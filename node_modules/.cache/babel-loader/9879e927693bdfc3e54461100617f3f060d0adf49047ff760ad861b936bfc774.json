{"ast":null,"code":"import { EngineInstrumentation } from \"../../Instrumentation/engineInstrumentation.js\";\nimport { PrecisionDate } from \"../precisionDate.js\";\nimport { SceneInstrumentation } from \"../../Instrumentation/sceneInstrumentation.js\";\nimport { PressureObserverWrapper } from \"../pressureObserverWrapper.js\";\n// Dispose which does nothing.\nconst defaultDisposeImpl = () => {};\n/**\n * Defines the predefined strategies used in the performance viewer.\n */\nexport class PerfCollectionStrategy {\n  /**\n   * Gets the initializer for the strategy used for collection of fps metrics\n   * @returns the initializer for the fps strategy\n   */\n  static FpsStrategy() {\n    return scene => {\n      const engine = scene.getEngine();\n      return {\n        id: \"FPS\",\n        getData: () => engine.getFps(),\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of thermal utilization metrics.\n   * Needs the experimental pressure API.\n   * @returns the initializer for the thermal utilization strategy\n   */\n  static ThermalStrategy() {\n    return this._PressureStrategy(\"Thermal utilization\", \"thermal\");\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of power supply utilization metrics.\n   * Needs the experimental pressure API.\n   * @returns the initializer for the power supply utilization strategy\n   */\n  static PowerSupplyStrategy() {\n    return this._PressureStrategy(\"Power supply utilization\", \"power-supply\");\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of pressure metrics.\n   * Needs the experimental pressure API.\n   * @returns the initializer for the pressure strategy\n   */\n  static PressureStrategy() {\n    return this._PressureStrategy(\"Pressure\");\n  }\n  static _PressureStrategy(name, factor = null) {\n    return () => {\n      let value = 0;\n      const wrapper = new PressureObserverWrapper();\n      wrapper.observe(\"cpu\");\n      wrapper.onPressureChanged.add(update => {\n        var _a, _b;\n        for (const record of update) {\n          if (factor && record.factors.includes(factor) || !factor && ((_b = (_a = record.factors) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) === 0) {\n            // Let s consider each step being 25% of the total pressure.\n            switch (record.state) {\n              case \"nominal\":\n                value = 0;\n                break;\n              case \"fair\":\n                value = 0.25;\n                break;\n              case \"serious\":\n                value = 0.5;\n                break;\n              case \"critical\":\n                value = 1;\n                break;\n            }\n          }\n        }\n      });\n      return {\n        id: name,\n        getData: () => value,\n        dispose: () => wrapper.dispose()\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of total meshes metrics.\n   * @returns the initializer for the total meshes strategy\n   */\n  static TotalMeshesStrategy() {\n    return scene => {\n      return {\n        id: \"Total meshes\",\n        getData: () => scene.meshes.length,\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of active meshes metrics.\n   * @returns the initializer for the active meshes strategy\n   */\n  static ActiveMeshesStrategy() {\n    return scene => {\n      return {\n        id: \"Active meshes\",\n        getData: () => scene.getActiveMeshes().length,\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of active indices metrics.\n   * @returns the initializer for the active indices strategy\n   */\n  static ActiveIndicesStrategy() {\n    return scene => {\n      return {\n        id: \"Active indices\",\n        getData: () => scene.getActiveIndices(),\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of active faces metrics.\n   * @returns the initializer for the active faces strategy\n   */\n  static ActiveFacesStrategy() {\n    return scene => {\n      return {\n        id: \"Active faces\",\n        getData: () => scene.getActiveIndices() / 3,\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of active bones metrics.\n   * @returns the initializer for the active bones strategy\n   */\n  static ActiveBonesStrategy() {\n    return scene => {\n      return {\n        id: \"Active bones\",\n        getData: () => scene.getActiveBones(),\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of active particles metrics.\n   * @returns the initializer for the active particles strategy\n   */\n  static ActiveParticlesStrategy() {\n    return scene => {\n      return {\n        id: \"Active particles\",\n        getData: () => scene.getActiveParticles(),\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of draw calls metrics.\n   * @returns the initializer for the draw calls strategy\n   */\n  static DrawCallsStrategy() {\n    return scene => {\n      let drawCalls = 0;\n      const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\n        scene.getEngine()._drawCalls.fetchNewFrame();\n      });\n      const onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {\n        drawCalls = scene.getEngine()._drawCalls.current;\n      });\n      return {\n        id: \"Draw calls\",\n        getData: () => drawCalls,\n        dispose: () => {\n          scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);\n          scene.onAfterRenderObservable.remove(onAfterRenderObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of total lights metrics.\n   * @returns the initializer for the total lights strategy\n   */\n  static TotalLightsStrategy() {\n    return scene => {\n      return {\n        id: \"Total lights\",\n        getData: () => scene.lights.length,\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of total vertices metrics.\n   * @returns the initializer for the total vertices strategy\n   */\n  static TotalVerticesStrategy() {\n    return scene => {\n      return {\n        id: \"Total vertices\",\n        getData: () => scene.getTotalVertices(),\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of total materials metrics.\n   * @returns the initializer for the total materials strategy\n   */\n  static TotalMaterialsStrategy() {\n    return scene => {\n      return {\n        id: \"Total materials\",\n        getData: () => scene.materials.length,\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of total textures metrics.\n   * @returns the initializer for the total textures strategy\n   */\n  static TotalTexturesStrategy() {\n    return scene => {\n      return {\n        id: \"Total textures\",\n        getData: () => scene.textures.length,\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of absolute fps metrics.\n   * @returns the initializer for the absolute fps strategy\n   */\n  static AbsoluteFpsStrategy() {\n    return scene => {\n      const sceneInstrumentation = new SceneInstrumentation(scene);\n      sceneInstrumentation.captureFrameTime = true;\n      return {\n        id: \"Absolute FPS\",\n        getData: () => {\n          return 1000.0 / sceneInstrumentation.frameTimeCounter.lastSecAverage;\n        },\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of meshes selection time metrics.\n   * @returns the initializer for the meshes selection time strategy\n   */\n  static MeshesSelectionStrategy() {\n    return scene => {\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforeActiveMeshesObserver = scene.onBeforeActiveMeshesEvaluationObservable.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      const onAfterActiveMeshesObserver = scene.onAfterActiveMeshesEvaluationObservable.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      return {\n        id: \"Meshes Selection\",\n        getData: () => timeTaken,\n        dispose: () => {\n          scene.onBeforeActiveMeshesEvaluationObservable.remove(onBeforeActiveMeshesObserver);\n          scene.onAfterActiveMeshesEvaluationObservable.remove(onAfterActiveMeshesObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of render targets time metrics.\n   * @returns the initializer for the render targets time strategy\n   */\n  static RenderTargetsStrategy() {\n    return scene => {\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforeRenderTargetsObserver = scene.onBeforeRenderTargetsRenderObservable.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      const onAfterRenderTargetsObserver = scene.onAfterRenderTargetsRenderObservable.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      return {\n        id: \"Render Targets\",\n        getData: () => timeTaken,\n        dispose: () => {\n          scene.onBeforeRenderTargetsRenderObservable.remove(onBeforeRenderTargetsObserver);\n          scene.onAfterRenderTargetsRenderObservable.remove(onAfterRenderTargetsObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of particles time metrics.\n   * @returns the initializer for the particles time strategy\n   */\n  static ParticlesStrategy() {\n    return scene => {\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforeParticlesObserver = scene.onBeforeParticlesRenderingObservable.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      const onAfterParticlesObserver = scene.onAfterParticlesRenderingObservable.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      return {\n        id: \"Particles\",\n        getData: () => timeTaken,\n        dispose: () => {\n          scene.onBeforeParticlesRenderingObservable.remove(onBeforeParticlesObserver);\n          scene.onAfterParticlesRenderingObservable.remove(onAfterParticlesObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of sprites time metrics.\n   * @returns the initializer for the sprites time strategy\n   */\n  static SpritesStrategy() {\n    return scene => {\n      var _a, _b;\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforeSpritesObserver = (_a = scene.onBeforeSpritesRenderingObservable) === null || _a === void 0 ? void 0 : _a.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      const onAfterSpritesObserver = (_b = scene.onAfterSpritesRenderingObservable) === null || _b === void 0 ? void 0 : _b.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      return {\n        id: \"Sprites\",\n        getData: () => timeTaken,\n        dispose: () => {\n          var _a, _b;\n          (_a = scene.onBeforeSpritesRenderingObservable) === null || _a === void 0 ? void 0 : _a.remove(onBeforeSpritesObserver);\n          (_b = scene.onAfterSpritesRenderingObservable) === null || _b === void 0 ? void 0 : _b.remove(onAfterSpritesObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of animations time metrics.\n   * @returns the initializer for the animations time strategy\n   */\n  static AnimationsStrategy() {\n    return scene => {\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      const onAfterAnimationsObserver = scene.onAfterAnimationsObservable.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      return {\n        id: \"Animations\",\n        getData: () => timeTaken,\n        dispose: () => {\n          scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);\n          scene.onAfterAnimationsObservable.remove(onAfterAnimationsObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of physics time metrics.\n   * @returns the initializer for the physics time strategy\n   */\n  static PhysicsStrategy() {\n    return scene => {\n      var _a, _b;\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforePhysicsObserver = (_a = scene.onBeforePhysicsObservable) === null || _a === void 0 ? void 0 : _a.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      const onAfterPhysicsObserver = (_b = scene.onAfterPhysicsObservable) === null || _b === void 0 ? void 0 : _b.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      return {\n        id: \"Physics\",\n        getData: () => timeTaken,\n        dispose: () => {\n          var _a, _b;\n          (_a = scene.onBeforePhysicsObservable) === null || _a === void 0 ? void 0 : _a.remove(onBeforePhysicsObserver);\n          (_b = scene.onAfterPhysicsObservable) === null || _b === void 0 ? void 0 : _b.remove(onAfterPhysicsObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of render time metrics.\n   * @returns the initializer for the render time strategy\n   */\n  static RenderStrategy() {\n    return scene => {\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforeDrawPhaseObserver = scene.onBeforeDrawPhaseObservable.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      const onAfterDrawPhaseObserver = scene.onAfterDrawPhaseObservable.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      return {\n        id: \"Render\",\n        getData: () => timeTaken,\n        dispose: () => {\n          scene.onBeforeDrawPhaseObservable.remove(onBeforeDrawPhaseObserver);\n          scene.onAfterDrawPhaseObservable.remove(onAfterDrawPhaseObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of total frame time metrics.\n   * @returns the initializer for the total frame time strategy\n   */\n  static FrameTotalStrategy() {\n    return scene => {\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      const onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      return {\n        id: \"Frame Total\",\n        getData: () => timeTaken,\n        dispose: () => {\n          scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);\n          scene.onAfterRenderObservable.remove(onAfterRenderObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of inter-frame time metrics.\n   * @returns the initializer for the inter-frame time strategy\n   */\n  static InterFrameStrategy() {\n    return scene => {\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      const onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      return {\n        id: \"Inter-frame\",\n        getData: () => timeTaken,\n        dispose: () => {\n          scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);\n          scene.onAfterRenderObservable.remove(onAfterRenderObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of gpu frame time metrics.\n   * @returns the initializer for the gpu frame time strategy\n   */\n  static GpuFrameTimeStrategy() {\n    return scene => {\n      const engineInstrumentation = new EngineInstrumentation(scene.getEngine());\n      engineInstrumentation.captureGPUFrameTime = true;\n      return {\n        id: \"GPU frame time\",\n        getData: () => Math.max(engineInstrumentation.gpuFrameTimeCounter.current * 0.000001, 0),\n        dispose: () => {\n          engineInstrumentation.dispose();\n        }\n      };\n    };\n  }\n}","map":{"version":3,"names":["EngineInstrumentation","PrecisionDate","SceneInstrumentation","PressureObserverWrapper","defaultDisposeImpl","PerfCollectionStrategy","FpsStrategy","scene","engine","getEngine","id","getData","getFps","dispose","ThermalStrategy","_PressureStrategy","PowerSupplyStrategy","PressureStrategy","name","factor","value","wrapper","observe","onPressureChanged","add","update","record","factors","includes","_b","_a","length","state","TotalMeshesStrategy","meshes","ActiveMeshesStrategy","getActiveMeshes","ActiveIndicesStrategy","getActiveIndices","ActiveFacesStrategy","ActiveBonesStrategy","getActiveBones","ActiveParticlesStrategy","getActiveParticles","DrawCallsStrategy","drawCalls","onBeforeAnimationsObserver","onBeforeAnimationsObservable","_drawCalls","fetchNewFrame","onAfterRenderObserver","onAfterRenderObservable","current","remove","TotalLightsStrategy","lights","TotalVerticesStrategy","getTotalVertices","TotalMaterialsStrategy","materials","TotalTexturesStrategy","textures","AbsoluteFpsStrategy","sceneInstrumentation","captureFrameTime","frameTimeCounter","lastSecAverage","MeshesSelectionStrategy","startTime","Now","timeTaken","onBeforeActiveMeshesObserver","onBeforeActiveMeshesEvaluationObservable","onAfterActiveMeshesObserver","onAfterActiveMeshesEvaluationObservable","RenderTargetsStrategy","onBeforeRenderTargetsObserver","onBeforeRenderTargetsRenderObservable","onAfterRenderTargetsObserver","onAfterRenderTargetsRenderObservable","ParticlesStrategy","onBeforeParticlesObserver","onBeforeParticlesRenderingObservable","onAfterParticlesObserver","onAfterParticlesRenderingObservable","SpritesStrategy","onBeforeSpritesObserver","onBeforeSpritesRenderingObservable","onAfterSpritesObserver","onAfterSpritesRenderingObservable","AnimationsStrategy","onAfterAnimationsObserver","onAfterAnimationsObservable","PhysicsStrategy","onBeforePhysicsObserver","onBeforePhysicsObservable","onAfterPhysicsObserver","onAfterPhysicsObservable","RenderStrategy","onBeforeDrawPhaseObserver","onBeforeDrawPhaseObservable","onAfterDrawPhaseObserver","onAfterDrawPhaseObservable","FrameTotalStrategy","InterFrameStrategy","GpuFrameTimeStrategy","engineInstrumentation","captureGPUFrameTime","Math","max","gpuFrameTimeCounter"],"sources":["../../../../../dev/core/src/Misc/PerformanceViewer/performanceViewerCollectionStrategies.ts"],"sourcesContent":["import { EngineInstrumentation } from \"../../Instrumentation/engineInstrumentation\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { PrecisionDate } from \"../precisionDate\";\r\nimport { SceneInstrumentation } from \"../../Instrumentation/sceneInstrumentation\";\r\nimport { PressureObserverWrapper } from \"../pressureObserverWrapper\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Defines the general structure of what is necessary for a collection strategy.\r\n */\r\nexport interface IPerfViewerCollectionStrategy {\r\n    /**\r\n     * The id of the strategy.\r\n     */\r\n    id: string;\r\n    /**\r\n     * Function which gets the data for the strategy.\r\n     */\r\n    getData: () => number;\r\n    /**\r\n     * Function which does any necessary cleanup. Called when performanceViewerCollector.dispose() is called.\r\n     */\r\n    dispose: () => void;\r\n}\r\n// Dispose which does nothing.\r\nconst defaultDisposeImpl = () => {};\r\n\r\n/**\r\n * Initializer callback for a strategy\r\n */\r\nexport type PerfStrategyInitialization = (scene: Scene) => IPerfViewerCollectionStrategy;\r\n/**\r\n * Defines the predefined strategies used in the performance viewer.\r\n */\r\nexport class PerfCollectionStrategy {\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of fps metrics\r\n     * @returns the initializer for the fps strategy\r\n     */\r\n    public static FpsStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            const engine = scene.getEngine();\r\n            return {\r\n                id: \"FPS\",\r\n                getData: () => engine.getFps(),\r\n                dispose: defaultDisposeImpl,\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of thermal utilization metrics.\r\n     * Needs the experimental pressure API.\r\n     * @returns the initializer for the thermal utilization strategy\r\n     */\r\n    public static ThermalStrategy(): PerfStrategyInitialization {\r\n        return this._PressureStrategy(\"Thermal utilization\", \"thermal\");\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of power supply utilization metrics.\r\n     * Needs the experimental pressure API.\r\n     * @returns the initializer for the power supply utilization strategy\r\n     */\r\n    public static PowerSupplyStrategy(): PerfStrategyInitialization {\r\n        return this._PressureStrategy(\"Power supply utilization\", \"power-supply\");\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of pressure metrics.\r\n     * Needs the experimental pressure API.\r\n     * @returns the initializer for the pressure strategy\r\n     */\r\n    public static PressureStrategy(): PerfStrategyInitialization {\r\n        return this._PressureStrategy(\"Pressure\");\r\n    }\r\n\r\n    private static _PressureStrategy(name: string, factor: Nullable<PressureFactor> = null): PerfStrategyInitialization {\r\n        return () => {\r\n            let value = 0;\r\n\r\n            const wrapper = new PressureObserverWrapper();\r\n            wrapper.observe(\"cpu\");\r\n\r\n            wrapper.onPressureChanged.add((update) => {\r\n                for (const record of update) {\r\n                    if ((factor && record.factors.includes(factor)) || (!factor && (record.factors?.length ?? 0) === 0)) {\r\n                        // Let s consider each step being 25% of the total pressure.\r\n                        switch (record.state) {\r\n                            case \"nominal\":\r\n                                value = 0;\r\n                                break;\r\n                            case \"fair\":\r\n                                value = 0.25;\r\n                                break;\r\n                            case \"serious\":\r\n                                value = 0.5;\r\n                                break;\r\n                            case \"critical\":\r\n                                value = 1;\r\n                                break;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n            return {\r\n                id: name,\r\n                getData: () => value,\r\n                dispose: () => wrapper.dispose(),\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of total meshes metrics.\r\n     * @returns the initializer for the total meshes strategy\r\n     */\r\n    public static TotalMeshesStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            return {\r\n                id: \"Total meshes\",\r\n                getData: () => scene.meshes.length,\r\n                dispose: defaultDisposeImpl,\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of active meshes metrics.\r\n     * @returns the initializer for the active meshes strategy\r\n     */\r\n    public static ActiveMeshesStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            return {\r\n                id: \"Active meshes\",\r\n                getData: () => scene.getActiveMeshes().length,\r\n                dispose: defaultDisposeImpl,\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of active indices metrics.\r\n     * @returns the initializer for the active indices strategy\r\n     */\r\n    public static ActiveIndicesStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            return {\r\n                id: \"Active indices\",\r\n                getData: () => scene.getActiveIndices(),\r\n                dispose: defaultDisposeImpl,\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of active faces metrics.\r\n     * @returns the initializer for the active faces strategy\r\n     */\r\n    public static ActiveFacesStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            return {\r\n                id: \"Active faces\",\r\n                getData: () => scene.getActiveIndices() / 3,\r\n                dispose: defaultDisposeImpl,\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of active bones metrics.\r\n     * @returns the initializer for the active bones strategy\r\n     */\r\n    public static ActiveBonesStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            return {\r\n                id: \"Active bones\",\r\n                getData: () => scene.getActiveBones(),\r\n                dispose: defaultDisposeImpl,\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of active particles metrics.\r\n     * @returns the initializer for the active particles strategy\r\n     */\r\n    public static ActiveParticlesStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            return {\r\n                id: \"Active particles\",\r\n                getData: () => scene.getActiveParticles(),\r\n                dispose: defaultDisposeImpl,\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of draw calls metrics.\r\n     * @returns the initializer for the draw calls strategy\r\n     */\r\n    public static DrawCallsStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            let drawCalls = 0;\r\n            const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\r\n                scene.getEngine()._drawCalls.fetchNewFrame();\r\n            });\r\n\r\n            const onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {\r\n                drawCalls = scene.getEngine()._drawCalls.current;\r\n            });\r\n\r\n            return {\r\n                id: \"Draw calls\",\r\n                getData: () => drawCalls,\r\n                dispose: () => {\r\n                    scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);\r\n                    scene.onAfterRenderObservable.remove(onAfterRenderObserver);\r\n                },\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of total lights metrics.\r\n     * @returns the initializer for the total lights strategy\r\n     */\r\n    public static TotalLightsStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            return {\r\n                id: \"Total lights\",\r\n                getData: () => scene.lights.length,\r\n                dispose: defaultDisposeImpl,\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of total vertices metrics.\r\n     * @returns the initializer for the total vertices strategy\r\n     */\r\n    public static TotalVerticesStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            return {\r\n                id: \"Total vertices\",\r\n                getData: () => scene.getTotalVertices(),\r\n                dispose: defaultDisposeImpl,\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of total materials metrics.\r\n     * @returns the initializer for the total materials strategy\r\n     */\r\n    public static TotalMaterialsStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            return {\r\n                id: \"Total materials\",\r\n                getData: () => scene.materials.length,\r\n                dispose: defaultDisposeImpl,\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of total textures metrics.\r\n     * @returns the initializer for the total textures strategy\r\n     */\r\n    public static TotalTexturesStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            return {\r\n                id: \"Total textures\",\r\n                getData: () => scene.textures.length,\r\n                dispose: defaultDisposeImpl,\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of absolute fps metrics.\r\n     * @returns the initializer for the absolute fps strategy\r\n     */\r\n    public static AbsoluteFpsStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            const sceneInstrumentation = new SceneInstrumentation(scene);\r\n            sceneInstrumentation.captureFrameTime = true;\r\n\r\n            return {\r\n                id: \"Absolute FPS\",\r\n                getData: () => {\r\n                    return 1000.0 / sceneInstrumentation.frameTimeCounter.lastSecAverage;\r\n                },\r\n                dispose: defaultDisposeImpl,\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of meshes selection time metrics.\r\n     * @returns the initializer for the meshes selection time strategy\r\n     */\r\n    public static MeshesSelectionStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            let startTime = PrecisionDate.Now;\r\n            let timeTaken = 0;\r\n            const onBeforeActiveMeshesObserver = scene.onBeforeActiveMeshesEvaluationObservable.add(() => {\r\n                startTime = PrecisionDate.Now;\r\n            });\r\n\r\n            const onAfterActiveMeshesObserver = scene.onAfterActiveMeshesEvaluationObservable.add(() => {\r\n                timeTaken = PrecisionDate.Now - startTime;\r\n            });\r\n\r\n            return {\r\n                id: \"Meshes Selection\",\r\n                getData: () => timeTaken,\r\n                dispose: () => {\r\n                    scene.onBeforeActiveMeshesEvaluationObservable.remove(onBeforeActiveMeshesObserver);\r\n                    scene.onAfterActiveMeshesEvaluationObservable.remove(onAfterActiveMeshesObserver);\r\n                },\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of render targets time metrics.\r\n     * @returns the initializer for the render targets time strategy\r\n     */\r\n    public static RenderTargetsStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            let startTime = PrecisionDate.Now;\r\n            let timeTaken = 0;\r\n            const onBeforeRenderTargetsObserver = scene.onBeforeRenderTargetsRenderObservable.add(() => {\r\n                startTime = PrecisionDate.Now;\r\n            });\r\n\r\n            const onAfterRenderTargetsObserver = scene.onAfterRenderTargetsRenderObservable.add(() => {\r\n                timeTaken = PrecisionDate.Now - startTime;\r\n            });\r\n\r\n            return {\r\n                id: \"Render Targets\",\r\n                getData: () => timeTaken,\r\n                dispose: () => {\r\n                    scene.onBeforeRenderTargetsRenderObservable.remove(onBeforeRenderTargetsObserver);\r\n                    scene.onAfterRenderTargetsRenderObservable.remove(onAfterRenderTargetsObserver);\r\n                },\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of particles time metrics.\r\n     * @returns the initializer for the particles time strategy\r\n     */\r\n    public static ParticlesStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            let startTime = PrecisionDate.Now;\r\n            let timeTaken = 0;\r\n            const onBeforeParticlesObserver = scene.onBeforeParticlesRenderingObservable.add(() => {\r\n                startTime = PrecisionDate.Now;\r\n            });\r\n\r\n            const onAfterParticlesObserver = scene.onAfterParticlesRenderingObservable.add(() => {\r\n                timeTaken = PrecisionDate.Now - startTime;\r\n            });\r\n\r\n            return {\r\n                id: \"Particles\",\r\n                getData: () => timeTaken,\r\n                dispose: () => {\r\n                    scene.onBeforeParticlesRenderingObservable.remove(onBeforeParticlesObserver);\r\n                    scene.onAfterParticlesRenderingObservable.remove(onAfterParticlesObserver);\r\n                },\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of sprites time metrics.\r\n     * @returns the initializer for the sprites time strategy\r\n     */\r\n    public static SpritesStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            let startTime = PrecisionDate.Now;\r\n            let timeTaken = 0;\r\n            const onBeforeSpritesObserver = scene.onBeforeSpritesRenderingObservable?.add(() => {\r\n                startTime = PrecisionDate.Now;\r\n            });\r\n\r\n            const onAfterSpritesObserver = scene.onAfterSpritesRenderingObservable?.add(() => {\r\n                timeTaken = PrecisionDate.Now - startTime;\r\n            });\r\n\r\n            return {\r\n                id: \"Sprites\",\r\n                getData: () => timeTaken,\r\n                dispose: () => {\r\n                    scene.onBeforeSpritesRenderingObservable?.remove(onBeforeSpritesObserver);\r\n                    scene.onAfterSpritesRenderingObservable?.remove(onAfterSpritesObserver);\r\n                },\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of animations time metrics.\r\n     * @returns the initializer for the animations time strategy\r\n     */\r\n    public static AnimationsStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            let startTime = PrecisionDate.Now;\r\n            let timeTaken = 0;\r\n            const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\r\n                startTime = PrecisionDate.Now;\r\n            });\r\n\r\n            const onAfterAnimationsObserver = scene.onAfterAnimationsObservable.add(() => {\r\n                timeTaken = PrecisionDate.Now - startTime;\r\n            });\r\n\r\n            return {\r\n                id: \"Animations\",\r\n                getData: () => timeTaken,\r\n                dispose: () => {\r\n                    scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);\r\n                    scene.onAfterAnimationsObservable.remove(onAfterAnimationsObserver);\r\n                },\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of physics time metrics.\r\n     * @returns the initializer for the physics time strategy\r\n     */\r\n    public static PhysicsStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            let startTime = PrecisionDate.Now;\r\n            let timeTaken = 0;\r\n            const onBeforePhysicsObserver = scene.onBeforePhysicsObservable?.add(() => {\r\n                startTime = PrecisionDate.Now;\r\n            });\r\n\r\n            const onAfterPhysicsObserver = scene.onAfterPhysicsObservable?.add(() => {\r\n                timeTaken = PrecisionDate.Now - startTime;\r\n            });\r\n\r\n            return {\r\n                id: \"Physics\",\r\n                getData: () => timeTaken,\r\n                dispose: () => {\r\n                    scene.onBeforePhysicsObservable?.remove(onBeforePhysicsObserver);\r\n                    scene.onAfterPhysicsObservable?.remove(onAfterPhysicsObserver);\r\n                },\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of render time metrics.\r\n     * @returns the initializer for the render time strategy\r\n     */\r\n    public static RenderStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            let startTime = PrecisionDate.Now;\r\n            let timeTaken = 0;\r\n            const onBeforeDrawPhaseObserver = scene.onBeforeDrawPhaseObservable.add(() => {\r\n                startTime = PrecisionDate.Now;\r\n            });\r\n\r\n            const onAfterDrawPhaseObserver = scene.onAfterDrawPhaseObservable.add(() => {\r\n                timeTaken = PrecisionDate.Now - startTime;\r\n            });\r\n\r\n            return {\r\n                id: \"Render\",\r\n                getData: () => timeTaken,\r\n                dispose: () => {\r\n                    scene.onBeforeDrawPhaseObservable.remove(onBeforeDrawPhaseObserver);\r\n                    scene.onAfterDrawPhaseObservable.remove(onAfterDrawPhaseObserver);\r\n                },\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of total frame time metrics.\r\n     * @returns the initializer for the total frame time strategy\r\n     */\r\n    public static FrameTotalStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            let startTime = PrecisionDate.Now;\r\n            let timeTaken = 0;\r\n            const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\r\n                startTime = PrecisionDate.Now;\r\n            });\r\n\r\n            const onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {\r\n                timeTaken = PrecisionDate.Now - startTime;\r\n            });\r\n\r\n            return {\r\n                id: \"Frame Total\",\r\n                getData: () => timeTaken,\r\n                dispose: () => {\r\n                    scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);\r\n                    scene.onAfterRenderObservable.remove(onAfterRenderObserver);\r\n                },\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of inter-frame time metrics.\r\n     * @returns the initializer for the inter-frame time strategy\r\n     */\r\n    public static InterFrameStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            let startTime = PrecisionDate.Now;\r\n            let timeTaken = 0;\r\n\r\n            const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\r\n                timeTaken = PrecisionDate.Now - startTime;\r\n            });\r\n\r\n            const onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {\r\n                startTime = PrecisionDate.Now;\r\n            });\r\n\r\n            return {\r\n                id: \"Inter-frame\",\r\n                getData: () => timeTaken,\r\n                dispose: () => {\r\n                    scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);\r\n                    scene.onAfterRenderObservable.remove(onAfterRenderObserver);\r\n                },\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of gpu frame time metrics.\r\n     * @returns the initializer for the gpu frame time strategy\r\n     */\r\n    public static GpuFrameTimeStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            const engineInstrumentation = new EngineInstrumentation(scene.getEngine());\r\n            engineInstrumentation.captureGPUFrameTime = true;\r\n            return {\r\n                id: \"GPU frame time\",\r\n                getData: () => Math.max(engineInstrumentation.gpuFrameTimeCounter.current * 0.000001, 0),\r\n                dispose: () => {\r\n                    engineInstrumentation.dispose();\r\n                },\r\n            };\r\n        };\r\n    }\r\n}\r\n"],"mappings":"AAAA,SAASA,qBAAqB,QAAQ,gDAA8C;AAEpF,SAASC,aAAa,QAAQ,qBAAmB;AACjD,SAASC,oBAAoB,QAAQ,+CAA6C;AAClF,SAASC,uBAAuB,QAAQ,+BAA6B;AAoBrE;AACA,MAAMC,kBAAkB,GAAGA,CAAA,KAAK,CAAE,CAAC;AAMnC;;;AAGA,OAAM,MAAOC,sBAAsB;EAC/B;;;;EAIO,OAAOC,WAAWA,CAAA;IACrB,OAAQC,KAAK,IAAI;MACb,MAAMC,MAAM,GAAGD,KAAK,CAACE,SAAS,EAAE;MAChC,OAAO;QACHC,EAAE,EAAE,KAAK;QACTC,OAAO,EAAEA,CAAA,KAAMH,MAAM,CAACI,MAAM,EAAE;QAC9BC,OAAO,EAAET;OACZ;IACL,CAAC;EACL;EAEA;;;;;EAKO,OAAOU,eAAeA,CAAA;IACzB,OAAO,IAAI,CAACC,iBAAiB,CAAC,qBAAqB,EAAE,SAAS,CAAC;EACnE;EAEA;;;;;EAKO,OAAOC,mBAAmBA,CAAA;IAC7B,OAAO,IAAI,CAACD,iBAAiB,CAAC,0BAA0B,EAAE,cAAc,CAAC;EAC7E;EAEA;;;;;EAKO,OAAOE,gBAAgBA,CAAA;IAC1B,OAAO,IAAI,CAACF,iBAAiB,CAAC,UAAU,CAAC;EAC7C;EAEQ,OAAOA,iBAAiBA,CAACG,IAAY,EAAEC,MAAA,GAAmC,IAAI;IAClF,OAAO,MAAK;MACR,IAAIC,KAAK,GAAG,CAAC;MAEb,MAAMC,OAAO,GAAG,IAAIlB,uBAAuB,EAAE;MAC7CkB,OAAO,CAACC,OAAO,CAAC,KAAK,CAAC;MAEtBD,OAAO,CAACE,iBAAiB,CAACC,GAAG,CAAEC,MAAM,IAAI;;QACrC,KAAK,MAAMC,MAAM,IAAID,MAAM,EAAE;UACzB,IAAKN,MAAM,IAAIO,MAAM,CAACC,OAAO,CAACC,QAAQ,CAACT,MAAM,CAAC,IAAM,CAACA,MAAM,IAAI,CAAC,CAAAU,EAAA,IAAAC,EAAA,GAAAJ,MAAM,CAACC,OAAO,cAAAG,EAAA,uBAAAA,EAAA,CAAEC,MAAM,cAAAF,EAAA,cAAAA,EAAA,GAAI,CAAC,MAAM,CAAE,EAAE;YACjG;YACA,QAAQH,MAAM,CAACM,KAAK;cAChB,KAAK,SAAS;gBACVZ,KAAK,GAAG,CAAC;gBACT;cACJ,KAAK,MAAM;gBACPA,KAAK,GAAG,IAAI;gBACZ;cACJ,KAAK,SAAS;gBACVA,KAAK,GAAG,GAAG;gBACX;cACJ,KAAK,UAAU;gBACXA,KAAK,GAAG,CAAC;gBACT;;;;MAIpB,CAAC,CAAC;MACF,OAAO;QACHV,EAAE,EAAEQ,IAAI;QACRP,OAAO,EAAEA,CAAA,KAAMS,KAAK;QACpBP,OAAO,EAAEA,CAAA,KAAMQ,OAAO,CAACR,OAAO;OACjC;IACL,CAAC;EACL;EAEA;;;;EAIO,OAAOoB,mBAAmBA,CAAA;IAC7B,OAAQ1B,KAAK,IAAI;MACb,OAAO;QACHG,EAAE,EAAE,cAAc;QAClBC,OAAO,EAAEA,CAAA,KAAMJ,KAAK,CAAC2B,MAAM,CAACH,MAAM;QAClClB,OAAO,EAAET;OACZ;IACL,CAAC;EACL;EAEA;;;;EAIO,OAAO+B,oBAAoBA,CAAA;IAC9B,OAAQ5B,KAAK,IAAI;MACb,OAAO;QACHG,EAAE,EAAE,eAAe;QACnBC,OAAO,EAAEA,CAAA,KAAMJ,KAAK,CAAC6B,eAAe,EAAE,CAACL,MAAM;QAC7ClB,OAAO,EAAET;OACZ;IACL,CAAC;EACL;EAEA;;;;EAIO,OAAOiC,qBAAqBA,CAAA;IAC/B,OAAQ9B,KAAK,IAAI;MACb,OAAO;QACHG,EAAE,EAAE,gBAAgB;QACpBC,OAAO,EAAEA,CAAA,KAAMJ,KAAK,CAAC+B,gBAAgB,EAAE;QACvCzB,OAAO,EAAET;OACZ;IACL,CAAC;EACL;EAEA;;;;EAIO,OAAOmC,mBAAmBA,CAAA;IAC7B,OAAQhC,KAAK,IAAI;MACb,OAAO;QACHG,EAAE,EAAE,cAAc;QAClBC,OAAO,EAAEA,CAAA,KAAMJ,KAAK,CAAC+B,gBAAgB,EAAE,GAAG,CAAC;QAC3CzB,OAAO,EAAET;OACZ;IACL,CAAC;EACL;EAEA;;;;EAIO,OAAOoC,mBAAmBA,CAAA;IAC7B,OAAQjC,KAAK,IAAI;MACb,OAAO;QACHG,EAAE,EAAE,cAAc;QAClBC,OAAO,EAAEA,CAAA,KAAMJ,KAAK,CAACkC,cAAc,EAAE;QACrC5B,OAAO,EAAET;OACZ;IACL,CAAC;EACL;EAEA;;;;EAIO,OAAOsC,uBAAuBA,CAAA;IACjC,OAAQnC,KAAK,IAAI;MACb,OAAO;QACHG,EAAE,EAAE,kBAAkB;QACtBC,OAAO,EAAEA,CAAA,KAAMJ,KAAK,CAACoC,kBAAkB,EAAE;QACzC9B,OAAO,EAAET;OACZ;IACL,CAAC;EACL;EAEA;;;;EAIO,OAAOwC,iBAAiBA,CAAA;IAC3B,OAAQrC,KAAK,IAAI;MACb,IAAIsC,SAAS,GAAG,CAAC;MACjB,MAAMC,0BAA0B,GAAGvC,KAAK,CAACwC,4BAA4B,CAACvB,GAAG,CAAC,MAAK;QAC3EjB,KAAK,CAACE,SAAS,EAAE,CAACuC,UAAU,CAACC,aAAa,EAAE;MAChD,CAAC,CAAC;MAEF,MAAMC,qBAAqB,GAAG3C,KAAK,CAAC4C,uBAAuB,CAAC3B,GAAG,CAAC,MAAK;QACjEqB,SAAS,GAAGtC,KAAK,CAACE,SAAS,EAAE,CAACuC,UAAU,CAACI,OAAO;MACpD,CAAC,CAAC;MAEF,OAAO;QACH1C,EAAE,EAAE,YAAY;QAChBC,OAAO,EAAEA,CAAA,KAAMkC,SAAS;QACxBhC,OAAO,EAAEA,CAAA,KAAK;UACVN,KAAK,CAACwC,4BAA4B,CAACM,MAAM,CAACP,0BAA0B,CAAC;UACrEvC,KAAK,CAAC4C,uBAAuB,CAACE,MAAM,CAACH,qBAAqB,CAAC;QAC/D;OACH;IACL,CAAC;EACL;EAEA;;;;EAIO,OAAOI,mBAAmBA,CAAA;IAC7B,OAAQ/C,KAAK,IAAI;MACb,OAAO;QACHG,EAAE,EAAE,cAAc;QAClBC,OAAO,EAAEA,CAAA,KAAMJ,KAAK,CAACgD,MAAM,CAACxB,MAAM;QAClClB,OAAO,EAAET;OACZ;IACL,CAAC;EACL;EAEA;;;;EAIO,OAAOoD,qBAAqBA,CAAA;IAC/B,OAAQjD,KAAK,IAAI;MACb,OAAO;QACHG,EAAE,EAAE,gBAAgB;QACpBC,OAAO,EAAEA,CAAA,KAAMJ,KAAK,CAACkD,gBAAgB,EAAE;QACvC5C,OAAO,EAAET;OACZ;IACL,CAAC;EACL;EAEA;;;;EAIO,OAAOsD,sBAAsBA,CAAA;IAChC,OAAQnD,KAAK,IAAI;MACb,OAAO;QACHG,EAAE,EAAE,iBAAiB;QACrBC,OAAO,EAAEA,CAAA,KAAMJ,KAAK,CAACoD,SAAS,CAAC5B,MAAM;QACrClB,OAAO,EAAET;OACZ;IACL,CAAC;EACL;EAEA;;;;EAIO,OAAOwD,qBAAqBA,CAAA;IAC/B,OAAQrD,KAAK,IAAI;MACb,OAAO;QACHG,EAAE,EAAE,gBAAgB;QACpBC,OAAO,EAAEA,CAAA,KAAMJ,KAAK,CAACsD,QAAQ,CAAC9B,MAAM;QACpClB,OAAO,EAAET;OACZ;IACL,CAAC;EACL;EAEA;;;;EAIO,OAAO0D,mBAAmBA,CAAA;IAC7B,OAAQvD,KAAK,IAAI;MACb,MAAMwD,oBAAoB,GAAG,IAAI7D,oBAAoB,CAACK,KAAK,CAAC;MAC5DwD,oBAAoB,CAACC,gBAAgB,GAAG,IAAI;MAE5C,OAAO;QACHtD,EAAE,EAAE,cAAc;QAClBC,OAAO,EAAEA,CAAA,KAAK;UACV,OAAO,MAAM,GAAGoD,oBAAoB,CAACE,gBAAgB,CAACC,cAAc;QACxE,CAAC;QACDrD,OAAO,EAAET;OACZ;IACL,CAAC;EACL;EAEA;;;;EAIO,OAAO+D,uBAAuBA,CAAA;IACjC,OAAQ5D,KAAK,IAAI;MACb,IAAI6D,SAAS,GAAGnE,aAAa,CAACoE,GAAG;MACjC,IAAIC,SAAS,GAAG,CAAC;MACjB,MAAMC,4BAA4B,GAAGhE,KAAK,CAACiE,wCAAwC,CAAChD,GAAG,CAAC,MAAK;QACzF4C,SAAS,GAAGnE,aAAa,CAACoE,GAAG;MACjC,CAAC,CAAC;MAEF,MAAMI,2BAA2B,GAAGlE,KAAK,CAACmE,uCAAuC,CAAClD,GAAG,CAAC,MAAK;QACvF8C,SAAS,GAAGrE,aAAa,CAACoE,GAAG,GAAGD,SAAS;MAC7C,CAAC,CAAC;MAEF,OAAO;QACH1D,EAAE,EAAE,kBAAkB;QACtBC,OAAO,EAAEA,CAAA,KAAM2D,SAAS;QACxBzD,OAAO,EAAEA,CAAA,KAAK;UACVN,KAAK,CAACiE,wCAAwC,CAACnB,MAAM,CAACkB,4BAA4B,CAAC;UACnFhE,KAAK,CAACmE,uCAAuC,CAACrB,MAAM,CAACoB,2BAA2B,CAAC;QACrF;OACH;IACL,CAAC;EACL;EAEA;;;;EAIO,OAAOE,qBAAqBA,CAAA;IAC/B,OAAQpE,KAAK,IAAI;MACb,IAAI6D,SAAS,GAAGnE,aAAa,CAACoE,GAAG;MACjC,IAAIC,SAAS,GAAG,CAAC;MACjB,MAAMM,6BAA6B,GAAGrE,KAAK,CAACsE,qCAAqC,CAACrD,GAAG,CAAC,MAAK;QACvF4C,SAAS,GAAGnE,aAAa,CAACoE,GAAG;MACjC,CAAC,CAAC;MAEF,MAAMS,4BAA4B,GAAGvE,KAAK,CAACwE,oCAAoC,CAACvD,GAAG,CAAC,MAAK;QACrF8C,SAAS,GAAGrE,aAAa,CAACoE,GAAG,GAAGD,SAAS;MAC7C,CAAC,CAAC;MAEF,OAAO;QACH1D,EAAE,EAAE,gBAAgB;QACpBC,OAAO,EAAEA,CAAA,KAAM2D,SAAS;QACxBzD,OAAO,EAAEA,CAAA,KAAK;UACVN,KAAK,CAACsE,qCAAqC,CAACxB,MAAM,CAACuB,6BAA6B,CAAC;UACjFrE,KAAK,CAACwE,oCAAoC,CAAC1B,MAAM,CAACyB,4BAA4B,CAAC;QACnF;OACH;IACL,CAAC;EACL;EAEA;;;;EAIO,OAAOE,iBAAiBA,CAAA;IAC3B,OAAQzE,KAAK,IAAI;MACb,IAAI6D,SAAS,GAAGnE,aAAa,CAACoE,GAAG;MACjC,IAAIC,SAAS,GAAG,CAAC;MACjB,MAAMW,yBAAyB,GAAG1E,KAAK,CAAC2E,oCAAoC,CAAC1D,GAAG,CAAC,MAAK;QAClF4C,SAAS,GAAGnE,aAAa,CAACoE,GAAG;MACjC,CAAC,CAAC;MAEF,MAAMc,wBAAwB,GAAG5E,KAAK,CAAC6E,mCAAmC,CAAC5D,GAAG,CAAC,MAAK;QAChF8C,SAAS,GAAGrE,aAAa,CAACoE,GAAG,GAAGD,SAAS;MAC7C,CAAC,CAAC;MAEF,OAAO;QACH1D,EAAE,EAAE,WAAW;QACfC,OAAO,EAAEA,CAAA,KAAM2D,SAAS;QACxBzD,OAAO,EAAEA,CAAA,KAAK;UACVN,KAAK,CAAC2E,oCAAoC,CAAC7B,MAAM,CAAC4B,yBAAyB,CAAC;UAC5E1E,KAAK,CAAC6E,mCAAmC,CAAC/B,MAAM,CAAC8B,wBAAwB,CAAC;QAC9E;OACH;IACL,CAAC;EACL;EAEA;;;;EAIO,OAAOE,eAAeA,CAAA;IACzB,OAAQ9E,KAAK,IAAI;;MACb,IAAI6D,SAAS,GAAGnE,aAAa,CAACoE,GAAG;MACjC,IAAIC,SAAS,GAAG,CAAC;MACjB,MAAMgB,uBAAuB,GAAG,CAAAxD,EAAA,GAAAvB,KAAK,CAACgF,kCAAkC,cAAAzD,EAAA,uBAAAA,EAAA,CAAEN,GAAG,CAAC,MAAK;QAC/E4C,SAAS,GAAGnE,aAAa,CAACoE,GAAG;MACjC,CAAC,CAAC;MAEF,MAAMmB,sBAAsB,GAAG,CAAA3D,EAAA,GAAAtB,KAAK,CAACkF,iCAAiC,cAAA5D,EAAA,uBAAAA,EAAA,CAAEL,GAAG,CAAC,MAAK;QAC7E8C,SAAS,GAAGrE,aAAa,CAACoE,GAAG,GAAGD,SAAS;MAC7C,CAAC,CAAC;MAEF,OAAO;QACH1D,EAAE,EAAE,SAAS;QACbC,OAAO,EAAEA,CAAA,KAAM2D,SAAS;QACxBzD,OAAO,EAAEA,CAAA,KAAK;;UACV,CAAAiB,EAAA,GAAAvB,KAAK,CAACgF,kCAAkC,cAAAzD,EAAA,uBAAAA,EAAA,CAAEuB,MAAM,CAACiC,uBAAuB,CAAC;UACzE,CAAAzD,EAAA,GAAAtB,KAAK,CAACkF,iCAAiC,cAAA5D,EAAA,uBAAAA,EAAA,CAAEwB,MAAM,CAACmC,sBAAsB,CAAC;QAC3E;OACH;IACL,CAAC;EACL;EAEA;;;;EAIO,OAAOE,kBAAkBA,CAAA;IAC5B,OAAQnF,KAAK,IAAI;MACb,IAAI6D,SAAS,GAAGnE,aAAa,CAACoE,GAAG;MACjC,IAAIC,SAAS,GAAG,CAAC;MACjB,MAAMxB,0BAA0B,GAAGvC,KAAK,CAACwC,4BAA4B,CAACvB,GAAG,CAAC,MAAK;QAC3E4C,SAAS,GAAGnE,aAAa,CAACoE,GAAG;MACjC,CAAC,CAAC;MAEF,MAAMsB,yBAAyB,GAAGpF,KAAK,CAACqF,2BAA2B,CAACpE,GAAG,CAAC,MAAK;QACzE8C,SAAS,GAAGrE,aAAa,CAACoE,GAAG,GAAGD,SAAS;MAC7C,CAAC,CAAC;MAEF,OAAO;QACH1D,EAAE,EAAE,YAAY;QAChBC,OAAO,EAAEA,CAAA,KAAM2D,SAAS;QACxBzD,OAAO,EAAEA,CAAA,KAAK;UACVN,KAAK,CAACwC,4BAA4B,CAACM,MAAM,CAACP,0BAA0B,CAAC;UACrEvC,KAAK,CAACqF,2BAA2B,CAACvC,MAAM,CAACsC,yBAAyB,CAAC;QACvE;OACH;IACL,CAAC;EACL;EAEA;;;;EAIO,OAAOE,eAAeA,CAAA;IACzB,OAAQtF,KAAK,IAAI;;MACb,IAAI6D,SAAS,GAAGnE,aAAa,CAACoE,GAAG;MACjC,IAAIC,SAAS,GAAG,CAAC;MACjB,MAAMwB,uBAAuB,GAAG,CAAAhE,EAAA,GAAAvB,KAAK,CAACwF,yBAAyB,cAAAjE,EAAA,uBAAAA,EAAA,CAAEN,GAAG,CAAC,MAAK;QACtE4C,SAAS,GAAGnE,aAAa,CAACoE,GAAG;MACjC,CAAC,CAAC;MAEF,MAAM2B,sBAAsB,GAAG,CAAAnE,EAAA,GAAAtB,KAAK,CAAC0F,wBAAwB,cAAApE,EAAA,uBAAAA,EAAA,CAAEL,GAAG,CAAC,MAAK;QACpE8C,SAAS,GAAGrE,aAAa,CAACoE,GAAG,GAAGD,SAAS;MAC7C,CAAC,CAAC;MAEF,OAAO;QACH1D,EAAE,EAAE,SAAS;QACbC,OAAO,EAAEA,CAAA,KAAM2D,SAAS;QACxBzD,OAAO,EAAEA,CAAA,KAAK;;UACV,CAAAiB,EAAA,GAAAvB,KAAK,CAACwF,yBAAyB,cAAAjE,EAAA,uBAAAA,EAAA,CAAEuB,MAAM,CAACyC,uBAAuB,CAAC;UAChE,CAAAjE,EAAA,GAAAtB,KAAK,CAAC0F,wBAAwB,cAAApE,EAAA,uBAAAA,EAAA,CAAEwB,MAAM,CAAC2C,sBAAsB,CAAC;QAClE;OACH;IACL,CAAC;EACL;EAEA;;;;EAIO,OAAOE,cAAcA,CAAA;IACxB,OAAQ3F,KAAK,IAAI;MACb,IAAI6D,SAAS,GAAGnE,aAAa,CAACoE,GAAG;MACjC,IAAIC,SAAS,GAAG,CAAC;MACjB,MAAM6B,yBAAyB,GAAG5F,KAAK,CAAC6F,2BAA2B,CAAC5E,GAAG,CAAC,MAAK;QACzE4C,SAAS,GAAGnE,aAAa,CAACoE,GAAG;MACjC,CAAC,CAAC;MAEF,MAAMgC,wBAAwB,GAAG9F,KAAK,CAAC+F,0BAA0B,CAAC9E,GAAG,CAAC,MAAK;QACvE8C,SAAS,GAAGrE,aAAa,CAACoE,GAAG,GAAGD,SAAS;MAC7C,CAAC,CAAC;MAEF,OAAO;QACH1D,EAAE,EAAE,QAAQ;QACZC,OAAO,EAAEA,CAAA,KAAM2D,SAAS;QACxBzD,OAAO,EAAEA,CAAA,KAAK;UACVN,KAAK,CAAC6F,2BAA2B,CAAC/C,MAAM,CAAC8C,yBAAyB,CAAC;UACnE5F,KAAK,CAAC+F,0BAA0B,CAACjD,MAAM,CAACgD,wBAAwB,CAAC;QACrE;OACH;IACL,CAAC;EACL;EAEA;;;;EAIO,OAAOE,kBAAkBA,CAAA;IAC5B,OAAQhG,KAAK,IAAI;MACb,IAAI6D,SAAS,GAAGnE,aAAa,CAACoE,GAAG;MACjC,IAAIC,SAAS,GAAG,CAAC;MACjB,MAAMxB,0BAA0B,GAAGvC,KAAK,CAACwC,4BAA4B,CAACvB,GAAG,CAAC,MAAK;QAC3E4C,SAAS,GAAGnE,aAAa,CAACoE,GAAG;MACjC,CAAC,CAAC;MAEF,MAAMnB,qBAAqB,GAAG3C,KAAK,CAAC4C,uBAAuB,CAAC3B,GAAG,CAAC,MAAK;QACjE8C,SAAS,GAAGrE,aAAa,CAACoE,GAAG,GAAGD,SAAS;MAC7C,CAAC,CAAC;MAEF,OAAO;QACH1D,EAAE,EAAE,aAAa;QACjBC,OAAO,EAAEA,CAAA,KAAM2D,SAAS;QACxBzD,OAAO,EAAEA,CAAA,KAAK;UACVN,KAAK,CAACwC,4BAA4B,CAACM,MAAM,CAACP,0BAA0B,CAAC;UACrEvC,KAAK,CAAC4C,uBAAuB,CAACE,MAAM,CAACH,qBAAqB,CAAC;QAC/D;OACH;IACL,CAAC;EACL;EAEA;;;;EAIO,OAAOsD,kBAAkBA,CAAA;IAC5B,OAAQjG,KAAK,IAAI;MACb,IAAI6D,SAAS,GAAGnE,aAAa,CAACoE,GAAG;MACjC,IAAIC,SAAS,GAAG,CAAC;MAEjB,MAAMxB,0BAA0B,GAAGvC,KAAK,CAACwC,4BAA4B,CAACvB,GAAG,CAAC,MAAK;QAC3E8C,SAAS,GAAGrE,aAAa,CAACoE,GAAG,GAAGD,SAAS;MAC7C,CAAC,CAAC;MAEF,MAAMlB,qBAAqB,GAAG3C,KAAK,CAAC4C,uBAAuB,CAAC3B,GAAG,CAAC,MAAK;QACjE4C,SAAS,GAAGnE,aAAa,CAACoE,GAAG;MACjC,CAAC,CAAC;MAEF,OAAO;QACH3D,EAAE,EAAE,aAAa;QACjBC,OAAO,EAAEA,CAAA,KAAM2D,SAAS;QACxBzD,OAAO,EAAEA,CAAA,KAAK;UACVN,KAAK,CAACwC,4BAA4B,CAACM,MAAM,CAACP,0BAA0B,CAAC;UACrEvC,KAAK,CAAC4C,uBAAuB,CAACE,MAAM,CAACH,qBAAqB,CAAC;QAC/D;OACH;IACL,CAAC;EACL;EAEA;;;;EAIO,OAAOuD,oBAAoBA,CAAA;IAC9B,OAAQlG,KAAK,IAAI;MACb,MAAMmG,qBAAqB,GAAG,IAAI1G,qBAAqB,CAACO,KAAK,CAACE,SAAS,EAAE,CAAC;MAC1EiG,qBAAqB,CAACC,mBAAmB,GAAG,IAAI;MAChD,OAAO;QACHjG,EAAE,EAAE,gBAAgB;QACpBC,OAAO,EAAEA,CAAA,KAAMiG,IAAI,CAACC,GAAG,CAACH,qBAAqB,CAACI,mBAAmB,CAAC1D,OAAO,GAAG,QAAQ,EAAE,CAAC,CAAC;QACxFvC,OAAO,EAAEA,CAAA,KAAK;UACV6F,qBAAqB,CAAC7F,OAAO,EAAE;QACnC;OACH;IACL,CAAC;EACL"},"metadata":{},"sourceType":"module","externalDependencies":[]}