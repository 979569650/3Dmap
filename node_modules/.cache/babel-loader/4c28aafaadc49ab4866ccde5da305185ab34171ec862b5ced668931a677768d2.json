{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"@babylonjs/core/tslib.es6.js\";\nimport { Container } from \"./container.js\";\nimport { ValueAndUnit } from \"../valueAndUnit.js\";\nimport { Control } from \"./control.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { RegisterClass } from \"@babylonjs/core/Misc/typeStore.js\";\nimport { serialize } from \"@babylonjs/core/Misc/decorators.js\";\n/**\n * Class used to create a 2D grid container\n */\nexport class Grid extends Container {\n  /**\n   * Sets/Gets a boolean indicating that control content must be clipped\n   * Please note that not clipping content may generate issues with adt.useInvalidateRectOptimization so it is recommended to turn this optimization off if you want to use unclipped children\n   */\n  set clipContent(value) {\n    this._clipContent = value;\n    // This value has to be replicated on all of the container cells\n    for (const key in this._cells) {\n      this._cells[key].clipContent = value;\n    }\n  }\n  get clipContent() {\n    return this._clipContent;\n  }\n  /**\n   * Sets/Gets a boolean indicating if the children are clipped to the current control bounds.\n   * Please note that not clipping children may generate issues with adt.useInvalidateRectOptimization so it is recommended to turn this optimization off if you want to use unclipped children\n   */\n  set clipChildren(value) {\n    this._clipChildren = value;\n    // This value has to be replicated on all of the container cells\n    for (const key in this._cells) {\n      this._cells[key].clipChildren = value;\n    }\n  }\n  get clipChildren() {\n    return this._clipChildren;\n  }\n  /**\n   * Gets the number of columns\n   */\n  get columnCount() {\n    return this._columnDefinitions.length;\n  }\n  /**\n   * Gets the number of rows\n   */\n  get rowCount() {\n    return this._rowDefinitions.length;\n  }\n  /** Gets the list of children */\n  get children() {\n    return this._childControls;\n  }\n  /** Gets the list of cells (e.g. the containers) */\n  get cells() {\n    return this._cells;\n  }\n  /**\n   * Gets the definition of a specific row\n   * @param index defines the index of the row\n   * @returns the row definition\n   */\n  getRowDefinition(index) {\n    if (index < 0 || index >= this._rowDefinitions.length) {\n      return null;\n    }\n    return this._rowDefinitions[index];\n  }\n  /**\n   * Gets the definition of a specific column\n   * @param index defines the index of the column\n   * @returns the column definition\n   */\n  getColumnDefinition(index) {\n    if (index < 0 || index >= this._columnDefinitions.length) {\n      return null;\n    }\n    return this._columnDefinitions[index];\n  }\n  /**\n   * Adds a new row to the grid\n   * @param height defines the height of the row (either in pixel or a value between 0 and 1)\n   * @param isPixel defines if the height is expressed in pixel (or in percentage)\n   * @returns the current grid\n   */\n  addRowDefinition(height, isPixel = false) {\n    this._rowDefinitions.push(new ValueAndUnit(height, isPixel ? ValueAndUnit.UNITMODE_PIXEL : ValueAndUnit.UNITMODE_PERCENTAGE));\n    this._rowDefinitionObservers.push(this._rowDefinitions[this.rowCount - 1].onChangedObservable.add(() => this._markAsDirty()));\n    this._markAsDirty();\n    return this;\n  }\n  /**\n   * Adds a new column to the grid\n   * @param width defines the width of the column (either in pixel or a value between 0 and 1)\n   * @param isPixel defines if the width is expressed in pixel (or in percentage)\n   * @returns the current grid\n   */\n  addColumnDefinition(width, isPixel = false) {\n    this._columnDefinitions.push(new ValueAndUnit(width, isPixel ? ValueAndUnit.UNITMODE_PIXEL : ValueAndUnit.UNITMODE_PERCENTAGE));\n    this._columnDefinitionObservers.push(this._columnDefinitions[this.columnCount - 1].onChangedObservable.add(() => this._markAsDirty()));\n    this._markAsDirty();\n    return this;\n  }\n  /**\n   * Update a row definition\n   * @param index defines the index of the row to update\n   * @param height defines the height of the row (either in pixel or a value between 0 and 1)\n   * @param isPixel defines if the weight is expressed in pixel (or in percentage)\n   * @returns the current grid\n   */\n  setRowDefinition(index, height, isPixel = false) {\n    if (index < 0 || index >= this._rowDefinitions.length) {\n      return this;\n    }\n    const current = this._rowDefinitions[index];\n    if (current && current.isPixel === isPixel && current.value === height) {\n      return this;\n    }\n    this._rowDefinitions[index].onChangedObservable.remove(this._rowDefinitionObservers[index]);\n    this._rowDefinitions[index] = new ValueAndUnit(height, isPixel ? ValueAndUnit.UNITMODE_PIXEL : ValueAndUnit.UNITMODE_PERCENTAGE);\n    this._rowDefinitionObservers[index] = this._rowDefinitions[index].onChangedObservable.add(() => this._markAsDirty());\n    this._markAsDirty();\n    return this;\n  }\n  /**\n   * Update a column definition\n   * @param index defines the index of the column to update\n   * @param width defines the width of the column (either in pixel or a value between 0 and 1)\n   * @param isPixel defines if the width is expressed in pixel (or in percentage)\n   * @returns the current grid\n   */\n  setColumnDefinition(index, width, isPixel = false) {\n    if (index < 0 || index >= this._columnDefinitions.length) {\n      return this;\n    }\n    const current = this._columnDefinitions[index];\n    if (current && current.isPixel === isPixel && current.value === width) {\n      return this;\n    }\n    this._columnDefinitions[index].onChangedObservable.remove(this._columnDefinitionObservers[index]);\n    this._columnDefinitions[index] = new ValueAndUnit(width, isPixel ? ValueAndUnit.UNITMODE_PIXEL : ValueAndUnit.UNITMODE_PERCENTAGE);\n    this._columnDefinitionObservers[index] = this._columnDefinitions[index].onChangedObservable.add(() => this._markAsDirty());\n    this._markAsDirty();\n    return this;\n  }\n  /**\n   * Gets the list of children stored in a specific cell\n   * @param row defines the row to check\n   * @param column defines the column to check\n   * @returns the list of controls\n   */\n  getChildrenAt(row, column) {\n    const cell = this._cells[`${row}:${column}`];\n    if (!cell) {\n      return null;\n    }\n    return cell.children;\n  }\n  /**\n   * Gets a string representing the child cell info (row x column)\n   * @param child defines the control to get info from\n   * @returns a string containing the child cell info (row x column)\n   */\n  getChildCellInfo(child) {\n    return child._tag;\n  }\n  _removeCell(cell, key) {\n    if (!cell) {\n      return;\n    }\n    super.removeControl(cell);\n    for (const control of cell.children) {\n      const childIndex = this._childControls.indexOf(control);\n      if (childIndex !== -1) {\n        this._childControls.splice(childIndex, 1);\n      }\n    }\n    delete this._cells[key];\n  }\n  _offsetCell(previousKey, key) {\n    if (!this._cells[key]) {\n      return;\n    }\n    this._cells[previousKey] = this._cells[key];\n    for (const control of this._cells[previousKey].children) {\n      control._tag = previousKey;\n    }\n    delete this._cells[key];\n  }\n  /**\n   * Remove a column definition at specified index\n   * @param index defines the index of the column to remove\n   * @returns the current grid\n   */\n  removeColumnDefinition(index) {\n    if (index < 0 || index >= this._columnDefinitions.length) {\n      return this;\n    }\n    for (let x = 0; x < this._rowDefinitions.length; x++) {\n      const key = `${x}:${index}`;\n      const cell = this._cells[key];\n      this._removeCell(cell, key);\n    }\n    for (let x = 0; x < this._rowDefinitions.length; x++) {\n      for (let y = index + 1; y < this._columnDefinitions.length; y++) {\n        const previousKey = `${x}:${y - 1}`;\n        const key = `${x}:${y}`;\n        this._offsetCell(previousKey, key);\n      }\n    }\n    this._columnDefinitions[index].onChangedObservable.remove(this._columnDefinitionObservers[index]);\n    this._columnDefinitions.splice(index, 1);\n    this._columnDefinitionObservers.splice(index, 1);\n    this._markAsDirty();\n    return this;\n  }\n  /**\n   * Remove a row definition at specified index\n   * @param index defines the index of the row to remove\n   * @returns the current grid\n   */\n  removeRowDefinition(index) {\n    if (index < 0 || index >= this._rowDefinitions.length) {\n      return this;\n    }\n    for (let y = 0; y < this._columnDefinitions.length; y++) {\n      const key = `${index}:${y}`;\n      const cell = this._cells[key];\n      this._removeCell(cell, key);\n    }\n    for (let y = 0; y < this._columnDefinitions.length; y++) {\n      for (let x = index + 1; x < this._rowDefinitions.length; x++) {\n        const previousKey = `${x - 1}:${y}`;\n        const key = `${x}:${y}`;\n        this._offsetCell(previousKey, key);\n      }\n    }\n    this._rowDefinitions[index].onChangedObservable.remove(this._rowDefinitionObservers[index]);\n    this._rowDefinitions.splice(index, 1);\n    this._rowDefinitionObservers.splice(index, 1);\n    this._markAsDirty();\n    return this;\n  }\n  /**\n   * Adds a new control to the current grid\n   * @param control defines the control to add\n   * @param row defines the row where to add the control (0 by default)\n   * @param column defines the column where to add the control (0 by default)\n   * @returns the current grid\n   */\n  addControl(control, row = 0, column = 0) {\n    if (this._rowDefinitions.length === 0) {\n      // Add default row definition\n      this.addRowDefinition(1, false);\n    }\n    if (this._columnDefinitions.length === 0) {\n      // Add default column definition\n      this.addColumnDefinition(1, false);\n    }\n    if (this._childControls.indexOf(control) !== -1) {\n      Tools.Warn(`Control (Name:${control.name}, UniqueId:${control.uniqueId}) is already associated with this grid. You must remove it before reattaching it`);\n      return this;\n    }\n    const x = Math.min(row, this._rowDefinitions.length - 1);\n    const y = Math.min(column, this._columnDefinitions.length - 1);\n    const key = `${x}:${y}`;\n    let goodContainer = this._cells[key];\n    if (!goodContainer) {\n      goodContainer = new Container(key);\n      this._cells[key] = goodContainer;\n      goodContainer.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\n      goodContainer.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\n      goodContainer.clipContent = this.clipContent;\n      goodContainer.clipChildren = this.clipChildren;\n      super.addControl(goodContainer);\n    }\n    goodContainer.addControl(control);\n    this._childControls.push(control);\n    control._tag = key;\n    control.parent = this;\n    this._markAsDirty();\n    return this;\n  }\n  /**\n   * Removes a control from the current container\n   * @param control defines the control to remove\n   * @returns the current container\n   */\n  removeControl(control) {\n    const index = this._childControls.indexOf(control);\n    if (index !== -1) {\n      this._childControls.splice(index, 1);\n    }\n    const cell = this._cells[control._tag];\n    if (cell) {\n      cell.removeControl(control);\n      control._tag = null;\n    }\n    this._markAsDirty();\n    return this;\n  }\n  /**\n   * Creates a new Grid\n   * @param name defines control name\n   */\n  constructor(name) {\n    super(name);\n    this.name = name;\n    this._rowDefinitions = new Array();\n    this._rowDefinitionObservers = [];\n    this._columnDefinitions = new Array();\n    this._columnDefinitionObservers = [];\n    this._cells = {};\n    this._childControls = new Array();\n  }\n  _getTypeName() {\n    return \"Grid\";\n  }\n  _getGridDefinitions(definitionCallback) {\n    const widths = [];\n    const heights = [];\n    const lefts = [];\n    const tops = [];\n    let availableWidth = this._currentMeasure.width;\n    let globalWidthPercentage = 0;\n    let availableHeight = this._currentMeasure.height;\n    let globalHeightPercentage = 0;\n    // Heights\n    let index = 0;\n    for (const rowDefinition of this._rowDefinitions) {\n      if (rowDefinition.isPixel) {\n        const height = rowDefinition.getValue(this._host);\n        availableHeight -= height;\n        heights[index] = height;\n      } else {\n        globalHeightPercentage += rowDefinition.value;\n      }\n      index++;\n    }\n    let top = 0;\n    index = 0;\n    for (const rowDefinition of this._rowDefinitions) {\n      tops.push(top);\n      if (!rowDefinition.isPixel) {\n        const height = Math.round(rowDefinition.value / globalHeightPercentage * availableHeight);\n        top += height;\n        heights[index] = height;\n      } else {\n        top += rowDefinition.getValue(this._host);\n      }\n      index++;\n    }\n    // Widths\n    index = 0;\n    for (const columnDefinition of this._columnDefinitions) {\n      if (columnDefinition.isPixel) {\n        const width = columnDefinition.getValue(this._host);\n        availableWidth -= width;\n        widths[index] = width;\n      } else {\n        globalWidthPercentage += columnDefinition.value;\n      }\n      index++;\n    }\n    let left = 0;\n    index = 0;\n    for (const columnDefinition of this._columnDefinitions) {\n      lefts.push(left);\n      if (!columnDefinition.isPixel) {\n        const width = Math.round(columnDefinition.value / globalWidthPercentage * availableWidth);\n        left += width;\n        widths[index] = width;\n      } else {\n        left += columnDefinition.getValue(this._host);\n      }\n      index++;\n    }\n    definitionCallback(lefts, tops, widths, heights);\n  }\n  _additionalProcessing(parentMeasure, context) {\n    this._getGridDefinitions((lefts, tops, widths, heights) => {\n      // Setting child sizes\n      for (const key in this._cells) {\n        if (!Object.prototype.hasOwnProperty.call(this._cells, key)) {\n          continue;\n        }\n        const split = key.split(\":\");\n        const x = parseInt(split[0]);\n        const y = parseInt(split[1]);\n        const cell = this._cells[key];\n        cell.leftInPixels = lefts[y];\n        cell.topInPixels = tops[x];\n        cell.widthInPixels = widths[y];\n        cell.heightInPixels = heights[x];\n        cell._left.ignoreAdaptiveScaling = true;\n        cell._top.ignoreAdaptiveScaling = true;\n        cell._width.ignoreAdaptiveScaling = true;\n        cell._height.ignoreAdaptiveScaling = true;\n      }\n    });\n    super._additionalProcessing(parentMeasure, context);\n  }\n  _flagDescendantsAsMatrixDirty() {\n    for (const key in this._cells) {\n      if (!Object.prototype.hasOwnProperty.call(this._cells, key)) {\n        continue;\n      }\n      const child = this._cells[key];\n      child._markMatrixAsDirty();\n    }\n  }\n  _renderHighlightSpecific(context) {\n    super._renderHighlightSpecific(context);\n    this._getGridDefinitions((lefts, tops, widths, heights) => {\n      // Columns\n      for (let index = 0; index < lefts.length; index++) {\n        const left = this._currentMeasure.left + lefts[index] + widths[index];\n        context.beginPath();\n        context.moveTo(left, this._currentMeasure.top);\n        context.lineTo(left, this._currentMeasure.top + this._currentMeasure.height);\n        context.stroke();\n      }\n      // Rows\n      for (let index = 0; index < tops.length; index++) {\n        const top = this._currentMeasure.top + tops[index] + heights[index];\n        context.beginPath();\n        context.moveTo(this._currentMeasure.left, top);\n        context.lineTo(this._currentMeasure.left + this._currentMeasure.width, top);\n        context.stroke();\n      }\n    });\n    context.restore();\n  }\n  /** Releases associated resources */\n  dispose() {\n    super.dispose();\n    for (const control of this._childControls) {\n      control.dispose();\n    }\n    for (let index = 0; index < this._rowDefinitions.length; index++) {\n      this._rowDefinitions[index].onChangedObservable.remove(this._rowDefinitionObservers[index]);\n    }\n    for (let index = 0; index < this._columnDefinitions.length; index++) {\n      this._columnDefinitions[index].onChangedObservable.remove(this._columnDefinitionObservers[index]);\n    }\n    this._rowDefinitionObservers.length = 0;\n    this._rowDefinitions.length = 0;\n    this._columnDefinitionObservers.length = 0;\n    this._columnDefinitions.length = 0;\n    this._cells = {};\n    this._childControls.length = 0;\n  }\n  /**\n   * Serializes the current control\n   * @param serializationObject defined the JSON serialized object\n   */\n  serialize(serializationObject) {\n    super.serialize(serializationObject);\n    serializationObject.columnCount = this.columnCount;\n    serializationObject.rowCount = this.rowCount;\n    serializationObject.columns = [];\n    serializationObject.rows = [];\n    serializationObject.tags = [];\n    for (let i = 0; i < this.columnCount; ++i) {\n      const cd = this.getColumnDefinition(i);\n      const childSerializationObject = {\n        value: cd === null || cd === void 0 ? void 0 : cd.getValue(this.host),\n        unit: cd === null || cd === void 0 ? void 0 : cd.unit\n      };\n      serializationObject.columns.push(childSerializationObject);\n    }\n    for (let i = 0; i < this.rowCount; ++i) {\n      const rd = this.getRowDefinition(i);\n      const childSerializationObject = {\n        value: rd === null || rd === void 0 ? void 0 : rd.getValue(this.host),\n        unit: rd === null || rd === void 0 ? void 0 : rd.unit\n      };\n      serializationObject.rows.push(childSerializationObject);\n    }\n    this.children.forEach(child => {\n      serializationObject.tags.push(child._tag);\n    });\n  }\n  /**\n   * @internal\n   */\n  _parseFromContent(serializedObject, host) {\n    super._parseFromContent(serializedObject, host);\n    const children = [];\n    this.children.forEach(child => {\n      children.push(child);\n    });\n    this.removeRowDefinition(0);\n    this.removeColumnDefinition(0);\n    for (let i = 0; i < serializedObject.columnCount; ++i) {\n      const columnValue = serializedObject.columns[i].value;\n      const unit = serializedObject.columns[i].unit;\n      this.addColumnDefinition(columnValue, unit === 1 ? true : false);\n    }\n    for (let i = 0; i < serializedObject.rowCount; ++i) {\n      const rowValue = serializedObject.rows[i].value;\n      const unit = serializedObject.rows[i].unit;\n      this.addRowDefinition(rowValue, unit === 1 ? true : false);\n    }\n    for (let i = 0; i < children.length; ++i) {\n      const cellInfo = serializedObject.tags[i];\n      let rowNumber = parseInt(cellInfo.substring(0, cellInfo.search(\":\")));\n      if (isNaN(rowNumber)) {\n        rowNumber = 0;\n      }\n      let columnNumber = parseInt(cellInfo.substring(cellInfo.search(\":\") + 1));\n      if (isNaN(columnNumber)) {\n        columnNumber = 0;\n      }\n      this.addControl(children[i], rowNumber, columnNumber);\n    }\n  }\n}\n__decorate([serialize()], Grid.prototype, \"clipContent\", null);\nRegisterClass(\"BABYLON.GUI.Grid\", Grid);","map":{"version":3,"names":["Container","ValueAndUnit","Control","Tools","RegisterClass","serialize","Grid","clipContent","value","_clipContent","key","_cells","clipChildren","_clipChildren","columnCount","_columnDefinitions","length","rowCount","_rowDefinitions","children","_childControls","cells","getRowDefinition","index","getColumnDefinition","addRowDefinition","height","isPixel","push","UNITMODE_PIXEL","UNITMODE_PERCENTAGE","_rowDefinitionObservers","onChangedObservable","add","_markAsDirty","addColumnDefinition","width","_columnDefinitionObservers","setRowDefinition","current","remove","setColumnDefinition","getChildrenAt","row","column","cell","getChildCellInfo","child","_tag","_removeCell","removeControl","control","childIndex","indexOf","splice","_offsetCell","previousKey","removeColumnDefinition","x","y","removeRowDefinition","addControl","Warn","name","uniqueId","Math","min","goodContainer","horizontalAlignment","HORIZONTAL_ALIGNMENT_LEFT","verticalAlignment","VERTICAL_ALIGNMENT_TOP","parent","constructor","Array","_getTypeName","_getGridDefinitions","definitionCallback","widths","heights","lefts","tops","availableWidth","_currentMeasure","globalWidthPercentage","availableHeight","globalHeightPercentage","rowDefinition","getValue","_host","top","round","columnDefinition","left","_additionalProcessing","parentMeasure","context","Object","prototype","hasOwnProperty","call","split","parseInt","leftInPixels","topInPixels","widthInPixels","heightInPixels","_left","ignoreAdaptiveScaling","_top","_width","_height","_flagDescendantsAsMatrixDirty","_markMatrixAsDirty","_renderHighlightSpecific","beginPath","moveTo","lineTo","stroke","restore","dispose","serializationObject","columns","rows","tags","i","cd","childSerializationObject","host","unit","rd","forEach","_parseFromContent","serializedObject","columnValue","rowValue","cellInfo","rowNumber","substring","search","isNaN","columnNumber","__decorate"],"sources":["../../../../../dev/gui/src/2D/controls/grid.ts"],"sourcesContent":["import type { Nullable } from \"core/types\";\r\n\r\nimport { Container } from \"./container\";\r\nimport { ValueAndUnit } from \"../valueAndUnit\";\r\nimport { Control } from \"./control\";\r\nimport type { Measure } from \"../measure\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\nimport type { AdvancedDynamicTexture } from \"../advancedDynamicTexture\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\n\r\n/**\r\n * Class used to create a 2D grid container\r\n */\r\nexport class Grid extends Container {\r\n    private _rowDefinitions = new Array<ValueAndUnit>();\r\n    private _rowDefinitionObservers: Observer<void>[] = [];\r\n    private _columnDefinitions = new Array<ValueAndUnit>();\r\n    private _columnDefinitionObservers: Observer<void>[] = [];\r\n    private _cells: { [key: string]: Container } = {};\r\n    private _childControls = new Array<Control>();\r\n\r\n    /**\r\n     * Sets/Gets a boolean indicating that control content must be clipped\r\n     * Please note that not clipping content may generate issues with adt.useInvalidateRectOptimization so it is recommended to turn this optimization off if you want to use unclipped children\r\n     */\r\n    public set clipContent(value: boolean) {\r\n        this._clipContent = value;\r\n\r\n        // This value has to be replicated on all of the container cells\r\n        for (const key in this._cells) {\r\n            this._cells[key].clipContent = value;\r\n        }\r\n    }\r\n\r\n    @serialize()\r\n    public get clipContent(): boolean {\r\n        return this._clipContent;\r\n    }\r\n\r\n    /**\r\n     * Sets/Gets a boolean indicating if the children are clipped to the current control bounds.\r\n     * Please note that not clipping children may generate issues with adt.useInvalidateRectOptimization so it is recommended to turn this optimization off if you want to use unclipped children\r\n     */\r\n    public set clipChildren(value: boolean) {\r\n        this._clipChildren = value;\r\n\r\n        // This value has to be replicated on all of the container cells\r\n        for (const key in this._cells) {\r\n            this._cells[key].clipChildren = value;\r\n        }\r\n    }\r\n\r\n    public get clipChildren(): boolean {\r\n        return this._clipChildren;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of columns\r\n     */\r\n    public get columnCount(): number {\r\n        return this._columnDefinitions.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of rows\r\n     */\r\n    public get rowCount(): number {\r\n        return this._rowDefinitions.length;\r\n    }\r\n\r\n    /** Gets the list of children */\r\n    public get children(): Control[] {\r\n        return this._childControls;\r\n    }\r\n\r\n    /** Gets the list of cells (e.g. the containers) */\r\n    public get cells(): { [key: string]: Container } {\r\n        return this._cells;\r\n    }\r\n\r\n    /**\r\n     * Gets the definition of a specific row\r\n     * @param index defines the index of the row\r\n     * @returns the row definition\r\n     */\r\n    public getRowDefinition(index: number): Nullable<ValueAndUnit> {\r\n        if (index < 0 || index >= this._rowDefinitions.length) {\r\n            return null;\r\n        }\r\n\r\n        return this._rowDefinitions[index];\r\n    }\r\n\r\n    /**\r\n     * Gets the definition of a specific column\r\n     * @param index defines the index of the column\r\n     * @returns the column definition\r\n     */\r\n    public getColumnDefinition(index: number): Nullable<ValueAndUnit> {\r\n        if (index < 0 || index >= this._columnDefinitions.length) {\r\n            return null;\r\n        }\r\n\r\n        return this._columnDefinitions[index];\r\n    }\r\n\r\n    /**\r\n     * Adds a new row to the grid\r\n     * @param height defines the height of the row (either in pixel or a value between 0 and 1)\r\n     * @param isPixel defines if the height is expressed in pixel (or in percentage)\r\n     * @returns the current grid\r\n     */\r\n    public addRowDefinition(height: number, isPixel = false): Grid {\r\n        this._rowDefinitions.push(new ValueAndUnit(height, isPixel ? ValueAndUnit.UNITMODE_PIXEL : ValueAndUnit.UNITMODE_PERCENTAGE));\r\n        this._rowDefinitionObservers.push(this._rowDefinitions[this.rowCount - 1].onChangedObservable.add(() => this._markAsDirty())!);\r\n        this._markAsDirty();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new column to the grid\r\n     * @param width defines the width of the column (either in pixel or a value between 0 and 1)\r\n     * @param isPixel defines if the width is expressed in pixel (or in percentage)\r\n     * @returns the current grid\r\n     */\r\n    public addColumnDefinition(width: number, isPixel = false): Grid {\r\n        this._columnDefinitions.push(new ValueAndUnit(width, isPixel ? ValueAndUnit.UNITMODE_PIXEL : ValueAndUnit.UNITMODE_PERCENTAGE));\r\n        this._columnDefinitionObservers.push(this._columnDefinitions[this.columnCount - 1].onChangedObservable.add(() => this._markAsDirty())!);\r\n        this._markAsDirty();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Update a row definition\r\n     * @param index defines the index of the row to update\r\n     * @param height defines the height of the row (either in pixel or a value between 0 and 1)\r\n     * @param isPixel defines if the weight is expressed in pixel (or in percentage)\r\n     * @returns the current grid\r\n     */\r\n    public setRowDefinition(index: number, height: number, isPixel = false): Grid {\r\n        if (index < 0 || index >= this._rowDefinitions.length) {\r\n            return this;\r\n        }\r\n\r\n        const current = this._rowDefinitions[index];\r\n        if (current && current.isPixel === isPixel && current.value === height) {\r\n            return this;\r\n        }\r\n\r\n        this._rowDefinitions[index].onChangedObservable.remove(this._rowDefinitionObservers[index]);\r\n        this._rowDefinitions[index] = new ValueAndUnit(height, isPixel ? ValueAndUnit.UNITMODE_PIXEL : ValueAndUnit.UNITMODE_PERCENTAGE);\r\n        this._rowDefinitionObservers[index] = this._rowDefinitions[index].onChangedObservable.add(() => this._markAsDirty())!;\r\n\r\n        this._markAsDirty();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Update a column definition\r\n     * @param index defines the index of the column to update\r\n     * @param width defines the width of the column (either in pixel or a value between 0 and 1)\r\n     * @param isPixel defines if the width is expressed in pixel (or in percentage)\r\n     * @returns the current grid\r\n     */\r\n    public setColumnDefinition(index: number, width: number, isPixel = false): Grid {\r\n        if (index < 0 || index >= this._columnDefinitions.length) {\r\n            return this;\r\n        }\r\n\r\n        const current = this._columnDefinitions[index];\r\n        if (current && current.isPixel === isPixel && current.value === width) {\r\n            return this;\r\n        }\r\n\r\n        this._columnDefinitions[index].onChangedObservable.remove(this._columnDefinitionObservers[index]);\r\n        this._columnDefinitions[index] = new ValueAndUnit(width, isPixel ? ValueAndUnit.UNITMODE_PIXEL : ValueAndUnit.UNITMODE_PERCENTAGE);\r\n        this._columnDefinitionObservers[index] = this._columnDefinitions[index].onChangedObservable.add(() => this._markAsDirty())!;\r\n\r\n        this._markAsDirty();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of children stored in a specific cell\r\n     * @param row defines the row to check\r\n     * @param column defines the column to check\r\n     * @returns the list of controls\r\n     */\r\n    public getChildrenAt(row: number, column: number): Nullable<Array<Control>> {\r\n        const cell = this._cells[`${row}:${column}`];\r\n\r\n        if (!cell) {\r\n            return null;\r\n        }\r\n\r\n        return cell.children;\r\n    }\r\n\r\n    /**\r\n     * Gets a string representing the child cell info (row x column)\r\n     * @param child defines the control to get info from\r\n     * @returns a string containing the child cell info (row x column)\r\n     */\r\n    public getChildCellInfo(child: Control): string {\r\n        return child._tag;\r\n    }\r\n\r\n    private _removeCell(cell: Container, key: string) {\r\n        if (!cell) {\r\n            return;\r\n        }\r\n\r\n        super.removeControl(cell);\r\n\r\n        for (const control of cell.children) {\r\n            const childIndex = this._childControls.indexOf(control);\r\n\r\n            if (childIndex !== -1) {\r\n                this._childControls.splice(childIndex, 1);\r\n            }\r\n        }\r\n\r\n        delete this._cells[key];\r\n    }\r\n\r\n    private _offsetCell(previousKey: string, key: string) {\r\n        if (!this._cells[key]) {\r\n            return;\r\n        }\r\n\r\n        this._cells[previousKey] = this._cells[key];\r\n\r\n        for (const control of this._cells[previousKey].children) {\r\n            control._tag = previousKey;\r\n        }\r\n\r\n        delete this._cells[key];\r\n    }\r\n\r\n    /**\r\n     * Remove a column definition at specified index\r\n     * @param index defines the index of the column to remove\r\n     * @returns the current grid\r\n     */\r\n    public removeColumnDefinition(index: number): Grid {\r\n        if (index < 0 || index >= this._columnDefinitions.length) {\r\n            return this;\r\n        }\r\n\r\n        for (let x = 0; x < this._rowDefinitions.length; x++) {\r\n            const key = `${x}:${index}`;\r\n            const cell = this._cells[key];\r\n\r\n            this._removeCell(cell, key);\r\n        }\r\n\r\n        for (let x = 0; x < this._rowDefinitions.length; x++) {\r\n            for (let y = index + 1; y < this._columnDefinitions.length; y++) {\r\n                const previousKey = `${x}:${y - 1}`;\r\n                const key = `${x}:${y}`;\r\n\r\n                this._offsetCell(previousKey, key);\r\n            }\r\n        }\r\n\r\n        this._columnDefinitions[index].onChangedObservable.remove(this._columnDefinitionObservers[index]);\r\n        this._columnDefinitions.splice(index, 1);\r\n        this._columnDefinitionObservers.splice(index, 1);\r\n\r\n        this._markAsDirty();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a row definition at specified index\r\n     * @param index defines the index of the row to remove\r\n     * @returns the current grid\r\n     */\r\n    public removeRowDefinition(index: number): Grid {\r\n        if (index < 0 || index >= this._rowDefinitions.length) {\r\n            return this;\r\n        }\r\n\r\n        for (let y = 0; y < this._columnDefinitions.length; y++) {\r\n            const key = `${index}:${y}`;\r\n            const cell = this._cells[key];\r\n\r\n            this._removeCell(cell, key);\r\n        }\r\n\r\n        for (let y = 0; y < this._columnDefinitions.length; y++) {\r\n            for (let x = index + 1; x < this._rowDefinitions.length; x++) {\r\n                const previousKey = `${x - 1}:${y}`;\r\n                const key = `${x}:${y}`;\r\n\r\n                this._offsetCell(previousKey, key);\r\n            }\r\n        }\r\n\r\n        this._rowDefinitions[index].onChangedObservable.remove(this._rowDefinitionObservers[index]);\r\n        this._rowDefinitions.splice(index, 1);\r\n        this._rowDefinitionObservers.splice(index, 1);\r\n\r\n        this._markAsDirty();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new control to the current grid\r\n     * @param control defines the control to add\r\n     * @param row defines the row where to add the control (0 by default)\r\n     * @param column defines the column where to add the control (0 by default)\r\n     * @returns the current grid\r\n     */\r\n    public addControl(control: Control, row: number = 0, column: number = 0): Grid {\r\n        if (this._rowDefinitions.length === 0) {\r\n            // Add default row definition\r\n            this.addRowDefinition(1, false);\r\n        }\r\n\r\n        if (this._columnDefinitions.length === 0) {\r\n            // Add default column definition\r\n            this.addColumnDefinition(1, false);\r\n        }\r\n\r\n        if (this._childControls.indexOf(control) !== -1) {\r\n            Tools.Warn(`Control (Name:${control.name}, UniqueId:${control.uniqueId}) is already associated with this grid. You must remove it before reattaching it`);\r\n            return this;\r\n        }\r\n\r\n        const x = Math.min(row, this._rowDefinitions.length - 1);\r\n        const y = Math.min(column, this._columnDefinitions.length - 1);\r\n        const key = `${x}:${y}`;\r\n        let goodContainer = this._cells[key];\r\n\r\n        if (!goodContainer) {\r\n            goodContainer = new Container(key);\r\n            this._cells[key] = goodContainer;\r\n            goodContainer.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n            goodContainer.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n            goodContainer.clipContent = this.clipContent;\r\n            goodContainer.clipChildren = this.clipChildren;\r\n            super.addControl(goodContainer);\r\n        }\r\n\r\n        goodContainer.addControl(control);\r\n        this._childControls.push(control);\r\n        control._tag = key;\r\n        control.parent = this;\r\n\r\n        this._markAsDirty();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes a control from the current container\r\n     * @param control defines the control to remove\r\n     * @returns the current container\r\n     */\r\n    public removeControl(control: Control): Container {\r\n        const index = this._childControls.indexOf(control);\r\n\r\n        if (index !== -1) {\r\n            this._childControls.splice(index, 1);\r\n        }\r\n\r\n        const cell = this._cells[control._tag];\r\n\r\n        if (cell) {\r\n            cell.removeControl(control);\r\n            control._tag = null;\r\n        }\r\n\r\n        this._markAsDirty();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Grid\r\n     * @param name defines control name\r\n     */\r\n    constructor(public name?: string) {\r\n        super(name);\r\n    }\r\n\r\n    protected _getTypeName(): string {\r\n        return \"Grid\";\r\n    }\r\n\r\n    protected _getGridDefinitions(definitionCallback: (lefts: number[], tops: number[], widths: number[], heights: number[]) => void) {\r\n        const widths = [];\r\n        const heights = [];\r\n        const lefts = [];\r\n        const tops = [];\r\n\r\n        let availableWidth = this._currentMeasure.width;\r\n        let globalWidthPercentage = 0;\r\n        let availableHeight = this._currentMeasure.height;\r\n        let globalHeightPercentage = 0;\r\n\r\n        // Heights\r\n        let index = 0;\r\n        for (const rowDefinition of this._rowDefinitions) {\r\n            if (rowDefinition.isPixel) {\r\n                const height = rowDefinition.getValue(this._host);\r\n                availableHeight -= height;\r\n                heights[index] = height;\r\n            } else {\r\n                globalHeightPercentage += rowDefinition.value;\r\n            }\r\n            index++;\r\n        }\r\n\r\n        let top = 0;\r\n        index = 0;\r\n        for (const rowDefinition of this._rowDefinitions) {\r\n            tops.push(top);\r\n\r\n            if (!rowDefinition.isPixel) {\r\n                const height = Math.round((rowDefinition.value / globalHeightPercentage) * availableHeight);\r\n                top += height;\r\n                heights[index] = height;\r\n            } else {\r\n                top += rowDefinition.getValue(this._host);\r\n            }\r\n            index++;\r\n        }\r\n\r\n        // Widths\r\n        index = 0;\r\n        for (const columnDefinition of this._columnDefinitions) {\r\n            if (columnDefinition.isPixel) {\r\n                const width = columnDefinition.getValue(this._host);\r\n                availableWidth -= width;\r\n                widths[index] = width;\r\n            } else {\r\n                globalWidthPercentage += columnDefinition.value;\r\n            }\r\n            index++;\r\n        }\r\n\r\n        let left = 0;\r\n        index = 0;\r\n        for (const columnDefinition of this._columnDefinitions) {\r\n            lefts.push(left);\r\n            if (!columnDefinition.isPixel) {\r\n                const width = Math.round((columnDefinition.value / globalWidthPercentage) * availableWidth);\r\n                left += width;\r\n                widths[index] = width;\r\n            } else {\r\n                left += columnDefinition.getValue(this._host);\r\n            }\r\n            index++;\r\n        }\r\n\r\n        definitionCallback(lefts, tops, widths, heights);\r\n    }\r\n\r\n    protected _additionalProcessing(parentMeasure: Measure, context: ICanvasRenderingContext): void {\r\n        this._getGridDefinitions((lefts: number[], tops: number[], widths: number[], heights: number[]) => {\r\n            // Setting child sizes\r\n            for (const key in this._cells) {\r\n                if (!Object.prototype.hasOwnProperty.call(this._cells, key)) {\r\n                    continue;\r\n                }\r\n                const split = key.split(\":\");\r\n                const x = parseInt(split[0]);\r\n                const y = parseInt(split[1]);\r\n                const cell = this._cells[key];\r\n\r\n                cell.leftInPixels = lefts[y];\r\n                cell.topInPixels = tops[x];\r\n                cell.widthInPixels = widths[y];\r\n                cell.heightInPixels = heights[x];\r\n                cell._left.ignoreAdaptiveScaling = true;\r\n                cell._top.ignoreAdaptiveScaling = true;\r\n                cell._width.ignoreAdaptiveScaling = true;\r\n                cell._height.ignoreAdaptiveScaling = true;\r\n            }\r\n        });\r\n\r\n        super._additionalProcessing(parentMeasure, context);\r\n    }\r\n\r\n    public _flagDescendantsAsMatrixDirty(): void {\r\n        for (const key in this._cells) {\r\n            if (!Object.prototype.hasOwnProperty.call(this._cells, key)) {\r\n                continue;\r\n            }\r\n\r\n            const child = this._cells[key];\r\n            child._markMatrixAsDirty();\r\n        }\r\n    }\r\n\r\n    public _renderHighlightSpecific(context: ICanvasRenderingContext): void {\r\n        super._renderHighlightSpecific(context);\r\n\r\n        this._getGridDefinitions((lefts: number[], tops: number[], widths: number[], heights: number[]) => {\r\n            // Columns\r\n            for (let index = 0; index < lefts.length; index++) {\r\n                const left = this._currentMeasure.left + lefts[index] + widths[index];\r\n                context.beginPath();\r\n                context.moveTo(left, this._currentMeasure.top);\r\n                context.lineTo(left, this._currentMeasure.top + this._currentMeasure.height);\r\n                context.stroke();\r\n            }\r\n\r\n            // Rows\r\n            for (let index = 0; index < tops.length; index++) {\r\n                const top = this._currentMeasure.top + tops[index] + heights[index];\r\n                context.beginPath();\r\n                context.moveTo(this._currentMeasure.left, top);\r\n                context.lineTo(this._currentMeasure.left + this._currentMeasure.width, top);\r\n                context.stroke();\r\n            }\r\n        });\r\n\r\n        context.restore();\r\n    }\r\n\r\n    /** Releases associated resources */\r\n    public dispose() {\r\n        super.dispose();\r\n\r\n        for (const control of this._childControls) {\r\n            control.dispose();\r\n        }\r\n        for (let index = 0; index < this._rowDefinitions.length; index++) {\r\n            this._rowDefinitions[index].onChangedObservable.remove(this._rowDefinitionObservers[index]);\r\n        }\r\n        for (let index = 0; index < this._columnDefinitions.length; index++) {\r\n            this._columnDefinitions[index].onChangedObservable.remove(this._columnDefinitionObservers[index]);\r\n        }\r\n        this._rowDefinitionObservers.length = 0;\r\n        this._rowDefinitions.length = 0;\r\n        this._columnDefinitionObservers.length = 0;\r\n        this._columnDefinitions.length = 0;\r\n        this._cells = {};\r\n        this._childControls.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current control\r\n     * @param serializationObject defined the JSON serialized object\r\n     */\r\n    public serialize(serializationObject: any) {\r\n        super.serialize(serializationObject);\r\n        serializationObject.columnCount = this.columnCount;\r\n        serializationObject.rowCount = this.rowCount;\r\n        serializationObject.columns = [];\r\n        serializationObject.rows = [];\r\n        serializationObject.tags = [];\r\n        for (let i = 0; i < this.columnCount; ++i) {\r\n            const cd = this.getColumnDefinition(i);\r\n            const childSerializationObject = { value: cd?.getValue(this.host), unit: cd?.unit };\r\n            serializationObject.columns.push(childSerializationObject);\r\n        }\r\n        for (let i = 0; i < this.rowCount; ++i) {\r\n            const rd = this.getRowDefinition(i);\r\n            const childSerializationObject = { value: rd?.getValue(this.host), unit: rd?.unit };\r\n            serializationObject.rows.push(childSerializationObject);\r\n        }\r\n        this.children.forEach((child) => {\r\n            serializationObject.tags.push(child._tag);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _parseFromContent(serializedObject: any, host: AdvancedDynamicTexture) {\r\n        super._parseFromContent(serializedObject, host);\r\n        const children: Control[] = [];\r\n        this.children.forEach((child) => {\r\n            children.push(child);\r\n        });\r\n        this.removeRowDefinition(0);\r\n        this.removeColumnDefinition(0);\r\n        for (let i = 0; i < serializedObject.columnCount; ++i) {\r\n            const columnValue = serializedObject.columns[i].value;\r\n            const unit = serializedObject.columns[i].unit;\r\n            this.addColumnDefinition(columnValue, unit === 1 ? true : false);\r\n        }\r\n        for (let i = 0; i < serializedObject.rowCount; ++i) {\r\n            const rowValue = serializedObject.rows[i].value;\r\n            const unit = serializedObject.rows[i].unit;\r\n            this.addRowDefinition(rowValue, unit === 1 ? true : false);\r\n        }\r\n\r\n        for (let i = 0; i < children.length; ++i) {\r\n            const cellInfo = serializedObject.tags[i];\r\n            let rowNumber = parseInt(cellInfo.substring(0, cellInfo.search(\":\")));\r\n            if (isNaN(rowNumber)) {\r\n                rowNumber = 0;\r\n            }\r\n            let columnNumber = parseInt(cellInfo.substring(cellInfo.search(\":\") + 1));\r\n            if (isNaN(columnNumber)) {\r\n                columnNumber = 0;\r\n            }\r\n            this.addControl(children[i], rowNumber, columnNumber);\r\n        }\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.Grid\", Grid);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}