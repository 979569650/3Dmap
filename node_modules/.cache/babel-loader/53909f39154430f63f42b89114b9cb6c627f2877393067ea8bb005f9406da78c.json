{"ast":null,"code":"import { Vector3, Vector2, TmpVectors } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\n/**\n * Information about the result of picking within a scene\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/picking_collisions\n */\nexport class PickingInfo {\n  constructor() {\n    /**\n     * If the pick collided with an object\n     */\n    this.hit = false;\n    /**\n     * Distance away where the pick collided\n     */\n    this.distance = 0;\n    /**\n     * The location of pick collision\n     */\n    this.pickedPoint = null;\n    /**\n     * The mesh corresponding the pick collision\n     */\n    this.pickedMesh = null;\n    /** (See getTextureCoordinates) The barycentric U coordinate that is used when calculating the texture coordinates of the collision.*/\n    this.bu = 0;\n    /** (See getTextureCoordinates) The barycentric V coordinate that is used when calculating the texture coordinates of the collision.*/\n    this.bv = 0;\n    /** The index of the face on the mesh that was picked, or the index of the Line if the picked Mesh is a LinesMesh */\n    this.faceId = -1;\n    /** The index of the face on the subMesh that was picked, or the index of the Line if the picked Mesh is a LinesMesh */\n    this.subMeshFaceId = -1;\n    /** Id of the submesh that was picked */\n    this.subMeshId = 0;\n    /** If a sprite was picked, this will be the sprite the pick collided with */\n    this.pickedSprite = null;\n    /** If we are picking a mesh with thin instance, this will give you the picked thin instance */\n    this.thinInstanceIndex = -1;\n    /**\n     * The ray that was used to perform the picking.\n     */\n    this.ray = null;\n    /**\n     * If a mesh was used to do the picking (eg. 6dof controller) as a \"near interaction\", this will be populated.\n     */\n    this.originMesh = null;\n    /**\n     * The aim-space transform of the input used for picking, if it is an XR input source.\n     */\n    this.aimTransform = null;\n    /**\n     * The grip-space transform of the input used for picking, if it is an XR input source.\n     * Some XR sources, such as input coming from head mounted displays, do not have this.\n     */\n    this.gripTransform = null;\n  }\n  /**\n   * Gets the normal corresponding to the face the pick collided with\n   * @param useWorldCoordinates If the resulting normal should be relative to the world (default: false)\n   * @param useVerticesNormals If the vertices normals should be used to calculate the normal instead of the normal map (default: true)\n   * @returns The normal corresponding to the face the pick collided with\n   * @remarks Note that the returned normal will always point towards the picking ray.\n   */\n  getNormal(useWorldCoordinates = false, useVerticesNormals = true) {\n    if (!this.pickedMesh || useVerticesNormals && !this.pickedMesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      return null;\n    }\n    let indices = this.pickedMesh.getIndices();\n    if ((indices === null || indices === void 0 ? void 0 : indices.length) === 0) {\n      indices = null;\n    }\n    let result;\n    const tmp0 = TmpVectors.Vector3[0];\n    const tmp1 = TmpVectors.Vector3[1];\n    const tmp2 = TmpVectors.Vector3[2];\n    if (useVerticesNormals) {\n      const normals = this.pickedMesh.getVerticesData(VertexBuffer.NormalKind);\n      let normal0 = indices ? Vector3.FromArrayToRef(normals, indices[this.faceId * 3] * 3, tmp0) : tmp0.copyFromFloats(normals[this.faceId * 3 * 3], normals[this.faceId * 3 * 3 + 1], normals[this.faceId * 3 * 3 + 2]);\n      let normal1 = indices ? Vector3.FromArrayToRef(normals, indices[this.faceId * 3 + 1] * 3, tmp1) : tmp1.copyFromFloats(normals[(this.faceId * 3 + 1) * 3], normals[(this.faceId * 3 + 1) * 3 + 1], normals[(this.faceId * 3 + 1) * 3 + 2]);\n      let normal2 = indices ? Vector3.FromArrayToRef(normals, indices[this.faceId * 3 + 2] * 3, tmp2) : tmp2.copyFromFloats(normals[(this.faceId * 3 + 2) * 3], normals[(this.faceId * 3 + 2) * 3 + 1], normals[(this.faceId * 3 + 2) * 3 + 2]);\n      normal0 = normal0.scale(this.bu);\n      normal1 = normal1.scale(this.bv);\n      normal2 = normal2.scale(1.0 - this.bu - this.bv);\n      result = new Vector3(normal0.x + normal1.x + normal2.x, normal0.y + normal1.y + normal2.y, normal0.z + normal1.z + normal2.z);\n    } else {\n      const positions = this.pickedMesh.getVerticesData(VertexBuffer.PositionKind);\n      const vertex1 = indices ? Vector3.FromArrayToRef(positions, indices[this.faceId * 3] * 3, tmp0) : tmp0.copyFromFloats(positions[this.faceId * 3 * 3], positions[this.faceId * 3 * 3 + 1], positions[this.faceId * 3 * 3 + 2]);\n      const vertex2 = indices ? Vector3.FromArrayToRef(positions, indices[this.faceId * 3 + 1] * 3, tmp1) : tmp1.copyFromFloats(positions[(this.faceId * 3 + 1) * 3], positions[(this.faceId * 3 + 1) * 3 + 1], positions[(this.faceId * 3 + 1) * 3 + 2]);\n      const vertex3 = indices ? Vector3.FromArrayToRef(positions, indices[this.faceId * 3 + 2] * 3, tmp2) : tmp2.copyFromFloats(positions[(this.faceId * 3 + 2) * 3], positions[(this.faceId * 3 + 2) * 3 + 1], positions[(this.faceId * 3 + 2) * 3 + 2]);\n      const p1p2 = vertex1.subtract(vertex2);\n      const p3p2 = vertex3.subtract(vertex2);\n      result = Vector3.Cross(p1p2, p3p2);\n    }\n    const transformNormalToWorld = (pickedMesh, n) => {\n      let wm = pickedMesh.getWorldMatrix();\n      if (pickedMesh.nonUniformScaling) {\n        TmpVectors.Matrix[0].copyFrom(wm);\n        wm = TmpVectors.Matrix[0];\n        wm.setTranslationFromFloats(0, 0, 0);\n        wm.invert();\n        wm.transposeToRef(TmpVectors.Matrix[1]);\n        wm = TmpVectors.Matrix[1];\n      }\n      Vector3.TransformNormalToRef(n, wm, n);\n    };\n    if (useWorldCoordinates) {\n      transformNormalToWorld(this.pickedMesh, result);\n    }\n    if (this.ray) {\n      const normalForDirectionChecking = TmpVectors.Vector3[0].copyFrom(result);\n      if (!useWorldCoordinates) {\n        // the normal has not been transformed to world space as part as the normal processing, so we must do it now\n        transformNormalToWorld(this.pickedMesh, normalForDirectionChecking);\n      }\n      // Flip the normal if the picking ray is in the same direction.\n      if (Vector3.Dot(normalForDirectionChecking, this.ray.direction) > 0) {\n        result.negateInPlace();\n      }\n    }\n    result.normalize();\n    return result;\n  }\n  /**\n   * Gets the texture coordinates of where the pick occurred\n   * @param uvSet The UV set to use to calculate the texture coordinates (default: VertexBuffer.UVKind)\n   * @returns The vector containing the coordinates of the texture\n   */\n  getTextureCoordinates(uvSet = VertexBuffer.UVKind) {\n    if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(uvSet)) {\n      return null;\n    }\n    const indices = this.pickedMesh.getIndices();\n    if (!indices) {\n      return null;\n    }\n    const uvs = this.pickedMesh.getVerticesData(uvSet);\n    if (!uvs) {\n      return null;\n    }\n    let uv0 = Vector2.FromArray(uvs, indices[this.faceId * 3] * 2);\n    let uv1 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 1] * 2);\n    let uv2 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 2] * 2);\n    uv0 = uv0.scale(this.bu);\n    uv1 = uv1.scale(this.bv);\n    uv2 = uv2.scale(1.0 - this.bu - this.bv);\n    return new Vector2(uv0.x + uv1.x + uv2.x, uv0.y + uv1.y + uv2.y);\n  }\n}","map":{"version":3,"names":["Vector3","Vector2","TmpVectors","VertexBuffer","PickingInfo","constructor","hit","distance","pickedPoint","pickedMesh","bu","bv","faceId","subMeshFaceId","subMeshId","pickedSprite","thinInstanceIndex","ray","originMesh","aimTransform","gripTransform","getNormal","useWorldCoordinates","useVerticesNormals","isVerticesDataPresent","NormalKind","indices","getIndices","length","result","tmp0","tmp1","tmp2","normals","getVerticesData","normal0","FromArrayToRef","copyFromFloats","normal1","normal2","scale","x","y","z","positions","PositionKind","vertex1","vertex2","vertex3","p1p2","subtract","p3p2","Cross","transformNormalToWorld","n","wm","getWorldMatrix","nonUniformScaling","Matrix","copyFrom","setTranslationFromFloats","invert","transposeToRef","TransformNormalToRef","normalForDirectionChecking","Dot","direction","negateInPlace","normalize","getTextureCoordinates","uvSet","UVKind","uvs","uv0","FromArray","uv1","uv2"],"sources":["../../../../dev/core/src/Collisions/pickingInfo.ts"],"sourcesContent":["import type { Nullable, FloatArray } from \"../types\";\r\nimport { Vector3, Vector2, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { Sprite } from \"../Sprites/sprite\";\r\n\r\nimport type { Ray } from \"../Culling/ray\";\r\n\r\n/**\r\n * Information about the result of picking within a scene\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/picking_collisions\r\n */\r\nexport class PickingInfo {\r\n    /**\r\n     * If the pick collided with an object\r\n     */\r\n    public hit = false;\r\n    /**\r\n     * Distance away where the pick collided\r\n     */\r\n    public distance = 0;\r\n    /**\r\n     * The location of pick collision\r\n     */\r\n    public pickedPoint: Nullable<Vector3> = null;\r\n    /**\r\n     * The mesh corresponding the pick collision\r\n     */\r\n    public pickedMesh: Nullable<AbstractMesh> = null;\r\n    /** (See getTextureCoordinates) The barycentric U coordinate that is used when calculating the texture coordinates of the collision.*/\r\n    public bu = 0;\r\n    /** (See getTextureCoordinates) The barycentric V coordinate that is used when calculating the texture coordinates of the collision.*/\r\n    public bv = 0;\r\n    /** The index of the face on the mesh that was picked, or the index of the Line if the picked Mesh is a LinesMesh */\r\n    public faceId = -1;\r\n    /** The index of the face on the subMesh that was picked, or the index of the Line if the picked Mesh is a LinesMesh */\r\n    public subMeshFaceId = -1;\r\n    /** Id of the submesh that was picked */\r\n    public subMeshId = 0;\r\n    /** If a sprite was picked, this will be the sprite the pick collided with */\r\n    public pickedSprite: Nullable<Sprite> = null;\r\n    /** If we are picking a mesh with thin instance, this will give you the picked thin instance */\r\n    public thinInstanceIndex = -1;\r\n    /**\r\n     * The ray that was used to perform the picking.\r\n     */\r\n    public ray: Nullable<Ray> = null;\r\n    /**\r\n     * If a mesh was used to do the picking (eg. 6dof controller) as a \"near interaction\", this will be populated.\r\n     */\r\n    public originMesh: Nullable<AbstractMesh> = null;\r\n    /**\r\n     * The aim-space transform of the input used for picking, if it is an XR input source.\r\n     */\r\n    public aimTransform: Nullable<TransformNode> = null;\r\n    /**\r\n     * The grip-space transform of the input used for picking, if it is an XR input source.\r\n     * Some XR sources, such as input coming from head mounted displays, do not have this.\r\n     */\r\n    public gripTransform: Nullable<TransformNode> = null;\r\n\r\n    /**\r\n     * Gets the normal corresponding to the face the pick collided with\r\n     * @param useWorldCoordinates If the resulting normal should be relative to the world (default: false)\r\n     * @param useVerticesNormals If the vertices normals should be used to calculate the normal instead of the normal map (default: true)\r\n     * @returns The normal corresponding to the face the pick collided with\r\n     * @remarks Note that the returned normal will always point towards the picking ray.\r\n     */\r\n    public getNormal(useWorldCoordinates = false, useVerticesNormals = true): Nullable<Vector3> {\r\n        if (!this.pickedMesh || (useVerticesNormals && !this.pickedMesh.isVerticesDataPresent(VertexBuffer.NormalKind))) {\r\n            return null;\r\n        }\r\n\r\n        let indices = this.pickedMesh.getIndices();\r\n\r\n        if (indices?.length === 0) {\r\n            indices = null;\r\n        }\r\n\r\n        let result: Vector3;\r\n\r\n        const tmp0 = TmpVectors.Vector3[0];\r\n        const tmp1 = TmpVectors.Vector3[1];\r\n        const tmp2 = TmpVectors.Vector3[2];\r\n\r\n        if (useVerticesNormals) {\r\n            const normals = <FloatArray>this.pickedMesh.getVerticesData(VertexBuffer.NormalKind);\r\n\r\n            let normal0 = indices\r\n                ? Vector3.FromArrayToRef(normals, indices[this.faceId * 3] * 3, tmp0)\r\n                : tmp0.copyFromFloats(normals[this.faceId * 3 * 3], normals[this.faceId * 3 * 3 + 1], normals[this.faceId * 3 * 3 + 2]);\r\n            let normal1 = indices\r\n                ? Vector3.FromArrayToRef(normals, indices[this.faceId * 3 + 1] * 3, tmp1)\r\n                : tmp1.copyFromFloats(normals[(this.faceId * 3 + 1) * 3], normals[(this.faceId * 3 + 1) * 3 + 1], normals[(this.faceId * 3 + 1) * 3 + 2]);\r\n            let normal2 = indices\r\n                ? Vector3.FromArrayToRef(normals, indices[this.faceId * 3 + 2] * 3, tmp2)\r\n                : tmp2.copyFromFloats(normals[(this.faceId * 3 + 2) * 3], normals[(this.faceId * 3 + 2) * 3 + 1], normals[(this.faceId * 3 + 2) * 3 + 2]);\r\n\r\n            normal0 = normal0.scale(this.bu);\r\n            normal1 = normal1.scale(this.bv);\r\n            normal2 = normal2.scale(1.0 - this.bu - this.bv);\r\n\r\n            result = new Vector3(normal0.x + normal1.x + normal2.x, normal0.y + normal1.y + normal2.y, normal0.z + normal1.z + normal2.z);\r\n        } else {\r\n            const positions = <FloatArray>this.pickedMesh.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n            const vertex1 = indices\r\n                ? Vector3.FromArrayToRef(positions, indices[this.faceId * 3] * 3, tmp0)\r\n                : tmp0.copyFromFloats(positions[this.faceId * 3 * 3], positions[this.faceId * 3 * 3 + 1], positions[this.faceId * 3 * 3 + 2]);\r\n            const vertex2 = indices\r\n                ? Vector3.FromArrayToRef(positions, indices[this.faceId * 3 + 1] * 3, tmp1)\r\n                : tmp1.copyFromFloats(positions[(this.faceId * 3 + 1) * 3], positions[(this.faceId * 3 + 1) * 3 + 1], positions[(this.faceId * 3 + 1) * 3 + 2]);\r\n            const vertex3 = indices\r\n                ? Vector3.FromArrayToRef(positions, indices[this.faceId * 3 + 2] * 3, tmp2)\r\n                : tmp2.copyFromFloats(positions[(this.faceId * 3 + 2) * 3], positions[(this.faceId * 3 + 2) * 3 + 1], positions[(this.faceId * 3 + 2) * 3 + 2]);\r\n\r\n            const p1p2 = vertex1.subtract(vertex2);\r\n            const p3p2 = vertex3.subtract(vertex2);\r\n\r\n            result = Vector3.Cross(p1p2, p3p2);\r\n        }\r\n\r\n        const transformNormalToWorld = (pickedMesh: AbstractMesh, n: Vector3) => {\r\n            let wm = pickedMesh.getWorldMatrix();\r\n\r\n            if (pickedMesh.nonUniformScaling) {\r\n                TmpVectors.Matrix[0].copyFrom(wm);\r\n                wm = TmpVectors.Matrix[0];\r\n                wm.setTranslationFromFloats(0, 0, 0);\r\n                wm.invert();\r\n                wm.transposeToRef(TmpVectors.Matrix[1]);\r\n\r\n                wm = TmpVectors.Matrix[1];\r\n            }\r\n\r\n            Vector3.TransformNormalToRef(n, wm, n);\r\n        };\r\n\r\n        if (useWorldCoordinates) {\r\n            transformNormalToWorld(this.pickedMesh, result);\r\n        }\r\n\r\n        if (this.ray) {\r\n            const normalForDirectionChecking = TmpVectors.Vector3[0].copyFrom(result);\r\n\r\n            if (!useWorldCoordinates) {\r\n                // the normal has not been transformed to world space as part as the normal processing, so we must do it now\r\n                transformNormalToWorld(this.pickedMesh, normalForDirectionChecking);\r\n            }\r\n\r\n            // Flip the normal if the picking ray is in the same direction.\r\n            if (Vector3.Dot(normalForDirectionChecking, this.ray.direction) > 0) {\r\n                result.negateInPlace();\r\n            }\r\n        }\r\n\r\n        result.normalize();\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Gets the texture coordinates of where the pick occurred\r\n     * @param uvSet The UV set to use to calculate the texture coordinates (default: VertexBuffer.UVKind)\r\n     * @returns The vector containing the coordinates of the texture\r\n     */\r\n    public getTextureCoordinates(uvSet = VertexBuffer.UVKind): Nullable<Vector2> {\r\n        if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(uvSet)) {\r\n            return null;\r\n        }\r\n\r\n        const indices = this.pickedMesh.getIndices();\r\n        if (!indices) {\r\n            return null;\r\n        }\r\n\r\n        const uvs = this.pickedMesh.getVerticesData(uvSet);\r\n        if (!uvs) {\r\n            return null;\r\n        }\r\n\r\n        let uv0 = Vector2.FromArray(uvs, indices[this.faceId * 3] * 2);\r\n        let uv1 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 1] * 2);\r\n        let uv2 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 2] * 2);\r\n\r\n        uv0 = uv0.scale(this.bu);\r\n        uv1 = uv1.scale(this.bv);\r\n        uv2 = uv2.scale(1.0 - this.bu - this.bv);\r\n\r\n        return new Vector2(uv0.x + uv1.x + uv2.x, uv0.y + uv1.y + uv2.y);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}