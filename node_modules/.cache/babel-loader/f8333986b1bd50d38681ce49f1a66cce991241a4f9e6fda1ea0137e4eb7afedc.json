{"ast":null,"code":"import { PhysicsShapeType } from \"./IPhysicsEnginePlugin.js\";\nimport { Matrix, Vector3, Quaternion, TmpVectors } from \"../../Maths/math.vector.js\";\n/**\n * PhysicsShape class.\n * This class is useful for creating a physics shape that can be used in a physics engine.\n * A Physic Shape determine how collision are computed. It must be attached to a body.\n */\nexport class PhysicsShape {\n  /**\n   * Constructs a new physics shape.\n   * @param options The options for the physics shape. These are:\n   *  * type: The type of the shape. This can be one of the following: SPHERE, BOX, CAPSULE, CYLINDER, CONVEX_HULL, MESH, HEIGHTFIELD, CONTAINER\n   *  * parameters: The parameters of the shape.\n   *  * pluginData: The plugin data of the shape. This is used if you already have a reference to the object on the plugin side.\n   * You need to specify either type or pluginData.\n   * @param scene The scene the shape belongs to.\n   *\n   * This code is useful for creating a new physics shape with the given type, options, and scene.\n   * It also checks that the physics engine and plugin version are correct.\n   * If not, it throws an error. This ensures that the shape is created with the correct parameters and is compatible with the physics engine.\n   */\n  constructor(options, scene) {\n    var _a;\n    /**\n     * V2 Physics plugin private data for single shape\n     */\n    this._pluginData = undefined;\n    this._isTrigger = false;\n    this._isDisposed = false;\n    if (!scene) {\n      return;\n    }\n    const physicsEngine = scene.getPhysicsEngine();\n    if (!physicsEngine) {\n      throw new Error(\"No Physics Engine available.\");\n    }\n    if (physicsEngine.getPluginVersion() != 2) {\n      throw new Error(\"Plugin version is incorrect. Expected version 2.\");\n    }\n    const physicsPlugin = physicsEngine.getPhysicsPlugin();\n    if (!physicsPlugin) {\n      throw new Error(\"No Physics Plugin available.\");\n    }\n    this._physicsPlugin = physicsPlugin;\n    if (options.pluginData !== undefined && options.pluginData !== null) {\n      this._pluginData = options.pluginData;\n      this._type = this._physicsPlugin.getShapeType(this);\n    } else if (options.type !== undefined && options.type !== null) {\n      this._type = options.type;\n      const parameters = (_a = options.parameters) !== null && _a !== void 0 ? _a : {};\n      this._physicsPlugin.initShape(this, options.type, parameters);\n    }\n  }\n  /**\n   * Returns the string \"PhysicsShape\".\n   * @returns \"PhysicsShape\"\n   */\n  getClassName() {\n    return \"PhysicsShape\";\n  }\n  /**\n   * Returns the type of the physics shape.\n   * @returns The type of the physics shape.\n   */\n  get type() {\n    return this._type;\n  }\n  /**\n   * Set the membership mask of a shape. This is a bitfield of arbitrary\n   * \"categories\" to which the shape is a member. This is used in combination\n   * with the collide mask to determine if this shape should collide with\n   * another.\n   *\n   * @param membershipMask Bitfield of categories of this shape.\n   */\n  set filterMembershipMask(membershipMask) {\n    this._physicsPlugin.setShapeFilterMembershipMask(this, membershipMask);\n  }\n  /**\n   * Get the membership mask of a shape.\n   * @returns Bitmask of categories which this shape is a member of.\n   */\n  get filterMembershipMask() {\n    return this._physicsPlugin.getShapeFilterMembershipMask(this);\n  }\n  /**\n   * Sets the collide mask of a shape. This is a bitfield of arbitrary\n   * \"categories\" to which this shape collides with. Given two shapes,\n   * the engine will check if the collide mask and membership overlap:\n   * shapeA.filterMembershipMask & shapeB.filterCollideMask\n   *\n   * If this value is zero (i.e. shapeB only collides with categories\n   * which shapeA is _not_ a member of) then the shapes will not collide.\n   *\n   * Note, the engine will also perform the same test with shapeA and\n   * shapeB swapped; the shapes will not collide if either shape has\n   * a collideMask which prevents collision with the other shape.\n   *\n   * @param collideMask Bitmask of categories this shape should collide with\n   */\n  set filterCollideMask(collideMask) {\n    this._physicsPlugin.setShapeFilterCollideMask(this, collideMask);\n  }\n  /**\n   *\n   * @returns Bitmask of categories that this shape should collide with\n   */\n  get filterCollideMask() {\n    return this._physicsPlugin.getShapeFilterCollideMask(this);\n  }\n  /**\n   *\n   * @param material\n   */\n  set material(material) {\n    this._physicsPlugin.setMaterial(this, material);\n    this._material = material;\n  }\n  /**\n   * Returns the material of the physics shape.\n   * @returns The material of the physics shape.\n   */\n  get material() {\n    return this._material;\n  }\n  /**\n   * Sets the density of the physics shape.\n   * @param density The density of the physics shape.\n   */\n  set density(density) {\n    this._physicsPlugin.setDensity(this, density);\n  }\n  /**\n   * Returns the density of the physics shape.\n   * @returns The density of the physics shape.\n   */\n  get density() {\n    return this._physicsPlugin.getDensity(this);\n  }\n  /**\n   * Utility to add a child shape to this container,\n   * automatically computing the relative transform between\n   * the container shape and the child instance.\n   *\n   * @param parentTransform The transform node associated with this shape\n   * @param newChild The new PhysicsShape to add\n   * @param childTransform The transform node associated with the child shape\n   */\n  addChildFromParent(parentTransform, newChild, childTransform) {\n    const childToWorld = childTransform.computeWorldMatrix(true);\n    const parentToWorld = parentTransform.computeWorldMatrix(true);\n    const childToParent = TmpVectors.Matrix[0];\n    childToWorld.multiplyToRef(Matrix.Invert(parentToWorld), childToParent);\n    const translation = TmpVectors.Vector3[0];\n    const rotation = TmpVectors.Quaternion[0];\n    const scale = TmpVectors.Vector3[1];\n    childToParent.decompose(scale, rotation, translation);\n    this._physicsPlugin.addChild(this, newChild, translation, rotation, scale);\n  }\n  /**\n   * Adds a child shape to a container with an optional transform\n   * @param newChild The new PhysicsShape to add\n   * @param translation Optional position of the child shape relative to this shape\n   * @param rotation Optional rotation of the child shape relative to this shape\n   * @param scale Optional scale of the child shape relative to this shape\n   */\n  addChild(newChild, translation, rotation, scale) {\n    this._physicsPlugin.addChild(this, newChild, translation, rotation, scale);\n  }\n  /**\n   * Removes a child shape from this shape.\n   * @param childIndex The index of the child shape to remove\n   */\n  removeChild(childIndex) {\n    this._physicsPlugin.removeChild(this, childIndex);\n  }\n  /**\n   * Returns the number of children of a physics shape.\n   * @returns The number of children of a physics shape.\n   */\n  getNumChildren() {\n    return this._physicsPlugin.getNumChildren(this);\n  }\n  /**\n   * Returns the bounding box of the physics shape.\n   * @returns The bounding box of the physics shape.\n   */\n  getBoundingBox() {\n    return this._physicsPlugin.getBoundingBox(this);\n  }\n  set isTrigger(isTrigger) {\n    if (this._isTrigger === isTrigger) {\n      return;\n    }\n    this._isTrigger = isTrigger;\n    this._physicsPlugin.setTrigger(this, isTrigger);\n  }\n  get isTrigger() {\n    return this._isTrigger;\n  }\n  /**\n   * Dispose the shape and release its associated resources.\n   */\n  dispose() {\n    if (this._isDisposed) {\n      return;\n    }\n    this._physicsPlugin.disposeShape(this);\n    this._isDisposed = true;\n  }\n}\n/**\n * Helper object to create a sphere shape\n */\nexport class PhysicsShapeSphere extends PhysicsShape {\n  /**\n   * Constructor for the Sphere Shape\n   * @param center local center of the sphere\n   * @param radius radius\n   * @param scene scene to attach to\n   */\n  constructor(center, radius, scene) {\n    super({\n      type: PhysicsShapeType.SPHERE,\n      parameters: {\n        center: center,\n        radius: radius\n      }\n    }, scene);\n  }\n  /**\n   * Derive an approximate sphere from the mesh.\n   * @param mesh node from which to derive the sphere shape\n   * @returns PhysicsShapeSphere\n   */\n  static FromMesh(mesh) {\n    const bounds = mesh.getBoundingInfo();\n    const centerLocal = bounds.boundingSphere.center;\n    const he = bounds.boundingBox.extendSize;\n    const radius = Math.max(he.x, he.y, he.z);\n    return new PhysicsShapeSphere(centerLocal, radius, mesh.getScene());\n  }\n}\n/**\n * Helper object to create a capsule shape\n */\nexport class PhysicsShapeCapsule extends PhysicsShape {\n  /**\n   *\n   * @param pointA Starting point that defines the capsule segment\n   * @param pointB ending point of that same segment\n   * @param radius radius\n   * @param scene scene to attach to\n   */\n  constructor(pointA, pointB, radius, scene) {\n    super({\n      type: PhysicsShapeType.CAPSULE,\n      parameters: {\n        pointA: pointA,\n        pointB: pointB,\n        radius: radius\n      }\n    }, scene);\n  }\n  /**\n   * Derive an approximate capsule from the mesh. Note, this is\n   * not the optimal bounding capsule.\n   * @param mesh Node from which to derive a cylinder shape\n   */\n  static FromMesh(mesh) {\n    const boundsLocal = mesh.getBoundingInfo();\n    const radius = boundsLocal.boundingBox.extendSize.x;\n    const pointFromCenter = new Vector3(0, boundsLocal.boundingBox.extendSize.y - radius, 0);\n    const pointA = boundsLocal.boundingBox.center.add(pointFromCenter);\n    const pointB = boundsLocal.boundingBox.center.subtract(pointFromCenter);\n    return new PhysicsShapeCapsule(pointA, pointB, radius, mesh.getScene());\n  }\n}\n/**\n * Helper object to create a cylinder shape\n */\nexport class PhysicsShapeCylinder extends PhysicsShape {\n  /**\n   *\n   * @param pointA Starting point that defines the cylinder segment\n   * @param pointB ending point of that same segment\n   * @param radius radius\n   * @param scene scene to attach to\n   */\n  constructor(pointA, pointB, radius, scene) {\n    super({\n      type: PhysicsShapeType.CYLINDER,\n      parameters: {\n        pointA: pointA,\n        pointB: pointB,\n        radius: radius\n      }\n    }, scene);\n  }\n  /**\n   * Derive an approximate cylinder from the mesh. Note, this is\n   * not the optimal bounding cylinder.\n   * @param mesh Node from which to derive a cylinder shape\n   */\n  static FromMesh(mesh) {\n    const boundsLocal = mesh.getBoundingInfo();\n    const radius = boundsLocal.boundingBox.extendSize.x;\n    const pointFromCenter = new Vector3(0, boundsLocal.boundingBox.extendSize.y, 0);\n    const pointA = boundsLocal.boundingBox.center.add(pointFromCenter);\n    const pointB = boundsLocal.boundingBox.center.subtract(pointFromCenter);\n    return new PhysicsShapeCylinder(pointA, pointB, radius, mesh.getScene());\n  }\n}\n/**\n * Helper object to create a box shape\n */\nexport class PhysicsShapeBox extends PhysicsShape {\n  /**\n   *\n   * @param center local center of the box\n   * @param rotation local orientation\n   * @param extents size of the box in each direction\n   * @param scene scene to attach to\n   */\n  constructor(center, rotation, extents, scene) {\n    super({\n      type: PhysicsShapeType.BOX,\n      parameters: {\n        center: center,\n        rotation: rotation,\n        extents: extents\n      }\n    }, scene);\n  }\n  /**\n   *\n   * @param mesh\n   * @returns PhysicsShapeBox\n   */\n  static FromMesh(mesh) {\n    const bounds = mesh.getBoundingInfo();\n    const centerLocal = bounds.boundingBox.center;\n    const extents = bounds.boundingBox.extendSize.scale(2.0); //<todo.eoin extendSize seems to really be half-extents?\n    return new PhysicsShapeBox(centerLocal, Quaternion.Identity(), extents, mesh.getScene());\n  }\n}\n/**\n * Helper object to create a convex hull shape\n */\nexport class PhysicsShapeConvexHull extends PhysicsShape {\n  /**\n   *\n   * @param mesh the mesh to be used as topology infos for the convex hull\n   * @param scene scene to attach to\n   */\n  constructor(mesh, scene) {\n    super({\n      type: PhysicsShapeType.CONVEX_HULL,\n      parameters: {\n        mesh: mesh\n      }\n    }, scene);\n  }\n}\n/**\n * Helper object to create a mesh shape\n */\nexport class PhysicsShapeMesh extends PhysicsShape {\n  /**\n   *\n   * @param mesh the mesh topology that will be used to create the shape\n   * @param scene scene to attach to\n   */\n  constructor(mesh, scene) {\n    super({\n      type: PhysicsShapeType.MESH,\n      parameters: {\n        mesh: mesh\n      }\n    }, scene);\n  }\n}\n/**\n * A shape container holds a variable number of shapes. Use AddChild to append to newly created parent container.\n */\nexport class PhysicsShapeContainer extends PhysicsShape {\n  /**\n   * Constructor of the Shape container\n   * @param scene scene to attach to\n   */\n  constructor(scene) {\n    super({\n      type: PhysicsShapeType.CONTAINER,\n      parameters: {}\n    }, scene);\n  }\n}","map":{"version":3,"names":["PhysicsShapeType","Matrix","Vector3","Quaternion","TmpVectors","PhysicsShape","constructor","options","scene","_pluginData","undefined","_isTrigger","_isDisposed","physicsEngine","getPhysicsEngine","Error","getPluginVersion","physicsPlugin","getPhysicsPlugin","_physicsPlugin","pluginData","_type","getShapeType","type","parameters","_a","initShape","getClassName","filterMembershipMask","membershipMask","setShapeFilterMembershipMask","getShapeFilterMembershipMask","filterCollideMask","collideMask","setShapeFilterCollideMask","getShapeFilterCollideMask","material","setMaterial","_material","density","setDensity","getDensity","addChildFromParent","parentTransform","newChild","childTransform","childToWorld","computeWorldMatrix","parentToWorld","childToParent","multiplyToRef","Invert","translation","rotation","scale","decompose","addChild","removeChild","childIndex","getNumChildren","getBoundingBox","isTrigger","setTrigger","dispose","disposeShape","PhysicsShapeSphere","center","radius","SPHERE","FromMesh","mesh","bounds","getBoundingInfo","centerLocal","boundingSphere","he","boundingBox","extendSize","Math","max","x","y","z","getScene","PhysicsShapeCapsule","pointA","pointB","CAPSULE","boundsLocal","pointFromCenter","add","subtract","PhysicsShapeCylinder","CYLINDER","PhysicsShapeBox","extents","BOX","Identity","PhysicsShapeConvexHull","CONVEX_HULL","PhysicsShapeMesh","MESH","PhysicsShapeContainer","CONTAINER"],"sources":["../../../../../dev/core/src/Physics/v2/physicsShape.ts"],"sourcesContent":["import type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { BoundingBox } from \"../../Culling/boundingBox\";\r\nimport { PhysicsShapeType } from \"./IPhysicsEnginePlugin\";\r\nimport type { IPhysicsEnginePluginV2, PhysicsShapeParameters } from \"./IPhysicsEnginePlugin\";\r\nimport type { PhysicsMaterial } from \"./physicsMaterial\";\r\nimport { Matrix, Vector3, Quaternion, TmpVectors } from \"../../Maths/math.vector\";\r\n\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Scene } from \"../../scene\";\r\n\r\n/**\r\n * Options for creating a physics shape\r\n */\r\nexport interface PhysicShapeOptions {\r\n    /**\r\n     * The type of the shape. This can be one of the following: SPHERE, BOX, CAPSULE, CYLINDER, CONVEX_HULL, MESH, HEIGHTFIELD, CONTAINER\r\n     */\r\n    type?: PhysicsShapeType;\r\n    /**\r\n     * The parameters of the shape. Varies depending of the shape type.\r\n     */\r\n    parameters?: PhysicsShapeParameters;\r\n    /**\r\n     * Reference to an already existing physics shape in the plugin.\r\n     */\r\n    pluginData?: any;\r\n}\r\n\r\n/**\r\n * PhysicsShape class.\r\n * This class is useful for creating a physics shape that can be used in a physics engine.\r\n * A Physic Shape determine how collision are computed. It must be attached to a body.\r\n */\r\nexport class PhysicsShape {\r\n    /**\r\n     * V2 Physics plugin private data for single shape\r\n     */\r\n    public _pluginData: any = undefined;\r\n    /**\r\n     * The V2 plugin used to create and manage this Physics Body\r\n     */\r\n    private _physicsPlugin: IPhysicsEnginePluginV2;\r\n\r\n    private _type: PhysicsShapeType;\r\n\r\n    private _material: PhysicsMaterial;\r\n\r\n    private _isTrigger: boolean = false;\r\n\r\n    private _isDisposed = false;\r\n\r\n    /**\r\n     * Constructs a new physics shape.\r\n     * @param options The options for the physics shape. These are:\r\n     *  * type: The type of the shape. This can be one of the following: SPHERE, BOX, CAPSULE, CYLINDER, CONVEX_HULL, MESH, HEIGHTFIELD, CONTAINER\r\n     *  * parameters: The parameters of the shape.\r\n     *  * pluginData: The plugin data of the shape. This is used if you already have a reference to the object on the plugin side.\r\n     * You need to specify either type or pluginData.\r\n     * @param scene The scene the shape belongs to.\r\n     *\r\n     * This code is useful for creating a new physics shape with the given type, options, and scene.\r\n     * It also checks that the physics engine and plugin version are correct.\r\n     * If not, it throws an error. This ensures that the shape is created with the correct parameters and is compatible with the physics engine.\r\n     */\r\n    constructor(options: PhysicShapeOptions, scene: Scene) {\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        const physicsEngine = scene.getPhysicsEngine();\r\n        if (!physicsEngine) {\r\n            throw new Error(\"No Physics Engine available.\");\r\n        }\r\n        if (physicsEngine.getPluginVersion() != 2) {\r\n            throw new Error(\"Plugin version is incorrect. Expected version 2.\");\r\n        }\r\n        const physicsPlugin = physicsEngine.getPhysicsPlugin();\r\n        if (!physicsPlugin) {\r\n            throw new Error(\"No Physics Plugin available.\");\r\n        }\r\n        this._physicsPlugin = physicsPlugin as IPhysicsEnginePluginV2;\r\n\r\n        if (options.pluginData !== undefined && options.pluginData !== null) {\r\n            this._pluginData = options.pluginData;\r\n            this._type = this._physicsPlugin.getShapeType(this);\r\n        } else if (options.type !== undefined && options.type !== null) {\r\n            this._type = options.type;\r\n            const parameters = options.parameters ?? {};\r\n            this._physicsPlugin.initShape(this, options.type, parameters);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"PhysicsShape\".\r\n     * @returns \"PhysicsShape\"\r\n     */\r\n    public getClassName() {\r\n        return \"PhysicsShape\";\r\n    }\r\n\r\n    /**\r\n     * Returns the type of the physics shape.\r\n     * @returns The type of the physics shape.\r\n     */\r\n    public get type(): PhysicsShapeType {\r\n        return this._type;\r\n    }\r\n\r\n    /**\r\n     * Set the membership mask of a shape. This is a bitfield of arbitrary\r\n     * \"categories\" to which the shape is a member. This is used in combination\r\n     * with the collide mask to determine if this shape should collide with\r\n     * another.\r\n     *\r\n     * @param membershipMask Bitfield of categories of this shape.\r\n     */\r\n    public set filterMembershipMask(membershipMask: number) {\r\n        this._physicsPlugin.setShapeFilterMembershipMask(this, membershipMask);\r\n    }\r\n\r\n    /**\r\n     * Get the membership mask of a shape.\r\n     * @returns Bitmask of categories which this shape is a member of.\r\n     */\r\n    public get filterMembershipMask(): number {\r\n        return this._physicsPlugin.getShapeFilterMembershipMask(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the collide mask of a shape. This is a bitfield of arbitrary\r\n     * \"categories\" to which this shape collides with. Given two shapes,\r\n     * the engine will check if the collide mask and membership overlap:\r\n     * shapeA.filterMembershipMask & shapeB.filterCollideMask\r\n     *\r\n     * If this value is zero (i.e. shapeB only collides with categories\r\n     * which shapeA is _not_ a member of) then the shapes will not collide.\r\n     *\r\n     * Note, the engine will also perform the same test with shapeA and\r\n     * shapeB swapped; the shapes will not collide if either shape has\r\n     * a collideMask which prevents collision with the other shape.\r\n     *\r\n     * @param collideMask Bitmask of categories this shape should collide with\r\n     */\r\n    public set filterCollideMask(collideMask: number) {\r\n        this._physicsPlugin.setShapeFilterCollideMask(this, collideMask);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @returns Bitmask of categories that this shape should collide with\r\n     */\r\n    public get filterCollideMask(): number {\r\n        return this._physicsPlugin.getShapeFilterCollideMask(this);\r\n    }\r\n    /**\r\n     *\r\n     * @param material\r\n     */\r\n    public set material(material: PhysicsMaterial) {\r\n        this._physicsPlugin.setMaterial(this, material);\r\n        this._material = material;\r\n    }\r\n\r\n    /**\r\n     * Returns the material of the physics shape.\r\n     * @returns The material of the physics shape.\r\n     */\r\n    public get material(): PhysicsMaterial {\r\n        return this._material;\r\n    }\r\n\r\n    /**\r\n     * Sets the density of the physics shape.\r\n     * @param density The density of the physics shape.\r\n     */\r\n    public set density(density: number) {\r\n        this._physicsPlugin.setDensity(this, density);\r\n    }\r\n\r\n    /**\r\n     * Returns the density of the physics shape.\r\n     * @returns The density of the physics shape.\r\n     */\r\n    public get density(): number {\r\n        return this._physicsPlugin.getDensity(this);\r\n    }\r\n\r\n    /**\r\n     * Utility to add a child shape to this container,\r\n     * automatically computing the relative transform between\r\n     * the container shape and the child instance.\r\n     *\r\n     * @param parentTransform The transform node associated with this shape\r\n     * @param newChild The new PhysicsShape to add\r\n     * @param childTransform The transform node associated with the child shape\r\n     */\r\n    public addChildFromParent(parentTransform: TransformNode, newChild: PhysicsShape, childTransform: TransformNode): void {\r\n        const childToWorld = childTransform.computeWorldMatrix(true);\r\n        const parentToWorld = parentTransform.computeWorldMatrix(true);\r\n        const childToParent = TmpVectors.Matrix[0];\r\n        childToWorld.multiplyToRef(Matrix.Invert(parentToWorld), childToParent);\r\n        const translation = TmpVectors.Vector3[0];\r\n        const rotation = TmpVectors.Quaternion[0];\r\n        const scale = TmpVectors.Vector3[1];\r\n        childToParent.decompose(scale, rotation, translation);\r\n        this._physicsPlugin.addChild(this, newChild, translation, rotation, scale);\r\n    }\r\n\r\n    /**\r\n     * Adds a child shape to a container with an optional transform\r\n     * @param newChild The new PhysicsShape to add\r\n     * @param translation Optional position of the child shape relative to this shape\r\n     * @param rotation Optional rotation of the child shape relative to this shape\r\n     * @param scale Optional scale of the child shape relative to this shape\r\n     */\r\n    public addChild(newChild: PhysicsShape, translation?: Vector3, rotation?: Quaternion, scale?: Vector3): void {\r\n        this._physicsPlugin.addChild(this, newChild, translation, rotation, scale);\r\n    }\r\n\r\n    /**\r\n     * Removes a child shape from this shape.\r\n     * @param childIndex The index of the child shape to remove\r\n     */\r\n    public removeChild(childIndex: number): void {\r\n        this._physicsPlugin.removeChild(this, childIndex);\r\n    }\r\n\r\n    /**\r\n     * Returns the number of children of a physics shape.\r\n     * @returns The number of children of a physics shape.\r\n     */\r\n    public getNumChildren(): number {\r\n        return this._physicsPlugin.getNumChildren(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the bounding box of the physics shape.\r\n     * @returns The bounding box of the physics shape.\r\n     */\r\n    public getBoundingBox(): BoundingBox {\r\n        return this._physicsPlugin.getBoundingBox(this);\r\n    }\r\n\r\n    public set isTrigger(isTrigger: boolean) {\r\n        if (this._isTrigger === isTrigger) {\r\n            return;\r\n        }\r\n        this._isTrigger = isTrigger;\r\n        this._physicsPlugin.setTrigger(this, isTrigger);\r\n    }\r\n\r\n    public get isTrigger(): boolean {\r\n        return this._isTrigger;\r\n    }\r\n\r\n    /**\r\n     * Dispose the shape and release its associated resources.\r\n     */\r\n    public dispose() {\r\n        if (this._isDisposed) {\r\n            return;\r\n        }\r\n        this._physicsPlugin.disposeShape(this);\r\n        this._isDisposed = true;\r\n    }\r\n}\r\n\r\n/**\r\n * Helper object to create a sphere shape\r\n */\r\nexport class PhysicsShapeSphere extends PhysicsShape {\r\n    /**\r\n     * Constructor for the Sphere Shape\r\n     * @param center local center of the sphere\r\n     * @param radius radius\r\n     * @param scene scene to attach to\r\n     */\r\n    constructor(center: Vector3, radius: number, scene: Scene) {\r\n        super({ type: PhysicsShapeType.SPHERE, parameters: { center: center, radius: radius } }, scene);\r\n    }\r\n\r\n    /**\r\n     * Derive an approximate sphere from the mesh.\r\n     * @param mesh node from which to derive the sphere shape\r\n     * @returns PhysicsShapeSphere\r\n     */\r\n    static FromMesh(mesh: AbstractMesh) {\r\n        const bounds = mesh.getBoundingInfo();\r\n        const centerLocal = bounds.boundingSphere.center;\r\n        const he = bounds.boundingBox.extendSize;\r\n        const radius = Math.max(he.x, he.y, he.z);\r\n        return new PhysicsShapeSphere(centerLocal, radius, mesh.getScene());\r\n    }\r\n}\r\n\r\n/**\r\n * Helper object to create a capsule shape\r\n */\r\nexport class PhysicsShapeCapsule extends PhysicsShape {\r\n    /**\r\n     *\r\n     * @param pointA Starting point that defines the capsule segment\r\n     * @param pointB ending point of that same segment\r\n     * @param radius radius\r\n     * @param scene scene to attach to\r\n     */\r\n    constructor(pointA: Vector3, pointB: Vector3, radius: number, scene: Scene) {\r\n        super({ type: PhysicsShapeType.CAPSULE, parameters: { pointA: pointA, pointB: pointB, radius: radius } }, scene);\r\n    }\r\n\r\n    /**\r\n     * Derive an approximate capsule from the mesh. Note, this is\r\n     * not the optimal bounding capsule.\r\n     * @param mesh Node from which to derive a cylinder shape\r\n     */\r\n    static FromMesh(mesh: AbstractMesh): PhysicsShapeCapsule {\r\n        const boundsLocal = mesh.getBoundingInfo();\r\n        const radius = boundsLocal.boundingBox.extendSize.x;\r\n        const pointFromCenter = new Vector3(0, boundsLocal.boundingBox.extendSize.y - radius, 0);\r\n        const pointA = boundsLocal.boundingBox.center.add(pointFromCenter);\r\n        const pointB = boundsLocal.boundingBox.center.subtract(pointFromCenter);\r\n        return new PhysicsShapeCapsule(pointA, pointB, radius, mesh.getScene());\r\n    }\r\n}\r\n\r\n/**\r\n * Helper object to create a cylinder shape\r\n */\r\nexport class PhysicsShapeCylinder extends PhysicsShape {\r\n    /**\r\n     *\r\n     * @param pointA Starting point that defines the cylinder segment\r\n     * @param pointB ending point of that same segment\r\n     * @param radius radius\r\n     * @param scene scene to attach to\r\n     */\r\n    constructor(pointA: Vector3, pointB: Vector3, radius: number, scene: Scene) {\r\n        super({ type: PhysicsShapeType.CYLINDER, parameters: { pointA: pointA, pointB: pointB, radius: radius } }, scene);\r\n    }\r\n\r\n    /**\r\n     * Derive an approximate cylinder from the mesh. Note, this is\r\n     * not the optimal bounding cylinder.\r\n     * @param mesh Node from which to derive a cylinder shape\r\n     */\r\n    static FromMesh(mesh: AbstractMesh): PhysicsShapeCylinder {\r\n        const boundsLocal = mesh.getBoundingInfo();\r\n        const radius = boundsLocal.boundingBox.extendSize.x;\r\n        const pointFromCenter = new Vector3(0, boundsLocal.boundingBox.extendSize.y, 0);\r\n        const pointA = boundsLocal.boundingBox.center.add(pointFromCenter);\r\n        const pointB = boundsLocal.boundingBox.center.subtract(pointFromCenter);\r\n        return new PhysicsShapeCylinder(pointA, pointB, radius, mesh.getScene());\r\n    }\r\n}\r\n\r\n/**\r\n * Helper object to create a box shape\r\n */\r\nexport class PhysicsShapeBox extends PhysicsShape {\r\n    /**\r\n     *\r\n     * @param center local center of the box\r\n     * @param rotation local orientation\r\n     * @param extents size of the box in each direction\r\n     * @param scene scene to attach to\r\n     */\r\n    constructor(center: Vector3, rotation: Quaternion, extents: Vector3, scene: Scene) {\r\n        super({ type: PhysicsShapeType.BOX, parameters: { center: center, rotation: rotation, extents: extents } }, scene);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param mesh\r\n     * @returns PhysicsShapeBox\r\n     */\r\n    static FromMesh(mesh: AbstractMesh): PhysicsShapeBox {\r\n        const bounds = mesh.getBoundingInfo();\r\n        const centerLocal = bounds.boundingBox.center;\r\n        const extents = bounds.boundingBox.extendSize.scale(2.0); //<todo.eoin extendSize seems to really be half-extents?\r\n        return new PhysicsShapeBox(centerLocal, Quaternion.Identity(), extents, mesh.getScene());\r\n    }\r\n}\r\n\r\n/**\r\n * Helper object to create a convex hull shape\r\n */\r\nexport class PhysicsShapeConvexHull extends PhysicsShape {\r\n    /**\r\n     *\r\n     * @param mesh the mesh to be used as topology infos for the convex hull\r\n     * @param scene scene to attach to\r\n     */\r\n    constructor(mesh: Mesh, scene: Scene) {\r\n        super({ type: PhysicsShapeType.CONVEX_HULL, parameters: { mesh: mesh } }, scene);\r\n    }\r\n}\r\n\r\n/**\r\n * Helper object to create a mesh shape\r\n */\r\nexport class PhysicsShapeMesh extends PhysicsShape {\r\n    /**\r\n     *\r\n     * @param mesh the mesh topology that will be used to create the shape\r\n     * @param scene scene to attach to\r\n     */\r\n    constructor(mesh: Mesh, scene: Scene) {\r\n        super({ type: PhysicsShapeType.MESH, parameters: { mesh: mesh } }, scene);\r\n    }\r\n}\r\n\r\n/**\r\n * A shape container holds a variable number of shapes. Use AddChild to append to newly created parent container.\r\n */\r\nexport class PhysicsShapeContainer extends PhysicsShape {\r\n    /**\r\n     * Constructor of the Shape container\r\n     * @param scene scene to attach to\r\n     */\r\n    constructor(scene: Scene) {\r\n        super({ type: PhysicsShapeType.CONTAINER, parameters: {} }, scene);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}