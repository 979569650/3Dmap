{"ast":null,"code":"import { Vector2, Vector3 } from \"../Maths/math.vector.js\";\nimport { ImageProcessingConfigurationDefines } from \"../Materials/imageProcessingConfiguration.js\";\nimport { BoxParticleEmitter, PointParticleEmitter, HemisphericParticleEmitter, SphereParticleEmitter, SphereDirectedParticleEmitter, CylinderParticleEmitter, CylinderDirectedParticleEmitter, ConeParticleEmitter } from \"../Particles/EmitterTypes/index.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport \"../Engines/Extensions/engine.dynamicBuffer.js\";\n/**\n * This represents the base class for particle system in Babylon.\n * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\n * Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.\n * @example https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro\n */\nexport class BaseParticleSystem {\n  /**\n   * Gets or sets a texture used to add random noise to particle positions\n   */\n  get noiseTexture() {\n    return this._noiseTexture;\n  }\n  set noiseTexture(value) {\n    if (this._noiseTexture === value) {\n      return;\n    }\n    this._noiseTexture = value;\n    this._reset();\n  }\n  /**\n   * Gets or sets whether an animation sprite sheet is enabled or not on the particle system\n   */\n  get isAnimationSheetEnabled() {\n    return this._isAnimationSheetEnabled;\n  }\n  set isAnimationSheetEnabled(value) {\n    if (this._isAnimationSheetEnabled == value) {\n      return;\n    }\n    this._isAnimationSheetEnabled = value;\n    this._reset();\n  }\n  /**\n   * Gets or sets a boolean enabling the use of logarithmic depth buffers, which is good for wide depth buffers.\n   */\n  get useLogarithmicDepth() {\n    return this._useLogarithmicDepth;\n  }\n  set useLogarithmicDepth(value) {\n    this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;\n  }\n  /**\n   * Get hosting scene\n   * @returns the scene\n   */\n  getScene() {\n    return this._scene;\n  }\n  _hasTargetStopDurationDependantGradient() {\n    return this._startSizeGradients && this._startSizeGradients.length > 0 || this._emitRateGradients && this._emitRateGradients.length > 0 || this._lifeTimeGradients && this._lifeTimeGradients.length > 0;\n  }\n  /**\n   * Gets the current list of drag gradients.\n   * You must use addDragGradient and removeDragGradient to update this list\n   * @returns the list of drag gradients\n   */\n  getDragGradients() {\n    return this._dragGradients;\n  }\n  /**\n   * Gets the current list of limit velocity gradients.\n   * You must use addLimitVelocityGradient and removeLimitVelocityGradient to update this list\n   * @returns the list of limit velocity gradients\n   */\n  getLimitVelocityGradients() {\n    return this._limitVelocityGradients;\n  }\n  /**\n   * Gets the current list of color gradients.\n   * You must use addColorGradient and removeColorGradient to update this list\n   * @returns the list of color gradients\n   */\n  getColorGradients() {\n    return this._colorGradients;\n  }\n  /**\n   * Gets the current list of size gradients.\n   * You must use addSizeGradient and removeSizeGradient to update this list\n   * @returns the list of size gradients\n   */\n  getSizeGradients() {\n    return this._sizeGradients;\n  }\n  /**\n   * Gets the current list of color remap gradients.\n   * You must use addColorRemapGradient and removeColorRemapGradient to update this list\n   * @returns the list of color remap gradients\n   */\n  getColorRemapGradients() {\n    return this._colorRemapGradients;\n  }\n  /**\n   * Gets the current list of alpha remap gradients.\n   * You must use addAlphaRemapGradient and removeAlphaRemapGradient to update this list\n   * @returns the list of alpha remap gradients\n   */\n  getAlphaRemapGradients() {\n    return this._alphaRemapGradients;\n  }\n  /**\n   * Gets the current list of life time gradients.\n   * You must use addLifeTimeGradient and removeLifeTimeGradient to update this list\n   * @returns the list of life time gradients\n   */\n  getLifeTimeGradients() {\n    return this._lifeTimeGradients;\n  }\n  /**\n   * Gets the current list of angular speed gradients.\n   * You must use addAngularSpeedGradient and removeAngularSpeedGradient to update this list\n   * @returns the list of angular speed gradients\n   */\n  getAngularSpeedGradients() {\n    return this._angularSpeedGradients;\n  }\n  /**\n   * Gets the current list of velocity gradients.\n   * You must use addVelocityGradient and removeVelocityGradient to update this list\n   * @returns the list of velocity gradients\n   */\n  getVelocityGradients() {\n    return this._velocityGradients;\n  }\n  /**\n   * Gets the current list of start size gradients.\n   * You must use addStartSizeGradient and removeStartSizeGradient to update this list\n   * @returns the list of start size gradients\n   */\n  getStartSizeGradients() {\n    return this._startSizeGradients;\n  }\n  /**\n   * Gets the current list of emit rate gradients.\n   * You must use addEmitRateGradient and removeEmitRateGradient to update this list\n   * @returns the list of emit rate gradients\n   */\n  getEmitRateGradients() {\n    return this._emitRateGradients;\n  }\n  /**\n   * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\n   * This only works when particleEmitterTyps is a BoxParticleEmitter\n   */\n  get direction1() {\n    if (this.particleEmitterType.direction1) {\n      return this.particleEmitterType.direction1;\n    }\n    return Vector3.Zero();\n  }\n  set direction1(value) {\n    if (this.particleEmitterType.direction1) {\n      this.particleEmitterType.direction1 = value;\n    }\n  }\n  /**\n   * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\n   * This only works when particleEmitterTyps is a BoxParticleEmitter\n   */\n  get direction2() {\n    if (this.particleEmitterType.direction2) {\n      return this.particleEmitterType.direction2;\n    }\n    return Vector3.Zero();\n  }\n  set direction2(value) {\n    if (this.particleEmitterType.direction2) {\n      this.particleEmitterType.direction2 = value;\n    }\n  }\n  /**\n   * Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.\n   * This only works when particleEmitterTyps is a BoxParticleEmitter\n   */\n  get minEmitBox() {\n    if (this.particleEmitterType.minEmitBox) {\n      return this.particleEmitterType.minEmitBox;\n    }\n    return Vector3.Zero();\n  }\n  set minEmitBox(value) {\n    if (this.particleEmitterType.minEmitBox) {\n      this.particleEmitterType.minEmitBox = value;\n    }\n  }\n  /**\n   * Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.\n   * This only works when particleEmitterTyps is a BoxParticleEmitter\n   */\n  get maxEmitBox() {\n    if (this.particleEmitterType.maxEmitBox) {\n      return this.particleEmitterType.maxEmitBox;\n    }\n    return Vector3.Zero();\n  }\n  set maxEmitBox(value) {\n    if (this.particleEmitterType.maxEmitBox) {\n      this.particleEmitterType.maxEmitBox = value;\n    }\n  }\n  /**\n   * Gets or sets the billboard mode to use when isBillboardBased = true.\n   * Value can be: ParticleSystem.BILLBOARDMODE_ALL, ParticleSystem.BILLBOARDMODE_Y, ParticleSystem.BILLBOARDMODE_STRETCHED\n   */\n  get billboardMode() {\n    return this._billboardMode;\n  }\n  set billboardMode(value) {\n    if (this._billboardMode === value) {\n      return;\n    }\n    this._billboardMode = value;\n    this._reset();\n  }\n  /**\n   * Gets or sets a boolean indicating if the particles must be rendered as billboard or aligned with the direction\n   */\n  get isBillboardBased() {\n    return this._isBillboardBased;\n  }\n  set isBillboardBased(value) {\n    if (this._isBillboardBased === value) {\n      return;\n    }\n    this._isBillboardBased = value;\n    this._reset();\n  }\n  /**\n   * Gets the image processing configuration used either in this material.\n   */\n  get imageProcessingConfiguration() {\n    return this._imageProcessingConfiguration;\n  }\n  /**\n   * Sets the Default image processing configuration used either in the this material.\n   *\n   * If sets to null, the scene one is in use.\n   */\n  set imageProcessingConfiguration(value) {\n    this._attachImageProcessingConfiguration(value);\n  }\n  /**\n   * Attaches a new image processing configuration to the Standard Material.\n   * @param configuration\n   */\n  _attachImageProcessingConfiguration(configuration) {\n    if (configuration === this._imageProcessingConfiguration) {\n      return;\n    }\n    // Pick the scene configuration if needed.\n    if (!configuration && this._scene) {\n      this._imageProcessingConfiguration = this._scene.imageProcessingConfiguration;\n    } else {\n      this._imageProcessingConfiguration = configuration;\n    }\n  }\n  /** @internal */\n  _reset() {}\n  /**\n   * @internal\n   */\n  _removeGradientAndTexture(gradient, gradients, texture) {\n    if (!gradients) {\n      return this;\n    }\n    let index = 0;\n    for (const valueGradient of gradients) {\n      if (valueGradient.gradient === gradient) {\n        gradients.splice(index, 1);\n        break;\n      }\n      index++;\n    }\n    if (texture) {\n      texture.dispose();\n    }\n    return this;\n  }\n  /**\n   * Instantiates a particle system.\n   * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\n   * @param name The name of the particle system\n   */\n  constructor(name) {\n    /**\n     * List of animations used by the particle system.\n     */\n    this.animations = [];\n    /**\n     * The rendering group used by the Particle system to chose when to render.\n     */\n    this.renderingGroupId = 0;\n    /**\n     * The emitter represents the Mesh or position we are attaching the particle system to.\n     */\n    this.emitter = Vector3.Zero();\n    /**\n     * The maximum number of particles to emit per frame\n     */\n    this.emitRate = 10;\n    /**\n     * If you want to launch only a few particles at once, that can be done, as well.\n     */\n    this.manualEmitCount = -1;\n    /**\n     * The overall motion speed (0.01 is default update speed, faster updates = faster animation)\n     */\n    this.updateSpeed = 0.01;\n    /**\n     * The amount of time the particle system is running (depends of the overall update speed).\n     */\n    this.targetStopDuration = 0;\n    /**\n     * Specifies whether the particle system will be disposed once it reaches the end of the animation.\n     */\n    this.disposeOnStop = false;\n    /**\n     * Minimum power of emitting particles.\n     */\n    this.minEmitPower = 1;\n    /**\n     * Maximum power of emitting particles.\n     */\n    this.maxEmitPower = 1;\n    /**\n     * Minimum life time of emitting particles.\n     */\n    this.minLifeTime = 1;\n    /**\n     * Maximum life time of emitting particles.\n     */\n    this.maxLifeTime = 1;\n    /**\n     * Minimum Size of emitting particles.\n     */\n    this.minSize = 1;\n    /**\n     * Maximum Size of emitting particles.\n     */\n    this.maxSize = 1;\n    /**\n     * Minimum scale of emitting particles on X axis.\n     */\n    this.minScaleX = 1;\n    /**\n     * Maximum scale of emitting particles on X axis.\n     */\n    this.maxScaleX = 1;\n    /**\n     * Minimum scale of emitting particles on Y axis.\n     */\n    this.minScaleY = 1;\n    /**\n     * Maximum scale of emitting particles on Y axis.\n     */\n    this.maxScaleY = 1;\n    /**\n     * Gets or sets the minimal initial rotation in radians.\n     */\n    this.minInitialRotation = 0;\n    /**\n     * Gets or sets the maximal initial rotation in radians.\n     */\n    this.maxInitialRotation = 0;\n    /**\n     * Minimum angular speed of emitting particles (Z-axis rotation for each particle).\n     */\n    this.minAngularSpeed = 0;\n    /**\n     * Maximum angular speed of emitting particles (Z-axis rotation for each particle).\n     */\n    this.maxAngularSpeed = 0;\n    /**\n     * The layer mask we are rendering the particles through.\n     */\n    this.layerMask = 0x0fffffff;\n    /**\n     * This can help using your own shader to render the particle system.\n     * The according effect will be created\n     */\n    this.customShader = null;\n    /**\n     * By default particle system starts as soon as they are created. This prevents the\n     * automatic start to happen and let you decide when to start emitting particles.\n     */\n    this.preventAutoStart = false;\n    /** @internal */\n    this._wasDispatched = false;\n    this._rootUrl = \"\";\n    /** Gets or sets the strength to apply to the noise value (default is (10, 10, 10)) */\n    this.noiseStrength = new Vector3(10, 10, 10);\n    /**\n     * Callback triggered when the particle animation is ending.\n     */\n    this.onAnimationEnd = null;\n    /**\n     * Blend mode use to render the particle, it can be either ParticleSystem.BLENDMODE_ONEONE or ParticleSystem.BLENDMODE_STANDARD.\n     */\n    this.blendMode = BaseParticleSystem.BLENDMODE_ONEONE;\n    /**\n     * Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls\n     * to override the particles.\n     */\n    this.forceDepthWrite = false;\n    /** Gets or sets a value indicating how many cycles (or frames) must be executed before first rendering (this value has to be set before starting the system). Default is 0 */\n    this.preWarmCycles = 0;\n    /** Gets or sets a value indicating the time step multiplier to use in pre-warm mode (default is 1) */\n    this.preWarmStepOffset = 1;\n    /**\n     * If using a spritesheet (isAnimationSheetEnabled) defines the speed of the sprite loop (default is 1 meaning the animation will play once during the entire particle lifetime)\n     */\n    this.spriteCellChangeSpeed = 1;\n    /**\n     * If using a spritesheet (isAnimationSheetEnabled) defines the first sprite cell to display\n     */\n    this.startSpriteCellID = 0;\n    /**\n     * If using a spritesheet (isAnimationSheetEnabled) defines the last sprite cell to display\n     */\n    this.endSpriteCellID = 0;\n    /**\n     * If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell width to use\n     */\n    this.spriteCellWidth = 0;\n    /**\n     * If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell height to use\n     */\n    this.spriteCellHeight = 0;\n    /**\n     * If using a spritesheet (isAnimationSheetEnabled), defines wether the sprite animation is looping\n     */\n    this.spriteCellLoop = true;\n    /**\n     * This allows the system to random pick the start cell ID between startSpriteCellID and endSpriteCellID\n     */\n    this.spriteRandomStartCell = false;\n    /** Gets or sets a Vector2 used to move the pivot (by default (0,0)) */\n    this.translationPivot = new Vector2(0, 0);\n    /**\n     * Gets or sets a boolean indicating that hosted animations (in the system.animations array) must be started when system.start() is called\n     */\n    this.beginAnimationOnStart = false;\n    /**\n     * Gets or sets the frame to start the animation from when beginAnimationOnStart is true\n     */\n    this.beginAnimationFrom = 0;\n    /**\n     * Gets or sets the frame to end the animation on when beginAnimationOnStart is true\n     */\n    this.beginAnimationTo = 60;\n    /**\n     * Gets or sets a boolean indicating if animations must loop when beginAnimationOnStart is true\n     */\n    this.beginAnimationLoop = false;\n    /**\n     * Gets or sets a world offset applied to all particles\n     */\n    this.worldOffset = new Vector3(0, 0, 0);\n    this._useLogarithmicDepth = false;\n    /**\n     * You can use gravity if you want to give an orientation to your particles.\n     */\n    this.gravity = Vector3.Zero();\n    this._colorGradients = null;\n    this._sizeGradients = null;\n    this._lifeTimeGradients = null;\n    this._angularSpeedGradients = null;\n    this._velocityGradients = null;\n    this._limitVelocityGradients = null;\n    this._dragGradients = null;\n    this._emitRateGradients = null;\n    this._startSizeGradients = null;\n    this._rampGradients = null;\n    this._colorRemapGradients = null;\n    this._alphaRemapGradients = null;\n    /**\n     * Defines the delay in milliseconds before starting the system (0 by default)\n     */\n    this.startDelay = 0;\n    /** Gets or sets a value indicating the damping to apply if the limit velocity factor is reached */\n    this.limitVelocityDamping = 0.4;\n    /**\n     * Random color of each particle after it has been emitted, between color1 and color2 vectors\n     */\n    this.color1 = new Color4(1.0, 1.0, 1.0, 1.0);\n    /**\n     * Random color of each particle after it has been emitted, between color1 and color2 vectors\n     */\n    this.color2 = new Color4(1.0, 1.0, 1.0, 1.0);\n    /**\n     * Color the particle will have at the end of its lifetime\n     */\n    this.colorDead = new Color4(0, 0, 0, 1.0);\n    /**\n     * An optional mask to filter some colors out of the texture, or filter a part of the alpha channel\n     */\n    this.textureMask = new Color4(1.0, 1.0, 1.0, 1.0);\n    /** @internal */\n    this._isSubEmitter = false;\n    /** @internal */\n    this._billboardMode = 7;\n    /** @internal */\n    this._isBillboardBased = true;\n    /**\n     * Local cache of defines for image processing.\n     */\n    this._imageProcessingConfigurationDefines = new ImageProcessingConfigurationDefines();\n    this.id = name;\n    this.name = name;\n  }\n  /**\n   * Creates a Point Emitter for the particle system (emits directly from the emitter position)\n   * @param direction1 Particles are emitted between the direction1 and direction2 from within the box\n   * @param direction2 Particles are emitted between the direction1 and direction2 from within the box\n   * @returns the emitter\n   */\n  createPointEmitter(direction1, direction2) {\n    const particleEmitter = new PointParticleEmitter();\n    particleEmitter.direction1 = direction1;\n    particleEmitter.direction2 = direction2;\n    this.particleEmitterType = particleEmitter;\n    return particleEmitter;\n  }\n  /**\n   * Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)\n   * @param radius The radius of the hemisphere to emit from\n   * @param radiusRange The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius\n   * @returns the emitter\n   */\n  createHemisphericEmitter(radius = 1, radiusRange = 1) {\n    const particleEmitter = new HemisphericParticleEmitter(radius, radiusRange);\n    this.particleEmitterType = particleEmitter;\n    return particleEmitter;\n  }\n  /**\n   * Creates a Sphere Emitter for the particle system (emits along the sphere radius)\n   * @param radius The radius of the sphere to emit from\n   * @param radiusRange The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius\n   * @returns the emitter\n   */\n  createSphereEmitter(radius = 1, radiusRange = 1) {\n    const particleEmitter = new SphereParticleEmitter(radius, radiusRange);\n    this.particleEmitterType = particleEmitter;\n    return particleEmitter;\n  }\n  /**\n   * Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)\n   * @param radius The radius of the sphere to emit from\n   * @param direction1 Particles are emitted between the direction1 and direction2 from within the sphere\n   * @param direction2 Particles are emitted between the direction1 and direction2 from within the sphere\n   * @returns the emitter\n   */\n  createDirectedSphereEmitter(radius = 1, direction1 = new Vector3(0, 1.0, 0), direction2 = new Vector3(0, 1.0, 0)) {\n    const particleEmitter = new SphereDirectedParticleEmitter(radius, direction1, direction2);\n    this.particleEmitterType = particleEmitter;\n    return particleEmitter;\n  }\n  /**\n   * Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)\n   * @param radius The radius of the emission cylinder\n   * @param height The height of the emission cylinder\n   * @param radiusRange The range of emission [0-1] 0 Surface only, 1 Entire Radius\n   * @param directionRandomizer How much to randomize the particle direction [0-1]\n   * @returns the emitter\n   */\n  createCylinderEmitter(radius = 1, height = 1, radiusRange = 1, directionRandomizer = 0) {\n    const particleEmitter = new CylinderParticleEmitter(radius, height, radiusRange, directionRandomizer);\n    this.particleEmitterType = particleEmitter;\n    return particleEmitter;\n  }\n  /**\n   * Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)\n   * @param radius The radius of the cylinder to emit from\n   * @param height The height of the emission cylinder\n   * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\n   * @param direction1 Particles are emitted between the direction1 and direction2 from within the cylinder\n   * @param direction2 Particles are emitted between the direction1 and direction2 from within the cylinder\n   * @returns the emitter\n   */\n  createDirectedCylinderEmitter(radius = 1, height = 1, radiusRange = 1, direction1 = new Vector3(0, 1.0, 0), direction2 = new Vector3(0, 1.0, 0)) {\n    const particleEmitter = new CylinderDirectedParticleEmitter(radius, height, radiusRange, direction1, direction2);\n    this.particleEmitterType = particleEmitter;\n    return particleEmitter;\n  }\n  /**\n   * Creates a Cone Emitter for the particle system (emits from the cone to the particle position)\n   * @param radius The radius of the cone to emit from\n   * @param angle The base angle of the cone\n   * @returns the emitter\n   */\n  createConeEmitter(radius = 1, angle = Math.PI / 4) {\n    const particleEmitter = new ConeParticleEmitter(radius, angle);\n    this.particleEmitterType = particleEmitter;\n    return particleEmitter;\n  }\n  /**\n   * Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)\n   * @param direction1 Particles are emitted between the direction1 and direction2 from within the box\n   * @param direction2 Particles are emitted between the direction1 and direction2 from within the box\n   * @param minEmitBox Particles are emitted from the box between minEmitBox and maxEmitBox\n   * @param maxEmitBox  Particles are emitted from the box between minEmitBox and maxEmitBox\n   * @returns the emitter\n   */\n  createBoxEmitter(direction1, direction2, minEmitBox, maxEmitBox) {\n    const particleEmitter = new BoxParticleEmitter();\n    this.particleEmitterType = particleEmitter;\n    this.direction1 = direction1;\n    this.direction2 = direction2;\n    this.minEmitBox = minEmitBox;\n    this.maxEmitBox = maxEmitBox;\n    return particleEmitter;\n  }\n}\n/**\n * Source color is added to the destination color without alpha affecting the result\n */\nBaseParticleSystem.BLENDMODE_ONEONE = 0;\n/**\n * Blend current color and particle color using particle’s alpha\n */\nBaseParticleSystem.BLENDMODE_STANDARD = 1;\n/**\n * Add current color and particle color multiplied by particle’s alpha\n */\nBaseParticleSystem.BLENDMODE_ADD = 2;\n/**\n * Multiply current color with particle color\n */\nBaseParticleSystem.BLENDMODE_MULTIPLY = 3;\n/**\n * Multiply current color with particle color then add current color and particle color multiplied by particle’s alpha\n */\nBaseParticleSystem.BLENDMODE_MULTIPLYADD = 4;","map":{"version":3,"names":["Vector2","Vector3","ImageProcessingConfigurationDefines","BoxParticleEmitter","PointParticleEmitter","HemisphericParticleEmitter","SphereParticleEmitter","SphereDirectedParticleEmitter","CylinderParticleEmitter","CylinderDirectedParticleEmitter","ConeParticleEmitter","Color4","BaseParticleSystem","noiseTexture","_noiseTexture","value","_reset","isAnimationSheetEnabled","_isAnimationSheetEnabled","useLogarithmicDepth","_useLogarithmicDepth","getScene","getEngine","getCaps","fragmentDepthSupported","_scene","_hasTargetStopDurationDependantGradient","_startSizeGradients","length","_emitRateGradients","_lifeTimeGradients","getDragGradients","_dragGradients","getLimitVelocityGradients","_limitVelocityGradients","getColorGradients","_colorGradients","getSizeGradients","_sizeGradients","getColorRemapGradients","_colorRemapGradients","getAlphaRemapGradients","_alphaRemapGradients","getLifeTimeGradients","getAngularSpeedGradients","_angularSpeedGradients","getVelocityGradients","_velocityGradients","getStartSizeGradients","getEmitRateGradients","direction1","particleEmitterType","Zero","direction2","minEmitBox","maxEmitBox","billboardMode","_billboardMode","isBillboardBased","_isBillboardBased","imageProcessingConfiguration","_imageProcessingConfiguration","_attachImageProcessingConfiguration","configuration","_removeGradientAndTexture","gradient","gradients","texture","index","valueGradient","splice","dispose","constructor","name","animations","renderingGroupId","emitter","emitRate","manualEmitCount","updateSpeed","targetStopDuration","disposeOnStop","minEmitPower","maxEmitPower","minLifeTime","maxLifeTime","minSize","maxSize","minScaleX","maxScaleX","minScaleY","maxScaleY","minInitialRotation","maxInitialRotation","minAngularSpeed","maxAngularSpeed","layerMask","customShader","preventAutoStart","_wasDispatched","_rootUrl","noiseStrength","onAnimationEnd","blendMode","BLENDMODE_ONEONE","forceDepthWrite","preWarmCycles","preWarmStepOffset","spriteCellChangeSpeed","startSpriteCellID","endSpriteCellID","spriteCellWidth","spriteCellHeight","spriteCellLoop","spriteRandomStartCell","translationPivot","beginAnimationOnStart","beginAnimationFrom","beginAnimationTo","beginAnimationLoop","worldOffset","gravity","_rampGradients","startDelay","limitVelocityDamping","color1","color2","colorDead","textureMask","_isSubEmitter","_imageProcessingConfigurationDefines","id","createPointEmitter","particleEmitter","createHemisphericEmitter","radius","radiusRange","createSphereEmitter","createDirectedSphereEmitter","createCylinderEmitter","height","directionRandomizer","createDirectedCylinderEmitter","createConeEmitter","angle","Math","PI","createBoxEmitter","BLENDMODE_STANDARD","BLENDMODE_ADD","BLENDMODE_MULTIPLY","BLENDMODE_MULTIPLYADD"],"sources":["../../../../dev/core/src/Particles/baseParticleSystem.ts"],"sourcesContent":["/* eslint-disable import/no-internal-modules */\r\nimport type { Nullable } from \"../types\";\r\nimport { Vector2, Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\r\nimport { ImageProcessingConfigurationDefines } from \"../Materials/imageProcessingConfiguration\";\r\nimport type { ColorGradient, FactorGradient, Color3Gradient, IValueGradient } from \"../Misc/gradients\";\r\nimport type { IParticleEmitterType } from \"../Particles/EmitterTypes/index\";\r\nimport {\r\n    BoxParticleEmitter,\r\n    PointParticleEmitter,\r\n    HemisphericParticleEmitter,\r\n    SphereParticleEmitter,\r\n    SphereDirectedParticleEmitter,\r\n    CylinderParticleEmitter,\r\n    CylinderDirectedParticleEmitter,\r\n    ConeParticleEmitter,\r\n} from \"../Particles/EmitterTypes/index\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\n\r\nimport \"../Engines/Extensions/engine.dynamicBuffer\";\r\nimport type { IClipPlanesHolder } from \"../Misc/interfaces/iClipPlanesHolder\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport type { Animation } from \"../Animations/animation\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { ProceduralTexture } from \"../Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { RawTexture } from \"../Materials/Textures/rawTexture\";\r\n\r\n/**\r\n * This represents the base class for particle system in Babylon.\r\n * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n * Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.\r\n * @example https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro\r\n */\r\nexport class BaseParticleSystem implements IClipPlanesHolder {\r\n    /**\r\n     * Source color is added to the destination color without alpha affecting the result\r\n     */\r\n    public static BLENDMODE_ONEONE = 0;\r\n    /**\r\n     * Blend current color and particle color using particle’s alpha\r\n     */\r\n    public static BLENDMODE_STANDARD = 1;\r\n    /**\r\n     * Add current color and particle color multiplied by particle’s alpha\r\n     */\r\n    public static BLENDMODE_ADD = 2;\r\n    /**\r\n     * Multiply current color with particle color\r\n     */\r\n    public static BLENDMODE_MULTIPLY = 3;\r\n\r\n    /**\r\n     * Multiply current color with particle color then add current color and particle color multiplied by particle’s alpha\r\n     */\r\n    public static BLENDMODE_MULTIPLYADD = 4;\r\n\r\n    /**\r\n     * List of animations used by the particle system.\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    /**\r\n     * Gets or sets the unique id of the particle system\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * The id of the Particle system.\r\n     */\r\n    public id: string;\r\n\r\n    /**\r\n     * The friendly name of the Particle system.\r\n     */\r\n    public name: string;\r\n\r\n    /**\r\n     * Snippet ID if the particle system was created from the snippet server\r\n     */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * The rendering group used by the Particle system to chose when to render.\r\n     */\r\n    public renderingGroupId = 0;\r\n\r\n    /**\r\n     * The emitter represents the Mesh or position we are attaching the particle system to.\r\n     */\r\n    public emitter: Nullable<AbstractMesh | Vector3> = Vector3.Zero();\r\n\r\n    /**\r\n     * The maximum number of particles to emit per frame\r\n     */\r\n    public emitRate = 10;\r\n\r\n    /**\r\n     * If you want to launch only a few particles at once, that can be done, as well.\r\n     */\r\n    public manualEmitCount = -1;\r\n\r\n    /**\r\n     * The overall motion speed (0.01 is default update speed, faster updates = faster animation)\r\n     */\r\n    public updateSpeed = 0.01;\r\n\r\n    /**\r\n     * The amount of time the particle system is running (depends of the overall update speed).\r\n     */\r\n    public targetStopDuration = 0;\r\n\r\n    /**\r\n     * Specifies whether the particle system will be disposed once it reaches the end of the animation.\r\n     */\r\n    public disposeOnStop = false;\r\n\r\n    /**\r\n     * Minimum power of emitting particles.\r\n     */\r\n    public minEmitPower = 1;\r\n    /**\r\n     * Maximum power of emitting particles.\r\n     */\r\n    public maxEmitPower = 1;\r\n\r\n    /**\r\n     * Minimum life time of emitting particles.\r\n     */\r\n    public minLifeTime = 1;\r\n    /**\r\n     * Maximum life time of emitting particles.\r\n     */\r\n    public maxLifeTime = 1;\r\n\r\n    /**\r\n     * Minimum Size of emitting particles.\r\n     */\r\n    public minSize = 1;\r\n    /**\r\n     * Maximum Size of emitting particles.\r\n     */\r\n    public maxSize = 1;\r\n\r\n    /**\r\n     * Minimum scale of emitting particles on X axis.\r\n     */\r\n    public minScaleX = 1;\r\n    /**\r\n     * Maximum scale of emitting particles on X axis.\r\n     */\r\n    public maxScaleX = 1;\r\n\r\n    /**\r\n     * Minimum scale of emitting particles on Y axis.\r\n     */\r\n    public minScaleY = 1;\r\n    /**\r\n     * Maximum scale of emitting particles on Y axis.\r\n     */\r\n    public maxScaleY = 1;\r\n\r\n    /**\r\n     * Gets or sets the minimal initial rotation in radians.\r\n     */\r\n    public minInitialRotation = 0;\r\n    /**\r\n     * Gets or sets the maximal initial rotation in radians.\r\n     */\r\n    public maxInitialRotation = 0;\r\n\r\n    /**\r\n     * Minimum angular speed of emitting particles (Z-axis rotation for each particle).\r\n     */\r\n    public minAngularSpeed = 0;\r\n    /**\r\n     * Maximum angular speed of emitting particles (Z-axis rotation for each particle).\r\n     */\r\n    public maxAngularSpeed = 0;\r\n\r\n    /**\r\n     * The texture used to render each particle. (this can be a spritesheet)\r\n     */\r\n    public particleTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * The layer mask we are rendering the particles through.\r\n     */\r\n    public layerMask: number = 0x0fffffff;\r\n\r\n    /**\r\n     * This can help using your own shader to render the particle system.\r\n     * The according effect will be created\r\n     */\r\n    public customShader: any = null;\r\n\r\n    /**\r\n     * By default particle system starts as soon as they are created. This prevents the\r\n     * automatic start to happen and let you decide when to start emitting particles.\r\n     */\r\n    public preventAutoStart: boolean = false;\r\n\r\n    /** @internal */\r\n    _wasDispatched = false;\r\n\r\n    protected _rootUrl = \"\";\r\n    private _noiseTexture: Nullable<ProceduralTexture>;\r\n\r\n    /**\r\n     * Gets or sets a texture used to add random noise to particle positions\r\n     */\r\n    public get noiseTexture(): Nullable<ProceduralTexture> {\r\n        return this._noiseTexture;\r\n    }\r\n\r\n    public set noiseTexture(value: Nullable<ProceduralTexture>) {\r\n        if (this._noiseTexture === value) {\r\n            return;\r\n        }\r\n\r\n        this._noiseTexture = value;\r\n        this._reset();\r\n    }\r\n\r\n    /** Gets or sets the strength to apply to the noise value (default is (10, 10, 10)) */\r\n    public noiseStrength = new Vector3(10, 10, 10);\r\n\r\n    /**\r\n     * Callback triggered when the particle animation is ending.\r\n     */\r\n    public onAnimationEnd: Nullable<() => void> = null;\r\n\r\n    /**\r\n     * Blend mode use to render the particle, it can be either ParticleSystem.BLENDMODE_ONEONE or ParticleSystem.BLENDMODE_STANDARD.\r\n     */\r\n    public blendMode = BaseParticleSystem.BLENDMODE_ONEONE;\r\n\r\n    /**\r\n     * Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls\r\n     * to override the particles.\r\n     */\r\n    public forceDepthWrite = false;\r\n\r\n    /** Gets or sets a value indicating how many cycles (or frames) must be executed before first rendering (this value has to be set before starting the system). Default is 0 */\r\n    public preWarmCycles = 0;\r\n\r\n    /** Gets or sets a value indicating the time step multiplier to use in pre-warm mode (default is 1) */\r\n    public preWarmStepOffset = 1;\r\n\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled) defines the speed of the sprite loop (default is 1 meaning the animation will play once during the entire particle lifetime)\r\n     */\r\n    public spriteCellChangeSpeed = 1;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled) defines the first sprite cell to display\r\n     */\r\n    public startSpriteCellID = 0;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled) defines the last sprite cell to display\r\n     */\r\n    public endSpriteCellID = 0;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell width to use\r\n     */\r\n    public spriteCellWidth = 0;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell height to use\r\n     */\r\n    public spriteCellHeight = 0;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled), defines wether the sprite animation is looping\r\n     */\r\n    public spriteCellLoop = true;\r\n    /**\r\n     * This allows the system to random pick the start cell ID between startSpriteCellID and endSpriteCellID\r\n     */\r\n    public spriteRandomStartCell = false;\r\n\r\n    /** Gets or sets a Vector2 used to move the pivot (by default (0,0)) */\r\n    public translationPivot = new Vector2(0, 0);\r\n\r\n    /** @internal */\r\n    public _isAnimationSheetEnabled: boolean;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that hosted animations (in the system.animations array) must be started when system.start() is called\r\n     */\r\n    public beginAnimationOnStart = false;\r\n\r\n    /**\r\n     * Gets or sets the frame to start the animation from when beginAnimationOnStart is true\r\n     */\r\n    public beginAnimationFrom = 0;\r\n\r\n    /**\r\n     * Gets or sets the frame to end the animation on when beginAnimationOnStart is true\r\n     */\r\n    public beginAnimationTo = 60;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if animations must loop when beginAnimationOnStart is true\r\n     */\r\n    public beginAnimationLoop = false;\r\n\r\n    /**\r\n     * Gets or sets a world offset applied to all particles\r\n     */\r\n    public worldOffset = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 1\r\n     */\r\n    public clipPlane: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 2\r\n     */\r\n    public clipPlane2: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 3\r\n     */\r\n    public clipPlane3: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 4\r\n     */\r\n    public clipPlane4: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 5\r\n     */\r\n    public clipPlane5: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 6\r\n     */\r\n    public clipPlane6: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets whether an animation sprite sheet is enabled or not on the particle system\r\n     */\r\n    public get isAnimationSheetEnabled(): boolean {\r\n        return this._isAnimationSheetEnabled;\r\n    }\r\n\r\n    public set isAnimationSheetEnabled(value: boolean) {\r\n        if (this._isAnimationSheetEnabled == value) {\r\n            return;\r\n        }\r\n\r\n        this._isAnimationSheetEnabled = value;\r\n\r\n        this._reset();\r\n    }\r\n\r\n    private _useLogarithmicDepth: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean enabling the use of logarithmic depth buffers, which is good for wide depth buffers.\r\n     */\r\n    public get useLogarithmicDepth(): boolean {\r\n        return this._useLogarithmicDepth;\r\n    }\r\n\r\n    public set useLogarithmicDepth(value: boolean) {\r\n        this._useLogarithmicDepth = value && this.getScene()!.getEngine().getCaps().fragmentDepthSupported;\r\n    }\r\n\r\n    /**\r\n     * Get hosting scene\r\n     * @returns the scene\r\n     */\r\n    public getScene(): Nullable<Scene> {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * You can use gravity if you want to give an orientation to your particles.\r\n     */\r\n    public gravity = Vector3.Zero();\r\n\r\n    protected _colorGradients: Nullable<Array<ColorGradient>> = null;\r\n    protected _sizeGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _lifeTimeGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _angularSpeedGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _velocityGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _limitVelocityGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _dragGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _emitRateGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _startSizeGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _rampGradients: Nullable<Array<Color3Gradient>> = null;\r\n    protected _colorRemapGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _alphaRemapGradients: Nullable<Array<FactorGradient>> = null;\r\n\r\n    protected _hasTargetStopDurationDependantGradient() {\r\n        return (\r\n            (this._startSizeGradients && this._startSizeGradients.length > 0) ||\r\n            (this._emitRateGradients && this._emitRateGradients.length > 0) ||\r\n            (this._lifeTimeGradients && this._lifeTimeGradients.length > 0)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Defines the delay in milliseconds before starting the system (0 by default)\r\n     */\r\n    public startDelay = 0;\r\n\r\n    /**\r\n     * Gets the current list of drag gradients.\r\n     * You must use addDragGradient and removeDragGradient to update this list\r\n     * @returns the list of drag gradients\r\n     */\r\n    public getDragGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._dragGradients;\r\n    }\r\n\r\n    /** Gets or sets a value indicating the damping to apply if the limit velocity factor is reached */\r\n    public limitVelocityDamping = 0.4;\r\n\r\n    /**\r\n     * Gets the current list of limit velocity gradients.\r\n     * You must use addLimitVelocityGradient and removeLimitVelocityGradient to update this list\r\n     * @returns the list of limit velocity gradients\r\n     */\r\n    public getLimitVelocityGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._limitVelocityGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of color gradients.\r\n     * You must use addColorGradient and removeColorGradient to update this list\r\n     * @returns the list of color gradients\r\n     */\r\n    public getColorGradients(): Nullable<Array<ColorGradient>> {\r\n        return this._colorGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of size gradients.\r\n     * You must use addSizeGradient and removeSizeGradient to update this list\r\n     * @returns the list of size gradients\r\n     */\r\n    public getSizeGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._sizeGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of color remap gradients.\r\n     * You must use addColorRemapGradient and removeColorRemapGradient to update this list\r\n     * @returns the list of color remap gradients\r\n     */\r\n    public getColorRemapGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._colorRemapGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of alpha remap gradients.\r\n     * You must use addAlphaRemapGradient and removeAlphaRemapGradient to update this list\r\n     * @returns the list of alpha remap gradients\r\n     */\r\n    public getAlphaRemapGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._alphaRemapGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of life time gradients.\r\n     * You must use addLifeTimeGradient and removeLifeTimeGradient to update this list\r\n     * @returns the list of life time gradients\r\n     */\r\n    public getLifeTimeGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._lifeTimeGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of angular speed gradients.\r\n     * You must use addAngularSpeedGradient and removeAngularSpeedGradient to update this list\r\n     * @returns the list of angular speed gradients\r\n     */\r\n    public getAngularSpeedGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._angularSpeedGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of velocity gradients.\r\n     * You must use addVelocityGradient and removeVelocityGradient to update this list\r\n     * @returns the list of velocity gradients\r\n     */\r\n    public getVelocityGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._velocityGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of start size gradients.\r\n     * You must use addStartSizeGradient and removeStartSizeGradient to update this list\r\n     * @returns the list of start size gradients\r\n     */\r\n    public getStartSizeGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._startSizeGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of emit rate gradients.\r\n     * You must use addEmitRateGradient and removeEmitRateGradient to update this list\r\n     * @returns the list of emit rate gradients\r\n     */\r\n    public getEmitRateGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._emitRateGradients;\r\n    }\r\n\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     * This only works when particleEmitterTyps is a BoxParticleEmitter\r\n     */\r\n    public get direction1(): Vector3 {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).direction1) {\r\n            return (<BoxParticleEmitter>this.particleEmitterType).direction1;\r\n        }\r\n\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    public set direction1(value: Vector3) {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).direction1) {\r\n            (<BoxParticleEmitter>this.particleEmitterType).direction1 = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     * This only works when particleEmitterTyps is a BoxParticleEmitter\r\n     */\r\n    public get direction2(): Vector3 {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).direction2) {\r\n            return (<BoxParticleEmitter>this.particleEmitterType).direction2;\r\n        }\r\n\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    public set direction2(value: Vector3) {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).direction2) {\r\n            (<BoxParticleEmitter>this.particleEmitterType).direction2 = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.\r\n     * This only works when particleEmitterTyps is a BoxParticleEmitter\r\n     */\r\n    public get minEmitBox(): Vector3 {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).minEmitBox) {\r\n            return (<BoxParticleEmitter>this.particleEmitterType).minEmitBox;\r\n        }\r\n\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    public set minEmitBox(value: Vector3) {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).minEmitBox) {\r\n            (<BoxParticleEmitter>this.particleEmitterType).minEmitBox = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.\r\n     * This only works when particleEmitterTyps is a BoxParticleEmitter\r\n     */\r\n    public get maxEmitBox(): Vector3 {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).maxEmitBox) {\r\n            return (<BoxParticleEmitter>this.particleEmitterType).maxEmitBox;\r\n        }\r\n\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    public set maxEmitBox(value: Vector3) {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).maxEmitBox) {\r\n            (<BoxParticleEmitter>this.particleEmitterType).maxEmitBox = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Random color of each particle after it has been emitted, between color1 and color2 vectors\r\n     */\r\n    public color1 = new Color4(1.0, 1.0, 1.0, 1.0);\r\n    /**\r\n     * Random color of each particle after it has been emitted, between color1 and color2 vectors\r\n     */\r\n    public color2 = new Color4(1.0, 1.0, 1.0, 1.0);\r\n    /**\r\n     * Color the particle will have at the end of its lifetime\r\n     */\r\n    public colorDead = new Color4(0, 0, 0, 1.0);\r\n\r\n    /**\r\n     * An optional mask to filter some colors out of the texture, or filter a part of the alpha channel\r\n     */\r\n    public textureMask = new Color4(1.0, 1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * The particle emitter type defines the emitter used by the particle system.\r\n     * It can be for example box, sphere, or cone...\r\n     */\r\n    public particleEmitterType: IParticleEmitterType;\r\n\r\n    /** @internal */\r\n    public _isSubEmitter = false;\r\n\r\n    /** @internal */\r\n    public _billboardMode = Constants.PARTICLES_BILLBOARDMODE_ALL;\r\n    /**\r\n     * Gets or sets the billboard mode to use when isBillboardBased = true.\r\n     * Value can be: ParticleSystem.BILLBOARDMODE_ALL, ParticleSystem.BILLBOARDMODE_Y, ParticleSystem.BILLBOARDMODE_STRETCHED\r\n     */\r\n    public get billboardMode(): number {\r\n        return this._billboardMode;\r\n    }\r\n\r\n    public set billboardMode(value: number) {\r\n        if (this._billboardMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._billboardMode = value;\r\n        this._reset();\r\n    }\r\n\r\n    /** @internal */\r\n    public _isBillboardBased = true;\r\n    /**\r\n     * Gets or sets a boolean indicating if the particles must be rendered as billboard or aligned with the direction\r\n     */\r\n    public get isBillboardBased(): boolean {\r\n        return this._isBillboardBased;\r\n    }\r\n\r\n    public set isBillboardBased(value: boolean) {\r\n        if (this._isBillboardBased === value) {\r\n            return;\r\n        }\r\n\r\n        this._isBillboardBased = value;\r\n        this._reset();\r\n    }\r\n\r\n    /**\r\n     * The scene the particle system belongs to.\r\n     */\r\n    protected _scene: Nullable<Scene>;\r\n\r\n    /**\r\n     * The engine the particle system belongs to.\r\n     */\r\n    protected _engine: ThinEngine;\r\n\r\n    /**\r\n     * Local cache of defines for image processing.\r\n     */\r\n    protected _imageProcessingConfigurationDefines = new ImageProcessingConfigurationDefines();\r\n\r\n    /**\r\n     * Default configuration related to image processing available in the standard Material.\r\n     */\r\n    protected _imageProcessingConfiguration: Nullable<ImageProcessingConfiguration>;\r\n\r\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\r\n    public get imageProcessingConfiguration(): Nullable<ImageProcessingConfiguration> {\r\n        return this._imageProcessingConfiguration;\r\n    }\r\n\r\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\r\n    public set imageProcessingConfiguration(value: Nullable<ImageProcessingConfiguration>) {\r\n        this._attachImageProcessingConfiguration(value);\r\n    }\r\n\r\n    /**\r\n     * Attaches a new image processing configuration to the Standard Material.\r\n     * @param configuration\r\n     */\r\n    protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void {\r\n        if (configuration === this._imageProcessingConfiguration) {\r\n            return;\r\n        }\r\n\r\n        // Pick the scene configuration if needed.\r\n        if (!configuration && this._scene) {\r\n            this._imageProcessingConfiguration = this._scene.imageProcessingConfiguration;\r\n        } else {\r\n            this._imageProcessingConfiguration = configuration;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    protected _reset() {}\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _removeGradientAndTexture(gradient: number, gradients: Nullable<IValueGradient[]>, texture: Nullable<RawTexture>): BaseParticleSystem {\r\n        if (!gradients) {\r\n            return this;\r\n        }\r\n\r\n        let index = 0;\r\n        for (const valueGradient of gradients) {\r\n            if (valueGradient.gradient === gradient) {\r\n                gradients.splice(index, 1);\r\n                break;\r\n            }\r\n            index++;\r\n        }\r\n\r\n        if (texture) {\r\n            texture.dispose();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a particle system.\r\n     * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n     * @param name The name of the particle system\r\n     */\r\n    public constructor(name: string) {\r\n        this.id = name;\r\n        this.name = name;\r\n    }\r\n\r\n    /**\r\n     * Creates a Point Emitter for the particle system (emits directly from the emitter position)\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @returns the emitter\r\n     */\r\n    public createPointEmitter(direction1: Vector3, direction2: Vector3): PointParticleEmitter {\r\n        const particleEmitter = new PointParticleEmitter();\r\n        particleEmitter.direction1 = direction1;\r\n        particleEmitter.direction2 = direction2;\r\n\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)\r\n     * @param radius The radius of the hemisphere to emit from\r\n     * @param radiusRange The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius\r\n     * @returns the emitter\r\n     */\r\n    public createHemisphericEmitter(radius = 1, radiusRange = 1): HemisphericParticleEmitter {\r\n        const particleEmitter = new HemisphericParticleEmitter(radius, radiusRange);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Sphere Emitter for the particle system (emits along the sphere radius)\r\n     * @param radius The radius of the sphere to emit from\r\n     * @param radiusRange The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius\r\n     * @returns the emitter\r\n     */\r\n    public createSphereEmitter(radius = 1, radiusRange = 1): SphereParticleEmitter {\r\n        const particleEmitter = new SphereParticleEmitter(radius, radiusRange);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)\r\n     * @param radius The radius of the sphere to emit from\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the sphere\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the sphere\r\n     * @returns the emitter\r\n     */\r\n    public createDirectedSphereEmitter(radius = 1, direction1 = new Vector3(0, 1.0, 0), direction2 = new Vector3(0, 1.0, 0)): SphereDirectedParticleEmitter {\r\n        const particleEmitter = new SphereDirectedParticleEmitter(radius, direction1, direction2);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)\r\n     * @param radius The radius of the emission cylinder\r\n     * @param height The height of the emission cylinder\r\n     * @param radiusRange The range of emission [0-1] 0 Surface only, 1 Entire Radius\r\n     * @param directionRandomizer How much to randomize the particle direction [0-1]\r\n     * @returns the emitter\r\n     */\r\n    public createCylinderEmitter(radius = 1, height = 1, radiusRange = 1, directionRandomizer = 0): CylinderParticleEmitter {\r\n        const particleEmitter = new CylinderParticleEmitter(radius, height, radiusRange, directionRandomizer);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)\r\n     * @param radius The radius of the cylinder to emit from\r\n     * @param height The height of the emission cylinder\r\n     * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the cylinder\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the cylinder\r\n     * @returns the emitter\r\n     */\r\n    public createDirectedCylinderEmitter(\r\n        radius = 1,\r\n        height = 1,\r\n        radiusRange = 1,\r\n        direction1 = new Vector3(0, 1.0, 0),\r\n        direction2 = new Vector3(0, 1.0, 0)\r\n    ): CylinderDirectedParticleEmitter {\r\n        const particleEmitter = new CylinderDirectedParticleEmitter(radius, height, radiusRange, direction1, direction2);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Cone Emitter for the particle system (emits from the cone to the particle position)\r\n     * @param radius The radius of the cone to emit from\r\n     * @param angle The base angle of the cone\r\n     * @returns the emitter\r\n     */\r\n    public createConeEmitter(radius = 1, angle = Math.PI / 4): ConeParticleEmitter {\r\n        const particleEmitter = new ConeParticleEmitter(radius, angle);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @param minEmitBox Particles are emitted from the box between minEmitBox and maxEmitBox\r\n     * @param maxEmitBox  Particles are emitted from the box between minEmitBox and maxEmitBox\r\n     * @returns the emitter\r\n     */\r\n    public createBoxEmitter(direction1: Vector3, direction2: Vector3, minEmitBox: Vector3, maxEmitBox: Vector3): BoxParticleEmitter {\r\n        const particleEmitter = new BoxParticleEmitter();\r\n        this.particleEmitterType = particleEmitter;\r\n        this.direction1 = direction1;\r\n        this.direction2 = direction2;\r\n        this.minEmitBox = minEmitBox;\r\n        this.maxEmitBox = maxEmitBox;\r\n        return particleEmitter;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}