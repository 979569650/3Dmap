{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../tslib.es6.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Matrix, TmpVectors, Vector2 } from \"../Maths/math.vector.js\";\nimport { PostProcess } from \"./postProcess.js\";\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer.js\";\nimport { MotionBlurConfiguration } from \"../Rendering/motionBlurConfiguration.js\";\nimport \"../Animations/animatable.js\";\nimport \"../Rendering/geometryBufferRendererSceneComponent.js\";\nimport \"../Shaders/motionBlur.fragment.js\";\nimport { serialize, SerializationHelper } from \"../Misc/decorators.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\n/**\n * The Motion Blur Post Process which blurs an image based on the objects velocity in scene.\n * Velocity can be affected by each object's rotation, position and scale depending on the transformation speed.\n * As an example, all you have to do is to create the post-process:\n *  var mb = new BABYLON.MotionBlurPostProcess(\n *      'mb', // The name of the effect.\n *      scene, // The scene containing the objects to blur according to their velocity.\n *      1.0, // The required width/height ratio to downsize to before computing the render pass.\n *      camera // The camera to apply the render pass to.\n * );\n * Then, all objects moving, rotating and/or scaling will be blurred depending on the transformation speed.\n */\nexport class MotionBlurPostProcess extends PostProcess {\n  /**\n   * Gets the number of iterations are used for motion blur quality. Default value is equal to 32\n   */\n  get motionBlurSamples() {\n    return this._motionBlurSamples;\n  }\n  /**\n   * Sets the number of iterations to be used for motion blur quality\n   */\n  set motionBlurSamples(samples) {\n    this._motionBlurSamples = samples;\n    this._updateEffect();\n  }\n  /**\n   * Gets whether or not the motion blur post-process is in object based mode.\n   */\n  get isObjectBased() {\n    return this._isObjectBased;\n  }\n  /**\n   * Sets whether or not the motion blur post-process is in object based mode.\n   */\n  set isObjectBased(value) {\n    if (this._isObjectBased === value) {\n      return;\n    }\n    this._isObjectBased = value;\n    this._applyMode();\n  }\n  get _geometryBufferRenderer() {\n    if (!this._forceGeometryBuffer) {\n      return null;\n    }\n    return this._scene.geometryBufferRenderer;\n  }\n  get _prePassRenderer() {\n    if (this._forceGeometryBuffer) {\n      return null;\n    }\n    return this._scene.prePassRenderer;\n  }\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"MotionBlurPostProcess\" string\n   */\n  getClassName() {\n    return \"MotionBlurPostProcess\";\n  }\n  /**\n   * Creates a new instance MotionBlurPostProcess\n   * @param name The name of the effect.\n   * @param scene The scene containing the objects to blur according to their velocity.\n   * @param options The required width/height ratio to downsize to before computing the render pass.\n   * @param camera The camera to apply the render pass to.\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\n   * @param engine The engine which the post process will be applied. (default: current engine)\n   * @param reusable If the post process can be reused on the same frame. (default: false)\n   * @param textureType Type of textures used when performing the post process. (default: 0)\n   * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: true)\n   * @param forceGeometryBuffer If this post process should use geometry buffer instead of prepass (default: false)\n   */\n  constructor(name, scene, options, camera, samplingMode, engine, reusable, textureType = 0, blockCompilation = false, forceGeometryBuffer = false) {\n    super(name, \"motionBlur\", [\"motionStrength\", \"motionScale\", \"screenSize\", \"inverseViewProjection\", \"prevViewProjection\", \"projection\"], [\"velocitySampler\", \"depthSampler\"], options, camera, samplingMode, engine, reusable, \"#define GEOMETRY_SUPPORTED\\n#define SAMPLES 64.0\\n#define OBJECT_BASED\", textureType, undefined, null, blockCompilation);\n    /**\n     * Defines how much the image is blurred by the movement. Default value is equal to 1\n     */\n    this.motionStrength = 1;\n    this._motionBlurSamples = 32;\n    this._isObjectBased = true;\n    this._forceGeometryBuffer = false;\n    this._invViewProjection = null;\n    this._previousViewProjection = null;\n    this._forceGeometryBuffer = forceGeometryBuffer;\n    // Set up assets\n    if (this._forceGeometryBuffer) {\n      scene.enableGeometryBufferRenderer();\n      if (this._geometryBufferRenderer) {\n        this._geometryBufferRenderer.enableVelocity = this._isObjectBased;\n      }\n    } else {\n      scene.enablePrePassRenderer();\n      if (this._prePassRenderer) {\n        this._prePassRenderer.markAsDirty();\n        this._prePassEffectConfiguration = new MotionBlurConfiguration();\n      }\n    }\n    this._applyMode();\n  }\n  /**\n   * Excludes the given skinned mesh from computing bones velocities.\n   * Computing bones velocities can have a cost and that cost. The cost can be saved by calling this function and by passing the skinned mesh reference to ignore.\n   * @param skinnedMesh The mesh containing the skeleton to ignore when computing the velocity map.\n   */\n  excludeSkinnedMesh(skinnedMesh) {\n    if (skinnedMesh.skeleton) {\n      let list;\n      if (this._geometryBufferRenderer) {\n        list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;\n      } else if (this._prePassRenderer) {\n        list = this._prePassRenderer.excludedSkinnedMesh;\n      } else {\n        return;\n      }\n      list.push(skinnedMesh);\n    }\n  }\n  /**\n   * Removes the given skinned mesh from the excluded meshes to integrate bones velocities while rendering the velocity map.\n   * @param skinnedMesh The mesh containing the skeleton that has been ignored previously.\n   * @see excludeSkinnedMesh to exclude a skinned mesh from bones velocity computation.\n   */\n  removeExcludedSkinnedMesh(skinnedMesh) {\n    if (skinnedMesh.skeleton) {\n      let list;\n      if (this._geometryBufferRenderer) {\n        list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;\n      } else if (this._prePassRenderer) {\n        list = this._prePassRenderer.excludedSkinnedMesh;\n      } else {\n        return;\n      }\n      const index = list.indexOf(skinnedMesh);\n      if (index !== -1) {\n        list.splice(index, 1);\n      }\n    }\n  }\n  /**\n   * Disposes the post process.\n   * @param camera The camera to dispose the post process on.\n   */\n  dispose(camera) {\n    if (this._geometryBufferRenderer) {\n      // Clear previous transformation matrices dictionary used to compute objects velocities\n      this._geometryBufferRenderer._previousTransformationMatrices = {};\n      this._geometryBufferRenderer._previousBonesTransformationMatrices = {};\n      this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity = [];\n    }\n    super.dispose(camera);\n  }\n  /**\n   * Called on the mode changed (object based or screen based).\n   */\n  _applyMode() {\n    if (!this._geometryBufferRenderer && !this._prePassRenderer) {\n      // We can't get a velocity or depth texture. So, work as a passthrough.\n      Logger.Warn(\"Multiple Render Target support needed to compute object based motion blur\");\n      return this.updateEffect();\n    }\n    if (this._geometryBufferRenderer) {\n      this._geometryBufferRenderer.enableVelocity = this._isObjectBased;\n    }\n    this._updateEffect();\n    this._invViewProjection = null;\n    this._previousViewProjection = null;\n    if (this.isObjectBased) {\n      if (this._prePassRenderer && this._prePassEffectConfiguration) {\n        this._prePassEffectConfiguration.texturesRequired[0] = 2;\n      }\n      this.onApply = effect => this._onApplyObjectBased(effect);\n    } else {\n      this._invViewProjection = Matrix.Identity();\n      this._previousViewProjection = this._scene.getTransformMatrix().clone();\n      if (this._prePassRenderer && this._prePassEffectConfiguration) {\n        this._prePassEffectConfiguration.texturesRequired[0] = 5;\n      }\n      this.onApply = effect => this._onApplyScreenBased(effect);\n    }\n  }\n  /**\n   * Called on the effect is applied when the motion blur post-process is in object based mode.\n   * @param effect\n   */\n  _onApplyObjectBased(effect) {\n    effect.setVector2(\"screenSize\", new Vector2(this.width, this.height));\n    effect.setFloat(\"motionScale\", this._scene.getAnimationRatio());\n    effect.setFloat(\"motionStrength\", this.motionStrength);\n    if (this._geometryBufferRenderer) {\n      const velocityIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE);\n      effect.setTexture(\"velocitySampler\", this._geometryBufferRenderer.getGBuffer().textures[velocityIndex]);\n    } else if (this._prePassRenderer) {\n      const velocityIndex = this._prePassRenderer.getIndex(2);\n      effect.setTexture(\"velocitySampler\", this._prePassRenderer.getRenderTarget().textures[velocityIndex]);\n    }\n  }\n  /**\n   * Called on the effect is applied when the motion blur post-process is in screen based mode.\n   * @param effect\n   */\n  _onApplyScreenBased(effect) {\n    const viewProjection = TmpVectors.Matrix[0];\n    viewProjection.copyFrom(this._scene.getTransformMatrix());\n    viewProjection.invertToRef(this._invViewProjection);\n    effect.setMatrix(\"inverseViewProjection\", this._invViewProjection);\n    effect.setMatrix(\"prevViewProjection\", this._previousViewProjection);\n    this._previousViewProjection.copyFrom(viewProjection);\n    effect.setMatrix(\"projection\", this._scene.getProjectionMatrix());\n    effect.setVector2(\"screenSize\", new Vector2(this.width, this.height));\n    effect.setFloat(\"motionScale\", this._scene.getAnimationRatio());\n    effect.setFloat(\"motionStrength\", this.motionStrength);\n    if (this._geometryBufferRenderer) {\n      const depthIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.DEPTH_TEXTURE_TYPE);\n      effect.setTexture(\"depthSampler\", this._geometryBufferRenderer.getGBuffer().textures[depthIndex]);\n    } else if (this._prePassRenderer) {\n      const depthIndex = this._prePassRenderer.getIndex(5);\n      effect.setTexture(\"depthSampler\", this._prePassRenderer.getRenderTarget().textures[depthIndex]);\n    }\n  }\n  /**\n   * Called on the effect must be updated (changed mode, samples count, etc.).\n   */\n  _updateEffect() {\n    if (this._geometryBufferRenderer || this._prePassRenderer) {\n      const defines = [\"#define GEOMETRY_SUPPORTED\", \"#define SAMPLES \" + this._motionBlurSamples.toFixed(1), this._isObjectBased ? \"#define OBJECT_BASED\" : \"#define SCREEN_BASED\"];\n      this.updateEffect(defines.join(\"\\n\"));\n    }\n  }\n  /**\n   * @internal\n   */\n  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {\n    return SerializationHelper.Parse(() => {\n      return new MotionBlurPostProcess(parsedPostProcess.name, scene, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable, parsedPostProcess.textureType, false);\n    }, parsedPostProcess, scene, rootUrl);\n  }\n}\n__decorate([serialize()], MotionBlurPostProcess.prototype, \"motionStrength\", void 0);\n__decorate([serialize()], MotionBlurPostProcess.prototype, \"motionBlurSamples\", null);\n__decorate([serialize()], MotionBlurPostProcess.prototype, \"isObjectBased\", null);\nRegisterClass(\"BABYLON.MotionBlurPostProcess\", MotionBlurPostProcess);","map":{"version":3,"names":["Logger","Matrix","TmpVectors","Vector2","PostProcess","GeometryBufferRenderer","MotionBlurConfiguration","serialize","SerializationHelper","RegisterClass","MotionBlurPostProcess","motionBlurSamples","_motionBlurSamples","samples","_updateEffect","isObjectBased","_isObjectBased","value","_applyMode","_geometryBufferRenderer","_forceGeometryBuffer","_scene","geometryBufferRenderer","_prePassRenderer","prePassRenderer","getClassName","constructor","name","scene","options","camera","samplingMode","engine","reusable","textureType","blockCompilation","forceGeometryBuffer","undefined","motionStrength","_invViewProjection","_previousViewProjection","enableGeometryBufferRenderer","enableVelocity","enablePrePassRenderer","markAsDirty","_prePassEffectConfiguration","excludeSkinnedMesh","skinnedMesh","skeleton","list","excludedSkinnedMeshesFromVelocity","excludedSkinnedMesh","push","removeExcludedSkinnedMesh","index","indexOf","splice","dispose","_previousTransformationMatrices","_previousBonesTransformationMatrices","Warn","updateEffect","texturesRequired","onApply","effect","_onApplyObjectBased","Identity","getTransformMatrix","clone","_onApplyScreenBased","setVector2","width","height","setFloat","getAnimationRatio","velocityIndex","getTextureIndex","VELOCITY_TEXTURE_TYPE","setTexture","getGBuffer","textures","getIndex","getRenderTarget","viewProjection","copyFrom","invertToRef","setMatrix","getProjectionMatrix","depthIndex","DEPTH_TEXTURE_TYPE","defines","toFixed","join","_Parse","parsedPostProcess","targetCamera","rootUrl","Parse","renderTargetSamplingMode","getEngine","__decorate"],"sources":["../../../../dev/core/src/PostProcesses/motionBlurPostProcess.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Matrix, TmpVectors, Vector2 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { MotionBlurConfiguration } from \"../Rendering/motionBlurConfiguration\";\r\nimport type { PrePassRenderer } from \"../Rendering/prePassRenderer\";\r\n\r\nimport \"../Animations/animatable\";\r\nimport \"../Rendering/geometryBufferRendererSceneComponent\";\r\nimport \"../Shaders/motionBlur.fragment\";\r\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * The Motion Blur Post Process which blurs an image based on the objects velocity in scene.\r\n * Velocity can be affected by each object's rotation, position and scale depending on the transformation speed.\r\n * As an example, all you have to do is to create the post-process:\r\n *  var mb = new BABYLON.MotionBlurPostProcess(\r\n *      'mb', // The name of the effect.\r\n *      scene, // The scene containing the objects to blur according to their velocity.\r\n *      1.0, // The required width/height ratio to downsize to before computing the render pass.\r\n *      camera // The camera to apply the render pass to.\r\n * );\r\n * Then, all objects moving, rotating and/or scaling will be blurred depending on the transformation speed.\r\n */\r\nexport class MotionBlurPostProcess extends PostProcess {\r\n    /**\r\n     * Defines how much the image is blurred by the movement. Default value is equal to 1\r\n     */\r\n    @serialize()\r\n    public motionStrength: number = 1;\r\n\r\n    /**\r\n     * Gets the number of iterations are used for motion blur quality. Default value is equal to 32\r\n     */\r\n    @serialize()\r\n    public get motionBlurSamples(): number {\r\n        return this._motionBlurSamples;\r\n    }\r\n\r\n    /**\r\n     * Sets the number of iterations to be used for motion blur quality\r\n     */\r\n    public set motionBlurSamples(samples: number) {\r\n        this._motionBlurSamples = samples;\r\n        this._updateEffect();\r\n    }\r\n\r\n    private _motionBlurSamples: number = 32;\r\n\r\n    /**\r\n     * Gets whether or not the motion blur post-process is in object based mode.\r\n     */\r\n    @serialize()\r\n    public get isObjectBased(): boolean {\r\n        return this._isObjectBased;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not the motion blur post-process is in object based mode.\r\n     */\r\n    public set isObjectBased(value: boolean) {\r\n        if (this._isObjectBased === value) {\r\n            return;\r\n        }\r\n\r\n        this._isObjectBased = value;\r\n        this._applyMode();\r\n    }\r\n\r\n    private _isObjectBased: boolean = true;\r\n\r\n    private _forceGeometryBuffer: boolean = false;\r\n    private get _geometryBufferRenderer(): Nullable<GeometryBufferRenderer> {\r\n        if (!this._forceGeometryBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.geometryBufferRenderer;\r\n    }\r\n\r\n    private get _prePassRenderer(): Nullable<PrePassRenderer> {\r\n        if (this._forceGeometryBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.prePassRenderer;\r\n    }\r\n\r\n    private _invViewProjection: Nullable<Matrix> = null;\r\n    private _previousViewProjection: Nullable<Matrix> = null;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"MotionBlurPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"MotionBlurPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance MotionBlurPostProcess\r\n     * @param name The name of the effect.\r\n     * @param scene The scene containing the objects to blur according to their velocity.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: true)\r\n     * @param forceGeometryBuffer If this post process should use geometry buffer instead of prepass (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Scene,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode?: number,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        blockCompilation = false,\r\n        forceGeometryBuffer = false\r\n    ) {\r\n        super(\r\n            name,\r\n            \"motionBlur\",\r\n            [\"motionStrength\", \"motionScale\", \"screenSize\", \"inverseViewProjection\", \"prevViewProjection\", \"projection\"],\r\n            [\"velocitySampler\", \"depthSampler\"],\r\n            options,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            \"#define GEOMETRY_SUPPORTED\\n#define SAMPLES 64.0\\n#define OBJECT_BASED\",\r\n            textureType,\r\n            undefined,\r\n            null,\r\n            blockCompilation\r\n        );\r\n\r\n        this._forceGeometryBuffer = forceGeometryBuffer;\r\n\r\n        // Set up assets\r\n        if (this._forceGeometryBuffer) {\r\n            scene.enableGeometryBufferRenderer();\r\n\r\n            if (this._geometryBufferRenderer) {\r\n                this._geometryBufferRenderer.enableVelocity = this._isObjectBased;\r\n            }\r\n        } else {\r\n            scene.enablePrePassRenderer();\r\n\r\n            if (this._prePassRenderer) {\r\n                this._prePassRenderer.markAsDirty();\r\n                this._prePassEffectConfiguration = new MotionBlurConfiguration();\r\n            }\r\n        }\r\n\r\n        this._applyMode();\r\n    }\r\n\r\n    /**\r\n     * Excludes the given skinned mesh from computing bones velocities.\r\n     * Computing bones velocities can have a cost and that cost. The cost can be saved by calling this function and by passing the skinned mesh reference to ignore.\r\n     * @param skinnedMesh The mesh containing the skeleton to ignore when computing the velocity map.\r\n     */\r\n    public excludeSkinnedMesh(skinnedMesh: AbstractMesh): void {\r\n        if (skinnedMesh.skeleton) {\r\n            let list;\r\n            if (this._geometryBufferRenderer) {\r\n                list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;\r\n            } else if (this._prePassRenderer) {\r\n                list = this._prePassRenderer.excludedSkinnedMesh;\r\n            } else {\r\n                return;\r\n            }\r\n            list.push(skinnedMesh);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the given skinned mesh from the excluded meshes to integrate bones velocities while rendering the velocity map.\r\n     * @param skinnedMesh The mesh containing the skeleton that has been ignored previously.\r\n     * @see excludeSkinnedMesh to exclude a skinned mesh from bones velocity computation.\r\n     */\r\n    public removeExcludedSkinnedMesh(skinnedMesh: AbstractMesh): void {\r\n        if (skinnedMesh.skeleton) {\r\n            let list;\r\n            if (this._geometryBufferRenderer) {\r\n                list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;\r\n            } else if (this._prePassRenderer) {\r\n                list = this._prePassRenderer.excludedSkinnedMesh;\r\n            } else {\r\n                return;\r\n            }\r\n\r\n            const index = list.indexOf(skinnedMesh);\r\n            if (index !== -1) {\r\n                list.splice(index, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the post process.\r\n     * @param camera The camera to dispose the post process on.\r\n     */\r\n    public dispose(camera?: Camera): void {\r\n        if (this._geometryBufferRenderer) {\r\n            // Clear previous transformation matrices dictionary used to compute objects velocities\r\n            this._geometryBufferRenderer._previousTransformationMatrices = {};\r\n            this._geometryBufferRenderer._previousBonesTransformationMatrices = {};\r\n            this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity = [];\r\n        }\r\n\r\n        super.dispose(camera);\r\n    }\r\n\r\n    /**\r\n     * Called on the mode changed (object based or screen based).\r\n     */\r\n    private _applyMode(): void {\r\n        if (!this._geometryBufferRenderer && !this._prePassRenderer) {\r\n            // We can't get a velocity or depth texture. So, work as a passthrough.\r\n            Logger.Warn(\"Multiple Render Target support needed to compute object based motion blur\");\r\n            return this.updateEffect();\r\n        }\r\n\r\n        if (this._geometryBufferRenderer) {\r\n            this._geometryBufferRenderer.enableVelocity = this._isObjectBased;\r\n        }\r\n\r\n        this._updateEffect();\r\n\r\n        this._invViewProjection = null;\r\n        this._previousViewProjection = null;\r\n\r\n        if (this.isObjectBased) {\r\n            if (this._prePassRenderer && this._prePassEffectConfiguration) {\r\n                this._prePassEffectConfiguration.texturesRequired[0] = Constants.PREPASS_VELOCITY_TEXTURE_TYPE;\r\n            }\r\n\r\n            this.onApply = (effect: Effect) => this._onApplyObjectBased(effect);\r\n        } else {\r\n            this._invViewProjection = Matrix.Identity();\r\n            this._previousViewProjection = this._scene.getTransformMatrix().clone();\r\n\r\n            if (this._prePassRenderer && this._prePassEffectConfiguration) {\r\n                this._prePassEffectConfiguration.texturesRequired[0] = Constants.PREPASS_DEPTH_TEXTURE_TYPE;\r\n            }\r\n\r\n            this.onApply = (effect: Effect) => this._onApplyScreenBased(effect);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on the effect is applied when the motion blur post-process is in object based mode.\r\n     * @param effect\r\n     */\r\n    private _onApplyObjectBased(effect: Effect): void {\r\n        effect.setVector2(\"screenSize\", new Vector2(this.width, this.height));\r\n\r\n        effect.setFloat(\"motionScale\", this._scene.getAnimationRatio());\r\n        effect.setFloat(\"motionStrength\", this.motionStrength);\r\n\r\n        if (this._geometryBufferRenderer) {\r\n            const velocityIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE);\r\n            effect.setTexture(\"velocitySampler\", this._geometryBufferRenderer.getGBuffer().textures[velocityIndex]);\r\n        } else if (this._prePassRenderer) {\r\n            const velocityIndex = this._prePassRenderer.getIndex(Constants.PREPASS_VELOCITY_TEXTURE_TYPE);\r\n            effect.setTexture(\"velocitySampler\", this._prePassRenderer.getRenderTarget().textures[velocityIndex]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on the effect is applied when the motion blur post-process is in screen based mode.\r\n     * @param effect\r\n     */\r\n    private _onApplyScreenBased(effect: Effect): void {\r\n        const viewProjection = TmpVectors.Matrix[0];\r\n        viewProjection.copyFrom(this._scene.getTransformMatrix());\r\n\r\n        viewProjection.invertToRef(this._invViewProjection!);\r\n        effect.setMatrix(\"inverseViewProjection\", this._invViewProjection!);\r\n\r\n        effect.setMatrix(\"prevViewProjection\", this._previousViewProjection!);\r\n        this._previousViewProjection!.copyFrom(viewProjection);\r\n\r\n        effect.setMatrix(\"projection\", this._scene.getProjectionMatrix());\r\n\r\n        effect.setVector2(\"screenSize\", new Vector2(this.width, this.height));\r\n\r\n        effect.setFloat(\"motionScale\", this._scene.getAnimationRatio());\r\n        effect.setFloat(\"motionStrength\", this.motionStrength);\r\n\r\n        if (this._geometryBufferRenderer) {\r\n            const depthIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.DEPTH_TEXTURE_TYPE);\r\n            effect.setTexture(\"depthSampler\", this._geometryBufferRenderer.getGBuffer().textures[depthIndex]);\r\n        } else if (this._prePassRenderer) {\r\n            const depthIndex = this._prePassRenderer.getIndex(Constants.PREPASS_DEPTH_TEXTURE_TYPE);\r\n            effect.setTexture(\"depthSampler\", this._prePassRenderer.getRenderTarget().textures[depthIndex]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on the effect must be updated (changed mode, samples count, etc.).\r\n     */\r\n    private _updateEffect(): void {\r\n        if (this._geometryBufferRenderer || this._prePassRenderer) {\r\n            const defines: string[] = [\r\n                \"#define GEOMETRY_SUPPORTED\",\r\n                \"#define SAMPLES \" + this._motionBlurSamples.toFixed(1),\r\n                this._isObjectBased ? \"#define OBJECT_BASED\" : \"#define SCREEN_BASED\",\r\n            ];\r\n\r\n            this.updateEffect(defines.join(\"\\n\"));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<MotionBlurPostProcess> {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new MotionBlurPostProcess(\r\n                    parsedPostProcess.name,\r\n                    scene,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    scene.getEngine(),\r\n                    parsedPostProcess.reusable,\r\n                    parsedPostProcess.textureType,\r\n                    false\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MotionBlurPostProcess\", MotionBlurPostProcess);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}