{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext.js\";\nimport * as WebGPUConstants from \"./webgpuConstants.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor.js\";\nimport { RemoveComments } from \"../../Misc/codeStringParsingTools.js\";\nimport \"../../ShadersWGSL/ShadersInclude/bonesDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/bonesVertex.js\";\nimport \"../../ShadersWGSL/ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/bakedVertexAnimation.js\";\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneFragment.js\";\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneFragmentDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneVertex.js\";\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/instancesDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/instancesVertex.js\";\nimport \"../../ShadersWGSL/ShadersInclude/meshUboDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertex.js\";\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertexGlobal.js\";\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/sceneUboDeclaration.js\";\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage.js\";\nconst builtInName_frag_depth = \"fragmentOutputs.fragDepth\";\nconst leftOverVarName = \"uniforms\";\nconst internalsVarName = \"internals\";\nconst gpuTextureViewDimensionByWebGPUTextureFunction = {\n  texture_1d: WebGPUConstants.TextureViewDimension.E1d,\n  texture_2d: WebGPUConstants.TextureViewDimension.E2d,\n  texture_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\n  texture_3d: WebGPUConstants.TextureViewDimension.E3d,\n  texture_cube: WebGPUConstants.TextureViewDimension.Cube,\n  texture_cube_array: WebGPUConstants.TextureViewDimension.CubeArray,\n  texture_multisampled_2d: WebGPUConstants.TextureViewDimension.E2d,\n  texture_depth_2d: WebGPUConstants.TextureViewDimension.E2d,\n  texture_depth_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\n  texture_depth_cube: WebGPUConstants.TextureViewDimension.Cube,\n  texture_depth_cube_array: WebGPUConstants.TextureViewDimension.CubeArray,\n  texture_depth_multisampled_2d: WebGPUConstants.TextureViewDimension.E2d,\n  texture_storage_1d: WebGPUConstants.TextureViewDimension.E1d,\n  texture_storage_2d: WebGPUConstants.TextureViewDimension.E2d,\n  texture_storage_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\n  texture_storage_3d: WebGPUConstants.TextureViewDimension.E3d,\n  texture_external: null\n};\n/** @internal */\nexport class WebGPUShaderProcessorWGSL extends WebGPUShaderProcessor {\n  constructor() {\n    super(...arguments);\n    this.shaderLanguage = ShaderLanguage.WGSL;\n    this.uniformRegexp = /uniform\\s+(\\w+)\\s*:\\s*(.+)\\s*;/;\n    this.textureRegexp = /var\\s+(\\w+)\\s*:\\s*((array<\\s*)?(texture_\\w+)\\s*(<\\s*(.+)\\s*>)?\\s*(,\\s*\\w+\\s*>\\s*)?);/;\n    this.noPrecision = true;\n  }\n  _getArraySize(name, uniformType, preProcessors) {\n    let length = 0;\n    const endArray = uniformType.lastIndexOf(\">\");\n    if (uniformType.indexOf(\"array\") >= 0 && endArray > 0) {\n      let startArray = endArray;\n      while (startArray > 0 && uniformType.charAt(startArray) !== \" \" && uniformType.charAt(startArray) !== \",\") {\n        startArray--;\n      }\n      const lengthInString = uniformType.substring(startArray + 1, endArray);\n      length = +lengthInString;\n      if (isNaN(length)) {\n        length = +preProcessors[lengthInString.trim()];\n      }\n      while (startArray > 0 && (uniformType.charAt(startArray) === \" \" || uniformType.charAt(startArray) === \",\")) {\n        startArray--;\n      }\n      uniformType = uniformType.substring(uniformType.indexOf(\"<\") + 1, startArray + 1);\n    }\n    return [name, uniformType, length];\n  }\n  initializeShaders(processingContext) {\n    this._webgpuProcessingContext = processingContext;\n    this._attributesInputWGSL = [];\n    this._attributesWGSL = [];\n    this._attributesConversionCodeWGSL = [];\n    this._hasNonFloatAttribute = false;\n    this._varyingsWGSL = [];\n    this._varyingNamesWGSL = [];\n    this._stridedUniformArrays = [];\n  }\n  preProcessShaderCode(code) {\n    return `struct ${WebGPUShaderProcessor.InternalsUBOName} {\\n  yFactor_: f32,\\n  textureOutputHeight_: f32,\\n};\\nvar<uniform> ${internalsVarName} : ${WebGPUShaderProcessor.InternalsUBOName};\\n` + RemoveComments(code);\n  }\n  varyingProcessor(varying, isFragment, preProcessors) {\n    const varyingRegex = /\\s*varying\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s*:\\s*(.+)\\s*;/gm;\n    const match = varyingRegex.exec(varying);\n    if (match !== null) {\n      const varyingType = match[2];\n      const name = match[1];\n      let location;\n      if (isFragment) {\n        location = this._webgpuProcessingContext.availableVaryings[name];\n        if (location === undefined) {\n          Logger.Warn(`Invalid fragment shader: The varying named \"${name}\" is not declared in the vertex shader! This declaration will be ignored.`);\n        }\n      } else {\n        location = this._webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name, varyingType, preProcessors)[2]);\n        this._webgpuProcessingContext.availableVaryings[name] = location;\n        this._varyingsWGSL.push(`  @location(${location}) ${name} : ${varyingType},`);\n        this._varyingNamesWGSL.push(name);\n      }\n      varying = \"\";\n    }\n    return varying;\n  }\n  attributeProcessor(attribute, preProcessors) {\n    const attribRegex = /\\s*attribute\\s+(\\S+)\\s*:\\s*(.+)\\s*;/gm;\n    const match = attribRegex.exec(attribute);\n    if (match !== null) {\n      const attributeType = match[2];\n      const name = match[1];\n      const location = this._webgpuProcessingContext.getAttributeNextLocation(attributeType, this._getArraySize(name, attributeType, preProcessors)[2]);\n      this._webgpuProcessingContext.availableAttributes[name] = location;\n      this._webgpuProcessingContext.orderedAttributes[location] = name;\n      const numComponents = this.vertexBufferKindToNumberOfComponents[name];\n      if (numComponents !== undefined) {\n        // Special case for an int/ivecX vertex buffer that is used as a float/vecX attribute in the shader.\n        const newType = numComponents < 0 ? numComponents === -1 ? \"i32\" : \"vec\" + -numComponents + \"<i32>\" : numComponents === 1 ? \"u32\" : \"vec\" + numComponents + \"<u32>\";\n        const newName = `_int_${name}_`;\n        this._attributesInputWGSL.push(`@location(${location}) ${newName} : ${newType},`);\n        this._attributesWGSL.push(`${name} : ${attributeType},`);\n        this._attributesConversionCodeWGSL.push(`vertexInputs.${name} = ${attributeType}(vertexInputs_.${newName});`);\n        this._hasNonFloatAttribute = true;\n      } else {\n        this._attributesInputWGSL.push(`@location(${location}) ${name} : ${attributeType},`);\n        this._attributesWGSL.push(`${name} : ${attributeType},`);\n        this._attributesConversionCodeWGSL.push(`vertexInputs.${name} = vertexInputs_.${name};`);\n      }\n      attribute = \"\";\n    }\n    return attribute;\n  }\n  uniformProcessor(uniform, isFragment, preProcessors) {\n    const match = this.uniformRegexp.exec(uniform);\n    if (match !== null) {\n      const uniformType = match[2];\n      const name = match[1];\n      this._addUniformToLeftOverUBO(name, uniformType, preProcessors);\n      uniform = \"\";\n    }\n    return uniform;\n  }\n  textureProcessor(texture, isFragment, preProcessors) {\n    const match = this.textureRegexp.exec(texture);\n    if (match !== null) {\n      const name = match[1]; // name of the variable\n      const type = match[2]; // texture_2d<f32> or array<texture_2d_array<f32>, 5> for eg\n      const isArrayOfTexture = !!match[3];\n      const textureFunc = match[4]; // texture_2d, texture_depth_2d, etc\n      const isStorageTexture = textureFunc.indexOf(\"storage\") > 0;\n      const componentType = match[6]; // f32 or i32 or u32 or undefined\n      const storageTextureFormat = isStorageTexture ? componentType.substring(0, componentType.indexOf(\",\")).trim() : null;\n      let arraySize = isArrayOfTexture ? this._getArraySize(name, type, preProcessors)[2] : 0;\n      let textureInfo = this._webgpuProcessingContext.availableTextures[name];\n      if (!textureInfo) {\n        textureInfo = {\n          isTextureArray: arraySize > 0,\n          isStorageTexture,\n          textures: [],\n          sampleType: WebGPUConstants.TextureSampleType.Float\n        };\n        arraySize = arraySize || 1;\n        for (let i = 0; i < arraySize; ++i) {\n          textureInfo.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding());\n        }\n      } else {\n        arraySize = textureInfo.textures.length;\n      }\n      this._webgpuProcessingContext.availableTextures[name] = textureInfo;\n      const isDepthTexture = textureFunc.indexOf(\"depth\") > 0;\n      const textureDimension = gpuTextureViewDimensionByWebGPUTextureFunction[textureFunc];\n      const sampleType = isDepthTexture ? WebGPUConstants.TextureSampleType.Depth : componentType === \"u32\" ? WebGPUConstants.TextureSampleType.Uint : componentType === \"i32\" ? WebGPUConstants.TextureSampleType.Sint : WebGPUConstants.TextureSampleType.Float;\n      textureInfo.sampleType = sampleType;\n      if (textureDimension === undefined) {\n        throw `Can't get the texture dimension corresponding to the texture function \"${textureFunc}\"!`;\n      }\n      for (let i = 0; i < arraySize; ++i) {\n        const {\n          groupIndex,\n          bindingIndex\n        } = textureInfo.textures[i];\n        if (i === 0) {\n          texture = `@group(${groupIndex}) @binding(${bindingIndex}) ${texture}`;\n        }\n        this._addTextureBindingDescription(name, textureInfo, i, textureDimension, storageTextureFormat, !isFragment);\n      }\n    }\n    return texture;\n  }\n  postProcessor(code) {\n    return code;\n  }\n  finalizeShaders(vertexCode, fragmentCode) {\n    const fragCoordCode = fragmentCode.indexOf(\"fragmentInputs.position\") >= 0 ? `\n            if (internals.yFactor_ == 1.) {\n                fragmentInputs.position.y = internals.textureOutputHeight_ - fragmentInputs.position.y;\n            }\n        ` : \"\";\n    // Add the group/binding info to the sampler declaration (var xxx: sampler|sampler_comparison)\n    vertexCode = this._processSamplers(vertexCode, true);\n    fragmentCode = this._processSamplers(fragmentCode, false);\n    // Add the group/binding info to the uniform/storage buffer declarations (var<uniform> XXX:YYY or var<storage(,read_write|read)> XXX:YYY)\n    vertexCode = this._processCustomBuffers(vertexCode, true);\n    fragmentCode = this._processCustomBuffers(fragmentCode, false);\n    // Builds the leftover UBOs.\n    const leftOverUBO = this._buildLeftOverUBO();\n    vertexCode = leftOverUBO + vertexCode;\n    fragmentCode = leftOverUBO + fragmentCode;\n    // Vertex code\n    vertexCode = vertexCode.replace(/#define /g, \"//#define \");\n    vertexCode = this._processStridedUniformArrays(vertexCode);\n    let vertexInputs = \"struct VertexInputs {\\n  @builtin(vertex_index) vertexIndex : u32,\\n  @builtin(instance_index) instanceIndex : u32,\\n\";\n    if (this._attributesInputWGSL.length > 0) {\n      vertexInputs += this._attributesInputWGSL.join(\"\\n\");\n    }\n    vertexInputs += \"\\n};\\nvar<private> vertexInputs\" + (this._hasNonFloatAttribute ? \"_\" : \"\") + \" : VertexInputs;\\n\";\n    if (this._hasNonFloatAttribute) {\n      vertexInputs += \"struct VertexInputs_ {\\n  vertexIndex : u32, instanceIndex : u32,\\n\";\n      vertexInputs += this._attributesWGSL.join(\"\\n\");\n      vertexInputs += \"\\n};\\nvar<private> vertexInputs : VertexInputs_;\\n\";\n    }\n    let vertexOutputs = \"struct FragmentInputs {\\n  @builtin(position) position : vec4<f32>,\\n\";\n    if (this._varyingsWGSL.length > 0) {\n      vertexOutputs += this._varyingsWGSL.join(\"\\n\");\n    }\n    vertexOutputs += \"\\n};\\nvar<private> vertexOutputs : FragmentInputs;\\n\";\n    vertexCode = vertexInputs + vertexOutputs + vertexCode;\n    let vertexMainStartingCode = `\\n  vertexInputs${this._hasNonFloatAttribute ? \"_\" : \"\"} = input;\\n`;\n    if (this._hasNonFloatAttribute) {\n      vertexMainStartingCode += \"vertexInputs.vertexIndex = vertexInputs_.vertexIndex;\\nvertexInputs.instanceIndex = vertexInputs_.instanceIndex;\\n\";\n      vertexMainStartingCode += this._attributesConversionCodeWGSL.join(\"\\n\");\n      vertexMainStartingCode += \"\\n\";\n    }\n    const vertexMainEndingCode = `  vertexOutputs.position.y = vertexOutputs.position.y * internals.yFactor_;\\n  return vertexOutputs;`;\n    vertexCode = this._injectStartingAndEndingCode(vertexCode, \"fn main\", vertexMainStartingCode, vertexMainEndingCode);\n    // fragment code\n    fragmentCode = fragmentCode.replace(/#define /g, \"//#define \");\n    fragmentCode = this._processStridedUniformArrays(fragmentCode);\n    fragmentCode = fragmentCode.replace(/dpdy/g, \"(-internals.yFactor_)*dpdy\"); // will also handle dpdyCoarse and dpdyFine\n    let fragmentInputs = \"struct FragmentInputs {\\n  @builtin(position) position : vec4<f32>,\\n  @builtin(front_facing) frontFacing : bool,\\n\";\n    if (this._varyingsWGSL.length > 0) {\n      fragmentInputs += this._varyingsWGSL.join(\"\\n\");\n    }\n    fragmentInputs += \"\\n};\\nvar<private> fragmentInputs : FragmentInputs;\\n\";\n    let fragmentOutputs = \"struct FragmentOutputs {\\n  @location(0) color : vec4<f32>,\\n\";\n    let hasFragDepth = false;\n    let idx = 0;\n    while (!hasFragDepth) {\n      idx = fragmentCode.indexOf(builtInName_frag_depth, idx);\n      if (idx < 0) {\n        break;\n      }\n      const saveIndex = idx;\n      hasFragDepth = true;\n      while (idx > 1 && fragmentCode.charAt(idx) !== \"\\n\") {\n        if (fragmentCode.charAt(idx) === \"/\" && fragmentCode.charAt(idx - 1) === \"/\") {\n          hasFragDepth = false;\n          break;\n        }\n        idx--;\n      }\n      idx = saveIndex + builtInName_frag_depth.length;\n    }\n    if (hasFragDepth) {\n      fragmentOutputs += \"  @builtin(frag_depth) fragDepth: f32,\\n\";\n    }\n    fragmentOutputs += \"};\\nvar<private> fragmentOutputs : FragmentOutputs;\\n\";\n    fragmentCode = fragmentInputs + fragmentOutputs + fragmentCode;\n    const fragmentStartingCode = \"  fragmentInputs = input;\\n  \" + fragCoordCode;\n    const fragmentEndingCode = \"  return fragmentOutputs;\";\n    fragmentCode = this._injectStartingAndEndingCode(fragmentCode, \"fn main\", fragmentStartingCode, fragmentEndingCode);\n    this._collectBindingNames();\n    this._preCreateBindGroupEntries();\n    this.vertexBufferKindToNumberOfComponents = {};\n    return {\n      vertexCode,\n      fragmentCode\n    };\n  }\n  _generateLeftOverUBOCode(name, uniformBufferDescription) {\n    let stridedArrays = \"\";\n    let ubo = `struct ${name} {\\n`;\n    for (const leftOverUniform of this._webgpuProcessingContext.leftOverUniforms) {\n      const type = leftOverUniform.type.replace(/^(.*?)(<.*>)?$/, \"$1\");\n      const size = WebGPUShaderProcessor.UniformSizes[type];\n      if (leftOverUniform.length > 0) {\n        if (size <= 2) {\n          const stridedArrayType = `${name}_${this._stridedUniformArrays.length}_strided_arr`;\n          stridedArrays += `struct ${stridedArrayType} {\n                        @size(16)\n                        el: ${type},\n                    }`;\n          this._stridedUniformArrays.push(leftOverUniform.name);\n          ubo += ` @align(16) ${leftOverUniform.name} : array<${stridedArrayType}, ${leftOverUniform.length}>,\\n`;\n        } else {\n          ubo += ` ${leftOverUniform.name} : array<${leftOverUniform.type}, ${leftOverUniform.length}>,\\n`;\n        }\n      } else {\n        ubo += `  ${leftOverUniform.name} : ${leftOverUniform.type},\\n`;\n      }\n    }\n    ubo += \"};\\n\";\n    ubo = `${stridedArrays}\\n${ubo}`;\n    ubo += `@group(${uniformBufferDescription.binding.groupIndex}) @binding(${uniformBufferDescription.binding.bindingIndex}) var<uniform> ${leftOverVarName} : ${name};\\n`;\n    return ubo;\n  }\n  _processSamplers(code, isVertex) {\n    const samplerRegexp = /var\\s+(\\w+Sampler)\\s*:\\s*(sampler|sampler_comparison)\\s*;/gm;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const match = samplerRegexp.exec(code);\n      if (match === null) {\n        break;\n      }\n      const name = match[1]; // name of the variable\n      const samplerType = match[2]; // sampler or sampler_comparison\n      const textureName = name.indexOf(WebGPUShaderProcessor.AutoSamplerSuffix) === name.length - WebGPUShaderProcessor.AutoSamplerSuffix.length ? name.substring(0, name.indexOf(WebGPUShaderProcessor.AutoSamplerSuffix)) : null;\n      const samplerBindingType = samplerType === \"sampler_comparison\" ? WebGPUConstants.SamplerBindingType.Comparison : WebGPUConstants.SamplerBindingType.Filtering;\n      if (textureName) {\n        const textureInfo = this._webgpuProcessingContext.availableTextures[textureName];\n        if (textureInfo) {\n          textureInfo.autoBindSampler = true;\n        }\n      }\n      let samplerInfo = this._webgpuProcessingContext.availableSamplers[name];\n      if (!samplerInfo) {\n        samplerInfo = {\n          binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),\n          type: samplerBindingType\n        };\n        this._webgpuProcessingContext.availableSamplers[name] = samplerInfo;\n      }\n      this._addSamplerBindingDescription(name, samplerInfo, isVertex);\n      const part1 = code.substring(0, match.index);\n      const insertPart = `@group(${samplerInfo.binding.groupIndex}) @binding(${samplerInfo.binding.bindingIndex}) `;\n      const part2 = code.substring(match.index);\n      code = part1 + insertPart + part2;\n      samplerRegexp.lastIndex += insertPart.length;\n    }\n    return code;\n  }\n  _processCustomBuffers(code, isVertex) {\n    const instantiateBufferRegexp = /var<\\s*(uniform|storage)\\s*(,\\s*(read|read_write)\\s*)?>\\s+(\\S+)\\s*:\\s*(\\S+)\\s*;/gm;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const match = instantiateBufferRegexp.exec(code);\n      if (match === null) {\n        break;\n      }\n      const type = match[1];\n      const decoration = match[3];\n      let name = match[4];\n      const structName = match[5];\n      let bufferInfo = this._webgpuProcessingContext.availableBuffers[name];\n      if (!bufferInfo) {\n        const knownUBO = type === \"uniform\" ? WebGPUShaderProcessingContext.KnownUBOs[structName] : null;\n        let binding;\n        if (knownUBO) {\n          name = structName;\n          binding = knownUBO.binding;\n          if (binding.groupIndex === -1) {\n            binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\n          }\n        } else {\n          binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\n        }\n        bufferInfo = {\n          binding\n        };\n        this._webgpuProcessingContext.availableBuffers[name] = bufferInfo;\n      }\n      this._addBufferBindingDescription(name, this._webgpuProcessingContext.availableBuffers[name], decoration === \"read_write\" ? WebGPUConstants.BufferBindingType.Storage : type === \"storage\" ? WebGPUConstants.BufferBindingType.ReadOnlyStorage : WebGPUConstants.BufferBindingType.Uniform, isVertex);\n      const groupIndex = bufferInfo.binding.groupIndex;\n      const bindingIndex = bufferInfo.binding.bindingIndex;\n      const part1 = code.substring(0, match.index);\n      const insertPart = `@group(${groupIndex}) @binding(${bindingIndex}) `;\n      const part2 = code.substring(match.index);\n      code = part1 + insertPart + part2;\n      instantiateBufferRegexp.lastIndex += insertPart.length;\n    }\n    return code;\n  }\n  _processStridedUniformArrays(code) {\n    for (const uniformArrayName of this._stridedUniformArrays) {\n      code = code.replace(new RegExp(`${uniformArrayName}\\\\s*\\\\[(.*)\\\\]`, \"g\"), `${uniformArrayName}[$1].el`);\n    }\n    return code;\n  }\n}","map":{"version":3,"names":["WebGPUShaderProcessingContext","WebGPUConstants","Logger","WebGPUShaderProcessor","RemoveComments","ShaderLanguage","builtInName_frag_depth","leftOverVarName","internalsVarName","gpuTextureViewDimensionByWebGPUTextureFunction","texture_1d","TextureViewDimension","E1d","texture_2d","E2d","texture_2d_array","E2dArray","texture_3d","E3d","texture_cube","Cube","texture_cube_array","CubeArray","texture_multisampled_2d","texture_depth_2d","texture_depth_2d_array","texture_depth_cube","texture_depth_cube_array","texture_depth_multisampled_2d","texture_storage_1d","texture_storage_2d","texture_storage_2d_array","texture_storage_3d","texture_external","WebGPUShaderProcessorWGSL","constructor","shaderLanguage","WGSL","uniformRegexp","textureRegexp","noPrecision","_getArraySize","name","uniformType","preProcessors","length","endArray","lastIndexOf","indexOf","startArray","charAt","lengthInString","substring","isNaN","trim","initializeShaders","processingContext","_webgpuProcessingContext","_attributesInputWGSL","_attributesWGSL","_attributesConversionCodeWGSL","_hasNonFloatAttribute","_varyingsWGSL","_varyingNamesWGSL","_stridedUniformArrays","preProcessShaderCode","code","InternalsUBOName","varyingProcessor","varying","isFragment","varyingRegex","match","exec","varyingType","location","availableVaryings","undefined","Warn","getVaryingNextLocation","push","attributeProcessor","attribute","attribRegex","attributeType","getAttributeNextLocation","availableAttributes","orderedAttributes","numComponents","vertexBufferKindToNumberOfComponents","newType","newName","uniformProcessor","uniform","_addUniformToLeftOverUBO","textureProcessor","texture","type","isArrayOfTexture","textureFunc","isStorageTexture","componentType","storageTextureFormat","arraySize","textureInfo","availableTextures","isTextureArray","textures","sampleType","TextureSampleType","Float","i","getNextFreeUBOBinding","isDepthTexture","textureDimension","Depth","Uint","Sint","groupIndex","bindingIndex","_addTextureBindingDescription","postProcessor","finalizeShaders","vertexCode","fragmentCode","fragCoordCode","_processSamplers","_processCustomBuffers","leftOverUBO","_buildLeftOverUBO","replace","_processStridedUniformArrays","vertexInputs","join","vertexOutputs","vertexMainStartingCode","vertexMainEndingCode","_injectStartingAndEndingCode","fragmentInputs","fragmentOutputs","hasFragDepth","idx","saveIndex","fragmentStartingCode","fragmentEndingCode","_collectBindingNames","_preCreateBindGroupEntries","_generateLeftOverUBOCode","uniformBufferDescription","stridedArrays","ubo","leftOverUniform","leftOverUniforms","size","UniformSizes","stridedArrayType","binding","isVertex","samplerRegexp","samplerType","textureName","AutoSamplerSuffix","samplerBindingType","SamplerBindingType","Comparison","Filtering","autoBindSampler","samplerInfo","availableSamplers","_addSamplerBindingDescription","part1","index","insertPart","part2","lastIndex","instantiateBufferRegexp","decoration","structName","bufferInfo","availableBuffers","knownUBO","KnownUBOs","_addBufferBindingDescription","BufferBindingType","Storage","ReadOnlyStorage","Uniform","uniformArrayName","RegExp"],"sources":["../../../../../dev/core/src/Engines/WebGPU/webgpuShaderProcessorsWGSL.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\n/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ShaderProcessingContext } from \"../Processors/shaderProcessingOptions\";\r\nimport type { WebGPUBufferDescription } from \"./webgpuShaderProcessingContext\";\r\nimport { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor\";\r\nimport { RemoveComments } from \"../../Misc/codeStringParsingTools\";\r\n\r\nimport \"../../ShadersWGSL/ShadersInclude/bonesDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/bonesVertex\";\r\nimport \"../../ShadersWGSL/ShadersInclude/bakedVertexAnimationDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/bakedVertexAnimation\";\r\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneFragment\";\r\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneFragmentDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneVertex\";\r\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneVertexDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/instancesDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/instancesVertex\";\r\nimport \"../../ShadersWGSL/ShadersInclude/meshUboDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertex\";\r\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertexDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertexGlobal\";\r\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertexGlobalDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/sceneUboDeclaration\";\r\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\n\r\nconst builtInName_frag_depth = \"fragmentOutputs.fragDepth\";\r\n\r\nconst leftOverVarName = \"uniforms\";\r\nconst internalsVarName = \"internals\";\r\n\r\nconst gpuTextureViewDimensionByWebGPUTextureFunction: { [key: string]: Nullable<GPUTextureViewDimension> } = {\r\n    texture_1d: WebGPUConstants.TextureViewDimension.E1d,\r\n    texture_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\r\n    texture_3d: WebGPUConstants.TextureViewDimension.E3d,\r\n    texture_cube: WebGPUConstants.TextureViewDimension.Cube,\r\n    texture_cube_array: WebGPUConstants.TextureViewDimension.CubeArray,\r\n    texture_multisampled_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_depth_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_depth_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\r\n    texture_depth_cube: WebGPUConstants.TextureViewDimension.Cube,\r\n    texture_depth_cube_array: WebGPUConstants.TextureViewDimension.CubeArray,\r\n    texture_depth_multisampled_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_storage_1d: WebGPUConstants.TextureViewDimension.E1d,\r\n    texture_storage_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_storage_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\r\n    texture_storage_3d: WebGPUConstants.TextureViewDimension.E3d,\r\n    texture_external: null,\r\n};\r\n\r\n/** @internal */\r\nexport class WebGPUShaderProcessorWGSL extends WebGPUShaderProcessor {\r\n    protected _attributesInputWGSL: string[];\r\n    protected _attributesWGSL: string[];\r\n    protected _attributesConversionCodeWGSL: string[];\r\n    protected _hasNonFloatAttribute: boolean;\r\n    protected _varyingsWGSL: string[];\r\n    protected _varyingNamesWGSL: string[];\r\n    protected _stridedUniformArrays: string[];\r\n\r\n    public shaderLanguage = ShaderLanguage.WGSL;\r\n    public uniformRegexp = /uniform\\s+(\\w+)\\s*:\\s*(.+)\\s*;/;\r\n    public textureRegexp = /var\\s+(\\w+)\\s*:\\s*((array<\\s*)?(texture_\\w+)\\s*(<\\s*(.+)\\s*>)?\\s*(,\\s*\\w+\\s*>\\s*)?);/;\r\n    public noPrecision = true;\r\n\r\n    protected _getArraySize(name: string, uniformType: string, preProcessors: { [key: string]: string }): [string, string, number] {\r\n        let length = 0;\r\n\r\n        const endArray = uniformType.lastIndexOf(\">\");\r\n        if (uniformType.indexOf(\"array\") >= 0 && endArray > 0) {\r\n            let startArray = endArray;\r\n            while (startArray > 0 && uniformType.charAt(startArray) !== \" \" && uniformType.charAt(startArray) !== \",\") {\r\n                startArray--;\r\n            }\r\n            const lengthInString = uniformType.substring(startArray + 1, endArray);\r\n            length = +lengthInString;\r\n            if (isNaN(length)) {\r\n                length = +preProcessors[lengthInString.trim()];\r\n            }\r\n            while (startArray > 0 && (uniformType.charAt(startArray) === \" \" || uniformType.charAt(startArray) === \",\")) {\r\n                startArray--;\r\n            }\r\n            uniformType = uniformType.substring(uniformType.indexOf(\"<\") + 1, startArray + 1);\r\n        }\r\n\r\n        return [name, uniformType, length];\r\n    }\r\n\r\n    public initializeShaders(processingContext: Nullable<ShaderProcessingContext>): void {\r\n        this._webgpuProcessingContext = processingContext as WebGPUShaderProcessingContext;\r\n\r\n        this._attributesInputWGSL = [];\r\n        this._attributesWGSL = [];\r\n        this._attributesConversionCodeWGSL = [];\r\n        this._hasNonFloatAttribute = false;\r\n        this._varyingsWGSL = [];\r\n        this._varyingNamesWGSL = [];\r\n        this._stridedUniformArrays = [];\r\n    }\r\n\r\n    public preProcessShaderCode(code: string): string {\r\n        return (\r\n            `struct ${WebGPUShaderProcessor.InternalsUBOName} {\\n  yFactor_: f32,\\n  textureOutputHeight_: f32,\\n};\\nvar<uniform> ${internalsVarName} : ${WebGPUShaderProcessor.InternalsUBOName};\\n` +\r\n            RemoveComments(code)\r\n        );\r\n    }\r\n\r\n    public varyingProcessor(varying: string, isFragment: boolean, preProcessors: { [key: string]: string }) {\r\n        const varyingRegex = /\\s*varying\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s*:\\s*(.+)\\s*;/gm;\r\n        const match = varyingRegex.exec(varying);\r\n        if (match !== null) {\r\n            const varyingType = match[2];\r\n            const name = match[1];\r\n            let location: number;\r\n            if (isFragment) {\r\n                location = this._webgpuProcessingContext.availableVaryings[name];\r\n                if (location === undefined) {\r\n                    Logger.Warn(`Invalid fragment shader: The varying named \"${name}\" is not declared in the vertex shader! This declaration will be ignored.`);\r\n                }\r\n            } else {\r\n                location = this._webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name, varyingType, preProcessors)[2]);\r\n                this._webgpuProcessingContext.availableVaryings[name] = location;\r\n                this._varyingsWGSL.push(`  @location(${location}) ${name} : ${varyingType},`);\r\n                this._varyingNamesWGSL.push(name);\r\n            }\r\n\r\n            varying = \"\";\r\n        }\r\n        return varying;\r\n    }\r\n\r\n    public attributeProcessor(attribute: string, preProcessors: { [key: string]: string }) {\r\n        const attribRegex = /\\s*attribute\\s+(\\S+)\\s*:\\s*(.+)\\s*;/gm;\r\n        const match = attribRegex.exec(attribute);\r\n        if (match !== null) {\r\n            const attributeType = match[2];\r\n            const name = match[1];\r\n            const location = this._webgpuProcessingContext.getAttributeNextLocation(attributeType, this._getArraySize(name, attributeType, preProcessors)[2]);\r\n\r\n            this._webgpuProcessingContext.availableAttributes[name] = location;\r\n            this._webgpuProcessingContext.orderedAttributes[location] = name;\r\n\r\n            const numComponents = this.vertexBufferKindToNumberOfComponents[name];\r\n            if (numComponents !== undefined) {\r\n                // Special case for an int/ivecX vertex buffer that is used as a float/vecX attribute in the shader.\r\n                const newType =\r\n                    numComponents < 0 ? (numComponents === -1 ? \"i32\" : \"vec\" + -numComponents + \"<i32>\") : numComponents === 1 ? \"u32\" : \"vec\" + numComponents + \"<u32>\";\r\n                const newName = `_int_${name}_`;\r\n\r\n                this._attributesInputWGSL.push(`@location(${location}) ${newName} : ${newType},`);\r\n                this._attributesWGSL.push(`${name} : ${attributeType},`);\r\n                this._attributesConversionCodeWGSL.push(`vertexInputs.${name} = ${attributeType}(vertexInputs_.${newName});`);\r\n                this._hasNonFloatAttribute = true;\r\n            } else {\r\n                this._attributesInputWGSL.push(`@location(${location}) ${name} : ${attributeType},`);\r\n                this._attributesWGSL.push(`${name} : ${attributeType},`);\r\n                this._attributesConversionCodeWGSL.push(`vertexInputs.${name} = vertexInputs_.${name};`);\r\n            }\r\n            attribute = \"\";\r\n        }\r\n        return attribute;\r\n    }\r\n\r\n    public uniformProcessor(uniform: string, isFragment: boolean, preProcessors: { [key: string]: string }): string {\r\n        const match = this.uniformRegexp.exec(uniform);\r\n        if (match !== null) {\r\n            const uniformType = match[2];\r\n            const name = match[1];\r\n\r\n            this._addUniformToLeftOverUBO(name, uniformType, preProcessors);\r\n\r\n            uniform = \"\";\r\n        }\r\n        return uniform;\r\n    }\r\n\r\n    public textureProcessor(texture: string, isFragment: boolean, preProcessors: { [key: string]: string }): string {\r\n        const match = this.textureRegexp.exec(texture);\r\n        if (match !== null) {\r\n            const name = match[1]; // name of the variable\r\n            const type = match[2]; // texture_2d<f32> or array<texture_2d_array<f32>, 5> for eg\r\n            const isArrayOfTexture = !!match[3];\r\n            const textureFunc = match[4]; // texture_2d, texture_depth_2d, etc\r\n            const isStorageTexture = textureFunc.indexOf(\"storage\") > 0;\r\n            const componentType = match[6]; // f32 or i32 or u32 or undefined\r\n            const storageTextureFormat = isStorageTexture ? (componentType.substring(0, componentType.indexOf(\",\")).trim() as GPUTextureFormat) : null;\r\n\r\n            let arraySize = isArrayOfTexture ? this._getArraySize(name, type, preProcessors)[2] : 0;\r\n            let textureInfo = this._webgpuProcessingContext.availableTextures[name];\r\n            if (!textureInfo) {\r\n                textureInfo = {\r\n                    isTextureArray: arraySize > 0,\r\n                    isStorageTexture,\r\n                    textures: [],\r\n                    sampleType: WebGPUConstants.TextureSampleType.Float,\r\n                };\r\n                arraySize = arraySize || 1;\r\n                for (let i = 0; i < arraySize; ++i) {\r\n                    textureInfo.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding());\r\n                }\r\n            } else {\r\n                arraySize = textureInfo.textures.length;\r\n            }\r\n\r\n            this._webgpuProcessingContext.availableTextures[name] = textureInfo;\r\n\r\n            const isDepthTexture = textureFunc.indexOf(\"depth\") > 0;\r\n            const textureDimension = gpuTextureViewDimensionByWebGPUTextureFunction[textureFunc];\r\n            const sampleType = isDepthTexture\r\n                ? WebGPUConstants.TextureSampleType.Depth\r\n                : componentType === \"u32\"\r\n                ? WebGPUConstants.TextureSampleType.Uint\r\n                : componentType === \"i32\"\r\n                ? WebGPUConstants.TextureSampleType.Sint\r\n                : WebGPUConstants.TextureSampleType.Float;\r\n\r\n            textureInfo.sampleType = sampleType;\r\n\r\n            if (textureDimension === undefined) {\r\n                throw `Can't get the texture dimension corresponding to the texture function \"${textureFunc}\"!`;\r\n            }\r\n\r\n            for (let i = 0; i < arraySize; ++i) {\r\n                const { groupIndex, bindingIndex } = textureInfo.textures[i];\r\n\r\n                if (i === 0) {\r\n                    texture = `@group(${groupIndex}) @binding(${bindingIndex}) ${texture}`;\r\n                }\r\n\r\n                this._addTextureBindingDescription(name, textureInfo, i, textureDimension, storageTextureFormat, !isFragment);\r\n            }\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    public postProcessor(code: string) {\r\n        return code;\r\n    }\r\n\r\n    public finalizeShaders(vertexCode: string, fragmentCode: string): { vertexCode: string; fragmentCode: string } {\r\n        const fragCoordCode =\r\n            fragmentCode.indexOf(\"fragmentInputs.position\") >= 0\r\n                ? `\r\n            if (internals.yFactor_ == 1.) {\r\n                fragmentInputs.position.y = internals.textureOutputHeight_ - fragmentInputs.position.y;\r\n            }\r\n        `\r\n                : \"\";\r\n\r\n        // Add the group/binding info to the sampler declaration (var xxx: sampler|sampler_comparison)\r\n        vertexCode = this._processSamplers(vertexCode, true);\r\n        fragmentCode = this._processSamplers(fragmentCode, false);\r\n\r\n        // Add the group/binding info to the uniform/storage buffer declarations (var<uniform> XXX:YYY or var<storage(,read_write|read)> XXX:YYY)\r\n        vertexCode = this._processCustomBuffers(vertexCode, true);\r\n        fragmentCode = this._processCustomBuffers(fragmentCode, false);\r\n\r\n        // Builds the leftover UBOs.\r\n        const leftOverUBO = this._buildLeftOverUBO();\r\n\r\n        vertexCode = leftOverUBO + vertexCode;\r\n        fragmentCode = leftOverUBO + fragmentCode;\r\n\r\n        // Vertex code\r\n        vertexCode = vertexCode.replace(/#define /g, \"//#define \");\r\n        vertexCode = this._processStridedUniformArrays(vertexCode);\r\n\r\n        let vertexInputs = \"struct VertexInputs {\\n  @builtin(vertex_index) vertexIndex : u32,\\n  @builtin(instance_index) instanceIndex : u32,\\n\";\r\n        if (this._attributesInputWGSL.length > 0) {\r\n            vertexInputs += this._attributesInputWGSL.join(\"\\n\");\r\n        }\r\n        vertexInputs += \"\\n};\\nvar<private> vertexInputs\" + (this._hasNonFloatAttribute ? \"_\" : \"\") + \" : VertexInputs;\\n\";\r\n        if (this._hasNonFloatAttribute) {\r\n            vertexInputs += \"struct VertexInputs_ {\\n  vertexIndex : u32, instanceIndex : u32,\\n\";\r\n            vertexInputs += this._attributesWGSL.join(\"\\n\");\r\n            vertexInputs += \"\\n};\\nvar<private> vertexInputs : VertexInputs_;\\n\";\r\n        }\r\n\r\n        let vertexOutputs = \"struct FragmentInputs {\\n  @builtin(position) position : vec4<f32>,\\n\";\r\n        if (this._varyingsWGSL.length > 0) {\r\n            vertexOutputs += this._varyingsWGSL.join(\"\\n\");\r\n        }\r\n        vertexOutputs += \"\\n};\\nvar<private> vertexOutputs : FragmentInputs;\\n\";\r\n\r\n        vertexCode = vertexInputs + vertexOutputs + vertexCode;\r\n\r\n        let vertexMainStartingCode = `\\n  vertexInputs${this._hasNonFloatAttribute ? \"_\" : \"\"} = input;\\n`;\r\n        if (this._hasNonFloatAttribute) {\r\n            vertexMainStartingCode += \"vertexInputs.vertexIndex = vertexInputs_.vertexIndex;\\nvertexInputs.instanceIndex = vertexInputs_.instanceIndex;\\n\";\r\n            vertexMainStartingCode += this._attributesConversionCodeWGSL.join(\"\\n\");\r\n            vertexMainStartingCode += \"\\n\";\r\n        }\r\n        const vertexMainEndingCode = `  vertexOutputs.position.y = vertexOutputs.position.y * internals.yFactor_;\\n  return vertexOutputs;`;\r\n\r\n        vertexCode = this._injectStartingAndEndingCode(vertexCode, \"fn main\", vertexMainStartingCode, vertexMainEndingCode);\r\n\r\n        // fragment code\r\n        fragmentCode = fragmentCode.replace(/#define /g, \"//#define \");\r\n        fragmentCode = this._processStridedUniformArrays(fragmentCode);\r\n        fragmentCode = fragmentCode.replace(/dpdy/g, \"(-internals.yFactor_)*dpdy\"); // will also handle dpdyCoarse and dpdyFine\r\n\r\n        let fragmentInputs = \"struct FragmentInputs {\\n  @builtin(position) position : vec4<f32>,\\n  @builtin(front_facing) frontFacing : bool,\\n\";\r\n        if (this._varyingsWGSL.length > 0) {\r\n            fragmentInputs += this._varyingsWGSL.join(\"\\n\");\r\n        }\r\n        fragmentInputs += \"\\n};\\nvar<private> fragmentInputs : FragmentInputs;\\n\";\r\n\r\n        let fragmentOutputs = \"struct FragmentOutputs {\\n  @location(0) color : vec4<f32>,\\n\";\r\n\r\n        let hasFragDepth = false;\r\n        let idx = 0;\r\n        while (!hasFragDepth) {\r\n            idx = fragmentCode.indexOf(builtInName_frag_depth, idx);\r\n            if (idx < 0) {\r\n                break;\r\n            }\r\n            const saveIndex = idx;\r\n            hasFragDepth = true;\r\n            while (idx > 1 && fragmentCode.charAt(idx) !== \"\\n\") {\r\n                if (fragmentCode.charAt(idx) === \"/\" && fragmentCode.charAt(idx - 1) === \"/\") {\r\n                    hasFragDepth = false;\r\n                    break;\r\n                }\r\n                idx--;\r\n            }\r\n            idx = saveIndex + builtInName_frag_depth.length;\r\n        }\r\n\r\n        if (hasFragDepth) {\r\n            fragmentOutputs += \"  @builtin(frag_depth) fragDepth: f32,\\n\";\r\n        }\r\n\r\n        fragmentOutputs += \"};\\nvar<private> fragmentOutputs : FragmentOutputs;\\n\";\r\n\r\n        fragmentCode = fragmentInputs + fragmentOutputs + fragmentCode;\r\n\r\n        const fragmentStartingCode = \"  fragmentInputs = input;\\n  \" + fragCoordCode;\r\n        const fragmentEndingCode = \"  return fragmentOutputs;\";\r\n\r\n        fragmentCode = this._injectStartingAndEndingCode(fragmentCode, \"fn main\", fragmentStartingCode, fragmentEndingCode);\r\n\r\n        this._collectBindingNames();\r\n        this._preCreateBindGroupEntries();\r\n\r\n        this.vertexBufferKindToNumberOfComponents = {};\r\n\r\n        return { vertexCode, fragmentCode };\r\n    }\r\n\r\n    protected _generateLeftOverUBOCode(name: string, uniformBufferDescription: WebGPUBufferDescription): string {\r\n        let stridedArrays = \"\";\r\n        let ubo = `struct ${name} {\\n`;\r\n        for (const leftOverUniform of this._webgpuProcessingContext.leftOverUniforms) {\r\n            const type = leftOverUniform.type.replace(/^(.*?)(<.*>)?$/, \"$1\");\r\n            const size = WebGPUShaderProcessor.UniformSizes[type];\r\n\r\n            if (leftOverUniform.length > 0) {\r\n                if (size <= 2) {\r\n                    const stridedArrayType = `${name}_${this._stridedUniformArrays.length}_strided_arr`;\r\n                    stridedArrays += `struct ${stridedArrayType} {\r\n                        @size(16)\r\n                        el: ${type},\r\n                    }`;\r\n                    this._stridedUniformArrays.push(leftOverUniform.name);\r\n\r\n                    ubo += ` @align(16) ${leftOverUniform.name} : array<${stridedArrayType}, ${leftOverUniform.length}>,\\n`;\r\n                } else {\r\n                    ubo += ` ${leftOverUniform.name} : array<${leftOverUniform.type}, ${leftOverUniform.length}>,\\n`;\r\n                }\r\n            } else {\r\n                ubo += `  ${leftOverUniform.name} : ${leftOverUniform.type},\\n`;\r\n            }\r\n        }\r\n        ubo += \"};\\n\";\r\n        ubo = `${stridedArrays}\\n${ubo}`;\r\n        ubo += `@group(${uniformBufferDescription.binding.groupIndex}) @binding(${uniformBufferDescription.binding.bindingIndex}) var<uniform> ${leftOverVarName} : ${name};\\n`;\r\n\r\n        return ubo;\r\n    }\r\n\r\n    private _processSamplers(code: string, isVertex: boolean): string {\r\n        const samplerRegexp = /var\\s+(\\w+Sampler)\\s*:\\s*(sampler|sampler_comparison)\\s*;/gm;\r\n\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            const match = samplerRegexp.exec(code);\r\n            if (match === null) {\r\n                break;\r\n            }\r\n\r\n            const name = match[1]; // name of the variable\r\n            const samplerType = match[2]; // sampler or sampler_comparison\r\n            const textureName =\r\n                name.indexOf(WebGPUShaderProcessor.AutoSamplerSuffix) === name.length - WebGPUShaderProcessor.AutoSamplerSuffix.length\r\n                    ? name.substring(0, name.indexOf(WebGPUShaderProcessor.AutoSamplerSuffix))\r\n                    : null;\r\n            const samplerBindingType = samplerType === \"sampler_comparison\" ? WebGPUConstants.SamplerBindingType.Comparison : WebGPUConstants.SamplerBindingType.Filtering;\r\n\r\n            if (textureName) {\r\n                const textureInfo = this._webgpuProcessingContext.availableTextures[textureName];\r\n                if (textureInfo) {\r\n                    textureInfo.autoBindSampler = true;\r\n                }\r\n            }\r\n\r\n            let samplerInfo = this._webgpuProcessingContext.availableSamplers[name];\r\n            if (!samplerInfo) {\r\n                samplerInfo = {\r\n                    binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),\r\n                    type: samplerBindingType,\r\n                };\r\n                this._webgpuProcessingContext.availableSamplers[name] = samplerInfo;\r\n            }\r\n\r\n            this._addSamplerBindingDescription(name, samplerInfo, isVertex);\r\n\r\n            const part1 = code.substring(0, match.index);\r\n            const insertPart = `@group(${samplerInfo.binding.groupIndex}) @binding(${samplerInfo.binding.bindingIndex}) `;\r\n            const part2 = code.substring(match.index);\r\n\r\n            code = part1 + insertPart + part2;\r\n\r\n            samplerRegexp.lastIndex += insertPart.length;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    private _processCustomBuffers(code: string, isVertex: boolean): string {\r\n        const instantiateBufferRegexp = /var<\\s*(uniform|storage)\\s*(,\\s*(read|read_write)\\s*)?>\\s+(\\S+)\\s*:\\s*(\\S+)\\s*;/gm;\r\n\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            const match = instantiateBufferRegexp.exec(code);\r\n            if (match === null) {\r\n                break;\r\n            }\r\n\r\n            const type = match[1];\r\n            const decoration = match[3];\r\n            let name = match[4];\r\n            const structName = match[5];\r\n\r\n            let bufferInfo = this._webgpuProcessingContext.availableBuffers[name];\r\n            if (!bufferInfo) {\r\n                const knownUBO = type === \"uniform\" ? WebGPUShaderProcessingContext.KnownUBOs[structName] : null;\r\n\r\n                let binding;\r\n                if (knownUBO) {\r\n                    name = structName;\r\n                    binding = knownUBO.binding;\r\n                    if (binding.groupIndex === -1) {\r\n                        binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\r\n                    }\r\n                } else {\r\n                    binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\r\n                }\r\n\r\n                bufferInfo = { binding };\r\n                this._webgpuProcessingContext.availableBuffers[name] = bufferInfo;\r\n            }\r\n\r\n            this._addBufferBindingDescription(\r\n                name,\r\n                this._webgpuProcessingContext.availableBuffers[name],\r\n                decoration === \"read_write\"\r\n                    ? WebGPUConstants.BufferBindingType.Storage\r\n                    : type === \"storage\"\r\n                    ? WebGPUConstants.BufferBindingType.ReadOnlyStorage\r\n                    : WebGPUConstants.BufferBindingType.Uniform,\r\n                isVertex\r\n            );\r\n\r\n            const groupIndex = bufferInfo.binding.groupIndex;\r\n            const bindingIndex = bufferInfo.binding.bindingIndex;\r\n\r\n            const part1 = code.substring(0, match.index);\r\n            const insertPart = `@group(${groupIndex}) @binding(${bindingIndex}) `;\r\n            const part2 = code.substring(match.index);\r\n\r\n            code = part1 + insertPart + part2;\r\n\r\n            instantiateBufferRegexp.lastIndex += insertPart.length;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    private _processStridedUniformArrays(code: string): string {\r\n        for (const uniformArrayName of this._stridedUniformArrays) {\r\n            code = code.replace(new RegExp(`${uniformArrayName}\\\\s*\\\\[(.*)\\\\]`, \"g\"), `${uniformArrayName}[$1].el`);\r\n        }\r\n        return code;\r\n    }\r\n}\r\n"],"mappings":";AAMA,SAASA,6BAA6B,QAAQ,oCAAkC;AAChF,OAAO,KAAKC,eAAe,MAAM,sBAAoB;AACrD,SAASC,MAAM,QAAQ,sBAAoB;AAC3C,SAASC,qBAAqB,QAAQ,4BAA0B;AAChE,SAASC,cAAc,QAAQ,sCAAoC;AAEnE,OAAO,sDAAoD;AAC3D,OAAO,iDAA+C;AACtD,OAAO,qEAAmE;AAC1E,OAAO,0DAAwD;AAC/D,OAAO,uDAAqD;AAC5D,OAAO,kEAAgE;AACvE,OAAO,qDAAmD;AAC1D,OAAO,gEAA8D;AACrE,OAAO,0DAAwD;AAC/D,OAAO,qDAAmD;AAC1D,OAAO,wDAAsD;AAC7D,OAAO,wDAAsD;AAC7D,OAAO,mEAAiE;AACxE,OAAO,8DAA4D;AACnE,OAAO,yEAAuE;AAC9E,OAAO,yDAAuD;AAC9D,SAASC,cAAc,QAAQ,mCAAiC;AAEhE,MAAMC,sBAAsB,GAAG,2BAA2B;AAE1D,MAAMC,eAAe,GAAG,UAAU;AAClC,MAAMC,gBAAgB,GAAG,WAAW;AAEpC,MAAMC,8CAA8C,GAAyD;EACzGC,UAAU,EAAET,eAAe,CAACU,oBAAoB,CAACC,GAAG;EACpDC,UAAU,EAAEZ,eAAe,CAACU,oBAAoB,CAACG,GAAG;EACpDC,gBAAgB,EAAEd,eAAe,CAACU,oBAAoB,CAACK,QAAQ;EAC/DC,UAAU,EAAEhB,eAAe,CAACU,oBAAoB,CAACO,GAAG;EACpDC,YAAY,EAAElB,eAAe,CAACU,oBAAoB,CAACS,IAAI;EACvDC,kBAAkB,EAAEpB,eAAe,CAACU,oBAAoB,CAACW,SAAS;EAClEC,uBAAuB,EAAEtB,eAAe,CAACU,oBAAoB,CAACG,GAAG;EACjEU,gBAAgB,EAAEvB,eAAe,CAACU,oBAAoB,CAACG,GAAG;EAC1DW,sBAAsB,EAAExB,eAAe,CAACU,oBAAoB,CAACK,QAAQ;EACrEU,kBAAkB,EAAEzB,eAAe,CAACU,oBAAoB,CAACS,IAAI;EAC7DO,wBAAwB,EAAE1B,eAAe,CAACU,oBAAoB,CAACW,SAAS;EACxEM,6BAA6B,EAAE3B,eAAe,CAACU,oBAAoB,CAACG,GAAG;EACvEe,kBAAkB,EAAE5B,eAAe,CAACU,oBAAoB,CAACC,GAAG;EAC5DkB,kBAAkB,EAAE7B,eAAe,CAACU,oBAAoB,CAACG,GAAG;EAC5DiB,wBAAwB,EAAE9B,eAAe,CAACU,oBAAoB,CAACK,QAAQ;EACvEgB,kBAAkB,EAAE/B,eAAe,CAACU,oBAAoB,CAACO,GAAG;EAC5De,gBAAgB,EAAE;CACrB;AAED;AACA,OAAM,MAAOC,yBAA0B,SAAQ/B,qBAAqB;EAApEgC,YAAA;;IASW,KAAAC,cAAc,GAAG/B,cAAc,CAACgC,IAAI;IACpC,KAAAC,aAAa,GAAG,gCAAgC;IAChD,KAAAC,aAAa,GAAG,sFAAsF;IACtG,KAAAC,WAAW,GAAG,IAAI;EAgb7B;EA9acC,aAAaA,CAACC,IAAY,EAAEC,WAAmB,EAAEC,aAAwC;IAC/F,IAAIC,MAAM,GAAG,CAAC;IAEd,MAAMC,QAAQ,GAAGH,WAAW,CAACI,WAAW,CAAC,GAAG,CAAC;IAC7C,IAAIJ,WAAW,CAACK,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,IAAIF,QAAQ,GAAG,CAAC,EAAE;MACnD,IAAIG,UAAU,GAAGH,QAAQ;MACzB,OAAOG,UAAU,GAAG,CAAC,IAAIN,WAAW,CAACO,MAAM,CAACD,UAAU,CAAC,KAAK,GAAG,IAAIN,WAAW,CAACO,MAAM,CAACD,UAAU,CAAC,KAAK,GAAG,EAAE;QACvGA,UAAU,EAAE;;MAEhB,MAAME,cAAc,GAAGR,WAAW,CAACS,SAAS,CAACH,UAAU,GAAG,CAAC,EAAEH,QAAQ,CAAC;MACtED,MAAM,GAAG,CAACM,cAAc;MACxB,IAAIE,KAAK,CAACR,MAAM,CAAC,EAAE;QACfA,MAAM,GAAG,CAACD,aAAa,CAACO,cAAc,CAACG,IAAI,EAAE,CAAC;;MAElD,OAAOL,UAAU,GAAG,CAAC,KAAKN,WAAW,CAACO,MAAM,CAACD,UAAU,CAAC,KAAK,GAAG,IAAIN,WAAW,CAACO,MAAM,CAACD,UAAU,CAAC,KAAK,GAAG,CAAC,EAAE;QACzGA,UAAU,EAAE;;MAEhBN,WAAW,GAAGA,WAAW,CAACS,SAAS,CAACT,WAAW,CAACK,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAEC,UAAU,GAAG,CAAC,CAAC;;IAGrF,OAAO,CAACP,IAAI,EAAEC,WAAW,EAAEE,MAAM,CAAC;EACtC;EAEOU,iBAAiBA,CAACC,iBAAoD;IACzE,IAAI,CAACC,wBAAwB,GAAGD,iBAAkD;IAElF,IAAI,CAACE,oBAAoB,GAAG,EAAE;IAC9B,IAAI,CAACC,eAAe,GAAG,EAAE;IACzB,IAAI,CAACC,6BAA6B,GAAG,EAAE;IACvC,IAAI,CAACC,qBAAqB,GAAG,KAAK;IAClC,IAAI,CAACC,aAAa,GAAG,EAAE;IACvB,IAAI,CAACC,iBAAiB,GAAG,EAAE;IAC3B,IAAI,CAACC,qBAAqB,GAAG,EAAE;EACnC;EAEOC,oBAAoBA,CAACC,IAAY;IACpC,OACI,UAAU/D,qBAAqB,CAACgE,gBAAgB,wEAAwE3D,gBAAgB,MAAML,qBAAqB,CAACgE,gBAAgB,KAAK,GACzL/D,cAAc,CAAC8D,IAAI,CAAC;EAE5B;EAEOE,gBAAgBA,CAACC,OAAe,EAAEC,UAAmB,EAAE1B,aAAwC;IAClG,MAAM2B,YAAY,GAAG,gEAAgE;IACrF,MAAMC,KAAK,GAAGD,YAAY,CAACE,IAAI,CAACJ,OAAO,CAAC;IACxC,IAAIG,KAAK,KAAK,IAAI,EAAE;MAChB,MAAME,WAAW,GAAGF,KAAK,CAAC,CAAC,CAAC;MAC5B,MAAM9B,IAAI,GAAG8B,KAAK,CAAC,CAAC,CAAC;MACrB,IAAIG,QAAgB;MACpB,IAAIL,UAAU,EAAE;QACZK,QAAQ,GAAG,IAAI,CAAClB,wBAAwB,CAACmB,iBAAiB,CAAClC,IAAI,CAAC;QAChE,IAAIiC,QAAQ,KAAKE,SAAS,EAAE;UACxB3E,MAAM,CAAC4E,IAAI,CAAC,+CAA+CpC,IAAI,2EAA2E,CAAC;;OAElJ,MAAM;QACHiC,QAAQ,GAAG,IAAI,CAAClB,wBAAwB,CAACsB,sBAAsB,CAACL,WAAW,EAAE,IAAI,CAACjC,aAAa,CAACC,IAAI,EAAEgC,WAAW,EAAE9B,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;QACrI,IAAI,CAACa,wBAAwB,CAACmB,iBAAiB,CAAClC,IAAI,CAAC,GAAGiC,QAAQ;QAChE,IAAI,CAACb,aAAa,CAACkB,IAAI,CAAC,eAAeL,QAAQ,KAAKjC,IAAI,MAAMgC,WAAW,GAAG,CAAC;QAC7E,IAAI,CAACX,iBAAiB,CAACiB,IAAI,CAACtC,IAAI,CAAC;;MAGrC2B,OAAO,GAAG,EAAE;;IAEhB,OAAOA,OAAO;EAClB;EAEOY,kBAAkBA,CAACC,SAAiB,EAAEtC,aAAwC;IACjF,MAAMuC,WAAW,GAAG,uCAAuC;IAC3D,MAAMX,KAAK,GAAGW,WAAW,CAACV,IAAI,CAACS,SAAS,CAAC;IACzC,IAAIV,KAAK,KAAK,IAAI,EAAE;MAChB,MAAMY,aAAa,GAAGZ,KAAK,CAAC,CAAC,CAAC;MAC9B,MAAM9B,IAAI,GAAG8B,KAAK,CAAC,CAAC,CAAC;MACrB,MAAMG,QAAQ,GAAG,IAAI,CAAClB,wBAAwB,CAAC4B,wBAAwB,CAACD,aAAa,EAAE,IAAI,CAAC3C,aAAa,CAACC,IAAI,EAAE0C,aAAa,EAAExC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;MAEjJ,IAAI,CAACa,wBAAwB,CAAC6B,mBAAmB,CAAC5C,IAAI,CAAC,GAAGiC,QAAQ;MAClE,IAAI,CAAClB,wBAAwB,CAAC8B,iBAAiB,CAACZ,QAAQ,CAAC,GAAGjC,IAAI;MAEhE,MAAM8C,aAAa,GAAG,IAAI,CAACC,oCAAoC,CAAC/C,IAAI,CAAC;MACrE,IAAI8C,aAAa,KAAKX,SAAS,EAAE;QAC7B;QACA,MAAMa,OAAO,GACTF,aAAa,GAAG,CAAC,GAAIA,aAAa,KAAK,CAAC,CAAC,GAAG,KAAK,GAAG,KAAK,GAAG,CAACA,aAAa,GAAG,OAAO,GAAIA,aAAa,KAAK,CAAC,GAAG,KAAK,GAAG,KAAK,GAAGA,aAAa,GAAG,OAAO;QACzJ,MAAMG,OAAO,GAAG,QAAQjD,IAAI,GAAG;QAE/B,IAAI,CAACgB,oBAAoB,CAACsB,IAAI,CAAC,aAAaL,QAAQ,KAAKgB,OAAO,MAAMD,OAAO,GAAG,CAAC;QACjF,IAAI,CAAC/B,eAAe,CAACqB,IAAI,CAAC,GAAGtC,IAAI,MAAM0C,aAAa,GAAG,CAAC;QACxD,IAAI,CAACxB,6BAA6B,CAACoB,IAAI,CAAC,gBAAgBtC,IAAI,MAAM0C,aAAa,kBAAkBO,OAAO,IAAI,CAAC;QAC7G,IAAI,CAAC9B,qBAAqB,GAAG,IAAI;OACpC,MAAM;QACH,IAAI,CAACH,oBAAoB,CAACsB,IAAI,CAAC,aAAaL,QAAQ,KAAKjC,IAAI,MAAM0C,aAAa,GAAG,CAAC;QACpF,IAAI,CAACzB,eAAe,CAACqB,IAAI,CAAC,GAAGtC,IAAI,MAAM0C,aAAa,GAAG,CAAC;QACxD,IAAI,CAACxB,6BAA6B,CAACoB,IAAI,CAAC,gBAAgBtC,IAAI,oBAAoBA,IAAI,GAAG,CAAC;;MAE5FwC,SAAS,GAAG,EAAE;;IAElB,OAAOA,SAAS;EACpB;EAEOU,gBAAgBA,CAACC,OAAe,EAAEvB,UAAmB,EAAE1B,aAAwC;IAClG,MAAM4B,KAAK,GAAG,IAAI,CAAClC,aAAa,CAACmC,IAAI,CAACoB,OAAO,CAAC;IAC9C,IAAIrB,KAAK,KAAK,IAAI,EAAE;MAChB,MAAM7B,WAAW,GAAG6B,KAAK,CAAC,CAAC,CAAC;MAC5B,MAAM9B,IAAI,GAAG8B,KAAK,CAAC,CAAC,CAAC;MAErB,IAAI,CAACsB,wBAAwB,CAACpD,IAAI,EAAEC,WAAW,EAAEC,aAAa,CAAC;MAE/DiD,OAAO,GAAG,EAAE;;IAEhB,OAAOA,OAAO;EAClB;EAEOE,gBAAgBA,CAACC,OAAe,EAAE1B,UAAmB,EAAE1B,aAAwC;IAClG,MAAM4B,KAAK,GAAG,IAAI,CAACjC,aAAa,CAACkC,IAAI,CAACuB,OAAO,CAAC;IAC9C,IAAIxB,KAAK,KAAK,IAAI,EAAE;MAChB,MAAM9B,IAAI,GAAG8B,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;MACvB,MAAMyB,IAAI,GAAGzB,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;MACvB,MAAM0B,gBAAgB,GAAG,CAAC,CAAC1B,KAAK,CAAC,CAAC,CAAC;MACnC,MAAM2B,WAAW,GAAG3B,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;MAC9B,MAAM4B,gBAAgB,GAAGD,WAAW,CAACnD,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC;MAC3D,MAAMqD,aAAa,GAAG7B,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;MAChC,MAAM8B,oBAAoB,GAAGF,gBAAgB,GAAIC,aAAa,CAACjD,SAAS,CAAC,CAAC,EAAEiD,aAAa,CAACrD,OAAO,CAAC,GAAG,CAAC,CAAC,CAACM,IAAI,EAAuB,GAAG,IAAI;MAE1I,IAAIiD,SAAS,GAAGL,gBAAgB,GAAG,IAAI,CAACzD,aAAa,CAACC,IAAI,EAAEuD,IAAI,EAAErD,aAAa,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;MACvF,IAAI4D,WAAW,GAAG,IAAI,CAAC/C,wBAAwB,CAACgD,iBAAiB,CAAC/D,IAAI,CAAC;MACvE,IAAI,CAAC8D,WAAW,EAAE;QACdA,WAAW,GAAG;UACVE,cAAc,EAAEH,SAAS,GAAG,CAAC;UAC7BH,gBAAgB;UAChBO,QAAQ,EAAE,EAAE;UACZC,UAAU,EAAE3G,eAAe,CAAC4G,iBAAiB,CAACC;SACjD;QACDP,SAAS,GAAGA,SAAS,IAAI,CAAC;QAC1B,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,SAAS,EAAE,EAAEQ,CAAC,EAAE;UAChCP,WAAW,CAACG,QAAQ,CAAC3B,IAAI,CAAC,IAAI,CAACvB,wBAAwB,CAACuD,qBAAqB,EAAE,CAAC;;OAEvF,MAAM;QACHT,SAAS,GAAGC,WAAW,CAACG,QAAQ,CAAC9D,MAAM;;MAG3C,IAAI,CAACY,wBAAwB,CAACgD,iBAAiB,CAAC/D,IAAI,CAAC,GAAG8D,WAAW;MAEnE,MAAMS,cAAc,GAAGd,WAAW,CAACnD,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC;MACvD,MAAMkE,gBAAgB,GAAGzG,8CAA8C,CAAC0F,WAAW,CAAC;MACpF,MAAMS,UAAU,GAAGK,cAAc,GAC3BhH,eAAe,CAAC4G,iBAAiB,CAACM,KAAK,GACvCd,aAAa,KAAK,KAAK,GACvBpG,eAAe,CAAC4G,iBAAiB,CAACO,IAAI,GACtCf,aAAa,KAAK,KAAK,GACvBpG,eAAe,CAAC4G,iBAAiB,CAACQ,IAAI,GACtCpH,eAAe,CAAC4G,iBAAiB,CAACC,KAAK;MAE7CN,WAAW,CAACI,UAAU,GAAGA,UAAU;MAEnC,IAAIM,gBAAgB,KAAKrC,SAAS,EAAE;QAChC,MAAM,0EAA0EsB,WAAW,IAAI;;MAGnG,KAAK,IAAIY,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,SAAS,EAAE,EAAEQ,CAAC,EAAE;QAChC,MAAM;UAAEO,UAAU;UAAEC;QAAY,CAAE,GAAGf,WAAW,CAACG,QAAQ,CAACI,CAAC,CAAC;QAE5D,IAAIA,CAAC,KAAK,CAAC,EAAE;UACTf,OAAO,GAAG,UAAUsB,UAAU,cAAcC,YAAY,KAAKvB,OAAO,EAAE;;QAG1E,IAAI,CAACwB,6BAA6B,CAAC9E,IAAI,EAAE8D,WAAW,EAAEO,CAAC,EAAEG,gBAAgB,EAAEZ,oBAAoB,EAAE,CAAChC,UAAU,CAAC;;;IAIrH,OAAO0B,OAAO;EAClB;EAEOyB,aAAaA,CAACvD,IAAY;IAC7B,OAAOA,IAAI;EACf;EAEOwD,eAAeA,CAACC,UAAkB,EAAEC,YAAoB;IAC3D,MAAMC,aAAa,GACfD,YAAY,CAAC5E,OAAO,CAAC,yBAAyB,CAAC,IAAI,CAAC,GAC9C;;;;SAIT,GACS,EAAE;IAEZ;IACA2E,UAAU,GAAG,IAAI,CAACG,gBAAgB,CAACH,UAAU,EAAE,IAAI,CAAC;IACpDC,YAAY,GAAG,IAAI,CAACE,gBAAgB,CAACF,YAAY,EAAE,KAAK,CAAC;IAEzD;IACAD,UAAU,GAAG,IAAI,CAACI,qBAAqB,CAACJ,UAAU,EAAE,IAAI,CAAC;IACzDC,YAAY,GAAG,IAAI,CAACG,qBAAqB,CAACH,YAAY,EAAE,KAAK,CAAC;IAE9D;IACA,MAAMI,WAAW,GAAG,IAAI,CAACC,iBAAiB,EAAE;IAE5CN,UAAU,GAAGK,WAAW,GAAGL,UAAU;IACrCC,YAAY,GAAGI,WAAW,GAAGJ,YAAY;IAEzC;IACAD,UAAU,GAAGA,UAAU,CAACO,OAAO,CAAC,WAAW,EAAE,YAAY,CAAC;IAC1DP,UAAU,GAAG,IAAI,CAACQ,4BAA4B,CAACR,UAAU,CAAC;IAE1D,IAAIS,YAAY,GAAG,uHAAuH;IAC1I,IAAI,IAAI,CAAC1E,oBAAoB,CAACb,MAAM,GAAG,CAAC,EAAE;MACtCuF,YAAY,IAAI,IAAI,CAAC1E,oBAAoB,CAAC2E,IAAI,CAAC,IAAI,CAAC;;IAExDD,YAAY,IAAI,iCAAiC,IAAI,IAAI,CAACvE,qBAAqB,GAAG,GAAG,GAAG,EAAE,CAAC,GAAG,oBAAoB;IAClH,IAAI,IAAI,CAACA,qBAAqB,EAAE;MAC5BuE,YAAY,IAAI,qEAAqE;MACrFA,YAAY,IAAI,IAAI,CAACzE,eAAe,CAAC0E,IAAI,CAAC,IAAI,CAAC;MAC/CD,YAAY,IAAI,oDAAoD;;IAGxE,IAAIE,aAAa,GAAG,uEAAuE;IAC3F,IAAI,IAAI,CAACxE,aAAa,CAACjB,MAAM,GAAG,CAAC,EAAE;MAC/ByF,aAAa,IAAI,IAAI,CAACxE,aAAa,CAACuE,IAAI,CAAC,IAAI,CAAC;;IAElDC,aAAa,IAAI,sDAAsD;IAEvEX,UAAU,GAAGS,YAAY,GAAGE,aAAa,GAAGX,UAAU;IAEtD,IAAIY,sBAAsB,GAAG,mBAAmB,IAAI,CAAC1E,qBAAqB,GAAG,GAAG,GAAG,EAAE,aAAa;IAClG,IAAI,IAAI,CAACA,qBAAqB,EAAE;MAC5B0E,sBAAsB,IAAI,oHAAoH;MAC9IA,sBAAsB,IAAI,IAAI,CAAC3E,6BAA6B,CAACyE,IAAI,CAAC,IAAI,CAAC;MACvEE,sBAAsB,IAAI,IAAI;;IAElC,MAAMC,oBAAoB,GAAG,sGAAsG;IAEnIb,UAAU,GAAG,IAAI,CAACc,4BAA4B,CAACd,UAAU,EAAE,SAAS,EAAEY,sBAAsB,EAAEC,oBAAoB,CAAC;IAEnH;IACAZ,YAAY,GAAGA,YAAY,CAACM,OAAO,CAAC,WAAW,EAAE,YAAY,CAAC;IAC9DN,YAAY,GAAG,IAAI,CAACO,4BAA4B,CAACP,YAAY,CAAC;IAC9DA,YAAY,GAAGA,YAAY,CAACM,OAAO,CAAC,OAAO,EAAE,4BAA4B,CAAC,CAAC,CAAC;IAE5E,IAAIQ,cAAc,GAAG,qHAAqH;IAC1I,IAAI,IAAI,CAAC5E,aAAa,CAACjB,MAAM,GAAG,CAAC,EAAE;MAC/B6F,cAAc,IAAI,IAAI,CAAC5E,aAAa,CAACuE,IAAI,CAAC,IAAI,CAAC;;IAEnDK,cAAc,IAAI,uDAAuD;IAEzE,IAAIC,eAAe,GAAG,+DAA+D;IAErF,IAAIC,YAAY,GAAG,KAAK;IACxB,IAAIC,GAAG,GAAG,CAAC;IACX,OAAO,CAACD,YAAY,EAAE;MAClBC,GAAG,GAAGjB,YAAY,CAAC5E,OAAO,CAAC1C,sBAAsB,EAAEuI,GAAG,CAAC;MACvD,IAAIA,GAAG,GAAG,CAAC,EAAE;QACT;;MAEJ,MAAMC,SAAS,GAAGD,GAAG;MACrBD,YAAY,GAAG,IAAI;MACnB,OAAOC,GAAG,GAAG,CAAC,IAAIjB,YAAY,CAAC1E,MAAM,CAAC2F,GAAG,CAAC,KAAK,IAAI,EAAE;QACjD,IAAIjB,YAAY,CAAC1E,MAAM,CAAC2F,GAAG,CAAC,KAAK,GAAG,IAAIjB,YAAY,CAAC1E,MAAM,CAAC2F,GAAG,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;UAC1ED,YAAY,GAAG,KAAK;UACpB;;QAEJC,GAAG,EAAE;;MAETA,GAAG,GAAGC,SAAS,GAAGxI,sBAAsB,CAACuC,MAAM;;IAGnD,IAAI+F,YAAY,EAAE;MACdD,eAAe,IAAI,0CAA0C;;IAGjEA,eAAe,IAAI,uDAAuD;IAE1Ef,YAAY,GAAGc,cAAc,GAAGC,eAAe,GAAGf,YAAY;IAE9D,MAAMmB,oBAAoB,GAAG,+BAA+B,GAAGlB,aAAa;IAC5E,MAAMmB,kBAAkB,GAAG,2BAA2B;IAEtDpB,YAAY,GAAG,IAAI,CAACa,4BAA4B,CAACb,YAAY,EAAE,SAAS,EAAEmB,oBAAoB,EAAEC,kBAAkB,CAAC;IAEnH,IAAI,CAACC,oBAAoB,EAAE;IAC3B,IAAI,CAACC,0BAA0B,EAAE;IAEjC,IAAI,CAACzD,oCAAoC,GAAG,EAAE;IAE9C,OAAO;MAAEkC,UAAU;MAAEC;IAAY,CAAE;EACvC;EAEUuB,wBAAwBA,CAACzG,IAAY,EAAE0G,wBAAiD;IAC9F,IAAIC,aAAa,GAAG,EAAE;IACtB,IAAIC,GAAG,GAAG,UAAU5G,IAAI,MAAM;IAC9B,KAAK,MAAM6G,eAAe,IAAI,IAAI,CAAC9F,wBAAwB,CAAC+F,gBAAgB,EAAE;MAC1E,MAAMvD,IAAI,GAAGsD,eAAe,CAACtD,IAAI,CAACiC,OAAO,CAAC,gBAAgB,EAAE,IAAI,CAAC;MACjE,MAAMuB,IAAI,GAAGtJ,qBAAqB,CAACuJ,YAAY,CAACzD,IAAI,CAAC;MAErD,IAAIsD,eAAe,CAAC1G,MAAM,GAAG,CAAC,EAAE;QAC5B,IAAI4G,IAAI,IAAI,CAAC,EAAE;UACX,MAAME,gBAAgB,GAAG,GAAGjH,IAAI,IAAI,IAAI,CAACsB,qBAAqB,CAACnB,MAAM,cAAc;UACnFwG,aAAa,IAAI,UAAUM,gBAAgB;;8BAEjC1D,IAAI;sBACZ;UACF,IAAI,CAACjC,qBAAqB,CAACgB,IAAI,CAACuE,eAAe,CAAC7G,IAAI,CAAC;UAErD4G,GAAG,IAAI,eAAeC,eAAe,CAAC7G,IAAI,YAAYiH,gBAAgB,KAAKJ,eAAe,CAAC1G,MAAM,MAAM;SAC1G,MAAM;UACHyG,GAAG,IAAI,IAAIC,eAAe,CAAC7G,IAAI,YAAY6G,eAAe,CAACtD,IAAI,KAAKsD,eAAe,CAAC1G,MAAM,MAAM;;OAEvG,MAAM;QACHyG,GAAG,IAAI,KAAKC,eAAe,CAAC7G,IAAI,MAAM6G,eAAe,CAACtD,IAAI,KAAK;;;IAGvEqD,GAAG,IAAI,MAAM;IACbA,GAAG,GAAG,GAAGD,aAAa,KAAKC,GAAG,EAAE;IAChCA,GAAG,IAAI,UAAUF,wBAAwB,CAACQ,OAAO,CAACtC,UAAU,cAAc8B,wBAAwB,CAACQ,OAAO,CAACrC,YAAY,kBAAkBhH,eAAe,MAAMmC,IAAI,KAAK;IAEvK,OAAO4G,GAAG;EACd;EAEQxB,gBAAgBA,CAAC5D,IAAY,EAAE2F,QAAiB;IACpD,MAAMC,aAAa,GAAG,6DAA6D;IAEnF;IACA,OAAO,IAAI,EAAE;MACT,MAAMtF,KAAK,GAAGsF,aAAa,CAACrF,IAAI,CAACP,IAAI,CAAC;MACtC,IAAIM,KAAK,KAAK,IAAI,EAAE;QAChB;;MAGJ,MAAM9B,IAAI,GAAG8B,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;MACvB,MAAMuF,WAAW,GAAGvF,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;MAC9B,MAAMwF,WAAW,GACbtH,IAAI,CAACM,OAAO,CAAC7C,qBAAqB,CAAC8J,iBAAiB,CAAC,KAAKvH,IAAI,CAACG,MAAM,GAAG1C,qBAAqB,CAAC8J,iBAAiB,CAACpH,MAAM,GAChHH,IAAI,CAACU,SAAS,CAAC,CAAC,EAAEV,IAAI,CAACM,OAAO,CAAC7C,qBAAqB,CAAC8J,iBAAiB,CAAC,CAAC,GACxE,IAAI;MACd,MAAMC,kBAAkB,GAAGH,WAAW,KAAK,oBAAoB,GAAG9J,eAAe,CAACkK,kBAAkB,CAACC,UAAU,GAAGnK,eAAe,CAACkK,kBAAkB,CAACE,SAAS;MAE9J,IAAIL,WAAW,EAAE;QACb,MAAMxD,WAAW,GAAG,IAAI,CAAC/C,wBAAwB,CAACgD,iBAAiB,CAACuD,WAAW,CAAC;QAChF,IAAIxD,WAAW,EAAE;UACbA,WAAW,CAAC8D,eAAe,GAAG,IAAI;;;MAI1C,IAAIC,WAAW,GAAG,IAAI,CAAC9G,wBAAwB,CAAC+G,iBAAiB,CAAC9H,IAAI,CAAC;MACvE,IAAI,CAAC6H,WAAW,EAAE;QACdA,WAAW,GAAG;UACVX,OAAO,EAAE,IAAI,CAACnG,wBAAwB,CAACuD,qBAAqB,EAAE;UAC9Df,IAAI,EAAEiE;SACT;QACD,IAAI,CAACzG,wBAAwB,CAAC+G,iBAAiB,CAAC9H,IAAI,CAAC,GAAG6H,WAAW;;MAGvE,IAAI,CAACE,6BAA6B,CAAC/H,IAAI,EAAE6H,WAAW,EAAEV,QAAQ,CAAC;MAE/D,MAAMa,KAAK,GAAGxG,IAAI,CAACd,SAAS,CAAC,CAAC,EAAEoB,KAAK,CAACmG,KAAK,CAAC;MAC5C,MAAMC,UAAU,GAAG,UAAUL,WAAW,CAACX,OAAO,CAACtC,UAAU,cAAciD,WAAW,CAACX,OAAO,CAACrC,YAAY,IAAI;MAC7G,MAAMsD,KAAK,GAAG3G,IAAI,CAACd,SAAS,CAACoB,KAAK,CAACmG,KAAK,CAAC;MAEzCzG,IAAI,GAAGwG,KAAK,GAAGE,UAAU,GAAGC,KAAK;MAEjCf,aAAa,CAACgB,SAAS,IAAIF,UAAU,CAAC/H,MAAM;;IAGhD,OAAOqB,IAAI;EACf;EAEQ6D,qBAAqBA,CAAC7D,IAAY,EAAE2F,QAAiB;IACzD,MAAMkB,uBAAuB,GAAG,mFAAmF;IAEnH;IACA,OAAO,IAAI,EAAE;MACT,MAAMvG,KAAK,GAAGuG,uBAAuB,CAACtG,IAAI,CAACP,IAAI,CAAC;MAChD,IAAIM,KAAK,KAAK,IAAI,EAAE;QAChB;;MAGJ,MAAMyB,IAAI,GAAGzB,KAAK,CAAC,CAAC,CAAC;MACrB,MAAMwG,UAAU,GAAGxG,KAAK,CAAC,CAAC,CAAC;MAC3B,IAAI9B,IAAI,GAAG8B,KAAK,CAAC,CAAC,CAAC;MACnB,MAAMyG,UAAU,GAAGzG,KAAK,CAAC,CAAC,CAAC;MAE3B,IAAI0G,UAAU,GAAG,IAAI,CAACzH,wBAAwB,CAAC0H,gBAAgB,CAACzI,IAAI,CAAC;MACrE,IAAI,CAACwI,UAAU,EAAE;QACb,MAAME,QAAQ,GAAGnF,IAAI,KAAK,SAAS,GAAGjG,6BAA6B,CAACqL,SAAS,CAACJ,UAAU,CAAC,GAAG,IAAI;QAEhG,IAAIrB,OAAO;QACX,IAAIwB,QAAQ,EAAE;UACV1I,IAAI,GAAGuI,UAAU;UACjBrB,OAAO,GAAGwB,QAAQ,CAACxB,OAAO;UAC1B,IAAIA,OAAO,CAACtC,UAAU,KAAK,CAAC,CAAC,EAAE;YAC3BsC,OAAO,GAAG,IAAI,CAACnG,wBAAwB,CAACuD,qBAAqB,EAAE;;SAEtE,MAAM;UACH4C,OAAO,GAAG,IAAI,CAACnG,wBAAwB,CAACuD,qBAAqB,EAAE;;QAGnEkE,UAAU,GAAG;UAAEtB;QAAO,CAAE;QACxB,IAAI,CAACnG,wBAAwB,CAAC0H,gBAAgB,CAACzI,IAAI,CAAC,GAAGwI,UAAU;;MAGrE,IAAI,CAACI,4BAA4B,CAC7B5I,IAAI,EACJ,IAAI,CAACe,wBAAwB,CAAC0H,gBAAgB,CAACzI,IAAI,CAAC,EACpDsI,UAAU,KAAK,YAAY,GACrB/K,eAAe,CAACsL,iBAAiB,CAACC,OAAO,GACzCvF,IAAI,KAAK,SAAS,GAClBhG,eAAe,CAACsL,iBAAiB,CAACE,eAAe,GACjDxL,eAAe,CAACsL,iBAAiB,CAACG,OAAO,EAC/C7B,QAAQ,CACX;MAED,MAAMvC,UAAU,GAAG4D,UAAU,CAACtB,OAAO,CAACtC,UAAU;MAChD,MAAMC,YAAY,GAAG2D,UAAU,CAACtB,OAAO,CAACrC,YAAY;MAEpD,MAAMmD,KAAK,GAAGxG,IAAI,CAACd,SAAS,CAAC,CAAC,EAAEoB,KAAK,CAACmG,KAAK,CAAC;MAC5C,MAAMC,UAAU,GAAG,UAAUtD,UAAU,cAAcC,YAAY,IAAI;MACrE,MAAMsD,KAAK,GAAG3G,IAAI,CAACd,SAAS,CAACoB,KAAK,CAACmG,KAAK,CAAC;MAEzCzG,IAAI,GAAGwG,KAAK,GAAGE,UAAU,GAAGC,KAAK;MAEjCE,uBAAuB,CAACD,SAAS,IAAIF,UAAU,CAAC/H,MAAM;;IAG1D,OAAOqB,IAAI;EACf;EAEQiE,4BAA4BA,CAACjE,IAAY;IAC7C,KAAK,MAAMyH,gBAAgB,IAAI,IAAI,CAAC3H,qBAAqB,EAAE;MACvDE,IAAI,GAAGA,IAAI,CAACgE,OAAO,CAAC,IAAI0D,MAAM,CAAC,GAAGD,gBAAgB,gBAAgB,EAAE,GAAG,CAAC,EAAE,GAAGA,gBAAgB,SAAS,CAAC;;IAE3G,OAAOzH,IAAI;EACf"},"metadata":{},"sourceType":"module","externalDependencies":[]}