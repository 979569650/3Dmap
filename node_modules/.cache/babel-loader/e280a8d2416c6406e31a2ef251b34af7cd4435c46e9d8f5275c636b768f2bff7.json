{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock.js\";\n/**\n * Defines a block used to teleport a value to an endpoint\n */\nexport class TeleportInBlock extends NodeGeometryBlock {\n  /** Gets the list of attached endpoints */\n  get endpoints() {\n    return this._endpoints;\n  }\n  /**\n   * Create a new TeleportInBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    this._endpoints = [];\n    this._isTeleportIn = true;\n    this.registerInput(\"input\", NodeGeometryBlockConnectionPointTypes.AutoDetect);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"TeleportInBlock\";\n  }\n  /**\n   * Gets the input component\n   */\n  get input() {\n    return this._inputs[0];\n  }\n  _dumpCode(uniqueNames, alreadyDumped) {\n    let codeString = super._dumpCode(uniqueNames, alreadyDumped);\n    for (const endpoint of this.endpoints) {\n      if (alreadyDumped.indexOf(endpoint) === -1) {\n        codeString += endpoint._dumpCode(uniqueNames, alreadyDumped);\n      }\n    }\n    return codeString;\n  }\n  /**\n   * Checks if the current block is an ancestor of a given type\n   * @param type defines the potential type to check\n   * @returns true if block is a descendant\n   */\n  isAnAncestorOfType(type) {\n    if (this.getClassName() === type) {\n      return true;\n    }\n    for (const endpoint of this.endpoints) {\n      if (endpoint.isAnAncestorOfType(type)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks if the current block is an ancestor of a given block\n   * @param block defines the potential descendant block to check\n   * @returns true if block is a descendant\n   */\n  isAnAncestorOf(block) {\n    for (const endpoint of this.endpoints) {\n      if (endpoint === block) {\n        return true;\n      }\n      if (endpoint.isAnAncestorOf(block)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Get the first descendant using a predicate\n   * @param predicate defines the predicate to check\n   * @returns descendant or null if none found\n   */\n  getDescendantOfPredicate(predicate) {\n    if (predicate(this)) {\n      return this;\n    }\n    for (const endpoint of this.endpoints) {\n      const descendant = endpoint.getDescendantOfPredicate(predicate);\n      if (descendant) {\n        return descendant;\n      }\n    }\n    return null;\n  }\n  /**\n   * Add an enpoint to this block\n   * @param endpoint define the endpoint to attach to\n   */\n  attachToEndpoint(endpoint) {\n    endpoint.detach();\n    this._endpoints.push(endpoint);\n    endpoint._entryPoint = this;\n    endpoint._outputs[0]._typeConnectionSource = this._inputs[0];\n    endpoint._tempEntryPointUniqueId = null;\n    endpoint.name = \"> \" + this.name;\n  }\n  /**\n   * Remove enpoint from this block\n   * @param endpoint define the endpoint to remove\n   */\n  detachFromEndpoint(endpoint) {\n    const index = this._endpoints.indexOf(endpoint);\n    if (index !== -1) {\n      this._endpoints.splice(index, 1);\n      endpoint._outputs[0]._typeConnectionSource = null;\n      endpoint._entryPoint = null;\n    }\n  }\n  _buildBlock() {\n    for (const endpoint of this._endpoints) {\n      endpoint.output._storedFunction = state => {\n        return this.input.getConnectedValue(state);\n      };\n    }\n  }\n}\nRegisterClass(\"BABYLON.TeleportInBlock\", TeleportInBlock);","map":{"version":3,"names":["RegisterClass","NodeGeometryBlockConnectionPointTypes","NodeGeometryBlock","TeleportInBlock","endpoints","_endpoints","constructor","name","_isTeleportIn","registerInput","AutoDetect","getClassName","input","_inputs","_dumpCode","uniqueNames","alreadyDumped","codeString","endpoint","indexOf","isAnAncestorOfType","type","isAnAncestorOf","block","getDescendantOfPredicate","predicate","descendant","attachToEndpoint","detach","push","_entryPoint","_outputs","_typeConnectionSource","_tempEntryPointUniqueId","detachFromEndpoint","index","splice","_buildBlock","output","_storedFunction","state","getConnectedValue"],"sources":["../../../../../../../dev/core/src/Meshes/Node/Blocks/Teleport/teleportInBlock.ts"],"sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport type { TeleportOutBlock } from \"./teleportOutBlock\";\r\n\r\n/**\r\n * Defines a block used to teleport a value to an endpoint\r\n */\r\nexport class TeleportInBlock extends NodeGeometryBlock {\r\n    private _endpoints: TeleportOutBlock[] = [];\r\n\r\n    /** Gets the list of attached endpoints */\r\n    public get endpoints() {\r\n        return this._endpoints;\r\n    }\r\n\r\n    /**\r\n     * Create a new TeleportInBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n        this._isTeleportIn = true;\r\n\r\n        this.registerInput(\"input\", NodeGeometryBlockConnectionPointTypes.AutoDetect);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"TeleportInBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    public _dumpCode(uniqueNames: string[], alreadyDumped: NodeGeometryBlock[]) {\r\n        let codeString = super._dumpCode(uniqueNames, alreadyDumped);\r\n\r\n        for (const endpoint of this.endpoints) {\r\n            if (alreadyDumped.indexOf(endpoint) === -1) {\r\n                codeString += endpoint._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Checks if the current block is an ancestor of a given type\r\n     * @param type defines the potential type to check\r\n     * @returns true if block is a descendant\r\n     */\r\n    public isAnAncestorOfType(type: string): boolean {\r\n        if (this.getClassName() === type) {\r\n            return true;\r\n        }\r\n\r\n        for (const endpoint of this.endpoints) {\r\n            if (endpoint.isAnAncestorOfType(type)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the current block is an ancestor of a given block\r\n     * @param block defines the potential descendant block to check\r\n     * @returns true if block is a descendant\r\n     */\r\n    public isAnAncestorOf(block: NodeGeometryBlock): boolean {\r\n        for (const endpoint of this.endpoints) {\r\n            if (endpoint === block) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.isAnAncestorOf(block)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the first descendant using a predicate\r\n     * @param predicate defines the predicate to check\r\n     * @returns descendant or null if none found\r\n     */\r\n    public getDescendantOfPredicate(predicate: (block: NodeGeometryBlock) => boolean): Nullable<NodeGeometryBlock> {\r\n        if (predicate(this)) {\r\n            return this;\r\n        }\r\n\r\n        for (const endpoint of this.endpoints) {\r\n            const descendant = endpoint.getDescendantOfPredicate(predicate);\r\n\r\n            if (descendant) {\r\n                return descendant;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Add an enpoint to this block\r\n     * @param endpoint define the endpoint to attach to\r\n     */\r\n    public attachToEndpoint(endpoint: TeleportOutBlock) {\r\n        endpoint.detach();\r\n\r\n        this._endpoints.push(endpoint);\r\n        endpoint._entryPoint = this;\r\n        endpoint._outputs[0]._typeConnectionSource = this._inputs[0];\r\n        endpoint._tempEntryPointUniqueId = null;\r\n        endpoint.name = \"> \" + this.name;\r\n    }\r\n\r\n    /**\r\n     * Remove enpoint from this block\r\n     * @param endpoint define the endpoint to remove\r\n     */\r\n    public detachFromEndpoint(endpoint: TeleportOutBlock) {\r\n        const index = this._endpoints.indexOf(endpoint);\r\n\r\n        if (index !== -1) {\r\n            this._endpoints.splice(index, 1);\r\n            endpoint._outputs[0]._typeConnectionSource = null;\r\n            endpoint._entryPoint = null;\r\n        }\r\n    }\r\n\r\n    protected _buildBlock() {\r\n        for (const endpoint of this._endpoints) {\r\n            endpoint.output._storedFunction = (state) => {\r\n                return this.input.getConnectedValue(state);\r\n            };\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TeleportInBlock\", TeleportInBlock);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}