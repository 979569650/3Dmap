{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { Matrix, Vector3, TmpVectors } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Container3D } from \"./container3D.js\";\n/**\n * Abstract class used to create a container panel deployed on the surface of a volume\n */\nexport class VolumeBasedPanel extends Container3D {\n  /**\n   * Gets or sets the orientation to apply to all controls (BABYLON.Container3D.FaceOriginReversedOrientation by default)\n   * | Value | Type                                | Description |\n   * | ----- | ----------------------------------- | ----------- |\n   * | 0     | UNSET_ORIENTATION                   |  Control rotation will remain unchanged |\n   * | 1     | FACEORIGIN_ORIENTATION              |  Control will rotate to make it look at sphere central axis |\n   * | 2     | FACEORIGINREVERSED_ORIENTATION      |  Control will rotate to make it look back at sphere central axis |\n   * | 3     | FACEFORWARD_ORIENTATION             |  Control will rotate to look at z axis (0, 0, 1) |\n   * | 4     | FACEFORWARDREVERSED_ORIENTATION     |  Control will rotate to look at negative z axis (0, 0, -1) |\n   */\n  get orientation() {\n    return this._orientation;\n  }\n  set orientation(value) {\n    if (this._orientation === value) {\n      return;\n    }\n    this._orientation = value;\n    Tools.SetImmediate(() => {\n      this._arrangeChildren();\n    });\n  }\n  /**\n   * Gets or sets the number of columns requested (10 by default).\n   * The panel will automatically compute the number of rows based on number of child controls.\n   */\n  get columns() {\n    return this._columns;\n  }\n  set columns(value) {\n    if (this._columns === value) {\n      return;\n    }\n    this._columns = value;\n    this._rowThenColum = true;\n    Tools.SetImmediate(() => {\n      this._arrangeChildren();\n    });\n  }\n  /**\n   * Gets or sets a the number of rows requested.\n   * The panel will automatically compute the number of columns based on number of child controls.\n   */\n  get rows() {\n    return this._rows;\n  }\n  set rows(value) {\n    if (this._rows === value) {\n      return;\n    }\n    this._rows = value;\n    this._rowThenColum = false;\n    Tools.SetImmediate(() => {\n      this._arrangeChildren();\n    });\n  }\n  /**\n   * Creates new VolumeBasedPanel\n   * @param name\n   */\n  constructor(name) {\n    super(name);\n    this._columns = 10;\n    this._rows = 0;\n    this._rowThenColum = true;\n    this._orientation = Container3D.FACEORIGIN_ORIENTATION;\n    /**\n     * Gets or sets the distance between elements\n     */\n    this.margin = 0;\n  }\n  _arrangeChildren() {\n    this._cellWidth = 0;\n    this._cellHeight = 0;\n    let rows = 0;\n    let columns = 0;\n    let controlCount = 0;\n    const currentInverseWorld = Matrix.Invert(this.node.computeWorldMatrix(true));\n    // Measure\n    for (const child of this._children) {\n      if (!child.mesh) {\n        continue;\n      }\n      controlCount++;\n      child.mesh.computeWorldMatrix(true);\n      //   child.mesh.getWorldMatrix().multiplyToRef(currentInverseWorld, Tmp.Matrix[0]);\n      const boundingBox = child.mesh.getHierarchyBoundingVectors();\n      const extendSize = TmpVectors.Vector3[0];\n      const diff = TmpVectors.Vector3[1];\n      boundingBox.max.subtractToRef(boundingBox.min, diff);\n      diff.scaleInPlace(0.5);\n      Vector3.TransformNormalToRef(diff, currentInverseWorld, extendSize);\n      this._cellWidth = Math.max(this._cellWidth, extendSize.x * 2);\n      this._cellHeight = Math.max(this._cellHeight, extendSize.y * 2);\n    }\n    this._cellWidth += this.margin * 2;\n    this._cellHeight += this.margin * 2;\n    // Arrange\n    if (this._rowThenColum) {\n      columns = this._columns;\n      rows = Math.ceil(controlCount / this._columns);\n    } else {\n      rows = this._rows;\n      columns = Math.ceil(controlCount / this._rows);\n    }\n    const startOffsetX = columns * 0.5 * this._cellWidth;\n    const startOffsetY = rows * 0.5 * this._cellHeight;\n    const nodeGrid = [];\n    let cellCounter = 0;\n    if (this._rowThenColum) {\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < columns; c++) {\n          nodeGrid.push(new Vector3(c * this._cellWidth - startOffsetX + this._cellWidth / 2, r * this._cellHeight - startOffsetY + this._cellHeight / 2, 0));\n          cellCounter++;\n          if (cellCounter > controlCount) {\n            break;\n          }\n        }\n      }\n    } else {\n      for (let c = 0; c < columns; c++) {\n        for (let r = 0; r < rows; r++) {\n          nodeGrid.push(new Vector3(c * this._cellWidth - startOffsetX + this._cellWidth / 2, r * this._cellHeight - startOffsetY + this._cellHeight / 2, 0));\n          cellCounter++;\n          if (cellCounter > controlCount) {\n            break;\n          }\n        }\n      }\n    }\n    cellCounter = 0;\n    for (const child of this._children) {\n      if (!child.mesh) {\n        continue;\n      }\n      this._mapGridNode(child, nodeGrid[cellCounter]);\n      cellCounter++;\n    }\n    this._finalProcessing();\n  }\n  /** Child classes can implement this function to provide additional processing */\n  _finalProcessing() {}\n}","map":{"version":3,"names":["Tools","Matrix","Vector3","TmpVectors","Container3D","VolumeBasedPanel","orientation","_orientation","value","SetImmediate","_arrangeChildren","columns","_columns","_rowThenColum","rows","_rows","constructor","name","FACEORIGIN_ORIENTATION","margin","_cellWidth","_cellHeight","controlCount","currentInverseWorld","Invert","node","computeWorldMatrix","child","_children","mesh","boundingBox","getHierarchyBoundingVectors","extendSize","diff","max","subtractToRef","min","scaleInPlace","TransformNormalToRef","Math","x","y","ceil","startOffsetX","startOffsetY","nodeGrid","cellCounter","r","c","push","_mapGridNode","_finalProcessing"],"sources":["../../../../../dev/gui/src/3D/controls/volumeBasedPanel.ts"],"sourcesContent":["import { Tools } from \"core/Misc/tools\";\r\nimport { Matrix, Vector3, TmpVectors } from \"core/Maths/math.vector\";\r\nimport type { int } from \"core/types\";\r\n\r\nimport { Container3D } from \"./container3D\";\r\nimport type { Control3D } from \"./control3D\";\r\n\r\n/**\r\n * Abstract class used to create a container panel deployed on the surface of a volume\r\n */\r\nexport abstract class VolumeBasedPanel extends Container3D {\r\n    private _columns = 10;\r\n    private _rows = 0;\r\n    private _rowThenColum = true;\r\n\r\n    private _orientation = Container3D.FACEORIGIN_ORIENTATION;\r\n\r\n    protected _cellWidth: number;\r\n    protected _cellHeight: number;\r\n\r\n    /**\r\n     * Gets or sets the distance between elements\r\n     */\r\n    public margin = 0;\r\n\r\n    /**\r\n     * Gets or sets the orientation to apply to all controls (BABYLON.Container3D.FaceOriginReversedOrientation by default)\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 0     | UNSET_ORIENTATION                   |  Control rotation will remain unchanged |\r\n     * | 1     | FACEORIGIN_ORIENTATION              |  Control will rotate to make it look at sphere central axis |\r\n     * | 2     | FACEORIGINREVERSED_ORIENTATION      |  Control will rotate to make it look back at sphere central axis |\r\n     * | 3     | FACEFORWARD_ORIENTATION             |  Control will rotate to look at z axis (0, 0, 1) |\r\n     * | 4     | FACEFORWARDREVERSED_ORIENTATION     |  Control will rotate to look at negative z axis (0, 0, -1) |\r\n     */\r\n    public get orientation(): number {\r\n        return this._orientation;\r\n    }\r\n\r\n    public set orientation(value: number) {\r\n        if (this._orientation === value) {\r\n            return;\r\n        }\r\n\r\n        this._orientation = value;\r\n\r\n        Tools.SetImmediate(() => {\r\n            this._arrangeChildren();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the number of columns requested (10 by default).\r\n     * The panel will automatically compute the number of rows based on number of child controls.\r\n     */\r\n    public get columns(): int {\r\n        return this._columns;\r\n    }\r\n\r\n    public set columns(value: int) {\r\n        if (this._columns === value) {\r\n            return;\r\n        }\r\n\r\n        this._columns = value;\r\n        this._rowThenColum = true;\r\n\r\n        Tools.SetImmediate(() => {\r\n            this._arrangeChildren();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a the number of rows requested.\r\n     * The panel will automatically compute the number of columns based on number of child controls.\r\n     */\r\n    public get rows(): int {\r\n        return this._rows;\r\n    }\r\n\r\n    public set rows(value: int) {\r\n        if (this._rows === value) {\r\n            return;\r\n        }\r\n\r\n        this._rows = value;\r\n        this._rowThenColum = false;\r\n\r\n        Tools.SetImmediate(() => {\r\n            this._arrangeChildren();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates new VolumeBasedPanel\r\n     * @param name\r\n     */\r\n    public constructor(name?: string) {\r\n        super(name);\r\n    }\r\n\r\n    protected _arrangeChildren() {\r\n        this._cellWidth = 0;\r\n        this._cellHeight = 0;\r\n        let rows = 0;\r\n        let columns = 0;\r\n        let controlCount = 0;\r\n\r\n        const currentInverseWorld = Matrix.Invert(this.node!.computeWorldMatrix(true));\r\n\r\n        // Measure\r\n        for (const child of this._children) {\r\n            if (!child.mesh) {\r\n                continue;\r\n            }\r\n\r\n            controlCount++;\r\n            child.mesh.computeWorldMatrix(true);\r\n            //   child.mesh.getWorldMatrix().multiplyToRef(currentInverseWorld, Tmp.Matrix[0]);\r\n\r\n            const boundingBox = child.mesh.getHierarchyBoundingVectors();\r\n            const extendSize = TmpVectors.Vector3[0];\r\n            const diff = TmpVectors.Vector3[1];\r\n\r\n            boundingBox.max.subtractToRef(boundingBox.min, diff);\r\n\r\n            diff.scaleInPlace(0.5);\r\n\r\n            Vector3.TransformNormalToRef(diff, currentInverseWorld, extendSize);\r\n\r\n            this._cellWidth = Math.max(this._cellWidth, extendSize.x * 2);\r\n            this._cellHeight = Math.max(this._cellHeight, extendSize.y * 2);\r\n        }\r\n\r\n        this._cellWidth += this.margin * 2;\r\n        this._cellHeight += this.margin * 2;\r\n\r\n        // Arrange\r\n        if (this._rowThenColum) {\r\n            columns = this._columns;\r\n            rows = Math.ceil(controlCount / this._columns);\r\n        } else {\r\n            rows = this._rows;\r\n            columns = Math.ceil(controlCount / this._rows);\r\n        }\r\n\r\n        const startOffsetX = columns * 0.5 * this._cellWidth;\r\n        const startOffsetY = rows * 0.5 * this._cellHeight;\r\n        const nodeGrid = [];\r\n        let cellCounter = 0;\r\n\r\n        if (this._rowThenColum) {\r\n            for (let r = 0; r < rows; r++) {\r\n                for (let c = 0; c < columns; c++) {\r\n                    nodeGrid.push(new Vector3(c * this._cellWidth - startOffsetX + this._cellWidth / 2, r * this._cellHeight - startOffsetY + this._cellHeight / 2, 0));\r\n                    cellCounter++;\r\n                    if (cellCounter > controlCount) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            for (let c = 0; c < columns; c++) {\r\n                for (let r = 0; r < rows; r++) {\r\n                    nodeGrid.push(new Vector3(c * this._cellWidth - startOffsetX + this._cellWidth / 2, r * this._cellHeight - startOffsetY + this._cellHeight / 2, 0));\r\n                    cellCounter++;\r\n                    if (cellCounter > controlCount) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        cellCounter = 0;\r\n        for (const child of this._children) {\r\n            if (!child.mesh) {\r\n                continue;\r\n            }\r\n\r\n            this._mapGridNode(child, nodeGrid[cellCounter]);\r\n\r\n            cellCounter++;\r\n        }\r\n\r\n        this._finalProcessing();\r\n    }\r\n\r\n    /** Child classes must implement this function to provide correct control positioning */\r\n    protected abstract _mapGridNode(control: Control3D, nodePosition: Vector3): void;\r\n\r\n    /** Child classes can implement this function to provide additional processing */\r\n    protected _finalProcessing() {}\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}