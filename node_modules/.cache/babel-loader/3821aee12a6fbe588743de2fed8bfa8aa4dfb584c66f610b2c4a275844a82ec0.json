{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../../tslib.es6.js\";\nimport { NodeGeometryBlock } from \"../nodeGeometryBlock.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { Vector2, Vector3, Vector4 } from \"../../../Maths/math.vector.js\";\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../Decorators/nodeDecorator.js\";\n/**\n * Operations supported by the Math block\n */\nexport var MathBlockOperations;\n(function (MathBlockOperations) {\n  /** Add */\n  MathBlockOperations[MathBlockOperations[\"Add\"] = 0] = \"Add\";\n  /** Subtract */\n  MathBlockOperations[MathBlockOperations[\"Subtract\"] = 1] = \"Subtract\";\n  /** Multiply */\n  MathBlockOperations[MathBlockOperations[\"Multiply\"] = 2] = \"Multiply\";\n  /** Divide */\n  MathBlockOperations[MathBlockOperations[\"Divide\"] = 3] = \"Divide\";\n  /** Max */\n  MathBlockOperations[MathBlockOperations[\"Max\"] = 4] = \"Max\";\n  /** Min */\n  MathBlockOperations[MathBlockOperations[\"Min\"] = 5] = \"Min\";\n})(MathBlockOperations || (MathBlockOperations = {}));\n/**\n * Block used to apply math functions\n */\nexport class MathBlock extends NodeGeometryBlock {\n  /**\n   * Create a new MathBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    /**\n     * Gets or sets the operation applied by the block\n     */\n    this.operation = MathBlockOperations.Add;\n    this.registerInput(\"left\", NodeGeometryBlockConnectionPointTypes.AutoDetect);\n    this.registerInput(\"right\", NodeGeometryBlockConnectionPointTypes.AutoDetect);\n    this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.BasedOnInput);\n    this._outputs[0]._typeConnectionSource = this._inputs[0];\n    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Matrix);\n    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Geometry);\n    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Texture);\n    this._inputs[1].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Matrix);\n    this._inputs[1].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Geometry);\n    this._inputs[1].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Texture);\n    this._inputs[1].acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\n    this._linkConnectionTypes(0, 1);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"MathBlock\";\n  }\n  /**\n   * Gets the left input component\n   */\n  get left() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the right input component\n   */\n  get right() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the geometry output component\n   */\n  get output() {\n    return this._outputs[0];\n  }\n  _buildBlock() {\n    let func;\n    const left = this.left;\n    const right = this.right;\n    if (!left.isConnected || !right.isConnected) {\n      this.output._storedFunction = null;\n      this.output._storedValue = null;\n      return;\n    }\n    const isFloat = left.type === NodeGeometryBlockConnectionPointTypes.Float || left.type === NodeGeometryBlockConnectionPointTypes.Int;\n    switch (this.operation) {\n      case MathBlockOperations.Add:\n        {\n          if (isFloat) {\n            func = state => {\n              return left.getConnectedValue(state) + right.getConnectedValue(state);\n            };\n          } else {\n            func = state => {\n              return left.getConnectedValue(state).add(state.adapt(right, left.type));\n            };\n          }\n          break;\n        }\n      case MathBlockOperations.Subtract:\n        {\n          if (isFloat) {\n            func = state => {\n              return left.getConnectedValue(state) - right.getConnectedValue(state);\n            };\n          } else {\n            func = state => {\n              return left.getConnectedValue(state).subtract(state.adapt(right, left.type));\n            };\n          }\n          break;\n        }\n      case MathBlockOperations.Multiply:\n        {\n          if (isFloat) {\n            func = state => {\n              return left.getConnectedValue(state) * right.getConnectedValue(state);\n            };\n          } else {\n            func = state => {\n              return left.getConnectedValue(state).multiply(state.adapt(right, left.type));\n            };\n          }\n          break;\n        }\n      case MathBlockOperations.Divide:\n        {\n          if (isFloat) {\n            func = state => {\n              return left.getConnectedValue(state) / right.getConnectedValue(state);\n            };\n          } else {\n            func = state => {\n              return left.getConnectedValue(state).divide(state.adapt(right, left.type));\n            };\n          }\n          break;\n        }\n      case MathBlockOperations.Min:\n        {\n          if (isFloat) {\n            func = state => {\n              return Math.min(left.getConnectedValue(state), right.getConnectedValue(state));\n            };\n          } else {\n            switch (left.type) {\n              case NodeGeometryBlockConnectionPointTypes.Vector2:\n                {\n                  func = state => {\n                    return Vector2.Minimize(left.getConnectedValue(state), state.adapt(right, left.type));\n                  };\n                  break;\n                }\n              case NodeGeometryBlockConnectionPointTypes.Vector3:\n                {\n                  func = state => {\n                    return Vector3.Minimize(left.getConnectedValue(state), state.adapt(right, left.type));\n                  };\n                  break;\n                }\n              case NodeGeometryBlockConnectionPointTypes.Vector4:\n                {\n                  func = state => {\n                    return Vector4.Minimize(left.getConnectedValue(state), state.adapt(right, left.type));\n                  };\n                  break;\n                }\n            }\n          }\n          break;\n        }\n      case MathBlockOperations.Max:\n        {\n          if (isFloat) {\n            func = state => {\n              return Math.max(left.getConnectedValue(state), right.getConnectedValue(state));\n            };\n          } else {\n            switch (left.type) {\n              case NodeGeometryBlockConnectionPointTypes.Vector2:\n                {\n                  func = state => {\n                    return Vector2.Maximize(left.getConnectedValue(state), state.adapt(right, left.type));\n                  };\n                  break;\n                }\n              case NodeGeometryBlockConnectionPointTypes.Vector3:\n                {\n                  func = state => {\n                    return Vector3.Maximize(left.getConnectedValue(state), state.adapt(right, left.type));\n                  };\n                  break;\n                }\n              case NodeGeometryBlockConnectionPointTypes.Vector4:\n                {\n                  func = state => {\n                    return Vector4.Maximize(left.getConnectedValue(state), state.adapt(right, left.type));\n                  };\n                  break;\n                }\n            }\n            break;\n          }\n        }\n    }\n    this.output._storedFunction = state => {\n      if (left.type === NodeGeometryBlockConnectionPointTypes.Int) {\n        return func(state) | 0;\n      }\n      return func(state);\n    };\n  }\n  _dumpPropertiesCode() {\n    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.operation = BABYLON.MathBlockOperations.${MathBlockOperations[this.operation]};\\n`;\n    return codeString;\n  }\n  /**\n   * Serializes this block in a JSON representation\n   * @returns the serialized block object\n   */\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.operation = this.operation;\n    return serializationObject;\n  }\n  _deserialize(serializationObject) {\n    super._deserialize(serializationObject);\n    this.operation = serializationObject.operation;\n  }\n}\n__decorate([editableInPropertyPage(\"Operation\", PropertyTypeForEdition.List, \"ADVANCED\", {\n  notifiers: {\n    rebuild: true\n  },\n  options: [{\n    label: \"Add\",\n    value: MathBlockOperations.Add\n  }, {\n    label: \"Subtract\",\n    value: MathBlockOperations.Subtract\n  }, {\n    label: \"Multiply\",\n    value: MathBlockOperations.Multiply\n  }, {\n    label: \"Divide\",\n    value: MathBlockOperations.Divide\n  }, {\n    label: \"Max\",\n    value: MathBlockOperations.Max\n  }, {\n    label: \"Min\",\n    value: MathBlockOperations.Min\n  }]\n})], MathBlock.prototype, \"operation\", void 0);\nRegisterClass(\"BABYLON.MathBlock\", MathBlock);","map":{"version":3,"names":["NodeGeometryBlock","RegisterClass","NodeGeometryBlockConnectionPointTypes","Vector2","Vector3","Vector4","PropertyTypeForEdition","editableInPropertyPage","MathBlockOperations","MathBlock","constructor","name","operation","Add","registerInput","AutoDetect","registerOutput","BasedOnInput","_outputs","_typeConnectionSource","_inputs","excludedConnectionPointTypes","push","Matrix","Geometry","Texture","acceptedConnectionPointTypes","Float","_linkConnectionTypes","getClassName","left","right","output","_buildBlock","func","isConnected","_storedFunction","_storedValue","isFloat","type","Int","state","getConnectedValue","add","adapt","Subtract","subtract","Multiply","multiply","Divide","divide","Min","Math","min","Minimize","Max","max","Maximize","_dumpPropertiesCode","codeString","_codeVariableName","serialize","serializationObject","_deserialize","__decorate","List","notifiers","rebuild","options","label","value"],"sources":["../../../../../../dev/core/src/Meshes/Node/Blocks/mathBlock.ts"],"sourcesContent":["import { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../nodeGeometryBuildState\";\r\nimport { Vector2, Vector3, Vector4 } from \"core/Maths/math.vector\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Operations supported by the Math block\r\n */\r\nexport enum MathBlockOperations {\r\n    /** Add */\r\n    Add,\r\n    /** Subtract */\r\n    Subtract,\r\n    /** Multiply */\r\n    Multiply,\r\n    /** Divide */\r\n    Divide,\r\n    /** Max */\r\n    Max,\r\n    /** Min */\r\n    Min,\r\n}\r\n\r\n/**\r\n * Block used to apply math functions\r\n */\r\nexport class MathBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Gets or sets the operation applied by the block\r\n     */\r\n    @editableInPropertyPage(\"Operation\", PropertyTypeForEdition.List, \"ADVANCED\", {\r\n        notifiers: { rebuild: true },\r\n        options: [\r\n            { label: \"Add\", value: MathBlockOperations.Add },\r\n            { label: \"Subtract\", value: MathBlockOperations.Subtract },\r\n            { label: \"Multiply\", value: MathBlockOperations.Multiply },\r\n            { label: \"Divide\", value: MathBlockOperations.Divide },\r\n            { label: \"Max\", value: MathBlockOperations.Max },\r\n            { label: \"Min\", value: MathBlockOperations.Min },\r\n        ],\r\n    })\r\n    public operation = MathBlockOperations.Add;\r\n\r\n    /**\r\n     * Create a new MathBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"left\", NodeGeometryBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"right\", NodeGeometryBlockConnectionPointTypes.AutoDetect);\r\n\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Matrix);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Texture);\r\n        this._inputs[1].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Matrix);\r\n        this._inputs[1].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this._inputs[1].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Texture);\r\n        this._inputs[1].acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\r\n        this._linkConnectionTypes(0, 1);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"MathBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the left input component\r\n     */\r\n    public get left(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the right input component\r\n     */\r\n    public get right(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock() {\r\n        let func: (state: NodeGeometryBuildState) => any;\r\n        const left = this.left;\r\n        const right = this.right;\r\n\r\n        if (!left.isConnected || !right.isConnected) {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = null;\r\n            return;\r\n        }\r\n\r\n        const isFloat = left.type === NodeGeometryBlockConnectionPointTypes.Float || left.type === NodeGeometryBlockConnectionPointTypes.Int;\r\n\r\n        switch (this.operation) {\r\n            case MathBlockOperations.Add: {\r\n                if (isFloat) {\r\n                    func = (state) => {\r\n                        return left.getConnectedValue(state) + right.getConnectedValue(state);\r\n                    };\r\n                } else {\r\n                    func = (state) => {\r\n                        return left.getConnectedValue(state).add(state.adapt(right, left.type));\r\n                    };\r\n                }\r\n                break;\r\n            }\r\n            case MathBlockOperations.Subtract: {\r\n                if (isFloat) {\r\n                    func = (state) => {\r\n                        return left.getConnectedValue(state) - right.getConnectedValue(state);\r\n                    };\r\n                } else {\r\n                    func = (state) => {\r\n                        return left.getConnectedValue(state).subtract(state.adapt(right, left.type));\r\n                    };\r\n                }\r\n                break;\r\n            }\r\n            case MathBlockOperations.Multiply: {\r\n                if (isFloat) {\r\n                    func = (state) => {\r\n                        return left.getConnectedValue(state) * right.getConnectedValue(state);\r\n                    };\r\n                } else {\r\n                    func = (state) => {\r\n                        return left.getConnectedValue(state).multiply(state.adapt(right, left.type));\r\n                    };\r\n                }\r\n                break;\r\n            }\r\n            case MathBlockOperations.Divide: {\r\n                if (isFloat) {\r\n                    func = (state) => {\r\n                        return left.getConnectedValue(state) / right.getConnectedValue(state);\r\n                    };\r\n                } else {\r\n                    func = (state) => {\r\n                        return left.getConnectedValue(state).divide(state.adapt(right, left.type));\r\n                    };\r\n                }\r\n                break;\r\n            }\r\n            case MathBlockOperations.Min: {\r\n                if (isFloat) {\r\n                    func = (state) => {\r\n                        return Math.min(left.getConnectedValue(state), right.getConnectedValue(state));\r\n                    };\r\n                } else {\r\n                    switch (left.type) {\r\n                        case NodeGeometryBlockConnectionPointTypes.Vector2: {\r\n                            func = (state) => {\r\n                                return Vector2.Minimize(left.getConnectedValue(state), state.adapt(right, left.type));\r\n                            };\r\n                            break;\r\n                        }\r\n                        case NodeGeometryBlockConnectionPointTypes.Vector3: {\r\n                            func = (state) => {\r\n                                return Vector3.Minimize(left.getConnectedValue(state), state.adapt(right, left.type));\r\n                            };\r\n                            break;\r\n                        }\r\n                        case NodeGeometryBlockConnectionPointTypes.Vector4: {\r\n                            func = (state) => {\r\n                                return Vector4.Minimize(left.getConnectedValue(state), state.adapt(right, left.type));\r\n                            };\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case MathBlockOperations.Max: {\r\n                if (isFloat) {\r\n                    func = (state) => {\r\n                        return Math.max(left.getConnectedValue(state), right.getConnectedValue(state));\r\n                    };\r\n                } else {\r\n                    switch (left.type) {\r\n                        case NodeGeometryBlockConnectionPointTypes.Vector2: {\r\n                            func = (state) => {\r\n                                return Vector2.Maximize(left.getConnectedValue(state), state.adapt(right, left.type));\r\n                            };\r\n                            break;\r\n                        }\r\n                        case NodeGeometryBlockConnectionPointTypes.Vector3: {\r\n                            func = (state) => {\r\n                                return Vector3.Maximize(left.getConnectedValue(state), state.adapt(right, left.type));\r\n                            };\r\n                            break;\r\n                        }\r\n                        case NodeGeometryBlockConnectionPointTypes.Vector4: {\r\n                            func = (state) => {\r\n                                return Vector4.Maximize(left.getConnectedValue(state), state.adapt(right, left.type));\r\n                            };\r\n                            break;\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.output._storedFunction = (state) => {\r\n            if (left.type === NodeGeometryBlockConnectionPointTypes.Int) {\r\n                return func(state) | 0;\r\n            }\r\n            return func(state);\r\n        };\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.operation = BABYLON.MathBlockOperations.${MathBlockOperations[this.operation]};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.operation = this.operation;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.operation = serializationObject.operation;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MathBlock\", MathBlock);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}