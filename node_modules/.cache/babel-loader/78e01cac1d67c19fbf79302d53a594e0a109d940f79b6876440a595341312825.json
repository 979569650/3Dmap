{"ast":null,"code":"import { Vector3, Vector2 } from \"../Maths/math.vector.js\";\nimport { StringDictionary } from \"./stringDictionary.js\";\n// Mainly based on these 2 articles :\n// Creating an universal virtual touch joystick working for all Touch models thanks to Hand.JS : http://blogs.msdn.com/b/davrous/archive/2013/02/22/creating-an-universal-virtual-touch-joystick-working-for-all-touch-models-thanks-to-hand-js.aspx\n// & on Seb Lee-Delisle original work: http://seb.ly/2011/04/multi-touch-game-controller-in-javascripthtml5-for-ipad/\n/**\n * Defines the potential axis of a Joystick\n */\nexport var JoystickAxis;\n(function (JoystickAxis) {\n  /** X axis */\n  JoystickAxis[JoystickAxis[\"X\"] = 0] = \"X\";\n  /** Y axis */\n  JoystickAxis[JoystickAxis[\"Y\"] = 1] = \"Y\";\n  /** Z axis */\n  JoystickAxis[JoystickAxis[\"Z\"] = 2] = \"Z\";\n})(JoystickAxis || (JoystickAxis = {}));\n/**\n * Class used to define virtual joystick (used in touch mode)\n */\nexport class VirtualJoystick {\n  static _GetDefaultOptions() {\n    return {\n      puckSize: 40,\n      containerSize: 60,\n      color: \"cyan\",\n      puckImage: undefined,\n      containerImage: undefined,\n      position: undefined,\n      alwaysVisible: false,\n      limitToContainer: false\n    };\n  }\n  /**\n   * Creates a new virtual joystick\n   * @param leftJoystick defines that the joystick is for left hand (false by default)\n   * @param customizations Defines the options we want to customize the VirtualJoystick\n   */\n  constructor(leftJoystick, customizations) {\n    this._released = false;\n    const options = Object.assign(Object.assign({}, VirtualJoystick._GetDefaultOptions()), customizations);\n    if (leftJoystick) {\n      this._leftJoystick = true;\n    } else {\n      this._leftJoystick = false;\n    }\n    VirtualJoystick._GlobalJoystickIndex++;\n    // By default left & right arrow keys are moving the X\n    // and up & down keys are moving the Y\n    this._axisTargetedByLeftAndRight = JoystickAxis.X;\n    this._axisTargetedByUpAndDown = JoystickAxis.Y;\n    this.reverseLeftRight = false;\n    this.reverseUpDown = false;\n    // collections of pointers\n    this._touches = new StringDictionary();\n    this.deltaPosition = Vector3.Zero();\n    this._joystickSensibility = 25;\n    this._inversedSensibility = 1 / (this._joystickSensibility / 1000);\n    this._onResize = () => {\n      VirtualJoystick._VJCanvasWidth = window.innerWidth;\n      VirtualJoystick._VJCanvasHeight = window.innerHeight;\n      if (VirtualJoystick.Canvas) {\n        VirtualJoystick.Canvas.width = VirtualJoystick._VJCanvasWidth;\n        VirtualJoystick.Canvas.height = VirtualJoystick._VJCanvasHeight;\n      }\n      VirtualJoystick._HalfWidth = VirtualJoystick._VJCanvasWidth / 2;\n    };\n    // injecting a canvas element on top of the canvas 3D game\n    if (!VirtualJoystick.Canvas) {\n      window.addEventListener(\"resize\", this._onResize, false);\n      VirtualJoystick.Canvas = document.createElement(\"canvas\");\n      VirtualJoystick._VJCanvasWidth = window.innerWidth;\n      VirtualJoystick._VJCanvasHeight = window.innerHeight;\n      VirtualJoystick.Canvas.width = window.innerWidth;\n      VirtualJoystick.Canvas.height = window.innerHeight;\n      VirtualJoystick.Canvas.style.width = \"100%\";\n      VirtualJoystick.Canvas.style.height = \"100%\";\n      VirtualJoystick.Canvas.style.position = \"absolute\";\n      VirtualJoystick.Canvas.style.backgroundColor = \"transparent\";\n      VirtualJoystick.Canvas.style.top = \"0px\";\n      VirtualJoystick.Canvas.style.left = \"0px\";\n      VirtualJoystick.Canvas.style.zIndex = \"5\";\n      VirtualJoystick.Canvas.style.touchAction = \"none\"; // fix https://forum.babylonjs.com/t/virtualjoystick-needs-to-set-style-touch-action-none-explicitly/9562\n      // Support for jQuery PEP polyfill\n      VirtualJoystick.Canvas.setAttribute(\"touch-action\", \"none\");\n      const context = VirtualJoystick.Canvas.getContext(\"2d\");\n      if (!context) {\n        throw new Error(\"Unable to create canvas for virtual joystick\");\n      }\n      VirtualJoystick._VJCanvasContext = context;\n      VirtualJoystick._VJCanvasContext.strokeStyle = \"#ffffff\";\n      VirtualJoystick._VJCanvasContext.lineWidth = 2;\n      document.body.appendChild(VirtualJoystick.Canvas);\n    }\n    VirtualJoystick._HalfWidth = VirtualJoystick.Canvas.width / 2;\n    this.pressed = false;\n    this.limitToContainer = options.limitToContainer;\n    // default joystick color\n    this._joystickColor = options.color;\n    // default joystick size\n    this.containerSize = options.containerSize;\n    this.puckSize = options.puckSize;\n    if (options.position) {\n      this.setPosition(options.position.x, options.position.y);\n    }\n    if (options.puckImage) {\n      this.setPuckImage(options.puckImage);\n    }\n    if (options.containerImage) {\n      this.setContainerImage(options.containerImage);\n    }\n    if (options.alwaysVisible) {\n      VirtualJoystick._AlwaysVisibleSticks++;\n    }\n    // must come after position potentially set\n    this.alwaysVisible = options.alwaysVisible;\n    this._joystickPointerId = -1;\n    // current joystick position\n    this._joystickPointerPos = new Vector2(0, 0);\n    this._joystickPreviousPointerPos = new Vector2(0, 0);\n    // origin joystick position\n    this._joystickPointerStartPos = new Vector2(0, 0);\n    this._deltaJoystickVector = new Vector2(0, 0);\n    this._onPointerDownHandlerRef = evt => {\n      this._onPointerDown(evt);\n    };\n    this._onPointerMoveHandlerRef = evt => {\n      this._onPointerMove(evt);\n    };\n    this._onPointerUpHandlerRef = evt => {\n      this._onPointerUp(evt);\n    };\n    VirtualJoystick.Canvas.addEventListener(\"pointerdown\", this._onPointerDownHandlerRef, false);\n    VirtualJoystick.Canvas.addEventListener(\"pointermove\", this._onPointerMoveHandlerRef, false);\n    VirtualJoystick.Canvas.addEventListener(\"pointerup\", this._onPointerUpHandlerRef, false);\n    VirtualJoystick.Canvas.addEventListener(\"pointerout\", this._onPointerUpHandlerRef, false);\n    VirtualJoystick.Canvas.addEventListener(\"contextmenu\", evt => {\n      evt.preventDefault(); // Disables system menu\n    }, false);\n    requestAnimationFrame(() => {\n      this._drawVirtualJoystick();\n    });\n  }\n  /**\n   * Defines joystick sensibility (ie. the ratio between a physical move and virtual joystick position change)\n   * @param newJoystickSensibility defines the new sensibility\n   */\n  setJoystickSensibility(newJoystickSensibility) {\n    this._joystickSensibility = newJoystickSensibility;\n    this._inversedSensibility = 1 / (this._joystickSensibility / 1000);\n  }\n  _onPointerDown(e) {\n    let positionOnScreenCondition;\n    e.preventDefault();\n    if (this._leftJoystick === true) {\n      positionOnScreenCondition = e.clientX < VirtualJoystick._HalfWidth;\n    } else {\n      positionOnScreenCondition = e.clientX > VirtualJoystick._HalfWidth;\n    }\n    if (positionOnScreenCondition && this._joystickPointerId < 0) {\n      // First contact will be dedicated to the virtual joystick\n      this._joystickPointerId = e.pointerId;\n      if (this._joystickPosition) {\n        this._joystickPointerStartPos = this._joystickPosition.clone();\n        this._joystickPointerPos = this._joystickPosition.clone();\n        this._joystickPreviousPointerPos = this._joystickPosition.clone();\n        // in case the user only clicks down && doesn't move:\n        // this ensures the delta is properly set\n        this._onPointerMove(e);\n      } else {\n        this._joystickPointerStartPos.x = e.clientX;\n        this._joystickPointerStartPos.y = e.clientY;\n        this._joystickPointerPos = this._joystickPointerStartPos.clone();\n        this._joystickPreviousPointerPos = this._joystickPointerStartPos.clone();\n      }\n      this._deltaJoystickVector.x = 0;\n      this._deltaJoystickVector.y = 0;\n      this.pressed = true;\n      this._touches.add(e.pointerId.toString(), e);\n    } else {\n      // You can only trigger the action buttons with a joystick declared\n      if (VirtualJoystick._GlobalJoystickIndex < 2 && this._action) {\n        this._action();\n        this._touches.add(e.pointerId.toString(), {\n          x: e.clientX,\n          y: e.clientY,\n          prevX: e.clientX,\n          prevY: e.clientY\n        });\n      }\n    }\n  }\n  _onPointerMove(e) {\n    // If the current pointer is the one associated to the joystick (first touch contact)\n    if (this._joystickPointerId == e.pointerId) {\n      // limit to container if need be\n      if (this.limitToContainer) {\n        const vector = new Vector2(e.clientX - this._joystickPointerStartPos.x, e.clientY - this._joystickPointerStartPos.y);\n        const distance = vector.length();\n        if (distance > this.containerSize) {\n          vector.scaleInPlace(this.containerSize / distance);\n        }\n        this._joystickPointerPos.x = this._joystickPointerStartPos.x + vector.x;\n        this._joystickPointerPos.y = this._joystickPointerStartPos.y + vector.y;\n      } else {\n        this._joystickPointerPos.x = e.clientX;\n        this._joystickPointerPos.y = e.clientY;\n      }\n      // create delta vector\n      this._deltaJoystickVector = this._joystickPointerPos.clone();\n      this._deltaJoystickVector = this._deltaJoystickVector.subtract(this._joystickPointerStartPos);\n      // if a joystick is always visible, there will be clipping issues if\n      // you drag the puck from one over the container of the other\n      if (0 < VirtualJoystick._AlwaysVisibleSticks) {\n        if (this._leftJoystick) {\n          this._joystickPointerPos.x = Math.min(VirtualJoystick._HalfWidth, this._joystickPointerPos.x);\n        } else {\n          this._joystickPointerPos.x = Math.max(VirtualJoystick._HalfWidth, this._joystickPointerPos.x);\n        }\n      }\n      const directionLeftRight = this.reverseLeftRight ? -1 : 1;\n      const deltaJoystickX = directionLeftRight * this._deltaJoystickVector.x / this._inversedSensibility;\n      switch (this._axisTargetedByLeftAndRight) {\n        case JoystickAxis.X:\n          this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickX));\n          break;\n        case JoystickAxis.Y:\n          this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickX));\n          break;\n        case JoystickAxis.Z:\n          this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickX));\n          break;\n      }\n      const directionUpDown = this.reverseUpDown ? 1 : -1;\n      const deltaJoystickY = directionUpDown * this._deltaJoystickVector.y / this._inversedSensibility;\n      switch (this._axisTargetedByUpAndDown) {\n        case JoystickAxis.X:\n          this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickY));\n          break;\n        case JoystickAxis.Y:\n          this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickY));\n          break;\n        case JoystickAxis.Z:\n          this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickY));\n          break;\n      }\n    } else {\n      const data = this._touches.get(e.pointerId.toString());\n      if (data) {\n        data.x = e.clientX;\n        data.y = e.clientY;\n      }\n    }\n  }\n  _onPointerUp(e) {\n    if (this._joystickPointerId == e.pointerId) {\n      this._clearPreviousDraw();\n      this._joystickPointerId = -1;\n      this.pressed = false;\n    } else {\n      const touch = this._touches.get(e.pointerId.toString());\n      if (touch) {\n        VirtualJoystick._VJCanvasContext.clearRect(touch.prevX - 44, touch.prevY - 44, 88, 88);\n      }\n    }\n    this._deltaJoystickVector.x = 0;\n    this._deltaJoystickVector.y = 0;\n    this._touches.remove(e.pointerId.toString());\n  }\n  /**\n   * Change the color of the virtual joystick\n   * @param newColor a string that must be a CSS color value (like \"red\") or the hexa value (like \"#FF0000\")\n   */\n  setJoystickColor(newColor) {\n    this._joystickColor = newColor;\n  }\n  /**\n   * Size of the joystick's container\n   */\n  set containerSize(newSize) {\n    this._joystickContainerSize = newSize;\n    this._clearContainerSize = ~~(this._joystickContainerSize * 2.1);\n    this._clearContainerSizeOffset = ~~(this._clearContainerSize / 2);\n  }\n  get containerSize() {\n    return this._joystickContainerSize;\n  }\n  /**\n   * Size of the joystick's puck\n   */\n  set puckSize(newSize) {\n    this._joystickPuckSize = newSize;\n    this._clearPuckSize = ~~(this._joystickPuckSize * 2.1);\n    this._clearPuckSizeOffset = ~~(this._clearPuckSize / 2);\n  }\n  get puckSize() {\n    return this._joystickPuckSize;\n  }\n  /**\n   * Clears the set position of the joystick\n   */\n  clearPosition() {\n    this.alwaysVisible = false;\n    this._joystickPosition = null;\n  }\n  /**\n   * Defines whether or not the joystick container is always visible\n   */\n  set alwaysVisible(value) {\n    if (this._alwaysVisible === value) {\n      return;\n    }\n    if (value && this._joystickPosition) {\n      VirtualJoystick._AlwaysVisibleSticks++;\n      this._alwaysVisible = true;\n    } else {\n      VirtualJoystick._AlwaysVisibleSticks--;\n      this._alwaysVisible = false;\n    }\n  }\n  get alwaysVisible() {\n    return this._alwaysVisible;\n  }\n  /**\n   * Sets the constant position of the Joystick container\n   * @param x X axis coordinate\n   * @param y Y axis coordinate\n   */\n  setPosition(x, y) {\n    // just in case position is moved while the container is visible\n    if (this._joystickPointerStartPos) {\n      this._clearPreviousDraw();\n    }\n    this._joystickPosition = new Vector2(x, y);\n  }\n  /**\n   * Defines a callback to call when the joystick is touched\n   * @param action defines the callback\n   */\n  setActionOnTouch(action) {\n    this._action = action;\n  }\n  /**\n   * Defines which axis you'd like to control for left & right\n   * @param axis defines the axis to use\n   */\n  setAxisForLeftRight(axis) {\n    switch (axis) {\n      case JoystickAxis.X:\n      case JoystickAxis.Y:\n      case JoystickAxis.Z:\n        this._axisTargetedByLeftAndRight = axis;\n        break;\n      default:\n        this._axisTargetedByLeftAndRight = JoystickAxis.X;\n        break;\n    }\n  }\n  /**\n   * Defines which axis you'd like to control for up & down\n   * @param axis defines the axis to use\n   */\n  setAxisForUpDown(axis) {\n    switch (axis) {\n      case JoystickAxis.X:\n      case JoystickAxis.Y:\n      case JoystickAxis.Z:\n        this._axisTargetedByUpAndDown = axis;\n        break;\n      default:\n        this._axisTargetedByUpAndDown = JoystickAxis.Y;\n        break;\n    }\n  }\n  /**\n   * Clears the canvas from the previous puck / container draw\n   */\n  _clearPreviousDraw() {\n    const jp = this._joystickPosition || this._joystickPointerStartPos;\n    // clear container pixels\n    VirtualJoystick._VJCanvasContext.clearRect(jp.x - this._clearContainerSizeOffset, jp.y - this._clearContainerSizeOffset, this._clearContainerSize, this._clearContainerSize);\n    // clear puck pixels + 1 pixel for the change made before it moved\n    VirtualJoystick._VJCanvasContext.clearRect(this._joystickPreviousPointerPos.x - this._clearPuckSizeOffset - 1, this._joystickPreviousPointerPos.y - this._clearPuckSizeOffset - 1, this._clearPuckSize + 2, this._clearPuckSize + 2);\n  }\n  /**\n   * Loads `urlPath` to be used for the container's image\n   * @param urlPath defines the urlPath of an image to use\n   */\n  setContainerImage(urlPath) {\n    const image = new Image();\n    image.src = urlPath;\n    image.onload = () => this._containerImage = image;\n  }\n  /**\n   * Loads `urlPath` to be used for the puck's image\n   * @param urlPath defines the urlPath of an image to use\n   */\n  setPuckImage(urlPath) {\n    const image = new Image();\n    image.src = urlPath;\n    image.onload = () => this._puckImage = image;\n  }\n  /**\n   * Draws the Virtual Joystick's container\n   */\n  _drawContainer() {\n    const jp = this._joystickPosition || this._joystickPointerStartPos;\n    this._clearPreviousDraw();\n    if (this._containerImage) {\n      VirtualJoystick._VJCanvasContext.drawImage(this._containerImage, jp.x - this.containerSize, jp.y - this.containerSize, this.containerSize * 2, this.containerSize * 2);\n    } else {\n      // outer container\n      VirtualJoystick._VJCanvasContext.beginPath();\n      VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;\n      VirtualJoystick._VJCanvasContext.lineWidth = 2;\n      VirtualJoystick._VJCanvasContext.arc(jp.x, jp.y, this.containerSize, 0, Math.PI * 2, true);\n      VirtualJoystick._VJCanvasContext.stroke();\n      VirtualJoystick._VJCanvasContext.closePath();\n      // inner container\n      VirtualJoystick._VJCanvasContext.beginPath();\n      VirtualJoystick._VJCanvasContext.lineWidth = 6;\n      VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;\n      VirtualJoystick._VJCanvasContext.arc(jp.x, jp.y, this.puckSize, 0, Math.PI * 2, true);\n      VirtualJoystick._VJCanvasContext.stroke();\n      VirtualJoystick._VJCanvasContext.closePath();\n    }\n  }\n  /**\n   * Draws the Virtual Joystick's puck\n   */\n  _drawPuck() {\n    if (this._puckImage) {\n      VirtualJoystick._VJCanvasContext.drawImage(this._puckImage, this._joystickPointerPos.x - this.puckSize, this._joystickPointerPos.y - this.puckSize, this.puckSize * 2, this.puckSize * 2);\n    } else {\n      VirtualJoystick._VJCanvasContext.beginPath();\n      VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;\n      VirtualJoystick._VJCanvasContext.lineWidth = 2;\n      VirtualJoystick._VJCanvasContext.arc(this._joystickPointerPos.x, this._joystickPointerPos.y, this.puckSize, 0, Math.PI * 2, true);\n      VirtualJoystick._VJCanvasContext.stroke();\n      VirtualJoystick._VJCanvasContext.closePath();\n    }\n  }\n  _drawVirtualJoystick() {\n    // canvas released? don't continue iterating\n    if (this._released) {\n      return;\n    }\n    if (this.alwaysVisible) {\n      this._drawContainer();\n    }\n    if (this.pressed) {\n      this._touches.forEach((key, touch) => {\n        if (touch.pointerId === this._joystickPointerId) {\n          if (!this.alwaysVisible) {\n            this._drawContainer();\n          }\n          this._drawPuck();\n          // store current pointer for next clear\n          this._joystickPreviousPointerPos = this._joystickPointerPos.clone();\n        } else {\n          VirtualJoystick._VJCanvasContext.clearRect(touch.prevX - 44, touch.prevY - 44, 88, 88);\n          VirtualJoystick._VJCanvasContext.beginPath();\n          VirtualJoystick._VJCanvasContext.fillStyle = \"white\";\n          VirtualJoystick._VJCanvasContext.beginPath();\n          VirtualJoystick._VJCanvasContext.strokeStyle = \"red\";\n          VirtualJoystick._VJCanvasContext.lineWidth = 6;\n          VirtualJoystick._VJCanvasContext.arc(touch.x, touch.y, 40, 0, Math.PI * 2, true);\n          VirtualJoystick._VJCanvasContext.stroke();\n          VirtualJoystick._VJCanvasContext.closePath();\n          touch.prevX = touch.x;\n          touch.prevY = touch.y;\n        }\n      });\n    }\n    requestAnimationFrame(() => {\n      this._drawVirtualJoystick();\n    });\n  }\n  /**\n   * Release internal HTML canvas\n   */\n  releaseCanvas() {\n    if (VirtualJoystick.Canvas) {\n      VirtualJoystick.Canvas.removeEventListener(\"pointerdown\", this._onPointerDownHandlerRef);\n      VirtualJoystick.Canvas.removeEventListener(\"pointermove\", this._onPointerMoveHandlerRef);\n      VirtualJoystick.Canvas.removeEventListener(\"pointerup\", this._onPointerUpHandlerRef);\n      VirtualJoystick.Canvas.removeEventListener(\"pointerout\", this._onPointerUpHandlerRef);\n      window.removeEventListener(\"resize\", this._onResize);\n      document.body.removeChild(VirtualJoystick.Canvas);\n      VirtualJoystick.Canvas = null;\n    }\n    this._released = true;\n  }\n}\n// Used to draw the virtual joystick inside a 2D canvas on top of the WebGL rendering canvas\nVirtualJoystick._GlobalJoystickIndex = 0;\nVirtualJoystick._AlwaysVisibleSticks = 0;","map":{"version":3,"names":["Vector3","Vector2","StringDictionary","JoystickAxis","VirtualJoystick","_GetDefaultOptions","puckSize","containerSize","color","puckImage","undefined","containerImage","position","alwaysVisible","limitToContainer","constructor","leftJoystick","customizations","_released","options","Object","assign","_leftJoystick","_GlobalJoystickIndex","_axisTargetedByLeftAndRight","X","_axisTargetedByUpAndDown","Y","reverseLeftRight","reverseUpDown","_touches","deltaPosition","Zero","_joystickSensibility","_inversedSensibility","_onResize","_VJCanvasWidth","window","innerWidth","_VJCanvasHeight","innerHeight","Canvas","width","height","_HalfWidth","addEventListener","document","createElement","style","backgroundColor","top","left","zIndex","touchAction","setAttribute","context","getContext","Error","_VJCanvasContext","strokeStyle","lineWidth","body","appendChild","pressed","_joystickColor","setPosition","x","y","setPuckImage","setContainerImage","_AlwaysVisibleSticks","_joystickPointerId","_joystickPointerPos","_joystickPreviousPointerPos","_joystickPointerStartPos","_deltaJoystickVector","_onPointerDownHandlerRef","evt","_onPointerDown","_onPointerMoveHandlerRef","_onPointerMove","_onPointerUpHandlerRef","_onPointerUp","preventDefault","requestAnimationFrame","_drawVirtualJoystick","setJoystickSensibility","newJoystickSensibility","e","positionOnScreenCondition","clientX","pointerId","_joystickPosition","clone","clientY","add","toString","_action","prevX","prevY","vector","distance","length","scaleInPlace","subtract","Math","min","max","directionLeftRight","deltaJoystickX","Z","z","directionUpDown","deltaJoystickY","data","get","_clearPreviousDraw","touch","clearRect","remove","setJoystickColor","newColor","newSize","_joystickContainerSize","_clearContainerSize","_clearContainerSizeOffset","_joystickPuckSize","_clearPuckSize","_clearPuckSizeOffset","clearPosition","value","_alwaysVisible","setActionOnTouch","action","setAxisForLeftRight","axis","setAxisForUpDown","jp","urlPath","image","Image","src","onload","_containerImage","_puckImage","_drawContainer","drawImage","beginPath","arc","PI","stroke","closePath","_drawPuck","forEach","key","fillStyle","releaseCanvas","removeEventListener","removeChild"],"sources":["../../../../dev/core/src/Misc/virtualJoystick.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { StringDictionary } from \"./stringDictionary\";\r\n\r\n// Mainly based on these 2 articles :\r\n// Creating an universal virtual touch joystick working for all Touch models thanks to Hand.JS : http://blogs.msdn.com/b/davrous/archive/2013/02/22/creating-an-universal-virtual-touch-joystick-working-for-all-touch-models-thanks-to-hand-js.aspx\r\n// & on Seb Lee-Delisle original work: http://seb.ly/2011/04/multi-touch-game-controller-in-javascripthtml5-for-ipad/\r\n\r\n/**\r\n * Defines the potential axis of a Joystick\r\n */\r\nexport enum JoystickAxis {\r\n    /** X axis */\r\n    X,\r\n    /** Y axis */\r\n    Y,\r\n    /** Z axis */\r\n    Z,\r\n}\r\n\r\n/**\r\n * Represents the different customization options available\r\n * for VirtualJoystick\r\n */\r\ninterface VirtualJoystickCustomizations {\r\n    /**\r\n     * Size of the joystick's puck\r\n     */\r\n    puckSize: number;\r\n    /**\r\n     * Size of the joystick's container\r\n     */\r\n    containerSize: number;\r\n    /**\r\n     * Color of the joystick && puck\r\n     */\r\n    color: string;\r\n    /**\r\n     * Image URL for the joystick's puck\r\n     */\r\n    puckImage?: string;\r\n    /**\r\n     * Image URL for the joystick's container\r\n     */\r\n    containerImage?: string;\r\n    /**\r\n     * Defines the unmoving position of the joystick container\r\n     */\r\n    position?: { x: number; y: number };\r\n    /**\r\n     * Defines whether or not the joystick container is always visible\r\n     */\r\n    alwaysVisible: boolean;\r\n    /**\r\n     * Defines whether or not to limit the movement of the puck to the joystick's container\r\n     */\r\n    limitToContainer: boolean;\r\n}\r\n\r\n/**\r\n * Class used to define virtual joystick (used in touch mode)\r\n */\r\nexport class VirtualJoystick {\r\n    /**\r\n     * Gets or sets a boolean indicating that left and right values must be inverted\r\n     */\r\n    public reverseLeftRight: boolean;\r\n    /**\r\n     * Gets or sets a boolean indicating that up and down values must be inverted\r\n     */\r\n    public reverseUpDown: boolean;\r\n    /**\r\n     * Gets the offset value for the position (ie. the change of the position value)\r\n     */\r\n    public deltaPosition: Vector3;\r\n    /**\r\n     * Gets a boolean indicating if the virtual joystick was pressed\r\n     */\r\n    public pressed: boolean;\r\n    /**\r\n     * Canvas the virtual joystick will render onto, default z-index of this is 5\r\n     */\r\n    public static Canvas: Nullable<HTMLCanvasElement>;\r\n\r\n    /**\r\n     * boolean indicating whether or not the joystick's puck's movement should be limited to the joystick's container area\r\n     */\r\n    public limitToContainer: boolean;\r\n\r\n    // Used to draw the virtual joystick inside a 2D canvas on top of the WebGL rendering canvas\r\n    private static _GlobalJoystickIndex: number = 0;\r\n    private static _AlwaysVisibleSticks: number = 0;\r\n    private static _VJCanvasContext: CanvasRenderingContext2D;\r\n    private static _VJCanvasWidth: number;\r\n    private static _VJCanvasHeight: number;\r\n    private static _HalfWidth: number;\r\n    private static _GetDefaultOptions(): VirtualJoystickCustomizations {\r\n        return {\r\n            puckSize: 40,\r\n            containerSize: 60,\r\n            color: \"cyan\",\r\n            puckImage: undefined,\r\n            containerImage: undefined,\r\n            position: undefined,\r\n            alwaysVisible: false,\r\n            limitToContainer: false,\r\n        };\r\n    }\r\n\r\n    private _action: () => any;\r\n    private _axisTargetedByLeftAndRight: JoystickAxis;\r\n    private _axisTargetedByUpAndDown: JoystickAxis;\r\n    private _joystickSensibility: number;\r\n    private _inversedSensibility: number;\r\n    private _joystickPointerId: number;\r\n    private _joystickColor: string;\r\n    private _joystickPointerPos: Vector2;\r\n    private _joystickPreviousPointerPos: Vector2;\r\n    private _joystickPointerStartPos: Vector2;\r\n    private _deltaJoystickVector: Vector2;\r\n    private _leftJoystick: boolean;\r\n    private _touches: StringDictionary<{ x: number; y: number; prevX: number; prevY: number } | PointerEvent>;\r\n    private _joystickPosition: Nullable<Vector2>;\r\n    private _alwaysVisible: boolean;\r\n    private _puckImage: HTMLImageElement;\r\n    private _containerImage: HTMLImageElement;\r\n    private _released = false;\r\n\r\n    // size properties\r\n    private _joystickPuckSize: number;\r\n    private _joystickContainerSize: number;\r\n    private _clearPuckSize: number;\r\n    private _clearContainerSize: number;\r\n    private _clearPuckSizeOffset: number;\r\n    private _clearContainerSizeOffset: number;\r\n\r\n    private _onPointerDownHandlerRef: (e: PointerEvent) => any;\r\n    private _onPointerMoveHandlerRef: (e: PointerEvent) => any;\r\n    private _onPointerUpHandlerRef: (e: PointerEvent) => any;\r\n    private _onResize: (e: any) => any;\r\n\r\n    /**\r\n     * Creates a new virtual joystick\r\n     * @param leftJoystick defines that the joystick is for left hand (false by default)\r\n     * @param customizations Defines the options we want to customize the VirtualJoystick\r\n     */\r\n    constructor(leftJoystick?: boolean, customizations?: Partial<VirtualJoystickCustomizations>) {\r\n        const options = {\r\n            ...VirtualJoystick._GetDefaultOptions(),\r\n            ...customizations,\r\n        };\r\n\r\n        if (leftJoystick) {\r\n            this._leftJoystick = true;\r\n        } else {\r\n            this._leftJoystick = false;\r\n        }\r\n\r\n        VirtualJoystick._GlobalJoystickIndex++;\r\n\r\n        // By default left & right arrow keys are moving the X\r\n        // and up & down keys are moving the Y\r\n        this._axisTargetedByLeftAndRight = JoystickAxis.X;\r\n        this._axisTargetedByUpAndDown = JoystickAxis.Y;\r\n\r\n        this.reverseLeftRight = false;\r\n        this.reverseUpDown = false;\r\n\r\n        // collections of pointers\r\n        this._touches = new StringDictionary<{ x: number; y: number; prevX: number; prevY: number } | PointerEvent>();\r\n        this.deltaPosition = Vector3.Zero();\r\n\r\n        this._joystickSensibility = 25;\r\n        this._inversedSensibility = 1 / (this._joystickSensibility / 1000);\r\n\r\n        this._onResize = () => {\r\n            VirtualJoystick._VJCanvasWidth = window.innerWidth;\r\n            VirtualJoystick._VJCanvasHeight = window.innerHeight;\r\n            if (VirtualJoystick.Canvas) {\r\n                VirtualJoystick.Canvas.width = VirtualJoystick._VJCanvasWidth;\r\n                VirtualJoystick.Canvas.height = VirtualJoystick._VJCanvasHeight;\r\n            }\r\n            VirtualJoystick._HalfWidth = VirtualJoystick._VJCanvasWidth / 2;\r\n        };\r\n\r\n        // injecting a canvas element on top of the canvas 3D game\r\n        if (!VirtualJoystick.Canvas) {\r\n            window.addEventListener(\"resize\", this._onResize, false);\r\n            VirtualJoystick.Canvas = document.createElement(\"canvas\");\r\n            VirtualJoystick._VJCanvasWidth = window.innerWidth;\r\n            VirtualJoystick._VJCanvasHeight = window.innerHeight;\r\n            VirtualJoystick.Canvas.width = window.innerWidth;\r\n            VirtualJoystick.Canvas.height = window.innerHeight;\r\n            VirtualJoystick.Canvas.style.width = \"100%\";\r\n            VirtualJoystick.Canvas.style.height = \"100%\";\r\n            VirtualJoystick.Canvas.style.position = \"absolute\";\r\n            VirtualJoystick.Canvas.style.backgroundColor = \"transparent\";\r\n            VirtualJoystick.Canvas.style.top = \"0px\";\r\n            VirtualJoystick.Canvas.style.left = \"0px\";\r\n            VirtualJoystick.Canvas.style.zIndex = \"5\";\r\n            VirtualJoystick.Canvas.style.touchAction = \"none\"; // fix https://forum.babylonjs.com/t/virtualjoystick-needs-to-set-style-touch-action-none-explicitly/9562\r\n            // Support for jQuery PEP polyfill\r\n            VirtualJoystick.Canvas.setAttribute(\"touch-action\", \"none\");\r\n            const context = VirtualJoystick.Canvas.getContext(\"2d\");\r\n\r\n            if (!context) {\r\n                throw new Error(\"Unable to create canvas for virtual joystick\");\r\n            }\r\n\r\n            VirtualJoystick._VJCanvasContext = context;\r\n            VirtualJoystick._VJCanvasContext.strokeStyle = \"#ffffff\";\r\n            VirtualJoystick._VJCanvasContext.lineWidth = 2;\r\n            document.body.appendChild(VirtualJoystick.Canvas);\r\n        }\r\n        VirtualJoystick._HalfWidth = VirtualJoystick.Canvas.width / 2;\r\n        this.pressed = false;\r\n        this.limitToContainer = options.limitToContainer;\r\n\r\n        // default joystick color\r\n        this._joystickColor = options.color;\r\n\r\n        // default joystick size\r\n        this.containerSize = options.containerSize;\r\n        this.puckSize = options.puckSize;\r\n\r\n        if (options.position) {\r\n            this.setPosition(options.position.x, options.position.y);\r\n        }\r\n        if (options.puckImage) {\r\n            this.setPuckImage(options.puckImage);\r\n        }\r\n        if (options.containerImage) {\r\n            this.setContainerImage(options.containerImage);\r\n        }\r\n        if (options.alwaysVisible) {\r\n            VirtualJoystick._AlwaysVisibleSticks++;\r\n        }\r\n\r\n        // must come after position potentially set\r\n        this.alwaysVisible = options.alwaysVisible;\r\n\r\n        this._joystickPointerId = -1;\r\n        // current joystick position\r\n        this._joystickPointerPos = new Vector2(0, 0);\r\n        this._joystickPreviousPointerPos = new Vector2(0, 0);\r\n        // origin joystick position\r\n        this._joystickPointerStartPos = new Vector2(0, 0);\r\n        this._deltaJoystickVector = new Vector2(0, 0);\r\n\r\n        this._onPointerDownHandlerRef = (evt) => {\r\n            this._onPointerDown(evt);\r\n        };\r\n        this._onPointerMoveHandlerRef = (evt) => {\r\n            this._onPointerMove(evt);\r\n        };\r\n        this._onPointerUpHandlerRef = (evt) => {\r\n            this._onPointerUp(evt);\r\n        };\r\n\r\n        VirtualJoystick.Canvas.addEventListener(\"pointerdown\", this._onPointerDownHandlerRef, false);\r\n        VirtualJoystick.Canvas.addEventListener(\"pointermove\", this._onPointerMoveHandlerRef, false);\r\n        VirtualJoystick.Canvas.addEventListener(\"pointerup\", this._onPointerUpHandlerRef, false);\r\n        VirtualJoystick.Canvas.addEventListener(\"pointerout\", this._onPointerUpHandlerRef, false);\r\n        VirtualJoystick.Canvas.addEventListener(\r\n            \"contextmenu\",\r\n            (evt) => {\r\n                evt.preventDefault(); // Disables system menu\r\n            },\r\n            false\r\n        );\r\n        requestAnimationFrame(() => {\r\n            this._drawVirtualJoystick();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Defines joystick sensibility (ie. the ratio between a physical move and virtual joystick position change)\r\n     * @param newJoystickSensibility defines the new sensibility\r\n     */\r\n    public setJoystickSensibility(newJoystickSensibility: number) {\r\n        this._joystickSensibility = newJoystickSensibility;\r\n        this._inversedSensibility = 1 / (this._joystickSensibility / 1000);\r\n    }\r\n\r\n    private _onPointerDown(e: PointerEvent) {\r\n        let positionOnScreenCondition: boolean;\r\n\r\n        e.preventDefault();\r\n\r\n        if (this._leftJoystick === true) {\r\n            positionOnScreenCondition = e.clientX < VirtualJoystick._HalfWidth;\r\n        } else {\r\n            positionOnScreenCondition = e.clientX > VirtualJoystick._HalfWidth;\r\n        }\r\n\r\n        if (positionOnScreenCondition && this._joystickPointerId < 0) {\r\n            // First contact will be dedicated to the virtual joystick\r\n            this._joystickPointerId = e.pointerId;\r\n\r\n            if (this._joystickPosition) {\r\n                this._joystickPointerStartPos = this._joystickPosition.clone();\r\n                this._joystickPointerPos = this._joystickPosition.clone();\r\n                this._joystickPreviousPointerPos = this._joystickPosition.clone();\r\n\r\n                // in case the user only clicks down && doesn't move:\r\n                // this ensures the delta is properly set\r\n                this._onPointerMove(e);\r\n            } else {\r\n                this._joystickPointerStartPos.x = e.clientX;\r\n                this._joystickPointerStartPos.y = e.clientY;\r\n                this._joystickPointerPos = this._joystickPointerStartPos.clone();\r\n                this._joystickPreviousPointerPos = this._joystickPointerStartPos.clone();\r\n            }\r\n\r\n            this._deltaJoystickVector.x = 0;\r\n            this._deltaJoystickVector.y = 0;\r\n            this.pressed = true;\r\n            this._touches.add(e.pointerId.toString(), e);\r\n        } else {\r\n            // You can only trigger the action buttons with a joystick declared\r\n            if (VirtualJoystick._GlobalJoystickIndex < 2 && this._action) {\r\n                this._action();\r\n                this._touches.add(e.pointerId.toString(), { x: e.clientX, y: e.clientY, prevX: e.clientX, prevY: e.clientY });\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onPointerMove(e: PointerEvent) {\r\n        // If the current pointer is the one associated to the joystick (first touch contact)\r\n        if (this._joystickPointerId == e.pointerId) {\r\n            // limit to container if need be\r\n            if (this.limitToContainer) {\r\n                const vector = new Vector2(e.clientX - this._joystickPointerStartPos.x, e.clientY - this._joystickPointerStartPos.y);\r\n                const distance = vector.length();\r\n\r\n                if (distance > this.containerSize) {\r\n                    vector.scaleInPlace(this.containerSize / distance);\r\n                }\r\n\r\n                this._joystickPointerPos.x = this._joystickPointerStartPos.x + vector.x;\r\n                this._joystickPointerPos.y = this._joystickPointerStartPos.y + vector.y;\r\n            } else {\r\n                this._joystickPointerPos.x = e.clientX;\r\n                this._joystickPointerPos.y = e.clientY;\r\n            }\r\n\r\n            // create delta vector\r\n            this._deltaJoystickVector = this._joystickPointerPos.clone();\r\n            this._deltaJoystickVector = this._deltaJoystickVector.subtract(this._joystickPointerStartPos);\r\n\r\n            // if a joystick is always visible, there will be clipping issues if\r\n            // you drag the puck from one over the container of the other\r\n            if (0 < VirtualJoystick._AlwaysVisibleSticks) {\r\n                if (this._leftJoystick) {\r\n                    this._joystickPointerPos.x = Math.min(VirtualJoystick._HalfWidth, this._joystickPointerPos.x);\r\n                } else {\r\n                    this._joystickPointerPos.x = Math.max(VirtualJoystick._HalfWidth, this._joystickPointerPos.x);\r\n                }\r\n            }\r\n\r\n            const directionLeftRight = this.reverseLeftRight ? -1 : 1;\r\n            const deltaJoystickX = (directionLeftRight * this._deltaJoystickVector.x) / this._inversedSensibility;\r\n            switch (this._axisTargetedByLeftAndRight) {\r\n                case JoystickAxis.X:\r\n                    this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickX));\r\n                    break;\r\n                case JoystickAxis.Y:\r\n                    this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickX));\r\n                    break;\r\n                case JoystickAxis.Z:\r\n                    this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickX));\r\n                    break;\r\n            }\r\n            const directionUpDown = this.reverseUpDown ? 1 : -1;\r\n            const deltaJoystickY = (directionUpDown * this._deltaJoystickVector.y) / this._inversedSensibility;\r\n            switch (this._axisTargetedByUpAndDown) {\r\n                case JoystickAxis.X:\r\n                    this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickY));\r\n                    break;\r\n                case JoystickAxis.Y:\r\n                    this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickY));\r\n                    break;\r\n                case JoystickAxis.Z:\r\n                    this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickY));\r\n                    break;\r\n            }\r\n        } else {\r\n            const data = this._touches.get(e.pointerId.toString());\r\n            if (data) {\r\n                (data as any).x = e.clientX;\r\n                (data as any).y = e.clientY;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onPointerUp(e: PointerEvent) {\r\n        if (this._joystickPointerId == e.pointerId) {\r\n            this._clearPreviousDraw();\r\n\r\n            this._joystickPointerId = -1;\r\n            this.pressed = false;\r\n        } else {\r\n            const touch = <{ x: number; y: number; prevX: number; prevY: number }>this._touches.get(e.pointerId.toString());\r\n            if (touch) {\r\n                VirtualJoystick._VJCanvasContext.clearRect(touch.prevX - 44, touch.prevY - 44, 88, 88);\r\n            }\r\n        }\r\n        this._deltaJoystickVector.x = 0;\r\n        this._deltaJoystickVector.y = 0;\r\n\r\n        this._touches.remove(e.pointerId.toString());\r\n    }\r\n\r\n    /**\r\n     * Change the color of the virtual joystick\r\n     * @param newColor a string that must be a CSS color value (like \"red\") or the hexa value (like \"#FF0000\")\r\n     */\r\n    public setJoystickColor(newColor: string) {\r\n        this._joystickColor = newColor;\r\n    }\r\n\r\n    /**\r\n     * Size of the joystick's container\r\n     */\r\n    public set containerSize(newSize: number) {\r\n        this._joystickContainerSize = newSize;\r\n        this._clearContainerSize = ~~(this._joystickContainerSize * 2.1);\r\n        this._clearContainerSizeOffset = ~~(this._clearContainerSize / 2);\r\n    }\r\n    public get containerSize() {\r\n        return this._joystickContainerSize;\r\n    }\r\n\r\n    /**\r\n     * Size of the joystick's puck\r\n     */\r\n    public set puckSize(newSize: number) {\r\n        this._joystickPuckSize = newSize;\r\n        this._clearPuckSize = ~~(this._joystickPuckSize * 2.1);\r\n        this._clearPuckSizeOffset = ~~(this._clearPuckSize / 2);\r\n    }\r\n    public get puckSize() {\r\n        return this._joystickPuckSize;\r\n    }\r\n\r\n    /**\r\n     * Clears the set position of the joystick\r\n     */\r\n    public clearPosition() {\r\n        this.alwaysVisible = false;\r\n\r\n        this._joystickPosition = null;\r\n    }\r\n\r\n    /**\r\n     * Defines whether or not the joystick container is always visible\r\n     */\r\n    public set alwaysVisible(value: boolean) {\r\n        if (this._alwaysVisible === value) {\r\n            return;\r\n        }\r\n\r\n        if (value && this._joystickPosition) {\r\n            VirtualJoystick._AlwaysVisibleSticks++;\r\n\r\n            this._alwaysVisible = true;\r\n        } else {\r\n            VirtualJoystick._AlwaysVisibleSticks--;\r\n\r\n            this._alwaysVisible = false;\r\n        }\r\n    }\r\n    public get alwaysVisible() {\r\n        return this._alwaysVisible;\r\n    }\r\n\r\n    /**\r\n     * Sets the constant position of the Joystick container\r\n     * @param x X axis coordinate\r\n     * @param y Y axis coordinate\r\n     */\r\n    public setPosition(x: number, y: number) {\r\n        // just in case position is moved while the container is visible\r\n        if (this._joystickPointerStartPos) {\r\n            this._clearPreviousDraw();\r\n        }\r\n\r\n        this._joystickPosition = new Vector2(x, y);\r\n    }\r\n\r\n    /**\r\n     * Defines a callback to call when the joystick is touched\r\n     * @param action defines the callback\r\n     */\r\n    public setActionOnTouch(action: () => any) {\r\n        this._action = action;\r\n    }\r\n\r\n    /**\r\n     * Defines which axis you'd like to control for left & right\r\n     * @param axis defines the axis to use\r\n     */\r\n    public setAxisForLeftRight(axis: JoystickAxis) {\r\n        switch (axis) {\r\n            case JoystickAxis.X:\r\n            case JoystickAxis.Y:\r\n            case JoystickAxis.Z:\r\n                this._axisTargetedByLeftAndRight = axis;\r\n                break;\r\n            default:\r\n                this._axisTargetedByLeftAndRight = JoystickAxis.X;\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines which axis you'd like to control for up & down\r\n     * @param axis defines the axis to use\r\n     */\r\n    public setAxisForUpDown(axis: JoystickAxis) {\r\n        switch (axis) {\r\n            case JoystickAxis.X:\r\n            case JoystickAxis.Y:\r\n            case JoystickAxis.Z:\r\n                this._axisTargetedByUpAndDown = axis;\r\n                break;\r\n            default:\r\n                this._axisTargetedByUpAndDown = JoystickAxis.Y;\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clears the canvas from the previous puck / container draw\r\n     */\r\n    private _clearPreviousDraw() {\r\n        const jp = this._joystickPosition || this._joystickPointerStartPos;\r\n\r\n        // clear container pixels\r\n        VirtualJoystick._VJCanvasContext.clearRect(\r\n            jp.x - this._clearContainerSizeOffset,\r\n            jp.y - this._clearContainerSizeOffset,\r\n            this._clearContainerSize,\r\n            this._clearContainerSize\r\n        );\r\n\r\n        // clear puck pixels + 1 pixel for the change made before it moved\r\n        VirtualJoystick._VJCanvasContext.clearRect(\r\n            this._joystickPreviousPointerPos.x - this._clearPuckSizeOffset - 1,\r\n            this._joystickPreviousPointerPos.y - this._clearPuckSizeOffset - 1,\r\n            this._clearPuckSize + 2,\r\n            this._clearPuckSize + 2\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Loads `urlPath` to be used for the container's image\r\n     * @param urlPath defines the urlPath of an image to use\r\n     */\r\n    public setContainerImage(urlPath: string) {\r\n        const image = new Image();\r\n        image.src = urlPath;\r\n\r\n        image.onload = () => (this._containerImage = image);\r\n    }\r\n\r\n    /**\r\n     * Loads `urlPath` to be used for the puck's image\r\n     * @param urlPath defines the urlPath of an image to use\r\n     */\r\n    public setPuckImage(urlPath: string) {\r\n        const image = new Image();\r\n        image.src = urlPath;\r\n\r\n        image.onload = () => (this._puckImage = image);\r\n    }\r\n\r\n    /**\r\n     * Draws the Virtual Joystick's container\r\n     */\r\n    private _drawContainer() {\r\n        const jp = this._joystickPosition || this._joystickPointerStartPos;\r\n\r\n        this._clearPreviousDraw();\r\n\r\n        if (this._containerImage) {\r\n            VirtualJoystick._VJCanvasContext.drawImage(this._containerImage, jp.x - this.containerSize, jp.y - this.containerSize, this.containerSize * 2, this.containerSize * 2);\r\n        } else {\r\n            // outer container\r\n            VirtualJoystick._VJCanvasContext.beginPath();\r\n            VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;\r\n            VirtualJoystick._VJCanvasContext.lineWidth = 2;\r\n            VirtualJoystick._VJCanvasContext.arc(jp.x, jp.y, this.containerSize, 0, Math.PI * 2, true);\r\n            VirtualJoystick._VJCanvasContext.stroke();\r\n            VirtualJoystick._VJCanvasContext.closePath();\r\n\r\n            // inner container\r\n            VirtualJoystick._VJCanvasContext.beginPath();\r\n            VirtualJoystick._VJCanvasContext.lineWidth = 6;\r\n            VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;\r\n            VirtualJoystick._VJCanvasContext.arc(jp.x, jp.y, this.puckSize, 0, Math.PI * 2, true);\r\n            VirtualJoystick._VJCanvasContext.stroke();\r\n            VirtualJoystick._VJCanvasContext.closePath();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the Virtual Joystick's puck\r\n     */\r\n    private _drawPuck() {\r\n        if (this._puckImage) {\r\n            VirtualJoystick._VJCanvasContext.drawImage(\r\n                this._puckImage,\r\n                this._joystickPointerPos.x - this.puckSize,\r\n                this._joystickPointerPos.y - this.puckSize,\r\n                this.puckSize * 2,\r\n                this.puckSize * 2\r\n            );\r\n        } else {\r\n            VirtualJoystick._VJCanvasContext.beginPath();\r\n            VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;\r\n            VirtualJoystick._VJCanvasContext.lineWidth = 2;\r\n            VirtualJoystick._VJCanvasContext.arc(this._joystickPointerPos.x, this._joystickPointerPos.y, this.puckSize, 0, Math.PI * 2, true);\r\n            VirtualJoystick._VJCanvasContext.stroke();\r\n            VirtualJoystick._VJCanvasContext.closePath();\r\n        }\r\n    }\r\n\r\n    private _drawVirtualJoystick() {\r\n        // canvas released? don't continue iterating\r\n        if (this._released) {\r\n            return;\r\n        }\r\n        if (this.alwaysVisible) {\r\n            this._drawContainer();\r\n        }\r\n\r\n        if (this.pressed) {\r\n            this._touches.forEach((key, touch) => {\r\n                if ((<PointerEvent>touch).pointerId === this._joystickPointerId) {\r\n                    if (!this.alwaysVisible) {\r\n                        this._drawContainer();\r\n                    }\r\n\r\n                    this._drawPuck();\r\n\r\n                    // store current pointer for next clear\r\n                    this._joystickPreviousPointerPos = this._joystickPointerPos.clone();\r\n                } else {\r\n                    VirtualJoystick._VJCanvasContext.clearRect((<any>touch).prevX - 44, (<any>touch).prevY - 44, 88, 88);\r\n                    VirtualJoystick._VJCanvasContext.beginPath();\r\n                    VirtualJoystick._VJCanvasContext.fillStyle = \"white\";\r\n                    VirtualJoystick._VJCanvasContext.beginPath();\r\n                    VirtualJoystick._VJCanvasContext.strokeStyle = \"red\";\r\n                    VirtualJoystick._VJCanvasContext.lineWidth = 6;\r\n                    VirtualJoystick._VJCanvasContext.arc(touch.x, touch.y, 40, 0, Math.PI * 2, true);\r\n                    VirtualJoystick._VJCanvasContext.stroke();\r\n                    VirtualJoystick._VJCanvasContext.closePath();\r\n                    (<any>touch).prevX = touch.x;\r\n                    (<any>touch).prevY = touch.y;\r\n                }\r\n            });\r\n        }\r\n        requestAnimationFrame(() => {\r\n            this._drawVirtualJoystick();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Release internal HTML canvas\r\n     */\r\n    public releaseCanvas() {\r\n        if (VirtualJoystick.Canvas) {\r\n            VirtualJoystick.Canvas.removeEventListener(\"pointerdown\", this._onPointerDownHandlerRef);\r\n            VirtualJoystick.Canvas.removeEventListener(\"pointermove\", this._onPointerMoveHandlerRef);\r\n            VirtualJoystick.Canvas.removeEventListener(\"pointerup\", this._onPointerUpHandlerRef);\r\n            VirtualJoystick.Canvas.removeEventListener(\"pointerout\", this._onPointerUpHandlerRef);\r\n            window.removeEventListener(\"resize\", this._onResize);\r\n            document.body.removeChild(VirtualJoystick.Canvas);\r\n            VirtualJoystick.Canvas = null;\r\n        }\r\n        this._released = true;\r\n    }\r\n}\r\n"],"mappings":"AACA,SAASA,OAAO,EAAEC,OAAO,QAAQ,yBAAuB;AACxD,SAASC,gBAAgB,QAAQ,uBAAqB;AAEtD;AACA;AACA;AAEA;;;AAGA,WAAYC,YAOX;AAPD,WAAYA,YAAY;EACpB;EACAA,YAAA,CAAAA,YAAA,gBAAC;EACD;EACAA,YAAA,CAAAA,YAAA,gBAAC;EACD;EACAA,YAAA,CAAAA,YAAA,gBAAC;AACL,CAAC,EAPWA,YAAY,KAAZA,YAAY;AAgDxB;;;AAGA,OAAM,MAAOC,eAAe;EAkChB,OAAOC,kBAAkBA,CAAA;IAC7B,OAAO;MACHC,QAAQ,EAAE,EAAE;MACZC,aAAa,EAAE,EAAE;MACjBC,KAAK,EAAE,MAAM;MACbC,SAAS,EAAEC,SAAS;MACpBC,cAAc,EAAED,SAAS;MACzBE,QAAQ,EAAEF,SAAS;MACnBG,aAAa,EAAE,KAAK;MACpBC,gBAAgB,EAAE;KACrB;EACL;EAkCA;;;;;EAKAC,YAAYC,YAAsB,EAAEC,cAAuD;IApBnF,KAAAC,SAAS,GAAG,KAAK;IAqBrB,MAAMC,OAAO,GAAAC,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACNjB,eAAe,CAACC,kBAAkB,EAAE,GACpCY,cAAc,CACpB;IAED,IAAID,YAAY,EAAE;MACd,IAAI,CAACM,aAAa,GAAG,IAAI;KAC5B,MAAM;MACH,IAAI,CAACA,aAAa,GAAG,KAAK;;IAG9BlB,eAAe,CAACmB,oBAAoB,EAAE;IAEtC;IACA;IACA,IAAI,CAACC,2BAA2B,GAAGrB,YAAY,CAACsB,CAAC;IACjD,IAAI,CAACC,wBAAwB,GAAGvB,YAAY,CAACwB,CAAC;IAE9C,IAAI,CAACC,gBAAgB,GAAG,KAAK;IAC7B,IAAI,CAACC,aAAa,GAAG,KAAK;IAE1B;IACA,IAAI,CAACC,QAAQ,GAAG,IAAI5B,gBAAgB,EAAyE;IAC7G,IAAI,CAAC6B,aAAa,GAAG/B,OAAO,CAACgC,IAAI,EAAE;IAEnC,IAAI,CAACC,oBAAoB,GAAG,EAAE;IAC9B,IAAI,CAACC,oBAAoB,GAAG,CAAC,IAAI,IAAI,CAACD,oBAAoB,GAAG,IAAI,CAAC;IAElE,IAAI,CAACE,SAAS,GAAG,MAAK;MAClB/B,eAAe,CAACgC,cAAc,GAAGC,MAAM,CAACC,UAAU;MAClDlC,eAAe,CAACmC,eAAe,GAAGF,MAAM,CAACG,WAAW;MACpD,IAAIpC,eAAe,CAACqC,MAAM,EAAE;QACxBrC,eAAe,CAACqC,MAAM,CAACC,KAAK,GAAGtC,eAAe,CAACgC,cAAc;QAC7DhC,eAAe,CAACqC,MAAM,CAACE,MAAM,GAAGvC,eAAe,CAACmC,eAAe;;MAEnEnC,eAAe,CAACwC,UAAU,GAAGxC,eAAe,CAACgC,cAAc,GAAG,CAAC;IACnE,CAAC;IAED;IACA,IAAI,CAAChC,eAAe,CAACqC,MAAM,EAAE;MACzBJ,MAAM,CAACQ,gBAAgB,CAAC,QAAQ,EAAE,IAAI,CAACV,SAAS,EAAE,KAAK,CAAC;MACxD/B,eAAe,CAACqC,MAAM,GAAGK,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;MACzD3C,eAAe,CAACgC,cAAc,GAAGC,MAAM,CAACC,UAAU;MAClDlC,eAAe,CAACmC,eAAe,GAAGF,MAAM,CAACG,WAAW;MACpDpC,eAAe,CAACqC,MAAM,CAACC,KAAK,GAAGL,MAAM,CAACC,UAAU;MAChDlC,eAAe,CAACqC,MAAM,CAACE,MAAM,GAAGN,MAAM,CAACG,WAAW;MAClDpC,eAAe,CAACqC,MAAM,CAACO,KAAK,CAACN,KAAK,GAAG,MAAM;MAC3CtC,eAAe,CAACqC,MAAM,CAACO,KAAK,CAACL,MAAM,GAAG,MAAM;MAC5CvC,eAAe,CAACqC,MAAM,CAACO,KAAK,CAACpC,QAAQ,GAAG,UAAU;MAClDR,eAAe,CAACqC,MAAM,CAACO,KAAK,CAACC,eAAe,GAAG,aAAa;MAC5D7C,eAAe,CAACqC,MAAM,CAACO,KAAK,CAACE,GAAG,GAAG,KAAK;MACxC9C,eAAe,CAACqC,MAAM,CAACO,KAAK,CAACG,IAAI,GAAG,KAAK;MACzC/C,eAAe,CAACqC,MAAM,CAACO,KAAK,CAACI,MAAM,GAAG,GAAG;MACzChD,eAAe,CAACqC,MAAM,CAACO,KAAK,CAACK,WAAW,GAAG,MAAM,CAAC,CAAC;MACnD;MACAjD,eAAe,CAACqC,MAAM,CAACa,YAAY,CAAC,cAAc,EAAE,MAAM,CAAC;MAC3D,MAAMC,OAAO,GAAGnD,eAAe,CAACqC,MAAM,CAACe,UAAU,CAAC,IAAI,CAAC;MAEvD,IAAI,CAACD,OAAO,EAAE;QACV,MAAM,IAAIE,KAAK,CAAC,8CAA8C,CAAC;;MAGnErD,eAAe,CAACsD,gBAAgB,GAAGH,OAAO;MAC1CnD,eAAe,CAACsD,gBAAgB,CAACC,WAAW,GAAG,SAAS;MACxDvD,eAAe,CAACsD,gBAAgB,CAACE,SAAS,GAAG,CAAC;MAC9Cd,QAAQ,CAACe,IAAI,CAACC,WAAW,CAAC1D,eAAe,CAACqC,MAAM,CAAC;;IAErDrC,eAAe,CAACwC,UAAU,GAAGxC,eAAe,CAACqC,MAAM,CAACC,KAAK,GAAG,CAAC;IAC7D,IAAI,CAACqB,OAAO,GAAG,KAAK;IACpB,IAAI,CAACjD,gBAAgB,GAAGK,OAAO,CAACL,gBAAgB;IAEhD;IACA,IAAI,CAACkD,cAAc,GAAG7C,OAAO,CAACX,KAAK;IAEnC;IACA,IAAI,CAACD,aAAa,GAAGY,OAAO,CAACZ,aAAa;IAC1C,IAAI,CAACD,QAAQ,GAAGa,OAAO,CAACb,QAAQ;IAEhC,IAAIa,OAAO,CAACP,QAAQ,EAAE;MAClB,IAAI,CAACqD,WAAW,CAAC9C,OAAO,CAACP,QAAQ,CAACsD,CAAC,EAAE/C,OAAO,CAACP,QAAQ,CAACuD,CAAC,CAAC;;IAE5D,IAAIhD,OAAO,CAACV,SAAS,EAAE;MACnB,IAAI,CAAC2D,YAAY,CAACjD,OAAO,CAACV,SAAS,CAAC;;IAExC,IAAIU,OAAO,CAACR,cAAc,EAAE;MACxB,IAAI,CAAC0D,iBAAiB,CAAClD,OAAO,CAACR,cAAc,CAAC;;IAElD,IAAIQ,OAAO,CAACN,aAAa,EAAE;MACvBT,eAAe,CAACkE,oBAAoB,EAAE;;IAG1C;IACA,IAAI,CAACzD,aAAa,GAAGM,OAAO,CAACN,aAAa;IAE1C,IAAI,CAAC0D,kBAAkB,GAAG,CAAC,CAAC;IAC5B;IACA,IAAI,CAACC,mBAAmB,GAAG,IAAIvE,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;IAC5C,IAAI,CAACwE,2BAA2B,GAAG,IAAIxE,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;IACpD;IACA,IAAI,CAACyE,wBAAwB,GAAG,IAAIzE,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;IACjD,IAAI,CAAC0E,oBAAoB,GAAG,IAAI1E,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;IAE7C,IAAI,CAAC2E,wBAAwB,GAAIC,GAAG,IAAI;MACpC,IAAI,CAACC,cAAc,CAACD,GAAG,CAAC;IAC5B,CAAC;IACD,IAAI,CAACE,wBAAwB,GAAIF,GAAG,IAAI;MACpC,IAAI,CAACG,cAAc,CAACH,GAAG,CAAC;IAC5B,CAAC;IACD,IAAI,CAACI,sBAAsB,GAAIJ,GAAG,IAAI;MAClC,IAAI,CAACK,YAAY,CAACL,GAAG,CAAC;IAC1B,CAAC;IAEDzE,eAAe,CAACqC,MAAM,CAACI,gBAAgB,CAAC,aAAa,EAAE,IAAI,CAAC+B,wBAAwB,EAAE,KAAK,CAAC;IAC5FxE,eAAe,CAACqC,MAAM,CAACI,gBAAgB,CAAC,aAAa,EAAE,IAAI,CAACkC,wBAAwB,EAAE,KAAK,CAAC;IAC5F3E,eAAe,CAACqC,MAAM,CAACI,gBAAgB,CAAC,WAAW,EAAE,IAAI,CAACoC,sBAAsB,EAAE,KAAK,CAAC;IACxF7E,eAAe,CAACqC,MAAM,CAACI,gBAAgB,CAAC,YAAY,EAAE,IAAI,CAACoC,sBAAsB,EAAE,KAAK,CAAC;IACzF7E,eAAe,CAACqC,MAAM,CAACI,gBAAgB,CACnC,aAAa,EACZgC,GAAG,IAAI;MACJA,GAAG,CAACM,cAAc,EAAE,CAAC,CAAC;IAC1B,CAAC,EACD,KAAK,CACR;IACDC,qBAAqB,CAAC,MAAK;MACvB,IAAI,CAACC,oBAAoB,EAAE;IAC/B,CAAC,CAAC;EACN;EAEA;;;;EAIOC,sBAAsBA,CAACC,sBAA8B;IACxD,IAAI,CAACtD,oBAAoB,GAAGsD,sBAAsB;IAClD,IAAI,CAACrD,oBAAoB,GAAG,CAAC,IAAI,IAAI,CAACD,oBAAoB,GAAG,IAAI,CAAC;EACtE;EAEQ6C,cAAcA,CAACU,CAAe;IAClC,IAAIC,yBAAkC;IAEtCD,CAAC,CAACL,cAAc,EAAE;IAElB,IAAI,IAAI,CAAC7D,aAAa,KAAK,IAAI,EAAE;MAC7BmE,yBAAyB,GAAGD,CAAC,CAACE,OAAO,GAAGtF,eAAe,CAACwC,UAAU;KACrE,MAAM;MACH6C,yBAAyB,GAAGD,CAAC,CAACE,OAAO,GAAGtF,eAAe,CAACwC,UAAU;;IAGtE,IAAI6C,yBAAyB,IAAI,IAAI,CAAClB,kBAAkB,GAAG,CAAC,EAAE;MAC1D;MACA,IAAI,CAACA,kBAAkB,GAAGiB,CAAC,CAACG,SAAS;MAErC,IAAI,IAAI,CAACC,iBAAiB,EAAE;QACxB,IAAI,CAAClB,wBAAwB,GAAG,IAAI,CAACkB,iBAAiB,CAACC,KAAK,EAAE;QAC9D,IAAI,CAACrB,mBAAmB,GAAG,IAAI,CAACoB,iBAAiB,CAACC,KAAK,EAAE;QACzD,IAAI,CAACpB,2BAA2B,GAAG,IAAI,CAACmB,iBAAiB,CAACC,KAAK,EAAE;QAEjE;QACA;QACA,IAAI,CAACb,cAAc,CAACQ,CAAC,CAAC;OACzB,MAAM;QACH,IAAI,CAACd,wBAAwB,CAACR,CAAC,GAAGsB,CAAC,CAACE,OAAO;QAC3C,IAAI,CAAChB,wBAAwB,CAACP,CAAC,GAAGqB,CAAC,CAACM,OAAO;QAC3C,IAAI,CAACtB,mBAAmB,GAAG,IAAI,CAACE,wBAAwB,CAACmB,KAAK,EAAE;QAChE,IAAI,CAACpB,2BAA2B,GAAG,IAAI,CAACC,wBAAwB,CAACmB,KAAK,EAAE;;MAG5E,IAAI,CAAClB,oBAAoB,CAACT,CAAC,GAAG,CAAC;MAC/B,IAAI,CAACS,oBAAoB,CAACR,CAAC,GAAG,CAAC;MAC/B,IAAI,CAACJ,OAAO,GAAG,IAAI;MACnB,IAAI,CAACjC,QAAQ,CAACiE,GAAG,CAACP,CAAC,CAACG,SAAS,CAACK,QAAQ,EAAE,EAAER,CAAC,CAAC;KAC/C,MAAM;MACH;MACA,IAAIpF,eAAe,CAACmB,oBAAoB,GAAG,CAAC,IAAI,IAAI,CAAC0E,OAAO,EAAE;QAC1D,IAAI,CAACA,OAAO,EAAE;QACd,IAAI,CAACnE,QAAQ,CAACiE,GAAG,CAACP,CAAC,CAACG,SAAS,CAACK,QAAQ,EAAE,EAAE;UAAE9B,CAAC,EAAEsB,CAAC,CAACE,OAAO;UAAEvB,CAAC,EAAEqB,CAAC,CAACM,OAAO;UAAEI,KAAK,EAAEV,CAAC,CAACE,OAAO;UAAES,KAAK,EAAEX,CAAC,CAACM;QAAO,CAAE,CAAC;;;EAGzH;EAEQd,cAAcA,CAACQ,CAAe;IAClC;IACA,IAAI,IAAI,CAACjB,kBAAkB,IAAIiB,CAAC,CAACG,SAAS,EAAE;MACxC;MACA,IAAI,IAAI,CAAC7E,gBAAgB,EAAE;QACvB,MAAMsF,MAAM,GAAG,IAAInG,OAAO,CAACuF,CAAC,CAACE,OAAO,GAAG,IAAI,CAAChB,wBAAwB,CAACR,CAAC,EAAEsB,CAAC,CAACM,OAAO,GAAG,IAAI,CAACpB,wBAAwB,CAACP,CAAC,CAAC;QACpH,MAAMkC,QAAQ,GAAGD,MAAM,CAACE,MAAM,EAAE;QAEhC,IAAID,QAAQ,GAAG,IAAI,CAAC9F,aAAa,EAAE;UAC/B6F,MAAM,CAACG,YAAY,CAAC,IAAI,CAAChG,aAAa,GAAG8F,QAAQ,CAAC;;QAGtD,IAAI,CAAC7B,mBAAmB,CAACN,CAAC,GAAG,IAAI,CAACQ,wBAAwB,CAACR,CAAC,GAAGkC,MAAM,CAAClC,CAAC;QACvE,IAAI,CAACM,mBAAmB,CAACL,CAAC,GAAG,IAAI,CAACO,wBAAwB,CAACP,CAAC,GAAGiC,MAAM,CAACjC,CAAC;OAC1E,MAAM;QACH,IAAI,CAACK,mBAAmB,CAACN,CAAC,GAAGsB,CAAC,CAACE,OAAO;QACtC,IAAI,CAAClB,mBAAmB,CAACL,CAAC,GAAGqB,CAAC,CAACM,OAAO;;MAG1C;MACA,IAAI,CAACnB,oBAAoB,GAAG,IAAI,CAACH,mBAAmB,CAACqB,KAAK,EAAE;MAC5D,IAAI,CAAClB,oBAAoB,GAAG,IAAI,CAACA,oBAAoB,CAAC6B,QAAQ,CAAC,IAAI,CAAC9B,wBAAwB,CAAC;MAE7F;MACA;MACA,IAAI,CAAC,GAAGtE,eAAe,CAACkE,oBAAoB,EAAE;QAC1C,IAAI,IAAI,CAAChD,aAAa,EAAE;UACpB,IAAI,CAACkD,mBAAmB,CAACN,CAAC,GAAGuC,IAAI,CAACC,GAAG,CAACtG,eAAe,CAACwC,UAAU,EAAE,IAAI,CAAC4B,mBAAmB,CAACN,CAAC,CAAC;SAChG,MAAM;UACH,IAAI,CAACM,mBAAmB,CAACN,CAAC,GAAGuC,IAAI,CAACE,GAAG,CAACvG,eAAe,CAACwC,UAAU,EAAE,IAAI,CAAC4B,mBAAmB,CAACN,CAAC,CAAC;;;MAIrG,MAAM0C,kBAAkB,GAAG,IAAI,CAAChF,gBAAgB,GAAG,CAAC,CAAC,GAAG,CAAC;MACzD,MAAMiF,cAAc,GAAID,kBAAkB,GAAG,IAAI,CAACjC,oBAAoB,CAACT,CAAC,GAAI,IAAI,CAAChC,oBAAoB;MACrG,QAAQ,IAAI,CAACV,2BAA2B;QACpC,KAAKrB,YAAY,CAACsB,CAAC;UACf,IAAI,CAACM,aAAa,CAACmC,CAAC,GAAGuC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,GAAG,CAAC,CAAC,CAAC,EAAEE,cAAc,CAAC,CAAC;UAChE;QACJ,KAAK1G,YAAY,CAACwB,CAAC;UACf,IAAI,CAACI,aAAa,CAACoC,CAAC,GAAGsC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,GAAG,CAAC,CAAC,CAAC,EAAEE,cAAc,CAAC,CAAC;UAChE;QACJ,KAAK1G,YAAY,CAAC2G,CAAC;UACf,IAAI,CAAC/E,aAAa,CAACgF,CAAC,GAAGN,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,GAAG,CAAC,CAAC,CAAC,EAAEE,cAAc,CAAC,CAAC;UAChE;;MAER,MAAMG,eAAe,GAAG,IAAI,CAACnF,aAAa,GAAG,CAAC,GAAG,CAAC,CAAC;MACnD,MAAMoF,cAAc,GAAID,eAAe,GAAG,IAAI,CAACrC,oBAAoB,CAACR,CAAC,GAAI,IAAI,CAACjC,oBAAoB;MAClG,QAAQ,IAAI,CAACR,wBAAwB;QACjC,KAAKvB,YAAY,CAACsB,CAAC;UACf,IAAI,CAACM,aAAa,CAACmC,CAAC,GAAGuC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,GAAG,CAAC,CAAC,CAAC,EAAEM,cAAc,CAAC,CAAC;UAChE;QACJ,KAAK9G,YAAY,CAACwB,CAAC;UACf,IAAI,CAACI,aAAa,CAACoC,CAAC,GAAGsC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,GAAG,CAAC,CAAC,CAAC,EAAEM,cAAc,CAAC,CAAC;UAChE;QACJ,KAAK9G,YAAY,CAAC2G,CAAC;UACf,IAAI,CAAC/E,aAAa,CAACgF,CAAC,GAAGN,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,GAAG,CAAC,CAAC,CAAC,EAAEM,cAAc,CAAC,CAAC;UAChE;;KAEX,MAAM;MACH,MAAMC,IAAI,GAAG,IAAI,CAACpF,QAAQ,CAACqF,GAAG,CAAC3B,CAAC,CAACG,SAAS,CAACK,QAAQ,EAAE,CAAC;MACtD,IAAIkB,IAAI,EAAE;QACLA,IAAY,CAAChD,CAAC,GAAGsB,CAAC,CAACE,OAAO;QAC1BwB,IAAY,CAAC/C,CAAC,GAAGqB,CAAC,CAACM,OAAO;;;EAGvC;EAEQZ,YAAYA,CAACM,CAAe;IAChC,IAAI,IAAI,CAACjB,kBAAkB,IAAIiB,CAAC,CAACG,SAAS,EAAE;MACxC,IAAI,CAACyB,kBAAkB,EAAE;MAEzB,IAAI,CAAC7C,kBAAkB,GAAG,CAAC,CAAC;MAC5B,IAAI,CAACR,OAAO,GAAG,KAAK;KACvB,MAAM;MACH,MAAMsD,KAAK,GAA2D,IAAI,CAACvF,QAAQ,CAACqF,GAAG,CAAC3B,CAAC,CAACG,SAAS,CAACK,QAAQ,EAAE,CAAC;MAC/G,IAAIqB,KAAK,EAAE;QACPjH,eAAe,CAACsD,gBAAgB,CAAC4D,SAAS,CAACD,KAAK,CAACnB,KAAK,GAAG,EAAE,EAAEmB,KAAK,CAAClB,KAAK,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;;;IAG9F,IAAI,CAACxB,oBAAoB,CAACT,CAAC,GAAG,CAAC;IAC/B,IAAI,CAACS,oBAAoB,CAACR,CAAC,GAAG,CAAC;IAE/B,IAAI,CAACrC,QAAQ,CAACyF,MAAM,CAAC/B,CAAC,CAACG,SAAS,CAACK,QAAQ,EAAE,CAAC;EAChD;EAEA;;;;EAIOwB,gBAAgBA,CAACC,QAAgB;IACpC,IAAI,CAACzD,cAAc,GAAGyD,QAAQ;EAClC;EAEA;;;EAGA,IAAWlH,aAAaA,CAACmH,OAAe;IACpC,IAAI,CAACC,sBAAsB,GAAGD,OAAO;IACrC,IAAI,CAACE,mBAAmB,GAAG,CAAC,EAAE,IAAI,CAACD,sBAAsB,GAAG,GAAG,CAAC;IAChE,IAAI,CAACE,yBAAyB,GAAG,CAAC,EAAE,IAAI,CAACD,mBAAmB,GAAG,CAAC,CAAC;EACrE;EACA,IAAWrH,aAAaA,CAAA;IACpB,OAAO,IAAI,CAACoH,sBAAsB;EACtC;EAEA;;;EAGA,IAAWrH,QAAQA,CAACoH,OAAe;IAC/B,IAAI,CAACI,iBAAiB,GAAGJ,OAAO;IAChC,IAAI,CAACK,cAAc,GAAG,CAAC,EAAE,IAAI,CAACD,iBAAiB,GAAG,GAAG,CAAC;IACtD,IAAI,CAACE,oBAAoB,GAAG,CAAC,EAAE,IAAI,CAACD,cAAc,GAAG,CAAC,CAAC;EAC3D;EACA,IAAWzH,QAAQA,CAAA;IACf,OAAO,IAAI,CAACwH,iBAAiB;EACjC;EAEA;;;EAGOG,aAAaA,CAAA;IAChB,IAAI,CAACpH,aAAa,GAAG,KAAK;IAE1B,IAAI,CAAC+E,iBAAiB,GAAG,IAAI;EACjC;EAEA;;;EAGA,IAAW/E,aAAaA,CAACqH,KAAc;IACnC,IAAI,IAAI,CAACC,cAAc,KAAKD,KAAK,EAAE;MAC/B;;IAGJ,IAAIA,KAAK,IAAI,IAAI,CAACtC,iBAAiB,EAAE;MACjCxF,eAAe,CAACkE,oBAAoB,EAAE;MAEtC,IAAI,CAAC6D,cAAc,GAAG,IAAI;KAC7B,MAAM;MACH/H,eAAe,CAACkE,oBAAoB,EAAE;MAEtC,IAAI,CAAC6D,cAAc,GAAG,KAAK;;EAEnC;EACA,IAAWtH,aAAaA,CAAA;IACpB,OAAO,IAAI,CAACsH,cAAc;EAC9B;EAEA;;;;;EAKOlE,WAAWA,CAACC,CAAS,EAAEC,CAAS;IACnC;IACA,IAAI,IAAI,CAACO,wBAAwB,EAAE;MAC/B,IAAI,CAAC0C,kBAAkB,EAAE;;IAG7B,IAAI,CAACxB,iBAAiB,GAAG,IAAI3F,OAAO,CAACiE,CAAC,EAAEC,CAAC,CAAC;EAC9C;EAEA;;;;EAIOiE,gBAAgBA,CAACC,MAAiB;IACrC,IAAI,CAACpC,OAAO,GAAGoC,MAAM;EACzB;EAEA;;;;EAIOC,mBAAmBA,CAACC,IAAkB;IACzC,QAAQA,IAAI;MACR,KAAKpI,YAAY,CAACsB,CAAC;MACnB,KAAKtB,YAAY,CAACwB,CAAC;MACnB,KAAKxB,YAAY,CAAC2G,CAAC;QACf,IAAI,CAACtF,2BAA2B,GAAG+G,IAAI;QACvC;MACJ;QACI,IAAI,CAAC/G,2BAA2B,GAAGrB,YAAY,CAACsB,CAAC;QACjD;;EAEZ;EAEA;;;;EAIO+G,gBAAgBA,CAACD,IAAkB;IACtC,QAAQA,IAAI;MACR,KAAKpI,YAAY,CAACsB,CAAC;MACnB,KAAKtB,YAAY,CAACwB,CAAC;MACnB,KAAKxB,YAAY,CAAC2G,CAAC;QACf,IAAI,CAACpF,wBAAwB,GAAG6G,IAAI;QACpC;MACJ;QACI,IAAI,CAAC7G,wBAAwB,GAAGvB,YAAY,CAACwB,CAAC;QAC9C;;EAEZ;EAEA;;;EAGQyF,kBAAkBA,CAAA;IACtB,MAAMqB,EAAE,GAAG,IAAI,CAAC7C,iBAAiB,IAAI,IAAI,CAAClB,wBAAwB;IAElE;IACAtE,eAAe,CAACsD,gBAAgB,CAAC4D,SAAS,CACtCmB,EAAE,CAACvE,CAAC,GAAG,IAAI,CAAC2D,yBAAyB,EACrCY,EAAE,CAACtE,CAAC,GAAG,IAAI,CAAC0D,yBAAyB,EACrC,IAAI,CAACD,mBAAmB,EACxB,IAAI,CAACA,mBAAmB,CAC3B;IAED;IACAxH,eAAe,CAACsD,gBAAgB,CAAC4D,SAAS,CACtC,IAAI,CAAC7C,2BAA2B,CAACP,CAAC,GAAG,IAAI,CAAC8D,oBAAoB,GAAG,CAAC,EAClE,IAAI,CAACvD,2BAA2B,CAACN,CAAC,GAAG,IAAI,CAAC6D,oBAAoB,GAAG,CAAC,EAClE,IAAI,CAACD,cAAc,GAAG,CAAC,EACvB,IAAI,CAACA,cAAc,GAAG,CAAC,CAC1B;EACL;EAEA;;;;EAIO1D,iBAAiBA,CAACqE,OAAe;IACpC,MAAMC,KAAK,GAAG,IAAIC,KAAK,EAAE;IACzBD,KAAK,CAACE,GAAG,GAAGH,OAAO;IAEnBC,KAAK,CAACG,MAAM,GAAG,MAAO,IAAI,CAACC,eAAe,GAAGJ,KAAM;EACvD;EAEA;;;;EAIOvE,YAAYA,CAACsE,OAAe;IAC/B,MAAMC,KAAK,GAAG,IAAIC,KAAK,EAAE;IACzBD,KAAK,CAACE,GAAG,GAAGH,OAAO;IAEnBC,KAAK,CAACG,MAAM,GAAG,MAAO,IAAI,CAACE,UAAU,GAAGL,KAAM;EAClD;EAEA;;;EAGQM,cAAcA,CAAA;IAClB,MAAMR,EAAE,GAAG,IAAI,CAAC7C,iBAAiB,IAAI,IAAI,CAAClB,wBAAwB;IAElE,IAAI,CAAC0C,kBAAkB,EAAE;IAEzB,IAAI,IAAI,CAAC2B,eAAe,EAAE;MACtB3I,eAAe,CAACsD,gBAAgB,CAACwF,SAAS,CAAC,IAAI,CAACH,eAAe,EAAEN,EAAE,CAACvE,CAAC,GAAG,IAAI,CAAC3D,aAAa,EAAEkI,EAAE,CAACtE,CAAC,GAAG,IAAI,CAAC5D,aAAa,EAAE,IAAI,CAACA,aAAa,GAAG,CAAC,EAAE,IAAI,CAACA,aAAa,GAAG,CAAC,CAAC;KACzK,MAAM;MACH;MACAH,eAAe,CAACsD,gBAAgB,CAACyF,SAAS,EAAE;MAC5C/I,eAAe,CAACsD,gBAAgB,CAACC,WAAW,GAAG,IAAI,CAACK,cAAc;MAClE5D,eAAe,CAACsD,gBAAgB,CAACE,SAAS,GAAG,CAAC;MAC9CxD,eAAe,CAACsD,gBAAgB,CAAC0F,GAAG,CAACX,EAAE,CAACvE,CAAC,EAAEuE,EAAE,CAACtE,CAAC,EAAE,IAAI,CAAC5D,aAAa,EAAE,CAAC,EAAEkG,IAAI,CAAC4C,EAAE,GAAG,CAAC,EAAE,IAAI,CAAC;MAC1FjJ,eAAe,CAACsD,gBAAgB,CAAC4F,MAAM,EAAE;MACzClJ,eAAe,CAACsD,gBAAgB,CAAC6F,SAAS,EAAE;MAE5C;MACAnJ,eAAe,CAACsD,gBAAgB,CAACyF,SAAS,EAAE;MAC5C/I,eAAe,CAACsD,gBAAgB,CAACE,SAAS,GAAG,CAAC;MAC9CxD,eAAe,CAACsD,gBAAgB,CAACC,WAAW,GAAG,IAAI,CAACK,cAAc;MAClE5D,eAAe,CAACsD,gBAAgB,CAAC0F,GAAG,CAACX,EAAE,CAACvE,CAAC,EAAEuE,EAAE,CAACtE,CAAC,EAAE,IAAI,CAAC7D,QAAQ,EAAE,CAAC,EAAEmG,IAAI,CAAC4C,EAAE,GAAG,CAAC,EAAE,IAAI,CAAC;MACrFjJ,eAAe,CAACsD,gBAAgB,CAAC4F,MAAM,EAAE;MACzClJ,eAAe,CAACsD,gBAAgB,CAAC6F,SAAS,EAAE;;EAEpD;EAEA;;;EAGQC,SAASA,CAAA;IACb,IAAI,IAAI,CAACR,UAAU,EAAE;MACjB5I,eAAe,CAACsD,gBAAgB,CAACwF,SAAS,CACtC,IAAI,CAACF,UAAU,EACf,IAAI,CAACxE,mBAAmB,CAACN,CAAC,GAAG,IAAI,CAAC5D,QAAQ,EAC1C,IAAI,CAACkE,mBAAmB,CAACL,CAAC,GAAG,IAAI,CAAC7D,QAAQ,EAC1C,IAAI,CAACA,QAAQ,GAAG,CAAC,EACjB,IAAI,CAACA,QAAQ,GAAG,CAAC,CACpB;KACJ,MAAM;MACHF,eAAe,CAACsD,gBAAgB,CAACyF,SAAS,EAAE;MAC5C/I,eAAe,CAACsD,gBAAgB,CAACC,WAAW,GAAG,IAAI,CAACK,cAAc;MAClE5D,eAAe,CAACsD,gBAAgB,CAACE,SAAS,GAAG,CAAC;MAC9CxD,eAAe,CAACsD,gBAAgB,CAAC0F,GAAG,CAAC,IAAI,CAAC5E,mBAAmB,CAACN,CAAC,EAAE,IAAI,CAACM,mBAAmB,CAACL,CAAC,EAAE,IAAI,CAAC7D,QAAQ,EAAE,CAAC,EAAEmG,IAAI,CAAC4C,EAAE,GAAG,CAAC,EAAE,IAAI,CAAC;MACjIjJ,eAAe,CAACsD,gBAAgB,CAAC4F,MAAM,EAAE;MACzClJ,eAAe,CAACsD,gBAAgB,CAAC6F,SAAS,EAAE;;EAEpD;EAEQlE,oBAAoBA,CAAA;IACxB;IACA,IAAI,IAAI,CAACnE,SAAS,EAAE;MAChB;;IAEJ,IAAI,IAAI,CAACL,aAAa,EAAE;MACpB,IAAI,CAACoI,cAAc,EAAE;;IAGzB,IAAI,IAAI,CAAClF,OAAO,EAAE;MACd,IAAI,CAACjC,QAAQ,CAAC2H,OAAO,CAAC,CAACC,GAAG,EAAErC,KAAK,KAAI;QACjC,IAAmBA,KAAM,CAAC1B,SAAS,KAAK,IAAI,CAACpB,kBAAkB,EAAE;UAC7D,IAAI,CAAC,IAAI,CAAC1D,aAAa,EAAE;YACrB,IAAI,CAACoI,cAAc,EAAE;;UAGzB,IAAI,CAACO,SAAS,EAAE;UAEhB;UACA,IAAI,CAAC/E,2BAA2B,GAAG,IAAI,CAACD,mBAAmB,CAACqB,KAAK,EAAE;SACtE,MAAM;UACHzF,eAAe,CAACsD,gBAAgB,CAAC4D,SAAS,CAAOD,KAAM,CAACnB,KAAK,GAAG,EAAE,EAAQmB,KAAM,CAAClB,KAAK,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;UACpG/F,eAAe,CAACsD,gBAAgB,CAACyF,SAAS,EAAE;UAC5C/I,eAAe,CAACsD,gBAAgB,CAACiG,SAAS,GAAG,OAAO;UACpDvJ,eAAe,CAACsD,gBAAgB,CAACyF,SAAS,EAAE;UAC5C/I,eAAe,CAACsD,gBAAgB,CAACC,WAAW,GAAG,KAAK;UACpDvD,eAAe,CAACsD,gBAAgB,CAACE,SAAS,GAAG,CAAC;UAC9CxD,eAAe,CAACsD,gBAAgB,CAAC0F,GAAG,CAAC/B,KAAK,CAACnD,CAAC,EAAEmD,KAAK,CAAClD,CAAC,EAAE,EAAE,EAAE,CAAC,EAAEsC,IAAI,CAAC4C,EAAE,GAAG,CAAC,EAAE,IAAI,CAAC;UAChFjJ,eAAe,CAACsD,gBAAgB,CAAC4F,MAAM,EAAE;UACzClJ,eAAe,CAACsD,gBAAgB,CAAC6F,SAAS,EAAE;UACtClC,KAAM,CAACnB,KAAK,GAAGmB,KAAK,CAACnD,CAAC;UACtBmD,KAAM,CAAClB,KAAK,GAAGkB,KAAK,CAAClD,CAAC;;MAEpC,CAAC,CAAC;;IAENiB,qBAAqB,CAAC,MAAK;MACvB,IAAI,CAACC,oBAAoB,EAAE;IAC/B,CAAC,CAAC;EACN;EAEA;;;EAGOuE,aAAaA,CAAA;IAChB,IAAIxJ,eAAe,CAACqC,MAAM,EAAE;MACxBrC,eAAe,CAACqC,MAAM,CAACoH,mBAAmB,CAAC,aAAa,EAAE,IAAI,CAACjF,wBAAwB,CAAC;MACxFxE,eAAe,CAACqC,MAAM,CAACoH,mBAAmB,CAAC,aAAa,EAAE,IAAI,CAAC9E,wBAAwB,CAAC;MACxF3E,eAAe,CAACqC,MAAM,CAACoH,mBAAmB,CAAC,WAAW,EAAE,IAAI,CAAC5E,sBAAsB,CAAC;MACpF7E,eAAe,CAACqC,MAAM,CAACoH,mBAAmB,CAAC,YAAY,EAAE,IAAI,CAAC5E,sBAAsB,CAAC;MACrF5C,MAAM,CAACwH,mBAAmB,CAAC,QAAQ,EAAE,IAAI,CAAC1H,SAAS,CAAC;MACpDW,QAAQ,CAACe,IAAI,CAACiG,WAAW,CAAC1J,eAAe,CAACqC,MAAM,CAAC;MACjDrC,eAAe,CAACqC,MAAM,GAAG,IAAI;;IAEjC,IAAI,CAACvB,SAAS,GAAG,IAAI;EACzB;;AAjlBA;AACed,eAAA,CAAAmB,oBAAoB,GAAW,CAAC;AAChCnB,eAAA,CAAAkE,oBAAoB,GAAW,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}