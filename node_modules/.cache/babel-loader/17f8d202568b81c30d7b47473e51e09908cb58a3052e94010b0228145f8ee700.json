{"ast":null,"code":"import { Logger } from \"../Misc/logger.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { WebXRManagedOutputCanvas, WebXRManagedOutputCanvasOptions } from \"./webXRManagedOutputCanvas.js\";\nimport { NativeXRLayerWrapper, NativeXRRenderTarget } from \"./native/nativeXRRenderTarget.js\";\nimport { WebXRWebGLLayerWrapper } from \"./webXRWebGLLayer.js\";\n/**\n * Manages an XRSession to work with Babylon's engine\n * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRSessionManagers\n */\nexport class WebXRSessionManager {\n  /**\n   * Constructs a WebXRSessionManager, this must be initialized within a user action before usage\n   * @param scene The scene which the session should be created for\n   */\n  constructor( /** The scene which the session should be created for */\n  scene) {\n    this.scene = scene;\n    /** WebXR timestamp updated every frame */\n    this.currentTimestamp = -1;\n    /**\n     * Used just in case of a failure to initialize an immersive session.\n     * The viewer reference space is compensated using this height, creating a kind of \"viewer-floor\" reference space\n     */\n    this.defaultHeightCompensation = 1.7;\n    /**\n     * Fires every time a new xrFrame arrives which can be used to update the camera\n     */\n    this.onXRFrameObservable = new Observable();\n    /**\n     * Fires when the reference space changed\n     */\n    this.onXRReferenceSpaceChanged = new Observable();\n    /**\n     * Fires when the xr session is ended either by the device or manually done\n     */\n    this.onXRSessionEnded = new Observable();\n    /**\n     * Fires when the xr session is initialized: right after requestSession was called and returned with a successful result\n     */\n    this.onXRSessionInit = new Observable();\n    /**\n     * Are we currently in the XR loop?\n     */\n    this.inXRFrameLoop = false;\n    /**\n     * Are we in an XR session?\n     */\n    this.inXRSession = false;\n    this._engine = scene.getEngine();\n    this._onEngineDisposedObserver = this._engine.onDisposeObservable.addOnce(() => {\n      this._engine = null;\n    });\n    scene.onDisposeObservable.addOnce(() => {\n      this.dispose();\n    });\n  }\n  /**\n   * The current reference space used in this session. This reference space can constantly change!\n   * It is mainly used to offset the camera's position.\n   */\n  get referenceSpace() {\n    return this._referenceSpace;\n  }\n  /**\n   * Set a new reference space and triggers the observable\n   */\n  set referenceSpace(newReferenceSpace) {\n    this._referenceSpace = newReferenceSpace;\n    this.onXRReferenceSpaceChanged.notifyObservers(this._referenceSpace);\n  }\n  /**\n   * The mode for the managed XR session\n   */\n  get sessionMode() {\n    return this._sessionMode;\n  }\n  /**\n   * Disposes of the session manager\n   * This should be called explicitly by the dev, if required.\n   */\n  dispose() {\n    var _a;\n    // disposing without leaving XR? Exit XR first\n    if (this.inXRSession) {\n      this.exitXRAsync();\n    }\n    this.onXRFrameObservable.clear();\n    this.onXRSessionEnded.clear();\n    this.onXRReferenceSpaceChanged.clear();\n    this.onXRSessionInit.clear();\n    (_a = this._engine) === null || _a === void 0 ? void 0 : _a.onDisposeObservable.remove(this._onEngineDisposedObserver);\n    this._engine = null;\n  }\n  /**\n   * Stops the xrSession and restores the render loop\n   * @returns Promise which resolves after it exits XR\n   */\n  exitXRAsync() {\n    if (this.session && this.inXRSession) {\n      this.inXRSession = false;\n      return this.session.end().catch(() => {\n        Logger.Warn(\"Could not end XR session.\");\n      });\n    }\n    return Promise.resolve();\n  }\n  /**\n   * Attempts to set the framebuffer-size-normalized viewport to be rendered this frame for this view.\n   * In the event of a failure, the supplied viewport is not updated.\n   * @param viewport the viewport to which the view will be rendered\n   * @param view the view for which to set the viewport\n   * @returns whether the operation was successful\n   */\n  trySetViewportForView(viewport, view) {\n    var _a;\n    return ((_a = this._baseLayerRTTProvider) === null || _a === void 0 ? void 0 : _a.trySetViewportForView(viewport, view)) || false;\n  }\n  /**\n   * Gets the correct render target texture to be rendered this frame for this eye\n   * @param eye the eye for which to get the render target\n   * @returns the render target for the specified eye or null if not available\n   */\n  getRenderTargetTextureForEye(eye) {\n    var _a;\n    return ((_a = this._baseLayerRTTProvider) === null || _a === void 0 ? void 0 : _a.getRenderTargetTextureForEye(eye)) || null;\n  }\n  /**\n   * Gets the correct render target texture to be rendered this frame for this view\n   * @param view the view for which to get the render target\n   * @returns the render target for the specified view or null if not available\n   */\n  getRenderTargetTextureForView(view) {\n    var _a;\n    return ((_a = this._baseLayerRTTProvider) === null || _a === void 0 ? void 0 : _a.getRenderTargetTextureForView(view)) || null;\n  }\n  /**\n   * Creates a WebXRRenderTarget object for the XR session\n   * @param options optional options to provide when creating a new render target\n   * @returns a WebXR render target to which the session can render\n   */\n  getWebXRRenderTarget(options) {\n    const engine = this.scene.getEngine();\n    if (this._xrNavigator.xr.native) {\n      return new NativeXRRenderTarget(this);\n    } else {\n      options = options || WebXRManagedOutputCanvasOptions.GetDefaults(engine);\n      options.canvasElement = options.canvasElement || engine.getRenderingCanvas() || undefined;\n      return new WebXRManagedOutputCanvas(this, options);\n    }\n  }\n  /**\n   * Initializes the manager\n   * After initialization enterXR can be called to start an XR session\n   * @returns Promise which resolves after it is initialized\n   */\n  initializeAsync() {\n    // Check if the browser supports webXR\n    this._xrNavigator = navigator;\n    if (!this._xrNavigator.xr) {\n      return Promise.reject(\"WebXR not available\");\n    }\n    return Promise.resolve();\n  }\n  /**\n   * Initializes an xr session\n   * @param xrSessionMode mode to initialize\n   * @param xrSessionInit defines optional and required values to pass to the session builder\n   * @returns a promise which will resolve once the session has been initialized\n   */\n  initializeSessionAsync(xrSessionMode = \"immersive-vr\", xrSessionInit = {}) {\n    return this._xrNavigator.xr.requestSession(xrSessionMode, xrSessionInit).then(session => {\n      this.session = session;\n      this._sessionMode = xrSessionMode;\n      this.onXRSessionInit.notifyObservers(session);\n      this.inXRSession = true;\n      // handle when the session is ended (By calling session.end or device ends its own session eg. pressing home button on phone)\n      this.session.addEventListener(\"end\", () => {\n        var _a;\n        this.inXRSession = false;\n        // Notify frame observers\n        this.onXRSessionEnded.notifyObservers(null);\n        if (this._engine) {\n          // make sure dimensions object is restored\n          this._engine.framebufferDimensionsObject = null;\n          // Restore frame buffer to avoid clear on xr framebuffer after session end\n          this._engine.restoreDefaultFramebuffer();\n          // Need to restart render loop as after the session is ended the last request for new frame will never call callback\n          this._engine.customAnimationFrameRequester = null;\n          this._engine._renderLoop();\n        }\n        // Dispose render target textures.\n        // Only dispose on native because we can't destroy opaque textures on browser.\n        if (this.isNative) {\n          (_a = this._baseLayerRTTProvider) === null || _a === void 0 ? void 0 : _a.dispose();\n        }\n        this._baseLayerRTTProvider = null;\n        this._baseLayerWrapper = null;\n      }, {\n        once: true\n      });\n      return this.session;\n    });\n  }\n  /**\n   * Checks if a session would be supported for the creation options specified\n   * @param sessionMode session mode to check if supported eg. immersive-vr\n   * @returns A Promise that resolves to true if supported and false if not\n   */\n  isSessionSupportedAsync(sessionMode) {\n    return WebXRSessionManager.IsSessionSupportedAsync(sessionMode);\n  }\n  /**\n   * Resets the reference space to the one started the session\n   */\n  resetReferenceSpace() {\n    this.referenceSpace = this.baseReferenceSpace;\n  }\n  /**\n   * Starts rendering to the xr layer\n   */\n  runXRRenderLoop() {\n    var _a;\n    if (!this.inXRSession || !this._engine) {\n      return;\n    }\n    // Tell the engine's render loop to be driven by the xr session's refresh rate and provide xr pose information\n    this._engine.customAnimationFrameRequester = {\n      requestAnimationFrame: callback => this.session.requestAnimationFrame(callback),\n      renderFunction: (timestamp, xrFrame) => {\n        var _a;\n        if (!this.inXRSession || !this._engine) {\n          return;\n        }\n        // Store the XR frame and timestamp in the session manager\n        this.currentFrame = xrFrame;\n        this.currentTimestamp = timestamp;\n        if (xrFrame) {\n          this.inXRFrameLoop = true;\n          this._engine.framebufferDimensionsObject = ((_a = this._baseLayerRTTProvider) === null || _a === void 0 ? void 0 : _a.getFramebufferDimensions()) || null;\n          this.onXRFrameObservable.notifyObservers(xrFrame);\n          this._engine._renderLoop();\n          this._engine.framebufferDimensionsObject = null;\n          this.inXRFrameLoop = false;\n        }\n      }\n    };\n    this._engine.framebufferDimensionsObject = ((_a = this._baseLayerRTTProvider) === null || _a === void 0 ? void 0 : _a.getFramebufferDimensions()) || null;\n    // Stop window's animation frame and trigger sessions animation frame\n    if (typeof window !== \"undefined\" && window.cancelAnimationFrame) {\n      window.cancelAnimationFrame(this._engine._frameHandler);\n    }\n    this._engine._renderLoop();\n  }\n  /**\n   * Sets the reference space on the xr session\n   * @param referenceSpaceType space to set\n   * @returns a promise that will resolve once the reference space has been set\n   */\n  setReferenceSpaceTypeAsync(referenceSpaceType = \"local-floor\") {\n    return this.session.requestReferenceSpace(referenceSpaceType).then(referenceSpace => {\n      return referenceSpace;\n    }, rejectionReason => {\n      Logger.Error(\"XR.requestReferenceSpace failed for the following reason: \");\n      Logger.Error(rejectionReason);\n      Logger.Log('Defaulting to universally-supported \"viewer\" reference space type.');\n      return this.session.requestReferenceSpace(\"viewer\").then(referenceSpace => {\n        const heightCompensation = new XRRigidTransform({\n          x: 0,\n          y: -this.defaultHeightCompensation,\n          z: 0\n        });\n        return referenceSpace.getOffsetReferenceSpace(heightCompensation);\n      }, rejectionReason => {\n        Logger.Error(rejectionReason);\n        throw 'XR initialization failed: required \"viewer\" reference space type not supported.';\n      });\n    }).then(referenceSpace => {\n      // create viewer reference space before setting the first reference space\n      return this.session.requestReferenceSpace(\"viewer\").then(viewerReferenceSpace => {\n        this.viewerReferenceSpace = viewerReferenceSpace;\n        return referenceSpace;\n      });\n    }).then(referenceSpace => {\n      // initialize the base and offset (currently the same)\n      this.referenceSpace = this.baseReferenceSpace = referenceSpace;\n      return this.referenceSpace;\n    });\n  }\n  /**\n   * Updates the render state of the session.\n   * Note that this is deprecated in favor of WebXRSessionManager.updateRenderState().\n   * @param state state to set\n   * @returns a promise that resolves once the render state has been updated\n   * @deprecated\n   */\n  updateRenderStateAsync(state) {\n    return Promise.resolve(this.session.updateRenderState(state));\n  }\n  /**\n   * @internal\n   */\n  _setBaseLayerWrapper(baseLayerWrapper) {\n    var _a, _b;\n    if (this.isNative) {\n      (_a = this._baseLayerRTTProvider) === null || _a === void 0 ? void 0 : _a.dispose();\n    }\n    this._baseLayerWrapper = baseLayerWrapper;\n    this._baseLayerRTTProvider = ((_b = this._baseLayerWrapper) === null || _b === void 0 ? void 0 : _b.createRenderTargetTextureProvider(this)) || null;\n  }\n  /**\n   * @internal\n   */\n  _getBaseLayerWrapper() {\n    return this._baseLayerWrapper;\n  }\n  /**\n   * Updates the render state of the session\n   * @param state state to set\n   */\n  updateRenderState(state) {\n    if (state.baseLayer) {\n      this._setBaseLayerWrapper(this.isNative ? new NativeXRLayerWrapper(state.baseLayer) : new WebXRWebGLLayerWrapper(state.baseLayer));\n    }\n    this.session.updateRenderState(state);\n  }\n  /**\n   * Returns a promise that resolves with a boolean indicating if the provided session mode is supported by this browser\n   * @param sessionMode defines the session to test\n   * @returns a promise with boolean as final value\n   */\n  static IsSessionSupportedAsync(sessionMode) {\n    if (!navigator.xr) {\n      return Promise.resolve(false);\n    }\n    // When the specs are final, remove supportsSession!\n    const functionToUse = navigator.xr.isSessionSupported || navigator.xr.supportsSession;\n    if (!functionToUse) {\n      return Promise.resolve(false);\n    } else {\n      return functionToUse.call(navigator.xr, sessionMode).then(result => {\n        const returnValue = typeof result === \"undefined\" ? true : result;\n        return Promise.resolve(returnValue);\n      }).catch(e => {\n        Logger.Warn(e);\n        return Promise.resolve(false);\n      });\n    }\n  }\n  /**\n   * Returns true if Babylon.js is using the BabylonNative backend, otherwise false\n   */\n  get isNative() {\n    var _a;\n    return (_a = this._xrNavigator.xr.native) !== null && _a !== void 0 ? _a : false;\n  }\n  /**\n   * The current frame rate as reported by the device\n   */\n  get currentFrameRate() {\n    var _a;\n    return (_a = this.session) === null || _a === void 0 ? void 0 : _a.frameRate;\n  }\n  /**\n   * A list of supported frame rates (only available in-session!\n   */\n  get supportedFrameRates() {\n    var _a;\n    return (_a = this.session) === null || _a === void 0 ? void 0 : _a.supportedFrameRates;\n  }\n  /**\n   * Set the framerate of the session.\n   * @param rate the new framerate. This value needs to be in the supportedFrameRates array\n   * @returns a promise that resolves once the framerate has been set\n   */\n  updateTargetFrameRate(rate) {\n    return this.session.updateTargetFrameRate(rate);\n  }\n  /**\n   * Run a callback in the xr render loop\n   * @param callback the callback to call when in XR Frame\n   * @param ignoreIfNotInSession if no session is currently running, run it first thing on the next session\n   */\n  runInXRFrame(callback, ignoreIfNotInSession = true) {\n    if (this.inXRFrameLoop) {\n      callback();\n    } else if (this.inXRSession || !ignoreIfNotInSession) {\n      this.onXRFrameObservable.addOnce(callback);\n    }\n  }\n  /**\n   * Check if fixed foveation is supported on this device\n   */\n  get isFixedFoveationSupported() {\n    var _a;\n    return ((_a = this._baseLayerWrapper) === null || _a === void 0 ? void 0 : _a.isFixedFoveationSupported) || false;\n  }\n  /**\n   * Get the fixed foveation currently set, as specified by the webxr specs\n   * If this returns null, then fixed foveation is not supported\n   */\n  get fixedFoveation() {\n    var _a;\n    return ((_a = this._baseLayerWrapper) === null || _a === void 0 ? void 0 : _a.fixedFoveation) || null;\n  }\n  /**\n   * Set the fixed foveation to the specified value, as specified by the webxr specs\n   * This value will be normalized to be between 0 and 1, 1 being max foveation, 0 being no foveation\n   */\n  set fixedFoveation(value) {\n    const val = Math.max(0, Math.min(1, value || 0));\n    if (this._baseLayerWrapper) {\n      this._baseLayerWrapper.fixedFoveation = val;\n    }\n  }\n  /**\n   * Get the features enabled on the current session\n   * This is only available in-session!\n   * @see https://www.w3.org/TR/webxr/#dom-xrsession-enabledfeatures\n   */\n  get enabledFeatures() {\n    var _a, _b;\n    return (_b = (_a = this.session) === null || _a === void 0 ? void 0 : _a.enabledFeatures) !== null && _b !== void 0 ? _b : null;\n  }\n}","map":{"version":3,"names":["Logger","Observable","WebXRManagedOutputCanvas","WebXRManagedOutputCanvasOptions","NativeXRLayerWrapper","NativeXRRenderTarget","WebXRWebGLLayerWrapper","WebXRSessionManager","constructor","scene","currentTimestamp","defaultHeightCompensation","onXRFrameObservable","onXRReferenceSpaceChanged","onXRSessionEnded","onXRSessionInit","inXRFrameLoop","inXRSession","_engine","getEngine","_onEngineDisposedObserver","onDisposeObservable","addOnce","dispose","referenceSpace","_referenceSpace","newReferenceSpace","notifyObservers","sessionMode","_sessionMode","exitXRAsync","clear","_a","remove","session","end","catch","Warn","Promise","resolve","trySetViewportForView","viewport","view","_baseLayerRTTProvider","getRenderTargetTextureForEye","eye","getRenderTargetTextureForView","getWebXRRenderTarget","options","engine","_xrNavigator","xr","native","GetDefaults","canvasElement","getRenderingCanvas","undefined","initializeAsync","navigator","reject","initializeSessionAsync","xrSessionMode","xrSessionInit","requestSession","then","addEventListener","framebufferDimensionsObject","restoreDefaultFramebuffer","customAnimationFrameRequester","_renderLoop","isNative","_baseLayerWrapper","once","isSessionSupportedAsync","IsSessionSupportedAsync","resetReferenceSpace","baseReferenceSpace","runXRRenderLoop","requestAnimationFrame","callback","renderFunction","timestamp","xrFrame","currentFrame","getFramebufferDimensions","window","cancelAnimationFrame","_frameHandler","setReferenceSpaceTypeAsync","referenceSpaceType","requestReferenceSpace","rejectionReason","Error","Log","heightCompensation","XRRigidTransform","x","y","z","getOffsetReferenceSpace","viewerReferenceSpace","updateRenderStateAsync","state","updateRenderState","_setBaseLayerWrapper","baseLayerWrapper","_b","createRenderTargetTextureProvider","_getBaseLayerWrapper","baseLayer","functionToUse","isSessionSupported","supportsSession","call","result","returnValue","e","currentFrameRate","frameRate","supportedFrameRates","updateTargetFrameRate","rate","runInXRFrame","ignoreIfNotInSession","isFixedFoveationSupported","fixedFoveation","value","val","Math","max","min","enabledFeatures"],"sources":["../../../../dev/core/src/XR/webXRSessionManager.ts"],"sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport { WebXRManagedOutputCanvas, WebXRManagedOutputCanvasOptions } from \"./webXRManagedOutputCanvas\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { IWebXRRenderTargetTextureProvider, WebXRLayerRenderTargetTextureProvider } from \"./webXRRenderTargetTextureProvider\";\r\nimport type { Viewport } from \"../Maths/math.viewport\";\r\nimport type { WebXRLayerWrapper } from \"./webXRLayerWrapper\";\r\nimport { NativeXRLayerWrapper, NativeXRRenderTarget } from \"./native/nativeXRRenderTarget\";\r\nimport { WebXRWebGLLayerWrapper } from \"./webXRWebGLLayer\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\n\r\n/**\r\n * Manages an XRSession to work with Babylon's engine\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRSessionManagers\r\n */\r\nexport class WebXRSessionManager implements IDisposable, IWebXRRenderTargetTextureProvider {\r\n    private _engine: Nullable<Engine>;\r\n    private _referenceSpace: XRReferenceSpace;\r\n    private _baseLayerWrapper: Nullable<WebXRLayerWrapper>;\r\n    private _baseLayerRTTProvider: Nullable<WebXRLayerRenderTargetTextureProvider>;\r\n    private _xrNavigator: any;\r\n    private _sessionMode: XRSessionMode;\r\n    private _onEngineDisposedObserver: Nullable<Observer<ThinEngine>>;\r\n\r\n    /**\r\n     * The base reference space from which the session started. good if you want to reset your\r\n     * reference space\r\n     */\r\n    public baseReferenceSpace: XRReferenceSpace;\r\n    /**\r\n     * Current XR frame\r\n     */\r\n    public currentFrame: Nullable<XRFrame>;\r\n    /** WebXR timestamp updated every frame */\r\n    public currentTimestamp: number = -1;\r\n    /**\r\n     * Used just in case of a failure to initialize an immersive session.\r\n     * The viewer reference space is compensated using this height, creating a kind of \"viewer-floor\" reference space\r\n     */\r\n    public defaultHeightCompensation = 1.7;\r\n    /**\r\n     * Fires every time a new xrFrame arrives which can be used to update the camera\r\n     */\r\n    public onXRFrameObservable: Observable<XRFrame> = new Observable<XRFrame>();\r\n    /**\r\n     * Fires when the reference space changed\r\n     */\r\n    public onXRReferenceSpaceChanged: Observable<XRReferenceSpace> = new Observable();\r\n    /**\r\n     * Fires when the xr session is ended either by the device or manually done\r\n     */\r\n    public onXRSessionEnded: Observable<any> = new Observable<any>();\r\n    /**\r\n     * Fires when the xr session is initialized: right after requestSession was called and returned with a successful result\r\n     */\r\n    public onXRSessionInit: Observable<XRSession> = new Observable<XRSession>();\r\n    /**\r\n     * Underlying xr session\r\n     */\r\n    public session: XRSession;\r\n    /**\r\n     * The viewer (head position) reference space. This can be used to get the XR world coordinates\r\n     * or get the offset the player is currently at.\r\n     */\r\n    public viewerReferenceSpace: XRReferenceSpace;\r\n    /**\r\n     * Are we currently in the XR loop?\r\n     */\r\n    public inXRFrameLoop: boolean = false;\r\n    /**\r\n     * Are we in an XR session?\r\n     */\r\n    public inXRSession: boolean = false;\r\n\r\n    /**\r\n     * Constructs a WebXRSessionManager, this must be initialized within a user action before usage\r\n     * @param scene The scene which the session should be created for\r\n     */\r\n    constructor(\r\n        /** The scene which the session should be created for */\r\n        public scene: Scene\r\n    ) {\r\n        this._engine = scene.getEngine();\r\n        this._onEngineDisposedObserver = this._engine.onDisposeObservable.addOnce(() => {\r\n            this._engine = null;\r\n        });\r\n        scene.onDisposeObservable.addOnce(() => {\r\n            this.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The current reference space used in this session. This reference space can constantly change!\r\n     * It is mainly used to offset the camera's position.\r\n     */\r\n    public get referenceSpace(): XRReferenceSpace {\r\n        return this._referenceSpace;\r\n    }\r\n\r\n    /**\r\n     * Set a new reference space and triggers the observable\r\n     */\r\n    public set referenceSpace(newReferenceSpace: XRReferenceSpace) {\r\n        this._referenceSpace = newReferenceSpace;\r\n        this.onXRReferenceSpaceChanged.notifyObservers(this._referenceSpace);\r\n    }\r\n\r\n    /**\r\n     * The mode for the managed XR session\r\n     */\r\n    public get sessionMode(): XRSessionMode {\r\n        return this._sessionMode;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the session manager\r\n     * This should be called explicitly by the dev, if required.\r\n     */\r\n    public dispose() {\r\n        // disposing without leaving XR? Exit XR first\r\n        if (this.inXRSession) {\r\n            this.exitXRAsync();\r\n        }\r\n        this.onXRFrameObservable.clear();\r\n        this.onXRSessionEnded.clear();\r\n        this.onXRReferenceSpaceChanged.clear();\r\n        this.onXRSessionInit.clear();\r\n        this._engine?.onDisposeObservable.remove(this._onEngineDisposedObserver);\r\n        this._engine = null;\r\n    }\r\n\r\n    /**\r\n     * Stops the xrSession and restores the render loop\r\n     * @returns Promise which resolves after it exits XR\r\n     */\r\n    public exitXRAsync() {\r\n        if (this.session && this.inXRSession) {\r\n            this.inXRSession = false;\r\n            return this.session.end().catch(() => {\r\n                Logger.Warn(\"Could not end XR session.\");\r\n            });\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Attempts to set the framebuffer-size-normalized viewport to be rendered this frame for this view.\r\n     * In the event of a failure, the supplied viewport is not updated.\r\n     * @param viewport the viewport to which the view will be rendered\r\n     * @param view the view for which to set the viewport\r\n     * @returns whether the operation was successful\r\n     */\r\n    public trySetViewportForView(viewport: Viewport, view: XRView): boolean {\r\n        return this._baseLayerRTTProvider?.trySetViewportForView(viewport, view) || false;\r\n    }\r\n\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this eye\r\n     * @param eye the eye for which to get the render target\r\n     * @returns the render target for the specified eye or null if not available\r\n     */\r\n    public getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture> {\r\n        return this._baseLayerRTTProvider?.getRenderTargetTextureForEye(eye) || null;\r\n    }\r\n\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this view\r\n     * @param view the view for which to get the render target\r\n     * @returns the render target for the specified view or null if not available\r\n     */\r\n    public getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture> {\r\n        return this._baseLayerRTTProvider?.getRenderTargetTextureForView(view) || null;\r\n    }\r\n\r\n    /**\r\n     * Creates a WebXRRenderTarget object for the XR session\r\n     * @param options optional options to provide when creating a new render target\r\n     * @returns a WebXR render target to which the session can render\r\n     */\r\n    public getWebXRRenderTarget(options?: WebXRManagedOutputCanvasOptions): WebXRRenderTarget {\r\n        const engine = this.scene.getEngine();\r\n        if (this._xrNavigator.xr.native) {\r\n            return new NativeXRRenderTarget(this);\r\n        } else {\r\n            options = options || WebXRManagedOutputCanvasOptions.GetDefaults(engine);\r\n            options.canvasElement = options.canvasElement || engine.getRenderingCanvas() || undefined;\r\n            return new WebXRManagedOutputCanvas(this, options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes the manager\r\n     * After initialization enterXR can be called to start an XR session\r\n     * @returns Promise which resolves after it is initialized\r\n     */\r\n    public initializeAsync(): Promise<void> {\r\n        // Check if the browser supports webXR\r\n        this._xrNavigator = navigator;\r\n        if (!this._xrNavigator.xr) {\r\n            return Promise.reject(\"WebXR not available\");\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Initializes an xr session\r\n     * @param xrSessionMode mode to initialize\r\n     * @param xrSessionInit defines optional and required values to pass to the session builder\r\n     * @returns a promise which will resolve once the session has been initialized\r\n     */\r\n    public initializeSessionAsync(xrSessionMode: XRSessionMode = \"immersive-vr\", xrSessionInit: XRSessionInit = {}): Promise<XRSession> {\r\n        return this._xrNavigator.xr.requestSession(xrSessionMode, xrSessionInit).then((session: XRSession) => {\r\n            this.session = session;\r\n            this._sessionMode = xrSessionMode;\r\n            this.onXRSessionInit.notifyObservers(session);\r\n            this.inXRSession = true;\r\n\r\n            // handle when the session is ended (By calling session.end or device ends its own session eg. pressing home button on phone)\r\n            this.session.addEventListener(\r\n                \"end\",\r\n                () => {\r\n                    this.inXRSession = false;\r\n\r\n                    // Notify frame observers\r\n                    this.onXRSessionEnded.notifyObservers(null);\r\n\r\n                    if (this._engine) {\r\n                        // make sure dimensions object is restored\r\n                        this._engine.framebufferDimensionsObject = null;\r\n\r\n                        // Restore frame buffer to avoid clear on xr framebuffer after session end\r\n                        this._engine.restoreDefaultFramebuffer();\r\n\r\n                        // Need to restart render loop as after the session is ended the last request for new frame will never call callback\r\n                        this._engine.customAnimationFrameRequester = null;\r\n                        this._engine._renderLoop();\r\n                    }\r\n\r\n                    // Dispose render target textures.\r\n                    // Only dispose on native because we can't destroy opaque textures on browser.\r\n                    if (this.isNative) {\r\n                        this._baseLayerRTTProvider?.dispose();\r\n                    }\r\n                    this._baseLayerRTTProvider = null;\r\n                    this._baseLayerWrapper = null;\r\n                },\r\n                { once: true }\r\n            );\r\n\r\n            return this.session;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Checks if a session would be supported for the creation options specified\r\n     * @param sessionMode session mode to check if supported eg. immersive-vr\r\n     * @returns A Promise that resolves to true if supported and false if not\r\n     */\r\n    public isSessionSupportedAsync(sessionMode: XRSessionMode): Promise<boolean> {\r\n        return WebXRSessionManager.IsSessionSupportedAsync(sessionMode);\r\n    }\r\n\r\n    /**\r\n     * Resets the reference space to the one started the session\r\n     */\r\n    public resetReferenceSpace() {\r\n        this.referenceSpace = this.baseReferenceSpace;\r\n    }\r\n\r\n    /**\r\n     * Starts rendering to the xr layer\r\n     */\r\n    public runXRRenderLoop() {\r\n        if (!this.inXRSession || !this._engine) {\r\n            return;\r\n        }\r\n\r\n        // Tell the engine's render loop to be driven by the xr session's refresh rate and provide xr pose information\r\n        this._engine.customAnimationFrameRequester = {\r\n            requestAnimationFrame: (callback: FrameRequestCallback) => this.session.requestAnimationFrame(callback),\r\n            renderFunction: (timestamp: number, xrFrame: Nullable<XRFrame>) => {\r\n                if (!this.inXRSession || !this._engine) {\r\n                    return;\r\n                }\r\n                // Store the XR frame and timestamp in the session manager\r\n                this.currentFrame = xrFrame;\r\n                this.currentTimestamp = timestamp;\r\n                if (xrFrame) {\r\n                    this.inXRFrameLoop = true;\r\n                    this._engine.framebufferDimensionsObject = this._baseLayerRTTProvider?.getFramebufferDimensions() || null;\r\n                    this.onXRFrameObservable.notifyObservers(xrFrame);\r\n                    this._engine._renderLoop();\r\n                    this._engine.framebufferDimensionsObject = null;\r\n                    this.inXRFrameLoop = false;\r\n                }\r\n            },\r\n        };\r\n\r\n        this._engine.framebufferDimensionsObject = this._baseLayerRTTProvider?.getFramebufferDimensions() || null;\r\n\r\n        // Stop window's animation frame and trigger sessions animation frame\r\n        if (typeof window !== \"undefined\" && window.cancelAnimationFrame) {\r\n            window.cancelAnimationFrame(this._engine._frameHandler);\r\n        }\r\n        this._engine._renderLoop();\r\n    }\r\n\r\n    /**\r\n     * Sets the reference space on the xr session\r\n     * @param referenceSpaceType space to set\r\n     * @returns a promise that will resolve once the reference space has been set\r\n     */\r\n    public setReferenceSpaceTypeAsync(referenceSpaceType: XRReferenceSpaceType = \"local-floor\"): Promise<XRReferenceSpace> {\r\n        return this.session\r\n            .requestReferenceSpace(referenceSpaceType)\r\n            .then(\r\n                (referenceSpace) => {\r\n                    return referenceSpace as XRReferenceSpace;\r\n                },\r\n                (rejectionReason) => {\r\n                    Logger.Error(\"XR.requestReferenceSpace failed for the following reason: \");\r\n                    Logger.Error(rejectionReason);\r\n                    Logger.Log('Defaulting to universally-supported \"viewer\" reference space type.');\r\n\r\n                    return this.session.requestReferenceSpace(\"viewer\").then(\r\n                        (referenceSpace) => {\r\n                            const heightCompensation = new XRRigidTransform({ x: 0, y: -this.defaultHeightCompensation, z: 0 });\r\n                            return (referenceSpace as XRReferenceSpace).getOffsetReferenceSpace(heightCompensation);\r\n                        },\r\n                        (rejectionReason) => {\r\n                            Logger.Error(rejectionReason);\r\n                            throw 'XR initialization failed: required \"viewer\" reference space type not supported.';\r\n                        }\r\n                    );\r\n                }\r\n            )\r\n            .then((referenceSpace) => {\r\n                // create viewer reference space before setting the first reference space\r\n                return this.session.requestReferenceSpace(\"viewer\").then((viewerReferenceSpace) => {\r\n                    this.viewerReferenceSpace = viewerReferenceSpace as XRReferenceSpace;\r\n                    return referenceSpace;\r\n                });\r\n            })\r\n            .then((referenceSpace) => {\r\n                // initialize the base and offset (currently the same)\r\n                this.referenceSpace = this.baseReferenceSpace = referenceSpace;\r\n                return this.referenceSpace;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Updates the render state of the session.\r\n     * Note that this is deprecated in favor of WebXRSessionManager.updateRenderState().\r\n     * @param state state to set\r\n     * @returns a promise that resolves once the render state has been updated\r\n     * @deprecated\r\n     */\r\n    public updateRenderStateAsync(state: XRRenderState): Promise<void> {\r\n        return Promise.resolve(this.session.updateRenderState(state));\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setBaseLayerWrapper(baseLayerWrapper: Nullable<WebXRLayerWrapper>): void {\r\n        if (this.isNative) {\r\n            this._baseLayerRTTProvider?.dispose();\r\n        }\r\n        this._baseLayerWrapper = baseLayerWrapper;\r\n        this._baseLayerRTTProvider = this._baseLayerWrapper?.createRenderTargetTextureProvider(this) || null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getBaseLayerWrapper(): Nullable<WebXRLayerWrapper> {\r\n        return this._baseLayerWrapper;\r\n    }\r\n\r\n    /**\r\n     * Updates the render state of the session\r\n     * @param state state to set\r\n     */\r\n    public updateRenderState(state: XRRenderStateInit): void {\r\n        if (state.baseLayer) {\r\n            this._setBaseLayerWrapper(this.isNative ? new NativeXRLayerWrapper(state.baseLayer) : new WebXRWebGLLayerWrapper(state.baseLayer));\r\n        }\r\n\r\n        this.session.updateRenderState(state);\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves with a boolean indicating if the provided session mode is supported by this browser\r\n     * @param sessionMode defines the session to test\r\n     * @returns a promise with boolean as final value\r\n     */\r\n    public static IsSessionSupportedAsync(sessionMode: XRSessionMode): Promise<boolean> {\r\n        if (!(navigator as any).xr) {\r\n            return Promise.resolve(false);\r\n        }\r\n        // When the specs are final, remove supportsSession!\r\n        const functionToUse = (navigator as any).xr.isSessionSupported || (navigator as any).xr.supportsSession;\r\n        if (!functionToUse) {\r\n            return Promise.resolve(false);\r\n        } else {\r\n            return functionToUse\r\n                .call((navigator as any).xr, sessionMode)\r\n                .then((result: boolean) => {\r\n                    const returnValue = typeof result === \"undefined\" ? true : result;\r\n                    return Promise.resolve(returnValue);\r\n                })\r\n                .catch((e: any) => {\r\n                    Logger.Warn(e);\r\n                    return Promise.resolve(false);\r\n                });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if Babylon.js is using the BabylonNative backend, otherwise false\r\n     */\r\n    public get isNative(): boolean {\r\n        return this._xrNavigator.xr.native ?? false;\r\n    }\r\n\r\n    /**\r\n     * The current frame rate as reported by the device\r\n     */\r\n    public get currentFrameRate(): number | undefined {\r\n        return this.session?.frameRate;\r\n    }\r\n\r\n    /**\r\n     * A list of supported frame rates (only available in-session!\r\n     */\r\n    public get supportedFrameRates(): Float32Array | undefined {\r\n        return this.session?.supportedFrameRates;\r\n    }\r\n\r\n    /**\r\n     * Set the framerate of the session.\r\n     * @param rate the new framerate. This value needs to be in the supportedFrameRates array\r\n     * @returns a promise that resolves once the framerate has been set\r\n     */\r\n    public updateTargetFrameRate(rate: number): Promise<void> {\r\n        return this.session.updateTargetFrameRate(rate);\r\n    }\r\n\r\n    /**\r\n     * Run a callback in the xr render loop\r\n     * @param callback the callback to call when in XR Frame\r\n     * @param ignoreIfNotInSession if no session is currently running, run it first thing on the next session\r\n     */\r\n    public runInXRFrame(callback: () => void, ignoreIfNotInSession = true): void {\r\n        if (this.inXRFrameLoop) {\r\n            callback();\r\n        } else if (this.inXRSession || !ignoreIfNotInSession) {\r\n            this.onXRFrameObservable.addOnce(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if fixed foveation is supported on this device\r\n     */\r\n    public get isFixedFoveationSupported(): boolean {\r\n        return this._baseLayerWrapper?.isFixedFoveationSupported || false;\r\n    }\r\n\r\n    /**\r\n     * Get the fixed foveation currently set, as specified by the webxr specs\r\n     * If this returns null, then fixed foveation is not supported\r\n     */\r\n    public get fixedFoveation(): Nullable<number> {\r\n        return this._baseLayerWrapper?.fixedFoveation || null;\r\n    }\r\n\r\n    /**\r\n     * Set the fixed foveation to the specified value, as specified by the webxr specs\r\n     * This value will be normalized to be between 0 and 1, 1 being max foveation, 0 being no foveation\r\n     */\r\n    public set fixedFoveation(value: Nullable<number>) {\r\n        const val = Math.max(0, Math.min(1, value || 0));\r\n        if (this._baseLayerWrapper) {\r\n            this._baseLayerWrapper.fixedFoveation = val;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the features enabled on the current session\r\n     * This is only available in-session!\r\n     * @see https://www.w3.org/TR/webxr/#dom-xrsession-enabledfeatures\r\n     */\r\n    public get enabledFeatures(): Nullable<string[]> {\r\n        return this.session?.enabledFeatures ?? null;\r\n    }\r\n}\r\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,mBAAiB;AAExC,SAASC,UAAU,QAAQ,uBAAqB;AAKhD,SAASC,wBAAwB,EAAEC,+BAA+B,QAAQ,+BAA6B;AAKvG,SAASC,oBAAoB,EAAEC,oBAAoB,QAAQ,kCAAgC;AAC3F,SAASC,sBAAsB,QAAQ,sBAAoB;AAG3D;;;;AAIA,OAAM,MAAOC,mBAAmB;EA2D5B;;;;EAIAC,YAAA,CACI;EACOC,KAAY;IAAZ,KAAAA,KAAK,GAALA,KAAK;IA/ChB;IACO,KAAAC,gBAAgB,GAAW,CAAC,CAAC;IACpC;;;;IAIO,KAAAC,yBAAyB,GAAG,GAAG;IACtC;;;IAGO,KAAAC,mBAAmB,GAAwB,IAAIX,UAAU,EAAW;IAC3E;;;IAGO,KAAAY,yBAAyB,GAAiC,IAAIZ,UAAU,EAAE;IACjF;;;IAGO,KAAAa,gBAAgB,GAAoB,IAAIb,UAAU,EAAO;IAChE;;;IAGO,KAAAc,eAAe,GAA0B,IAAId,UAAU,EAAa;IAU3E;;;IAGO,KAAAe,aAAa,GAAY,KAAK;IACrC;;;IAGO,KAAAC,WAAW,GAAY,KAAK;IAU/B,IAAI,CAACC,OAAO,GAAGT,KAAK,CAACU,SAAS,EAAE;IAChC,IAAI,CAACC,yBAAyB,GAAG,IAAI,CAACF,OAAO,CAACG,mBAAmB,CAACC,OAAO,CAAC,MAAK;MAC3E,IAAI,CAACJ,OAAO,GAAG,IAAI;IACvB,CAAC,CAAC;IACFT,KAAK,CAACY,mBAAmB,CAACC,OAAO,CAAC,MAAK;MACnC,IAAI,CAACC,OAAO,EAAE;IAClB,CAAC,CAAC;EACN;EAEA;;;;EAIA,IAAWC,cAAcA,CAAA;IACrB,OAAO,IAAI,CAACC,eAAe;EAC/B;EAEA;;;EAGA,IAAWD,cAAcA,CAACE,iBAAmC;IACzD,IAAI,CAACD,eAAe,GAAGC,iBAAiB;IACxC,IAAI,CAACb,yBAAyB,CAACc,eAAe,CAAC,IAAI,CAACF,eAAe,CAAC;EACxE;EAEA;;;EAGA,IAAWG,WAAWA,CAAA;IAClB,OAAO,IAAI,CAACC,YAAY;EAC5B;EAEA;;;;EAION,OAAOA,CAAA;;IACV;IACA,IAAI,IAAI,CAACN,WAAW,EAAE;MAClB,IAAI,CAACa,WAAW,EAAE;;IAEtB,IAAI,CAAClB,mBAAmB,CAACmB,KAAK,EAAE;IAChC,IAAI,CAACjB,gBAAgB,CAACiB,KAAK,EAAE;IAC7B,IAAI,CAAClB,yBAAyB,CAACkB,KAAK,EAAE;IACtC,IAAI,CAAChB,eAAe,CAACgB,KAAK,EAAE;IAC5B,CAAAC,EAAA,OAAI,CAACd,OAAO,cAAAc,EAAA,uBAAAA,EAAA,CAAEX,mBAAmB,CAACY,MAAM,CAAC,IAAI,CAACb,yBAAyB,CAAC;IACxE,IAAI,CAACF,OAAO,GAAG,IAAI;EACvB;EAEA;;;;EAIOY,WAAWA,CAAA;IACd,IAAI,IAAI,CAACI,OAAO,IAAI,IAAI,CAACjB,WAAW,EAAE;MAClC,IAAI,CAACA,WAAW,GAAG,KAAK;MACxB,OAAO,IAAI,CAACiB,OAAO,CAACC,GAAG,EAAE,CAACC,KAAK,CAAC,MAAK;QACjCpC,MAAM,CAACqC,IAAI,CAAC,2BAA2B,CAAC;MAC5C,CAAC,CAAC;;IAEN,OAAOC,OAAO,CAACC,OAAO,EAAE;EAC5B;EAEA;;;;;;;EAOOC,qBAAqBA,CAACC,QAAkB,EAAEC,IAAY;;IACzD,OAAO,EAAAV,EAAA,OAAI,CAACW,qBAAqB,cAAAX,EAAA,uBAAAA,EAAA,CAAEQ,qBAAqB,CAACC,QAAQ,EAAEC,IAAI,CAAC,KAAI,KAAK;EACrF;EAEA;;;;;EAKOE,4BAA4BA,CAACC,GAAU;;IAC1C,OAAO,EAAAb,EAAA,OAAI,CAACW,qBAAqB,cAAAX,EAAA,uBAAAA,EAAA,CAAEY,4BAA4B,CAACC,GAAG,CAAC,KAAI,IAAI;EAChF;EAEA;;;;;EAKOC,6BAA6BA,CAACJ,IAAY;;IAC7C,OAAO,EAAAV,EAAA,OAAI,CAACW,qBAAqB,cAAAX,EAAA,uBAAAA,EAAA,CAAEc,6BAA6B,CAACJ,IAAI,CAAC,KAAI,IAAI;EAClF;EAEA;;;;;EAKOK,oBAAoBA,CAACC,OAAyC;IACjE,MAAMC,MAAM,GAAG,IAAI,CAACxC,KAAK,CAACU,SAAS,EAAE;IACrC,IAAI,IAAI,CAAC+B,YAAY,CAACC,EAAE,CAACC,MAAM,EAAE;MAC7B,OAAO,IAAI/C,oBAAoB,CAAC,IAAI,CAAC;KACxC,MAAM;MACH2C,OAAO,GAAGA,OAAO,IAAI7C,+BAA+B,CAACkD,WAAW,CAACJ,MAAM,CAAC;MACxED,OAAO,CAACM,aAAa,GAAGN,OAAO,CAACM,aAAa,IAAIL,MAAM,CAACM,kBAAkB,EAAE,IAAIC,SAAS;MACzF,OAAO,IAAItD,wBAAwB,CAAC,IAAI,EAAE8C,OAAO,CAAC;;EAE1D;EAEA;;;;;EAKOS,eAAeA,CAAA;IAClB;IACA,IAAI,CAACP,YAAY,GAAGQ,SAAS;IAC7B,IAAI,CAAC,IAAI,CAACR,YAAY,CAACC,EAAE,EAAE;MACvB,OAAOb,OAAO,CAACqB,MAAM,CAAC,qBAAqB,CAAC;;IAEhD,OAAOrB,OAAO,CAACC,OAAO,EAAE;EAC5B;EAEA;;;;;;EAMOqB,sBAAsBA,CAACC,aAAA,GAA+B,cAAc,EAAEC,aAAA,GAA+B,EAAE;IAC1G,OAAO,IAAI,CAACZ,YAAY,CAACC,EAAE,CAACY,cAAc,CAACF,aAAa,EAAEC,aAAa,CAAC,CAACE,IAAI,CAAE9B,OAAkB,IAAI;MACjG,IAAI,CAACA,OAAO,GAAGA,OAAO;MACtB,IAAI,CAACL,YAAY,GAAGgC,aAAa;MACjC,IAAI,CAAC9C,eAAe,CAACY,eAAe,CAACO,OAAO,CAAC;MAC7C,IAAI,CAACjB,WAAW,GAAG,IAAI;MAEvB;MACA,IAAI,CAACiB,OAAO,CAAC+B,gBAAgB,CACzB,KAAK,EACL,MAAK;;QACD,IAAI,CAAChD,WAAW,GAAG,KAAK;QAExB;QACA,IAAI,CAACH,gBAAgB,CAACa,eAAe,CAAC,IAAI,CAAC;QAE3C,IAAI,IAAI,CAACT,OAAO,EAAE;UACd;UACA,IAAI,CAACA,OAAO,CAACgD,2BAA2B,GAAG,IAAI;UAE/C;UACA,IAAI,CAAChD,OAAO,CAACiD,yBAAyB,EAAE;UAExC;UACA,IAAI,CAACjD,OAAO,CAACkD,6BAA6B,GAAG,IAAI;UACjD,IAAI,CAAClD,OAAO,CAACmD,WAAW,EAAE;;QAG9B;QACA;QACA,IAAI,IAAI,CAACC,QAAQ,EAAE;UACf,CAAAtC,EAAA,OAAI,CAACW,qBAAqB,cAAAX,EAAA,uBAAAA,EAAA,CAAET,OAAO,EAAE;;QAEzC,IAAI,CAACoB,qBAAqB,GAAG,IAAI;QACjC,IAAI,CAAC4B,iBAAiB,GAAG,IAAI;MACjC,CAAC,EACD;QAAEC,IAAI,EAAE;MAAI,CAAE,CACjB;MAED,OAAO,IAAI,CAACtC,OAAO;IACvB,CAAC,CAAC;EACN;EAEA;;;;;EAKOuC,uBAAuBA,CAAC7C,WAA0B;IACrD,OAAOrB,mBAAmB,CAACmE,uBAAuB,CAAC9C,WAAW,CAAC;EACnE;EAEA;;;EAGO+C,mBAAmBA,CAAA;IACtB,IAAI,CAACnD,cAAc,GAAG,IAAI,CAACoD,kBAAkB;EACjD;EAEA;;;EAGOC,eAAeA,CAAA;;IAClB,IAAI,CAAC,IAAI,CAAC5D,WAAW,IAAI,CAAC,IAAI,CAACC,OAAO,EAAE;MACpC;;IAGJ;IACA,IAAI,CAACA,OAAO,CAACkD,6BAA6B,GAAG;MACzCU,qBAAqB,EAAGC,QAA8B,IAAK,IAAI,CAAC7C,OAAO,CAAC4C,qBAAqB,CAACC,QAAQ,CAAC;MACvGC,cAAc,EAAEA,CAACC,SAAiB,EAAEC,OAA0B,KAAI;;QAC9D,IAAI,CAAC,IAAI,CAACjE,WAAW,IAAI,CAAC,IAAI,CAACC,OAAO,EAAE;UACpC;;QAEJ;QACA,IAAI,CAACiE,YAAY,GAAGD,OAAO;QAC3B,IAAI,CAACxE,gBAAgB,GAAGuE,SAAS;QACjC,IAAIC,OAAO,EAAE;UACT,IAAI,CAAClE,aAAa,GAAG,IAAI;UACzB,IAAI,CAACE,OAAO,CAACgD,2BAA2B,GAAG,EAAAlC,EAAA,OAAI,CAACW,qBAAqB,cAAAX,EAAA,uBAAAA,EAAA,CAAEoD,wBAAwB,EAAE,KAAI,IAAI;UACzG,IAAI,CAACxE,mBAAmB,CAACe,eAAe,CAACuD,OAAO,CAAC;UACjD,IAAI,CAAChE,OAAO,CAACmD,WAAW,EAAE;UAC1B,IAAI,CAACnD,OAAO,CAACgD,2BAA2B,GAAG,IAAI;UAC/C,IAAI,CAAClD,aAAa,GAAG,KAAK;;MAElC;KACH;IAED,IAAI,CAACE,OAAO,CAACgD,2BAA2B,GAAG,EAAAlC,EAAA,OAAI,CAACW,qBAAqB,cAAAX,EAAA,uBAAAA,EAAA,CAAEoD,wBAAwB,EAAE,KAAI,IAAI;IAEzG;IACA,IAAI,OAAOC,MAAM,KAAK,WAAW,IAAIA,MAAM,CAACC,oBAAoB,EAAE;MAC9DD,MAAM,CAACC,oBAAoB,CAAC,IAAI,CAACpE,OAAO,CAACqE,aAAa,CAAC;;IAE3D,IAAI,CAACrE,OAAO,CAACmD,WAAW,EAAE;EAC9B;EAEA;;;;;EAKOmB,0BAA0BA,CAACC,kBAAA,GAA2C,aAAa;IACtF,OAAO,IAAI,CAACvD,OAAO,CACdwD,qBAAqB,CAACD,kBAAkB,CAAC,CACzCzB,IAAI,CACAxC,cAAc,IAAI;MACf,OAAOA,cAAkC;IAC7C,CAAC,EACAmE,eAAe,IAAI;MAChB3F,MAAM,CAAC4F,KAAK,CAAC,4DAA4D,CAAC;MAC1E5F,MAAM,CAAC4F,KAAK,CAACD,eAAe,CAAC;MAC7B3F,MAAM,CAAC6F,GAAG,CAAC,oEAAoE,CAAC;MAEhF,OAAO,IAAI,CAAC3D,OAAO,CAACwD,qBAAqB,CAAC,QAAQ,CAAC,CAAC1B,IAAI,CACnDxC,cAAc,IAAI;QACf,MAAMsE,kBAAkB,GAAG,IAAIC,gBAAgB,CAAC;UAAEC,CAAC,EAAE,CAAC;UAAEC,CAAC,EAAE,CAAC,IAAI,CAACtF,yBAAyB;UAAEuF,CAAC,EAAE;QAAC,CAAE,CAAC;QACnG,OAAQ1E,cAAmC,CAAC2E,uBAAuB,CAACL,kBAAkB,CAAC;MAC3F,CAAC,EACAH,eAAe,IAAI;QAChB3F,MAAM,CAAC4F,KAAK,CAACD,eAAe,CAAC;QAC7B,MAAM,iFAAiF;MAC3F,CAAC,CACJ;IACL,CAAC,CACJ,CACA3B,IAAI,CAAExC,cAAc,IAAI;MACrB;MACA,OAAO,IAAI,CAACU,OAAO,CAACwD,qBAAqB,CAAC,QAAQ,CAAC,CAAC1B,IAAI,CAAEoC,oBAAoB,IAAI;QAC9E,IAAI,CAACA,oBAAoB,GAAGA,oBAAwC;QACpE,OAAO5E,cAAc;MACzB,CAAC,CAAC;IACN,CAAC,CAAC,CACDwC,IAAI,CAAExC,cAAc,IAAI;MACrB;MACA,IAAI,CAACA,cAAc,GAAG,IAAI,CAACoD,kBAAkB,GAAGpD,cAAc;MAC9D,OAAO,IAAI,CAACA,cAAc;IAC9B,CAAC,CAAC;EACV;EAEA;;;;;;;EAOO6E,sBAAsBA,CAACC,KAAoB;IAC9C,OAAOhE,OAAO,CAACC,OAAO,CAAC,IAAI,CAACL,OAAO,CAACqE,iBAAiB,CAACD,KAAK,CAAC,CAAC;EACjE;EAEA;;;EAGOE,oBAAoBA,CAACC,gBAA6C;;IACrE,IAAI,IAAI,CAACnC,QAAQ,EAAE;MACf,CAAAtC,EAAA,OAAI,CAACW,qBAAqB,cAAAX,EAAA,uBAAAA,EAAA,CAAET,OAAO,EAAE;;IAEzC,IAAI,CAACgD,iBAAiB,GAAGkC,gBAAgB;IACzC,IAAI,CAAC9D,qBAAqB,GAAG,EAAA+D,EAAA,OAAI,CAACnC,iBAAiB,cAAAmC,EAAA,uBAAAA,EAAA,CAAEC,iCAAiC,CAAC,IAAI,CAAC,KAAI,IAAI;EACxG;EAEA;;;EAGOC,oBAAoBA,CAAA;IACvB,OAAO,IAAI,CAACrC,iBAAiB;EACjC;EAEA;;;;EAIOgC,iBAAiBA,CAACD,KAAwB;IAC7C,IAAIA,KAAK,CAACO,SAAS,EAAE;MACjB,IAAI,CAACL,oBAAoB,CAAC,IAAI,CAAClC,QAAQ,GAAG,IAAIlE,oBAAoB,CAACkG,KAAK,CAACO,SAAS,CAAC,GAAG,IAAIvG,sBAAsB,CAACgG,KAAK,CAACO,SAAS,CAAC,CAAC;;IAGtI,IAAI,CAAC3E,OAAO,CAACqE,iBAAiB,CAACD,KAAK,CAAC;EACzC;EAEA;;;;;EAKO,OAAO5B,uBAAuBA,CAAC9C,WAA0B;IAC5D,IAAI,CAAE8B,SAAiB,CAACP,EAAE,EAAE;MACxB,OAAOb,OAAO,CAACC,OAAO,CAAC,KAAK,CAAC;;IAEjC;IACA,MAAMuE,aAAa,GAAIpD,SAAiB,CAACP,EAAE,CAAC4D,kBAAkB,IAAKrD,SAAiB,CAACP,EAAE,CAAC6D,eAAe;IACvG,IAAI,CAACF,aAAa,EAAE;MAChB,OAAOxE,OAAO,CAACC,OAAO,CAAC,KAAK,CAAC;KAChC,MAAM;MACH,OAAOuE,aAAa,CACfG,IAAI,CAAEvD,SAAiB,CAACP,EAAE,EAAEvB,WAAW,CAAC,CACxCoC,IAAI,CAAEkD,MAAe,IAAI;QACtB,MAAMC,WAAW,GAAG,OAAOD,MAAM,KAAK,WAAW,GAAG,IAAI,GAAGA,MAAM;QACjE,OAAO5E,OAAO,CAACC,OAAO,CAAC4E,WAAW,CAAC;MACvC,CAAC,CAAC,CACD/E,KAAK,CAAEgF,CAAM,IAAI;QACdpH,MAAM,CAACqC,IAAI,CAAC+E,CAAC,CAAC;QACd,OAAO9E,OAAO,CAACC,OAAO,CAAC,KAAK,CAAC;MACjC,CAAC,CAAC;;EAEd;EAEA;;;EAGA,IAAW+B,QAAQA,CAAA;;IACf,OAAO,CAAAtC,EAAA,OAAI,CAACkB,YAAY,CAACC,EAAE,CAACC,MAAM,cAAApB,EAAA,cAAAA,EAAA,GAAI,KAAK;EAC/C;EAEA;;;EAGA,IAAWqF,gBAAgBA,CAAA;;IACvB,OAAO,CAAArF,EAAA,OAAI,CAACE,OAAO,cAAAF,EAAA,uBAAAA,EAAA,CAAEsF,SAAS;EAClC;EAEA;;;EAGA,IAAWC,mBAAmBA,CAAA;;IAC1B,OAAO,CAAAvF,EAAA,OAAI,CAACE,OAAO,cAAAF,EAAA,uBAAAA,EAAA,CAAEuF,mBAAmB;EAC5C;EAEA;;;;;EAKOC,qBAAqBA,CAACC,IAAY;IACrC,OAAO,IAAI,CAACvF,OAAO,CAACsF,qBAAqB,CAACC,IAAI,CAAC;EACnD;EAEA;;;;;EAKOC,YAAYA,CAAC3C,QAAoB,EAAE4C,oBAAoB,GAAG,IAAI;IACjE,IAAI,IAAI,CAAC3G,aAAa,EAAE;MACpB+D,QAAQ,EAAE;KACb,MAAM,IAAI,IAAI,CAAC9D,WAAW,IAAI,CAAC0G,oBAAoB,EAAE;MAClD,IAAI,CAAC/G,mBAAmB,CAACU,OAAO,CAACyD,QAAQ,CAAC;;EAElD;EAEA;;;EAGA,IAAW6C,yBAAyBA,CAAA;;IAChC,OAAO,EAAA5F,EAAA,OAAI,CAACuC,iBAAiB,cAAAvC,EAAA,uBAAAA,EAAA,CAAE4F,yBAAyB,KAAI,KAAK;EACrE;EAEA;;;;EAIA,IAAWC,cAAcA,CAAA;;IACrB,OAAO,EAAA7F,EAAA,OAAI,CAACuC,iBAAiB,cAAAvC,EAAA,uBAAAA,EAAA,CAAE6F,cAAc,KAAI,IAAI;EACzD;EAEA;;;;EAIA,IAAWA,cAAcA,CAACC,KAAuB;IAC7C,MAAMC,GAAG,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,GAAG,CAAC,CAAC,EAAEJ,KAAK,IAAI,CAAC,CAAC,CAAC;IAChD,IAAI,IAAI,CAACvD,iBAAiB,EAAE;MACxB,IAAI,CAACA,iBAAiB,CAACsD,cAAc,GAAGE,GAAG;;EAEnD;EAEA;;;;;EAKA,IAAWI,eAAeA,CAAA;;IACtB,OAAO,CAAAzB,EAAA,IAAA1E,EAAA,OAAI,CAACE,OAAO,cAAAF,EAAA,uBAAAA,EAAA,CAAEmG,eAAe,cAAAzB,EAAA,cAAAA,EAAA,GAAI,IAAI;EAChD"},"metadata":{},"sourceType":"module","externalDependencies":[]}