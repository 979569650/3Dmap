{"ast":null,"code":"import { GetClass } from \"@babylonjs/core/Misc/typeStore.js\";\nconst XmlLoaderError = \"XmlLoader Exception : XML file is malformed or corrupted.\";\n/**\n * Class used to load GUI via XML.\n */\nexport class XmlLoader {\n  /**\n   * Create a new xml loader\n   * @param parentClass Sets the class context. Used when the loader is instanced inside a class and not in a global context\n   */\n  constructor(parentClass = null) {\n    this._nodes = {};\n    this._nodeTypes = {\n      element: 1,\n      attribute: 2,\n      text: 3\n    };\n    this._isLoaded = false;\n    this._objectAttributes = {\n      textHorizontalAlignment: 1,\n      textVerticalAlignment: 2,\n      horizontalAlignment: 3,\n      verticalAlignment: 4,\n      stretch: 5\n    };\n    if (parentClass) {\n      this._parentClass = parentClass;\n    }\n  }\n  _getChainElement(attributeValue) {\n    let element = window;\n    if (this._parentClass) {\n      element = this._parentClass;\n    }\n    let value = attributeValue;\n    value = value.split(\".\");\n    for (let i = 0; i < value.length; i++) {\n      element = element[value[i]];\n    }\n    return element;\n  }\n  _getClassAttribute(attributeName) {\n    const attribute = attributeName.split(\".\");\n    const className = GetClass(\"BABYLON.GUI.\" + attribute[0]);\n    return className[attribute[1]];\n  }\n  _createGuiElement(node, parent, linkParent = true) {\n    try {\n      const className = GetClass(\"BABYLON.GUI.\" + node.nodeName);\n      const guiNode = new className();\n      if (parent && linkParent) {\n        parent.addControl(guiNode);\n      }\n      for (let i = 0; i < node.attributes.length; i++) {\n        if (node.attributes[i].name.toLowerCase().includes(\"datasource\")) {\n          continue;\n        }\n        if (node.attributes[i].name.toLowerCase().includes(\"observable\")) {\n          const element = this._getChainElement(node.attributes[i].value);\n          guiNode[node.attributes[i].name].add(element);\n          continue;\n        } else if (node.attributes[i].name == \"linkWithMesh\") {\n          if (this._parentClass) {\n            guiNode.linkWithMesh(this._parentClass[node.attributes[i].value]);\n          } else {\n            guiNode.linkWithMesh(window[node.attributes[i].value]);\n          }\n        } else if (node.attributes[i].value.startsWith(\"{{\") && node.attributes[i].value.endsWith(\"}}\")) {\n          const element = this._getChainElement(node.attributes[i].value.substring(2, node.attributes[i].value.length - 2));\n          guiNode[node.attributes[i].name] = element;\n        } else if (!this._objectAttributes[node.attributes[i].name]) {\n          if (node.attributes[i].value == \"true\" || node.attributes[i].value == \"false\") {\n            guiNode[node.attributes[i].name] = node.attributes[i].value == \"true\";\n          } else {\n            guiNode[node.attributes[i].name] = !isNaN(Number(node.attributes[i].value)) ? Number(node.attributes[i].value) : node.attributes[i].value;\n          }\n        } else {\n          guiNode[node.attributes[i].name] = this._getClassAttribute(node.attributes[i].value);\n        }\n      }\n      if (!node.attributes.getNamedItem(\"id\")) {\n        this._nodes[node.nodeName + Object.keys(this._nodes).length + \"_gen\"] = guiNode;\n        return guiNode;\n      }\n      let id = node.attributes.getNamedItem(\"id\").value;\n      if (id.startsWith(\"{{\") && id.endsWith(\"}}\")) {\n        id = this._getChainElement(id.substring(2, id.length - 2));\n      }\n      if (!this._nodes[id]) {\n        this._nodes[id] = guiNode;\n      } else {\n        throw \"XmlLoader Exception : Duplicate ID, every element should have an unique ID attribute\";\n      }\n      return guiNode;\n    } catch (exception) {\n      throw \"XmlLoader Exception : Error parsing Control \" + node.nodeName + \",\" + exception + \".\";\n    }\n  }\n  _parseGrid(node, guiNode, parent) {\n    let width;\n    let height;\n    let columns;\n    const rows = node.children;\n    let cells;\n    let isPixel = false;\n    let cellNode;\n    let rowNumber = -1;\n    let columnNumber = -1;\n    let totalColumnsNumber = 0;\n    for (let i = 0; i < rows.length; i++) {\n      if (rows[i].nodeType != this._nodeTypes.element) {\n        continue;\n      }\n      if (rows[i].nodeName != \"Row\") {\n        throw \"XmlLoader Exception : Expecting Row node, received \" + rows[i].nodeName;\n      }\n      rowNumber += 1;\n      columns = rows[i].children;\n      if (!rows[i].attributes.getNamedItem(\"height\")) {\n        throw \"XmlLoader Exception : Height must be defined for grid rows\";\n      }\n      height = Number(rows[i].attributes.getNamedItem(\"height\").nodeValue);\n      isPixel = rows[i].attributes.getNamedItem(\"isPixel\") ? JSON.parse(rows[i].attributes.getNamedItem(\"isPixel\").nodeValue) : false;\n      guiNode.addRowDefinition(height, isPixel);\n      for (let j = 0; j < columns.length; j++) {\n        if (columns[j].nodeType != this._nodeTypes.element) {\n          continue;\n        }\n        if (columns[j].nodeName != \"Column\") {\n          throw \"XmlLoader Exception : Expecting Column node, received \" + columns[j].nodeName;\n        }\n        columnNumber += 1;\n        if (rowNumber > 0 && columnNumber > totalColumnsNumber) {\n          throw \"XmlLoader Exception : In the Grid element, the number of columns is defined in the first row, do not add more columns in the subsequent rows.\";\n        }\n        if (rowNumber == 0) {\n          if (!columns[j].attributes.getNamedItem(\"width\")) {\n            throw \"XmlLoader Exception : Width must be defined for all the grid columns in the first row\";\n          }\n          width = Number(columns[j].attributes.getNamedItem(\"width\").nodeValue);\n          isPixel = columns[j].attributes.getNamedItem(\"isPixel\") ? JSON.parse(columns[j].attributes.getNamedItem(\"isPixel\").nodeValue) : false;\n          guiNode.addColumnDefinition(width, isPixel);\n        }\n        cells = columns[j].children;\n        for (let k = 0; k < cells.length; k++) {\n          if (cells[k].nodeType != this._nodeTypes.element) {\n            continue;\n          }\n          cellNode = this._createGuiElement(cells[k], guiNode, false);\n          guiNode.addControl(cellNode, rowNumber, columnNumber);\n          if (cells[k].firstChild) {\n            this._parseXml(cells[k].firstChild, cellNode);\n          }\n        }\n      }\n      if (rowNumber == 0) {\n        totalColumnsNumber = columnNumber;\n      }\n      columnNumber = -1;\n    }\n    if (node.nextSibling) {\n      this._parseXml(node.nextSibling, parent);\n    }\n  }\n  _parseElement(node, guiNode, parent) {\n    if (node.firstChild) {\n      this._parseXml(node.firstChild, guiNode);\n    }\n    if (node.nextSibling) {\n      this._parseXml(node.nextSibling, parent);\n    }\n  }\n  _prepareSourceElement(node, guiNode, variable, source, iterator) {\n    if (this._parentClass) {\n      this._parentClass[variable] = source[iterator];\n    } else {\n      window[variable] = source[iterator];\n    }\n    if (node.firstChild) {\n      this._parseXml(node.firstChild, guiNode, true);\n    }\n  }\n  _parseElementsFromSource(node, guiNode, parent) {\n    const dataSource = node.attributes.getNamedItem(\"dataSource\").value;\n    if (!dataSource.includes(\" in \")) {\n      throw \"XmlLoader Exception : Malformed XML, Data Source must include an in\";\n    } else {\n      let isArray = true;\n      const splittedSource = dataSource.split(\" in \");\n      if (splittedSource.length < 2) {\n        throw \"XmlLoader Exception : Malformed XML, Data Source must have an iterator and a source\";\n      }\n      let source = splittedSource[1];\n      if (source.startsWith(\"{\") && source.endsWith(\"}\")) {\n        isArray = false;\n      }\n      if (!isArray || source.startsWith(\"[\") && source.endsWith(\"]\")) {\n        source = source.substring(1, source.length - 1);\n      }\n      if (this._parentClass) {\n        source = this._parentClass[source];\n      } else {\n        source = window[source];\n      }\n      if (isArray) {\n        for (let i = 0; i < source.length; i++) {\n          this._prepareSourceElement(node, guiNode, splittedSource[0], source, i);\n        }\n      } else {\n        for (const i in source) {\n          this._prepareSourceElement(node, guiNode, splittedSource[0], source, i);\n        }\n      }\n      if (node.nextSibling) {\n        this._parseXml(node.nextSibling, parent);\n      }\n    }\n  }\n  _parseXml(node, parent, generated = false) {\n    if (node.nodeType != this._nodeTypes.element) {\n      if (node.nextSibling) {\n        this._parseXml(node.nextSibling, parent, generated);\n      }\n      return;\n    }\n    if (generated) {\n      node.setAttribute(\"id\", parent.id + (parent._children.length + 1));\n    }\n    const guiNode = this._createGuiElement(node, parent);\n    if (!this._rootNode) {\n      this._rootNode = guiNode;\n    }\n    if (node.nodeName == \"Grid\") {\n      this._parseGrid(node, guiNode, parent);\n    } else if (!node.attributes.getNamedItem(\"dataSource\")) {\n      this._parseElement(node, guiNode, parent);\n    } else {\n      this._parseElementsFromSource(node, guiNode, parent);\n    }\n  }\n  /**\n   * Gets if the loading has finished.\n   * @returns whether the loading has finished or not\n   */\n  isLoaded() {\n    return this._isLoaded;\n  }\n  /**\n   * Gets a loaded node / control by id.\n   * @param id the Controls id set in the xml\n   * @returns element of type Control\n   */\n  getNodeById(id) {\n    return this._nodes[id];\n  }\n  /**\n   * Gets all loaded nodes / controls\n   * @returns Array of controls\n   */\n  getNodes() {\n    return this._nodes;\n  }\n  /**\n   * Disposes the loaded layout\n   */\n  dispose() {\n    if (this._rootNode) {\n      this._rootNode.dispose();\n      this._rootNode = null;\n      this._nodes = {};\n    }\n  }\n  /**\n   * Initiates the xml layout loading\n   * @param xmlFile defines the xml layout to load\n   * @param rootNode defines the node / control to use as a parent for the loaded layout controls.\n   * @param onSuccess defines the callback called on layout load successfully.\n   * @param onError defines the callback called on layout load failure.\n   */\n  loadLayout(xmlFile, rootNode, onSuccess = null, onError = null) {\n    const xhttp = new XMLHttpRequest();\n    xhttp.onload = () => {\n      if (xhttp.readyState === 4 && xhttp.status === 200) {\n        if (!xhttp.responseXML) {\n          if (onError) {\n            onError(XmlLoaderError);\n            return;\n          } else {\n            throw XmlLoaderError;\n          }\n        }\n        const xmlDoc = xhttp.responseXML.documentElement;\n        this._parseXml(xmlDoc.firstChild, rootNode);\n        this._isLoaded = true;\n        if (onSuccess) {\n          onSuccess();\n        }\n      }\n    };\n    xhttp.onerror = function () {\n      if (onError) {\n        onError(\"an error occurred during loading the layout\");\n      }\n    };\n    xhttp.open(\"GET\", xmlFile, true);\n    xhttp.send();\n  }\n  /**\n   * Initiates the xml layout loading asynchronously\n   * @param xmlFile defines the xml layout to load\n   * @param rootNode defines the node / control to use as a parent for the loaded layout controls.\n   * @returns Promise\n   */\n  async loadLayoutAsync(xmlFile, rootNode) {\n    return new Promise((resolve, reject) => {\n      this.loadLayout(xmlFile, rootNode, resolve, reject);\n    });\n  }\n}","map":{"version":3,"names":["GetClass","XmlLoaderError","XmlLoader","constructor","parentClass","_nodes","_nodeTypes","element","attribute","text","_isLoaded","_objectAttributes","textHorizontalAlignment","textVerticalAlignment","horizontalAlignment","verticalAlignment","stretch","_parentClass","_getChainElement","attributeValue","window","value","split","i","length","_getClassAttribute","attributeName","className","_createGuiElement","node","parent","linkParent","nodeName","guiNode","addControl","attributes","name","toLowerCase","includes","add","linkWithMesh","startsWith","endsWith","substring","isNaN","Number","getNamedItem","Object","keys","id","exception","_parseGrid","width","height","columns","rows","children","cells","isPixel","cellNode","rowNumber","columnNumber","totalColumnsNumber","nodeType","nodeValue","JSON","parse","addRowDefinition","j","addColumnDefinition","k","firstChild","_parseXml","nextSibling","_parseElement","_prepareSourceElement","variable","source","iterator","_parseElementsFromSource","dataSource","isArray","splittedSource","generated","setAttribute","_children","_rootNode","isLoaded","getNodeById","getNodes","dispose","loadLayout","xmlFile","rootNode","onSuccess","onError","xhttp","XMLHttpRequest","onload","readyState","status","responseXML","xmlDoc","documentElement","onerror","open","send","loadLayoutAsync","Promise","resolve","reject"],"sources":["../../../../dev/gui/src/2D/xmlLoader.ts"],"sourcesContent":["import { GetClass } from \"core/Misc/typeStore\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\nconst XmlLoaderError = \"XmlLoader Exception : XML file is malformed or corrupted.\";\r\n\r\n/**\r\n * Class used to load GUI via XML.\r\n */\r\nexport class XmlLoader {\r\n    private _nodes: any = {};\r\n\r\n    private _nodeTypes: any = {\r\n        element: 1,\r\n        attribute: 2,\r\n        text: 3,\r\n    };\r\n\r\n    private _isLoaded: boolean = false;\r\n\r\n    private _objectAttributes: any = {\r\n        textHorizontalAlignment: 1,\r\n        textVerticalAlignment: 2,\r\n        horizontalAlignment: 3,\r\n        verticalAlignment: 4,\r\n        stretch: 5,\r\n    };\r\n\r\n    private _rootNode: any;\r\n\r\n    private _parentClass: any;\r\n\r\n    /**\r\n     * Create a new xml loader\r\n     * @param parentClass Sets the class context. Used when the loader is instanced inside a class and not in a global context\r\n     */\r\n    constructor(parentClass: any = null) {\r\n        if (parentClass) {\r\n            this._parentClass = parentClass;\r\n        }\r\n    }\r\n\r\n    private _getChainElement(attributeValue: any): any {\r\n        let element: any = window;\r\n\r\n        if (this._parentClass) {\r\n            element = this._parentClass;\r\n        }\r\n        let value = attributeValue;\r\n        value = value.split(\".\");\r\n\r\n        for (let i = 0; i < value.length; i++) {\r\n            element = element[value[i]];\r\n        }\r\n        return element;\r\n    }\r\n\r\n    private _getClassAttribute(attributeName: string): any {\r\n        const attribute = attributeName.split(\".\");\r\n        const className = GetClass(\"BABYLON.GUI.\" + attribute[0]);\r\n        return className[attribute[1]];\r\n    }\r\n\r\n    private _createGuiElement(node: any, parent: any, linkParent: boolean = true): void {\r\n        try {\r\n            const className = GetClass(\"BABYLON.GUI.\" + node.nodeName);\r\n            const guiNode = new className();\r\n\r\n            if (parent && linkParent) {\r\n                parent.addControl(guiNode);\r\n            }\r\n\r\n            for (let i = 0; i < node.attributes.length; i++) {\r\n                if (node.attributes[i].name.toLowerCase().includes(\"datasource\")) {\r\n                    continue;\r\n                }\r\n\r\n                if (node.attributes[i].name.toLowerCase().includes(\"observable\")) {\r\n                    const element = this._getChainElement(node.attributes[i].value);\r\n                    guiNode[node.attributes[i].name].add(element);\r\n\r\n                    continue;\r\n                } else if (node.attributes[i].name == \"linkWithMesh\") {\r\n                    if (this._parentClass) {\r\n                        guiNode.linkWithMesh(this._parentClass[node.attributes[i].value]);\r\n                    } else {\r\n                        guiNode.linkWithMesh(window[node.attributes[i].value]);\r\n                    }\r\n                } else if (node.attributes[i].value.startsWith(\"{{\") && node.attributes[i].value.endsWith(\"}}\")) {\r\n                    const element = this._getChainElement(node.attributes[i].value.substring(2, node.attributes[i].value.length - 2));\r\n                    guiNode[node.attributes[i].name] = element;\r\n                } else if (!this._objectAttributes[node.attributes[i].name]) {\r\n                    if (node.attributes[i].value == \"true\" || node.attributes[i].value == \"false\") {\r\n                        guiNode[node.attributes[i].name] = node.attributes[i].value == \"true\";\r\n                    } else {\r\n                        guiNode[node.attributes[i].name] = !isNaN(Number(node.attributes[i].value)) ? Number(node.attributes[i].value) : node.attributes[i].value;\r\n                    }\r\n                } else {\r\n                    guiNode[node.attributes[i].name] = this._getClassAttribute(node.attributes[i].value);\r\n                }\r\n            }\r\n\r\n            if (!node.attributes.getNamedItem(\"id\")) {\r\n                this._nodes[node.nodeName + Object.keys(this._nodes).length + \"_gen\"] = guiNode;\r\n                return guiNode;\r\n            }\r\n\r\n            let id = node.attributes.getNamedItem(\"id\").value;\r\n            if (id.startsWith(\"{{\") && id.endsWith(\"}}\")) {\r\n                id = this._getChainElement(id.substring(2, id.length - 2));\r\n            }\r\n\r\n            if (!this._nodes[id]) {\r\n                this._nodes[id] = guiNode;\r\n            } else {\r\n                throw \"XmlLoader Exception : Duplicate ID, every element should have an unique ID attribute\";\r\n            }\r\n            return guiNode;\r\n        } catch (exception) {\r\n            throw \"XmlLoader Exception : Error parsing Control \" + node.nodeName + \",\" + exception + \".\";\r\n        }\r\n    }\r\n\r\n    private _parseGrid(node: any, guiNode: any, parent: any): void {\r\n        let width;\r\n        let height;\r\n        let columns;\r\n        const rows = node.children;\r\n        let cells;\r\n        let isPixel = false;\r\n        let cellNode;\r\n        let rowNumber = -1;\r\n        let columnNumber = -1;\r\n        let totalColumnsNumber = 0;\r\n\r\n        for (let i = 0; i < rows.length; i++) {\r\n            if (rows[i].nodeType != this._nodeTypes.element) {\r\n                continue;\r\n            }\r\n            if (rows[i].nodeName != \"Row\") {\r\n                throw \"XmlLoader Exception : Expecting Row node, received \" + rows[i].nodeName;\r\n            }\r\n            rowNumber += 1;\r\n            columns = rows[i].children;\r\n\r\n            if (!rows[i].attributes.getNamedItem(\"height\")) {\r\n                throw \"XmlLoader Exception : Height must be defined for grid rows\";\r\n            }\r\n            height = Number(rows[i].attributes.getNamedItem(\"height\").nodeValue);\r\n            isPixel = rows[i].attributes.getNamedItem(\"isPixel\") ? JSON.parse(rows[i].attributes.getNamedItem(\"isPixel\").nodeValue) : false;\r\n            guiNode.addRowDefinition(height, isPixel);\r\n\r\n            for (let j = 0; j < columns.length; j++) {\r\n                if (columns[j].nodeType != this._nodeTypes.element) {\r\n                    continue;\r\n                }\r\n                if (columns[j].nodeName != \"Column\") {\r\n                    throw \"XmlLoader Exception : Expecting Column node, received \" + columns[j].nodeName;\r\n                }\r\n                columnNumber += 1;\r\n                if (rowNumber > 0 && columnNumber > totalColumnsNumber) {\r\n                    throw \"XmlLoader Exception : In the Grid element, the number of columns is defined in the first row, do not add more columns in the subsequent rows.\";\r\n                }\r\n\r\n                if (rowNumber == 0) {\r\n                    if (!columns[j].attributes.getNamedItem(\"width\")) {\r\n                        throw \"XmlLoader Exception : Width must be defined for all the grid columns in the first row\";\r\n                    }\r\n                    width = Number(columns[j].attributes.getNamedItem(\"width\").nodeValue);\r\n                    isPixel = columns[j].attributes.getNamedItem(\"isPixel\") ? JSON.parse(columns[j].attributes.getNamedItem(\"isPixel\").nodeValue) : false;\r\n                    guiNode.addColumnDefinition(width, isPixel);\r\n                }\r\n\r\n                cells = columns[j].children;\r\n\r\n                for (let k = 0; k < cells.length; k++) {\r\n                    if (cells[k].nodeType != this._nodeTypes.element) {\r\n                        continue;\r\n                    }\r\n                    cellNode = this._createGuiElement(cells[k], guiNode, false);\r\n                    guiNode.addControl(cellNode, rowNumber, columnNumber);\r\n                    if (cells[k].firstChild) {\r\n                        this._parseXml(cells[k].firstChild, cellNode);\r\n                    }\r\n                }\r\n            }\r\n            if (rowNumber == 0) {\r\n                totalColumnsNumber = columnNumber;\r\n            }\r\n            columnNumber = -1;\r\n        }\r\n\r\n        if (node.nextSibling) {\r\n            this._parseXml(node.nextSibling, parent);\r\n        }\r\n    }\r\n\r\n    private _parseElement(node: any, guiNode: any, parent: any): void {\r\n        if (node.firstChild) {\r\n            this._parseXml(node.firstChild, guiNode);\r\n        }\r\n\r\n        if (node.nextSibling) {\r\n            this._parseXml(node.nextSibling, parent);\r\n        }\r\n    }\r\n\r\n    private _prepareSourceElement(node: any, guiNode: any, variable: any, source: any, iterator: any): void {\r\n        if (this._parentClass) {\r\n            this._parentClass[variable] = source[iterator];\r\n        } else {\r\n            window[variable] = source[iterator];\r\n        }\r\n\r\n        if (node.firstChild) {\r\n            this._parseXml(node.firstChild, guiNode, true);\r\n        }\r\n    }\r\n\r\n    private _parseElementsFromSource(node: any, guiNode: any, parent: any): void {\r\n        const dataSource = node.attributes.getNamedItem(\"dataSource\").value;\r\n\r\n        if (!dataSource.includes(\" in \")) {\r\n            throw \"XmlLoader Exception : Malformed XML, Data Source must include an in\";\r\n        } else {\r\n            let isArray = true;\r\n            const splittedSource = dataSource.split(\" in \");\r\n            if (splittedSource.length < 2) {\r\n                throw \"XmlLoader Exception : Malformed XML, Data Source must have an iterator and a source\";\r\n            }\r\n            let source = splittedSource[1];\r\n            if (source.startsWith(\"{\") && source.endsWith(\"}\")) {\r\n                isArray = false;\r\n            }\r\n\r\n            if (!isArray || (source.startsWith(\"[\") && source.endsWith(\"]\"))) {\r\n                source = source.substring(1, source.length - 1);\r\n            }\r\n\r\n            if (this._parentClass) {\r\n                source = this._parentClass[source];\r\n            } else {\r\n                source = window[source];\r\n            }\r\n\r\n            if (isArray) {\r\n                for (let i = 0; i < source.length; i++) {\r\n                    this._prepareSourceElement(node, guiNode, splittedSource[0], source, i);\r\n                }\r\n            } else {\r\n                for (const i in source) {\r\n                    this._prepareSourceElement(node, guiNode, splittedSource[0], source, i);\r\n                }\r\n            }\r\n\r\n            if (node.nextSibling) {\r\n                this._parseXml(node.nextSibling, parent);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _parseXml(node: any, parent: any, generated: boolean = false): void {\r\n        if (node.nodeType != this._nodeTypes.element) {\r\n            if (node.nextSibling) {\r\n                this._parseXml(node.nextSibling, parent, generated);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (generated) {\r\n            node.setAttribute(\"id\", parent.id + (parent._children.length + 1));\r\n        }\r\n\r\n        const guiNode = this._createGuiElement(node, parent);\r\n\r\n        if (!this._rootNode) {\r\n            this._rootNode = guiNode;\r\n        }\r\n\r\n        if (node.nodeName == \"Grid\") {\r\n            this._parseGrid(node, guiNode, parent);\r\n        } else if (!node.attributes.getNamedItem(\"dataSource\")) {\r\n            this._parseElement(node, guiNode, parent);\r\n        } else {\r\n            this._parseElementsFromSource(node, guiNode, parent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets if the loading has finished.\r\n     * @returns whether the loading has finished or not\r\n     */\r\n    public isLoaded(): boolean {\r\n        return this._isLoaded;\r\n    }\r\n\r\n    /**\r\n     * Gets a loaded node / control by id.\r\n     * @param id the Controls id set in the xml\r\n     * @returns element of type Control\r\n     */\r\n    public getNodeById(id: string): any {\r\n        return this._nodes[id];\r\n    }\r\n\r\n    /**\r\n     * Gets all loaded nodes / controls\r\n     * @returns Array of controls\r\n     */\r\n    public getNodes(): any {\r\n        return this._nodes;\r\n    }\r\n    /**\r\n     * Disposes the loaded layout\r\n     */\r\n    public dispose(): void {\r\n        if (this._rootNode) {\r\n            this._rootNode.dispose();\r\n            this._rootNode = null;\r\n            this._nodes = {};\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initiates the xml layout loading\r\n     * @param xmlFile defines the xml layout to load\r\n     * @param rootNode defines the node / control to use as a parent for the loaded layout controls.\r\n     * @param onSuccess defines the callback called on layout load successfully.\r\n     * @param onError defines the callback called on layout load failure.\r\n     */\r\n    public loadLayout(xmlFile: any, rootNode: any, onSuccess: Nullable<() => void> = null, onError: Nullable<(error: string) => void> = null): void {\r\n        const xhttp = new XMLHttpRequest();\r\n        xhttp.onload = () => {\r\n            if (xhttp.readyState === 4 && xhttp.status === 200) {\r\n                if (!xhttp.responseXML) {\r\n                    if (onError) {\r\n                        onError(XmlLoaderError);\r\n                        return;\r\n                    } else {\r\n                        throw XmlLoaderError;\r\n                    }\r\n                }\r\n\r\n                const xmlDoc = xhttp.responseXML.documentElement;\r\n                this._parseXml(xmlDoc.firstChild, rootNode);\r\n                this._isLoaded = true;\r\n\r\n                if (onSuccess) {\r\n                    onSuccess();\r\n                }\r\n            }\r\n        };\r\n\r\n        xhttp.onerror = function () {\r\n            if (onError) {\r\n                onError(\"an error occurred during loading the layout\");\r\n            }\r\n        };\r\n\r\n        xhttp.open(\"GET\", xmlFile, true);\r\n        xhttp.send();\r\n    }\r\n    /**\r\n     * Initiates the xml layout loading asynchronously\r\n     * @param xmlFile defines the xml layout to load\r\n     * @param rootNode defines the node / control to use as a parent for the loaded layout controls.\r\n     * @returns Promise\r\n     */\r\n    public async loadLayoutAsync(xmlFile: any, rootNode: any): Promise<any> {\r\n        return new Promise((resolve: any, reject: any) => {\r\n            this.loadLayout(xmlFile, rootNode, resolve, reject);\r\n        });\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}