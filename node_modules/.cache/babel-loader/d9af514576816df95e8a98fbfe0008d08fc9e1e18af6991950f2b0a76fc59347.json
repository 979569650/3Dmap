{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { Buffer, VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { PickingInfo } from \"../../Collisions/pickingInfo.js\";\nimport { DeepCopier } from \"../../Misc/deepCopier.js\";\nimport { GreasedLineTools } from \"../../Misc/greasedLineTools.js\";\nimport { GreasedLineBaseMesh } from \"./greasedLineBaseMesh.js\";\nMesh._GreasedLineMeshParser = (parsedMesh, scene) => {\n  return GreasedLineMesh.Parse(parsedMesh, scene);\n};\n/**\n * GreasedLineMesh\n * Use the GreasedLineBuilder.CreateGreasedLine function to create an instance of this class.\n */\nexport class GreasedLineMesh extends GreasedLineBaseMesh {\n  /**\n   * GreasedLineMesh\n   * @param name name of the mesh\n   * @param scene the scene\n   * @param _options mesh options\n   */\n  constructor(name, scene, _options) {\n    super(name, scene, _options);\n    this.name = name;\n    /**\n     * Treshold used to pick the mesh\n     */\n    this.intersectionThreshold = 0.1;\n    this._previousAndSide = [];\n    this._nextAndCounters = [];\n    if (_options.points) {\n      this.addPoints(GreasedLineTools.ConvertPoints(_options.points));\n    }\n  }\n  /**\n   * \"GreasedLineMesh\"\n   * @returns \"GreasedLineMesh\"\n   */\n  getClassName() {\n    return \"GreasedLineMesh\";\n  }\n  _updateColorPointers() {\n    if (this._options.colorPointers) {\n      return;\n    }\n    let colorPointer = 0;\n    this._colorPointers = [];\n    this._points.forEach(p => {\n      for (let jj = 0; jj < p.length; jj += 3) {\n        this._colorPointers.push(colorPointer);\n        this._colorPointers.push(colorPointer++);\n      }\n    });\n  }\n  _updateWidths() {\n    super._updateWidthsWithValue(0);\n  }\n  _setPoints(points) {\n    this._points = points;\n    this._options.points = points;\n    this._initGreasedLine();\n    let indiceOffset = 0;\n    points.forEach(p => {\n      var _a;\n      const counters = [];\n      const positions = [];\n      const indices = [];\n      const totalLength = GreasedLineTools.GetLineLength(p);\n      for (let j = 0, jj = 0; jj < p.length; j++, jj += 3) {\n        const partialLine = p.slice(0, jj + 3);\n        const partialLineLength = GreasedLineTools.GetLineLength(partialLine);\n        const c = partialLineLength / totalLength;\n        positions.push(p[jj], p[jj + 1], p[jj + 2]);\n        positions.push(p[jj], p[jj + 1], p[jj + 2]);\n        counters.push(c);\n        counters.push(c);\n        if (jj < p.length - 3) {\n          const n = j * 2 + indiceOffset;\n          indices.push(n, n + 1, n + 2);\n          indices.push(n + 2, n + 1, n + 3);\n        }\n      }\n      indiceOffset += p.length / 3 * 2;\n      const previous = [];\n      const next = [];\n      const side = [];\n      let uvs = [];\n      this._preprocess(positions, previous, next, side, uvs);\n      for (const vp of positions) {\n        this._vertexPositions.push(vp);\n      }\n      for (const i of indices) {\n        this._indices.push(i);\n      }\n      for (let i = 0; i < side.length; i++) {\n        this._previousAndSide.push(previous[i * 3], previous[i * 3 + 1], previous[i * 3 + 2], side[i]);\n        this._nextAndCounters.push(next[i * 3], next[i * 3 + 1], next[i * 3 + 2], counters[i]);\n      }\n      uvs = (_a = this._options.uvs) !== null && _a !== void 0 ? _a : uvs;\n      for (const uv of uvs) {\n        this._uvs.push(uv);\n      }\n    });\n    if (!this._lazy) {\n      if (!this._options.colorPointers) {\n        this._updateColorPointers();\n      }\n      this._createVertexBuffers();\n      this.refreshBoundingInfo();\n    }\n  }\n  /**\n   * Clones the GreasedLineMesh.\n   * @param name new line name\n   * @param newParent new parent node\n   * @returns cloned line\n   */\n  clone(name = `${this.name}-cloned`, newParent) {\n    const lineOptions = this._createLineOptions();\n    const deepCopiedLineOptions = {};\n    DeepCopier.DeepCopy(lineOptions, deepCopiedLineOptions, [\"instance\"]);\n    const cloned = new GreasedLineMesh(name, this._scene, deepCopiedLineOptions);\n    if (newParent) {\n      cloned.parent = newParent;\n    }\n    cloned.material = this.material;\n    return cloned;\n  }\n  /**\n   * Serializes this GreasedLineMesh\n   * @param serializationObject object to write serialization to\n   */\n  serialize(serializationObject) {\n    super.serialize(serializationObject);\n    serializationObject.type = this.getClassName();\n    serializationObject.lineOptions = this._createLineOptions();\n  }\n  /**\n   * Parses a serialized GreasedLineMesh\n   * @param parsedMesh the serialized GreasedLineMesh\n   * @param scene the scene to create the GreasedLineMesh in\n   * @returns the created GreasedLineMesh\n   */\n  static Parse(parsedMesh, scene) {\n    const lineOptions = parsedMesh.lineOptions;\n    const name = parsedMesh.name;\n    const result = new GreasedLineMesh(name, scene, lineOptions);\n    return result;\n  }\n  _initGreasedLine() {\n    super._initGreasedLine();\n    this._previousAndSide = [];\n    this._nextAndCounters = [];\n  }\n  /**\n   * Checks whether a ray is intersecting this GreasedLineMesh\n   * @param ray ray to check the intersection of this mesh with\n   * @param fastCheck not supported\n   * @param trianglePredicate not supported\n   * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)\n   * @param worldToUse not supported\n   * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\n   * @returns the picking info\n   */\n  intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo = false, worldToUse, skipBoundingInfo = false) {\n    const pickingInfo = new PickingInfo();\n    const intersections = this.findAllIntersections(ray, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo, true);\n    if ((intersections === null || intersections === void 0 ? void 0 : intersections.length) === 1) {\n      const intersection = intersections[0];\n      pickingInfo.hit = true;\n      pickingInfo.distance = intersection.distance;\n      pickingInfo.ray = ray;\n      pickingInfo.pickedMesh = this;\n      pickingInfo.pickedPoint = intersection.point;\n    }\n    return pickingInfo;\n  }\n  /**\n   * Gets all intersections of a ray and the line\n   * @param ray Ray to check the intersection of this mesh with\n   * @param _fastCheck not supported\n   * @param _trianglePredicate not supported\n   * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)\n   * @param _worldToUse not supported\n   * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\n   * @param firstOnly If true, the first and only intersection is immediatelly returned if found\n   * @returns intersection(s)\n   */\n  findAllIntersections(ray, _fastCheck, _trianglePredicate, onlyBoundingInfo = false, _worldToUse, skipBoundingInfo = false, firstOnly = false) {\n    var _a, _b;\n    if (onlyBoundingInfo && !skipBoundingInfo && ray.intersectsSphere(this._boundingSphere, this.intersectionThreshold) === false) {\n      return;\n    }\n    const indices = this.getIndices();\n    const positions = this.getVerticesData(VertexBuffer.PositionKind);\n    const widths = this._widths;\n    const lineWidth = (_b = (_a = this.greasedLineMaterial) === null || _a === void 0 ? void 0 : _a.width) !== null && _b !== void 0 ? _b : 1;\n    const intersects = [];\n    if (indices && positions && widths) {\n      let i = 0,\n        l = 0;\n      for (i = 0, l = indices.length - 1; i < l; i += 3) {\n        const a = indices[i];\n        const b = indices[i + 1];\n        GreasedLineMesh._V_START.fromArray(positions, a * 3);\n        GreasedLineMesh._V_END.fromArray(positions, b * 3);\n        if (this._offsets) {\n          GreasedLineMesh._V_OFFSET_START.fromArray(this._offsets, a * 3);\n          GreasedLineMesh._V_OFFSET_END.fromArray(this._offsets, b * 3);\n          GreasedLineMesh._V_START.addInPlace(GreasedLineMesh._V_OFFSET_START);\n          GreasedLineMesh._V_END.addInPlace(GreasedLineMesh._V_OFFSET_END);\n        }\n        const iFloored = Math.floor(i / 3);\n        const width = widths[iFloored] !== undefined ? widths[iFloored] : 1;\n        const precision = this.intersectionThreshold * (lineWidth * width) / 2;\n        const distance = ray.intersectionSegment(GreasedLineMesh._V_START, GreasedLineMesh._V_END, precision);\n        if (distance !== -1) {\n          intersects.push({\n            distance: distance,\n            point: ray.direction.normalize().multiplyByFloats(distance, distance, distance).add(ray.origin)\n          });\n          if (firstOnly) {\n            return intersects;\n          }\n        }\n      }\n      i = l;\n    }\n    return intersects;\n  }\n  get _boundingSphere() {\n    return this.getBoundingInfo().boundingSphere;\n  }\n  static _CompareV3(positionIdx1, positionIdx2, positions) {\n    const arrayIdx1 = positionIdx1 * 6;\n    const arrayIdx2 = positionIdx2 * 6;\n    return positions[arrayIdx1] === positions[arrayIdx2] && positions[arrayIdx1 + 1] === positions[arrayIdx2 + 1] && positions[arrayIdx1 + 2] === positions[arrayIdx2 + 2];\n  }\n  static _CopyV3(positionIdx, positions) {\n    const arrayIdx = positionIdx * 6;\n    return [positions[arrayIdx], positions[arrayIdx + 1], positions[arrayIdx + 2]];\n  }\n  _preprocess(positions, previous, next, side, uvs) {\n    const l = positions.length / 6;\n    let v = [];\n    if (GreasedLineMesh._CompareV3(0, l - 1, positions)) {\n      v = GreasedLineMesh._CopyV3(l - 2, positions);\n    } else {\n      v = GreasedLineMesh._CopyV3(0, positions);\n    }\n    previous.push(v[0], v[1], v[2]);\n    previous.push(v[0], v[1], v[2]);\n    for (let j = 0; j < l; j++) {\n      side.push(1);\n      side.push(-1);\n      // uvs\n      if (!this._options.uvs) {\n        uvs.push(j / (l - 1), 0);\n        uvs.push(j / (l - 1), 1);\n      }\n      if (j < l - 1) {\n        v = GreasedLineMesh._CopyV3(j, positions);\n        previous.push(v[0], v[1], v[2]);\n        previous.push(v[0], v[1], v[2]);\n      }\n      if (j > 0) {\n        v = GreasedLineMesh._CopyV3(j, positions);\n        next.push(v[0], v[1], v[2]);\n        next.push(v[0], v[1], v[2]);\n      }\n    }\n    if (GreasedLineMesh._CompareV3(l - 1, 0, positions)) {\n      v = GreasedLineMesh._CopyV3(1, positions);\n    } else {\n      v = GreasedLineMesh._CopyV3(l - 1, positions);\n    }\n    next.push(v[0], v[1], v[2]);\n    next.push(v[0], v[1], v[2]);\n    return {\n      previous,\n      next,\n      uvs,\n      side\n    };\n  }\n  _createVertexBuffers() {\n    const vertexData = super._createVertexBuffers();\n    const engine = this._scene.getEngine();\n    const previousAndSideBuffer = new Buffer(engine, this._previousAndSide, false, 4);\n    this.setVerticesBuffer(previousAndSideBuffer.createVertexBuffer(\"grl_previousAndSide\", 0, 4));\n    const nextAndCountersBuffer = new Buffer(engine, this._nextAndCounters, false, 4);\n    this.setVerticesBuffer(nextAndCountersBuffer.createVertexBuffer(\"grl_nextAndCounters\", 0, 4));\n    const widthBuffer = new Buffer(engine, this._widths, this._updatable, 1);\n    this.setVerticesBuffer(widthBuffer.createVertexBuffer(\"grl_widths\", 0, 1));\n    this._widthsBuffer = widthBuffer;\n    const colorPointersBuffer = new Buffer(engine, this._colorPointers, this._updatable, 1);\n    this.setVerticesBuffer(colorPointersBuffer.createVertexBuffer(\"grl_colorPointers\", 0, 1));\n    this._colorPointersBuffer = colorPointersBuffer;\n    return vertexData;\n  }\n}\nGreasedLineMesh._V_START = new Vector3();\nGreasedLineMesh._V_END = new Vector3();\nGreasedLineMesh._V_OFFSET_START = new Vector3();\nGreasedLineMesh._V_OFFSET_END = new Vector3();","map":{"version":3,"names":["Vector3","Mesh","Buffer","VertexBuffer","PickingInfo","DeepCopier","GreasedLineTools","GreasedLineBaseMesh","_GreasedLineMeshParser","parsedMesh","scene","GreasedLineMesh","Parse","constructor","name","_options","intersectionThreshold","_previousAndSide","_nextAndCounters","points","addPoints","ConvertPoints","getClassName","_updateColorPointers","colorPointers","colorPointer","_colorPointers","_points","forEach","p","jj","length","push","_updateWidths","_updateWidthsWithValue","_setPoints","_initGreasedLine","indiceOffset","counters","positions","indices","totalLength","GetLineLength","j","partialLine","slice","partialLineLength","c","n","previous","next","side","uvs","_preprocess","vp","_vertexPositions","i","_indices","_a","uv","_uvs","_lazy","_createVertexBuffers","refreshBoundingInfo","clone","newParent","lineOptions","_createLineOptions","deepCopiedLineOptions","DeepCopy","cloned","_scene","parent","material","serialize","serializationObject","type","result","intersects","ray","fastCheck","trianglePredicate","onlyBoundingInfo","worldToUse","skipBoundingInfo","pickingInfo","intersections","findAllIntersections","intersection","hit","distance","pickedMesh","pickedPoint","point","_fastCheck","_trianglePredicate","_worldToUse","firstOnly","intersectsSphere","_boundingSphere","getIndices","getVerticesData","PositionKind","widths","_widths","lineWidth","_b","greasedLineMaterial","width","l","a","b","_V_START","fromArray","_V_END","_offsets","_V_OFFSET_START","_V_OFFSET_END","addInPlace","iFloored","Math","floor","undefined","precision","intersectionSegment","direction","normalize","multiplyByFloats","add","origin","getBoundingInfo","boundingSphere","_CompareV3","positionIdx1","positionIdx2","arrayIdx1","arrayIdx2","_CopyV3","positionIdx","arrayIdx","v","vertexData","engine","getEngine","previousAndSideBuffer","setVerticesBuffer","createVertexBuffer","nextAndCountersBuffer","widthBuffer","_updatable","_widthsBuffer","colorPointersBuffer","_colorPointersBuffer"],"sources":["../../../../../dev/core/src/Meshes/GreasedLine/greasedLineMesh.ts"],"sourcesContent":["import type { Scene } from \"../../scene\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport type { Ray, TrianglePickingPredicate } from \"../../Culling/ray\";\r\nimport { Buffer, VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Node } from \"../../node\";\r\nimport { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport { GreasedLineTools } from \"../../Misc/greasedLineTools\";\r\nimport type { GreasedLineMeshOptions } from \"./greasedLineBaseMesh\";\r\nimport { GreasedLineBaseMesh } from \"./greasedLineBaseMesh\";\r\n\r\nMesh._GreasedLineMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return GreasedLineMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * GreasedLineMesh\r\n * Use the GreasedLineBuilder.CreateGreasedLine function to create an instance of this class.\r\n */\r\nexport class GreasedLineMesh extends GreasedLineBaseMesh {\r\n    private _previousAndSide: number[];\r\n    private _nextAndCounters: number[];\r\n\r\n    private static _V_START = new Vector3();\r\n    private static _V_END = new Vector3();\r\n    private static _V_OFFSET_START = new Vector3();\r\n    private static _V_OFFSET_END = new Vector3();\r\n\r\n    /**\r\n     * Treshold used to pick the mesh\r\n     */\r\n    public intersectionThreshold = 0.1;\r\n\r\n    /**\r\n     * GreasedLineMesh\r\n     * @param name name of the mesh\r\n     * @param scene the scene\r\n     * @param _options mesh options\r\n     */\r\n    constructor(public readonly name: string, scene: Scene, _options: GreasedLineMeshOptions) {\r\n        super(name, scene, _options);\r\n\r\n        this._previousAndSide = [];\r\n        this._nextAndCounters = [];\r\n\r\n        if (_options.points) {\r\n            this.addPoints(GreasedLineTools.ConvertPoints(_options.points));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * \"GreasedLineMesh\"\r\n     * @returns \"GreasedLineMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"GreasedLineMesh\";\r\n    }\r\n\r\n    protected _updateColorPointers() {\r\n        if (this._options.colorPointers) {\r\n            return;\r\n        }\r\n\r\n        let colorPointer = 0;\r\n        this._colorPointers = [];\r\n        this._points.forEach((p) => {\r\n            for (let jj = 0; jj < p.length; jj += 3) {\r\n                this._colorPointers.push(colorPointer);\r\n                this._colorPointers.push(colorPointer++);\r\n            }\r\n        });\r\n    }\r\n\r\n    protected _updateWidths(): void {\r\n        super._updateWidthsWithValue(0);\r\n    }\r\n\r\n    protected _setPoints(points: number[][]) {\r\n        this._points = points;\r\n        this._options.points = points;\r\n\r\n        this._initGreasedLine();\r\n\r\n        let indiceOffset = 0;\r\n\r\n        points.forEach((p) => {\r\n            const counters: number[] = [];\r\n            const positions: number[] = [];\r\n            const indices: number[] = [];\r\n\r\n            const totalLength = GreasedLineTools.GetLineLength(p);\r\n            for (let j = 0, jj = 0; jj < p.length; j++, jj += 3) {\r\n                const partialLine = p.slice(0, jj + 3);\r\n                const partialLineLength = GreasedLineTools.GetLineLength(partialLine);\r\n                const c = partialLineLength / totalLength;\r\n\r\n                positions.push(p[jj], p[jj + 1], p[jj + 2]);\r\n                positions.push(p[jj], p[jj + 1], p[jj + 2]);\r\n                counters.push(c);\r\n                counters.push(c);\r\n\r\n                if (jj < p.length - 3) {\r\n                    const n = j * 2 + indiceOffset;\r\n                    indices.push(n, n + 1, n + 2);\r\n                    indices.push(n + 2, n + 1, n + 3);\r\n                }\r\n            }\r\n\r\n            indiceOffset += (p.length / 3) * 2;\r\n\r\n            const previous: number[] = [];\r\n            const next: number[] = [];\r\n            const side: number[] = [];\r\n            let uvs: number[] = [];\r\n\r\n            this._preprocess(positions, previous, next, side, uvs);\r\n\r\n            for (const vp of positions) {\r\n                this._vertexPositions.push(vp);\r\n            }\r\n\r\n            for (const i of indices) {\r\n                this._indices.push(i);\r\n            }\r\n\r\n            for (let i = 0; i < side.length; i++) {\r\n                this._previousAndSide.push(previous[i * 3], previous[i * 3 + 1], previous[i * 3 + 2], side[i]);\r\n                this._nextAndCounters.push(next[i * 3], next[i * 3 + 1], next[i * 3 + 2], counters[i]);\r\n            }\r\n\r\n            uvs = this._options.uvs ?? uvs;\r\n            for (const uv of uvs) {\r\n                this._uvs.push(uv);\r\n            }\r\n        });\r\n\r\n        if (!this._lazy) {\r\n            if (!this._options.colorPointers) {\r\n                this._updateColorPointers();\r\n            }\r\n            this._createVertexBuffers();\r\n            this.refreshBoundingInfo();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones the GreasedLineMesh.\r\n     * @param name new line name\r\n     * @param newParent new parent node\r\n     * @returns cloned line\r\n     */\r\n    public clone(name: string = `${this.name}-cloned`, newParent?: Nullable<Node>) {\r\n        const lineOptions = this._createLineOptions();\r\n        const deepCopiedLineOptions = {};\r\n        DeepCopier.DeepCopy(lineOptions, deepCopiedLineOptions, [\"instance\"]);\r\n\r\n        const cloned = new GreasedLineMesh(name, this._scene, <GreasedLineMeshOptions>deepCopiedLineOptions);\r\n        if (newParent) {\r\n            cloned.parent = newParent;\r\n        }\r\n\r\n        cloned.material = this.material;\r\n\r\n        return cloned;\r\n    }\r\n\r\n    /**\r\n     * Serializes this GreasedLineMesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.type = this.getClassName();\r\n\r\n        serializationObject.lineOptions = this._createLineOptions();\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized GreasedLineMesh\r\n     * @param parsedMesh the serialized GreasedLineMesh\r\n     * @param scene the scene to create the GreasedLineMesh in\r\n     * @returns the created GreasedLineMesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): Mesh {\r\n        const lineOptions = <GreasedLineMeshOptions>parsedMesh.lineOptions;\r\n        const name = <string>parsedMesh.name;\r\n        const result = new GreasedLineMesh(name, scene, lineOptions);\r\n        return result;\r\n    }\r\n\r\n    protected _initGreasedLine() {\r\n        super._initGreasedLine();\r\n\r\n        this._previousAndSide = [];\r\n        this._nextAndCounters = [];\r\n    }\r\n    /**\r\n     * Checks whether a ray is intersecting this GreasedLineMesh\r\n     * @param ray ray to check the intersection of this mesh with\r\n     * @param fastCheck not supported\r\n     * @param trianglePredicate not supported\r\n     * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)\r\n     * @param worldToUse not supported\r\n     * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\r\n     * @returns the picking info\r\n     */\r\n    public intersects(\r\n        ray: Ray,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate,\r\n        onlyBoundingInfo = false,\r\n        worldToUse?: Matrix,\r\n        skipBoundingInfo = false\r\n    ): PickingInfo {\r\n        const pickingInfo = new PickingInfo();\r\n        const intersections = this.findAllIntersections(ray, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo, true);\r\n        if (intersections?.length === 1) {\r\n            const intersection = intersections[0];\r\n            pickingInfo.hit = true;\r\n            pickingInfo.distance = intersection.distance;\r\n            pickingInfo.ray = ray;\r\n            pickingInfo.pickedMesh = this;\r\n            pickingInfo.pickedPoint = intersection.point;\r\n        }\r\n        return pickingInfo;\r\n    }\r\n\r\n    /**\r\n     * Gets all intersections of a ray and the line\r\n     * @param ray Ray to check the intersection of this mesh with\r\n     * @param _fastCheck not supported\r\n     * @param _trianglePredicate not supported\r\n     * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)\r\n     * @param _worldToUse not supported\r\n     * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\r\n     * @param firstOnly If true, the first and only intersection is immediatelly returned if found\r\n     * @returns intersection(s)\r\n     */\r\n    public findAllIntersections(\r\n        ray: Ray,\r\n        _fastCheck?: boolean,\r\n        _trianglePredicate?: TrianglePickingPredicate,\r\n        onlyBoundingInfo = false,\r\n        _worldToUse?: Matrix,\r\n        skipBoundingInfo = false,\r\n        firstOnly = false\r\n    ): { distance: number; point: Vector3 }[] | undefined {\r\n        if (onlyBoundingInfo && !skipBoundingInfo && ray.intersectsSphere(this._boundingSphere, this.intersectionThreshold) === false) {\r\n            return;\r\n        }\r\n\r\n        const indices = this.getIndices();\r\n        const positions = this.getVerticesData(VertexBuffer.PositionKind);\r\n        const widths = this._widths;\r\n\r\n        const lineWidth = this.greasedLineMaterial?.width ?? 1;\r\n\r\n        const intersects = [];\r\n        if (indices && positions && widths) {\r\n            let i = 0,\r\n                l = 0;\r\n            for (i = 0, l = indices.length - 1; i < l; i += 3) {\r\n                const a = indices[i];\r\n                const b = indices[i + 1];\r\n\r\n                GreasedLineMesh._V_START.fromArray(positions, a * 3);\r\n                GreasedLineMesh._V_END.fromArray(positions, b * 3);\r\n\r\n                if (this._offsets) {\r\n                    GreasedLineMesh._V_OFFSET_START.fromArray(this._offsets, a * 3);\r\n                    GreasedLineMesh._V_OFFSET_END.fromArray(this._offsets, b * 3);\r\n                    GreasedLineMesh._V_START.addInPlace(GreasedLineMesh._V_OFFSET_START);\r\n                    GreasedLineMesh._V_END.addInPlace(GreasedLineMesh._V_OFFSET_END);\r\n                }\r\n\r\n                const iFloored = Math.floor(i / 3);\r\n                const width = widths[iFloored] !== undefined ? widths[iFloored] : 1;\r\n                const precision = (this.intersectionThreshold * (lineWidth * width)) / 2;\r\n\r\n                const distance = ray.intersectionSegment(GreasedLineMesh._V_START, GreasedLineMesh._V_END, precision);\r\n                if (distance !== -1) {\r\n                    intersects.push({\r\n                        distance: distance,\r\n                        point: ray.direction.normalize().multiplyByFloats(distance, distance, distance).add(ray.origin),\r\n                    });\r\n                    if (firstOnly) {\r\n                        return intersects;\r\n                    }\r\n                }\r\n            }\r\n            i = l;\r\n        }\r\n\r\n        return intersects;\r\n    }\r\n\r\n    private get _boundingSphere() {\r\n        return this.getBoundingInfo().boundingSphere;\r\n    }\r\n\r\n    private static _CompareV3(positionIdx1: number, positionIdx2: number, positions: number[]) {\r\n        const arrayIdx1 = positionIdx1 * 6;\r\n        const arrayIdx2 = positionIdx2 * 6;\r\n        return positions[arrayIdx1] === positions[arrayIdx2] && positions[arrayIdx1 + 1] === positions[arrayIdx2 + 1] && positions[arrayIdx1 + 2] === positions[arrayIdx2 + 2];\r\n    }\r\n\r\n    private static _CopyV3(positionIdx: number, positions: number[]) {\r\n        const arrayIdx = positionIdx * 6;\r\n        return [positions[arrayIdx], positions[arrayIdx + 1], positions[arrayIdx + 2]];\r\n    }\r\n\r\n    private _preprocess(positions: number[], previous: number[], next: number[], side: number[], uvs: number[]) {\r\n        const l = positions.length / 6;\r\n\r\n        let v: number[] = [];\r\n\r\n        if (GreasedLineMesh._CompareV3(0, l - 1, positions)) {\r\n            v = GreasedLineMesh._CopyV3(l - 2, positions);\r\n        } else {\r\n            v = GreasedLineMesh._CopyV3(0, positions);\r\n        }\r\n        previous.push(v[0], v[1], v[2]);\r\n        previous.push(v[0], v[1], v[2]);\r\n\r\n        for (let j = 0; j < l; j++) {\r\n            side.push(1);\r\n            side.push(-1);\r\n\r\n            // uvs\r\n            if (!this._options.uvs) {\r\n                uvs.push(j / (l - 1), 0);\r\n                uvs.push(j / (l - 1), 1);\r\n            }\r\n\r\n            if (j < l - 1) {\r\n                v = GreasedLineMesh._CopyV3(j, positions);\r\n                previous.push(v[0], v[1], v[2]);\r\n                previous.push(v[0], v[1], v[2]);\r\n            }\r\n            if (j > 0) {\r\n                v = GreasedLineMesh._CopyV3(j, positions);\r\n                next.push(v[0], v[1], v[2]);\r\n                next.push(v[0], v[1], v[2]);\r\n            }\r\n        }\r\n\r\n        if (GreasedLineMesh._CompareV3(l - 1, 0, positions)) {\r\n            v = GreasedLineMesh._CopyV3(1, positions);\r\n        } else {\r\n            v = GreasedLineMesh._CopyV3(l - 1, positions);\r\n        }\r\n        next.push(v[0], v[1], v[2]);\r\n        next.push(v[0], v[1], v[2]);\r\n\r\n        return {\r\n            previous,\r\n            next,\r\n            uvs,\r\n            side,\r\n        };\r\n    }\r\n\r\n    protected _createVertexBuffers() {\r\n        const vertexData = super._createVertexBuffers();\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        const previousAndSideBuffer = new Buffer(engine, this._previousAndSide, false, 4);\r\n        this.setVerticesBuffer(previousAndSideBuffer.createVertexBuffer(\"grl_previousAndSide\", 0, 4));\r\n\r\n        const nextAndCountersBuffer = new Buffer(engine, this._nextAndCounters, false, 4);\r\n        this.setVerticesBuffer(nextAndCountersBuffer.createVertexBuffer(\"grl_nextAndCounters\", 0, 4));\r\n\r\n        const widthBuffer = new Buffer(engine, this._widths, this._updatable, 1);\r\n        this.setVerticesBuffer(widthBuffer.createVertexBuffer(\"grl_widths\", 0, 1));\r\n        this._widthsBuffer = widthBuffer;\r\n\r\n        const colorPointersBuffer = new Buffer(engine, this._colorPointers, this._updatable, 1);\r\n        this.setVerticesBuffer(colorPointersBuffer.createVertexBuffer(\"grl_colorPointers\", 0, 1));\r\n        this._colorPointersBuffer = colorPointersBuffer;\r\n\r\n        return vertexData;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}