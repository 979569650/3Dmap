{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { ThinEngine } from \"../../Engines/thinEngine.js\";\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { LoadImage } from \"../../Misc/fileTools.js\";\nimport { RandomGUID } from \"../../Misc/guid.js\";\nThinEngine.prototype._createDepthStencilCubeTexture = function (size, options, rtWrapper) {\n  const internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);\n  internalTexture.isCube = true;\n  if (this.webGLVersion === 1) {\n    Logger.Error(\"Depth cube texture is not supported by WebGL 1.\");\n    return internalTexture;\n  }\n  const internalOptions = Object.assign({\n    bilinearFiltering: false,\n    comparisonFunction: 0,\n    generateStencil: false\n  }, options);\n  const gl = this._gl;\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, internalTexture, true);\n  this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.bilinearFiltering, internalOptions.comparisonFunction);\n  rtWrapper._depthStencilTexture = internalTexture;\n  rtWrapper._depthStencilTextureWithStencil = internalOptions.generateStencil;\n  // Create the depth/stencil buffer\n  for (let face = 0; face < 6; face++) {\n    if (internalOptions.generateStencil) {\n      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH24_STENCIL8, size, size, 0, gl.DEPTH_STENCIL, gl.UNSIGNED_INT_24_8, null);\n    } else {\n      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH_COMPONENT24, size, size, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);\n    }\n  }\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n  this._internalTexturesCache.push(internalTexture);\n  return internalTexture;\n};\nThinEngine.prototype._partialLoadFile = function (url, index, loadedFiles, onfinish, onErrorCallBack = null) {\n  const onload = data => {\n    loadedFiles[index] = data;\n    loadedFiles._internalCount++;\n    if (loadedFiles._internalCount === 6) {\n      onfinish(loadedFiles);\n    }\n  };\n  const onerror = (request, exception) => {\n    if (onErrorCallBack && request) {\n      onErrorCallBack(request.status + \" \" + request.statusText, exception);\n    }\n  };\n  this._loadFile(url, onload, undefined, undefined, true, onerror);\n};\nThinEngine.prototype._cascadeLoadFiles = function (scene, onfinish, files, onError = null) {\n  const loadedFiles = [];\n  loadedFiles._internalCount = 0;\n  for (let index = 0; index < 6; index++) {\n    this._partialLoadFile(files[index], index, loadedFiles, onfinish, onError);\n  }\n};\nThinEngine.prototype._cascadeLoadImgs = function (scene, texture, onfinish, files, onError = null, mimeType) {\n  const loadedImages = [];\n  loadedImages._internalCount = 0;\n  for (let index = 0; index < 6; index++) {\n    this._partialLoadImg(files[index], index, loadedImages, scene, texture, onfinish, onError, mimeType);\n  }\n};\nThinEngine.prototype._partialLoadImg = function (url, index, loadedImages, scene, texture, onfinish, onErrorCallBack = null, mimeType) {\n  const tokenPendingData = RandomGUID();\n  const onload = img => {\n    loadedImages[index] = img;\n    loadedImages._internalCount++;\n    if (scene) {\n      scene.removePendingData(tokenPendingData);\n    }\n    if (loadedImages._internalCount === 6 && onfinish) {\n      onfinish(texture, loadedImages);\n    }\n  };\n  const onerror = (message, exception) => {\n    if (scene) {\n      scene.removePendingData(tokenPendingData);\n    }\n    if (onErrorCallBack) {\n      onErrorCallBack(message, exception);\n    }\n  };\n  LoadImage(url, onload, onerror, scene ? scene.offlineProvider : null, mimeType);\n  if (scene) {\n    scene.addPendingData(tokenPendingData);\n  }\n};\nThinEngine.prototype._setCubeMapTextureParams = function (texture, loadMipmap, maxLevel) {\n  const gl = this._gl;\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, loadMipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  texture.samplingMode = loadMipmap ? 3 : 2;\n  if (loadMipmap && this.getCaps().textureMaxLevel && maxLevel !== undefined && maxLevel > 0) {\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAX_LEVEL, maxLevel);\n    texture._maxLodLevel = maxLevel;\n  }\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n};\nThinEngine.prototype.createCubeTextureBase = function (rootUrl, scene, files, noMipmap, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = false, lodScale = 0, lodOffset = 0, fallback = null, beforeLoadCubeDataCallback = null, imageHandler = null, useSRGBBuffer = false) {\n  const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);\n  texture.isCube = true;\n  texture.url = rootUrl;\n  texture.generateMipMaps = !noMipmap;\n  texture._lodGenerationScale = lodScale;\n  texture._lodGenerationOffset = lodOffset;\n  texture._useSRGBBuffer = !!useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU || !!noMipmap);\n  if (texture !== fallback) {\n    texture.label = rootUrl.substring(0, 60); // default label, can be overriden by the caller\n  }\n\n  if (!this._doNotHandleContextLost) {\n    texture._extension = forcedExtension;\n    texture._files = files;\n  }\n  const originalRootUrl = rootUrl;\n  if (this._transformTextureUrl && !fallback) {\n    rootUrl = this._transformTextureUrl(rootUrl);\n  }\n  const rootUrlWithoutUriParams = rootUrl.split(\"?\")[0];\n  const lastDot = rootUrlWithoutUriParams.lastIndexOf(\".\");\n  const extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrlWithoutUriParams.substring(lastDot).toLowerCase() : \"\";\n  let loader = null;\n  for (const availableLoader of ThinEngine._TextureLoaders) {\n    if (availableLoader.canLoad(extension)) {\n      loader = availableLoader;\n      break;\n    }\n  }\n  const onInternalError = (request, exception) => {\n    if (rootUrl === originalRootUrl) {\n      if (onError && request) {\n        onError(request.status + \" \" + request.statusText, exception);\n      }\n    } else {\n      // fall back to the original url if the transformed url fails to load\n      Logger.Warn(`Failed to load ${rootUrl}, falling back to the ${originalRootUrl}`);\n      this.createCubeTextureBase(originalRootUrl, scene, files, !!noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, texture, beforeLoadCubeDataCallback, imageHandler, useSRGBBuffer);\n    }\n  };\n  if (loader) {\n    const onloaddata = data => {\n      if (beforeLoadCubeDataCallback) {\n        beforeLoadCubeDataCallback(texture, data);\n      }\n      loader.loadCubeData(data, texture, createPolynomials, onLoad, onError);\n    };\n    if (files && files.length === 6) {\n      if (loader.supportCascades) {\n        this._cascadeLoadFiles(scene, images => onloaddata(images.map(image => new Uint8Array(image))), files, onError);\n      } else {\n        if (onError) {\n          onError(\"Textures type does not support cascades.\");\n        } else {\n          Logger.Warn(\"Texture loader does not support cascades.\");\n        }\n      }\n    } else {\n      this._loadFile(rootUrl, data => onloaddata(new Uint8Array(data)), undefined, undefined, true, onInternalError);\n    }\n  } else {\n    if (!files) {\n      throw new Error(\"Cannot load cubemap because files were not defined\");\n    }\n    this._cascadeLoadImgs(scene, texture, (texture, imgs) => {\n      if (imageHandler) {\n        imageHandler(texture, imgs);\n      }\n    }, files, onError);\n  }\n  this._internalTexturesCache.push(texture);\n  return texture;\n};\nThinEngine.prototype.createCubeTexture = function (rootUrl, scene, files, noMipmap, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = false, lodScale = 0, lodOffset = 0, fallback = null, loaderOptions, useSRGBBuffer = false) {\n  const gl = this._gl;\n  return this.createCubeTextureBase(rootUrl, scene, files, !!noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, fallback, texture => this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true), (texture, imgs) => {\n    const width = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(imgs[0].width, this._caps.maxCubemapTextureSize) : imgs[0].width;\n    const height = width;\n    const faces = [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\n    this._unpackFlipY(false);\n    const internalFormat = format ? this._getInternalFormat(format, texture._useSRGBBuffer) : texture._useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : gl.RGBA;\n    let texelFormat = format ? this._getInternalFormat(format) : gl.RGBA;\n    if (texture._useSRGBBuffer && this.webGLVersion === 1) {\n      texelFormat = internalFormat;\n    }\n    for (let index = 0; index < faces.length; index++) {\n      if (imgs[index].width !== width || imgs[index].height !== height) {\n        this._prepareWorkingCanvas();\n        if (!this._workingCanvas || !this._workingContext) {\n          Logger.Warn(\"Cannot create canvas to resize texture.\");\n          return;\n        }\n        this._workingCanvas.width = width;\n        this._workingCanvas.height = height;\n        this._workingContext.drawImage(imgs[index], 0, 0, imgs[index].width, imgs[index].height, 0, 0, width, height);\n        gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, this._workingCanvas);\n      } else {\n        gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, imgs[index]);\n      }\n    }\n    if (!noMipmap) {\n      gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n    }\n    this._setCubeMapTextureParams(texture, !noMipmap);\n    texture.width = width;\n    texture.height = height;\n    texture.isReady = true;\n    if (format) {\n      texture.format = format;\n    }\n    texture.onLoadedObservable.notifyObservers(texture);\n    texture.onLoadedObservable.clear();\n    if (onLoad) {\n      onLoad();\n    }\n  }, !!useSRGBBuffer);\n};","map":{"version":3,"names":["ThinEngine","InternalTexture","InternalTextureSource","Logger","LoadImage","RandomGUID","prototype","_createDepthStencilCubeTexture","size","options","rtWrapper","internalTexture","DepthStencil","isCube","webGLVersion","Error","internalOptions","Object","assign","bilinearFiltering","comparisonFunction","generateStencil","gl","_gl","_bindTextureDirectly","TEXTURE_CUBE_MAP","_setupDepthStencilTexture","_depthStencilTexture","_depthStencilTextureWithStencil","face","texImage2D","TEXTURE_CUBE_MAP_POSITIVE_X","DEPTH24_STENCIL8","DEPTH_STENCIL","UNSIGNED_INT_24_8","DEPTH_COMPONENT24","DEPTH_COMPONENT","UNSIGNED_INT","_internalTexturesCache","push","_partialLoadFile","url","index","loadedFiles","onfinish","onErrorCallBack","onload","data","_internalCount","onerror","request","exception","status","statusText","_loadFile","undefined","_cascadeLoadFiles","scene","files","onError","_cascadeLoadImgs","texture","mimeType","loadedImages","_partialLoadImg","tokenPendingData","img","removePendingData","message","offlineProvider","addPendingData","_setCubeMapTextureParams","loadMipmap","maxLevel","texParameteri","TEXTURE_MAG_FILTER","LINEAR","TEXTURE_MIN_FILTER","LINEAR_MIPMAP_LINEAR","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","samplingMode","getCaps","textureMaxLevel","TEXTURE_MAX_LEVEL","_maxLodLevel","createCubeTextureBase","rootUrl","noMipmap","onLoad","format","forcedExtension","createPolynomials","lodScale","lodOffset","fallback","beforeLoadCubeDataCallback","imageHandler","useSRGBBuffer","Cube","generateMipMaps","_lodGenerationScale","_lodGenerationOffset","_useSRGBBuffer","_caps","supportSRGBBuffers","isWebGPU","label","substring","_doNotHandleContextLost","_extension","_files","originalRootUrl","_transformTextureUrl","rootUrlWithoutUriParams","split","lastDot","lastIndexOf","extension","toLowerCase","loader","availableLoader","_TextureLoaders","canLoad","onInternalError","Warn","onloaddata","loadCubeData","length","supportCascades","images","map","image","Uint8Array","imgs","createCubeTexture","loaderOptions","width","needPOTTextures","GetExponentOfTwo","maxCubemapTextureSize","height","faces","TEXTURE_CUBE_MAP_POSITIVE_Y","TEXTURE_CUBE_MAP_POSITIVE_Z","TEXTURE_CUBE_MAP_NEGATIVE_X","TEXTURE_CUBE_MAP_NEGATIVE_Y","TEXTURE_CUBE_MAP_NEGATIVE_Z","_unpackFlipY","internalFormat","_getInternalFormat","_glSRGBExtensionValues","SRGB8_ALPHA8","RGBA","texelFormat","_prepareWorkingCanvas","_workingCanvas","_workingContext","drawImage","UNSIGNED_BYTE","generateMipmap","isReady","onLoadedObservable","notifyObservers","clear"],"sources":["../../../../../dev/core/src/Engines/Extensions/engine.cubeTexture.ts"],"sourcesContent":["import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { IInternalTextureLoader } from \"../../Materials/Textures/internalTextureLoader\";\r\nimport { LoadImage } from \"../../Misc/fileTools\";\r\nimport { RandomGUID } from \"../../Misc/guid\";\r\nimport type { IWebRequest } from \"../../Misc/interfaces/iWebRequest\";\r\nimport { Constants } from \"../constants\";\r\nimport type { DepthTextureCreationOptions } from \"../../Materials/Textures/textureCreationOptions\";\r\nimport type { RenderTargetWrapper } from \"../renderTargetWrapper\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a depth stencil cube texture.\r\n         * This is only available in WebGL 2.\r\n         * @param size The size of face edge in the cube texture.\r\n         * @param options The options defining the cube texture.\r\n         * @param rtWrapper The render target wrapper for which the depth/stencil texture must be created\r\n         * @returns The cube texture\r\n         */\r\n        _createDepthStencilCubeTexture(size: number, options: DepthTextureCreationOptions, rtWrapper: RenderTargetWrapper): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n         * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n         * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n         * @param fallback defines texture to use while falling back when (compressed) texture file not found.\r\n         * @param loaderOptions options to be passed to the loader\r\n         * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean | undefined,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number,\r\n            fallback: Nullable<InternalTexture>,\r\n            loaderOptions: any,\r\n            useSRGBBuffer: boolean\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n         * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n         * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number\r\n        ): InternalTexture;\r\n\r\n        /** @internal */\r\n        createCubeTextureBase(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number,\r\n            fallback: Nullable<InternalTexture>,\r\n            beforeLoadCubeDataCallback: Nullable<(texture: InternalTexture, data: ArrayBufferView | ArrayBufferView[]) => void>,\r\n            imageHandler: Nullable<(texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            useSRGBBuffer: boolean\r\n        ): InternalTexture;\r\n\r\n        /** @internal */\r\n        _partialLoadFile(\r\n            url: string,\r\n            index: number,\r\n            loadedFiles: ArrayBuffer[],\r\n            onfinish: (files: ArrayBuffer[]) => void,\r\n            onErrorCallBack: Nullable<(message?: string, exception?: any) => void>\r\n        ): void;\r\n\r\n        /** @internal */\r\n        _cascadeLoadFiles(scene: Nullable<Scene>, onfinish: (images: ArrayBuffer[]) => void, files: string[], onError: Nullable<(message?: string, exception?: any) => void>): void;\r\n\r\n        /** @internal */\r\n        _cascadeLoadImgs(\r\n            scene: Nullable<Scene>,\r\n            texture: InternalTexture,\r\n            onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            files: string[],\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            mimeType?: string\r\n        ): void;\r\n\r\n        /** @internal */\r\n        _partialLoadImg(\r\n            url: string,\r\n            index: number,\r\n            loadedImages: HTMLImageElement[] | ImageBitmap[],\r\n            scene: Nullable<Scene>,\r\n            texture: InternalTexture,\r\n            onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            onErrorCallBack: Nullable<(message?: string, exception?: any) => void>,\r\n            mimeType?: string\r\n        ): void;\r\n\r\n        /**\r\n         * @internal\r\n         */\r\n        _setCubeMapTextureParams(texture: InternalTexture, loadMipmap: boolean, maxLevel?: number): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype._createDepthStencilCubeTexture = function (size: number, options: DepthTextureCreationOptions, rtWrapper: RenderTargetWrapper): InternalTexture {\r\n    const internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);\r\n    internalTexture.isCube = true;\r\n\r\n    if (this.webGLVersion === 1) {\r\n        Logger.Error(\"Depth cube texture is not supported by WebGL 1.\");\r\n        return internalTexture;\r\n    }\r\n\r\n    const internalOptions = {\r\n        bilinearFiltering: false,\r\n        comparisonFunction: 0,\r\n        generateStencil: false,\r\n        ...options,\r\n    };\r\n\r\n    const gl = this._gl;\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, internalTexture, true);\r\n\r\n    this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.bilinearFiltering, internalOptions.comparisonFunction);\r\n\r\n    rtWrapper._depthStencilTexture = internalTexture;\r\n    rtWrapper._depthStencilTextureWithStencil = internalOptions.generateStencil;\r\n\r\n    // Create the depth/stencil buffer\r\n    for (let face = 0; face < 6; face++) {\r\n        if (internalOptions.generateStencil) {\r\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH24_STENCIL8, size, size, 0, gl.DEPTH_STENCIL, gl.UNSIGNED_INT_24_8, null);\r\n        } else {\r\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH_COMPONENT24, size, size, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);\r\n        }\r\n    }\r\n\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n\r\n    this._internalTexturesCache.push(internalTexture);\r\n\r\n    return internalTexture;\r\n};\r\n\r\nThinEngine.prototype._partialLoadFile = function (\r\n    url: string,\r\n    index: number,\r\n    loadedFiles: ArrayBuffer[],\r\n    onfinish: (files: ArrayBuffer[]) => void,\r\n    onErrorCallBack: Nullable<(message?: string, exception?: any) => void> = null\r\n): void {\r\n    const onload = (data: ArrayBuffer) => {\r\n        loadedFiles[index] = data;\r\n        (<any>loadedFiles)._internalCount++;\r\n\r\n        if ((<any>loadedFiles)._internalCount === 6) {\r\n            onfinish(loadedFiles);\r\n        }\r\n    };\r\n\r\n    const onerror = (request?: IWebRequest, exception?: any) => {\r\n        if (onErrorCallBack && request) {\r\n            onErrorCallBack(request.status + \" \" + request.statusText, exception);\r\n        }\r\n    };\r\n\r\n    this._loadFile(url, onload as (data: string | ArrayBuffer) => void, undefined, undefined, true, onerror);\r\n};\r\n\r\nThinEngine.prototype._cascadeLoadFiles = function (\r\n    scene: Nullable<Scene>,\r\n    onfinish: (images: ArrayBuffer[]) => void,\r\n    files: string[],\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null\r\n): void {\r\n    const loadedFiles: ArrayBuffer[] = [];\r\n    (<any>loadedFiles)._internalCount = 0;\r\n\r\n    for (let index = 0; index < 6; index++) {\r\n        this._partialLoadFile(files[index], index, loadedFiles, onfinish, onError);\r\n    }\r\n};\r\n\r\nThinEngine.prototype._cascadeLoadImgs = function (\r\n    scene: Nullable<Scene>,\r\n    texture: InternalTexture,\r\n    onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n    files: string[],\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    mimeType?: string\r\n) {\r\n    const loadedImages: HTMLImageElement[] | ImageBitmap[] = [];\r\n    (<any>loadedImages)._internalCount = 0;\r\n\r\n    for (let index = 0; index < 6; index++) {\r\n        this._partialLoadImg(files[index], index, loadedImages, scene, texture, onfinish, onError, mimeType);\r\n    }\r\n};\r\n\r\nThinEngine.prototype._partialLoadImg = function (\r\n    url: string,\r\n    index: number,\r\n    loadedImages: HTMLImageElement[] | ImageBitmap[],\r\n    scene: Nullable<Scene>,\r\n    texture: InternalTexture,\r\n    onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n    onErrorCallBack: Nullable<(message?: string, exception?: any) => void> = null,\r\n    mimeType?: string\r\n) {\r\n    const tokenPendingData = RandomGUID();\r\n\r\n    const onload = (img: HTMLImageElement | ImageBitmap) => {\r\n        loadedImages[index] = img;\r\n        (<any>loadedImages)._internalCount++;\r\n\r\n        if (scene) {\r\n            scene.removePendingData(tokenPendingData);\r\n        }\r\n\r\n        if ((<any>loadedImages)._internalCount === 6 && onfinish) {\r\n            onfinish(texture, loadedImages);\r\n        }\r\n    };\r\n\r\n    const onerror = (message?: string, exception?: any) => {\r\n        if (scene) {\r\n            scene.removePendingData(tokenPendingData);\r\n        }\r\n\r\n        if (onErrorCallBack) {\r\n            onErrorCallBack(message, exception);\r\n        }\r\n    };\r\n\r\n    LoadImage(url, onload, onerror, scene ? scene.offlineProvider : null, mimeType);\r\n    if (scene) {\r\n        scene.addPendingData(tokenPendingData);\r\n    }\r\n};\r\n\r\nThinEngine.prototype._setCubeMapTextureParams = function (texture: InternalTexture, loadMipmap: boolean, maxLevel?: number): void {\r\n    const gl = this._gl;\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, loadMipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    texture.samplingMode = loadMipmap ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : Constants.TEXTURE_LINEAR_LINEAR;\r\n\r\n    if (loadMipmap && this.getCaps().textureMaxLevel && maxLevel !== undefined && maxLevel > 0) {\r\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAX_LEVEL, maxLevel);\r\n        texture._maxLodLevel = maxLevel;\r\n    }\r\n\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n};\r\n\r\nThinEngine.prototype.createCubeTextureBase = function (\r\n    rootUrl: string,\r\n    scene: Nullable<Scene>,\r\n    files: Nullable<string[]>,\r\n    noMipmap?: boolean,\r\n    onLoad: Nullable<(data?: any) => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    format?: number,\r\n    forcedExtension: any = null,\r\n    createPolynomials: boolean = false,\r\n    lodScale: number = 0,\r\n    lodOffset: number = 0,\r\n    fallback: Nullable<InternalTexture> = null,\r\n    beforeLoadCubeDataCallback: Nullable<(texture: InternalTexture, data: ArrayBufferView | ArrayBufferView[]) => void> = null,\r\n    imageHandler: Nullable<(texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => void> = null,\r\n    useSRGBBuffer = false\r\n): InternalTexture {\r\n    const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);\r\n    texture.isCube = true;\r\n    texture.url = rootUrl;\r\n    texture.generateMipMaps = !noMipmap;\r\n    texture._lodGenerationScale = lodScale;\r\n    texture._lodGenerationOffset = lodOffset;\r\n    texture._useSRGBBuffer = !!useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU || !!noMipmap);\r\n    if (texture !== fallback) {\r\n        texture.label = rootUrl.substring(0, 60); // default label, can be overriden by the caller\r\n    }\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._extension = forcedExtension;\r\n        texture._files = files;\r\n    }\r\n\r\n    const originalRootUrl = rootUrl;\r\n    if (this._transformTextureUrl && !fallback) {\r\n        rootUrl = this._transformTextureUrl(rootUrl);\r\n    }\r\n\r\n    const rootUrlWithoutUriParams = rootUrl.split(\"?\")[0];\r\n    const lastDot = rootUrlWithoutUriParams.lastIndexOf(\".\");\r\n    const extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrlWithoutUriParams.substring(lastDot).toLowerCase() : \"\";\r\n\r\n    let loader: Nullable<IInternalTextureLoader> = null;\r\n    for (const availableLoader of ThinEngine._TextureLoaders) {\r\n        if (availableLoader.canLoad(extension)) {\r\n            loader = availableLoader;\r\n            break;\r\n        }\r\n    }\r\n\r\n    const onInternalError = (request?: IWebRequest, exception?: any) => {\r\n        if (rootUrl === originalRootUrl) {\r\n            if (onError && request) {\r\n                onError(request.status + \" \" + request.statusText, exception);\r\n            }\r\n        } else {\r\n            // fall back to the original url if the transformed url fails to load\r\n            Logger.Warn(`Failed to load ${rootUrl}, falling back to the ${originalRootUrl}`);\r\n            this.createCubeTextureBase(\r\n                originalRootUrl,\r\n                scene,\r\n                files,\r\n                !!noMipmap,\r\n                onLoad,\r\n                onError,\r\n                format,\r\n                forcedExtension,\r\n                createPolynomials,\r\n                lodScale,\r\n                lodOffset,\r\n                texture,\r\n                beforeLoadCubeDataCallback,\r\n                imageHandler,\r\n                useSRGBBuffer\r\n            );\r\n        }\r\n    };\r\n\r\n    if (loader) {\r\n        const onloaddata = (data: ArrayBufferView | ArrayBufferView[]) => {\r\n            if (beforeLoadCubeDataCallback) {\r\n                beforeLoadCubeDataCallback(texture, data);\r\n            }\r\n            loader!.loadCubeData(data, texture, createPolynomials, onLoad, onError);\r\n        };\r\n        if (files && files.length === 6) {\r\n            if (loader.supportCascades) {\r\n                this._cascadeLoadFiles(scene, (images) => onloaddata(images.map((image) => new Uint8Array(image))), files, onError);\r\n            } else {\r\n                if (onError) {\r\n                    onError(\"Textures type does not support cascades.\");\r\n                } else {\r\n                    Logger.Warn(\"Texture loader does not support cascades.\");\r\n                }\r\n            }\r\n        } else {\r\n            this._loadFile(rootUrl, (data) => onloaddata(new Uint8Array(data as ArrayBuffer)), undefined, undefined, true, onInternalError);\r\n        }\r\n    } else {\r\n        if (!files) {\r\n            throw new Error(\"Cannot load cubemap because files were not defined\");\r\n        }\r\n\r\n        this._cascadeLoadImgs(\r\n            scene,\r\n            texture,\r\n            (texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => {\r\n                if (imageHandler) {\r\n                    imageHandler(texture, imgs);\r\n                }\r\n            },\r\n            files,\r\n            onError\r\n        );\r\n    }\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.createCubeTexture = function (\r\n    rootUrl: string,\r\n    scene: Nullable<Scene>,\r\n    files: Nullable<string[]>,\r\n    noMipmap?: boolean,\r\n    onLoad: Nullable<(data?: any) => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    format?: number,\r\n    forcedExtension: any = null,\r\n    createPolynomials: boolean = false,\r\n    lodScale: number = 0,\r\n    lodOffset: number = 0,\r\n    fallback: Nullable<InternalTexture> = null,\r\n    loaderOptions?: any,\r\n    useSRGBBuffer = false\r\n): InternalTexture {\r\n    const gl = this._gl;\r\n\r\n    return this.createCubeTextureBase(\r\n        rootUrl,\r\n        scene,\r\n        files,\r\n        !!noMipmap,\r\n        onLoad,\r\n        onError,\r\n        format,\r\n        forcedExtension,\r\n        createPolynomials,\r\n        lodScale,\r\n        lodOffset,\r\n        fallback,\r\n        (texture: InternalTexture) => this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true),\r\n        (texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => {\r\n            const width = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(imgs[0].width, this._caps.maxCubemapTextureSize) : imgs[0].width;\r\n            const height = width;\r\n\r\n            const faces = [\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_X,\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_Y,\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_Z,\r\n                gl.TEXTURE_CUBE_MAP_NEGATIVE_X,\r\n                gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,\r\n                gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,\r\n            ];\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n            this._unpackFlipY(false);\r\n\r\n            const internalFormat = format ? this._getInternalFormat(format, texture._useSRGBBuffer) : texture._useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : gl.RGBA;\r\n            let texelFormat = format ? this._getInternalFormat(format) : gl.RGBA;\r\n\r\n            if (texture._useSRGBBuffer && this.webGLVersion === 1) {\r\n                texelFormat = internalFormat;\r\n            }\r\n\r\n            for (let index = 0; index < faces.length; index++) {\r\n                if (imgs[index].width !== width || imgs[index].height !== height) {\r\n                    this._prepareWorkingCanvas();\r\n\r\n                    if (!this._workingCanvas || !this._workingContext) {\r\n                        Logger.Warn(\"Cannot create canvas to resize texture.\");\r\n                        return;\r\n                    }\r\n                    this._workingCanvas.width = width;\r\n                    this._workingCanvas.height = height;\r\n\r\n                    this._workingContext.drawImage(imgs[index], 0, 0, imgs[index].width, imgs[index].height, 0, 0, width, height);\r\n                    gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, this._workingCanvas as TexImageSource);\r\n                } else {\r\n                    gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, imgs[index]);\r\n                }\r\n            }\r\n\r\n            if (!noMipmap) {\r\n                gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\r\n            }\r\n\r\n            this._setCubeMapTextureParams(texture, !noMipmap);\r\n\r\n            texture.width = width;\r\n            texture.height = height;\r\n            texture.isReady = true;\r\n            if (format) {\r\n                texture.format = format;\r\n            }\r\n\r\n            texture.onLoadedObservable.notifyObservers(texture);\r\n            texture.onLoadedObservable.clear();\r\n\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n        },\r\n        !!useSRGBBuffer\r\n    );\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}