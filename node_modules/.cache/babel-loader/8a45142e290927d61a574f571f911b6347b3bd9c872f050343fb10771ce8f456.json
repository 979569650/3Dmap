{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { Matrix, Quaternion } from \"../../Maths/math.vector.js\";\nimport { PhysicsImpostor } from \"../../Physics/v1/physicsImpostor.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { SceneLoader } from \"../../Loading/sceneLoader.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { NodeMaterial } from \"../../Materials/Node/nodeMaterial.js\";\nimport { Material } from \"../../Materials/material.js\";\nimport { CreateIcoSphere } from \"../../Meshes/Builders/icoSphereBuilder.js\";\nimport { TransformNode } from \"../../Meshes/transformNode.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\n\n/**\n * Parts of the hands divided to writs and finger names\n */\nexport var HandPart;\n(function (HandPart) {\n  /**\n   * HandPart - Wrist\n   */\n  HandPart[\"WRIST\"] = \"wrist\";\n  /**\n   * HandPart - The thumb\n   */\n  HandPart[\"THUMB\"] = \"thumb\";\n  /**\n   * HandPart - Index finger\n   */\n  HandPart[\"INDEX\"] = \"index\";\n  /**\n   * HandPart - Middle finger\n   */\n  HandPart[\"MIDDLE\"] = \"middle\";\n  /**\n   * HandPart - Ring finger\n   */\n  HandPart[\"RING\"] = \"ring\";\n  /**\n   * HandPart - Little finger\n   */\n  HandPart[\"LITTLE\"] = \"little\";\n})(HandPart || (HandPart = {}));\n/**\n * Joints of the hand as defined by the WebXR specification.\n * https://immersive-web.github.io/webxr-hand-input/#skeleton-joints-section\n */\nexport var WebXRHandJoint;\n(function (WebXRHandJoint) {\n  /** Wrist */\n  WebXRHandJoint[\"WRIST\"] = \"wrist\";\n  /** Thumb near wrist */\n  WebXRHandJoint[\"THUMB_METACARPAL\"] = \"thumb-metacarpal\";\n  /** Thumb first knuckle */\n  WebXRHandJoint[\"THUMB_PHALANX_PROXIMAL\"] = \"thumb-phalanx-proximal\";\n  /** Thumb second knuckle */\n  WebXRHandJoint[\"THUMB_PHALANX_DISTAL\"] = \"thumb-phalanx-distal\";\n  /** Thumb tip */\n  WebXRHandJoint[\"THUMB_TIP\"] = \"thumb-tip\";\n  /** Index finger near wrist */\n  WebXRHandJoint[\"INDEX_FINGER_METACARPAL\"] = \"index-finger-metacarpal\";\n  /** Index finger first knuckle */\n  WebXRHandJoint[\"INDEX_FINGER_PHALANX_PROXIMAL\"] = \"index-finger-phalanx-proximal\";\n  /** Index finger second knuckle */\n  WebXRHandJoint[\"INDEX_FINGER_PHALANX_INTERMEDIATE\"] = \"index-finger-phalanx-intermediate\";\n  /** Index finger third knuckle */\n  WebXRHandJoint[\"INDEX_FINGER_PHALANX_DISTAL\"] = \"index-finger-phalanx-distal\";\n  /** Index finger tip */\n  WebXRHandJoint[\"INDEX_FINGER_TIP\"] = \"index-finger-tip\";\n  /** Middle finger near wrist */\n  WebXRHandJoint[\"MIDDLE_FINGER_METACARPAL\"] = \"middle-finger-metacarpal\";\n  /** Middle finger first knuckle */\n  WebXRHandJoint[\"MIDDLE_FINGER_PHALANX_PROXIMAL\"] = \"middle-finger-phalanx-proximal\";\n  /** Middle finger second knuckle */\n  WebXRHandJoint[\"MIDDLE_FINGER_PHALANX_INTERMEDIATE\"] = \"middle-finger-phalanx-intermediate\";\n  /** Middle finger third knuckle */\n  WebXRHandJoint[\"MIDDLE_FINGER_PHALANX_DISTAL\"] = \"middle-finger-phalanx-distal\";\n  /** Middle finger tip */\n  WebXRHandJoint[\"MIDDLE_FINGER_TIP\"] = \"middle-finger-tip\";\n  /** Ring finger near wrist */\n  WebXRHandJoint[\"RING_FINGER_METACARPAL\"] = \"ring-finger-metacarpal\";\n  /** Ring finger first knuckle */\n  WebXRHandJoint[\"RING_FINGER_PHALANX_PROXIMAL\"] = \"ring-finger-phalanx-proximal\";\n  /** Ring finger second knuckle */\n  WebXRHandJoint[\"RING_FINGER_PHALANX_INTERMEDIATE\"] = \"ring-finger-phalanx-intermediate\";\n  /** Ring finger third knuckle */\n  WebXRHandJoint[\"RING_FINGER_PHALANX_DISTAL\"] = \"ring-finger-phalanx-distal\";\n  /** Ring finger tip */\n  WebXRHandJoint[\"RING_FINGER_TIP\"] = \"ring-finger-tip\";\n  /** Pinky finger near wrist */\n  WebXRHandJoint[\"PINKY_FINGER_METACARPAL\"] = \"pinky-finger-metacarpal\";\n  /** Pinky finger first knuckle */\n  WebXRHandJoint[\"PINKY_FINGER_PHALANX_PROXIMAL\"] = \"pinky-finger-phalanx-proximal\";\n  /** Pinky finger second knuckle */\n  WebXRHandJoint[\"PINKY_FINGER_PHALANX_INTERMEDIATE\"] = \"pinky-finger-phalanx-intermediate\";\n  /** Pinky finger third knuckle */\n  WebXRHandJoint[\"PINKY_FINGER_PHALANX_DISTAL\"] = \"pinky-finger-phalanx-distal\";\n  /** Pinky finger tip */\n  WebXRHandJoint[\"PINKY_FINGER_TIP\"] = \"pinky-finger-tip\";\n})(WebXRHandJoint || (WebXRHandJoint = {}));\nconst handJointReferenceArray = [WebXRHandJoint.WRIST, WebXRHandJoint.THUMB_METACARPAL, WebXRHandJoint.THUMB_PHALANX_PROXIMAL, WebXRHandJoint.THUMB_PHALANX_DISTAL, WebXRHandJoint.THUMB_TIP, WebXRHandJoint.INDEX_FINGER_METACARPAL, WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL, WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE, WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL, WebXRHandJoint.INDEX_FINGER_TIP, WebXRHandJoint.MIDDLE_FINGER_METACARPAL, WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL, WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE, WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL, WebXRHandJoint.MIDDLE_FINGER_TIP, WebXRHandJoint.RING_FINGER_METACARPAL, WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL, WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE, WebXRHandJoint.RING_FINGER_PHALANX_DISTAL, WebXRHandJoint.RING_FINGER_TIP, WebXRHandJoint.PINKY_FINGER_METACARPAL, WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL, WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE, WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL, WebXRHandJoint.PINKY_FINGER_TIP];\nconst handPartsDefinition = {\n  [HandPart.WRIST]: [WebXRHandJoint.WRIST],\n  [HandPart.THUMB]: [WebXRHandJoint.THUMB_METACARPAL, WebXRHandJoint.THUMB_PHALANX_PROXIMAL, WebXRHandJoint.THUMB_PHALANX_DISTAL, WebXRHandJoint.THUMB_TIP],\n  [HandPart.INDEX]: [WebXRHandJoint.INDEX_FINGER_METACARPAL, WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL, WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE, WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL, WebXRHandJoint.INDEX_FINGER_TIP],\n  [HandPart.MIDDLE]: [WebXRHandJoint.MIDDLE_FINGER_METACARPAL, WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL, WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE, WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL, WebXRHandJoint.MIDDLE_FINGER_TIP],\n  [HandPart.RING]: [WebXRHandJoint.RING_FINGER_METACARPAL, WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL, WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE, WebXRHandJoint.RING_FINGER_PHALANX_DISTAL, WebXRHandJoint.RING_FINGER_TIP],\n  [HandPart.LITTLE]: [WebXRHandJoint.PINKY_FINGER_METACARPAL, WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL, WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE, WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL, WebXRHandJoint.PINKY_FINGER_TIP]\n};\n/**\n * Representing a single hand (with its corresponding native XRHand object)\n */\nexport class WebXRHand {\n  /**\n   * Get the hand mesh.\n   */\n  get handMesh() {\n    return this._handMesh;\n  }\n  /**\n   * Get meshes of part of the hand.\n   * @param part The part of hand to get.\n   * @returns An array of meshes that correlate to the hand part requested.\n   */\n  getHandPartMeshes(part) {\n    return handPartsDefinition[part].map(name => this._jointMeshes[handJointReferenceArray.indexOf(name)]);\n  }\n  /**\n   * Retrieves a mesh linked to a named joint in the hand.\n   * @param jointName The name of the joint.\n   * @returns An AbstractMesh whose position corresponds with the joint position.\n   */\n  getJointMesh(jointName) {\n    return this._jointMeshes[handJointReferenceArray.indexOf(jointName)];\n  }\n  /**\n   * Construct a new hand object\n   * @param xrController The controller to which the hand correlates.\n   * @param _jointMeshes The meshes to be used to track the hand joints.\n   * @param _handMesh An optional hand mesh.\n   * @param rigMapping An optional rig mapping for the hand mesh.\n   *                   If not provided (but a hand mesh is provided),\n   *                   it will be assumed that the hand mesh's bones are named\n   *                   directly after the WebXR bone names.\n   * @param _leftHandedMeshes Are the hand meshes left-handed-system meshes\n   * @param _jointsInvisible Are the tracked joint meshes visible\n   * @param _jointScaleFactor Scale factor for all joint meshes\n   */\n  constructor( /** The controller to which the hand correlates. */\n  xrController, _jointMeshes, _handMesh,\n  /** An optional rig mapping for the hand mesh. If not provided (but a hand mesh is provided),\n   * it will be assumed that the hand mesh's bones are named directly after the WebXR bone names. */\n  rigMapping, _leftHandedMeshes = false, _jointsInvisible = false, _jointScaleFactor = 1) {\n    this.xrController = xrController;\n    this._jointMeshes = _jointMeshes;\n    this._handMesh = _handMesh;\n    this.rigMapping = rigMapping;\n    this._leftHandedMeshes = _leftHandedMeshes;\n    this._jointsInvisible = _jointsInvisible;\n    this._jointScaleFactor = _jointScaleFactor;\n    /**\n     * Transform nodes that will directly receive the transforms from the WebXR matrix data.\n     */\n    this._jointTransforms = new Array(handJointReferenceArray.length);\n    /**\n     * The float array that will directly receive the transform matrix data from WebXR.\n     */\n    this._jointTransformMatrices = new Float32Array(handJointReferenceArray.length * 16);\n    this._tempJointMatrix = new Matrix();\n    /**\n     * The float array that will directly receive the joint radii from WebXR.\n     */\n    this._jointRadii = new Float32Array(handJointReferenceArray.length);\n    this._scene = _jointMeshes[0].getScene();\n    // Initialize the joint transform quaternions and link the transforms to the bones.\n    for (let jointIdx = 0; jointIdx < this._jointTransforms.length; jointIdx++) {\n      const jointTransform = this._jointTransforms[jointIdx] = new TransformNode(handJointReferenceArray[jointIdx], this._scene);\n      jointTransform.rotationQuaternion = new Quaternion();\n      // Set the rotation quaternion so we can use it later for tracking.\n      _jointMeshes[jointIdx].rotationQuaternion = new Quaternion();\n    }\n    if (_handMesh) {\n      // Note that this logic needs to happen after we initialize the joint tracking transform nodes.\n      this.setHandMesh(_handMesh, rigMapping);\n    }\n    // hide the motion controller, if available/loaded\n    if (this.xrController.motionController) {\n      if (this.xrController.motionController.rootMesh) {\n        this.xrController.motionController.rootMesh.setEnabled(false);\n      } else {\n        this.xrController.motionController.onModelLoadedObservable.add(controller => {\n          if (controller.rootMesh) {\n            controller.rootMesh.setEnabled(false);\n          }\n        });\n      }\n    }\n    this.xrController.onMotionControllerInitObservable.add(motionController => {\n      motionController.onModelLoadedObservable.add(controller => {\n        if (controller.rootMesh) {\n          controller.rootMesh.setEnabled(false);\n        }\n      });\n      if (motionController.rootMesh) {\n        motionController.rootMesh.setEnabled(false);\n      }\n    });\n  }\n  /**\n   * Sets the current hand mesh to render for the WebXRHand.\n   * @param handMesh The rigged hand mesh that will be tracked to the user's hand.\n   * @param rigMapping The mapping from XRHandJoint to bone names to use with the mesh.\n   */\n  setHandMesh(handMesh, rigMapping) {\n    this._handMesh = handMesh;\n    // Avoid any strange frustum culling. We will manually control visibility via attach and detach.\n    handMesh.alwaysSelectAsActiveMesh = true;\n    handMesh.getChildMeshes().forEach(mesh => mesh.alwaysSelectAsActiveMesh = true);\n    // Link the bones in the hand mesh to the transform nodes that will be bound to the WebXR tracked joints.\n    if (this._handMesh.skeleton) {\n      const handMeshSkeleton = this._handMesh.skeleton;\n      handJointReferenceArray.forEach((jointName, jointIdx) => {\n        const jointBoneIdx = handMeshSkeleton.getBoneIndexByName(rigMapping ? rigMapping[jointName] : jointName);\n        if (jointBoneIdx !== -1) {\n          handMeshSkeleton.bones[jointBoneIdx].linkTransformNode(this._jointTransforms[jointIdx]);\n        }\n      });\n    }\n  }\n  /**\n   * Update this hand from the latest xr frame.\n   * @param xrFrame The latest frame received from WebXR.\n   * @param referenceSpace The current viewer reference space.\n   */\n  updateFromXRFrame(xrFrame, referenceSpace) {\n    const hand = this.xrController.inputSource.hand;\n    if (!hand) {\n      return;\n    }\n    // TODO: Modify webxr.d.ts to better match WebXR IDL so we don't need this any cast.\n    const anyHand = hand;\n    const jointSpaces = handJointReferenceArray.map(jointName => anyHand[jointName] || hand.get(jointName));\n    let trackingSuccessful = false;\n    if (xrFrame.fillPoses && xrFrame.fillJointRadii) {\n      trackingSuccessful = xrFrame.fillPoses(jointSpaces, referenceSpace, this._jointTransformMatrices) && xrFrame.fillJointRadii(jointSpaces, this._jointRadii);\n    } else if (xrFrame.getJointPose) {\n      trackingSuccessful = true;\n      // Warning: This codepath is slow by comparison, only here for compat.\n      for (let jointIdx = 0; jointIdx < jointSpaces.length; jointIdx++) {\n        const jointPose = xrFrame.getJointPose(jointSpaces[jointIdx], referenceSpace);\n        if (jointPose) {\n          this._jointTransformMatrices.set(jointPose.transform.matrix, jointIdx * 16);\n          this._jointRadii[jointIdx] = jointPose.radius || 0.008;\n        } else {\n          trackingSuccessful = false;\n          break;\n        }\n      }\n    }\n    if (!trackingSuccessful) {\n      return;\n    }\n    handJointReferenceArray.forEach((_jointName, jointIdx) => {\n      const jointTransform = this._jointTransforms[jointIdx];\n      Matrix.FromArrayToRef(this._jointTransformMatrices, jointIdx * 16, this._tempJointMatrix);\n      this._tempJointMatrix.decompose(undefined, jointTransform.rotationQuaternion, jointTransform.position);\n      // The radius we need to make the joint in order for it to roughly cover the joints of the user's real hand.\n      const scaledJointRadius = this._jointRadii[jointIdx] * this._jointScaleFactor;\n      const jointMesh = this._jointMeshes[jointIdx];\n      jointMesh.isVisible = !this._handMesh && !this._jointsInvisible;\n      jointMesh.position.copyFrom(jointTransform.position);\n      jointMesh.rotationQuaternion.copyFrom(jointTransform.rotationQuaternion);\n      jointMesh.scaling.setAll(scaledJointRadius);\n      // The WebXR data comes as right-handed, so we might need to do some conversions.\n      if (!this._scene.useRightHandedSystem) {\n        jointMesh.position.z *= -1;\n        jointMesh.rotationQuaternion.z *= -1;\n        jointMesh.rotationQuaternion.w *= -1;\n        if (this._leftHandedMeshes && this._handMesh) {\n          jointTransform.position.z *= -1;\n          jointTransform.rotationQuaternion.z *= -1;\n          jointTransform.rotationQuaternion.w *= -1;\n        }\n      }\n    });\n    if (this._handMesh) {\n      this._handMesh.isVisible = true;\n    }\n  }\n  /**\n   * Dispose this Hand object\n   */\n  dispose() {\n    if (this._handMesh) {\n      this._handMesh.isVisible = false;\n    }\n  }\n}\n/**\n * WebXR Hand Joint tracking feature, available for selected browsers and devices\n */\nexport class WebXRHandTracking extends WebXRAbstractFeature {\n  static _GenerateTrackedJointMeshes(featureOptions) {\n    const meshes = {};\n    [\"left\", \"right\"].map(handedness => {\n      var _a, _b, _c, _d, _e;\n      const trackedMeshes = [];\n      const originalMesh = ((_a = featureOptions.jointMeshes) === null || _a === void 0 ? void 0 : _a.sourceMesh) || CreateIcoSphere(\"jointParent\", WebXRHandTracking._ICOSPHERE_PARAMS);\n      originalMesh.isVisible = !!((_b = featureOptions.jointMeshes) === null || _b === void 0 ? void 0 : _b.keepOriginalVisible);\n      for (let i = 0; i < handJointReferenceArray.length; ++i) {\n        let newInstance = originalMesh.createInstance(`${handedness}-handJoint-${i}`);\n        if ((_c = featureOptions.jointMeshes) === null || _c === void 0 ? void 0 : _c.onHandJointMeshGenerated) {\n          const returnedMesh = featureOptions.jointMeshes.onHandJointMeshGenerated(newInstance, i, handedness);\n          if (returnedMesh) {\n            if (returnedMesh !== newInstance) {\n              newInstance.dispose();\n              newInstance = returnedMesh;\n            }\n          }\n        }\n        newInstance.isPickable = false;\n        if ((_d = featureOptions.jointMeshes) === null || _d === void 0 ? void 0 : _d.enablePhysics) {\n          const props = ((_e = featureOptions.jointMeshes) === null || _e === void 0 ? void 0 : _e.physicsProps) || {};\n          // downscale the instances so that physics will be initialized correctly\n          newInstance.scaling.setAll(0.02);\n          const type = props.impostorType !== undefined ? props.impostorType : PhysicsImpostor.SphereImpostor;\n          newInstance.physicsImpostor = new PhysicsImpostor(newInstance, type, Object.assign({\n            mass: 0\n          }, props));\n        }\n        newInstance.rotationQuaternion = new Quaternion();\n        newInstance.isVisible = false;\n        trackedMeshes.push(newInstance);\n      }\n      meshes[handedness] = trackedMeshes;\n    });\n    return {\n      left: meshes.left,\n      right: meshes.right\n    };\n  }\n  static _GenerateDefaultHandMeshesAsync(scene, options) {\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise(async resolve => {\n      var _a, _b, _c, _d, _e;\n      const riggedMeshes = {};\n      // check the cache, defensive\n      if ((_b = (_a = WebXRHandTracking._RightHandGLB) === null || _a === void 0 ? void 0 : _a.meshes[1]) === null || _b === void 0 ? void 0 : _b.isDisposed()) {\n        WebXRHandTracking._RightHandGLB = null;\n      }\n      if ((_d = (_c = WebXRHandTracking._LeftHandGLB) === null || _c === void 0 ? void 0 : _c.meshes[1]) === null || _d === void 0 ? void 0 : _d.isDisposed()) {\n        WebXRHandTracking._LeftHandGLB = null;\n      }\n      const handsDefined = !!(WebXRHandTracking._RightHandGLB && WebXRHandTracking._LeftHandGLB);\n      // load them in parallel\n      const handGLBs = await Promise.all([WebXRHandTracking._RightHandGLB || SceneLoader.ImportMeshAsync(\"\", WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL, WebXRHandTracking.DEFAULT_HAND_MODEL_RIGHT_FILENAME, scene), WebXRHandTracking._LeftHandGLB || SceneLoader.ImportMeshAsync(\"\", WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL, WebXRHandTracking.DEFAULT_HAND_MODEL_LEFT_FILENAME, scene)]);\n      WebXRHandTracking._RightHandGLB = handGLBs[0];\n      WebXRHandTracking._LeftHandGLB = handGLBs[1];\n      const handShader = new NodeMaterial(\"handShader\", scene, {\n        emitComments: false\n      });\n      await handShader.loadAsync(WebXRHandTracking.DEFAULT_HAND_MODEL_SHADER_URL);\n      // depth prepass and alpha mode\n      handShader.needDepthPrePass = true;\n      handShader.transparencyMode = Material.MATERIAL_ALPHABLEND;\n      handShader.alphaMode = 2;\n      // build node materials\n      handShader.build(false);\n      // shader\n      const handColors = Object.assign({\n        base: Color3.FromInts(116, 63, 203),\n        fresnel: Color3.FromInts(149, 102, 229),\n        fingerColor: Color3.FromInts(177, 130, 255),\n        tipFresnel: Color3.FromInts(220, 200, 255)\n      }, (_e = options === null || options === void 0 ? void 0 : options.handMeshes) === null || _e === void 0 ? void 0 : _e.customColors);\n      const handNodes = {\n        base: handShader.getBlockByName(\"baseColor\"),\n        fresnel: handShader.getBlockByName(\"fresnelColor\"),\n        fingerColor: handShader.getBlockByName(\"fingerColor\"),\n        tipFresnel: handShader.getBlockByName(\"tipFresnelColor\")\n      };\n      handNodes.base.value = handColors.base;\n      handNodes.fresnel.value = handColors.fresnel;\n      handNodes.fingerColor.value = handColors.fingerColor;\n      handNodes.tipFresnel.value = handColors.tipFresnel;\n      [\"left\", \"right\"].forEach(handedness => {\n        const handGLB = handedness == \"left\" ? WebXRHandTracking._LeftHandGLB : WebXRHandTracking._RightHandGLB;\n        if (!handGLB) {\n          // this should never happen!\n          throw new Error(\"Could not load hand model\");\n        }\n        const handMesh = handGLB.meshes[1];\n        handMesh._internalAbstractMeshDataInfo._computeBonesUsingShaders = true;\n        handMesh.material = handShader.clone(`${handedness}HandShaderClone`, true);\n        handMesh.isVisible = false;\n        riggedMeshes[handedness] = handMesh;\n        // single change for left handed systems\n        if (!handsDefined && !scene.useRightHandedSystem) {\n          handGLB.meshes[1].rotate(Axis.Y, Math.PI);\n        }\n      });\n      handShader.dispose();\n      resolve({\n        left: riggedMeshes.left,\n        right: riggedMeshes.right\n      });\n    });\n  }\n  /**\n   * Generates a mapping from XRHandJoint to bone name for the default hand mesh.\n   * @param handedness The handedness being mapped for.\n   */\n  static _GenerateDefaultHandMeshRigMapping(handedness) {\n    const H = handedness == \"right\" ? \"R\" : \"L\";\n    return {\n      [WebXRHandJoint.WRIST]: `wrist_${H}`,\n      [WebXRHandJoint.THUMB_METACARPAL]: `thumb_metacarpal_${H}`,\n      [WebXRHandJoint.THUMB_PHALANX_PROXIMAL]: `thumb_proxPhalanx_${H}`,\n      [WebXRHandJoint.THUMB_PHALANX_DISTAL]: `thumb_distPhalanx_${H}`,\n      [WebXRHandJoint.THUMB_TIP]: `thumb_tip_${H}`,\n      [WebXRHandJoint.INDEX_FINGER_METACARPAL]: `index_metacarpal_${H}`,\n      [WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL]: `index_proxPhalanx_${H}`,\n      [WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE]: `index_intPhalanx_${H}`,\n      [WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL]: `index_distPhalanx_${H}`,\n      [WebXRHandJoint.INDEX_FINGER_TIP]: `index_tip_${H}`,\n      [WebXRHandJoint.MIDDLE_FINGER_METACARPAL]: `middle_metacarpal_${H}`,\n      [WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL]: `middle_proxPhalanx_${H}`,\n      [WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE]: `middle_intPhalanx_${H}`,\n      [WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL]: `middle_distPhalanx_${H}`,\n      [WebXRHandJoint.MIDDLE_FINGER_TIP]: `middle_tip_${H}`,\n      [WebXRHandJoint.RING_FINGER_METACARPAL]: `ring_metacarpal_${H}`,\n      [WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL]: `ring_proxPhalanx_${H}`,\n      [WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE]: `ring_intPhalanx_${H}`,\n      [WebXRHandJoint.RING_FINGER_PHALANX_DISTAL]: `ring_distPhalanx_${H}`,\n      [WebXRHandJoint.RING_FINGER_TIP]: `ring_tip_${H}`,\n      [WebXRHandJoint.PINKY_FINGER_METACARPAL]: `little_metacarpal_${H}`,\n      [WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL]: `little_proxPhalanx_${H}`,\n      [WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE]: `little_intPhalanx_${H}`,\n      [WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL]: `little_distPhalanx_${H}`,\n      [WebXRHandJoint.PINKY_FINGER_TIP]: `little_tip_${H}`\n    };\n  }\n  /**\n   * Check if the needed objects are defined.\n   * This does not mean that the feature is enabled, but that the objects needed are well defined.\n   */\n  isCompatible() {\n    return typeof XRHand !== \"undefined\";\n  }\n  /**\n   * Get the hand object according to the controller id\n   * @param controllerId the controller id to which we want to get the hand\n   * @returns null if not found or the WebXRHand object if found\n   */\n  getHandByControllerId(controllerId) {\n    return this._attachedHands[controllerId];\n  }\n  /**\n   * Get a hand object according to the requested handedness\n   * @param handedness the handedness to request\n   * @returns null if not found or the WebXRHand object if found\n   */\n  getHandByHandedness(handedness) {\n    if (handedness == \"none\") {\n      return null;\n    }\n    return this._trackingHands[handedness];\n  }\n  /**\n   * Creates a new instance of the XR hand tracking feature.\n   * @param _xrSessionManager An instance of WebXRSessionManager.\n   * @param options Options to use when constructing this feature.\n   */\n  constructor(_xrSessionManager, /** Options to use when constructing this feature. */\n  options) {\n    super(_xrSessionManager);\n    this.options = options;\n    this._attachedHands = {};\n    this._trackingHands = {\n      left: null,\n      right: null\n    };\n    this._handResources = {\n      jointMeshes: null,\n      handMeshes: null,\n      rigMappings: null\n    };\n    /**\n     * This observable will notify registered observers when a new hand object was added and initialized\n     */\n    this.onHandAddedObservable = new Observable();\n    /**\n     * This observable will notify its observers right before the hand object is disposed\n     */\n    this.onHandRemovedObservable = new Observable();\n    this._attachHand = xrController => {\n      var _a, _b, _c;\n      if (!xrController.inputSource.hand || xrController.inputSource.handedness == \"none\" || !this._handResources.jointMeshes) {\n        return;\n      }\n      const handedness = xrController.inputSource.handedness;\n      const webxrHand = new WebXRHand(xrController, this._handResources.jointMeshes[handedness], this._handResources.handMeshes && this._handResources.handMeshes[handedness], this._handResources.rigMappings && this._handResources.rigMappings[handedness], (_a = this.options.handMeshes) === null || _a === void 0 ? void 0 : _a.meshesUseLeftHandedCoordinates, (_b = this.options.jointMeshes) === null || _b === void 0 ? void 0 : _b.invisible, (_c = this.options.jointMeshes) === null || _c === void 0 ? void 0 : _c.scaleFactor);\n      this._attachedHands[xrController.uniqueId] = webxrHand;\n      this._trackingHands[handedness] = webxrHand;\n      this.onHandAddedObservable.notifyObservers(webxrHand);\n    };\n    this._detachHand = xrController => {\n      this._detachHandById(xrController.uniqueId);\n    };\n    this.xrNativeFeatureName = \"hand-tracking\";\n    // Support legacy versions of the options object by copying over joint mesh properties\n    const anyOptions = options;\n    const anyJointMeshOptions = anyOptions.jointMeshes;\n    if (anyJointMeshOptions) {\n      if (typeof anyJointMeshOptions.disableDefaultHandMesh !== \"undefined\") {\n        options.handMeshes = options.handMeshes || {};\n        options.handMeshes.disableDefaultMeshes = anyJointMeshOptions.disableDefaultHandMesh;\n      }\n      if (typeof anyJointMeshOptions.handMeshes !== \"undefined\") {\n        options.handMeshes = options.handMeshes || {};\n        options.handMeshes.customMeshes = anyJointMeshOptions.handMeshes;\n      }\n      if (typeof anyJointMeshOptions.leftHandedSystemMeshes !== \"undefined\") {\n        options.handMeshes = options.handMeshes || {};\n        options.handMeshes.meshesUseLeftHandedCoordinates = anyJointMeshOptions.leftHandedSystemMeshes;\n      }\n      if (typeof anyJointMeshOptions.rigMapping !== \"undefined\") {\n        options.handMeshes = options.handMeshes || {};\n        const leftRigMapping = {};\n        const rightRigMapping = {};\n        [[anyJointMeshOptions.rigMapping.left, leftRigMapping], [anyJointMeshOptions.rigMapping.right, rightRigMapping]].forEach(rigMappingTuple => {\n          const legacyRigMapping = rigMappingTuple[0];\n          const rigMapping = rigMappingTuple[1];\n          legacyRigMapping.forEach((modelJointName, index) => {\n            rigMapping[handJointReferenceArray[index]] = modelJointName;\n          });\n        });\n        options.handMeshes.customRigMappings = {\n          left: leftRigMapping,\n          right: rightRigMapping\n        };\n      }\n    }\n  }\n  /**\n   * Attach this feature.\n   * Will usually be called by the features manager.\n   *\n   * @returns true if successful.\n   */\n  attach() {\n    var _a, _b, _c, _d;\n    if (!super.attach()) {\n      return false;\n    }\n    this._handResources = {\n      jointMeshes: WebXRHandTracking._GenerateTrackedJointMeshes(this.options),\n      handMeshes: ((_a = this.options.handMeshes) === null || _a === void 0 ? void 0 : _a.customMeshes) || null,\n      rigMappings: ((_b = this.options.handMeshes) === null || _b === void 0 ? void 0 : _b.customRigMappings) || null\n    };\n    // If they didn't supply custom meshes and are not disabling the default meshes...\n    if (!((_c = this.options.handMeshes) === null || _c === void 0 ? void 0 : _c.customMeshes) && !((_d = this.options.handMeshes) === null || _d === void 0 ? void 0 : _d.disableDefaultMeshes)) {\n      WebXRHandTracking._GenerateDefaultHandMeshesAsync(EngineStore.LastCreatedScene, this.options).then(defaultHandMeshes => {\n        var _a, _b;\n        this._handResources.handMeshes = defaultHandMeshes;\n        this._handResources.rigMappings = {\n          left: WebXRHandTracking._GenerateDefaultHandMeshRigMapping(\"left\"),\n          right: WebXRHandTracking._GenerateDefaultHandMeshRigMapping(\"right\")\n        };\n        // Apply meshes to existing hands if already tracking.\n        (_a = this._trackingHands.left) === null || _a === void 0 ? void 0 : _a.setHandMesh(this._handResources.handMeshes.left, this._handResources.rigMappings.left);\n        (_b = this._trackingHands.right) === null || _b === void 0 ? void 0 : _b.setHandMesh(this._handResources.handMeshes.right, this._handResources.rigMappings.right);\n      });\n    }\n    this.options.xrInput.controllers.forEach(this._attachHand);\n    this._addNewAttachObserver(this.options.xrInput.onControllerAddedObservable, this._attachHand);\n    this._addNewAttachObserver(this.options.xrInput.onControllerRemovedObservable, this._detachHand);\n    return true;\n  }\n  _onXRFrame(_xrFrame) {\n    var _a, _b;\n    (_a = this._trackingHands.left) === null || _a === void 0 ? void 0 : _a.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace);\n    (_b = this._trackingHands.right) === null || _b === void 0 ? void 0 : _b.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace);\n  }\n  _detachHandById(controllerId) {\n    var _a;\n    const hand = this.getHandByControllerId(controllerId);\n    if (hand) {\n      const handedness = hand.xrController.inputSource.handedness == \"left\" ? \"left\" : \"right\";\n      if (((_a = this._trackingHands[handedness]) === null || _a === void 0 ? void 0 : _a.xrController.uniqueId) === controllerId) {\n        this._trackingHands[handedness] = null;\n      }\n      this.onHandRemovedObservable.notifyObservers(hand);\n      hand.dispose();\n      delete this._attachedHands[controllerId];\n    }\n  }\n  /**\n   * Detach this feature.\n   * Will usually be called by the features manager.\n   *\n   * @returns true if successful.\n   */\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    Object.keys(this._attachedHands).forEach(uniqueId => this._detachHandById(uniqueId));\n    return true;\n  }\n  /**\n   * Dispose this feature and all of the resources attached.\n   */\n  dispose() {\n    var _a;\n    super.dispose();\n    this.onHandAddedObservable.clear();\n    this.onHandRemovedObservable.clear();\n    if (this._handResources.handMeshes && !((_a = this.options.handMeshes) === null || _a === void 0 ? void 0 : _a.customMeshes)) {\n      // this will dispose the cached meshes\n      this._handResources.handMeshes.left.dispose();\n      this._handResources.handMeshes.right.dispose();\n      // remove the cached meshes\n      WebXRHandTracking._RightHandGLB = null;\n      WebXRHandTracking._LeftHandGLB = null;\n    }\n    if (this._handResources.jointMeshes) {\n      this._handResources.jointMeshes.left.forEach(trackedMesh => trackedMesh.dispose());\n      this._handResources.jointMeshes.right.forEach(trackedMesh => trackedMesh.dispose());\n    }\n  }\n}\n/**\n * The module's name\n */\nWebXRHandTracking.Name = WebXRFeatureName.HAND_TRACKING;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRHandTracking.Version = 1;\n/** The base URL for the default hand model. */\nWebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL = \"https://assets.babylonjs.com/meshes/HandMeshes/\";\n/** The filename to use for the default right hand model. */\nWebXRHandTracking.DEFAULT_HAND_MODEL_RIGHT_FILENAME = \"r_hand_rhs.glb\";\n/** The filename to use for the default left hand model. */\nWebXRHandTracking.DEFAULT_HAND_MODEL_LEFT_FILENAME = \"l_hand_rhs.glb\";\n/** The URL pointing to the default hand model NodeMaterial shader. */\nWebXRHandTracking.DEFAULT_HAND_MODEL_SHADER_URL = \"https://assets.babylonjs.com/meshes/HandMeshes/handsShader.json\";\n// We want to use lightweight models, diameter will initially be 1 but scaled to the values returned from WebXR.\nWebXRHandTracking._ICOSPHERE_PARAMS = {\n  radius: 0.5,\n  flat: false,\n  subdivisions: 2\n};\nWebXRHandTracking._RightHandGLB = null;\nWebXRHandTracking._LeftHandGLB = null;\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRHandTracking.Name, (xrSessionManager, options) => {\n  return () => new WebXRHandTracking(xrSessionManager, options);\n}, WebXRHandTracking.Version, false);","map":{"version":3,"names":["WebXRAbstractFeature","WebXRFeatureName","WebXRFeaturesManager","Matrix","Quaternion","PhysicsImpostor","Observable","SceneLoader","Color3","NodeMaterial","Material","CreateIcoSphere","TransformNode","Axis","EngineStore","HandPart","WebXRHandJoint","handJointReferenceArray","WRIST","THUMB_METACARPAL","THUMB_PHALANX_PROXIMAL","THUMB_PHALANX_DISTAL","THUMB_TIP","INDEX_FINGER_METACARPAL","INDEX_FINGER_PHALANX_PROXIMAL","INDEX_FINGER_PHALANX_INTERMEDIATE","INDEX_FINGER_PHALANX_DISTAL","INDEX_FINGER_TIP","MIDDLE_FINGER_METACARPAL","MIDDLE_FINGER_PHALANX_PROXIMAL","MIDDLE_FINGER_PHALANX_INTERMEDIATE","MIDDLE_FINGER_PHALANX_DISTAL","MIDDLE_FINGER_TIP","RING_FINGER_METACARPAL","RING_FINGER_PHALANX_PROXIMAL","RING_FINGER_PHALANX_INTERMEDIATE","RING_FINGER_PHALANX_DISTAL","RING_FINGER_TIP","PINKY_FINGER_METACARPAL","PINKY_FINGER_PHALANX_PROXIMAL","PINKY_FINGER_PHALANX_INTERMEDIATE","PINKY_FINGER_PHALANX_DISTAL","PINKY_FINGER_TIP","handPartsDefinition","THUMB","INDEX","MIDDLE","RING","LITTLE","WebXRHand","handMesh","_handMesh","getHandPartMeshes","part","map","name","_jointMeshes","indexOf","getJointMesh","jointName","constructor","xrController","rigMapping","_leftHandedMeshes","_jointsInvisible","_jointScaleFactor","_jointTransforms","Array","length","_jointTransformMatrices","Float32Array","_tempJointMatrix","_jointRadii","_scene","getScene","jointIdx","jointTransform","rotationQuaternion","setHandMesh","motionController","rootMesh","setEnabled","onModelLoadedObservable","add","controller","onMotionControllerInitObservable","alwaysSelectAsActiveMesh","getChildMeshes","forEach","mesh","skeleton","handMeshSkeleton","jointBoneIdx","getBoneIndexByName","bones","linkTransformNode","updateFromXRFrame","xrFrame","referenceSpace","hand","inputSource","anyHand","jointSpaces","get","trackingSuccessful","fillPoses","fillJointRadii","getJointPose","jointPose","set","transform","matrix","radius","_jointName","FromArrayToRef","decompose","undefined","position","scaledJointRadius","jointMesh","isVisible","copyFrom","scaling","setAll","useRightHandedSystem","z","w","dispose","WebXRHandTracking","_GenerateTrackedJointMeshes","featureOptions","meshes","handedness","trackedMeshes","originalMesh","_a","jointMeshes","sourceMesh","_ICOSPHERE_PARAMS","_b","keepOriginalVisible","i","newInstance","createInstance","_c","onHandJointMeshGenerated","returnedMesh","isPickable","_d","enablePhysics","props","_e","physicsProps","type","impostorType","SphereImpostor","physicsImpostor","Object","assign","mass","push","left","right","_GenerateDefaultHandMeshesAsync","scene","options","Promise","resolve","riggedMeshes","_RightHandGLB","isDisposed","_LeftHandGLB","handsDefined","handGLBs","all","ImportMeshAsync","DEFAULT_HAND_MODEL_BASE_URL","DEFAULT_HAND_MODEL_RIGHT_FILENAME","DEFAULT_HAND_MODEL_LEFT_FILENAME","handShader","emitComments","loadAsync","DEFAULT_HAND_MODEL_SHADER_URL","needDepthPrePass","transparencyMode","MATERIAL_ALPHABLEND","alphaMode","build","handColors","base","FromInts","fresnel","fingerColor","tipFresnel","handMeshes","customColors","handNodes","getBlockByName","value","handGLB","Error","_internalAbstractMeshDataInfo","_computeBonesUsingShaders","material","clone","rotate","Y","Math","PI","_GenerateDefaultHandMeshRigMapping","H","isCompatible","XRHand","getHandByControllerId","controllerId","_attachedHands","getHandByHandedness","_trackingHands","_xrSessionManager","_handResources","rigMappings","onHandAddedObservable","onHandRemovedObservable","_attachHand","webxrHand","meshesUseLeftHandedCoordinates","invisible","scaleFactor","uniqueId","notifyObservers","_detachHand","_detachHandById","xrNativeFeatureName","anyOptions","anyJointMeshOptions","disableDefaultHandMesh","disableDefaultMeshes","customMeshes","leftHandedSystemMeshes","leftRigMapping","rightRigMapping","rigMappingTuple","legacyRigMapping","modelJointName","index","customRigMappings","attach","LastCreatedScene","then","defaultHandMeshes","xrInput","controllers","_addNewAttachObserver","onControllerAddedObservable","onControllerRemovedObservable","_onXRFrame","_xrFrame","detach","keys","clear","trackedMesh","Name","HAND_TRACKING","Version","flat","subdivisions","AddWebXRFeature","xrSessionManager"],"sources":["../../../../../dev/core/src/XR/features/WebXRHandTracking.ts"],"sourcesContent":["import { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport { Matrix, Quaternion } from \"../../Maths/math.vector\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { PhysicsImpostor } from \"../../Physics/v1/physicsImpostor\";\r\n\r\nimport type { IDisposable, Scene } from \"../../scene\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { InstancedMesh } from \"../../Meshes/instancedMesh\";\r\nimport type { ISceneLoaderAsyncResult } from \"../../Loading/sceneLoader\";\r\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { NodeMaterial } from \"../../Materials/Node/nodeMaterial\";\r\nimport type { InputBlock } from \"../../Materials/Node/Blocks/Input/inputBlock\";\r\nimport { Material } from \"../../Materials/material\";\r\nimport { CreateIcoSphere } from \"../../Meshes/Builders/icoSphereBuilder\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\ndeclare const XRHand: XRHand;\r\n\r\n/**\r\n * Configuration interface for the hand tracking feature\r\n */\r\nexport interface IWebXRHandTrackingOptions {\r\n    /**\r\n     * The xrInput that will be used as source for new hands\r\n     */\r\n    xrInput: WebXRInput;\r\n\r\n    /**\r\n     * Configuration object for the joint meshes.\r\n     */\r\n    jointMeshes?: {\r\n        /**\r\n         * Should the meshes created be invisible (defaults to false).\r\n         */\r\n        invisible?: boolean;\r\n        /**\r\n         * A source mesh to be used to create instances. Defaults to an icosphere with two subdivisions and smooth lighting.\r\n         * This mesh will be the source for all other (25) meshes.\r\n         * It should have the general size of a single unit, as the instances will be scaled according to the provided radius.\r\n         */\r\n        sourceMesh?: Mesh;\r\n        /**\r\n         * This function will be called after a mesh was created for a specific joint.\r\n         * Using this function you can either manipulate the instance or return a new mesh.\r\n         * When returning a new mesh the instance created before will be disposed.\r\n         * @param meshInstance An instance of the original joint mesh being used for the joint.\r\n         * @param jointId The joint's index, see https://immersive-web.github.io/webxr-hand-input/#skeleton-joints-section for more info.\r\n         * @param hand Which hand (\"left\", \"right\") the joint will be on.\r\n         */\r\n        onHandJointMeshGenerated?: (meshInstance: InstancedMesh, jointId: number, hand: XRHandedness) => AbstractMesh | undefined;\r\n        /**\r\n         * Should the source mesh stay visible (defaults to false).\r\n         */\r\n        keepOriginalVisible?: boolean;\r\n        /**\r\n         * Should each instance have its own physics impostor\r\n         */\r\n        enablePhysics?: boolean;\r\n        /**\r\n         * If enabled, override default physics properties\r\n         */\r\n        physicsProps?: { friction?: number; restitution?: number; impostorType?: number };\r\n        /**\r\n         * Scale factor for all joint meshes (defaults to 1)\r\n         */\r\n        scaleFactor?: number;\r\n    };\r\n\r\n    /**\r\n     * Configuration object for the hand meshes.\r\n     */\r\n    handMeshes?: {\r\n        /**\r\n         * Should the default hand mesh be disabled. In this case, the spheres will be visible (unless set invisible).\r\n         */\r\n        disableDefaultMeshes?: boolean;\r\n        /**\r\n         * Rigged hand meshes that will be tracked to the user's hands. This will override the default hand mesh.\r\n         */\r\n        customMeshes?: {\r\n            right: AbstractMesh;\r\n            left: AbstractMesh;\r\n        };\r\n        /**\r\n         * Are the meshes prepared for a left-handed system. Default hand meshes are right-handed.\r\n         */\r\n        meshesUseLeftHandedCoordinates?: boolean;\r\n        /**\r\n         * If a hand mesh was provided, this array will define what axis will update which node. This will override the default hand mesh\r\n         */\r\n        customRigMappings?: {\r\n            right: XRHandMeshRigMapping;\r\n            left: XRHandMeshRigMapping;\r\n        };\r\n\r\n        /**\r\n         * Override the colors of the hand meshes.\r\n         */\r\n        customColors?: {\r\n            base?: Color3;\r\n            fresnel?: Color3;\r\n            fingerColor?: Color3;\r\n            tipFresnel?: Color3;\r\n        };\r\n    };\r\n}\r\n\r\n/**\r\n * Parts of the hands divided to writs and finger names\r\n */\r\nexport enum HandPart {\r\n    /**\r\n     * HandPart - Wrist\r\n     */\r\n    WRIST = \"wrist\",\r\n    /**\r\n     * HandPart - The thumb\r\n     */\r\n    THUMB = \"thumb\",\r\n    /**\r\n     * HandPart - Index finger\r\n     */\r\n    INDEX = \"index\",\r\n    /**\r\n     * HandPart - Middle finger\r\n     */\r\n    MIDDLE = \"middle\",\r\n    /**\r\n     * HandPart - Ring finger\r\n     */\r\n    RING = \"ring\",\r\n    /**\r\n     * HandPart - Little finger\r\n     */\r\n    LITTLE = \"little\",\r\n}\r\n\r\n/**\r\n * Joints of the hand as defined by the WebXR specification.\r\n * https://immersive-web.github.io/webxr-hand-input/#skeleton-joints-section\r\n */\r\nexport enum WebXRHandJoint {\r\n    /** Wrist */\r\n    WRIST = \"wrist\",\r\n\r\n    /** Thumb near wrist */\r\n    THUMB_METACARPAL = \"thumb-metacarpal\",\r\n    /** Thumb first knuckle */\r\n    THUMB_PHALANX_PROXIMAL = \"thumb-phalanx-proximal\",\r\n    /** Thumb second knuckle */\r\n    THUMB_PHALANX_DISTAL = \"thumb-phalanx-distal\",\r\n    /** Thumb tip */\r\n    THUMB_TIP = \"thumb-tip\",\r\n\r\n    /** Index finger near wrist */\r\n    INDEX_FINGER_METACARPAL = \"index-finger-metacarpal\",\r\n    /** Index finger first knuckle */\r\n    INDEX_FINGER_PHALANX_PROXIMAL = \"index-finger-phalanx-proximal\",\r\n    /** Index finger second knuckle */\r\n    INDEX_FINGER_PHALANX_INTERMEDIATE = \"index-finger-phalanx-intermediate\",\r\n    /** Index finger third knuckle */\r\n    INDEX_FINGER_PHALANX_DISTAL = \"index-finger-phalanx-distal\",\r\n    /** Index finger tip */\r\n    INDEX_FINGER_TIP = \"index-finger-tip\",\r\n\r\n    /** Middle finger near wrist */\r\n    MIDDLE_FINGER_METACARPAL = \"middle-finger-metacarpal\",\r\n    /** Middle finger first knuckle */\r\n    MIDDLE_FINGER_PHALANX_PROXIMAL = \"middle-finger-phalanx-proximal\",\r\n    /** Middle finger second knuckle */\r\n    MIDDLE_FINGER_PHALANX_INTERMEDIATE = \"middle-finger-phalanx-intermediate\",\r\n    /** Middle finger third knuckle */\r\n    MIDDLE_FINGER_PHALANX_DISTAL = \"middle-finger-phalanx-distal\",\r\n    /** Middle finger tip */\r\n    MIDDLE_FINGER_TIP = \"middle-finger-tip\",\r\n\r\n    /** Ring finger near wrist */\r\n    RING_FINGER_METACARPAL = \"ring-finger-metacarpal\",\r\n    /** Ring finger first knuckle */\r\n    RING_FINGER_PHALANX_PROXIMAL = \"ring-finger-phalanx-proximal\",\r\n    /** Ring finger second knuckle */\r\n    RING_FINGER_PHALANX_INTERMEDIATE = \"ring-finger-phalanx-intermediate\",\r\n    /** Ring finger third knuckle */\r\n    RING_FINGER_PHALANX_DISTAL = \"ring-finger-phalanx-distal\",\r\n    /** Ring finger tip */\r\n    RING_FINGER_TIP = \"ring-finger-tip\",\r\n\r\n    /** Pinky finger near wrist */\r\n    PINKY_FINGER_METACARPAL = \"pinky-finger-metacarpal\",\r\n    /** Pinky finger first knuckle */\r\n    PINKY_FINGER_PHALANX_PROXIMAL = \"pinky-finger-phalanx-proximal\",\r\n    /** Pinky finger second knuckle */\r\n    PINKY_FINGER_PHALANX_INTERMEDIATE = \"pinky-finger-phalanx-intermediate\",\r\n    /** Pinky finger third knuckle */\r\n    PINKY_FINGER_PHALANX_DISTAL = \"pinky-finger-phalanx-distal\",\r\n    /** Pinky finger tip */\r\n    PINKY_FINGER_TIP = \"pinky-finger-tip\",\r\n}\r\n\r\n/** A type encapsulating a dictionary mapping WebXR joints to bone names in a rigged hand mesh.  */\r\nexport type XRHandMeshRigMapping = { [webXRJointName in WebXRHandJoint]: string };\r\n\r\nconst handJointReferenceArray: WebXRHandJoint[] = [\r\n    WebXRHandJoint.WRIST,\r\n    WebXRHandJoint.THUMB_METACARPAL,\r\n    WebXRHandJoint.THUMB_PHALANX_PROXIMAL,\r\n    WebXRHandJoint.THUMB_PHALANX_DISTAL,\r\n    WebXRHandJoint.THUMB_TIP,\r\n    WebXRHandJoint.INDEX_FINGER_METACARPAL,\r\n    WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL,\r\n    WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE,\r\n    WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL,\r\n    WebXRHandJoint.INDEX_FINGER_TIP,\r\n    WebXRHandJoint.MIDDLE_FINGER_METACARPAL,\r\n    WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL,\r\n    WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE,\r\n    WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL,\r\n    WebXRHandJoint.MIDDLE_FINGER_TIP,\r\n    WebXRHandJoint.RING_FINGER_METACARPAL,\r\n    WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL,\r\n    WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE,\r\n    WebXRHandJoint.RING_FINGER_PHALANX_DISTAL,\r\n    WebXRHandJoint.RING_FINGER_TIP,\r\n    WebXRHandJoint.PINKY_FINGER_METACARPAL,\r\n    WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL,\r\n    WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE,\r\n    WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL,\r\n    WebXRHandJoint.PINKY_FINGER_TIP,\r\n];\r\n\r\nconst handPartsDefinition: { [key in HandPart]: WebXRHandJoint[] } = {\r\n    [HandPart.WRIST]: [WebXRHandJoint.WRIST],\r\n    [HandPart.THUMB]: [WebXRHandJoint.THUMB_METACARPAL, WebXRHandJoint.THUMB_PHALANX_PROXIMAL, WebXRHandJoint.THUMB_PHALANX_DISTAL, WebXRHandJoint.THUMB_TIP],\r\n    [HandPart.INDEX]: [\r\n        WebXRHandJoint.INDEX_FINGER_METACARPAL,\r\n        WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL,\r\n        WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE,\r\n        WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL,\r\n        WebXRHandJoint.INDEX_FINGER_TIP,\r\n    ],\r\n    [HandPart.MIDDLE]: [\r\n        WebXRHandJoint.MIDDLE_FINGER_METACARPAL,\r\n        WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL,\r\n        WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE,\r\n        WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL,\r\n        WebXRHandJoint.MIDDLE_FINGER_TIP,\r\n    ],\r\n    [HandPart.RING]: [\r\n        WebXRHandJoint.RING_FINGER_METACARPAL,\r\n        WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL,\r\n        WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE,\r\n        WebXRHandJoint.RING_FINGER_PHALANX_DISTAL,\r\n        WebXRHandJoint.RING_FINGER_TIP,\r\n    ],\r\n    [HandPart.LITTLE]: [\r\n        WebXRHandJoint.PINKY_FINGER_METACARPAL,\r\n        WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL,\r\n        WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE,\r\n        WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL,\r\n        WebXRHandJoint.PINKY_FINGER_TIP,\r\n    ],\r\n};\r\n\r\n/**\r\n * Representing a single hand (with its corresponding native XRHand object)\r\n */\r\nexport class WebXRHand implements IDisposable {\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Transform nodes that will directly receive the transforms from the WebXR matrix data.\r\n     */\r\n    private _jointTransforms = new Array<TransformNode>(handJointReferenceArray.length);\r\n\r\n    /**\r\n     * The float array that will directly receive the transform matrix data from WebXR.\r\n     */\r\n    private _jointTransformMatrices = new Float32Array(handJointReferenceArray.length * 16);\r\n\r\n    private _tempJointMatrix = new Matrix();\r\n\r\n    /**\r\n     * The float array that will directly receive the joint radii from WebXR.\r\n     */\r\n    private _jointRadii = new Float32Array(handJointReferenceArray.length);\r\n\r\n    /**\r\n     * Get the hand mesh.\r\n     */\r\n    public get handMesh(): Nullable<AbstractMesh> {\r\n        return this._handMesh;\r\n    }\r\n\r\n    /**\r\n     * Get meshes of part of the hand.\r\n     * @param part The part of hand to get.\r\n     * @returns An array of meshes that correlate to the hand part requested.\r\n     */\r\n    public getHandPartMeshes(part: HandPart): AbstractMesh[] {\r\n        return handPartsDefinition[part].map((name) => this._jointMeshes[handJointReferenceArray.indexOf(name)]!);\r\n    }\r\n\r\n    /**\r\n     * Retrieves a mesh linked to a named joint in the hand.\r\n     * @param jointName The name of the joint.\r\n     * @returns An AbstractMesh whose position corresponds with the joint position.\r\n     */\r\n    public getJointMesh(jointName: WebXRHandJoint): AbstractMesh {\r\n        return this._jointMeshes[handJointReferenceArray.indexOf(jointName)!];\r\n    }\r\n\r\n    /**\r\n     * Construct a new hand object\r\n     * @param xrController The controller to which the hand correlates.\r\n     * @param _jointMeshes The meshes to be used to track the hand joints.\r\n     * @param _handMesh An optional hand mesh.\r\n     * @param rigMapping An optional rig mapping for the hand mesh.\r\n     *                   If not provided (but a hand mesh is provided),\r\n     *                   it will be assumed that the hand mesh's bones are named\r\n     *                   directly after the WebXR bone names.\r\n     * @param _leftHandedMeshes Are the hand meshes left-handed-system meshes\r\n     * @param _jointsInvisible Are the tracked joint meshes visible\r\n     * @param _jointScaleFactor Scale factor for all joint meshes\r\n     */\r\n    constructor(\r\n        /** The controller to which the hand correlates. */\r\n        public readonly xrController: WebXRInputSource,\r\n        private readonly _jointMeshes: AbstractMesh[],\r\n        private _handMesh: Nullable<AbstractMesh>,\r\n        /** An optional rig mapping for the hand mesh. If not provided (but a hand mesh is provided),\r\n         * it will be assumed that the hand mesh's bones are named directly after the WebXR bone names. */\r\n        readonly rigMapping: Nullable<XRHandMeshRigMapping>,\r\n        private readonly _leftHandedMeshes: boolean = false,\r\n        private readonly _jointsInvisible: boolean = false,\r\n        private readonly _jointScaleFactor: number = 1\r\n    ) {\r\n        this._scene = _jointMeshes[0].getScene();\r\n\r\n        // Initialize the joint transform quaternions and link the transforms to the bones.\r\n        for (let jointIdx = 0; jointIdx < this._jointTransforms.length; jointIdx++) {\r\n            const jointTransform = (this._jointTransforms[jointIdx] = new TransformNode(handJointReferenceArray[jointIdx], this._scene));\r\n            jointTransform.rotationQuaternion = new Quaternion();\r\n\r\n            // Set the rotation quaternion so we can use it later for tracking.\r\n            _jointMeshes[jointIdx].rotationQuaternion = new Quaternion();\r\n        }\r\n\r\n        if (_handMesh) {\r\n            // Note that this logic needs to happen after we initialize the joint tracking transform nodes.\r\n            this.setHandMesh(_handMesh, rigMapping);\r\n        }\r\n\r\n        // hide the motion controller, if available/loaded\r\n        if (this.xrController.motionController) {\r\n            if (this.xrController.motionController.rootMesh) {\r\n                this.xrController.motionController.rootMesh.setEnabled(false);\r\n            } else {\r\n                this.xrController.motionController.onModelLoadedObservable.add((controller) => {\r\n                    if (controller.rootMesh) {\r\n                        controller.rootMesh.setEnabled(false);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        this.xrController.onMotionControllerInitObservable.add((motionController) => {\r\n            motionController.onModelLoadedObservable.add((controller) => {\r\n                if (controller.rootMesh) {\r\n                    controller.rootMesh.setEnabled(false);\r\n                }\r\n            });\r\n            if (motionController.rootMesh) {\r\n                motionController.rootMesh.setEnabled(false);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the current hand mesh to render for the WebXRHand.\r\n     * @param handMesh The rigged hand mesh that will be tracked to the user's hand.\r\n     * @param rigMapping The mapping from XRHandJoint to bone names to use with the mesh.\r\n     */\r\n    public setHandMesh(handMesh: AbstractMesh, rigMapping: Nullable<XRHandMeshRigMapping>) {\r\n        this._handMesh = handMesh;\r\n\r\n        // Avoid any strange frustum culling. We will manually control visibility via attach and detach.\r\n        handMesh.alwaysSelectAsActiveMesh = true;\r\n        handMesh.getChildMeshes().forEach((mesh) => (mesh.alwaysSelectAsActiveMesh = true));\r\n\r\n        // Link the bones in the hand mesh to the transform nodes that will be bound to the WebXR tracked joints.\r\n        if (this._handMesh.skeleton) {\r\n            const handMeshSkeleton = this._handMesh.skeleton;\r\n            handJointReferenceArray.forEach((jointName, jointIdx) => {\r\n                const jointBoneIdx = handMeshSkeleton.getBoneIndexByName(rigMapping ? rigMapping[jointName] : jointName);\r\n                if (jointBoneIdx !== -1) {\r\n                    handMeshSkeleton.bones[jointBoneIdx].linkTransformNode(this._jointTransforms[jointIdx]);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update this hand from the latest xr frame.\r\n     * @param xrFrame The latest frame received from WebXR.\r\n     * @param referenceSpace The current viewer reference space.\r\n     */\r\n    public updateFromXRFrame(xrFrame: XRFrame, referenceSpace: XRReferenceSpace) {\r\n        const hand = this.xrController.inputSource.hand;\r\n        if (!hand) {\r\n            return;\r\n        }\r\n\r\n        // TODO: Modify webxr.d.ts to better match WebXR IDL so we don't need this any cast.\r\n        const anyHand: any = hand;\r\n        const jointSpaces: XRJointSpace[] = handJointReferenceArray.map((jointName) => anyHand[jointName] || hand.get(jointName));\r\n        let trackingSuccessful = false;\r\n\r\n        if (xrFrame.fillPoses && xrFrame.fillJointRadii) {\r\n            trackingSuccessful = xrFrame.fillPoses(jointSpaces, referenceSpace, this._jointTransformMatrices) && xrFrame.fillJointRadii(jointSpaces, this._jointRadii);\r\n        } else if (xrFrame.getJointPose) {\r\n            trackingSuccessful = true;\r\n            // Warning: This codepath is slow by comparison, only here for compat.\r\n            for (let jointIdx = 0; jointIdx < jointSpaces.length; jointIdx++) {\r\n                const jointPose = xrFrame.getJointPose(jointSpaces[jointIdx], referenceSpace);\r\n                if (jointPose) {\r\n                    this._jointTransformMatrices.set(jointPose.transform.matrix, jointIdx * 16);\r\n                    this._jointRadii[jointIdx] = jointPose.radius || 0.008;\r\n                } else {\r\n                    trackingSuccessful = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!trackingSuccessful) {\r\n            return;\r\n        }\r\n\r\n        handJointReferenceArray.forEach((_jointName, jointIdx) => {\r\n            const jointTransform = this._jointTransforms[jointIdx];\r\n            Matrix.FromArrayToRef(this._jointTransformMatrices, jointIdx * 16, this._tempJointMatrix);\r\n            this._tempJointMatrix.decompose(undefined, jointTransform.rotationQuaternion!, jointTransform.position);\r\n\r\n            // The radius we need to make the joint in order for it to roughly cover the joints of the user's real hand.\r\n            const scaledJointRadius = this._jointRadii[jointIdx] * this._jointScaleFactor;\r\n\r\n            const jointMesh = this._jointMeshes[jointIdx];\r\n            jointMesh.isVisible = !this._handMesh && !this._jointsInvisible;\r\n            jointMesh.position.copyFrom(jointTransform.position);\r\n            jointMesh.rotationQuaternion!.copyFrom(jointTransform.rotationQuaternion!);\r\n            jointMesh.scaling.setAll(scaledJointRadius);\r\n\r\n            // The WebXR data comes as right-handed, so we might need to do some conversions.\r\n            if (!this._scene.useRightHandedSystem) {\r\n                jointMesh.position.z *= -1;\r\n                jointMesh.rotationQuaternion!.z *= -1;\r\n                jointMesh.rotationQuaternion!.w *= -1;\r\n\r\n                if (this._leftHandedMeshes && this._handMesh) {\r\n                    jointTransform.position.z *= -1;\r\n                    jointTransform.rotationQuaternion!.z *= -1;\r\n                    jointTransform.rotationQuaternion!.w *= -1;\r\n                }\r\n            }\r\n        });\r\n\r\n        if (this._handMesh) {\r\n            this._handMesh.isVisible = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose this Hand object\r\n     */\r\n    public dispose() {\r\n        if (this._handMesh) {\r\n            this._handMesh.isVisible = false;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * WebXR Hand Joint tracking feature, available for selected browsers and devices\r\n */\r\nexport class WebXRHandTracking extends WebXRAbstractFeature {\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.HAND_TRACKING;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /** The base URL for the default hand model. */\r\n    public static DEFAULT_HAND_MODEL_BASE_URL = \"https://assets.babylonjs.com/meshes/HandMeshes/\";\r\n    /** The filename to use for the default right hand model. */\r\n    public static DEFAULT_HAND_MODEL_RIGHT_FILENAME = \"r_hand_rhs.glb\";\r\n    /** The filename to use for the default left hand model. */\r\n    public static DEFAULT_HAND_MODEL_LEFT_FILENAME = \"l_hand_rhs.glb\";\r\n    /** The URL pointing to the default hand model NodeMaterial shader. */\r\n    public static DEFAULT_HAND_MODEL_SHADER_URL = \"https://assets.babylonjs.com/meshes/HandMeshes/handsShader.json\";\r\n\r\n    // We want to use lightweight models, diameter will initially be 1 but scaled to the values returned from WebXR.\r\n    private static readonly _ICOSPHERE_PARAMS = { radius: 0.5, flat: false, subdivisions: 2 };\r\n\r\n    private static _RightHandGLB: Nullable<ISceneLoaderAsyncResult> = null;\r\n    private static _LeftHandGLB: Nullable<ISceneLoaderAsyncResult> = null;\r\n\r\n    private static _GenerateTrackedJointMeshes(featureOptions: IWebXRHandTrackingOptions): { left: AbstractMesh[]; right: AbstractMesh[] } {\r\n        const meshes: { [handedness: string]: AbstractMesh[] } = {};\r\n        [\"left\" as XRHandedness, \"right\" as XRHandedness].map((handedness) => {\r\n            const trackedMeshes = [];\r\n            const originalMesh = featureOptions.jointMeshes?.sourceMesh || CreateIcoSphere(\"jointParent\", WebXRHandTracking._ICOSPHERE_PARAMS);\r\n            originalMesh.isVisible = !!featureOptions.jointMeshes?.keepOriginalVisible;\r\n            for (let i = 0; i < handJointReferenceArray.length; ++i) {\r\n                let newInstance: AbstractMesh = originalMesh.createInstance(`${handedness}-handJoint-${i}`);\r\n                if (featureOptions.jointMeshes?.onHandJointMeshGenerated) {\r\n                    const returnedMesh = featureOptions.jointMeshes.onHandJointMeshGenerated(newInstance as InstancedMesh, i, handedness);\r\n                    if (returnedMesh) {\r\n                        if (returnedMesh !== newInstance) {\r\n                            newInstance.dispose();\r\n                            newInstance = returnedMesh;\r\n                        }\r\n                    }\r\n                }\r\n                newInstance.isPickable = false;\r\n                if (featureOptions.jointMeshes?.enablePhysics) {\r\n                    const props = featureOptions.jointMeshes?.physicsProps || {};\r\n                    // downscale the instances so that physics will be initialized correctly\r\n                    newInstance.scaling.setAll(0.02);\r\n                    const type = props.impostorType !== undefined ? props.impostorType : PhysicsImpostor.SphereImpostor;\r\n                    newInstance.physicsImpostor = new PhysicsImpostor(newInstance, type, { mass: 0, ...props });\r\n                }\r\n                newInstance.rotationQuaternion = new Quaternion();\r\n                newInstance.isVisible = false;\r\n                trackedMeshes.push(newInstance);\r\n            }\r\n\r\n            meshes[handedness] = trackedMeshes;\r\n        });\r\n        return { left: meshes.left, right: meshes.right };\r\n    }\r\n\r\n    private static _GenerateDefaultHandMeshesAsync(scene: Scene, options?: IWebXRHandTrackingOptions): Promise<{ left: AbstractMesh; right: AbstractMesh }> {\r\n        // eslint-disable-next-line no-async-promise-executor\r\n        return new Promise(async (resolve) => {\r\n            const riggedMeshes: { [handedness: string]: AbstractMesh } = {};\r\n            // check the cache, defensive\r\n            if (WebXRHandTracking._RightHandGLB?.meshes[1]?.isDisposed()) {\r\n                WebXRHandTracking._RightHandGLB = null;\r\n            }\r\n            if (WebXRHandTracking._LeftHandGLB?.meshes[1]?.isDisposed()) {\r\n                WebXRHandTracking._LeftHandGLB = null;\r\n            }\r\n\r\n            const handsDefined = !!(WebXRHandTracking._RightHandGLB && WebXRHandTracking._LeftHandGLB);\r\n            // load them in parallel\r\n            const handGLBs = await Promise.all([\r\n                WebXRHandTracking._RightHandGLB ||\r\n                    SceneLoader.ImportMeshAsync(\"\", WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL, WebXRHandTracking.DEFAULT_HAND_MODEL_RIGHT_FILENAME, scene),\r\n                WebXRHandTracking._LeftHandGLB ||\r\n                    SceneLoader.ImportMeshAsync(\"\", WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL, WebXRHandTracking.DEFAULT_HAND_MODEL_LEFT_FILENAME, scene),\r\n            ]);\r\n            WebXRHandTracking._RightHandGLB = handGLBs[0];\r\n            WebXRHandTracking._LeftHandGLB = handGLBs[1];\r\n\r\n            const handShader = new NodeMaterial(\"handShader\", scene, { emitComments: false });\r\n            await handShader.loadAsync(WebXRHandTracking.DEFAULT_HAND_MODEL_SHADER_URL);\r\n\r\n            // depth prepass and alpha mode\r\n            handShader.needDepthPrePass = true;\r\n            handShader.transparencyMode = Material.MATERIAL_ALPHABLEND;\r\n            handShader.alphaMode = Constants.ALPHA_COMBINE;\r\n\r\n            // build node materials\r\n            handShader.build(false);\r\n\r\n            // shader\r\n            const handColors = {\r\n                base: Color3.FromInts(116, 63, 203),\r\n                fresnel: Color3.FromInts(149, 102, 229),\r\n                fingerColor: Color3.FromInts(177, 130, 255),\r\n                tipFresnel: Color3.FromInts(220, 200, 255),\r\n                ...options?.handMeshes?.customColors,\r\n            };\r\n\r\n            const handNodes = {\r\n                base: handShader.getBlockByName(\"baseColor\") as InputBlock,\r\n                fresnel: handShader.getBlockByName(\"fresnelColor\") as InputBlock,\r\n                fingerColor: handShader.getBlockByName(\"fingerColor\") as InputBlock,\r\n                tipFresnel: handShader.getBlockByName(\"tipFresnelColor\") as InputBlock,\r\n            };\r\n\r\n            handNodes.base.value = handColors.base;\r\n            handNodes.fresnel.value = handColors.fresnel;\r\n            handNodes.fingerColor.value = handColors.fingerColor;\r\n            handNodes.tipFresnel.value = handColors.tipFresnel;\r\n\r\n            [\"left\", \"right\"].forEach((handedness) => {\r\n                const handGLB = handedness == \"left\" ? WebXRHandTracking._LeftHandGLB : WebXRHandTracking._RightHandGLB;\r\n                if (!handGLB) {\r\n                    // this should never happen!\r\n                    throw new Error(\"Could not load hand model\");\r\n                }\r\n                const handMesh = handGLB.meshes[1];\r\n                handMesh._internalAbstractMeshDataInfo._computeBonesUsingShaders = true;\r\n                handMesh.material = handShader.clone(`${handedness}HandShaderClone`, true);\r\n                handMesh.isVisible = false;\r\n\r\n                riggedMeshes[handedness] = handMesh;\r\n\r\n                // single change for left handed systems\r\n                if (!handsDefined && !scene.useRightHandedSystem) {\r\n                    handGLB.meshes[1].rotate(Axis.Y, Math.PI);\r\n                }\r\n            });\r\n\r\n            handShader.dispose();\r\n            resolve({ left: riggedMeshes.left, right: riggedMeshes.right });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Generates a mapping from XRHandJoint to bone name for the default hand mesh.\r\n     * @param handedness The handedness being mapped for.\r\n     */\r\n    private static _GenerateDefaultHandMeshRigMapping(handedness: XRHandedness): XRHandMeshRigMapping {\r\n        const H = handedness == \"right\" ? \"R\" : \"L\";\r\n        return {\r\n            [WebXRHandJoint.WRIST]: `wrist_${H}`,\r\n            [WebXRHandJoint.THUMB_METACARPAL]: `thumb_metacarpal_${H}`,\r\n            [WebXRHandJoint.THUMB_PHALANX_PROXIMAL]: `thumb_proxPhalanx_${H}`,\r\n            [WebXRHandJoint.THUMB_PHALANX_DISTAL]: `thumb_distPhalanx_${H}`,\r\n            [WebXRHandJoint.THUMB_TIP]: `thumb_tip_${H}`,\r\n            [WebXRHandJoint.INDEX_FINGER_METACARPAL]: `index_metacarpal_${H}`,\r\n            [WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL]: `index_proxPhalanx_${H}`,\r\n            [WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE]: `index_intPhalanx_${H}`,\r\n            [WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL]: `index_distPhalanx_${H}`,\r\n            [WebXRHandJoint.INDEX_FINGER_TIP]: `index_tip_${H}`,\r\n            [WebXRHandJoint.MIDDLE_FINGER_METACARPAL]: `middle_metacarpal_${H}`,\r\n            [WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL]: `middle_proxPhalanx_${H}`,\r\n            [WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE]: `middle_intPhalanx_${H}`,\r\n            [WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL]: `middle_distPhalanx_${H}`,\r\n            [WebXRHandJoint.MIDDLE_FINGER_TIP]: `middle_tip_${H}`,\r\n            [WebXRHandJoint.RING_FINGER_METACARPAL]: `ring_metacarpal_${H}`,\r\n            [WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL]: `ring_proxPhalanx_${H}`,\r\n            [WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE]: `ring_intPhalanx_${H}`,\r\n            [WebXRHandJoint.RING_FINGER_PHALANX_DISTAL]: `ring_distPhalanx_${H}`,\r\n            [WebXRHandJoint.RING_FINGER_TIP]: `ring_tip_${H}`,\r\n            [WebXRHandJoint.PINKY_FINGER_METACARPAL]: `little_metacarpal_${H}`,\r\n            [WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL]: `little_proxPhalanx_${H}`,\r\n            [WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE]: `little_intPhalanx_${H}`,\r\n            [WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL]: `little_distPhalanx_${H}`,\r\n            [WebXRHandJoint.PINKY_FINGER_TIP]: `little_tip_${H}`,\r\n        };\r\n    }\r\n\r\n    private _attachedHands: {\r\n        [uniqueId: string]: WebXRHand;\r\n    } = {};\r\n\r\n    private _trackingHands: {\r\n        left: Nullable<WebXRHand>;\r\n        right: Nullable<WebXRHand>;\r\n    } = { left: null, right: null };\r\n\r\n    private _handResources: {\r\n        jointMeshes: Nullable<{ left: AbstractMesh[]; right: AbstractMesh[] }>;\r\n        handMeshes: Nullable<{ left: AbstractMesh; right: AbstractMesh }>;\r\n        rigMappings: Nullable<{ left: XRHandMeshRigMapping; right: XRHandMeshRigMapping }>;\r\n    } = { jointMeshes: null, handMeshes: null, rigMappings: null };\r\n\r\n    /**\r\n     * This observable will notify registered observers when a new hand object was added and initialized\r\n     */\r\n    public onHandAddedObservable: Observable<WebXRHand> = new Observable();\r\n    /**\r\n     * This observable will notify its observers right before the hand object is disposed\r\n     */\r\n    public onHandRemovedObservable: Observable<WebXRHand> = new Observable();\r\n\r\n    /**\r\n     * Check if the needed objects are defined.\r\n     * This does not mean that the feature is enabled, but that the objects needed are well defined.\r\n     */\r\n    public isCompatible(): boolean {\r\n        return typeof XRHand !== \"undefined\";\r\n    }\r\n\r\n    /**\r\n     * Get the hand object according to the controller id\r\n     * @param controllerId the controller id to which we want to get the hand\r\n     * @returns null if not found or the WebXRHand object if found\r\n     */\r\n    public getHandByControllerId(controllerId: string): Nullable<WebXRHand> {\r\n        return this._attachedHands[controllerId];\r\n    }\r\n\r\n    /**\r\n     * Get a hand object according to the requested handedness\r\n     * @param handedness the handedness to request\r\n     * @returns null if not found or the WebXRHand object if found\r\n     */\r\n    public getHandByHandedness(handedness: XRHandedness): Nullable<WebXRHand> {\r\n        if (handedness == \"none\") {\r\n            return null;\r\n        }\r\n        return this._trackingHands[handedness];\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of the XR hand tracking feature.\r\n     * @param _xrSessionManager An instance of WebXRSessionManager.\r\n     * @param options Options to use when constructing this feature.\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        /** Options to use when constructing this feature. */\r\n        public readonly options: IWebXRHandTrackingOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"hand-tracking\";\r\n\r\n        // Support legacy versions of the options object by copying over joint mesh properties\r\n        const anyOptions = options as any;\r\n        const anyJointMeshOptions = anyOptions.jointMeshes;\r\n        if (anyJointMeshOptions) {\r\n            if (typeof anyJointMeshOptions.disableDefaultHandMesh !== \"undefined\") {\r\n                options.handMeshes = options.handMeshes || {};\r\n                options.handMeshes.disableDefaultMeshes = anyJointMeshOptions.disableDefaultHandMesh;\r\n            }\r\n            if (typeof anyJointMeshOptions.handMeshes !== \"undefined\") {\r\n                options.handMeshes = options.handMeshes || {};\r\n                options.handMeshes.customMeshes = anyJointMeshOptions.handMeshes;\r\n            }\r\n            if (typeof anyJointMeshOptions.leftHandedSystemMeshes !== \"undefined\") {\r\n                options.handMeshes = options.handMeshes || {};\r\n                options.handMeshes.meshesUseLeftHandedCoordinates = anyJointMeshOptions.leftHandedSystemMeshes;\r\n            }\r\n            if (typeof anyJointMeshOptions.rigMapping !== \"undefined\") {\r\n                options.handMeshes = options.handMeshes || {};\r\n                const leftRigMapping = {};\r\n                const rightRigMapping = {};\r\n                [\r\n                    [anyJointMeshOptions.rigMapping.left, leftRigMapping],\r\n                    [anyJointMeshOptions.rigMapping.right, rightRigMapping],\r\n                ].forEach((rigMappingTuple) => {\r\n                    const legacyRigMapping = rigMappingTuple[0] as string[];\r\n                    const rigMapping = rigMappingTuple[1] as XRHandMeshRigMapping;\r\n                    legacyRigMapping.forEach((modelJointName, index) => {\r\n                        rigMapping[handJointReferenceArray[index]] = modelJointName;\r\n                    });\r\n                });\r\n                options.handMeshes.customRigMappings = {\r\n                    left: leftRigMapping as XRHandMeshRigMapping,\r\n                    right: rightRigMapping as XRHandMeshRigMapping,\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach this feature.\r\n     * Will usually be called by the features manager.\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        this._handResources = {\r\n            jointMeshes: WebXRHandTracking._GenerateTrackedJointMeshes(this.options),\r\n            handMeshes: this.options.handMeshes?.customMeshes || null,\r\n            rigMappings: this.options.handMeshes?.customRigMappings || null,\r\n        };\r\n\r\n        // If they didn't supply custom meshes and are not disabling the default meshes...\r\n        if (!this.options.handMeshes?.customMeshes && !this.options.handMeshes?.disableDefaultMeshes) {\r\n            WebXRHandTracking._GenerateDefaultHandMeshesAsync(EngineStore.LastCreatedScene!, this.options).then((defaultHandMeshes) => {\r\n                this._handResources.handMeshes = defaultHandMeshes;\r\n                this._handResources.rigMappings = {\r\n                    left: WebXRHandTracking._GenerateDefaultHandMeshRigMapping(\"left\"),\r\n                    right: WebXRHandTracking._GenerateDefaultHandMeshRigMapping(\"right\"),\r\n                };\r\n\r\n                // Apply meshes to existing hands if already tracking.\r\n                this._trackingHands.left?.setHandMesh(this._handResources.handMeshes.left, this._handResources.rigMappings.left);\r\n                this._trackingHands.right?.setHandMesh(this._handResources.handMeshes.right, this._handResources.rigMappings.right);\r\n            });\r\n        }\r\n\r\n        this.options.xrInput.controllers.forEach(this._attachHand);\r\n        this._addNewAttachObserver(this.options.xrInput.onControllerAddedObservable, this._attachHand);\r\n        this._addNewAttachObserver(this.options.xrInput.onControllerRemovedObservable, this._detachHand);\r\n\r\n        return true;\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame): void {\r\n        this._trackingHands.left?.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace);\r\n        this._trackingHands.right?.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace);\r\n    }\r\n\r\n    private _attachHand = (xrController: WebXRInputSource) => {\r\n        if (!xrController.inputSource.hand || xrController.inputSource.handedness == \"none\" || !this._handResources.jointMeshes) {\r\n            return;\r\n        }\r\n\r\n        const handedness = xrController.inputSource.handedness;\r\n        const webxrHand = new WebXRHand(\r\n            xrController,\r\n            this._handResources.jointMeshes[handedness],\r\n            this._handResources.handMeshes && this._handResources.handMeshes[handedness],\r\n            this._handResources.rigMappings && this._handResources.rigMappings[handedness],\r\n            this.options.handMeshes?.meshesUseLeftHandedCoordinates,\r\n            this.options.jointMeshes?.invisible,\r\n            this.options.jointMeshes?.scaleFactor\r\n        );\r\n\r\n        this._attachedHands[xrController.uniqueId] = webxrHand;\r\n        this._trackingHands[handedness] = webxrHand;\r\n\r\n        this.onHandAddedObservable.notifyObservers(webxrHand);\r\n    };\r\n\r\n    private _detachHandById(controllerId: string) {\r\n        const hand = this.getHandByControllerId(controllerId);\r\n        if (hand) {\r\n            const handedness = hand.xrController.inputSource.handedness == \"left\" ? \"left\" : \"right\";\r\n            if (this._trackingHands[handedness]?.xrController.uniqueId === controllerId) {\r\n                this._trackingHands[handedness] = null;\r\n            }\r\n            this.onHandRemovedObservable.notifyObservers(hand);\r\n            hand.dispose();\r\n            delete this._attachedHands[controllerId];\r\n        }\r\n    }\r\n\r\n    private _detachHand = (xrController: WebXRInputSource) => {\r\n        this._detachHandById(xrController.uniqueId);\r\n    };\r\n\r\n    /**\r\n     * Detach this feature.\r\n     * Will usually be called by the features manager.\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._attachedHands).forEach((uniqueId) => this._detachHandById(uniqueId));\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached.\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this.onHandAddedObservable.clear();\r\n        this.onHandRemovedObservable.clear();\r\n\r\n        if (this._handResources.handMeshes && !this.options.handMeshes?.customMeshes) {\r\n            // this will dispose the cached meshes\r\n            this._handResources.handMeshes.left.dispose();\r\n            this._handResources.handMeshes.right.dispose();\r\n            // remove the cached meshes\r\n            WebXRHandTracking._RightHandGLB = null;\r\n            WebXRHandTracking._LeftHandGLB = null;\r\n        }\r\n\r\n        if (this._handResources.jointMeshes) {\r\n            this._handResources.jointMeshes.left.forEach((trackedMesh) => trackedMesh.dispose());\r\n            this._handResources.jointMeshes.right.forEach((trackedMesh) => trackedMesh.dispose());\r\n        }\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRHandTracking.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRHandTracking(xrSessionManager, options);\r\n    },\r\n    WebXRHandTracking.Version,\r\n    false\r\n);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}