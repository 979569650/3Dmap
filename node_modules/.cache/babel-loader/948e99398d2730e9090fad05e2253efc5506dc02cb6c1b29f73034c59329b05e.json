{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../../tslib.es6.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { serialize, SerializationHelper } from \"../../../Misc/decorators.js\";\nimport { Vector3, Matrix, Quaternion, TmpVectors } from \"../../../Maths/math.vector.js\";\nimport { PostProcess } from \"../../postProcess.js\";\nimport { PostProcessRenderPipeline } from \"../postProcessRenderPipeline.js\";\nimport { PostProcessRenderEffect } from \"../postProcessRenderEffect.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { ScreenSpaceReflections2Configuration } from \"../../../Rendering/screenSpaceReflections2Configuration.js\";\nimport { GeometryBufferRenderer } from \"../../../Rendering/geometryBufferRenderer.js\";\nimport { DepthRenderer } from \"../../../Rendering/depthRenderer.js\";\nimport \"../postProcessRenderPipelineManagerSceneComponent.js\";\nimport \"../../../Shaders/screenSpaceReflection2.fragment.js\";\nimport \"../../../Shaders/screenSpaceReflection2Blur.fragment.js\";\nimport \"../../../Shaders/screenSpaceReflection2BlurCombiner.fragment.js\";\nconst trs = Matrix.Compose(new Vector3(0.5, 0.5, 0.5), Quaternion.Identity(), new Vector3(0.5, 0.5, 0.5));\nconst trsWebGPU = Matrix.Compose(new Vector3(0.5, 0.5, 1), Quaternion.Identity(), new Vector3(0.5, 0.5, 0));\n/**\n * Render pipeline to produce Screen Space Reflections (SSR) effect\n *\n * References:\n *   Screen Space Ray Tracing:\n *     - http://casual-effects.blogspot.com/2014/08/screen-space-ray-tracing.html\n *     - https://sourceforge.net/p/g3d/code/HEAD/tree/G3D10/data-files/shader/screenSpaceRayTrace.glsl\n *     - https://github.com/kode80/kode80SSR\n *   SSR:\n *     - general tips: https://sakibsaikia.github.io/graphics/2016/12/26/Screen-Space-Reflection-in-Killing-Floor-2.html\n *     - computation of blur radius from roughness and distance: https://github.com/godotengine/godot/blob/master/servers/rendering/renderer_rd/shaders/effects/screen_space_reflection.glsl\n *     - blur and usage of back depth buffer: https://github.com/kode80/kode80SSR\n */\nexport class SSRRenderingPipeline extends PostProcessRenderPipeline {\n  /**\n   * MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)\n   */\n  set samples(sampleCount) {\n    if (this._samples === sampleCount) {\n      return;\n    }\n    this._samples = sampleCount;\n    this._buildPipeline();\n  }\n  get samples() {\n    return this._samples;\n  }\n  /**\n   * Gets or sets the minimum value for one of the reflectivity component of the material to consider it for SSR (default: 0.04).\n   * If all r/g/b components of the reflectivity is below or equal this value, the pixel will not be considered reflective and SSR won't be applied.\n   */\n  get reflectivityThreshold() {\n    return this._reflectivityThreshold;\n  }\n  set reflectivityThreshold(threshold) {\n    if (threshold === this._reflectivityThreshold) {\n      return;\n    }\n    if (threshold === 0 && this._reflectivityThreshold !== 0 || threshold !== 0 && this._reflectivityThreshold === 0) {\n      this._reflectivityThreshold = threshold;\n      this._buildPipeline();\n    } else {\n      this._reflectivityThreshold = threshold;\n    }\n  }\n  /**\n   * Gets or sets the downsample factor used to reduce the size of the texture used to compute the SSR contribution (default: 0).\n   * Use 0 to render the SSR contribution at full resolution, 1 to render at half resolution, 2 to render at 1/3 resolution, etc.\n   * Note that it is used only when blurring is enabled (blurDispersionStrength \\> 0), because in that mode the SSR contribution is generated in a separate texture.\n   */\n  get ssrDownsample() {\n    return this._ssrDownsample;\n  }\n  set ssrDownsample(downsample) {\n    if (downsample === this._ssrDownsample) {\n      return;\n    }\n    this._ssrDownsample = downsample;\n    this._buildPipeline();\n  }\n  /**\n   * Gets or sets the blur dispersion strength. Set this value to 0 to disable blurring (default: 0.05)\n   * The reflections are blurred based on the roughness of the surface and the distance between the pixel shaded and the reflected pixel: the higher the distance the more blurry the reflection is.\n   * blurDispersionStrength allows to increase or decrease this effect.\n   */\n  get blurDispersionStrength() {\n    return this._blurDispersionStrength;\n  }\n  set blurDispersionStrength(strength) {\n    if (strength === this._blurDispersionStrength) {\n      return;\n    }\n    const rebuild = strength === 0 && this._blurDispersionStrength !== 0 || strength !== 0 && this._blurDispersionStrength === 0;\n    this._blurDispersionStrength = strength;\n    if (rebuild) {\n      this._buildPipeline();\n    }\n  }\n  _useBlur() {\n    return this._blurDispersionStrength > 0;\n  }\n  /**\n   * Gets or sets the downsample factor used to reduce the size of the textures used to blur the reflection effect (default: 0).\n   * Use 0 to blur at full resolution, 1 to render at half resolution, 2 to render at 1/3 resolution, etc.\n   */\n  get blurDownsample() {\n    return this._blurDownsample;\n  }\n  set blurDownsample(downsample) {\n    if (downsample === this._blurDownsample) {\n      return;\n    }\n    this._blurDownsample = downsample;\n    this._buildPipeline();\n  }\n  /**\n   * Gets or sets whether or not smoothing reflections is enabled (default: false)\n   * Enabling smoothing will require more GPU power.\n   * Note that this setting has no effect if step = 1: it's only used if step \\> 1.\n   */\n  get enableSmoothReflections() {\n    return this._enableSmoothReflections;\n  }\n  set enableSmoothReflections(enabled) {\n    if (enabled === this._enableSmoothReflections) {\n      return;\n    }\n    this._enableSmoothReflections = enabled;\n    this._updateEffectDefines();\n  }\n  /**\n   * Gets or sets the environment cube texture used to define the reflection when the reflected rays of SSR leave the view space or when the maxDistance/maxSteps is reached.\n   */\n  get environmentTexture() {\n    return this._environmentTexture;\n  }\n  set environmentTexture(texture) {\n    this._environmentTexture = texture;\n    this._updateEffectDefines();\n  }\n  /**\n   * Gets or sets the boolean defining if the environment texture is a standard cubemap (false) or a probe (true). Default value is false.\n   * Note: a probe cube texture is treated differently than an ordinary cube texture because the Y axis is reversed.\n   */\n  get environmentTextureIsProbe() {\n    return this._environmentTextureIsProbe;\n  }\n  set environmentTextureIsProbe(isProbe) {\n    this._environmentTextureIsProbe = isProbe;\n    this._updateEffectDefines();\n  }\n  /**\n   * Gets or sets a boolean indicating if the reflections should be attenuated at the screen borders (default: true).\n   */\n  get attenuateScreenBorders() {\n    return this._attenuateScreenBorders;\n  }\n  set attenuateScreenBorders(attenuate) {\n    if (this._attenuateScreenBorders === attenuate) {\n      return;\n    }\n    this._attenuateScreenBorders = attenuate;\n    this._updateEffectDefines();\n  }\n  /**\n   * Gets or sets a boolean indicating if the reflections should be attenuated according to the distance of the intersection (default: true).\n   */\n  get attenuateIntersectionDistance() {\n    return this._attenuateIntersectionDistance;\n  }\n  set attenuateIntersectionDistance(attenuate) {\n    if (this._attenuateIntersectionDistance === attenuate) {\n      return;\n    }\n    this._attenuateIntersectionDistance = attenuate;\n    this._updateEffectDefines();\n  }\n  /**\n   * Gets or sets a boolean indicating if the reflections should be attenuated according to the number of iterations performed to find the intersection (default: true).\n   */\n  get attenuateIntersectionIterations() {\n    return this._attenuateIntersectionIterations;\n  }\n  set attenuateIntersectionIterations(attenuate) {\n    if (this._attenuateIntersectionIterations === attenuate) {\n      return;\n    }\n    this._attenuateIntersectionIterations = attenuate;\n    this._updateEffectDefines();\n  }\n  /**\n   * Gets or sets a boolean indicating if the reflections should be attenuated when the reflection ray is facing the camera (the view direction) (default: false).\n   */\n  get attenuateFacingCamera() {\n    return this._attenuateFacingCamera;\n  }\n  set attenuateFacingCamera(attenuate) {\n    if (this._attenuateFacingCamera === attenuate) {\n      return;\n    }\n    this._attenuateFacingCamera = attenuate;\n    this._updateEffectDefines();\n  }\n  /**\n   * Gets or sets a boolean indicating if the backface reflections should be attenuated (default: false).\n   */\n  get attenuateBackfaceReflection() {\n    return this._attenuateBackfaceReflection;\n  }\n  set attenuateBackfaceReflection(attenuate) {\n    if (this._attenuateBackfaceReflection === attenuate) {\n      return;\n    }\n    this._attenuateBackfaceReflection = attenuate;\n    this._updateEffectDefines();\n  }\n  /**\n   * Gets or sets a boolean indicating if the ray should be clipped to the frustum (default: true).\n   * You can try to set this parameter to false to save some performances: it may produce some artefacts in some cases, but generally they won't really be visible\n   */\n  get clipToFrustum() {\n    return this._clipToFrustum;\n  }\n  set clipToFrustum(clip) {\n    if (this._clipToFrustum === clip) {\n      return;\n    }\n    this._clipToFrustum = clip;\n    this._updateEffectDefines();\n  }\n  /**\n   * Gets or sets a boolean indicating whether the blending between the current color pixel and the reflection color should be done with a Fresnel coefficient (default: false).\n   * It is more physically accurate to use the Fresnel coefficient (otherwise it uses the reflectivity of the material for blending), but it is also more expensive when you use blur (when blurDispersionStrength \\> 0).\n   */\n  get useFresnel() {\n    return this._useFresnel;\n  }\n  set useFresnel(fresnel) {\n    if (this._useFresnel === fresnel) {\n      return;\n    }\n    this._useFresnel = fresnel;\n    this._buildPipeline();\n  }\n  /**\n   * Gets or sets a boolean defining if geometry thickness should be computed automatically (default: false).\n   * When enabled, a depth renderer is created which will render the back faces of the scene to a depth texture (meaning additional work for the GPU).\n   * In that mode, the \"thickness\" property is still used as an offset to compute the ray intersection, but you can typically use a much lower\n   * value than when enableAutomaticThicknessComputation is false (it's even possible to use a value of 0 when using low values for \"step\")\n   * Note that for performance reasons, this option will only apply to the first camera to which the the rendering pipeline is attached!\n   */\n  get enableAutomaticThicknessComputation() {\n    return this._enableAutomaticThicknessComputation;\n  }\n  set enableAutomaticThicknessComputation(automatic) {\n    if (this._enableAutomaticThicknessComputation === automatic) {\n      return;\n    }\n    this._enableAutomaticThicknessComputation = automatic;\n    this._buildPipeline();\n  }\n  /**\n   * Gets the depth renderer used to render the back faces of the scene to a depth texture.\n   */\n  get backfaceDepthRenderer() {\n    return this._depthRenderer;\n  }\n  /**\n   * Gets or sets the downsample factor (default: 0) used to create the backface depth texture - used only if enableAutomaticThicknessComputation = true.\n   * Use 0 to render the depth at full resolution, 1 to render at half resolution, 2 to render at 1/4 resolution, etc.\n   * Note that you will get rendering artefacts when using a value different from 0: it's a tradeoff between image quality and performances.\n   */\n  get backfaceDepthTextureDownsample() {\n    return this._backfaceDepthTextureDownsample;\n  }\n  set backfaceDepthTextureDownsample(factor) {\n    if (this._backfaceDepthTextureDownsample === factor) {\n      return;\n    }\n    this._backfaceDepthTextureDownsample = factor;\n    this._resizeDepthRenderer();\n  }\n  /**\n   * Gets or sets a boolean (default: true) indicating if the depth of transparent meshes should be written to the backface depth texture (when automatic thickness computation is enabled).\n   */\n  get backfaceForceDepthWriteTransparentMeshes() {\n    return this._backfaceForceDepthWriteTransparentMeshes;\n  }\n  set backfaceForceDepthWriteTransparentMeshes(force) {\n    if (this._backfaceForceDepthWriteTransparentMeshes === force) {\n      return;\n    }\n    this._backfaceForceDepthWriteTransparentMeshes = force;\n    if (this._depthRenderer) {\n      this._depthRenderer.forceDepthWriteTransparentMeshes = force;\n    }\n  }\n  /**\n   * Gets or sets a boolean indicating if the effect is enabled (default: true).\n   */\n  get isEnabled() {\n    return this._isEnabled;\n  }\n  set isEnabled(value) {\n    if (this._isEnabled === value) {\n      return;\n    }\n    this._isEnabled = value;\n    if (!value) {\n      if (this._cameras !== null) {\n        this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\n        this._cameras = this._camerasToBeAttached.slice();\n      }\n    } else if (value) {\n      if (!this._isDirty) {\n        if (this._cameras !== null) {\n          this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);\n        }\n      } else {\n        this._buildPipeline();\n      }\n    }\n  }\n  /**\n   * Gets or sets a boolean defining if the input color texture is in gamma space (default: true)\n   * The SSR effect works in linear space, so if the input texture is in gamma space, we must convert the texture to linear space before applying the effect\n   */\n  get inputTextureColorIsInGammaSpace() {\n    return this._inputTextureColorIsInGammaSpace;\n  }\n  set inputTextureColorIsInGammaSpace(gammaSpace) {\n    if (this._inputTextureColorIsInGammaSpace === gammaSpace) {\n      return;\n    }\n    this._inputTextureColorIsInGammaSpace = gammaSpace;\n    this._buildPipeline();\n  }\n  /**\n   * Gets or sets a boolean defining if the output color texture generated by the SSR pipeline should be in gamma space (default: true)\n   * If you have a post-process that comes after the SSR and that post-process needs the input to be in a linear space, you must disable generateOutputInGammaSpace\n   */\n  get generateOutputInGammaSpace() {\n    return this._generateOutputInGammaSpace;\n  }\n  set generateOutputInGammaSpace(gammaSpace) {\n    if (this._generateOutputInGammaSpace === gammaSpace) {\n      return;\n    }\n    this._generateOutputInGammaSpace = gammaSpace;\n    this._buildPipeline();\n  }\n  /**\n   * Gets or sets a boolean indicating if the effect should be rendered in debug mode (default: false).\n   * In this mode, colors have this meaning:\n   *   - blue: the ray hit the max distance (we reached maxDistance)\n   *   - red: the ray ran out of steps (we reached maxSteps)\n   *   - yellow: the ray went off screen\n   *   - green: the ray hit a surface. The brightness of the green color is proportional to the distance between the ray origin and the intersection point: A brighter green means more computation than a darker green.\n   * In the first 3 cases, the final color is calculated by mixing the skybox color with the pixel color (if environmentTexture is defined), otherwise the pixel color is not modified\n   * You should try to get as few blue/red/yellow pixels as possible, as this means that the ray has gone further than if it had hit a surface.\n   */\n  get debug() {\n    return this._debug;\n  }\n  set debug(value) {\n    if (this._debug === value) {\n      return;\n    }\n    this._debug = value;\n    this._buildPipeline();\n  }\n  /**\n   * Gets the scene the effect belongs to.\n   * @returns the scene the effect belongs to.\n   */\n  getScene() {\n    return this._scene;\n  }\n  get _geometryBufferRenderer() {\n    if (!this._forceGeometryBuffer) {\n      return null;\n    }\n    return this._scene.geometryBufferRenderer;\n  }\n  get _prePassRenderer() {\n    if (this._forceGeometryBuffer) {\n      return null;\n    }\n    return this._scene.prePassRenderer;\n  }\n  /**\n   * Gets active scene\n   */\n  get scene() {\n    return this._scene;\n  }\n  /**\n   * Returns true if SSR is supported by the running hardware\n   */\n  get isSupported() {\n    const caps = this._scene.getEngine().getCaps();\n    return caps.drawBuffersExtension && caps.texelFetch;\n  }\n  /**\n   * Constructor of the SSR rendering pipeline\n   * @param name The rendering pipeline name\n   * @param scene The scene linked to this pipeline\n   * @param cameras The array of cameras that the rendering pipeline will be attached to (default: scene.cameras)\n   * @param forceGeometryBuffer Set to true if you want to use the legacy geometry buffer renderer (default: false)\n   * @param textureType The texture type used by the different post processes created by SSR (default: 0)\n   */\n  constructor(name, scene, cameras, forceGeometryBuffer = false, textureType = 0) {\n    super(scene.getEngine(), name);\n    /**\n     * The SSR PostProcess effect id in the pipeline\n     */\n    this.SSRRenderEffect = \"SSRRenderEffect\";\n    /**\n     * The blur PostProcess effect id in the pipeline\n     */\n    this.SSRBlurRenderEffect = \"SSRBlurRenderEffect\";\n    /**\n     * The PostProcess effect id in the pipeline that combines the SSR-Blur output with the original scene color\n     */\n    this.SSRCombineRenderEffect = \"SSRCombineRenderEffect\";\n    this._samples = 1;\n    /**\n     * Gets or sets the maxDistance used to define how far we look for reflection during the ray-marching on the reflected ray (default: 1000).\n     * Note that this value is a view (camera) space distance (not pixels!).\n     */\n    this.maxDistance = 1000.0;\n    /**\n     * Gets or sets the step size used to iterate until the effect finds the color of the reflection's pixel. Should be an integer \\>= 1 as it is the number of pixels we advance at each step (default: 1).\n     * Use higher values to improve performances (but at the expense of quality).\n     */\n    this.step = 1.0;\n    /**\n     * Gets or sets the thickness value used as tolerance when computing the intersection between the reflected ray and the scene (default: 0.5).\n     * If setting \"enableAutomaticThicknessComputation\" to true, you can use lower values for \"thickness\" (even 0), as the geometry thickness\n     * is automatically computed thank to the regular depth buffer + the backface depth buffer\n     */\n    this.thickness = 0.5;\n    /**\n     * Gets or sets the current reflection strength. 1.0 is an ideal value but can be increased/decreased for particular results (default: 1).\n     */\n    this.strength = 1;\n    /**\n     * Gets or sets the falloff exponent used to compute the reflection strength. Higher values lead to fainter reflections (default: 1).\n     */\n    this.reflectionSpecularFalloffExponent = 1;\n    /**\n     * Maximum number of steps during the ray marching process after which we consider an intersection could not be found (default: 1000).\n     * Should be an integer value.\n     */\n    this.maxSteps = 1000.0;\n    /**\n     * Gets or sets the factor applied when computing roughness. Default value is 0.2.\n     * When blurring based on roughness is enabled (meaning blurDispersionStrength \\> 0), roughnessFactor is used as a global roughness factor applied on all objects.\n     * If you want to disable this global roughness set it to 0.\n     */\n    this.roughnessFactor = 0.2;\n    /**\n     * Number of steps to skip at start when marching the ray to avoid self collisions (default: 1)\n     * 1 should normally be a good value, depending on the scene you may need to use a higher value (2 or 3)\n     */\n    this.selfCollisionNumSkip = 1;\n    this._reflectivityThreshold = 0.04;\n    this._ssrDownsample = 0;\n    this._blurDispersionStrength = 0.03;\n    this._blurDownsample = 0;\n    this._enableSmoothReflections = false;\n    this._environmentTextureIsProbe = false;\n    this._attenuateScreenBorders = true;\n    this._attenuateIntersectionDistance = true;\n    this._attenuateIntersectionIterations = true;\n    this._attenuateFacingCamera = false;\n    this._attenuateBackfaceReflection = false;\n    this._clipToFrustum = true;\n    this._useFresnel = false;\n    this._enableAutomaticThicknessComputation = false;\n    this._backfaceDepthTextureDownsample = 0;\n    this._backfaceForceDepthWriteTransparentMeshes = true;\n    this._isEnabled = true;\n    this._inputTextureColorIsInGammaSpace = true;\n    this._generateOutputInGammaSpace = true;\n    this._debug = false;\n    this._forceGeometryBuffer = false;\n    this._isDirty = false;\n    this._camerasToBeAttached = [];\n    this._cameras = cameras || scene.cameras;\n    this._cameras = this._cameras.slice();\n    this._camerasToBeAttached = this._cameras.slice();\n    this._scene = scene;\n    this._textureType = textureType;\n    this._forceGeometryBuffer = forceGeometryBuffer;\n    if (this.isSupported) {\n      scene.postProcessRenderPipelineManager.addPipeline(this);\n      if (this._forceGeometryBuffer) {\n        const geometryBufferRenderer = scene.enableGeometryBufferRenderer();\n        if (geometryBufferRenderer) {\n          geometryBufferRenderer.enableReflectivity = true;\n          geometryBufferRenderer.useSpecificClearForDepthTexture = true;\n          if (geometryBufferRenderer.generateNormalsInWorldSpace) {\n            console.error(\"SSRRenderingPipeline does not support generateNormalsInWorldSpace=true for the geometry buffer renderer!\");\n          }\n        }\n      } else {\n        const prePassRenderer = scene.enablePrePassRenderer();\n        if (prePassRenderer) {\n          prePassRenderer.useSpecificClearForDepthTexture = true;\n          prePassRenderer.markAsDirty();\n          if (prePassRenderer.generateNormalsInWorldSpace) {\n            console.error(\"SSRRenderingPipeline does not support generateNormalsInWorldSpace=true for the prepass renderer!\");\n          }\n        }\n      }\n      this._buildPipeline();\n    }\n  }\n  /**\n   * Get the class name\n   * @returns \"SSRRenderingPipeline\"\n   */\n  getClassName() {\n    return \"SSRRenderingPipeline\";\n  }\n  /**\n   * Adds a camera to the pipeline\n   * @param camera the camera to be added\n   */\n  addCamera(camera) {\n    this._camerasToBeAttached.push(camera);\n    this._buildPipeline();\n  }\n  /**\n   * Removes a camera from the pipeline\n   * @param camera the camera to remove\n   */\n  removeCamera(camera) {\n    const index = this._camerasToBeAttached.indexOf(camera);\n    this._camerasToBeAttached.splice(index, 1);\n    this._buildPipeline();\n  }\n  /**\n   * Removes the internal pipeline assets and detaches the pipeline from the scene cameras\n   * @param disableGeometryBufferRenderer\n   */\n  dispose(disableGeometryBufferRenderer = false) {\n    this._disposeDepthRenderer();\n    this._disposePostProcesses();\n    if (disableGeometryBufferRenderer) {\n      this._scene.disableGeometryBufferRenderer();\n    }\n    this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\n    super.dispose();\n  }\n  _getTextureSize() {\n    var _a, _b;\n    const engine = this._scene.getEngine();\n    const prePassRenderer = this._prePassRenderer;\n    let textureSize = {\n      width: engine.getRenderWidth(),\n      height: engine.getRenderHeight()\n    };\n    if (prePassRenderer && ((_a = this._scene.activeCamera) === null || _a === void 0 ? void 0 : _a._getFirstPostProcess()) === this._ssrPostProcess) {\n      const renderTarget = prePassRenderer.getRenderTarget();\n      if (renderTarget && renderTarget.textures) {\n        textureSize = renderTarget.textures[prePassRenderer.getIndex(4)].getSize();\n      }\n    } else if ((_b = this._ssrPostProcess) === null || _b === void 0 ? void 0 : _b.inputTexture) {\n      textureSize.width = this._ssrPostProcess.inputTexture.width;\n      textureSize.height = this._ssrPostProcess.inputTexture.height;\n    }\n    return textureSize;\n  }\n  _updateEffectDefines() {\n    var _a;\n    const defines = [];\n    if (this._geometryBufferRenderer || this._prePassRenderer) {\n      defines.push(\"#define SSR_SUPPORTED\");\n    }\n    if (this._enableSmoothReflections) {\n      defines.push(\"#define SSRAYTRACE_ENABLE_REFINEMENT\");\n    }\n    if (this._scene.useRightHandedSystem) {\n      defines.push(\"#define SSRAYTRACE_RIGHT_HANDED_SCENE\");\n    }\n    if (this._environmentTexture) {\n      defines.push(\"#define SSR_USE_ENVIRONMENT_CUBE\");\n      if (this._environmentTexture.boundingBoxSize) {\n        defines.push(\"#define SSR_USE_LOCAL_REFLECTIONMAP_CUBIC\");\n      }\n      if (this._environmentTexture.gammaSpace) {\n        defines.push(\"#define SSR_ENVIRONMENT_CUBE_IS_GAMMASPACE\");\n      }\n    }\n    if (this._environmentTextureIsProbe) {\n      defines.push(\"#define SSR_INVERTCUBICMAP\");\n    }\n    if (this._enableAutomaticThicknessComputation) {\n      defines.push(\"#define SSRAYTRACE_USE_BACK_DEPTHBUFFER\");\n    }\n    if (this._attenuateScreenBorders) {\n      defines.push(\"#define SSR_ATTENUATE_SCREEN_BORDERS\");\n    }\n    if (this._attenuateIntersectionDistance) {\n      defines.push(\"#define SSR_ATTENUATE_INTERSECTION_DISTANCE\");\n    }\n    if (this._attenuateIntersectionIterations) {\n      defines.push(\"#define SSR_ATTENUATE_INTERSECTION_NUMITERATIONS\");\n    }\n    if (this._attenuateFacingCamera) {\n      defines.push(\"#define SSR_ATTENUATE_FACING_CAMERA\");\n    }\n    if (this._attenuateBackfaceReflection) {\n      defines.push(\"#define SSR_ATTENUATE_BACKFACE_REFLECTION\");\n    }\n    if (this._clipToFrustum) {\n      defines.push(\"#define SSRAYTRACE_CLIP_TO_FRUSTUM\");\n    }\n    if (this._useBlur()) {\n      defines.push(\"#define SSR_USE_BLUR\");\n    }\n    if (this._debug) {\n      defines.push(\"#define SSRAYTRACE_DEBUG\");\n    }\n    if (this._inputTextureColorIsInGammaSpace) {\n      defines.push(\"#define SSR_INPUT_IS_GAMMA_SPACE\");\n    }\n    if (this._generateOutputInGammaSpace) {\n      defines.push(\"#define SSR_OUTPUT_IS_GAMMA_SPACE\");\n    }\n    if (this._useFresnel) {\n      defines.push(\"#define SSR_BLEND_WITH_FRESNEL\");\n    }\n    if (this._reflectivityThreshold === 0) {\n      defines.push(\"#define SSR_DISABLE_REFLECTIVITY_TEST\");\n    }\n    (_a = this._ssrPostProcess) === null || _a === void 0 ? void 0 : _a.updateEffect(defines.join(\"\\n\"));\n  }\n  _buildPipeline() {\n    var _a;\n    if (!this.isSupported) {\n      return;\n    }\n    if (!this._isEnabled) {\n      this._isDirty = true;\n      return;\n    }\n    this._isDirty = false;\n    const engine = this._scene.getEngine();\n    this._disposeDepthRenderer();\n    this._disposePostProcesses();\n    if (this._cameras !== null) {\n      this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\n      // get back cameras to be used to reattach pipeline\n      this._cameras = this._camerasToBeAttached.slice();\n    }\n    this._reset();\n    if (this._enableAutomaticThicknessComputation) {\n      const camera = (_a = this._cameras) === null || _a === void 0 ? void 0 : _a[0];\n      if (camera) {\n        this._depthRendererCamera = camera;\n        this._depthRenderer = new DepthRenderer(this._scene, undefined, undefined, undefined, 1, true, \"SSRBackDepth\");\n        this._depthRenderer.clearColor.r = 1e8; // \"infinity\": put a big value because we use the storeCameraSpaceZ mode\n        this._depthRenderer.reverseCulling = true; // we generate depth for the back faces\n        this._depthRenderer.forceDepthWriteTransparentMeshes = this._backfaceForceDepthWriteTransparentMeshes;\n        this._resizeDepthRenderer();\n        camera.customRenderTargets.push(this._depthRenderer.getDepthMap());\n      }\n    }\n    this._createSSRPostProcess();\n    this.addEffect(new PostProcessRenderEffect(engine, this.SSRRenderEffect, () => {\n      return this._ssrPostProcess;\n    }, true));\n    if (this._useBlur()) {\n      this._createBlurAndCombinerPostProcesses();\n      this.addEffect(new PostProcessRenderEffect(engine, this.SSRBlurRenderEffect, () => {\n        return [this._blurPostProcessX, this._blurPostProcessY];\n      }, true));\n      this.addEffect(new PostProcessRenderEffect(engine, this.SSRCombineRenderEffect, () => {\n        return this._blurCombinerPostProcess;\n      }, true));\n    }\n    if (this._cameras !== null) {\n      this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);\n    }\n  }\n  _resizeDepthRenderer() {\n    if (!this._depthRenderer) {\n      return;\n    }\n    const textureSize = this._getTextureSize();\n    const depthRendererSize = this._depthRenderer.getDepthMap().getSize();\n    const width = Math.floor(textureSize.width / (this._backfaceDepthTextureDownsample + 1));\n    const height = Math.floor(textureSize.height / (this._backfaceDepthTextureDownsample + 1));\n    if (depthRendererSize.width !== width || depthRendererSize.height !== height) {\n      this._depthRenderer.getDepthMap().resize({\n        width,\n        height\n      });\n    }\n  }\n  _disposeDepthRenderer() {\n    var _a;\n    if (this._depthRenderer) {\n      if (this._depthRendererCamera) {\n        const idx = (_a = this._depthRendererCamera.customRenderTargets.indexOf(this._depthRenderer.getDepthMap())) !== null && _a !== void 0 ? _a : -1;\n        if (idx !== -1) {\n          this._depthRendererCamera.customRenderTargets.splice(idx, 1);\n        }\n      }\n      this._depthRendererCamera = null;\n      this._depthRenderer.getDepthMap().dispose();\n    }\n    this._depthRenderer = null;\n  }\n  _disposePostProcesses() {\n    var _a, _b, _c, _d;\n    for (let i = 0; i < this._cameras.length; i++) {\n      const camera = this._cameras[i];\n      (_a = this._ssrPostProcess) === null || _a === void 0 ? void 0 : _a.dispose(camera);\n      (_b = this._blurPostProcessX) === null || _b === void 0 ? void 0 : _b.dispose(camera);\n      (_c = this._blurPostProcessY) === null || _c === void 0 ? void 0 : _c.dispose(camera);\n      (_d = this._blurCombinerPostProcess) === null || _d === void 0 ? void 0 : _d.dispose(camera);\n    }\n    this._ssrPostProcess = null;\n    this._blurPostProcessX = null;\n    this._blurPostProcessY = null;\n    this._blurCombinerPostProcess = null;\n  }\n  _createSSRPostProcess() {\n    this._ssrPostProcess = new PostProcess(\"ssr\", \"screenSpaceReflection2\", [\"projection\", \"invProjectionMatrix\", \"view\", \"invView\", \"thickness\", \"reflectionSpecularFalloffExponent\", \"strength\", \"stepSize\", \"maxSteps\", \"roughnessFactor\", \"projectionPixel\", \"nearPlaneZ\", \"maxDistance\", \"selfCollisionNumSkip\", \"vReflectionPosition\", \"vReflectionSize\", \"backSizeFactor\", \"reflectivityThreshold\"], [\"textureSampler\", \"normalSampler\", \"reflectivitySampler\", \"depthSampler\", \"envCubeSampler\", \"backDepthSampler\"], 1.0, null, this._textureType, this._scene.getEngine(), false, \"\", this._textureType);\n    this._updateEffectDefines();\n    this._ssrPostProcess.onApply = effect => {\n      this._resizeDepthRenderer();\n      const geometryBufferRenderer = this._geometryBufferRenderer;\n      const prePassRenderer = this._prePassRenderer;\n      if (!prePassRenderer && !geometryBufferRenderer) {\n        return;\n      }\n      if (geometryBufferRenderer) {\n        const roughnessIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE);\n        effect.setTexture(\"normalSampler\", geometryBufferRenderer.getGBuffer().textures[1]);\n        effect.setTexture(\"reflectivitySampler\", geometryBufferRenderer.getGBuffer().textures[roughnessIndex]);\n        effect.setTexture(\"depthSampler\", geometryBufferRenderer.getGBuffer().textures[0]);\n      } else if (prePassRenderer) {\n        const depthIndex = prePassRenderer.getIndex(5);\n        const roughnessIndex = prePassRenderer.getIndex(3);\n        const normalIndex = prePassRenderer.getIndex(6);\n        effect.setTexture(\"normalSampler\", prePassRenderer.getRenderTarget().textures[normalIndex]);\n        effect.setTexture(\"depthSampler\", prePassRenderer.getRenderTarget().textures[depthIndex]);\n        effect.setTexture(\"reflectivitySampler\", prePassRenderer.getRenderTarget().textures[roughnessIndex]);\n      }\n      if (this._enableAutomaticThicknessComputation && this._depthRenderer) {\n        effect.setTexture(\"backDepthSampler\", this._depthRenderer.getDepthMap());\n        effect.setFloat(\"backSizeFactor\", this._backfaceDepthTextureDownsample + 1);\n      }\n      const camera = this._scene.activeCamera;\n      if (!camera) {\n        return;\n      }\n      const viewMatrix = camera.getViewMatrix(true);\n      const projectionMatrix = camera.getProjectionMatrix(true);\n      projectionMatrix.invertToRef(TmpVectors.Matrix[0]);\n      viewMatrix.invertToRef(TmpVectors.Matrix[1]);\n      effect.setMatrix(\"projection\", projectionMatrix);\n      effect.setMatrix(\"view\", viewMatrix);\n      effect.setMatrix(\"invView\", TmpVectors.Matrix[1]);\n      effect.setMatrix(\"invProjectionMatrix\", TmpVectors.Matrix[0]);\n      effect.setFloat(\"thickness\", this.thickness);\n      effect.setFloat(\"reflectionSpecularFalloffExponent\", this.reflectionSpecularFalloffExponent);\n      effect.setFloat(\"strength\", this.strength);\n      effect.setFloat(\"stepSize\", this.step);\n      effect.setFloat(\"maxSteps\", this.maxSteps);\n      effect.setFloat(\"roughnessFactor\", this.roughnessFactor);\n      effect.setFloat(\"nearPlaneZ\", camera.minZ);\n      effect.setFloat(\"maxDistance\", this.maxDistance);\n      effect.setFloat(\"selfCollisionNumSkip\", this.selfCollisionNumSkip);\n      effect.setFloat(\"reflectivityThreshold\", this._reflectivityThreshold);\n      const textureSize = this._getTextureSize();\n      Matrix.ScalingToRef(textureSize.width, textureSize.height, 1, TmpVectors.Matrix[2]);\n      projectionMatrix.multiplyToRef(this._scene.getEngine().isWebGPU ? trsWebGPU : trs, TmpVectors.Matrix[3]);\n      TmpVectors.Matrix[3].multiplyToRef(TmpVectors.Matrix[2], TmpVectors.Matrix[4]);\n      effect.setMatrix(\"projectionPixel\", TmpVectors.Matrix[4]);\n      if (this._environmentTexture) {\n        effect.setTexture(\"envCubeSampler\", this._environmentTexture);\n        if (this._environmentTexture.boundingBoxSize) {\n          effect.setVector3(\"vReflectionPosition\", this._environmentTexture.boundingBoxPosition);\n          effect.setVector3(\"vReflectionSize\", this._environmentTexture.boundingBoxSize);\n        }\n      }\n    };\n    this._ssrPostProcess.samples = this.samples;\n    if (!this._forceGeometryBuffer) {\n      this._ssrPostProcess._prePassEffectConfiguration = new ScreenSpaceReflections2Configuration();\n    }\n  }\n  _createBlurAndCombinerPostProcesses() {\n    const engine = this._scene.getEngine();\n    this._blurPostProcessX = new PostProcess(\"SSRblurX\", \"screenSpaceReflection2Blur\", [\"texelOffsetScale\"], [\"textureSampler\"], this._useBlur() ? 1 / (this._ssrDownsample + 1) : 1, null, 2, engine, false, \"\", this._textureType);\n    this._blurPostProcessX.autoClear = false;\n    this._blurPostProcessX.onApplyObservable.add(effect => {\n      var _a, _b;\n      const width = (_b = (_a = this._blurPostProcessX) === null || _a === void 0 ? void 0 : _a.inputTexture.width) !== null && _b !== void 0 ? _b : this._scene.getEngine().getRenderWidth();\n      effect.setFloat2(\"texelOffsetScale\", this._blurDispersionStrength / width, 0);\n    });\n    this._blurPostProcessY = new PostProcess(\"SSRblurY\", \"screenSpaceReflection2Blur\", [\"texelOffsetScale\"], [\"textureSampler\"], this._useBlur() ? 1 / (this._blurDownsample + 1) : 1, null, 2, engine, false, \"\", this._textureType);\n    this._blurPostProcessY.autoClear = false;\n    this._blurPostProcessY.onApplyObservable.add(effect => {\n      var _a, _b;\n      const height = (_b = (_a = this._blurPostProcessY) === null || _a === void 0 ? void 0 : _a.inputTexture.height) !== null && _b !== void 0 ? _b : this._scene.getEngine().getRenderHeight();\n      effect.setFloat2(\"texelOffsetScale\", 0, this._blurDispersionStrength / height);\n    });\n    const uniformNames = [\"strength\", \"reflectionSpecularFalloffExponent\", \"reflectivityThreshold\"];\n    const samplerNames = [\"textureSampler\", \"mainSampler\", \"reflectivitySampler\"];\n    let defines = \"\";\n    if (this._debug) {\n      defines += \"#define SSRAYTRACE_DEBUG\\n\";\n    }\n    if (this._inputTextureColorIsInGammaSpace) {\n      defines += \"#define SSR_INPUT_IS_GAMMA_SPACE\\n\";\n    }\n    if (this._generateOutputInGammaSpace) {\n      defines += \"#define SSR_OUTPUT_IS_GAMMA_SPACE\\n\";\n    }\n    if (this.useFresnel) {\n      defines += \"#define SSR_BLEND_WITH_FRESNEL\\n\";\n      uniformNames.push(\"projection\", \"invProjectionMatrix\");\n      samplerNames.push(\"depthSampler\", \"normalSampler\");\n    }\n    if (this._reflectivityThreshold === 0) {\n      defines += \"#define SSR_DISABLE_REFLECTIVITY_TEST\";\n    }\n    this._blurCombinerPostProcess = new PostProcess(\"SSRblurCombiner\", \"screenSpaceReflection2BlurCombiner\", uniformNames, samplerNames, this._useBlur() ? 1 / (this._blurDownsample + 1) : 1, null, 1, engine, false, defines, this._textureType);\n    this._blurCombinerPostProcess.autoClear = false;\n    this._blurCombinerPostProcess.onApplyObservable.add(effect => {\n      var _a;\n      const geometryBufferRenderer = this._geometryBufferRenderer;\n      const prePassRenderer = this._prePassRenderer;\n      if (!prePassRenderer && !geometryBufferRenderer) {\n        return;\n      }\n      if (prePassRenderer && ((_a = this._scene.activeCamera) === null || _a === void 0 ? void 0 : _a._getFirstPostProcess()) === this._ssrPostProcess) {\n        const renderTarget = prePassRenderer.getRenderTarget();\n        if (renderTarget && renderTarget.textures) {\n          effect.setTexture(\"mainSampler\", renderTarget.textures[prePassRenderer.getIndex(4)]);\n        }\n      } else {\n        effect.setTextureFromPostProcess(\"mainSampler\", this._ssrPostProcess);\n      }\n      if (geometryBufferRenderer) {\n        const roughnessIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE);\n        effect.setTexture(\"reflectivitySampler\", geometryBufferRenderer.getGBuffer().textures[roughnessIndex]);\n        if (this.useFresnel) {\n          effect.setTexture(\"normalSampler\", geometryBufferRenderer.getGBuffer().textures[1]);\n          effect.setTexture(\"depthSampler\", geometryBufferRenderer.getGBuffer().textures[0]);\n        }\n      } else if (prePassRenderer) {\n        const roughnessIndex = prePassRenderer.getIndex(3);\n        effect.setTexture(\"reflectivitySampler\", prePassRenderer.getRenderTarget().textures[roughnessIndex]);\n        if (this.useFresnel) {\n          const depthIndex = prePassRenderer.getIndex(5);\n          const normalIndex = prePassRenderer.getIndex(6);\n          effect.setTexture(\"normalSampler\", prePassRenderer.getRenderTarget().textures[normalIndex]);\n          effect.setTexture(\"depthSampler\", prePassRenderer.getRenderTarget().textures[depthIndex]);\n        }\n      }\n      effect.setFloat(\"strength\", this.strength);\n      effect.setFloat(\"reflectionSpecularFalloffExponent\", this.reflectionSpecularFalloffExponent);\n      effect.setFloat(\"reflectivityThreshold\", this._reflectivityThreshold);\n      if (this.useFresnel) {\n        const camera = this._scene.activeCamera;\n        if (camera) {\n          const projectionMatrix = camera.getProjectionMatrix();\n          projectionMatrix.invertToRef(TmpVectors.Matrix[0]);\n          effect.setMatrix(\"projection\", projectionMatrix);\n          effect.setMatrix(\"invProjectionMatrix\", TmpVectors.Matrix[0]);\n        }\n      }\n    });\n  }\n  /**\n   * Serializes the rendering pipeline (Used when exporting)\n   * @returns the serialized object\n   */\n  serialize() {\n    const serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.customType = \"SSRRenderingPipeline\";\n    return serializationObject;\n  }\n  /**\n   * Parse the serialized pipeline\n   * @param source Source pipeline.\n   * @param scene The scene to load the pipeline to.\n   * @param rootUrl The URL of the serialized pipeline.\n   * @returns An instantiated pipeline from the serialized object.\n   */\n  static Parse(source, scene, rootUrl) {\n    return SerializationHelper.Parse(() => new SSRRenderingPipeline(source._name, scene, source._ratio), source, scene, rootUrl);\n  }\n}\n__decorate([serialize()], SSRRenderingPipeline.prototype, \"samples\", null);\n__decorate([serialize()], SSRRenderingPipeline.prototype, \"maxDistance\", void 0);\n__decorate([serialize()], SSRRenderingPipeline.prototype, \"step\", void 0);\n__decorate([serialize()], SSRRenderingPipeline.prototype, \"thickness\", void 0);\n__decorate([serialize()], SSRRenderingPipeline.prototype, \"strength\", void 0);\n__decorate([serialize()], SSRRenderingPipeline.prototype, \"reflectionSpecularFalloffExponent\", void 0);\n__decorate([serialize()], SSRRenderingPipeline.prototype, \"maxSteps\", void 0);\n__decorate([serialize()], SSRRenderingPipeline.prototype, \"roughnessFactor\", void 0);\n__decorate([serialize()], SSRRenderingPipeline.prototype, \"selfCollisionNumSkip\", void 0);\n__decorate([serialize()], SSRRenderingPipeline.prototype, \"_reflectivityThreshold\", void 0);\n__decorate([serialize(\"_ssrDownsample\")], SSRRenderingPipeline.prototype, \"_ssrDownsample\", void 0);\n__decorate([serialize()], SSRRenderingPipeline.prototype, \"ssrDownsample\", null);\n__decorate([serialize(\"blurDispersionStrength\")], SSRRenderingPipeline.prototype, \"_blurDispersionStrength\", void 0);\n__decorate([serialize(\"blurDownsample\")], SSRRenderingPipeline.prototype, \"_blurDownsample\", void 0);\n__decorate([serialize(\"enableSmoothReflections\")], SSRRenderingPipeline.prototype, \"_enableSmoothReflections\", void 0);\n__decorate([serialize(\"environmentTexture\")], SSRRenderingPipeline.prototype, \"_environmentTexture\", void 0);\n__decorate([serialize(\"environmentTextureIsProbe\")], SSRRenderingPipeline.prototype, \"_environmentTextureIsProbe\", void 0);\n__decorate([serialize(\"attenuateScreenBorders\")], SSRRenderingPipeline.prototype, \"_attenuateScreenBorders\", void 0);\n__decorate([serialize(\"attenuateIntersectionDistance\")], SSRRenderingPipeline.prototype, \"_attenuateIntersectionDistance\", void 0);\n__decorate([serialize(\"attenuateIntersectionIterations\")], SSRRenderingPipeline.prototype, \"_attenuateIntersectionIterations\", void 0);\n__decorate([serialize(\"attenuateFacingCamera\")], SSRRenderingPipeline.prototype, \"_attenuateFacingCamera\", void 0);\n__decorate([serialize(\"attenuateBackfaceReflection\")], SSRRenderingPipeline.prototype, \"_attenuateBackfaceReflection\", void 0);\n__decorate([serialize(\"clipToFrustum\")], SSRRenderingPipeline.prototype, \"_clipToFrustum\", void 0);\n__decorate([serialize(\"useFresnel\")], SSRRenderingPipeline.prototype, \"_useFresnel\", void 0);\n__decorate([serialize(\"enableAutomaticThicknessComputation\")], SSRRenderingPipeline.prototype, \"_enableAutomaticThicknessComputation\", void 0);\n__decorate([serialize(\"backfaceDepthTextureDownsample\")], SSRRenderingPipeline.prototype, \"_backfaceDepthTextureDownsample\", void 0);\n__decorate([serialize(\"backfaceForceDepthWriteTransparentMeshes\")], SSRRenderingPipeline.prototype, \"_backfaceForceDepthWriteTransparentMeshes\", void 0);\n__decorate([serialize(\"isEnabled\")], SSRRenderingPipeline.prototype, \"_isEnabled\", void 0);\n__decorate([serialize(\"inputTextureColorIsInGammaSpace\")], SSRRenderingPipeline.prototype, \"_inputTextureColorIsInGammaSpace\", void 0);\n__decorate([serialize(\"generateOutputInGammaSpace\")], SSRRenderingPipeline.prototype, \"_generateOutputInGammaSpace\", void 0);\n__decorate([serialize(\"debug\")], SSRRenderingPipeline.prototype, \"_debug\", void 0);\nRegisterClass(\"BABYLON.SSRRenderingPipeline\", SSRRenderingPipeline);","map":{"version":3,"names":["serialize","SerializationHelper","Vector3","Matrix","Quaternion","TmpVectors","PostProcess","PostProcessRenderPipeline","PostProcessRenderEffect","RegisterClass","ScreenSpaceReflections2Configuration","GeometryBufferRenderer","DepthRenderer","trs","Compose","Identity","trsWebGPU","SSRRenderingPipeline","samples","sampleCount","_samples","_buildPipeline","reflectivityThreshold","_reflectivityThreshold","threshold","ssrDownsample","_ssrDownsample","downsample","blurDispersionStrength","_blurDispersionStrength","strength","rebuild","_useBlur","blurDownsample","_blurDownsample","enableSmoothReflections","_enableSmoothReflections","enabled","_updateEffectDefines","environmentTexture","_environmentTexture","texture","environmentTextureIsProbe","_environmentTextureIsProbe","isProbe","attenuateScreenBorders","_attenuateScreenBorders","attenuate","attenuateIntersectionDistance","_attenuateIntersectionDistance","attenuateIntersectionIterations","_attenuateIntersectionIterations","attenuateFacingCamera","_attenuateFacingCamera","attenuateBackfaceReflection","_attenuateBackfaceReflection","clipToFrustum","_clipToFrustum","clip","useFresnel","_useFresnel","fresnel","enableAutomaticThicknessComputation","_enableAutomaticThicknessComputation","automatic","backfaceDepthRenderer","_depthRenderer","backfaceDepthTextureDownsample","_backfaceDepthTextureDownsample","factor","_resizeDepthRenderer","backfaceForceDepthWriteTransparentMeshes","_backfaceForceDepthWriteTransparentMeshes","force","forceDepthWriteTransparentMeshes","isEnabled","_isEnabled","value","_cameras","_scene","postProcessRenderPipelineManager","detachCamerasFromRenderPipeline","_name","_camerasToBeAttached","slice","_isDirty","attachCamerasToRenderPipeline","inputTextureColorIsInGammaSpace","_inputTextureColorIsInGammaSpace","gammaSpace","generateOutputInGammaSpace","_generateOutputInGammaSpace","debug","_debug","getScene","_geometryBufferRenderer","_forceGeometryBuffer","geometryBufferRenderer","_prePassRenderer","prePassRenderer","scene","isSupported","caps","getEngine","getCaps","drawBuffersExtension","texelFetch","constructor","name","cameras","forceGeometryBuffer","textureType","SSRRenderEffect","SSRBlurRenderEffect","SSRCombineRenderEffect","maxDistance","step","thickness","reflectionSpecularFalloffExponent","maxSteps","roughnessFactor","selfCollisionNumSkip","_textureType","addPipeline","enableGeometryBufferRenderer","enableReflectivity","useSpecificClearForDepthTexture","generateNormalsInWorldSpace","console","error","enablePrePassRenderer","markAsDirty","getClassName","addCamera","camera","push","removeCamera","index","indexOf","splice","dispose","disableGeometryBufferRenderer","_disposeDepthRenderer","_disposePostProcesses","_getTextureSize","engine","textureSize","width","getRenderWidth","height","getRenderHeight","_a","activeCamera","_getFirstPostProcess","_ssrPostProcess","renderTarget","getRenderTarget","textures","getIndex","getSize","_b","inputTexture","defines","useRightHandedSystem","boundingBoxSize","updateEffect","join","_reset","_depthRendererCamera","undefined","clearColor","r","reverseCulling","customRenderTargets","getDepthMap","_createSSRPostProcess","addEffect","_createBlurAndCombinerPostProcesses","_blurPostProcessX","_blurPostProcessY","_blurCombinerPostProcess","depthRendererSize","Math","floor","resize","idx","i","length","_c","_d","onApply","effect","roughnessIndex","getTextureIndex","REFLECTIVITY_TEXTURE_TYPE","setTexture","getGBuffer","depthIndex","normalIndex","setFloat","viewMatrix","getViewMatrix","projectionMatrix","getProjectionMatrix","invertToRef","setMatrix","minZ","ScalingToRef","multiplyToRef","isWebGPU","setVector3","boundingBoxPosition","_prePassEffectConfiguration","autoClear","onApplyObservable","add","setFloat2","uniformNames","samplerNames","setTextureFromPostProcess","serializationObject","Serialize","customType","Parse","source","rootUrl","_ratio","__decorate"],"sources":["../../../../../../dev/core/src/PostProcesses/RenderPipeline/Pipelines/ssrRenderingPipeline.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { serialize, SerializationHelper } from \"../../../Misc/decorators\";\r\nimport { Vector3, Matrix, Quaternion, TmpVectors } from \"../../../Maths/math.vector\";\r\nimport type { Camera } from \"../../../Cameras/camera\";\r\nimport type { Effect } from \"../../../Materials/effect\";\r\nimport { PostProcess } from \"../../postProcess\";\r\nimport { PostProcessRenderPipeline } from \"../postProcessRenderPipeline\";\r\nimport { PostProcessRenderEffect } from \"../postProcessRenderEffect\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { ScreenSpaceReflections2Configuration } from \"../../../Rendering/screenSpaceReflections2Configuration\";\r\nimport type { PrePassRenderer } from \"../../../Rendering/prePassRenderer\";\r\nimport { GeometryBufferRenderer } from \"../../../Rendering/geometryBufferRenderer\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { CubeTexture } from \"../../../Materials/Textures/cubeTexture\";\r\nimport { DepthRenderer } from \"../../../Rendering/depthRenderer\";\r\nimport type { ISize } from \"../../../Maths/math.size\";\r\n\r\nimport \"../postProcessRenderPipelineManagerSceneComponent\";\r\n\r\nimport \"../../../Shaders/screenSpaceReflection2.fragment\";\r\nimport \"../../../Shaders/screenSpaceReflection2Blur.fragment\";\r\nimport \"../../../Shaders/screenSpaceReflection2BlurCombiner.fragment\";\r\n\r\nconst trs = Matrix.Compose(new Vector3(0.5, 0.5, 0.5), Quaternion.Identity(), new Vector3(0.5, 0.5, 0.5));\r\nconst trsWebGPU = Matrix.Compose(new Vector3(0.5, 0.5, 1), Quaternion.Identity(), new Vector3(0.5, 0.5, 0));\r\n\r\n/**\r\n * Render pipeline to produce Screen Space Reflections (SSR) effect\r\n *\r\n * References:\r\n *   Screen Space Ray Tracing:\r\n *     - http://casual-effects.blogspot.com/2014/08/screen-space-ray-tracing.html\r\n *     - https://sourceforge.net/p/g3d/code/HEAD/tree/G3D10/data-files/shader/screenSpaceRayTrace.glsl\r\n *     - https://github.com/kode80/kode80SSR\r\n *   SSR:\r\n *     - general tips: https://sakibsaikia.github.io/graphics/2016/12/26/Screen-Space-Reflection-in-Killing-Floor-2.html\r\n *     - computation of blur radius from roughness and distance: https://github.com/godotengine/godot/blob/master/servers/rendering/renderer_rd/shaders/effects/screen_space_reflection.glsl\r\n *     - blur and usage of back depth buffer: https://github.com/kode80/kode80SSR\r\n */\r\nexport class SSRRenderingPipeline extends PostProcessRenderPipeline {\r\n    /**\r\n     * The SSR PostProcess effect id in the pipeline\r\n     */\r\n    public SSRRenderEffect: string = \"SSRRenderEffect\";\r\n    /**\r\n     * The blur PostProcess effect id in the pipeline\r\n     */\r\n    public SSRBlurRenderEffect: string = \"SSRBlurRenderEffect\";\r\n    /**\r\n     * The PostProcess effect id in the pipeline that combines the SSR-Blur output with the original scene color\r\n     */\r\n    public SSRCombineRenderEffect: string = \"SSRCombineRenderEffect\";\r\n\r\n    private _samples = 1;\r\n    /**\r\n     * MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)\r\n     */\r\n    public set samples(sampleCount: number) {\r\n        if (this._samples === sampleCount) {\r\n            return;\r\n        }\r\n        this._samples = sampleCount;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the maxDistance used to define how far we look for reflection during the ray-marching on the reflected ray (default: 1000).\r\n     * Note that this value is a view (camera) space distance (not pixels!).\r\n     */\r\n    @serialize()\r\n    public maxDistance = 1000.0;\r\n    /**\r\n     * Gets or sets the step size used to iterate until the effect finds the color of the reflection's pixel. Should be an integer \\>= 1 as it is the number of pixels we advance at each step (default: 1).\r\n     * Use higher values to improve performances (but at the expense of quality).\r\n     */\r\n    @serialize()\r\n    public step = 1.0;\r\n    /**\r\n     * Gets or sets the thickness value used as tolerance when computing the intersection between the reflected ray and the scene (default: 0.5).\r\n     * If setting \"enableAutomaticThicknessComputation\" to true, you can use lower values for \"thickness\" (even 0), as the geometry thickness\r\n     * is automatically computed thank to the regular depth buffer + the backface depth buffer\r\n     */\r\n    @serialize()\r\n    public thickness = 0.5;\r\n    /**\r\n     * Gets or sets the current reflection strength. 1.0 is an ideal value but can be increased/decreased for particular results (default: 1).\r\n     */\r\n    @serialize()\r\n    public strength = 1;\r\n    /**\r\n     * Gets or sets the falloff exponent used to compute the reflection strength. Higher values lead to fainter reflections (default: 1).\r\n     */\r\n    @serialize()\r\n    public reflectionSpecularFalloffExponent = 1;\r\n    /**\r\n     * Maximum number of steps during the ray marching process after which we consider an intersection could not be found (default: 1000).\r\n     * Should be an integer value.\r\n     */\r\n    @serialize()\r\n    public maxSteps = 1000.0;\r\n    /**\r\n     * Gets or sets the factor applied when computing roughness. Default value is 0.2.\r\n     * When blurring based on roughness is enabled (meaning blurDispersionStrength \\> 0), roughnessFactor is used as a global roughness factor applied on all objects.\r\n     * If you want to disable this global roughness set it to 0.\r\n     */\r\n    @serialize()\r\n    public roughnessFactor = 0.2;\r\n    /**\r\n     * Number of steps to skip at start when marching the ray to avoid self collisions (default: 1)\r\n     * 1 should normally be a good value, depending on the scene you may need to use a higher value (2 or 3)\r\n     */\r\n    @serialize()\r\n    public selfCollisionNumSkip = 1;\r\n\r\n    @serialize()\r\n    private _reflectivityThreshold = 0.04;\r\n\r\n    /**\r\n     * Gets or sets the minimum value for one of the reflectivity component of the material to consider it for SSR (default: 0.04).\r\n     * If all r/g/b components of the reflectivity is below or equal this value, the pixel will not be considered reflective and SSR won't be applied.\r\n     */\r\n    public get reflectivityThreshold() {\r\n        return this._reflectivityThreshold;\r\n    }\r\n\r\n    public set reflectivityThreshold(threshold: number) {\r\n        if (threshold === this._reflectivityThreshold) {\r\n            return;\r\n        }\r\n\r\n        if ((threshold === 0 && this._reflectivityThreshold !== 0) || (threshold !== 0 && this._reflectivityThreshold === 0)) {\r\n            this._reflectivityThreshold = threshold;\r\n            this._buildPipeline();\r\n        } else {\r\n            this._reflectivityThreshold = threshold;\r\n        }\r\n    }\r\n\r\n    @serialize(\"_ssrDownsample\")\r\n    private _ssrDownsample = 0;\r\n\r\n    /**\r\n     * Gets or sets the downsample factor used to reduce the size of the texture used to compute the SSR contribution (default: 0).\r\n     * Use 0 to render the SSR contribution at full resolution, 1 to render at half resolution, 2 to render at 1/3 resolution, etc.\r\n     * Note that it is used only when blurring is enabled (blurDispersionStrength \\> 0), because in that mode the SSR contribution is generated in a separate texture.\r\n     */\r\n    @serialize()\r\n    public get ssrDownsample() {\r\n        return this._ssrDownsample;\r\n    }\r\n\r\n    public set ssrDownsample(downsample: number) {\r\n        if (downsample === this._ssrDownsample) {\r\n            return;\r\n        }\r\n\r\n        this._ssrDownsample = downsample;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize(\"blurDispersionStrength\")\r\n    private _blurDispersionStrength = 0.03;\r\n\r\n    /**\r\n     * Gets or sets the blur dispersion strength. Set this value to 0 to disable blurring (default: 0.05)\r\n     * The reflections are blurred based on the roughness of the surface and the distance between the pixel shaded and the reflected pixel: the higher the distance the more blurry the reflection is.\r\n     * blurDispersionStrength allows to increase or decrease this effect.\r\n     */\r\n    public get blurDispersionStrength() {\r\n        return this._blurDispersionStrength;\r\n    }\r\n\r\n    public set blurDispersionStrength(strength: number) {\r\n        if (strength === this._blurDispersionStrength) {\r\n            return;\r\n        }\r\n\r\n        const rebuild = (strength === 0 && this._blurDispersionStrength !== 0) || (strength !== 0 && this._blurDispersionStrength === 0);\r\n\r\n        this._blurDispersionStrength = strength;\r\n\r\n        if (rebuild) {\r\n            this._buildPipeline();\r\n        }\r\n    }\r\n\r\n    private _useBlur() {\r\n        return this._blurDispersionStrength > 0;\r\n    }\r\n\r\n    @serialize(\"blurDownsample\")\r\n    private _blurDownsample = 0;\r\n\r\n    /**\r\n     * Gets or sets the downsample factor used to reduce the size of the textures used to blur the reflection effect (default: 0).\r\n     * Use 0 to blur at full resolution, 1 to render at half resolution, 2 to render at 1/3 resolution, etc.\r\n     */\r\n    public get blurDownsample() {\r\n        return this._blurDownsample;\r\n    }\r\n\r\n    public set blurDownsample(downsample: number) {\r\n        if (downsample === this._blurDownsample) {\r\n            return;\r\n        }\r\n\r\n        this._blurDownsample = downsample;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize(\"enableSmoothReflections\")\r\n    private _enableSmoothReflections = false;\r\n\r\n    /**\r\n     * Gets or sets whether or not smoothing reflections is enabled (default: false)\r\n     * Enabling smoothing will require more GPU power.\r\n     * Note that this setting has no effect if step = 1: it's only used if step \\> 1.\r\n     */\r\n    public get enableSmoothReflections(): boolean {\r\n        return this._enableSmoothReflections;\r\n    }\r\n\r\n    public set enableSmoothReflections(enabled: boolean) {\r\n        if (enabled === this._enableSmoothReflections) {\r\n            return;\r\n        }\r\n\r\n        this._enableSmoothReflections = enabled;\r\n        this._updateEffectDefines();\r\n    }\r\n\r\n    @serialize(\"environmentTexture\")\r\n    private _environmentTexture: Nullable<CubeTexture>;\r\n\r\n    /**\r\n     * Gets or sets the environment cube texture used to define the reflection when the reflected rays of SSR leave the view space or when the maxDistance/maxSteps is reached.\r\n     */\r\n    public get environmentTexture() {\r\n        return this._environmentTexture;\r\n    }\r\n\r\n    public set environmentTexture(texture: Nullable<CubeTexture>) {\r\n        this._environmentTexture = texture;\r\n        this._updateEffectDefines();\r\n    }\r\n\r\n    @serialize(\"environmentTextureIsProbe\")\r\n    private _environmentTextureIsProbe = false;\r\n\r\n    /**\r\n     * Gets or sets the boolean defining if the environment texture is a standard cubemap (false) or a probe (true). Default value is false.\r\n     * Note: a probe cube texture is treated differently than an ordinary cube texture because the Y axis is reversed.\r\n     */\r\n    public get environmentTextureIsProbe(): boolean {\r\n        return this._environmentTextureIsProbe;\r\n    }\r\n\r\n    public set environmentTextureIsProbe(isProbe: boolean) {\r\n        this._environmentTextureIsProbe = isProbe;\r\n        this._updateEffectDefines();\r\n    }\r\n\r\n    @serialize(\"attenuateScreenBorders\")\r\n    private _attenuateScreenBorders = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the reflections should be attenuated at the screen borders (default: true).\r\n     */\r\n    public get attenuateScreenBorders() {\r\n        return this._attenuateScreenBorders;\r\n    }\r\n\r\n    public set attenuateScreenBorders(attenuate: boolean) {\r\n        if (this._attenuateScreenBorders === attenuate) {\r\n            return;\r\n        }\r\n        this._attenuateScreenBorders = attenuate;\r\n        this._updateEffectDefines();\r\n    }\r\n\r\n    @serialize(\"attenuateIntersectionDistance\")\r\n    private _attenuateIntersectionDistance = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the reflections should be attenuated according to the distance of the intersection (default: true).\r\n     */\r\n    public get attenuateIntersectionDistance() {\r\n        return this._attenuateIntersectionDistance;\r\n    }\r\n\r\n    public set attenuateIntersectionDistance(attenuate: boolean) {\r\n        if (this._attenuateIntersectionDistance === attenuate) {\r\n            return;\r\n        }\r\n        this._attenuateIntersectionDistance = attenuate;\r\n        this._updateEffectDefines();\r\n    }\r\n\r\n    @serialize(\"attenuateIntersectionIterations\")\r\n    private _attenuateIntersectionIterations = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the reflections should be attenuated according to the number of iterations performed to find the intersection (default: true).\r\n     */\r\n    public get attenuateIntersectionIterations() {\r\n        return this._attenuateIntersectionIterations;\r\n    }\r\n\r\n    public set attenuateIntersectionIterations(attenuate: boolean) {\r\n        if (this._attenuateIntersectionIterations === attenuate) {\r\n            return;\r\n        }\r\n        this._attenuateIntersectionIterations = attenuate;\r\n        this._updateEffectDefines();\r\n    }\r\n\r\n    @serialize(\"attenuateFacingCamera\")\r\n    private _attenuateFacingCamera = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the reflections should be attenuated when the reflection ray is facing the camera (the view direction) (default: false).\r\n     */\r\n    public get attenuateFacingCamera() {\r\n        return this._attenuateFacingCamera;\r\n    }\r\n\r\n    public set attenuateFacingCamera(attenuate: boolean) {\r\n        if (this._attenuateFacingCamera === attenuate) {\r\n            return;\r\n        }\r\n        this._attenuateFacingCamera = attenuate;\r\n        this._updateEffectDefines();\r\n    }\r\n\r\n    @serialize(\"attenuateBackfaceReflection\")\r\n    private _attenuateBackfaceReflection = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the backface reflections should be attenuated (default: false).\r\n     */\r\n    public get attenuateBackfaceReflection() {\r\n        return this._attenuateBackfaceReflection;\r\n    }\r\n\r\n    public set attenuateBackfaceReflection(attenuate: boolean) {\r\n        if (this._attenuateBackfaceReflection === attenuate) {\r\n            return;\r\n        }\r\n        this._attenuateBackfaceReflection = attenuate;\r\n        this._updateEffectDefines();\r\n    }\r\n\r\n    @serialize(\"clipToFrustum\")\r\n    private _clipToFrustum = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the ray should be clipped to the frustum (default: true).\r\n     * You can try to set this parameter to false to save some performances: it may produce some artefacts in some cases, but generally they won't really be visible\r\n     */\r\n    public get clipToFrustum() {\r\n        return this._clipToFrustum;\r\n    }\r\n\r\n    public set clipToFrustum(clip: boolean) {\r\n        if (this._clipToFrustum === clip) {\r\n            return;\r\n        }\r\n        this._clipToFrustum = clip;\r\n        this._updateEffectDefines();\r\n    }\r\n\r\n    @serialize(\"useFresnel\")\r\n    private _useFresnel = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating whether the blending between the current color pixel and the reflection color should be done with a Fresnel coefficient (default: false).\r\n     * It is more physically accurate to use the Fresnel coefficient (otherwise it uses the reflectivity of the material for blending), but it is also more expensive when you use blur (when blurDispersionStrength \\> 0).\r\n     */\r\n    public get useFresnel() {\r\n        return this._useFresnel;\r\n    }\r\n\r\n    public set useFresnel(fresnel: boolean) {\r\n        if (this._useFresnel === fresnel) {\r\n            return;\r\n        }\r\n        this._useFresnel = fresnel;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize(\"enableAutomaticThicknessComputation\")\r\n    private _enableAutomaticThicknessComputation = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean defining if geometry thickness should be computed automatically (default: false).\r\n     * When enabled, a depth renderer is created which will render the back faces of the scene to a depth texture (meaning additional work for the GPU).\r\n     * In that mode, the \"thickness\" property is still used as an offset to compute the ray intersection, but you can typically use a much lower\r\n     * value than when enableAutomaticThicknessComputation is false (it's even possible to use a value of 0 when using low values for \"step\")\r\n     * Note that for performance reasons, this option will only apply to the first camera to which the the rendering pipeline is attached!\r\n     */\r\n    public get enableAutomaticThicknessComputation(): boolean {\r\n        return this._enableAutomaticThicknessComputation;\r\n    }\r\n\r\n    public set enableAutomaticThicknessComputation(automatic: boolean) {\r\n        if (this._enableAutomaticThicknessComputation === automatic) {\r\n            return;\r\n        }\r\n\r\n        this._enableAutomaticThicknessComputation = automatic;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Gets the depth renderer used to render the back faces of the scene to a depth texture.\r\n     */\r\n    public get backfaceDepthRenderer(): Nullable<DepthRenderer> {\r\n        return this._depthRenderer;\r\n    }\r\n\r\n    @serialize(\"backfaceDepthTextureDownsample\")\r\n    private _backfaceDepthTextureDownsample = 0;\r\n\r\n    /**\r\n     * Gets or sets the downsample factor (default: 0) used to create the backface depth texture - used only if enableAutomaticThicknessComputation = true.\r\n     * Use 0 to render the depth at full resolution, 1 to render at half resolution, 2 to render at 1/4 resolution, etc.\r\n     * Note that you will get rendering artefacts when using a value different from 0: it's a tradeoff between image quality and performances.\r\n     */\r\n    public get backfaceDepthTextureDownsample() {\r\n        return this._backfaceDepthTextureDownsample;\r\n    }\r\n\r\n    public set backfaceDepthTextureDownsample(factor: number) {\r\n        if (this._backfaceDepthTextureDownsample === factor) {\r\n            return;\r\n        }\r\n\r\n        this._backfaceDepthTextureDownsample = factor;\r\n        this._resizeDepthRenderer();\r\n    }\r\n\r\n    @serialize(\"backfaceForceDepthWriteTransparentMeshes\")\r\n    private _backfaceForceDepthWriteTransparentMeshes = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean (default: true) indicating if the depth of transparent meshes should be written to the backface depth texture (when automatic thickness computation is enabled).\r\n     */\r\n    public get backfaceForceDepthWriteTransparentMeshes() {\r\n        return this._backfaceForceDepthWriteTransparentMeshes;\r\n    }\r\n\r\n    public set backfaceForceDepthWriteTransparentMeshes(force: boolean) {\r\n        if (this._backfaceForceDepthWriteTransparentMeshes === force) {\r\n            return;\r\n        }\r\n\r\n        this._backfaceForceDepthWriteTransparentMeshes = force;\r\n\r\n        if (this._depthRenderer) {\r\n            this._depthRenderer.forceDepthWriteTransparentMeshes = force;\r\n        }\r\n    }\r\n\r\n    @serialize(\"isEnabled\")\r\n    private _isEnabled = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the effect is enabled (default: true).\r\n     */\r\n    public get isEnabled(): boolean {\r\n        return this._isEnabled;\r\n    }\r\n\r\n    public set isEnabled(value: boolean) {\r\n        if (this._isEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._isEnabled = value;\r\n\r\n        if (!value) {\r\n            if (this._cameras !== null) {\r\n                this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\r\n                this._cameras = this._camerasToBeAttached.slice();\r\n            }\r\n        } else if (value) {\r\n            if (!this._isDirty) {\r\n                if (this._cameras !== null) {\r\n                    this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);\r\n                }\r\n            } else {\r\n                this._buildPipeline();\r\n            }\r\n        }\r\n    }\r\n\r\n    @serialize(\"inputTextureColorIsInGammaSpace\")\r\n    private _inputTextureColorIsInGammaSpace = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean defining if the input color texture is in gamma space (default: true)\r\n     * The SSR effect works in linear space, so if the input texture is in gamma space, we must convert the texture to linear space before applying the effect\r\n     */\r\n    public get inputTextureColorIsInGammaSpace(): boolean {\r\n        return this._inputTextureColorIsInGammaSpace;\r\n    }\r\n\r\n    public set inputTextureColorIsInGammaSpace(gammaSpace: boolean) {\r\n        if (this._inputTextureColorIsInGammaSpace === gammaSpace) {\r\n            return;\r\n        }\r\n\r\n        this._inputTextureColorIsInGammaSpace = gammaSpace;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize(\"generateOutputInGammaSpace\")\r\n    private _generateOutputInGammaSpace = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean defining if the output color texture generated by the SSR pipeline should be in gamma space (default: true)\r\n     * If you have a post-process that comes after the SSR and that post-process needs the input to be in a linear space, you must disable generateOutputInGammaSpace\r\n     */\r\n    public get generateOutputInGammaSpace(): boolean {\r\n        return this._generateOutputInGammaSpace;\r\n    }\r\n\r\n    public set generateOutputInGammaSpace(gammaSpace: boolean) {\r\n        if (this._generateOutputInGammaSpace === gammaSpace) {\r\n            return;\r\n        }\r\n\r\n        this._generateOutputInGammaSpace = gammaSpace;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize(\"debug\")\r\n    private _debug = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the effect should be rendered in debug mode (default: false).\r\n     * In this mode, colors have this meaning:\r\n     *   - blue: the ray hit the max distance (we reached maxDistance)\r\n     *   - red: the ray ran out of steps (we reached maxSteps)\r\n     *   - yellow: the ray went off screen\r\n     *   - green: the ray hit a surface. The brightness of the green color is proportional to the distance between the ray origin and the intersection point: A brighter green means more computation than a darker green.\r\n     * In the first 3 cases, the final color is calculated by mixing the skybox color with the pixel color (if environmentTexture is defined), otherwise the pixel color is not modified\r\n     * You should try to get as few blue/red/yellow pixels as possible, as this means that the ray has gone further than if it had hit a surface.\r\n     */\r\n    public get debug(): boolean {\r\n        return this._debug;\r\n    }\r\n\r\n    public set debug(value: boolean) {\r\n        if (this._debug === value) {\r\n            return;\r\n        }\r\n\r\n        this._debug = value;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Gets the scene the effect belongs to.\r\n     * @returns the scene the effect belongs to.\r\n     */\r\n    public getScene() {\r\n        return this._scene;\r\n    }\r\n\r\n    private _forceGeometryBuffer = false;\r\n    private get _geometryBufferRenderer(): Nullable<GeometryBufferRenderer> {\r\n        if (!this._forceGeometryBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.geometryBufferRenderer;\r\n    }\r\n\r\n    private get _prePassRenderer(): Nullable<PrePassRenderer> {\r\n        if (this._forceGeometryBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.prePassRenderer;\r\n    }\r\n\r\n    private _scene: Scene;\r\n    private _isDirty = false;\r\n    private _camerasToBeAttached: Array<Camera> = [];\r\n    private _textureType: number;\r\n    private _ssrPostProcess: Nullable<PostProcess>;\r\n    private _blurPostProcessX: Nullable<PostProcess>;\r\n    private _blurPostProcessY: Nullable<PostProcess>;\r\n    private _blurCombinerPostProcess: Nullable<PostProcess>;\r\n    private _depthRenderer: Nullable<DepthRenderer>;\r\n    private _depthRendererCamera: Nullable<Camera>;\r\n\r\n    /**\r\n     * Gets active scene\r\n     */\r\n    public get scene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Returns true if SSR is supported by the running hardware\r\n     */\r\n    public get isSupported(): boolean {\r\n        const caps = this._scene.getEngine().getCaps();\r\n\r\n        return caps.drawBuffersExtension && caps.texelFetch;\r\n    }\r\n\r\n    /**\r\n     * Constructor of the SSR rendering pipeline\r\n     * @param name The rendering pipeline name\r\n     * @param scene The scene linked to this pipeline\r\n     * @param cameras The array of cameras that the rendering pipeline will be attached to (default: scene.cameras)\r\n     * @param forceGeometryBuffer Set to true if you want to use the legacy geometry buffer renderer (default: false)\r\n     * @param textureType The texture type used by the different post processes created by SSR (default: Constants.TEXTURETYPE_UNSIGNED_BYTE)\r\n     */\r\n    constructor(name: string, scene: Scene, cameras?: Camera[], forceGeometryBuffer = false, textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE) {\r\n        super(scene.getEngine(), name);\r\n\r\n        this._cameras = cameras || scene.cameras;\r\n        this._cameras = this._cameras.slice();\r\n        this._camerasToBeAttached = this._cameras.slice();\r\n\r\n        this._scene = scene;\r\n        this._textureType = textureType;\r\n        this._forceGeometryBuffer = forceGeometryBuffer;\r\n\r\n        if (this.isSupported) {\r\n            scene.postProcessRenderPipelineManager.addPipeline(this);\r\n\r\n            if (this._forceGeometryBuffer) {\r\n                const geometryBufferRenderer = scene.enableGeometryBufferRenderer();\r\n                if (geometryBufferRenderer) {\r\n                    geometryBufferRenderer.enableReflectivity = true;\r\n                    geometryBufferRenderer.useSpecificClearForDepthTexture = true;\r\n                    if (geometryBufferRenderer.generateNormalsInWorldSpace) {\r\n                        console.error(\"SSRRenderingPipeline does not support generateNormalsInWorldSpace=true for the geometry buffer renderer!\");\r\n                    }\r\n                }\r\n            } else {\r\n                const prePassRenderer = scene.enablePrePassRenderer();\r\n                if (prePassRenderer) {\r\n                    prePassRenderer.useSpecificClearForDepthTexture = true;\r\n                    prePassRenderer.markAsDirty();\r\n                    if (prePassRenderer.generateNormalsInWorldSpace) {\r\n                        console.error(\"SSRRenderingPipeline does not support generateNormalsInWorldSpace=true for the prepass renderer!\");\r\n                    }\r\n                }\r\n            }\r\n\r\n            this._buildPipeline();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the class name\r\n     * @returns \"SSRRenderingPipeline\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"SSRRenderingPipeline\";\r\n    }\r\n\r\n    /**\r\n     * Adds a camera to the pipeline\r\n     * @param camera the camera to be added\r\n     */\r\n    public addCamera(camera: Camera): void {\r\n        this._camerasToBeAttached.push(camera);\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Removes a camera from the pipeline\r\n     * @param camera the camera to remove\r\n     */\r\n    public removeCamera(camera: Camera): void {\r\n        const index = this._camerasToBeAttached.indexOf(camera);\r\n        this._camerasToBeAttached.splice(index, 1);\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Removes the internal pipeline assets and detaches the pipeline from the scene cameras\r\n     * @param disableGeometryBufferRenderer\r\n     */\r\n    public dispose(disableGeometryBufferRenderer: boolean = false): void {\r\n        this._disposeDepthRenderer();\r\n        this._disposePostProcesses();\r\n\r\n        if (disableGeometryBufferRenderer) {\r\n            this._scene.disableGeometryBufferRenderer();\r\n        }\r\n\r\n        this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    private _getTextureSize() {\r\n        const engine = this._scene.getEngine();\r\n        const prePassRenderer = this._prePassRenderer;\r\n\r\n        let textureSize: ISize = { width: engine.getRenderWidth(), height: engine.getRenderHeight() };\r\n\r\n        if (prePassRenderer && this._scene.activeCamera?._getFirstPostProcess() === this._ssrPostProcess) {\r\n            const renderTarget = prePassRenderer.getRenderTarget();\r\n\r\n            if (renderTarget && renderTarget.textures) {\r\n                textureSize = renderTarget.textures[prePassRenderer.getIndex(Constants.PREPASS_COLOR_TEXTURE_TYPE)].getSize();\r\n            }\r\n        } else if (this._ssrPostProcess?.inputTexture) {\r\n            textureSize.width = this._ssrPostProcess.inputTexture.width;\r\n            textureSize.height = this._ssrPostProcess.inputTexture.height;\r\n        }\r\n\r\n        return textureSize;\r\n    }\r\n\r\n    private _updateEffectDefines(): void {\r\n        const defines: string[] = [];\r\n\r\n        if (this._geometryBufferRenderer || this._prePassRenderer) {\r\n            defines.push(\"#define SSR_SUPPORTED\");\r\n        }\r\n        if (this._enableSmoothReflections) {\r\n            defines.push(\"#define SSRAYTRACE_ENABLE_REFINEMENT\");\r\n        }\r\n        if (this._scene.useRightHandedSystem) {\r\n            defines.push(\"#define SSRAYTRACE_RIGHT_HANDED_SCENE\");\r\n        }\r\n        if (this._environmentTexture) {\r\n            defines.push(\"#define SSR_USE_ENVIRONMENT_CUBE\");\r\n            if (this._environmentTexture.boundingBoxSize) {\r\n                defines.push(\"#define SSR_USE_LOCAL_REFLECTIONMAP_CUBIC\");\r\n            }\r\n            if (this._environmentTexture.gammaSpace) {\r\n                defines.push(\"#define SSR_ENVIRONMENT_CUBE_IS_GAMMASPACE\");\r\n            }\r\n        }\r\n        if (this._environmentTextureIsProbe) {\r\n            defines.push(\"#define SSR_INVERTCUBICMAP\");\r\n        }\r\n        if (this._enableAutomaticThicknessComputation) {\r\n            defines.push(\"#define SSRAYTRACE_USE_BACK_DEPTHBUFFER\");\r\n        }\r\n        if (this._attenuateScreenBorders) {\r\n            defines.push(\"#define SSR_ATTENUATE_SCREEN_BORDERS\");\r\n        }\r\n        if (this._attenuateIntersectionDistance) {\r\n            defines.push(\"#define SSR_ATTENUATE_INTERSECTION_DISTANCE\");\r\n        }\r\n        if (this._attenuateIntersectionIterations) {\r\n            defines.push(\"#define SSR_ATTENUATE_INTERSECTION_NUMITERATIONS\");\r\n        }\r\n        if (this._attenuateFacingCamera) {\r\n            defines.push(\"#define SSR_ATTENUATE_FACING_CAMERA\");\r\n        }\r\n        if (this._attenuateBackfaceReflection) {\r\n            defines.push(\"#define SSR_ATTENUATE_BACKFACE_REFLECTION\");\r\n        }\r\n        if (this._clipToFrustum) {\r\n            defines.push(\"#define SSRAYTRACE_CLIP_TO_FRUSTUM\");\r\n        }\r\n        if (this._useBlur()) {\r\n            defines.push(\"#define SSR_USE_BLUR\");\r\n        }\r\n        if (this._debug) {\r\n            defines.push(\"#define SSRAYTRACE_DEBUG\");\r\n        }\r\n        if (this._inputTextureColorIsInGammaSpace) {\r\n            defines.push(\"#define SSR_INPUT_IS_GAMMA_SPACE\");\r\n        }\r\n        if (this._generateOutputInGammaSpace) {\r\n            defines.push(\"#define SSR_OUTPUT_IS_GAMMA_SPACE\");\r\n        }\r\n        if (this._useFresnel) {\r\n            defines.push(\"#define SSR_BLEND_WITH_FRESNEL\");\r\n        }\r\n        if (this._reflectivityThreshold === 0) {\r\n            defines.push(\"#define SSR_DISABLE_REFLECTIVITY_TEST\");\r\n        }\r\n\r\n        this._ssrPostProcess?.updateEffect(defines.join(\"\\n\"));\r\n    }\r\n\r\n    private _buildPipeline() {\r\n        if (!this.isSupported) {\r\n            return;\r\n        }\r\n\r\n        if (!this._isEnabled) {\r\n            this._isDirty = true;\r\n            return;\r\n        }\r\n\r\n        this._isDirty = false;\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        this._disposeDepthRenderer();\r\n        this._disposePostProcesses();\r\n        if (this._cameras !== null) {\r\n            this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\r\n            // get back cameras to be used to reattach pipeline\r\n            this._cameras = this._camerasToBeAttached.slice();\r\n        }\r\n        this._reset();\r\n\r\n        if (this._enableAutomaticThicknessComputation) {\r\n            const camera = this._cameras?.[0];\r\n\r\n            if (camera) {\r\n                this._depthRendererCamera = camera;\r\n                this._depthRenderer = new DepthRenderer(this._scene, undefined, undefined, undefined, Constants.TEXTURE_NEAREST_SAMPLINGMODE, true, \"SSRBackDepth\");\r\n                this._depthRenderer.clearColor.r = 1e8; // \"infinity\": put a big value because we use the storeCameraSpaceZ mode\r\n                this._depthRenderer.reverseCulling = true; // we generate depth for the back faces\r\n                this._depthRenderer.forceDepthWriteTransparentMeshes = this._backfaceForceDepthWriteTransparentMeshes;\r\n\r\n                this._resizeDepthRenderer();\r\n\r\n                camera.customRenderTargets.push(this._depthRenderer.getDepthMap());\r\n            }\r\n        }\r\n\r\n        this._createSSRPostProcess();\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                engine,\r\n                this.SSRRenderEffect,\r\n                () => {\r\n                    return this._ssrPostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n\r\n        if (this._useBlur()) {\r\n            this._createBlurAndCombinerPostProcesses();\r\n            this.addEffect(\r\n                new PostProcessRenderEffect(\r\n                    engine,\r\n                    this.SSRBlurRenderEffect,\r\n                    () => {\r\n                        return [this._blurPostProcessX!, this._blurPostProcessY!];\r\n                    },\r\n                    true\r\n                )\r\n            );\r\n            this.addEffect(\r\n                new PostProcessRenderEffect(\r\n                    engine,\r\n                    this.SSRCombineRenderEffect,\r\n                    () => {\r\n                        return this._blurCombinerPostProcess;\r\n                    },\r\n                    true\r\n                )\r\n            );\r\n        }\r\n\r\n        if (this._cameras !== null) {\r\n            this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);\r\n        }\r\n    }\r\n\r\n    private _resizeDepthRenderer() {\r\n        if (!this._depthRenderer) {\r\n            return;\r\n        }\r\n\r\n        const textureSize = this._getTextureSize();\r\n        const depthRendererSize = this._depthRenderer.getDepthMap().getSize();\r\n\r\n        const width = Math.floor(textureSize.width / (this._backfaceDepthTextureDownsample + 1));\r\n        const height = Math.floor(textureSize.height / (this._backfaceDepthTextureDownsample + 1));\r\n\r\n        if (depthRendererSize.width !== width || depthRendererSize.height !== height) {\r\n            this._depthRenderer.getDepthMap().resize({ width, height });\r\n        }\r\n    }\r\n\r\n    private _disposeDepthRenderer() {\r\n        if (this._depthRenderer) {\r\n            if (this._depthRendererCamera) {\r\n                const idx = this._depthRendererCamera.customRenderTargets.indexOf(this._depthRenderer.getDepthMap()) ?? -1;\r\n                if (idx !== -1) {\r\n                    this._depthRendererCamera.customRenderTargets.splice(idx, 1);\r\n                }\r\n            }\r\n            this._depthRendererCamera = null;\r\n            this._depthRenderer.getDepthMap().dispose();\r\n        }\r\n        this._depthRenderer = null;\r\n    }\r\n\r\n    private _disposePostProcesses(): void {\r\n        for (let i = 0; i < this._cameras.length; i++) {\r\n            const camera = this._cameras[i];\r\n\r\n            this._ssrPostProcess?.dispose(camera);\r\n            this._blurPostProcessX?.dispose(camera);\r\n            this._blurPostProcessY?.dispose(camera);\r\n            this._blurCombinerPostProcess?.dispose(camera);\r\n        }\r\n\r\n        this._ssrPostProcess = null;\r\n        this._blurPostProcessX = null;\r\n        this._blurPostProcessY = null;\r\n        this._blurCombinerPostProcess = null;\r\n    }\r\n\r\n    private _createSSRPostProcess(): void {\r\n        this._ssrPostProcess = new PostProcess(\r\n            \"ssr\",\r\n            \"screenSpaceReflection2\",\r\n            [\r\n                \"projection\",\r\n                \"invProjectionMatrix\",\r\n                \"view\",\r\n                \"invView\",\r\n                \"thickness\",\r\n                \"reflectionSpecularFalloffExponent\",\r\n                \"strength\",\r\n                \"stepSize\",\r\n                \"maxSteps\",\r\n                \"roughnessFactor\",\r\n                \"projectionPixel\",\r\n                \"nearPlaneZ\",\r\n                \"maxDistance\",\r\n                \"selfCollisionNumSkip\",\r\n                \"vReflectionPosition\",\r\n                \"vReflectionSize\",\r\n                \"backSizeFactor\",\r\n                \"reflectivityThreshold\",\r\n            ],\r\n            [\"textureSampler\", \"normalSampler\", \"reflectivitySampler\", \"depthSampler\", \"envCubeSampler\", \"backDepthSampler\"],\r\n            1.0,\r\n            null,\r\n            this._textureType,\r\n            this._scene.getEngine(),\r\n            false,\r\n            \"\",\r\n            this._textureType\r\n        );\r\n\r\n        this._updateEffectDefines();\r\n\r\n        this._ssrPostProcess.onApply = (effect: Effect) => {\r\n            this._resizeDepthRenderer();\r\n\r\n            const geometryBufferRenderer = this._geometryBufferRenderer;\r\n            const prePassRenderer = this._prePassRenderer;\r\n\r\n            if (!prePassRenderer && !geometryBufferRenderer) {\r\n                return;\r\n            }\r\n\r\n            if (geometryBufferRenderer) {\r\n                const roughnessIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE);\r\n\r\n                effect.setTexture(\"normalSampler\", geometryBufferRenderer.getGBuffer().textures[1]);\r\n                effect.setTexture(\"reflectivitySampler\", geometryBufferRenderer.getGBuffer().textures[roughnessIndex]);\r\n                effect.setTexture(\"depthSampler\", geometryBufferRenderer.getGBuffer().textures[0]);\r\n            } else if (prePassRenderer) {\r\n                const depthIndex = prePassRenderer.getIndex(Constants.PREPASS_DEPTH_TEXTURE_TYPE);\r\n                const roughnessIndex = prePassRenderer.getIndex(Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE);\r\n                const normalIndex = prePassRenderer.getIndex(Constants.PREPASS_NORMAL_TEXTURE_TYPE);\r\n\r\n                effect.setTexture(\"normalSampler\", prePassRenderer.getRenderTarget().textures[normalIndex]);\r\n                effect.setTexture(\"depthSampler\", prePassRenderer.getRenderTarget().textures[depthIndex]);\r\n                effect.setTexture(\"reflectivitySampler\", prePassRenderer.getRenderTarget().textures[roughnessIndex]);\r\n            }\r\n\r\n            if (this._enableAutomaticThicknessComputation && this._depthRenderer) {\r\n                effect.setTexture(\"backDepthSampler\", this._depthRenderer.getDepthMap());\r\n                effect.setFloat(\"backSizeFactor\", this._backfaceDepthTextureDownsample + 1);\r\n            }\r\n\r\n            const camera = this._scene.activeCamera;\r\n            if (!camera) {\r\n                return;\r\n            }\r\n\r\n            const viewMatrix = camera.getViewMatrix(true);\r\n            const projectionMatrix = camera.getProjectionMatrix(true);\r\n\r\n            projectionMatrix.invertToRef(TmpVectors.Matrix[0]);\r\n            viewMatrix.invertToRef(TmpVectors.Matrix[1]);\r\n\r\n            effect.setMatrix(\"projection\", projectionMatrix);\r\n            effect.setMatrix(\"view\", viewMatrix);\r\n            effect.setMatrix(\"invView\", TmpVectors.Matrix[1]);\r\n            effect.setMatrix(\"invProjectionMatrix\", TmpVectors.Matrix[0]);\r\n            effect.setFloat(\"thickness\", this.thickness);\r\n            effect.setFloat(\"reflectionSpecularFalloffExponent\", this.reflectionSpecularFalloffExponent);\r\n            effect.setFloat(\"strength\", this.strength);\r\n            effect.setFloat(\"stepSize\", this.step);\r\n            effect.setFloat(\"maxSteps\", this.maxSteps);\r\n            effect.setFloat(\"roughnessFactor\", this.roughnessFactor);\r\n            effect.setFloat(\"nearPlaneZ\", camera.minZ);\r\n            effect.setFloat(\"maxDistance\", this.maxDistance);\r\n            effect.setFloat(\"selfCollisionNumSkip\", this.selfCollisionNumSkip);\r\n            effect.setFloat(\"reflectivityThreshold\", this._reflectivityThreshold);\r\n\r\n            const textureSize = this._getTextureSize();\r\n\r\n            Matrix.ScalingToRef(textureSize!.width, textureSize!.height, 1, TmpVectors.Matrix[2]);\r\n\r\n            projectionMatrix.multiplyToRef(this._scene.getEngine().isWebGPU ? trsWebGPU : trs, TmpVectors.Matrix[3]);\r\n\r\n            TmpVectors.Matrix[3].multiplyToRef(TmpVectors.Matrix[2], TmpVectors.Matrix[4]);\r\n\r\n            effect.setMatrix(\"projectionPixel\", TmpVectors.Matrix[4]);\r\n\r\n            if (this._environmentTexture) {\r\n                effect.setTexture(\"envCubeSampler\", this._environmentTexture);\r\n\r\n                if (this._environmentTexture.boundingBoxSize) {\r\n                    effect.setVector3(\"vReflectionPosition\", this._environmentTexture.boundingBoxPosition);\r\n                    effect.setVector3(\"vReflectionSize\", this._environmentTexture.boundingBoxSize);\r\n                }\r\n            }\r\n        };\r\n        this._ssrPostProcess.samples = this.samples;\r\n\r\n        if (!this._forceGeometryBuffer) {\r\n            this._ssrPostProcess._prePassEffectConfiguration = new ScreenSpaceReflections2Configuration();\r\n        }\r\n    }\r\n\r\n    private _createBlurAndCombinerPostProcesses() {\r\n        const engine = this._scene.getEngine();\r\n\r\n        this._blurPostProcessX = new PostProcess(\r\n            \"SSRblurX\",\r\n            \"screenSpaceReflection2Blur\",\r\n            [\"texelOffsetScale\"],\r\n            [\"textureSampler\"],\r\n            this._useBlur() ? 1 / (this._ssrDownsample + 1) : 1,\r\n            null,\r\n            Constants.TEXTURE_BILINEAR_SAMPLINGMODE,\r\n            engine,\r\n            false,\r\n            \"\",\r\n            this._textureType\r\n        );\r\n        this._blurPostProcessX.autoClear = false;\r\n\r\n        this._blurPostProcessX.onApplyObservable.add((effect) => {\r\n            const width = this._blurPostProcessX?.inputTexture.width ?? this._scene.getEngine().getRenderWidth();\r\n\r\n            effect.setFloat2(\"texelOffsetScale\", this._blurDispersionStrength / width, 0);\r\n        });\r\n\r\n        this._blurPostProcessY = new PostProcess(\r\n            \"SSRblurY\",\r\n            \"screenSpaceReflection2Blur\",\r\n            [\"texelOffsetScale\"],\r\n            [\"textureSampler\"],\r\n            this._useBlur() ? 1 / (this._blurDownsample + 1) : 1,\r\n            null,\r\n            Constants.TEXTURE_BILINEAR_SAMPLINGMODE,\r\n            engine,\r\n            false,\r\n            \"\",\r\n            this._textureType\r\n        );\r\n        this._blurPostProcessY.autoClear = false;\r\n\r\n        this._blurPostProcessY.onApplyObservable.add((effect) => {\r\n            const height = this._blurPostProcessY?.inputTexture.height ?? this._scene.getEngine().getRenderHeight();\r\n\r\n            effect.setFloat2(\"texelOffsetScale\", 0, this._blurDispersionStrength / height);\r\n        });\r\n\r\n        const uniformNames = [\"strength\", \"reflectionSpecularFalloffExponent\", \"reflectivityThreshold\"];\r\n        const samplerNames = [\"textureSampler\", \"mainSampler\", \"reflectivitySampler\"];\r\n\r\n        let defines = \"\";\r\n\r\n        if (this._debug) {\r\n            defines += \"#define SSRAYTRACE_DEBUG\\n\";\r\n        }\r\n        if (this._inputTextureColorIsInGammaSpace) {\r\n            defines += \"#define SSR_INPUT_IS_GAMMA_SPACE\\n\";\r\n        }\r\n        if (this._generateOutputInGammaSpace) {\r\n            defines += \"#define SSR_OUTPUT_IS_GAMMA_SPACE\\n\";\r\n        }\r\n        if (this.useFresnel) {\r\n            defines += \"#define SSR_BLEND_WITH_FRESNEL\\n\";\r\n\r\n            uniformNames.push(\"projection\", \"invProjectionMatrix\");\r\n            samplerNames.push(\"depthSampler\", \"normalSampler\");\r\n        }\r\n        if (this._reflectivityThreshold === 0) {\r\n            defines += \"#define SSR_DISABLE_REFLECTIVITY_TEST\";\r\n        }\r\n\r\n        this._blurCombinerPostProcess = new PostProcess(\r\n            \"SSRblurCombiner\",\r\n            \"screenSpaceReflection2BlurCombiner\",\r\n            uniformNames,\r\n            samplerNames,\r\n            this._useBlur() ? 1 / (this._blurDownsample + 1) : 1,\r\n            null,\r\n            Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n            engine,\r\n            false,\r\n            defines,\r\n            this._textureType\r\n        );\r\n        this._blurCombinerPostProcess.autoClear = false;\r\n\r\n        this._blurCombinerPostProcess.onApplyObservable.add((effect) => {\r\n            const geometryBufferRenderer = this._geometryBufferRenderer;\r\n            const prePassRenderer = this._prePassRenderer;\r\n\r\n            if (!prePassRenderer && !geometryBufferRenderer) {\r\n                return;\r\n            }\r\n\r\n            if (prePassRenderer && this._scene.activeCamera?._getFirstPostProcess() === this._ssrPostProcess) {\r\n                const renderTarget = prePassRenderer.getRenderTarget();\r\n\r\n                if (renderTarget && renderTarget.textures) {\r\n                    effect.setTexture(\"mainSampler\", renderTarget.textures[prePassRenderer.getIndex(Constants.PREPASS_COLOR_TEXTURE_TYPE)]);\r\n                }\r\n            } else {\r\n                effect.setTextureFromPostProcess(\"mainSampler\", this._ssrPostProcess);\r\n            }\r\n\r\n            if (geometryBufferRenderer) {\r\n                const roughnessIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE);\r\n                effect.setTexture(\"reflectivitySampler\", geometryBufferRenderer.getGBuffer().textures[roughnessIndex]);\r\n                if (this.useFresnel) {\r\n                    effect.setTexture(\"normalSampler\", geometryBufferRenderer.getGBuffer().textures[1]);\r\n                    effect.setTexture(\"depthSampler\", geometryBufferRenderer.getGBuffer().textures[0]);\r\n                }\r\n            } else if (prePassRenderer) {\r\n                const roughnessIndex = prePassRenderer.getIndex(Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE);\r\n                effect.setTexture(\"reflectivitySampler\", prePassRenderer.getRenderTarget().textures[roughnessIndex]);\r\n                if (this.useFresnel) {\r\n                    const depthIndex = prePassRenderer.getIndex(Constants.PREPASS_DEPTH_TEXTURE_TYPE);\r\n                    const normalIndex = prePassRenderer.getIndex(Constants.PREPASS_NORMAL_TEXTURE_TYPE);\r\n\r\n                    effect.setTexture(\"normalSampler\", prePassRenderer.getRenderTarget().textures[normalIndex]);\r\n                    effect.setTexture(\"depthSampler\", prePassRenderer.getRenderTarget().textures[depthIndex]);\r\n                }\r\n            }\r\n\r\n            effect.setFloat(\"strength\", this.strength);\r\n            effect.setFloat(\"reflectionSpecularFalloffExponent\", this.reflectionSpecularFalloffExponent);\r\n            effect.setFloat(\"reflectivityThreshold\", this._reflectivityThreshold);\r\n\r\n            if (this.useFresnel) {\r\n                const camera = this._scene.activeCamera;\r\n                if (camera) {\r\n                    const projectionMatrix = camera.getProjectionMatrix();\r\n\r\n                    projectionMatrix.invertToRef(TmpVectors.Matrix[0]);\r\n\r\n                    effect.setMatrix(\"projection\", projectionMatrix);\r\n                    effect.setMatrix(\"invProjectionMatrix\", TmpVectors.Matrix[0]);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Serializes the rendering pipeline (Used when exporting)\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"SSRRenderingPipeline\";\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse the serialized pipeline\r\n     * @param source Source pipeline.\r\n     * @param scene The scene to load the pipeline to.\r\n     * @param rootUrl The URL of the serialized pipeline.\r\n     * @returns An instantiated pipeline from the serialized object.\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): SSRRenderingPipeline {\r\n        return SerializationHelper.Parse(() => new SSRRenderingPipeline(source._name, scene, source._ratio), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SSRRenderingPipeline\", SSRRenderingPipeline);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}