{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\nimport { Tools } from \"./tools.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial.js\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { BaseTexture } from \"../Materials/Textures/baseTexture.js\";\nimport { Scene } from \"../scene.js\";\nimport { PostProcess } from \"../PostProcesses/postProcess.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { RGBDTextureTools } from \"./rgbdTextureTools.js\";\nimport \"../Engines/Extensions/engine.renderTargetCube.js\";\nimport \"../Engines/Extensions/engine.readTexture.js\";\nimport \"../Materials/Textures/baseTexture.polynomial.js\";\nimport \"../Shaders/rgbdEncode.fragment.js\";\nimport \"../Shaders/rgbdDecode.fragment.js\";\nimport { DumpTools } from \"../Misc/dumpTools.js\";\nconst DefaultEnvironmentTextureImageType = \"image/png\";\nconst CurrentVersion = 2;\n/**\n * Magic number identifying the env file.\n */\nconst MagicBytes = [0x86, 0x16, 0x87, 0x96, 0xf6, 0xd6, 0x96, 0x36];\n/**\n * Gets the environment info from an env file.\n * @param data The array buffer containing the .env bytes.\n * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\n */\nexport function GetEnvInfo(data) {\n  const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n  let pos = 0;\n  for (let i = 0; i < MagicBytes.length; i++) {\n    if (dataView.getUint8(pos++) !== MagicBytes[i]) {\n      Logger.Error(\"Not a babylon environment map\");\n      return null;\n    }\n  }\n  // Read json manifest - collect characters up to null terminator\n  let manifestString = \"\";\n  let charCode = 0x00;\n  while (charCode = dataView.getUint8(pos++)) {\n    manifestString += String.fromCharCode(charCode);\n  }\n  let manifest = JSON.parse(manifestString);\n  manifest = normalizeEnvInfo(manifest);\n  if (manifest.specular) {\n    // Extend the header with the position of the payload.\n    manifest.specular.specularDataPosition = pos;\n    // Fallback to 0.8 exactly if lodGenerationScale is not defined for backward compatibility.\n    manifest.specular.lodGenerationScale = manifest.specular.lodGenerationScale || 0.8;\n  }\n  return manifest;\n}\n/**\n * Normalizes any supported version of the environment file info to the latest version\n * @param info environment file info on any supported version\n * @returns environment file info in the latest supported version\n * @private\n */\nexport function normalizeEnvInfo(info) {\n  if (info.version > CurrentVersion) {\n    throw new Error(`Unsupported babylon environment map version \"${info.version}\". Latest supported version is \"${CurrentVersion}\".`);\n  }\n  if (info.version === 2) {\n    return info;\n  }\n  // Migrate a v1 info to v2\n  info = Object.assign(Object.assign({}, info), {\n    version: 2,\n    imageType: DefaultEnvironmentTextureImageType\n  });\n  return info;\n}\n/**\n * Creates an environment texture from a loaded cube texture.\n * @param texture defines the cube texture to convert in env file\n * @param options options for the conversion process\n * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\n * @param options.imageQuality the image quality of encoded WebP images.\n * @returns a promise containing the environment data if successful.\n */\nexport async function CreateEnvTextureAsync(texture, options = {}) {\n  var _a, _b;\n  const internalTexture = texture.getInternalTexture();\n  if (!internalTexture) {\n    return Promise.reject(\"The cube texture is invalid.\");\n  }\n  const imageType = (_a = options.imageType) !== null && _a !== void 0 ? _a : DefaultEnvironmentTextureImageType;\n  const engine = internalTexture.getEngine();\n  if (texture.textureType !== 2 && texture.textureType !== 1 && texture.textureType !== 0 && texture.textureType !== 0 && texture.textureType !== 7 && texture.textureType !== -1) {\n    return Promise.reject(\"The cube texture should allow HDR (Full Float or Half Float).\");\n  }\n  let textureType = 1;\n  if (!engine.getCaps().textureFloatRender) {\n    textureType = 2;\n    if (!engine.getCaps().textureHalfFloatRender) {\n      return Promise.reject(\"Env texture can only be created when the browser supports half float or full float rendering.\");\n    }\n  }\n  // sphericalPolynomial is lazy loaded so simply accessing it should trigger the computation.\n  texture.sphericalPolynomial;\n  // Lets keep track of the polynomial promise so we can wait for it to be ready before generating the pixels.\n  const sphericalPolynomialPromise = (_b = texture.getInternalTexture()) === null || _b === void 0 ? void 0 : _b._sphericalPolynomialPromise;\n  const cubeWidth = internalTexture.width;\n  const hostingScene = new Scene(engine);\n  const specularTextures = {};\n  // As we are going to readPixels the faces of the cube, make sure the drawing/update commands for the cube texture are fully sent to the GPU in case it is drawn for the first time in this very frame!\n  engine.flushFramebuffer();\n  // Read and collect all mipmaps data from the cube.\n  const mipmapsCount = Scalar.ILog2(internalTexture.width);\n  for (let i = 0; i <= mipmapsCount; i++) {\n    const faceWidth = Math.pow(2, mipmapsCount - i);\n    // All faces of the cube.\n    for (let face = 0; face < 6; face++) {\n      let faceData = await texture.readPixels(face, i, undefined, false);\n      if (faceData && faceData.byteLength === faceData.length) {\n        const faceDataFloat = new Float32Array(faceData.byteLength * 4);\n        for (let i = 0; i < faceData.byteLength; i++) {\n          faceDataFloat[i] = faceData[i] / 255;\n          // Gamma to linear\n          faceDataFloat[i] = Math.pow(faceDataFloat[i], 2.2);\n        }\n        faceData = faceDataFloat;\n      } else if (faceData && texture.gammaSpace) {\n        const floatData = faceData;\n        for (let i = 0; i < floatData.length; i++) {\n          // Gamma to linear\n          floatData[i] = Math.pow(floatData[i], 2.2);\n        }\n      }\n      const tempTexture = engine.createRawTexture(faceData, faceWidth, faceWidth, 5, false, true, 1, null, textureType);\n      await RGBDTextureTools.EncodeTextureToRGBD(tempTexture, hostingScene, textureType);\n      const rgbdEncodedData = await engine._readTexturePixels(tempTexture, faceWidth, faceWidth);\n      const imageEncodedData = await DumpTools.DumpDataAsync(faceWidth, faceWidth, rgbdEncodedData, imageType, undefined, false, true, options.imageQuality);\n      specularTextures[i * 6 + face] = imageEncodedData;\n      tempTexture.dispose();\n    }\n  }\n  // We can delete the hosting scene keeping track of all the creation objects\n  hostingScene.dispose();\n  // Ensure completion of the polynomial creation promise.\n  if (sphericalPolynomialPromise) {\n    await sphericalPolynomialPromise;\n  }\n  // Creates the json header for the env texture\n  const info = {\n    version: CurrentVersion,\n    width: cubeWidth,\n    imageType,\n    irradiance: _CreateEnvTextureIrradiance(texture),\n    specular: {\n      mipmaps: [],\n      lodGenerationScale: texture.lodGenerationScale\n    }\n  };\n  // Sets the specular image data information\n  let position = 0;\n  for (let i = 0; i <= mipmapsCount; i++) {\n    for (let face = 0; face < 6; face++) {\n      const byteLength = specularTextures[i * 6 + face].byteLength;\n      info.specular.mipmaps.push({\n        length: byteLength,\n        position: position\n      });\n      position += byteLength;\n    }\n  }\n  // Encode the JSON as an array buffer\n  const infoString = JSON.stringify(info);\n  const infoBuffer = new ArrayBuffer(infoString.length + 1);\n  const infoView = new Uint8Array(infoBuffer); // Limited to ascii subset matching unicode.\n  for (let i = 0, strLen = infoString.length; i < strLen; i++) {\n    infoView[i] = infoString.charCodeAt(i);\n  }\n  // Ends up with a null terminator for easier parsing\n  infoView[infoString.length] = 0x00;\n  // Computes the final required size and creates the storage\n  const totalSize = MagicBytes.length + position + infoBuffer.byteLength;\n  const finalBuffer = new ArrayBuffer(totalSize);\n  const finalBufferView = new Uint8Array(finalBuffer);\n  const dataView = new DataView(finalBuffer);\n  // Copy the magic bytes identifying the file in\n  let pos = 0;\n  for (let i = 0; i < MagicBytes.length; i++) {\n    dataView.setUint8(pos++, MagicBytes[i]);\n  }\n  // Add the json info\n  finalBufferView.set(new Uint8Array(infoBuffer), pos);\n  pos += infoBuffer.byteLength;\n  // Finally inserts the texture data\n  for (let i = 0; i <= mipmapsCount; i++) {\n    for (let face = 0; face < 6; face++) {\n      const dataBuffer = specularTextures[i * 6 + face];\n      finalBufferView.set(new Uint8Array(dataBuffer), pos);\n      pos += dataBuffer.byteLength;\n    }\n  }\n  // Voila\n  return finalBuffer;\n}\n/**\n * Creates a JSON representation of the spherical data.\n * @param texture defines the texture containing the polynomials\n * @returns the JSON representation of the spherical info\n */\nfunction _CreateEnvTextureIrradiance(texture) {\n  const polynmials = texture.sphericalPolynomial;\n  if (polynmials == null) {\n    return null;\n  }\n  return {\n    x: [polynmials.x.x, polynmials.x.y, polynmials.x.z],\n    y: [polynmials.y.x, polynmials.y.y, polynmials.y.z],\n    z: [polynmials.z.x, polynmials.z.y, polynmials.z.z],\n    xx: [polynmials.xx.x, polynmials.xx.y, polynmials.xx.z],\n    yy: [polynmials.yy.x, polynmials.yy.y, polynmials.yy.z],\n    zz: [polynmials.zz.x, polynmials.zz.y, polynmials.zz.z],\n    yz: [polynmials.yz.x, polynmials.yz.y, polynmials.yz.z],\n    zx: [polynmials.zx.x, polynmials.zx.y, polynmials.zx.z],\n    xy: [polynmials.xy.x, polynmials.xy.y, polynmials.xy.z]\n  };\n}\n/**\n * Creates the ArrayBufferViews used for initializing environment texture image data.\n * @param data the image data\n * @param info parameters that determine what views will be created for accessing the underlying buffer\n * @returns the views described by info providing access to the underlying buffer\n */\nexport function CreateImageDataArrayBufferViews(data, info) {\n  info = normalizeEnvInfo(info);\n  const specularInfo = info.specular;\n  // Double checks the enclosed info\n  let mipmapsCount = Scalar.Log2(info.width);\n  mipmapsCount = Math.round(mipmapsCount) + 1;\n  if (specularInfo.mipmaps.length !== 6 * mipmapsCount) {\n    throw new Error(`Unsupported specular mipmaps number \"${specularInfo.mipmaps.length}\"`);\n  }\n  const imageData = new Array(mipmapsCount);\n  for (let i = 0; i < mipmapsCount; i++) {\n    imageData[i] = new Array(6);\n    for (let face = 0; face < 6; face++) {\n      const imageInfo = specularInfo.mipmaps[i * 6 + face];\n      imageData[i][face] = new Uint8Array(data.buffer, data.byteOffset + specularInfo.specularDataPosition + imageInfo.position, imageInfo.length);\n    }\n  }\n  return imageData;\n}\n/**\n * Uploads the texture info contained in the env file to the GPU.\n * @param texture defines the internal texture to upload to\n * @param data defines the data to load\n * @param info defines the texture info retrieved through the GetEnvInfo method\n * @returns a promise\n */\nexport function UploadEnvLevelsAsync(texture, data, info) {\n  info = normalizeEnvInfo(info);\n  const specularInfo = info.specular;\n  if (!specularInfo) {\n    // Nothing else parsed so far\n    return Promise.resolve();\n  }\n  texture._lodGenerationScale = specularInfo.lodGenerationScale;\n  const imageData = CreateImageDataArrayBufferViews(data, info);\n  return UploadLevelsAsync(texture, imageData, info.imageType);\n}\nfunction _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture) {\n  return new Promise((resolve, reject) => {\n    if (expandTexture) {\n      const tempTexture = engine.createTexture(null, true, true, null, 1, null, message => {\n        reject(message);\n      }, image);\n      rgbdPostProcess.getEffect().executeWhenCompiled(() => {\n        // Uncompress the data to a RTT\n        rgbdPostProcess.externalTextureSamplerBinding = true;\n        rgbdPostProcess.onApply = effect => {\n          effect._bindTexture(\"textureSampler\", tempTexture);\n          effect.setFloat2(\"scale\", 1, engine._features.needsInvertingBitmap && image instanceof ImageBitmap ? -1 : 1);\n        };\n        if (!engine.scenes.length) {\n          return;\n        }\n        engine.scenes[0].postProcessManager.directRender([rgbdPostProcess], cubeRtt, true, face, i);\n        // Cleanup\n        engine.restoreDefaultFramebuffer();\n        tempTexture.dispose();\n        URL.revokeObjectURL(url);\n        resolve();\n      });\n    } else {\n      engine._uploadImageToTexture(texture, image, face, i);\n      // Upload the face to the non lod texture support\n      if (generateNonLODTextures) {\n        const lodTexture = lodTextures[i];\n        if (lodTexture) {\n          engine._uploadImageToTexture(lodTexture._texture, image, face, 0);\n        }\n      }\n      resolve();\n    }\n  });\n}\n/**\n * Uploads the levels of image data to the GPU.\n * @param texture defines the internal texture to upload to\n * @param imageData defines the array buffer views of image data [mipmap][face]\n * @param imageType the mime type of the image data\n * @returns a promise\n */\nexport function UploadLevelsAsync(texture, imageData, imageType = DefaultEnvironmentTextureImageType) {\n  if (!Tools.IsExponentOfTwo(texture.width)) {\n    throw new Error(\"Texture size must be a power of two\");\n  }\n  const mipmapsCount = Scalar.ILog2(texture.width) + 1;\n  // Gets everything ready.\n  const engine = texture.getEngine();\n  let expandTexture = false;\n  let generateNonLODTextures = false;\n  let rgbdPostProcess = null;\n  let cubeRtt = null;\n  let lodTextures = null;\n  const caps = engine.getCaps();\n  texture.format = 5;\n  texture.type = 0;\n  texture.generateMipMaps = true;\n  texture._cachedAnisotropicFilteringLevel = null;\n  engine.updateTextureSamplingMode(3, texture);\n  // Add extra process if texture lod is not supported\n  if (!caps.textureLOD) {\n    expandTexture = false;\n    generateNonLODTextures = true;\n    lodTextures = {};\n  }\n  // in webgl 1 there are no ways to either render or copy lod level information for float textures.\n  else if (!engine._features.supportRenderAndCopyToLodForFloatTextures) {\n    expandTexture = false;\n  }\n  // If half float available we can uncompress the texture\n  else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\n    expandTexture = true;\n    texture.type = 2;\n  }\n  // If full float available we can uncompress the texture\n  else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\n    expandTexture = true;\n    texture.type = 1;\n  }\n  // Expand the texture if possible\n  if (expandTexture) {\n    // Simply run through the decode PP\n    rgbdPostProcess = new PostProcess(\"rgbdDecode\", \"rgbdDecode\", null, null, 1, null, 3, engine, false, undefined, texture.type, undefined, null, false);\n    texture._isRGBD = false;\n    texture.invertY = false;\n    cubeRtt = engine.createRenderTargetCubeTexture(texture.width, {\n      generateDepthBuffer: false,\n      generateMipMaps: true,\n      generateStencilBuffer: false,\n      samplingMode: 3,\n      type: texture.type,\n      format: 5\n    });\n  } else {\n    texture._isRGBD = true;\n    texture.invertY = true;\n    // In case of missing support, applies the same patch than DDS files.\n    if (generateNonLODTextures) {\n      const mipSlices = 3;\n      const scale = texture._lodGenerationScale;\n      const offset = texture._lodGenerationOffset;\n      for (let i = 0; i < mipSlices; i++) {\n        //compute LOD from even spacing in smoothness (matching shader calculation)\n        const smoothness = i / (mipSlices - 1);\n        const roughness = 1 - smoothness;\n        const minLODIndex = offset; // roughness = 0\n        const maxLODIndex = (mipmapsCount - 1) * scale + offset; // roughness = 1 (mipmaps start from 0)\n        const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\n        const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\n        const glTextureFromLod = new InternalTexture(engine, InternalTextureSource.Temp);\n        glTextureFromLod.isCube = true;\n        glTextureFromLod.invertY = true;\n        glTextureFromLod.generateMipMaps = false;\n        engine.updateTextureSamplingMode(2, glTextureFromLod);\n        // Wrap in a base texture for easy binding.\n        const lodTexture = new BaseTexture(null);\n        lodTexture._isCube = true;\n        lodTexture._texture = glTextureFromLod;\n        lodTextures[mipmapIndex] = lodTexture;\n        switch (i) {\n          case 0:\n            texture._lodTextureLow = lodTexture;\n            break;\n          case 1:\n            texture._lodTextureMid = lodTexture;\n            break;\n          case 2:\n            texture._lodTextureHigh = lodTexture;\n            break;\n        }\n      }\n    }\n  }\n  const promises = [];\n  // All mipmaps up to provided number of images\n  for (let i = 0; i < imageData.length; i++) {\n    // All faces\n    for (let face = 0; face < 6; face++) {\n      // Constructs an image element from image data\n      const bytes = imageData[i][face];\n      const blob = new Blob([bytes], {\n        type: imageType\n      });\n      const url = URL.createObjectURL(blob);\n      let promise;\n      if (typeof Image === \"undefined\" || engine._features.forceBitmapOverHTMLImageElement) {\n        promise = engine.createImageBitmap(blob, {\n          premultiplyAlpha: \"none\"\n        }).then(img => {\n          return _OnImageReadyAsync(img, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture);\n        });\n      } else {\n        const image = new Image();\n        image.src = url;\n        // Enqueue promise to upload to the texture.\n        promise = new Promise((resolve, reject) => {\n          image.onload = () => {\n            _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture).then(() => resolve()).catch(reason => {\n              reject(reason);\n            });\n          };\n          image.onerror = error => {\n            reject(error);\n          };\n        });\n      }\n      promises.push(promise);\n    }\n  }\n  // Fill remaining mipmaps with black textures.\n  if (imageData.length < mipmapsCount) {\n    let data;\n    const size = Math.pow(2, mipmapsCount - 1 - imageData.length);\n    const dataLength = size * size * 4;\n    switch (texture.type) {\n      case 0:\n        {\n          data = new Uint8Array(dataLength);\n          break;\n        }\n      case 2:\n        {\n          data = new Uint16Array(dataLength);\n          break;\n        }\n      case 1:\n        {\n          data = new Float32Array(dataLength);\n          break;\n        }\n    }\n    for (let i = imageData.length; i < mipmapsCount; i++) {\n      for (let face = 0; face < 6; face++) {\n        engine._uploadArrayBufferViewToTexture(texture, data, face, i);\n      }\n    }\n  }\n  // Once all done, finishes the cleanup and return\n  return Promise.all(promises).then(() => {\n    // Release temp RTT.\n    if (cubeRtt) {\n      engine._releaseTexture(texture);\n      cubeRtt._swapAndDie(texture);\n    }\n    // Release temp Post Process.\n    if (rgbdPostProcess) {\n      rgbdPostProcess.dispose();\n    }\n    // Flag internal texture as ready in case they are in use.\n    if (generateNonLODTextures) {\n      if (texture._lodTextureHigh && texture._lodTextureHigh._texture) {\n        texture._lodTextureHigh._texture.isReady = true;\n      }\n      if (texture._lodTextureMid && texture._lodTextureMid._texture) {\n        texture._lodTextureMid._texture.isReady = true;\n      }\n      if (texture._lodTextureLow && texture._lodTextureLow._texture) {\n        texture._lodTextureLow._texture.isReady = true;\n      }\n    }\n  });\n}\n/**\n * Uploads spherical polynomials information to the texture.\n * @param texture defines the texture we are trying to upload the information to\n * @param info defines the environment texture info retrieved through the GetEnvInfo method\n */\nexport function UploadEnvSpherical(texture, info) {\n  info = normalizeEnvInfo(info);\n  const irradianceInfo = info.irradiance;\n  if (!irradianceInfo) {\n    return;\n  }\n  const sp = new SphericalPolynomial();\n  Vector3.FromArrayToRef(irradianceInfo.x, 0, sp.x);\n  Vector3.FromArrayToRef(irradianceInfo.y, 0, sp.y);\n  Vector3.FromArrayToRef(irradianceInfo.z, 0, sp.z);\n  Vector3.FromArrayToRef(irradianceInfo.xx, 0, sp.xx);\n  Vector3.FromArrayToRef(irradianceInfo.yy, 0, sp.yy);\n  Vector3.FromArrayToRef(irradianceInfo.zz, 0, sp.zz);\n  Vector3.FromArrayToRef(irradianceInfo.yz, 0, sp.yz);\n  Vector3.FromArrayToRef(irradianceInfo.zx, 0, sp.zx);\n  Vector3.FromArrayToRef(irradianceInfo.xy, 0, sp.xy);\n  texture._sphericalPolynomial = sp;\n}\n/**\n * @internal\n */\nexport function _UpdateRGBDAsync(internalTexture, data, sphericalPolynomial, lodScale, lodOffset) {\n  const proxy = internalTexture.getEngine().createRawCubeTexture(null, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);\n  const proxyPromise = UploadLevelsAsync(proxy, data).then(() => internalTexture);\n  internalTexture.onRebuildCallback = _internalTexture => {\n    return {\n      proxy: proxyPromise,\n      isReady: true,\n      isAsync: true\n    };\n  };\n  internalTexture._source = InternalTextureSource.CubeRawRGBD;\n  internalTexture._bufferViewArrayArray = data;\n  internalTexture._lodGenerationScale = lodScale;\n  internalTexture._lodGenerationOffset = lodOffset;\n  internalTexture._sphericalPolynomial = sphericalPolynomial;\n  return UploadLevelsAsync(internalTexture, data).then(() => {\n    internalTexture.isReady = true;\n    return internalTexture;\n  });\n}\n/**\n * Sets of helpers addressing the serialization and deserialization of environment texture\n * stored in a BabylonJS env file.\n * Those files are usually stored as .env files.\n */\nexport const EnvironmentTextureTools = {\n  /**\n   * Gets the environment info from an env file.\n   * @param data The array buffer containing the .env bytes.\n   * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\n   */\n  GetEnvInfo,\n  /**\n   * Creates an environment texture from a loaded cube texture.\n   * @param texture defines the cube texture to convert in env file\n   * @param options options for the conversion process\n   * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\n   * @param options.imageQuality the image quality of encoded WebP images.\n   * @returns a promise containing the environment data if successful.\n   */\n  CreateEnvTextureAsync,\n  /**\n   * Creates the ArrayBufferViews used for initializing environment texture image data.\n   * @param data the image data\n   * @param info parameters that determine what views will be created for accessing the underlying buffer\n   * @returns the views described by info providing access to the underlying buffer\n   */\n  CreateImageDataArrayBufferViews,\n  /**\n   * Uploads the texture info contained in the env file to the GPU.\n   * @param texture defines the internal texture to upload to\n   * @param data defines the data to load\n   * @param info defines the texture info retrieved through the GetEnvInfo method\n   * @returns a promise\n   */\n  UploadEnvLevelsAsync,\n  /**\n   * Uploads the levels of image data to the GPU.\n   * @param texture defines the internal texture to upload to\n   * @param imageData defines the array buffer views of image data [mipmap][face]\n   * @param imageType the mime type of the image data\n   * @returns a promise\n   */\n  UploadLevelsAsync,\n  /**\n   * Uploads spherical polynomials information to the texture.\n   * @param texture defines the texture we are trying to upload the information to\n   * @param info defines the environment texture info retrieved through the GetEnvInfo method\n   */\n  UploadEnvSpherical\n};","map":{"version":3,"names":["Tools","Vector3","Scalar","SphericalPolynomial","InternalTexture","InternalTextureSource","BaseTexture","Scene","PostProcess","Logger","RGBDTextureTools","DumpTools","DefaultEnvironmentTextureImageType","CurrentVersion","MagicBytes","GetEnvInfo","data","dataView","DataView","buffer","byteOffset","byteLength","pos","i","length","getUint8","Error","manifestString","charCode","String","fromCharCode","manifest","JSON","parse","normalizeEnvInfo","specular","specularDataPosition","lodGenerationScale","info","version","Object","assign","imageType","CreateEnvTextureAsync","texture","options","internalTexture","getInternalTexture","Promise","reject","_a","engine","getEngine","textureType","getCaps","textureFloatRender","textureHalfFloatRender","sphericalPolynomial","sphericalPolynomialPromise","_b","_sphericalPolynomialPromise","cubeWidth","width","hostingScene","specularTextures","flushFramebuffer","mipmapsCount","ILog2","faceWidth","Math","pow","face","faceData","readPixels","undefined","faceDataFloat","Float32Array","gammaSpace","floatData","tempTexture","createRawTexture","EncodeTextureToRGBD","rgbdEncodedData","_readTexturePixels","imageEncodedData","DumpDataAsync","imageQuality","dispose","irradiance","_CreateEnvTextureIrradiance","mipmaps","position","push","infoString","stringify","infoBuffer","ArrayBuffer","infoView","Uint8Array","strLen","charCodeAt","totalSize","finalBuffer","finalBufferView","setUint8","set","dataBuffer","polynmials","x","y","z","xx","yy","zz","yz","zx","xy","CreateImageDataArrayBufferViews","specularInfo","Log2","round","imageData","Array","imageInfo","UploadEnvLevelsAsync","resolve","_lodGenerationScale","UploadLevelsAsync","_OnImageReadyAsync","image","expandTexture","rgbdPostProcess","url","generateNonLODTextures","lodTextures","cubeRtt","createTexture","message","getEffect","executeWhenCompiled","externalTextureSamplerBinding","onApply","effect","_bindTexture","setFloat2","_features","needsInvertingBitmap","ImageBitmap","scenes","postProcessManager","directRender","restoreDefaultFramebuffer","URL","revokeObjectURL","_uploadImageToTexture","lodTexture","_texture","IsExponentOfTwo","caps","format","type","generateMipMaps","_cachedAnisotropicFilteringLevel","updateTextureSamplingMode","textureLOD","supportRenderAndCopyToLodForFloatTextures","textureHalfFloatLinearFiltering","textureFloatLinearFiltering","_isRGBD","invertY","createRenderTargetCubeTexture","generateDepthBuffer","generateStencilBuffer","samplingMode","mipSlices","scale","offset","_lodGenerationOffset","smoothness","roughness","minLODIndex","maxLODIndex","lodIndex","mipmapIndex","min","max","glTextureFromLod","Temp","isCube","_isCube","_lodTextureLow","_lodTextureMid","_lodTextureHigh","promises","bytes","blob","Blob","createObjectURL","promise","Image","forceBitmapOverHTMLImageElement","createImageBitmap","premultiplyAlpha","then","img","src","onload","catch","reason","onerror","error","size","dataLength","Uint16Array","_uploadArrayBufferViewToTexture","all","_releaseTexture","_swapAndDie","isReady","UploadEnvSpherical","irradianceInfo","sp","FromArrayToRef","_sphericalPolynomial","_UpdateRGBDAsync","lodScale","lodOffset","proxy","createRawCubeTexture","_compression","proxyPromise","onRebuildCallback","_internalTexture","isAsync","_source","CubeRawRGBD","_bufferViewArrayArray","EnvironmentTextureTools"],"sources":["../../../../dev/core/src/Misc/environmentTextureTools.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../types\";\r\nimport { Tools } from \"./tools\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Scene } from \"../scene\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { RGBDTextureTools } from \"./rgbdTextureTools\";\r\nimport type { RenderTargetWrapper } from \"../Engines/renderTargetWrapper\";\r\n\r\nimport \"../Engines/Extensions/engine.renderTargetCube\";\r\nimport \"../Engines/Extensions/engine.readTexture\";\r\nimport \"../Materials/Textures/baseTexture.polynomial\";\r\n\r\nimport \"../Shaders/rgbdEncode.fragment\";\r\nimport \"../Shaders/rgbdDecode.fragment\";\r\nimport { DumpTools } from \"../Misc/dumpTools\";\r\n\r\nconst DefaultEnvironmentTextureImageType = \"image/png\";\r\nconst CurrentVersion = 2;\r\n\r\n/**\r\n * Raw texture data and descriptor sufficient for WebGL texture upload\r\n */\r\nexport type EnvironmentTextureInfo = EnvironmentTextureInfoV1 | EnvironmentTextureInfoV2;\r\n\r\n/**\r\n * v1 of EnvironmentTextureInfo\r\n */\r\ninterface EnvironmentTextureInfoV1 {\r\n    /**\r\n     * Version of the environment map\r\n     */\r\n    version: 1;\r\n\r\n    /**\r\n     * Width of image\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * Irradiance information stored in the file.\r\n     */\r\n    irradiance: any;\r\n\r\n    /**\r\n     * Specular information stored in the file.\r\n     */\r\n    specular: any;\r\n}\r\n\r\n/**\r\n * v2 of EnvironmentTextureInfo\r\n */\r\ninterface EnvironmentTextureInfoV2 {\r\n    /**\r\n     * Version of the environment map\r\n     */\r\n    version: 2;\r\n\r\n    /**\r\n     * Width of image\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * Irradiance information stored in the file.\r\n     */\r\n    irradiance: any;\r\n\r\n    /**\r\n     * Specular information stored in the file.\r\n     */\r\n    specular: any;\r\n\r\n    /**\r\n     * The mime type used to encode the image data.\r\n     */\r\n    imageType: string;\r\n}\r\n\r\n/**\r\n * Defines One Image in the file. It requires only the position in the file\r\n * as well as the length.\r\n */\r\ninterface BufferImageData {\r\n    /**\r\n     * Length of the image data.\r\n     */\r\n    length: number;\r\n    /**\r\n     * Position of the data from the null terminator delimiting the end of the JSON.\r\n     */\r\n    position: number;\r\n}\r\n\r\n/**\r\n * Defines the specular data enclosed in the file.\r\n * This corresponds to the version 1 of the data.\r\n */\r\nexport interface EnvironmentTextureSpecularInfoV1 {\r\n    /**\r\n     * Defines where the specular Payload is located. It is a runtime value only not stored in the file.\r\n     */\r\n    specularDataPosition?: number;\r\n    /**\r\n     * This contains all the images data needed to reconstruct the cubemap.\r\n     */\r\n    mipmaps: Array<BufferImageData>;\r\n    /**\r\n     * Defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness.\r\n     */\r\n    lodGenerationScale: number;\r\n}\r\n\r\n/**\r\n * Defines the required storage to save the environment irradiance information.\r\n */\r\ninterface EnvironmentTextureIrradianceInfoV1 {\r\n    x: Array<number>;\r\n    y: Array<number>;\r\n    z: Array<number>;\r\n\r\n    xx: Array<number>;\r\n    yy: Array<number>;\r\n    zz: Array<number>;\r\n\r\n    yz: Array<number>;\r\n    zx: Array<number>;\r\n    xy: Array<number>;\r\n}\r\n\r\n/**\r\n * Options for creating environment textures\r\n */\r\nexport interface CreateEnvTextureOptions {\r\n    /**\r\n     * The mime type of encoded images.\r\n     */\r\n    imageType?: string;\r\n\r\n    /**\r\n     * the image quality of encoded WebP images.\r\n     */\r\n    imageQuality?: number;\r\n}\r\n\r\n/**\r\n * Magic number identifying the env file.\r\n */\r\nconst MagicBytes = [0x86, 0x16, 0x87, 0x96, 0xf6, 0xd6, 0x96, 0x36];\r\n\r\n/**\r\n * Gets the environment info from an env file.\r\n * @param data The array buffer containing the .env bytes.\r\n * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\r\n */\r\nexport function GetEnvInfo(data: ArrayBufferView): Nullable<EnvironmentTextureInfoV2> {\r\n    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n    let pos = 0;\r\n\r\n    for (let i = 0; i < MagicBytes.length; i++) {\r\n        if (dataView.getUint8(pos++) !== MagicBytes[i]) {\r\n            Logger.Error(\"Not a babylon environment map\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Read json manifest - collect characters up to null terminator\r\n    let manifestString = \"\";\r\n    let charCode = 0x00;\r\n    while ((charCode = dataView.getUint8(pos++))) {\r\n        manifestString += String.fromCharCode(charCode);\r\n    }\r\n\r\n    let manifest: EnvironmentTextureInfo = JSON.parse(manifestString);\r\n    manifest = normalizeEnvInfo(manifest);\r\n    if (manifest.specular) {\r\n        // Extend the header with the position of the payload.\r\n        manifest.specular.specularDataPosition = pos;\r\n        // Fallback to 0.8 exactly if lodGenerationScale is not defined for backward compatibility.\r\n        manifest.specular.lodGenerationScale = manifest.specular.lodGenerationScale || 0.8;\r\n    }\r\n\r\n    return manifest;\r\n}\r\n\r\n/**\r\n * Normalizes any supported version of the environment file info to the latest version\r\n * @param info environment file info on any supported version\r\n * @returns environment file info in the latest supported version\r\n * @private\r\n */\r\nexport function normalizeEnvInfo(info: EnvironmentTextureInfo): EnvironmentTextureInfoV2 {\r\n    if (info.version > CurrentVersion) {\r\n        throw new Error(`Unsupported babylon environment map version \"${info.version}\". Latest supported version is \"${CurrentVersion}\".`);\r\n    }\r\n\r\n    if (info.version === 2) {\r\n        return info;\r\n    }\r\n\r\n    // Migrate a v1 info to v2\r\n    info = { ...info, version: 2, imageType: DefaultEnvironmentTextureImageType };\r\n\r\n    return info;\r\n}\r\n\r\n/**\r\n * Creates an environment texture from a loaded cube texture.\r\n * @param texture defines the cube texture to convert in env file\r\n * @param options options for the conversion process\r\n * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\r\n * @param options.imageQuality the image quality of encoded WebP images.\r\n * @returns a promise containing the environment data if successful.\r\n */\r\nexport async function CreateEnvTextureAsync(texture: BaseTexture, options: CreateEnvTextureOptions = {}): Promise<ArrayBuffer> {\r\n    const internalTexture = texture.getInternalTexture();\r\n    if (!internalTexture) {\r\n        return Promise.reject(\"The cube texture is invalid.\");\r\n    }\r\n\r\n    const imageType = options.imageType ?? DefaultEnvironmentTextureImageType;\r\n\r\n    const engine = internalTexture.getEngine() as Engine;\r\n\r\n    if (\r\n        texture.textureType !== Constants.TEXTURETYPE_HALF_FLOAT &&\r\n        texture.textureType !== Constants.TEXTURETYPE_FLOAT &&\r\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_BYTE &&\r\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_INT &&\r\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_INTEGER &&\r\n        texture.textureType !== -1\r\n    ) {\r\n        return Promise.reject(\"The cube texture should allow HDR (Full Float or Half Float).\");\r\n    }\r\n\r\n    let textureType = Constants.TEXTURETYPE_FLOAT;\r\n    if (!engine.getCaps().textureFloatRender) {\r\n        textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        if (!engine.getCaps().textureHalfFloatRender) {\r\n            return Promise.reject(\"Env texture can only be created when the browser supports half float or full float rendering.\");\r\n        }\r\n    }\r\n\r\n    // sphericalPolynomial is lazy loaded so simply accessing it should trigger the computation.\r\n    texture.sphericalPolynomial;\r\n\r\n    // Lets keep track of the polynomial promise so we can wait for it to be ready before generating the pixels.\r\n    const sphericalPolynomialPromise = texture.getInternalTexture()?._sphericalPolynomialPromise;\r\n\r\n    const cubeWidth = internalTexture.width;\r\n    const hostingScene = new Scene(engine);\r\n    const specularTextures: { [key: number]: ArrayBuffer } = {};\r\n\r\n    // As we are going to readPixels the faces of the cube, make sure the drawing/update commands for the cube texture are fully sent to the GPU in case it is drawn for the first time in this very frame!\r\n    engine.flushFramebuffer();\r\n\r\n    // Read and collect all mipmaps data from the cube.\r\n    const mipmapsCount = Scalar.ILog2(internalTexture.width);\r\n    for (let i = 0; i <= mipmapsCount; i++) {\r\n        const faceWidth = Math.pow(2, mipmapsCount - i);\r\n\r\n        // All faces of the cube.\r\n        for (let face = 0; face < 6; face++) {\r\n            let faceData = await texture.readPixels(face, i, undefined, false);\r\n            if (faceData && faceData.byteLength === (faceData as Uint8Array).length) {\r\n                const faceDataFloat = new Float32Array(faceData!.byteLength * 4);\r\n                for (let i = 0; i < faceData.byteLength; i++) {\r\n                    faceDataFloat[i] = (faceData as Uint8Array)[i] / 255;\r\n                    // Gamma to linear\r\n                    faceDataFloat[i] = Math.pow(faceDataFloat[i], 2.2);\r\n                }\r\n                faceData = faceDataFloat;\r\n            } else if (faceData && texture.gammaSpace) {\r\n                const floatData = faceData as Float32Array;\r\n                for (let i = 0; i < floatData.length; i++) {\r\n                    // Gamma to linear\r\n                    floatData[i] = Math.pow(floatData[i], 2.2);\r\n                }\r\n            }\r\n\r\n            const tempTexture = engine.createRawTexture(\r\n                faceData,\r\n                faceWidth,\r\n                faceWidth,\r\n                Constants.TEXTUREFORMAT_RGBA,\r\n                false,\r\n                true,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                null,\r\n                textureType\r\n            );\r\n\r\n            await RGBDTextureTools.EncodeTextureToRGBD(tempTexture, hostingScene, textureType);\r\n\r\n            const rgbdEncodedData = await engine._readTexturePixels(tempTexture, faceWidth, faceWidth);\r\n\r\n            const imageEncodedData = await DumpTools.DumpDataAsync(faceWidth, faceWidth, rgbdEncodedData, imageType, undefined, false, true, options.imageQuality);\r\n\r\n            specularTextures[i * 6 + face] = imageEncodedData as ArrayBuffer;\r\n\r\n            tempTexture.dispose();\r\n        }\r\n    }\r\n\r\n    // We can delete the hosting scene keeping track of all the creation objects\r\n    hostingScene.dispose();\r\n\r\n    // Ensure completion of the polynomial creation promise.\r\n    if (sphericalPolynomialPromise) {\r\n        await sphericalPolynomialPromise;\r\n    }\r\n\r\n    // Creates the json header for the env texture\r\n    const info: EnvironmentTextureInfo = {\r\n        version: CurrentVersion,\r\n        width: cubeWidth,\r\n        imageType,\r\n        irradiance: _CreateEnvTextureIrradiance(texture),\r\n        specular: {\r\n            mipmaps: [],\r\n            lodGenerationScale: texture.lodGenerationScale,\r\n        },\r\n    };\r\n\r\n    // Sets the specular image data information\r\n    let position = 0;\r\n    for (let i = 0; i <= mipmapsCount; i++) {\r\n        for (let face = 0; face < 6; face++) {\r\n            const byteLength = specularTextures[i * 6 + face].byteLength;\r\n            info.specular.mipmaps.push({\r\n                length: byteLength,\r\n                position: position,\r\n            });\r\n            position += byteLength;\r\n        }\r\n    }\r\n\r\n    // Encode the JSON as an array buffer\r\n    const infoString = JSON.stringify(info);\r\n    const infoBuffer = new ArrayBuffer(infoString.length + 1);\r\n    const infoView = new Uint8Array(infoBuffer); // Limited to ascii subset matching unicode.\r\n    for (let i = 0, strLen = infoString.length; i < strLen; i++) {\r\n        infoView[i] = infoString.charCodeAt(i);\r\n    }\r\n    // Ends up with a null terminator for easier parsing\r\n    infoView[infoString.length] = 0x00;\r\n\r\n    // Computes the final required size and creates the storage\r\n    const totalSize = MagicBytes.length + position + infoBuffer.byteLength;\r\n    const finalBuffer = new ArrayBuffer(totalSize);\r\n    const finalBufferView = new Uint8Array(finalBuffer);\r\n    const dataView = new DataView(finalBuffer);\r\n\r\n    // Copy the magic bytes identifying the file in\r\n    let pos = 0;\r\n    for (let i = 0; i < MagicBytes.length; i++) {\r\n        dataView.setUint8(pos++, MagicBytes[i]);\r\n    }\r\n\r\n    // Add the json info\r\n    finalBufferView.set(new Uint8Array(infoBuffer), pos);\r\n    pos += infoBuffer.byteLength;\r\n\r\n    // Finally inserts the texture data\r\n    for (let i = 0; i <= mipmapsCount; i++) {\r\n        for (let face = 0; face < 6; face++) {\r\n            const dataBuffer = specularTextures[i * 6 + face];\r\n            finalBufferView.set(new Uint8Array(dataBuffer), pos);\r\n            pos += dataBuffer.byteLength;\r\n        }\r\n    }\r\n\r\n    // Voila\r\n    return finalBuffer;\r\n}\r\n\r\n/**\r\n * Creates a JSON representation of the spherical data.\r\n * @param texture defines the texture containing the polynomials\r\n * @returns the JSON representation of the spherical info\r\n */\r\nfunction _CreateEnvTextureIrradiance(texture: BaseTexture): Nullable<EnvironmentTextureIrradianceInfoV1> {\r\n    const polynmials = texture.sphericalPolynomial;\r\n    if (polynmials == null) {\r\n        return null;\r\n    }\r\n\r\n    return {\r\n        x: [polynmials.x.x, polynmials.x.y, polynmials.x.z],\r\n        y: [polynmials.y.x, polynmials.y.y, polynmials.y.z],\r\n        z: [polynmials.z.x, polynmials.z.y, polynmials.z.z],\r\n\r\n        xx: [polynmials.xx.x, polynmials.xx.y, polynmials.xx.z],\r\n        yy: [polynmials.yy.x, polynmials.yy.y, polynmials.yy.z],\r\n        zz: [polynmials.zz.x, polynmials.zz.y, polynmials.zz.z],\r\n\r\n        yz: [polynmials.yz.x, polynmials.yz.y, polynmials.yz.z],\r\n        zx: [polynmials.zx.x, polynmials.zx.y, polynmials.zx.z],\r\n        xy: [polynmials.xy.x, polynmials.xy.y, polynmials.xy.z],\r\n    } as any;\r\n}\r\n\r\n/**\r\n * Creates the ArrayBufferViews used for initializing environment texture image data.\r\n * @param data the image data\r\n * @param info parameters that determine what views will be created for accessing the underlying buffer\r\n * @returns the views described by info providing access to the underlying buffer\r\n */\r\nexport function CreateImageDataArrayBufferViews(data: ArrayBufferView, info: EnvironmentTextureInfo): Array<Array<ArrayBufferView>> {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const specularInfo = info.specular as EnvironmentTextureSpecularInfoV1;\r\n\r\n    // Double checks the enclosed info\r\n    let mipmapsCount = Scalar.Log2(info.width);\r\n    mipmapsCount = Math.round(mipmapsCount) + 1;\r\n    if (specularInfo.mipmaps.length !== 6 * mipmapsCount) {\r\n        throw new Error(`Unsupported specular mipmaps number \"${specularInfo.mipmaps.length}\"`);\r\n    }\r\n\r\n    const imageData = new Array<Array<ArrayBufferView>>(mipmapsCount);\r\n    for (let i = 0; i < mipmapsCount; i++) {\r\n        imageData[i] = new Array<ArrayBufferView>(6);\r\n        for (let face = 0; face < 6; face++) {\r\n            const imageInfo = specularInfo.mipmaps[i * 6 + face];\r\n            imageData[i][face] = new Uint8Array(data.buffer, data.byteOffset + specularInfo.specularDataPosition! + imageInfo.position, imageInfo.length);\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * Uploads the texture info contained in the env file to the GPU.\r\n * @param texture defines the internal texture to upload to\r\n * @param data defines the data to load\r\n * @param info defines the texture info retrieved through the GetEnvInfo method\r\n * @returns a promise\r\n */\r\nexport function UploadEnvLevelsAsync(texture: InternalTexture, data: ArrayBufferView, info: EnvironmentTextureInfo): Promise<void> {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const specularInfo = info.specular as EnvironmentTextureSpecularInfoV1;\r\n    if (!specularInfo) {\r\n        // Nothing else parsed so far\r\n        return Promise.resolve();\r\n    }\r\n\r\n    texture._lodGenerationScale = specularInfo.lodGenerationScale;\r\n\r\n    const imageData = CreateImageDataArrayBufferViews(data, info);\r\n\r\n    return UploadLevelsAsync(texture, imageData, info.imageType);\r\n}\r\n\r\nfunction _OnImageReadyAsync(\r\n    image: HTMLImageElement | ImageBitmap,\r\n    engine: Engine,\r\n    expandTexture: boolean,\r\n    rgbdPostProcess: Nullable<PostProcess>,\r\n    url: string,\r\n    face: number,\r\n    i: number,\r\n    generateNonLODTextures: boolean,\r\n    lodTextures: Nullable<{ [lod: number]: BaseTexture }>,\r\n    cubeRtt: Nullable<RenderTargetWrapper>,\r\n    texture: InternalTexture\r\n): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n        if (expandTexture) {\r\n            const tempTexture = engine.createTexture(\r\n                null,\r\n                true,\r\n                true,\r\n                null,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                null,\r\n                (message) => {\r\n                    reject(message);\r\n                },\r\n                image\r\n            );\r\n\r\n            rgbdPostProcess!.getEffect().executeWhenCompiled(() => {\r\n                // Uncompress the data to a RTT\r\n                rgbdPostProcess!.externalTextureSamplerBinding = true;\r\n                rgbdPostProcess!.onApply = (effect) => {\r\n                    effect._bindTexture(\"textureSampler\", tempTexture);\r\n                    effect.setFloat2(\"scale\", 1, engine._features.needsInvertingBitmap && image instanceof ImageBitmap ? -1 : 1);\r\n                };\r\n\r\n                if (!engine.scenes.length) {\r\n                    return;\r\n                }\r\n\r\n                engine.scenes[0].postProcessManager.directRender([rgbdPostProcess!], cubeRtt, true, face, i);\r\n\r\n                // Cleanup\r\n                engine.restoreDefaultFramebuffer();\r\n                tempTexture.dispose();\r\n                URL.revokeObjectURL(url);\r\n                resolve();\r\n            });\r\n        } else {\r\n            engine._uploadImageToTexture(texture, image, face, i);\r\n\r\n            // Upload the face to the non lod texture support\r\n            if (generateNonLODTextures) {\r\n                const lodTexture = lodTextures![i];\r\n                if (lodTexture) {\r\n                    engine._uploadImageToTexture(lodTexture._texture!, image, face, 0);\r\n                }\r\n            }\r\n            resolve();\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Uploads the levels of image data to the GPU.\r\n * @param texture defines the internal texture to upload to\r\n * @param imageData defines the array buffer views of image data [mipmap][face]\r\n * @param imageType the mime type of the image data\r\n * @returns a promise\r\n */\r\nexport function UploadLevelsAsync(texture: InternalTexture, imageData: ArrayBufferView[][], imageType: string = DefaultEnvironmentTextureImageType): Promise<void> {\r\n    if (!Tools.IsExponentOfTwo(texture.width)) {\r\n        throw new Error(\"Texture size must be a power of two\");\r\n    }\r\n\r\n    const mipmapsCount = Scalar.ILog2(texture.width) + 1;\r\n\r\n    // Gets everything ready.\r\n    const engine = texture.getEngine() as Engine;\r\n    let expandTexture = false;\r\n    let generateNonLODTextures = false;\r\n    let rgbdPostProcess: Nullable<PostProcess> = null;\r\n    let cubeRtt: Nullable<RenderTargetWrapper> = null;\r\n    let lodTextures: Nullable<{ [lod: number]: BaseTexture }> = null;\r\n    const caps = engine.getCaps();\r\n\r\n    texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n    texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n    texture.generateMipMaps = true;\r\n    texture._cachedAnisotropicFilteringLevel = null;\r\n    engine.updateTextureSamplingMode(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, texture);\r\n\r\n    // Add extra process if texture lod is not supported\r\n    if (!caps.textureLOD) {\r\n        expandTexture = false;\r\n        generateNonLODTextures = true;\r\n        lodTextures = {};\r\n    }\r\n    // in webgl 1 there are no ways to either render or copy lod level information for float textures.\r\n    else if (!engine._features.supportRenderAndCopyToLodForFloatTextures) {\r\n        expandTexture = false;\r\n    }\r\n    // If half float available we can uncompress the texture\r\n    else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\r\n        expandTexture = true;\r\n        texture.type = Constants.TEXTURETYPE_HALF_FLOAT;\r\n    }\r\n    // If full float available we can uncompress the texture\r\n    else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\r\n        expandTexture = true;\r\n        texture.type = Constants.TEXTURETYPE_FLOAT;\r\n    }\r\n\r\n    // Expand the texture if possible\r\n    if (expandTexture) {\r\n        // Simply run through the decode PP\r\n        rgbdPostProcess = new PostProcess(\r\n            \"rgbdDecode\",\r\n            \"rgbdDecode\",\r\n            null,\r\n            null,\r\n            1,\r\n            null,\r\n            Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n            engine,\r\n            false,\r\n            undefined,\r\n            texture.type,\r\n            undefined,\r\n            null,\r\n            false\r\n        );\r\n\r\n        texture._isRGBD = false;\r\n        texture.invertY = false;\r\n        cubeRtt = engine.createRenderTargetCubeTexture(texture.width, {\r\n            generateDepthBuffer: false,\r\n            generateMipMaps: true,\r\n            generateStencilBuffer: false,\r\n            samplingMode: Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n            type: texture.type,\r\n            format: Constants.TEXTUREFORMAT_RGBA,\r\n        });\r\n    } else {\r\n        texture._isRGBD = true;\r\n        texture.invertY = true;\r\n\r\n        // In case of missing support, applies the same patch than DDS files.\r\n        if (generateNonLODTextures) {\r\n            const mipSlices = 3;\r\n            const scale = texture._lodGenerationScale;\r\n            const offset = texture._lodGenerationOffset;\r\n\r\n            for (let i = 0; i < mipSlices; i++) {\r\n                //compute LOD from even spacing in smoothness (matching shader calculation)\r\n                const smoothness = i / (mipSlices - 1);\r\n                const roughness = 1 - smoothness;\r\n\r\n                const minLODIndex = offset; // roughness = 0\r\n                const maxLODIndex = (mipmapsCount - 1) * scale + offset; // roughness = 1 (mipmaps start from 0)\r\n\r\n                const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\r\n                const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\r\n\r\n                const glTextureFromLod = new InternalTexture(engine, InternalTextureSource.Temp);\r\n                glTextureFromLod.isCube = true;\r\n                glTextureFromLod.invertY = true;\r\n                glTextureFromLod.generateMipMaps = false;\r\n                engine.updateTextureSamplingMode(Constants.TEXTURE_LINEAR_LINEAR, glTextureFromLod);\r\n\r\n                // Wrap in a base texture for easy binding.\r\n                const lodTexture = new BaseTexture(null);\r\n                lodTexture._isCube = true;\r\n                lodTexture._texture = glTextureFromLod;\r\n                lodTextures![mipmapIndex] = lodTexture;\r\n\r\n                switch (i) {\r\n                    case 0:\r\n                        texture._lodTextureLow = lodTexture;\r\n                        break;\r\n                    case 1:\r\n                        texture._lodTextureMid = lodTexture;\r\n                        break;\r\n                    case 2:\r\n                        texture._lodTextureHigh = lodTexture;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const promises: Promise<void>[] = [];\r\n    // All mipmaps up to provided number of images\r\n    for (let i = 0; i < imageData.length; i++) {\r\n        // All faces\r\n        for (let face = 0; face < 6; face++) {\r\n            // Constructs an image element from image data\r\n            const bytes = imageData[i][face];\r\n            const blob = new Blob([bytes], { type: imageType });\r\n            const url = URL.createObjectURL(blob);\r\n            let promise: Promise<void>;\r\n\r\n            if (typeof Image === \"undefined\" || engine._features.forceBitmapOverHTMLImageElement) {\r\n                promise = engine.createImageBitmap(blob, { premultiplyAlpha: \"none\" }).then((img) => {\r\n                    return _OnImageReadyAsync(img, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture);\r\n                });\r\n            } else {\r\n                const image = new Image();\r\n                image.src = url;\r\n\r\n                // Enqueue promise to upload to the texture.\r\n                promise = new Promise<void>((resolve, reject) => {\r\n                    image.onload = () => {\r\n                        _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture)\r\n                            .then(() => resolve())\r\n                            .catch((reason) => {\r\n                                reject(reason);\r\n                            });\r\n                    };\r\n                    image.onerror = (error) => {\r\n                        reject(error);\r\n                    };\r\n                });\r\n            }\r\n            promises.push(promise);\r\n        }\r\n    }\r\n\r\n    // Fill remaining mipmaps with black textures.\r\n    if (imageData.length < mipmapsCount) {\r\n        let data: ArrayBufferView;\r\n        const size = Math.pow(2, mipmapsCount - 1 - imageData.length);\r\n        const dataLength = size * size * 4;\r\n        switch (texture.type) {\r\n            case Constants.TEXTURETYPE_UNSIGNED_INT: {\r\n                data = new Uint8Array(dataLength);\r\n                break;\r\n            }\r\n            case Constants.TEXTURETYPE_HALF_FLOAT: {\r\n                data = new Uint16Array(dataLength);\r\n                break;\r\n            }\r\n            case Constants.TEXTURETYPE_FLOAT: {\r\n                data = new Float32Array(dataLength);\r\n                break;\r\n            }\r\n        }\r\n        for (let i = imageData.length; i < mipmapsCount; i++) {\r\n            for (let face = 0; face < 6; face++) {\r\n                engine._uploadArrayBufferViewToTexture(texture, data!, face, i);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Once all done, finishes the cleanup and return\r\n    return Promise.all(promises).then(() => {\r\n        // Release temp RTT.\r\n        if (cubeRtt) {\r\n            engine._releaseTexture(texture);\r\n            cubeRtt._swapAndDie(texture);\r\n        }\r\n        // Release temp Post Process.\r\n        if (rgbdPostProcess) {\r\n            rgbdPostProcess.dispose();\r\n        }\r\n        // Flag internal texture as ready in case they are in use.\r\n        if (generateNonLODTextures) {\r\n            if (texture._lodTextureHigh && texture._lodTextureHigh._texture) {\r\n                texture._lodTextureHigh._texture.isReady = true;\r\n            }\r\n            if (texture._lodTextureMid && texture._lodTextureMid._texture) {\r\n                texture._lodTextureMid._texture.isReady = true;\r\n            }\r\n            if (texture._lodTextureLow && texture._lodTextureLow._texture) {\r\n                texture._lodTextureLow._texture.isReady = true;\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Uploads spherical polynomials information to the texture.\r\n * @param texture defines the texture we are trying to upload the information to\r\n * @param info defines the environment texture info retrieved through the GetEnvInfo method\r\n */\r\nexport function UploadEnvSpherical(texture: InternalTexture, info: EnvironmentTextureInfo): void {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const irradianceInfo = info.irradiance as EnvironmentTextureIrradianceInfoV1;\r\n    if (!irradianceInfo) {\r\n        return;\r\n    }\r\n\r\n    const sp = new SphericalPolynomial();\r\n    Vector3.FromArrayToRef(irradianceInfo.x, 0, sp.x);\r\n    Vector3.FromArrayToRef(irradianceInfo.y, 0, sp.y);\r\n    Vector3.FromArrayToRef(irradianceInfo.z, 0, sp.z);\r\n    Vector3.FromArrayToRef(irradianceInfo.xx, 0, sp.xx);\r\n    Vector3.FromArrayToRef(irradianceInfo.yy, 0, sp.yy);\r\n    Vector3.FromArrayToRef(irradianceInfo.zz, 0, sp.zz);\r\n    Vector3.FromArrayToRef(irradianceInfo.yz, 0, sp.yz);\r\n    Vector3.FromArrayToRef(irradianceInfo.zx, 0, sp.zx);\r\n    Vector3.FromArrayToRef(irradianceInfo.xy, 0, sp.xy);\r\n    texture._sphericalPolynomial = sp;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _UpdateRGBDAsync(\r\n    internalTexture: InternalTexture,\r\n    data: ArrayBufferView[][],\r\n    sphericalPolynomial: Nullable<SphericalPolynomial>,\r\n    lodScale: number,\r\n    lodOffset: number\r\n): Promise<InternalTexture> {\r\n    const proxy = internalTexture\r\n        .getEngine()\r\n        .createRawCubeTexture(\r\n            null,\r\n            internalTexture.width,\r\n            internalTexture.format,\r\n            internalTexture.type,\r\n            internalTexture.generateMipMaps,\r\n            internalTexture.invertY,\r\n            internalTexture.samplingMode,\r\n            internalTexture._compression\r\n        );\r\n    const proxyPromise = UploadLevelsAsync(proxy, data).then(() => internalTexture);\r\n    internalTexture.onRebuildCallback = (_internalTexture) => {\r\n        return {\r\n            proxy: proxyPromise,\r\n            isReady: true,\r\n            isAsync: true,\r\n        };\r\n    };\r\n    internalTexture._source = InternalTextureSource.CubeRawRGBD;\r\n    internalTexture._bufferViewArrayArray = data;\r\n    internalTexture._lodGenerationScale = lodScale;\r\n    internalTexture._lodGenerationOffset = lodOffset;\r\n    internalTexture._sphericalPolynomial = sphericalPolynomial;\r\n\r\n    return UploadLevelsAsync(internalTexture, data).then(() => {\r\n        internalTexture.isReady = true;\r\n        return internalTexture;\r\n    });\r\n}\r\n\r\n/**\r\n * Sets of helpers addressing the serialization and deserialization of environment texture\r\n * stored in a BabylonJS env file.\r\n * Those files are usually stored as .env files.\r\n */\r\nexport const EnvironmentTextureTools = {\r\n    /**\r\n     * Gets the environment info from an env file.\r\n     * @param data The array buffer containing the .env bytes.\r\n     * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\r\n     */\r\n    GetEnvInfo,\r\n\r\n    /**\r\n     * Creates an environment texture from a loaded cube texture.\r\n     * @param texture defines the cube texture to convert in env file\r\n     * @param options options for the conversion process\r\n     * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\r\n     * @param options.imageQuality the image quality of encoded WebP images.\r\n     * @returns a promise containing the environment data if successful.\r\n     */\r\n    CreateEnvTextureAsync,\r\n\r\n    /**\r\n     * Creates the ArrayBufferViews used for initializing environment texture image data.\r\n     * @param data the image data\r\n     * @param info parameters that determine what views will be created for accessing the underlying buffer\r\n     * @returns the views described by info providing access to the underlying buffer\r\n     */\r\n    CreateImageDataArrayBufferViews,\r\n\r\n    /**\r\n     * Uploads the texture info contained in the env file to the GPU.\r\n     * @param texture defines the internal texture to upload to\r\n     * @param data defines the data to load\r\n     * @param info defines the texture info retrieved through the GetEnvInfo method\r\n     * @returns a promise\r\n     */\r\n    UploadEnvLevelsAsync,\r\n\r\n    /**\r\n     * Uploads the levels of image data to the GPU.\r\n     * @param texture defines the internal texture to upload to\r\n     * @param imageData defines the array buffer views of image data [mipmap][face]\r\n     * @param imageType the mime type of the image data\r\n     * @returns a promise\r\n     */\r\n    UploadLevelsAsync,\r\n\r\n    /**\r\n     * Uploads spherical polynomials information to the texture.\r\n     * @param texture defines the texture we are trying to upload the information to\r\n     * @param info defines the environment texture info retrieved through the GetEnvInfo method\r\n     */\r\n    UploadEnvSpherical,\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}