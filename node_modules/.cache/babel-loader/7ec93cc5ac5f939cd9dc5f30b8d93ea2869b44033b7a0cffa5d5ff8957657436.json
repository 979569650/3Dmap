{"ast":null,"code":"import { Scalar } from \"./math.scalar.js\";\nimport { ToLinearSpace, ToGammaSpace } from \"./math.constants.js\";\nimport { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nfunction colorChannelToLinearSpace(color) {\n  return Math.pow(color, ToLinearSpace);\n}\nfunction colorChannelToLinearSpaceExact(color) {\n  if (color <= 0.04045) {\n    return 0.0773993808 * color;\n  }\n  return Math.pow(0.947867299 * (color + 0.055), 2.4);\n}\nfunction colorChannelToGammaSpace(color) {\n  return Math.pow(color, ToGammaSpace);\n}\nfunction colorChannelToGammaSpaceExact(color) {\n  if (color <= 0.0031308) {\n    return 12.92 * color;\n  }\n  return 1.055 * Math.pow(color, 0.41666) - 0.055;\n}\n/**\n * Class used to hold a RGB color\n */\nexport class Color3 {\n  /**\n   * Creates a new Color3 object from red, green, blue values, all between 0 and 1\n   * @param r defines the red component (between 0 and 1, default is 0)\n   * @param g defines the green component (between 0 and 1, default is 0)\n   * @param b defines the blue component (between 0 and 1, default is 0)\n   */\n  constructor(\n  /**\n   * Defines the red component (between 0 and 1, default is 0)\n   */\n  r = 0,\n  /**\n   * Defines the green component (between 0 and 1, default is 0)\n   */\n  g = 0,\n  /**\n   * Defines the blue component (between 0 and 1, default is 0)\n   */\n  b = 0) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n  }\n  /**\n   * Creates a string with the Color3 current values\n   * @returns the string representation of the Color3 object\n   */\n  toString() {\n    return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \"}\";\n  }\n  /**\n   * Returns the string \"Color3\"\n   * @returns \"Color3\"\n   */\n  getClassName() {\n    return \"Color3\";\n  }\n  /**\n   * Compute the Color3 hash code\n   * @returns an unique number that can be used to hash Color3 objects\n   */\n  getHashCode() {\n    let hash = this.r * 255 | 0;\n    hash = hash * 397 ^ (this.g * 255 | 0);\n    hash = hash * 397 ^ (this.b * 255 | 0);\n    return hash;\n  }\n  // Operators\n  /**\n   * Stores in the given array from the given starting index the red, green, blue values as successive elements\n   * @param array defines the array where to store the r,g,b components\n   * @param index defines an optional index in the target array to define where to start storing values\n   * @returns the current Color3 object\n   */\n  toArray(array, index = 0) {\n    array[index] = this.r;\n    array[index + 1] = this.g;\n    array[index + 2] = this.b;\n    return this;\n  }\n  /**\n   * Update the current color with values stored in an array from the starting index of the given array\n   * @param array defines the source array\n   * @param offset defines an offset in the source array\n   * @returns the current Color3 object\n   */\n  fromArray(array, offset = 0) {\n    Color3.FromArrayToRef(array, offset, this);\n    return this;\n  }\n  /**\n   * Returns a new Color4 object from the current Color3 and the given alpha\n   * @param alpha defines the alpha component on the new Color4 object (default is 1)\n   * @returns a new Color4 object\n   */\n  toColor4(alpha = 1) {\n    return new Color4(this.r, this.g, this.b, alpha);\n  }\n  /**\n   * Returns a new array populated with 3 numeric elements : red, green and blue values\n   * @returns the new array\n   */\n  asArray() {\n    return [this.r, this.g, this.b];\n  }\n  /**\n   * Returns the luminance value\n   * @returns a float value\n   */\n  toLuminance() {\n    return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;\n  }\n  /**\n   * Multiply each Color3 rgb values by the given Color3 rgb values in a new Color3 object\n   * @param otherColor defines the second operand\n   * @returns the new Color3 object\n   */\n  multiply(otherColor) {\n    return new Color3(this.r * otherColor.r, this.g * otherColor.g, this.b * otherColor.b);\n  }\n  /**\n   * Multiply the rgb values of the Color3 and the given Color3 and stores the result in the object \"result\"\n   * @param otherColor defines the second operand\n   * @param result defines the Color3 object where to store the result\n   * @returns the current Color3\n   */\n  multiplyToRef(otherColor, result) {\n    result.r = this.r * otherColor.r;\n    result.g = this.g * otherColor.g;\n    result.b = this.b * otherColor.b;\n    return this;\n  }\n  /**\n   * Determines equality between Color3 objects\n   * @param otherColor defines the second operand\n   * @returns true if the rgb values are equal to the given ones\n   */\n  equals(otherColor) {\n    return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b;\n  }\n  /**\n   * Determines equality between the current Color3 object and a set of r,b,g values\n   * @param r defines the red component to check\n   * @param g defines the green component to check\n   * @param b defines the blue component to check\n   * @returns true if the rgb values are equal to the given ones\n   */\n  equalsFloats(r, g, b) {\n    return this.r === r && this.g === g && this.b === b;\n  }\n  /**\n   * Creates a new Color3 with the current Color3 values multiplied by scale\n   * @param scale defines the scaling factor to apply\n   * @returns a new Color3 object\n   */\n  scale(scale) {\n    return new Color3(this.r * scale, this.g * scale, this.b * scale);\n  }\n  /**\n   * Multiplies the Color3 values by the float \"scale\"\n   * @param scale defines the scaling factor to apply\n   * @returns the current updated Color3\n   */\n  scaleInPlace(scale) {\n    this.r *= scale;\n    this.g *= scale;\n    this.b *= scale;\n    return this;\n  }\n  /**\n   * Multiplies the rgb values by scale and stores the result into \"result\"\n   * @param scale defines the scaling factor\n   * @param result defines the Color3 object where to store the result\n   * @returns the unmodified current Color3\n   */\n  scaleToRef(scale, result) {\n    result.r = this.r * scale;\n    result.g = this.g * scale;\n    result.b = this.b * scale;\n    return this;\n  }\n  /**\n   * Scale the current Color3 values by a factor and add the result to a given Color3\n   * @param scale defines the scale factor\n   * @param result defines color to store the result into\n   * @returns the unmodified current Color3\n   */\n  scaleAndAddToRef(scale, result) {\n    result.r += this.r * scale;\n    result.g += this.g * scale;\n    result.b += this.b * scale;\n    return this;\n  }\n  /**\n   * Clamps the rgb values by the min and max values and stores the result into \"result\"\n   * @param min defines minimum clamping value (default is 0)\n   * @param max defines maximum clamping value (default is 1)\n   * @param result defines color to store the result into\n   * @returns the original Color3\n   */\n  clampToRef(min = 0, max = 1, result) {\n    result.r = Scalar.Clamp(this.r, min, max);\n    result.g = Scalar.Clamp(this.g, min, max);\n    result.b = Scalar.Clamp(this.b, min, max);\n    return this;\n  }\n  /**\n   * Creates a new Color3 set with the added values of the current Color3 and of the given one\n   * @param otherColor defines the second operand\n   * @returns the new Color3\n   */\n  add(otherColor) {\n    return new Color3(this.r + otherColor.r, this.g + otherColor.g, this.b + otherColor.b);\n  }\n  /**\n   * Stores the result of the addition of the current Color3 and given one rgb values into \"result\"\n   * @param otherColor defines the second operand\n   * @param result defines Color3 object to store the result into\n   * @returns the unmodified current Color3\n   */\n  addToRef(otherColor, result) {\n    result.r = this.r + otherColor.r;\n    result.g = this.g + otherColor.g;\n    result.b = this.b + otherColor.b;\n    return this;\n  }\n  /**\n   * Returns a new Color3 set with the subtracted values of the given one from the current Color3\n   * @param otherColor defines the second operand\n   * @returns the new Color3\n   */\n  subtract(otherColor) {\n    return new Color3(this.r - otherColor.r, this.g - otherColor.g, this.b - otherColor.b);\n  }\n  /**\n   * Stores the result of the subtraction of given one from the current Color3 rgb values into \"result\"\n   * @param otherColor defines the second operand\n   * @param result defines Color3 object to store the result into\n   * @returns the unmodified current Color3\n   */\n  subtractToRef(otherColor, result) {\n    result.r = this.r - otherColor.r;\n    result.g = this.g - otherColor.g;\n    result.b = this.b - otherColor.b;\n    return this;\n  }\n  /**\n   * Copy the current object\n   * @returns a new Color3 copied the current one\n   */\n  clone() {\n    return new Color3(this.r, this.g, this.b);\n  }\n  /**\n   * Copies the rgb values from the source in the current Color3\n   * @param source defines the source Color3 object\n   * @returns the updated Color3 object\n   */\n  copyFrom(source) {\n    this.r = source.r;\n    this.g = source.g;\n    this.b = source.b;\n    return this;\n  }\n  /**\n   * Updates the Color3 rgb values from the given floats\n   * @param r defines the red component to read from\n   * @param g defines the green component to read from\n   * @param b defines the blue component to read from\n   * @returns the current Color3 object\n   */\n  copyFromFloats(r, g, b) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    return this;\n  }\n  /**\n   * Updates the Color3 rgb values from the given floats\n   * @param r defines the red component to read from\n   * @param g defines the green component to read from\n   * @param b defines the blue component to read from\n   * @returns the current Color3 object\n   */\n  set(r, g, b) {\n    return this.copyFromFloats(r, g, b);\n  }\n  /**\n   * Compute the Color3 hexadecimal code as a string\n   * @returns a string containing the hexadecimal representation of the Color3 object\n   */\n  toHexString() {\n    const intR = Math.round(this.r * 255);\n    const intG = Math.round(this.g * 255);\n    const intB = Math.round(this.b * 255);\n    return \"#\" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);\n  }\n  /**\n   * Converts current color in rgb space to HSV values\n   * @returns a new color3 representing the HSV values\n   */\n  toHSV() {\n    const result = new Color3();\n    this.toHSVToRef(result);\n    return result;\n  }\n  /**\n   * Converts current color in rgb space to HSV values\n   * @param result defines the Color3 where to store the HSV values\n   */\n  toHSVToRef(result) {\n    const r = this.r;\n    const g = this.g;\n    const b = this.b;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    let h = 0;\n    let s = 0;\n    const v = max;\n    const dm = max - min;\n    if (max !== 0) {\n      s = dm / max;\n    }\n    if (max != min) {\n      if (max == r) {\n        h = (g - b) / dm;\n        if (g < b) {\n          h += 6;\n        }\n      } else if (max == g) {\n        h = (b - r) / dm + 2;\n      } else if (max == b) {\n        h = (r - g) / dm + 4;\n      }\n      h *= 60;\n    }\n    result.r = h;\n    result.g = s;\n    result.b = v;\n  }\n  /**\n   * Computes a new Color3 converted from the current one to linear space\n   * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\n   * @returns a new Color3 object\n   */\n  toLinearSpace(exact = false) {\n    const convertedColor = new Color3();\n    this.toLinearSpaceToRef(convertedColor, exact);\n    return convertedColor;\n  }\n  /**\n   * Converts the Color3 values to linear space and stores the result in \"convertedColor\"\n   * @param convertedColor defines the Color3 object where to store the linear space version\n   * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\n   * @returns the unmodified Color3\n   */\n  toLinearSpaceToRef(convertedColor, exact = false) {\n    if (exact) {\n      convertedColor.r = colorChannelToLinearSpaceExact(this.r);\n      convertedColor.g = colorChannelToLinearSpaceExact(this.g);\n      convertedColor.b = colorChannelToLinearSpaceExact(this.b);\n    } else {\n      convertedColor.r = colorChannelToLinearSpace(this.r);\n      convertedColor.g = colorChannelToLinearSpace(this.g);\n      convertedColor.b = colorChannelToLinearSpace(this.b);\n    }\n    return this;\n  }\n  /**\n   * Computes a new Color3 converted from the current one to gamma space\n   * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\n   * @returns a new Color3 object\n   */\n  toGammaSpace(exact = false) {\n    const convertedColor = new Color3();\n    this.toGammaSpaceToRef(convertedColor, exact);\n    return convertedColor;\n  }\n  /**\n   * Converts the Color3 values to gamma space and stores the result in \"convertedColor\"\n   * @param convertedColor defines the Color3 object where to store the gamma space version\n   * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\n   * @returns the unmodified Color3\n   */\n  toGammaSpaceToRef(convertedColor, exact = false) {\n    if (exact) {\n      convertedColor.r = colorChannelToGammaSpaceExact(this.r);\n      convertedColor.g = colorChannelToGammaSpaceExact(this.g);\n      convertedColor.b = colorChannelToGammaSpaceExact(this.b);\n    } else {\n      convertedColor.r = colorChannelToGammaSpace(this.r);\n      convertedColor.g = colorChannelToGammaSpace(this.g);\n      convertedColor.b = colorChannelToGammaSpace(this.b);\n    }\n    return this;\n  }\n  /**\n   * Converts Hue, saturation and value to a Color3 (RGB)\n   * @param hue defines the hue (value between 0 and 360)\n   * @param saturation defines the saturation (value between 0 and 1)\n   * @param value defines the value (value between 0 and 1)\n   * @param result defines the Color3 where to store the RGB values\n   */\n  static HSVtoRGBToRef(hue, saturation, value, result) {\n    const chroma = value * saturation;\n    const h = hue / 60;\n    const x = chroma * (1 - Math.abs(h % 2 - 1));\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    if (h >= 0 && h <= 1) {\n      r = chroma;\n      g = x;\n    } else if (h >= 1 && h <= 2) {\n      r = x;\n      g = chroma;\n    } else if (h >= 2 && h <= 3) {\n      g = chroma;\n      b = x;\n    } else if (h >= 3 && h <= 4) {\n      g = x;\n      b = chroma;\n    } else if (h >= 4 && h <= 5) {\n      r = x;\n      b = chroma;\n    } else if (h >= 5 && h <= 6) {\n      r = chroma;\n      b = x;\n    }\n    const m = value - chroma;\n    result.set(r + m, g + m, b + m);\n  }\n  /**\n   * Converts Hue, saturation and value to a new Color3 (RGB)\n   * @param hue defines the hue (value between 0 and 360)\n   * @param saturation defines the saturation (value between 0 and 1)\n   * @param value defines the value (value between 0 and 1)\n   * @returns a new Color3 object\n   */\n  static FromHSV(hue, saturation, value) {\n    const result = new Color3(0, 0, 0);\n    Color3.HSVtoRGBToRef(hue, saturation, value, result);\n    return result;\n  }\n  /**\n   * Creates a new Color3 from the string containing valid hexadecimal values\n   * @param hex defines a string containing valid hexadecimal values\n   * @returns a new Color3 object\n   */\n  static FromHexString(hex) {\n    if (hex.substring(0, 1) !== \"#\" || hex.length !== 7) {\n      return new Color3(0, 0, 0);\n    }\n    const r = parseInt(hex.substring(1, 3), 16);\n    const g = parseInt(hex.substring(3, 5), 16);\n    const b = parseInt(hex.substring(5, 7), 16);\n    return Color3.FromInts(r, g, b);\n  }\n  /**\n   * Creates a new Color3 from the starting index of the given array\n   * @param array defines the source array\n   * @param offset defines an offset in the source array\n   * @returns a new Color3 object\n   */\n  static FromArray(array, offset = 0) {\n    return new Color3(array[offset], array[offset + 1], array[offset + 2]);\n  }\n  /**\n   * Creates a new Color3 from the starting index element of the given array\n   * @param array defines the source array to read from\n   * @param offset defines the offset in the source array\n   * @param result defines the target Color3 object\n   */\n  static FromArrayToRef(array, offset = 0, result) {\n    result.r = array[offset];\n    result.g = array[offset + 1];\n    result.b = array[offset + 2];\n  }\n  /**\n   * Creates a new Color3 from integer values (< 256)\n   * @param r defines the red component to read from (value between 0 and 255)\n   * @param g defines the green component to read from (value between 0 and 255)\n   * @param b defines the blue component to read from (value between 0 and 255)\n   * @returns a new Color3 object\n   */\n  static FromInts(r, g, b) {\n    return new Color3(r / 255.0, g / 255.0, b / 255.0);\n  }\n  /**\n   * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\n   * @param start defines the start Color3 value\n   * @param end defines the end Color3 value\n   * @param amount defines the gradient value between start and end\n   * @returns a new Color3 object\n   */\n  static Lerp(start, end, amount) {\n    const result = new Color3(0.0, 0.0, 0.0);\n    Color3.LerpToRef(start, end, amount, result);\n    return result;\n  }\n  /**\n   * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\n   * @param left defines the start value\n   * @param right defines the end value\n   * @param amount defines the gradient factor\n   * @param result defines the Color3 object where to store the result\n   */\n  static LerpToRef(left, right, amount, result) {\n    result.r = left.r + (right.r - left.r) * amount;\n    result.g = left.g + (right.g - left.g) * amount;\n    result.b = left.b + (right.b - left.b) * amount;\n  }\n  /**\n   * Returns a new Color3 located for \"amount\" (float) on the Hermite interpolation spline defined by the vectors \"value1\", \"tangent1\", \"value2\", \"tangent2\"\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent Color3\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent Color3\n   * @param amount defines the amount on the interpolation spline (between 0 and 1)\n   * @returns the new Color3\n   */\n  static Hermite(value1, tangent1, value2, tangent2, amount) {\n    const squared = amount * amount;\n    const cubed = amount * squared;\n    const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n    const part2 = -2.0 * cubed + 3.0 * squared;\n    const part3 = cubed - 2.0 * squared + amount;\n    const part4 = cubed - squared;\n    const r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;\n    const g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;\n    const b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;\n    return new Color3(r, g, b);\n  }\n  /**\n   * Returns a new Color3 which is the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param time define where the derivative must be done\n   * @returns 1st derivative\n   */\n  static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {\n    const result = Color3.Black();\n    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\n    return result;\n  }\n  /**\n   * Returns a new Color3 which is the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param time define where the derivative must be done\n   * @param result define where to store the derivative\n   */\n  static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {\n    const t2 = time * time;\n    result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;\n    result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;\n    result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;\n  }\n  /**\n   * Returns a Color3 value containing a red color\n   * @returns a new Color3 object\n   */\n  static Red() {\n    return new Color3(1, 0, 0);\n  }\n  /**\n   * Returns a Color3 value containing a green color\n   * @returns a new Color3 object\n   */\n  static Green() {\n    return new Color3(0, 1, 0);\n  }\n  /**\n   * Returns a Color3 value containing a blue color\n   * @returns a new Color3 object\n   */\n  static Blue() {\n    return new Color3(0, 0, 1);\n  }\n  /**\n   * Returns a Color3 value containing a black color\n   * @returns a new Color3 object\n   */\n  static Black() {\n    return new Color3(0, 0, 0);\n  }\n  /**\n   * Gets a Color3 value containing a black color that must not be updated\n   */\n  static get BlackReadOnly() {\n    return Color3._BlackReadOnly;\n  }\n  /**\n   * Returns a Color3 value containing a white color\n   * @returns a new Color3 object\n   */\n  static White() {\n    return new Color3(1, 1, 1);\n  }\n  /**\n   * Returns a Color3 value containing a purple color\n   * @returns a new Color3 object\n   */\n  static Purple() {\n    return new Color3(0.5, 0, 0.5);\n  }\n  /**\n   * Returns a Color3 value containing a magenta color\n   * @returns a new Color3 object\n   */\n  static Magenta() {\n    return new Color3(1, 0, 1);\n  }\n  /**\n   * Returns a Color3 value containing a yellow color\n   * @returns a new Color3 object\n   */\n  static Yellow() {\n    return new Color3(1, 1, 0);\n  }\n  /**\n   * Returns a Color3 value containing a gray color\n   * @returns a new Color3 object\n   */\n  static Gray() {\n    return new Color3(0.5, 0.5, 0.5);\n  }\n  /**\n   * Returns a Color3 value containing a teal color\n   * @returns a new Color3 object\n   */\n  static Teal() {\n    return new Color3(0, 1.0, 1.0);\n  }\n  /**\n   * Returns a Color3 value containing a random color\n   * @returns a new Color3 object\n   */\n  static Random() {\n    return new Color3(Math.random(), Math.random(), Math.random());\n  }\n}\n// Statics\nColor3._BlackReadOnly = Color3.Black();\n/**\n * Class used to hold a RBGA color\n */\nexport class Color4 {\n  /**\n   * Creates a new Color4 object from red, green, blue values, all between 0 and 1\n   * @param r defines the red component (between 0 and 1, default is 0)\n   * @param g defines the green component (between 0 and 1, default is 0)\n   * @param b defines the blue component (between 0 and 1, default is 0)\n   * @param a defines the alpha component (between 0 and 1, default is 1)\n   */\n  constructor(\n  /**\n   * Defines the red component (between 0 and 1, default is 0)\n   */\n  r = 0,\n  /**\n   * Defines the green component (between 0 and 1, default is 0)\n   */\n  g = 0,\n  /**\n   * Defines the blue component (between 0 and 1, default is 0)\n   */\n  b = 0,\n  /**\n   * Defines the alpha component (between 0 and 1, default is 1)\n   */\n  a = 1) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n  }\n  // Operators\n  /**\n   * Adds in place the given Color4 values to the current Color4 object\n   * @param right defines the second operand\n   * @returns the current updated Color4 object\n   */\n  addInPlace(right) {\n    this.r += right.r;\n    this.g += right.g;\n    this.b += right.b;\n    this.a += right.a;\n    return this;\n  }\n  /**\n   * Creates a new array populated with 4 numeric elements : red, green, blue, alpha values\n   * @returns the new array\n   */\n  asArray() {\n    return [this.r, this.g, this.b, this.a];\n  }\n  /**\n   * Stores from the starting index in the given array the Color4 successive values\n   * @param array defines the array where to store the r,g,b components\n   * @param index defines an optional index in the target array to define where to start storing values\n   * @returns the current Color4 object\n   */\n  toArray(array, index = 0) {\n    array[index] = this.r;\n    array[index + 1] = this.g;\n    array[index + 2] = this.b;\n    array[index + 3] = this.a;\n    return this;\n  }\n  /**\n   * Update the current color with values stored in an array from the starting index of the given array\n   * @param array defines the source array\n   * @param offset defines an offset in the source array\n   * @returns the current Color4 object\n   */\n  fromArray(array, offset = 0) {\n    Color4.FromArrayToRef(array, offset, this);\n    return this;\n  }\n  /**\n   * Determines equality between Color4 objects\n   * @param otherColor defines the second operand\n   * @returns true if the rgba values are equal to the given ones\n   */\n  equals(otherColor) {\n    return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b && this.a === otherColor.a;\n  }\n  /**\n   * Creates a new Color4 set with the added values of the current Color4 and of the given one\n   * @param right defines the second operand\n   * @returns a new Color4 object\n   */\n  add(right) {\n    return new Color4(this.r + right.r, this.g + right.g, this.b + right.b, this.a + right.a);\n  }\n  /**\n   * Creates a new Color4 set with the subtracted values of the given one from the current Color4\n   * @param right defines the second operand\n   * @returns a new Color4 object\n   */\n  subtract(right) {\n    return new Color4(this.r - right.r, this.g - right.g, this.b - right.b, this.a - right.a);\n  }\n  /**\n   * Subtracts the given ones from the current Color4 values and stores the results in \"result\"\n   * @param right defines the second operand\n   * @param result defines the Color4 object where to store the result\n   * @returns the current Color4 object\n   */\n  subtractToRef(right, result) {\n    result.r = this.r - right.r;\n    result.g = this.g - right.g;\n    result.b = this.b - right.b;\n    result.a = this.a - right.a;\n    return this;\n  }\n  /**\n   * Creates a new Color4 with the current Color4 values multiplied by scale\n   * @param scale defines the scaling factor to apply\n   * @returns a new Color4 object\n   */\n  scale(scale) {\n    return new Color4(this.r * scale, this.g * scale, this.b * scale, this.a * scale);\n  }\n  /**\n   * Multiplies the Color4 values by the float \"scale\"\n   * @param scale defines the scaling factor to apply\n   * @returns the current updated Color4\n   */\n  scaleInPlace(scale) {\n    this.r *= scale;\n    this.g *= scale;\n    this.b *= scale;\n    this.a *= scale;\n    return this;\n  }\n  /**\n   * Multiplies the current Color4 values by scale and stores the result in \"result\"\n   * @param scale defines the scaling factor to apply\n   * @param result defines the Color4 object where to store the result\n   * @returns the current unmodified Color4\n   */\n  scaleToRef(scale, result) {\n    result.r = this.r * scale;\n    result.g = this.g * scale;\n    result.b = this.b * scale;\n    result.a = this.a * scale;\n    return this;\n  }\n  /**\n   * Scale the current Color4 values by a factor and add the result to a given Color4\n   * @param scale defines the scale factor\n   * @param result defines the Color4 object where to store the result\n   * @returns the unmodified current Color4\n   */\n  scaleAndAddToRef(scale, result) {\n    result.r += this.r * scale;\n    result.g += this.g * scale;\n    result.b += this.b * scale;\n    result.a += this.a * scale;\n    return this;\n  }\n  /**\n   * Clamps the rgb values by the min and max values and stores the result into \"result\"\n   * @param min defines minimum clamping value (default is 0)\n   * @param max defines maximum clamping value (default is 1)\n   * @param result defines color to store the result into.\n   * @returns the current Color4\n   */\n  clampToRef(min = 0, max = 1, result) {\n    result.r = Scalar.Clamp(this.r, min, max);\n    result.g = Scalar.Clamp(this.g, min, max);\n    result.b = Scalar.Clamp(this.b, min, max);\n    result.a = Scalar.Clamp(this.a, min, max);\n    return this;\n  }\n  /**\n   * Multiply an Color4 value by another and return a new Color4 object\n   * @param color defines the Color4 value to multiply by\n   * @returns a new Color4 object\n   */\n  multiply(color) {\n    return new Color4(this.r * color.r, this.g * color.g, this.b * color.b, this.a * color.a);\n  }\n  /**\n   * Multiply a Color4 value by another and push the result in a reference value\n   * @param color defines the Color4 value to multiply by\n   * @param result defines the Color4 to fill the result in\n   * @returns the result Color4\n   */\n  multiplyToRef(color, result) {\n    result.r = this.r * color.r;\n    result.g = this.g * color.g;\n    result.b = this.b * color.b;\n    result.a = this.a * color.a;\n    return result;\n  }\n  /**\n   * Creates a string with the Color4 current values\n   * @returns the string representation of the Color4 object\n   */\n  toString() {\n    return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \" A:\" + this.a + \"}\";\n  }\n  /**\n   * Returns the string \"Color4\"\n   * @returns \"Color4\"\n   */\n  getClassName() {\n    return \"Color4\";\n  }\n  /**\n   * Compute the Color4 hash code\n   * @returns an unique number that can be used to hash Color4 objects\n   */\n  getHashCode() {\n    let hash = this.r * 255 | 0;\n    hash = hash * 397 ^ (this.g * 255 | 0);\n    hash = hash * 397 ^ (this.b * 255 | 0);\n    hash = hash * 397 ^ (this.a * 255 | 0);\n    return hash;\n  }\n  /**\n   * Creates a new Color4 copied from the current one\n   * @returns a new Color4 object\n   */\n  clone() {\n    return new Color4(this.r, this.g, this.b, this.a);\n  }\n  /**\n   * Copies the given Color4 values into the current one\n   * @param source defines the source Color4 object\n   * @returns the current updated Color4 object\n   */\n  copyFrom(source) {\n    this.r = source.r;\n    this.g = source.g;\n    this.b = source.b;\n    this.a = source.a;\n    return this;\n  }\n  /**\n   * Copies the given float values into the current one\n   * @param r defines the red component to read from\n   * @param g defines the green component to read from\n   * @param b defines the blue component to read from\n   * @param a defines the alpha component to read from\n   * @returns the current updated Color4 object\n   */\n  copyFromFloats(r, g, b, a) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n    return this;\n  }\n  /**\n   * Copies the given float values into the current one\n   * @param r defines the red component to read from\n   * @param g defines the green component to read from\n   * @param b defines the blue component to read from\n   * @param a defines the alpha component to read from\n   * @returns the current updated Color4 object\n   */\n  set(r, g, b, a) {\n    return this.copyFromFloats(r, g, b, a);\n  }\n  /**\n   * Compute the Color4 hexadecimal code as a string\n   * @param returnAsColor3 defines if the string should only contains RGB values (off by default)\n   * @returns a string containing the hexadecimal representation of the Color4 object\n   */\n  toHexString(returnAsColor3 = false) {\n    const intR = Math.round(this.r * 255);\n    const intG = Math.round(this.g * 255);\n    const intB = Math.round(this.b * 255);\n    if (returnAsColor3) {\n      return \"#\" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);\n    }\n    const intA = Math.round(this.a * 255);\n    return \"#\" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB) + Scalar.ToHex(intA);\n  }\n  /**\n   * Computes a new Color4 converted from the current one to linear space\n   * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\n   * @returns a new Color4 object\n   */\n  toLinearSpace(exact = false) {\n    const convertedColor = new Color4();\n    this.toLinearSpaceToRef(convertedColor, exact);\n    return convertedColor;\n  }\n  /**\n   * Converts the Color4 values to linear space and stores the result in \"convertedColor\"\n   * @param convertedColor defines the Color4 object where to store the linear space version\n   * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\n   * @returns the unmodified Color4\n   */\n  toLinearSpaceToRef(convertedColor, exact = false) {\n    if (exact) {\n      convertedColor.r = colorChannelToLinearSpaceExact(this.r);\n      convertedColor.g = colorChannelToLinearSpaceExact(this.g);\n      convertedColor.b = colorChannelToLinearSpaceExact(this.b);\n    } else {\n      convertedColor.r = colorChannelToLinearSpace(this.r);\n      convertedColor.g = colorChannelToLinearSpace(this.g);\n      convertedColor.b = colorChannelToLinearSpace(this.b);\n    }\n    convertedColor.a = this.a;\n    return this;\n  }\n  /**\n   * Computes a new Color4 converted from the current one to gamma space\n   * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\n   * @returns a new Color4 object\n   */\n  toGammaSpace(exact = false) {\n    const convertedColor = new Color4();\n    this.toGammaSpaceToRef(convertedColor, exact);\n    return convertedColor;\n  }\n  /**\n   * Converts the Color4 values to gamma space and stores the result in \"convertedColor\"\n   * @param convertedColor defines the Color4 object where to store the gamma space version\n   * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\n   * @returns the unmodified Color4\n   */\n  toGammaSpaceToRef(convertedColor, exact = false) {\n    if (exact) {\n      convertedColor.r = colorChannelToGammaSpaceExact(this.r);\n      convertedColor.g = colorChannelToGammaSpaceExact(this.g);\n      convertedColor.b = colorChannelToGammaSpaceExact(this.b);\n    } else {\n      convertedColor.r = colorChannelToGammaSpace(this.r);\n      convertedColor.g = colorChannelToGammaSpace(this.g);\n      convertedColor.b = colorChannelToGammaSpace(this.b);\n    }\n    convertedColor.a = this.a;\n    return this;\n  }\n  // Statics\n  /**\n   * Creates a new Color4 from the string containing valid hexadecimal values.\n   *\n   * A valid hex string is either in the format #RRGGBB or #RRGGBBAA.\n   *\n   * When a hex string without alpha is passed, the resulting Color4 has\n   * its alpha value set to 1.0.\n   *\n   * An invalid string results in a Color with all its channels set to 0.0,\n   * i.e. \"transparent black\".\n   *\n   * @param hex defines a string containing valid hexadecimal values\n   * @returns a new Color4 object\n   */\n  static FromHexString(hex) {\n    if (hex.substring(0, 1) !== \"#\" || hex.length !== 9 && hex.length !== 7) {\n      return new Color4(0.0, 0.0, 0.0, 0.0);\n    }\n    const r = parseInt(hex.substring(1, 3), 16);\n    const g = parseInt(hex.substring(3, 5), 16);\n    const b = parseInt(hex.substring(5, 7), 16);\n    const a = hex.length === 9 ? parseInt(hex.substring(7, 9), 16) : 255;\n    return Color4.FromInts(r, g, b, a);\n  }\n  /**\n   * Creates a new Color4 object set with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\n   * @param left defines the start value\n   * @param right defines the end value\n   * @param amount defines the gradient factor\n   * @returns a new Color4 object\n   */\n  static Lerp(left, right, amount) {\n    const result = new Color4(0.0, 0.0, 0.0, 0.0);\n    Color4.LerpToRef(left, right, amount, result);\n    return result;\n  }\n  /**\n   * Set the given \"result\" with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\n   * @param left defines the start value\n   * @param right defines the end value\n   * @param amount defines the gradient factor\n   * @param result defines the Color4 object where to store data\n   */\n  static LerpToRef(left, right, amount, result) {\n    result.r = left.r + (right.r - left.r) * amount;\n    result.g = left.g + (right.g - left.g) * amount;\n    result.b = left.b + (right.b - left.b) * amount;\n    result.a = left.a + (right.a - left.a) * amount;\n  }\n  /**\n   * Interpolate between two Color4 using Hermite interpolation\n   * @param value1 defines first Color4\n   * @param tangent1 defines the incoming tangent\n   * @param value2 defines second Color4\n   * @param tangent2 defines the outgoing tangent\n   * @param amount defines the target Color4\n   * @returns the new interpolated Color4\n   */\n  static Hermite(value1, tangent1, value2, tangent2, amount) {\n    const squared = amount * amount;\n    const cubed = amount * squared;\n    const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n    const part2 = -2.0 * cubed + 3.0 * squared;\n    const part3 = cubed - 2.0 * squared + amount;\n    const part4 = cubed - squared;\n    const r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;\n    const g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;\n    const b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;\n    const a = value1.a * part1 + value2.a * part2 + tangent1.a * part3 + tangent2.a * part4;\n    return new Color4(r, g, b, a);\n  }\n  /**\n   * Returns a new Color4 which is the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param time define where the derivative must be done\n   * @returns 1st derivative\n   */\n  static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {\n    const result = new Color4();\n    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\n    return result;\n  }\n  /**\n   * Update a Color4 with the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param time define where the derivative must be done\n   * @param result define where to store the derivative\n   */\n  static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {\n    const t2 = time * time;\n    result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;\n    result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;\n    result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;\n    result.a = (t2 - time) * 6 * value1.a + (3 * t2 - 4 * time + 1) * tangent1.a + (-t2 + time) * 6 * value2.a + (3 * t2 - 2 * time) * tangent2.a;\n  }\n  /**\n   * Creates a new Color4 from a Color3 and an alpha value\n   * @param color3 defines the source Color3 to read from\n   * @param alpha defines the alpha component (1.0 by default)\n   * @returns a new Color4 object\n   */\n  static FromColor3(color3, alpha = 1.0) {\n    return new Color4(color3.r, color3.g, color3.b, alpha);\n  }\n  /**\n   * Creates a new Color4 from the starting index element of the given array\n   * @param array defines the source array to read from\n   * @param offset defines the offset in the source array\n   * @returns a new Color4 object\n   */\n  static FromArray(array, offset = 0) {\n    return new Color4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n  }\n  /**\n   * Creates a new Color4 from the starting index element of the given array\n   * @param array defines the source array to read from\n   * @param offset defines the offset in the source array\n   * @param result defines the target Color4 object\n   */\n  static FromArrayToRef(array, offset = 0, result) {\n    result.r = array[offset];\n    result.g = array[offset + 1];\n    result.b = array[offset + 2];\n    result.a = array[offset + 3];\n  }\n  /**\n   * Creates a new Color3 from integer values (< 256)\n   * @param r defines the red component to read from (value between 0 and 255)\n   * @param g defines the green component to read from (value between 0 and 255)\n   * @param b defines the blue component to read from (value between 0 and 255)\n   * @param a defines the alpha component to read from (value between 0 and 255)\n   * @returns a new Color3 object\n   */\n  static FromInts(r, g, b, a) {\n    return new Color4(r / 255.0, g / 255.0, b / 255.0, a / 255.0);\n  }\n  /**\n   * Check the content of a given array and convert it to an array containing RGBA data\n   * If the original array was already containing count * 4 values then it is returned directly\n   * @param colors defines the array to check\n   * @param count defines the number of RGBA data to expect\n   * @returns an array containing count * 4 values (RGBA)\n   */\n  static CheckColors4(colors, count) {\n    // Check if color3 was used\n    if (colors.length === count * 3) {\n      const colors4 = [];\n      for (let index = 0; index < colors.length; index += 3) {\n        const newIndex = index / 3 * 4;\n        colors4[newIndex] = colors[index];\n        colors4[newIndex + 1] = colors[index + 1];\n        colors4[newIndex + 2] = colors[index + 2];\n        colors4[newIndex + 3] = 1.0;\n      }\n      return colors4;\n    }\n    return colors;\n  }\n}\n/**\n * @internal\n */\nexport class TmpColors {}\nTmpColors.Color3 = ArrayTools.BuildArray(3, Color3.Black);\nTmpColors.Color4 = ArrayTools.BuildArray(3, () => new Color4(0, 0, 0, 0));\nRegisterClass(\"BABYLON.Color3\", Color3);\nRegisterClass(\"BABYLON.Color4\", Color4);","map":{"version":3,"names":["Scalar","ToLinearSpace","ToGammaSpace","ArrayTools","RegisterClass","colorChannelToLinearSpace","color","Math","pow","colorChannelToLinearSpaceExact","colorChannelToGammaSpace","colorChannelToGammaSpaceExact","Color3","constructor","r","g","b","toString","getClassName","getHashCode","hash","toArray","array","index","fromArray","offset","FromArrayToRef","toColor4","alpha","Color4","asArray","toLuminance","multiply","otherColor","multiplyToRef","result","equals","equalsFloats","scale","scaleInPlace","scaleToRef","scaleAndAddToRef","clampToRef","min","max","Clamp","add","addToRef","subtract","subtractToRef","clone","copyFrom","source","copyFromFloats","set","toHexString","intR","round","intG","intB","ToHex","toHSV","toHSVToRef","h","s","v","dm","toLinearSpace","exact","convertedColor","toLinearSpaceToRef","toGammaSpace","toGammaSpaceToRef","HSVtoRGBToRef","hue","saturation","value","chroma","x","abs","m","FromHSV","FromHexString","hex","substring","length","parseInt","FromInts","FromArray","Lerp","start","end","amount","LerpToRef","left","right","Hermite","value1","tangent1","value2","tangent2","squared","cubed","part1","part2","part3","part4","Hermite1stDerivative","time","Black","Hermite1stDerivativeToRef","t2","Red","Green","Blue","BlackReadOnly","_BlackReadOnly","White","Purple","Magenta","Yellow","Gray","Teal","Random","random","a","addInPlace","returnAsColor3","intA","FromColor3","color3","CheckColors4","colors","count","colors4","newIndex","TmpColors","BuildArray"],"sources":["../../../../dev/core/src/Maths/math.color.ts"],"sourcesContent":["import type { DeepImmutable, FloatArray } from \"../types\";\r\nimport { Scalar } from \"./math.scalar\";\r\nimport { ToLinearSpace, ToGammaSpace } from \"./math.constants\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\nfunction colorChannelToLinearSpace(color: number): number {\r\n    return Math.pow(color, ToLinearSpace);\r\n}\r\n\r\nfunction colorChannelToLinearSpaceExact(color: number): number {\r\n    if (color <= 0.04045) {\r\n        return 0.0773993808 * color;\r\n    }\r\n    return Math.pow(0.947867299 * (color + 0.055), 2.4);\r\n}\r\n\r\nfunction colorChannelToGammaSpace(color: number): number {\r\n    return Math.pow(color, ToGammaSpace);\r\n}\r\n\r\nfunction colorChannelToGammaSpaceExact(color: number): number {\r\n    if (color <= 0.0031308) {\r\n        return 12.92 * color;\r\n    }\r\n    return 1.055 * Math.pow(color, 0.41666) - 0.055;\r\n}\r\n\r\n/**\r\n * Class used to hold a RGB color\r\n */\r\nexport class Color3 {\r\n    /**\r\n     * Creates a new Color3 object from red, green, blue values, all between 0 and 1\r\n     * @param r defines the red component (between 0 and 1, default is 0)\r\n     * @param g defines the green component (between 0 and 1, default is 0)\r\n     * @param b defines the blue component (between 0 and 1, default is 0)\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the red component (between 0 and 1, default is 0)\r\n         */\r\n        public r: number = 0,\r\n        /**\r\n         * Defines the green component (between 0 and 1, default is 0)\r\n         */\r\n        public g: number = 0,\r\n        /**\r\n         * Defines the blue component (between 0 and 1, default is 0)\r\n         */\r\n        public b: number = 0\r\n    ) {}\r\n\r\n    /**\r\n     * Creates a string with the Color3 current values\r\n     * @returns the string representation of the Color3 object\r\n     */\r\n    public toString(): string {\r\n        return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \"}\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"Color3\"\r\n     * @returns \"Color3\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"Color3\";\r\n    }\r\n\r\n    /**\r\n     * Compute the Color3 hash code\r\n     * @returns an unique number that can be used to hash Color3 objects\r\n     */\r\n    public getHashCode(): number {\r\n        let hash = (this.r * 255) | 0;\r\n        hash = (hash * 397) ^ ((this.g * 255) | 0);\r\n        hash = (hash * 397) ^ ((this.b * 255) | 0);\r\n        return hash;\r\n    }\r\n\r\n    // Operators\r\n\r\n    /**\r\n     * Stores in the given array from the given starting index the red, green, blue values as successive elements\r\n     * @param array defines the array where to store the r,g,b components\r\n     * @param index defines an optional index in the target array to define where to start storing values\r\n     * @returns the current Color3 object\r\n     */\r\n    public toArray(array: FloatArray, index: number = 0): Color3 {\r\n        array[index] = this.r;\r\n        array[index + 1] = this.g;\r\n        array[index + 2] = this.b;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Update the current color with values stored in an array from the starting index of the given array\r\n     * @param array defines the source array\r\n     * @param offset defines an offset in the source array\r\n     * @returns the current Color3 object\r\n     */\r\n    public fromArray(array: DeepImmutable<ArrayLike<number>>, offset: number = 0): Color3 {\r\n        Color3.FromArrayToRef(array, offset, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Color4 object from the current Color3 and the given alpha\r\n     * @param alpha defines the alpha component on the new Color4 object (default is 1)\r\n     * @returns a new Color4 object\r\n     */\r\n    public toColor4(alpha: number = 1): Color4 {\r\n        return new Color4(this.r, this.g, this.b, alpha);\r\n    }\r\n\r\n    /**\r\n     * Returns a new array populated with 3 numeric elements : red, green and blue values\r\n     * @returns the new array\r\n     */\r\n    public asArray(): number[] {\r\n        return [this.r, this.g, this.b];\r\n    }\r\n\r\n    /**\r\n     * Returns the luminance value\r\n     * @returns a float value\r\n     */\r\n    public toLuminance(): number {\r\n        return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;\r\n    }\r\n\r\n    /**\r\n     * Multiply each Color3 rgb values by the given Color3 rgb values in a new Color3 object\r\n     * @param otherColor defines the second operand\r\n     * @returns the new Color3 object\r\n     */\r\n    public multiply(otherColor: DeepImmutable<Color3>): Color3 {\r\n        return new Color3(this.r * otherColor.r, this.g * otherColor.g, this.b * otherColor.b);\r\n    }\r\n\r\n    /**\r\n     * Multiply the rgb values of the Color3 and the given Color3 and stores the result in the object \"result\"\r\n     * @param otherColor defines the second operand\r\n     * @param result defines the Color3 object where to store the result\r\n     * @returns the current Color3\r\n     */\r\n    public multiplyToRef(otherColor: DeepImmutable<Color3>, result: Color3): Color3 {\r\n        result.r = this.r * otherColor.r;\r\n        result.g = this.g * otherColor.g;\r\n        result.b = this.b * otherColor.b;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Determines equality between Color3 objects\r\n     * @param otherColor defines the second operand\r\n     * @returns true if the rgb values are equal to the given ones\r\n     */\r\n    public equals(otherColor: DeepImmutable<Color3>): boolean {\r\n        return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b;\r\n    }\r\n\r\n    /**\r\n     * Determines equality between the current Color3 object and a set of r,b,g values\r\n     * @param r defines the red component to check\r\n     * @param g defines the green component to check\r\n     * @param b defines the blue component to check\r\n     * @returns true if the rgb values are equal to the given ones\r\n     */\r\n    public equalsFloats(r: number, g: number, b: number): boolean {\r\n        return this.r === r && this.g === g && this.b === b;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 with the current Color3 values multiplied by scale\r\n     * @param scale defines the scaling factor to apply\r\n     * @returns a new Color3 object\r\n     */\r\n    public scale(scale: number): Color3 {\r\n        return new Color3(this.r * scale, this.g * scale, this.b * scale);\r\n    }\r\n\r\n    /**\r\n     * Multiplies the Color3 values by the float \"scale\"\r\n     * @param scale defines the scaling factor to apply\r\n     * @returns the current updated Color3\r\n     */\r\n    public scaleInPlace(scale: number): Color3 {\r\n        this.r *= scale;\r\n        this.g *= scale;\r\n        this.b *= scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Multiplies the rgb values by scale and stores the result into \"result\"\r\n     * @param scale defines the scaling factor\r\n     * @param result defines the Color3 object where to store the result\r\n     * @returns the unmodified current Color3\r\n     */\r\n    public scaleToRef(scale: number, result: Color3): Color3 {\r\n        result.r = this.r * scale;\r\n        result.g = this.g * scale;\r\n        result.b = this.b * scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Scale the current Color3 values by a factor and add the result to a given Color3\r\n     * @param scale defines the scale factor\r\n     * @param result defines color to store the result into\r\n     * @returns the unmodified current Color3\r\n     */\r\n    public scaleAndAddToRef(scale: number, result: Color3): Color3 {\r\n        result.r += this.r * scale;\r\n        result.g += this.g * scale;\r\n        result.b += this.b * scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clamps the rgb values by the min and max values and stores the result into \"result\"\r\n     * @param min defines minimum clamping value (default is 0)\r\n     * @param max defines maximum clamping value (default is 1)\r\n     * @param result defines color to store the result into\r\n     * @returns the original Color3\r\n     */\r\n    public clampToRef(min: number = 0, max: number = 1, result: Color3): Color3 {\r\n        result.r = Scalar.Clamp(this.r, min, max);\r\n        result.g = Scalar.Clamp(this.g, min, max);\r\n        result.b = Scalar.Clamp(this.b, min, max);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 set with the added values of the current Color3 and of the given one\r\n     * @param otherColor defines the second operand\r\n     * @returns the new Color3\r\n     */\r\n    public add(otherColor: DeepImmutable<Color3>): Color3 {\r\n        return new Color3(this.r + otherColor.r, this.g + otherColor.g, this.b + otherColor.b);\r\n    }\r\n\r\n    /**\r\n     * Stores the result of the addition of the current Color3 and given one rgb values into \"result\"\r\n     * @param otherColor defines the second operand\r\n     * @param result defines Color3 object to store the result into\r\n     * @returns the unmodified current Color3\r\n     */\r\n    public addToRef(otherColor: DeepImmutable<Color3>, result: Color3): Color3 {\r\n        result.r = this.r + otherColor.r;\r\n        result.g = this.g + otherColor.g;\r\n        result.b = this.b + otherColor.b;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Color3 set with the subtracted values of the given one from the current Color3\r\n     * @param otherColor defines the second operand\r\n     * @returns the new Color3\r\n     */\r\n    public subtract(otherColor: DeepImmutable<Color3>): Color3 {\r\n        return new Color3(this.r - otherColor.r, this.g - otherColor.g, this.b - otherColor.b);\r\n    }\r\n\r\n    /**\r\n     * Stores the result of the subtraction of given one from the current Color3 rgb values into \"result\"\r\n     * @param otherColor defines the second operand\r\n     * @param result defines Color3 object to store the result into\r\n     * @returns the unmodified current Color3\r\n     */\r\n    public subtractToRef(otherColor: DeepImmutable<Color3>, result: Color3): Color3 {\r\n        result.r = this.r - otherColor.r;\r\n        result.g = this.g - otherColor.g;\r\n        result.b = this.b - otherColor.b;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copy the current object\r\n     * @returns a new Color3 copied the current one\r\n     */\r\n    public clone(): Color3 {\r\n        return new Color3(this.r, this.g, this.b);\r\n    }\r\n\r\n    /**\r\n     * Copies the rgb values from the source in the current Color3\r\n     * @param source defines the source Color3 object\r\n     * @returns the updated Color3 object\r\n     */\r\n    public copyFrom(source: DeepImmutable<Color3>): Color3 {\r\n        this.r = source.r;\r\n        this.g = source.g;\r\n        this.b = source.b;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the Color3 rgb values from the given floats\r\n     * @param r defines the red component to read from\r\n     * @param g defines the green component to read from\r\n     * @param b defines the blue component to read from\r\n     * @returns the current Color3 object\r\n     */\r\n    public copyFromFloats(r: number, g: number, b: number): Color3 {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the Color3 rgb values from the given floats\r\n     * @param r defines the red component to read from\r\n     * @param g defines the green component to read from\r\n     * @param b defines the blue component to read from\r\n     * @returns the current Color3 object\r\n     */\r\n    public set(r: number, g: number, b: number): Color3 {\r\n        return this.copyFromFloats(r, g, b);\r\n    }\r\n\r\n    /**\r\n     * Compute the Color3 hexadecimal code as a string\r\n     * @returns a string containing the hexadecimal representation of the Color3 object\r\n     */\r\n    public toHexString(): string {\r\n        const intR = Math.round(this.r * 255);\r\n        const intG = Math.round(this.g * 255);\r\n        const intB = Math.round(this.b * 255);\r\n        return \"#\" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);\r\n    }\r\n\r\n    /**\r\n     * Converts current color in rgb space to HSV values\r\n     * @returns a new color3 representing the HSV values\r\n     */\r\n    public toHSV(): Color3 {\r\n        const result = new Color3();\r\n\r\n        this.toHSVToRef(result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Converts current color in rgb space to HSV values\r\n     * @param result defines the Color3 where to store the HSV values\r\n     */\r\n    public toHSVToRef(result: Color3) {\r\n        const r = this.r;\r\n        const g = this.g;\r\n        const b = this.b;\r\n\r\n        const max = Math.max(r, g, b);\r\n        const min = Math.min(r, g, b);\r\n        let h = 0;\r\n        let s = 0;\r\n        const v = max;\r\n\r\n        const dm = max - min;\r\n\r\n        if (max !== 0) {\r\n            s = dm / max;\r\n        }\r\n\r\n        if (max != min) {\r\n            if (max == r) {\r\n                h = (g - b) / dm;\r\n                if (g < b) {\r\n                    h += 6;\r\n                }\r\n            } else if (max == g) {\r\n                h = (b - r) / dm + 2;\r\n            } else if (max == b) {\r\n                h = (r - g) / dm + 4;\r\n            }\r\n            h *= 60;\r\n        }\r\n\r\n        result.r = h;\r\n        result.g = s;\r\n        result.b = v;\r\n    }\r\n\r\n    /**\r\n     * Computes a new Color3 converted from the current one to linear space\r\n     * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\r\n     * @returns a new Color3 object\r\n     */\r\n    public toLinearSpace(exact = false): Color3 {\r\n        const convertedColor = new Color3();\r\n        this.toLinearSpaceToRef(convertedColor, exact);\r\n        return convertedColor;\r\n    }\r\n\r\n    /**\r\n     * Converts the Color3 values to linear space and stores the result in \"convertedColor\"\r\n     * @param convertedColor defines the Color3 object where to store the linear space version\r\n     * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\r\n     * @returns the unmodified Color3\r\n     */\r\n    public toLinearSpaceToRef(convertedColor: Color3, exact = false): Color3 {\r\n        if (exact) {\r\n            convertedColor.r = colorChannelToLinearSpaceExact(this.r);\r\n            convertedColor.g = colorChannelToLinearSpaceExact(this.g);\r\n            convertedColor.b = colorChannelToLinearSpaceExact(this.b);\r\n        } else {\r\n            convertedColor.r = colorChannelToLinearSpace(this.r);\r\n            convertedColor.g = colorChannelToLinearSpace(this.g);\r\n            convertedColor.b = colorChannelToLinearSpace(this.b);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Computes a new Color3 converted from the current one to gamma space\r\n     * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\r\n     * @returns a new Color3 object\r\n     */\r\n    public toGammaSpace(exact = false): Color3 {\r\n        const convertedColor = new Color3();\r\n        this.toGammaSpaceToRef(convertedColor, exact);\r\n        return convertedColor;\r\n    }\r\n\r\n    /**\r\n     * Converts the Color3 values to gamma space and stores the result in \"convertedColor\"\r\n     * @param convertedColor defines the Color3 object where to store the gamma space version\r\n     * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\r\n     * @returns the unmodified Color3\r\n     */\r\n    public toGammaSpaceToRef(convertedColor: Color3, exact = false): Color3 {\r\n        if (exact) {\r\n            convertedColor.r = colorChannelToGammaSpaceExact(this.r);\r\n            convertedColor.g = colorChannelToGammaSpaceExact(this.g);\r\n            convertedColor.b = colorChannelToGammaSpaceExact(this.b);\r\n        } else {\r\n            convertedColor.r = colorChannelToGammaSpace(this.r);\r\n            convertedColor.g = colorChannelToGammaSpace(this.g);\r\n            convertedColor.b = colorChannelToGammaSpace(this.b);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // Statics\r\n\r\n    private static _BlackReadOnly = Color3.Black() as DeepImmutable<Color3>;\r\n\r\n    /**\r\n     * Converts Hue, saturation and value to a Color3 (RGB)\r\n     * @param hue defines the hue (value between 0 and 360)\r\n     * @param saturation defines the saturation (value between 0 and 1)\r\n     * @param value defines the value (value between 0 and 1)\r\n     * @param result defines the Color3 where to store the RGB values\r\n     */\r\n    public static HSVtoRGBToRef(hue: number, saturation: number, value: number, result: Color3) {\r\n        const chroma = value * saturation;\r\n        const h = hue / 60;\r\n        const x = chroma * (1 - Math.abs((h % 2) - 1));\r\n        let r = 0;\r\n        let g = 0;\r\n        let b = 0;\r\n\r\n        if (h >= 0 && h <= 1) {\r\n            r = chroma;\r\n            g = x;\r\n        } else if (h >= 1 && h <= 2) {\r\n            r = x;\r\n            g = chroma;\r\n        } else if (h >= 2 && h <= 3) {\r\n            g = chroma;\r\n            b = x;\r\n        } else if (h >= 3 && h <= 4) {\r\n            g = x;\r\n            b = chroma;\r\n        } else if (h >= 4 && h <= 5) {\r\n            r = x;\r\n            b = chroma;\r\n        } else if (h >= 5 && h <= 6) {\r\n            r = chroma;\r\n            b = x;\r\n        }\r\n\r\n        const m = value - chroma;\r\n        result.set(r + m, g + m, b + m);\r\n    }\r\n\r\n    /**\r\n     * Converts Hue, saturation and value to a new Color3 (RGB)\r\n     * @param hue defines the hue (value between 0 and 360)\r\n     * @param saturation defines the saturation (value between 0 and 1)\r\n     * @param value defines the value (value between 0 and 1)\r\n     * @returns a new Color3 object\r\n     */\r\n    public static FromHSV(hue: number, saturation: number, value: number): Color3 {\r\n        const result = new Color3(0, 0, 0);\r\n        Color3.HSVtoRGBToRef(hue, saturation, value, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 from the string containing valid hexadecimal values\r\n     * @param hex defines a string containing valid hexadecimal values\r\n     * @returns a new Color3 object\r\n     */\r\n    public static FromHexString(hex: string): Color3 {\r\n        if (hex.substring(0, 1) !== \"#\" || hex.length !== 7) {\r\n            return new Color3(0, 0, 0);\r\n        }\r\n\r\n        const r = parseInt(hex.substring(1, 3), 16);\r\n        const g = parseInt(hex.substring(3, 5), 16);\r\n        const b = parseInt(hex.substring(5, 7), 16);\r\n\r\n        return Color3.FromInts(r, g, b);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 from the starting index of the given array\r\n     * @param array defines the source array\r\n     * @param offset defines an offset in the source array\r\n     * @returns a new Color3 object\r\n     */\r\n    public static FromArray(array: DeepImmutable<ArrayLike<number>>, offset: number = 0): Color3 {\r\n        return new Color3(array[offset], array[offset + 1], array[offset + 2]);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 from the starting index element of the given array\r\n     * @param array defines the source array to read from\r\n     * @param offset defines the offset in the source array\r\n     * @param result defines the target Color3 object\r\n     */\r\n    public static FromArrayToRef(array: DeepImmutable<ArrayLike<number>>, offset: number = 0, result: Color3) {\r\n        result.r = array[offset];\r\n        result.g = array[offset + 1];\r\n        result.b = array[offset + 2];\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 from integer values (< 256)\r\n     * @param r defines the red component to read from (value between 0 and 255)\r\n     * @param g defines the green component to read from (value between 0 and 255)\r\n     * @param b defines the blue component to read from (value between 0 and 255)\r\n     * @returns a new Color3 object\r\n     */\r\n    public static FromInts(r: number, g: number, b: number): Color3 {\r\n        return new Color3(r / 255.0, g / 255.0, b / 255.0);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\r\n     * @param start defines the start Color3 value\r\n     * @param end defines the end Color3 value\r\n     * @param amount defines the gradient value between start and end\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Lerp(start: DeepImmutable<Color3>, end: DeepImmutable<Color3>, amount: number): Color3 {\r\n        const result = new Color3(0.0, 0.0, 0.0);\r\n        Color3.LerpToRef(start, end, amount, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\r\n     * @param left defines the start value\r\n     * @param right defines the end value\r\n     * @param amount defines the gradient factor\r\n     * @param result defines the Color3 object where to store the result\r\n     */\r\n    public static LerpToRef(left: DeepImmutable<Color3>, right: DeepImmutable<Color3>, amount: number, result: Color3): void {\r\n        result.r = left.r + (right.r - left.r) * amount;\r\n        result.g = left.g + (right.g - left.g) * amount;\r\n        result.b = left.b + (right.b - left.b) * amount;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Color3 located for \"amount\" (float) on the Hermite interpolation spline defined by the vectors \"value1\", \"tangent1\", \"value2\", \"tangent2\"\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent Color3\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent Color3\r\n     * @param amount defines the amount on the interpolation spline (between 0 and 1)\r\n     * @returns the new Color3\r\n     */\r\n    public static Hermite(value1: DeepImmutable<Color3>, tangent1: DeepImmutable<Color3>, value2: DeepImmutable<Color3>, tangent2: DeepImmutable<Color3>, amount: number): Color3 {\r\n        const squared = amount * amount;\r\n        const cubed = amount * squared;\r\n        const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\r\n        const part2 = -2.0 * cubed + 3.0 * squared;\r\n        const part3 = cubed - 2.0 * squared + amount;\r\n        const part4 = cubed - squared;\r\n\r\n        const r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;\r\n        const g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;\r\n        const b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;\r\n        return new Color3(r, g, b);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Color3 which is the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent\r\n     * @param time define where the derivative must be done\r\n     * @returns 1st derivative\r\n     */\r\n    public static Hermite1stDerivative(\r\n        value1: DeepImmutable<Color3>,\r\n        tangent1: DeepImmutable<Color3>,\r\n        value2: DeepImmutable<Color3>,\r\n        tangent2: DeepImmutable<Color3>,\r\n        time: number\r\n    ): Color3 {\r\n        const result = Color3.Black();\r\n\r\n        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Color3 which is the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent\r\n     * @param time define where the derivative must be done\r\n     * @param result define where to store the derivative\r\n     */\r\n    public static Hermite1stDerivativeToRef(\r\n        value1: DeepImmutable<Color3>,\r\n        tangent1: DeepImmutable<Color3>,\r\n        value2: DeepImmutable<Color3>,\r\n        tangent2: DeepImmutable<Color3>,\r\n        time: number,\r\n        result: Color3\r\n    ) {\r\n        const t2 = time * time;\r\n\r\n        result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;\r\n        result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;\r\n        result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;\r\n    }\r\n\r\n    /**\r\n     * Returns a Color3 value containing a red color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Red(): Color3 {\r\n        return new Color3(1, 0, 0);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a green color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Green(): Color3 {\r\n        return new Color3(0, 1, 0);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a blue color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Blue(): Color3 {\r\n        return new Color3(0, 0, 1);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a black color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Black(): Color3 {\r\n        return new Color3(0, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Gets a Color3 value containing a black color that must not be updated\r\n     */\r\n    public static get BlackReadOnly(): DeepImmutable<Color3> {\r\n        return Color3._BlackReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Returns a Color3 value containing a white color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static White(): Color3 {\r\n        return new Color3(1, 1, 1);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a purple color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Purple(): Color3 {\r\n        return new Color3(0.5, 0, 0.5);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a magenta color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Magenta(): Color3 {\r\n        return new Color3(1, 0, 1);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a yellow color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Yellow(): Color3 {\r\n        return new Color3(1, 1, 0);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a gray color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Gray(): Color3 {\r\n        return new Color3(0.5, 0.5, 0.5);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a teal color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Teal(): Color3 {\r\n        return new Color3(0, 1.0, 1.0);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a random color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Random(): Color3 {\r\n        return new Color3(Math.random(), Math.random(), Math.random());\r\n    }\r\n}\r\n\r\n/**\r\n * Class used to hold a RBGA color\r\n */\r\nexport class Color4 {\r\n    /**\r\n     * Creates a new Color4 object from red, green, blue values, all between 0 and 1\r\n     * @param r defines the red component (between 0 and 1, default is 0)\r\n     * @param g defines the green component (between 0 and 1, default is 0)\r\n     * @param b defines the blue component (between 0 and 1, default is 0)\r\n     * @param a defines the alpha component (between 0 and 1, default is 1)\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the red component (between 0 and 1, default is 0)\r\n         */\r\n        public r: number = 0,\r\n        /**\r\n         * Defines the green component (between 0 and 1, default is 0)\r\n         */\r\n        public g: number = 0,\r\n        /**\r\n         * Defines the blue component (between 0 and 1, default is 0)\r\n         */\r\n        public b: number = 0,\r\n        /**\r\n         * Defines the alpha component (between 0 and 1, default is 1)\r\n         */\r\n        public a: number = 1\r\n    ) {}\r\n\r\n    // Operators\r\n\r\n    /**\r\n     * Adds in place the given Color4 values to the current Color4 object\r\n     * @param right defines the second operand\r\n     * @returns the current updated Color4 object\r\n     */\r\n    public addInPlace(right: DeepImmutable<Color4>): Color4 {\r\n        this.r += right.r;\r\n        this.g += right.g;\r\n        this.b += right.b;\r\n        this.a += right.a;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new array populated with 4 numeric elements : red, green, blue, alpha values\r\n     * @returns the new array\r\n     */\r\n    public asArray(): number[] {\r\n        return [this.r, this.g, this.b, this.a];\r\n    }\r\n\r\n    /**\r\n     * Stores from the starting index in the given array the Color4 successive values\r\n     * @param array defines the array where to store the r,g,b components\r\n     * @param index defines an optional index in the target array to define where to start storing values\r\n     * @returns the current Color4 object\r\n     */\r\n    public toArray(array: FloatArray, index: number = 0): Color4 {\r\n        array[index] = this.r;\r\n        array[index + 1] = this.g;\r\n        array[index + 2] = this.b;\r\n        array[index + 3] = this.a;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Update the current color with values stored in an array from the starting index of the given array\r\n     * @param array defines the source array\r\n     * @param offset defines an offset in the source array\r\n     * @returns the current Color4 object\r\n     */\r\n    public fromArray(array: DeepImmutable<ArrayLike<number>>, offset: number = 0): Color4 {\r\n        Color4.FromArrayToRef(array, offset, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Determines equality between Color4 objects\r\n     * @param otherColor defines the second operand\r\n     * @returns true if the rgba values are equal to the given ones\r\n     */\r\n    public equals(otherColor: DeepImmutable<Color4>): boolean {\r\n        return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b && this.a === otherColor.a;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color4 set with the added values of the current Color4 and of the given one\r\n     * @param right defines the second operand\r\n     * @returns a new Color4 object\r\n     */\r\n    public add(right: DeepImmutable<Color4>): Color4 {\r\n        return new Color4(this.r + right.r, this.g + right.g, this.b + right.b, this.a + right.a);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color4 set with the subtracted values of the given one from the current Color4\r\n     * @param right defines the second operand\r\n     * @returns a new Color4 object\r\n     */\r\n    public subtract(right: DeepImmutable<Color4>): Color4 {\r\n        return new Color4(this.r - right.r, this.g - right.g, this.b - right.b, this.a - right.a);\r\n    }\r\n\r\n    /**\r\n     * Subtracts the given ones from the current Color4 values and stores the results in \"result\"\r\n     * @param right defines the second operand\r\n     * @param result defines the Color4 object where to store the result\r\n     * @returns the current Color4 object\r\n     */\r\n    public subtractToRef(right: DeepImmutable<Color4>, result: Color4): Color4 {\r\n        result.r = this.r - right.r;\r\n        result.g = this.g - right.g;\r\n        result.b = this.b - right.b;\r\n        result.a = this.a - right.a;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color4 with the current Color4 values multiplied by scale\r\n     * @param scale defines the scaling factor to apply\r\n     * @returns a new Color4 object\r\n     */\r\n    public scale(scale: number): Color4 {\r\n        return new Color4(this.r * scale, this.g * scale, this.b * scale, this.a * scale);\r\n    }\r\n\r\n    /**\r\n     * Multiplies the Color4 values by the float \"scale\"\r\n     * @param scale defines the scaling factor to apply\r\n     * @returns the current updated Color4\r\n     */\r\n    public scaleInPlace(scale: number): Color4 {\r\n        this.r *= scale;\r\n        this.g *= scale;\r\n        this.b *= scale;\r\n        this.a *= scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Multiplies the current Color4 values by scale and stores the result in \"result\"\r\n     * @param scale defines the scaling factor to apply\r\n     * @param result defines the Color4 object where to store the result\r\n     * @returns the current unmodified Color4\r\n     */\r\n    public scaleToRef(scale: number, result: Color4): Color4 {\r\n        result.r = this.r * scale;\r\n        result.g = this.g * scale;\r\n        result.b = this.b * scale;\r\n        result.a = this.a * scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Scale the current Color4 values by a factor and add the result to a given Color4\r\n     * @param scale defines the scale factor\r\n     * @param result defines the Color4 object where to store the result\r\n     * @returns the unmodified current Color4\r\n     */\r\n    public scaleAndAddToRef(scale: number, result: Color4): Color4 {\r\n        result.r += this.r * scale;\r\n        result.g += this.g * scale;\r\n        result.b += this.b * scale;\r\n        result.a += this.a * scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clamps the rgb values by the min and max values and stores the result into \"result\"\r\n     * @param min defines minimum clamping value (default is 0)\r\n     * @param max defines maximum clamping value (default is 1)\r\n     * @param result defines color to store the result into.\r\n     * @returns the current Color4\r\n     */\r\n    public clampToRef(min: number = 0, max: number = 1, result: Color4): Color4 {\r\n        result.r = Scalar.Clamp(this.r, min, max);\r\n        result.g = Scalar.Clamp(this.g, min, max);\r\n        result.b = Scalar.Clamp(this.b, min, max);\r\n        result.a = Scalar.Clamp(this.a, min, max);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Multiply an Color4 value by another and return a new Color4 object\r\n     * @param color defines the Color4 value to multiply by\r\n     * @returns a new Color4 object\r\n     */\r\n    public multiply(color: Color4): Color4 {\r\n        return new Color4(this.r * color.r, this.g * color.g, this.b * color.b, this.a * color.a);\r\n    }\r\n\r\n    /**\r\n     * Multiply a Color4 value by another and push the result in a reference value\r\n     * @param color defines the Color4 value to multiply by\r\n     * @param result defines the Color4 to fill the result in\r\n     * @returns the result Color4\r\n     */\r\n    public multiplyToRef(color: Color4, result: Color4): Color4 {\r\n        result.r = this.r * color.r;\r\n        result.g = this.g * color.g;\r\n        result.b = this.b * color.b;\r\n        result.a = this.a * color.a;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a string with the Color4 current values\r\n     * @returns the string representation of the Color4 object\r\n     */\r\n    public toString(): string {\r\n        return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \" A:\" + this.a + \"}\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"Color4\"\r\n     * @returns \"Color4\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"Color4\";\r\n    }\r\n\r\n    /**\r\n     * Compute the Color4 hash code\r\n     * @returns an unique number that can be used to hash Color4 objects\r\n     */\r\n    public getHashCode(): number {\r\n        let hash = (this.r * 255) | 0;\r\n        hash = (hash * 397) ^ ((this.g * 255) | 0);\r\n        hash = (hash * 397) ^ ((this.b * 255) | 0);\r\n        hash = (hash * 397) ^ ((this.a * 255) | 0);\r\n        return hash;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color4 copied from the current one\r\n     * @returns a new Color4 object\r\n     */\r\n    public clone(): Color4 {\r\n        return new Color4(this.r, this.g, this.b, this.a);\r\n    }\r\n\r\n    /**\r\n     * Copies the given Color4 values into the current one\r\n     * @param source defines the source Color4 object\r\n     * @returns the current updated Color4 object\r\n     */\r\n    public copyFrom(source: Color4): Color4 {\r\n        this.r = source.r;\r\n        this.g = source.g;\r\n        this.b = source.b;\r\n        this.a = source.a;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copies the given float values into the current one\r\n     * @param r defines the red component to read from\r\n     * @param g defines the green component to read from\r\n     * @param b defines the blue component to read from\r\n     * @param a defines the alpha component to read from\r\n     * @returns the current updated Color4 object\r\n     */\r\n    public copyFromFloats(r: number, g: number, b: number, a: number): Color4 {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n        this.a = a;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copies the given float values into the current one\r\n     * @param r defines the red component to read from\r\n     * @param g defines the green component to read from\r\n     * @param b defines the blue component to read from\r\n     * @param a defines the alpha component to read from\r\n     * @returns the current updated Color4 object\r\n     */\r\n    public set(r: number, g: number, b: number, a: number): Color4 {\r\n        return this.copyFromFloats(r, g, b, a);\r\n    }\r\n\r\n    /**\r\n     * Compute the Color4 hexadecimal code as a string\r\n     * @param returnAsColor3 defines if the string should only contains RGB values (off by default)\r\n     * @returns a string containing the hexadecimal representation of the Color4 object\r\n     */\r\n    public toHexString(returnAsColor3 = false): string {\r\n        const intR = Math.round(this.r * 255);\r\n        const intG = Math.round(this.g * 255);\r\n        const intB = Math.round(this.b * 255);\r\n\r\n        if (returnAsColor3) {\r\n            return \"#\" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);\r\n        }\r\n\r\n        const intA = Math.round(this.a * 255);\r\n        return \"#\" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB) + Scalar.ToHex(intA);\r\n    }\r\n\r\n    /**\r\n     * Computes a new Color4 converted from the current one to linear space\r\n     * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\r\n     * @returns a new Color4 object\r\n     */\r\n    public toLinearSpace(exact = false): Color4 {\r\n        const convertedColor = new Color4();\r\n        this.toLinearSpaceToRef(convertedColor, exact);\r\n        return convertedColor;\r\n    }\r\n\r\n    /**\r\n     * Converts the Color4 values to linear space and stores the result in \"convertedColor\"\r\n     * @param convertedColor defines the Color4 object where to store the linear space version\r\n     * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\r\n     * @returns the unmodified Color4\r\n     */\r\n    public toLinearSpaceToRef(convertedColor: Color4, exact = false): Color4 {\r\n        if (exact) {\r\n            convertedColor.r = colorChannelToLinearSpaceExact(this.r);\r\n            convertedColor.g = colorChannelToLinearSpaceExact(this.g);\r\n            convertedColor.b = colorChannelToLinearSpaceExact(this.b);\r\n        } else {\r\n            convertedColor.r = colorChannelToLinearSpace(this.r);\r\n            convertedColor.g = colorChannelToLinearSpace(this.g);\r\n            convertedColor.b = colorChannelToLinearSpace(this.b);\r\n        }\r\n        convertedColor.a = this.a;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Computes a new Color4 converted from the current one to gamma space\r\n     * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\r\n     * @returns a new Color4 object\r\n     */\r\n    public toGammaSpace(exact = false): Color4 {\r\n        const convertedColor = new Color4();\r\n        this.toGammaSpaceToRef(convertedColor, exact);\r\n        return convertedColor;\r\n    }\r\n\r\n    /**\r\n     * Converts the Color4 values to gamma space and stores the result in \"convertedColor\"\r\n     * @param convertedColor defines the Color4 object where to store the gamma space version\r\n     * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\r\n     * @returns the unmodified Color4\r\n     */\r\n    public toGammaSpaceToRef(convertedColor: Color4, exact = false): Color4 {\r\n        if (exact) {\r\n            convertedColor.r = colorChannelToGammaSpaceExact(this.r);\r\n            convertedColor.g = colorChannelToGammaSpaceExact(this.g);\r\n            convertedColor.b = colorChannelToGammaSpaceExact(this.b);\r\n        } else {\r\n            convertedColor.r = colorChannelToGammaSpace(this.r);\r\n            convertedColor.g = colorChannelToGammaSpace(this.g);\r\n            convertedColor.b = colorChannelToGammaSpace(this.b);\r\n        }\r\n        convertedColor.a = this.a;\r\n        return this;\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Creates a new Color4 from the string containing valid hexadecimal values.\r\n     *\r\n     * A valid hex string is either in the format #RRGGBB or #RRGGBBAA.\r\n     *\r\n     * When a hex string without alpha is passed, the resulting Color4 has\r\n     * its alpha value set to 1.0.\r\n     *\r\n     * An invalid string results in a Color with all its channels set to 0.0,\r\n     * i.e. \"transparent black\".\r\n     *\r\n     * @param hex defines a string containing valid hexadecimal values\r\n     * @returns a new Color4 object\r\n     */\r\n    public static FromHexString(hex: string): Color4 {\r\n        if (hex.substring(0, 1) !== \"#\" || (hex.length !== 9 && hex.length !== 7)) {\r\n            return new Color4(0.0, 0.0, 0.0, 0.0);\r\n        }\r\n\r\n        const r = parseInt(hex.substring(1, 3), 16);\r\n        const g = parseInt(hex.substring(3, 5), 16);\r\n        const b = parseInt(hex.substring(5, 7), 16);\r\n        const a = hex.length === 9 ? parseInt(hex.substring(7, 9), 16) : 255;\r\n\r\n        return Color4.FromInts(r, g, b, a);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color4 object set with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\r\n     * @param left defines the start value\r\n     * @param right defines the end value\r\n     * @param amount defines the gradient factor\r\n     * @returns a new Color4 object\r\n     */\r\n    public static Lerp(left: DeepImmutable<Color4>, right: DeepImmutable<Color4>, amount: number): Color4 {\r\n        const result = new Color4(0.0, 0.0, 0.0, 0.0);\r\n        Color4.LerpToRef(left, right, amount, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Set the given \"result\" with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\r\n     * @param left defines the start value\r\n     * @param right defines the end value\r\n     * @param amount defines the gradient factor\r\n     * @param result defines the Color4 object where to store data\r\n     */\r\n    public static LerpToRef(left: DeepImmutable<Color4>, right: DeepImmutable<Color4>, amount: number, result: Color4): void {\r\n        result.r = left.r + (right.r - left.r) * amount;\r\n        result.g = left.g + (right.g - left.g) * amount;\r\n        result.b = left.b + (right.b - left.b) * amount;\r\n        result.a = left.a + (right.a - left.a) * amount;\r\n    }\r\n\r\n    /**\r\n     * Interpolate between two Color4 using Hermite interpolation\r\n     * @param value1 defines first Color4\r\n     * @param tangent1 defines the incoming tangent\r\n     * @param value2 defines second Color4\r\n     * @param tangent2 defines the outgoing tangent\r\n     * @param amount defines the target Color4\r\n     * @returns the new interpolated Color4\r\n     */\r\n    public static Hermite(value1: DeepImmutable<Color4>, tangent1: DeepImmutable<Color4>, value2: DeepImmutable<Color4>, tangent2: DeepImmutable<Color4>, amount: number): Color4 {\r\n        const squared = amount * amount;\r\n        const cubed = amount * squared;\r\n        const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\r\n        const part2 = -2.0 * cubed + 3.0 * squared;\r\n        const part3 = cubed - 2.0 * squared + amount;\r\n        const part4 = cubed - squared;\r\n\r\n        const r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;\r\n        const g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;\r\n        const b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;\r\n        const a = value1.a * part1 + value2.a * part2 + tangent1.a * part3 + tangent2.a * part4;\r\n        return new Color4(r, g, b, a);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Color4 which is the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent\r\n     * @param time define where the derivative must be done\r\n     * @returns 1st derivative\r\n     */\r\n    public static Hermite1stDerivative(\r\n        value1: DeepImmutable<Color4>,\r\n        tangent1: DeepImmutable<Color4>,\r\n        value2: DeepImmutable<Color4>,\r\n        tangent2: DeepImmutable<Color4>,\r\n        time: number\r\n    ): Color4 {\r\n        const result = new Color4();\r\n\r\n        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Update a Color4 with the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent\r\n     * @param time define where the derivative must be done\r\n     * @param result define where to store the derivative\r\n     */\r\n    public static Hermite1stDerivativeToRef(\r\n        value1: DeepImmutable<Color4>,\r\n        tangent1: DeepImmutable<Color4>,\r\n        value2: DeepImmutable<Color4>,\r\n        tangent2: DeepImmutable<Color4>,\r\n        time: number,\r\n        result: Color4\r\n    ) {\r\n        const t2 = time * time;\r\n\r\n        result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;\r\n        result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;\r\n        result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;\r\n        result.a = (t2 - time) * 6 * value1.a + (3 * t2 - 4 * time + 1) * tangent1.a + (-t2 + time) * 6 * value2.a + (3 * t2 - 2 * time) * tangent2.a;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color4 from a Color3 and an alpha value\r\n     * @param color3 defines the source Color3 to read from\r\n     * @param alpha defines the alpha component (1.0 by default)\r\n     * @returns a new Color4 object\r\n     */\r\n    public static FromColor3(color3: DeepImmutable<Color3>, alpha: number = 1.0): Color4 {\r\n        return new Color4(color3.r, color3.g, color3.b, alpha);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color4 from the starting index element of the given array\r\n     * @param array defines the source array to read from\r\n     * @param offset defines the offset in the source array\r\n     * @returns a new Color4 object\r\n     */\r\n    public static FromArray(array: DeepImmutable<ArrayLike<number>>, offset: number = 0): Color4 {\r\n        return new Color4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color4 from the starting index element of the given array\r\n     * @param array defines the source array to read from\r\n     * @param offset defines the offset in the source array\r\n     * @param result defines the target Color4 object\r\n     */\r\n    public static FromArrayToRef(array: DeepImmutable<ArrayLike<number>>, offset: number = 0, result: Color4) {\r\n        result.r = array[offset];\r\n        result.g = array[offset + 1];\r\n        result.b = array[offset + 2];\r\n        result.a = array[offset + 3];\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 from integer values (< 256)\r\n     * @param r defines the red component to read from (value between 0 and 255)\r\n     * @param g defines the green component to read from (value between 0 and 255)\r\n     * @param b defines the blue component to read from (value between 0 and 255)\r\n     * @param a defines the alpha component to read from (value between 0 and 255)\r\n     * @returns a new Color3 object\r\n     */\r\n    public static FromInts(r: number, g: number, b: number, a: number): Color4 {\r\n        return new Color4(r / 255.0, g / 255.0, b / 255.0, a / 255.0);\r\n    }\r\n\r\n    /**\r\n     * Check the content of a given array and convert it to an array containing RGBA data\r\n     * If the original array was already containing count * 4 values then it is returned directly\r\n     * @param colors defines the array to check\r\n     * @param count defines the number of RGBA data to expect\r\n     * @returns an array containing count * 4 values (RGBA)\r\n     */\r\n    public static CheckColors4(colors: number[], count: number): number[] {\r\n        // Check if color3 was used\r\n        if (colors.length === count * 3) {\r\n            const colors4 = [];\r\n            for (let index = 0; index < colors.length; index += 3) {\r\n                const newIndex = (index / 3) * 4;\r\n                colors4[newIndex] = colors[index];\r\n                colors4[newIndex + 1] = colors[index + 1];\r\n                colors4[newIndex + 2] = colors[index + 2];\r\n                colors4[newIndex + 3] = 1.0;\r\n            }\r\n\r\n            return colors4;\r\n        }\r\n\r\n        return colors;\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class TmpColors {\r\n    public static Color3: Color3[] = ArrayTools.BuildArray(3, Color3.Black);\r\n    public static Color4: Color4[] = ArrayTools.BuildArray(3, () => new Color4(0, 0, 0, 0));\r\n}\r\n\r\nRegisterClass(\"BABYLON.Color3\", Color3);\r\nRegisterClass(\"BABYLON.Color4\", Color4);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}