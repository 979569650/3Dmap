{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { NodeGeometryContextualSources } from \"./Enums/nodeGeometryContextualSources.js\";\nimport { Matrix, Vector2, Vector3, Vector4 } from \"../../Maths/math.vector.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"./Enums/nodeGeometryConnectionPointTypes.js\";\n/**\n * Class used to store node based geometry build state\n */\nexport class NodeGeometryBuildState {\n  constructor() {\n    this._rotationMatrix = new Matrix();\n    this._scalingMatrix = new Matrix();\n    this._positionMatrix = new Matrix();\n    this._scalingRotationMatrix = new Matrix();\n    this._transformMatrix = new Matrix();\n    this._tempVector3 = new Vector3();\n    /** Gets or sets the list of non connected mandatory inputs */\n    this.notConnectedNonOptionalInputs = [];\n    /** Gets or sets the list of non contextual inputs having no contextudal data */\n    this.noContextualData = [];\n    /** Gets or sets the vertex data */\n    this.vertexData = null;\n    this._geometryContext = null;\n    this._executionContext = null;\n    this._instancingContext = null;\n    this._geometryContextStack = [];\n    this._executionContextStack = [];\n    this._instancingContextStack = [];\n  }\n  /** Gets or sets the geometry context */\n  get geometryContext() {\n    return this._geometryContext;\n  }\n  /** Gets or sets the execution context */\n  get executionContext() {\n    return this._executionContext;\n  }\n  /** Gets or sets the instancing context */\n  get instancingContext() {\n    return this._instancingContext;\n  }\n  /**\n   * Push the new active geometry context\n   * @param geometryContext defines the geometry context\n   */\n  pushGeometryContext(geometryContext) {\n    this._geometryContext = geometryContext;\n    this._geometryContextStack.push(this._geometryContext);\n  }\n  /**\n   * Push the new active execution context\n   * @param executionContext defines the execution context\n   */\n  pushExecutionContext(executionContext) {\n    this._executionContext = executionContext;\n    this._executionContextStack.push(this._executionContext);\n  }\n  /**\n   * Push the new active instancing context\n   * @param instancingContext defines the instancing context\n   */\n  pushInstancingContext(instancingContext) {\n    this._instancingContext = instancingContext;\n    this._instancingContextStack.push(this._instancingContext);\n  }\n  /**\n   * Remove current geometry context and restore the previous one\n   */\n  restoreGeometryContext() {\n    this._geometryContextStack.pop();\n    this._geometryContext = this._geometryContextStack.length > 0 ? this._geometryContextStack[this._geometryContextStack.length - 1] : null;\n  }\n  /**\n   * Remove current execution context and restore the previous one\n   */\n  restoreExecutionContext() {\n    this._executionContextStack.pop();\n    this._executionContext = this._executionContextStack.length > 0 ? this._executionContextStack[this._executionContextStack.length - 1] : null;\n  }\n  /**\n   * Remove current isntancing context and restore the previous one\n   */\n  restoreInstancingContext() {\n    this._instancingContextStack.pop();\n    this._instancingContext = this._instancingContextStack.length > 0 ? this._instancingContextStack[this._instancingContextStack.length - 1] : null;\n  }\n  /**\n   * Gets the value associated with a contextual source\n   * @param source Source of the contextual value\n   * @param skipWarning Do not store the warning for reporting if true\n   * @returns the value associated with the source\n   */\n  getContextualValue(source, skipWarning = false) {\n    if (!this.executionContext) {\n      if (!skipWarning) {\n        this.noContextualData.push(source);\n      }\n      return null;\n    }\n    const index = this.executionContext.getExecutionIndex();\n    switch (source) {\n      case NodeGeometryContextualSources.Positions:\n        if (this.executionContext.getOverridePositionsContextualValue) {\n          return this.executionContext.getOverridePositionsContextualValue();\n        }\n        if (!this.geometryContext || !this.geometryContext.positions) {\n          return Vector3.Zero();\n        }\n        return Vector3.FromArray(this.geometryContext.positions, index * 3);\n      case NodeGeometryContextualSources.Normals:\n        if (this.executionContext.getOverrideNormalsContextualValue) {\n          return this.executionContext.getOverrideNormalsContextualValue();\n        }\n        if (!this.geometryContext || !this.geometryContext.normals) {\n          return Vector3.Zero();\n        }\n        return Vector3.FromArray(this.geometryContext.normals, index * 3);\n      case NodeGeometryContextualSources.Colors:\n        if (!this.geometryContext || !this.geometryContext.colors) {\n          return Vector4.Zero();\n        }\n        return Vector4.FromArray(this.geometryContext.colors, index * 4);\n      case NodeGeometryContextualSources.Tangents:\n        if (!this.geometryContext || !this.geometryContext.tangents) {\n          return Vector4.Zero();\n        }\n        return Vector4.FromArray(this.geometryContext.tangents, index * 4);\n      case NodeGeometryContextualSources.UV:\n        if (!this.geometryContext || !this.geometryContext.uvs) {\n          return Vector2.Zero();\n        }\n        return Vector2.FromArray(this.geometryContext.uvs, index * 2);\n      case NodeGeometryContextualSources.UV2:\n        if (!this.geometryContext || !this.geometryContext.uvs2) {\n          return Vector2.Zero();\n        }\n        return Vector2.FromArray(this.geometryContext.uvs2, index * 2);\n      case NodeGeometryContextualSources.UV3:\n        if (!this.geometryContext || !this.geometryContext.uvs3) {\n          return Vector2.Zero();\n        }\n        return Vector2.FromArray(this.geometryContext.uvs3, index * 2);\n      case NodeGeometryContextualSources.UV4:\n        if (!this.geometryContext || !this.geometryContext.uvs4) {\n          return Vector2.Zero();\n        }\n        return Vector2.FromArray(this.geometryContext.uvs4, index * 2);\n      case NodeGeometryContextualSources.UV5:\n        if (!this.geometryContext || !this.geometryContext.uvs5) {\n          return Vector2.Zero();\n        }\n        return Vector2.FromArray(this.geometryContext.uvs5, index * 2);\n      case NodeGeometryContextualSources.UV6:\n        if (!this.geometryContext || !this.geometryContext.uvs6) {\n          return Vector2.Zero();\n        }\n        return Vector2.FromArray(this.geometryContext.uvs6, index * 2);\n      case NodeGeometryContextualSources.VertexID:\n        return index;\n      case NodeGeometryContextualSources.FaceID:\n        return this.executionContext.getExecutionFaceIndex();\n      case NodeGeometryContextualSources.LoopID:\n        return this.executionContext.getExecutionLoopIndex();\n      case NodeGeometryContextualSources.InstanceID:\n        return this.instancingContext ? this.instancingContext.getInstanceIndex() : 0;\n      case NodeGeometryContextualSources.GeometryID:\n        return !this.geometryContext ? 0 : this.geometryContext.uniqueId;\n      case NodeGeometryContextualSources.CollectionID:\n        {\n          if (!this.geometryContext || !this.geometryContext.metadata) {\n            return 0;\n          }\n          return this.geometryContext.metadata.collectionId || 0;\n        }\n    }\n    return null;\n  }\n  /**\n   * Adapt a value to a target type\n   * @param source defines the value to adapt\n   * @param targetType defines the target type\n   * @returns the adapted value\n   */\n  adapt(source, targetType) {\n    const value = source.getConnectedValue(this) || 0;\n    if (source.type === targetType) {\n      return value;\n    }\n    switch (targetType) {\n      case NodeGeometryBlockConnectionPointTypes.Vector2:\n        return new Vector2(value, value);\n      case NodeGeometryBlockConnectionPointTypes.Vector3:\n        return new Vector3(value, value, value);\n      case NodeGeometryBlockConnectionPointTypes.Vector4:\n        return new Vector4(value, value, value, value);\n    }\n    return null;\n  }\n  /**\n   * Adapt an input value to a target type\n   * @param source defines the value to adapt\n   * @param targetType defines the target type\n   * @param defaultValue defines the default value to use if not connected\n   * @returns the adapted value\n   */\n  adaptInput(source, targetType, defaultValue) {\n    var _a;\n    if (!source.isConnected) {\n      return source.value || defaultValue;\n    }\n    const value = source.getConnectedValue(this);\n    if (((_a = source._connectedPoint) === null || _a === void 0 ? void 0 : _a.type) === targetType) {\n      return value;\n    }\n    switch (targetType) {\n      case NodeGeometryBlockConnectionPointTypes.Vector2:\n        return new Vector2(value, value);\n      case NodeGeometryBlockConnectionPointTypes.Vector3:\n        return new Vector3(value, value, value);\n      case NodeGeometryBlockConnectionPointTypes.Vector4:\n        return new Vector4(value, value, value, value);\n    }\n    return null;\n  }\n  /**\n   * Emits console errors and exceptions if there is a failing check\n   */\n  emitErrors() {\n    let errorMessage = \"\";\n    for (const notConnectedInput of this.notConnectedNonOptionalInputs) {\n      errorMessage += `input ${notConnectedInput.name} from block ${notConnectedInput.ownerBlock.name}[${notConnectedInput.ownerBlock.getClassName()}] is not connected and is not optional.\\n`;\n    }\n    for (const source of this.noContextualData) {\n      errorMessage += `Contextual input ${NodeGeometryContextualSources[source]} has no context to pull data from (must be connected to a setXXX block or a instantiateXXX block).\\n`;\n    }\n    if (errorMessage) {\n      throw \"Build of NodeGeometry failed:\\n\" + errorMessage;\n    }\n  }\n  /** @internal  */\n  _instantiate(clone, currentPosition, rotation, scaling, additionalVertexData) {\n    // Transform\n    Matrix.ScalingToRef(scaling.x, scaling.y, scaling.z, this._scalingMatrix);\n    Matrix.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, this._rotationMatrix);\n    Matrix.TranslationToRef(currentPosition.x, currentPosition.y, currentPosition.z, this._positionMatrix);\n    this._scalingMatrix.multiplyToRef(this._rotationMatrix, this._scalingRotationMatrix);\n    this._scalingRotationMatrix.multiplyToRef(this._positionMatrix, this._transformMatrix);\n    for (let clonePositionIndex = 0; clonePositionIndex < clone.positions.length; clonePositionIndex += 3) {\n      this._tempVector3.fromArray(clone.positions, clonePositionIndex);\n      Vector3.TransformCoordinatesToRef(this._tempVector3, this._transformMatrix, this._tempVector3);\n      this._tempVector3.toArray(clone.positions, clonePositionIndex);\n      if (clone.normals) {\n        this._tempVector3.fromArray(clone.normals, clonePositionIndex);\n        Vector3.TransformNormalToRef(this._tempVector3, this._scalingRotationMatrix, this._tempVector3);\n        this._tempVector3.toArray(clone.normals, clonePositionIndex);\n      }\n    }\n    additionalVertexData.push(clone);\n  }\n  /** @internal  */\n  _instantiateWithMatrix(clone, transform, additionalVertexData) {\n    for (let clonePositionIndex = 0; clonePositionIndex < clone.positions.length; clonePositionIndex += 3) {\n      this._tempVector3.fromArray(clone.positions, clonePositionIndex);\n      Vector3.TransformCoordinatesToRef(this._tempVector3, transform, this._tempVector3);\n      this._tempVector3.toArray(clone.positions, clonePositionIndex);\n      if (clone.normals) {\n        this._tempVector3.fromArray(clone.normals, clonePositionIndex);\n        Vector3.TransformNormalToRef(this._tempVector3, transform, this._tempVector3);\n        this._tempVector3.toArray(clone.normals, clonePositionIndex);\n      }\n    }\n    additionalVertexData.push(clone);\n  }\n  /** @internal  */\n  _instantiateWithPositionAndMatrix(clone, currentPosition, transform, additionalVertexData) {\n    Matrix.TranslationToRef(currentPosition.x, currentPosition.y, currentPosition.z, this._positionMatrix);\n    transform.multiplyToRef(this._positionMatrix, this._transformMatrix);\n    for (let clonePositionIndex = 0; clonePositionIndex < clone.positions.length; clonePositionIndex += 3) {\n      this._tempVector3.fromArray(clone.positions, clonePositionIndex);\n      Vector3.TransformCoordinatesToRef(this._tempVector3, this._transformMatrix, this._tempVector3);\n      this._tempVector3.toArray(clone.positions, clonePositionIndex);\n      if (clone.normals) {\n        this._tempVector3.fromArray(clone.normals, clonePositionIndex);\n        Vector3.TransformNormalToRef(this._tempVector3, this._transformMatrix, this._tempVector3);\n        this._tempVector3.toArray(clone.normals, clonePositionIndex);\n      }\n    }\n    additionalVertexData.push(clone);\n  }\n}","map":{"version":3,"names":["NodeGeometryContextualSources","Matrix","Vector2","Vector3","Vector4","NodeGeometryBlockConnectionPointTypes","NodeGeometryBuildState","constructor","_rotationMatrix","_scalingMatrix","_positionMatrix","_scalingRotationMatrix","_transformMatrix","_tempVector3","notConnectedNonOptionalInputs","noContextualData","vertexData","_geometryContext","_executionContext","_instancingContext","_geometryContextStack","_executionContextStack","_instancingContextStack","geometryContext","executionContext","instancingContext","pushGeometryContext","push","pushExecutionContext","pushInstancingContext","restoreGeometryContext","pop","length","restoreExecutionContext","restoreInstancingContext","getContextualValue","source","skipWarning","index","getExecutionIndex","Positions","getOverridePositionsContextualValue","positions","Zero","FromArray","Normals","getOverrideNormalsContextualValue","normals","Colors","colors","Tangents","tangents","UV","uvs","UV2","uvs2","UV3","uvs3","UV4","uvs4","UV5","uvs5","UV6","uvs6","VertexID","FaceID","getExecutionFaceIndex","LoopID","getExecutionLoopIndex","InstanceID","getInstanceIndex","GeometryID","uniqueId","CollectionID","metadata","collectionId","adapt","targetType","value","getConnectedValue","type","adaptInput","defaultValue","isConnected","_a","_connectedPoint","emitErrors","errorMessage","notConnectedInput","name","ownerBlock","getClassName","_instantiate","clone","currentPosition","rotation","scaling","additionalVertexData","ScalingToRef","x","y","z","RotationYawPitchRollToRef","TranslationToRef","multiplyToRef","clonePositionIndex","fromArray","TransformCoordinatesToRef","toArray","TransformNormalToRef","_instantiateWithMatrix","transform","_instantiateWithPositionAndMatrix"],"sources":["../../../../../dev/core/src/Meshes/Node/nodeGeometryBuildState.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { VertexData } from \"../mesh.vertexData\";\r\nimport type { NodeGeometryConnectionPoint } from \"./nodeGeometryBlockConnectionPoint\";\r\nimport { NodeGeometryContextualSources } from \"./Enums/nodeGeometryContextualSources\";\r\nimport { Matrix, Vector2, Vector3, Vector4 } from \"../../Maths/math.vector\";\r\nimport type { INodeGeometryExecutionContext } from \"./Interfaces/nodeGeometryExecutionContext\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"./Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { INodeGeometryInstancingContext } from \"./Interfaces/nodeGeometryInstancingContext\";\r\n\r\n/**\r\n * Class used to store node based geometry build state\r\n */\r\nexport class NodeGeometryBuildState {\r\n    private _rotationMatrix = new Matrix();\r\n    private _scalingMatrix = new Matrix();\r\n    private _positionMatrix = new Matrix();\r\n    private _scalingRotationMatrix = new Matrix();\r\n    private _transformMatrix = new Matrix();\r\n    private _tempVector3 = new Vector3();\r\n\r\n    /** Gets or sets the list of non connected mandatory inputs */\r\n    public notConnectedNonOptionalInputs: NodeGeometryConnectionPoint[] = [];\r\n    /** Gets or sets the list of non contextual inputs having no contextudal data */\r\n    public noContextualData: NodeGeometryContextualSources[] = [];\r\n    /** Gets or sets the build identifier */\r\n    public buildId: number;\r\n    /** Gets or sets a boolean indicating that verbose mode is on */\r\n    public verbose: boolean;\r\n    /** Gets or sets the vertex data */\r\n    public vertexData: Nullable<VertexData> = null;\r\n\r\n    private _geometryContext: Nullable<VertexData> = null;\r\n    private _executionContext: Nullable<INodeGeometryExecutionContext> = null;\r\n    private _instancingContext: Nullable<INodeGeometryInstancingContext> = null;\r\n\r\n    private _geometryContextStack: Array<Nullable<VertexData>> = [];\r\n    private _executionContextStack: Array<Nullable<INodeGeometryExecutionContext>> = [];\r\n    private _instancingContextStack: Array<Nullable<INodeGeometryInstancingContext>> = [];\r\n\r\n    /** Gets or sets the geometry context */\r\n    public get geometryContext() {\r\n        return this._geometryContext;\r\n    }\r\n\r\n    /** Gets or sets the execution context */\r\n    public get executionContext() {\r\n        return this._executionContext;\r\n    }\r\n\r\n    /** Gets or sets the instancing context */\r\n    public get instancingContext() {\r\n        return this._instancingContext;\r\n    }\r\n\r\n    /**\r\n     * Push the new active geometry context\r\n     * @param geometryContext defines the geometry context\r\n     */\r\n    public pushGeometryContext(geometryContext: VertexData) {\r\n        this._geometryContext = geometryContext;\r\n        this._geometryContextStack.push(this._geometryContext);\r\n    }\r\n\r\n    /**\r\n     * Push the new active execution context\r\n     * @param executionContext defines the execution context\r\n     */\r\n    public pushExecutionContext(executionContext: INodeGeometryExecutionContext) {\r\n        this._executionContext = executionContext;\r\n        this._executionContextStack.push(this._executionContext);\r\n    }\r\n\r\n    /**\r\n     * Push the new active instancing context\r\n     * @param instancingContext defines the instancing context\r\n     */\r\n    public pushInstancingContext(instancingContext: INodeGeometryInstancingContext) {\r\n        this._instancingContext = instancingContext;\r\n        this._instancingContextStack.push(this._instancingContext);\r\n    }\r\n\r\n    /**\r\n     * Remove current geometry context and restore the previous one\r\n     */\r\n    public restoreGeometryContext() {\r\n        this._geometryContextStack.pop();\r\n        this._geometryContext = this._geometryContextStack.length > 0 ? this._geometryContextStack[this._geometryContextStack.length - 1] : null;\r\n    }\r\n\r\n    /**\r\n     * Remove current execution context and restore the previous one\r\n     */\r\n    public restoreExecutionContext() {\r\n        this._executionContextStack.pop();\r\n        this._executionContext = this._executionContextStack.length > 0 ? this._executionContextStack[this._executionContextStack.length - 1] : null;\r\n    }\r\n\r\n    /**\r\n     * Remove current isntancing context and restore the previous one\r\n     */\r\n    public restoreInstancingContext() {\r\n        this._instancingContextStack.pop();\r\n        this._instancingContext = this._instancingContextStack.length > 0 ? this._instancingContextStack[this._instancingContextStack.length - 1] : null;\r\n    }\r\n\r\n    /**\r\n     * Gets the value associated with a contextual source\r\n     * @param source Source of the contextual value\r\n     * @param skipWarning Do not store the warning for reporting if true\r\n     * @returns the value associated with the source\r\n     */\r\n    public getContextualValue(source: NodeGeometryContextualSources, skipWarning = false) {\r\n        if (!this.executionContext) {\r\n            if (!skipWarning) {\r\n                this.noContextualData.push(source);\r\n            }\r\n            return null;\r\n        }\r\n\r\n        const index = this.executionContext.getExecutionIndex();\r\n\r\n        switch (source) {\r\n            case NodeGeometryContextualSources.Positions:\r\n                if (this.executionContext.getOverridePositionsContextualValue) {\r\n                    return this.executionContext.getOverridePositionsContextualValue();\r\n                }\r\n                if (!this.geometryContext || !this.geometryContext.positions) {\r\n                    return Vector3.Zero();\r\n                }\r\n                return Vector3.FromArray(this.geometryContext.positions as ArrayLike<number>, index * 3);\r\n            case NodeGeometryContextualSources.Normals:\r\n                if (this.executionContext.getOverrideNormalsContextualValue) {\r\n                    return this.executionContext.getOverrideNormalsContextualValue();\r\n                }\r\n                if (!this.geometryContext || !this.geometryContext.normals) {\r\n                    return Vector3.Zero();\r\n                }\r\n                return Vector3.FromArray(this.geometryContext.normals as ArrayLike<number>, index * 3);\r\n            case NodeGeometryContextualSources.Colors:\r\n                if (!this.geometryContext || !this.geometryContext.colors) {\r\n                    return Vector4.Zero();\r\n                }\r\n                return Vector4.FromArray(this.geometryContext.colors as ArrayLike<number>, index * 4);\r\n            case NodeGeometryContextualSources.Tangents:\r\n                if (!this.geometryContext || !this.geometryContext.tangents) {\r\n                    return Vector4.Zero();\r\n                }\r\n                return Vector4.FromArray(this.geometryContext.tangents as ArrayLike<number>, index * 4);\r\n            case NodeGeometryContextualSources.UV:\r\n                if (!this.geometryContext || !this.geometryContext.uvs) {\r\n                    return Vector2.Zero();\r\n                }\r\n                return Vector2.FromArray(this.geometryContext.uvs as ArrayLike<number>, index * 2);\r\n            case NodeGeometryContextualSources.UV2:\r\n                if (!this.geometryContext || !this.geometryContext.uvs2) {\r\n                    return Vector2.Zero();\r\n                }\r\n                return Vector2.FromArray(this.geometryContext.uvs2 as ArrayLike<number>, index * 2);\r\n            case NodeGeometryContextualSources.UV3:\r\n                if (!this.geometryContext || !this.geometryContext.uvs3) {\r\n                    return Vector2.Zero();\r\n                }\r\n                return Vector2.FromArray(this.geometryContext.uvs3 as ArrayLike<number>, index * 2);\r\n            case NodeGeometryContextualSources.UV4:\r\n                if (!this.geometryContext || !this.geometryContext.uvs4) {\r\n                    return Vector2.Zero();\r\n                }\r\n                return Vector2.FromArray(this.geometryContext.uvs4 as ArrayLike<number>, index * 2);\r\n            case NodeGeometryContextualSources.UV5:\r\n                if (!this.geometryContext || !this.geometryContext.uvs5) {\r\n                    return Vector2.Zero();\r\n                }\r\n                return Vector2.FromArray(this.geometryContext.uvs5 as ArrayLike<number>, index * 2);\r\n            case NodeGeometryContextualSources.UV6:\r\n                if (!this.geometryContext || !this.geometryContext.uvs6) {\r\n                    return Vector2.Zero();\r\n                }\r\n                return Vector2.FromArray(this.geometryContext.uvs6 as ArrayLike<number>, index * 2);\r\n            case NodeGeometryContextualSources.VertexID:\r\n                return index;\r\n            case NodeGeometryContextualSources.FaceID:\r\n                return this.executionContext.getExecutionFaceIndex();\r\n            case NodeGeometryContextualSources.LoopID:\r\n                return this.executionContext.getExecutionLoopIndex();\r\n            case NodeGeometryContextualSources.InstanceID:\r\n                return this.instancingContext ? this.instancingContext.getInstanceIndex() : 0;\r\n            case NodeGeometryContextualSources.GeometryID:\r\n                return !this.geometryContext ? 0 : this.geometryContext.uniqueId;\r\n            case NodeGeometryContextualSources.CollectionID: {\r\n                if (!this.geometryContext || !this.geometryContext.metadata) {\r\n                    return 0;\r\n                }\r\n                return this.geometryContext.metadata.collectionId || 0;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Adapt a value to a target type\r\n     * @param source defines the value to adapt\r\n     * @param targetType defines the target type\r\n     * @returns the adapted value\r\n     */\r\n    adapt(source: NodeGeometryConnectionPoint, targetType: NodeGeometryBlockConnectionPointTypes) {\r\n        const value = source.getConnectedValue(this) || 0;\r\n\r\n        if (source.type === targetType) {\r\n            return value;\r\n        }\r\n\r\n        switch (targetType) {\r\n            case NodeGeometryBlockConnectionPointTypes.Vector2:\r\n                return new Vector2(value, value);\r\n            case NodeGeometryBlockConnectionPointTypes.Vector3:\r\n                return new Vector3(value, value, value);\r\n            case NodeGeometryBlockConnectionPointTypes.Vector4:\r\n                return new Vector4(value, value, value, value);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Adapt an input value to a target type\r\n     * @param source defines the value to adapt\r\n     * @param targetType defines the target type\r\n     * @param defaultValue defines the default value to use if not connected\r\n     * @returns the adapted value\r\n     */\r\n    adaptInput(source: NodeGeometryConnectionPoint, targetType: NodeGeometryBlockConnectionPointTypes, defaultValue: any) {\r\n        if (!source.isConnected) {\r\n            return source.value || defaultValue;\r\n        }\r\n\r\n        const value = source.getConnectedValue(this);\r\n\r\n        if (source._connectedPoint?.type === targetType) {\r\n            return value;\r\n        }\r\n\r\n        switch (targetType) {\r\n            case NodeGeometryBlockConnectionPointTypes.Vector2:\r\n                return new Vector2(value, value);\r\n            case NodeGeometryBlockConnectionPointTypes.Vector3:\r\n                return new Vector3(value, value, value);\r\n            case NodeGeometryBlockConnectionPointTypes.Vector4:\r\n                return new Vector4(value, value, value, value);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Emits console errors and exceptions if there is a failing check\r\n     */\r\n    public emitErrors() {\r\n        let errorMessage = \"\";\r\n\r\n        for (const notConnectedInput of this.notConnectedNonOptionalInputs) {\r\n            errorMessage += `input ${notConnectedInput.name} from block ${\r\n                notConnectedInput.ownerBlock.name\r\n            }[${notConnectedInput.ownerBlock.getClassName()}] is not connected and is not optional.\\n`;\r\n        }\r\n\r\n        for (const source of this.noContextualData) {\r\n            errorMessage += `Contextual input ${NodeGeometryContextualSources[source]} has no context to pull data from (must be connected to a setXXX block or a instantiateXXX block).\\n`;\r\n        }\r\n\r\n        if (errorMessage) {\r\n            throw \"Build of NodeGeometry failed:\\n\" + errorMessage;\r\n        }\r\n    }\r\n\r\n    /** @internal  */\r\n    public _instantiate(clone: VertexData, currentPosition: Vector3, rotation: Vector3, scaling: Vector3, additionalVertexData: VertexData[]) {\r\n        // Transform\r\n        Matrix.ScalingToRef(scaling.x, scaling.y, scaling.z, this._scalingMatrix);\r\n        Matrix.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, this._rotationMatrix);\r\n        Matrix.TranslationToRef(currentPosition.x, currentPosition.y, currentPosition.z, this._positionMatrix);\r\n\r\n        this._scalingMatrix.multiplyToRef(this._rotationMatrix, this._scalingRotationMatrix);\r\n        this._scalingRotationMatrix.multiplyToRef(this._positionMatrix, this._transformMatrix);\r\n        for (let clonePositionIndex = 0; clonePositionIndex < clone.positions!.length; clonePositionIndex += 3) {\r\n            this._tempVector3.fromArray(clone.positions!, clonePositionIndex);\r\n            Vector3.TransformCoordinatesToRef(this._tempVector3, this._transformMatrix, this._tempVector3);\r\n            this._tempVector3.toArray(clone.positions!, clonePositionIndex);\r\n\r\n            if (clone.normals) {\r\n                this._tempVector3.fromArray(clone.normals, clonePositionIndex);\r\n                Vector3.TransformNormalToRef(this._tempVector3, this._scalingRotationMatrix, this._tempVector3);\r\n                this._tempVector3.toArray(clone.normals, clonePositionIndex);\r\n            }\r\n        }\r\n\r\n        additionalVertexData.push(clone);\r\n    }\r\n\r\n    /** @internal  */\r\n    public _instantiateWithMatrix(clone: VertexData, transform: Matrix, additionalVertexData: VertexData[]) {\r\n        for (let clonePositionIndex = 0; clonePositionIndex < clone.positions!.length; clonePositionIndex += 3) {\r\n            this._tempVector3.fromArray(clone.positions!, clonePositionIndex);\r\n            Vector3.TransformCoordinatesToRef(this._tempVector3, transform, this._tempVector3);\r\n            this._tempVector3.toArray(clone.positions!, clonePositionIndex);\r\n\r\n            if (clone.normals) {\r\n                this._tempVector3.fromArray(clone.normals, clonePositionIndex);\r\n                Vector3.TransformNormalToRef(this._tempVector3, transform, this._tempVector3);\r\n                this._tempVector3.toArray(clone.normals, clonePositionIndex);\r\n            }\r\n        }\r\n\r\n        additionalVertexData.push(clone);\r\n    }\r\n\r\n    /** @internal  */\r\n    public _instantiateWithPositionAndMatrix(clone: VertexData, currentPosition: Vector3, transform: Matrix, additionalVertexData: VertexData[]) {\r\n        Matrix.TranslationToRef(currentPosition.x, currentPosition.y, currentPosition.z, this._positionMatrix);\r\n        transform.multiplyToRef(this._positionMatrix, this._transformMatrix);\r\n\r\n        for (let clonePositionIndex = 0; clonePositionIndex < clone.positions!.length; clonePositionIndex += 3) {\r\n            this._tempVector3.fromArray(clone.positions!, clonePositionIndex);\r\n            Vector3.TransformCoordinatesToRef(this._tempVector3, this._transformMatrix, this._tempVector3);\r\n            this._tempVector3.toArray(clone.positions!, clonePositionIndex);\r\n\r\n            if (clone.normals) {\r\n                this._tempVector3.fromArray(clone.normals, clonePositionIndex);\r\n                Vector3.TransformNormalToRef(this._tempVector3, this._transformMatrix, this._tempVector3);\r\n                this._tempVector3.toArray(clone.normals, clonePositionIndex);\r\n            }\r\n        }\r\n\r\n        additionalVertexData.push(clone);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}