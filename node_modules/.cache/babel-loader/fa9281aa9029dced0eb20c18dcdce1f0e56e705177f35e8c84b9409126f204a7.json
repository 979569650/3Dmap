{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { EventState, Observable } from \"../observable.js\";\nimport { PrecisionDate } from \"../precisionDate.js\";\nimport { Tools } from \"../tools.js\";\nimport { DynamicFloat32Array } from \"./dynamicFloat32Array.js\";\n// the initial size of our array, should be a multiple of two!\nconst InitialArraySize = 1800;\n// three octets in a hexcode. #[AA][BB][CC], i.e. 24 bits of data.\nconst NumberOfBitsInHexcode = 24;\n// Allows single numeral hex numbers to be appended by a 0.\nconst HexPadding = \"0\";\n// header for the timestamp column\nconst TimestampColHeader = \"timestamp\";\n// header for the numPoints column\nconst NumPointsColHeader = \"numPoints\";\n// regex to capture all carriage returns in the string.\nconst CarriageReturnRegex = /\\r/g;\n// string to use as separator when exporting extra information along with the dataset id\nconst ExportedDataSeparator = \"@\";\n/**\n * The collector class handles the collection and storage of data into the appropriate array.\n * The collector also handles notifying any observers of any updates.\n */\nexport class PerformanceViewerCollector {\n  /**\n   * The offset for when actual data values start appearing inside a slice.\n   */\n  static get SliceDataOffset() {\n    return 2;\n  }\n  /**\n   * The offset for the value of the number of points inside a slice.\n   */\n  static get NumberOfPointsOffset() {\n    return 1;\n  }\n  /**\n   * Handles the creation of a performance viewer collector.\n   * @param _scene the scene to collect on.\n   * @param _enabledStrategyCallbacks the list of data to collect with callbacks for initialization purposes.\n   */\n  constructor(_scene, _enabledStrategyCallbacks) {\n    this._scene = _scene;\n    /**\n     * Collects data for every dataset by using the appropriate strategy. This is called every frame.\n     * This method will then notify all observers with the latest slice.\n     */\n    this._collectDataAtFrame = () => {\n      const timestamp = PrecisionDate.Now - this._startingTimestamp;\n      const numPoints = this.datasets.ids.length;\n      // add the starting index for the slice\n      const numberOfIndices = this.datasets.startingIndices.itemLength;\n      let startingIndex = 0;\n      if (numberOfIndices > 0) {\n        const previousStartingIndex = this.datasets.startingIndices.at(numberOfIndices - 1);\n        startingIndex = previousStartingIndex + this.datasets.data.at(previousStartingIndex + PerformanceViewerCollector.NumberOfPointsOffset) + PerformanceViewerCollector.SliceDataOffset;\n      }\n      this.datasets.startingIndices.push(startingIndex);\n      // add the first 2 items in our slice.\n      this.datasets.data.push(timestamp);\n      this.datasets.data.push(numPoints);\n      // add the values inside the slice.\n      this.datasets.ids.forEach(id => {\n        const strategy = this._strategies.get(id);\n        if (!strategy) {\n          return;\n        }\n        this.datasets.data.push(strategy.getData());\n      });\n      if (this.datasetObservable.hasObservers()) {\n        const slice = [timestamp, numPoints];\n        for (let i = 0; i < numPoints; i++) {\n          slice.push(this.datasets.data.at(startingIndex + PerformanceViewerCollector.SliceDataOffset + i));\n        }\n        this.datasetObservable.notifyObservers(slice);\n      }\n    };\n    this.datasets = {\n      ids: [],\n      data: new DynamicFloat32Array(InitialArraySize),\n      startingIndices: new DynamicFloat32Array(InitialArraySize)\n    };\n    this._strategies = new Map();\n    this._datasetMeta = new Map();\n    this._eventRestoreSet = new Set();\n    this._customEventObservable = new Observable();\n    this.datasetObservable = new Observable();\n    this.metadataObservable = new Observable(observer => observer.callback(this._datasetMeta, new EventState(0)));\n    if (_enabledStrategyCallbacks) {\n      this.addCollectionStrategies(..._enabledStrategyCallbacks);\n    }\n  }\n  /**\n   * Registers a custom string event which will be callable via sendEvent. This method returns an event object which will contain the id of the event.\n   * The user can set a value optionally, which will be used in the sendEvent method. If the value is set, we will record this value at the end of each frame,\n   * if not we will increment our counter and record the value of the counter at the end of each frame. The value recorded is 0 if no sendEvent method is called, within a frame.\n   * @param name The name of the event to register\n   * @param forceUpdate if the code should force add an event, and replace the last one.\n   * @param category the category for that event\n   * @returns The event registered, used in sendEvent\n   */\n  registerEvent(name, forceUpdate, category) {\n    var _a;\n    if (this._strategies.has(name) && !forceUpdate) {\n      return;\n    }\n    if (this._strategies.has(name) && forceUpdate) {\n      (_a = this._strategies.get(name)) === null || _a === void 0 ? void 0 : _a.dispose();\n      this._strategies.delete(name);\n    }\n    const strategy = scene => {\n      let counter = 0;\n      let value = 0;\n      const afterRenderObserver = scene.onAfterRenderObservable.add(() => {\n        value = counter;\n        counter = 0;\n      });\n      const stringObserver = this._customEventObservable.add(eventVal => {\n        if (name !== eventVal.name) {\n          return;\n        }\n        if (eventVal.value !== undefined) {\n          counter = eventVal.value;\n        } else {\n          counter++;\n        }\n      });\n      return {\n        id: name,\n        getData: () => value,\n        dispose: () => {\n          scene.onAfterRenderObservable.remove(afterRenderObserver);\n          this._customEventObservable.remove(stringObserver);\n        }\n      };\n    };\n    const event = {\n      name\n    };\n    this._eventRestoreSet.add(name);\n    this.addCollectionStrategies({\n      strategyCallback: strategy,\n      category\n    });\n    return event;\n  }\n  /**\n   * Lets the perf collector handle an event, occurences or event value depending on if the event.value params is set.\n   * @param event the event to handle an occurence for\n   */\n  sendEvent(event) {\n    this._customEventObservable.notifyObservers(event);\n  }\n  /**\n   * This event restores all custom string events if necessary.\n   */\n  _restoreStringEvents() {\n    if (this._eventRestoreSet.size !== this._customEventObservable.observers.length) {\n      this._eventRestoreSet.forEach(event => {\n        this.registerEvent(event, true);\n      });\n    }\n  }\n  /**\n   * This method adds additional collection strategies for data collection purposes.\n   * @param strategyCallbacks the list of data to collect with callbacks.\n   */\n  addCollectionStrategies(...strategyCallbacks) {\n    // eslint-disable-next-line prefer-const\n    for (let {\n      strategyCallback,\n      category,\n      hidden\n    } of strategyCallbacks) {\n      const strategy = strategyCallback(this._scene);\n      if (this._strategies.has(strategy.id)) {\n        strategy.dispose();\n        continue;\n      }\n      this.datasets.ids.push(strategy.id);\n      if (category) {\n        category = category.replace(new RegExp(ExportedDataSeparator, \"g\"), \"\");\n      }\n      this._datasetMeta.set(strategy.id, {\n        color: this._getHexColorFromId(strategy.id),\n        category,\n        hidden\n      });\n      this._strategies.set(strategy.id, strategy);\n    }\n    this.metadataObservable.notifyObservers(this._datasetMeta);\n  }\n  /**\n   * Gets a 6 character hexcode representing the colour from a passed in string.\n   * @param id the string to get a hex code for.\n   * @returns a hexcode hashed from the id.\n   */\n  _getHexColorFromId(id) {\n    // this first bit is just a known way of hashing a string.\n    let hash = 0;\n    for (let i = 0; i < id.length; i++) {\n      // (hash << 5) - hash is the same as hash * 31\n      hash = id.charCodeAt(i) + ((hash << 5) - hash);\n    }\n    // then we build the string octet by octet.\n    let hex = \"#\";\n    for (let i = 0; i < NumberOfBitsInHexcode; i += 8) {\n      const octet = hash >> i & 0xff;\n      hex += (HexPadding + octet.toString(16)).substr(-2);\n    }\n    return hex;\n  }\n  /**\n   * Collects and then sends the latest slice to any observers by using the appropriate strategy when the user wants.\n   * The slice will be of the form [timestamp, numberOfPoints, value1, value2...]\n   * This method does not add onto the collected data accessible via the datasets variable.\n   */\n  getCurrentSlice() {\n    const timestamp = PrecisionDate.Now - this._startingTimestamp;\n    const numPoints = this.datasets.ids.length;\n    const slice = [timestamp, numPoints];\n    // add the values inside the slice.\n    this.datasets.ids.forEach(id => {\n      const strategy = this._strategies.get(id);\n      if (!strategy) {\n        return;\n      }\n      if (this.datasetObservable.hasObservers()) {\n        slice.push(strategy.getData());\n      }\n    });\n    if (this.datasetObservable.hasObservers()) {\n      this.datasetObservable.notifyObservers(slice);\n    }\n  }\n  /**\n   * Updates a property for a dataset's metadata with the value provided.\n   * @param id the id of the dataset which needs its metadata updated.\n   * @param prop the property to update.\n   * @param value the value to update the property with.\n   */\n  updateMetadata(id, prop, value) {\n    const meta = this._datasetMeta.get(id);\n    if (!meta) {\n      return;\n    }\n    meta[prop] = value;\n    this.metadataObservable.notifyObservers(this._datasetMeta);\n  }\n  /**\n   * Completely clear, data, ids, and strategies saved to this performance collector.\n   * @param preserveStringEventsRestore if it should preserve the string events, by default will clear string events registered when called.\n   */\n  clear(preserveStringEventsRestore) {\n    this.datasets.data = new DynamicFloat32Array(InitialArraySize);\n    this.datasets.ids.length = 0;\n    this.datasets.startingIndices = new DynamicFloat32Array(InitialArraySize);\n    this._datasetMeta.clear();\n    this._strategies.forEach(strategy => strategy.dispose());\n    this._strategies.clear();\n    if (!preserveStringEventsRestore) {\n      this._eventRestoreSet.clear();\n    }\n    this._hasLoadedData = false;\n  }\n  /**\n   * Accessor which lets the caller know if the performance collector has data loaded from a file or not!\n   * Call clear() to reset this value.\n   * @returns true if the data is loaded from a file, false otherwise.\n   */\n  get hasLoadedData() {\n    return this._hasLoadedData;\n  }\n  /**\n   * Given a string containing file data, this function parses the file data into the datasets object.\n   * It returns a boolean to indicate if this object was successfully loaded with the data.\n   * @param data string content representing the file data.\n   * @param keepDatasetMeta if it should use reuse the existing dataset metadata\n   * @returns true if the data was successfully loaded, false otherwise.\n   */\n  loadFromFileData(data, keepDatasetMeta) {\n    const lines = data.replace(CarriageReturnRegex, \"\").split(\"\\n\").map(line => line.split(\",\").filter(s => s.length > 0)).filter(line => line.length > 0);\n    const timestampIndex = 0;\n    const numPointsIndex = PerformanceViewerCollector.NumberOfPointsOffset;\n    if (lines.length < 2) {\n      return false;\n    }\n    const parsedDatasets = {\n      ids: [],\n      data: new DynamicFloat32Array(InitialArraySize),\n      startingIndices: new DynamicFloat32Array(InitialArraySize)\n    };\n    // parse first line separately to populate ids!\n    const [firstLine, ...dataLines] = lines;\n    // make sure we have the correct beginning headers\n    if (firstLine.length < 2 || firstLine[timestampIndex] !== TimestampColHeader || firstLine[numPointsIndex] !== NumPointsColHeader) {\n      return false;\n    }\n    const idCategoryMap = new Map();\n    // populate the ids.\n    for (let i = PerformanceViewerCollector.SliceDataOffset; i < firstLine.length; i++) {\n      const [id, category] = firstLine[i].split(ExportedDataSeparator);\n      parsedDatasets.ids.push(id);\n      idCategoryMap.set(id, category);\n    }\n    let startingIndex = 0;\n    for (const line of dataLines) {\n      if (line.length < 2) {\n        return false;\n      }\n      const timestamp = parseFloat(line[timestampIndex]);\n      const numPoints = parseInt(line[numPointsIndex]);\n      if (isNaN(numPoints) || isNaN(timestamp)) {\n        return false;\n      }\n      parsedDatasets.data.push(timestamp);\n      parsedDatasets.data.push(numPoints);\n      if (numPoints + PerformanceViewerCollector.SliceDataOffset !== line.length) {\n        return false;\n      }\n      for (let i = PerformanceViewerCollector.SliceDataOffset; i < line.length; i++) {\n        const val = parseFloat(line[i]);\n        if (isNaN(val)) {\n          return false;\n        }\n        parsedDatasets.data.push(val);\n      }\n      parsedDatasets.startingIndices.push(startingIndex);\n      startingIndex += line.length;\n    }\n    this.datasets.ids = parsedDatasets.ids;\n    this.datasets.data = parsedDatasets.data;\n    this.datasets.startingIndices = parsedDatasets.startingIndices;\n    if (!keepDatasetMeta) {\n      this._datasetMeta.clear();\n    }\n    this._strategies.forEach(strategy => strategy.dispose());\n    this._strategies.clear();\n    // populate metadata.\n    if (!keepDatasetMeta) {\n      for (const id of this.datasets.ids) {\n        const category = idCategoryMap.get(id);\n        this._datasetMeta.set(id, {\n          category,\n          color: this._getHexColorFromId(id)\n        });\n      }\n    }\n    this.metadataObservable.notifyObservers(this._datasetMeta);\n    this._hasLoadedData = true;\n    return true;\n  }\n  /**\n   * Exports the datasets inside of the collector to a csv.\n   */\n  exportDataToCsv() {\n    let csvContent = \"\";\n    // create the header line.\n    csvContent += `${TimestampColHeader},${NumPointsColHeader}`;\n    for (let i = 0; i < this.datasets.ids.length; i++) {\n      csvContent += `,${this.datasets.ids[i]}`;\n      if (this._datasetMeta) {\n        const meta = this._datasetMeta.get(this.datasets.ids[i]);\n        if (meta === null || meta === void 0 ? void 0 : meta.category) {\n          csvContent += `${ExportedDataSeparator}${meta.category}`;\n        }\n      }\n    }\n    csvContent += \"\\n\";\n    // create the data lines\n    for (let i = 0; i < this.datasets.startingIndices.itemLength; i++) {\n      const startingIndex = this.datasets.startingIndices.at(i);\n      const timestamp = this.datasets.data.at(startingIndex);\n      const numPoints = this.datasets.data.at(startingIndex + PerformanceViewerCollector.NumberOfPointsOffset);\n      csvContent += `${timestamp},${numPoints}`;\n      for (let offset = 0; offset < numPoints; offset++) {\n        csvContent += `,${this.datasets.data.at(startingIndex + PerformanceViewerCollector.SliceDataOffset + offset)}`;\n      }\n      // add extra commas.\n      for (let diff = 0; diff < this.datasets.ids.length - numPoints; diff++) {\n        csvContent += \",\";\n      }\n      csvContent += \"\\n\";\n    }\n    const fileName = `${new Date().toISOString()}-perfdata.csv`;\n    Tools.Download(new Blob([csvContent], {\n      type: \"text/csv\"\n    }), fileName);\n  }\n  /**\n   * Starts the realtime collection of data.\n   * @param shouldPreserve optional boolean param, if set will preserve the dataset between calls of start.\n   */\n  start(shouldPreserve) {\n    if (!shouldPreserve) {\n      this.datasets.data = new DynamicFloat32Array(InitialArraySize);\n      this.datasets.startingIndices = new DynamicFloat32Array(InitialArraySize);\n      this._startingTimestamp = PrecisionDate.Now;\n    } else if (this._startingTimestamp === undefined) {\n      this._startingTimestamp = PrecisionDate.Now;\n    }\n    this._scene.onAfterRenderObservable.add(this._collectDataAtFrame);\n    this._restoreStringEvents();\n    this._isStarted = true;\n  }\n  /**\n   * Stops the collection of data.\n   */\n  stop() {\n    this._scene.onAfterRenderObservable.removeCallback(this._collectDataAtFrame);\n    this._isStarted = false;\n  }\n  /**\n   * Returns if the perf collector has been started or not.\n   */\n  get isStarted() {\n    return this._isStarted;\n  }\n  /**\n   * Disposes of the object\n   */\n  dispose() {\n    this._scene.onAfterRenderObservable.removeCallback(this._collectDataAtFrame);\n    this._datasetMeta.clear();\n    this._strategies.forEach(strategy => {\n      strategy.dispose();\n    });\n    this.datasetObservable.clear();\n    this.metadataObservable.clear();\n    this._isStarted = false;\n    this.datasets = null;\n  }\n}","map":{"version":3,"names":["EventState","Observable","PrecisionDate","Tools","DynamicFloat32Array","InitialArraySize","NumberOfBitsInHexcode","HexPadding","TimestampColHeader","NumPointsColHeader","CarriageReturnRegex","ExportedDataSeparator","PerformanceViewerCollector","SliceDataOffset","NumberOfPointsOffset","constructor","_scene","_enabledStrategyCallbacks","_collectDataAtFrame","timestamp","Now","_startingTimestamp","numPoints","datasets","ids","length","numberOfIndices","startingIndices","itemLength","startingIndex","previousStartingIndex","at","data","push","forEach","id","strategy","_strategies","get","getData","datasetObservable","hasObservers","slice","i","notifyObservers","Map","_datasetMeta","_eventRestoreSet","Set","_customEventObservable","metadataObservable","observer","callback","addCollectionStrategies","registerEvent","name","forceUpdate","category","has","_a","dispose","delete","scene","counter","value","afterRenderObserver","onAfterRenderObservable","add","stringObserver","eventVal","undefined","remove","event","strategyCallback","sendEvent","_restoreStringEvents","size","observers","strategyCallbacks","hidden","replace","RegExp","set","color","_getHexColorFromId","hash","charCodeAt","hex","octet","toString","substr","getCurrentSlice","updateMetadata","prop","meta","clear","preserveStringEventsRestore","_hasLoadedData","hasLoadedData","loadFromFileData","keepDatasetMeta","lines","split","map","line","filter","s","timestampIndex","numPointsIndex","parsedDatasets","firstLine","dataLines","idCategoryMap","parseFloat","parseInt","isNaN","val","exportDataToCsv","csvContent","offset","diff","fileName","Date","toISOString","Download","Blob","type","start","shouldPreserve","_isStarted","stop","removeCallback","isStarted"],"sources":["../../../../../dev/core/src/Misc/PerformanceViewer/performanceViewerCollector.ts"],"sourcesContent":["import type { Scene } from \"../../scene\";\r\nimport type { IPerfCustomEvent, IPerfDatasets, IPerfMetadata } from \"../interfaces/iPerfViewer\";\r\nimport { EventState, Observable } from \"../observable\";\r\nimport { PrecisionDate } from \"../precisionDate\";\r\nimport { Tools } from \"../tools\";\r\nimport { DynamicFloat32Array } from \"./dynamicFloat32Array\";\r\nimport type { IPerfViewerCollectionStrategy, PerfStrategyInitialization } from \"./performanceViewerCollectionStrategies\";\r\n\r\n// the initial size of our array, should be a multiple of two!\r\nconst InitialArraySize = 1800;\r\n\r\n// three octets in a hexcode. #[AA][BB][CC], i.e. 24 bits of data.\r\nconst NumberOfBitsInHexcode = 24;\r\n\r\n// Allows single numeral hex numbers to be appended by a 0.\r\nconst HexPadding = \"0\";\r\n\r\n// header for the timestamp column\r\nconst TimestampColHeader = \"timestamp\";\r\n\r\n// header for the numPoints column\r\nconst NumPointsColHeader = \"numPoints\";\r\n\r\n// regex to capture all carriage returns in the string.\r\nconst CarriageReturnRegex = /\\r/g;\r\n\r\n// string to use as separator when exporting extra information along with the dataset id\r\nconst ExportedDataSeparator = \"@\";\r\n\r\n/**\r\n * Callback strategy and optional category for data collection\r\n */\r\ninterface IPerformanceViewerStrategyParameter {\r\n    /**\r\n     * The strategy for collecting data. Available strategies are located on the PerfCollectionStrategy class\r\n     */\r\n    strategyCallback: PerfStrategyInitialization;\r\n    /**\r\n     * Category for displaying this strategy on the viewer. Can be undefined or an empty string, in which case the strategy will be displayed on top\r\n     */\r\n    category?: string;\r\n    /**\r\n     * Starts hidden\r\n     */\r\n    hidden?: boolean;\r\n}\r\n\r\n/**\r\n * The collector class handles the collection and storage of data into the appropriate array.\r\n * The collector also handles notifying any observers of any updates.\r\n */\r\nexport class PerformanceViewerCollector {\r\n    private _datasetMeta: Map<string, IPerfMetadata>;\r\n    private _strategies: Map<string, IPerfViewerCollectionStrategy>;\r\n    private _startingTimestamp: number;\r\n    private _hasLoadedData: boolean;\r\n    private _isStarted: boolean;\r\n    private readonly _customEventObservable: Observable<IPerfCustomEvent>;\r\n    private readonly _eventRestoreSet: Set<string>;\r\n\r\n    /**\r\n     * Datastructure containing the collected datasets. Warning: you should not modify the values in here, data will be of the form [timestamp, numberOfPoints, value1, value2..., timestamp, etc...]\r\n     */\r\n    public readonly datasets: IPerfDatasets;\r\n    /**\r\n     * An observable you can attach to get deltas in the dataset. Subscribing to this will increase memory consumption slightly, and may hurt performance due to increased garbage collection needed.\r\n     * Updates of slices will be of the form [timestamp, numberOfPoints, value1, value2...].\r\n     */\r\n    public readonly datasetObservable: Observable<number[]>;\r\n    /**\r\n     * An observable you can attach to get the most updated map of metadatas.\r\n     */\r\n    public readonly metadataObservable: Observable<Map<string, IPerfMetadata>>;\r\n\r\n    /**\r\n     * The offset for when actual data values start appearing inside a slice.\r\n     */\r\n    public static get SliceDataOffset() {\r\n        return 2;\r\n    }\r\n\r\n    /**\r\n     * The offset for the value of the number of points inside a slice.\r\n     */\r\n    public static get NumberOfPointsOffset() {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Handles the creation of a performance viewer collector.\r\n     * @param _scene the scene to collect on.\r\n     * @param _enabledStrategyCallbacks the list of data to collect with callbacks for initialization purposes.\r\n     */\r\n    constructor(private _scene: Scene, _enabledStrategyCallbacks?: IPerformanceViewerStrategyParameter[]) {\r\n        this.datasets = {\r\n            ids: [],\r\n            data: new DynamicFloat32Array(InitialArraySize),\r\n            startingIndices: new DynamicFloat32Array(InitialArraySize),\r\n        };\r\n        this._strategies = new Map<string, IPerfViewerCollectionStrategy>();\r\n        this._datasetMeta = new Map<string, IPerfMetadata>();\r\n        this._eventRestoreSet = new Set();\r\n        this._customEventObservable = new Observable();\r\n        this.datasetObservable = new Observable();\r\n        this.metadataObservable = new Observable((observer) => observer.callback(this._datasetMeta, new EventState(0)));\r\n        if (_enabledStrategyCallbacks) {\r\n            this.addCollectionStrategies(..._enabledStrategyCallbacks);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Registers a custom string event which will be callable via sendEvent. This method returns an event object which will contain the id of the event.\r\n     * The user can set a value optionally, which will be used in the sendEvent method. If the value is set, we will record this value at the end of each frame,\r\n     * if not we will increment our counter and record the value of the counter at the end of each frame. The value recorded is 0 if no sendEvent method is called, within a frame.\r\n     * @param name The name of the event to register\r\n     * @param forceUpdate if the code should force add an event, and replace the last one.\r\n     * @param category the category for that event\r\n     * @returns The event registered, used in sendEvent\r\n     */\r\n    public registerEvent(name: string, forceUpdate?: boolean, category?: string): IPerfCustomEvent | undefined {\r\n        if (this._strategies.has(name) && !forceUpdate) {\r\n            return;\r\n        }\r\n\r\n        if (this._strategies.has(name) && forceUpdate) {\r\n            this._strategies.get(name)?.dispose();\r\n            this._strategies.delete(name);\r\n        }\r\n\r\n        const strategy: PerfStrategyInitialization = (scene) => {\r\n            let counter: number = 0;\r\n            let value: number = 0;\r\n\r\n            const afterRenderObserver = scene.onAfterRenderObservable.add(() => {\r\n                value = counter;\r\n                counter = 0;\r\n            });\r\n\r\n            const stringObserver = this._customEventObservable.add((eventVal) => {\r\n                if (name !== eventVal.name) {\r\n                    return;\r\n                }\r\n\r\n                if (eventVal.value !== undefined) {\r\n                    counter = eventVal.value;\r\n                } else {\r\n                    counter++;\r\n                }\r\n            });\r\n\r\n            return {\r\n                id: name,\r\n                getData: () => value,\r\n                dispose: () => {\r\n                    scene.onAfterRenderObservable.remove(afterRenderObserver);\r\n                    this._customEventObservable.remove(stringObserver);\r\n                },\r\n            };\r\n        };\r\n        const event: IPerfCustomEvent = {\r\n            name,\r\n        };\r\n\r\n        this._eventRestoreSet.add(name);\r\n        this.addCollectionStrategies({ strategyCallback: strategy, category });\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Lets the perf collector handle an event, occurences or event value depending on if the event.value params is set.\r\n     * @param event the event to handle an occurence for\r\n     */\r\n    public sendEvent(event: IPerfCustomEvent) {\r\n        this._customEventObservable.notifyObservers(event);\r\n    }\r\n\r\n    /**\r\n     * This event restores all custom string events if necessary.\r\n     */\r\n    private _restoreStringEvents() {\r\n        if (this._eventRestoreSet.size !== this._customEventObservable.observers.length) {\r\n            this._eventRestoreSet.forEach((event) => {\r\n                this.registerEvent(event, true);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method adds additional collection strategies for data collection purposes.\r\n     * @param strategyCallbacks the list of data to collect with callbacks.\r\n     */\r\n    public addCollectionStrategies(...strategyCallbacks: IPerformanceViewerStrategyParameter[]) {\r\n        // eslint-disable-next-line prefer-const\r\n        for (let { strategyCallback, category, hidden } of strategyCallbacks) {\r\n            const strategy = strategyCallback(this._scene);\r\n            if (this._strategies.has(strategy.id)) {\r\n                strategy.dispose();\r\n                continue;\r\n            }\r\n\r\n            this.datasets.ids.push(strategy.id);\r\n\r\n            if (category) {\r\n                category = category.replace(new RegExp(ExportedDataSeparator, \"g\"), \"\");\r\n            }\r\n\r\n            this._datasetMeta.set(strategy.id, {\r\n                color: this._getHexColorFromId(strategy.id),\r\n                category,\r\n                hidden,\r\n            });\r\n\r\n            this._strategies.set(strategy.id, strategy);\r\n        }\r\n\r\n        this.metadataObservable.notifyObservers(this._datasetMeta);\r\n    }\r\n\r\n    /**\r\n     * Gets a 6 character hexcode representing the colour from a passed in string.\r\n     * @param id the string to get a hex code for.\r\n     * @returns a hexcode hashed from the id.\r\n     */\r\n    private _getHexColorFromId(id: string) {\r\n        // this first bit is just a known way of hashing a string.\r\n        let hash = 0;\r\n        for (let i = 0; i < id.length; i++) {\r\n            // (hash << 5) - hash is the same as hash * 31\r\n            hash = id.charCodeAt(i) + ((hash << 5) - hash);\r\n        }\r\n\r\n        // then we build the string octet by octet.\r\n        let hex = \"#\";\r\n        for (let i = 0; i < NumberOfBitsInHexcode; i += 8) {\r\n            const octet = (hash >> i) & 0xff;\r\n            hex += (HexPadding + octet.toString(16)).substr(-2);\r\n        }\r\n\r\n        return hex;\r\n    }\r\n\r\n    /**\r\n     * Collects data for every dataset by using the appropriate strategy. This is called every frame.\r\n     * This method will then notify all observers with the latest slice.\r\n     */\r\n    private _collectDataAtFrame = () => {\r\n        const timestamp = PrecisionDate.Now - this._startingTimestamp;\r\n        const numPoints = this.datasets.ids.length;\r\n\r\n        // add the starting index for the slice\r\n        const numberOfIndices = this.datasets.startingIndices.itemLength;\r\n        let startingIndex = 0;\r\n\r\n        if (numberOfIndices > 0) {\r\n            const previousStartingIndex = this.datasets.startingIndices.at(numberOfIndices - 1);\r\n            startingIndex =\r\n                previousStartingIndex + this.datasets.data.at(previousStartingIndex + PerformanceViewerCollector.NumberOfPointsOffset) + PerformanceViewerCollector.SliceDataOffset;\r\n        }\r\n\r\n        this.datasets.startingIndices.push(startingIndex);\r\n\r\n        // add the first 2 items in our slice.\r\n        this.datasets.data.push(timestamp);\r\n        this.datasets.data.push(numPoints);\r\n\r\n        // add the values inside the slice.\r\n        this.datasets.ids.forEach((id: string) => {\r\n            const strategy = this._strategies.get(id);\r\n\r\n            if (!strategy) {\r\n                return;\r\n            }\r\n\r\n            this.datasets.data.push(strategy.getData());\r\n        });\r\n\r\n        if (this.datasetObservable.hasObservers()) {\r\n            const slice: number[] = [timestamp, numPoints];\r\n\r\n            for (let i = 0; i < numPoints; i++) {\r\n                slice.push(this.datasets.data.at(startingIndex + PerformanceViewerCollector.SliceDataOffset + i));\r\n            }\r\n\r\n            this.datasetObservable.notifyObservers(slice);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Collects and then sends the latest slice to any observers by using the appropriate strategy when the user wants.\r\n     * The slice will be of the form [timestamp, numberOfPoints, value1, value2...]\r\n     * This method does not add onto the collected data accessible via the datasets variable.\r\n     */\r\n    public getCurrentSlice() {\r\n        const timestamp = PrecisionDate.Now - this._startingTimestamp;\r\n        const numPoints = this.datasets.ids.length;\r\n        const slice: number[] = [timestamp, numPoints];\r\n\r\n        // add the values inside the slice.\r\n        this.datasets.ids.forEach((id: string) => {\r\n            const strategy = this._strategies.get(id);\r\n\r\n            if (!strategy) {\r\n                return;\r\n            }\r\n\r\n            if (this.datasetObservable.hasObservers()) {\r\n                slice.push(strategy.getData());\r\n            }\r\n        });\r\n\r\n        if (this.datasetObservable.hasObservers()) {\r\n            this.datasetObservable.notifyObservers(slice);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates a property for a dataset's metadata with the value provided.\r\n     * @param id the id of the dataset which needs its metadata updated.\r\n     * @param prop the property to update.\r\n     * @param value the value to update the property with.\r\n     */\r\n    public updateMetadata<T extends keyof IPerfMetadata>(id: string, prop: T, value: IPerfMetadata[T]) {\r\n        const meta = this._datasetMeta.get(id);\r\n\r\n        if (!meta) {\r\n            return;\r\n        }\r\n\r\n        meta[prop] = value;\r\n\r\n        this.metadataObservable.notifyObservers(this._datasetMeta);\r\n    }\r\n\r\n    /**\r\n     * Completely clear, data, ids, and strategies saved to this performance collector.\r\n     * @param preserveStringEventsRestore if it should preserve the string events, by default will clear string events registered when called.\r\n     */\r\n    public clear(preserveStringEventsRestore?: boolean) {\r\n        this.datasets.data = new DynamicFloat32Array(InitialArraySize);\r\n        this.datasets.ids.length = 0;\r\n        this.datasets.startingIndices = new DynamicFloat32Array(InitialArraySize);\r\n        this._datasetMeta.clear();\r\n        this._strategies.forEach((strategy) => strategy.dispose());\r\n        this._strategies.clear();\r\n\r\n        if (!preserveStringEventsRestore) {\r\n            this._eventRestoreSet.clear();\r\n        }\r\n        this._hasLoadedData = false;\r\n    }\r\n\r\n    /**\r\n     * Accessor which lets the caller know if the performance collector has data loaded from a file or not!\r\n     * Call clear() to reset this value.\r\n     * @returns true if the data is loaded from a file, false otherwise.\r\n     */\r\n    public get hasLoadedData(): boolean {\r\n        return this._hasLoadedData;\r\n    }\r\n\r\n    /**\r\n     * Given a string containing file data, this function parses the file data into the datasets object.\r\n     * It returns a boolean to indicate if this object was successfully loaded with the data.\r\n     * @param data string content representing the file data.\r\n     * @param keepDatasetMeta if it should use reuse the existing dataset metadata\r\n     * @returns true if the data was successfully loaded, false otherwise.\r\n     */\r\n    public loadFromFileData(data: string, keepDatasetMeta?: boolean): boolean {\r\n        const lines = data\r\n            .replace(CarriageReturnRegex, \"\")\r\n            .split(\"\\n\")\r\n            .map((line) => line.split(\",\").filter((s) => s.length > 0))\r\n            .filter((line) => line.length > 0);\r\n        const timestampIndex = 0;\r\n        const numPointsIndex = PerformanceViewerCollector.NumberOfPointsOffset;\r\n        if (lines.length < 2) {\r\n            return false;\r\n        }\r\n\r\n        const parsedDatasets: IPerfDatasets = {\r\n            ids: [],\r\n            data: new DynamicFloat32Array(InitialArraySize),\r\n            startingIndices: new DynamicFloat32Array(InitialArraySize),\r\n        };\r\n\r\n        // parse first line separately to populate ids!\r\n        const [firstLine, ...dataLines] = lines;\r\n        // make sure we have the correct beginning headers\r\n        if (firstLine.length < 2 || firstLine[timestampIndex] !== TimestampColHeader || firstLine[numPointsIndex] !== NumPointsColHeader) {\r\n            return false;\r\n        }\r\n\r\n        const idCategoryMap: Map<string, string> = new Map<string, string>();\r\n\r\n        // populate the ids.\r\n        for (let i = PerformanceViewerCollector.SliceDataOffset; i < firstLine.length; i++) {\r\n            const [id, category] = firstLine[i].split(ExportedDataSeparator);\r\n            parsedDatasets.ids.push(id);\r\n            idCategoryMap.set(id, category);\r\n        }\r\n\r\n        let startingIndex = 0;\r\n        for (const line of dataLines) {\r\n            if (line.length < 2) {\r\n                return false;\r\n            }\r\n\r\n            const timestamp = parseFloat(line[timestampIndex]);\r\n            const numPoints = parseInt(line[numPointsIndex]);\r\n\r\n            if (isNaN(numPoints) || isNaN(timestamp)) {\r\n                return false;\r\n            }\r\n\r\n            parsedDatasets.data.push(timestamp);\r\n            parsedDatasets.data.push(numPoints);\r\n\r\n            if (numPoints + PerformanceViewerCollector.SliceDataOffset !== line.length) {\r\n                return false;\r\n            }\r\n\r\n            for (let i = PerformanceViewerCollector.SliceDataOffset; i < line.length; i++) {\r\n                const val = parseFloat(line[i]);\r\n                if (isNaN(val)) {\r\n                    return false;\r\n                }\r\n                parsedDatasets.data.push(val);\r\n            }\r\n\r\n            parsedDatasets.startingIndices.push(startingIndex);\r\n            startingIndex += line.length;\r\n        }\r\n\r\n        this.datasets.ids = parsedDatasets.ids;\r\n        this.datasets.data = parsedDatasets.data;\r\n        this.datasets.startingIndices = parsedDatasets.startingIndices;\r\n        if (!keepDatasetMeta) {\r\n            this._datasetMeta.clear();\r\n        }\r\n        this._strategies.forEach((strategy) => strategy.dispose());\r\n        this._strategies.clear();\r\n\r\n        // populate metadata.\r\n        if (!keepDatasetMeta) {\r\n            for (const id of this.datasets.ids) {\r\n                const category = idCategoryMap.get(id);\r\n\r\n                this._datasetMeta.set(id, { category, color: this._getHexColorFromId(id) });\r\n            }\r\n        }\r\n        this.metadataObservable.notifyObservers(this._datasetMeta);\r\n        this._hasLoadedData = true;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Exports the datasets inside of the collector to a csv.\r\n     */\r\n    public exportDataToCsv() {\r\n        let csvContent = \"\";\r\n        // create the header line.\r\n        csvContent += `${TimestampColHeader},${NumPointsColHeader}`;\r\n        for (let i = 0; i < this.datasets.ids.length; i++) {\r\n            csvContent += `,${this.datasets.ids[i]}`;\r\n            if (this._datasetMeta) {\r\n                const meta = this._datasetMeta.get(this.datasets.ids[i]);\r\n                if (meta?.category) {\r\n                    csvContent += `${ExportedDataSeparator}${meta.category}`;\r\n                }\r\n            }\r\n        }\r\n        csvContent += \"\\n\";\r\n        // create the data lines\r\n        for (let i = 0; i < this.datasets.startingIndices.itemLength; i++) {\r\n            const startingIndex = this.datasets.startingIndices.at(i);\r\n            const timestamp = this.datasets.data.at(startingIndex);\r\n            const numPoints = this.datasets.data.at(startingIndex + PerformanceViewerCollector.NumberOfPointsOffset);\r\n\r\n            csvContent += `${timestamp},${numPoints}`;\r\n\r\n            for (let offset = 0; offset < numPoints; offset++) {\r\n                csvContent += `,${this.datasets.data.at(startingIndex + PerformanceViewerCollector.SliceDataOffset + offset)}`;\r\n            }\r\n\r\n            // add extra commas.\r\n            for (let diff = 0; diff < this.datasets.ids.length - numPoints; diff++) {\r\n                csvContent += \",\";\r\n            }\r\n\r\n            csvContent += \"\\n\";\r\n        }\r\n\r\n        const fileName = `${new Date().toISOString()}-perfdata.csv`;\r\n        Tools.Download(new Blob([csvContent], { type: \"text/csv\" }), fileName);\r\n    }\r\n    /**\r\n     * Starts the realtime collection of data.\r\n     * @param shouldPreserve optional boolean param, if set will preserve the dataset between calls of start.\r\n     */\r\n    public start(shouldPreserve?: boolean) {\r\n        if (!shouldPreserve) {\r\n            this.datasets.data = new DynamicFloat32Array(InitialArraySize);\r\n            this.datasets.startingIndices = new DynamicFloat32Array(InitialArraySize);\r\n            this._startingTimestamp = PrecisionDate.Now;\r\n        } else if (this._startingTimestamp === undefined) {\r\n            this._startingTimestamp = PrecisionDate.Now;\r\n        }\r\n        this._scene.onAfterRenderObservable.add(this._collectDataAtFrame);\r\n        this._restoreStringEvents();\r\n        this._isStarted = true;\r\n    }\r\n\r\n    /**\r\n     * Stops the collection of data.\r\n     */\r\n    public stop() {\r\n        this._scene.onAfterRenderObservable.removeCallback(this._collectDataAtFrame);\r\n        this._isStarted = false;\r\n    }\r\n\r\n    /**\r\n     * Returns if the perf collector has been started or not.\r\n     */\r\n    public get isStarted(): boolean {\r\n        return this._isStarted;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the object\r\n     */\r\n    public dispose() {\r\n        this._scene.onAfterRenderObservable.removeCallback(this._collectDataAtFrame);\r\n        this._datasetMeta.clear();\r\n        this._strategies.forEach((strategy) => {\r\n            strategy.dispose();\r\n        });\r\n        this.datasetObservable.clear();\r\n        this.metadataObservable.clear();\r\n        this._isStarted = false;\r\n        (<any>this.datasets) = null;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}