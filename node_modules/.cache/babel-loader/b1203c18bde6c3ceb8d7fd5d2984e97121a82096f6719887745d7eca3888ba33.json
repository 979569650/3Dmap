{"ast":null,"code":"import { Observable } from \"../Misc/observable.js\";\nimport { Scene } from \"../scene.js\";\nimport { Ray } from \"../Culling/ray.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { ActionEvent } from \"../Actions/actionEvent.js\";\nScene.prototype._internalPickSprites = function (ray, predicate, fastCheck, camera) {\n  if (!PickingInfo) {\n    return null;\n  }\n  let pickingInfo = null;\n  if (!camera) {\n    if (!this.activeCamera) {\n      return null;\n    }\n    camera = this.activeCamera;\n  }\n  if (this.spriteManagers && this.spriteManagers.length > 0) {\n    for (let spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {\n      const spriteManager = this.spriteManagers[spriteIndex];\n      if (!spriteManager.isPickable) {\n        continue;\n      }\n      const result = spriteManager.intersects(ray, camera, predicate, fastCheck);\n      if (!result || !result.hit) {\n        continue;\n      }\n      if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\n        continue;\n      }\n      pickingInfo = result;\n      if (fastCheck) {\n        break;\n      }\n    }\n  }\n  return pickingInfo || new PickingInfo();\n};\nScene.prototype._internalMultiPickSprites = function (ray, predicate, camera) {\n  if (!PickingInfo) {\n    return null;\n  }\n  let pickingInfos = new Array();\n  if (!camera) {\n    if (!this.activeCamera) {\n      return null;\n    }\n    camera = this.activeCamera;\n  }\n  if (this.spriteManagers && this.spriteManagers.length > 0) {\n    for (let spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {\n      const spriteManager = this.spriteManagers[spriteIndex];\n      if (!spriteManager.isPickable) {\n        continue;\n      }\n      const results = spriteManager.multiIntersects(ray, camera, predicate);\n      if (results !== null) {\n        pickingInfos = pickingInfos.concat(results);\n      }\n    }\n  }\n  return pickingInfos;\n};\nScene.prototype.pickSprite = function (x, y, predicate, fastCheck, camera) {\n  if (!this._tempSpritePickingRay) {\n    return null;\n  }\n  this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay, camera);\n  const result = this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);\n  if (result) {\n    result.ray = this.createPickingRayInCameraSpace(x, y, camera);\n  }\n  return result;\n};\nScene.prototype.pickSpriteWithRay = function (ray, predicate, fastCheck, camera) {\n  if (!this._tempSpritePickingRay) {\n    return null;\n  }\n  if (!camera) {\n    if (!this.activeCamera) {\n      return null;\n    }\n    camera = this.activeCamera;\n  }\n  Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);\n  const result = this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);\n  if (result) {\n    result.ray = ray;\n  }\n  return result;\n};\nScene.prototype.multiPickSprite = function (x, y, predicate, camera) {\n  this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay, camera);\n  return this._internalMultiPickSprites(this._tempSpritePickingRay, predicate, camera);\n};\nScene.prototype.multiPickSpriteWithRay = function (ray, predicate, camera) {\n  if (!this._tempSpritePickingRay) {\n    return null;\n  }\n  if (!camera) {\n    if (!this.activeCamera) {\n      return null;\n    }\n    camera = this.activeCamera;\n  }\n  Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);\n  return this._internalMultiPickSprites(this._tempSpritePickingRay, predicate, camera);\n};\nScene.prototype.setPointerOverSprite = function (sprite) {\n  if (this._pointerOverSprite === sprite) {\n    return;\n  }\n  if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\n    this._pointerOverSprite.actionManager.processTrigger(10, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\n  }\n  this._pointerOverSprite = sprite;\n  if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\n    this._pointerOverSprite.actionManager.processTrigger(9, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\n  }\n};\nScene.prototype.getPointerOverSprite = function () {\n  return this._pointerOverSprite;\n};\n/**\n * Defines the sprite scene component responsible to manage sprites\n * in a given scene.\n */\nexport class SpriteSceneComponent {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  constructor(scene) {\n    /**\n     * The component name helpfull to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_SPRITE;\n    this.scene = scene;\n    this.scene.spriteManagers = new Array();\n    this.scene._tempSpritePickingRay = Ray ? Ray.Zero() : null;\n    this.scene.onBeforeSpritesRenderingObservable = new Observable();\n    this.scene.onAfterSpritesRenderingObservable = new Observable();\n    this._spritePredicate = sprite => {\n      if (!sprite.actionManager) {\n        return false;\n      }\n      return sprite.isPickable && sprite.actionManager.hasPointerTriggers;\n    };\n  }\n  /**\n   * Registers the component in a given scene\n   */\n  register() {\n    this.scene._pointerMoveStage.registerStep(SceneComponentConstants.STEP_POINTERMOVE_SPRITE, this, this._pointerMove);\n    this.scene._pointerDownStage.registerStep(SceneComponentConstants.STEP_POINTERDOWN_SPRITE, this, this._pointerDown);\n    this.scene._pointerUpStage.registerStep(SceneComponentConstants.STEP_POINTERUP_SPRITE, this, this._pointerUp);\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  rebuild() {\n    /** Nothing to do for sprites */\n  }\n  /**\n   * Disposes the component and the associated resources.\n   */\n  dispose() {\n    this.scene.onBeforeSpritesRenderingObservable.clear();\n    this.scene.onAfterSpritesRenderingObservable.clear();\n    const spriteManagers = this.scene.spriteManagers;\n    if (!spriteManagers) {\n      return;\n    }\n    while (spriteManagers.length) {\n      spriteManagers[0].dispose();\n    }\n  }\n  _pickSpriteButKeepRay(originalPointerInfo, x, y, fastCheck, camera) {\n    const result = this.scene.pickSprite(x, y, this._spritePredicate, fastCheck, camera);\n    if (result) {\n      result.ray = originalPointerInfo ? originalPointerInfo.ray : null;\n    }\n    return result;\n  }\n  _pointerMove(unTranslatedPointerX, unTranslatedPointerY, pickResult, isMeshPicked, element) {\n    const scene = this.scene;\n    if (isMeshPicked) {\n      scene.setPointerOverSprite(null);\n    } else {\n      pickResult = this._pickSpriteButKeepRay(pickResult, unTranslatedPointerX, unTranslatedPointerY, false, scene.cameraToUseForPointers || undefined);\n      if (pickResult && pickResult.hit && pickResult.pickedSprite) {\n        scene.setPointerOverSprite(pickResult.pickedSprite);\n        if (!scene.doNotHandleCursors && element) {\n          if (scene._pointerOverSprite && scene._pointerOverSprite.actionManager && scene._pointerOverSprite.actionManager.hoverCursor) {\n            element.style.cursor = scene._pointerOverSprite.actionManager.hoverCursor;\n          } else {\n            element.style.cursor = scene.hoverCursor;\n          }\n        }\n      } else {\n        scene.setPointerOverSprite(null);\n      }\n    }\n    return pickResult;\n  }\n  _pointerDown(unTranslatedPointerX, unTranslatedPointerY, pickResult, evt) {\n    const scene = this.scene;\n    scene._pickedDownSprite = null;\n    if (scene.spriteManagers && scene.spriteManagers.length > 0) {\n      pickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);\n      if (pickResult && pickResult.hit && pickResult.pickedSprite) {\n        if (pickResult.pickedSprite.actionManager) {\n          scene._pickedDownSprite = pickResult.pickedSprite;\n          switch (evt.button) {\n            case 0:\n              pickResult.pickedSprite.actionManager.processTrigger(2, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n              break;\n            case 1:\n              pickResult.pickedSprite.actionManager.processTrigger(4, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n              break;\n            case 2:\n              pickResult.pickedSprite.actionManager.processTrigger(3, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n              break;\n          }\n          if (pickResult.pickedSprite.actionManager) {\n            pickResult.pickedSprite.actionManager.processTrigger(5, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n          }\n        }\n      }\n    }\n    return pickResult;\n  }\n  _pointerUp(unTranslatedPointerX, unTranslatedPointerY, pickResult, evt, doubleClick) {\n    const scene = this.scene;\n    if (scene.spriteManagers && scene.spriteManagers.length > 0) {\n      const spritePickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);\n      if (spritePickResult) {\n        if (spritePickResult.hit && spritePickResult.pickedSprite) {\n          if (spritePickResult.pickedSprite.actionManager) {\n            spritePickResult.pickedSprite.actionManager.processTrigger(7, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));\n            if (spritePickResult.pickedSprite.actionManager) {\n              if (!this.scene._inputManager._isPointerSwiping()) {\n                spritePickResult.pickedSprite.actionManager.processTrigger(1, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));\n              }\n              if (doubleClick) {\n                spritePickResult.pickedSprite.actionManager.processTrigger(6, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));\n              }\n            }\n          }\n        }\n        if (scene._pickedDownSprite && scene._pickedDownSprite.actionManager && scene._pickedDownSprite !== spritePickResult.pickedSprite) {\n          scene._pickedDownSprite.actionManager.processTrigger(16, ActionEvent.CreateNewFromSprite(scene._pickedDownSprite, scene, evt));\n        }\n      }\n    }\n    return pickResult;\n  }\n}","map":{"version":3,"names":["Observable","Scene","Ray","PickingInfo","SceneComponentConstants","ActionEvent","prototype","_internalPickSprites","ray","predicate","fastCheck","camera","pickingInfo","activeCamera","spriteManagers","length","spriteIndex","spriteManager","isPickable","result","intersects","hit","distance","_internalMultiPickSprites","pickingInfos","Array","results","multiIntersects","concat","pickSprite","x","y","_tempSpritePickingRay","createPickingRayInCameraSpaceToRef","createPickingRayInCameraSpace","pickSpriteWithRay","TransformToRef","getViewMatrix","multiPickSprite","multiPickSpriteWithRay","setPointerOverSprite","sprite","_pointerOverSprite","actionManager","processTrigger","CreateNewFromSprite","getPointerOverSprite","SpriteSceneComponent","constructor","scene","name","NAME_SPRITE","Zero","onBeforeSpritesRenderingObservable","onAfterSpritesRenderingObservable","_spritePredicate","hasPointerTriggers","register","_pointerMoveStage","registerStep","STEP_POINTERMOVE_SPRITE","_pointerMove","_pointerDownStage","STEP_POINTERDOWN_SPRITE","_pointerDown","_pointerUpStage","STEP_POINTERUP_SPRITE","_pointerUp","rebuild","dispose","clear","_pickSpriteButKeepRay","originalPointerInfo","unTranslatedPointerX","unTranslatedPointerY","pickResult","isMeshPicked","element","cameraToUseForPointers","undefined","pickedSprite","doNotHandleCursors","hoverCursor","style","cursor","evt","_pickedDownSprite","button","doubleClick","spritePickResult","_inputManager","_isPointerSwiping"],"sources":["../../../../dev/core/src/Sprites/spriteSceneComponent.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Scene } from \"../scene\";\r\nimport type { Sprite } from \"./sprite\";\r\nimport type { ISpriteManager } from \"./spriteManager\";\r\nimport { Ray } from \"../Culling/ray\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { ActionEvent } from \"../Actions/actionEvent\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { IPointerEvent } from \"../Events/deviceInputEvents\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @internal */\r\n        _pointerOverSprite: Nullable<Sprite>;\r\n\r\n        /** @internal */\r\n        _pickedDownSprite: Nullable<Sprite>;\r\n\r\n        /** @internal */\r\n        _tempSpritePickingRay: Nullable<Ray>;\r\n\r\n        /**\r\n         * All of the sprite managers added to this scene\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/sprites\r\n         */\r\n        spriteManagers?: Array<ISpriteManager>;\r\n\r\n        /**\r\n         * An event triggered when sprites rendering is about to start\r\n         * Note: This event can be trigger more than once per frame (because sprites can be rendered by render target textures as well)\r\n         */\r\n        onBeforeSpritesRenderingObservable: Observable<Scene>;\r\n\r\n        /**\r\n         * An event triggered when sprites rendering is done\r\n         * Note: This event can be trigger more than once per frame (because sprites can be rendered by render target textures as well)\r\n         */\r\n        onAfterSpritesRenderingObservable: Observable<Scene>;\r\n\r\n        /** @internal */\r\n        _internalPickSprites(ray: Ray, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo>;\r\n\r\n        /** Launch a ray to try to pick a sprite in the scene\r\n         * @param x position on screen\r\n         * @param y position on screen\r\n         * @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true\r\n         * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n         * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n         * @returns a PickingInfo\r\n         */\r\n        pickSprite(x: number, y: number, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo>;\r\n\r\n        /** Use the given ray to pick a sprite in the scene\r\n         * @param ray The ray (in world space) to use to pick meshes\r\n         * @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true\r\n         * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n         * @param camera camera to use. Can be set to null. In this case, the scene.activeCamera will be used\r\n         * @returns a PickingInfo\r\n         */\r\n        pickSpriteWithRay(ray: Ray, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo>;\r\n\r\n        /** @internal */\r\n        _internalMultiPickSprites(ray: Ray, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]>;\r\n\r\n        /** Launch a ray to try to pick sprites in the scene\r\n         * @param x position on screen\r\n         * @param y position on screen\r\n         * @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true\r\n         * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n         * @returns a PickingInfo array\r\n         */\r\n        multiPickSprite(x: number, y: number, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]>;\r\n\r\n        /** Use the given ray to pick sprites in the scene\r\n         * @param ray The ray (in world space) to use to pick meshes\r\n         * @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true\r\n         * @param camera camera to use. Can be set to null. In this case, the scene.activeCamera will be used\r\n         * @returns a PickingInfo array\r\n         */\r\n        multiPickSpriteWithRay(ray: Ray, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]>;\r\n\r\n        /**\r\n         * Force the sprite under the pointer\r\n         * @param sprite defines the sprite to use\r\n         */\r\n        setPointerOverSprite(sprite: Nullable<Sprite>): void;\r\n\r\n        /**\r\n         * Gets the sprite under the pointer\r\n         * @returns a Sprite or null if no sprite is under the pointer\r\n         */\r\n        getPointerOverSprite(): Nullable<Sprite>;\r\n    }\r\n}\r\n\r\nScene.prototype._internalPickSprites = function (ray: Ray, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n\r\n    let pickingInfo = null;\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            return null;\r\n        }\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    if (this.spriteManagers && this.spriteManagers.length > 0) {\r\n        for (let spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {\r\n            const spriteManager = this.spriteManagers[spriteIndex];\r\n\r\n            if (!spriteManager.isPickable) {\r\n                continue;\r\n            }\r\n\r\n            const result = spriteManager.intersects(ray, camera, predicate, fastCheck);\r\n            if (!result || !result.hit) {\r\n                continue;\r\n            }\r\n\r\n            if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\r\n                continue;\r\n            }\r\n\r\n            pickingInfo = result;\r\n\r\n            if (fastCheck) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfo || new PickingInfo();\r\n};\r\n\r\nScene.prototype._internalMultiPickSprites = function (ray: Ray, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n\r\n    let pickingInfos = new Array<PickingInfo>();\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            return null;\r\n        }\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    if (this.spriteManagers && this.spriteManagers.length > 0) {\r\n        for (let spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {\r\n            const spriteManager = this.spriteManagers[spriteIndex];\r\n\r\n            if (!spriteManager.isPickable) {\r\n                continue;\r\n            }\r\n\r\n            const results = spriteManager.multiIntersects(ray, camera, predicate);\r\n\r\n            if (results !== null) {\r\n                pickingInfos = pickingInfos.concat(results);\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfos;\r\n};\r\n\r\nScene.prototype.pickSprite = function (x: number, y: number, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo> {\r\n    if (!this._tempSpritePickingRay) {\r\n        return null;\r\n    }\r\n\r\n    this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay, camera);\r\n\r\n    const result = this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);\r\n    if (result) {\r\n        result.ray = this.createPickingRayInCameraSpace(x, y, camera);\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.pickSpriteWithRay = function (ray: Ray, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo> {\r\n    if (!this._tempSpritePickingRay) {\r\n        return null;\r\n    }\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            return null;\r\n        }\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);\r\n\r\n    const result = this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);\r\n    if (result) {\r\n        result.ray = ray;\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.multiPickSprite = function (x: number, y: number, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]> {\r\n    this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay!, camera);\r\n\r\n    return this._internalMultiPickSprites(this._tempSpritePickingRay!, predicate, camera);\r\n};\r\n\r\nScene.prototype.multiPickSpriteWithRay = function (ray: Ray, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]> {\r\n    if (!this._tempSpritePickingRay) {\r\n        return null;\r\n    }\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            return null;\r\n        }\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);\r\n\r\n    return this._internalMultiPickSprites(this._tempSpritePickingRay, predicate, camera);\r\n};\r\n\r\nScene.prototype.setPointerOverSprite = function (sprite: Nullable<Sprite>): void {\r\n    if (this._pointerOverSprite === sprite) {\r\n        return;\r\n    }\r\n\r\n    if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\r\n        this._pointerOverSprite.actionManager.processTrigger(Constants.ACTION_OnPointerOutTrigger, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\r\n    }\r\n\r\n    this._pointerOverSprite = sprite;\r\n    if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\r\n        this._pointerOverSprite.actionManager.processTrigger(Constants.ACTION_OnPointerOverTrigger, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\r\n    }\r\n};\r\n\r\nScene.prototype.getPointerOverSprite = function (): Nullable<Sprite> {\r\n    return this._pointerOverSprite;\r\n};\r\n\r\n/**\r\n * Defines the sprite scene component responsible to manage sprites\r\n * in a given scene.\r\n */\r\nexport class SpriteSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpfull to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_SPRITE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /** @internal */\r\n    private _spritePredicate: (sprite: Sprite) => boolean;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this.scene.spriteManagers = new Array<ISpriteManager>();\r\n        this.scene._tempSpritePickingRay = Ray ? Ray.Zero() : null;\r\n        this.scene.onBeforeSpritesRenderingObservable = new Observable<Scene>();\r\n        this.scene.onAfterSpritesRenderingObservable = new Observable<Scene>();\r\n        this._spritePredicate = (sprite: Sprite): boolean => {\r\n            if (!sprite.actionManager) {\r\n                return false;\r\n            }\r\n            return sprite.isPickable && sprite.actionManager.hasPointerTriggers;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._pointerMoveStage.registerStep(SceneComponentConstants.STEP_POINTERMOVE_SPRITE, this, this._pointerMove);\r\n        this.scene._pointerDownStage.registerStep(SceneComponentConstants.STEP_POINTERDOWN_SPRITE, this, this._pointerDown);\r\n        this.scene._pointerUpStage.registerStep(SceneComponentConstants.STEP_POINTERUP_SPRITE, this, this._pointerUp);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        /** Nothing to do for sprites */\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        this.scene.onBeforeSpritesRenderingObservable.clear();\r\n        this.scene.onAfterSpritesRenderingObservable.clear();\r\n\r\n        const spriteManagers = this.scene.spriteManagers;\r\n        if (!spriteManagers) {\r\n            return;\r\n        }\r\n        while (spriteManagers.length) {\r\n            spriteManagers[0].dispose();\r\n        }\r\n    }\r\n\r\n    private _pickSpriteButKeepRay(originalPointerInfo: Nullable<PickingInfo>, x: number, y: number, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo> {\r\n        const result = this.scene.pickSprite(x, y, this._spritePredicate, fastCheck, camera);\r\n        if (result) {\r\n            result.ray = originalPointerInfo ? originalPointerInfo.ray : null;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private _pointerMove(\r\n        unTranslatedPointerX: number,\r\n        unTranslatedPointerY: number,\r\n        pickResult: Nullable<PickingInfo>,\r\n        isMeshPicked: boolean,\r\n        element: Nullable<HTMLElement>\r\n    ): Nullable<PickingInfo> {\r\n        const scene = this.scene;\r\n        if (isMeshPicked) {\r\n            scene.setPointerOverSprite(null);\r\n        } else {\r\n            pickResult = this._pickSpriteButKeepRay(pickResult, unTranslatedPointerX, unTranslatedPointerY, false, scene.cameraToUseForPointers || undefined);\r\n\r\n            if (pickResult && pickResult.hit && pickResult.pickedSprite) {\r\n                scene.setPointerOverSprite(pickResult.pickedSprite);\r\n                if (!scene.doNotHandleCursors && element) {\r\n                    if (scene._pointerOverSprite && scene._pointerOverSprite.actionManager && scene._pointerOverSprite.actionManager.hoverCursor) {\r\n                        element.style.cursor = scene._pointerOverSprite.actionManager.hoverCursor;\r\n                    } else {\r\n                        element.style.cursor = scene.hoverCursor;\r\n                    }\r\n                }\r\n            } else {\r\n                scene.setPointerOverSprite(null);\r\n            }\r\n        }\r\n\r\n        return pickResult;\r\n    }\r\n\r\n    private _pointerDown(unTranslatedPointerX: number, unTranslatedPointerY: number, pickResult: Nullable<PickingInfo>, evt: IPointerEvent): Nullable<PickingInfo> {\r\n        const scene = this.scene;\r\n        scene._pickedDownSprite = null;\r\n        if (scene.spriteManagers && scene.spriteManagers.length > 0) {\r\n            pickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);\r\n\r\n            if (pickResult && pickResult.hit && pickResult.pickedSprite) {\r\n                if (pickResult.pickedSprite.actionManager) {\r\n                    scene._pickedDownSprite = pickResult.pickedSprite;\r\n                    switch (evt.button) {\r\n                        case 0:\r\n                            pickResult.pickedSprite.actionManager.processTrigger(\r\n                                Constants.ACTION_OnLeftPickTrigger,\r\n                                ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt)\r\n                            );\r\n                            break;\r\n                        case 1:\r\n                            pickResult.pickedSprite.actionManager.processTrigger(\r\n                                Constants.ACTION_OnCenterPickTrigger,\r\n                                ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt)\r\n                            );\r\n                            break;\r\n                        case 2:\r\n                            pickResult.pickedSprite.actionManager.processTrigger(\r\n                                Constants.ACTION_OnRightPickTrigger,\r\n                                ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt)\r\n                            );\r\n                            break;\r\n                    }\r\n                    if (pickResult.pickedSprite.actionManager) {\r\n                        pickResult.pickedSprite.actionManager.processTrigger(\r\n                            Constants.ACTION_OnPickDownTrigger,\r\n                            ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt)\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return pickResult;\r\n    }\r\n\r\n    private _pointerUp(\r\n        unTranslatedPointerX: number,\r\n        unTranslatedPointerY: number,\r\n        pickResult: Nullable<PickingInfo>,\r\n        evt: IPointerEvent,\r\n        doubleClick: boolean\r\n    ): Nullable<PickingInfo> {\r\n        const scene = this.scene;\r\n        if (scene.spriteManagers && scene.spriteManagers.length > 0) {\r\n            const spritePickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);\r\n\r\n            if (spritePickResult) {\r\n                if (spritePickResult.hit && spritePickResult.pickedSprite) {\r\n                    if (spritePickResult.pickedSprite.actionManager) {\r\n                        spritePickResult.pickedSprite.actionManager.processTrigger(\r\n                            Constants.ACTION_OnPickUpTrigger,\r\n                            ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt)\r\n                        );\r\n\r\n                        if (spritePickResult.pickedSprite.actionManager) {\r\n                            if (!this.scene._inputManager._isPointerSwiping()) {\r\n                                spritePickResult.pickedSprite.actionManager.processTrigger(\r\n                                    Constants.ACTION_OnPickTrigger,\r\n                                    ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt)\r\n                                );\r\n                            }\r\n\r\n                            if (doubleClick) {\r\n                                spritePickResult.pickedSprite.actionManager.processTrigger(\r\n                                    Constants.ACTION_OnDoublePickTrigger,\r\n                                    ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt)\r\n                                );\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (scene._pickedDownSprite && scene._pickedDownSprite.actionManager && scene._pickedDownSprite !== spritePickResult.pickedSprite) {\r\n                    scene._pickedDownSprite.actionManager.processTrigger(Constants.ACTION_OnPickOutTrigger, ActionEvent.CreateNewFromSprite(scene._pickedDownSprite, scene, evt));\r\n                }\r\n            }\r\n        }\r\n\r\n        return pickResult;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}