{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Quaternion, Vector3, Matrix } from \"../../../Maths/math.vector.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nimport { PhysicsImpostor } from \"../physicsImpostor.js\";\nimport { PhysicsJoint } from \"../physicsJoint.js\";\nimport { VertexBuffer } from \"../../../Buffers/buffer.js\";\nimport { VertexData } from \"../../../Meshes/mesh.vertexData.js\";\nimport { ExtrudeShape } from \"../../../Meshes/Builders/shapeBuilder.js\";\nimport { CreateLines } from \"../../../Meshes/Builders/linesBuilder.js\";\nimport { PhysicsRaycastResult } from \"../../physicsRaycastResult.js\";\nimport { Scalar } from \"../../../Maths/math.scalar.js\";\nimport { Epsilon } from \"../../../Maths/math.constants.js\";\n/**\n * AmmoJS Physics plugin\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\n * @see https://github.com/kripken/ammo.js/\n */\nexport class AmmoJSPlugin {\n  /**\n   * Initializes the ammoJS plugin\n   * @param _useDeltaForWorldStep if the time between frames should be used when calculating physics steps (Default: true)\n   * @param ammoInjection can be used to inject your own ammo reference\n   * @param overlappingPairCache can be used to specify your own overlapping pair cache\n   */\n  constructor(_useDeltaForWorldStep = true, ammoInjection = Ammo, overlappingPairCache = null) {\n    this._useDeltaForWorldStep = _useDeltaForWorldStep;\n    /**\n     * Reference to the Ammo library\n     */\n    this.bjsAMMO = {};\n    /**\n     * Name of the plugin\n     */\n    this.name = \"AmmoJSPlugin\";\n    this._timeStep = 1 / 60;\n    this._fixedTimeStep = 1 / 60;\n    this._maxSteps = 5;\n    this._tmpQuaternion = new Quaternion();\n    this._tmpContactCallbackResult = false;\n    this._tmpContactPoint = new Vector3();\n    this._tmpContactNormal = new Vector3();\n    this._tmpVec3 = new Vector3();\n    this._tmpMatrix = new Matrix();\n    if (typeof ammoInjection === \"function\") {\n      Logger.Error(\"AmmoJS is not ready. Please make sure you await Ammo() before using the plugin.\");\n      return;\n    } else {\n      this.bjsAMMO = ammoInjection;\n    }\n    if (!this.isSupported()) {\n      Logger.Error(\"AmmoJS is not available. Please make sure you included the js file.\");\n      return;\n    }\n    // Initialize the physics world\n    this._collisionConfiguration = new this.bjsAMMO.btSoftBodyRigidBodyCollisionConfiguration();\n    this._dispatcher = new this.bjsAMMO.btCollisionDispatcher(this._collisionConfiguration);\n    this._overlappingPairCache = overlappingPairCache || new this.bjsAMMO.btDbvtBroadphase();\n    this._solver = new this.bjsAMMO.btSequentialImpulseConstraintSolver();\n    this._softBodySolver = new this.bjsAMMO.btDefaultSoftBodySolver();\n    this.world = new this.bjsAMMO.btSoftRigidDynamicsWorld(this._dispatcher, this._overlappingPairCache, this._solver, this._collisionConfiguration, this._softBodySolver);\n    this._tmpAmmoConcreteContactResultCallback = new this.bjsAMMO.ConcreteContactResultCallback();\n    this._tmpAmmoConcreteContactResultCallback.addSingleResult = contactPoint => {\n      contactPoint = this.bjsAMMO.wrapPointer(contactPoint, this.bjsAMMO.btManifoldPoint);\n      const worldPoint = contactPoint.getPositionWorldOnA();\n      const worldNormal = contactPoint.m_normalWorldOnB;\n      this._tmpContactPoint.x = worldPoint.x();\n      this._tmpContactPoint.y = worldPoint.y();\n      this._tmpContactPoint.z = worldPoint.z();\n      this._tmpContactNormal.x = worldNormal.x();\n      this._tmpContactNormal.y = worldNormal.y();\n      this._tmpContactNormal.z = worldNormal.z();\n      this._tmpContactImpulse = contactPoint.getAppliedImpulse();\n      this._tmpContactDistance = contactPoint.getDistance();\n      this._tmpContactCallbackResult = true;\n    };\n    this._raycastResult = new PhysicsRaycastResult();\n    // Create temp ammo variables\n    this._tmpAmmoTransform = new this.bjsAMMO.btTransform();\n    this._tmpAmmoTransform.setIdentity();\n    this._tmpAmmoQuaternion = new this.bjsAMMO.btQuaternion(0, 0, 0, 1);\n    this._tmpAmmoVectorA = new this.bjsAMMO.btVector3(0, 0, 0);\n    this._tmpAmmoVectorB = new this.bjsAMMO.btVector3(0, 0, 0);\n    this._tmpAmmoVectorC = new this.bjsAMMO.btVector3(0, 0, 0);\n    this._tmpAmmoVectorD = new this.bjsAMMO.btVector3(0, 0, 0);\n  }\n  /**\n   *\n   * @returns plugin version\n   */\n  getPluginVersion() {\n    return 1;\n  }\n  /**\n   * Sets the gravity of the physics world (m/(s^2))\n   * @param gravity Gravity to set\n   */\n  setGravity(gravity) {\n    this._tmpAmmoVectorA.setValue(gravity.x, gravity.y, gravity.z);\n    this.world.setGravity(this._tmpAmmoVectorA);\n    this.world.getWorldInfo().set_m_gravity(this._tmpAmmoVectorA);\n  }\n  /**\n   * Amount of time to step forward on each frame (only used if useDeltaForWorldStep is false in the constructor)\n   * @param timeStep timestep to use in seconds\n   */\n  setTimeStep(timeStep) {\n    this._timeStep = timeStep;\n  }\n  /**\n   * Increment to step forward in the physics engine (If timeStep is set to 1/60 and fixedTimeStep is set to 1/120 the physics engine should run 2 steps per frame) (Default: 1/60)\n   * @param fixedTimeStep fixedTimeStep to use in seconds\n   */\n  setFixedTimeStep(fixedTimeStep) {\n    this._fixedTimeStep = fixedTimeStep;\n  }\n  /**\n   * Sets the maximum number of steps by the physics engine per frame (Default: 5)\n   * @param maxSteps the maximum number of steps by the physics engine per frame\n   */\n  setMaxSteps(maxSteps) {\n    this._maxSteps = maxSteps;\n  }\n  /**\n   * Gets the current timestep (only used if useDeltaForWorldStep is false in the constructor)\n   * @returns the current timestep in seconds\n   */\n  getTimeStep() {\n    return this._timeStep;\n  }\n  // Ammo's contactTest and contactPairTest take a callback that runs synchronously, wrap them so that they are easier to consume\n  _isImpostorInContact(impostor) {\n    this._tmpContactCallbackResult = false;\n    this.world.contactTest(impostor.physicsBody, this._tmpAmmoConcreteContactResultCallback);\n    return this._tmpContactCallbackResult;\n  }\n  // Ammo's collision events have some weird quirks\n  // contactPairTest fires too many events as it fires events even when objects are close together but contactTest does not\n  // so only fire event if both contactTest and contactPairTest have a hit\n  _isImpostorPairInContact(impostorA, impostorB) {\n    this._tmpContactCallbackResult = false;\n    this.world.contactPairTest(impostorA.physicsBody, impostorB.physicsBody, this._tmpAmmoConcreteContactResultCallback);\n    return this._tmpContactCallbackResult;\n  }\n  // Ammo's behavior when maxSteps > 0 does not behave as described in docs\n  // @see http://www.bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World\n  //\n  // When maxSteps is 0 do the entire simulation in one step\n  // When maxSteps is > 0, run up to maxStep times, if on the last step the (remaining step - fixedTimeStep) is < fixedTimeStep, the remainder will be used for the step. (eg. if remainder is 1.001 and fixedTimeStep is 1 the last step will be 1.001, if instead it did 2 steps (1, 0.001) issues occuered when having a tiny step in ammo)\n  // Note: To get deterministic physics, timeStep would always need to be divisible by fixedTimeStep\n  _stepSimulation(timeStep = 1 / 60, maxSteps = 10, fixedTimeStep = 1 / 60) {\n    if (maxSteps == 0) {\n      this.world.stepSimulation(timeStep, 0);\n    } else {\n      while (maxSteps > 0 && timeStep > 0) {\n        if (timeStep - fixedTimeStep < fixedTimeStep) {\n          this.world.stepSimulation(timeStep, 0);\n          timeStep = 0;\n        } else {\n          timeStep -= fixedTimeStep;\n          this.world.stepSimulation(fixedTimeStep, 0);\n        }\n        maxSteps--;\n      }\n    }\n  }\n  /**\n   * Moves the physics simulation forward delta seconds and updates the given physics imposters\n   * Prior to the step the imposters physics location is set to the position of the babylon meshes\n   * After the step the babylon meshes are set to the position of the physics imposters\n   * @param delta amount of time to step forward\n   * @param impostors array of imposters to update before/after the step\n   */\n  executeStep(delta, impostors) {\n    for (const impostor of impostors) {\n      // Update physics world objects to match babylon world\n      if (!impostor.soft) {\n        impostor.beforeStep();\n      }\n    }\n    this._stepSimulation(this._useDeltaForWorldStep ? delta : this._timeStep, this._maxSteps, this._fixedTimeStep);\n    for (const mainImpostor of impostors) {\n      // After physics update make babylon world objects match physics world objects\n      if (mainImpostor.soft) {\n        this._afterSoftStep(mainImpostor);\n      } else {\n        mainImpostor.afterStep();\n      }\n      // Handle collision event\n      if (mainImpostor._onPhysicsCollideCallbacks.length > 0) {\n        if (this._isImpostorInContact(mainImpostor)) {\n          for (const collideCallback of mainImpostor._onPhysicsCollideCallbacks) {\n            for (const otherImpostor of collideCallback.otherImpostors) {\n              if (mainImpostor.physicsBody.isActive() || otherImpostor.physicsBody.isActive()) {\n                if (this._isImpostorPairInContact(mainImpostor, otherImpostor)) {\n                  mainImpostor.onCollide({\n                    body: otherImpostor.physicsBody,\n                    point: this._tmpContactPoint,\n                    distance: this._tmpContactDistance,\n                    impulse: this._tmpContactImpulse,\n                    normal: this._tmpContactNormal\n                  });\n                  otherImpostor.onCollide({\n                    body: mainImpostor.physicsBody,\n                    point: this._tmpContactPoint,\n                    distance: this._tmpContactDistance,\n                    impulse: this._tmpContactImpulse,\n                    normal: this._tmpContactNormal\n                  });\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Update babylon mesh to match physics world object\n   * @param impostor imposter to match\n   */\n  _afterSoftStep(impostor) {\n    if (impostor.type === PhysicsImpostor.RopeImpostor) {\n      this._ropeStep(impostor);\n    } else {\n      this._softbodyOrClothStep(impostor);\n    }\n  }\n  /**\n   * Update babylon mesh vertices vertices to match physics world softbody or cloth\n   * @param impostor imposter to match\n   */\n  _ropeStep(impostor) {\n    const bodyVertices = impostor.physicsBody.get_m_nodes();\n    const nbVertices = bodyVertices.size();\n    let node;\n    let nodePositions;\n    let x, y, z;\n    const path = new Array();\n    for (let n = 0; n < nbVertices; n++) {\n      node = bodyVertices.at(n);\n      nodePositions = node.get_m_x();\n      x = nodePositions.x();\n      y = nodePositions.y();\n      z = nodePositions.z();\n      path.push(new Vector3(x, y, z));\n    }\n    const object = impostor.object;\n    const shape = impostor.getParam(\"shape\");\n    if (impostor._isFromLine) {\n      impostor.object = CreateLines(\"lines\", {\n        points: path,\n        instance: object\n      });\n    } else {\n      impostor.object = ExtrudeShape(\"ext\", {\n        shape: shape,\n        path: path,\n        instance: object\n      });\n    }\n  }\n  /**\n   * Update babylon mesh vertices vertices to match physics world softbody or cloth\n   * @param impostor imposter to match\n   */\n  _softbodyOrClothStep(impostor) {\n    const normalDirection = impostor.type === PhysicsImpostor.ClothImpostor ? 1 : -1;\n    const object = impostor.object;\n    let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\n    if (!vertexPositions) {\n      vertexPositions = [];\n    }\n    let vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);\n    if (!vertexNormals) {\n      vertexNormals = [];\n    }\n    const nbVertices = vertexPositions.length / 3;\n    const bodyVertices = impostor.physicsBody.get_m_nodes();\n    let node;\n    let nodePositions;\n    let x, y, z;\n    let nx, ny, nz;\n    for (let n = 0; n < nbVertices; n++) {\n      node = bodyVertices.at(n);\n      nodePositions = node.get_m_x();\n      x = nodePositions.x();\n      y = nodePositions.y();\n      z = nodePositions.z() * normalDirection;\n      const nodeNormals = node.get_m_n();\n      nx = nodeNormals.x();\n      ny = nodeNormals.y();\n      nz = nodeNormals.z() * normalDirection;\n      vertexPositions[3 * n] = x;\n      vertexPositions[3 * n + 1] = y;\n      vertexPositions[3 * n + 2] = z;\n      vertexNormals[3 * n] = nx;\n      vertexNormals[3 * n + 1] = ny;\n      vertexNormals[3 * n + 2] = nz;\n    }\n    const vertex_data = new VertexData();\n    vertex_data.positions = vertexPositions;\n    vertex_data.normals = vertexNormals;\n    vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);\n    vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);\n    if (object && object.getIndices) {\n      vertex_data.indices = object.getIndices();\n    }\n    vertex_data.applyToMesh(object);\n  }\n  /**\n   * Applies an impulse on the imposter\n   * @param impostor imposter to apply impulse to\n   * @param force amount of force to be applied to the imposter\n   * @param contactPoint the location to apply the impulse on the imposter\n   */\n  applyImpulse(impostor, force, contactPoint) {\n    if (!impostor.soft) {\n      impostor.physicsBody.activate();\n      const worldPoint = this._tmpAmmoVectorA;\n      const impulse = this._tmpAmmoVectorB;\n      // Convert contactPoint relative to center of mass\n      if (impostor.object && impostor.object.getWorldMatrix) {\n        contactPoint.subtractInPlace(impostor.object.getWorldMatrix().getTranslation());\n      }\n      worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);\n      impulse.setValue(force.x, force.y, force.z);\n      impostor.physicsBody.applyImpulse(impulse, worldPoint);\n    } else {\n      Logger.Warn(\"Cannot be applied to a soft body\");\n    }\n  }\n  /**\n   * Applies a force on the imposter\n   * @param impostor imposter to apply force\n   * @param force amount of force to be applied to the imposter\n   * @param contactPoint the location to apply the force on the imposter\n   */\n  applyForce(impostor, force, contactPoint) {\n    if (!impostor.soft) {\n      impostor.physicsBody.activate();\n      const worldPoint = this._tmpAmmoVectorA;\n      const impulse = this._tmpAmmoVectorB;\n      // Convert contactPoint relative to center of mass\n      if (impostor.object && impostor.object.getWorldMatrix) {\n        const localTranslation = impostor.object.getWorldMatrix().getTranslation();\n        worldPoint.setValue(contactPoint.x - localTranslation.x, contactPoint.y - localTranslation.y, contactPoint.z - localTranslation.z);\n      } else {\n        worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);\n      }\n      impulse.setValue(force.x, force.y, force.z);\n      impostor.physicsBody.applyForce(impulse, worldPoint);\n    } else {\n      Logger.Warn(\"Cannot be applied to a soft body\");\n    }\n  }\n  /**\n   * Creates a physics body using the plugin\n   * @param impostor the imposter to create the physics body on\n   */\n  generatePhysicsBody(impostor) {\n    // Note: this method will not be called on child imposotrs for compound impostors\n    impostor._pluginData.toDispose = [];\n    //parent-child relationship\n    if (impostor.parent) {\n      if (impostor.physicsBody) {\n        this.removePhysicsBody(impostor);\n        impostor.forceUpdate();\n      }\n      return;\n    }\n    if (impostor.isBodyInitRequired()) {\n      const colShape = this._createShape(impostor);\n      const mass = impostor.getParam(\"mass\");\n      impostor._pluginData.mass = mass;\n      if (impostor.soft) {\n        colShape.get_m_cfg().set_collisions(0x11);\n        colShape.get_m_cfg().set_kDP(impostor.getParam(\"damping\"));\n        this.bjsAMMO.castObject(colShape, this.bjsAMMO.btCollisionObject).getCollisionShape().setMargin(impostor.getParam(\"margin\"));\n        colShape.setActivationState(AmmoJSPlugin._DISABLE_DEACTIVATION_FLAG);\n        this.world.addSoftBody(colShape, 1, -1);\n        impostor.physicsBody = colShape;\n        impostor._pluginData.toDispose.push(colShape);\n        this.setBodyPressure(impostor, 0);\n        if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {\n          this.setBodyPressure(impostor, impostor.getParam(\"pressure\"));\n        }\n        this.setBodyStiffness(impostor, impostor.getParam(\"stiffness\"));\n        this.setBodyVelocityIterations(impostor, impostor.getParam(\"velocityIterations\"));\n        this.setBodyPositionIterations(impostor, impostor.getParam(\"positionIterations\"));\n      } else {\n        const localInertia = new this.bjsAMMO.btVector3(0, 0, 0);\n        const startTransform = new this.bjsAMMO.btTransform();\n        impostor.object.computeWorldMatrix(true);\n        startTransform.setIdentity();\n        if (mass !== 0) {\n          colShape.calculateLocalInertia(mass, localInertia);\n        }\n        this._tmpAmmoVectorA.setValue(impostor.object.position.x, impostor.object.position.y, impostor.object.position.z);\n        this._tmpAmmoQuaternion.setValue(impostor.object.rotationQuaternion.x, impostor.object.rotationQuaternion.y, impostor.object.rotationQuaternion.z, impostor.object.rotationQuaternion.w);\n        startTransform.setOrigin(this._tmpAmmoVectorA);\n        startTransform.setRotation(this._tmpAmmoQuaternion);\n        const myMotionState = new this.bjsAMMO.btDefaultMotionState(startTransform);\n        const rbInfo = new this.bjsAMMO.btRigidBodyConstructionInfo(mass, myMotionState, colShape, localInertia);\n        const body = new this.bjsAMMO.btRigidBody(rbInfo);\n        // Make objects kinematic if it's mass is 0\n        if (mass === 0) {\n          body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin._KINEMATIC_FLAG);\n          body.setActivationState(AmmoJSPlugin._DISABLE_DEACTIVATION_FLAG);\n        }\n        // Disable collision if NoImpostor, but keep collision if shape is btCompoundShape\n        if (impostor.type == PhysicsImpostor.NoImpostor && !colShape.getChildShape) {\n          body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin._DISABLE_COLLISION_FLAG);\n        }\n        // compute delta position: compensate the difference between shape center and mesh origin\n        if (impostor.type !== PhysicsImpostor.MeshImpostor && impostor.type !== PhysicsImpostor.NoImpostor) {\n          const boundingInfo = impostor.object.getBoundingInfo();\n          this._tmpVec3.copyFrom(impostor.object.getAbsolutePosition());\n          this._tmpVec3.subtractInPlace(boundingInfo.boundingBox.centerWorld);\n          this._tmpVec3.x /= impostor.object.scaling.x;\n          this._tmpVec3.y /= impostor.object.scaling.y;\n          this._tmpVec3.z /= impostor.object.scaling.z;\n          impostor.setDeltaPosition(this._tmpVec3);\n        }\n        const group = impostor.getParam(\"group\");\n        const mask = impostor.getParam(\"mask\");\n        if (group && mask) {\n          this.world.addRigidBody(body, group, mask);\n        } else {\n          this.world.addRigidBody(body);\n        }\n        impostor.physicsBody = body;\n        impostor._pluginData.toDispose = impostor._pluginData.toDispose.concat([body, rbInfo, myMotionState, startTransform, localInertia, colShape]);\n      }\n      this.setBodyRestitution(impostor, impostor.getParam(\"restitution\"));\n      this.setBodyFriction(impostor, impostor.getParam(\"friction\"));\n    }\n  }\n  /**\n   * Removes the physics body from the imposter and disposes of the body's memory\n   * @param impostor imposter to remove the physics body from\n   */\n  removePhysicsBody(impostor) {\n    if (this.world) {\n      if (impostor.soft) {\n        this.world.removeSoftBody(impostor.physicsBody);\n      } else {\n        this.world.removeRigidBody(impostor.physicsBody);\n      }\n      if (impostor._pluginData) {\n        impostor._pluginData.toDispose.forEach(d => {\n          this.bjsAMMO.destroy(d);\n        });\n        impostor._pluginData.toDispose = [];\n      }\n    }\n  }\n  /**\n   * Generates a joint\n   * @param impostorJoint the imposter joint to create the joint with\n   */\n  generateJoint(impostorJoint) {\n    const mainBody = impostorJoint.mainImpostor.physicsBody;\n    const connectedBody = impostorJoint.connectedImpostor.physicsBody;\n    if (!mainBody || !connectedBody) {\n      return;\n    }\n    const jointData = impostorJoint.joint.jointData;\n    if (!jointData.mainPivot) {\n      jointData.mainPivot = new Vector3(0, 0, 0);\n    }\n    if (!jointData.connectedPivot) {\n      jointData.connectedPivot = new Vector3(0, 0, 0);\n    }\n    let joint;\n    switch (impostorJoint.joint.type) {\n      case PhysicsJoint.DistanceJoint:\n        {\n          const distance = jointData.maxDistance;\n          if (distance) {\n            jointData.mainPivot = new Vector3(0, -distance / 2, 0);\n            jointData.connectedPivot = new Vector3(0, distance / 2, 0);\n          }\n          joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));\n          break;\n        }\n      case PhysicsJoint.HingeJoint:\n        {\n          if (!jointData.mainAxis) {\n            jointData.mainAxis = new Vector3(0, 0, 0);\n          }\n          if (!jointData.connectedAxis) {\n            jointData.connectedAxis = new Vector3(0, 0, 0);\n          }\n          const mainAxis = new this.bjsAMMO.btVector3(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z);\n          const connectedAxis = new this.bjsAMMO.btVector3(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z);\n          joint = new this.bjsAMMO.btHingeConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z), mainAxis, connectedAxis);\n          break;\n        }\n      case PhysicsJoint.BallAndSocketJoint:\n        joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));\n        break;\n      default:\n        Logger.Warn(\"JointType not currently supported by the Ammo plugin, falling back to PhysicsJoint.BallAndSocketJoint\");\n        joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));\n        break;\n    }\n    this.world.addConstraint(joint, !impostorJoint.joint.jointData.collision);\n    impostorJoint.joint.physicsJoint = joint;\n  }\n  /**\n   * Removes a joint\n   * @param impostorJoint the imposter joint to remove the joint from\n   */\n  removeJoint(impostorJoint) {\n    if (this.world) {\n      this.world.removeConstraint(impostorJoint.joint.physicsJoint);\n    }\n  }\n  // adds all verticies (including child verticies) to the triangle mesh\n  _addMeshVerts(btTriangleMesh, topLevelObject, object) {\n    let triangleCount = 0;\n    if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\n      let indices = object.getIndices();\n      if (!indices) {\n        indices = [];\n      }\n      let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\n      if (!vertexPositions) {\n        vertexPositions = [];\n      }\n      let localMatrix;\n      if (topLevelObject && topLevelObject !== object) {\n        // top level matrix used for shape transform doesn't take scale into account.\n        // Moreover, every children vertex position must be in that space.\n        // So, each vertex position here is transform by (mesh world matrix * toplevelMatrix -1)\n        let topLevelQuaternion;\n        if (topLevelObject.rotationQuaternion) {\n          topLevelQuaternion = topLevelObject.rotationQuaternion;\n        } else if (topLevelObject.rotation) {\n          topLevelQuaternion = Quaternion.FromEulerAngles(topLevelObject.rotation.x, topLevelObject.rotation.y, topLevelObject.rotation.z);\n        } else {\n          topLevelQuaternion = Quaternion.Identity();\n        }\n        const topLevelMatrix = Matrix.Compose(Vector3.One(), topLevelQuaternion, topLevelObject.position);\n        topLevelMatrix.invertToRef(this._tmpMatrix);\n        const wm = object.computeWorldMatrix(false);\n        localMatrix = wm.multiply(this._tmpMatrix);\n      } else {\n        // current top level is same as object level -> only use local scaling\n        Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);\n        localMatrix = this._tmpMatrix;\n      }\n      const faceCount = indices.length / 3;\n      for (let i = 0; i < faceCount; i++) {\n        const triPoints = [];\n        for (let point = 0; point < 3; point++) {\n          let v = new Vector3(vertexPositions[indices[i * 3 + point] * 3 + 0], vertexPositions[indices[i * 3 + point] * 3 + 1], vertexPositions[indices[i * 3 + point] * 3 + 2]);\n          v = Vector3.TransformCoordinates(v, localMatrix);\n          let vec;\n          if (point == 0) {\n            vec = this._tmpAmmoVectorA;\n          } else if (point == 1) {\n            vec = this._tmpAmmoVectorB;\n          } else {\n            vec = this._tmpAmmoVectorC;\n          }\n          vec.setValue(v.x, v.y, v.z);\n          triPoints.push(vec);\n        }\n        btTriangleMesh.addTriangle(triPoints[0], triPoints[1], triPoints[2]);\n        triangleCount++;\n      }\n      object.getChildMeshes().forEach(m => {\n        triangleCount += this._addMeshVerts(btTriangleMesh, topLevelObject, m);\n      });\n    }\n    return triangleCount;\n  }\n  /**\n   * Initialise the soft body vertices to match its object's (mesh) vertices\n   * Softbody vertices (nodes) are in world space and to match this\n   * The object's position and rotation is set to zero and so its vertices are also then set in world space\n   * @param impostor to create the softbody for\n   */\n  _softVertexData(impostor) {\n    const object = impostor.object;\n    if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\n      let indices = object.getIndices();\n      if (!indices) {\n        indices = [];\n      }\n      let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\n      if (!vertexPositions) {\n        vertexPositions = [];\n      }\n      let vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);\n      if (!vertexNormals) {\n        vertexNormals = [];\n      }\n      object.computeWorldMatrix(false);\n      const newPoints = [];\n      const newNorms = [];\n      for (let i = 0; i < vertexPositions.length; i += 3) {\n        let v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);\n        let n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);\n        v = Vector3.TransformCoordinates(v, object.getWorldMatrix());\n        n = Vector3.TransformNormal(n, object.getWorldMatrix());\n        newPoints.push(v.x, v.y, v.z);\n        newNorms.push(n.x, n.y, n.z);\n      }\n      const vertex_data = new VertexData();\n      vertex_data.positions = newPoints;\n      vertex_data.normals = newNorms;\n      vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);\n      vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);\n      if (object && object.getIndices) {\n        vertex_data.indices = object.getIndices();\n      }\n      vertex_data.applyToMesh(object);\n      object.position = Vector3.Zero();\n      object.rotationQuaternion = null;\n      object.rotation = Vector3.Zero();\n      object.computeWorldMatrix(true);\n      return vertex_data;\n    }\n    return VertexData.ExtractFromMesh(object);\n  }\n  /**\n   * Create an impostor's soft body\n   * @param impostor to create the softbody for\n   */\n  _createSoftbody(impostor) {\n    const object = impostor.object;\n    if (object && object.getIndices) {\n      let indices = object.getIndices();\n      if (!indices) {\n        indices = [];\n      }\n      const vertex_data = this._softVertexData(impostor);\n      const vertexPositions = vertex_data.positions;\n      const vertexNormals = vertex_data.normals;\n      if (vertexPositions === null || vertexNormals === null) {\n        return new this.bjsAMMO.btCompoundShape();\n      } else {\n        const triPoints = [];\n        const triNorms = [];\n        for (let i = 0; i < vertexPositions.length; i += 3) {\n          const v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);\n          const n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);\n          triPoints.push(v.x, v.y, -v.z);\n          triNorms.push(n.x, n.y, -n.z);\n        }\n        const softBody = new this.bjsAMMO.btSoftBodyHelpers().CreateFromTriMesh(this.world.getWorldInfo(), triPoints, object.getIndices(), indices.length / 3, true);\n        const nbVertices = vertexPositions.length / 3;\n        const bodyVertices = softBody.get_m_nodes();\n        let node;\n        let nodeNormals;\n        for (let i = 0; i < nbVertices; i++) {\n          node = bodyVertices.at(i);\n          nodeNormals = node.get_m_n();\n          nodeNormals.setX(triNorms[3 * i]);\n          nodeNormals.setY(triNorms[3 * i + 1]);\n          nodeNormals.setZ(triNorms[3 * i + 2]);\n        }\n        return softBody;\n      }\n    }\n  }\n  /**\n   * Create cloth for an impostor\n   * @param impostor to create the softbody for\n   */\n  _createCloth(impostor) {\n    const object = impostor.object;\n    if (object && object.getIndices) {\n      let indices = object.getIndices();\n      if (!indices) {\n        indices = [];\n      }\n      const vertex_data = this._softVertexData(impostor);\n      const vertexPositions = vertex_data.positions;\n      const vertexNormals = vertex_data.normals;\n      if (vertexPositions === null || vertexNormals === null) {\n        return new this.bjsAMMO.btCompoundShape();\n      } else {\n        const len = vertexPositions.length;\n        const segments = Math.sqrt(len / 3);\n        impostor.segments = segments;\n        const segs = segments - 1;\n        this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);\n        this._tmpAmmoVectorB.setValue(vertexPositions[3 * segs], vertexPositions[3 * segs + 1], vertexPositions[3 * segs + 2]);\n        this._tmpAmmoVectorD.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);\n        this._tmpAmmoVectorC.setValue(vertexPositions[len - 3 - 3 * segs], vertexPositions[len - 2 - 3 * segs], vertexPositions[len - 1 - 3 * segs]);\n        const clothBody = new this.bjsAMMO.btSoftBodyHelpers().CreatePatch(this.world.getWorldInfo(), this._tmpAmmoVectorA, this._tmpAmmoVectorB, this._tmpAmmoVectorC, this._tmpAmmoVectorD, segments, segments, impostor.getParam(\"fixedPoints\"), true);\n        return clothBody;\n      }\n    }\n  }\n  /**\n   * Create rope for an impostor\n   * @param impostor to create the softbody for\n   */\n  _createRope(impostor) {\n    let len;\n    let segments;\n    const vertex_data = this._softVertexData(impostor);\n    const vertexPositions = vertex_data.positions;\n    const vertexNormals = vertex_data.normals;\n    if (vertexPositions === null || vertexNormals === null) {\n      return new this.bjsAMMO.btCompoundShape();\n    }\n    //force the mesh to be updatable\n    vertex_data.applyToMesh(impostor.object, true);\n    impostor._isFromLine = true;\n    // If in lines mesh all normals will be zero\n    const vertexSquared = vertexNormals.map(x => x * x);\n    const reducer = (accumulator, currentValue) => accumulator + currentValue;\n    const reduced = vertexSquared.reduce(reducer);\n    if (reduced === 0) {\n      // line mesh\n      len = vertexPositions.length;\n      segments = len / 3 - 1;\n      this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);\n      this._tmpAmmoVectorB.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);\n    } else {\n      //extruded mesh\n      impostor._isFromLine = false;\n      const pathVectors = impostor.getParam(\"path\");\n      const shape = impostor.getParam(\"shape\");\n      if (shape === null) {\n        Logger.Warn(\"No shape available for extruded mesh\");\n        return new this.bjsAMMO.btCompoundShape();\n      }\n      len = pathVectors.length;\n      segments = len - 1;\n      this._tmpAmmoVectorA.setValue(pathVectors[0].x, pathVectors[0].y, pathVectors[0].z);\n      this._tmpAmmoVectorB.setValue(pathVectors[len - 1].x, pathVectors[len - 1].y, pathVectors[len - 1].z);\n    }\n    impostor.segments = segments;\n    let fixedPoints = impostor.getParam(\"fixedPoints\");\n    fixedPoints = fixedPoints > 3 ? 3 : fixedPoints;\n    const ropeBody = new this.bjsAMMO.btSoftBodyHelpers().CreateRope(this.world.getWorldInfo(), this._tmpAmmoVectorA, this._tmpAmmoVectorB, segments - 1, fixedPoints);\n    ropeBody.get_m_cfg().set_collisions(0x11);\n    return ropeBody;\n  }\n  /**\n   * Create a custom physics impostor shape using the plugin's onCreateCustomShape handler\n   * @param impostor to create the custom physics shape for\n   */\n  _createCustom(impostor) {\n    let returnValue = null;\n    if (this.onCreateCustomShape) {\n      returnValue = this.onCreateCustomShape(impostor);\n    }\n    if (returnValue == null) {\n      returnValue = new this.bjsAMMO.btCompoundShape();\n    }\n    return returnValue;\n  }\n  // adds all verticies (including child verticies) to the convex hull shape\n  _addHullVerts(btConvexHullShape, topLevelObject, object) {\n    let triangleCount = 0;\n    if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\n      let indices = object.getIndices();\n      if (!indices) {\n        indices = [];\n      }\n      let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\n      if (!vertexPositions) {\n        vertexPositions = [];\n      }\n      object.computeWorldMatrix(false);\n      const faceCount = indices.length / 3;\n      for (let i = 0; i < faceCount; i++) {\n        const triPoints = [];\n        for (let point = 0; point < 3; point++) {\n          let v = new Vector3(vertexPositions[indices[i * 3 + point] * 3 + 0], vertexPositions[indices[i * 3 + point] * 3 + 1], vertexPositions[indices[i * 3 + point] * 3 + 2]);\n          // Adjust for initial scaling\n          Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);\n          v = Vector3.TransformCoordinates(v, this._tmpMatrix);\n          let vec;\n          if (point == 0) {\n            vec = this._tmpAmmoVectorA;\n          } else if (point == 1) {\n            vec = this._tmpAmmoVectorB;\n          } else {\n            vec = this._tmpAmmoVectorC;\n          }\n          vec.setValue(v.x, v.y, v.z);\n          triPoints.push(vec);\n        }\n        btConvexHullShape.addPoint(triPoints[0], true);\n        btConvexHullShape.addPoint(triPoints[1], true);\n        btConvexHullShape.addPoint(triPoints[2], true);\n        triangleCount++;\n      }\n      object.getChildMeshes().forEach(m => {\n        triangleCount += this._addHullVerts(btConvexHullShape, topLevelObject, m);\n      });\n    }\n    return triangleCount;\n  }\n  _createShape(impostor, ignoreChildren = false) {\n    const object = impostor.object;\n    let returnValue;\n    const impostorExtents = impostor.getObjectExtents();\n    if (!ignoreChildren) {\n      const meshChildren = impostor.object.getChildMeshes ? impostor.object.getChildMeshes(true) : [];\n      returnValue = new this.bjsAMMO.btCompoundShape();\n      // Add shape of all children to the compound shape\n      let childrenAdded = 0;\n      meshChildren.forEach(childMesh => {\n        const childImpostor = childMesh.getPhysicsImpostor();\n        if (childImpostor) {\n          if (childImpostor.type == PhysicsImpostor.MeshImpostor) {\n            throw \"A child MeshImpostor is not supported. Only primitive impostors are supported as children (eg. box or sphere)\";\n          }\n          const shape = this._createShape(childImpostor);\n          // Position needs to be scaled based on parent's scaling\n          const parentMat = childMesh.parent.getWorldMatrix().clone();\n          const s = new Vector3();\n          parentMat.decompose(s);\n          this._tmpAmmoTransform.getOrigin().setValue(childMesh.position.x * s.x, childMesh.position.y * s.y, childMesh.position.z * s.z);\n          this._tmpAmmoQuaternion.setValue(childMesh.rotationQuaternion.x, childMesh.rotationQuaternion.y, childMesh.rotationQuaternion.z, childMesh.rotationQuaternion.w);\n          this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);\n          returnValue.addChildShape(this._tmpAmmoTransform, shape);\n          childImpostor.dispose();\n          childrenAdded++;\n        }\n      });\n      if (childrenAdded > 0) {\n        // Add parents shape as a child if present\n        if (impostor.type != PhysicsImpostor.NoImpostor) {\n          const shape = this._createShape(impostor, true);\n          if (shape) {\n            this._tmpAmmoTransform.getOrigin().setValue(0, 0, 0);\n            this._tmpAmmoQuaternion.setValue(0, 0, 0, 1);\n            this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);\n            returnValue.addChildShape(this._tmpAmmoTransform, shape);\n          }\n        }\n        return returnValue;\n      } else {\n        // If no children with impostors create the actual shape below instead\n        this.bjsAMMO.destroy(returnValue);\n        returnValue = null;\n      }\n    }\n    switch (impostor.type) {\n      case PhysicsImpostor.SphereImpostor:\n        // Is there a better way to compare floats number? With an epsilon or with a Math function\n        if (Scalar.WithinEpsilon(impostorExtents.x, impostorExtents.y, 0.0001) && Scalar.WithinEpsilon(impostorExtents.x, impostorExtents.z, 0.0001)) {\n          returnValue = new this.bjsAMMO.btSphereShape(impostorExtents.x / 2);\n        } else {\n          // create a btMultiSphereShape because it's not possible to set a local scaling on a btSphereShape\n          const positions = [new this.bjsAMMO.btVector3(0, 0, 0)];\n          const radii = [1];\n          returnValue = new this.bjsAMMO.btMultiSphereShape(positions, radii, 1);\n          returnValue.setLocalScaling(new this.bjsAMMO.btVector3(impostorExtents.x / 2, impostorExtents.y / 2, impostorExtents.z / 2));\n        }\n        break;\n      case PhysicsImpostor.CapsuleImpostor:\n        {\n          // https://pybullet.org/Bullet/BulletFull/classbtCapsuleShape.html#details\n          // Height is just the height between the center of each 'sphere' of the capsule caps\n          const capRadius = impostorExtents.x / 2;\n          returnValue = new this.bjsAMMO.btCapsuleShape(capRadius, impostorExtents.y - capRadius * 2);\n        }\n        break;\n      case PhysicsImpostor.CylinderImpostor:\n        this._tmpAmmoVectorA.setValue(impostorExtents.x / 2, impostorExtents.y / 2, impostorExtents.z / 2);\n        returnValue = new this.bjsAMMO.btCylinderShape(this._tmpAmmoVectorA);\n        break;\n      case PhysicsImpostor.PlaneImpostor:\n      case PhysicsImpostor.BoxImpostor:\n        this._tmpAmmoVectorA.setValue(impostorExtents.x / 2, impostorExtents.y / 2, impostorExtents.z / 2);\n        returnValue = new this.bjsAMMO.btBoxShape(this._tmpAmmoVectorA);\n        break;\n      case PhysicsImpostor.MeshImpostor:\n        {\n          if (impostor.getParam(\"mass\") == 0) {\n            // Only create btBvhTriangleMeshShape if the impostor is static\n            // See https://pybullet.org/Bullet/phpBB3/viewtopic.php?t=7283\n            if (this.onCreateCustomMeshImpostor) {\n              returnValue = this.onCreateCustomMeshImpostor(impostor);\n            } else {\n              const triMesh = new this.bjsAMMO.btTriangleMesh();\n              impostor._pluginData.toDispose.push(triMesh);\n              const triangleCount = this._addMeshVerts(triMesh, object, object);\n              if (triangleCount == 0) {\n                returnValue = new this.bjsAMMO.btCompoundShape();\n              } else {\n                returnValue = new this.bjsAMMO.btBvhTriangleMeshShape(triMesh);\n              }\n            }\n            break;\n          }\n        }\n      // Otherwise create convexHullImpostor\n      // eslint-disable-next-line no-fallthrough\n      case PhysicsImpostor.ConvexHullImpostor:\n        {\n          if (this.onCreateCustomConvexHullImpostor) {\n            returnValue = this.onCreateCustomConvexHullImpostor(impostor);\n          } else {\n            const convexHull = new this.bjsAMMO.btConvexHullShape();\n            const triangleCount = this._addHullVerts(convexHull, object, object);\n            if (triangleCount == 0) {\n              // Cleanup Unused Convex Hull Shape\n              impostor._pluginData.toDispose.push(convexHull);\n              returnValue = new this.bjsAMMO.btCompoundShape();\n            } else {\n              returnValue = convexHull;\n            }\n          }\n          break;\n        }\n      case PhysicsImpostor.NoImpostor:\n        // Fill with sphere but collision is disabled on the rigid body in generatePhysicsBody, using an empty shape caused unexpected movement with joints\n        returnValue = new this.bjsAMMO.btSphereShape(impostorExtents.x / 2);\n        break;\n      case PhysicsImpostor.CustomImpostor:\n        // Only usable when the plugin's onCreateCustomShape is set\n        returnValue = this._createCustom(impostor);\n        break;\n      case PhysicsImpostor.SoftbodyImpostor:\n        // Only usable with a mesh that has sufficient and shared vertices\n        returnValue = this._createSoftbody(impostor);\n        break;\n      case PhysicsImpostor.ClothImpostor:\n        // Only usable with a ground mesh that has sufficient and shared vertices\n        returnValue = this._createCloth(impostor);\n        break;\n      case PhysicsImpostor.RopeImpostor:\n        // Only usable with a line mesh or an extruded mesh that is updatable\n        returnValue = this._createRope(impostor);\n        break;\n      default:\n        Logger.Warn(\"The impostor type is not currently supported by the ammo plugin.\");\n        break;\n    }\n    return returnValue;\n  }\n  /**\n   * Sets the mesh body position/rotation from the babylon impostor\n   * @param impostor imposter containing the physics body and babylon object\n   */\n  setTransformationFromPhysicsBody(impostor) {\n    impostor.physicsBody.getMotionState().getWorldTransform(this._tmpAmmoTransform);\n    impostor.object.position.set(this._tmpAmmoTransform.getOrigin().x(), this._tmpAmmoTransform.getOrigin().y(), this._tmpAmmoTransform.getOrigin().z());\n    if (!impostor.object.rotationQuaternion) {\n      if (impostor.object.rotation) {\n        this._tmpQuaternion.set(this._tmpAmmoTransform.getRotation().x(), this._tmpAmmoTransform.getRotation().y(), this._tmpAmmoTransform.getRotation().z(), this._tmpAmmoTransform.getRotation().w());\n        this._tmpQuaternion.toEulerAnglesToRef(impostor.object.rotation);\n      }\n    } else {\n      impostor.object.rotationQuaternion.set(this._tmpAmmoTransform.getRotation().x(), this._tmpAmmoTransform.getRotation().y(), this._tmpAmmoTransform.getRotation().z(), this._tmpAmmoTransform.getRotation().w());\n    }\n  }\n  /**\n   * Sets the babylon object's position/rotation from the physics body's position/rotation\n   * @param impostor imposter containing the physics body and babylon object\n   * @param newPosition new position\n   * @param newRotation new rotation\n   */\n  setPhysicsBodyTransformation(impostor, newPosition, newRotation) {\n    const trans = impostor.physicsBody.getWorldTransform();\n    // If rotation/position has changed update and activate rigged body\n    if (Math.abs(trans.getOrigin().x() - newPosition.x) > Epsilon || Math.abs(trans.getOrigin().y() - newPosition.y) > Epsilon || Math.abs(trans.getOrigin().z() - newPosition.z) > Epsilon || Math.abs(trans.getRotation().x() - newRotation.x) > Epsilon || Math.abs(trans.getRotation().y() - newRotation.y) > Epsilon || Math.abs(trans.getRotation().z() - newRotation.z) > Epsilon || Math.abs(trans.getRotation().w() - newRotation.w) > Epsilon) {\n      this._tmpAmmoVectorA.setValue(newPosition.x, newPosition.y, newPosition.z);\n      trans.setOrigin(this._tmpAmmoVectorA);\n      this._tmpAmmoQuaternion.setValue(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\n      trans.setRotation(this._tmpAmmoQuaternion);\n      impostor.physicsBody.setWorldTransform(trans);\n      if (impostor.mass == 0) {\n        // Kinematic objects must be updated using motion state\n        const motionState = impostor.physicsBody.getMotionState();\n        if (motionState) {\n          motionState.setWorldTransform(trans);\n        }\n      } else {\n        impostor.physicsBody.activate();\n      }\n    }\n  }\n  /**\n   * If this plugin is supported\n   * @returns true if its supported\n   */\n  isSupported() {\n    return this.bjsAMMO !== undefined;\n  }\n  /**\n   * Sets the linear velocity of the physics body\n   * @param impostor imposter to set the velocity on\n   * @param velocity velocity to set\n   */\n  setLinearVelocity(impostor, velocity) {\n    this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);\n    if (impostor.soft) {\n      impostor.physicsBody.linearVelocity(this._tmpAmmoVectorA);\n    } else {\n      impostor.physicsBody.setLinearVelocity(this._tmpAmmoVectorA);\n    }\n  }\n  /**\n   * Sets the angular velocity of the physics body\n   * @param impostor imposter to set the velocity on\n   * @param velocity velocity to set\n   */\n  setAngularVelocity(impostor, velocity) {\n    this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);\n    if (impostor.soft) {\n      impostor.physicsBody.angularVelocity(this._tmpAmmoVectorA);\n    } else {\n      impostor.physicsBody.setAngularVelocity(this._tmpAmmoVectorA);\n    }\n  }\n  /**\n   * gets the linear velocity\n   * @param impostor imposter to get linear velocity from\n   * @returns linear velocity\n   */\n  getLinearVelocity(impostor) {\n    let v;\n    if (impostor.soft) {\n      v = impostor.physicsBody.linearVelocity();\n    } else {\n      v = impostor.physicsBody.getLinearVelocity();\n    }\n    if (!v) {\n      return null;\n    }\n    const result = new Vector3(v.x(), v.y(), v.z());\n    this.bjsAMMO.destroy(v);\n    return result;\n  }\n  /**\n   * gets the angular velocity\n   * @param impostor imposter to get angular velocity from\n   * @returns angular velocity\n   */\n  getAngularVelocity(impostor) {\n    let v;\n    if (impostor.soft) {\n      v = impostor.physicsBody.angularVelocity();\n    } else {\n      v = impostor.physicsBody.getAngularVelocity();\n    }\n    if (!v) {\n      return null;\n    }\n    const result = new Vector3(v.x(), v.y(), v.z());\n    this.bjsAMMO.destroy(v);\n    return result;\n  }\n  /**\n   * Sets the mass of physics body\n   * @param impostor imposter to set the mass on\n   * @param mass mass to set\n   */\n  setBodyMass(impostor, mass) {\n    if (impostor.soft) {\n      impostor.physicsBody.setTotalMass(mass, false);\n    } else {\n      impostor.physicsBody.setMassProps(mass);\n    }\n    impostor._pluginData.mass = mass;\n  }\n  /**\n   * Gets the mass of the physics body\n   * @param impostor imposter to get the mass from\n   * @returns mass\n   */\n  getBodyMass(impostor) {\n    return impostor._pluginData.mass || 0;\n  }\n  /**\n   * Gets friction of the impostor\n   * @param impostor impostor to get friction from\n   * @returns friction value\n   */\n  getBodyFriction(impostor) {\n    return impostor._pluginData.friction || 0;\n  }\n  /**\n   * Sets friction of the impostor\n   * @param impostor impostor to set friction on\n   * @param friction friction value\n   */\n  setBodyFriction(impostor, friction) {\n    if (impostor.soft) {\n      impostor.physicsBody.get_m_cfg().set_kDF(friction);\n    } else {\n      impostor.physicsBody.setFriction(friction);\n    }\n    impostor._pluginData.friction = friction;\n  }\n  /**\n   * Gets restitution of the impostor\n   * @param impostor impostor to get restitution from\n   * @returns restitution value\n   */\n  getBodyRestitution(impostor) {\n    return impostor._pluginData.restitution || 0;\n  }\n  /**\n   * Sets restitution of the impostor\n   * @param impostor impostor to set resitution on\n   * @param restitution resitution value\n   */\n  setBodyRestitution(impostor, restitution) {\n    impostor.physicsBody.setRestitution(restitution);\n    impostor._pluginData.restitution = restitution;\n  }\n  /**\n   * Gets pressure inside the impostor\n   * @param impostor impostor to get pressure from\n   * @returns pressure value\n   */\n  getBodyPressure(impostor) {\n    if (!impostor.soft) {\n      Logger.Warn(\"Pressure is not a property of a rigid body\");\n      return 0;\n    }\n    return impostor._pluginData.pressure || 0;\n  }\n  /**\n   * Sets pressure inside a soft body impostor\n   * Cloth and rope must remain 0 pressure\n   * @param impostor impostor to set pressure on\n   * @param pressure pressure value\n   */\n  setBodyPressure(impostor, pressure) {\n    if (impostor.soft) {\n      if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {\n        impostor.physicsBody.get_m_cfg().set_kPR(pressure);\n        impostor._pluginData.pressure = pressure;\n      } else {\n        impostor.physicsBody.get_m_cfg().set_kPR(0);\n        impostor._pluginData.pressure = 0;\n      }\n    } else {\n      Logger.Warn(\"Pressure can only be applied to a softbody\");\n    }\n  }\n  /**\n   * Gets stiffness of the impostor\n   * @param impostor impostor to get stiffness from\n   * @returns pressure value\n   */\n  getBodyStiffness(impostor) {\n    if (!impostor.soft) {\n      Logger.Warn(\"Stiffness is not a property of a rigid body\");\n      return 0;\n    }\n    return impostor._pluginData.stiffness || 0;\n  }\n  /**\n   * Sets stiffness of the impostor\n   * @param impostor impostor to set stiffness on\n   * @param stiffness stiffness value from 0 to 1\n   */\n  setBodyStiffness(impostor, stiffness) {\n    if (impostor.soft) {\n      stiffness = stiffness < 0 ? 0 : stiffness;\n      stiffness = stiffness > 1 ? 1 : stiffness;\n      impostor.physicsBody.get_m_materials().at(0).set_m_kLST(stiffness);\n      impostor._pluginData.stiffness = stiffness;\n    } else {\n      Logger.Warn(\"Stiffness cannot be applied to a rigid body\");\n    }\n  }\n  /**\n   * Gets velocityIterations of the impostor\n   * @param impostor impostor to get velocity iterations from\n   * @returns velocityIterations value\n   */\n  getBodyVelocityIterations(impostor) {\n    if (!impostor.soft) {\n      Logger.Warn(\"Velocity iterations is not a property of a rigid body\");\n      return 0;\n    }\n    return impostor._pluginData.velocityIterations || 0;\n  }\n  /**\n   * Sets velocityIterations of the impostor\n   * @param impostor impostor to set velocity iterations on\n   * @param velocityIterations velocityIterations value\n   */\n  setBodyVelocityIterations(impostor, velocityIterations) {\n    if (impostor.soft) {\n      velocityIterations = velocityIterations < 0 ? 0 : velocityIterations;\n      impostor.physicsBody.get_m_cfg().set_viterations(velocityIterations);\n      impostor._pluginData.velocityIterations = velocityIterations;\n    } else {\n      Logger.Warn(\"Velocity iterations cannot be applied to a rigid body\");\n    }\n  }\n  /**\n   * Gets positionIterations of the impostor\n   * @param impostor impostor to get position iterations from\n   * @returns positionIterations value\n   */\n  getBodyPositionIterations(impostor) {\n    if (!impostor.soft) {\n      Logger.Warn(\"Position iterations is not a property of a rigid body\");\n      return 0;\n    }\n    return impostor._pluginData.positionIterations || 0;\n  }\n  /**\n   * Sets positionIterations of the impostor\n   * @param impostor impostor to set position on\n   * @param positionIterations positionIterations value\n   */\n  setBodyPositionIterations(impostor, positionIterations) {\n    if (impostor.soft) {\n      positionIterations = positionIterations < 0 ? 0 : positionIterations;\n      impostor.physicsBody.get_m_cfg().set_piterations(positionIterations);\n      impostor._pluginData.positionIterations = positionIterations;\n    } else {\n      Logger.Warn(\"Position iterations cannot be applied to a rigid body\");\n    }\n  }\n  /**\n   * Append an anchor to a cloth object\n   * @param impostor is the cloth impostor to add anchor to\n   * @param otherImpostor is the rigid impostor to anchor to\n   * @param width ratio across width from 0 to 1\n   * @param height ratio up height from 0 to 1\n   * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little stretch\n   * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\n   */\n  appendAnchor(impostor, otherImpostor, width, height, influence = 1, noCollisionBetweenLinkedBodies = false) {\n    const segs = impostor.segments;\n    const nbAcross = Math.round((segs - 1) * width);\n    const nbUp = Math.round((segs - 1) * height);\n    const nbDown = segs - 1 - nbUp;\n    const node = nbAcross + segs * nbDown;\n    impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);\n  }\n  /**\n   * Append an hook to a rope object\n   * @param impostor is the rope impostor to add hook to\n   * @param otherImpostor is the rigid impostor to hook to\n   * @param length ratio along the rope from 0 to 1\n   * @param influence the elasticity between soft impostor and anchor from 0, very stretchy to 1, little stretch\n   * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\n   */\n  appendHook(impostor, otherImpostor, length, influence = 1, noCollisionBetweenLinkedBodies = false) {\n    const node = Math.round(impostor.segments * length);\n    impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);\n  }\n  /**\n   * Sleeps the physics body and stops it from being active\n   * @param impostor impostor to sleep\n   */\n  sleepBody(impostor) {\n    impostor.physicsBody.forceActivationState(0);\n  }\n  /**\n   * Activates the physics body\n   * @param impostor impostor to activate\n   */\n  wakeUpBody(impostor) {\n    impostor.physicsBody.activate();\n  }\n  /**\n   * Updates the distance parameters of the joint\n   */\n  updateDistanceJoint() {\n    Logger.Warn(\"updateDistanceJoint is not currently supported by the Ammo physics plugin\");\n  }\n  /**\n   * Sets a motor on the joint\n   * @param joint joint to set motor on\n   * @param speed speed of the motor\n   * @param maxForce maximum force of the motor\n   */\n  setMotor(joint, speed, maxForce) {\n    joint.physicsJoint.enableAngularMotor(true, speed, maxForce);\n  }\n  /**\n   * Sets the motors limit\n   */\n  setLimit() {\n    Logger.Warn(\"setLimit is not currently supported by the Ammo physics plugin\");\n  }\n  /**\n   * Syncs the position and rotation of a mesh with the impostor\n   * @param mesh mesh to sync\n   * @param impostor impostor to update the mesh with\n   */\n  syncMeshWithImpostor(mesh, impostor) {\n    const body = impostor.physicsBody;\n    body.getMotionState().getWorldTransform(this._tmpAmmoTransform);\n    mesh.position.x = this._tmpAmmoTransform.getOrigin().x();\n    mesh.position.y = this._tmpAmmoTransform.getOrigin().y();\n    mesh.position.z = this._tmpAmmoTransform.getOrigin().z();\n    if (mesh.rotationQuaternion) {\n      mesh.rotationQuaternion.x = this._tmpAmmoTransform.getRotation().x();\n      mesh.rotationQuaternion.y = this._tmpAmmoTransform.getRotation().y();\n      mesh.rotationQuaternion.z = this._tmpAmmoTransform.getRotation().z();\n      mesh.rotationQuaternion.w = this._tmpAmmoTransform.getRotation().w();\n    }\n  }\n  /**\n   * Gets the radius of the impostor\n   * @param impostor impostor to get radius from\n   * @returns the radius\n   */\n  getRadius(impostor) {\n    const extents = impostor.getObjectExtents();\n    return extents.x / 2;\n  }\n  /**\n   * Gets the box size of the impostor\n   * @param impostor impostor to get box size from\n   * @param result the resulting box size\n   */\n  getBoxSizeToRef(impostor, result) {\n    const extents = impostor.getObjectExtents();\n    result.x = extents.x;\n    result.y = extents.y;\n    result.z = extents.z;\n  }\n  /**\n   * Disposes of the impostor\n   */\n  dispose() {\n    // Dispose of world\n    this.bjsAMMO.destroy(this.world);\n    this.bjsAMMO.destroy(this._solver);\n    this.bjsAMMO.destroy(this._overlappingPairCache);\n    this.bjsAMMO.destroy(this._dispatcher);\n    this.bjsAMMO.destroy(this._collisionConfiguration);\n    // Dispose of temp variables\n    this.bjsAMMO.destroy(this._tmpAmmoVectorA);\n    this.bjsAMMO.destroy(this._tmpAmmoVectorB);\n    this.bjsAMMO.destroy(this._tmpAmmoVectorC);\n    this.bjsAMMO.destroy(this._tmpAmmoTransform);\n    this.bjsAMMO.destroy(this._tmpAmmoQuaternion);\n    this.bjsAMMO.destroy(this._tmpAmmoConcreteContactResultCallback);\n    this.world = null;\n  }\n  /**\n   * Does a raycast in the physics world\n   * @param from where should the ray start?\n   * @param to where should the ray end?\n   * @returns PhysicsRaycastResult\n   */\n  raycast(from, to) {\n    this.raycastToRef(from, to, this._raycastResult);\n    return this._raycastResult;\n  }\n  /**\n   * Does a raycast in the physics world\n   * @param from when should the ray start?\n   * @param to when should the ray end?\n   * @param result resulting PhysicsRaycastResult\n   */\n  raycastToRef(from, to, result) {\n    this._tmpAmmoVectorRCA = new this.bjsAMMO.btVector3(from.x, from.y, from.z);\n    this._tmpAmmoVectorRCB = new this.bjsAMMO.btVector3(to.x, to.y, to.z);\n    const rayCallback = new this.bjsAMMO.ClosestRayResultCallback(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB);\n    this.world.rayTest(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB, rayCallback);\n    result.reset(from, to);\n    if (rayCallback.hasHit()) {\n      // TODO: do we want/need the body? If so, set all the data\n      /*\n      var rigidBody = this.bjsAMMO.btRigidBody.prototype.upcast(\n          rayCallback.get_m_collisionObject()\n      );\n      var body = {};\n      */\n      result.setHitData({\n        x: rayCallback.get_m_hitNormalWorld().x(),\n        y: rayCallback.get_m_hitNormalWorld().y(),\n        z: rayCallback.get_m_hitNormalWorld().z()\n      }, {\n        x: rayCallback.get_m_hitPointWorld().x(),\n        y: rayCallback.get_m_hitPointWorld().y(),\n        z: rayCallback.get_m_hitPointWorld().z()\n      });\n      result.calculateHitDistance();\n    }\n    this.bjsAMMO.destroy(rayCallback);\n    this.bjsAMMO.destroy(this._tmpAmmoVectorRCA);\n    this.bjsAMMO.destroy(this._tmpAmmoVectorRCB);\n  }\n}\nAmmoJSPlugin._DISABLE_COLLISION_FLAG = 4;\nAmmoJSPlugin._KINEMATIC_FLAG = 2;\nAmmoJSPlugin._DISABLE_DEACTIVATION_FLAG = 4;","map":{"version":3,"names":["Quaternion","Vector3","Matrix","Logger","PhysicsImpostor","PhysicsJoint","VertexBuffer","VertexData","ExtrudeShape","CreateLines","PhysicsRaycastResult","Scalar","Epsilon","AmmoJSPlugin","constructor","_useDeltaForWorldStep","ammoInjection","Ammo","overlappingPairCache","bjsAMMO","name","_timeStep","_fixedTimeStep","_maxSteps","_tmpQuaternion","_tmpContactCallbackResult","_tmpContactPoint","_tmpContactNormal","_tmpVec3","_tmpMatrix","Error","isSupported","_collisionConfiguration","btSoftBodyRigidBodyCollisionConfiguration","_dispatcher","btCollisionDispatcher","_overlappingPairCache","btDbvtBroadphase","_solver","btSequentialImpulseConstraintSolver","_softBodySolver","btDefaultSoftBodySolver","world","btSoftRigidDynamicsWorld","_tmpAmmoConcreteContactResultCallback","ConcreteContactResultCallback","addSingleResult","contactPoint","wrapPointer","btManifoldPoint","worldPoint","getPositionWorldOnA","worldNormal","m_normalWorldOnB","x","y","z","_tmpContactImpulse","getAppliedImpulse","_tmpContactDistance","getDistance","_raycastResult","_tmpAmmoTransform","btTransform","setIdentity","_tmpAmmoQuaternion","btQuaternion","_tmpAmmoVectorA","btVector3","_tmpAmmoVectorB","_tmpAmmoVectorC","_tmpAmmoVectorD","getPluginVersion","setGravity","gravity","setValue","getWorldInfo","set_m_gravity","setTimeStep","timeStep","setFixedTimeStep","fixedTimeStep","setMaxSteps","maxSteps","getTimeStep","_isImpostorInContact","impostor","contactTest","physicsBody","_isImpostorPairInContact","impostorA","impostorB","contactPairTest","_stepSimulation","stepSimulation","executeStep","delta","impostors","soft","beforeStep","mainImpostor","_afterSoftStep","afterStep","_onPhysicsCollideCallbacks","length","collideCallback","otherImpostor","otherImpostors","isActive","onCollide","body","point","distance","impulse","normal","type","RopeImpostor","_ropeStep","_softbodyOrClothStep","bodyVertices","get_m_nodes","nbVertices","size","node","nodePositions","path","Array","n","at","get_m_x","push","object","shape","getParam","_isFromLine","points","instance","normalDirection","ClothImpostor","vertexPositions","getVerticesData","PositionKind","vertexNormals","NormalKind","nx","ny","nz","nodeNormals","get_m_n","vertex_data","positions","normals","uvs","UVKind","colors","ColorKind","getIndices","indices","applyToMesh","applyImpulse","force","activate","getWorldMatrix","subtractInPlace","getTranslation","Warn","applyForce","localTranslation","generatePhysicsBody","_pluginData","toDispose","parent","removePhysicsBody","forceUpdate","isBodyInitRequired","colShape","_createShape","mass","get_m_cfg","set_collisions","set_kDP","castObject","btCollisionObject","getCollisionShape","setMargin","setActivationState","_DISABLE_DEACTIVATION_FLAG","addSoftBody","setBodyPressure","SoftbodyImpostor","setBodyStiffness","setBodyVelocityIterations","setBodyPositionIterations","localInertia","startTransform","computeWorldMatrix","calculateLocalInertia","position","rotationQuaternion","w","setOrigin","setRotation","myMotionState","btDefaultMotionState","rbInfo","btRigidBodyConstructionInfo","btRigidBody","setCollisionFlags","getCollisionFlags","_KINEMATIC_FLAG","NoImpostor","getChildShape","_DISABLE_COLLISION_FLAG","MeshImpostor","boundingInfo","getBoundingInfo","copyFrom","getAbsolutePosition","boundingBox","centerWorld","scaling","setDeltaPosition","group","mask","addRigidBody","concat","setBodyRestitution","setBodyFriction","removeSoftBody","removeRigidBody","forEach","d","destroy","generateJoint","impostorJoint","mainBody","connectedBody","connectedImpostor","jointData","joint","mainPivot","connectedPivot","DistanceJoint","maxDistance","btPoint2PointConstraint","HingeJoint","mainAxis","connectedAxis","btHingeConstraint","BallAndSocketJoint","addConstraint","collision","physicsJoint","removeJoint","removeConstraint","_addMeshVerts","btTriangleMesh","topLevelObject","triangleCount","getChildMeshes","localMatrix","topLevelQuaternion","rotation","FromEulerAngles","Identity","topLevelMatrix","Compose","One","invertToRef","wm","multiply","ScalingToRef","faceCount","i","triPoints","v","TransformCoordinates","vec","addTriangle","m","_softVertexData","newPoints","newNorms","TransformNormal","Zero","ExtractFromMesh","_createSoftbody","btCompoundShape","triNorms","softBody","btSoftBodyHelpers","CreateFromTriMesh","setX","setY","setZ","_createCloth","len","segments","Math","sqrt","segs","clothBody","CreatePatch","_createRope","vertexSquared","map","reducer","accumulator","currentValue","reduced","reduce","pathVectors","fixedPoints","ropeBody","CreateRope","_createCustom","returnValue","onCreateCustomShape","_addHullVerts","btConvexHullShape","addPoint","ignoreChildren","impostorExtents","getObjectExtents","meshChildren","childrenAdded","childMesh","childImpostor","getPhysicsImpostor","parentMat","clone","s","decompose","getOrigin","addChildShape","dispose","SphereImpostor","WithinEpsilon","btSphereShape","radii","btMultiSphereShape","setLocalScaling","CapsuleImpostor","capRadius","btCapsuleShape","CylinderImpostor","btCylinderShape","PlaneImpostor","BoxImpostor","btBoxShape","onCreateCustomMeshImpostor","triMesh","btBvhTriangleMeshShape","ConvexHullImpostor","onCreateCustomConvexHullImpostor","convexHull","CustomImpostor","setTransformationFromPhysicsBody","getMotionState","getWorldTransform","set","getRotation","toEulerAnglesToRef","setPhysicsBodyTransformation","newPosition","newRotation","trans","abs","setWorldTransform","motionState","undefined","setLinearVelocity","velocity","linearVelocity","setAngularVelocity","angularVelocity","getLinearVelocity","result","getAngularVelocity","setBodyMass","setTotalMass","setMassProps","getBodyMass","getBodyFriction","friction","set_kDF","setFriction","getBodyRestitution","restitution","setRestitution","getBodyPressure","pressure","set_kPR","getBodyStiffness","stiffness","get_m_materials","set_m_kLST","getBodyVelocityIterations","velocityIterations","set_viterations","getBodyPositionIterations","positionIterations","set_piterations","appendAnchor","width","height","influence","noCollisionBetweenLinkedBodies","nbAcross","round","nbUp","nbDown","appendHook","sleepBody","forceActivationState","wakeUpBody","updateDistanceJoint","setMotor","speed","maxForce","enableAngularMotor","setLimit","syncMeshWithImpostor","mesh","getRadius","extents","getBoxSizeToRef","raycast","from","to","raycastToRef","_tmpAmmoVectorRCA","_tmpAmmoVectorRCB","rayCallback","ClosestRayResultCallback","rayTest","reset","hasHit","setHitData","get_m_hitNormalWorld","get_m_hitPointWorld","calculateHitDistance"],"sources":["../../../../../../dev/core/src/Physics/v1/Plugins/ammoJSPlugin.ts"],"sourcesContent":["import { Quaternion, Vector3, Matrix } from \"../../../Maths/math.vector\";\r\nimport type { IPhysicsEnginePlugin, PhysicsImpostorJoint } from \"../IPhysicsEnginePlugin\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport type { IPhysicsEnabledObject } from \"../physicsImpostor\";\r\nimport { PhysicsImpostor } from \"../physicsImpostor\";\r\nimport type { IMotorEnabledJoint, DistanceJointData } from \"../physicsJoint\";\r\nimport { PhysicsJoint } from \"../physicsJoint\";\r\nimport { VertexBuffer } from \"../../../Buffers/buffer\";\r\nimport { VertexData } from \"../../../Meshes/mesh.vertexData\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { AbstractMesh } from \"../../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../../Meshes/mesh\";\r\nimport { ExtrudeShape } from \"../../../Meshes/Builders/shapeBuilder\";\r\nimport { CreateLines } from \"../../../Meshes/Builders/linesBuilder\";\r\nimport type { LinesMesh } from \"../../../Meshes/linesMesh\";\r\nimport { PhysicsRaycastResult } from \"../../physicsRaycastResult\";\r\nimport { Scalar } from \"../../../Maths/math.scalar\";\r\nimport { Epsilon } from \"../../../Maths/math.constants\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let Ammo: any;\r\n\r\n/**\r\n * AmmoJS Physics plugin\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n * @see https://github.com/kripken/ammo.js/\r\n */\r\nexport class AmmoJSPlugin implements IPhysicsEnginePlugin {\r\n    /**\r\n     * Reference to the Ammo library\r\n     */\r\n    public bjsAMMO: any = {};\r\n    /**\r\n     * Created ammoJS world which physics bodies are added to\r\n     */\r\n    public world: any;\r\n    /**\r\n     * Name of the plugin\r\n     */\r\n    public name: string = \"AmmoJSPlugin\";\r\n\r\n    private _timeStep: number = 1 / 60;\r\n    private _fixedTimeStep: number = 1 / 60;\r\n    private _maxSteps = 5;\r\n    private _tmpQuaternion = new Quaternion();\r\n    private _tmpAmmoTransform: any;\r\n    private _tmpAmmoQuaternion: any;\r\n    private _tmpAmmoConcreteContactResultCallback: any;\r\n    private _collisionConfiguration: any;\r\n    private _dispatcher: any;\r\n    private _overlappingPairCache: any;\r\n    private _solver: any;\r\n    private _softBodySolver: any;\r\n    private _tmpAmmoVectorA: any;\r\n    private _tmpAmmoVectorB: any;\r\n    private _tmpAmmoVectorC: any;\r\n    private _tmpAmmoVectorD: any;\r\n    private _tmpContactCallbackResult = false;\r\n    private _tmpAmmoVectorRCA: any;\r\n    private _tmpAmmoVectorRCB: any;\r\n    private _raycastResult: PhysicsRaycastResult;\r\n    private _tmpContactPoint = new Vector3();\r\n    private _tmpContactNormal = new Vector3();\r\n    private _tmpContactDistance: number;\r\n    private _tmpContactImpulse: number;\r\n    private _tmpVec3 = new Vector3();\r\n\r\n    private static readonly _DISABLE_COLLISION_FLAG = 4;\r\n    private static readonly _KINEMATIC_FLAG = 2;\r\n    private static readonly _DISABLE_DEACTIVATION_FLAG = 4;\r\n\r\n    /**\r\n     * Initializes the ammoJS plugin\r\n     * @param _useDeltaForWorldStep if the time between frames should be used when calculating physics steps (Default: true)\r\n     * @param ammoInjection can be used to inject your own ammo reference\r\n     * @param overlappingPairCache can be used to specify your own overlapping pair cache\r\n     */\r\n    public constructor(private _useDeltaForWorldStep: boolean = true, ammoInjection: any = Ammo, overlappingPairCache: any = null) {\r\n        if (typeof ammoInjection === \"function\") {\r\n            Logger.Error(\"AmmoJS is not ready. Please make sure you await Ammo() before using the plugin.\");\r\n            return;\r\n        } else {\r\n            this.bjsAMMO = ammoInjection;\r\n        }\r\n\r\n        if (!this.isSupported()) {\r\n            Logger.Error(\"AmmoJS is not available. Please make sure you included the js file.\");\r\n            return;\r\n        }\r\n\r\n        // Initialize the physics world\r\n        this._collisionConfiguration = new this.bjsAMMO.btSoftBodyRigidBodyCollisionConfiguration();\r\n        this._dispatcher = new this.bjsAMMO.btCollisionDispatcher(this._collisionConfiguration);\r\n        this._overlappingPairCache = overlappingPairCache || new this.bjsAMMO.btDbvtBroadphase();\r\n        this._solver = new this.bjsAMMO.btSequentialImpulseConstraintSolver();\r\n        this._softBodySolver = new this.bjsAMMO.btDefaultSoftBodySolver();\r\n        this.world = new this.bjsAMMO.btSoftRigidDynamicsWorld(this._dispatcher, this._overlappingPairCache, this._solver, this._collisionConfiguration, this._softBodySolver);\r\n\r\n        this._tmpAmmoConcreteContactResultCallback = new this.bjsAMMO.ConcreteContactResultCallback();\r\n        this._tmpAmmoConcreteContactResultCallback.addSingleResult = (contactPoint: any) => {\r\n            contactPoint = this.bjsAMMO.wrapPointer(contactPoint, this.bjsAMMO.btManifoldPoint);\r\n            const worldPoint = contactPoint.getPositionWorldOnA();\r\n            const worldNormal = contactPoint.m_normalWorldOnB;\r\n            this._tmpContactPoint.x = worldPoint.x();\r\n            this._tmpContactPoint.y = worldPoint.y();\r\n            this._tmpContactPoint.z = worldPoint.z();\r\n            this._tmpContactNormal.x = worldNormal.x();\r\n            this._tmpContactNormal.y = worldNormal.y();\r\n            this._tmpContactNormal.z = worldNormal.z();\r\n            this._tmpContactImpulse = contactPoint.getAppliedImpulse();\r\n            this._tmpContactDistance = contactPoint.getDistance();\r\n            this._tmpContactCallbackResult = true;\r\n        };\r\n\r\n        this._raycastResult = new PhysicsRaycastResult();\r\n\r\n        // Create temp ammo variables\r\n        this._tmpAmmoTransform = new this.bjsAMMO.btTransform();\r\n        this._tmpAmmoTransform.setIdentity();\r\n        this._tmpAmmoQuaternion = new this.bjsAMMO.btQuaternion(0, 0, 0, 1);\r\n        this._tmpAmmoVectorA = new this.bjsAMMO.btVector3(0, 0, 0);\r\n        this._tmpAmmoVectorB = new this.bjsAMMO.btVector3(0, 0, 0);\r\n        this._tmpAmmoVectorC = new this.bjsAMMO.btVector3(0, 0, 0);\r\n        this._tmpAmmoVectorD = new this.bjsAMMO.btVector3(0, 0, 0);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @returns plugin version\r\n     */\r\n    public getPluginVersion(): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Sets the gravity of the physics world (m/(s^2))\r\n     * @param gravity Gravity to set\r\n     */\r\n    public setGravity(gravity: Vector3): void {\r\n        this._tmpAmmoVectorA.setValue(gravity.x, gravity.y, gravity.z);\r\n        this.world.setGravity(this._tmpAmmoVectorA);\r\n        this.world.getWorldInfo().set_m_gravity(this._tmpAmmoVectorA);\r\n    }\r\n\r\n    /**\r\n     * Amount of time to step forward on each frame (only used if useDeltaForWorldStep is false in the constructor)\r\n     * @param timeStep timestep to use in seconds\r\n     */\r\n    public setTimeStep(timeStep: number) {\r\n        this._timeStep = timeStep;\r\n    }\r\n\r\n    /**\r\n     * Increment to step forward in the physics engine (If timeStep is set to 1/60 and fixedTimeStep is set to 1/120 the physics engine should run 2 steps per frame) (Default: 1/60)\r\n     * @param fixedTimeStep fixedTimeStep to use in seconds\r\n     */\r\n    public setFixedTimeStep(fixedTimeStep: number) {\r\n        this._fixedTimeStep = fixedTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Sets the maximum number of steps by the physics engine per frame (Default: 5)\r\n     * @param maxSteps the maximum number of steps by the physics engine per frame\r\n     */\r\n    public setMaxSteps(maxSteps: number) {\r\n        this._maxSteps = maxSteps;\r\n    }\r\n\r\n    /**\r\n     * Gets the current timestep (only used if useDeltaForWorldStep is false in the constructor)\r\n     * @returns the current timestep in seconds\r\n     */\r\n    public getTimeStep(): number {\r\n        return this._timeStep;\r\n    }\r\n\r\n    /**\r\n     * The create custom shape handler function to be called when using BABYLON.PhysicsImposter.CustomImpostor\r\n     */\r\n    public onCreateCustomShape: (impostor: PhysicsImpostor) => any;\r\n\r\n    /**\r\n     * The create custom mesh impostor handler function to support building custom mesh impostor vertex data\r\n     */\r\n    public onCreateCustomMeshImpostor: (impostor: PhysicsImpostor) => any;\r\n\r\n    /**\r\n     * The create custom convex hull impostor handler function to support building custom convex hull impostor vertex data\r\n     */\r\n    public onCreateCustomConvexHullImpostor: (impostor: PhysicsImpostor) => any;\r\n\r\n    // Ammo's contactTest and contactPairTest take a callback that runs synchronously, wrap them so that they are easier to consume\r\n    private _isImpostorInContact(impostor: PhysicsImpostor) {\r\n        this._tmpContactCallbackResult = false;\r\n        this.world.contactTest(impostor.physicsBody, this._tmpAmmoConcreteContactResultCallback);\r\n        return this._tmpContactCallbackResult;\r\n    }\r\n    // Ammo's collision events have some weird quirks\r\n    // contactPairTest fires too many events as it fires events even when objects are close together but contactTest does not\r\n    // so only fire event if both contactTest and contactPairTest have a hit\r\n    private _isImpostorPairInContact(impostorA: PhysicsImpostor, impostorB: PhysicsImpostor) {\r\n        this._tmpContactCallbackResult = false;\r\n        this.world.contactPairTest(impostorA.physicsBody, impostorB.physicsBody, this._tmpAmmoConcreteContactResultCallback);\r\n        return this._tmpContactCallbackResult;\r\n    }\r\n\r\n    // Ammo's behavior when maxSteps > 0 does not behave as described in docs\r\n    // @see http://www.bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World\r\n    //\r\n    // When maxSteps is 0 do the entire simulation in one step\r\n    // When maxSteps is > 0, run up to maxStep times, if on the last step the (remaining step - fixedTimeStep) is < fixedTimeStep, the remainder will be used for the step. (eg. if remainder is 1.001 and fixedTimeStep is 1 the last step will be 1.001, if instead it did 2 steps (1, 0.001) issues occuered when having a tiny step in ammo)\r\n    // Note: To get deterministic physics, timeStep would always need to be divisible by fixedTimeStep\r\n    private _stepSimulation(timeStep: number = 1 / 60, maxSteps: number = 10, fixedTimeStep: number = 1 / 60) {\r\n        if (maxSteps == 0) {\r\n            this.world.stepSimulation(timeStep, 0);\r\n        } else {\r\n            while (maxSteps > 0 && timeStep > 0) {\r\n                if (timeStep - fixedTimeStep < fixedTimeStep) {\r\n                    this.world.stepSimulation(timeStep, 0);\r\n                    timeStep = 0;\r\n                } else {\r\n                    timeStep -= fixedTimeStep;\r\n                    this.world.stepSimulation(fixedTimeStep, 0);\r\n                }\r\n                maxSteps--;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves the physics simulation forward delta seconds and updates the given physics imposters\r\n     * Prior to the step the imposters physics location is set to the position of the babylon meshes\r\n     * After the step the babylon meshes are set to the position of the physics imposters\r\n     * @param delta amount of time to step forward\r\n     * @param impostors array of imposters to update before/after the step\r\n     */\r\n    public executeStep(delta: number, impostors: Array<PhysicsImpostor>): void {\r\n        for (const impostor of impostors) {\r\n            // Update physics world objects to match babylon world\r\n            if (!impostor.soft) {\r\n                impostor.beforeStep();\r\n            }\r\n        }\r\n\r\n        this._stepSimulation(this._useDeltaForWorldStep ? delta : this._timeStep, this._maxSteps, this._fixedTimeStep);\r\n\r\n        for (const mainImpostor of impostors) {\r\n            // After physics update make babylon world objects match physics world objects\r\n            if (mainImpostor.soft) {\r\n                this._afterSoftStep(mainImpostor);\r\n            } else {\r\n                mainImpostor.afterStep();\r\n            }\r\n\r\n            // Handle collision event\r\n            if (mainImpostor._onPhysicsCollideCallbacks.length > 0) {\r\n                if (this._isImpostorInContact(mainImpostor)) {\r\n                    for (const collideCallback of mainImpostor._onPhysicsCollideCallbacks) {\r\n                        for (const otherImpostor of collideCallback.otherImpostors) {\r\n                            if (mainImpostor.physicsBody.isActive() || otherImpostor.physicsBody.isActive()) {\r\n                                if (this._isImpostorPairInContact(mainImpostor, otherImpostor)) {\r\n                                    mainImpostor.onCollide({\r\n                                        body: otherImpostor.physicsBody,\r\n                                        point: this._tmpContactPoint,\r\n                                        distance: this._tmpContactDistance,\r\n                                        impulse: this._tmpContactImpulse,\r\n                                        normal: this._tmpContactNormal,\r\n                                    });\r\n                                    otherImpostor.onCollide({\r\n                                        body: mainImpostor.physicsBody,\r\n                                        point: this._tmpContactPoint,\r\n                                        distance: this._tmpContactDistance,\r\n                                        impulse: this._tmpContactImpulse,\r\n                                        normal: this._tmpContactNormal,\r\n                                    });\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update babylon mesh to match physics world object\r\n     * @param impostor imposter to match\r\n     */\r\n    private _afterSoftStep(impostor: PhysicsImpostor): void {\r\n        if (impostor.type === PhysicsImpostor.RopeImpostor) {\r\n            this._ropeStep(impostor);\r\n        } else {\r\n            this._softbodyOrClothStep(impostor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update babylon mesh vertices vertices to match physics world softbody or cloth\r\n     * @param impostor imposter to match\r\n     */\r\n    private _ropeStep(impostor: PhysicsImpostor): void {\r\n        const bodyVertices = impostor.physicsBody.get_m_nodes();\r\n        const nbVertices = bodyVertices.size();\r\n        let node: any;\r\n        let nodePositions: any;\r\n        let x, y, z: number;\r\n        const path: Array<Vector3> = new Array();\r\n        for (let n = 0; n < nbVertices; n++) {\r\n            node = bodyVertices.at(n);\r\n            nodePositions = node.get_m_x();\r\n            x = nodePositions.x();\r\n            y = nodePositions.y();\r\n            z = nodePositions.z();\r\n            path.push(new Vector3(x, y, z));\r\n        }\r\n        const object = impostor.object;\r\n        const shape = impostor.getParam(\"shape\");\r\n        if (impostor._isFromLine) {\r\n            impostor.object = CreateLines(\"lines\", { points: path, instance: <LinesMesh>object });\r\n        } else {\r\n            impostor.object = ExtrudeShape(\"ext\", { shape: shape, path: path, instance: <Mesh>object });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update babylon mesh vertices vertices to match physics world softbody or cloth\r\n     * @param impostor imposter to match\r\n     */\r\n    private _softbodyOrClothStep(impostor: PhysicsImpostor): void {\r\n        const normalDirection = impostor.type === PhysicsImpostor.ClothImpostor ? 1 : -1;\r\n        const object = impostor.object;\r\n        let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n        if (!vertexPositions) {\r\n            vertexPositions = [];\r\n        }\r\n        let vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);\r\n        if (!vertexNormals) {\r\n            vertexNormals = [];\r\n        }\r\n\r\n        const nbVertices = vertexPositions.length / 3;\r\n        const bodyVertices = impostor.physicsBody.get_m_nodes();\r\n        let node: any;\r\n        let nodePositions: any;\r\n        let x, y, z: number;\r\n        let nx, ny, nz: number;\r\n        for (let n = 0; n < nbVertices; n++) {\r\n            node = bodyVertices.at(n);\r\n            nodePositions = node.get_m_x();\r\n            x = nodePositions.x();\r\n            y = nodePositions.y();\r\n            z = nodePositions.z() * normalDirection;\r\n            const nodeNormals = node.get_m_n();\r\n            nx = nodeNormals.x();\r\n            ny = nodeNormals.y();\r\n            nz = nodeNormals.z() * normalDirection;\r\n\r\n            vertexPositions[3 * n] = x;\r\n            vertexPositions[3 * n + 1] = y;\r\n            vertexPositions[3 * n + 2] = z;\r\n            vertexNormals[3 * n] = nx;\r\n            vertexNormals[3 * n + 1] = ny;\r\n            vertexNormals[3 * n + 2] = nz;\r\n        }\r\n\r\n        const vertex_data = new VertexData();\r\n\r\n        vertex_data.positions = vertexPositions;\r\n        vertex_data.normals = vertexNormals;\r\n        vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);\r\n        vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);\r\n        if (object && object.getIndices) {\r\n            vertex_data.indices = object.getIndices();\r\n        }\r\n\r\n        vertex_data.applyToMesh(<Mesh>object);\r\n    }\r\n\r\n    private _tmpMatrix = new Matrix();\r\n    /**\r\n     * Applies an impulse on the imposter\r\n     * @param impostor imposter to apply impulse to\r\n     * @param force amount of force to be applied to the imposter\r\n     * @param contactPoint the location to apply the impulse on the imposter\r\n     */\r\n    public applyImpulse(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        if (!impostor.soft) {\r\n            impostor.physicsBody.activate();\r\n            const worldPoint = this._tmpAmmoVectorA;\r\n            const impulse = this._tmpAmmoVectorB;\r\n\r\n            // Convert contactPoint relative to center of mass\r\n            if (impostor.object && impostor.object.getWorldMatrix) {\r\n                contactPoint.subtractInPlace(impostor.object.getWorldMatrix().getTranslation());\r\n            }\r\n\r\n            worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);\r\n            impulse.setValue(force.x, force.y, force.z);\r\n\r\n            impostor.physicsBody.applyImpulse(impulse, worldPoint);\r\n        } else {\r\n            Logger.Warn(\"Cannot be applied to a soft body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Applies a force on the imposter\r\n     * @param impostor imposter to apply force\r\n     * @param force amount of force to be applied to the imposter\r\n     * @param contactPoint the location to apply the force on the imposter\r\n     */\r\n    public applyForce(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        if (!impostor.soft) {\r\n            impostor.physicsBody.activate();\r\n            const worldPoint = this._tmpAmmoVectorA;\r\n            const impulse = this._tmpAmmoVectorB;\r\n\r\n            // Convert contactPoint relative to center of mass\r\n            if (impostor.object && impostor.object.getWorldMatrix) {\r\n                const localTranslation = impostor.object.getWorldMatrix().getTranslation();\r\n                worldPoint.setValue(contactPoint.x - localTranslation.x, contactPoint.y - localTranslation.y, contactPoint.z - localTranslation.z);\r\n            } else {\r\n                worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);\r\n            }\r\n\r\n            impulse.setValue(force.x, force.y, force.z);\r\n\r\n            impostor.physicsBody.applyForce(impulse, worldPoint);\r\n        } else {\r\n            Logger.Warn(\"Cannot be applied to a soft body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a physics body using the plugin\r\n     * @param impostor the imposter to create the physics body on\r\n     */\r\n    public generatePhysicsBody(impostor: PhysicsImpostor) {\r\n        // Note: this method will not be called on child imposotrs for compound impostors\r\n\r\n        impostor._pluginData.toDispose = [];\r\n\r\n        //parent-child relationship\r\n        if (impostor.parent) {\r\n            if (impostor.physicsBody) {\r\n                this.removePhysicsBody(impostor);\r\n                impostor.forceUpdate();\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (impostor.isBodyInitRequired()) {\r\n            const colShape = this._createShape(impostor);\r\n            const mass = impostor.getParam(\"mass\");\r\n            impostor._pluginData.mass = mass;\r\n            if (impostor.soft) {\r\n                colShape.get_m_cfg().set_collisions(0x11);\r\n                colShape.get_m_cfg().set_kDP(impostor.getParam(\"damping\"));\r\n                this.bjsAMMO.castObject(colShape, this.bjsAMMO.btCollisionObject).getCollisionShape().setMargin(impostor.getParam(\"margin\"));\r\n                colShape.setActivationState(AmmoJSPlugin._DISABLE_DEACTIVATION_FLAG);\r\n                this.world.addSoftBody(colShape, 1, -1);\r\n                impostor.physicsBody = colShape;\r\n                impostor._pluginData.toDispose.push(colShape);\r\n                this.setBodyPressure(impostor, 0);\r\n                if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {\r\n                    this.setBodyPressure(impostor, impostor.getParam(\"pressure\"));\r\n                }\r\n                this.setBodyStiffness(impostor, impostor.getParam(\"stiffness\"));\r\n                this.setBodyVelocityIterations(impostor, impostor.getParam(\"velocityIterations\"));\r\n                this.setBodyPositionIterations(impostor, impostor.getParam(\"positionIterations\"));\r\n            } else {\r\n                const localInertia = new this.bjsAMMO.btVector3(0, 0, 0);\r\n                const startTransform = new this.bjsAMMO.btTransform();\r\n                impostor.object.computeWorldMatrix(true);\r\n                startTransform.setIdentity();\r\n                if (mass !== 0) {\r\n                    colShape.calculateLocalInertia(mass, localInertia);\r\n                }\r\n                this._tmpAmmoVectorA.setValue(impostor.object.position.x, impostor.object.position.y, impostor.object.position.z);\r\n                this._tmpAmmoQuaternion.setValue(\r\n                    impostor.object.rotationQuaternion!.x,\r\n                    impostor.object.rotationQuaternion!.y,\r\n                    impostor.object.rotationQuaternion!.z,\r\n                    impostor.object.rotationQuaternion!.w\r\n                );\r\n                startTransform.setOrigin(this._tmpAmmoVectorA);\r\n                startTransform.setRotation(this._tmpAmmoQuaternion);\r\n                const myMotionState = new this.bjsAMMO.btDefaultMotionState(startTransform);\r\n                const rbInfo = new this.bjsAMMO.btRigidBodyConstructionInfo(mass, myMotionState, colShape, localInertia);\r\n                const body = new this.bjsAMMO.btRigidBody(rbInfo);\r\n\r\n                // Make objects kinematic if it's mass is 0\r\n                if (mass === 0) {\r\n                    body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin._KINEMATIC_FLAG);\r\n                    body.setActivationState(AmmoJSPlugin._DISABLE_DEACTIVATION_FLAG);\r\n                }\r\n\r\n                // Disable collision if NoImpostor, but keep collision if shape is btCompoundShape\r\n                if (impostor.type == PhysicsImpostor.NoImpostor && !colShape.getChildShape) {\r\n                    body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin._DISABLE_COLLISION_FLAG);\r\n                }\r\n\r\n                // compute delta position: compensate the difference between shape center and mesh origin\r\n                if (impostor.type !== PhysicsImpostor.MeshImpostor && impostor.type !== PhysicsImpostor.NoImpostor) {\r\n                    const boundingInfo = impostor.object.getBoundingInfo();\r\n                    this._tmpVec3.copyFrom(impostor.object.getAbsolutePosition());\r\n                    this._tmpVec3.subtractInPlace(boundingInfo.boundingBox.centerWorld);\r\n                    this._tmpVec3.x /= impostor.object.scaling.x;\r\n                    this._tmpVec3.y /= impostor.object.scaling.y;\r\n                    this._tmpVec3.z /= impostor.object.scaling.z;\r\n                    impostor.setDeltaPosition(this._tmpVec3);\r\n                }\r\n\r\n                const group = impostor.getParam(\"group\");\r\n                const mask = impostor.getParam(\"mask\");\r\n                if (group && mask) {\r\n                    this.world.addRigidBody(body, group, mask);\r\n                } else {\r\n                    this.world.addRigidBody(body);\r\n                }\r\n                impostor.physicsBody = body;\r\n                impostor._pluginData.toDispose = impostor._pluginData.toDispose.concat([body, rbInfo, myMotionState, startTransform, localInertia, colShape]);\r\n            }\r\n            this.setBodyRestitution(impostor, impostor.getParam(\"restitution\"));\r\n            this.setBodyFriction(impostor, impostor.getParam(\"friction\"));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the physics body from the imposter and disposes of the body's memory\r\n     * @param impostor imposter to remove the physics body from\r\n     */\r\n    public removePhysicsBody(impostor: PhysicsImpostor) {\r\n        if (this.world) {\r\n            if (impostor.soft) {\r\n                this.world.removeSoftBody(impostor.physicsBody);\r\n            } else {\r\n                this.world.removeRigidBody(impostor.physicsBody);\r\n            }\r\n\r\n            if (impostor._pluginData) {\r\n                impostor._pluginData.toDispose.forEach((d: any) => {\r\n                    this.bjsAMMO.destroy(d);\r\n                });\r\n                impostor._pluginData.toDispose = [];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates a joint\r\n     * @param impostorJoint the imposter joint to create the joint with\r\n     */\r\n    public generateJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        const mainBody = impostorJoint.mainImpostor.physicsBody;\r\n        const connectedBody = impostorJoint.connectedImpostor.physicsBody;\r\n        if (!mainBody || !connectedBody) {\r\n            return;\r\n        }\r\n\r\n        const jointData = impostorJoint.joint.jointData;\r\n        if (!jointData.mainPivot) {\r\n            jointData.mainPivot = new Vector3(0, 0, 0);\r\n        }\r\n        if (!jointData.connectedPivot) {\r\n            jointData.connectedPivot = new Vector3(0, 0, 0);\r\n        }\r\n\r\n        let joint: any;\r\n        switch (impostorJoint.joint.type) {\r\n            case PhysicsJoint.DistanceJoint: {\r\n                const distance = (<DistanceJointData>jointData).maxDistance;\r\n                if (distance) {\r\n                    jointData.mainPivot = new Vector3(0, -distance / 2, 0);\r\n                    jointData.connectedPivot = new Vector3(0, distance / 2, 0);\r\n                }\r\n                joint = new this.bjsAMMO.btPoint2PointConstraint(\r\n                    mainBody,\r\n                    connectedBody,\r\n                    new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z),\r\n                    new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z)\r\n                );\r\n                break;\r\n            }\r\n            case PhysicsJoint.HingeJoint: {\r\n                if (!jointData.mainAxis) {\r\n                    jointData.mainAxis = new Vector3(0, 0, 0);\r\n                }\r\n                if (!jointData.connectedAxis) {\r\n                    jointData.connectedAxis = new Vector3(0, 0, 0);\r\n                }\r\n                const mainAxis = new this.bjsAMMO.btVector3(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z);\r\n                const connectedAxis = new this.bjsAMMO.btVector3(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z);\r\n                joint = new this.bjsAMMO.btHingeConstraint(\r\n                    mainBody,\r\n                    connectedBody,\r\n                    new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z),\r\n                    new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z),\r\n                    mainAxis,\r\n                    connectedAxis\r\n                );\r\n                break;\r\n            }\r\n            case PhysicsJoint.BallAndSocketJoint:\r\n                joint = new this.bjsAMMO.btPoint2PointConstraint(\r\n                    mainBody,\r\n                    connectedBody,\r\n                    new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z),\r\n                    new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z)\r\n                );\r\n                break;\r\n            default:\r\n                Logger.Warn(\"JointType not currently supported by the Ammo plugin, falling back to PhysicsJoint.BallAndSocketJoint\");\r\n                joint = new this.bjsAMMO.btPoint2PointConstraint(\r\n                    mainBody,\r\n                    connectedBody,\r\n                    new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z),\r\n                    new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z)\r\n                );\r\n                break;\r\n        }\r\n        this.world.addConstraint(joint, !impostorJoint.joint.jointData.collision);\r\n        impostorJoint.joint.physicsJoint = joint;\r\n    }\r\n\r\n    /**\r\n     * Removes a joint\r\n     * @param impostorJoint the imposter joint to remove the joint from\r\n     */\r\n    public removeJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        if (this.world) {\r\n            this.world.removeConstraint(impostorJoint.joint.physicsJoint);\r\n        }\r\n    }\r\n\r\n    // adds all verticies (including child verticies) to the triangle mesh\r\n    private _addMeshVerts(btTriangleMesh: any, topLevelObject: IPhysicsEnabledObject, object: IPhysicsEnabledObject) {\r\n        let triangleCount = 0;\r\n        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\r\n            let indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n            let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n            if (!vertexPositions) {\r\n                vertexPositions = [];\r\n            }\r\n\r\n            let localMatrix;\r\n\r\n            if (topLevelObject && topLevelObject !== object) {\r\n                // top level matrix used for shape transform doesn't take scale into account.\r\n                // Moreover, every children vertex position must be in that space.\r\n                // So, each vertex position here is transform by (mesh world matrix * toplevelMatrix -1)\r\n                let topLevelQuaternion;\r\n                if (topLevelObject.rotationQuaternion) {\r\n                    topLevelQuaternion = topLevelObject.rotationQuaternion;\r\n                } else if (topLevelObject.rotation) {\r\n                    topLevelQuaternion = Quaternion.FromEulerAngles(topLevelObject.rotation.x, topLevelObject.rotation.y, topLevelObject.rotation.z);\r\n                } else {\r\n                    topLevelQuaternion = Quaternion.Identity();\r\n                }\r\n                const topLevelMatrix = Matrix.Compose(Vector3.One(), topLevelQuaternion, topLevelObject.position);\r\n                topLevelMatrix.invertToRef(this._tmpMatrix);\r\n                const wm = object.computeWorldMatrix(false);\r\n                localMatrix = wm.multiply(this._tmpMatrix);\r\n            } else {\r\n                // current top level is same as object level -> only use local scaling\r\n                Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);\r\n                localMatrix = this._tmpMatrix;\r\n            }\r\n            const faceCount = indices.length / 3;\r\n            for (let i = 0; i < faceCount; i++) {\r\n                const triPoints = [];\r\n                for (let point = 0; point < 3; point++) {\r\n                    let v = new Vector3(\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 0],\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 1],\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 2]\r\n                    );\r\n\r\n                    v = Vector3.TransformCoordinates(v, localMatrix);\r\n\r\n                    let vec: any;\r\n                    if (point == 0) {\r\n                        vec = this._tmpAmmoVectorA;\r\n                    } else if (point == 1) {\r\n                        vec = this._tmpAmmoVectorB;\r\n                    } else {\r\n                        vec = this._tmpAmmoVectorC;\r\n                    }\r\n                    vec.setValue(v.x, v.y, v.z);\r\n\r\n                    triPoints.push(vec);\r\n                }\r\n                btTriangleMesh.addTriangle(triPoints[0], triPoints[1], triPoints[2]);\r\n                triangleCount++;\r\n            }\r\n\r\n            object.getChildMeshes().forEach((m) => {\r\n                triangleCount += this._addMeshVerts(btTriangleMesh, topLevelObject, m);\r\n            });\r\n        }\r\n        return triangleCount;\r\n    }\r\n\r\n    /**\r\n     * Initialise the soft body vertices to match its object's (mesh) vertices\r\n     * Softbody vertices (nodes) are in world space and to match this\r\n     * The object's position and rotation is set to zero and so its vertices are also then set in world space\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _softVertexData(impostor: PhysicsImpostor): VertexData {\r\n        const object = impostor.object;\r\n        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\r\n            let indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n            let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n            if (!vertexPositions) {\r\n                vertexPositions = [];\r\n            }\r\n            let vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);\r\n            if (!vertexNormals) {\r\n                vertexNormals = [];\r\n            }\r\n            object.computeWorldMatrix(false);\r\n            const newPoints = [];\r\n            const newNorms = [];\r\n            for (let i = 0; i < vertexPositions.length; i += 3) {\r\n                let v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);\r\n                let n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);\r\n                v = Vector3.TransformCoordinates(v, object.getWorldMatrix());\r\n                n = Vector3.TransformNormal(n, object.getWorldMatrix());\r\n                newPoints.push(v.x, v.y, v.z);\r\n                newNorms.push(n.x, n.y, n.z);\r\n            }\r\n\r\n            const vertex_data = new VertexData();\r\n\r\n            vertex_data.positions = newPoints;\r\n            vertex_data.normals = newNorms;\r\n            vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);\r\n            vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);\r\n            if (object && object.getIndices) {\r\n                vertex_data.indices = object.getIndices();\r\n            }\r\n\r\n            vertex_data.applyToMesh(<Mesh>object);\r\n\r\n            object.position = Vector3.Zero();\r\n            object.rotationQuaternion = null;\r\n            object.rotation = Vector3.Zero();\r\n            object.computeWorldMatrix(true);\r\n\r\n            return vertex_data;\r\n        }\r\n        return VertexData.ExtractFromMesh(<Mesh>object);\r\n    }\r\n\r\n    /**\r\n     * Create an impostor's soft body\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _createSoftbody(impostor: PhysicsImpostor) {\r\n        const object = impostor.object;\r\n        if (object && object.getIndices) {\r\n            let indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n\r\n            const vertex_data = this._softVertexData(impostor);\r\n            const vertexPositions = vertex_data.positions;\r\n            const vertexNormals = vertex_data.normals;\r\n\r\n            if (vertexPositions === null || vertexNormals === null) {\r\n                return new this.bjsAMMO.btCompoundShape();\r\n            } else {\r\n                const triPoints = [];\r\n                const triNorms = [];\r\n                for (let i = 0; i < vertexPositions.length; i += 3) {\r\n                    const v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);\r\n                    const n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);\r\n                    triPoints.push(v.x, v.y, -v.z);\r\n                    triNorms.push(n.x, n.y, -n.z);\r\n                }\r\n                const softBody = new this.bjsAMMO.btSoftBodyHelpers().CreateFromTriMesh(this.world.getWorldInfo(), triPoints, object.getIndices(), indices.length / 3, true);\r\n\r\n                const nbVertices = vertexPositions.length / 3;\r\n                const bodyVertices = softBody.get_m_nodes();\r\n                let node: any;\r\n                let nodeNormals: any;\r\n                for (let i = 0; i < nbVertices; i++) {\r\n                    node = bodyVertices.at(i);\r\n                    nodeNormals = node.get_m_n();\r\n                    nodeNormals.setX(triNorms[3 * i]);\r\n                    nodeNormals.setY(triNorms[3 * i + 1]);\r\n                    nodeNormals.setZ(triNorms[3 * i + 2]);\r\n                }\r\n                return softBody;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create cloth for an impostor\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _createCloth(impostor: PhysicsImpostor) {\r\n        const object = impostor.object;\r\n        if (object && object.getIndices) {\r\n            let indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n\r\n            const vertex_data = this._softVertexData(impostor);\r\n            const vertexPositions = vertex_data.positions;\r\n            const vertexNormals = vertex_data.normals;\r\n\r\n            if (vertexPositions === null || vertexNormals === null) {\r\n                return new this.bjsAMMO.btCompoundShape();\r\n            } else {\r\n                const len = vertexPositions.length;\r\n                const segments = Math.sqrt(len / 3);\r\n                impostor.segments = segments;\r\n                const segs = segments - 1;\r\n                this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);\r\n                this._tmpAmmoVectorB.setValue(vertexPositions[3 * segs], vertexPositions[3 * segs + 1], vertexPositions[3 * segs + 2]);\r\n                this._tmpAmmoVectorD.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);\r\n                this._tmpAmmoVectorC.setValue(vertexPositions[len - 3 - 3 * segs], vertexPositions[len - 2 - 3 * segs], vertexPositions[len - 1 - 3 * segs]);\r\n\r\n                const clothBody = new this.bjsAMMO.btSoftBodyHelpers().CreatePatch(\r\n                    this.world.getWorldInfo(),\r\n                    this._tmpAmmoVectorA,\r\n                    this._tmpAmmoVectorB,\r\n                    this._tmpAmmoVectorC,\r\n                    this._tmpAmmoVectorD,\r\n                    segments,\r\n                    segments,\r\n                    impostor.getParam(\"fixedPoints\"),\r\n                    true\r\n                );\r\n                return clothBody;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create rope for an impostor\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _createRope(impostor: PhysicsImpostor) {\r\n        let len: number;\r\n        let segments: number;\r\n        const vertex_data = this._softVertexData(impostor);\r\n        const vertexPositions = vertex_data.positions;\r\n        const vertexNormals = vertex_data.normals;\r\n\r\n        if (vertexPositions === null || vertexNormals === null) {\r\n            return new this.bjsAMMO.btCompoundShape();\r\n        }\r\n\r\n        //force the mesh to be updatable\r\n        vertex_data.applyToMesh(<Mesh>impostor.object, true);\r\n\r\n        impostor._isFromLine = true;\r\n\r\n        // If in lines mesh all normals will be zero\r\n        const vertexSquared: Array<number> = <Array<number>>vertexNormals.map((x: number) => x * x);\r\n        const reducer = (accumulator: number, currentValue: number): number => accumulator + currentValue;\r\n        const reduced: number = vertexSquared.reduce(reducer);\r\n\r\n        if (reduced === 0) {\r\n            // line mesh\r\n            len = vertexPositions.length;\r\n            segments = len / 3 - 1;\r\n            this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);\r\n            this._tmpAmmoVectorB.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);\r\n        } else {\r\n            //extruded mesh\r\n            impostor._isFromLine = false;\r\n            const pathVectors = impostor.getParam(\"path\");\r\n            const shape = impostor.getParam(\"shape\");\r\n            if (shape === null) {\r\n                Logger.Warn(\"No shape available for extruded mesh\");\r\n                return new this.bjsAMMO.btCompoundShape();\r\n            }\r\n            len = pathVectors.length;\r\n            segments = len - 1;\r\n            this._tmpAmmoVectorA.setValue(pathVectors[0].x, pathVectors[0].y, pathVectors[0].z);\r\n            this._tmpAmmoVectorB.setValue(pathVectors[len - 1].x, pathVectors[len - 1].y, pathVectors[len - 1].z);\r\n        }\r\n\r\n        impostor.segments = segments;\r\n\r\n        let fixedPoints = impostor.getParam(\"fixedPoints\");\r\n        fixedPoints = fixedPoints > 3 ? 3 : fixedPoints;\r\n\r\n        const ropeBody = new this.bjsAMMO.btSoftBodyHelpers().CreateRope(this.world.getWorldInfo(), this._tmpAmmoVectorA, this._tmpAmmoVectorB, segments - 1, fixedPoints);\r\n        ropeBody.get_m_cfg().set_collisions(0x11);\r\n        return ropeBody;\r\n    }\r\n\r\n    /**\r\n     * Create a custom physics impostor shape using the plugin's onCreateCustomShape handler\r\n     * @param impostor to create the custom physics shape for\r\n     */\r\n    private _createCustom(impostor: PhysicsImpostor): any {\r\n        let returnValue: any = null;\r\n        if (this.onCreateCustomShape) {\r\n            returnValue = this.onCreateCustomShape(impostor);\r\n        }\r\n        if (returnValue == null) {\r\n            returnValue = new this.bjsAMMO.btCompoundShape();\r\n        }\r\n        return returnValue;\r\n    }\r\n\r\n    // adds all verticies (including child verticies) to the convex hull shape\r\n    private _addHullVerts(btConvexHullShape: any, topLevelObject: IPhysicsEnabledObject, object: IPhysicsEnabledObject) {\r\n        let triangleCount = 0;\r\n        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\r\n            let indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n            let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n            if (!vertexPositions) {\r\n                vertexPositions = [];\r\n            }\r\n            object.computeWorldMatrix(false);\r\n            const faceCount = indices.length / 3;\r\n            for (let i = 0; i < faceCount; i++) {\r\n                const triPoints = [];\r\n                for (let point = 0; point < 3; point++) {\r\n                    let v = new Vector3(\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 0],\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 1],\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 2]\r\n                    );\r\n\r\n                    // Adjust for initial scaling\r\n                    Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);\r\n                    v = Vector3.TransformCoordinates(v, this._tmpMatrix);\r\n\r\n                    let vec: any;\r\n                    if (point == 0) {\r\n                        vec = this._tmpAmmoVectorA;\r\n                    } else if (point == 1) {\r\n                        vec = this._tmpAmmoVectorB;\r\n                    } else {\r\n                        vec = this._tmpAmmoVectorC;\r\n                    }\r\n                    vec.setValue(v.x, v.y, v.z);\r\n\r\n                    triPoints.push(vec);\r\n                }\r\n                btConvexHullShape.addPoint(triPoints[0], true);\r\n                btConvexHullShape.addPoint(triPoints[1], true);\r\n                btConvexHullShape.addPoint(triPoints[2], true);\r\n                triangleCount++;\r\n            }\r\n\r\n            object.getChildMeshes().forEach((m) => {\r\n                triangleCount += this._addHullVerts(btConvexHullShape, topLevelObject, m);\r\n            });\r\n        }\r\n        return triangleCount;\r\n    }\r\n\r\n    private _createShape(impostor: PhysicsImpostor, ignoreChildren = false) {\r\n        const object = impostor.object;\r\n\r\n        let returnValue: any;\r\n        const impostorExtents = impostor.getObjectExtents();\r\n\r\n        if (!ignoreChildren) {\r\n            const meshChildren = impostor.object.getChildMeshes ? impostor.object.getChildMeshes(true) : [];\r\n            returnValue = new this.bjsAMMO.btCompoundShape();\r\n\r\n            // Add shape of all children to the compound shape\r\n            let childrenAdded = 0;\r\n            meshChildren.forEach((childMesh) => {\r\n                const childImpostor = childMesh.getPhysicsImpostor();\r\n                if (childImpostor) {\r\n                    if (childImpostor.type == PhysicsImpostor.MeshImpostor) {\r\n                        throw \"A child MeshImpostor is not supported. Only primitive impostors are supported as children (eg. box or sphere)\";\r\n                    }\r\n                    const shape = this._createShape(childImpostor);\r\n\r\n                    // Position needs to be scaled based on parent's scaling\r\n                    const parentMat = childMesh.parent!.getWorldMatrix().clone();\r\n                    const s = new Vector3();\r\n                    parentMat.decompose(s);\r\n                    this._tmpAmmoTransform.getOrigin().setValue(childMesh.position.x * s.x, childMesh.position.y * s.y, childMesh.position.z * s.z);\r\n\r\n                    this._tmpAmmoQuaternion.setValue(\r\n                        childMesh.rotationQuaternion!.x,\r\n                        childMesh.rotationQuaternion!.y,\r\n                        childMesh.rotationQuaternion!.z,\r\n                        childMesh.rotationQuaternion!.w\r\n                    );\r\n                    this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);\r\n                    returnValue.addChildShape(this._tmpAmmoTransform, shape);\r\n                    childImpostor.dispose();\r\n                    childrenAdded++;\r\n                }\r\n            });\r\n\r\n            if (childrenAdded > 0) {\r\n                // Add parents shape as a child if present\r\n                if (impostor.type != PhysicsImpostor.NoImpostor) {\r\n                    const shape = this._createShape(impostor, true);\r\n                    if (shape) {\r\n                        this._tmpAmmoTransform.getOrigin().setValue(0, 0, 0);\r\n                        this._tmpAmmoQuaternion.setValue(0, 0, 0, 1);\r\n                        this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);\r\n\r\n                        returnValue.addChildShape(this._tmpAmmoTransform, shape);\r\n                    }\r\n                }\r\n                return returnValue;\r\n            } else {\r\n                // If no children with impostors create the actual shape below instead\r\n                this.bjsAMMO.destroy(returnValue);\r\n                returnValue = null;\r\n            }\r\n        }\r\n\r\n        switch (impostor.type) {\r\n            case PhysicsImpostor.SphereImpostor:\r\n                // Is there a better way to compare floats number? With an epsilon or with a Math function\r\n                if (Scalar.WithinEpsilon(impostorExtents.x, impostorExtents.y, 0.0001) && Scalar.WithinEpsilon(impostorExtents.x, impostorExtents.z, 0.0001)) {\r\n                    returnValue = new this.bjsAMMO.btSphereShape(impostorExtents.x / 2);\r\n                } else {\r\n                    // create a btMultiSphereShape because it's not possible to set a local scaling on a btSphereShape\r\n                    const positions = [new this.bjsAMMO.btVector3(0, 0, 0)];\r\n                    const radii = [1];\r\n                    returnValue = new this.bjsAMMO.btMultiSphereShape(positions, radii, 1);\r\n                    returnValue.setLocalScaling(new this.bjsAMMO.btVector3(impostorExtents.x / 2, impostorExtents.y / 2, impostorExtents.z / 2));\r\n                }\r\n                break;\r\n            case PhysicsImpostor.CapsuleImpostor:\r\n                {\r\n                    // https://pybullet.org/Bullet/BulletFull/classbtCapsuleShape.html#details\r\n                    // Height is just the height between the center of each 'sphere' of the capsule caps\r\n                    const capRadius = impostorExtents.x / 2;\r\n                    returnValue = new this.bjsAMMO.btCapsuleShape(capRadius, impostorExtents.y - capRadius * 2);\r\n                }\r\n                break;\r\n            case PhysicsImpostor.CylinderImpostor:\r\n                this._tmpAmmoVectorA.setValue(impostorExtents.x / 2, impostorExtents.y / 2, impostorExtents.z / 2);\r\n                returnValue = new this.bjsAMMO.btCylinderShape(this._tmpAmmoVectorA);\r\n                break;\r\n            case PhysicsImpostor.PlaneImpostor:\r\n            case PhysicsImpostor.BoxImpostor:\r\n                this._tmpAmmoVectorA.setValue(impostorExtents.x / 2, impostorExtents.y / 2, impostorExtents.z / 2);\r\n                returnValue = new this.bjsAMMO.btBoxShape(this._tmpAmmoVectorA);\r\n                break;\r\n            case PhysicsImpostor.MeshImpostor: {\r\n                if (impostor.getParam(\"mass\") == 0) {\r\n                    // Only create btBvhTriangleMeshShape if the impostor is static\r\n                    // See https://pybullet.org/Bullet/phpBB3/viewtopic.php?t=7283\r\n                    if (this.onCreateCustomMeshImpostor) {\r\n                        returnValue = this.onCreateCustomMeshImpostor(impostor);\r\n                    } else {\r\n                        const triMesh = new this.bjsAMMO.btTriangleMesh();\r\n                        impostor._pluginData.toDispose.push(triMesh);\r\n                        const triangleCount = this._addMeshVerts(triMesh, object, object);\r\n                        if (triangleCount == 0) {\r\n                            returnValue = new this.bjsAMMO.btCompoundShape();\r\n                        } else {\r\n                            returnValue = new this.bjsAMMO.btBvhTriangleMeshShape(triMesh);\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            // Otherwise create convexHullImpostor\r\n            // eslint-disable-next-line no-fallthrough\r\n            case PhysicsImpostor.ConvexHullImpostor: {\r\n                if (this.onCreateCustomConvexHullImpostor) {\r\n                    returnValue = this.onCreateCustomConvexHullImpostor(impostor);\r\n                } else {\r\n                    const convexHull = new this.bjsAMMO.btConvexHullShape();\r\n                    const triangleCount = this._addHullVerts(convexHull, object, object);\r\n                    if (triangleCount == 0) {\r\n                        // Cleanup Unused Convex Hull Shape\r\n                        impostor._pluginData.toDispose.push(convexHull);\r\n                        returnValue = new this.bjsAMMO.btCompoundShape();\r\n                    } else {\r\n                        returnValue = convexHull;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case PhysicsImpostor.NoImpostor:\r\n                // Fill with sphere but collision is disabled on the rigid body in generatePhysicsBody, using an empty shape caused unexpected movement with joints\r\n                returnValue = new this.bjsAMMO.btSphereShape(impostorExtents.x / 2);\r\n                break;\r\n            case PhysicsImpostor.CustomImpostor:\r\n                // Only usable when the plugin's onCreateCustomShape is set\r\n                returnValue = this._createCustom(impostor);\r\n                break;\r\n            case PhysicsImpostor.SoftbodyImpostor:\r\n                // Only usable with a mesh that has sufficient and shared vertices\r\n                returnValue = this._createSoftbody(impostor);\r\n                break;\r\n            case PhysicsImpostor.ClothImpostor:\r\n                // Only usable with a ground mesh that has sufficient and shared vertices\r\n                returnValue = this._createCloth(impostor);\r\n                break;\r\n            case PhysicsImpostor.RopeImpostor:\r\n                // Only usable with a line mesh or an extruded mesh that is updatable\r\n                returnValue = this._createRope(impostor);\r\n                break;\r\n            default:\r\n                Logger.Warn(\"The impostor type is not currently supported by the ammo plugin.\");\r\n                break;\r\n        }\r\n\r\n        return returnValue;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh body position/rotation from the babylon impostor\r\n     * @param impostor imposter containing the physics body and babylon object\r\n     */\r\n    public setTransformationFromPhysicsBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.getMotionState().getWorldTransform(this._tmpAmmoTransform);\r\n        impostor.object.position.set(this._tmpAmmoTransform.getOrigin().x(), this._tmpAmmoTransform.getOrigin().y(), this._tmpAmmoTransform.getOrigin().z());\r\n\r\n        if (!impostor.object.rotationQuaternion) {\r\n            if (impostor.object.rotation) {\r\n                this._tmpQuaternion.set(\r\n                    this._tmpAmmoTransform.getRotation().x(),\r\n                    this._tmpAmmoTransform.getRotation().y(),\r\n                    this._tmpAmmoTransform.getRotation().z(),\r\n                    this._tmpAmmoTransform.getRotation().w()\r\n                );\r\n                this._tmpQuaternion.toEulerAnglesToRef(impostor.object.rotation);\r\n            }\r\n        } else {\r\n            impostor.object.rotationQuaternion.set(\r\n                this._tmpAmmoTransform.getRotation().x(),\r\n                this._tmpAmmoTransform.getRotation().y(),\r\n                this._tmpAmmoTransform.getRotation().z(),\r\n                this._tmpAmmoTransform.getRotation().w()\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the babylon object's position/rotation from the physics body's position/rotation\r\n     * @param impostor imposter containing the physics body and babylon object\r\n     * @param newPosition new position\r\n     * @param newRotation new rotation\r\n     */\r\n    public setPhysicsBodyTransformation(impostor: PhysicsImpostor, newPosition: Vector3, newRotation: Quaternion) {\r\n        const trans = impostor.physicsBody.getWorldTransform();\r\n\r\n        // If rotation/position has changed update and activate rigged body\r\n        if (\r\n            Math.abs(trans.getOrigin().x() - newPosition.x) > Epsilon ||\r\n            Math.abs(trans.getOrigin().y() - newPosition.y) > Epsilon ||\r\n            Math.abs(trans.getOrigin().z() - newPosition.z) > Epsilon ||\r\n            Math.abs(trans.getRotation().x() - newRotation.x) > Epsilon ||\r\n            Math.abs(trans.getRotation().y() - newRotation.y) > Epsilon ||\r\n            Math.abs(trans.getRotation().z() - newRotation.z) > Epsilon ||\r\n            Math.abs(trans.getRotation().w() - newRotation.w) > Epsilon\r\n        ) {\r\n            this._tmpAmmoVectorA.setValue(newPosition.x, newPosition.y, newPosition.z);\r\n            trans.setOrigin(this._tmpAmmoVectorA);\r\n\r\n            this._tmpAmmoQuaternion.setValue(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\r\n            trans.setRotation(this._tmpAmmoQuaternion);\r\n            impostor.physicsBody.setWorldTransform(trans);\r\n\r\n            if (impostor.mass == 0) {\r\n                // Kinematic objects must be updated using motion state\r\n                const motionState = impostor.physicsBody.getMotionState();\r\n                if (motionState) {\r\n                    motionState.setWorldTransform(trans);\r\n                }\r\n            } else {\r\n                impostor.physicsBody.activate();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If this plugin is supported\r\n     * @returns true if its supported\r\n     */\r\n    public isSupported(): boolean {\r\n        return this.bjsAMMO !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Sets the linear velocity of the physics body\r\n     * @param impostor imposter to set the velocity on\r\n     * @param velocity velocity to set\r\n     */\r\n    public setLinearVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.linearVelocity(this._tmpAmmoVectorA);\r\n        } else {\r\n            impostor.physicsBody.setLinearVelocity(this._tmpAmmoVectorA);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the angular velocity of the physics body\r\n     * @param impostor imposter to set the velocity on\r\n     * @param velocity velocity to set\r\n     */\r\n    public setAngularVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.angularVelocity(this._tmpAmmoVectorA);\r\n        } else {\r\n            impostor.physicsBody.setAngularVelocity(this._tmpAmmoVectorA);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * gets the linear velocity\r\n     * @param impostor imposter to get linear velocity from\r\n     * @returns linear velocity\r\n     */\r\n    public getLinearVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        let v: any;\r\n        if (impostor.soft) {\r\n            v = impostor.physicsBody.linearVelocity();\r\n        } else {\r\n            v = impostor.physicsBody.getLinearVelocity();\r\n        }\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        const result = new Vector3(v.x(), v.y(), v.z());\r\n        this.bjsAMMO.destroy(v);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * gets the angular velocity\r\n     * @param impostor imposter to get angular velocity from\r\n     * @returns angular velocity\r\n     */\r\n    public getAngularVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        let v: any;\r\n        if (impostor.soft) {\r\n            v = impostor.physicsBody.angularVelocity();\r\n        } else {\r\n            v = impostor.physicsBody.getAngularVelocity();\r\n        }\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        const result = new Vector3(v.x(), v.y(), v.z());\r\n        this.bjsAMMO.destroy(v);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the mass of physics body\r\n     * @param impostor imposter to set the mass on\r\n     * @param mass mass to set\r\n     */\r\n    public setBodyMass(impostor: PhysicsImpostor, mass: number) {\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.setTotalMass(mass, false);\r\n        } else {\r\n            impostor.physicsBody.setMassProps(mass);\r\n        }\r\n        impostor._pluginData.mass = mass;\r\n    }\r\n\r\n    /**\r\n     * Gets the mass of the physics body\r\n     * @param impostor imposter to get the mass from\r\n     * @returns mass\r\n     */\r\n    public getBodyMass(impostor: PhysicsImpostor): number {\r\n        return impostor._pluginData.mass || 0;\r\n    }\r\n\r\n    /**\r\n     * Gets friction of the impostor\r\n     * @param impostor impostor to get friction from\r\n     * @returns friction value\r\n     */\r\n    public getBodyFriction(impostor: PhysicsImpostor): number {\r\n        return impostor._pluginData.friction || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets friction of the impostor\r\n     * @param impostor impostor to set friction on\r\n     * @param friction friction value\r\n     */\r\n    public setBodyFriction(impostor: PhysicsImpostor, friction: number) {\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.get_m_cfg().set_kDF(friction);\r\n        } else {\r\n            impostor.physicsBody.setFriction(friction);\r\n        }\r\n        impostor._pluginData.friction = friction;\r\n    }\r\n\r\n    /**\r\n     * Gets restitution of the impostor\r\n     * @param impostor impostor to get restitution from\r\n     * @returns restitution value\r\n     */\r\n    public getBodyRestitution(impostor: PhysicsImpostor): number {\r\n        return impostor._pluginData.restitution || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets restitution of the impostor\r\n     * @param impostor impostor to set resitution on\r\n     * @param restitution resitution value\r\n     */\r\n    public setBodyRestitution(impostor: PhysicsImpostor, restitution: number) {\r\n        impostor.physicsBody.setRestitution(restitution);\r\n        impostor._pluginData.restitution = restitution;\r\n    }\r\n\r\n    /**\r\n     * Gets pressure inside the impostor\r\n     * @param impostor impostor to get pressure from\r\n     * @returns pressure value\r\n     */\r\n    public getBodyPressure(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Pressure is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.pressure || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets pressure inside a soft body impostor\r\n     * Cloth and rope must remain 0 pressure\r\n     * @param impostor impostor to set pressure on\r\n     * @param pressure pressure value\r\n     */\r\n    public setBodyPressure(impostor: PhysicsImpostor, pressure: number) {\r\n        if (impostor.soft) {\r\n            if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {\r\n                impostor.physicsBody.get_m_cfg().set_kPR(pressure);\r\n                impostor._pluginData.pressure = pressure;\r\n            } else {\r\n                impostor.physicsBody.get_m_cfg().set_kPR(0);\r\n                impostor._pluginData.pressure = 0;\r\n            }\r\n        } else {\r\n            Logger.Warn(\"Pressure can only be applied to a softbody\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets stiffness of the impostor\r\n     * @param impostor impostor to get stiffness from\r\n     * @returns pressure value\r\n     */\r\n    public getBodyStiffness(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Stiffness is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.stiffness || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets stiffness of the impostor\r\n     * @param impostor impostor to set stiffness on\r\n     * @param stiffness stiffness value from 0 to 1\r\n     */\r\n    public setBodyStiffness(impostor: PhysicsImpostor, stiffness: number) {\r\n        if (impostor.soft) {\r\n            stiffness = stiffness < 0 ? 0 : stiffness;\r\n            stiffness = stiffness > 1 ? 1 : stiffness;\r\n            impostor.physicsBody.get_m_materials().at(0).set_m_kLST(stiffness);\r\n            impostor._pluginData.stiffness = stiffness;\r\n        } else {\r\n            Logger.Warn(\"Stiffness cannot be applied to a rigid body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets velocityIterations of the impostor\r\n     * @param impostor impostor to get velocity iterations from\r\n     * @returns velocityIterations value\r\n     */\r\n    public getBodyVelocityIterations(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Velocity iterations is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.velocityIterations || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets velocityIterations of the impostor\r\n     * @param impostor impostor to set velocity iterations on\r\n     * @param velocityIterations velocityIterations value\r\n     */\r\n    public setBodyVelocityIterations(impostor: PhysicsImpostor, velocityIterations: number) {\r\n        if (impostor.soft) {\r\n            velocityIterations = velocityIterations < 0 ? 0 : velocityIterations;\r\n            impostor.physicsBody.get_m_cfg().set_viterations(velocityIterations);\r\n            impostor._pluginData.velocityIterations = velocityIterations;\r\n        } else {\r\n            Logger.Warn(\"Velocity iterations cannot be applied to a rigid body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets positionIterations of the impostor\r\n     * @param impostor impostor to get position iterations from\r\n     * @returns positionIterations value\r\n     */\r\n    public getBodyPositionIterations(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Position iterations is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.positionIterations || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets positionIterations of the impostor\r\n     * @param impostor impostor to set position on\r\n     * @param positionIterations positionIterations value\r\n     */\r\n    public setBodyPositionIterations(impostor: PhysicsImpostor, positionIterations: number) {\r\n        if (impostor.soft) {\r\n            positionIterations = positionIterations < 0 ? 0 : positionIterations;\r\n            impostor.physicsBody.get_m_cfg().set_piterations(positionIterations);\r\n            impostor._pluginData.positionIterations = positionIterations;\r\n        } else {\r\n            Logger.Warn(\"Position iterations cannot be applied to a rigid body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Append an anchor to a cloth object\r\n     * @param impostor is the cloth impostor to add anchor to\r\n     * @param otherImpostor is the rigid impostor to anchor to\r\n     * @param width ratio across width from 0 to 1\r\n     * @param height ratio up height from 0 to 1\r\n     * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little stretch\r\n     * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\r\n     */\r\n    public appendAnchor(\r\n        impostor: PhysicsImpostor,\r\n        otherImpostor: PhysicsImpostor,\r\n        width: number,\r\n        height: number,\r\n        influence: number = 1,\r\n        noCollisionBetweenLinkedBodies: boolean = false\r\n    ) {\r\n        const segs = impostor.segments;\r\n        const nbAcross = Math.round((segs - 1) * width);\r\n        const nbUp = Math.round((segs - 1) * height);\r\n        const nbDown = segs - 1 - nbUp;\r\n        const node = nbAcross + segs * nbDown;\r\n        impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);\r\n    }\r\n\r\n    /**\r\n     * Append an hook to a rope object\r\n     * @param impostor is the rope impostor to add hook to\r\n     * @param otherImpostor is the rigid impostor to hook to\r\n     * @param length ratio along the rope from 0 to 1\r\n     * @param influence the elasticity between soft impostor and anchor from 0, very stretchy to 1, little stretch\r\n     * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\r\n     */\r\n    public appendHook(impostor: PhysicsImpostor, otherImpostor: PhysicsImpostor, length: number, influence: number = 1, noCollisionBetweenLinkedBodies: boolean = false) {\r\n        const node = Math.round(impostor.segments * length);\r\n        impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);\r\n    }\r\n\r\n    /**\r\n     * Sleeps the physics body and stops it from being active\r\n     * @param impostor impostor to sleep\r\n     */\r\n    public sleepBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.forceActivationState(0);\r\n    }\r\n\r\n    /**\r\n     * Activates the physics body\r\n     * @param impostor impostor to activate\r\n     */\r\n    public wakeUpBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.activate();\r\n    }\r\n\r\n    /**\r\n     * Updates the distance parameters of the joint\r\n     */\r\n    public updateDistanceJoint() {\r\n        Logger.Warn(\"updateDistanceJoint is not currently supported by the Ammo physics plugin\");\r\n    }\r\n\r\n    /**\r\n     * Sets a motor on the joint\r\n     * @param joint joint to set motor on\r\n     * @param speed speed of the motor\r\n     * @param maxForce maximum force of the motor\r\n     */\r\n    public setMotor(joint: IMotorEnabledJoint, speed?: number, maxForce?: number) {\r\n        joint.physicsJoint.enableAngularMotor(true, speed, maxForce);\r\n    }\r\n\r\n    /**\r\n     * Sets the motors limit\r\n     */\r\n    public setLimit() {\r\n        Logger.Warn(\"setLimit is not currently supported by the Ammo physics plugin\");\r\n    }\r\n\r\n    /**\r\n     * Syncs the position and rotation of a mesh with the impostor\r\n     * @param mesh mesh to sync\r\n     * @param impostor impostor to update the mesh with\r\n     */\r\n    public syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor) {\r\n        const body = impostor.physicsBody;\r\n\r\n        body.getMotionState().getWorldTransform(this._tmpAmmoTransform);\r\n\r\n        mesh.position.x = this._tmpAmmoTransform.getOrigin().x();\r\n        mesh.position.y = this._tmpAmmoTransform.getOrigin().y();\r\n        mesh.position.z = this._tmpAmmoTransform.getOrigin().z();\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            mesh.rotationQuaternion.x = this._tmpAmmoTransform.getRotation().x();\r\n            mesh.rotationQuaternion.y = this._tmpAmmoTransform.getRotation().y();\r\n            mesh.rotationQuaternion.z = this._tmpAmmoTransform.getRotation().z();\r\n            mesh.rotationQuaternion.w = this._tmpAmmoTransform.getRotation().w();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the radius of the impostor\r\n     * @param impostor impostor to get radius from\r\n     * @returns the radius\r\n     */\r\n    public getRadius(impostor: PhysicsImpostor): number {\r\n        const extents = impostor.getObjectExtents();\r\n        return extents.x / 2;\r\n    }\r\n\r\n    /**\r\n     * Gets the box size of the impostor\r\n     * @param impostor impostor to get box size from\r\n     * @param result the resulting box size\r\n     */\r\n    public getBoxSizeToRef(impostor: PhysicsImpostor, result: Vector3): void {\r\n        const extents = impostor.getObjectExtents();\r\n        result.x = extents.x;\r\n        result.y = extents.y;\r\n        result.z = extents.z;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the impostor\r\n     */\r\n    public dispose() {\r\n        // Dispose of world\r\n        this.bjsAMMO.destroy(this.world);\r\n        this.bjsAMMO.destroy(this._solver);\r\n        this.bjsAMMO.destroy(this._overlappingPairCache);\r\n        this.bjsAMMO.destroy(this._dispatcher);\r\n        this.bjsAMMO.destroy(this._collisionConfiguration);\r\n\r\n        // Dispose of temp variables\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorA);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorB);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorC);\r\n        this.bjsAMMO.destroy(this._tmpAmmoTransform);\r\n        this.bjsAMMO.destroy(this._tmpAmmoQuaternion);\r\n        this.bjsAMMO.destroy(this._tmpAmmoConcreteContactResultCallback);\r\n\r\n        this.world = null;\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from where should the ray start?\r\n     * @param to where should the ray end?\r\n     * @returns PhysicsRaycastResult\r\n     */\r\n    public raycast(from: Vector3, to: Vector3): PhysicsRaycastResult {\r\n        this.raycastToRef(from, to, this._raycastResult);\r\n        return this._raycastResult;\r\n    }\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @param result resulting PhysicsRaycastResult\r\n     */\r\n    public raycastToRef(from: Vector3, to: Vector3, result: PhysicsRaycastResult): void {\r\n        this._tmpAmmoVectorRCA = new this.bjsAMMO.btVector3(from.x, from.y, from.z);\r\n        this._tmpAmmoVectorRCB = new this.bjsAMMO.btVector3(to.x, to.y, to.z);\r\n\r\n        const rayCallback = new this.bjsAMMO.ClosestRayResultCallback(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB);\r\n        this.world.rayTest(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB, rayCallback);\r\n\r\n        result.reset(from, to);\r\n        if (rayCallback.hasHit()) {\r\n            // TODO: do we want/need the body? If so, set all the data\r\n            /*\r\n            var rigidBody = this.bjsAMMO.btRigidBody.prototype.upcast(\r\n                rayCallback.get_m_collisionObject()\r\n            );\r\n            var body = {};\r\n            */\r\n            result.setHitData(\r\n                {\r\n                    x: rayCallback.get_m_hitNormalWorld().x(),\r\n                    y: rayCallback.get_m_hitNormalWorld().y(),\r\n                    z: rayCallback.get_m_hitNormalWorld().z(),\r\n                },\r\n                {\r\n                    x: rayCallback.get_m_hitPointWorld().x(),\r\n                    y: rayCallback.get_m_hitPointWorld().y(),\r\n                    z: rayCallback.get_m_hitPointWorld().z(),\r\n                }\r\n            );\r\n            result.calculateHitDistance();\r\n        }\r\n        this.bjsAMMO.destroy(rayCallback);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorRCA);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorRCB);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}