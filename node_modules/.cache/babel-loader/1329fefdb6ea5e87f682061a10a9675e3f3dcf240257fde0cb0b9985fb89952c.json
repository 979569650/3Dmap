{"ast":null,"code":"import { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { Vector3, Quaternion, Matrix } from \"../Maths/math.vector.js\";\nimport { Space, Axis } from \"../Maths/math.axis.js\";\n/**\n * Class used to make a bone look toward a point in space\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons#bonelookcontroller\n */\nexport class BoneLookController {\n  /**\n   * Gets or sets the minimum yaw angle that the bone can look to\n   */\n  get minYaw() {\n    return this._minYaw;\n  }\n  set minYaw(value) {\n    this._minYaw = value;\n    this._minYawSin = Math.sin(value);\n    this._minYawCos = Math.cos(value);\n    if (this._maxYaw != null) {\n      this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * 0.5 + this._minYaw;\n      this._yawRange = this._maxYaw - this._minYaw;\n    }\n  }\n  /**\n   * Gets or sets the maximum yaw angle that the bone can look to\n   */\n  get maxYaw() {\n    return this._maxYaw;\n  }\n  set maxYaw(value) {\n    this._maxYaw = value;\n    this._maxYawSin = Math.sin(value);\n    this._maxYawCos = Math.cos(value);\n    if (this._minYaw != null) {\n      this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * 0.5 + this._minYaw;\n      this._yawRange = this._maxYaw - this._minYaw;\n    }\n  }\n  /**\n   * Gets or sets the minimum pitch angle that the bone can look to\n   */\n  get minPitch() {\n    return this._minPitch;\n  }\n  set minPitch(value) {\n    this._minPitch = value;\n    this._minPitchTan = Math.tan(value);\n  }\n  /**\n   * Gets or sets the maximum pitch angle that the bone can look to\n   */\n  get maxPitch() {\n    return this._maxPitch;\n  }\n  set maxPitch(value) {\n    this._maxPitch = value;\n    this._maxPitchTan = Math.tan(value);\n  }\n  /**\n   * Create a BoneLookController\n   * @param mesh the TransformNode that the bone belongs to\n   * @param bone the bone that will be looking to the target\n   * @param target the target Vector3 to look at\n   * @param options optional settings:\n   * * maxYaw: the maximum angle the bone will yaw to\n   * * minYaw: the minimum angle the bone will yaw to\n   * * maxPitch: the maximum angle the bone will pitch to\n   * * minPitch: the minimum angle the bone will yaw to\n   * * slerpAmount: set the between 0 and 1 to make the bone slerp to the target.\n   * * upAxis: the up axis of the coordinate system\n   * * upAxisSpace: the space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD.\n   * * yawAxis: set yawAxis if the bone does not yaw on the y axis\n   * * pitchAxis: set pitchAxis if the bone does not pitch on the x axis\n   * * adjustYaw: used to make an adjustment to the yaw of the bone\n   * * adjustPitch: used to make an adjustment to the pitch of the bone\n   * * adjustRoll: used to make an adjustment to the roll of the bone\n   * @param options.maxYaw\n   * @param options.minYaw\n   * @param options.maxPitch\n   * @param options.minPitch\n   * @param options.slerpAmount\n   * @param options.upAxis\n   * @param options.upAxisSpace\n   * @param options.yawAxis\n   * @param options.pitchAxis\n   * @param options.adjustYaw\n   * @param options.adjustPitch\n   * @param options.adjustRoll\n   **/\n  constructor(mesh, bone, target, options) {\n    /**\n     * The up axis of the coordinate system that is used when the bone is rotated\n     */\n    this.upAxis = Vector3.Up();\n    /**\n     * The space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD\n     */\n    this.upAxisSpace = Space.LOCAL;\n    /**\n     * Used to make an adjustment to the yaw of the bone\n     */\n    this.adjustYaw = 0;\n    /**\n     * Used to make an adjustment to the pitch of the bone\n     */\n    this.adjustPitch = 0;\n    /**\n     * Used to make an adjustment to the roll of the bone\n     */\n    this.adjustRoll = 0;\n    /**\n     * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)\n     */\n    this.slerpAmount = 1;\n    this._boneQuat = Quaternion.Identity();\n    this._slerping = false;\n    this._firstFrameSkipped = false;\n    this._fowardAxis = Vector3.Forward();\n    /**\n     * Use the absolute value for yaw when checking the min/max constraints\n     */\n    this.useAbsoluteValueForYaw = false;\n    this.mesh = mesh;\n    this.bone = bone;\n    this.target = target;\n    if (options) {\n      if (options.adjustYaw) {\n        this.adjustYaw = options.adjustYaw;\n      }\n      if (options.adjustPitch) {\n        this.adjustPitch = options.adjustPitch;\n      }\n      if (options.adjustRoll) {\n        this.adjustRoll = options.adjustRoll;\n      }\n      if (options.maxYaw != null) {\n        this.maxYaw = options.maxYaw;\n      } else {\n        this.maxYaw = Math.PI;\n      }\n      if (options.minYaw != null) {\n        this.minYaw = options.minYaw;\n      } else {\n        this.minYaw = -Math.PI;\n      }\n      if (options.maxPitch != null) {\n        this.maxPitch = options.maxPitch;\n      } else {\n        this.maxPitch = Math.PI;\n      }\n      if (options.minPitch != null) {\n        this.minPitch = options.minPitch;\n      } else {\n        this.minPitch = -Math.PI;\n      }\n      if (options.slerpAmount != null) {\n        this.slerpAmount = options.slerpAmount;\n      }\n      if (options.upAxis != null) {\n        this.upAxis = options.upAxis;\n      }\n      if (options.upAxisSpace != null) {\n        this.upAxisSpace = options.upAxisSpace;\n      }\n      if (options.yawAxis != null || options.pitchAxis != null) {\n        let newYawAxis = Axis.Y;\n        let newPitchAxis = Axis.X;\n        if (options.yawAxis != null) {\n          newYawAxis = options.yawAxis.clone();\n          newYawAxis.normalize();\n        }\n        if (options.pitchAxis != null) {\n          newPitchAxis = options.pitchAxis.clone();\n          newPitchAxis.normalize();\n        }\n        const newRollAxis = Vector3.Cross(newPitchAxis, newYawAxis);\n        this._transformYawPitch = Matrix.Identity();\n        Matrix.FromXYZAxesToRef(newPitchAxis, newYawAxis, newRollAxis, this._transformYawPitch);\n        this._transformYawPitchInv = this._transformYawPitch.clone();\n        this._transformYawPitch.invert();\n      }\n      if (options.useAbsoluteValueForYaw !== undefined) {\n        this.useAbsoluteValueForYaw = options.useAbsoluteValueForYaw;\n      }\n    }\n    if (!bone.getParent() && this.upAxisSpace == Space.BONE) {\n      this.upAxisSpace = Space.LOCAL;\n    }\n  }\n  /**\n   * Update the bone to look at the target.  This should be called before the scene is rendered (use scene.registerBeforeRender())\n   */\n  update() {\n    //skip the first frame when slerping so that the TransformNode rotation is correct\n    if (this.slerpAmount < 1 && !this._firstFrameSkipped) {\n      this._firstFrameSkipped = true;\n      return;\n    }\n    const bone = this.bone;\n    const bonePos = BoneLookController._TmpVecs[0];\n    bone.getAbsolutePositionToRef(this.mesh, bonePos);\n    let target = this.target;\n    const _tmpMat1 = BoneLookController._TmpMats[0];\n    const _tmpMat2 = BoneLookController._TmpMats[1];\n    const mesh = this.mesh;\n    const parentBone = bone.getParent();\n    const upAxis = BoneLookController._TmpVecs[1];\n    upAxis.copyFrom(this.upAxis);\n    if (this.upAxisSpace == Space.BONE && parentBone) {\n      if (this._transformYawPitch) {\n        Vector3.TransformCoordinatesToRef(upAxis, this._transformYawPitchInv, upAxis);\n      }\n      parentBone.getDirectionToRef(upAxis, this.mesh, upAxis);\n    } else if (this.upAxisSpace == Space.LOCAL) {\n      mesh.getDirectionToRef(upAxis, upAxis);\n      if (mesh.scaling.x != 1 || mesh.scaling.y != 1 || mesh.scaling.z != 1) {\n        upAxis.normalize();\n      }\n    }\n    let checkYaw = false;\n    let checkPitch = false;\n    if (this._maxYaw != Math.PI || this._minYaw != -Math.PI) {\n      checkYaw = true;\n    }\n    if (this._maxPitch != Math.PI || this._minPitch != -Math.PI) {\n      checkPitch = true;\n    }\n    if (checkYaw || checkPitch) {\n      const spaceMat = BoneLookController._TmpMats[2];\n      const spaceMatInv = BoneLookController._TmpMats[3];\n      if (this.upAxisSpace == Space.BONE && upAxis.y == 1 && parentBone) {\n        parentBone.getRotationMatrixToRef(Space.WORLD, this.mesh, spaceMat);\n      } else if (this.upAxisSpace == Space.LOCAL && upAxis.y == 1 && !parentBone) {\n        spaceMat.copyFrom(mesh.getWorldMatrix());\n      } else {\n        let forwardAxis = BoneLookController._TmpVecs[2];\n        forwardAxis.copyFrom(this._fowardAxis);\n        if (this._transformYawPitch) {\n          Vector3.TransformCoordinatesToRef(forwardAxis, this._transformYawPitchInv, forwardAxis);\n        }\n        if (parentBone) {\n          parentBone.getDirectionToRef(forwardAxis, this.mesh, forwardAxis);\n        } else {\n          mesh.getDirectionToRef(forwardAxis, forwardAxis);\n        }\n        const rightAxis = Vector3.Cross(upAxis, forwardAxis);\n        rightAxis.normalize();\n        forwardAxis = Vector3.Cross(rightAxis, upAxis);\n        Matrix.FromXYZAxesToRef(rightAxis, upAxis, forwardAxis, spaceMat);\n      }\n      spaceMat.invertToRef(spaceMatInv);\n      let xzlen = null;\n      if (checkPitch) {\n        const localTarget = BoneLookController._TmpVecs[3];\n        target.subtractToRef(bonePos, localTarget);\n        Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);\n        xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\n        const pitch = Math.atan2(localTarget.y, xzlen);\n        let newPitch = pitch;\n        if (pitch > this._maxPitch) {\n          localTarget.y = this._maxPitchTan * xzlen;\n          newPitch = this._maxPitch;\n        } else if (pitch < this._minPitch) {\n          localTarget.y = this._minPitchTan * xzlen;\n          newPitch = this._minPitch;\n        }\n        if (pitch != newPitch) {\n          Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);\n          localTarget.addInPlace(bonePos);\n          target = localTarget;\n        }\n      }\n      if (checkYaw) {\n        const localTarget = BoneLookController._TmpVecs[4];\n        target.subtractToRef(bonePos, localTarget);\n        Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);\n        const yaw = Math.atan2(localTarget.x, localTarget.z);\n        const yawCheck = this.useAbsoluteValueForYaw ? Math.abs(yaw) : yaw;\n        let newYaw = yaw;\n        if (yawCheck > this._maxYaw || yawCheck < this._minYaw) {\n          if (xzlen == null) {\n            xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\n          }\n          if (this._yawRange > Math.PI) {\n            if (this._isAngleBetween(yaw, this._maxYaw, this._midYawConstraint)) {\n              localTarget.z = this._maxYawCos * xzlen;\n              localTarget.x = this._maxYawSin * xzlen;\n              newYaw = this._maxYaw;\n            } else if (this._isAngleBetween(yaw, this._midYawConstraint, this._minYaw)) {\n              localTarget.z = this._minYawCos * xzlen;\n              localTarget.x = this._minYawSin * xzlen;\n              newYaw = this._minYaw;\n            }\n          } else {\n            if (yawCheck > this._maxYaw) {\n              localTarget.z = this._maxYawCos * xzlen;\n              localTarget.x = this._maxYawSin * xzlen;\n              if (yaw < 0 && this.useAbsoluteValueForYaw) {\n                localTarget.x *= -1;\n              }\n              newYaw = this._maxYaw;\n            } else if (yawCheck < this._minYaw) {\n              localTarget.z = this._minYawCos * xzlen;\n              localTarget.x = this._minYawSin * xzlen;\n              if (yaw < 0 && this.useAbsoluteValueForYaw) {\n                localTarget.x *= -1;\n              }\n              newYaw = this._minYaw;\n            }\n          }\n        }\n        if (this._slerping && this._yawRange > Math.PI) {\n          //are we going to be crossing into the min/max region?\n          const boneFwd = BoneLookController._TmpVecs[8];\n          boneFwd.copyFrom(Axis.Z);\n          if (this._transformYawPitch) {\n            Vector3.TransformCoordinatesToRef(boneFwd, this._transformYawPitchInv, boneFwd);\n          }\n          const boneRotMat = BoneLookController._TmpMats[4];\n          this._boneQuat.toRotationMatrix(boneRotMat);\n          this.mesh.getWorldMatrix().multiplyToRef(boneRotMat, boneRotMat);\n          Vector3.TransformCoordinatesToRef(boneFwd, boneRotMat, boneFwd);\n          Vector3.TransformCoordinatesToRef(boneFwd, spaceMatInv, boneFwd);\n          const boneYaw = Math.atan2(boneFwd.x, boneFwd.z);\n          const angBtwTar = this._getAngleBetween(boneYaw, yaw);\n          const angBtwMidYaw = this._getAngleBetween(boneYaw, this._midYawConstraint);\n          if (angBtwTar > angBtwMidYaw) {\n            if (xzlen == null) {\n              xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\n            }\n            const angBtwMax = this._getAngleBetween(boneYaw, this._maxYaw);\n            const angBtwMin = this._getAngleBetween(boneYaw, this._minYaw);\n            if (angBtwMin < angBtwMax) {\n              newYaw = boneYaw + Math.PI * 0.75;\n              localTarget.z = Math.cos(newYaw) * xzlen;\n              localTarget.x = Math.sin(newYaw) * xzlen;\n            } else {\n              newYaw = boneYaw - Math.PI * 0.75;\n              localTarget.z = Math.cos(newYaw) * xzlen;\n              localTarget.x = Math.sin(newYaw) * xzlen;\n            }\n          }\n        }\n        if (yaw != newYaw) {\n          Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);\n          localTarget.addInPlace(bonePos);\n          target = localTarget;\n        }\n      }\n    }\n    const zaxis = BoneLookController._TmpVecs[5];\n    const xaxis = BoneLookController._TmpVecs[6];\n    const yaxis = BoneLookController._TmpVecs[7];\n    const tmpQuat = BoneLookController._TmpQuat;\n    target.subtractToRef(bonePos, zaxis);\n    zaxis.normalize();\n    Vector3.CrossToRef(upAxis, zaxis, xaxis);\n    xaxis.normalize();\n    Vector3.CrossToRef(zaxis, xaxis, yaxis);\n    yaxis.normalize();\n    Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, _tmpMat1);\n    if (xaxis.x === 0 && xaxis.y === 0 && xaxis.z === 0) {\n      return;\n    }\n    if (yaxis.x === 0 && yaxis.y === 0 && yaxis.z === 0) {\n      return;\n    }\n    if (zaxis.x === 0 && zaxis.y === 0 && zaxis.z === 0) {\n      return;\n    }\n    if (this.adjustYaw || this.adjustPitch || this.adjustRoll) {\n      Matrix.RotationYawPitchRollToRef(this.adjustYaw, this.adjustPitch, this.adjustRoll, _tmpMat2);\n      _tmpMat2.multiplyToRef(_tmpMat1, _tmpMat1);\n    }\n    if (this.slerpAmount < 1) {\n      if (!this._slerping) {\n        this.bone.getRotationQuaternionToRef(Space.WORLD, this.mesh, this._boneQuat);\n      }\n      if (this._transformYawPitch) {\n        this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);\n      }\n      Quaternion.FromRotationMatrixToRef(_tmpMat1, tmpQuat);\n      Quaternion.SlerpToRef(this._boneQuat, tmpQuat, this.slerpAmount, this._boneQuat);\n      this.bone.setRotationQuaternion(this._boneQuat, Space.WORLD, this.mesh);\n      this._slerping = true;\n    } else {\n      if (this._transformYawPitch) {\n        this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);\n      }\n      this.bone.setRotationMatrix(_tmpMat1, Space.WORLD, this.mesh);\n      this._slerping = false;\n    }\n    this._updateLinkedTransformRotation();\n  }\n  _getAngleDiff(ang1, ang2) {\n    let angDiff = ang2 - ang1;\n    angDiff %= Math.PI * 2;\n    if (angDiff > Math.PI) {\n      angDiff -= Math.PI * 2;\n    } else if (angDiff < -Math.PI) {\n      angDiff += Math.PI * 2;\n    }\n    return angDiff;\n  }\n  _getAngleBetween(ang1, ang2) {\n    ang1 %= 2 * Math.PI;\n    ang1 = ang1 < 0 ? ang1 + 2 * Math.PI : ang1;\n    ang2 %= 2 * Math.PI;\n    ang2 = ang2 < 0 ? ang2 + 2 * Math.PI : ang2;\n    let ab = 0;\n    if (ang1 < ang2) {\n      ab = ang2 - ang1;\n    } else {\n      ab = ang1 - ang2;\n    }\n    if (ab > Math.PI) {\n      ab = Math.PI * 2 - ab;\n    }\n    return ab;\n  }\n  _isAngleBetween(ang, ang1, ang2) {\n    ang %= 2 * Math.PI;\n    ang = ang < 0 ? ang + 2 * Math.PI : ang;\n    ang1 %= 2 * Math.PI;\n    ang1 = ang1 < 0 ? ang1 + 2 * Math.PI : ang1;\n    ang2 %= 2 * Math.PI;\n    ang2 = ang2 < 0 ? ang2 + 2 * Math.PI : ang2;\n    if (ang1 < ang2) {\n      if (ang > ang1 && ang < ang2) {\n        return true;\n      }\n    } else {\n      if (ang > ang2 && ang < ang1) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _updateLinkedTransformRotation() {\n    const bone = this.bone;\n    if (bone._linkedTransformNode) {\n      if (!bone._linkedTransformNode.rotationQuaternion) {\n        bone._linkedTransformNode.rotationQuaternion = new Quaternion();\n      }\n      bone.getRotationQuaternionToRef(Space.LOCAL, null, bone._linkedTransformNode.rotationQuaternion);\n    }\n  }\n}\nBoneLookController._TmpVecs = ArrayTools.BuildArray(10, Vector3.Zero);\nBoneLookController._TmpQuat = Quaternion.Identity();\nBoneLookController._TmpMats = ArrayTools.BuildArray(5, Matrix.Identity);","map":{"version":3,"names":["ArrayTools","Vector3","Quaternion","Matrix","Space","Axis","BoneLookController","minYaw","_minYaw","value","_minYawSin","Math","sin","_minYawCos","cos","_maxYaw","_midYawConstraint","_getAngleDiff","_yawRange","maxYaw","_maxYawSin","_maxYawCos","minPitch","_minPitch","_minPitchTan","tan","maxPitch","_maxPitch","_maxPitchTan","constructor","mesh","bone","target","options","upAxis","Up","upAxisSpace","LOCAL","adjustYaw","adjustPitch","adjustRoll","slerpAmount","_boneQuat","Identity","_slerping","_firstFrameSkipped","_fowardAxis","Forward","useAbsoluteValueForYaw","PI","yawAxis","pitchAxis","newYawAxis","Y","newPitchAxis","X","clone","normalize","newRollAxis","Cross","_transformYawPitch","FromXYZAxesToRef","_transformYawPitchInv","invert","undefined","getParent","BONE","update","bonePos","_TmpVecs","getAbsolutePositionToRef","_tmpMat1","_TmpMats","_tmpMat2","parentBone","copyFrom","TransformCoordinatesToRef","getDirectionToRef","scaling","x","y","z","checkYaw","checkPitch","spaceMat","spaceMatInv","getRotationMatrixToRef","WORLD","getWorldMatrix","forwardAxis","rightAxis","invertToRef","xzlen","localTarget","subtractToRef","sqrt","pitch","atan2","newPitch","addInPlace","yaw","yawCheck","abs","newYaw","_isAngleBetween","boneFwd","Z","boneRotMat","toRotationMatrix","multiplyToRef","boneYaw","angBtwTar","_getAngleBetween","angBtwMidYaw","angBtwMax","angBtwMin","zaxis","xaxis","yaxis","tmpQuat","_TmpQuat","CrossToRef","RotationYawPitchRollToRef","getRotationQuaternionToRef","FromRotationMatrixToRef","SlerpToRef","setRotationQuaternion","setRotationMatrix","_updateLinkedTransformRotation","ang1","ang2","angDiff","ab","ang","_linkedTransformNode","rotationQuaternion","BuildArray","Zero"],"sources":["../../../../dev/core/src/Bones/boneLookController.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport { Vector3, Quaternion, Matrix } from \"../Maths/math.vector\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { Bone } from \"./bone\";\r\nimport { Space, Axis } from \"../Maths/math.axis\";\r\n\r\n/**\r\n * Class used to make a bone look toward a point in space\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons#bonelookcontroller\r\n */\r\nexport class BoneLookController {\r\n    private static _TmpVecs: Vector3[] = ArrayTools.BuildArray(10, Vector3.Zero);\r\n    private static _TmpQuat = Quaternion.Identity();\r\n    private static _TmpMats: Matrix[] = ArrayTools.BuildArray(5, Matrix.Identity);\r\n\r\n    /**\r\n     * The target Vector3 that the bone will look at\r\n     */\r\n    public target: Vector3;\r\n\r\n    /**\r\n     * The TransformNode that the bone is attached to\r\n     * Name kept as mesh for back compatibility\r\n     */\r\n    public mesh: TransformNode;\r\n\r\n    /**\r\n     * The bone that will be looking to the target\r\n     */\r\n    public bone: Bone;\r\n\r\n    /**\r\n     * The up axis of the coordinate system that is used when the bone is rotated\r\n     */\r\n    public upAxis: Vector3 = Vector3.Up();\r\n\r\n    /**\r\n     * The space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD\r\n     */\r\n    public upAxisSpace: Space = Space.LOCAL;\r\n\r\n    /**\r\n     * Used to make an adjustment to the yaw of the bone\r\n     */\r\n    public adjustYaw = 0;\r\n\r\n    /**\r\n     * Used to make an adjustment to the pitch of the bone\r\n     */\r\n    public adjustPitch = 0;\r\n\r\n    /**\r\n     * Used to make an adjustment to the roll of the bone\r\n     */\r\n    public adjustRoll = 0;\r\n\r\n    /**\r\n     * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)\r\n     */\r\n    public slerpAmount = 1;\r\n\r\n    private _minYaw: number;\r\n    private _maxYaw: number;\r\n    private _minPitch: number;\r\n    private _maxPitch: number;\r\n    private _minYawSin: number;\r\n    private _minYawCos: number;\r\n    private _maxYawSin: number;\r\n    private _maxYawCos: number;\r\n    private _midYawConstraint: number;\r\n    private _minPitchTan: number;\r\n    private _maxPitchTan: number;\r\n\r\n    private _boneQuat: Quaternion = Quaternion.Identity();\r\n    private _slerping = false;\r\n    private _transformYawPitch: Matrix;\r\n    private _transformYawPitchInv: Matrix;\r\n    private _firstFrameSkipped = false;\r\n    private _yawRange: number;\r\n    private _fowardAxis: Vector3 = Vector3.Forward();\r\n\r\n    /**\r\n     * Gets or sets the minimum yaw angle that the bone can look to\r\n     */\r\n    get minYaw(): number {\r\n        return this._minYaw;\r\n    }\r\n\r\n    set minYaw(value: number) {\r\n        this._minYaw = value;\r\n        this._minYawSin = Math.sin(value);\r\n        this._minYawCos = Math.cos(value);\r\n        if (this._maxYaw != null) {\r\n            this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * 0.5 + this._minYaw;\r\n            this._yawRange = this._maxYaw - this._minYaw;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the maximum yaw angle that the bone can look to\r\n     */\r\n    get maxYaw(): number {\r\n        return this._maxYaw;\r\n    }\r\n\r\n    set maxYaw(value: number) {\r\n        this._maxYaw = value;\r\n        this._maxYawSin = Math.sin(value);\r\n        this._maxYawCos = Math.cos(value);\r\n        if (this._minYaw != null) {\r\n            this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * 0.5 + this._minYaw;\r\n            this._yawRange = this._maxYaw - this._minYaw;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Use the absolute value for yaw when checking the min/max constraints\r\n     */\r\n    public useAbsoluteValueForYaw = false;\r\n\r\n    /**\r\n     * Gets or sets the minimum pitch angle that the bone can look to\r\n     */\r\n    get minPitch(): number {\r\n        return this._minPitch;\r\n    }\r\n\r\n    set minPitch(value: number) {\r\n        this._minPitch = value;\r\n        this._minPitchTan = Math.tan(value);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the maximum pitch angle that the bone can look to\r\n     */\r\n    get maxPitch(): number {\r\n        return this._maxPitch;\r\n    }\r\n\r\n    set maxPitch(value: number) {\r\n        this._maxPitch = value;\r\n        this._maxPitchTan = Math.tan(value);\r\n    }\r\n\r\n    /**\r\n     * Create a BoneLookController\r\n     * @param mesh the TransformNode that the bone belongs to\r\n     * @param bone the bone that will be looking to the target\r\n     * @param target the target Vector3 to look at\r\n     * @param options optional settings:\r\n     * * maxYaw: the maximum angle the bone will yaw to\r\n     * * minYaw: the minimum angle the bone will yaw to\r\n     * * maxPitch: the maximum angle the bone will pitch to\r\n     * * minPitch: the minimum angle the bone will yaw to\r\n     * * slerpAmount: set the between 0 and 1 to make the bone slerp to the target.\r\n     * * upAxis: the up axis of the coordinate system\r\n     * * upAxisSpace: the space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD.\r\n     * * yawAxis: set yawAxis if the bone does not yaw on the y axis\r\n     * * pitchAxis: set pitchAxis if the bone does not pitch on the x axis\r\n     * * adjustYaw: used to make an adjustment to the yaw of the bone\r\n     * * adjustPitch: used to make an adjustment to the pitch of the bone\r\n     * * adjustRoll: used to make an adjustment to the roll of the bone\r\n     * @param options.maxYaw\r\n     * @param options.minYaw\r\n     * @param options.maxPitch\r\n     * @param options.minPitch\r\n     * @param options.slerpAmount\r\n     * @param options.upAxis\r\n     * @param options.upAxisSpace\r\n     * @param options.yawAxis\r\n     * @param options.pitchAxis\r\n     * @param options.adjustYaw\r\n     * @param options.adjustPitch\r\n     * @param options.adjustRoll\r\n     **/\r\n    constructor(\r\n        mesh: TransformNode,\r\n        bone: Bone,\r\n        target: Vector3,\r\n        options?: {\r\n            maxYaw?: number;\r\n            minYaw?: number;\r\n            maxPitch?: number;\r\n            minPitch?: number;\r\n            slerpAmount?: number;\r\n            upAxis?: Vector3;\r\n            upAxisSpace?: Space;\r\n            yawAxis?: Vector3;\r\n            pitchAxis?: Vector3;\r\n            adjustYaw?: number;\r\n            adjustPitch?: number;\r\n            adjustRoll?: number;\r\n            useAbsoluteValueForYaw?: boolean;\r\n        }\r\n    ) {\r\n        this.mesh = mesh;\r\n        this.bone = bone;\r\n        this.target = target;\r\n\r\n        if (options) {\r\n            if (options.adjustYaw) {\r\n                this.adjustYaw = options.adjustYaw;\r\n            }\r\n\r\n            if (options.adjustPitch) {\r\n                this.adjustPitch = options.adjustPitch;\r\n            }\r\n\r\n            if (options.adjustRoll) {\r\n                this.adjustRoll = options.adjustRoll;\r\n            }\r\n\r\n            if (options.maxYaw != null) {\r\n                this.maxYaw = options.maxYaw;\r\n            } else {\r\n                this.maxYaw = Math.PI;\r\n            }\r\n\r\n            if (options.minYaw != null) {\r\n                this.minYaw = options.minYaw;\r\n            } else {\r\n                this.minYaw = -Math.PI;\r\n            }\r\n\r\n            if (options.maxPitch != null) {\r\n                this.maxPitch = options.maxPitch;\r\n            } else {\r\n                this.maxPitch = Math.PI;\r\n            }\r\n\r\n            if (options.minPitch != null) {\r\n                this.minPitch = options.minPitch;\r\n            } else {\r\n                this.minPitch = -Math.PI;\r\n            }\r\n\r\n            if (options.slerpAmount != null) {\r\n                this.slerpAmount = options.slerpAmount;\r\n            }\r\n\r\n            if (options.upAxis != null) {\r\n                this.upAxis = options.upAxis;\r\n            }\r\n\r\n            if (options.upAxisSpace != null) {\r\n                this.upAxisSpace = options.upAxisSpace;\r\n            }\r\n\r\n            if (options.yawAxis != null || options.pitchAxis != null) {\r\n                let newYawAxis = Axis.Y;\r\n                let newPitchAxis = Axis.X;\r\n\r\n                if (options.yawAxis != null) {\r\n                    newYawAxis = options.yawAxis.clone();\r\n                    newYawAxis.normalize();\r\n                }\r\n\r\n                if (options.pitchAxis != null) {\r\n                    newPitchAxis = options.pitchAxis.clone();\r\n                    newPitchAxis.normalize();\r\n                }\r\n\r\n                const newRollAxis = Vector3.Cross(newPitchAxis, newYawAxis);\r\n\r\n                this._transformYawPitch = Matrix.Identity();\r\n                Matrix.FromXYZAxesToRef(newPitchAxis, newYawAxis, newRollAxis, this._transformYawPitch);\r\n\r\n                this._transformYawPitchInv = this._transformYawPitch.clone();\r\n                this._transformYawPitch.invert();\r\n            }\r\n\r\n            if (options.useAbsoluteValueForYaw !== undefined) {\r\n                this.useAbsoluteValueForYaw = options.useAbsoluteValueForYaw;\r\n            }\r\n        }\r\n\r\n        if (!bone.getParent() && this.upAxisSpace == Space.BONE) {\r\n            this.upAxisSpace = Space.LOCAL;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the bone to look at the target.  This should be called before the scene is rendered (use scene.registerBeforeRender())\r\n     */\r\n    public update(): void {\r\n        //skip the first frame when slerping so that the TransformNode rotation is correct\r\n        if (this.slerpAmount < 1 && !this._firstFrameSkipped) {\r\n            this._firstFrameSkipped = true;\r\n            return;\r\n        }\r\n\r\n        const bone = this.bone;\r\n        const bonePos = BoneLookController._TmpVecs[0];\r\n        bone.getAbsolutePositionToRef(this.mesh, bonePos);\r\n\r\n        let target = this.target;\r\n        const _tmpMat1 = BoneLookController._TmpMats[0];\r\n        const _tmpMat2 = BoneLookController._TmpMats[1];\r\n\r\n        const mesh = this.mesh;\r\n        const parentBone = bone.getParent();\r\n\r\n        const upAxis = BoneLookController._TmpVecs[1];\r\n        upAxis.copyFrom(this.upAxis);\r\n\r\n        if (this.upAxisSpace == Space.BONE && parentBone) {\r\n            if (this._transformYawPitch) {\r\n                Vector3.TransformCoordinatesToRef(upAxis, this._transformYawPitchInv, upAxis);\r\n            }\r\n            parentBone.getDirectionToRef(upAxis, this.mesh, upAxis);\r\n        } else if (this.upAxisSpace == Space.LOCAL) {\r\n            mesh.getDirectionToRef(upAxis, upAxis);\r\n            if (mesh.scaling.x != 1 || mesh.scaling.y != 1 || mesh.scaling.z != 1) {\r\n                upAxis.normalize();\r\n            }\r\n        }\r\n\r\n        let checkYaw = false;\r\n        let checkPitch = false;\r\n\r\n        if (this._maxYaw != Math.PI || this._minYaw != -Math.PI) {\r\n            checkYaw = true;\r\n        }\r\n        if (this._maxPitch != Math.PI || this._minPitch != -Math.PI) {\r\n            checkPitch = true;\r\n        }\r\n\r\n        if (checkYaw || checkPitch) {\r\n            const spaceMat = BoneLookController._TmpMats[2];\r\n            const spaceMatInv = BoneLookController._TmpMats[3];\r\n\r\n            if (this.upAxisSpace == Space.BONE && upAxis.y == 1 && parentBone) {\r\n                parentBone.getRotationMatrixToRef(Space.WORLD, this.mesh, spaceMat);\r\n            } else if (this.upAxisSpace == Space.LOCAL && upAxis.y == 1 && !parentBone) {\r\n                spaceMat.copyFrom(mesh.getWorldMatrix());\r\n            } else {\r\n                let forwardAxis = BoneLookController._TmpVecs[2];\r\n                forwardAxis.copyFrom(this._fowardAxis);\r\n\r\n                if (this._transformYawPitch) {\r\n                    Vector3.TransformCoordinatesToRef(forwardAxis, this._transformYawPitchInv, forwardAxis);\r\n                }\r\n\r\n                if (parentBone) {\r\n                    parentBone.getDirectionToRef(forwardAxis, this.mesh, forwardAxis);\r\n                } else {\r\n                    mesh.getDirectionToRef(forwardAxis, forwardAxis);\r\n                }\r\n\r\n                const rightAxis = Vector3.Cross(upAxis, forwardAxis);\r\n                rightAxis.normalize();\r\n                forwardAxis = Vector3.Cross(rightAxis, upAxis);\r\n\r\n                Matrix.FromXYZAxesToRef(rightAxis, upAxis, forwardAxis, spaceMat);\r\n            }\r\n\r\n            spaceMat.invertToRef(spaceMatInv);\r\n\r\n            let xzlen: Nullable<number> = null;\r\n\r\n            if (checkPitch) {\r\n                const localTarget = BoneLookController._TmpVecs[3];\r\n                target.subtractToRef(bonePos, localTarget);\r\n                Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);\r\n\r\n                xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\r\n                const pitch = Math.atan2(localTarget.y, xzlen);\r\n                let newPitch = pitch;\r\n\r\n                if (pitch > this._maxPitch) {\r\n                    localTarget.y = this._maxPitchTan * xzlen;\r\n                    newPitch = this._maxPitch;\r\n                } else if (pitch < this._minPitch) {\r\n                    localTarget.y = this._minPitchTan * xzlen;\r\n                    newPitch = this._minPitch;\r\n                }\r\n\r\n                if (pitch != newPitch) {\r\n                    Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);\r\n                    localTarget.addInPlace(bonePos);\r\n                    target = localTarget;\r\n                }\r\n            }\r\n\r\n            if (checkYaw) {\r\n                const localTarget = BoneLookController._TmpVecs[4];\r\n                target.subtractToRef(bonePos, localTarget);\r\n                Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);\r\n\r\n                const yaw = Math.atan2(localTarget.x, localTarget.z);\r\n                const yawCheck = this.useAbsoluteValueForYaw ? Math.abs(yaw) : yaw;\r\n                let newYaw = yaw;\r\n\r\n                if (yawCheck > this._maxYaw || yawCheck < this._minYaw) {\r\n                    if (xzlen == null) {\r\n                        xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\r\n                    }\r\n\r\n                    if (this._yawRange > Math.PI) {\r\n                        if (this._isAngleBetween(yaw, this._maxYaw, this._midYawConstraint)) {\r\n                            localTarget.z = this._maxYawCos * xzlen;\r\n                            localTarget.x = this._maxYawSin * xzlen;\r\n                            newYaw = this._maxYaw;\r\n                        } else if (this._isAngleBetween(yaw, this._midYawConstraint, this._minYaw)) {\r\n                            localTarget.z = this._minYawCos * xzlen;\r\n                            localTarget.x = this._minYawSin * xzlen;\r\n                            newYaw = this._minYaw;\r\n                        }\r\n                    } else {\r\n                        if (yawCheck > this._maxYaw) {\r\n                            localTarget.z = this._maxYawCos * xzlen;\r\n                            localTarget.x = this._maxYawSin * xzlen;\r\n                            if (yaw < 0 && this.useAbsoluteValueForYaw) {\r\n                                localTarget.x *= -1;\r\n                            }\r\n                            newYaw = this._maxYaw;\r\n                        } else if (yawCheck < this._minYaw) {\r\n                            localTarget.z = this._minYawCos * xzlen;\r\n                            localTarget.x = this._minYawSin * xzlen;\r\n                            if (yaw < 0 && this.useAbsoluteValueForYaw) {\r\n                                localTarget.x *= -1;\r\n                            }\r\n                            newYaw = this._minYaw;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (this._slerping && this._yawRange > Math.PI) {\r\n                    //are we going to be crossing into the min/max region?\r\n                    const boneFwd = BoneLookController._TmpVecs[8];\r\n                    boneFwd.copyFrom(Axis.Z);\r\n                    if (this._transformYawPitch) {\r\n                        Vector3.TransformCoordinatesToRef(boneFwd, this._transformYawPitchInv, boneFwd);\r\n                    }\r\n\r\n                    const boneRotMat = BoneLookController._TmpMats[4];\r\n                    this._boneQuat.toRotationMatrix(boneRotMat);\r\n                    this.mesh.getWorldMatrix().multiplyToRef(boneRotMat, boneRotMat);\r\n                    Vector3.TransformCoordinatesToRef(boneFwd, boneRotMat, boneFwd);\r\n                    Vector3.TransformCoordinatesToRef(boneFwd, spaceMatInv, boneFwd);\r\n\r\n                    const boneYaw = Math.atan2(boneFwd.x, boneFwd.z);\r\n                    const angBtwTar = this._getAngleBetween(boneYaw, yaw);\r\n                    const angBtwMidYaw = this._getAngleBetween(boneYaw, this._midYawConstraint);\r\n\r\n                    if (angBtwTar > angBtwMidYaw) {\r\n                        if (xzlen == null) {\r\n                            xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\r\n                        }\r\n\r\n                        const angBtwMax = this._getAngleBetween(boneYaw, this._maxYaw);\r\n                        const angBtwMin = this._getAngleBetween(boneYaw, this._minYaw);\r\n\r\n                        if (angBtwMin < angBtwMax) {\r\n                            newYaw = boneYaw + Math.PI * 0.75;\r\n                            localTarget.z = Math.cos(newYaw) * xzlen;\r\n                            localTarget.x = Math.sin(newYaw) * xzlen;\r\n                        } else {\r\n                            newYaw = boneYaw - Math.PI * 0.75;\r\n                            localTarget.z = Math.cos(newYaw) * xzlen;\r\n                            localTarget.x = Math.sin(newYaw) * xzlen;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (yaw != newYaw) {\r\n                    Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);\r\n                    localTarget.addInPlace(bonePos);\r\n                    target = localTarget;\r\n                }\r\n            }\r\n        }\r\n\r\n        const zaxis = BoneLookController._TmpVecs[5];\r\n        const xaxis = BoneLookController._TmpVecs[6];\r\n        const yaxis = BoneLookController._TmpVecs[7];\r\n        const tmpQuat = BoneLookController._TmpQuat;\r\n\r\n        target.subtractToRef(bonePos, zaxis);\r\n        zaxis.normalize();\r\n        Vector3.CrossToRef(upAxis, zaxis, xaxis);\r\n        xaxis.normalize();\r\n        Vector3.CrossToRef(zaxis, xaxis, yaxis);\r\n        yaxis.normalize();\r\n        Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, _tmpMat1);\r\n\r\n        if (xaxis.x === 0 && xaxis.y === 0 && xaxis.z === 0) {\r\n            return;\r\n        }\r\n\r\n        if (yaxis.x === 0 && yaxis.y === 0 && yaxis.z === 0) {\r\n            return;\r\n        }\r\n\r\n        if (zaxis.x === 0 && zaxis.y === 0 && zaxis.z === 0) {\r\n            return;\r\n        }\r\n\r\n        if (this.adjustYaw || this.adjustPitch || this.adjustRoll) {\r\n            Matrix.RotationYawPitchRollToRef(this.adjustYaw, this.adjustPitch, this.adjustRoll, _tmpMat2);\r\n            _tmpMat2.multiplyToRef(_tmpMat1, _tmpMat1);\r\n        }\r\n\r\n        if (this.slerpAmount < 1) {\r\n            if (!this._slerping) {\r\n                this.bone.getRotationQuaternionToRef(Space.WORLD, this.mesh, this._boneQuat);\r\n            }\r\n            if (this._transformYawPitch) {\r\n                this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);\r\n            }\r\n            Quaternion.FromRotationMatrixToRef(_tmpMat1, tmpQuat);\r\n            Quaternion.SlerpToRef(this._boneQuat, tmpQuat, this.slerpAmount, this._boneQuat);\r\n\r\n            this.bone.setRotationQuaternion(this._boneQuat, Space.WORLD, this.mesh);\r\n            this._slerping = true;\r\n        } else {\r\n            if (this._transformYawPitch) {\r\n                this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);\r\n            }\r\n            this.bone.setRotationMatrix(_tmpMat1, Space.WORLD, this.mesh);\r\n            this._slerping = false;\r\n        }\r\n\r\n        this._updateLinkedTransformRotation();\r\n    }\r\n\r\n    private _getAngleDiff(ang1: number, ang2: number): number {\r\n        let angDiff = ang2 - ang1;\r\n        angDiff %= Math.PI * 2;\r\n\r\n        if (angDiff > Math.PI) {\r\n            angDiff -= Math.PI * 2;\r\n        } else if (angDiff < -Math.PI) {\r\n            angDiff += Math.PI * 2;\r\n        }\r\n\r\n        return angDiff;\r\n    }\r\n\r\n    private _getAngleBetween(ang1: number, ang2: number): number {\r\n        ang1 %= 2 * Math.PI;\r\n        ang1 = ang1 < 0 ? ang1 + 2 * Math.PI : ang1;\r\n\r\n        ang2 %= 2 * Math.PI;\r\n        ang2 = ang2 < 0 ? ang2 + 2 * Math.PI : ang2;\r\n\r\n        let ab = 0;\r\n\r\n        if (ang1 < ang2) {\r\n            ab = ang2 - ang1;\r\n        } else {\r\n            ab = ang1 - ang2;\r\n        }\r\n\r\n        if (ab > Math.PI) {\r\n            ab = Math.PI * 2 - ab;\r\n        }\r\n\r\n        return ab;\r\n    }\r\n\r\n    private _isAngleBetween(ang: number, ang1: number, ang2: number): boolean {\r\n        ang %= 2 * Math.PI;\r\n        ang = ang < 0 ? ang + 2 * Math.PI : ang;\r\n        ang1 %= 2 * Math.PI;\r\n        ang1 = ang1 < 0 ? ang1 + 2 * Math.PI : ang1;\r\n        ang2 %= 2 * Math.PI;\r\n        ang2 = ang2 < 0 ? ang2 + 2 * Math.PI : ang2;\r\n\r\n        if (ang1 < ang2) {\r\n            if (ang > ang1 && ang < ang2) {\r\n                return true;\r\n            }\r\n        } else {\r\n            if (ang > ang2 && ang < ang1) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private _updateLinkedTransformRotation(): void {\r\n        const bone = this.bone;\r\n        if (bone._linkedTransformNode) {\r\n            if (!bone._linkedTransformNode.rotationQuaternion) {\r\n                bone._linkedTransformNode.rotationQuaternion = new Quaternion();\r\n            }\r\n            bone.getRotationQuaternionToRef(Space.LOCAL, null, bone._linkedTransformNode.rotationQuaternion);\r\n        }\r\n    }\r\n}\r\n"],"mappings":"AACA,SAASA,UAAU,QAAQ,uBAAqB;AAChD,SAASC,OAAO,EAAEC,UAAU,EAAEC,MAAM,QAAQ,yBAAuB;AAGnE,SAASC,KAAK,EAAEC,IAAI,QAAQ,uBAAqB;AAEjD;;;;AAIA,OAAM,MAAOC,kBAAkB;EAuE3B;;;EAGA,IAAIC,MAAMA,CAAA;IACN,OAAO,IAAI,CAACC,OAAO;EACvB;EAEA,IAAID,MAAMA,CAACE,KAAa;IACpB,IAAI,CAACD,OAAO,GAAGC,KAAK;IACpB,IAAI,CAACC,UAAU,GAAGC,IAAI,CAACC,GAAG,CAACH,KAAK,CAAC;IACjC,IAAI,CAACI,UAAU,GAAGF,IAAI,CAACG,GAAG,CAACL,KAAK,CAAC;IACjC,IAAI,IAAI,CAACM,OAAO,IAAI,IAAI,EAAE;MACtB,IAAI,CAACC,iBAAiB,GAAG,IAAI,CAACC,aAAa,CAAC,IAAI,CAACT,OAAO,EAAE,IAAI,CAACO,OAAO,CAAC,GAAG,GAAG,GAAG,IAAI,CAACP,OAAO;MAC5F,IAAI,CAACU,SAAS,GAAG,IAAI,CAACH,OAAO,GAAG,IAAI,CAACP,OAAO;;EAEpD;EAEA;;;EAGA,IAAIW,MAAMA,CAAA;IACN,OAAO,IAAI,CAACJ,OAAO;EACvB;EAEA,IAAII,MAAMA,CAACV,KAAa;IACpB,IAAI,CAACM,OAAO,GAAGN,KAAK;IACpB,IAAI,CAACW,UAAU,GAAGT,IAAI,CAACC,GAAG,CAACH,KAAK,CAAC;IACjC,IAAI,CAACY,UAAU,GAAGV,IAAI,CAACG,GAAG,CAACL,KAAK,CAAC;IACjC,IAAI,IAAI,CAACD,OAAO,IAAI,IAAI,EAAE;MACtB,IAAI,CAACQ,iBAAiB,GAAG,IAAI,CAACC,aAAa,CAAC,IAAI,CAACT,OAAO,EAAE,IAAI,CAACO,OAAO,CAAC,GAAG,GAAG,GAAG,IAAI,CAACP,OAAO;MAC5F,IAAI,CAACU,SAAS,GAAG,IAAI,CAACH,OAAO,GAAG,IAAI,CAACP,OAAO;;EAEpD;EAOA;;;EAGA,IAAIc,QAAQA,CAAA;IACR,OAAO,IAAI,CAACC,SAAS;EACzB;EAEA,IAAID,QAAQA,CAACb,KAAa;IACtB,IAAI,CAACc,SAAS,GAAGd,KAAK;IACtB,IAAI,CAACe,YAAY,GAAGb,IAAI,CAACc,GAAG,CAAChB,KAAK,CAAC;EACvC;EAEA;;;EAGA,IAAIiB,QAAQA,CAAA;IACR,OAAO,IAAI,CAACC,SAAS;EACzB;EAEA,IAAID,QAAQA,CAACjB,KAAa;IACtB,IAAI,CAACkB,SAAS,GAAGlB,KAAK;IACtB,IAAI,CAACmB,YAAY,GAAGjB,IAAI,CAACc,GAAG,CAAChB,KAAK,CAAC;EACvC;EAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA+BAoB,YACIC,IAAmB,EACnBC,IAAU,EACVC,MAAe,EACfC,OAcC;IAlKL;;;IAGO,KAAAC,MAAM,GAAYjC,OAAO,CAACkC,EAAE,EAAE;IAErC;;;IAGO,KAAAC,WAAW,GAAUhC,KAAK,CAACiC,KAAK;IAEvC;;;IAGO,KAAAC,SAAS,GAAG,CAAC;IAEpB;;;IAGO,KAAAC,WAAW,GAAG,CAAC;IAEtB;;;IAGO,KAAAC,UAAU,GAAG,CAAC;IAErB;;;IAGO,KAAAC,WAAW,GAAG,CAAC;IAcd,KAAAC,SAAS,GAAexC,UAAU,CAACyC,QAAQ,EAAE;IAC7C,KAAAC,SAAS,GAAG,KAAK;IAGjB,KAAAC,kBAAkB,GAAG,KAAK;IAE1B,KAAAC,WAAW,GAAY7C,OAAO,CAAC8C,OAAO,EAAE;IAoChD;;;IAGO,KAAAC,sBAAsB,GAAG,KAAK;IA6EjC,IAAI,CAAClB,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,MAAM,GAAGA,MAAM;IAEpB,IAAIC,OAAO,EAAE;MACT,IAAIA,OAAO,CAACK,SAAS,EAAE;QACnB,IAAI,CAACA,SAAS,GAAGL,OAAO,CAACK,SAAS;;MAGtC,IAAIL,OAAO,CAACM,WAAW,EAAE;QACrB,IAAI,CAACA,WAAW,GAAGN,OAAO,CAACM,WAAW;;MAG1C,IAAIN,OAAO,CAACO,UAAU,EAAE;QACpB,IAAI,CAACA,UAAU,GAAGP,OAAO,CAACO,UAAU;;MAGxC,IAAIP,OAAO,CAACd,MAAM,IAAI,IAAI,EAAE;QACxB,IAAI,CAACA,MAAM,GAAGc,OAAO,CAACd,MAAM;OAC/B,MAAM;QACH,IAAI,CAACA,MAAM,GAAGR,IAAI,CAACsC,EAAE;;MAGzB,IAAIhB,OAAO,CAAC1B,MAAM,IAAI,IAAI,EAAE;QACxB,IAAI,CAACA,MAAM,GAAG0B,OAAO,CAAC1B,MAAM;OAC/B,MAAM;QACH,IAAI,CAACA,MAAM,GAAG,CAACI,IAAI,CAACsC,EAAE;;MAG1B,IAAIhB,OAAO,CAACP,QAAQ,IAAI,IAAI,EAAE;QAC1B,IAAI,CAACA,QAAQ,GAAGO,OAAO,CAACP,QAAQ;OACnC,MAAM;QACH,IAAI,CAACA,QAAQ,GAAGf,IAAI,CAACsC,EAAE;;MAG3B,IAAIhB,OAAO,CAACX,QAAQ,IAAI,IAAI,EAAE;QAC1B,IAAI,CAACA,QAAQ,GAAGW,OAAO,CAACX,QAAQ;OACnC,MAAM;QACH,IAAI,CAACA,QAAQ,GAAG,CAACX,IAAI,CAACsC,EAAE;;MAG5B,IAAIhB,OAAO,CAACQ,WAAW,IAAI,IAAI,EAAE;QAC7B,IAAI,CAACA,WAAW,GAAGR,OAAO,CAACQ,WAAW;;MAG1C,IAAIR,OAAO,CAACC,MAAM,IAAI,IAAI,EAAE;QACxB,IAAI,CAACA,MAAM,GAAGD,OAAO,CAACC,MAAM;;MAGhC,IAAID,OAAO,CAACG,WAAW,IAAI,IAAI,EAAE;QAC7B,IAAI,CAACA,WAAW,GAAGH,OAAO,CAACG,WAAW;;MAG1C,IAAIH,OAAO,CAACiB,OAAO,IAAI,IAAI,IAAIjB,OAAO,CAACkB,SAAS,IAAI,IAAI,EAAE;QACtD,IAAIC,UAAU,GAAG/C,IAAI,CAACgD,CAAC;QACvB,IAAIC,YAAY,GAAGjD,IAAI,CAACkD,CAAC;QAEzB,IAAItB,OAAO,CAACiB,OAAO,IAAI,IAAI,EAAE;UACzBE,UAAU,GAAGnB,OAAO,CAACiB,OAAO,CAACM,KAAK,EAAE;UACpCJ,UAAU,CAACK,SAAS,EAAE;;QAG1B,IAAIxB,OAAO,CAACkB,SAAS,IAAI,IAAI,EAAE;UAC3BG,YAAY,GAAGrB,OAAO,CAACkB,SAAS,CAACK,KAAK,EAAE;UACxCF,YAAY,CAACG,SAAS,EAAE;;QAG5B,MAAMC,WAAW,GAAGzD,OAAO,CAAC0D,KAAK,CAACL,YAAY,EAAEF,UAAU,CAAC;QAE3D,IAAI,CAACQ,kBAAkB,GAAGzD,MAAM,CAACwC,QAAQ,EAAE;QAC3CxC,MAAM,CAAC0D,gBAAgB,CAACP,YAAY,EAAEF,UAAU,EAAEM,WAAW,EAAE,IAAI,CAACE,kBAAkB,CAAC;QAEvF,IAAI,CAACE,qBAAqB,GAAG,IAAI,CAACF,kBAAkB,CAACJ,KAAK,EAAE;QAC5D,IAAI,CAACI,kBAAkB,CAACG,MAAM,EAAE;;MAGpC,IAAI9B,OAAO,CAACe,sBAAsB,KAAKgB,SAAS,EAAE;QAC9C,IAAI,CAAChB,sBAAsB,GAAGf,OAAO,CAACe,sBAAsB;;;IAIpE,IAAI,CAACjB,IAAI,CAACkC,SAAS,EAAE,IAAI,IAAI,CAAC7B,WAAW,IAAIhC,KAAK,CAAC8D,IAAI,EAAE;MACrD,IAAI,CAAC9B,WAAW,GAAGhC,KAAK,CAACiC,KAAK;;EAEtC;EAEA;;;EAGO8B,MAAMA,CAAA;IACT;IACA,IAAI,IAAI,CAAC1B,WAAW,GAAG,CAAC,IAAI,CAAC,IAAI,CAACI,kBAAkB,EAAE;MAClD,IAAI,CAACA,kBAAkB,GAAG,IAAI;MAC9B;;IAGJ,MAAMd,IAAI,GAAG,IAAI,CAACA,IAAI;IACtB,MAAMqC,OAAO,GAAG9D,kBAAkB,CAAC+D,QAAQ,CAAC,CAAC,CAAC;IAC9CtC,IAAI,CAACuC,wBAAwB,CAAC,IAAI,CAACxC,IAAI,EAAEsC,OAAO,CAAC;IAEjD,IAAIpC,MAAM,GAAG,IAAI,CAACA,MAAM;IACxB,MAAMuC,QAAQ,GAAGjE,kBAAkB,CAACkE,QAAQ,CAAC,CAAC,CAAC;IAC/C,MAAMC,QAAQ,GAAGnE,kBAAkB,CAACkE,QAAQ,CAAC,CAAC,CAAC;IAE/C,MAAM1C,IAAI,GAAG,IAAI,CAACA,IAAI;IACtB,MAAM4C,UAAU,GAAG3C,IAAI,CAACkC,SAAS,EAAE;IAEnC,MAAM/B,MAAM,GAAG5B,kBAAkB,CAAC+D,QAAQ,CAAC,CAAC,CAAC;IAC7CnC,MAAM,CAACyC,QAAQ,CAAC,IAAI,CAACzC,MAAM,CAAC;IAE5B,IAAI,IAAI,CAACE,WAAW,IAAIhC,KAAK,CAAC8D,IAAI,IAAIQ,UAAU,EAAE;MAC9C,IAAI,IAAI,CAACd,kBAAkB,EAAE;QACzB3D,OAAO,CAAC2E,yBAAyB,CAAC1C,MAAM,EAAE,IAAI,CAAC4B,qBAAqB,EAAE5B,MAAM,CAAC;;MAEjFwC,UAAU,CAACG,iBAAiB,CAAC3C,MAAM,EAAE,IAAI,CAACJ,IAAI,EAAEI,MAAM,CAAC;KAC1D,MAAM,IAAI,IAAI,CAACE,WAAW,IAAIhC,KAAK,CAACiC,KAAK,EAAE;MACxCP,IAAI,CAAC+C,iBAAiB,CAAC3C,MAAM,EAAEA,MAAM,CAAC;MACtC,IAAIJ,IAAI,CAACgD,OAAO,CAACC,CAAC,IAAI,CAAC,IAAIjD,IAAI,CAACgD,OAAO,CAACE,CAAC,IAAI,CAAC,IAAIlD,IAAI,CAACgD,OAAO,CAACG,CAAC,IAAI,CAAC,EAAE;QACnE/C,MAAM,CAACuB,SAAS,EAAE;;;IAI1B,IAAIyB,QAAQ,GAAG,KAAK;IACpB,IAAIC,UAAU,GAAG,KAAK;IAEtB,IAAI,IAAI,CAACpE,OAAO,IAAIJ,IAAI,CAACsC,EAAE,IAAI,IAAI,CAACzC,OAAO,IAAI,CAACG,IAAI,CAACsC,EAAE,EAAE;MACrDiC,QAAQ,GAAG,IAAI;;IAEnB,IAAI,IAAI,CAACvD,SAAS,IAAIhB,IAAI,CAACsC,EAAE,IAAI,IAAI,CAAC1B,SAAS,IAAI,CAACZ,IAAI,CAACsC,EAAE,EAAE;MACzDkC,UAAU,GAAG,IAAI;;IAGrB,IAAID,QAAQ,IAAIC,UAAU,EAAE;MACxB,MAAMC,QAAQ,GAAG9E,kBAAkB,CAACkE,QAAQ,CAAC,CAAC,CAAC;MAC/C,MAAMa,WAAW,GAAG/E,kBAAkB,CAACkE,QAAQ,CAAC,CAAC,CAAC;MAElD,IAAI,IAAI,CAACpC,WAAW,IAAIhC,KAAK,CAAC8D,IAAI,IAAIhC,MAAM,CAAC8C,CAAC,IAAI,CAAC,IAAIN,UAAU,EAAE;QAC/DA,UAAU,CAACY,sBAAsB,CAAClF,KAAK,CAACmF,KAAK,EAAE,IAAI,CAACzD,IAAI,EAAEsD,QAAQ,CAAC;OACtE,MAAM,IAAI,IAAI,CAAChD,WAAW,IAAIhC,KAAK,CAACiC,KAAK,IAAIH,MAAM,CAAC8C,CAAC,IAAI,CAAC,IAAI,CAACN,UAAU,EAAE;QACxEU,QAAQ,CAACT,QAAQ,CAAC7C,IAAI,CAAC0D,cAAc,EAAE,CAAC;OAC3C,MAAM;QACH,IAAIC,WAAW,GAAGnF,kBAAkB,CAAC+D,QAAQ,CAAC,CAAC,CAAC;QAChDoB,WAAW,CAACd,QAAQ,CAAC,IAAI,CAAC7B,WAAW,CAAC;QAEtC,IAAI,IAAI,CAACc,kBAAkB,EAAE;UACzB3D,OAAO,CAAC2E,yBAAyB,CAACa,WAAW,EAAE,IAAI,CAAC3B,qBAAqB,EAAE2B,WAAW,CAAC;;QAG3F,IAAIf,UAAU,EAAE;UACZA,UAAU,CAACG,iBAAiB,CAACY,WAAW,EAAE,IAAI,CAAC3D,IAAI,EAAE2D,WAAW,CAAC;SACpE,MAAM;UACH3D,IAAI,CAAC+C,iBAAiB,CAACY,WAAW,EAAEA,WAAW,CAAC;;QAGpD,MAAMC,SAAS,GAAGzF,OAAO,CAAC0D,KAAK,CAACzB,MAAM,EAAEuD,WAAW,CAAC;QACpDC,SAAS,CAACjC,SAAS,EAAE;QACrBgC,WAAW,GAAGxF,OAAO,CAAC0D,KAAK,CAAC+B,SAAS,EAAExD,MAAM,CAAC;QAE9C/B,MAAM,CAAC0D,gBAAgB,CAAC6B,SAAS,EAAExD,MAAM,EAAEuD,WAAW,EAAEL,QAAQ,CAAC;;MAGrEA,QAAQ,CAACO,WAAW,CAACN,WAAW,CAAC;MAEjC,IAAIO,KAAK,GAAqB,IAAI;MAElC,IAAIT,UAAU,EAAE;QACZ,MAAMU,WAAW,GAAGvF,kBAAkB,CAAC+D,QAAQ,CAAC,CAAC,CAAC;QAClDrC,MAAM,CAAC8D,aAAa,CAAC1B,OAAO,EAAEyB,WAAW,CAAC;QAC1C5F,OAAO,CAAC2E,yBAAyB,CAACiB,WAAW,EAAER,WAAW,EAAEQ,WAAW,CAAC;QAExED,KAAK,GAAGjF,IAAI,CAACoF,IAAI,CAACF,WAAW,CAACd,CAAC,GAAGc,WAAW,CAACd,CAAC,GAAGc,WAAW,CAACZ,CAAC,GAAGY,WAAW,CAACZ,CAAC,CAAC;QAChF,MAAMe,KAAK,GAAGrF,IAAI,CAACsF,KAAK,CAACJ,WAAW,CAACb,CAAC,EAAEY,KAAK,CAAC;QAC9C,IAAIM,QAAQ,GAAGF,KAAK;QAEpB,IAAIA,KAAK,GAAG,IAAI,CAACrE,SAAS,EAAE;UACxBkE,WAAW,CAACb,CAAC,GAAG,IAAI,CAACpD,YAAY,GAAGgE,KAAK;UACzCM,QAAQ,GAAG,IAAI,CAACvE,SAAS;SAC5B,MAAM,IAAIqE,KAAK,GAAG,IAAI,CAACzE,SAAS,EAAE;UAC/BsE,WAAW,CAACb,CAAC,GAAG,IAAI,CAACxD,YAAY,GAAGoE,KAAK;UACzCM,QAAQ,GAAG,IAAI,CAAC3E,SAAS;;QAG7B,IAAIyE,KAAK,IAAIE,QAAQ,EAAE;UACnBjG,OAAO,CAAC2E,yBAAyB,CAACiB,WAAW,EAAET,QAAQ,EAAES,WAAW,CAAC;UACrEA,WAAW,CAACM,UAAU,CAAC/B,OAAO,CAAC;UAC/BpC,MAAM,GAAG6D,WAAW;;;MAI5B,IAAIX,QAAQ,EAAE;QACV,MAAMW,WAAW,GAAGvF,kBAAkB,CAAC+D,QAAQ,CAAC,CAAC,CAAC;QAClDrC,MAAM,CAAC8D,aAAa,CAAC1B,OAAO,EAAEyB,WAAW,CAAC;QAC1C5F,OAAO,CAAC2E,yBAAyB,CAACiB,WAAW,EAAER,WAAW,EAAEQ,WAAW,CAAC;QAExE,MAAMO,GAAG,GAAGzF,IAAI,CAACsF,KAAK,CAACJ,WAAW,CAACd,CAAC,EAAEc,WAAW,CAACZ,CAAC,CAAC;QACpD,MAAMoB,QAAQ,GAAG,IAAI,CAACrD,sBAAsB,GAAGrC,IAAI,CAAC2F,GAAG,CAACF,GAAG,CAAC,GAAGA,GAAG;QAClE,IAAIG,MAAM,GAAGH,GAAG;QAEhB,IAAIC,QAAQ,GAAG,IAAI,CAACtF,OAAO,IAAIsF,QAAQ,GAAG,IAAI,CAAC7F,OAAO,EAAE;UACpD,IAAIoF,KAAK,IAAI,IAAI,EAAE;YACfA,KAAK,GAAGjF,IAAI,CAACoF,IAAI,CAACF,WAAW,CAACd,CAAC,GAAGc,WAAW,CAACd,CAAC,GAAGc,WAAW,CAACZ,CAAC,GAAGY,WAAW,CAACZ,CAAC,CAAC;;UAGpF,IAAI,IAAI,CAAC/D,SAAS,GAAGP,IAAI,CAACsC,EAAE,EAAE;YAC1B,IAAI,IAAI,CAACuD,eAAe,CAACJ,GAAG,EAAE,IAAI,CAACrF,OAAO,EAAE,IAAI,CAACC,iBAAiB,CAAC,EAAE;cACjE6E,WAAW,CAACZ,CAAC,GAAG,IAAI,CAAC5D,UAAU,GAAGuE,KAAK;cACvCC,WAAW,CAACd,CAAC,GAAG,IAAI,CAAC3D,UAAU,GAAGwE,KAAK;cACvCW,MAAM,GAAG,IAAI,CAACxF,OAAO;aACxB,MAAM,IAAI,IAAI,CAACyF,eAAe,CAACJ,GAAG,EAAE,IAAI,CAACpF,iBAAiB,EAAE,IAAI,CAACR,OAAO,CAAC,EAAE;cACxEqF,WAAW,CAACZ,CAAC,GAAG,IAAI,CAACpE,UAAU,GAAG+E,KAAK;cACvCC,WAAW,CAACd,CAAC,GAAG,IAAI,CAACrE,UAAU,GAAGkF,KAAK;cACvCW,MAAM,GAAG,IAAI,CAAC/F,OAAO;;WAE5B,MAAM;YACH,IAAI6F,QAAQ,GAAG,IAAI,CAACtF,OAAO,EAAE;cACzB8E,WAAW,CAACZ,CAAC,GAAG,IAAI,CAAC5D,UAAU,GAAGuE,KAAK;cACvCC,WAAW,CAACd,CAAC,GAAG,IAAI,CAAC3D,UAAU,GAAGwE,KAAK;cACvC,IAAIQ,GAAG,GAAG,CAAC,IAAI,IAAI,CAACpD,sBAAsB,EAAE;gBACxC6C,WAAW,CAACd,CAAC,IAAI,CAAC,CAAC;;cAEvBwB,MAAM,GAAG,IAAI,CAACxF,OAAO;aACxB,MAAM,IAAIsF,QAAQ,GAAG,IAAI,CAAC7F,OAAO,EAAE;cAChCqF,WAAW,CAACZ,CAAC,GAAG,IAAI,CAACpE,UAAU,GAAG+E,KAAK;cACvCC,WAAW,CAACd,CAAC,GAAG,IAAI,CAACrE,UAAU,GAAGkF,KAAK;cACvC,IAAIQ,GAAG,GAAG,CAAC,IAAI,IAAI,CAACpD,sBAAsB,EAAE;gBACxC6C,WAAW,CAACd,CAAC,IAAI,CAAC,CAAC;;cAEvBwB,MAAM,GAAG,IAAI,CAAC/F,OAAO;;;;QAKjC,IAAI,IAAI,CAACoC,SAAS,IAAI,IAAI,CAAC1B,SAAS,GAAGP,IAAI,CAACsC,EAAE,EAAE;UAC5C;UACA,MAAMwD,OAAO,GAAGnG,kBAAkB,CAAC+D,QAAQ,CAAC,CAAC,CAAC;UAC9CoC,OAAO,CAAC9B,QAAQ,CAACtE,IAAI,CAACqG,CAAC,CAAC;UACxB,IAAI,IAAI,CAAC9C,kBAAkB,EAAE;YACzB3D,OAAO,CAAC2E,yBAAyB,CAAC6B,OAAO,EAAE,IAAI,CAAC3C,qBAAqB,EAAE2C,OAAO,CAAC;;UAGnF,MAAME,UAAU,GAAGrG,kBAAkB,CAACkE,QAAQ,CAAC,CAAC,CAAC;UACjD,IAAI,CAAC9B,SAAS,CAACkE,gBAAgB,CAACD,UAAU,CAAC;UAC3C,IAAI,CAAC7E,IAAI,CAAC0D,cAAc,EAAE,CAACqB,aAAa,CAACF,UAAU,EAAEA,UAAU,CAAC;UAChE1G,OAAO,CAAC2E,yBAAyB,CAAC6B,OAAO,EAAEE,UAAU,EAAEF,OAAO,CAAC;UAC/DxG,OAAO,CAAC2E,yBAAyB,CAAC6B,OAAO,EAAEpB,WAAW,EAAEoB,OAAO,CAAC;UAEhE,MAAMK,OAAO,GAAGnG,IAAI,CAACsF,KAAK,CAACQ,OAAO,CAAC1B,CAAC,EAAE0B,OAAO,CAACxB,CAAC,CAAC;UAChD,MAAM8B,SAAS,GAAG,IAAI,CAACC,gBAAgB,CAACF,OAAO,EAAEV,GAAG,CAAC;UACrD,MAAMa,YAAY,GAAG,IAAI,CAACD,gBAAgB,CAACF,OAAO,EAAE,IAAI,CAAC9F,iBAAiB,CAAC;UAE3E,IAAI+F,SAAS,GAAGE,YAAY,EAAE;YAC1B,IAAIrB,KAAK,IAAI,IAAI,EAAE;cACfA,KAAK,GAAGjF,IAAI,CAACoF,IAAI,CAACF,WAAW,CAACd,CAAC,GAAGc,WAAW,CAACd,CAAC,GAAGc,WAAW,CAACZ,CAAC,GAAGY,WAAW,CAACZ,CAAC,CAAC;;YAGpF,MAAMiC,SAAS,GAAG,IAAI,CAACF,gBAAgB,CAACF,OAAO,EAAE,IAAI,CAAC/F,OAAO,CAAC;YAC9D,MAAMoG,SAAS,GAAG,IAAI,CAACH,gBAAgB,CAACF,OAAO,EAAE,IAAI,CAACtG,OAAO,CAAC;YAE9D,IAAI2G,SAAS,GAAGD,SAAS,EAAE;cACvBX,MAAM,GAAGO,OAAO,GAAGnG,IAAI,CAACsC,EAAE,GAAG,IAAI;cACjC4C,WAAW,CAACZ,CAAC,GAAGtE,IAAI,CAACG,GAAG,CAACyF,MAAM,CAAC,GAAGX,KAAK;cACxCC,WAAW,CAACd,CAAC,GAAGpE,IAAI,CAACC,GAAG,CAAC2F,MAAM,CAAC,GAAGX,KAAK;aAC3C,MAAM;cACHW,MAAM,GAAGO,OAAO,GAAGnG,IAAI,CAACsC,EAAE,GAAG,IAAI;cACjC4C,WAAW,CAACZ,CAAC,GAAGtE,IAAI,CAACG,GAAG,CAACyF,MAAM,CAAC,GAAGX,KAAK;cACxCC,WAAW,CAACd,CAAC,GAAGpE,IAAI,CAACC,GAAG,CAAC2F,MAAM,CAAC,GAAGX,KAAK;;;;QAKpD,IAAIQ,GAAG,IAAIG,MAAM,EAAE;UACftG,OAAO,CAAC2E,yBAAyB,CAACiB,WAAW,EAAET,QAAQ,EAAES,WAAW,CAAC;UACrEA,WAAW,CAACM,UAAU,CAAC/B,OAAO,CAAC;UAC/BpC,MAAM,GAAG6D,WAAW;;;;IAKhC,MAAMuB,KAAK,GAAG9G,kBAAkB,CAAC+D,QAAQ,CAAC,CAAC,CAAC;IAC5C,MAAMgD,KAAK,GAAG/G,kBAAkB,CAAC+D,QAAQ,CAAC,CAAC,CAAC;IAC5C,MAAMiD,KAAK,GAAGhH,kBAAkB,CAAC+D,QAAQ,CAAC,CAAC,CAAC;IAC5C,MAAMkD,OAAO,GAAGjH,kBAAkB,CAACkH,QAAQ;IAE3CxF,MAAM,CAAC8D,aAAa,CAAC1B,OAAO,EAAEgD,KAAK,CAAC;IACpCA,KAAK,CAAC3D,SAAS,EAAE;IACjBxD,OAAO,CAACwH,UAAU,CAACvF,MAAM,EAAEkF,KAAK,EAAEC,KAAK,CAAC;IACxCA,KAAK,CAAC5D,SAAS,EAAE;IACjBxD,OAAO,CAACwH,UAAU,CAACL,KAAK,EAAEC,KAAK,EAAEC,KAAK,CAAC;IACvCA,KAAK,CAAC7D,SAAS,EAAE;IACjBtD,MAAM,CAAC0D,gBAAgB,CAACwD,KAAK,EAAEC,KAAK,EAAEF,KAAK,EAAE7C,QAAQ,CAAC;IAEtD,IAAI8C,KAAK,CAACtC,CAAC,KAAK,CAAC,IAAIsC,KAAK,CAACrC,CAAC,KAAK,CAAC,IAAIqC,KAAK,CAACpC,CAAC,KAAK,CAAC,EAAE;MACjD;;IAGJ,IAAIqC,KAAK,CAACvC,CAAC,KAAK,CAAC,IAAIuC,KAAK,CAACtC,CAAC,KAAK,CAAC,IAAIsC,KAAK,CAACrC,CAAC,KAAK,CAAC,EAAE;MACjD;;IAGJ,IAAImC,KAAK,CAACrC,CAAC,KAAK,CAAC,IAAIqC,KAAK,CAACpC,CAAC,KAAK,CAAC,IAAIoC,KAAK,CAACnC,CAAC,KAAK,CAAC,EAAE;MACjD;;IAGJ,IAAI,IAAI,CAAC3C,SAAS,IAAI,IAAI,CAACC,WAAW,IAAI,IAAI,CAACC,UAAU,EAAE;MACvDrC,MAAM,CAACuH,yBAAyB,CAAC,IAAI,CAACpF,SAAS,EAAE,IAAI,CAACC,WAAW,EAAE,IAAI,CAACC,UAAU,EAAEiC,QAAQ,CAAC;MAC7FA,QAAQ,CAACoC,aAAa,CAACtC,QAAQ,EAAEA,QAAQ,CAAC;;IAG9C,IAAI,IAAI,CAAC9B,WAAW,GAAG,CAAC,EAAE;MACtB,IAAI,CAAC,IAAI,CAACG,SAAS,EAAE;QACjB,IAAI,CAACb,IAAI,CAAC4F,0BAA0B,CAACvH,KAAK,CAACmF,KAAK,EAAE,IAAI,CAACzD,IAAI,EAAE,IAAI,CAACY,SAAS,CAAC;;MAEhF,IAAI,IAAI,CAACkB,kBAAkB,EAAE;QACzB,IAAI,CAACA,kBAAkB,CAACiD,aAAa,CAACtC,QAAQ,EAAEA,QAAQ,CAAC;;MAE7DrE,UAAU,CAAC0H,uBAAuB,CAACrD,QAAQ,EAAEgD,OAAO,CAAC;MACrDrH,UAAU,CAAC2H,UAAU,CAAC,IAAI,CAACnF,SAAS,EAAE6E,OAAO,EAAE,IAAI,CAAC9E,WAAW,EAAE,IAAI,CAACC,SAAS,CAAC;MAEhF,IAAI,CAACX,IAAI,CAAC+F,qBAAqB,CAAC,IAAI,CAACpF,SAAS,EAAEtC,KAAK,CAACmF,KAAK,EAAE,IAAI,CAACzD,IAAI,CAAC;MACvE,IAAI,CAACc,SAAS,GAAG,IAAI;KACxB,MAAM;MACH,IAAI,IAAI,CAACgB,kBAAkB,EAAE;QACzB,IAAI,CAACA,kBAAkB,CAACiD,aAAa,CAACtC,QAAQ,EAAEA,QAAQ,CAAC;;MAE7D,IAAI,CAACxC,IAAI,CAACgG,iBAAiB,CAACxD,QAAQ,EAAEnE,KAAK,CAACmF,KAAK,EAAE,IAAI,CAACzD,IAAI,CAAC;MAC7D,IAAI,CAACc,SAAS,GAAG,KAAK;;IAG1B,IAAI,CAACoF,8BAA8B,EAAE;EACzC;EAEQ/G,aAAaA,CAACgH,IAAY,EAAEC,IAAY;IAC5C,IAAIC,OAAO,GAAGD,IAAI,GAAGD,IAAI;IACzBE,OAAO,IAAIxH,IAAI,CAACsC,EAAE,GAAG,CAAC;IAEtB,IAAIkF,OAAO,GAAGxH,IAAI,CAACsC,EAAE,EAAE;MACnBkF,OAAO,IAAIxH,IAAI,CAACsC,EAAE,GAAG,CAAC;KACzB,MAAM,IAAIkF,OAAO,GAAG,CAACxH,IAAI,CAACsC,EAAE,EAAE;MAC3BkF,OAAO,IAAIxH,IAAI,CAACsC,EAAE,GAAG,CAAC;;IAG1B,OAAOkF,OAAO;EAClB;EAEQnB,gBAAgBA,CAACiB,IAAY,EAAEC,IAAY;IAC/CD,IAAI,IAAI,CAAC,GAAGtH,IAAI,CAACsC,EAAE;IACnBgF,IAAI,GAAGA,IAAI,GAAG,CAAC,GAAGA,IAAI,GAAG,CAAC,GAAGtH,IAAI,CAACsC,EAAE,GAAGgF,IAAI;IAE3CC,IAAI,IAAI,CAAC,GAAGvH,IAAI,CAACsC,EAAE;IACnBiF,IAAI,GAAGA,IAAI,GAAG,CAAC,GAAGA,IAAI,GAAG,CAAC,GAAGvH,IAAI,CAACsC,EAAE,GAAGiF,IAAI;IAE3C,IAAIE,EAAE,GAAG,CAAC;IAEV,IAAIH,IAAI,GAAGC,IAAI,EAAE;MACbE,EAAE,GAAGF,IAAI,GAAGD,IAAI;KACnB,MAAM;MACHG,EAAE,GAAGH,IAAI,GAAGC,IAAI;;IAGpB,IAAIE,EAAE,GAAGzH,IAAI,CAACsC,EAAE,EAAE;MACdmF,EAAE,GAAGzH,IAAI,CAACsC,EAAE,GAAG,CAAC,GAAGmF,EAAE;;IAGzB,OAAOA,EAAE;EACb;EAEQ5B,eAAeA,CAAC6B,GAAW,EAAEJ,IAAY,EAAEC,IAAY;IAC3DG,GAAG,IAAI,CAAC,GAAG1H,IAAI,CAACsC,EAAE;IAClBoF,GAAG,GAAGA,GAAG,GAAG,CAAC,GAAGA,GAAG,GAAG,CAAC,GAAG1H,IAAI,CAACsC,EAAE,GAAGoF,GAAG;IACvCJ,IAAI,IAAI,CAAC,GAAGtH,IAAI,CAACsC,EAAE;IACnBgF,IAAI,GAAGA,IAAI,GAAG,CAAC,GAAGA,IAAI,GAAG,CAAC,GAAGtH,IAAI,CAACsC,EAAE,GAAGgF,IAAI;IAC3CC,IAAI,IAAI,CAAC,GAAGvH,IAAI,CAACsC,EAAE;IACnBiF,IAAI,GAAGA,IAAI,GAAG,CAAC,GAAGA,IAAI,GAAG,CAAC,GAAGvH,IAAI,CAACsC,EAAE,GAAGiF,IAAI;IAE3C,IAAID,IAAI,GAAGC,IAAI,EAAE;MACb,IAAIG,GAAG,GAAGJ,IAAI,IAAII,GAAG,GAAGH,IAAI,EAAE;QAC1B,OAAO,IAAI;;KAElB,MAAM;MACH,IAAIG,GAAG,GAAGH,IAAI,IAAIG,GAAG,GAAGJ,IAAI,EAAE;QAC1B,OAAO,IAAI;;;IAGnB,OAAO,KAAK;EAChB;EAEQD,8BAA8BA,CAAA;IAClC,MAAMjG,IAAI,GAAG,IAAI,CAACA,IAAI;IACtB,IAAIA,IAAI,CAACuG,oBAAoB,EAAE;MAC3B,IAAI,CAACvG,IAAI,CAACuG,oBAAoB,CAACC,kBAAkB,EAAE;QAC/CxG,IAAI,CAACuG,oBAAoB,CAACC,kBAAkB,GAAG,IAAIrI,UAAU,EAAE;;MAEnE6B,IAAI,CAAC4F,0BAA0B,CAACvH,KAAK,CAACiC,KAAK,EAAE,IAAI,EAAEN,IAAI,CAACuG,oBAAoB,CAACC,kBAAkB,CAAC;;EAExG;;AAlkBejI,kBAAA,CAAA+D,QAAQ,GAAcrE,UAAU,CAACwI,UAAU,CAAC,EAAE,EAAEvI,OAAO,CAACwI,IAAI,CAAC;AAC7DnI,kBAAA,CAAAkH,QAAQ,GAAGtH,UAAU,CAACyC,QAAQ,EAAE;AAChCrC,kBAAA,CAAAkE,QAAQ,GAAaxE,UAAU,CAACwI,UAAU,CAAC,CAAC,EAAErI,MAAM,CAACwC,QAAQ,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}