{"ast":null,"code":"import \"core-js/modules/es.array.unshift.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { Matrix, Vector4 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\nimport { CreateGroundVertexData } from \"./groundBuilder.js\";\n/**\n * Creates the VertexData for a box\n * @param options an object used to set the following optional parameters for the box, required but can be empty\n * * size sets the width, height and depth of the box to the value of size, optional default 1\n * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\n * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\n * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.depth\n * @param options.faceUV\n * @param options.faceColors\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.wrap\n * @param options.topBaseAt\n * @param options.bottomBaseAt\n * @returns the VertexData of the box\n */\nexport function CreateBoxVertexData(options) {\n  const nbFaces = 6;\n  let indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];\n  const normals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0];\n  const uvs = [];\n  let positions = [];\n  const width = options.width || options.size || 1;\n  const height = options.height || options.size || 1;\n  const depth = options.depth || options.size || 1;\n  const wrap = options.wrap || false;\n  let topBaseAt = options.topBaseAt === void 0 ? 1 : options.topBaseAt;\n  let bottomBaseAt = options.bottomBaseAt === void 0 ? 0 : options.bottomBaseAt;\n  topBaseAt = (topBaseAt + 4) % 4; // places values as 0 to 3\n  bottomBaseAt = (bottomBaseAt + 4) % 4; // places values as 0 to 3\n  const topOrder = [2, 0, 3, 1];\n  const bottomOrder = [2, 0, 1, 3];\n  let topIndex = topOrder[topBaseAt];\n  let bottomIndex = bottomOrder[bottomBaseAt];\n  let basePositions = [1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1];\n  if (wrap) {\n    indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];\n    basePositions = [-1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1];\n    let topFaceBase = [[1, 1, 1], [-1, 1, 1], [-1, 1, -1], [1, 1, -1]];\n    let bottomFaceBase = [[-1, -1, 1], [1, -1, 1], [1, -1, -1], [-1, -1, -1]];\n    const topFaceOrder = [17, 18, 19, 16];\n    const bottomFaceOrder = [22, 23, 20, 21];\n    while (topIndex > 0) {\n      topFaceBase.unshift(topFaceBase.pop());\n      topFaceOrder.unshift(topFaceOrder.pop());\n      topIndex--;\n    }\n    while (bottomIndex > 0) {\n      bottomFaceBase.unshift(bottomFaceBase.pop());\n      bottomFaceOrder.unshift(bottomFaceOrder.pop());\n      bottomIndex--;\n    }\n    topFaceBase = topFaceBase.flat();\n    bottomFaceBase = bottomFaceBase.flat();\n    basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);\n    indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);\n    indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);\n  }\n  const scaleArray = [width / 2, height / 2, depth / 2];\n  positions = basePositions.reduce((accumulator, currentValue, currentIndex) => accumulator.concat(currentValue * scaleArray[currentIndex % 3]), []);\n  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n  const faceUV = options.faceUV || new Array(6);\n  const faceColors = options.faceColors;\n  const colors = [];\n  // default face colors and UV if undefined\n  for (let f = 0; f < 6; f++) {\n    if (faceUV[f] === undefined) {\n      faceUV[f] = new Vector4(0, 0, 1, 1);\n    }\n    if (faceColors && faceColors[f] === undefined) {\n      faceColors[f] = new Color4(1, 1, 1, 1);\n    }\n  }\n  // Create each face in turn.\n  for (let index = 0; index < nbFaces; index++) {\n    uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\n    uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\n    uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\n    uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\n    if (faceColors) {\n      for (let c = 0; c < 4; c++) {\n        colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);\n      }\n    }\n  }\n  // sides\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n  // Result\n  const vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  if (faceColors) {\n    const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\n    vertexData.colors = totalColors;\n  }\n  return vertexData;\n}\n/**\n * Creates the VertexData for a segmented box\n * @param options an object used to set the following optional parameters for the box, required but can be empty\n * * size sets the width, height and depth of the box to the value of size, optional default 1\n * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\n * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\n * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\n * * segments sets the number of segments on the all axis (1 by default)\n * * widthSegments sets the number of segments on the x axis (1 by default)\n * * heightSegments sets the number of segments on the y axis (1 by default)\n * * depthSegments sets the number of segments on the z axis (1 by default)\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.depth\n * @param options.segments\n * @param options.widthSegments\n * @param options.heightSegments\n * @param options.depthSegments\n * @returns the VertexData of the box\n */\nexport function CreateSegmentedBoxVertexData(options) {\n  const width = options.width || options.size || 1;\n  const height = options.height || options.size || 1;\n  const depth = options.depth || options.size || 1;\n  const widthSegments = (options.widthSegments || options.segments || 1) | 0;\n  const heightSegments = (options.heightSegments || options.segments || 1) | 0;\n  const depthSegments = (options.depthSegments || options.segments || 1) | 0;\n  const rotationMatrix = new Matrix();\n  const translationMatrix = new Matrix();\n  const transformMatrix = new Matrix();\n  const bottomPlane = CreateGroundVertexData({\n    width: width,\n    height: depth,\n    subdivisionsX: widthSegments,\n    subdivisionsY: depthSegments\n  });\n  Matrix.TranslationToRef(0, -height / 2, 0, translationMatrix);\n  Matrix.RotationZToRef(Math.PI, rotationMatrix);\n  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);\n  bottomPlane.transform(transformMatrix);\n  const topPlane = CreateGroundVertexData({\n    width: width,\n    height: depth,\n    subdivisionsX: widthSegments,\n    subdivisionsY: depthSegments\n  });\n  Matrix.TranslationToRef(0, height / 2, 0, transformMatrix);\n  topPlane.transform(transformMatrix);\n  const negXPlane = CreateGroundVertexData({\n    width: height,\n    height: depth,\n    subdivisionsX: heightSegments,\n    subdivisionsY: depthSegments\n  });\n  Matrix.TranslationToRef(-width / 2, 0, 0, translationMatrix);\n  Matrix.RotationZToRef(Math.PI / 2, rotationMatrix);\n  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);\n  negXPlane.transform(transformMatrix);\n  const posXPlane = CreateGroundVertexData({\n    width: height,\n    height: depth,\n    subdivisionsX: heightSegments,\n    subdivisionsY: depthSegments\n  });\n  Matrix.TranslationToRef(width / 2, 0, 0, translationMatrix);\n  Matrix.RotationZToRef(-Math.PI / 2, rotationMatrix);\n  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);\n  posXPlane.transform(transformMatrix);\n  const negZPlane = CreateGroundVertexData({\n    width: width,\n    height: height,\n    subdivisionsX: widthSegments,\n    subdivisionsY: heightSegments\n  });\n  Matrix.TranslationToRef(0, 0, -depth / 2, translationMatrix);\n  Matrix.RotationXToRef(-Math.PI / 2, rotationMatrix);\n  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);\n  negZPlane.transform(transformMatrix);\n  const posZPlane = CreateGroundVertexData({\n    width: width,\n    height: height,\n    subdivisionsX: widthSegments,\n    subdivisionsY: heightSegments\n  });\n  Matrix.TranslationToRef(0, 0, depth / 2, translationMatrix);\n  Matrix.RotationXToRef(Math.PI / 2, rotationMatrix);\n  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);\n  posZPlane.transform(transformMatrix);\n  // Result\n  bottomPlane.merge([topPlane, posXPlane, negXPlane, negZPlane, posZPlane], true);\n  return bottomPlane;\n}\n/**\n * Creates a box mesh\n * * The parameter `size` sets the size (float) of each box side (default 1)\n * * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)\n * * Please read this tutorial : https://doc.babylonjs.com/features/featuresDeepDive/materials/using/texturePerBoxFace\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#box\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.depth\n * @param options.faceUV\n * @param options.faceColors\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.wrap\n * @param options.topBaseAt\n * @param options.bottomBaseAt\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the box mesh\n */\nexport function CreateBox(name, options = {}, scene = null) {\n  const box = new Mesh(name, scene);\n  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  box._originalBuilderSideOrientation = options.sideOrientation;\n  const vertexData = CreateBoxVertexData(options);\n  vertexData.applyToMesh(box, options.updatable);\n  return box;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated please use CreateBox directly\n */\nexport const BoxBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateBox\n};\n// Side effects\nVertexData.CreateBox = CreateBoxVertexData;\nMesh.CreateBox = (name, size, scene = null, updatable, sideOrientation) => {\n  const options = {\n    size,\n    sideOrientation,\n    updatable\n  };\n  return CreateBox(name, options, scene);\n};","map":{"version":3,"names":["Matrix","Vector4","Color4","Mesh","VertexData","CompatibilityOptions","CreateGroundVertexData","CreateBoxVertexData","options","nbFaces","indices","normals","uvs","positions","width","size","height","depth","wrap","topBaseAt","bottomBaseAt","topOrder","bottomOrder","topIndex","bottomIndex","basePositions","topFaceBase","bottomFaceBase","topFaceOrder","bottomFaceOrder","unshift","pop","flat","concat","push","scaleArray","reduce","accumulator","currentValue","currentIndex","sideOrientation","DEFAULTSIDE","faceUV","Array","faceColors","colors","f","undefined","index","z","UseOpenGLOrientationForUV","w","x","y","c","r","g","b","a","_ComputeSides","frontUVs","backUVs","vertexData","totalColors","DOUBLESIDE","CreateSegmentedBoxVertexData","widthSegments","segments","heightSegments","depthSegments","rotationMatrix","translationMatrix","transformMatrix","bottomPlane","subdivisionsX","subdivisionsY","TranslationToRef","RotationZToRef","Math","PI","multiplyToRef","transform","topPlane","negXPlane","posXPlane","negZPlane","RotationXToRef","posZPlane","merge","CreateBox","name","scene","box","_GetDefaultSideOrientation","_originalBuilderSideOrientation","applyToMesh","updatable","BoxBuilder"],"sources":["../../../../../dev/core/src/Meshes/Builders/boxBuilder.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\nimport { CreateGroundVertexData } from \"./groundBuilder\";\r\n\r\n/**\r\n * Creates the VertexData for a box\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * size sets the width, height and depth of the box to the value of size, optional default 1\r\n * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\r\n * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\r\n * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\r\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.depth\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.wrap\r\n * @param options.topBaseAt\r\n * @param options.bottomBaseAt\r\n * @returns the VertexData of the box\r\n */\r\nexport function CreateBoxVertexData(options: {\r\n    size?: number;\r\n    width?: number;\r\n    height?: number;\r\n    depth?: number;\r\n    faceUV?: Vector4[];\r\n    faceColors?: Color4[];\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n    wrap?: boolean;\r\n    topBaseAt?: number;\r\n    bottomBaseAt?: number;\r\n}): VertexData {\r\n    const nbFaces = 6;\r\n    let indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];\r\n    const normals = [\r\n        0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0,\r\n        1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,\r\n    ];\r\n    const uvs = [];\r\n    let positions = [];\r\n    const width = options.width || options.size || 1;\r\n    const height = options.height || options.size || 1;\r\n    const depth = options.depth || options.size || 1;\r\n    const wrap = options.wrap || false;\r\n    let topBaseAt = options.topBaseAt === void 0 ? 1 : options.topBaseAt;\r\n    let bottomBaseAt = options.bottomBaseAt === void 0 ? 0 : options.bottomBaseAt;\r\n    topBaseAt = (topBaseAt + 4) % 4; // places values as 0 to 3\r\n    bottomBaseAt = (bottomBaseAt + 4) % 4; // places values as 0 to 3\r\n    const topOrder = [2, 0, 3, 1];\r\n    const bottomOrder = [2, 0, 1, 3];\r\n    let topIndex = topOrder[topBaseAt];\r\n    let bottomIndex = bottomOrder[bottomBaseAt];\r\n    let basePositions = [\r\n        1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1,\r\n        1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1,\r\n    ];\r\n    if (wrap) {\r\n        indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];\r\n        basePositions = [\r\n            -1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1,\r\n        ];\r\n        let topFaceBase: any = [\r\n            [1, 1, 1],\r\n            [-1, 1, 1],\r\n            [-1, 1, -1],\r\n            [1, 1, -1],\r\n        ];\r\n        let bottomFaceBase: any = [\r\n            [-1, -1, 1],\r\n            [1, -1, 1],\r\n            [1, -1, -1],\r\n            [-1, -1, -1],\r\n        ];\r\n        const topFaceOrder: any = [17, 18, 19, 16];\r\n        const bottomFaceOrder: any = [22, 23, 20, 21];\r\n        while (topIndex > 0) {\r\n            topFaceBase.unshift(topFaceBase.pop());\r\n            topFaceOrder.unshift(topFaceOrder.pop());\r\n            topIndex--;\r\n        }\r\n        while (bottomIndex > 0) {\r\n            bottomFaceBase.unshift(bottomFaceBase.pop());\r\n            bottomFaceOrder.unshift(bottomFaceOrder.pop());\r\n            bottomIndex--;\r\n        }\r\n        topFaceBase = topFaceBase.flat();\r\n        bottomFaceBase = bottomFaceBase.flat();\r\n        basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);\r\n        indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);\r\n        indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);\r\n    }\r\n    const scaleArray = [width / 2, height / 2, depth / 2];\r\n    positions = basePositions.reduce((accumulator: Array<number>, currentValue, currentIndex) => accumulator.concat(currentValue * scaleArray[currentIndex % 3]), []);\r\n\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    const faceUV: Vector4[] = options.faceUV || new Array<Vector4>(6);\r\n    const faceColors = options.faceColors;\r\n    const colors = [];\r\n\r\n    // default face colors and UV if undefined\r\n    for (let f = 0; f < 6; f++) {\r\n        if (faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n\r\n    // Create each face in turn.\r\n    for (let index = 0; index < nbFaces; index++) {\r\n        uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\r\n        uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\r\n        uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\r\n        uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\r\n        if (faceColors) {\r\n            for (let c = 0; c < 4; c++) {\r\n                colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);\r\n            }\r\n        }\r\n    }\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    if (faceColors) {\r\n        const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\r\n        vertexData.colors = totalColors;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates the VertexData for a segmented box\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * size sets the width, height and depth of the box to the value of size, optional default 1\r\n * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\r\n * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\r\n * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\r\n * * segments sets the number of segments on the all axis (1 by default)\r\n * * widthSegments sets the number of segments on the x axis (1 by default)\r\n * * heightSegments sets the number of segments on the y axis (1 by default)\r\n * * depthSegments sets the number of segments on the z axis (1 by default)\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.depth\r\n * @param options.segments\r\n * @param options.widthSegments\r\n * @param options.heightSegments\r\n * @param options.depthSegments\r\n * @returns the VertexData of the box\r\n */\r\nexport function CreateSegmentedBoxVertexData(options: {\r\n    size?: number;\r\n    width?: number;\r\n    height?: number;\r\n    depth?: number;\r\n    segments?: number;\r\n    widthSegments?: number;\r\n    heightSegments?: number;\r\n    depthSegments?: number;\r\n}): VertexData {\r\n    const width = options.width || options.size || 1;\r\n    const height = options.height || options.size || 1;\r\n    const depth = options.depth || options.size || 1;\r\n    const widthSegments = (options.widthSegments || options.segments || 1) | 0;\r\n    const heightSegments = (options.heightSegments || options.segments || 1) | 0;\r\n    const depthSegments = (options.depthSegments || options.segments || 1) | 0;\r\n    const rotationMatrix = new Matrix();\r\n    const translationMatrix = new Matrix();\r\n    const transformMatrix = new Matrix();\r\n\r\n    const bottomPlane = CreateGroundVertexData({ width: width, height: depth, subdivisionsX: widthSegments, subdivisionsY: depthSegments });\r\n    Matrix.TranslationToRef(0, -height / 2, 0, translationMatrix);\r\n    Matrix.RotationZToRef(Math.PI, rotationMatrix);\r\n    rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);\r\n    bottomPlane.transform(transformMatrix);\r\n\r\n    const topPlane = CreateGroundVertexData({ width: width, height: depth, subdivisionsX: widthSegments, subdivisionsY: depthSegments });\r\n    Matrix.TranslationToRef(0, height / 2, 0, transformMatrix);\r\n    topPlane.transform(transformMatrix);\r\n\r\n    const negXPlane = CreateGroundVertexData({ width: height, height: depth, subdivisionsX: heightSegments, subdivisionsY: depthSegments });\r\n    Matrix.TranslationToRef(-width / 2, 0, 0, translationMatrix);\r\n    Matrix.RotationZToRef(Math.PI / 2, rotationMatrix);\r\n    rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);\r\n    negXPlane.transform(transformMatrix);\r\n\r\n    const posXPlane = CreateGroundVertexData({ width: height, height: depth, subdivisionsX: heightSegments, subdivisionsY: depthSegments });\r\n    Matrix.TranslationToRef(width / 2, 0, 0, translationMatrix);\r\n    Matrix.RotationZToRef(-Math.PI / 2, rotationMatrix);\r\n    rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);\r\n    posXPlane.transform(transformMatrix);\r\n\r\n    const negZPlane = CreateGroundVertexData({ width: width, height: height, subdivisionsX: widthSegments, subdivisionsY: heightSegments });\r\n    Matrix.TranslationToRef(0, 0, -depth / 2, translationMatrix);\r\n    Matrix.RotationXToRef(-Math.PI / 2, rotationMatrix);\r\n    rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);\r\n    negZPlane.transform(transformMatrix);\r\n\r\n    const posZPlane = CreateGroundVertexData({ width: width, height: height, subdivisionsX: widthSegments, subdivisionsY: heightSegments });\r\n    Matrix.TranslationToRef(0, 0, depth / 2, translationMatrix);\r\n    Matrix.RotationXToRef(Math.PI / 2, rotationMatrix);\r\n    rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);\r\n    posZPlane.transform(transformMatrix);\r\n\r\n    // Result\r\n    bottomPlane.merge([topPlane, posXPlane, negXPlane, negZPlane, posZPlane], true);\r\n\r\n    return bottomPlane;\r\n}\r\n\r\n/**\r\n * Creates a box mesh\r\n * * The parameter `size` sets the size (float) of each box side (default 1)\r\n * * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)\r\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)\r\n * * Please read this tutorial : https://doc.babylonjs.com/features/featuresDeepDive/materials/using/texturePerBoxFace\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#box\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.depth\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.wrap\r\n * @param options.topBaseAt\r\n * @param options.bottomBaseAt\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the box mesh\r\n */\r\nexport function CreateBox(\r\n    name: string,\r\n    options: {\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        wrap?: boolean;\r\n        topBaseAt?: number;\r\n        bottomBaseAt?: number;\r\n        updatable?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const box = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    box._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateBoxVertexData(options);\r\n\r\n    vertexData.applyToMesh(box, options.updatable);\r\n\r\n    return box;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated please use CreateBox directly\r\n */\r\nexport const BoxBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateBox,\r\n};\r\n\r\n// Side effects\r\nVertexData.CreateBox = CreateBoxVertexData;\r\n\r\nMesh.CreateBox = (name: string, size: number, scene: Nullable<Scene> = null, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        size,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateBox(name, options, scene);\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}