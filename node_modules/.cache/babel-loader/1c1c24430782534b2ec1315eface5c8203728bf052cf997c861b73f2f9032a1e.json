{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterial } from \"../../nodeMaterial.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\nimport \"../../../../Shaders/ShadersInclude/reflectionFunction.js\";\nimport { CubeTexture } from \"../../../Textures/cubeTexture.js\";\nimport { Texture } from \"../../../Textures/texture.js\";\nimport { EngineStore } from \"../../../../Engines/engineStore.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator.js\";\n/**\n * Base block used to read a reflection texture from a sampler\n */\nexport class ReflectionTextureBaseBlock extends NodeMaterialBlock {\n  /**\n   * Gets or sets the texture associated with the node\n   */\n  get texture() {\n    return this._texture;\n  }\n  set texture(texture) {\n    var _a;\n    if (this._texture === texture) {\n      return;\n    }\n    const scene = (_a = texture === null || texture === void 0 ? void 0 : texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;\n    if (!texture && scene) {\n      scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this._texture);\n      });\n    }\n    this._texture = texture;\n    if (texture && scene) {\n      scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(texture);\n      });\n    }\n  }\n  static _OnGenerateOnlyFragmentCodeChanged(block, _propertyName) {\n    const that = block;\n    return that._onGenerateOnlyFragmentCodeChanged();\n  }\n  _onGenerateOnlyFragmentCodeChanged() {\n    this._setTarget();\n    return true;\n  }\n  _setTarget() {\n    this._setInitialTarget(this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);\n  }\n  /**\n   * Create a new ReflectionTextureBaseBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.VertexAndFragment);\n    /** Indicates that no code should be generated in the vertex shader. Can be useful in some specific circumstances (like when doing ray marching for eg) */\n    this.generateOnlyFragmentCode = false;\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ReflectionTextureBaseBlock\";\n  }\n  _getTexture() {\n    return this.texture;\n  }\n  autoConfigure(material, additionalFilteringInfo = () => true) {\n    if (!this.position.isConnected) {\n      let positionInput = material.getInputBlockByPredicate(b => b.isAttribute && b.name === \"position\" && additionalFilteringInfo(b));\n      if (!positionInput) {\n        positionInput = new InputBlock(\"position\");\n        positionInput.setAsAttribute();\n      }\n      positionInput.output.connectTo(this.position);\n    }\n    if (!this.world.isConnected) {\n      let worldInput = material.getInputBlockByPredicate(b => b.systemValue === NodeMaterialSystemValues.World && additionalFilteringInfo(b));\n      if (!worldInput) {\n        worldInput = new InputBlock(\"world\");\n        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\n      }\n      worldInput.output.connectTo(this.world);\n    }\n    if (this.view && !this.view.isConnected) {\n      let viewInput = material.getInputBlockByPredicate(b => b.systemValue === NodeMaterialSystemValues.View && additionalFilteringInfo(b));\n      if (!viewInput) {\n        viewInput = new InputBlock(\"view\");\n        viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\n      }\n      viewInput.output.connectTo(this.view);\n    }\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    if (!defines._areTexturesDirty) {\n      return;\n    }\n    const texture = this._getTexture();\n    if (!texture || !texture.getTextureMatrix) {\n      return;\n    }\n    defines.setValue(this._define3DName, texture.isCube, true);\n    defines.setValue(this._defineLocalCubicName, texture.boundingBoxSize ? true : false, true);\n    defines.setValue(this._defineExplicitName, texture.coordinatesMode === 0, true);\n    defines.setValue(this._defineSkyboxName, texture.coordinatesMode === 5, true);\n    defines.setValue(this._defineCubicName, texture.coordinatesMode === 3 || texture.coordinatesMode === 6, true);\n    defines.setValue(\"INVERTCUBICMAP\", texture.coordinatesMode === 6, true);\n    defines.setValue(this._defineSphericalName, texture.coordinatesMode === 1, true);\n    defines.setValue(this._definePlanarName, texture.coordinatesMode === 2, true);\n    defines.setValue(this._defineProjectionName, texture.coordinatesMode === 4, true);\n    defines.setValue(this._defineEquirectangularName, texture.coordinatesMode === 7, true);\n    defines.setValue(this._defineEquirectangularFixedName, texture.coordinatesMode === 8, true);\n    defines.setValue(this._defineMirroredEquirectangularFixedName, texture.coordinatesMode === 9, true);\n  }\n  isReady() {\n    const texture = this._getTexture();\n    if (texture && !texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n    return true;\n  }\n  bind(effect, nodeMaterial, mesh) {\n    const texture = this._getTexture();\n    if (!mesh || !texture) {\n      return;\n    }\n    effect.setMatrix(this._reflectionMatrixName, texture.getReflectionTextureMatrix());\n    if (texture.isCube) {\n      effect.setTexture(this._cubeSamplerName, texture);\n    } else {\n      effect.setTexture(this._2DSamplerName, texture);\n    }\n    if (texture.boundingBoxSize) {\n      const cubeTexture = texture;\n      effect.setVector3(this._reflectionPositionName, cubeTexture.boundingBoxPosition);\n      effect.setVector3(this._reflectionSizeName, cubeTexture.boundingBoxSize);\n    }\n  }\n  /**\n   * Gets the code to inject in the vertex shader\n   * @param state current state of the node material building\n   * @returns the shader code\n   */\n  handleVertexSide(state) {\n    if (this.generateOnlyFragmentCode && state.target === NodeMaterialBlockTargets.Vertex) {\n      return \"\";\n    }\n    this._define3DName = state._getFreeDefineName(\"REFLECTIONMAP_3D\");\n    this._defineCubicName = state._getFreeDefineName(\"REFLECTIONMAP_CUBIC\");\n    this._defineSphericalName = state._getFreeDefineName(\"REFLECTIONMAP_SPHERICAL\");\n    this._definePlanarName = state._getFreeDefineName(\"REFLECTIONMAP_PLANAR\");\n    this._defineProjectionName = state._getFreeDefineName(\"REFLECTIONMAP_PROJECTION\");\n    this._defineExplicitName = state._getFreeDefineName(\"REFLECTIONMAP_EXPLICIT\");\n    this._defineEquirectangularName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR\");\n    this._defineLocalCubicName = state._getFreeDefineName(\"USE_LOCAL_REFLECTIONMAP_CUBIC\");\n    this._defineMirroredEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\");\n    this._defineEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\");\n    this._defineSkyboxName = state._getFreeDefineName(\"REFLECTIONMAP_SKYBOX\");\n    this._defineOppositeZ = state._getFreeDefineName(\"REFLECTIONMAP_OPPOSITEZ\");\n    this._reflectionMatrixName = state._getFreeVariableName(\"reflectionMatrix\");\n    state._emitUniformFromString(this._reflectionMatrixName, \"mat4\");\n    let code = \"\";\n    this._worldPositionNameInFragmentOnlyMode = state._getFreeVariableName(\"worldPosition\");\n    const worldPosVaryingName = this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : \"v_\" + this.worldPosition.associatedVariableName;\n    if (this.generateOnlyFragmentCode || state._emitVaryingFromString(worldPosVaryingName, \"vec4\")) {\n      code += `${this.generateOnlyFragmentCode ? \"vec4 \" : \"\"}${worldPosVaryingName} = ${this.worldPosition.associatedVariableName};\\n`;\n    }\n    this._positionUVWName = state._getFreeVariableName(\"positionUVW\");\n    this._directionWName = state._getFreeVariableName(\"directionW\");\n    if (this.generateOnlyFragmentCode || state._emitVaryingFromString(this._positionUVWName, \"vec3\", this._defineSkyboxName)) {\n      code += `#ifdef ${this._defineSkyboxName}\\n`;\n      code += `${this.generateOnlyFragmentCode ? \"vec3 \" : \"\"}${this._positionUVWName} = ${this.position.associatedVariableName}.xyz;\\n`;\n      code += `#endif\\n`;\n    }\n    if (this.generateOnlyFragmentCode || state._emitVaryingFromString(this._directionWName, \"vec3\", `defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})`)) {\n      code += `#if defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})\\n`;\n      code += `${this.generateOnlyFragmentCode ? \"vec3 \" : \"\"}${this._directionWName} = normalize(vec3(${this.world.associatedVariableName} * vec4(${this.position.associatedVariableName}.xyz, 0.0)));\\n`;\n      code += `#endif\\n`;\n    }\n    return code;\n  }\n  /**\n   * Handles the inits for the fragment code path\n   * @param state node material build state\n   */\n  handleFragmentSideInits(state) {\n    state.sharedData.blockingBlocks.push(this);\n    state.sharedData.textureBlocks.push(this);\n    // Samplers\n    this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\n    state.samplers.push(this._cubeSamplerName);\n    this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\n    state.samplers.push(this._2DSamplerName);\n    state._samplerDeclaration += `#ifdef ${this._define3DName}\\n`;\n    state._samplerDeclaration += `uniform samplerCube ${this._cubeSamplerName};\\n`;\n    state._samplerDeclaration += `#else\\n`;\n    state._samplerDeclaration += `uniform sampler2D ${this._2DSamplerName};\\n`;\n    state._samplerDeclaration += `#endif\\n`;\n    // Fragment\n    state.sharedData.blocksWithDefines.push(this);\n    state.sharedData.bindableBlocks.push(this);\n    const comments = `//${this.name}`;\n    state._emitFunction(\"ReciprocalPI\", \"#define RECIPROCAL_PI2 0.15915494\", \"\");\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n    state._emitFunctionFromInclude(\"reflectionFunction\", comments, {\n      replaceStrings: [{\n        search: /vec3 computeReflectionCoords/g,\n        replace: \"void DUMMYFUNC\"\n      }]\n    });\n    this._reflectionColorName = state._getFreeVariableName(\"reflectionColor\");\n    this._reflectionVectorName = state._getFreeVariableName(\"reflectionUVW\");\n    this._reflectionCoordsName = state._getFreeVariableName(\"reflectionCoords\");\n    this._reflectionPositionName = state._getFreeVariableName(\"vReflectionPosition\");\n    state._emitUniformFromString(this._reflectionPositionName, \"vec3\");\n    this._reflectionSizeName = state._getFreeVariableName(\"vReflectionPosition\");\n    state._emitUniformFromString(this._reflectionSizeName, \"vec3\");\n  }\n  /**\n   * Generates the reflection coords code for the fragment code path\n   * @param worldNormalVarName name of the world normal variable\n   * @param worldPos name of the world position variable. If not provided, will use the world position connected to this block\n   * @param onlyReflectionVector if true, generates code only for the reflection vector computation, not for the reflection coordinates\n   * @param doNotEmitInvertZ if true, does not emit the invertZ code\n   * @returns the shader code\n   */\n  handleFragmentSideCodeReflectionCoords(worldNormalVarName, worldPos, onlyReflectionVector = false, doNotEmitInvertZ = false) {\n    if (!worldPos) {\n      worldPos = this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : `v_${this.worldPosition.associatedVariableName}`;\n    }\n    const reflectionMatrix = this._reflectionMatrixName;\n    const direction = `normalize(${this._directionWName})`;\n    const positionUVW = `${this._positionUVWName}`;\n    const vEyePosition = `${this.cameraPosition.associatedVariableName}`;\n    const view = `${this.view.associatedVariableName}`;\n    worldNormalVarName += \".xyz\";\n    let code = `\n            #ifdef ${this._defineMirroredEquirectangularFixedName}\n                vec3 ${this._reflectionVectorName} = computeMirroredFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});\n            #endif\n\n            #ifdef ${this._defineEquirectangularFixedName}\n                vec3 ${this._reflectionVectorName} = computeFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});\n            #endif\n\n            #ifdef ${this._defineEquirectangularName}\n                vec3 ${this._reflectionVectorName} = computeEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\n            #endif\n\n            #ifdef ${this._defineSphericalName}\n                vec3 ${this._reflectionVectorName} = computeSphericalCoords(${worldPos}, ${worldNormalVarName}, ${view}, ${reflectionMatrix});\n            #endif\n\n            #ifdef ${this._definePlanarName}\n                vec3 ${this._reflectionVectorName} = computePlanarCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\n            #endif\n\n            #ifdef ${this._defineCubicName}\n                #ifdef ${this._defineLocalCubicName}\n                    vec3 ${this._reflectionVectorName} = computeCubicLocalCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix}, ${this._reflectionSizeName}, ${this._reflectionPositionName});\n                #else\n                vec3 ${this._reflectionVectorName} = computeCubicCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\n                #endif\n            #endif\n\n            #ifdef ${this._defineProjectionName}\n                vec3 ${this._reflectionVectorName} = computeProjectionCoords(${worldPos}, ${view}, ${reflectionMatrix});\n            #endif\n\n            #ifdef ${this._defineSkyboxName}\n                vec3 ${this._reflectionVectorName} = computeSkyBoxCoords(${positionUVW}, ${reflectionMatrix});\n            #endif\n\n            #ifdef ${this._defineExplicitName}\n                vec3 ${this._reflectionVectorName} = vec3(0, 0, 0);\n            #endif\\n`;\n    if (!doNotEmitInvertZ) {\n      code += `#ifdef ${this._defineOppositeZ}\n                ${this._reflectionVectorName}.z *= -1.0;\n            #endif\\n`;\n    }\n    if (!onlyReflectionVector) {\n      code += `\n                #ifdef ${this._define3DName}\n                    vec3 ${this._reflectionCoordsName} = ${this._reflectionVectorName};\n                #else\n                    vec2 ${this._reflectionCoordsName} = ${this._reflectionVectorName}.xy;\n                    #ifdef ${this._defineProjectionName}\n                        ${this._reflectionCoordsName} /= ${this._reflectionVectorName}.z;\n                    #endif\n                    ${this._reflectionCoordsName}.y = 1.0 - ${this._reflectionCoordsName}.y;\n                #endif\\n`;\n    }\n    return code;\n  }\n  /**\n   * Generates the reflection color code for the fragment code path\n   * @param lodVarName name of the lod variable\n   * @param swizzleLookupTexture swizzle to use for the final color variable\n   * @returns the shader code\n   */\n  handleFragmentSideCodeReflectionColor(lodVarName, swizzleLookupTexture = \".rgb\") {\n    const colorType = \"vec\" + (swizzleLookupTexture.length === 0 ? \"4\" : swizzleLookupTexture.length - 1);\n    let code = `${colorType} ${this._reflectionColorName};\n            #ifdef ${this._define3DName}\\n`;\n    if (lodVarName) {\n      code += `${this._reflectionColorName} = textureCubeLodEXT(${this._cubeSamplerName}, ${this._reflectionVectorName}, ${lodVarName})${swizzleLookupTexture};\\n`;\n    } else {\n      code += `${this._reflectionColorName} = textureCube(${this._cubeSamplerName}, ${this._reflectionVectorName})${swizzleLookupTexture};\\n`;\n    }\n    code += `\n            #else\\n`;\n    if (lodVarName) {\n      code += `${this._reflectionColorName} = texture2DLodEXT(${this._2DSamplerName}, ${this._reflectionCoordsName}, ${lodVarName})${swizzleLookupTexture};\\n`;\n    } else {\n      code += `${this._reflectionColorName} = texture2D(${this._2DSamplerName}, ${this._reflectionCoordsName})${swizzleLookupTexture};\\n`;\n    }\n    code += `#endif\\n`;\n    return code;\n  }\n  /**\n   * Generates the code corresponding to the connected output points\n   * @param state node material build state\n   * @param varName name of the variable to output\n   * @returns the shader code\n   */\n  writeOutputs(state, varName) {\n    let code = \"\";\n    if (state.target === NodeMaterialBlockTargets.Fragment) {\n      for (const output of this._outputs) {\n        if (output.hasEndpoints) {\n          code += `${this._declareOutput(output, state)} = ${varName}.${output.name};\\n`;\n        }\n      }\n    }\n    return code;\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    return this;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode();\n    if (!this.texture) {\n      return codeString;\n    }\n    if (this.texture.isCube) {\n      const forcedExtension = this.texture.forcedExtension;\n      codeString += `${this._codeVariableName}.texture = new BABYLON.CubeTexture(\"${this.texture.name}\", undefined, undefined, ${this.texture.noMipmap}, null, undefined, undefined, undefined, ${this.texture._prefiltered}, ${forcedExtension ? '\"' + forcedExtension + '\"' : \"null\"});\\n`;\n    } else {\n      codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null);\\n`;\n    }\n    codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\n`;\n    return codeString;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    if (this.texture && !this.texture.isRenderTarget) {\n      serializationObject.texture = this.texture.serialize();\n    }\n    serializationObject.generateOnlyFragmentCode = this.generateOnlyFragmentCode;\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n      if (serializationObject.texture.isCube) {\n        this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\n      } else {\n        this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n      }\n    }\n    this.generateOnlyFragmentCode = serializationObject.generateOnlyFragmentCode;\n    this._setTarget();\n  }\n}\n__decorate([editableInPropertyPage(\"Generate only fragment code\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    rebuild: true,\n    update: true,\n    onValidation: ReflectionTextureBaseBlock._OnGenerateOnlyFragmentCodeChanged\n  }\n})], ReflectionTextureBaseBlock.prototype, \"generateOnlyFragmentCode\", void 0);\nRegisterClass(\"BABYLON.ReflectionTextureBaseBlock\", ReflectionTextureBaseBlock);","map":{"version":3,"names":["NodeMaterialBlock","NodeMaterialBlockTargets","NodeMaterial","RegisterClass","InputBlock","NodeMaterialSystemValues","CubeTexture","Texture","EngineStore","editableInPropertyPage","PropertyTypeForEdition","ReflectionTextureBaseBlock","texture","_texture","scene","_a","getScene","LastCreatedScene","markAllMaterialsAsDirty","mat","hasTexture","_OnGenerateOnlyFragmentCodeChanged","block","_propertyName","that","_onGenerateOnlyFragmentCodeChanged","_setTarget","_setInitialTarget","generateOnlyFragmentCode","Fragment","VertexAndFragment","constructor","name","getClassName","_getTexture","autoConfigure","material","additionalFilteringInfo","position","isConnected","positionInput","getInputBlockByPredicate","b","isAttribute","setAsAttribute","output","connectTo","world","worldInput","systemValue","World","setAsSystemValue","view","viewInput","View","prepareDefines","mesh","nodeMaterial","defines","_areTexturesDirty","getTextureMatrix","setValue","_define3DName","isCube","_defineLocalCubicName","boundingBoxSize","_defineExplicitName","coordinatesMode","_defineSkyboxName","_defineCubicName","_defineSphericalName","_definePlanarName","_defineProjectionName","_defineEquirectangularName","_defineEquirectangularFixedName","_defineMirroredEquirectangularFixedName","isReady","isReadyOrNotBlocking","bind","effect","setMatrix","_reflectionMatrixName","getReflectionTextureMatrix","setTexture","_cubeSamplerName","_2DSamplerName","cubeTexture","setVector3","_reflectionPositionName","boundingBoxPosition","_reflectionSizeName","handleVertexSide","state","target","Vertex","_getFreeDefineName","_defineOppositeZ","_getFreeVariableName","_emitUniformFromString","code","_worldPositionNameInFragmentOnlyMode","worldPosVaryingName","worldPosition","associatedVariableName","_emitVaryingFromString","_positionUVWName","_directionWName","handleFragmentSideInits","sharedData","blockingBlocks","push","textureBlocks","samplers","_samplerDeclaration","blocksWithDefines","bindableBlocks","comments","_emitFunction","_emitFunctionFromInclude","replaceStrings","search","replace","_reflectionColorName","_reflectionVectorName","_reflectionCoordsName","handleFragmentSideCodeReflectionCoords","worldNormalVarName","worldPos","onlyReflectionVector","doNotEmitInvertZ","reflectionMatrix","direction","positionUVW","vEyePosition","cameraPosition","handleFragmentSideCodeReflectionColor","lodVarName","swizzleLookupTexture","colorType","length","writeOutputs","varName","_outputs","hasEndpoints","_declareOutput","_buildBlock","_dumpPropertiesCode","codeString","forcedExtension","_codeVariableName","noMipmap","_prefiltered","serialize","serializationObject","isRenderTarget","_deserialize","rootUrl","IgnoreTexturesAtLoadTime","url","indexOf","Parse","__decorate","Boolean","notifiers","rebuild","update","onValidation"],"sources":["../../../../../../../dev/core/src/Materials/Node/Blocks/Dual/reflectionTextureBaseBlock.ts"],"sourcesContent":["import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { NodeMaterial } from \"../../nodeMaterial\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport { Constants } from \"../../../../Engines/constants\";\r\n\r\nimport \"../../../../Shaders/ShadersInclude/reflectionFunction\";\r\nimport { CubeTexture } from \"../../../Textures/cubeTexture\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport { EngineStore } from \"../../../../Engines/engineStore\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Base block used to read a reflection texture from a sampler\r\n */\r\nexport abstract class ReflectionTextureBaseBlock extends NodeMaterialBlock {\r\n    /** @internal */\r\n    public _define3DName: string;\r\n    /** @internal */\r\n    public _defineCubicName: string;\r\n    /** @internal */\r\n    public _defineExplicitName: string;\r\n    /** @internal */\r\n    public _defineProjectionName: string;\r\n    /** @internal */\r\n    public _defineLocalCubicName: string;\r\n    /** @internal */\r\n    public _defineSphericalName: string;\r\n    /** @internal */\r\n    public _definePlanarName: string;\r\n    /** @internal */\r\n    public _defineEquirectangularName: string;\r\n    /** @internal */\r\n    public _defineMirroredEquirectangularFixedName: string;\r\n    /** @internal */\r\n    public _defineEquirectangularFixedName: string;\r\n    /** @internal */\r\n    public _defineSkyboxName: string;\r\n    /** @internal */\r\n    public _defineOppositeZ: string;\r\n    /** @internal */\r\n    public _cubeSamplerName: string;\r\n    /** @internal */\r\n    public _2DSamplerName: string;\r\n    /** @internal */\r\n    public _reflectionPositionName: string;\r\n    /** @internal */\r\n    public _reflectionSizeName: string;\r\n\r\n    protected _positionUVWName: string;\r\n    protected _directionWName: string;\r\n    protected _reflectionVectorName: string;\r\n    /** @internal */\r\n    public _reflectionCoordsName: string;\r\n    /** @internal */\r\n    public _reflectionMatrixName: string;\r\n    protected _reflectionColorName: string;\r\n    protected _worldPositionNameInFragmentOnlyMode: string;\r\n\r\n    protected _texture: Nullable<BaseTexture>;\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public get texture(): Nullable<BaseTexture> {\r\n        return this._texture;\r\n    }\r\n\r\n    public set texture(texture: Nullable<BaseTexture>) {\r\n        if (this._texture === texture) {\r\n            return;\r\n        }\r\n\r\n        const scene = texture?.getScene() ?? EngineStore.LastCreatedScene;\r\n\r\n        if (!texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this._texture!);\r\n            });\r\n        }\r\n\r\n        this._texture = texture;\r\n\r\n        if (texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(texture);\r\n            });\r\n        }\r\n    }\r\n\r\n    /** Indicates that no code should be generated in the vertex shader. Can be useful in some specific circumstances (like when doing ray marching for eg) */\r\n    @editableInPropertyPage(\"Generate only fragment code\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\r\n        notifiers: { rebuild: true, update: true, onValidation: ReflectionTextureBaseBlock._OnGenerateOnlyFragmentCodeChanged },\r\n    })\r\n    public generateOnlyFragmentCode = false;\r\n\r\n    protected static _OnGenerateOnlyFragmentCodeChanged(block: NodeMaterialBlock, _propertyName: string): boolean {\r\n        const that = block as ReflectionTextureBaseBlock;\r\n        return that._onGenerateOnlyFragmentCodeChanged();\r\n    }\r\n\r\n    protected _onGenerateOnlyFragmentCodeChanged(): boolean {\r\n        this._setTarget();\r\n        return true;\r\n    }\r\n\r\n    protected _setTarget(): void {\r\n        this._setInitialTarget(this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);\r\n    }\r\n\r\n    /**\r\n     * Create a new ReflectionTextureBaseBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ReflectionTextureBaseBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public abstract get position(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public abstract get worldPosition(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the world normal input component\r\n     */\r\n    public abstract get worldNormal(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the world input component\r\n     */\r\n    public abstract get world(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the camera (or eye) position component\r\n     */\r\n    public abstract get cameraPosition(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the view input component\r\n     */\r\n    public abstract get view(): NodeMaterialConnectionPoint;\r\n\r\n    protected _getTexture(): Nullable<BaseTexture> {\r\n        return this.texture;\r\n    }\r\n\r\n    public autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        if (!this.position.isConnected) {\r\n            let positionInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"position\" && additionalFilteringInfo(b));\r\n\r\n            if (!positionInput) {\r\n                positionInput = new InputBlock(\"position\");\r\n                positionInput.setAsAttribute();\r\n            }\r\n            positionInput.output.connectTo(this.position);\r\n        }\r\n\r\n        if (!this.world.isConnected) {\r\n            let worldInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.World && additionalFilteringInfo(b));\r\n\r\n            if (!worldInput) {\r\n                worldInput = new InputBlock(\"world\");\r\n                worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\r\n            }\r\n            worldInput.output.connectTo(this.world);\r\n        }\r\n\r\n        if (this.view && !this.view.isConnected) {\r\n            let viewInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.View && additionalFilteringInfo(b));\r\n\r\n            if (!viewInput) {\r\n                viewInput = new InputBlock(\"view\");\r\n                viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\r\n            }\r\n            viewInput.output.connectTo(this.view);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        if (!defines._areTexturesDirty) {\r\n            return;\r\n        }\r\n\r\n        const texture = this._getTexture();\r\n\r\n        if (!texture || !texture.getTextureMatrix) {\r\n            return;\r\n        }\r\n\r\n        defines.setValue(this._define3DName, texture.isCube, true);\r\n        defines.setValue(this._defineLocalCubicName, (<any>texture).boundingBoxSize ? true : false, true);\r\n        defines.setValue(this._defineExplicitName, texture.coordinatesMode === Constants.TEXTURE_EXPLICIT_MODE, true);\r\n        defines.setValue(this._defineSkyboxName, texture.coordinatesMode === Constants.TEXTURE_SKYBOX_MODE, true);\r\n        defines.setValue(this._defineCubicName, texture.coordinatesMode === Constants.TEXTURE_CUBIC_MODE || texture.coordinatesMode === Constants.TEXTURE_INVCUBIC_MODE, true);\r\n        defines.setValue(\"INVERTCUBICMAP\", texture.coordinatesMode === Constants.TEXTURE_INVCUBIC_MODE, true);\r\n        defines.setValue(this._defineSphericalName, texture.coordinatesMode === Constants.TEXTURE_SPHERICAL_MODE, true);\r\n        defines.setValue(this._definePlanarName, texture.coordinatesMode === Constants.TEXTURE_PLANAR_MODE, true);\r\n        defines.setValue(this._defineProjectionName, texture.coordinatesMode === Constants.TEXTURE_PROJECTION_MODE, true);\r\n        defines.setValue(this._defineEquirectangularName, texture.coordinatesMode === Constants.TEXTURE_EQUIRECTANGULAR_MODE, true);\r\n        defines.setValue(this._defineEquirectangularFixedName, texture.coordinatesMode === Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MODE, true);\r\n        defines.setValue(this._defineMirroredEquirectangularFixedName, texture.coordinatesMode === Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE, true);\r\n    }\r\n\r\n    public isReady() {\r\n        const texture = this._getTexture();\r\n\r\n        if (texture && !texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        const texture = this._getTexture();\r\n\r\n        if (!mesh || !texture) {\r\n            return;\r\n        }\r\n\r\n        effect.setMatrix(this._reflectionMatrixName, texture.getReflectionTextureMatrix());\r\n\r\n        if (texture.isCube) {\r\n            effect.setTexture(this._cubeSamplerName, texture);\r\n        } else {\r\n            effect.setTexture(this._2DSamplerName, texture);\r\n        }\r\n\r\n        if ((<any>texture).boundingBoxSize) {\r\n            const cubeTexture = <CubeTexture>texture;\r\n            effect.setVector3(this._reflectionPositionName, cubeTexture.boundingBoxPosition);\r\n            effect.setVector3(this._reflectionSizeName, cubeTexture.boundingBoxSize);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the code to inject in the vertex shader\r\n     * @param state current state of the node material building\r\n     * @returns the shader code\r\n     */\r\n    public handleVertexSide(state: NodeMaterialBuildState): string {\r\n        if (this.generateOnlyFragmentCode && state.target === NodeMaterialBlockTargets.Vertex) {\r\n            return \"\";\r\n        }\r\n\r\n        this._define3DName = state._getFreeDefineName(\"REFLECTIONMAP_3D\");\r\n        this._defineCubicName = state._getFreeDefineName(\"REFLECTIONMAP_CUBIC\");\r\n        this._defineSphericalName = state._getFreeDefineName(\"REFLECTIONMAP_SPHERICAL\");\r\n        this._definePlanarName = state._getFreeDefineName(\"REFLECTIONMAP_PLANAR\");\r\n        this._defineProjectionName = state._getFreeDefineName(\"REFLECTIONMAP_PROJECTION\");\r\n        this._defineExplicitName = state._getFreeDefineName(\"REFLECTIONMAP_EXPLICIT\");\r\n        this._defineEquirectangularName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR\");\r\n        this._defineLocalCubicName = state._getFreeDefineName(\"USE_LOCAL_REFLECTIONMAP_CUBIC\");\r\n        this._defineMirroredEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\");\r\n        this._defineEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\");\r\n        this._defineSkyboxName = state._getFreeDefineName(\"REFLECTIONMAP_SKYBOX\");\r\n        this._defineOppositeZ = state._getFreeDefineName(\"REFLECTIONMAP_OPPOSITEZ\");\r\n\r\n        this._reflectionMatrixName = state._getFreeVariableName(\"reflectionMatrix\");\r\n\r\n        state._emitUniformFromString(this._reflectionMatrixName, \"mat4\");\r\n\r\n        let code = \"\";\r\n\r\n        this._worldPositionNameInFragmentOnlyMode = state._getFreeVariableName(\"worldPosition\");\r\n\r\n        const worldPosVaryingName = this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : \"v_\" + this.worldPosition.associatedVariableName;\r\n        if (this.generateOnlyFragmentCode || state._emitVaryingFromString(worldPosVaryingName, \"vec4\")) {\r\n            code += `${this.generateOnlyFragmentCode ? \"vec4 \" : \"\"}${worldPosVaryingName} = ${this.worldPosition.associatedVariableName};\\n`;\r\n        }\r\n\r\n        this._positionUVWName = state._getFreeVariableName(\"positionUVW\");\r\n        this._directionWName = state._getFreeVariableName(\"directionW\");\r\n\r\n        if (this.generateOnlyFragmentCode || state._emitVaryingFromString(this._positionUVWName, \"vec3\", this._defineSkyboxName)) {\r\n            code += `#ifdef ${this._defineSkyboxName}\\n`;\r\n            code += `${this.generateOnlyFragmentCode ? \"vec3 \" : \"\"}${this._positionUVWName} = ${this.position.associatedVariableName}.xyz;\\n`;\r\n            code += `#endif\\n`;\r\n        }\r\n\r\n        if (\r\n            this.generateOnlyFragmentCode ||\r\n            state._emitVaryingFromString(\r\n                this._directionWName,\r\n                \"vec3\",\r\n                `defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})`\r\n            )\r\n        ) {\r\n            code += `#if defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})\\n`;\r\n            code += `${this.generateOnlyFragmentCode ? \"vec3 \" : \"\"}${this._directionWName} = normalize(vec3(${this.world.associatedVariableName} * vec4(${\r\n                this.position.associatedVariableName\r\n            }.xyz, 0.0)));\\n`;\r\n            code += `#endif\\n`;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Handles the inits for the fragment code path\r\n     * @param state node material build state\r\n     */\r\n    public handleFragmentSideInits(state: NodeMaterialBuildState) {\r\n        state.sharedData.blockingBlocks.push(this);\r\n        state.sharedData.textureBlocks.push(this);\r\n\r\n        // Samplers\r\n        this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\r\n        state.samplers.push(this._cubeSamplerName);\r\n\r\n        this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\r\n        state.samplers.push(this._2DSamplerName);\r\n\r\n        state._samplerDeclaration += `#ifdef ${this._define3DName}\\n`;\r\n        state._samplerDeclaration += `uniform samplerCube ${this._cubeSamplerName};\\n`;\r\n        state._samplerDeclaration += `#else\\n`;\r\n        state._samplerDeclaration += `uniform sampler2D ${this._2DSamplerName};\\n`;\r\n        state._samplerDeclaration += `#endif\\n`;\r\n\r\n        // Fragment\r\n        state.sharedData.blocksWithDefines.push(this);\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunction(\"ReciprocalPI\", \"#define RECIPROCAL_PI2 0.15915494\", \"\");\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n        state._emitFunctionFromInclude(\"reflectionFunction\", comments, {\r\n            replaceStrings: [{ search: /vec3 computeReflectionCoords/g, replace: \"void DUMMYFUNC\" }],\r\n        });\r\n\r\n        this._reflectionColorName = state._getFreeVariableName(\"reflectionColor\");\r\n        this._reflectionVectorName = state._getFreeVariableName(\"reflectionUVW\");\r\n        this._reflectionCoordsName = state._getFreeVariableName(\"reflectionCoords\");\r\n\r\n        this._reflectionPositionName = state._getFreeVariableName(\"vReflectionPosition\");\r\n        state._emitUniformFromString(this._reflectionPositionName, \"vec3\");\r\n\r\n        this._reflectionSizeName = state._getFreeVariableName(\"vReflectionPosition\");\r\n        state._emitUniformFromString(this._reflectionSizeName, \"vec3\");\r\n    }\r\n\r\n    /**\r\n     * Generates the reflection coords code for the fragment code path\r\n     * @param worldNormalVarName name of the world normal variable\r\n     * @param worldPos name of the world position variable. If not provided, will use the world position connected to this block\r\n     * @param onlyReflectionVector if true, generates code only for the reflection vector computation, not for the reflection coordinates\r\n     * @param doNotEmitInvertZ if true, does not emit the invertZ code\r\n     * @returns the shader code\r\n     */\r\n    public handleFragmentSideCodeReflectionCoords(worldNormalVarName: string, worldPos?: string, onlyReflectionVector = false, doNotEmitInvertZ = false): string {\r\n        if (!worldPos) {\r\n            worldPos = this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : `v_${this.worldPosition.associatedVariableName}`;\r\n        }\r\n        const reflectionMatrix = this._reflectionMatrixName;\r\n        const direction = `normalize(${this._directionWName})`;\r\n        const positionUVW = `${this._positionUVWName}`;\r\n        const vEyePosition = `${this.cameraPosition.associatedVariableName}`;\r\n        const view = `${this.view.associatedVariableName}`;\r\n\r\n        worldNormalVarName += \".xyz\";\r\n\r\n        let code = `\r\n            #ifdef ${this._defineMirroredEquirectangularFixedName}\r\n                vec3 ${this._reflectionVectorName} = computeMirroredFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});\r\n            #endif\r\n\r\n            #ifdef ${this._defineEquirectangularFixedName}\r\n                vec3 ${this._reflectionVectorName} = computeFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});\r\n            #endif\r\n\r\n            #ifdef ${this._defineEquirectangularName}\r\n                vec3 ${this._reflectionVectorName} = computeEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineSphericalName}\r\n                vec3 ${this._reflectionVectorName} = computeSphericalCoords(${worldPos}, ${worldNormalVarName}, ${view}, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._definePlanarName}\r\n                vec3 ${this._reflectionVectorName} = computePlanarCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineCubicName}\r\n                #ifdef ${this._defineLocalCubicName}\r\n                    vec3 ${this._reflectionVectorName} = computeCubicLocalCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix}, ${this._reflectionSizeName}, ${this._reflectionPositionName});\r\n                #else\r\n                vec3 ${this._reflectionVectorName} = computeCubicCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\r\n                #endif\r\n            #endif\r\n\r\n            #ifdef ${this._defineProjectionName}\r\n                vec3 ${this._reflectionVectorName} = computeProjectionCoords(${worldPos}, ${view}, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineSkyboxName}\r\n                vec3 ${this._reflectionVectorName} = computeSkyBoxCoords(${positionUVW}, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineExplicitName}\r\n                vec3 ${this._reflectionVectorName} = vec3(0, 0, 0);\r\n            #endif\\n`;\r\n\r\n        if (!doNotEmitInvertZ) {\r\n            code += `#ifdef ${this._defineOppositeZ}\r\n                ${this._reflectionVectorName}.z *= -1.0;\r\n            #endif\\n`;\r\n        }\r\n\r\n        if (!onlyReflectionVector) {\r\n            code += `\r\n                #ifdef ${this._define3DName}\r\n                    vec3 ${this._reflectionCoordsName} = ${this._reflectionVectorName};\r\n                #else\r\n                    vec2 ${this._reflectionCoordsName} = ${this._reflectionVectorName}.xy;\r\n                    #ifdef ${this._defineProjectionName}\r\n                        ${this._reflectionCoordsName} /= ${this._reflectionVectorName}.z;\r\n                    #endif\r\n                    ${this._reflectionCoordsName}.y = 1.0 - ${this._reflectionCoordsName}.y;\r\n                #endif\\n`;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Generates the reflection color code for the fragment code path\r\n     * @param lodVarName name of the lod variable\r\n     * @param swizzleLookupTexture swizzle to use for the final color variable\r\n     * @returns the shader code\r\n     */\r\n    public handleFragmentSideCodeReflectionColor(lodVarName?: string, swizzleLookupTexture = \".rgb\"): string {\r\n        const colorType = \"vec\" + (swizzleLookupTexture.length === 0 ? \"4\" : swizzleLookupTexture.length - 1);\r\n\r\n        let code = `${colorType} ${this._reflectionColorName};\r\n            #ifdef ${this._define3DName}\\n`;\r\n\r\n        if (lodVarName) {\r\n            code += `${this._reflectionColorName} = textureCubeLodEXT(${this._cubeSamplerName}, ${this._reflectionVectorName}, ${lodVarName})${swizzleLookupTexture};\\n`;\r\n        } else {\r\n            code += `${this._reflectionColorName} = textureCube(${this._cubeSamplerName}, ${this._reflectionVectorName})${swizzleLookupTexture};\\n`;\r\n        }\r\n\r\n        code += `\r\n            #else\\n`;\r\n\r\n        if (lodVarName) {\r\n            code += `${this._reflectionColorName} = texture2DLodEXT(${this._2DSamplerName}, ${this._reflectionCoordsName}, ${lodVarName})${swizzleLookupTexture};\\n`;\r\n        } else {\r\n            code += `${this._reflectionColorName} = texture2D(${this._2DSamplerName}, ${this._reflectionCoordsName})${swizzleLookupTexture};\\n`;\r\n        }\r\n\r\n        code += `#endif\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Generates the code corresponding to the connected output points\r\n     * @param state node material build state\r\n     * @param varName name of the variable to output\r\n     * @returns the shader code\r\n     */\r\n    public writeOutputs(state: NodeMaterialBuildState, varName: string): string {\r\n        let code = \"\";\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            for (const output of this._outputs) {\r\n                if (output.hasEndpoints) {\r\n                    code += `${this._declareOutput(output, state)} = ${varName}.${output.name};\\n`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        if (!this.texture) {\r\n            return codeString;\r\n        }\r\n\r\n        if (this.texture.isCube) {\r\n            const forcedExtension = (this.texture as CubeTexture).forcedExtension;\r\n            codeString += `${this._codeVariableName}.texture = new BABYLON.CubeTexture(\"${this.texture.name}\", undefined, undefined, ${\r\n                this.texture.noMipmap\r\n            }, null, undefined, undefined, undefined, ${this.texture._prefiltered}, ${forcedExtension ? '\"' + forcedExtension + '\"' : \"null\"});\\n`;\r\n        } else {\r\n            codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null);\\n`;\r\n        }\r\n        codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        if (this.texture && !this.texture.isRenderTarget) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        serializationObject.generateOnlyFragmentCode = this.generateOnlyFragmentCode;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            if (serializationObject.texture.isCube) {\r\n                this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\r\n            } else {\r\n                this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\r\n            }\r\n        }\r\n\r\n        this.generateOnlyFragmentCode = serializationObject.generateOnlyFragmentCode;\r\n\r\n        this._setTarget();\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ReflectionTextureBaseBlock\", ReflectionTextureBaseBlock);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}