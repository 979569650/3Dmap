{"ast":null,"code":"import { __decorate } from \"@babylonjs/core/tslib.es6.js\";\nimport { Observable } from \"@babylonjs/core/Misc/observable.js\";\nimport { Control } from \"../control.js\";\nimport { ValueAndUnit } from \"../../valueAndUnit.js\";\nimport { serialize } from \"@babylonjs/core/Misc/decorators.js\";\n/**\n * Class used to create slider controls\n */\nexport class BaseSlider extends Control {\n  /** Gets or sets a boolean indicating if the thumb must be rendered */\n  get displayThumb() {\n    return this._displayThumb;\n  }\n  set displayThumb(value) {\n    if (this._displayThumb === value) {\n      return;\n    }\n    this._displayThumb = value;\n    this._markAsDirty();\n  }\n  /** Gets or sets a step to apply to values (0 by default) */\n  get step() {\n    return this._step;\n  }\n  set step(value) {\n    if (this._step === value) {\n      return;\n    }\n    this._step = value;\n    this._markAsDirty();\n  }\n  /** Gets or sets main bar offset (ie. the margin applied to the value bar) */\n  get barOffset() {\n    return this._barOffset.toString(this._host);\n  }\n  /** Gets main bar offset in pixels*/\n  get barOffsetInPixels() {\n    return this._barOffset.getValueInPixel(this._host, this._cachedParentMeasure.width);\n  }\n  set barOffset(value) {\n    if (this._barOffset.toString(this._host) === value) {\n      return;\n    }\n    if (this._barOffset.fromString(value)) {\n      this._markAsDirty();\n    }\n  }\n  /** Gets or sets thumb width */\n  get thumbWidth() {\n    return this._thumbWidth.toString(this._host);\n  }\n  /** Gets thumb width in pixels */\n  get thumbWidthInPixels() {\n    return this._thumbWidth.getValueInPixel(this._host, this._cachedParentMeasure.width);\n  }\n  set thumbWidth(value) {\n    if (this._thumbWidth.toString(this._host) === value) {\n      return;\n    }\n    if (this._thumbWidth.fromString(value)) {\n      this._markAsDirty();\n    }\n  }\n  /** Gets or sets minimum value */\n  get minimum() {\n    return this._minimum;\n  }\n  set minimum(value) {\n    if (this._minimum === value) {\n      return;\n    }\n    this._minimum = value;\n    this._markAsDirty();\n    this.value = Math.max(Math.min(this.value, this._maximum), this._minimum);\n  }\n  /** Gets or sets maximum value */\n  get maximum() {\n    return this._maximum;\n  }\n  set maximum(value) {\n    if (this._maximum === value) {\n      return;\n    }\n    this._maximum = value;\n    this._markAsDirty();\n    this.value = Math.max(Math.min(this.value, this._maximum), this._minimum);\n  }\n  /** Gets or sets current value */\n  get value() {\n    return this._value;\n  }\n  set value(value) {\n    value = Math.max(Math.min(value, this._maximum), this._minimum);\n    if (this._value === value) {\n      return;\n    }\n    this._value = value;\n    this._markAsDirty();\n    this.onValueChangedObservable.notifyObservers(this._value);\n  }\n  /**Gets or sets a boolean indicating if the slider should be vertical or horizontal */\n  get isVertical() {\n    return this._isVertical;\n  }\n  set isVertical(value) {\n    if (this._isVertical === value) {\n      return;\n    }\n    this._isVertical = value;\n    this._markAsDirty();\n  }\n  /** Gets or sets a value indicating if the thumb can go over main bar extends */\n  get isThumbClamped() {\n    return this._isThumbClamped;\n  }\n  set isThumbClamped(value) {\n    if (this._isThumbClamped === value) {\n      return;\n    }\n    this._isThumbClamped = value;\n    this._markAsDirty();\n  }\n  /**\n   * Creates a new BaseSlider\n   * @param name defines the control name\n   */\n  constructor(name) {\n    super(name);\n    this.name = name;\n    this._thumbWidth = new ValueAndUnit(20, ValueAndUnit.UNITMODE_PIXEL, false);\n    this._minimum = 0;\n    this._maximum = 100;\n    this._value = 50;\n    this._isVertical = false;\n    this._barOffset = new ValueAndUnit(5, ValueAndUnit.UNITMODE_PIXEL, false);\n    this._isThumbClamped = false;\n    this._displayThumb = true;\n    this._step = 0;\n    this._lastPointerDownId = -1;\n    // Shared rendering info\n    this._effectiveBarOffset = 0;\n    /** Observable raised when the slider value changes */\n    this.onValueChangedObservable = new Observable();\n    // Events\n    this._pointerIsDown = false;\n    this.isPointerBlocker = true;\n  }\n  _getTypeName() {\n    return \"BaseSlider\";\n  }\n  _getThumbPosition() {\n    if (this.isVertical) {\n      return (this.maximum - this.value) / (this.maximum - this.minimum) * this._backgroundBoxLength;\n    }\n    return (this.value - this.minimum) / (this.maximum - this.minimum) * this._backgroundBoxLength;\n  }\n  _getThumbThickness(type) {\n    let thumbThickness = 0;\n    switch (type) {\n      case \"circle\":\n        if (this._thumbWidth.isPixel) {\n          thumbThickness = Math.max(this._thumbWidth.getValue(this._host), this._backgroundBoxThickness);\n        } else {\n          thumbThickness = this._backgroundBoxThickness * this._thumbWidth.getValue(this._host);\n        }\n        break;\n      case \"rectangle\":\n        if (this._thumbWidth.isPixel) {\n          thumbThickness = Math.min(this._thumbWidth.getValue(this._host), this._backgroundBoxThickness);\n        } else {\n          thumbThickness = this._backgroundBoxThickness * this._thumbWidth.getValue(this._host);\n        }\n    }\n    return thumbThickness;\n  }\n  _prepareRenderingData(type) {\n    // Main bar\n    this._effectiveBarOffset = 0;\n    this._renderLeft = this._currentMeasure.left;\n    this._renderTop = this._currentMeasure.top;\n    this._renderWidth = this._currentMeasure.width;\n    this._renderHeight = this._currentMeasure.height;\n    this._backgroundBoxLength = Math.max(this._currentMeasure.width, this._currentMeasure.height);\n    this._backgroundBoxThickness = Math.min(this._currentMeasure.width, this._currentMeasure.height);\n    this._effectiveThumbThickness = this._getThumbThickness(type);\n    if (this.displayThumb) {\n      this._backgroundBoxLength -= this._effectiveThumbThickness;\n    }\n    //throw error when height is less than width for vertical slider\n    if (this.isVertical && this._currentMeasure.height < this._currentMeasure.width) {\n      console.error(\"Height should be greater than width\");\n      return;\n    }\n    if (this._barOffset.isPixel) {\n      this._effectiveBarOffset = Math.min(this._barOffset.getValue(this._host), this._backgroundBoxThickness);\n    } else {\n      this._effectiveBarOffset = this._backgroundBoxThickness * this._barOffset.getValue(this._host);\n    }\n    this._backgroundBoxThickness -= this._effectiveBarOffset * 2;\n    if (this.isVertical) {\n      this._renderLeft += this._effectiveBarOffset;\n      if (!this.isThumbClamped && this.displayThumb) {\n        this._renderTop += this._effectiveThumbThickness / 2;\n      }\n      this._renderHeight = this._backgroundBoxLength;\n      this._renderWidth = this._backgroundBoxThickness;\n    } else {\n      this._renderTop += this._effectiveBarOffset;\n      if (!this.isThumbClamped && this.displayThumb) {\n        this._renderLeft += this._effectiveThumbThickness / 2;\n      }\n      this._renderHeight = this._backgroundBoxThickness;\n      this._renderWidth = this._backgroundBoxLength;\n    }\n  }\n  /**\n   * @internal\n   */\n  _updateValueFromPointer(x, y) {\n    if (this.rotation != 0) {\n      this._invertTransformMatrix.transformCoordinates(x, y, this._transformedPosition);\n      x = this._transformedPosition.x;\n      y = this._transformedPosition.y;\n    }\n    let value;\n    if (this._isVertical) {\n      value = this._minimum + (1 - (y - this._currentMeasure.top) / this._currentMeasure.height) * (this._maximum - this._minimum);\n    } else {\n      value = this._minimum + (x - this._currentMeasure.left) / this._currentMeasure.width * (this._maximum - this._minimum);\n    }\n    this.value = this._step ? Math.round(value / this._step) * this._step : value;\n  }\n  _onPointerDown(target, coordinates, pointerId, buttonIndex, pi) {\n    if (!super._onPointerDown(target, coordinates, pointerId, buttonIndex, pi)) {\n      return false;\n    }\n    if (this.isReadOnly) {\n      return true;\n    }\n    this._pointerIsDown = true;\n    this._updateValueFromPointer(coordinates.x, coordinates.y);\n    this._host._capturingControl[pointerId] = this;\n    this._lastPointerDownId = pointerId;\n    return true;\n  }\n  _onPointerMove(target, coordinates, pointerId, pi) {\n    // Only listen to pointer move events coming from the last pointer to click on the element (To support dual vr controller interaction)\n    if (pointerId != this._lastPointerDownId) {\n      return;\n    }\n    if (this._pointerIsDown && !this.isReadOnly) {\n      this._updateValueFromPointer(coordinates.x, coordinates.y);\n    }\n    super._onPointerMove(target, coordinates, pointerId, pi);\n  }\n  _onPointerUp(target, coordinates, pointerId, buttonIndex, notifyClick) {\n    this._pointerIsDown = false;\n    delete this._host._capturingControl[pointerId];\n    super._onPointerUp(target, coordinates, pointerId, buttonIndex, notifyClick);\n  }\n  _onCanvasBlur() {\n    this._forcePointerUp();\n    super._onCanvasBlur();\n  }\n}\n__decorate([serialize()], BaseSlider.prototype, \"displayThumb\", null);\n__decorate([serialize()], BaseSlider.prototype, \"step\", null);\n__decorate([serialize()], BaseSlider.prototype, \"barOffset\", null);\n__decorate([serialize()], BaseSlider.prototype, \"thumbWidth\", null);\n__decorate([serialize()], BaseSlider.prototype, \"minimum\", null);\n__decorate([serialize()], BaseSlider.prototype, \"maximum\", null);\n__decorate([serialize()], BaseSlider.prototype, \"value\", null);\n__decorate([serialize()], BaseSlider.prototype, \"isVertical\", null);\n__decorate([serialize()], BaseSlider.prototype, \"isThumbClamped\", null);","map":{"version":3,"names":["Observable","Control","ValueAndUnit","serialize","BaseSlider","displayThumb","_displayThumb","value","_markAsDirty","step","_step","barOffset","_barOffset","toString","_host","barOffsetInPixels","getValueInPixel","_cachedParentMeasure","width","fromString","thumbWidth","_thumbWidth","thumbWidthInPixels","minimum","_minimum","Math","max","min","_maximum","maximum","_value","onValueChangedObservable","notifyObservers","isVertical","_isVertical","isThumbClamped","_isThumbClamped","constructor","name","UNITMODE_PIXEL","_lastPointerDownId","_effectiveBarOffset","_pointerIsDown","isPointerBlocker","_getTypeName","_getThumbPosition","_backgroundBoxLength","_getThumbThickness","type","thumbThickness","isPixel","getValue","_backgroundBoxThickness","_prepareRenderingData","_renderLeft","_currentMeasure","left","_renderTop","top","_renderWidth","_renderHeight","height","_effectiveThumbThickness","console","error","_updateValueFromPointer","x","y","rotation","_invertTransformMatrix","transformCoordinates","_transformedPosition","round","_onPointerDown","target","coordinates","pointerId","buttonIndex","pi","isReadOnly","_capturingControl","_onPointerMove","_onPointerUp","notifyClick","_onCanvasBlur","_forcePointerUp","__decorate"],"sources":["../../../../../../dev/gui/src/2D/controls/sliders/baseSlider.ts"],"sourcesContent":["import { Observable } from \"core/Misc/observable\";\r\nimport type { Vector2 } from \"core/Maths/math.vector\";\r\n\r\nimport { Control } from \"../control\";\r\nimport { ValueAndUnit } from \"../../valueAndUnit\";\r\nimport type { PointerInfoBase } from \"core/Events/pointerEvents\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\n\r\n/**\r\n * Class used to create slider controls\r\n */\r\nexport class BaseSlider extends Control {\r\n    protected _thumbWidth = new ValueAndUnit(20, ValueAndUnit.UNITMODE_PIXEL, false);\r\n    private _minimum = 0;\r\n    private _maximum = 100;\r\n    private _value = 50;\r\n    private _isVertical = false;\r\n    protected _barOffset = new ValueAndUnit(5, ValueAndUnit.UNITMODE_PIXEL, false);\r\n    private _isThumbClamped = false;\r\n    protected _displayThumb = true;\r\n    private _step = 0;\r\n\r\n    private _lastPointerDownId = -1;\r\n\r\n    // Shared rendering info\r\n    protected _effectiveBarOffset = 0;\r\n    protected _renderLeft: number;\r\n    protected _renderTop: number;\r\n    protected _renderWidth: number;\r\n    protected _renderHeight: number;\r\n    protected _backgroundBoxLength: number;\r\n    protected _backgroundBoxThickness: number;\r\n    protected _effectiveThumbThickness: number;\r\n\r\n    /** Observable raised when the slider value changes */\r\n    public onValueChangedObservable = new Observable<number>();\r\n\r\n    /** Gets or sets a boolean indicating if the thumb must be rendered */\r\n    @serialize()\r\n    public get displayThumb(): boolean {\r\n        return this._displayThumb;\r\n    }\r\n\r\n    public set displayThumb(value: boolean) {\r\n        if (this._displayThumb === value) {\r\n            return;\r\n        }\r\n\r\n        this._displayThumb = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets a step to apply to values (0 by default) */\r\n    @serialize()\r\n    public get step(): number {\r\n        return this._step;\r\n    }\r\n\r\n    public set step(value: number) {\r\n        if (this._step === value) {\r\n            return;\r\n        }\r\n\r\n        this._step = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets main bar offset (ie. the margin applied to the value bar) */\r\n    @serialize()\r\n    public get barOffset(): string | number {\r\n        return this._barOffset.toString(this._host);\r\n    }\r\n\r\n    /** Gets main bar offset in pixels*/\r\n    public get barOffsetInPixels(): number {\r\n        return this._barOffset.getValueInPixel(this._host, this._cachedParentMeasure.width);\r\n    }\r\n\r\n    public set barOffset(value: string | number) {\r\n        if (this._barOffset.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._barOffset.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /** Gets or sets thumb width */\r\n    @serialize()\r\n    public get thumbWidth(): string | number {\r\n        return this._thumbWidth.toString(this._host);\r\n    }\r\n\r\n    /** Gets thumb width in pixels */\r\n    public get thumbWidthInPixels(): number {\r\n        return this._thumbWidth.getValueInPixel(this._host, this._cachedParentMeasure.width);\r\n    }\r\n\r\n    public set thumbWidth(value: string | number) {\r\n        if (this._thumbWidth.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._thumbWidth.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /** Gets or sets minimum value */\r\n    @serialize()\r\n    public get minimum(): number {\r\n        return this._minimum;\r\n    }\r\n\r\n    public set minimum(value: number) {\r\n        if (this._minimum === value) {\r\n            return;\r\n        }\r\n\r\n        this._minimum = value;\r\n        this._markAsDirty();\r\n\r\n        this.value = Math.max(Math.min(this.value, this._maximum), this._minimum);\r\n    }\r\n\r\n    /** Gets or sets maximum value */\r\n    @serialize()\r\n    public get maximum(): number {\r\n        return this._maximum;\r\n    }\r\n\r\n    public set maximum(value: number) {\r\n        if (this._maximum === value) {\r\n            return;\r\n        }\r\n\r\n        this._maximum = value;\r\n        this._markAsDirty();\r\n\r\n        this.value = Math.max(Math.min(this.value, this._maximum), this._minimum);\r\n    }\r\n\r\n    /** Gets or sets current value */\r\n    @serialize()\r\n    public get value(): number {\r\n        return this._value;\r\n    }\r\n\r\n    public set value(value: number) {\r\n        value = Math.max(Math.min(value, this._maximum), this._minimum);\r\n\r\n        if (this._value === value) {\r\n            return;\r\n        }\r\n\r\n        this._value = value;\r\n        this._markAsDirty();\r\n        this.onValueChangedObservable.notifyObservers(this._value);\r\n    }\r\n\r\n    /**Gets or sets a boolean indicating if the slider should be vertical or horizontal */\r\n    @serialize()\r\n    public get isVertical(): boolean {\r\n        return this._isVertical;\r\n    }\r\n\r\n    public set isVertical(value: boolean) {\r\n        if (this._isVertical === value) {\r\n            return;\r\n        }\r\n\r\n        this._isVertical = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets a value indicating if the thumb can go over main bar extends */\r\n    @serialize()\r\n    public get isThumbClamped(): boolean {\r\n        return this._isThumbClamped;\r\n    }\r\n\r\n    public set isThumbClamped(value: boolean) {\r\n        if (this._isThumbClamped === value) {\r\n            return;\r\n        }\r\n\r\n        this._isThumbClamped = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Creates a new BaseSlider\r\n     * @param name defines the control name\r\n     */\r\n    constructor(public name?: string) {\r\n        super(name);\r\n\r\n        this.isPointerBlocker = true;\r\n    }\r\n\r\n    protected _getTypeName(): string {\r\n        return \"BaseSlider\";\r\n    }\r\n\r\n    protected _getThumbPosition() {\r\n        if (this.isVertical) {\r\n            return ((this.maximum - this.value) / (this.maximum - this.minimum)) * this._backgroundBoxLength;\r\n        }\r\n\r\n        return ((this.value - this.minimum) / (this.maximum - this.minimum)) * this._backgroundBoxLength;\r\n    }\r\n\r\n    protected _getThumbThickness(type: string): number {\r\n        let thumbThickness = 0;\r\n        switch (type) {\r\n            case \"circle\":\r\n                if (this._thumbWidth.isPixel) {\r\n                    thumbThickness = Math.max(this._thumbWidth.getValue(this._host), this._backgroundBoxThickness);\r\n                } else {\r\n                    thumbThickness = this._backgroundBoxThickness * this._thumbWidth.getValue(this._host);\r\n                }\r\n                break;\r\n            case \"rectangle\":\r\n                if (this._thumbWidth.isPixel) {\r\n                    thumbThickness = Math.min(this._thumbWidth.getValue(this._host), this._backgroundBoxThickness);\r\n                } else {\r\n                    thumbThickness = this._backgroundBoxThickness * this._thumbWidth.getValue(this._host);\r\n                }\r\n        }\r\n        return thumbThickness;\r\n    }\r\n\r\n    protected _prepareRenderingData(type: string) {\r\n        // Main bar\r\n        this._effectiveBarOffset = 0;\r\n        this._renderLeft = this._currentMeasure.left;\r\n        this._renderTop = this._currentMeasure.top;\r\n        this._renderWidth = this._currentMeasure.width;\r\n        this._renderHeight = this._currentMeasure.height;\r\n\r\n        this._backgroundBoxLength = Math.max(this._currentMeasure.width, this._currentMeasure.height);\r\n        this._backgroundBoxThickness = Math.min(this._currentMeasure.width, this._currentMeasure.height);\r\n        this._effectiveThumbThickness = this._getThumbThickness(type);\r\n\r\n        if (this.displayThumb) {\r\n            this._backgroundBoxLength -= this._effectiveThumbThickness;\r\n        }\r\n        //throw error when height is less than width for vertical slider\r\n        if (this.isVertical && this._currentMeasure.height < this._currentMeasure.width) {\r\n            console.error(\"Height should be greater than width\");\r\n            return;\r\n        }\r\n        if (this._barOffset.isPixel) {\r\n            this._effectiveBarOffset = Math.min(this._barOffset.getValue(this._host), this._backgroundBoxThickness);\r\n        } else {\r\n            this._effectiveBarOffset = this._backgroundBoxThickness * this._barOffset.getValue(this._host);\r\n        }\r\n\r\n        this._backgroundBoxThickness -= this._effectiveBarOffset * 2;\r\n\r\n        if (this.isVertical) {\r\n            this._renderLeft += this._effectiveBarOffset;\r\n            if (!this.isThumbClamped && this.displayThumb) {\r\n                this._renderTop += this._effectiveThumbThickness / 2;\r\n            }\r\n\r\n            this._renderHeight = this._backgroundBoxLength;\r\n            this._renderWidth = this._backgroundBoxThickness;\r\n        } else {\r\n            this._renderTop += this._effectiveBarOffset;\r\n            if (!this.isThumbClamped && this.displayThumb) {\r\n                this._renderLeft += this._effectiveThumbThickness / 2;\r\n            }\r\n            this._renderHeight = this._backgroundBoxThickness;\r\n            this._renderWidth = this._backgroundBoxLength;\r\n        }\r\n    }\r\n\r\n    // Events\r\n    private _pointerIsDown = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _updateValueFromPointer(x: number, y: number): void {\r\n        if (this.rotation != 0) {\r\n            this._invertTransformMatrix.transformCoordinates(x, y, this._transformedPosition);\r\n            x = this._transformedPosition.x;\r\n            y = this._transformedPosition.y;\r\n        }\r\n\r\n        let value: number;\r\n        if (this._isVertical) {\r\n            value = this._minimum + (1 - (y - this._currentMeasure.top) / this._currentMeasure.height) * (this._maximum - this._minimum);\r\n        } else {\r\n            value = this._minimum + ((x - this._currentMeasure.left) / this._currentMeasure.width) * (this._maximum - this._minimum);\r\n        }\r\n        this.value = this._step ? Math.round(value / this._step) * this._step : value;\r\n    }\r\n\r\n    public _onPointerDown(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, pi: PointerInfoBase): boolean {\r\n        if (!super._onPointerDown(target, coordinates, pointerId, buttonIndex, pi)) {\r\n            return false;\r\n        }\r\n\r\n        if (this.isReadOnly) {\r\n            return true;\r\n        }\r\n\r\n        this._pointerIsDown = true;\r\n\r\n        this._updateValueFromPointer(coordinates.x, coordinates.y);\r\n        this._host._capturingControl[pointerId] = this;\r\n        this._lastPointerDownId = pointerId;\r\n        return true;\r\n    }\r\n\r\n    public _onPointerMove(target: Control, coordinates: Vector2, pointerId: number, pi: PointerInfoBase): void {\r\n        // Only listen to pointer move events coming from the last pointer to click on the element (To support dual vr controller interaction)\r\n        if (pointerId != this._lastPointerDownId) {\r\n            return;\r\n        }\r\n\r\n        if (this._pointerIsDown && !this.isReadOnly) {\r\n            this._updateValueFromPointer(coordinates.x, coordinates.y);\r\n        }\r\n\r\n        super._onPointerMove(target, coordinates, pointerId, pi);\r\n    }\r\n\r\n    public _onPointerUp(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, notifyClick: boolean): void {\r\n        this._pointerIsDown = false;\r\n\r\n        delete this._host._capturingControl[pointerId];\r\n        super._onPointerUp(target, coordinates, pointerId, buttonIndex, notifyClick);\r\n    }\r\n\r\n    public _onCanvasBlur(): void {\r\n        this._forcePointerUp();\r\n        super._onCanvasBlur();\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}