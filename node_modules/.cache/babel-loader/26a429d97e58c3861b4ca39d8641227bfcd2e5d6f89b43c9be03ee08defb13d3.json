{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../../tslib.es6.js\";\nimport { serialize, SerializationHelper } from \"../../../Misc/decorators.js\";\nimport { Observable } from \"../../../Misc/observable.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nimport { Texture } from \"../../../Materials/Textures/texture.js\";\nimport { GlowLayer } from \"../../../Layers/glowLayer.js\";\nimport { SharpenPostProcess } from \"../../../PostProcesses/sharpenPostProcess.js\";\nimport { ImageProcessingPostProcess } from \"../../../PostProcesses/imageProcessingPostProcess.js\";\nimport { ChromaticAberrationPostProcess } from \"../../../PostProcesses/chromaticAberrationPostProcess.js\";\nimport { GrainPostProcess } from \"../../../PostProcesses/grainPostProcess.js\";\nimport { FxaaPostProcess } from \"../../../PostProcesses/fxaaPostProcess.js\";\nimport { PostProcessRenderPipeline } from \"../../../PostProcesses/RenderPipeline/postProcessRenderPipeline.js\";\nimport { PostProcessRenderEffect } from \"../../../PostProcesses/RenderPipeline/postProcessRenderEffect.js\";\nimport { DepthOfFieldEffect, DepthOfFieldEffectBlurLevel } from \"../../../PostProcesses/depthOfFieldEffect.js\";\nimport { BloomEffect } from \"../../../PostProcesses/bloomEffect.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { EngineStore } from \"../../../Engines/engineStore.js\";\nimport { Tools } from \"../../../Misc/tools.js\";\nimport \"../../../PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent.js\";\n/**\n * The default rendering pipeline can be added to a scene to apply common post processing effects such as anti-aliasing or depth of field.\n * See https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/defaultRenderingPipeline\n */\nexport class DefaultRenderingPipeline extends PostProcessRenderPipeline {\n  /**\n   * Enable or disable automatic building of the pipeline when effects are enabled and disabled.\n   * If false, you will have to manually call prepare() to update the pipeline.\n   */\n  get automaticBuild() {\n    return this._buildAllowed;\n  }\n  set automaticBuild(value) {\n    this._buildAllowed = value;\n  }\n  /**\n   * Gets active scene\n   */\n  get scene() {\n    return this._scene;\n  }\n  /**\n   * Enable or disable the sharpen process from the pipeline\n   */\n  set sharpenEnabled(enabled) {\n    if (this._sharpenEnabled === enabled) {\n      return;\n    }\n    this._sharpenEnabled = enabled;\n    this._buildPipeline();\n  }\n  get sharpenEnabled() {\n    return this._sharpenEnabled;\n  }\n  /**\n   * Specifies the size of the bloom blur kernel, relative to the final output size\n   */\n  get bloomKernel() {\n    return this._bloomKernel;\n  }\n  set bloomKernel(value) {\n    this._bloomKernel = value;\n    this.bloom.kernel = value / this._hardwareScaleLevel;\n  }\n  /**\n   * The strength of the bloom.\n   */\n  set bloomWeight(value) {\n    if (this._bloomWeight === value) {\n      return;\n    }\n    this.bloom.weight = value;\n    this._bloomWeight = value;\n  }\n  get bloomWeight() {\n    return this._bloomWeight;\n  }\n  /**\n   * The luminance threshold to find bright areas of the image to bloom.\n   */\n  set bloomThreshold(value) {\n    if (this._bloomThreshold === value) {\n      return;\n    }\n    this.bloom.threshold = value;\n    this._bloomThreshold = value;\n  }\n  get bloomThreshold() {\n    return this._bloomThreshold;\n  }\n  /**\n   * The scale of the bloom, lower value will provide better performance.\n   */\n  set bloomScale(value) {\n    if (this._bloomScale === value) {\n      return;\n    }\n    this._bloomScale = value;\n    // recreate bloom and dispose old as this setting is not dynamic\n    this._rebuildBloom();\n    this._buildPipeline();\n  }\n  get bloomScale() {\n    return this._bloomScale;\n  }\n  /**\n   * Enable or disable the bloom from the pipeline\n   */\n  set bloomEnabled(enabled) {\n    if (this._bloomEnabled === enabled) {\n      return;\n    }\n    this._bloomEnabled = enabled;\n    this._buildPipeline();\n  }\n  get bloomEnabled() {\n    return this._bloomEnabled;\n  }\n  _rebuildBloom() {\n    // recreate bloom and dispose old as this setting is not dynamic\n    const oldBloom = this.bloom;\n    this.bloom = new BloomEffect(this._scene, this.bloomScale, this._bloomWeight, this.bloomKernel / this._hardwareScaleLevel, this._defaultPipelineTextureType, false);\n    this.bloom.threshold = oldBloom.threshold;\n    for (let i = 0; i < this._cameras.length; i++) {\n      oldBloom.disposeEffects(this._cameras[i]);\n    }\n  }\n  /**\n   * If the depth of field is enabled.\n   */\n  get depthOfFieldEnabled() {\n    return this._depthOfFieldEnabled;\n  }\n  set depthOfFieldEnabled(enabled) {\n    if (this._depthOfFieldEnabled === enabled) {\n      return;\n    }\n    this._depthOfFieldEnabled = enabled;\n    this._buildPipeline();\n  }\n  /**\n   * Blur level of the depth of field effect. (Higher blur will effect performance)\n   */\n  get depthOfFieldBlurLevel() {\n    return this._depthOfFieldBlurLevel;\n  }\n  set depthOfFieldBlurLevel(value) {\n    if (this._depthOfFieldBlurLevel === value) {\n      return;\n    }\n    this._depthOfFieldBlurLevel = value;\n    // recreate dof and dispose old as this setting is not dynamic\n    const oldDof = this.depthOfField;\n    this.depthOfField = new DepthOfFieldEffect(this._scene, null, this._depthOfFieldBlurLevel, this._defaultPipelineTextureType, false);\n    this.depthOfField.focalLength = oldDof.focalLength;\n    this.depthOfField.focusDistance = oldDof.focusDistance;\n    this.depthOfField.fStop = oldDof.fStop;\n    this.depthOfField.lensSize = oldDof.lensSize;\n    for (let i = 0; i < this._cameras.length; i++) {\n      oldDof.disposeEffects(this._cameras[i]);\n    }\n    this._buildPipeline();\n  }\n  /**\n   * If the anti aliasing is enabled.\n   */\n  set fxaaEnabled(enabled) {\n    if (this._fxaaEnabled === enabled) {\n      return;\n    }\n    this._fxaaEnabled = enabled;\n    this._buildPipeline();\n  }\n  get fxaaEnabled() {\n    return this._fxaaEnabled;\n  }\n  /**\n   * MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)\n   */\n  set samples(sampleCount) {\n    if (this._samples === sampleCount) {\n      return;\n    }\n    this._samples = sampleCount;\n    this._buildPipeline();\n  }\n  get samples() {\n    return this._samples;\n  }\n  /**\n   * If image processing is enabled.\n   */\n  set imageProcessingEnabled(enabled) {\n    if (this._imageProcessingEnabled === enabled) {\n      return;\n    }\n    this._scene.imageProcessingConfiguration.isEnabled = enabled;\n  }\n  get imageProcessingEnabled() {\n    return this._imageProcessingEnabled;\n  }\n  /**\n   * If glow layer is enabled. (Adds a glow effect to emmissive materials)\n   */\n  set glowLayerEnabled(enabled) {\n    if (enabled && !this._glowLayer) {\n      this._glowLayer = new GlowLayer(\"\", this._scene);\n    } else if (!enabled && this._glowLayer) {\n      this._glowLayer.dispose();\n      this._glowLayer = null;\n    }\n  }\n  get glowLayerEnabled() {\n    return this._glowLayer != null;\n  }\n  /**\n   * Gets the glow layer (or null if not defined)\n   */\n  get glowLayer() {\n    return this._glowLayer;\n  }\n  /**\n   * Enable or disable the chromaticAberration process from the pipeline\n   */\n  set chromaticAberrationEnabled(enabled) {\n    if (this._chromaticAberrationEnabled === enabled) {\n      return;\n    }\n    this._chromaticAberrationEnabled = enabled;\n    this._buildPipeline();\n  }\n  get chromaticAberrationEnabled() {\n    return this._chromaticAberrationEnabled;\n  }\n  /**\n   * Enable or disable the grain process from the pipeline\n   */\n  set grainEnabled(enabled) {\n    if (this._grainEnabled === enabled) {\n      return;\n    }\n    this._grainEnabled = enabled;\n    this._buildPipeline();\n  }\n  get grainEnabled() {\n    return this._grainEnabled;\n  }\n  /**\n   * Instantiates a DefaultRenderingPipeline.\n   * @param name The rendering pipeline name (default: \"\")\n   * @param hdr If high dynamic range textures should be used (default: true)\n   * @param scene The scene linked to this pipeline (default: the last created scene)\n   * @param cameras The array of cameras that the rendering pipeline will be attached to (default: scene.cameras)\n   * @param automaticBuild If false, you will have to manually call prepare() to update the pipeline (default: true)\n   */\n  constructor(name = \"\", hdr = true, scene = EngineStore.LastCreatedScene, cameras, automaticBuild = true) {\n    super(scene.getEngine(), name);\n    this._camerasToBeAttached = [];\n    /**\n     * ID of the sharpen post process,\n     */\n    this.SharpenPostProcessId = \"SharpenPostProcessEffect\";\n    /**\n     * @ignore\n     * ID of the image processing post process;\n     */\n    this.ImageProcessingPostProcessId = \"ImageProcessingPostProcessEffect\";\n    /**\n     * @ignore\n     * ID of the Fast Approximate Anti-Aliasing post process;\n     */\n    this.FxaaPostProcessId = \"FxaaPostProcessEffect\";\n    /**\n     * ID of the chromatic aberration post process,\n     */\n    this.ChromaticAberrationPostProcessId = \"ChromaticAberrationPostProcessEffect\";\n    /**\n     * ID of the grain post process\n     */\n    this.GrainPostProcessId = \"GrainPostProcessEffect\";\n    /**\n     * Glow post process which adds a glow to emissive areas of the image\n     */\n    this._glowLayer = null;\n    /**\n     * Animations which can be used to tweak settings over a period of time\n     */\n    this.animations = [];\n    this._imageProcessingConfigurationObserver = null;\n    // Values\n    this._sharpenEnabled = false;\n    this._bloomEnabled = false;\n    this._depthOfFieldEnabled = false;\n    this._depthOfFieldBlurLevel = DepthOfFieldEffectBlurLevel.Low;\n    this._fxaaEnabled = false;\n    this._imageProcessingEnabled = true;\n    this._bloomScale = 0.5;\n    this._chromaticAberrationEnabled = false;\n    this._grainEnabled = false;\n    this._buildAllowed = true;\n    /**\n     * This is triggered each time the pipeline has been built.\n     */\n    this.onBuildObservable = new Observable();\n    this._resizeObserver = null;\n    this._hardwareScaleLevel = 1.0;\n    this._bloomKernel = 64;\n    /**\n     * Specifies the weight of the bloom in the final rendering\n     */\n    this._bloomWeight = 0.15;\n    /**\n     * Specifies the luma threshold for the area that will be blurred by the bloom\n     */\n    this._bloomThreshold = 0.9;\n    this._samples = 1;\n    this._hasCleared = false;\n    this._prevPostProcess = null;\n    this._prevPrevPostProcess = null;\n    this._depthOfFieldSceneObserver = null;\n    this._activeCameraChangedObserver = null;\n    this._activeCamerasChangedObserver = null;\n    this._cameras = cameras || scene.cameras;\n    this._cameras = this._cameras.slice();\n    this._camerasToBeAttached = this._cameras.slice();\n    this._buildAllowed = automaticBuild;\n    // Initialize\n    this._scene = scene;\n    const caps = this._scene.getEngine().getCaps();\n    this._hdr = hdr && (caps.textureHalfFloatRender || caps.textureFloatRender);\n    // Misc\n    if (this._hdr) {\n      if (caps.textureHalfFloatRender) {\n        this._defaultPipelineTextureType = 2;\n      } else if (caps.textureFloatRender) {\n        this._defaultPipelineTextureType = 1;\n      }\n    } else {\n      this._defaultPipelineTextureType = 0;\n    }\n    // Attach\n    scene.postProcessRenderPipelineManager.addPipeline(this);\n    const engine = this._scene.getEngine();\n    // Create post processes before hand so they can be modified before enabled.\n    // Block compilation flag is set to true to avoid compilation prior to use, these will be updated on first use in build pipeline.\n    this.sharpen = new SharpenPostProcess(\"sharpen\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType, true);\n    this._sharpenEffect = new PostProcessRenderEffect(engine, this.SharpenPostProcessId, () => {\n      return this.sharpen;\n    }, true);\n    this.depthOfField = new DepthOfFieldEffect(this._scene, null, this._depthOfFieldBlurLevel, this._defaultPipelineTextureType, true);\n    // To keep the bloom sizes consistent across different display densities, factor in the hardware scaling level.\n    this._hardwareScaleLevel = engine.getHardwareScalingLevel();\n    this._resizeObserver = engine.onResizeObservable.add(() => {\n      this._hardwareScaleLevel = engine.getHardwareScalingLevel();\n      this.bloomKernel = this._bloomKernel;\n    });\n    this.bloom = new BloomEffect(this._scene, this._bloomScale, this._bloomWeight, this.bloomKernel / this._hardwareScaleLevel, this._defaultPipelineTextureType, true);\n    this.chromaticAberration = new ChromaticAberrationPostProcess(\"ChromaticAberration\", engine.getRenderWidth(), engine.getRenderHeight(), 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType, true);\n    this._chromaticAberrationEffect = new PostProcessRenderEffect(engine, this.ChromaticAberrationPostProcessId, () => {\n      return this.chromaticAberration;\n    }, true);\n    this.grain = new GrainPostProcess(\"Grain\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType, true);\n    this._grainEffect = new PostProcessRenderEffect(engine, this.GrainPostProcessId, () => {\n      return this.grain;\n    }, true);\n    let avoidReentrancyAtConstructionTime = true;\n    this._imageProcessingConfigurationObserver = this._scene.imageProcessingConfiguration.onUpdateParameters.add(() => {\n      this.bloom._downscale._exposure = this._scene.imageProcessingConfiguration.exposure;\n      if (this.imageProcessingEnabled !== this._scene.imageProcessingConfiguration.isEnabled) {\n        this._imageProcessingEnabled = this._scene.imageProcessingConfiguration.isEnabled;\n        // Avoid re-entrant problems by deferring the call to _buildPipeline because the call to _buildPipeline\n        // at the end of the constructor could end up triggering imageProcessingConfiguration.onUpdateParameters!\n        // Note that the pipeline could have been disposed before the deferred call was executed, but in that case\n        // _buildAllowed will have been set to false, preventing _buildPipeline from being executed.\n        if (avoidReentrancyAtConstructionTime) {\n          Tools.SetImmediate(() => {\n            this._buildPipeline();\n          });\n        } else {\n          this._buildPipeline();\n        }\n      }\n    });\n    this._buildPipeline();\n    avoidReentrancyAtConstructionTime = false;\n  }\n  /**\n   * Get the class name\n   * @returns \"DefaultRenderingPipeline\"\n   */\n  getClassName() {\n    return \"DefaultRenderingPipeline\";\n  }\n  /**\n   * Force the compilation of the entire pipeline.\n   */\n  prepare() {\n    const previousState = this._buildAllowed;\n    this._buildAllowed = true;\n    this._buildPipeline();\n    this._buildAllowed = previousState;\n  }\n  _setAutoClearAndTextureSharing(postProcess, skipTextureSharing = false) {\n    if (this._hasCleared) {\n      postProcess.autoClear = false;\n    } else {\n      postProcess.autoClear = true;\n      this._scene.autoClear = false;\n      this._hasCleared = true;\n    }\n    if (!skipTextureSharing) {\n      if (this._prevPrevPostProcess) {\n        postProcess.shareOutputWith(this._prevPrevPostProcess);\n      } else {\n        postProcess.useOwnOutput();\n      }\n      if (this._prevPostProcess) {\n        this._prevPrevPostProcess = this._prevPostProcess;\n      }\n      this._prevPostProcess = postProcess;\n    }\n  }\n  _buildPipeline() {\n    if (!this._buildAllowed) {\n      return;\n    }\n    this._scene.autoClear = true;\n    const engine = this._scene.getEngine();\n    this._disposePostProcesses();\n    if (this._cameras !== null) {\n      this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\n      // get back cameras to be used to reattach pipeline\n      this._cameras = this._camerasToBeAttached.slice();\n    }\n    this._reset();\n    this._prevPostProcess = null;\n    this._prevPrevPostProcess = null;\n    this._hasCleared = false;\n    if (this.depthOfFieldEnabled) {\n      // Multi camera suport\n      if (this._cameras.length > 1) {\n        for (const camera of this._cameras) {\n          const depthRenderer = this._scene.enableDepthRenderer(camera);\n          depthRenderer.useOnlyInActiveCamera = true;\n        }\n        this._depthOfFieldSceneObserver = this._scene.onAfterRenderTargetsRenderObservable.add(scene => {\n          if (this._cameras.indexOf(scene.activeCamera) > -1) {\n            this.depthOfField.depthTexture = scene.enableDepthRenderer(scene.activeCamera).getDepthMap();\n          }\n        });\n      } else {\n        this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);\n        const depthRenderer = this._scene.enableDepthRenderer(this._cameras[0]);\n        this.depthOfField.depthTexture = depthRenderer.getDepthMap();\n      }\n      if (!this.depthOfField._isReady()) {\n        this.depthOfField._updateEffects();\n      }\n      this.addEffect(this.depthOfField);\n      this._setAutoClearAndTextureSharing(this.depthOfField._effects[0], true);\n    } else {\n      this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);\n    }\n    if (this.bloomEnabled) {\n      if (!this.bloom._isReady()) {\n        this.bloom._updateEffects();\n      }\n      this.addEffect(this.bloom);\n      this._setAutoClearAndTextureSharing(this.bloom._effects[0], true);\n    }\n    if (this._imageProcessingEnabled) {\n      this.imageProcessing = new ImageProcessingPostProcess(\"imageProcessing\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType, this.scene.imageProcessingConfiguration);\n      if (this._hdr) {\n        this.addEffect(new PostProcessRenderEffect(engine, this.ImageProcessingPostProcessId, () => {\n          return this.imageProcessing;\n        }, true));\n        this._setAutoClearAndTextureSharing(this.imageProcessing);\n      } else {\n        this._scene.imageProcessingConfiguration.applyByPostProcess = false;\n      }\n      if (!this._cameras || this._cameras.length === 0) {\n        this._scene.imageProcessingConfiguration.applyByPostProcess = false;\n      }\n      if (!this.imageProcessing.getEffect()) {\n        this.imageProcessing._updateParameters();\n      }\n    }\n    if (this.sharpenEnabled) {\n      if (!this.sharpen.isReady()) {\n        this.sharpen.updateEffect();\n      }\n      this.addEffect(this._sharpenEffect);\n      this._setAutoClearAndTextureSharing(this.sharpen);\n    }\n    if (this.grainEnabled) {\n      if (!this.grain.isReady()) {\n        this.grain.updateEffect();\n      }\n      this.addEffect(this._grainEffect);\n      this._setAutoClearAndTextureSharing(this.grain);\n    }\n    if (this.chromaticAberrationEnabled) {\n      if (!this.chromaticAberration.isReady()) {\n        this.chromaticAberration.updateEffect();\n      }\n      this.addEffect(this._chromaticAberrationEffect);\n      this._setAutoClearAndTextureSharing(this.chromaticAberration);\n    }\n    if (this.fxaaEnabled) {\n      this.fxaa = new FxaaPostProcess(\"fxaa\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType);\n      this.addEffect(new PostProcessRenderEffect(engine, this.FxaaPostProcessId, () => {\n        return this.fxaa;\n      }, true));\n      this._setAutoClearAndTextureSharing(this.fxaa, true);\n    }\n    if (this._cameras !== null) {\n      this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);\n    }\n    // In multicamera mode, the scene needs to autoclear in between cameras.\n    if (this._scene.activeCameras && this._scene.activeCameras.length > 1 || this._scene.activeCamera && this._cameras.indexOf(this._scene.activeCamera) === -1) {\n      this._scene.autoClear = true;\n    }\n    // The active camera on the scene can be changed anytime\n    if (!this._activeCameraChangedObserver) {\n      this._activeCameraChangedObserver = this._scene.onActiveCameraChanged.add(() => {\n        if (this._scene.activeCamera && this._cameras.indexOf(this._scene.activeCamera) === -1) {\n          this._scene.autoClear = true;\n        }\n      });\n    }\n    if (!this._activeCamerasChangedObserver) {\n      this._activeCamerasChangedObserver = this._scene.onActiveCamerasChanged.add(() => {\n        if (this._scene.activeCameras && this._scene.activeCameras.length > 1) {\n          this._scene.autoClear = true;\n        }\n      });\n    }\n    if (!this._enableMSAAOnFirstPostProcess(this.samples) && this.samples > 1) {\n      Logger.Warn(\"MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0\");\n    }\n    this.onBuildObservable.notifyObservers(this);\n  }\n  _disposePostProcesses(disposeNonRecreated = false) {\n    for (let i = 0; i < this._cameras.length; i++) {\n      const camera = this._cameras[i];\n      if (this.imageProcessing) {\n        this.imageProcessing.dispose(camera);\n      }\n      if (this.fxaa) {\n        this.fxaa.dispose(camera);\n      }\n      // These are created in the constructor and should not be disposed on every pipeline change\n      if (disposeNonRecreated) {\n        if (this.sharpen) {\n          this.sharpen.dispose(camera);\n        }\n        if (this.depthOfField) {\n          this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);\n          this.depthOfField.disposeEffects(camera);\n        }\n        if (this.bloom) {\n          this.bloom.disposeEffects(camera);\n        }\n        if (this.chromaticAberration) {\n          this.chromaticAberration.dispose(camera);\n        }\n        if (this.grain) {\n          this.grain.dispose(camera);\n        }\n        if (this._glowLayer) {\n          this._glowLayer.dispose();\n        }\n      }\n    }\n    this.imageProcessing = null;\n    this.fxaa = null;\n    if (disposeNonRecreated) {\n      this.sharpen = null;\n      this._sharpenEffect = null;\n      this.depthOfField = null;\n      this.bloom = null;\n      this.chromaticAberration = null;\n      this._chromaticAberrationEffect = null;\n      this.grain = null;\n      this._grainEffect = null;\n      this._glowLayer = null;\n    }\n  }\n  /**\n   * Adds a camera to the pipeline\n   * @param camera the camera to be added\n   */\n  addCamera(camera) {\n    this._camerasToBeAttached.push(camera);\n    this._buildPipeline();\n  }\n  /**\n   * Removes a camera from the pipeline\n   * @param camera the camera to remove\n   */\n  removeCamera(camera) {\n    const index = this._camerasToBeAttached.indexOf(camera);\n    this._camerasToBeAttached.splice(index, 1);\n    this._buildPipeline();\n  }\n  /**\n   * Dispose of the pipeline and stop all post processes\n   */\n  dispose() {\n    this._buildAllowed = false;\n    this.onBuildObservable.clear();\n    this._disposePostProcesses(true);\n    this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\n    this._scene._postProcessRenderPipelineManager.removePipeline(this.name);\n    this._scene.autoClear = true;\n    if (this._resizeObserver) {\n      this._scene.getEngine().onResizeObservable.remove(this._resizeObserver);\n      this._resizeObserver = null;\n    }\n    this._scene.onActiveCameraChanged.remove(this._activeCameraChangedObserver);\n    this._scene.onActiveCamerasChanged.remove(this._activeCamerasChangedObserver);\n    this._scene.imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingConfigurationObserver);\n    super.dispose();\n  }\n  /**\n   * Serialize the rendering pipeline (Used when exporting)\n   * @returns the serialized object\n   */\n  serialize() {\n    const serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.customType = \"DefaultRenderingPipeline\";\n    return serializationObject;\n  }\n  /**\n   * Parse the serialized pipeline\n   * @param source Source pipeline.\n   * @param scene The scene to load the pipeline to.\n   * @param rootUrl The URL of the serialized pipeline.\n   * @returns An instantiated pipeline from the serialized object.\n   */\n  static Parse(source, scene, rootUrl) {\n    return SerializationHelper.Parse(() => new DefaultRenderingPipeline(source._name, source._name._hdr, scene), source, scene, rootUrl);\n  }\n}\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"sharpenEnabled\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"bloomKernel\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"_bloomWeight\", void 0);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"_bloomThreshold\", void 0);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"_hdr\", void 0);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"bloomWeight\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"bloomThreshold\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"bloomScale\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"bloomEnabled\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"depthOfFieldEnabled\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"depthOfFieldBlurLevel\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"fxaaEnabled\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"samples\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"imageProcessingEnabled\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"glowLayerEnabled\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"chromaticAberrationEnabled\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"grainEnabled\", null);\nRegisterClass(\"BABYLON.DefaultRenderingPipeline\", DefaultRenderingPipeline);","map":{"version":3,"names":["serialize","SerializationHelper","Observable","Logger","Texture","GlowLayer","SharpenPostProcess","ImageProcessingPostProcess","ChromaticAberrationPostProcess","GrainPostProcess","FxaaPostProcess","PostProcessRenderPipeline","PostProcessRenderEffect","DepthOfFieldEffect","DepthOfFieldEffectBlurLevel","BloomEffect","RegisterClass","EngineStore","Tools","DefaultRenderingPipeline","automaticBuild","_buildAllowed","value","scene","_scene","sharpenEnabled","enabled","_sharpenEnabled","_buildPipeline","bloomKernel","_bloomKernel","bloom","kernel","_hardwareScaleLevel","bloomWeight","_bloomWeight","weight","bloomThreshold","_bloomThreshold","threshold","bloomScale","_bloomScale","_rebuildBloom","bloomEnabled","_bloomEnabled","oldBloom","_defaultPipelineTextureType","i","_cameras","length","disposeEffects","depthOfFieldEnabled","_depthOfFieldEnabled","depthOfFieldBlurLevel","_depthOfFieldBlurLevel","oldDof","depthOfField","focalLength","focusDistance","fStop","lensSize","fxaaEnabled","_fxaaEnabled","samples","sampleCount","_samples","imageProcessingEnabled","_imageProcessingEnabled","imageProcessingConfiguration","isEnabled","glowLayerEnabled","_glowLayer","dispose","glowLayer","chromaticAberrationEnabled","_chromaticAberrationEnabled","grainEnabled","_grainEnabled","constructor","name","hdr","LastCreatedScene","cameras","getEngine","_camerasToBeAttached","SharpenPostProcessId","ImageProcessingPostProcessId","FxaaPostProcessId","ChromaticAberrationPostProcessId","GrainPostProcessId","animations","_imageProcessingConfigurationObserver","Low","onBuildObservable","_resizeObserver","_hasCleared","_prevPostProcess","_prevPrevPostProcess","_depthOfFieldSceneObserver","_activeCameraChangedObserver","_activeCamerasChangedObserver","slice","caps","getCaps","_hdr","textureHalfFloatRender","textureFloatRender","postProcessRenderPipelineManager","addPipeline","engine","sharpen","BILINEAR_SAMPLINGMODE","_sharpenEffect","getHardwareScalingLevel","onResizeObservable","add","chromaticAberration","getRenderWidth","getRenderHeight","_chromaticAberrationEffect","grain","_grainEffect","avoidReentrancyAtConstructionTime","onUpdateParameters","_downscale","_exposure","exposure","SetImmediate","getClassName","prepare","previousState","_setAutoClearAndTextureSharing","postProcess","skipTextureSharing","autoClear","shareOutputWith","useOwnOutput","_disposePostProcesses","detachCamerasFromRenderPipeline","_name","_reset","camera","depthRenderer","enableDepthRenderer","useOnlyInActiveCamera","onAfterRenderTargetsRenderObservable","indexOf","activeCamera","depthTexture","getDepthMap","remove","_isReady","_updateEffects","addEffect","_effects","imageProcessing","applyByPostProcess","getEffect","_updateParameters","isReady","updateEffect","fxaa","attachCamerasToRenderPipeline","activeCameras","onActiveCameraChanged","onActiveCamerasChanged","_enableMSAAOnFirstPostProcess","Warn","notifyObservers","disposeNonRecreated","addCamera","push","removeCamera","index","splice","clear","_postProcessRenderPipelineManager","removePipeline","serializationObject","Serialize","customType","Parse","source","rootUrl","__decorate"],"sources":["../../../../../../dev/core/src/PostProcesses/RenderPipeline/Pipelines/defaultRenderingPipeline.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../../types\";\r\nimport { serialize, SerializationHelper } from \"../../../Misc/decorators\";\r\nimport type { Observer } from \"../../../Misc/observable\";\r\nimport { Observable } from \"../../../Misc/observable\";\r\nimport type { IAnimatable } from \"../../../Animations/animatable.interface\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport type { Camera } from \"../../../Cameras/camera\";\r\nimport type { ImageProcessingConfiguration } from \"../../../Materials/imageProcessingConfiguration\";\r\nimport { Texture } from \"../../../Materials/Textures/texture\";\r\nimport type { Engine } from \"../../../Engines/engine\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport type { IDisposable, Scene } from \"../../../scene\";\r\nimport { GlowLayer } from \"../../../Layers/glowLayer\";\r\n\r\nimport type { PostProcess } from \"../../../PostProcesses/postProcess\";\r\nimport { SharpenPostProcess } from \"../../../PostProcesses/sharpenPostProcess\";\r\nimport { ImageProcessingPostProcess } from \"../../../PostProcesses/imageProcessingPostProcess\";\r\nimport { ChromaticAberrationPostProcess } from \"../../../PostProcesses/chromaticAberrationPostProcess\";\r\nimport { GrainPostProcess } from \"../../../PostProcesses/grainPostProcess\";\r\nimport { FxaaPostProcess } from \"../../../PostProcesses/fxaaPostProcess\";\r\nimport { PostProcessRenderPipeline } from \"../../../PostProcesses/RenderPipeline/postProcessRenderPipeline\";\r\nimport { PostProcessRenderEffect } from \"../../../PostProcesses/RenderPipeline/postProcessRenderEffect\";\r\nimport { DepthOfFieldEffect, DepthOfFieldEffectBlurLevel } from \"../../../PostProcesses/depthOfFieldEffect\";\r\nimport { BloomEffect } from \"../../../PostProcesses/bloomEffect\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { EngineStore } from \"../../../Engines/engineStore\";\r\nimport { Tools } from \"core/Misc/tools\";\r\n\r\nimport \"../../../PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent\";\r\n\r\nimport type { Animation } from \"../../../Animations/animation\";\r\n\r\n/**\r\n * The default rendering pipeline can be added to a scene to apply common post processing effects such as anti-aliasing or depth of field.\r\n * See https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/defaultRenderingPipeline\r\n */\r\nexport class DefaultRenderingPipeline extends PostProcessRenderPipeline implements IDisposable, IAnimatable {\r\n    private _scene: Scene;\r\n    private _camerasToBeAttached: Array<Camera> = [];\r\n    /**\r\n     * ID of the sharpen post process,\r\n     */\r\n    private readonly SharpenPostProcessId = \"SharpenPostProcessEffect\";\r\n    /**\r\n     * @ignore\r\n     * ID of the image processing post process;\r\n     */\r\n    readonly ImageProcessingPostProcessId = \"ImageProcessingPostProcessEffect\";\r\n    /**\r\n     * @ignore\r\n     * ID of the Fast Approximate Anti-Aliasing post process;\r\n     */\r\n    readonly FxaaPostProcessId = \"FxaaPostProcessEffect\";\r\n    /**\r\n     * ID of the chromatic aberration post process,\r\n     */\r\n    private readonly ChromaticAberrationPostProcessId = \"ChromaticAberrationPostProcessEffect\";\r\n    /**\r\n     * ID of the grain post process\r\n     */\r\n    private readonly GrainPostProcessId = \"GrainPostProcessEffect\";\r\n\r\n    // Post-processes\r\n    /**\r\n     * Sharpen post process which will apply a sharpen convolution to enhance edges\r\n     */\r\n    public sharpen: SharpenPostProcess;\r\n    private _sharpenEffect: PostProcessRenderEffect;\r\n    private bloom: BloomEffect;\r\n    /**\r\n     * Depth of field effect, applies a blur based on how far away objects are from the focus distance.\r\n     */\r\n    public depthOfField: DepthOfFieldEffect;\r\n    /**\r\n     * The Fast Approximate Anti-Aliasing post process which attempts to remove aliasing from an image.\r\n     */\r\n    public fxaa: FxaaPostProcess;\r\n    /**\r\n     * Image post processing pass used to perform operations such as tone mapping or color grading.\r\n     */\r\n    public imageProcessing: ImageProcessingPostProcess;\r\n    /**\r\n     * Chromatic aberration post process which will shift rgb colors in the image\r\n     */\r\n    public chromaticAberration: ChromaticAberrationPostProcess;\r\n    private _chromaticAberrationEffect: PostProcessRenderEffect;\r\n    /**\r\n     * Grain post process which add noise to the image\r\n     */\r\n    public grain: GrainPostProcess;\r\n    private _grainEffect: PostProcessRenderEffect;\r\n    /**\r\n     * Glow post process which adds a glow to emissive areas of the image\r\n     */\r\n    private _glowLayer: Nullable<GlowLayer> = null;\r\n\r\n    /**\r\n     * Animations which can be used to tweak settings over a period of time\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    private _imageProcessingConfigurationObserver: Nullable<Observer<ImageProcessingConfiguration>> = null;\r\n    // Values\r\n    private _sharpenEnabled: boolean = false;\r\n    private _bloomEnabled: boolean = false;\r\n    private _depthOfFieldEnabled: boolean = false;\r\n    private _depthOfFieldBlurLevel = DepthOfFieldEffectBlurLevel.Low;\r\n    private _fxaaEnabled: boolean = false;\r\n    private _imageProcessingEnabled: boolean = true;\r\n    private _defaultPipelineTextureType: number;\r\n    private _bloomScale: number = 0.5;\r\n    private _chromaticAberrationEnabled: boolean = false;\r\n    private _grainEnabled: boolean = false;\r\n\r\n    private _buildAllowed = true;\r\n\r\n    /**\r\n     * Enable or disable automatic building of the pipeline when effects are enabled and disabled.\r\n     * If false, you will have to manually call prepare() to update the pipeline.\r\n     */\r\n    public get automaticBuild() {\r\n        return this._buildAllowed;\r\n    }\r\n    public set automaticBuild(value: boolean) {\r\n        this._buildAllowed = value;\r\n    }\r\n\r\n    /**\r\n     * This is triggered each time the pipeline has been built.\r\n     */\r\n    public onBuildObservable = new Observable<DefaultRenderingPipeline>();\r\n\r\n    /**\r\n     * Gets active scene\r\n     */\r\n    public get scene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable the sharpen process from the pipeline\r\n     */\r\n    public set sharpenEnabled(enabled: boolean) {\r\n        if (this._sharpenEnabled === enabled) {\r\n            return;\r\n        }\r\n        this._sharpenEnabled = enabled;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get sharpenEnabled(): boolean {\r\n        return this._sharpenEnabled;\r\n    }\r\n\r\n    private _resizeObserver: Nullable<Observer<Engine>> = null;\r\n    private _hardwareScaleLevel = 1.0;\r\n    private _bloomKernel: number = 64;\r\n    /**\r\n     * Specifies the size of the bloom blur kernel, relative to the final output size\r\n     */\r\n    @serialize()\r\n    public get bloomKernel(): number {\r\n        return this._bloomKernel;\r\n    }\r\n    public set bloomKernel(value: number) {\r\n        this._bloomKernel = value;\r\n        this.bloom.kernel = value / this._hardwareScaleLevel;\r\n    }\r\n\r\n    /**\r\n     * Specifies the weight of the bloom in the final rendering\r\n     */\r\n    @serialize()\r\n    private _bloomWeight: number = 0.15;\r\n    /**\r\n     * Specifies the luma threshold for the area that will be blurred by the bloom\r\n     */\r\n    @serialize()\r\n    private _bloomThreshold: number = 0.9;\r\n\r\n    @serialize()\r\n    private _hdr: boolean;\r\n\r\n    /**\r\n     * The strength of the bloom.\r\n     */\r\n    public set bloomWeight(value: number) {\r\n        if (this._bloomWeight === value) {\r\n            return;\r\n        }\r\n        this.bloom.weight = value;\r\n\r\n        this._bloomWeight = value;\r\n    }\r\n\r\n    @serialize()\r\n    public get bloomWeight(): number {\r\n        return this._bloomWeight;\r\n    }\r\n\r\n    /**\r\n     * The luminance threshold to find bright areas of the image to bloom.\r\n     */\r\n    public set bloomThreshold(value: number) {\r\n        if (this._bloomThreshold === value) {\r\n            return;\r\n        }\r\n        this.bloom.threshold = value;\r\n        this._bloomThreshold = value;\r\n    }\r\n\r\n    @serialize()\r\n    public get bloomThreshold(): number {\r\n        return this._bloomThreshold;\r\n    }\r\n\r\n    /**\r\n     * The scale of the bloom, lower value will provide better performance.\r\n     */\r\n    public set bloomScale(value: number) {\r\n        if (this._bloomScale === value) {\r\n            return;\r\n        }\r\n        this._bloomScale = value;\r\n\r\n        // recreate bloom and dispose old as this setting is not dynamic\r\n        this._rebuildBloom();\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get bloomScale(): number {\r\n        return this._bloomScale;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable the bloom from the pipeline\r\n     */\r\n    public set bloomEnabled(enabled: boolean) {\r\n        if (this._bloomEnabled === enabled) {\r\n            return;\r\n        }\r\n        this._bloomEnabled = enabled;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get bloomEnabled(): boolean {\r\n        return this._bloomEnabled;\r\n    }\r\n\r\n    private _rebuildBloom() {\r\n        // recreate bloom and dispose old as this setting is not dynamic\r\n        const oldBloom = this.bloom;\r\n        this.bloom = new BloomEffect(this._scene, this.bloomScale, this._bloomWeight, this.bloomKernel / this._hardwareScaleLevel, this._defaultPipelineTextureType, false);\r\n        this.bloom.threshold = oldBloom.threshold;\r\n        for (let i = 0; i < this._cameras.length; i++) {\r\n            oldBloom.disposeEffects(this._cameras[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If the depth of field is enabled.\r\n     */\r\n    @serialize()\r\n    public get depthOfFieldEnabled(): boolean {\r\n        return this._depthOfFieldEnabled;\r\n    }\r\n\r\n    public set depthOfFieldEnabled(enabled: boolean) {\r\n        if (this._depthOfFieldEnabled === enabled) {\r\n            return;\r\n        }\r\n        this._depthOfFieldEnabled = enabled;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Blur level of the depth of field effect. (Higher blur will effect performance)\r\n     */\r\n    @serialize()\r\n    public get depthOfFieldBlurLevel(): DepthOfFieldEffectBlurLevel {\r\n        return this._depthOfFieldBlurLevel;\r\n    }\r\n\r\n    public set depthOfFieldBlurLevel(value: DepthOfFieldEffectBlurLevel) {\r\n        if (this._depthOfFieldBlurLevel === value) {\r\n            return;\r\n        }\r\n        this._depthOfFieldBlurLevel = value;\r\n\r\n        // recreate dof and dispose old as this setting is not dynamic\r\n        const oldDof = this.depthOfField;\r\n\r\n        this.depthOfField = new DepthOfFieldEffect(this._scene, null, this._depthOfFieldBlurLevel, this._defaultPipelineTextureType, false);\r\n        this.depthOfField.focalLength = oldDof.focalLength;\r\n        this.depthOfField.focusDistance = oldDof.focusDistance;\r\n        this.depthOfField.fStop = oldDof.fStop;\r\n        this.depthOfField.lensSize = oldDof.lensSize;\r\n\r\n        for (let i = 0; i < this._cameras.length; i++) {\r\n            oldDof.disposeEffects(this._cameras[i]);\r\n        }\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * If the anti aliasing is enabled.\r\n     */\r\n    public set fxaaEnabled(enabled: boolean) {\r\n        if (this._fxaaEnabled === enabled) {\r\n            return;\r\n        }\r\n        this._fxaaEnabled = enabled;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get fxaaEnabled(): boolean {\r\n        return this._fxaaEnabled;\r\n    }\r\n\r\n    private _samples = 1;\r\n    /**\r\n     * MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)\r\n     */\r\n    public set samples(sampleCount: number) {\r\n        if (this._samples === sampleCount) {\r\n            return;\r\n        }\r\n        this._samples = sampleCount;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    /**\r\n     * If image processing is enabled.\r\n     */\r\n    public set imageProcessingEnabled(enabled: boolean) {\r\n        if (this._imageProcessingEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._scene.imageProcessingConfiguration.isEnabled = enabled;\r\n    }\r\n\r\n    @serialize()\r\n    public get imageProcessingEnabled(): boolean {\r\n        return this._imageProcessingEnabled;\r\n    }\r\n\r\n    /**\r\n     * If glow layer is enabled. (Adds a glow effect to emmissive materials)\r\n     */\r\n    public set glowLayerEnabled(enabled: boolean) {\r\n        if (enabled && !this._glowLayer) {\r\n            this._glowLayer = new GlowLayer(\"\", this._scene);\r\n        } else if (!enabled && this._glowLayer) {\r\n            this._glowLayer.dispose();\r\n            this._glowLayer = null;\r\n        }\r\n    }\r\n\r\n    @serialize()\r\n    public get glowLayerEnabled(): boolean {\r\n        return this._glowLayer != null;\r\n    }\r\n\r\n    /**\r\n     * Gets the glow layer (or null if not defined)\r\n     */\r\n    public get glowLayer() {\r\n        return this._glowLayer;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable the chromaticAberration process from the pipeline\r\n     */\r\n    public set chromaticAberrationEnabled(enabled: boolean) {\r\n        if (this._chromaticAberrationEnabled === enabled) {\r\n            return;\r\n        }\r\n        this._chromaticAberrationEnabled = enabled;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get chromaticAberrationEnabled(): boolean {\r\n        return this._chromaticAberrationEnabled;\r\n    }\r\n    /**\r\n     * Enable or disable the grain process from the pipeline\r\n     */\r\n    public set grainEnabled(enabled: boolean) {\r\n        if (this._grainEnabled === enabled) {\r\n            return;\r\n        }\r\n        this._grainEnabled = enabled;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get grainEnabled(): boolean {\r\n        return this._grainEnabled;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a DefaultRenderingPipeline.\r\n     * @param name The rendering pipeline name (default: \"\")\r\n     * @param hdr If high dynamic range textures should be used (default: true)\r\n     * @param scene The scene linked to this pipeline (default: the last created scene)\r\n     * @param cameras The array of cameras that the rendering pipeline will be attached to (default: scene.cameras)\r\n     * @param automaticBuild If false, you will have to manually call prepare() to update the pipeline (default: true)\r\n     */\r\n    constructor(name = \"\", hdr = true, scene: Scene = EngineStore.LastCreatedScene!, cameras?: Camera[], automaticBuild = true) {\r\n        super(scene.getEngine(), name);\r\n        this._cameras = cameras || scene.cameras;\r\n        this._cameras = this._cameras.slice();\r\n        this._camerasToBeAttached = this._cameras.slice();\r\n\r\n        this._buildAllowed = automaticBuild;\r\n\r\n        // Initialize\r\n        this._scene = scene;\r\n        const caps = this._scene.getEngine().getCaps();\r\n        this._hdr = hdr && (caps.textureHalfFloatRender || caps.textureFloatRender);\r\n\r\n        // Misc\r\n        if (this._hdr) {\r\n            if (caps.textureHalfFloatRender) {\r\n                this._defaultPipelineTextureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n            } else if (caps.textureFloatRender) {\r\n                this._defaultPipelineTextureType = Constants.TEXTURETYPE_FLOAT;\r\n            }\r\n        } else {\r\n            this._defaultPipelineTextureType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        }\r\n\r\n        // Attach\r\n        scene.postProcessRenderPipelineManager.addPipeline(this);\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        // Create post processes before hand so they can be modified before enabled.\r\n        // Block compilation flag is set to true to avoid compilation prior to use, these will be updated on first use in build pipeline.\r\n        this.sharpen = new SharpenPostProcess(\"sharpen\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType, true);\r\n        this._sharpenEffect = new PostProcessRenderEffect(\r\n            engine,\r\n            this.SharpenPostProcessId,\r\n            () => {\r\n                return this.sharpen;\r\n            },\r\n            true\r\n        );\r\n\r\n        this.depthOfField = new DepthOfFieldEffect(this._scene, null, this._depthOfFieldBlurLevel, this._defaultPipelineTextureType, true);\r\n\r\n        // To keep the bloom sizes consistent across different display densities, factor in the hardware scaling level.\r\n        this._hardwareScaleLevel = engine.getHardwareScalingLevel();\r\n        this._resizeObserver = engine.onResizeObservable.add(() => {\r\n            this._hardwareScaleLevel = engine.getHardwareScalingLevel();\r\n            this.bloomKernel = this._bloomKernel;\r\n        });\r\n\r\n        this.bloom = new BloomEffect(this._scene, this._bloomScale, this._bloomWeight, this.bloomKernel / this._hardwareScaleLevel, this._defaultPipelineTextureType, true);\r\n\r\n        this.chromaticAberration = new ChromaticAberrationPostProcess(\r\n            \"ChromaticAberration\",\r\n            engine.getRenderWidth(),\r\n            engine.getRenderHeight(),\r\n            1.0,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            engine,\r\n            false,\r\n            this._defaultPipelineTextureType,\r\n            true\r\n        );\r\n        this._chromaticAberrationEffect = new PostProcessRenderEffect(\r\n            engine,\r\n            this.ChromaticAberrationPostProcessId,\r\n            () => {\r\n                return this.chromaticAberration;\r\n            },\r\n            true\r\n        );\r\n\r\n        this.grain = new GrainPostProcess(\"Grain\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType, true);\r\n        this._grainEffect = new PostProcessRenderEffect(\r\n            engine,\r\n            this.GrainPostProcessId,\r\n            () => {\r\n                return this.grain;\r\n            },\r\n            true\r\n        );\r\n\r\n        let avoidReentrancyAtConstructionTime = true;\r\n\r\n        this._imageProcessingConfigurationObserver = this._scene.imageProcessingConfiguration.onUpdateParameters.add(() => {\r\n            this.bloom._downscale._exposure = this._scene.imageProcessingConfiguration.exposure;\r\n\r\n            if (this.imageProcessingEnabled !== this._scene.imageProcessingConfiguration.isEnabled) {\r\n                this._imageProcessingEnabled = this._scene.imageProcessingConfiguration.isEnabled;\r\n                // Avoid re-entrant problems by deferring the call to _buildPipeline because the call to _buildPipeline\r\n                // at the end of the constructor could end up triggering imageProcessingConfiguration.onUpdateParameters!\r\n                // Note that the pipeline could have been disposed before the deferred call was executed, but in that case\r\n                // _buildAllowed will have been set to false, preventing _buildPipeline from being executed.\r\n                if (avoidReentrancyAtConstructionTime) {\r\n                    Tools.SetImmediate(() => {\r\n                        this._buildPipeline();\r\n                    });\r\n                } else {\r\n                    this._buildPipeline();\r\n                }\r\n            }\r\n        });\r\n\r\n        this._buildPipeline();\r\n\r\n        avoidReentrancyAtConstructionTime = false;\r\n    }\r\n\r\n    /**\r\n     * Get the class name\r\n     * @returns \"DefaultRenderingPipeline\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"DefaultRenderingPipeline\";\r\n    }\r\n\r\n    /**\r\n     * Force the compilation of the entire pipeline.\r\n     */\r\n    public prepare(): void {\r\n        const previousState = this._buildAllowed;\r\n        this._buildAllowed = true;\r\n        this._buildPipeline();\r\n        this._buildAllowed = previousState;\r\n    }\r\n\r\n    private _hasCleared = false;\r\n    private _prevPostProcess: Nullable<PostProcess> = null;\r\n    private _prevPrevPostProcess: Nullable<PostProcess> = null;\r\n\r\n    private _setAutoClearAndTextureSharing(postProcess: PostProcess, skipTextureSharing = false) {\r\n        if (this._hasCleared) {\r\n            postProcess.autoClear = false;\r\n        } else {\r\n            postProcess.autoClear = true;\r\n            this._scene.autoClear = false;\r\n            this._hasCleared = true;\r\n        }\r\n\r\n        if (!skipTextureSharing) {\r\n            if (this._prevPrevPostProcess) {\r\n                postProcess.shareOutputWith(this._prevPrevPostProcess);\r\n            } else {\r\n                postProcess.useOwnOutput();\r\n            }\r\n\r\n            if (this._prevPostProcess) {\r\n                this._prevPrevPostProcess = this._prevPostProcess;\r\n            }\r\n            this._prevPostProcess = postProcess;\r\n        }\r\n    }\r\n\r\n    private _depthOfFieldSceneObserver: Nullable<Observer<Scene>> = null;\r\n    private _activeCameraChangedObserver: Nullable<Observer<Scene>> = null;\r\n    private _activeCamerasChangedObserver: Nullable<Observer<Scene>> = null;\r\n\r\n    private _buildPipeline() {\r\n        if (!this._buildAllowed) {\r\n            return;\r\n        }\r\n        this._scene.autoClear = true;\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        this._disposePostProcesses();\r\n        if (this._cameras !== null) {\r\n            this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\r\n            // get back cameras to be used to reattach pipeline\r\n            this._cameras = this._camerasToBeAttached.slice();\r\n        }\r\n        this._reset();\r\n        this._prevPostProcess = null;\r\n        this._prevPrevPostProcess = null;\r\n        this._hasCleared = false;\r\n\r\n        if (this.depthOfFieldEnabled) {\r\n            // Multi camera suport\r\n            if (this._cameras.length > 1) {\r\n                for (const camera of this._cameras) {\r\n                    const depthRenderer = this._scene.enableDepthRenderer(camera);\r\n                    depthRenderer.useOnlyInActiveCamera = true;\r\n                }\r\n\r\n                this._depthOfFieldSceneObserver = this._scene.onAfterRenderTargetsRenderObservable.add((scene) => {\r\n                    if (this._cameras.indexOf(scene.activeCamera!) > -1) {\r\n                        this.depthOfField.depthTexture = scene.enableDepthRenderer(scene.activeCamera).getDepthMap();\r\n                    }\r\n                });\r\n            } else {\r\n                this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);\r\n                const depthRenderer = this._scene.enableDepthRenderer(this._cameras[0]);\r\n                this.depthOfField.depthTexture = depthRenderer.getDepthMap();\r\n            }\r\n\r\n            if (!this.depthOfField._isReady()) {\r\n                this.depthOfField._updateEffects();\r\n            }\r\n            this.addEffect(this.depthOfField);\r\n            this._setAutoClearAndTextureSharing(this.depthOfField._effects[0], true);\r\n        } else {\r\n            this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);\r\n        }\r\n\r\n        if (this.bloomEnabled) {\r\n            if (!this.bloom._isReady()) {\r\n                this.bloom._updateEffects();\r\n            }\r\n            this.addEffect(this.bloom);\r\n            this._setAutoClearAndTextureSharing(this.bloom._effects[0], true);\r\n        }\r\n\r\n        if (this._imageProcessingEnabled) {\r\n            this.imageProcessing = new ImageProcessingPostProcess(\r\n                \"imageProcessing\",\r\n                1.0,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                engine,\r\n                false,\r\n                this._defaultPipelineTextureType,\r\n                this.scene.imageProcessingConfiguration\r\n            );\r\n            if (this._hdr) {\r\n                this.addEffect(\r\n                    new PostProcessRenderEffect(\r\n                        engine,\r\n                        this.ImageProcessingPostProcessId,\r\n                        () => {\r\n                            return this.imageProcessing;\r\n                        },\r\n                        true\r\n                    )\r\n                );\r\n                this._setAutoClearAndTextureSharing(this.imageProcessing);\r\n            } else {\r\n                this._scene.imageProcessingConfiguration.applyByPostProcess = false;\r\n            }\r\n\r\n            if (!this._cameras || this._cameras.length === 0) {\r\n                this._scene.imageProcessingConfiguration.applyByPostProcess = false;\r\n            }\r\n\r\n            if (!this.imageProcessing.getEffect()) {\r\n                this.imageProcessing._updateParameters();\r\n            }\r\n        }\r\n\r\n        if (this.sharpenEnabled) {\r\n            if (!this.sharpen.isReady()) {\r\n                this.sharpen.updateEffect();\r\n            }\r\n            this.addEffect(this._sharpenEffect);\r\n            this._setAutoClearAndTextureSharing(this.sharpen);\r\n        }\r\n\r\n        if (this.grainEnabled) {\r\n            if (!this.grain.isReady()) {\r\n                this.grain.updateEffect();\r\n            }\r\n            this.addEffect(this._grainEffect);\r\n            this._setAutoClearAndTextureSharing(this.grain);\r\n        }\r\n\r\n        if (this.chromaticAberrationEnabled) {\r\n            if (!this.chromaticAberration.isReady()) {\r\n                this.chromaticAberration.updateEffect();\r\n            }\r\n            this.addEffect(this._chromaticAberrationEffect);\r\n            this._setAutoClearAndTextureSharing(this.chromaticAberration);\r\n        }\r\n\r\n        if (this.fxaaEnabled) {\r\n            this.fxaa = new FxaaPostProcess(\"fxaa\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType);\r\n            this.addEffect(\r\n                new PostProcessRenderEffect(\r\n                    engine,\r\n                    this.FxaaPostProcessId,\r\n                    () => {\r\n                        return this.fxaa;\r\n                    },\r\n                    true\r\n                )\r\n            );\r\n            this._setAutoClearAndTextureSharing(this.fxaa, true);\r\n        }\r\n\r\n        if (this._cameras !== null) {\r\n            this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);\r\n        }\r\n\r\n        // In multicamera mode, the scene needs to autoclear in between cameras.\r\n        if ((this._scene.activeCameras && this._scene.activeCameras.length > 1) || (this._scene.activeCamera && this._cameras.indexOf(this._scene.activeCamera) === -1)) {\r\n            this._scene.autoClear = true;\r\n        }\r\n        // The active camera on the scene can be changed anytime\r\n        if (!this._activeCameraChangedObserver) {\r\n            this._activeCameraChangedObserver = this._scene.onActiveCameraChanged.add(() => {\r\n                if (this._scene.activeCamera && this._cameras.indexOf(this._scene.activeCamera) === -1) {\r\n                    this._scene.autoClear = true;\r\n                }\r\n            });\r\n        }\r\n        if (!this._activeCamerasChangedObserver) {\r\n            this._activeCamerasChangedObserver = this._scene.onActiveCamerasChanged.add(() => {\r\n                if (this._scene.activeCameras && this._scene.activeCameras.length > 1) {\r\n                    this._scene.autoClear = true;\r\n                }\r\n            });\r\n        }\r\n\r\n        if (!this._enableMSAAOnFirstPostProcess(this.samples) && this.samples > 1) {\r\n            Logger.Warn(\"MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0\");\r\n        }\r\n\r\n        this.onBuildObservable.notifyObservers(this);\r\n    }\r\n\r\n    private _disposePostProcesses(disposeNonRecreated = false): void {\r\n        for (let i = 0; i < this._cameras.length; i++) {\r\n            const camera = this._cameras[i];\r\n\r\n            if (this.imageProcessing) {\r\n                this.imageProcessing.dispose(camera);\r\n            }\r\n\r\n            if (this.fxaa) {\r\n                this.fxaa.dispose(camera);\r\n            }\r\n\r\n            // These are created in the constructor and should not be disposed on every pipeline change\r\n            if (disposeNonRecreated) {\r\n                if (this.sharpen) {\r\n                    this.sharpen.dispose(camera);\r\n                }\r\n\r\n                if (this.depthOfField) {\r\n                    this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);\r\n                    this.depthOfField.disposeEffects(camera);\r\n                }\r\n\r\n                if (this.bloom) {\r\n                    this.bloom.disposeEffects(camera);\r\n                }\r\n\r\n                if (this.chromaticAberration) {\r\n                    this.chromaticAberration.dispose(camera);\r\n                }\r\n\r\n                if (this.grain) {\r\n                    this.grain.dispose(camera);\r\n                }\r\n                if (this._glowLayer) {\r\n                    this._glowLayer.dispose();\r\n                }\r\n            }\r\n        }\r\n\r\n        (<any>this.imageProcessing) = null;\r\n        (<any>this.fxaa) = null;\r\n\r\n        if (disposeNonRecreated) {\r\n            (<any>this.sharpen) = null;\r\n            (<any>this._sharpenEffect) = null;\r\n            (<any>this.depthOfField) = null;\r\n            (<any>this.bloom) = null;\r\n            (<any>this.chromaticAberration) = null;\r\n            (<any>this._chromaticAberrationEffect) = null;\r\n            (<any>this.grain) = null;\r\n            (<any>this._grainEffect) = null;\r\n            this._glowLayer = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a camera to the pipeline\r\n     * @param camera the camera to be added\r\n     */\r\n    public addCamera(camera: Camera): void {\r\n        this._camerasToBeAttached.push(camera);\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Removes a camera from the pipeline\r\n     * @param camera the camera to remove\r\n     */\r\n    public removeCamera(camera: Camera): void {\r\n        const index = this._camerasToBeAttached.indexOf(camera);\r\n        this._camerasToBeAttached.splice(index, 1);\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Dispose of the pipeline and stop all post processes\r\n     */\r\n    public dispose(): void {\r\n        this._buildAllowed = false;\r\n        this.onBuildObservable.clear();\r\n        this._disposePostProcesses(true);\r\n        this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\r\n        this._scene._postProcessRenderPipelineManager.removePipeline(this.name);\r\n        this._scene.autoClear = true;\r\n        if (this._resizeObserver) {\r\n            this._scene.getEngine().onResizeObservable.remove(this._resizeObserver);\r\n            this._resizeObserver = null;\r\n        }\r\n\r\n        this._scene.onActiveCameraChanged.remove(this._activeCameraChangedObserver);\r\n        this._scene.onActiveCamerasChanged.remove(this._activeCamerasChangedObserver);\r\n\r\n        this._scene.imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingConfigurationObserver);\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Serialize the rendering pipeline (Used when exporting)\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"DefaultRenderingPipeline\";\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse the serialized pipeline\r\n     * @param source Source pipeline.\r\n     * @param scene The scene to load the pipeline to.\r\n     * @param rootUrl The URL of the serialized pipeline.\r\n     * @returns An instantiated pipeline from the serialized object.\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): DefaultRenderingPipeline {\r\n        return SerializationHelper.Parse(() => new DefaultRenderingPipeline(source._name, source._name._hdr, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.DefaultRenderingPipeline\", DefaultRenderingPipeline);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}