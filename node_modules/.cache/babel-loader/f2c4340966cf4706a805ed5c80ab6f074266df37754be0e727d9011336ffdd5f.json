{"ast":null,"code":"import { Vector3, TmpVectors, Quaternion, Vector4, Vector2 } from \"../Maths/math.vector.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { BoundingInfo } from \"../Culling/boundingInfo.js\";\nimport { BoundingSphere } from \"../Culling/boundingSphere.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\n/**\n * Represents one particle of a solid particle system.\n */\nexport class SolidParticle {\n  /**\n   * Particle BoundingInfo object\n   * @returns a BoundingInfo\n   */\n  getBoundingInfo() {\n    return this._boundingInfo;\n  }\n  /**\n   * Returns true if there is already a bounding info\n   */\n  get hasBoundingInfo() {\n    return this._boundingInfo !== null;\n  }\n  /**\n   * Creates a Solid Particle object.\n   * Don't create particles manually, use instead the Solid Particle System internal tools like _addParticle()\n   * @param particleIndex (integer) is the particle index in the Solid Particle System pool.\n   * @param particleId (integer) is the particle identifier. Unless some particles are removed from the SPS, it's the same value than the particle idx.\n   * @param positionIndex (integer) is the starting index of the particle vertices in the SPS \"positions\" array.\n   * @param indiceIndex (integer) is the starting index of the particle indices in the SPS \"indices\" array.\n   * @param model (ModelShape) is a reference to the model shape on what the particle is designed.\n   * @param shapeId (integer) is the model shape identifier in the SPS.\n   * @param idxInShape (integer) is the index of the particle in the current model (ex: the 10th box of addShape(box, 30))\n   * @param sps defines the sps it is associated to\n   * @param modelBoundingInfo is the reference to the model BoundingInfo used for intersection computations.\n   * @param materialIndex is the particle material identifier (integer) when the MultiMaterials are enabled in the SPS.\n   */\n  constructor(particleIndex, particleId, positionIndex, indiceIndex, model, shapeId, idxInShape, sps, modelBoundingInfo = null, materialIndex = null) {\n    /**\n     * particle global index\n     */\n    this.idx = 0;\n    /**\n     * particle identifier\n     */\n    this.id = 0;\n    /**\n     * The color of the particle\n     */\n    this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n    /**\n     * The world space position of the particle.\n     */\n    this.position = Vector3.Zero();\n    /**\n     * The world space rotation of the particle. (Not use if rotationQuaternion is set)\n     */\n    this.rotation = Vector3.Zero();\n    /**\n     * The scaling of the particle.\n     */\n    this.scaling = Vector3.One();\n    /**\n     * The uvs of the particle.\n     */\n    this.uvs = new Vector4(0.0, 0.0, 1.0, 1.0);\n    /**\n     * The current speed of the particle.\n     */\n    this.velocity = Vector3.Zero();\n    /**\n     * The pivot point in the particle local space.\n     */\n    this.pivot = Vector3.Zero();\n    /**\n     * Must the particle be translated from its pivot point in its local space ?\n     * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.\n     * Default : false\n     */\n    this.translateFromPivot = false;\n    /**\n     * Is the particle active or not ?\n     */\n    this.alive = true;\n    /**\n     * Is the particle visible or not ?\n     */\n    this.isVisible = true;\n    /**\n     * Index of this particle in the global \"positions\" array (Internal use)\n     * @internal\n     */\n    this._pos = 0;\n    /**\n     * @internal Index of this particle in the global \"indices\" array (Internal use)\n     */\n    this._ind = 0;\n    /**\n     * ModelShape id of this particle\n     */\n    this.shapeId = 0;\n    /**\n     * Index of the particle in its shape id\n     */\n    this.idxInShape = 0;\n    /**\n     * @internal Still set as invisible in order to skip useless computations (Internal use)\n     */\n    this._stillInvisible = false;\n    /**\n     * @internal Last computed particle rotation matrix\n     */\n    this._rotationMatrix = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];\n    /**\n     * Parent particle Id, if any.\n     * Default null.\n     */\n    this.parentId = null;\n    /**\n     * The particle material identifier (integer) when MultiMaterials are enabled in the SPS.\n     */\n    this.materialIndex = null;\n    /**\n     * Custom object or properties.\n     */\n    this.props = null;\n    /**\n     * The culling strategy to use to check whether the solid particle must be culled or not when using isInFrustum().\n     * The possible values are :\n     * - AbstractMesh.CULLINGSTRATEGY_STANDARD\n     * - AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\n     * The default value for solid particles is AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\n     * Please read each static variable documentation in the class AbstractMesh to get details about the culling process.\n     * */\n    this.cullingStrategy = AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;\n    /**\n     * @internal Internal global position in the SPS.\n     */\n    this._globalPosition = Vector3.Zero();\n    this.idx = particleIndex;\n    this.id = particleId;\n    this._pos = positionIndex;\n    this._ind = indiceIndex;\n    this._model = model;\n    this.shapeId = shapeId;\n    this.idxInShape = idxInShape;\n    this._sps = sps;\n    if (modelBoundingInfo) {\n      this._modelBoundingInfo = modelBoundingInfo;\n      this._boundingInfo = new BoundingInfo(modelBoundingInfo.minimum, modelBoundingInfo.maximum);\n    }\n    if (materialIndex !== null) {\n      this.materialIndex = materialIndex;\n    }\n  }\n  /**\n   * Copies the particle property values into the existing target : position, rotation, scaling, uvs, colors, pivot, parent, visibility, alive\n   * @param target the particle target\n   * @returns the current particle\n   */\n  copyToRef(target) {\n    target.position.copyFrom(this.position);\n    target.rotation.copyFrom(this.rotation);\n    if (this.rotationQuaternion) {\n      if (target.rotationQuaternion) {\n        target.rotationQuaternion.copyFrom(this.rotationQuaternion);\n      } else {\n        target.rotationQuaternion = this.rotationQuaternion.clone();\n      }\n    }\n    target.scaling.copyFrom(this.scaling);\n    if (this.color) {\n      if (target.color) {\n        target.color.copyFrom(this.color);\n      } else {\n        target.color = this.color.clone();\n      }\n    }\n    target.uvs.copyFrom(this.uvs);\n    target.velocity.copyFrom(this.velocity);\n    target.pivot.copyFrom(this.pivot);\n    target.translateFromPivot = this.translateFromPivot;\n    target.alive = this.alive;\n    target.isVisible = this.isVisible;\n    target.parentId = this.parentId;\n    target.cullingStrategy = this.cullingStrategy;\n    if (this.materialIndex !== null) {\n      target.materialIndex = this.materialIndex;\n    }\n    return this;\n  }\n  /**\n   * Legacy support, changed scale to scaling\n   */\n  get scale() {\n    return this.scaling;\n  }\n  /**\n   * Legacy support, changed scale to scaling\n   */\n  set scale(scale) {\n    this.scaling = scale;\n  }\n  /**\n   * Legacy support, changed quaternion to rotationQuaternion\n   */\n  get quaternion() {\n    return this.rotationQuaternion;\n  }\n  /**\n   * Legacy support, changed quaternion to rotationQuaternion\n   */\n  set quaternion(q) {\n    this.rotationQuaternion = q;\n  }\n  /**\n   * Returns a boolean. True if the particle intersects another particle or another mesh, else false.\n   * The intersection is computed on the particle bounding sphere and Axis Aligned Bounding Box (AABB)\n   * @param target is the object (solid particle or mesh) what the intersection is computed against.\n   * @returns true if it intersects\n   */\n  intersectsMesh(target) {\n    if (!this._boundingInfo || !target.hasBoundingInfo) {\n      return false;\n    }\n    if (this._sps._bSphereOnly) {\n      return BoundingSphere.Intersects(this._boundingInfo.boundingSphere, target.getBoundingInfo().boundingSphere);\n    }\n    return this._boundingInfo.intersects(target.getBoundingInfo(), false);\n  }\n  /**\n   * Returns `true` if the solid particle is within the frustum defined by the passed array of planes.\n   * A particle is in the frustum if its bounding box intersects the frustum\n   * @param frustumPlanes defines the frustum to test\n   * @returns true if the particle is in the frustum planes\n   */\n  isInFrustum(frustumPlanes) {\n    return this._boundingInfo !== null && this._boundingInfo.isInFrustum(frustumPlanes, this.cullingStrategy);\n  }\n  /**\n   * get the rotation matrix of the particle\n   * @internal\n   */\n  getRotationMatrix(m) {\n    let quaternion;\n    if (this.rotationQuaternion) {\n      quaternion = this.rotationQuaternion;\n    } else {\n      quaternion = TmpVectors.Quaternion[0];\n      const rotation = this.rotation;\n      Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\n    }\n    quaternion.toRotationMatrix(m);\n  }\n}\n/**\n * Represents the shape of the model used by one particle of a solid particle system.\n * SPS internal tool, don't use it manually.\n */\nexport class ModelShape {\n  /**\n   * Get or set the shapeId\n   * @deprecated Please use shapeId instead\n   */\n  get shapeID() {\n    return this.shapeId;\n  }\n  set shapeID(shapeID) {\n    this.shapeId = shapeID;\n  }\n  /**\n   * Creates a ModelShape object. This is an internal simplified reference to a mesh used as for a model to replicate particles from by the SPS.\n   * SPS internal tool, don't use it manually.\n   * @internal\n   */\n  constructor(id, shape, indices, normals, colors, shapeUV, posFunction, vtxFunction, material) {\n    /**\n     * length of the shape in the model indices array (internal use)\n     * @internal\n     */\n    this._indicesLength = 0;\n    this.shapeId = id;\n    this._shape = shape;\n    this._indices = indices;\n    this._indicesLength = indices.length;\n    this._shapeUV = shapeUV;\n    this._shapeColors = colors;\n    this._normals = normals;\n    this._positionFunction = posFunction;\n    this._vertexFunction = vtxFunction;\n    this._material = material;\n  }\n}\n/**\n * Represents a Depth Sorted Particle in the solid particle system.\n * @internal\n */\nexport class DepthSortedParticle {\n  /**\n   * Creates a new sorted particle\n   * @param idx\n   * @param ind\n   * @param indLength\n   * @param materialIndex\n   */\n  constructor(idx, ind, indLength, materialIndex) {\n    /**\n     * Particle index\n     */\n    this.idx = 0;\n    /**\n     * Index of the particle in the \"indices\" array\n     */\n    this.ind = 0;\n    /**\n     * Length of the particle shape in the \"indices\" array\n     */\n    this.indicesLength = 0;\n    /**\n     * Squared distance from the particle to the camera\n     */\n    this.sqDistance = 0.0;\n    /**\n     * Material index when used with MultiMaterials\n     */\n    this.materialIndex = 0;\n    this.idx = idx;\n    this.ind = ind;\n    this.indicesLength = indLength;\n    this.materialIndex = materialIndex;\n  }\n}\n/**\n * Represents a solid particle vertex\n */\nexport class SolidParticleVertex {\n  /**\n   * Creates a new solid particle vertex\n   */\n  constructor() {\n    this.position = Vector3.Zero();\n    this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n    this.uv = Vector2.Zero();\n  }\n  // Getters and Setters for back-compatibility\n  /** Vertex x coordinate */\n  get x() {\n    return this.position.x;\n  }\n  set x(val) {\n    this.position.x = val;\n  }\n  /** Vertex y coordinate */\n  get y() {\n    return this.position.y;\n  }\n  set y(val) {\n    this.position.y = val;\n  }\n  /** Vertex z coordinate */\n  get z() {\n    return this.position.z;\n  }\n  set z(val) {\n    this.position.z = val;\n  }\n}","map":{"version":3,"names":["Vector3","TmpVectors","Quaternion","Vector4","Vector2","Color4","BoundingInfo","BoundingSphere","AbstractMesh","SolidParticle","getBoundingInfo","_boundingInfo","hasBoundingInfo","constructor","particleIndex","particleId","positionIndex","indiceIndex","model","shapeId","idxInShape","sps","modelBoundingInfo","materialIndex","idx","id","color","position","Zero","rotation","scaling","One","uvs","velocity","pivot","translateFromPivot","alive","isVisible","_pos","_ind","_stillInvisible","_rotationMatrix","parentId","props","cullingStrategy","CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY","_globalPosition","_model","_sps","_modelBoundingInfo","minimum","maximum","copyToRef","target","copyFrom","rotationQuaternion","clone","scale","quaternion","q","intersectsMesh","_bSphereOnly","Intersects","boundingSphere","intersects","isInFrustum","frustumPlanes","getRotationMatrix","m","RotationYawPitchRollToRef","y","x","z","toRotationMatrix","ModelShape","shapeID","shape","indices","normals","colors","shapeUV","posFunction","vtxFunction","material","_indicesLength","_shape","_indices","length","_shapeUV","_shapeColors","_normals","_positionFunction","_vertexFunction","_material","DepthSortedParticle","ind","indLength","indicesLength","sqDistance","SolidParticleVertex","uv","val"],"sources":["../../../../dev/core/src/Particles/solidParticle.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { Vector3, TmpVectors, Quaternion, Vector4, Vector2 } from \"../Maths/math.vector\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport { BoundingSphere } from \"../Culling/boundingSphere\";\r\nimport type { SolidParticleSystem } from \"./solidParticleSystem\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport type { Material } from \"../Materials/material\";\r\n/**\r\n * Represents one particle of a solid particle system.\r\n */\r\nexport class SolidParticle {\r\n    /**\r\n     * particle global index\r\n     */\r\n    public idx: number = 0;\r\n    /**\r\n     * particle identifier\r\n     */\r\n    public id: number = 0;\r\n    /**\r\n     * The color of the particle\r\n     */\r\n    public color: Nullable<Color4> = new Color4(1.0, 1.0, 1.0, 1.0);\r\n    /**\r\n     * The world space position of the particle.\r\n     */\r\n    public position: Vector3 = Vector3.Zero();\r\n    /**\r\n     * The world space rotation of the particle. (Not use if rotationQuaternion is set)\r\n     */\r\n    public rotation: Vector3 = Vector3.Zero();\r\n    /**\r\n     * The world space rotation quaternion of the particle.\r\n     */\r\n    public rotationQuaternion: Nullable<Quaternion>;\r\n    /**\r\n     * The scaling of the particle.\r\n     */\r\n    public scaling: Vector3 = Vector3.One();\r\n    /**\r\n     * The uvs of the particle.\r\n     */\r\n    public uvs: Vector4 = new Vector4(0.0, 0.0, 1.0, 1.0);\r\n    /**\r\n     * The current speed of the particle.\r\n     */\r\n    public velocity: Vector3 = Vector3.Zero();\r\n    /**\r\n     * The pivot point in the particle local space.\r\n     */\r\n    public pivot: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Must the particle be translated from its pivot point in its local space ?\r\n     * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.\r\n     * Default : false\r\n     */\r\n    public translateFromPivot: boolean = false;\r\n    /**\r\n     * Is the particle active or not ?\r\n     */\r\n    public alive: boolean = true;\r\n    /**\r\n     * Is the particle visible or not ?\r\n     */\r\n    public isVisible: boolean = true;\r\n    /**\r\n     * Index of this particle in the global \"positions\" array (Internal use)\r\n     * @internal\r\n     */\r\n    public _pos: number = 0;\r\n    /**\r\n     * @internal Index of this particle in the global \"indices\" array (Internal use)\r\n     */\r\n    public _ind: number = 0;\r\n    /**\r\n     * @internal ModelShape of this particle (Internal use)\r\n     */\r\n    public _model: ModelShape;\r\n    /**\r\n     * ModelShape id of this particle\r\n     */\r\n    public shapeId: number = 0;\r\n    /**\r\n     * Index of the particle in its shape id\r\n     */\r\n    public idxInShape: number = 0;\r\n    /**\r\n     * @internal Reference to the shape model BoundingInfo object (Internal use)\r\n     */\r\n    public _modelBoundingInfo: BoundingInfo;\r\n    private _boundingInfo: BoundingInfo;\r\n    /**\r\n     * @internal Reference to the SPS what the particle belongs to (Internal use)\r\n     */\r\n    public _sps: SolidParticleSystem;\r\n    /**\r\n     * @internal Still set as invisible in order to skip useless computations (Internal use)\r\n     */\r\n    public _stillInvisible: boolean = false;\r\n    /**\r\n     * @internal Last computed particle rotation matrix\r\n     */\r\n    public _rotationMatrix: number[] = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];\r\n    /**\r\n     * Parent particle Id, if any.\r\n     * Default null.\r\n     */\r\n    public parentId: Nullable<number> = null;\r\n    /**\r\n     * The particle material identifier (integer) when MultiMaterials are enabled in the SPS.\r\n     */\r\n    public materialIndex: Nullable<number> = null;\r\n    /**\r\n     * Custom object or properties.\r\n     */\r\n    public props: Nullable<any> = null;\r\n    /**\r\n     * The culling strategy to use to check whether the solid particle must be culled or not when using isInFrustum().\r\n     * The possible values are :\r\n     * - AbstractMesh.CULLINGSTRATEGY_STANDARD\r\n     * - AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\r\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\r\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\r\n     * The default value for solid particles is AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\r\n     * Please read each static variable documentation in the class AbstractMesh to get details about the culling process.\r\n     * */\r\n    public cullingStrategy = AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;\r\n\r\n    /**\r\n     * @internal Internal global position in the SPS.\r\n     */\r\n    public _globalPosition: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Particle BoundingInfo object\r\n     * @returns a BoundingInfo\r\n     */\r\n    public getBoundingInfo(): BoundingInfo {\r\n        return this._boundingInfo;\r\n    }\r\n\r\n    /**\r\n     * Returns true if there is already a bounding info\r\n     */\r\n    public get hasBoundingInfo(): boolean {\r\n        return this._boundingInfo !== null;\r\n    }\r\n\r\n    /**\r\n     * Creates a Solid Particle object.\r\n     * Don't create particles manually, use instead the Solid Particle System internal tools like _addParticle()\r\n     * @param particleIndex (integer) is the particle index in the Solid Particle System pool.\r\n     * @param particleId (integer) is the particle identifier. Unless some particles are removed from the SPS, it's the same value than the particle idx.\r\n     * @param positionIndex (integer) is the starting index of the particle vertices in the SPS \"positions\" array.\r\n     * @param indiceIndex (integer) is the starting index of the particle indices in the SPS \"indices\" array.\r\n     * @param model (ModelShape) is a reference to the model shape on what the particle is designed.\r\n     * @param shapeId (integer) is the model shape identifier in the SPS.\r\n     * @param idxInShape (integer) is the index of the particle in the current model (ex: the 10th box of addShape(box, 30))\r\n     * @param sps defines the sps it is associated to\r\n     * @param modelBoundingInfo is the reference to the model BoundingInfo used for intersection computations.\r\n     * @param materialIndex is the particle material identifier (integer) when the MultiMaterials are enabled in the SPS.\r\n     */\r\n    constructor(\r\n        particleIndex: number,\r\n        particleId: number,\r\n        positionIndex: number,\r\n        indiceIndex: number,\r\n        model: Nullable<ModelShape>,\r\n        shapeId: number,\r\n        idxInShape: number,\r\n        sps: SolidParticleSystem,\r\n        modelBoundingInfo: Nullable<BoundingInfo> = null,\r\n        materialIndex: Nullable<number> = null\r\n    ) {\r\n        this.idx = particleIndex;\r\n        this.id = particleId;\r\n        this._pos = positionIndex;\r\n        this._ind = indiceIndex;\r\n        this._model = <ModelShape>model;\r\n        this.shapeId = shapeId;\r\n        this.idxInShape = idxInShape;\r\n        this._sps = sps;\r\n        if (modelBoundingInfo) {\r\n            this._modelBoundingInfo = modelBoundingInfo;\r\n            this._boundingInfo = new BoundingInfo(modelBoundingInfo.minimum, modelBoundingInfo.maximum);\r\n        }\r\n        if (materialIndex !== null) {\r\n            this.materialIndex = materialIndex;\r\n        }\r\n    }\r\n    /**\r\n     * Copies the particle property values into the existing target : position, rotation, scaling, uvs, colors, pivot, parent, visibility, alive\r\n     * @param target the particle target\r\n     * @returns the current particle\r\n     */\r\n    public copyToRef(target: SolidParticle): SolidParticle {\r\n        target.position.copyFrom(this.position);\r\n        target.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            if (target.rotationQuaternion) {\r\n                target.rotationQuaternion!.copyFrom(this.rotationQuaternion!);\r\n            } else {\r\n                target.rotationQuaternion = this.rotationQuaternion.clone();\r\n            }\r\n        }\r\n        target.scaling.copyFrom(this.scaling);\r\n        if (this.color) {\r\n            if (target.color) {\r\n                target.color!.copyFrom(this.color!);\r\n            } else {\r\n                target.color = this.color.clone();\r\n            }\r\n        }\r\n        target.uvs.copyFrom(this.uvs);\r\n        target.velocity.copyFrom(this.velocity);\r\n        target.pivot.copyFrom(this.pivot);\r\n        target.translateFromPivot = this.translateFromPivot;\r\n        target.alive = this.alive;\r\n        target.isVisible = this.isVisible;\r\n        target.parentId = this.parentId;\r\n        target.cullingStrategy = this.cullingStrategy;\r\n        if (this.materialIndex !== null) {\r\n            target.materialIndex = this.materialIndex;\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Legacy support, changed scale to scaling\r\n     */\r\n    public get scale(): Vector3 {\r\n        return this.scaling;\r\n    }\r\n\r\n    /**\r\n     * Legacy support, changed scale to scaling\r\n     */\r\n    public set scale(scale: Vector3) {\r\n        this.scaling = scale;\r\n    }\r\n\r\n    /**\r\n     * Legacy support, changed quaternion to rotationQuaternion\r\n     */\r\n    public get quaternion(): Nullable<Quaternion> {\r\n        return this.rotationQuaternion;\r\n    }\r\n\r\n    /**\r\n     * Legacy support, changed quaternion to rotationQuaternion\r\n     */\r\n    public set quaternion(q: Nullable<Quaternion>) {\r\n        this.rotationQuaternion = q;\r\n    }\r\n\r\n    /**\r\n     * Returns a boolean. True if the particle intersects another particle or another mesh, else false.\r\n     * The intersection is computed on the particle bounding sphere and Axis Aligned Bounding Box (AABB)\r\n     * @param target is the object (solid particle or mesh) what the intersection is computed against.\r\n     * @returns true if it intersects\r\n     */\r\n    public intersectsMesh(target: Mesh | SolidParticle): boolean {\r\n        if (!this._boundingInfo || !target.hasBoundingInfo) {\r\n            return false;\r\n        }\r\n        if (this._sps._bSphereOnly) {\r\n            return BoundingSphere.Intersects(this._boundingInfo.boundingSphere, target.getBoundingInfo().boundingSphere);\r\n        }\r\n        return this._boundingInfo.intersects(target.getBoundingInfo(), false);\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if the solid particle is within the frustum defined by the passed array of planes.\r\n     * A particle is in the frustum if its bounding box intersects the frustum\r\n     * @param frustumPlanes defines the frustum to test\r\n     * @returns true if the particle is in the frustum planes\r\n     */\r\n    public isInFrustum(frustumPlanes: Plane[]): boolean {\r\n        return this._boundingInfo !== null && this._boundingInfo.isInFrustum(frustumPlanes, this.cullingStrategy);\r\n    }\r\n\r\n    /**\r\n     * get the rotation matrix of the particle\r\n     * @internal\r\n     */\r\n    public getRotationMatrix(m: Matrix) {\r\n        let quaternion: Quaternion;\r\n        if (this.rotationQuaternion) {\r\n            quaternion = this.rotationQuaternion;\r\n        } else {\r\n            quaternion = TmpVectors.Quaternion[0];\r\n            const rotation = this.rotation;\r\n            Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\r\n        }\r\n\r\n        quaternion.toRotationMatrix(m);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents the shape of the model used by one particle of a solid particle system.\r\n * SPS internal tool, don't use it manually.\r\n */\r\nexport class ModelShape {\r\n    /**\r\n     * Get or set the shapeId\r\n     * @deprecated Please use shapeId instead\r\n     */\r\n    public get shapeID(): number {\r\n        return this.shapeId;\r\n    }\r\n    public set shapeID(shapeID: number) {\r\n        this.shapeId = shapeID;\r\n    }\r\n    /**\r\n     * The shape id\r\n     * @internal\r\n     */\r\n    public shapeId: number;\r\n    /**\r\n     * flat array of model positions (internal use)\r\n     * @internal\r\n     */\r\n    public _shape: Vector3[];\r\n    /**\r\n     * flat array of model UVs (internal use)\r\n     * @internal\r\n     */\r\n    public _shapeUV: number[];\r\n    /**\r\n     * color array of the model\r\n     * @internal\r\n     */\r\n    public _shapeColors: number[];\r\n    /**\r\n     * indices array of the model\r\n     * @internal\r\n     */\r\n    public _indices: number[];\r\n    /**\r\n     * normals array of the model\r\n     * @internal\r\n     */\r\n    public _normals: number[];\r\n    /**\r\n     * length of the shape in the model indices array (internal use)\r\n     * @internal\r\n     */\r\n    public _indicesLength: number = 0;\r\n    /**\r\n     * Custom position function (internal use)\r\n     * @internal\r\n     */\r\n    public _positionFunction: Nullable<(particle: SolidParticle, i: number, s: number) => void>;\r\n    /**\r\n     * Custom vertex function (internal use)\r\n     * @internal\r\n     */\r\n    public _vertexFunction: Nullable<(particle: SolidParticle, vertex: Vector3, i: number) => void>;\r\n    /**\r\n     * Model material (internal use)\r\n     * @internal\r\n     */\r\n    public _material: Nullable<Material>;\r\n\r\n    /**\r\n     * Creates a ModelShape object. This is an internal simplified reference to a mesh used as for a model to replicate particles from by the SPS.\r\n     * SPS internal tool, don't use it manually.\r\n     * @internal\r\n     */\r\n    constructor(\r\n        id: number,\r\n        shape: Vector3[],\r\n        indices: number[],\r\n        normals: number[],\r\n        colors: number[],\r\n        shapeUV: number[],\r\n        posFunction: Nullable<(particle: SolidParticle, i: number, s: number) => void>,\r\n        vtxFunction: Nullable<(particle: SolidParticle, vertex: Vector3, i: number) => void>,\r\n        material: Nullable<Material>\r\n    ) {\r\n        this.shapeId = id;\r\n        this._shape = shape;\r\n        this._indices = indices;\r\n        this._indicesLength = indices.length;\r\n        this._shapeUV = shapeUV;\r\n        this._shapeColors = colors;\r\n        this._normals = normals;\r\n        this._positionFunction = posFunction;\r\n        this._vertexFunction = vtxFunction;\r\n        this._material = material;\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a Depth Sorted Particle in the solid particle system.\r\n * @internal\r\n */\r\nexport class DepthSortedParticle {\r\n    /**\r\n     * Particle index\r\n     */\r\n    public idx: number = 0;\r\n    /**\r\n     * Index of the particle in the \"indices\" array\r\n     */\r\n    public ind: number = 0;\r\n    /**\r\n     * Length of the particle shape in the \"indices\" array\r\n     */\r\n    public indicesLength: number = 0;\r\n    /**\r\n     * Squared distance from the particle to the camera\r\n     */\r\n    public sqDistance: number = 0.0;\r\n    /**\r\n     * Material index when used with MultiMaterials\r\n     */\r\n    public materialIndex: number = 0;\r\n\r\n    /**\r\n     * Creates a new sorted particle\r\n     * @param idx\r\n     * @param ind\r\n     * @param indLength\r\n     * @param materialIndex\r\n     */\r\n    constructor(idx: number, ind: number, indLength: number, materialIndex: number) {\r\n        this.idx = idx;\r\n        this.ind = ind;\r\n        this.indicesLength = indLength;\r\n        this.materialIndex = materialIndex;\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a solid particle vertex\r\n */\r\nexport class SolidParticleVertex {\r\n    /**\r\n     * Vertex position\r\n     */\r\n    public position: Vector3;\r\n    /**\r\n     * Vertex color\r\n     */\r\n    public color: Color4;\r\n    /**\r\n     * Vertex UV\r\n     */\r\n    public uv: Vector2;\r\n    /**\r\n     * Creates a new solid particle vertex\r\n     */\r\n    constructor() {\r\n        this.position = Vector3.Zero();\r\n        this.color = new Color4(1.0, 1.0, 1.0, 1.0);\r\n        this.uv = Vector2.Zero();\r\n    }\r\n    // Getters and Setters for back-compatibility\r\n    /** Vertex x coordinate */\r\n    public get x(): number {\r\n        return this.position.x;\r\n    }\r\n    public set x(val: number) {\r\n        this.position.x = val;\r\n    }\r\n    /** Vertex y coordinate */\r\n    public get y(): number {\r\n        return this.position.y;\r\n    }\r\n    public set y(val: number) {\r\n        this.position.y = val;\r\n    }\r\n    /** Vertex z coordinate */\r\n    public get z(): number {\r\n        return this.position.z;\r\n    }\r\n    public set z(val: number) {\r\n        this.position.z = val;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}