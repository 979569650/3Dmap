{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { Vector3 } from \"../../../../Maths/math.vector.js\";\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator.js\";\nimport { Ray } from \"../../../../Culling/ray.js\";\nimport { extractMinAndMax } from \"../../../../Maths/math.functions.js\";\n/**\n * Block used to instance geometry inside a geometry\n */\nexport class InstantiateOnVolumeBlock extends NodeGeometryBlock {\n  /**\n   * Create a new InstantiateOnVolumeBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    this._currentPosition = new Vector3();\n    this._vertex0 = new Vector3();\n    this._vertex1 = new Vector3();\n    this._vertex2 = new Vector3();\n    /**\n     * Gets or sets a boolean indicating that this block can evaluate context\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\n     */\n    this.evaluateContext = true;\n    this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\n    this.registerInput(\"instance\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\n    this.registerInput(\"count\", NodeGeometryBlockConnectionPointTypes.Int, true, 256);\n    this.registerInput(\"matrix\", NodeGeometryBlockConnectionPointTypes.Matrix, true);\n    this.registerInput(\"rotation\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());\n    this.registerInput(\"scaling\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.One());\n    this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\n    this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\n  }\n  /**\n   * Gets the current instance index in the current flow\n   * @returns the current index\n   */\n  getInstanceIndex() {\n    return this._currentLoopIndex;\n  }\n  /**\n   * Gets the current index in the current flow\n   * @returns the current index\n   */\n  getExecutionIndex() {\n    return 0;\n  }\n  /**\n   * Gets the current face index in the current flow\n   * @returns the current face index\n   */\n  getExecutionFaceIndex() {\n    return 0;\n  }\n  /**\n   * Gets the current loop index in the current flow\n   * @returns the current loop index\n   */\n  getExecutionLoopIndex() {\n    return this._currentLoopIndex;\n  }\n  /**\n   * Gets the value associated with a contextual positions\n   * @returns the value associated with the source\n   */\n  getOverridePositionsContextualValue() {\n    return this._currentPosition;\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"InstantiateOnVolumeBlock\";\n  }\n  /**\n   * Gets the geometry input component\n   */\n  get geometry() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the instance input component\n   */\n  get instance() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the count input component\n   */\n  get count() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the matrix input component\n   */\n  get matrix() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the rotation input component\n   */\n  get rotation() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the scaling input component\n   */\n  get scaling() {\n    return this._inputs[5];\n  }\n  /**\n   * Gets the geometry output component\n   */\n  get output() {\n    return this._outputs[0];\n  }\n  _buildBlock(state) {\n    const func = state => {\n      state.pushExecutionContext(this);\n      state.pushInstancingContext(this);\n      this._vertexData = this.geometry.getConnectedValue(state);\n      state.pushGeometryContext(this._vertexData);\n      if (!this._vertexData || !this._vertexData.positions || !this._vertexData.indices || !this.instance.isConnected) {\n        state.restoreExecutionContext();\n        state.restoreInstancingContext();\n        state.restoreGeometryContext();\n        this.output._storedValue = null;\n        return;\n      }\n      // Processing\n      let instanceGeometry = null;\n      const instanceCount = this.count.getConnectedValue(state);\n      const additionalVertexData = [];\n      const boundingInfo = extractMinAndMax(this._vertexData.positions, 0, this._vertexData.positions.length / 3);\n      const min = boundingInfo.minimum;\n      const max = boundingInfo.maximum;\n      const direction = new Vector3(1, 0, 0);\n      const faceCount = this._vertexData.indices.length / 3;\n      this._currentLoopIndex = 0;\n      for (let index = 0; index < instanceCount; index++) {\n        this._currentPosition.set(Math.random() * (max.x - min.x) + min.x, Math.random() * (max.y - min.y) + min.y, Math.random() * (max.z - min.z) + min.z);\n        // Cast a ray from the random point in an arbitrary direction\n        const ray = new Ray(this._currentPosition, direction);\n        let intersectionCount = 0;\n        for (let currentFaceIndex = 0; currentFaceIndex < faceCount; currentFaceIndex++) {\n          // Extract face vertices\n          this._vertex0.fromArray(this._vertexData.positions, this._vertexData.indices[currentFaceIndex * 3] * 3);\n          this._vertex1.fromArray(this._vertexData.positions, this._vertexData.indices[currentFaceIndex * 3 + 1] * 3);\n          this._vertex2.fromArray(this._vertexData.positions, this._vertexData.indices[currentFaceIndex * 3 + 2] * 3);\n          const currentIntersectInfo = ray.intersectsTriangle(this._vertex0, this._vertex1, this._vertex2);\n          if (currentIntersectInfo && currentIntersectInfo.distance > 0) {\n            intersectionCount++;\n          }\n        }\n        if (intersectionCount % 2 === 0) {\n          // We are outside, try again\n          index--;\n          continue;\n        }\n        // Clone the instance\n        instanceGeometry = this.instance.getConnectedValue(state);\n        if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {\n          continue;\n        }\n        const clone = instanceGeometry.clone();\n        if (this.matrix.isConnected) {\n          const transform = this.matrix.getConnectedValue(state);\n          state._instantiateWithPositionAndMatrix(clone, this._currentPosition, transform, additionalVertexData);\n        } else {\n          const scaling = state.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);\n          const rotation = this.rotation.getConnectedValue(state) || Vector3.ZeroReadOnly;\n          state._instantiate(clone, this._currentPosition, rotation, scaling, additionalVertexData);\n        }\n        this._currentLoopIndex++;\n      }\n      // Merge\n      if (additionalVertexData.length) {\n        if (additionalVertexData.length === 1) {\n          this._vertexData = additionalVertexData[0];\n        } else {\n          // We do not merge the main one as user can use a merge node if wanted\n          const main = additionalVertexData.splice(0, 1)[0];\n          this._vertexData = main.merge(additionalVertexData, true, false, true, true);\n        }\n      }\n      state.restoreGeometryContext();\n      state.restoreExecutionContext();\n      state.restoreInstancingContext();\n      return this._vertexData;\n    };\n    // Storage\n    if (this.evaluateContext) {\n      this.output._storedFunction = func;\n    } else {\n      this.output._storedFunction = null;\n      this.output._storedValue = func(state);\n    }\n  }\n  _dumpPropertiesCode() {\n    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\n    return codeString;\n  }\n  /**\n   * Serializes this block in a JSON representation\n   * @returns the serialized block object\n   */\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.evaluateContext = this.evaluateContext;\n    return serializationObject;\n  }\n  _deserialize(serializationObject) {\n    super._deserialize(serializationObject);\n    if (serializationObject.evaluateContext !== undefined) {\n      this.evaluateContext = serializationObject.evaluateContext;\n    }\n  }\n}\n__decorate([editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    rebuild: true\n  }\n})], InstantiateOnVolumeBlock.prototype, \"evaluateContext\", void 0);\nRegisterClass(\"BABYLON.InstantiateOnVolumeBlock\", InstantiateOnVolumeBlock);","map":{"version":3,"names":["NodeGeometryBlock","RegisterClass","NodeGeometryBlockConnectionPointTypes","Vector3","PropertyTypeForEdition","editableInPropertyPage","Ray","extractMinAndMax","InstantiateOnVolumeBlock","constructor","name","_currentPosition","_vertex0","_vertex1","_vertex2","evaluateContext","registerInput","Geometry","Int","Matrix","Zero","One","scaling","acceptedConnectionPointTypes","push","Float","registerOutput","getInstanceIndex","_currentLoopIndex","getExecutionIndex","getExecutionFaceIndex","getExecutionLoopIndex","getOverridePositionsContextualValue","getClassName","geometry","_inputs","instance","count","matrix","rotation","output","_outputs","_buildBlock","state","func","pushExecutionContext","pushInstancingContext","_vertexData","getConnectedValue","pushGeometryContext","positions","indices","isConnected","restoreExecutionContext","restoreInstancingContext","restoreGeometryContext","_storedValue","instanceGeometry","instanceCount","additionalVertexData","boundingInfo","length","min","minimum","max","maximum","direction","faceCount","index","set","Math","random","x","y","z","ray","intersectionCount","currentFaceIndex","fromArray","currentIntersectInfo","intersectsTriangle","distance","clone","transform","_instantiateWithPositionAndMatrix","adaptInput","OneReadOnly","ZeroReadOnly","_instantiate","main","splice","merge","_storedFunction","_dumpPropertiesCode","codeString","_codeVariableName","serialize","serializationObject","_deserialize","undefined","__decorate","Boolean","notifiers","rebuild"],"sources":["../../../../../../../dev/core/src/Meshes/Node/Blocks/Instances/instantiateOnVolumeBlock.ts"],"sourcesContent":["import { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport type { INodeGeometryExecutionContext } from \"../../Interfaces/nodeGeometryExecutionContext\";\r\nimport type { VertexData } from \"../../../mesh.vertexData\";\r\nimport { Vector3 } from \"../../../../Maths/math.vector\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { Ray } from \"../../../../Culling/ray\";\r\nimport { extractMinAndMax } from \"../../../../Maths/math.functions\";\r\nimport type { INodeGeometryInstancingContext } from \"../../Interfaces/nodeGeometryInstancingContext\";\r\n\r\n/**\r\n * Block used to instance geometry inside a geometry\r\n */\r\nexport class InstantiateOnVolumeBlock extends NodeGeometryBlock implements INodeGeometryExecutionContext, INodeGeometryInstancingContext {\r\n    private _vertexData: VertexData;\r\n    private _currentLoopIndex: number;\r\n    private _currentPosition = new Vector3();\r\n    private _vertex0 = new Vector3();\r\n    private _vertex1 = new Vector3();\r\n    private _vertex2 = new Vector3();\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = true;\r\n\r\n    /**\r\n     * Create a new InstantiateOnVolumeBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this.registerInput(\"instance\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\r\n        this.registerInput(\"count\", NodeGeometryBlockConnectionPointTypes.Int, true, 256);\r\n        this.registerInput(\"matrix\", NodeGeometryBlockConnectionPointTypes.Matrix, true);\r\n        this.registerInput(\"rotation\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());\r\n        this.registerInput(\"scaling\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.One());\r\n\r\n        this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current instance index in the current flow\r\n     * @returns the current index\r\n     */\r\n    public getInstanceIndex(): number {\r\n        return this._currentLoopIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current index in the current flow\r\n     * @returns the current index\r\n     */\r\n    public getExecutionIndex(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current face index in the current flow\r\n     * @returns the current face index\r\n     */\r\n    public getExecutionFaceIndex(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current loop index in the current flow\r\n     * @returns the current loop index\r\n     */\r\n    public getExecutionLoopIndex(): number {\r\n        return this._currentLoopIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the value associated with a contextual positions\r\n     * @returns the value associated with the source\r\n     */\r\n    public getOverridePositionsContextualValue() {\r\n        return this._currentPosition;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"InstantiateOnVolumeBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry input component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the instance input component\r\n     */\r\n    public get instance(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the count input component\r\n     */\r\n    public get count(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix input component\r\n     */\r\n    public get matrix(): NodeGeometryConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the rotation input component\r\n     */\r\n    public get rotation(): NodeGeometryConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the scaling input component\r\n     */\r\n    public get scaling(): NodeGeometryConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            state.pushExecutionContext(this);\r\n            state.pushInstancingContext(this);\r\n\r\n            this._vertexData = this.geometry.getConnectedValue(state);\r\n            state.pushGeometryContext(this._vertexData);\r\n\r\n            if (!this._vertexData || !this._vertexData.positions || !this._vertexData.indices || !this.instance.isConnected) {\r\n                state.restoreExecutionContext();\r\n                state.restoreInstancingContext();\r\n                state.restoreGeometryContext();\r\n                this.output._storedValue = null;\r\n                return;\r\n            }\r\n\r\n            // Processing\r\n            let instanceGeometry: Nullable<VertexData> = null;\r\n            const instanceCount = this.count.getConnectedValue(state);\r\n            const additionalVertexData: VertexData[] = [];\r\n            const boundingInfo = extractMinAndMax(this._vertexData.positions!, 0, this._vertexData.positions!.length / 3);\r\n            const min = boundingInfo.minimum;\r\n            const max = boundingInfo.maximum;\r\n            const direction = new Vector3(1, 0, 0);\r\n            const faceCount = this._vertexData.indices.length / 3;\r\n            this._currentLoopIndex = 0;\r\n\r\n            for (let index = 0; index < instanceCount; index++) {\r\n                this._currentPosition.set(Math.random() * (max.x - min.x) + min.x, Math.random() * (max.y - min.y) + min.y, Math.random() * (max.z - min.z) + min.z);\r\n\r\n                // Cast a ray from the random point in an arbitrary direction\r\n                const ray = new Ray(this._currentPosition, direction);\r\n\r\n                let intersectionCount = 0;\r\n                for (let currentFaceIndex = 0; currentFaceIndex < faceCount; currentFaceIndex++) {\r\n                    // Extract face vertices\r\n                    this._vertex0.fromArray(this._vertexData.positions!, this._vertexData.indices![currentFaceIndex * 3] * 3);\r\n                    this._vertex1.fromArray(this._vertexData.positions!, this._vertexData.indices![currentFaceIndex * 3 + 1] * 3);\r\n                    this._vertex2.fromArray(this._vertexData.positions!, this._vertexData.indices![currentFaceIndex * 3 + 2] * 3);\r\n\r\n                    const currentIntersectInfo = ray.intersectsTriangle(this._vertex0, this._vertex1, this._vertex2);\r\n\r\n                    if (currentIntersectInfo && currentIntersectInfo.distance > 0) {\r\n                        intersectionCount++;\r\n                    }\r\n                }\r\n\r\n                if (intersectionCount % 2 === 0) {\r\n                    // We are outside, try again\r\n                    index--;\r\n                    continue;\r\n                }\r\n\r\n                // Clone the instance\r\n                instanceGeometry = this.instance.getConnectedValue(state) as VertexData;\r\n\r\n                if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {\r\n                    continue;\r\n                }\r\n                const clone = instanceGeometry!.clone();\r\n\r\n                if (this.matrix.isConnected) {\r\n                    const transform = this.matrix.getConnectedValue(state);\r\n                    state._instantiateWithPositionAndMatrix(clone, this._currentPosition, transform, additionalVertexData);\r\n                } else {\r\n                    const scaling = state.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);\r\n                    const rotation = this.rotation.getConnectedValue(state) || Vector3.ZeroReadOnly;\r\n                    state._instantiate(clone, this._currentPosition, rotation, scaling, additionalVertexData);\r\n                }\r\n                this._currentLoopIndex++;\r\n            }\r\n\r\n            // Merge\r\n            if (additionalVertexData.length) {\r\n                if (additionalVertexData.length === 1) {\r\n                    this._vertexData = additionalVertexData[0];\r\n                } else {\r\n                    // We do not merge the main one as user can use a merge node if wanted\r\n                    const main = additionalVertexData.splice(0, 1)[0];\r\n                    this._vertexData = main.merge(additionalVertexData, true, false, true, true);\r\n                }\r\n            }\r\n\r\n            state.restoreGeometryContext();\r\n            state.restoreExecutionContext();\r\n            state.restoreInstancingContext();\r\n            return this._vertexData;\r\n        };\r\n\r\n        // Storage\r\n\r\n        if (this.evaluateContext) {\r\n            this.output._storedFunction = func;\r\n        } else {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = func(state);\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        if (serializationObject.evaluateContext !== undefined) {\r\n            this.evaluateContext = serializationObject.evaluateContext;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.InstantiateOnVolumeBlock\", InstantiateOnVolumeBlock);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}