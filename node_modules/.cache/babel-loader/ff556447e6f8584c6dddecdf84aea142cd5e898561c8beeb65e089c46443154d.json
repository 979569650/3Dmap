{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { FlowGraphWithOnDoneExecutionBlock } from \"../../../flowGraphWithOnDoneExecutionBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\n/**\n * @experimental\n * A block that waits for all input flows to be activated before activating its output flow.\n */\nexport class FlowGraphWaitAllBlock extends FlowGraphWithOnDoneExecutionBlock {\n  constructor(config) {\n    super(config);\n    this.config = config;\n    /**\n     * Input connection: The 2nd to nth input flows (the first is named onStart)\n     */\n    this.inFlows = [];\n    this._cachedActivationState = [];\n    this.reset = this._registerSignalInput(\"reset\");\n  }\n  configure() {\n    // The first inFlow is the default input signal all execution blocks have\n    for (let i = 1; i < this.config.numberInputFlows; i++) {\n      this.inFlows.push(this._registerSignalInput(`in${i}`));\n    }\n  }\n  _getCurrentActivationState(context) {\n    const activationState = this._cachedActivationState;\n    activationState.length = 0;\n    if (!context._hasExecutionVariable(this, \"activationState\")) {\n      for (let i = 0; i < this.config.numberInputFlows; i++) {\n        activationState.push(false);\n      }\n    } else {\n      const contextActivationState = context._getExecutionVariable(this, \"activationState\");\n      for (let i = 0; i < contextActivationState.length; i++) {\n        activationState.push(contextActivationState[i]);\n      }\n    }\n    return activationState;\n  }\n  _execute(context, callingSignal) {\n    const activationState = this._getCurrentActivationState(context);\n    if (callingSignal === this.reset) {\n      for (let i = 0; i < this.config.numberInputFlows; i++) {\n        activationState[i] = false;\n      }\n    } else if (callingSignal === this.onStart) {\n      activationState[0] = true;\n    } else {\n      const index = this.inFlows.indexOf(callingSignal);\n      if (index >= 0) {\n        activationState[index + 1] = true;\n      }\n    }\n    context._setExecutionVariable(this, \"activationState\", activationState.slice());\n    if (activationState.every(value => value)) {\n      this.onDone._activateSignal(context);\n      for (let i = 0; i < this.config.numberInputFlows; i++) {\n        activationState[i] = false;\n      }\n    }\n  }\n  getClassName() {\n    return \"FGWaitAllBlock\";\n  }\n}\nRegisterClass(\"FGWaitAllBlock\", FlowGraphWaitAllBlock);","map":{"version":3,"names":["FlowGraphWithOnDoneExecutionBlock","RegisterClass","FlowGraphWaitAllBlock","constructor","config","inFlows","_cachedActivationState","reset","_registerSignalInput","configure","i","numberInputFlows","push","_getCurrentActivationState","context","activationState","length","_hasExecutionVariable","contextActivationState","_getExecutionVariable","_execute","callingSignal","onStart","index","indexOf","_setExecutionVariable","slice","every","value","onDone","_activateSignal","getClassName"],"sources":["../../../../../../../dev/core/src/FlowGraph/Blocks/Execution/ControlFlow/flowGraphWaitAllBlock.ts"],"sourcesContent":["import type { FlowGraphContext } from \"../../../flowGraphContext\";\r\nimport type { FlowGraphSignalConnection } from \"../../../flowGraphSignalConnection\";\r\nimport { FlowGraphWithOnDoneExecutionBlock } from \"../../../flowGraphWithOnDoneExecutionBlock\";\r\nimport type { IFlowGraphBlockConfiguration } from \"../../../flowGraphBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\n/**\r\n * @experimental\r\n * Configuration for the wait all block.\r\n */\r\nexport interface IFlowGraphWaitAllBlockConfiguration extends IFlowGraphBlockConfiguration {\r\n    /**\r\n     * The number of input flows. There will always be at least one input flow.\r\n     */\r\n    numberInputFlows: number;\r\n}\r\n\r\n/**\r\n * @experimental\r\n * A block that waits for all input flows to be activated before activating its output flow.\r\n */\r\nexport class FlowGraphWaitAllBlock extends FlowGraphWithOnDoneExecutionBlock {\r\n    /**\r\n     * Input connection: Resets the block.\r\n     */\r\n    public reset: FlowGraphSignalConnection;\r\n    /**\r\n     * Input connection: The 2nd to nth input flows (the first is named onStart)\r\n     */\r\n    public readonly inFlows: FlowGraphSignalConnection[] = [];\r\n    private _cachedActivationState: boolean[] = [];\r\n\r\n    constructor(public config: IFlowGraphWaitAllBlockConfiguration) {\r\n        super(config);\r\n\r\n        this.reset = this._registerSignalInput(\"reset\");\r\n    }\r\n\r\n    configure(): void {\r\n        // The first inFlow is the default input signal all execution blocks have\r\n        for (let i = 1; i < this.config.numberInputFlows; i++) {\r\n            this.inFlows.push(this._registerSignalInput(`in${i}`));\r\n        }\r\n    }\r\n\r\n    private _getCurrentActivationState(context: FlowGraphContext) {\r\n        const activationState = this._cachedActivationState;\r\n        activationState.length = 0;\r\n        if (!context._hasExecutionVariable(this, \"activationState\")) {\r\n            for (let i = 0; i < this.config.numberInputFlows; i++) {\r\n                activationState.push(false);\r\n            }\r\n        } else {\r\n            const contextActivationState = context._getExecutionVariable(this, \"activationState\");\r\n            for (let i = 0; i < contextActivationState.length; i++) {\r\n                activationState.push(contextActivationState[i]);\r\n            }\r\n        }\r\n        return activationState;\r\n    }\r\n\r\n    public _execute(context: FlowGraphContext, callingSignal: FlowGraphSignalConnection): void {\r\n        const activationState = this._getCurrentActivationState(context);\r\n        if (callingSignal === this.reset) {\r\n            for (let i = 0; i < this.config.numberInputFlows; i++) {\r\n                activationState[i] = false;\r\n            }\r\n        } else if (callingSignal === this.onStart) {\r\n            activationState[0] = true;\r\n        } else {\r\n            const index = this.inFlows.indexOf(callingSignal);\r\n            if (index >= 0) {\r\n                activationState[index + 1] = true;\r\n            }\r\n        }\r\n\r\n        context._setExecutionVariable(this, \"activationState\", activationState.slice());\r\n\r\n        if (activationState.every((value: boolean) => value)) {\r\n            this.onDone._activateSignal(context);\r\n            for (let i = 0; i < this.config.numberInputFlows; i++) {\r\n                activationState[i] = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"FGWaitAllBlock\";\r\n    }\r\n}\r\nRegisterClass(\"FGWaitAllBlock\", FlowGraphWaitAllBlock);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}