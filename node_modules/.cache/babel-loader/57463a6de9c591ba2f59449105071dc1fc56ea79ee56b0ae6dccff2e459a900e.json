{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nimport { WebGPUEngine } from \"../../webgpuEngine.js\";\nWebGPUEngine.prototype.unBindMultiColorAttachmentFramebuffer = function (rtWrapper, disableGenerateMipMaps = false, onBeforeUnbind) {\n  if (onBeforeUnbind) {\n    onBeforeUnbind();\n  }\n  const attachments = rtWrapper._attachments;\n  const count = attachments.length;\n  if (this._currentRenderPass && this._currentRenderPass !== this._mainRenderPassWrapper.renderPass) {\n    this._endRenderTargetRenderPass();\n  }\n  for (let i = 0; i < count; i++) {\n    const texture = rtWrapper.textures[i];\n    if (texture.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\n      this._generateMipmaps(texture);\n    }\n  }\n  this._currentRenderTarget = null;\n  this._mrtAttachments = [];\n  this._cacheRenderPipeline.setMRT([]);\n  this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\n  this._currentRenderPass = this._mainRenderPassWrapper.renderPass;\n  this._setDepthTextureFormat(this._mainRenderPassWrapper);\n  this._setColorFormat(this._mainRenderPassWrapper);\n};\nWebGPUEngine.prototype.createMultipleRenderTarget = function (size, options, initializeBuffers) {\n  var _a, _b;\n  let generateMipMaps = false;\n  let generateDepthBuffer = true;\n  let generateStencilBuffer = false;\n  let generateDepthTexture = false;\n  let depthTextureFormat = 15;\n  let textureCount = 1;\n  const defaultType = 0;\n  const defaultSamplingMode = 3;\n  const defaultUseSRGBBuffer = false;\n  const defaultFormat = 5;\n  const defaultTarget = 3553;\n  let types = new Array();\n  let samplingModes = new Array();\n  let useSRGBBuffers = new Array();\n  let formats = new Array();\n  let targets = new Array();\n  let faceIndex = new Array();\n  let layerIndex = new Array();\n  let layers = new Array();\n  const rtWrapper = this._createHardwareRenderTargetWrapper(true, false, size);\n  if (options !== undefined) {\n    generateMipMaps = options.generateMipMaps === undefined ? false : options.generateMipMaps;\n    generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n    generateStencilBuffer = options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\n    generateDepthTexture = options.generateDepthTexture === undefined ? false : options.generateDepthTexture;\n    textureCount = options.textureCount || 1;\n    depthTextureFormat = (_a = options.depthTextureFormat) !== null && _a !== void 0 ? _a : 15;\n    if (options.types) {\n      types = options.types;\n    }\n    if (options.samplingModes) {\n      samplingModes = options.samplingModes;\n    }\n    if (options.useSRGBBuffers) {\n      useSRGBBuffers = options.useSRGBBuffers;\n    }\n    if (options.formats) {\n      formats = options.formats;\n    }\n    if (options.targetTypes) {\n      targets = options.targetTypes;\n    }\n    if (options.faceIndex) {\n      faceIndex = options.faceIndex;\n    }\n    if (options.layerIndex) {\n      layerIndex = options.layerIndex;\n    }\n    if (options.layerCounts) {\n      layers = options.layerCounts;\n    }\n  }\n  const width = size.width || size;\n  const height = size.height || size;\n  let depthStencilTexture = null;\n  if (generateDepthBuffer || generateStencilBuffer || generateDepthTexture) {\n    if (!generateDepthTexture) {\n      // The caller doesn't want a depth texture, so we are free to use the depth texture format we want.\n      // So, we will align with what the WebGL engine does\n      if (generateDepthBuffer && generateStencilBuffer) {\n        depthTextureFormat = 13;\n      } else if (generateDepthBuffer) {\n        depthTextureFormat = 14;\n      } else {\n        depthTextureFormat = 19;\n      }\n    }\n    depthStencilTexture = rtWrapper.createDepthStencilTexture(0, false, generateStencilBuffer, 1, depthTextureFormat);\n  }\n  const textures = [];\n  const attachments = [];\n  const defaultAttachments = [];\n  rtWrapper._generateDepthBuffer = generateDepthBuffer;\n  rtWrapper._generateStencilBuffer = generateStencilBuffer;\n  rtWrapper._attachments = attachments;\n  rtWrapper._defaultAttachments = defaultAttachments;\n  for (let i = 0; i < textureCount; i++) {\n    let samplingMode = samplingModes[i] || defaultSamplingMode;\n    let type = types[i] || defaultType;\n    const format = formats[i] || defaultFormat;\n    const useSRGBBuffer = (useSRGBBuffers[i] || defaultUseSRGBBuffer) && this._caps.supportSRGBBuffers;\n    const target = targets[i] || defaultTarget;\n    const layerCount = (_b = layers[i]) !== null && _b !== void 0 ? _b : 1;\n    if (type === 1 && !this._caps.textureFloatLinearFiltering) {\n      // if floating point linear (FLOAT) then force to NEAREST_SAMPLINGMODE\n      samplingMode = 1;\n    } else if (type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\n      // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\n      samplingMode = 1;\n    }\n    if (type === 1 && !this._caps.textureFloat) {\n      type = 0;\n      Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\n    }\n    attachments.push(i + 1);\n    defaultAttachments.push(initializeBuffers ? i + 1 : i === 0 ? 1 : 0);\n    if (target === -1) {\n      continue;\n    }\n    const texture = new InternalTexture(this, InternalTextureSource.MultiRenderTarget);\n    textures[i] = texture;\n    switch (target) {\n      case 34067:\n        texture.isCube = true;\n        break;\n      case 32879:\n        texture.is3D = true;\n        texture.baseDepth = texture.depth = layerCount;\n        break;\n      case 35866:\n        texture.is2DArray = true;\n        texture.baseDepth = texture.depth = layerCount;\n        break;\n    }\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = width;\n    texture.height = height;\n    texture.isReady = true;\n    texture.samples = 1;\n    texture.generateMipMaps = generateMipMaps;\n    texture.samplingMode = samplingMode;\n    texture.type = type;\n    texture._cachedWrapU = 0;\n    texture._cachedWrapV = 0;\n    texture._useSRGBBuffer = useSRGBBuffer;\n    texture.format = format;\n    this._internalTexturesCache.push(texture);\n    this._textureHelper.createGPUTextureForInternalTexture(texture);\n  }\n  if (depthStencilTexture) {\n    depthStencilTexture.incrementReferences();\n    textures[textureCount] = depthStencilTexture;\n    this._internalTexturesCache.push(depthStencilTexture);\n  }\n  rtWrapper.setTextures(textures);\n  rtWrapper.setLayerAndFaceIndices(layerIndex, faceIndex);\n  return rtWrapper;\n};\nWebGPUEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function (rtWrapper, samples) {\n  if (!rtWrapper || !rtWrapper.textures || rtWrapper.textures[0].samples === samples) {\n    return samples;\n  }\n  const count = rtWrapper.textures.length;\n  if (count === 0) {\n    return 1;\n  }\n  samples = Math.min(samples, this.getCaps().maxMSAASamples);\n  for (let i = 0; i < count; ++i) {\n    const texture = rtWrapper.textures[i];\n    const gpuTextureWrapper = texture._hardwareTexture;\n    gpuTextureWrapper === null || gpuTextureWrapper === void 0 ? void 0 : gpuTextureWrapper.releaseMSAATexture();\n  }\n  // Note that rtWrapper.textures can't have null textures, lastTextureIsDepthTexture can't be true if rtWrapper._depthStencilTexture is null\n  const lastTextureIsDepthTexture = rtWrapper._depthStencilTexture === rtWrapper.textures[count - 1];\n  for (let i = 0; i < count; ++i) {\n    const texture = rtWrapper.textures[i];\n    this._textureHelper.createMSAATexture(texture, samples, false, i === count - 1 && lastTextureIsDepthTexture ? 0 : i);\n    texture.samples = samples;\n  }\n  // Note that the last texture of textures is the depth texture if the depth texture has been generated by the MRT class and so the MSAA texture\n  // will be recreated for this texture by the loop above: in that case, there's no need to create the MSAA texture for rtWrapper._depthStencilTexture\n  // because rtWrapper._depthStencilTexture is the same texture than the depth texture\n  if (rtWrapper._depthStencilTexture && !lastTextureIsDepthTexture) {\n    this._textureHelper.createMSAATexture(rtWrapper._depthStencilTexture, samples);\n    rtWrapper._depthStencilTexture.samples = samples;\n  }\n  return samples;\n};\nWebGPUEngine.prototype.bindAttachments = function (attachments) {\n  if (attachments.length === 0 || !this._currentRenderTarget) {\n    return;\n  }\n  this._mrtAttachments = attachments;\n  if (this._currentRenderPass) {\n    // the render pass has already been created, we need to call setMRTAttachments to update the state of the attachments\n    this._cacheRenderPipeline.setMRTAttachments(attachments);\n  } else {\n    // the render pass is not created yet so we don't need to call setMRTAttachments: it will be called as part of the render pass creation (see WebGPUEngine._startRenderTargetRenderPass)\n  }\n};\nWebGPUEngine.prototype.buildTextureLayout = function (textureStatus) {\n  const result = [];\n  for (let i = 0; i < textureStatus.length; i++) {\n    if (textureStatus[i]) {\n      result.push(i + 1);\n    } else {\n      result.push(0);\n    }\n  }\n  return result;\n};\nWebGPUEngine.prototype.restoreSingleAttachment = function () {\n  // not sure what to do, probably nothing... This function and restoreSingleAttachmentForRenderTarget are not called in Babylon.js so it's hard to know the use case\n};\nWebGPUEngine.prototype.restoreSingleAttachmentForRenderTarget = function () {\n  // not sure what to do, probably nothing... This function and restoreSingleAttachment are not called in Babylon.js so it's hard to know the use case\n};","map":{"version":3,"names":["InternalTexture","InternalTextureSource","Logger","WebGPUEngine","prototype","unBindMultiColorAttachmentFramebuffer","rtWrapper","disableGenerateMipMaps","onBeforeUnbind","attachments","_attachments","count","length","_currentRenderPass","_mainRenderPassWrapper","renderPass","_endRenderTargetRenderPass","i","texture","textures","generateMipMaps","isCube","_generateMipmaps","_currentRenderTarget","_mrtAttachments","_cacheRenderPipeline","setMRT","setMRTAttachments","_setDepthTextureFormat","_setColorFormat","createMultipleRenderTarget","size","options","initializeBuffers","generateDepthBuffer","generateStencilBuffer","generateDepthTexture","depthTextureFormat","textureCount","defaultType","defaultSamplingMode","defaultUseSRGBBuffer","defaultFormat","defaultTarget","types","Array","samplingModes","useSRGBBuffers","formats","targets","faceIndex","layerIndex","layers","_createHardwareRenderTargetWrapper","undefined","_a","targetTypes","layerCounts","width","height","depthStencilTexture","createDepthStencilTexture","defaultAttachments","_generateDepthBuffer","_generateStencilBuffer","_defaultAttachments","samplingMode","type","format","useSRGBBuffer","_caps","supportSRGBBuffers","target","layerCount","_b","textureFloatLinearFiltering","textureHalfFloatLinearFiltering","textureFloat","Warn","push","MultiRenderTarget","is3D","baseDepth","depth","is2DArray","baseWidth","baseHeight","isReady","samples","_cachedWrapU","_cachedWrapV","_useSRGBBuffer","_internalTexturesCache","_textureHelper","createGPUTextureForInternalTexture","incrementReferences","setTextures","setLayerAndFaceIndices","updateMultipleRenderTargetTextureSampleCount","Math","min","getCaps","maxMSAASamples","gpuTextureWrapper","_hardwareTexture","releaseMSAATexture","lastTextureIsDepthTexture","_depthStencilTexture","createMSAATexture","bindAttachments","buildTextureLayout","textureStatus","result","restoreSingleAttachment","restoreSingleAttachmentForRenderTarget"],"sources":["../../../../../../dev/core/src/Engines/WebGPU/Extensions/engine.multiRender.ts"],"sourcesContent":["import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IMultiRenderTargetOptions } from \"../../../Materials/Textures/multiRenderTarget\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport type { TextureSize } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport type { RenderTargetWrapper } from \"../../renderTargetWrapper\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport type { WebGPURenderTargetWrapper } from \"../webgpuRenderTargetWrapper\";\r\nimport type { WebGPUHardwareTexture } from \"../webgpuHardwareTexture\";\r\n\r\nWebGPUEngine.prototype.unBindMultiColorAttachmentFramebuffer = function (\r\n    rtWrapper: RenderTargetWrapper,\r\n    disableGenerateMipMaps: boolean = false,\r\n    onBeforeUnbind?: () => void\r\n): void {\r\n    if (onBeforeUnbind) {\r\n        onBeforeUnbind();\r\n    }\r\n\r\n    const attachments = rtWrapper._attachments!;\r\n    const count = attachments.length;\r\n\r\n    if (this._currentRenderPass && this._currentRenderPass !== this._mainRenderPassWrapper.renderPass) {\r\n        this._endRenderTargetRenderPass();\r\n    }\r\n\r\n    for (let i = 0; i < count; i++) {\r\n        const texture = rtWrapper.textures![i];\r\n        if (texture.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\r\n            this._generateMipmaps(texture);\r\n        }\r\n    }\r\n\r\n    this._currentRenderTarget = null;\r\n\r\n    this._mrtAttachments = [];\r\n    this._cacheRenderPipeline.setMRT([]);\r\n    this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\r\n    this._currentRenderPass = this._mainRenderPassWrapper.renderPass;\r\n    this._setDepthTextureFormat(this._mainRenderPassWrapper);\r\n    this._setColorFormat(this._mainRenderPassWrapper);\r\n};\r\n\r\nWebGPUEngine.prototype.createMultipleRenderTarget = function (size: TextureSize, options: IMultiRenderTargetOptions, initializeBuffers?: boolean): RenderTargetWrapper {\r\n    let generateMipMaps = false;\r\n    let generateDepthBuffer = true;\r\n    let generateStencilBuffer = false;\r\n    let generateDepthTexture = false;\r\n    let depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH16;\r\n    let textureCount = 1;\r\n\r\n    const defaultType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n    const defaultSamplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n    const defaultUseSRGBBuffer = false;\r\n    const defaultFormat = Constants.TEXTUREFORMAT_RGBA;\r\n    const defaultTarget = Constants.TEXTURE_2D;\r\n\r\n    let types = new Array<number>();\r\n    let samplingModes = new Array<number>();\r\n    let useSRGBBuffers = new Array<boolean>();\r\n    let formats = new Array<number>();\r\n    let targets = new Array<number>();\r\n    let faceIndex = new Array<number>();\r\n    let layerIndex = new Array<number>();\r\n    let layers = new Array<number>();\r\n\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(true, false, size) as WebGPURenderTargetWrapper;\r\n\r\n    if (options !== undefined) {\r\n        generateMipMaps = options.generateMipMaps === undefined ? false : options.generateMipMaps;\r\n        generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\r\n        generateStencilBuffer = options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\r\n        generateDepthTexture = options.generateDepthTexture === undefined ? false : options.generateDepthTexture;\r\n        textureCount = options.textureCount || 1;\r\n        depthTextureFormat = options.depthTextureFormat ?? Constants.TEXTUREFORMAT_DEPTH16;\r\n\r\n        if (options.types) {\r\n            types = options.types;\r\n        }\r\n        if (options.samplingModes) {\r\n            samplingModes = options.samplingModes;\r\n        }\r\n        if (options.useSRGBBuffers) {\r\n            useSRGBBuffers = options.useSRGBBuffers;\r\n        }\r\n        if (options.formats) {\r\n            formats = options.formats;\r\n        }\r\n        if (options.targetTypes) {\r\n            targets = options.targetTypes;\r\n        }\r\n        if (options.faceIndex) {\r\n            faceIndex = options.faceIndex;\r\n        }\r\n        if (options.layerIndex) {\r\n            layerIndex = options.layerIndex;\r\n        }\r\n        if (options.layerCounts) {\r\n            layers = options.layerCounts;\r\n        }\r\n    }\r\n\r\n    const width = (<{ width: number; height: number }>size).width || <number>size;\r\n    const height = (<{ width: number; height: number }>size).height || <number>size;\r\n\r\n    let depthStencilTexture = null;\r\n    if (generateDepthBuffer || generateStencilBuffer || generateDepthTexture) {\r\n        if (!generateDepthTexture) {\r\n            // The caller doesn't want a depth texture, so we are free to use the depth texture format we want.\r\n            // So, we will align with what the WebGL engine does\r\n            if (generateDepthBuffer && generateStencilBuffer) {\r\n                depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH24_STENCIL8;\r\n            } else if (generateDepthBuffer) {\r\n                depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH32_FLOAT;\r\n            } else {\r\n                depthTextureFormat = Constants.TEXTUREFORMAT_STENCIL8;\r\n            }\r\n        }\r\n        depthStencilTexture = rtWrapper.createDepthStencilTexture(0, false, generateStencilBuffer, 1, depthTextureFormat);\r\n    }\r\n\r\n    const textures: InternalTexture[] = [];\r\n    const attachments: number[] = [];\r\n    const defaultAttachments: number[] = [];\r\n\r\n    rtWrapper._generateDepthBuffer = generateDepthBuffer;\r\n    rtWrapper._generateStencilBuffer = generateStencilBuffer;\r\n    rtWrapper._attachments = attachments;\r\n    rtWrapper._defaultAttachments = defaultAttachments;\r\n\r\n    for (let i = 0; i < textureCount; i++) {\r\n        let samplingMode = samplingModes[i] || defaultSamplingMode;\r\n        let type = types[i] || defaultType;\r\n\r\n        const format = formats[i] || defaultFormat;\r\n        const useSRGBBuffer = (useSRGBBuffers[i] || defaultUseSRGBBuffer) && this._caps.supportSRGBBuffers;\r\n\r\n        const target = targets[i] || defaultTarget;\r\n        const layerCount = layers[i] ?? 1;\r\n\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n            // if floating point linear (FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n            // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\r\n            type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n            Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\r\n        }\r\n\r\n        attachments.push(i + 1);\r\n        defaultAttachments.push(initializeBuffers ? i + 1 : i === 0 ? 1 : 0);\r\n\r\n        if (target === -1) {\r\n            continue;\r\n        }\r\n\r\n        const texture = new InternalTexture(this, InternalTextureSource.MultiRenderTarget);\r\n        textures[i] = texture;\r\n\r\n        switch (target) {\r\n            case Constants.TEXTURE_CUBE_MAP:\r\n                texture.isCube = true;\r\n                break;\r\n            case Constants.TEXTURE_3D:\r\n                texture.is3D = true;\r\n                texture.baseDepth = texture.depth = layerCount;\r\n                break;\r\n            case Constants.TEXTURE_2D_ARRAY:\r\n                texture.is2DArray = true;\r\n                texture.baseDepth = texture.depth = layerCount;\r\n                break;\r\n        }\r\n\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.isReady = true;\r\n        texture.samples = 1;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        texture.type = type;\r\n        texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        texture._useSRGBBuffer = useSRGBBuffer;\r\n        texture.format = format;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n    }\r\n\r\n    if (depthStencilTexture) {\r\n        depthStencilTexture.incrementReferences();\r\n        textures[textureCount] = depthStencilTexture;\r\n        this._internalTexturesCache.push(depthStencilTexture);\r\n    }\r\n\r\n    rtWrapper.setTextures(textures);\r\n    rtWrapper.setLayerAndFaceIndices(layerIndex, faceIndex);\r\n\r\n    return rtWrapper;\r\n};\r\n\r\nWebGPUEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function (rtWrapper: Nullable<RenderTargetWrapper>, samples: number): number {\r\n    if (!rtWrapper || !rtWrapper.textures || rtWrapper.textures[0].samples === samples) {\r\n        return samples;\r\n    }\r\n\r\n    const count = rtWrapper.textures.length;\r\n\r\n    if (count === 0) {\r\n        return 1;\r\n    }\r\n\r\n    samples = Math.min(samples, this.getCaps().maxMSAASamples);\r\n\r\n    for (let i = 0; i < count; ++i) {\r\n        const texture = rtWrapper.textures[i];\r\n        const gpuTextureWrapper = texture._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        gpuTextureWrapper?.releaseMSAATexture();\r\n    }\r\n\r\n    // Note that rtWrapper.textures can't have null textures, lastTextureIsDepthTexture can't be true if rtWrapper._depthStencilTexture is null\r\n    const lastTextureIsDepthTexture = rtWrapper._depthStencilTexture === rtWrapper.textures[count - 1];\r\n\r\n    for (let i = 0; i < count; ++i) {\r\n        const texture = rtWrapper.textures[i];\r\n        this._textureHelper.createMSAATexture(texture, samples, false, i === count - 1 && lastTextureIsDepthTexture ? 0 : i);\r\n        texture.samples = samples;\r\n    }\r\n\r\n    // Note that the last texture of textures is the depth texture if the depth texture has been generated by the MRT class and so the MSAA texture\r\n    // will be recreated for this texture by the loop above: in that case, there's no need to create the MSAA texture for rtWrapper._depthStencilTexture\r\n    // because rtWrapper._depthStencilTexture is the same texture than the depth texture\r\n    if (rtWrapper._depthStencilTexture && !lastTextureIsDepthTexture) {\r\n        this._textureHelper.createMSAATexture(rtWrapper._depthStencilTexture, samples);\r\n        rtWrapper._depthStencilTexture.samples = samples;\r\n    }\r\n\r\n    return samples;\r\n};\r\n\r\nWebGPUEngine.prototype.bindAttachments = function (attachments: number[]): void {\r\n    if (attachments.length === 0 || !this._currentRenderTarget) {\r\n        return;\r\n    }\r\n\r\n    this._mrtAttachments = attachments;\r\n    if (this._currentRenderPass) {\r\n        // the render pass has already been created, we need to call setMRTAttachments to update the state of the attachments\r\n        this._cacheRenderPipeline.setMRTAttachments(attachments);\r\n    } else {\r\n        // the render pass is not created yet so we don't need to call setMRTAttachments: it will be called as part of the render pass creation (see WebGPUEngine._startRenderTargetRenderPass)\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype.buildTextureLayout = function (textureStatus: boolean[]): number[] {\r\n    const result = [];\r\n\r\n    for (let i = 0; i < textureStatus.length; i++) {\r\n        if (textureStatus[i]) {\r\n            result.push(i + 1);\r\n        } else {\r\n            result.push(0);\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nWebGPUEngine.prototype.restoreSingleAttachment = function (): void {\r\n    // not sure what to do, probably nothing... This function and restoreSingleAttachmentForRenderTarget are not called in Babylon.js so it's hard to know the use case\r\n};\r\n\r\nWebGPUEngine.prototype.restoreSingleAttachmentForRenderTarget = function (): void {\r\n    // not sure what to do, probably nothing... This function and restoreSingleAttachment are not called in Babylon.js so it's hard to know the use case\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}