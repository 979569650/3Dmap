{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Quaternion, Vector3, Vector2, Matrix } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Animation } from \"./animation.js\";\nimport { Size } from \"../Maths/math.size.js\";\n// Static values to help the garbage collector\n// Quaternion\nconst _staticOffsetValueQuaternion = Object.freeze(new Quaternion(0, 0, 0, 0));\n// Vector3\nconst _staticOffsetValueVector3 = Object.freeze(Vector3.Zero());\n// Vector2\nconst _staticOffsetValueVector2 = Object.freeze(Vector2.Zero());\n// Size\nconst _staticOffsetValueSize = Object.freeze(Size.Zero());\n// Color3\nconst _staticOffsetValueColor3 = Object.freeze(Color3.Black());\n/**\n * Defines a runtime animation\n */\nexport class RuntimeAnimation {\n  /**\n   * Gets the current frame of the runtime animation\n   */\n  get currentFrame() {\n    return this._currentFrame;\n  }\n  /**\n   * Gets the weight of the runtime animation\n   */\n  get weight() {\n    return this._weight;\n  }\n  /**\n   * Gets the current value of the runtime animation\n   */\n  get currentValue() {\n    return this._currentValue;\n  }\n  /**\n   * Gets or sets the target path of the runtime animation\n   */\n  get targetPath() {\n    return this._targetPath;\n  }\n  /**\n   * Gets the actual target of the runtime animation\n   */\n  get target() {\n    return this._currentActiveTarget;\n  }\n  /**\n   * Gets the additive state of the runtime animation\n   */\n  get isAdditive() {\n    return this._host && this._host.isAdditive;\n  }\n  /**\n   * Create a new RuntimeAnimation object\n   * @param target defines the target of the animation\n   * @param animation defines the source animation object\n   * @param scene defines the hosting scene\n   * @param host defines the initiating Animatable\n   */\n  constructor(target, animation, scene, host) {\n    this._events = new Array();\n    /**\n     * The current frame of the runtime animation\n     */\n    this._currentFrame = 0;\n    /**\n     * The original value of the runtime animation\n     */\n    this._originalValue = new Array();\n    /**\n     * The original blend value of the runtime animation\n     */\n    this._originalBlendValue = null;\n    /**\n     * The offsets cache of the runtime animation\n     */\n    this._offsetsCache = {};\n    /**\n     * The high limits cache of the runtime animation\n     */\n    this._highLimitsCache = {};\n    /**\n     * Specifies if the runtime animation has been stopped\n     */\n    this._stopped = false;\n    /**\n     * The blending factor of the runtime animation\n     */\n    this._blendingFactor = 0;\n    /**\n     * The current value of the runtime animation\n     */\n    this._currentValue = null;\n    this._currentActiveTarget = null;\n    this._directTarget = null;\n    /**\n     * The target path of the runtime animation\n     */\n    this._targetPath = \"\";\n    /**\n     * The weight of the runtime animation\n     */\n    this._weight = 1.0;\n    /**\n     * The absolute frame offset of the runtime animation\n     */\n    this._absoluteFrameOffset = 0;\n    /**\n     * The previous elapsed time (since start of animation) of the runtime animation\n     */\n    this._previousElapsedTime = 0;\n    /**\n     * The previous absolute frame of the runtime animation (meaning, without taking into account the from/to values, only the elapsed time and the fps)\n     */\n    this._previousAbsoluteFrame = 0;\n    this._targetIsArray = false;\n    this._animation = animation;\n    this._target = target;\n    this._scene = scene;\n    this._host = host;\n    this._activeTargets = [];\n    animation._runtimeAnimations.push(this);\n    // State\n    this._animationState = {\n      key: 0,\n      repeatCount: 0,\n      loopMode: this._getCorrectLoopMode()\n    };\n    if (this._animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\n      this._animationState.workValue = Matrix.Zero();\n    }\n    // Limits\n    this._keys = this._animation.getKeys();\n    this._minFrame = this._keys[0].frame;\n    this._maxFrame = this._keys[this._keys.length - 1].frame;\n    this._minValue = this._keys[0].value;\n    this._maxValue = this._keys[this._keys.length - 1].value;\n    // Add a start key at frame 0 if missing\n    if (this._minFrame !== 0) {\n      const newKey = {\n        frame: 0,\n        value: this._minValue\n      };\n      this._keys.splice(0, 0, newKey);\n    }\n    // Check data\n    if (this._target instanceof Array) {\n      let index = 0;\n      for (const target of this._target) {\n        this._preparePath(target, index);\n        this._getOriginalValues(index);\n        index++;\n      }\n      this._targetIsArray = true;\n    } else {\n      this._preparePath(this._target);\n      this._getOriginalValues();\n      this._targetIsArray = false;\n      this._directTarget = this._activeTargets[0];\n    }\n    // Cloning events locally\n    const events = animation.getEvents();\n    if (events && events.length > 0) {\n      events.forEach(e => {\n        this._events.push(e._clone());\n      });\n    }\n    this._enableBlending = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.enableBlending : this._animation.enableBlending;\n  }\n  _preparePath(target, targetIndex = 0) {\n    const targetPropertyPath = this._animation.targetPropertyPath;\n    if (targetPropertyPath.length > 1) {\n      let property = target[targetPropertyPath[0]];\n      for (let index = 1; index < targetPropertyPath.length - 1; index++) {\n        property = property[targetPropertyPath[index]];\n      }\n      this._targetPath = targetPropertyPath[targetPropertyPath.length - 1];\n      this._activeTargets[targetIndex] = property;\n    } else {\n      this._targetPath = targetPropertyPath[0];\n      this._activeTargets[targetIndex] = target;\n    }\n  }\n  /**\n   * Gets the animation from the runtime animation\n   */\n  get animation() {\n    return this._animation;\n  }\n  /**\n   * Resets the runtime animation to the beginning\n   * @param restoreOriginal defines whether to restore the target property to the original value\n   */\n  reset(restoreOriginal = false) {\n    if (restoreOriginal) {\n      if (this._target instanceof Array) {\n        let index = 0;\n        for (const target of this._target) {\n          if (this._originalValue[index] !== undefined) {\n            this._setValue(target, this._activeTargets[index], this._originalValue[index], -1, index);\n          }\n          index++;\n        }\n      } else {\n        if (this._originalValue[0] !== undefined) {\n          this._setValue(this._target, this._directTarget, this._originalValue[0], -1, 0);\n        }\n      }\n    }\n    this._offsetsCache = {};\n    this._highLimitsCache = {};\n    this._currentFrame = 0;\n    this._blendingFactor = 0;\n    // Events\n    for (let index = 0; index < this._events.length; index++) {\n      this._events[index].isDone = false;\n    }\n  }\n  /**\n   * Specifies if the runtime animation is stopped\n   * @returns Boolean specifying if the runtime animation is stopped\n   */\n  isStopped() {\n    return this._stopped;\n  }\n  /**\n   * Disposes of the runtime animation\n   */\n  dispose() {\n    const index = this._animation.runtimeAnimations.indexOf(this);\n    if (index > -1) {\n      this._animation.runtimeAnimations.splice(index, 1);\n    }\n  }\n  /**\n   * Apply the interpolated value to the target\n   * @param currentValue defines the value computed by the animation\n   * @param weight defines the weight to apply to this value (Defaults to 1.0)\n   */\n  setValue(currentValue, weight) {\n    if (this._targetIsArray) {\n      for (let index = 0; index < this._target.length; index++) {\n        const target = this._target[index];\n        this._setValue(target, this._activeTargets[index], currentValue, weight, index);\n      }\n      return;\n    }\n    this._setValue(this._target, this._directTarget, currentValue, weight, 0);\n  }\n  _getOriginalValues(targetIndex = 0) {\n    let originalValue;\n    const target = this._activeTargets[targetIndex];\n    if (target.getLocalMatrix && this._targetPath === \"_matrix\") {\n      // For bones\n      originalValue = target.getLocalMatrix();\n    } else {\n      originalValue = target[this._targetPath];\n    }\n    if (originalValue && originalValue.clone) {\n      this._originalValue[targetIndex] = originalValue.clone();\n    } else {\n      this._originalValue[targetIndex] = originalValue;\n    }\n  }\n  _setValue(target, destination, currentValue, weight, targetIndex) {\n    // Set value\n    this._currentActiveTarget = destination;\n    this._weight = weight;\n    if (this._enableBlending && this._blendingFactor <= 1.0) {\n      if (!this._originalBlendValue) {\n        const originalValue = destination[this._targetPath];\n        if (originalValue.clone) {\n          this._originalBlendValue = originalValue.clone();\n        } else {\n          this._originalBlendValue = originalValue;\n        }\n      }\n      if (this._originalBlendValue.m) {\n        // Matrix\n        if (Animation.AllowMatrixDecomposeForInterpolation) {\n          if (this._currentValue) {\n            Matrix.DecomposeLerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\n          } else {\n            this._currentValue = Matrix.DecomposeLerp(this._originalBlendValue, currentValue, this._blendingFactor);\n          }\n        } else {\n          if (this._currentValue) {\n            Matrix.LerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\n          } else {\n            this._currentValue = Matrix.Lerp(this._originalBlendValue, currentValue, this._blendingFactor);\n          }\n        }\n      } else {\n        this._currentValue = Animation._UniversalLerp(this._originalBlendValue, currentValue, this._blendingFactor);\n      }\n      const blendingSpeed = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.blendingSpeed : this._animation.blendingSpeed;\n      this._blendingFactor += blendingSpeed;\n    } else {\n      if (!this._currentValue) {\n        if (currentValue === null || currentValue === void 0 ? void 0 : currentValue.clone) {\n          this._currentValue = currentValue.clone();\n        } else {\n          this._currentValue = currentValue;\n        }\n      } else if (this._currentValue.copyFrom) {\n        this._currentValue.copyFrom(currentValue);\n      } else {\n        this._currentValue = currentValue;\n      }\n    }\n    if (weight !== -1.0) {\n      this._scene._registerTargetForLateAnimationBinding(this, this._originalValue[targetIndex]);\n    } else {\n      destination[this._targetPath] = this._currentValue;\n    }\n    if (target.markAsDirty) {\n      target.markAsDirty(this._animation.targetProperty);\n    }\n  }\n  /**\n   * Gets the loop pmode of the runtime animation\n   * @returns Loop Mode\n   */\n  _getCorrectLoopMode() {\n    if (this._target && this._target.animationPropertiesOverride) {\n      return this._target.animationPropertiesOverride.loopMode;\n    }\n    return this._animation.loopMode;\n  }\n  /**\n   * Move the current animation to a given frame\n   * @param frame defines the frame to move to\n   */\n  goToFrame(frame) {\n    const keys = this._animation.getKeys();\n    if (frame < keys[0].frame) {\n      frame = keys[0].frame;\n    } else if (frame > keys[keys.length - 1].frame) {\n      frame = keys[keys.length - 1].frame;\n    }\n    // Need to reset animation events\n    const events = this._events;\n    if (events.length) {\n      for (let index = 0; index < events.length; index++) {\n        if (!events[index].onlyOnce) {\n          // reset events in the future\n          events[index].isDone = events[index].frame < frame;\n        }\n      }\n    }\n    this._currentFrame = frame;\n    const currentValue = this._animation._interpolate(frame, this._animationState);\n    this.setValue(currentValue, -1);\n  }\n  /**\n   * @internal Internal use only\n   */\n  _prepareForSpeedRatioChange(newSpeedRatio) {\n    const newAbsoluteFrame = this._previousElapsedTime * (this._animation.framePerSecond * newSpeedRatio) / 1000.0;\n    this._absoluteFrameOffset = this._previousAbsoluteFrame - newAbsoluteFrame;\n  }\n  /**\n   * Execute the current animation\n   * @param elapsedTimeSinceAnimationStart defines the elapsed time (in milliseconds) since the animation was started\n   * @param from defines the lower frame of the animation range\n   * @param to defines the upper frame of the animation range\n   * @param loop defines if the current animation must loop\n   * @param speedRatio defines the current speed ratio\n   * @param weight defines the weight of the animation (default is -1 so no weight)\n   * @returns a boolean indicating if the animation is running\n   */\n  animate(elapsedTimeSinceAnimationStart, from, to, loop, speedRatio, weight = -1.0) {\n    const animation = this._animation;\n    const targetPropertyPath = animation.targetPropertyPath;\n    if (!targetPropertyPath || targetPropertyPath.length < 1) {\n      this._stopped = true;\n      return false;\n    }\n    let returnValue = true;\n    // Check limits\n    if (from < this._minFrame || from > this._maxFrame) {\n      from = this._minFrame;\n    }\n    if (to < this._minFrame || to > this._maxFrame) {\n      to = this._maxFrame;\n    }\n    const frameRange = to - from;\n    let offsetValue;\n    // Compute the frame according to the elapsed time and the fps of the animation (\"from\" and \"to\" are not factored in!)\n    let absoluteFrame = elapsedTimeSinceAnimationStart * (animation.framePerSecond * speedRatio) / 1000.0 + this._absoluteFrameOffset;\n    let highLimitValue = 0;\n    // Apply the yoyo function if required\n    if (loop && this._animationState.loopMode === Animation.ANIMATIONLOOPMODE_YOYO) {\n      const position = (absoluteFrame - from) / frameRange;\n      // Apply the yoyo curve\n      const yoyoPosition = Math.abs(Math.sin(position * Math.PI));\n      // Map the yoyo position back to the range\n      absoluteFrame = yoyoPosition * frameRange + from;\n    }\n    this._previousElapsedTime = elapsedTimeSinceAnimationStart;\n    this._previousAbsoluteFrame = absoluteFrame;\n    if (!loop && to >= from && absoluteFrame >= frameRange) {\n      // If we are out of range and not looping get back to caller\n      returnValue = false;\n      highLimitValue = animation._getKeyValue(this._maxValue);\n    } else if (!loop && from >= to && absoluteFrame <= frameRange) {\n      returnValue = false;\n      highLimitValue = animation._getKeyValue(this._minValue);\n    } else if (this._animationState.loopMode !== Animation.ANIMATIONLOOPMODE_CYCLE) {\n      const keyOffset = to.toString() + from.toString();\n      if (!this._offsetsCache[keyOffset]) {\n        this._animationState.repeatCount = 0;\n        this._animationState.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE; // force a specific codepath in animation._interpolate()!\n        const fromValue = animation._interpolate(from, this._animationState);\n        const toValue = animation._interpolate(to, this._animationState);\n        this._animationState.loopMode = this._getCorrectLoopMode();\n        switch (animation.dataType) {\n          // Float\n          case Animation.ANIMATIONTYPE_FLOAT:\n            this._offsetsCache[keyOffset] = toValue - fromValue;\n            break;\n          // Quaternion\n          case Animation.ANIMATIONTYPE_QUATERNION:\n            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n            break;\n          // Vector3\n          case Animation.ANIMATIONTYPE_VECTOR3:\n            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n            break;\n          // Vector2\n          case Animation.ANIMATIONTYPE_VECTOR2:\n            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n            break;\n          // Size\n          case Animation.ANIMATIONTYPE_SIZE:\n            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n            break;\n          // Color3\n          case Animation.ANIMATIONTYPE_COLOR3:\n            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n            break;\n          default:\n            break;\n        }\n        this._highLimitsCache[keyOffset] = toValue;\n      }\n      highLimitValue = this._highLimitsCache[keyOffset];\n      offsetValue = this._offsetsCache[keyOffset];\n    }\n    if (offsetValue === undefined) {\n      switch (animation.dataType) {\n        // Float\n        case Animation.ANIMATIONTYPE_FLOAT:\n          offsetValue = 0;\n          break;\n        // Quaternion\n        case Animation.ANIMATIONTYPE_QUATERNION:\n          offsetValue = _staticOffsetValueQuaternion;\n          break;\n        // Vector3\n        case Animation.ANIMATIONTYPE_VECTOR3:\n          offsetValue = _staticOffsetValueVector3;\n          break;\n        // Vector2\n        case Animation.ANIMATIONTYPE_VECTOR2:\n          offsetValue = _staticOffsetValueVector2;\n          break;\n        // Size\n        case Animation.ANIMATIONTYPE_SIZE:\n          offsetValue = _staticOffsetValueSize;\n          break;\n        // Color3\n        case Animation.ANIMATIONTYPE_COLOR3:\n          offsetValue = _staticOffsetValueColor3;\n      }\n    }\n    // Compute value\n    let currentFrame;\n    if (this._host && this._host.syncRoot) {\n      // If we must sync with an animatable, calculate the current frame based on the frame of the root animatable\n      const syncRoot = this._host.syncRoot;\n      const hostNormalizedFrame = (syncRoot.masterFrame - syncRoot.fromFrame) / (syncRoot.toFrame - syncRoot.fromFrame);\n      currentFrame = from + frameRange * hostNormalizedFrame;\n    } else {\n      if (absoluteFrame > 0 && from > to || absoluteFrame < 0 && from < to) {\n        currentFrame = returnValue && frameRange !== 0 ? to + absoluteFrame % frameRange : from;\n      } else {\n        currentFrame = returnValue && frameRange !== 0 ? from + absoluteFrame % frameRange : to;\n      }\n    }\n    const events = this._events;\n    // Reset event/state if looping\n    if (speedRatio > 0 && this.currentFrame > currentFrame || speedRatio < 0 && this.currentFrame < currentFrame) {\n      this._onLoop();\n      // Need to reset animation events\n      for (let index = 0; index < events.length; index++) {\n        if (!events[index].onlyOnce) {\n          // reset event, the animation is looping\n          events[index].isDone = false;\n        }\n      }\n      this._animationState.key = speedRatio > 0 ? 0 : animation.getKeys().length - 1;\n    }\n    this._currentFrame = currentFrame;\n    this._animationState.repeatCount = frameRange === 0 ? 0 : absoluteFrame / frameRange >> 0;\n    this._animationState.highLimitValue = highLimitValue;\n    this._animationState.offsetValue = offsetValue;\n    const currentValue = animation._interpolate(currentFrame, this._animationState);\n    // Set value\n    this.setValue(currentValue, weight);\n    // Check events\n    if (events.length) {\n      for (let index = 0; index < events.length; index++) {\n        // Make sure current frame has passed event frame and that event frame is within the current range\n        // Also, handle both forward and reverse animations\n        if (frameRange > 0 && currentFrame >= events[index].frame && events[index].frame >= from || frameRange < 0 && currentFrame <= events[index].frame && events[index].frame <= from) {\n          const event = events[index];\n          if (!event.isDone) {\n            // If event should be done only once, remove it.\n            if (event.onlyOnce) {\n              events.splice(index, 1);\n              index--;\n            }\n            event.isDone = true;\n            event.action(currentFrame);\n          } // Don't do anything if the event has already been done.\n        }\n      }\n    }\n\n    if (!returnValue) {\n      this._stopped = true;\n    }\n    return returnValue;\n  }\n}","map":{"version":3,"names":["Quaternion","Vector3","Vector2","Matrix","Color3","Animation","Size","_staticOffsetValueQuaternion","Object","freeze","_staticOffsetValueVector3","Zero","_staticOffsetValueVector2","_staticOffsetValueSize","_staticOffsetValueColor3","Black","RuntimeAnimation","currentFrame","_currentFrame","weight","_weight","currentValue","_currentValue","targetPath","_targetPath","target","_currentActiveTarget","isAdditive","_host","constructor","animation","scene","host","_events","Array","_originalValue","_originalBlendValue","_offsetsCache","_highLimitsCache","_stopped","_blendingFactor","_directTarget","_absoluteFrameOffset","_previousElapsedTime","_previousAbsoluteFrame","_targetIsArray","_animation","_target","_scene","_activeTargets","_runtimeAnimations","push","_animationState","key","repeatCount","loopMode","_getCorrectLoopMode","dataType","ANIMATIONTYPE_MATRIX","workValue","_keys","getKeys","_minFrame","frame","_maxFrame","length","_minValue","value","_maxValue","newKey","splice","index","_preparePath","_getOriginalValues","events","getEvents","forEach","e","_clone","_enableBlending","animationPropertiesOverride","enableBlending","targetIndex","targetPropertyPath","property","reset","restoreOriginal","undefined","_setValue","isDone","isStopped","dispose","runtimeAnimations","indexOf","setValue","originalValue","getLocalMatrix","clone","destination","m","AllowMatrixDecomposeForInterpolation","DecomposeLerpToRef","DecomposeLerp","LerpToRef","Lerp","_UniversalLerp","blendingSpeed","copyFrom","_registerTargetForLateAnimationBinding","markAsDirty","targetProperty","goToFrame","keys","onlyOnce","_interpolate","_prepareForSpeedRatioChange","newSpeedRatio","newAbsoluteFrame","framePerSecond","animate","elapsedTimeSinceAnimationStart","from","to","loop","speedRatio","returnValue","frameRange","offsetValue","absoluteFrame","highLimitValue","ANIMATIONLOOPMODE_YOYO","position","yoyoPosition","Math","abs","sin","PI","_getKeyValue","ANIMATIONLOOPMODE_CYCLE","keyOffset","toString","fromValue","toValue","ANIMATIONTYPE_FLOAT","ANIMATIONTYPE_QUATERNION","subtract","ANIMATIONTYPE_VECTOR3","ANIMATIONTYPE_VECTOR2","ANIMATIONTYPE_SIZE","ANIMATIONTYPE_COLOR3","syncRoot","hostNormalizedFrame","masterFrame","fromFrame","toFrame","_onLoop","event","action"],"sources":["../../../../dev/core/src/Animations/runtimeAnimation.ts"],"sourcesContent":["import type { DeepImmutable, Nullable } from \"../types\";\r\nimport { Quaternion, Vector3, Vector2, Matrix } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { _IAnimationState } from \"./animation\";\r\nimport { Animation } from \"./animation\";\r\nimport type { AnimationEvent } from \"./animationEvent\";\r\n\r\nimport type { Animatable } from \"./animatable\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport type { IAnimationKey } from \"./animationKey\";\r\nimport { Size } from \"../Maths/math.size\";\r\n\r\n// Static values to help the garbage collector\r\n\r\n// Quaternion\r\nconst _staticOffsetValueQuaternion: DeepImmutable<Quaternion> = Object.freeze(new Quaternion(0, 0, 0, 0));\r\n\r\n// Vector3\r\nconst _staticOffsetValueVector3: DeepImmutable<Vector3> = Object.freeze(Vector3.Zero());\r\n\r\n// Vector2\r\nconst _staticOffsetValueVector2: DeepImmutable<Vector2> = Object.freeze(Vector2.Zero());\r\n\r\n// Size\r\nconst _staticOffsetValueSize: DeepImmutable<Size> = Object.freeze(Size.Zero());\r\n\r\n// Color3\r\nconst _staticOffsetValueColor3: DeepImmutable<Color3> = Object.freeze(Color3.Black());\r\n\r\n/**\r\n * Defines a runtime animation\r\n */\r\nexport class RuntimeAnimation {\r\n    private _events = new Array<AnimationEvent>();\r\n\r\n    /**\r\n     * The current frame of the runtime animation\r\n     */\r\n    private _currentFrame: number = 0;\r\n\r\n    /**\r\n     * The animation used by the runtime animation\r\n     */\r\n    private _animation: Animation;\r\n\r\n    /**\r\n     * The target of the runtime animation\r\n     */\r\n    private _target: any;\r\n\r\n    /**\r\n     * The initiating animatable\r\n     */\r\n    private _host: Animatable;\r\n\r\n    /**\r\n     * The original value of the runtime animation\r\n     */\r\n    private _originalValue = new Array<any>();\r\n\r\n    /**\r\n     * The original blend value of the runtime animation\r\n     */\r\n    private _originalBlendValue: Nullable<any> = null;\r\n\r\n    /**\r\n     * The offsets cache of the runtime animation\r\n     */\r\n    private _offsetsCache: { [key: string]: any } = {};\r\n\r\n    /**\r\n     * The high limits cache of the runtime animation\r\n     */\r\n    private _highLimitsCache: { [key: string]: any } = {};\r\n\r\n    /**\r\n     * Specifies if the runtime animation has been stopped\r\n     */\r\n    private _stopped = false;\r\n\r\n    /**\r\n     * The blending factor of the runtime animation\r\n     */\r\n    private _blendingFactor = 0;\r\n\r\n    /**\r\n     * The BabylonJS scene\r\n     */\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * The current value of the runtime animation\r\n     */\r\n    private _currentValue: Nullable<any> = null;\r\n\r\n    /** @internal */\r\n    public _animationState: _IAnimationState;\r\n\r\n    /**\r\n     * The active target of the runtime animation\r\n     */\r\n    private _activeTargets: any[];\r\n    private _currentActiveTarget: Nullable<any> = null;\r\n    private _directTarget: Nullable<any> = null;\r\n\r\n    /**\r\n     * The target path of the runtime animation\r\n     */\r\n    private _targetPath: string = \"\";\r\n\r\n    /**\r\n     * The weight of the runtime animation\r\n     */\r\n    private _weight = 1.0;\r\n\r\n    /**\r\n     * The absolute frame offset of the runtime animation\r\n     */\r\n    private _absoluteFrameOffset = 0;\r\n\r\n    /**\r\n     * The previous elapsed time (since start of animation) of the runtime animation\r\n     */\r\n    private _previousElapsedTime: number = 0;\r\n\r\n    /**\r\n     * The previous absolute frame of the runtime animation (meaning, without taking into account the from/to values, only the elapsed time and the fps)\r\n     */\r\n    private _previousAbsoluteFrame: number = 0;\r\n\r\n    private _enableBlending: boolean;\r\n\r\n    private _keys: IAnimationKey[];\r\n    private _minFrame: number;\r\n    private _maxFrame: number;\r\n    private _minValue: any;\r\n    private _maxValue: any;\r\n    private _targetIsArray = false;\r\n\r\n    /**\r\n     * Gets the current frame of the runtime animation\r\n     */\r\n    public get currentFrame(): number {\r\n        return this._currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Gets the weight of the runtime animation\r\n     */\r\n    public get weight(): number {\r\n        return this._weight;\r\n    }\r\n\r\n    /**\r\n     * Gets the current value of the runtime animation\r\n     */\r\n    public get currentValue(): any {\r\n        return this._currentValue;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the target path of the runtime animation\r\n     */\r\n    public get targetPath(): string {\r\n        return this._targetPath;\r\n    }\r\n\r\n    /**\r\n     * Gets the actual target of the runtime animation\r\n     */\r\n    public get target(): any {\r\n        return this._currentActiveTarget;\r\n    }\r\n\r\n    /**\r\n     * Gets the additive state of the runtime animation\r\n     */\r\n    public get isAdditive(): boolean {\r\n        return this._host && this._host.isAdditive;\r\n    }\r\n\r\n    /** @internal */\r\n    public _onLoop: () => void;\r\n\r\n    /**\r\n     * Create a new RuntimeAnimation object\r\n     * @param target defines the target of the animation\r\n     * @param animation defines the source animation object\r\n     * @param scene defines the hosting scene\r\n     * @param host defines the initiating Animatable\r\n     */\r\n    public constructor(target: any, animation: Animation, scene: Scene, host: Animatable) {\r\n        this._animation = animation;\r\n        this._target = target;\r\n        this._scene = scene;\r\n        this._host = host;\r\n        this._activeTargets = [];\r\n\r\n        animation._runtimeAnimations.push(this);\r\n\r\n        // State\r\n        this._animationState = {\r\n            key: 0,\r\n            repeatCount: 0,\r\n            loopMode: this._getCorrectLoopMode(),\r\n        };\r\n\r\n        if (this._animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\r\n            this._animationState.workValue = Matrix.Zero();\r\n        }\r\n\r\n        // Limits\r\n        this._keys = this._animation.getKeys();\r\n        this._minFrame = this._keys[0].frame;\r\n        this._maxFrame = this._keys[this._keys.length - 1].frame;\r\n        this._minValue = this._keys[0].value;\r\n        this._maxValue = this._keys[this._keys.length - 1].value;\r\n\r\n        // Add a start key at frame 0 if missing\r\n        if (this._minFrame !== 0) {\r\n            const newKey = { frame: 0, value: this._minValue };\r\n            this._keys.splice(0, 0, newKey);\r\n        }\r\n\r\n        // Check data\r\n        if (this._target instanceof Array) {\r\n            let index = 0;\r\n            for (const target of this._target) {\r\n                this._preparePath(target, index);\r\n                this._getOriginalValues(index);\r\n                index++;\r\n            }\r\n            this._targetIsArray = true;\r\n        } else {\r\n            this._preparePath(this._target);\r\n            this._getOriginalValues();\r\n            this._targetIsArray = false;\r\n            this._directTarget = this._activeTargets[0];\r\n        }\r\n\r\n        // Cloning events locally\r\n        const events = animation.getEvents();\r\n        if (events && events.length > 0) {\r\n            events.forEach((e) => {\r\n                this._events.push(e._clone());\r\n            });\r\n        }\r\n\r\n        this._enableBlending = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.enableBlending : this._animation.enableBlending;\r\n    }\r\n\r\n    private _preparePath(target: any, targetIndex = 0) {\r\n        const targetPropertyPath = this._animation.targetPropertyPath;\r\n\r\n        if (targetPropertyPath.length > 1) {\r\n            let property = target[targetPropertyPath[0]];\r\n\r\n            for (let index = 1; index < targetPropertyPath.length - 1; index++) {\r\n                property = property[targetPropertyPath[index]];\r\n            }\r\n\r\n            this._targetPath = targetPropertyPath[targetPropertyPath.length - 1];\r\n            this._activeTargets[targetIndex] = property;\r\n        } else {\r\n            this._targetPath = targetPropertyPath[0];\r\n            this._activeTargets[targetIndex] = target;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the animation from the runtime animation\r\n     */\r\n    public get animation(): Animation {\r\n        return this._animation;\r\n    }\r\n\r\n    /**\r\n     * Resets the runtime animation to the beginning\r\n     * @param restoreOriginal defines whether to restore the target property to the original value\r\n     */\r\n    public reset(restoreOriginal = false): void {\r\n        if (restoreOriginal) {\r\n            if (this._target instanceof Array) {\r\n                let index = 0;\r\n                for (const target of this._target) {\r\n                    if (this._originalValue[index] !== undefined) {\r\n                        this._setValue(target, this._activeTargets[index], this._originalValue[index], -1, index);\r\n                    }\r\n                    index++;\r\n                }\r\n            } else {\r\n                if (this._originalValue[0] !== undefined) {\r\n                    this._setValue(this._target, this._directTarget, this._originalValue[0], -1, 0);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._offsetsCache = {};\r\n        this._highLimitsCache = {};\r\n        this._currentFrame = 0;\r\n        this._blendingFactor = 0;\r\n\r\n        // Events\r\n        for (let index = 0; index < this._events.length; index++) {\r\n            this._events[index].isDone = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Specifies if the runtime animation is stopped\r\n     * @returns Boolean specifying if the runtime animation is stopped\r\n     */\r\n    public isStopped(): boolean {\r\n        return this._stopped;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the runtime animation\r\n     */\r\n    public dispose(): void {\r\n        const index = this._animation.runtimeAnimations.indexOf(this);\r\n\r\n        if (index > -1) {\r\n            this._animation.runtimeAnimations.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply the interpolated value to the target\r\n     * @param currentValue defines the value computed by the animation\r\n     * @param weight defines the weight to apply to this value (Defaults to 1.0)\r\n     */\r\n    public setValue(currentValue: any, weight: number) {\r\n        if (this._targetIsArray) {\r\n            for (let index = 0; index < this._target.length; index++) {\r\n                const target = this._target[index];\r\n                this._setValue(target, this._activeTargets[index], currentValue, weight, index);\r\n            }\r\n            return;\r\n        }\r\n        this._setValue(this._target, this._directTarget, currentValue, weight, 0);\r\n    }\r\n\r\n    private _getOriginalValues(targetIndex = 0) {\r\n        let originalValue: any;\r\n        const target = this._activeTargets[targetIndex];\r\n\r\n        if (target.getLocalMatrix && this._targetPath === \"_matrix\") {\r\n            // For bones\r\n            originalValue = target.getLocalMatrix();\r\n        } else {\r\n            originalValue = target[this._targetPath];\r\n        }\r\n\r\n        if (originalValue && originalValue.clone) {\r\n            this._originalValue[targetIndex] = originalValue.clone();\r\n        } else {\r\n            this._originalValue[targetIndex] = originalValue;\r\n        }\r\n    }\r\n\r\n    private _setValue(target: any, destination: any, currentValue: any, weight: number, targetIndex: number): void {\r\n        // Set value\r\n        this._currentActiveTarget = destination;\r\n\r\n        this._weight = weight;\r\n\r\n        if (this._enableBlending && this._blendingFactor <= 1.0) {\r\n            if (!this._originalBlendValue) {\r\n                const originalValue = destination[this._targetPath];\r\n\r\n                if (originalValue.clone) {\r\n                    this._originalBlendValue = originalValue.clone();\r\n                } else {\r\n                    this._originalBlendValue = originalValue;\r\n                }\r\n            }\r\n\r\n            if (this._originalBlendValue.m) {\r\n                // Matrix\r\n                if (Animation.AllowMatrixDecomposeForInterpolation) {\r\n                    if (this._currentValue) {\r\n                        Matrix.DecomposeLerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\r\n                    } else {\r\n                        this._currentValue = Matrix.DecomposeLerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n                    }\r\n                } else {\r\n                    if (this._currentValue) {\r\n                        Matrix.LerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\r\n                    } else {\r\n                        this._currentValue = Matrix.Lerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n                    }\r\n                }\r\n            } else {\r\n                this._currentValue = Animation._UniversalLerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n            }\r\n\r\n            const blendingSpeed = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.blendingSpeed : this._animation.blendingSpeed;\r\n            this._blendingFactor += blendingSpeed;\r\n        } else {\r\n            if (!this._currentValue) {\r\n                if (currentValue?.clone) {\r\n                    this._currentValue = currentValue.clone();\r\n                } else {\r\n                    this._currentValue = currentValue;\r\n                }\r\n            } else if (this._currentValue.copyFrom) {\r\n                this._currentValue.copyFrom(currentValue);\r\n            } else {\r\n                this._currentValue = currentValue;\r\n            }\r\n        }\r\n\r\n        if (weight !== -1.0) {\r\n            this._scene._registerTargetForLateAnimationBinding(this, this._originalValue[targetIndex]);\r\n        } else {\r\n            destination[this._targetPath] = this._currentValue;\r\n        }\r\n\r\n        if (target.markAsDirty) {\r\n            target.markAsDirty(this._animation.targetProperty);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the loop pmode of the runtime animation\r\n     * @returns Loop Mode\r\n     */\r\n    private _getCorrectLoopMode(): number | undefined {\r\n        if (this._target && this._target.animationPropertiesOverride) {\r\n            return this._target.animationPropertiesOverride.loopMode;\r\n        }\r\n\r\n        return this._animation.loopMode;\r\n    }\r\n\r\n    /**\r\n     * Move the current animation to a given frame\r\n     * @param frame defines the frame to move to\r\n     */\r\n    public goToFrame(frame: number): void {\r\n        const keys = this._animation.getKeys();\r\n\r\n        if (frame < keys[0].frame) {\r\n            frame = keys[0].frame;\r\n        } else if (frame > keys[keys.length - 1].frame) {\r\n            frame = keys[keys.length - 1].frame;\r\n        }\r\n\r\n        // Need to reset animation events\r\n        const events = this._events;\r\n        if (events.length) {\r\n            for (let index = 0; index < events.length; index++) {\r\n                if (!events[index].onlyOnce) {\r\n                    // reset events in the future\r\n                    events[index].isDone = events[index].frame < frame;\r\n                }\r\n            }\r\n        }\r\n\r\n        this._currentFrame = frame;\r\n        const currentValue = this._animation._interpolate(frame, this._animationState);\r\n\r\n        this.setValue(currentValue, -1);\r\n    }\r\n\r\n    /**\r\n     * @internal Internal use only\r\n     */\r\n    public _prepareForSpeedRatioChange(newSpeedRatio: number): void {\r\n        const newAbsoluteFrame = (this._previousElapsedTime * (this._animation.framePerSecond * newSpeedRatio)) / 1000.0;\r\n\r\n        this._absoluteFrameOffset = this._previousAbsoluteFrame - newAbsoluteFrame;\r\n    }\r\n\r\n    /**\r\n     * Execute the current animation\r\n     * @param elapsedTimeSinceAnimationStart defines the elapsed time (in milliseconds) since the animation was started\r\n     * @param from defines the lower frame of the animation range\r\n     * @param to defines the upper frame of the animation range\r\n     * @param loop defines if the current animation must loop\r\n     * @param speedRatio defines the current speed ratio\r\n     * @param weight defines the weight of the animation (default is -1 so no weight)\r\n     * @returns a boolean indicating if the animation is running\r\n     */\r\n    public animate(elapsedTimeSinceAnimationStart: number, from: number, to: number, loop: boolean, speedRatio: number, weight = -1.0): boolean {\r\n        const animation = this._animation;\r\n        const targetPropertyPath = animation.targetPropertyPath;\r\n        if (!targetPropertyPath || targetPropertyPath.length < 1) {\r\n            this._stopped = true;\r\n            return false;\r\n        }\r\n\r\n        let returnValue = true;\r\n\r\n        // Check limits\r\n        if (from < this._minFrame || from > this._maxFrame) {\r\n            from = this._minFrame;\r\n        }\r\n        if (to < this._minFrame || to > this._maxFrame) {\r\n            to = this._maxFrame;\r\n        }\r\n\r\n        const frameRange = to - from;\r\n        let offsetValue: any;\r\n\r\n        // Compute the frame according to the elapsed time and the fps of the animation (\"from\" and \"to\" are not factored in!)\r\n        let absoluteFrame = (elapsedTimeSinceAnimationStart * (animation.framePerSecond * speedRatio)) / 1000.0 + this._absoluteFrameOffset;\r\n        let highLimitValue = 0;\r\n\r\n        // Apply the yoyo function if required\r\n        if (loop && this._animationState.loopMode === Animation.ANIMATIONLOOPMODE_YOYO) {\r\n            const position = (absoluteFrame - from) / frameRange;\r\n\r\n            // Apply the yoyo curve\r\n            const yoyoPosition = Math.abs(Math.sin(position * Math.PI));\r\n\r\n            // Map the yoyo position back to the range\r\n            absoluteFrame = yoyoPosition * frameRange + from;\r\n        }\r\n\r\n        this._previousElapsedTime = elapsedTimeSinceAnimationStart;\r\n        this._previousAbsoluteFrame = absoluteFrame;\r\n\r\n        if (!loop && to >= from && absoluteFrame >= frameRange) {\r\n            // If we are out of range and not looping get back to caller\r\n            returnValue = false;\r\n            highLimitValue = animation._getKeyValue(this._maxValue);\r\n        } else if (!loop && from >= to && absoluteFrame <= frameRange) {\r\n            returnValue = false;\r\n            highLimitValue = animation._getKeyValue(this._minValue);\r\n        } else if (this._animationState.loopMode !== Animation.ANIMATIONLOOPMODE_CYCLE) {\r\n            const keyOffset = to.toString() + from.toString();\r\n            if (!this._offsetsCache[keyOffset]) {\r\n                this._animationState.repeatCount = 0;\r\n                this._animationState.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE; // force a specific codepath in animation._interpolate()!\r\n                const fromValue = animation._interpolate(from, this._animationState);\r\n                const toValue = animation._interpolate(to, this._animationState);\r\n\r\n                this._animationState.loopMode = this._getCorrectLoopMode();\r\n                switch (animation.dataType) {\r\n                    // Float\r\n                    case Animation.ANIMATIONTYPE_FLOAT:\r\n                        this._offsetsCache[keyOffset] = toValue - fromValue;\r\n                        break;\r\n                    // Quaternion\r\n                    case Animation.ANIMATIONTYPE_QUATERNION:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    // Vector3\r\n                    case Animation.ANIMATIONTYPE_VECTOR3:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    // Vector2\r\n                    case Animation.ANIMATIONTYPE_VECTOR2:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    // Size\r\n                    case Animation.ANIMATIONTYPE_SIZE:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    // Color3\r\n                    case Animation.ANIMATIONTYPE_COLOR3:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n\r\n                this._highLimitsCache[keyOffset] = toValue;\r\n            }\r\n\r\n            highLimitValue = this._highLimitsCache[keyOffset];\r\n            offsetValue = this._offsetsCache[keyOffset];\r\n        }\r\n\r\n        if (offsetValue === undefined) {\r\n            switch (animation.dataType) {\r\n                // Float\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    offsetValue = 0;\r\n                    break;\r\n                // Quaternion\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    offsetValue = _staticOffsetValueQuaternion;\r\n                    break;\r\n                // Vector3\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                    offsetValue = _staticOffsetValueVector3;\r\n                    break;\r\n                // Vector2\r\n                case Animation.ANIMATIONTYPE_VECTOR2:\r\n                    offsetValue = _staticOffsetValueVector2;\r\n                    break;\r\n                // Size\r\n                case Animation.ANIMATIONTYPE_SIZE:\r\n                    offsetValue = _staticOffsetValueSize;\r\n                    break;\r\n                // Color3\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                    offsetValue = _staticOffsetValueColor3;\r\n            }\r\n        }\r\n\r\n        // Compute value\r\n        let currentFrame: number;\r\n\r\n        if (this._host && this._host.syncRoot) {\r\n            // If we must sync with an animatable, calculate the current frame based on the frame of the root animatable\r\n            const syncRoot = this._host.syncRoot;\r\n            const hostNormalizedFrame = (syncRoot.masterFrame - syncRoot.fromFrame) / (syncRoot.toFrame - syncRoot.fromFrame);\r\n            currentFrame = from + frameRange * hostNormalizedFrame;\r\n        } else {\r\n            if ((absoluteFrame > 0 && from > to) || (absoluteFrame < 0 && from < to)) {\r\n                currentFrame = returnValue && frameRange !== 0 ? to + (absoluteFrame % frameRange) : from;\r\n            } else {\r\n                currentFrame = returnValue && frameRange !== 0 ? from + (absoluteFrame % frameRange) : to;\r\n            }\r\n        }\r\n\r\n        const events = this._events;\r\n\r\n        // Reset event/state if looping\r\n        if ((speedRatio > 0 && this.currentFrame > currentFrame) || (speedRatio < 0 && this.currentFrame < currentFrame)) {\r\n            this._onLoop();\r\n\r\n            // Need to reset animation events\r\n            for (let index = 0; index < events.length; index++) {\r\n                if (!events[index].onlyOnce) {\r\n                    // reset event, the animation is looping\r\n                    events[index].isDone = false;\r\n                }\r\n            }\r\n\r\n            this._animationState.key = speedRatio > 0 ? 0 : animation.getKeys().length - 1;\r\n        }\r\n        this._currentFrame = currentFrame;\r\n        this._animationState.repeatCount = frameRange === 0 ? 0 : (absoluteFrame / frameRange) >> 0;\r\n        this._animationState.highLimitValue = highLimitValue;\r\n        this._animationState.offsetValue = offsetValue;\r\n\r\n        const currentValue = animation._interpolate(currentFrame, this._animationState);\r\n\r\n        // Set value\r\n        this.setValue(currentValue, weight);\r\n\r\n        // Check events\r\n        if (events.length) {\r\n            for (let index = 0; index < events.length; index++) {\r\n                // Make sure current frame has passed event frame and that event frame is within the current range\r\n                // Also, handle both forward and reverse animations\r\n                if (\r\n                    (frameRange > 0 && currentFrame >= events[index].frame && events[index].frame >= from) ||\r\n                    (frameRange < 0 && currentFrame <= events[index].frame && events[index].frame <= from)\r\n                ) {\r\n                    const event = events[index];\r\n                    if (!event.isDone) {\r\n                        // If event should be done only once, remove it.\r\n                        if (event.onlyOnce) {\r\n                            events.splice(index, 1);\r\n                            index--;\r\n                        }\r\n                        event.isDone = true;\r\n                        event.action(currentFrame);\r\n                    } // Don't do anything if the event has already been done.\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!returnValue) {\r\n            this._stopped = true;\r\n        }\r\n\r\n        return returnValue;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}