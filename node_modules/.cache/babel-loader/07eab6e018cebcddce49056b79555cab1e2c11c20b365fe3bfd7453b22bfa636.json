{"ast":null,"code":"import { PhysicsBody } from \"./physicsBody.js\";\nimport { PhysicsShape } from \"./physicsShape.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { Quaternion, TmpVectors, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { PhysicsMotionType, PhysicsShapeType } from \"./IPhysicsEnginePlugin.js\";\nimport { BoundingBox } from \"../../Culling/boundingBox.js\";\n/**\n * Helper class to create and interact with a PhysicsAggregate.\n * This is a transition object that works like Physics Plugin V1 Impostors.\n * This helper instanciate all mandatory physics objects to get a body/shape and material.\n * It's less efficient that handling body and shapes independently but for prototyping or\n * a small numbers of physics objects, it's good enough.\n */\nexport class PhysicsAggregate {\n  constructor(\n  /**\n   * The physics-enabled object used as the physics aggregate\n   */\n  transformNode,\n  /**\n   * The type of the physics aggregate\n   */\n  type, _options = {\n    mass: 0\n  }, _scene) {\n    var _a;\n    this.transformNode = transformNode;\n    this.type = type;\n    this._options = _options;\n    this._scene = _scene;\n    this._disposeShapeWhenDisposed = true;\n    //sanity check!\n    if (!this.transformNode) {\n      Logger.Error(\"No object was provided. A physics object is obligatory\");\n      return;\n    }\n    const m = transformNode;\n    if (this.transformNode.parent && this._options.mass !== 0 && m.hasThinInstances) {\n      Logger.Warn(\"A physics body has been created for an object which has a parent and thin instances. Babylon physics currently works in local space so unexpected issues may occur.\");\n    }\n    // Legacy support for old syntax.\n    if (!this._scene && transformNode.getScene) {\n      this._scene = transformNode.getScene();\n    }\n    if (!this._scene) {\n      return;\n    }\n    //default options params\n    this._options.mass = _options.mass === void 0 ? 0 : _options.mass;\n    this._options.friction = _options.friction === void 0 ? 0.2 : _options.friction;\n    this._options.restitution = _options.restitution === void 0 ? 0.2 : _options.restitution;\n    const motionType = this._options.mass === 0 ? PhysicsMotionType.STATIC : PhysicsMotionType.DYNAMIC;\n    const startAsleep = (_a = this._options.startAsleep) !== null && _a !== void 0 ? _a : false;\n    this.body = new PhysicsBody(transformNode, motionType, startAsleep, this._scene);\n    this._addSizeOptions();\n    if (type.getClassName && type.getClassName() === \"PhysicsShape\") {\n      this.shape = type;\n      this._disposeShapeWhenDisposed = false;\n    } else {\n      this.shape = new PhysicsShape({\n        type: type,\n        parameters: this._options\n      }, this._scene);\n    }\n    if (this._options.isTriggerShape) {\n      this.shape.isTrigger = true;\n    }\n    this.material = {\n      friction: this._options.friction,\n      restitution: this._options.restitution\n    };\n    this.body.shape = this.shape;\n    this.shape.material = this.material;\n    this.body.setMassProperties({\n      mass: this._options.mass\n    });\n    this._nodeDisposeObserver = this.transformNode.onDisposeObservable.add(() => {\n      this.dispose();\n    });\n  }\n  _getObjectBoundingBox() {\n    if (this.transformNode.getRawBoundingInfo) {\n      return this.transformNode.getRawBoundingInfo().boundingBox;\n    } else {\n      return new BoundingBox(new Vector3(-0.5, -0.5, -0.5), new Vector3(0.5, 0.5, 0.5));\n    }\n  }\n  _hasVertices(node) {\n    return (node === null || node === void 0 ? void 0 : node.getTotalVertices()) > 0;\n  }\n  _addSizeOptions() {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    this.transformNode.computeWorldMatrix(true);\n    const bb = this._getObjectBoundingBox();\n    const extents = TmpVectors.Vector3[0];\n    extents.copyFrom(bb.extendSize);\n    extents.scaleInPlace(2);\n    extents.multiplyInPlace(this.transformNode.scaling);\n    // In case we had any negative scaling, we need to take the absolute value of the extents.\n    extents.x = Math.abs(extents.x);\n    extents.y = Math.abs(extents.y);\n    extents.z = Math.abs(extents.z);\n    const min = TmpVectors.Vector3[1];\n    min.copyFrom(bb.minimum);\n    min.multiplyInPlace(this.transformNode.scaling);\n    if (!this._options.center) {\n      const center = new Vector3();\n      center.copyFrom(bb.center);\n      center.multiplyInPlace(this.transformNode.scaling);\n      this._options.center = center;\n    }\n    switch (this.type) {\n      case PhysicsShapeType.SPHERE:\n        if (!this._options.radius && Scalar.WithinEpsilon(extents.x, extents.y, 0.0001) && Scalar.WithinEpsilon(extents.x, extents.z, 0.0001)) {\n          this._options.radius = extents.x / 2;\n        } else if (!this._options.radius) {\n          Logger.Warn(\"Non uniform scaling is unsupported for sphere shapes. Setting the radius to the biggest bounding box extent.\");\n          this._options.radius = Math.max(extents.x, extents.y, extents.z) / 2;\n        }\n        break;\n      case PhysicsShapeType.CAPSULE:\n        {\n          const capRadius = extents.x / 2;\n          this._options.radius = (_a = this._options.radius) !== null && _a !== void 0 ? _a : capRadius;\n          this._options.pointA = (_b = this._options.pointA) !== null && _b !== void 0 ? _b : new Vector3(0, min.y + capRadius, 0);\n          this._options.pointB = (_c = this._options.pointB) !== null && _c !== void 0 ? _c : new Vector3(0, min.y + extents.y - capRadius, 0);\n        }\n        break;\n      case PhysicsShapeType.CYLINDER:\n        {\n          const capRadius = extents.x / 2;\n          this._options.radius = (_d = this._options.radius) !== null && _d !== void 0 ? _d : capRadius;\n          this._options.pointA = (_e = this._options.pointA) !== null && _e !== void 0 ? _e : new Vector3(0, min.y, 0);\n          this._options.pointB = (_f = this._options.pointB) !== null && _f !== void 0 ? _f : new Vector3(0, min.y + extents.y, 0);\n        }\n        break;\n      case PhysicsShapeType.MESH:\n      case PhysicsShapeType.CONVEX_HULL:\n        if (!this._options.mesh && this._hasVertices(this.transformNode)) {\n          this._options.mesh = this.transformNode;\n        } else if (!this._options.mesh || !this._hasVertices(this._options.mesh)) {\n          throw new Error(\"No valid mesh was provided for mesh or convex hull shape parameter. Please provide a mesh with valid geometry (number of vertices greater than 0).\");\n        }\n        break;\n      case PhysicsShapeType.BOX:\n        this._options.extents = (_g = this._options.extents) !== null && _g !== void 0 ? _g : new Vector3(extents.x, extents.y, extents.z);\n        this._options.rotation = (_h = this._options.rotation) !== null && _h !== void 0 ? _h : Quaternion.Identity();\n        break;\n    }\n  }\n  /**\n   * Releases the body, shape and material\n   */\n  dispose() {\n    if (this._nodeDisposeObserver) {\n      this.body.transformNode.onDisposeObservable.remove(this._nodeDisposeObserver);\n      this._nodeDisposeObserver = null;\n    }\n    this.body.dispose();\n    if (this._disposeShapeWhenDisposed) {\n      this.shape.dispose();\n    }\n  }\n}","map":{"version":3,"names":["PhysicsBody","PhysicsShape","Logger","Quaternion","TmpVectors","Vector3","Scalar","PhysicsMotionType","PhysicsShapeType","BoundingBox","PhysicsAggregate","constructor","transformNode","type","_options","mass","_scene","_disposeShapeWhenDisposed","Error","m","parent","hasThinInstances","Warn","getScene","friction","restitution","motionType","STATIC","DYNAMIC","startAsleep","_a","body","_addSizeOptions","getClassName","shape","parameters","isTriggerShape","isTrigger","material","setMassProperties","_nodeDisposeObserver","onDisposeObservable","add","dispose","_getObjectBoundingBox","getRawBoundingInfo","boundingBox","_hasVertices","node","getTotalVertices","computeWorldMatrix","bb","extents","copyFrom","extendSize","scaleInPlace","multiplyInPlace","scaling","x","Math","abs","y","z","min","minimum","center","SPHERE","radius","WithinEpsilon","max","CAPSULE","capRadius","pointA","_b","pointB","_c","CYLINDER","_d","_e","_f","MESH","CONVEX_HULL","mesh","BOX","_g","rotation","_h","Identity","remove"],"sources":["../../../../../dev/core/src/Physics/v2/physicsAggregate.ts"],"sourcesContent":["import { PhysicsBody } from \"./physicsBody\";\r\nimport type { PhysicsMaterial } from \"./physicsMaterial\";\r\nimport { PhysicsShape } from \"./physicsShape\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Quaternion, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport { PhysicsMotionType, PhysicsShapeType } from \"./IPhysicsEnginePlugin\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Node } from \"../../node\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { BoundingBox } from \"../../Culling/boundingBox\";\r\n\r\n/**\r\n * The interface for the physics aggregate parameters\r\n */\r\nexport interface PhysicsAggregateParameters {\r\n    /**\r\n     * The mass of the physics aggregate\r\n     */\r\n    mass: number;\r\n\r\n    /**\r\n     * The friction of the physics aggregate\r\n     */\r\n    friction?: number;\r\n\r\n    /**\r\n     * The coefficient of restitution of the physics aggregate\r\n     */\r\n    restitution?: number;\r\n\r\n    /**\r\n     * Radius for sphere, cylinder and capsule\r\n     */\r\n    radius?: number;\r\n\r\n    /**\r\n     * Starting point for cylinder/capsule\r\n     */\r\n    pointA?: Vector3;\r\n\r\n    /**\r\n     * Ending point for cylinder/capsule\r\n     */\r\n    pointB?: Vector3;\r\n\r\n    /**\r\n     * Extents for box\r\n     */\r\n    extents?: Vector3;\r\n\r\n    /**\r\n     * Orientation for box\r\n     */\r\n    rotation?: Quaternion;\r\n\r\n    /**\r\n     * mesh local center\r\n     */\r\n    center?: Vector3;\r\n\r\n    /**\r\n     * mesh object. Used for mesh and convex hull aggregates.\r\n     */\r\n    mesh?: Mesh;\r\n\r\n    /**\r\n     * Physics engine will try to make this body sleeping and not active\r\n     */\r\n    startAsleep?: boolean;\r\n\r\n    /**\r\n     * If true, mark the created shape as a trigger shape\r\n     */\r\n    isTriggerShape?: boolean;\r\n}\r\n/**\r\n * Helper class to create and interact with a PhysicsAggregate.\r\n * This is a transition object that works like Physics Plugin V1 Impostors.\r\n * This helper instanciate all mandatory physics objects to get a body/shape and material.\r\n * It's less efficient that handling body and shapes independently but for prototyping or\r\n * a small numbers of physics objects, it's good enough.\r\n */\r\nexport class PhysicsAggregate {\r\n    /**\r\n     * The body that is associated with this aggregate\r\n     */\r\n    public body: PhysicsBody;\r\n\r\n    /**\r\n     * The shape that is associated with this aggregate\r\n     */\r\n    public shape: PhysicsShape;\r\n\r\n    /**\r\n     * The material that is associated with this aggregate\r\n     */\r\n    public material: PhysicsMaterial;\r\n\r\n    private _disposeShapeWhenDisposed = true;\r\n\r\n    private _nodeDisposeObserver: Nullable<Observer<Node>>;\r\n\r\n    constructor(\r\n        /**\r\n         * The physics-enabled object used as the physics aggregate\r\n         */\r\n        public transformNode: TransformNode,\r\n        /**\r\n         * The type of the physics aggregate\r\n         */\r\n        public type: PhysicsShapeType | PhysicsShape,\r\n        private _options: PhysicsAggregateParameters = { mass: 0 },\r\n        private _scene?: Scene\r\n    ) {\r\n        //sanity check!\r\n        if (!this.transformNode) {\r\n            Logger.Error(\"No object was provided. A physics object is obligatory\");\r\n            return;\r\n        }\r\n        const m = transformNode as Mesh;\r\n        if (this.transformNode.parent && this._options.mass !== 0 && m.hasThinInstances) {\r\n            Logger.Warn(\r\n                \"A physics body has been created for an object which has a parent and thin instances. Babylon physics currently works in local space so unexpected issues may occur.\"\r\n            );\r\n        }\r\n\r\n        // Legacy support for old syntax.\r\n        if (!this._scene && transformNode.getScene) {\r\n            this._scene = transformNode.getScene();\r\n        }\r\n\r\n        if (!this._scene) {\r\n            return;\r\n        }\r\n\r\n        //default options params\r\n        this._options.mass = _options.mass === void 0 ? 0 : _options.mass;\r\n        this._options.friction = _options.friction === void 0 ? 0.2 : _options.friction;\r\n        this._options.restitution = _options.restitution === void 0 ? 0.2 : _options.restitution;\r\n\r\n        const motionType = this._options.mass === 0 ? PhysicsMotionType.STATIC : PhysicsMotionType.DYNAMIC;\r\n        const startAsleep = this._options.startAsleep ?? false;\r\n        this.body = new PhysicsBody(transformNode, motionType, startAsleep, this._scene);\r\n        this._addSizeOptions();\r\n        if ((type as any).getClassName && (type as any).getClassName() === \"PhysicsShape\") {\r\n            this.shape = type as PhysicsShape;\r\n            this._disposeShapeWhenDisposed = false;\r\n        } else {\r\n            this.shape = new PhysicsShape({ type: type as PhysicsShapeType, parameters: this._options as any }, this._scene);\r\n        }\r\n\r\n        if (this._options.isTriggerShape) {\r\n            this.shape.isTrigger = true;\r\n        }\r\n\r\n        this.material = { friction: this._options.friction, restitution: this._options.restitution };\r\n        this.body.shape = this.shape;\r\n        this.shape.material = this.material;\r\n\r\n        this.body.setMassProperties({ mass: this._options.mass });\r\n\r\n        this._nodeDisposeObserver = this.transformNode.onDisposeObservable.add(() => {\r\n            this.dispose();\r\n        });\r\n    }\r\n\r\n    private _getObjectBoundingBox() {\r\n        if ((this.transformNode as AbstractMesh).getRawBoundingInfo) {\r\n            return (this.transformNode as AbstractMesh).getRawBoundingInfo().boundingBox;\r\n        } else {\r\n            return new BoundingBox(new Vector3(-0.5, -0.5, -0.5), new Vector3(0.5, 0.5, 0.5));\r\n        }\r\n    }\r\n\r\n    private _hasVertices(node: TransformNode): boolean {\r\n        return (node as any)?.getTotalVertices() > 0;\r\n    }\r\n\r\n    private _addSizeOptions(): void {\r\n        this.transformNode.computeWorldMatrix(true);\r\n        const bb = this._getObjectBoundingBox();\r\n        const extents = TmpVectors.Vector3[0];\r\n        extents.copyFrom(bb.extendSize);\r\n        extents.scaleInPlace(2);\r\n        extents.multiplyInPlace(this.transformNode.scaling);\r\n        // In case we had any negative scaling, we need to take the absolute value of the extents.\r\n        extents.x = Math.abs(extents.x);\r\n        extents.y = Math.abs(extents.y);\r\n        extents.z = Math.abs(extents.z);\r\n\r\n        const min = TmpVectors.Vector3[1];\r\n        min.copyFrom(bb.minimum);\r\n        min.multiplyInPlace(this.transformNode.scaling);\r\n\r\n        if (!this._options.center) {\r\n            const center = new Vector3();\r\n            center.copyFrom(bb.center);\r\n            center.multiplyInPlace(this.transformNode.scaling);\r\n            this._options.center = center;\r\n        }\r\n\r\n        switch (this.type) {\r\n            case PhysicsShapeType.SPHERE:\r\n                if (!this._options.radius && Scalar.WithinEpsilon(extents.x, extents.y, 0.0001) && Scalar.WithinEpsilon(extents.x, extents.z, 0.0001)) {\r\n                    this._options.radius = extents.x / 2;\r\n                } else if (!this._options.radius) {\r\n                    Logger.Warn(\"Non uniform scaling is unsupported for sphere shapes. Setting the radius to the biggest bounding box extent.\");\r\n                    this._options.radius = Math.max(extents.x, extents.y, extents.z) / 2;\r\n                }\r\n                break;\r\n            case PhysicsShapeType.CAPSULE:\r\n                {\r\n                    const capRadius = extents.x / 2;\r\n                    this._options.radius = this._options.radius ?? capRadius;\r\n                    this._options.pointA = this._options.pointA ?? new Vector3(0, min.y + capRadius, 0);\r\n                    this._options.pointB = this._options.pointB ?? new Vector3(0, min.y + extents.y - capRadius, 0);\r\n                }\r\n                break;\r\n            case PhysicsShapeType.CYLINDER:\r\n                {\r\n                    const capRadius = extents.x / 2;\r\n                    this._options.radius = this._options.radius ?? capRadius;\r\n                    this._options.pointA = this._options.pointA ?? new Vector3(0, min.y, 0);\r\n                    this._options.pointB = this._options.pointB ?? new Vector3(0, min.y + extents.y, 0);\r\n                }\r\n                break;\r\n            case PhysicsShapeType.MESH:\r\n            case PhysicsShapeType.CONVEX_HULL:\r\n                if (!this._options.mesh && this._hasVertices(this.transformNode)) {\r\n                    this._options.mesh = this.transformNode as Mesh;\r\n                } else if (!this._options.mesh || !this._hasVertices(this._options.mesh)) {\r\n                    throw new Error(\r\n                        \"No valid mesh was provided for mesh or convex hull shape parameter. Please provide a mesh with valid geometry (number of vertices greater than 0).\"\r\n                    );\r\n                }\r\n                break;\r\n            case PhysicsShapeType.BOX:\r\n                this._options.extents = this._options.extents ?? new Vector3(extents.x, extents.y, extents.z);\r\n                this._options.rotation = this._options.rotation ?? Quaternion.Identity();\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Releases the body, shape and material\r\n     */\r\n    public dispose(): void {\r\n        if (this._nodeDisposeObserver) {\r\n            this.body.transformNode.onDisposeObservable.remove(this._nodeDisposeObserver);\r\n            this._nodeDisposeObserver = null;\r\n        }\r\n        this.body.dispose();\r\n        if (this._disposeShapeWhenDisposed) {\r\n            this.shape.dispose();\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}