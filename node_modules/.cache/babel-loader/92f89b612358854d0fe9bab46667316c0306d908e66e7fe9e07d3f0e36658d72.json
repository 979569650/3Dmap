{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Manage the touch inputs to control the movement of a free camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class FreeCameraTouchInput {\n  /**\n   * Manage the touch inputs to control the movement of a free camera.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n   * @param allowMouse Defines if mouse events can be treated as touch events\n   */\n  constructor(\n  /**\n   * Define if mouse events can be treated as touch events\n   */\n  allowMouse = false) {\n    this.allowMouse = allowMouse;\n    /**\n     * Defines the touch sensibility for rotation.\n     * The lower the faster.\n     */\n    this.touchAngularSensibility = 200000.0;\n    /**\n     * Defines the touch sensibility for move.\n     * The lower the faster.\n     */\n    this.touchMoveSensibility = 250.0;\n    /**\n     * Swap touch actions so that one touch is used for rotation and multiple for movement\n     */\n    this.singleFingerRotate = false;\n    this._offsetX = null;\n    this._offsetY = null;\n    this._pointerPressed = new Array();\n    this._isSafari = Tools.IsSafari();\n  }\n  /**\n   * Attach the input controls to a specific dom element to get the input from.\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n   */\n  attachControl(noPreventDefault) {\n    // eslint-disable-next-line prefer-rest-params\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    let previousPosition = null;\n    if (this._pointerInput === undefined) {\n      this._onLostFocus = () => {\n        this._offsetX = null;\n        this._offsetY = null;\n      };\n      this._pointerInput = p => {\n        const evt = p.event;\n        const isMouseEvent = evt.pointerType === \"mouse\" || this._isSafari && typeof evt.pointerType === \"undefined\";\n        if (!this.allowMouse && isMouseEvent) {\n          return;\n        }\n        if (p.type === PointerEventTypes.POINTERDOWN) {\n          if (!noPreventDefault) {\n            evt.preventDefault();\n          }\n          this._pointerPressed.push(evt.pointerId);\n          if (this._pointerPressed.length !== 1) {\n            return;\n          }\n          previousPosition = {\n            x: evt.clientX,\n            y: evt.clientY\n          };\n        } else if (p.type === PointerEventTypes.POINTERUP) {\n          if (!noPreventDefault) {\n            evt.preventDefault();\n          }\n          const index = this._pointerPressed.indexOf(evt.pointerId);\n          if (index === -1) {\n            return;\n          }\n          this._pointerPressed.splice(index, 1);\n          if (index != 0) {\n            return;\n          }\n          previousPosition = null;\n          this._offsetX = null;\n          this._offsetY = null;\n        } else if (p.type === PointerEventTypes.POINTERMOVE) {\n          if (!noPreventDefault) {\n            evt.preventDefault();\n          }\n          if (!previousPosition) {\n            return;\n          }\n          const index = this._pointerPressed.indexOf(evt.pointerId);\n          if (index != 0) {\n            return;\n          }\n          this._offsetX = evt.clientX - previousPosition.x;\n          this._offsetY = -(evt.clientY - previousPosition.y);\n        }\n      };\n    }\n    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\n    if (this._onLostFocus) {\n      const engine = this.camera.getEngine();\n      const element = engine.getInputElement();\n      element && element.addEventListener(\"blur\", this._onLostFocus);\n    }\n  }\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n  detachControl() {\n    if (this._pointerInput) {\n      if (this._observer) {\n        this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\n        this._observer = null;\n      }\n      if (this._onLostFocus) {\n        const engine = this.camera.getEngine();\n        const element = engine.getInputElement();\n        element && element.removeEventListener(\"blur\", this._onLostFocus);\n        this._onLostFocus = null;\n      }\n      this._pointerPressed.length = 0;\n      this._offsetX = null;\n      this._offsetY = null;\n    }\n  }\n  /**\n   * Update the current camera state depending on the inputs that have been used this frame.\n   * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\n   */\n  checkInputs() {\n    if (this._offsetX === null || this._offsetY === null) {\n      return;\n    }\n    if (this._offsetX === 0 && this._offsetY === 0) {\n      return;\n    }\n    const camera = this.camera;\n    const handednessMultiplier = camera._calculateHandednessMultiplier();\n    camera.cameraRotation.y = handednessMultiplier * this._offsetX / this.touchAngularSensibility;\n    const rotateCamera = this.singleFingerRotate && this._pointerPressed.length === 1 || !this.singleFingerRotate && this._pointerPressed.length > 1;\n    if (rotateCamera) {\n      camera.cameraRotation.x = -this._offsetY / this.touchAngularSensibility;\n    } else {\n      const speed = camera._computeLocalCameraSpeed();\n      const direction = new Vector3(0, 0, this.touchMoveSensibility !== 0 ? speed * this._offsetY / this.touchMoveSensibility : 0);\n      Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);\n      camera.cameraDirection.addInPlace(Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));\n    }\n  }\n  /**\n   * Gets the class name of the current input.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"FreeCameraTouchInput\";\n  }\n  /**\n   * Get the friendly name associated with the input class.\n   * @returns the input friendly name\n   */\n  getSimpleName() {\n    return \"touch\";\n  }\n}\n__decorate([serialize()], FreeCameraTouchInput.prototype, \"touchAngularSensibility\", void 0);\n__decorate([serialize()], FreeCameraTouchInput.prototype, \"touchMoveSensibility\", void 0);\nCameraInputTypes[\"FreeCameraTouchInput\"] = FreeCameraTouchInput;","map":{"version":3,"names":["serialize","CameraInputTypes","PointerEventTypes","Matrix","Vector3","Tools","FreeCameraTouchInput","constructor","allowMouse","touchAngularSensibility","touchMoveSensibility","singleFingerRotate","_offsetX","_offsetY","_pointerPressed","Array","_isSafari","IsSafari","attachControl","noPreventDefault","BackCompatCameraNoPreventDefault","arguments","previousPosition","_pointerInput","undefined","_onLostFocus","p","evt","event","isMouseEvent","pointerType","type","POINTERDOWN","preventDefault","push","pointerId","length","x","clientX","y","clientY","POINTERUP","index","indexOf","splice","POINTERMOVE","_observer","camera","getScene","_inputManager","_addCameraPointerObserver","engine","getEngine","element","getInputElement","addEventListener","detachControl","_removeCameraPointerObserver","removeEventListener","checkInputs","handednessMultiplier","_calculateHandednessMultiplier","cameraRotation","rotateCamera","speed","_computeLocalCameraSpeed","direction","RotationYawPitchRollToRef","rotation","_cameraRotationMatrix","cameraDirection","addInPlace","TransformCoordinates","getClassName","getSimpleName","__decorate"],"sources":["../../../../../dev/core/src/Cameras/Inputs/freeCameraTouchInput.ts"],"sourcesContent":["import { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer, EventState } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Manage the touch inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraTouchInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the touch sensibility for rotation.\r\n     * The lower the faster.\r\n     */\r\n    @serialize()\r\n    public touchAngularSensibility: number = 200000.0;\r\n\r\n    /**\r\n     * Defines the touch sensibility for move.\r\n     * The lower the faster.\r\n     */\r\n    @serialize()\r\n    public touchMoveSensibility: number = 250.0;\r\n\r\n    /**\r\n     * Swap touch actions so that one touch is used for rotation and multiple for movement\r\n     */\r\n    public singleFingerRotate: boolean = false;\r\n\r\n    private _offsetX: Nullable<number> = null;\r\n    private _offsetY: Nullable<number> = null;\r\n\r\n    private _pointerPressed = new Array<number>();\r\n    private _pointerInput?: (p: PointerInfo, s: EventState) => void;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\r\n    private _isSafari: boolean;\r\n\r\n    /**\r\n     * Manage the touch inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param allowMouse Defines if mouse events can be treated as touch events\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define if mouse events can be treated as touch events\r\n         */\r\n        public allowMouse = false\r\n    ) {\r\n        this._isSafari = Tools.IsSafari();\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        let previousPosition: Nullable<{ x: number; y: number }> = null;\r\n\r\n        if (this._pointerInput === undefined) {\r\n            this._onLostFocus = () => {\r\n                this._offsetX = null;\r\n                this._offsetY = null;\r\n            };\r\n\r\n            this._pointerInput = (p) => {\r\n                const evt = <IPointerEvent>p.event;\r\n\r\n                const isMouseEvent = evt.pointerType === \"mouse\" || (this._isSafari && typeof evt.pointerType === \"undefined\");\r\n\r\n                if (!this.allowMouse && isMouseEvent) {\r\n                    return;\r\n                }\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    this._pointerPressed.push(evt.pointerId);\r\n\r\n                    if (this._pointerPressed.length !== 1) {\r\n                        return;\r\n                    }\r\n\r\n                    previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                    };\r\n                } else if (p.type === PointerEventTypes.POINTERUP) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    const index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index === -1) {\r\n                        return;\r\n                    }\r\n                    this._pointerPressed.splice(index, 1);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n                    previousPosition = null;\r\n                    this._offsetX = null;\r\n                    this._offsetY = null;\r\n                } else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    if (!previousPosition) {\r\n                        return;\r\n                    }\r\n\r\n                    const index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n\r\n                    this._offsetX = evt.clientX - previousPosition.x;\r\n                    this._offsetY = -(evt.clientY - previousPosition.y);\r\n                }\r\n            };\r\n        }\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        if (this._onLostFocus) {\r\n            const engine = this.camera.getEngine();\r\n            const element = engine.getInputElement();\r\n            element && element.addEventListener(\"blur\", this._onLostFocus);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._pointerInput) {\r\n            if (this._observer) {\r\n                this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n                this._observer = null;\r\n            }\r\n\r\n            if (this._onLostFocus) {\r\n                const engine = this.camera.getEngine();\r\n                const element = engine.getInputElement();\r\n                element && element.removeEventListener(\"blur\", this._onLostFocus);\r\n                this._onLostFocus = null;\r\n            }\r\n            this._pointerPressed.length = 0;\r\n            this._offsetX = null;\r\n            this._offsetY = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._offsetX === null || this._offsetY === null) {\r\n            return;\r\n        }\r\n        if (this._offsetX === 0 && this._offsetY === 0) {\r\n            return;\r\n        }\r\n\r\n        const camera = this.camera;\r\n        const handednessMultiplier = camera._calculateHandednessMultiplier();\r\n        camera.cameraRotation.y = (handednessMultiplier * this._offsetX) / this.touchAngularSensibility;\r\n\r\n        const rotateCamera = (this.singleFingerRotate && this._pointerPressed.length === 1) || (!this.singleFingerRotate && this._pointerPressed.length > 1);\r\n\r\n        if (rotateCamera) {\r\n            camera.cameraRotation.x = -this._offsetY / this.touchAngularSensibility;\r\n        } else {\r\n            const speed = camera._computeLocalCameraSpeed();\r\n            const direction = new Vector3(0, 0, this.touchMoveSensibility !== 0 ? (speed * this._offsetY) / this.touchMoveSensibility : 0);\r\n\r\n            Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);\r\n            camera.cameraDirection.addInPlace(Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraTouchInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"touch\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraTouchInput\"] = FreeCameraTouchInput;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}