{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { EffectLayer } from \"./effectLayer.js\";\nimport { AbstractScene } from \"../abstractScene.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n// Adds the parser to the scene parsers.\nAbstractScene.AddParser(SceneComponentConstants.NAME_EFFECTLAYER, (parsedData, scene, container, rootUrl) => {\n  if (parsedData.effectLayers) {\n    if (!container.effectLayers) {\n      container.effectLayers = new Array();\n    }\n    for (let index = 0; index < parsedData.effectLayers.length; index++) {\n      const effectLayer = EffectLayer.Parse(parsedData.effectLayers[index], scene, rootUrl);\n      container.effectLayers.push(effectLayer);\n    }\n  }\n});\nAbstractScene.prototype.removeEffectLayer = function (toRemove) {\n  const index = this.effectLayers.indexOf(toRemove);\n  if (index !== -1) {\n    this.effectLayers.splice(index, 1);\n  }\n  return index;\n};\nAbstractScene.prototype.addEffectLayer = function (newEffectLayer) {\n  this.effectLayers.push(newEffectLayer);\n};\n/**\n * Defines the layer scene component responsible to manage any effect layers\n * in a given scene.\n */\nexport class EffectLayerSceneComponent {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  constructor(scene) {\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_EFFECTLAYER;\n    this._renderEffects = false;\n    this._needStencil = false;\n    this._previousStencilState = false;\n    this.scene = scene || EngineStore.LastCreatedScene;\n    if (!this.scene) {\n      return;\n    }\n    this._engine = this.scene.getEngine();\n    this.scene.effectLayers = new Array();\n  }\n  /**\n   * Registers the component in a given scene\n   */\n  register() {\n    this.scene._isReadyForMeshStage.registerStep(SceneComponentConstants.STEP_ISREADYFORMESH_EFFECTLAYER, this, this._isReadyForMesh);\n    this.scene._cameraDrawRenderTargetStage.registerStep(SceneComponentConstants.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER, this, this._renderMainTexture);\n    this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_EFFECTLAYER, this, this._setStencil);\n    this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW, this, this._drawRenderingGroup);\n    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER, this, this._setStencilBack);\n    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW, this, this._drawCamera);\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  rebuild() {\n    const layers = this.scene.effectLayers;\n    for (const effectLayer of layers) {\n      effectLayer._rebuild();\n    }\n  }\n  /**\n   * Serializes the component data to the specified json object\n   * @param serializationObject The object to serialize to\n   */\n  serialize(serializationObject) {\n    // Effect layers\n    serializationObject.effectLayers = [];\n    const layers = this.scene.effectLayers;\n    for (const effectLayer of layers) {\n      if (effectLayer.serialize) {\n        serializationObject.effectLayers.push(effectLayer.serialize());\n      }\n    }\n  }\n  /**\n   * Adds all the elements from the container to the scene\n   * @param container the container holding the elements\n   */\n  addFromContainer(container) {\n    if (!container.effectLayers) {\n      return;\n    }\n    container.effectLayers.forEach(o => {\n      this.scene.addEffectLayer(o);\n    });\n  }\n  /**\n   * Removes all the elements in the container from the scene\n   * @param container contains the elements to remove\n   * @param dispose if the removed element should be disposed (default: false)\n   */\n  removeFromContainer(container, dispose) {\n    if (!container.effectLayers) {\n      return;\n    }\n    container.effectLayers.forEach(o => {\n      this.scene.removeEffectLayer(o);\n      if (dispose) {\n        o.dispose();\n      }\n    });\n  }\n  /**\n   * Disposes the component and the associated resources.\n   */\n  dispose() {\n    const layers = this.scene.effectLayers;\n    while (layers.length) {\n      layers[0].dispose();\n    }\n  }\n  _isReadyForMesh(mesh, hardwareInstancedRendering) {\n    const currentRenderPassId = this._engine.currentRenderPassId;\n    const layers = this.scene.effectLayers;\n    for (const layer of layers) {\n      if (!layer.hasMesh(mesh)) {\n        continue;\n      }\n      const renderTarget = layer._mainTexture;\n      this._engine.currentRenderPassId = renderTarget.renderPassId;\n      for (const subMesh of mesh.subMeshes) {\n        if (!layer.isReady(subMesh, hardwareInstancedRendering)) {\n          this._engine.currentRenderPassId = currentRenderPassId;\n          return false;\n        }\n      }\n    }\n    this._engine.currentRenderPassId = currentRenderPassId;\n    return true;\n  }\n  _renderMainTexture(camera) {\n    this._renderEffects = false;\n    this._needStencil = false;\n    let needRebind = false;\n    const layers = this.scene.effectLayers;\n    if (layers && layers.length > 0) {\n      this._previousStencilState = this._engine.getStencilBuffer();\n      for (const effectLayer of layers) {\n        if (effectLayer.shouldRender() && (!effectLayer.camera || effectLayer.camera.cameraRigMode === Camera.RIG_MODE_NONE && camera === effectLayer.camera || effectLayer.camera.cameraRigMode !== Camera.RIG_MODE_NONE && effectLayer.camera._rigCameras.indexOf(camera) > -1)) {\n          this._renderEffects = true;\n          this._needStencil = this._needStencil || effectLayer.needStencil();\n          const renderTarget = effectLayer._mainTexture;\n          if (renderTarget._shouldRender()) {\n            this.scene.incrementRenderId();\n            renderTarget.render(false, false);\n            needRebind = true;\n          }\n        }\n      }\n      this.scene.incrementRenderId();\n    }\n    return needRebind;\n  }\n  _setStencil() {\n    // Activate effect Layer stencil\n    if (this._needStencil) {\n      this._engine.setStencilBuffer(true);\n    }\n  }\n  _setStencilBack() {\n    // Restore effect Layer stencil\n    if (this._needStencil) {\n      this._engine.setStencilBuffer(this._previousStencilState);\n    }\n  }\n  _draw(renderingGroupId) {\n    if (this._renderEffects) {\n      this._engine.setDepthBuffer(false);\n      const layers = this.scene.effectLayers;\n      for (let i = 0; i < layers.length; i++) {\n        const effectLayer = layers[i];\n        if (effectLayer.renderingGroupId === renderingGroupId) {\n          if (effectLayer.shouldRender()) {\n            effectLayer.render();\n          }\n        }\n      }\n      this._engine.setDepthBuffer(true);\n    }\n  }\n  _drawCamera() {\n    if (this._renderEffects) {\n      this._draw(-1);\n    }\n  }\n  _drawRenderingGroup(index) {\n    if (!this.scene._isInIntermediateRendering() && this._renderEffects) {\n      this._draw(index);\n    }\n  }\n}\nEffectLayer._SceneComponentInitialization = scene => {\n  let component = scene._getComponent(SceneComponentConstants.NAME_EFFECTLAYER);\n  if (!component) {\n    component = new EffectLayerSceneComponent(scene);\n    scene._addComponent(component);\n  }\n};","map":{"version":3,"names":["Camera","SceneComponentConstants","EffectLayer","AbstractScene","EngineStore","AddParser","NAME_EFFECTLAYER","parsedData","scene","container","rootUrl","effectLayers","Array","index","length","effectLayer","Parse","push","prototype","removeEffectLayer","toRemove","indexOf","splice","addEffectLayer","newEffectLayer","EffectLayerSceneComponent","constructor","name","_renderEffects","_needStencil","_previousStencilState","LastCreatedScene","_engine","getEngine","register","_isReadyForMeshStage","registerStep","STEP_ISREADYFORMESH_EFFECTLAYER","_isReadyForMesh","_cameraDrawRenderTargetStage","STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER","_renderMainTexture","_beforeCameraDrawStage","STEP_BEFORECAMERADRAW_EFFECTLAYER","_setStencil","_afterRenderingGroupDrawStage","STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW","_drawRenderingGroup","_afterCameraDrawStage","STEP_AFTERCAMERADRAW_EFFECTLAYER","_setStencilBack","STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW","_drawCamera","rebuild","layers","_rebuild","serialize","serializationObject","addFromContainer","forEach","o","removeFromContainer","dispose","mesh","hardwareInstancedRendering","currentRenderPassId","layer","hasMesh","renderTarget","_mainTexture","renderPassId","subMesh","subMeshes","isReady","camera","needRebind","getStencilBuffer","shouldRender","cameraRigMode","RIG_MODE_NONE","_rigCameras","needStencil","_shouldRender","incrementRenderId","render","setStencilBuffer","_draw","renderingGroupId","setDepthBuffer","i","_isInIntermediateRendering","_SceneComponentInitialization","component","_getComponent","_addComponent"],"sources":["../../../../dev/core/src/Layers/effectLayerSceneComponent.ts"],"sourcesContent":["import { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { ISceneSerializableComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { EffectLayer } from \"./effectLayer\";\r\nimport { AbstractScene } from \"../abstractScene\";\r\nimport type { AssetContainer } from \"../assetContainer\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n// Adds the parser to the scene parsers.\r\nAbstractScene.AddParser(SceneComponentConstants.NAME_EFFECTLAYER, (parsedData: any, scene: Scene, container: AssetContainer, rootUrl: string) => {\r\n    if (parsedData.effectLayers) {\r\n        if (!container.effectLayers) {\r\n            container.effectLayers = new Array<EffectLayer>();\r\n        }\r\n\r\n        for (let index = 0; index < parsedData.effectLayers.length; index++) {\r\n            const effectLayer = EffectLayer.Parse(parsedData.effectLayers[index], scene, rootUrl);\r\n            container.effectLayers.push(effectLayer);\r\n        }\r\n    }\r\n});\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * The list of effect layers (highlights/glow) added to the scene\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/highlightLayer\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/glowLayer\r\n         */\r\n        effectLayers: Array<EffectLayer>;\r\n\r\n        /**\r\n         * Removes the given effect layer from this scene.\r\n         * @param toRemove defines the effect layer to remove\r\n         * @returns the index of the removed effect layer\r\n         */\r\n        removeEffectLayer(toRemove: EffectLayer): number;\r\n\r\n        /**\r\n         * Adds the given effect layer to this scene\r\n         * @param newEffectLayer defines the effect layer to add\r\n         */\r\n        addEffectLayer(newEffectLayer: EffectLayer): void;\r\n    }\r\n}\r\n\r\nAbstractScene.prototype.removeEffectLayer = function (toRemove: EffectLayer): number {\r\n    const index = this.effectLayers.indexOf(toRemove);\r\n    if (index !== -1) {\r\n        this.effectLayers.splice(index, 1);\r\n    }\r\n\r\n    return index;\r\n};\r\n\r\nAbstractScene.prototype.addEffectLayer = function (newEffectLayer: EffectLayer): void {\r\n    this.effectLayers.push(newEffectLayer);\r\n};\r\n\r\n/**\r\n * Defines the layer scene component responsible to manage any effect layers\r\n * in a given scene.\r\n */\r\nexport class EffectLayerSceneComponent implements ISceneSerializableComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_EFFECTLAYER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    private _engine: Engine;\r\n    private _renderEffects = false;\r\n    private _needStencil = false;\r\n    private _previousStencilState = false;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene?: Scene) {\r\n        this.scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        if (!this.scene) {\r\n            return;\r\n        }\r\n        this._engine = this.scene.getEngine();\r\n        this.scene.effectLayers = new Array<EffectLayer>();\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._isReadyForMeshStage.registerStep(SceneComponentConstants.STEP_ISREADYFORMESH_EFFECTLAYER, this, this._isReadyForMesh);\r\n\r\n        this.scene._cameraDrawRenderTargetStage.registerStep(SceneComponentConstants.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER, this, this._renderMainTexture);\r\n\r\n        this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_EFFECTLAYER, this, this._setStencil);\r\n\r\n        this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW, this, this._drawRenderingGroup);\r\n\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER, this, this._setStencilBack);\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW, this, this._drawCamera);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        const layers = this.scene.effectLayers;\r\n        for (const effectLayer of layers) {\r\n            effectLayer._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes the component data to the specified json object\r\n     * @param serializationObject The object to serialize to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        // Effect layers\r\n        serializationObject.effectLayers = [];\r\n\r\n        const layers = this.scene.effectLayers;\r\n        for (const effectLayer of layers) {\r\n            if (effectLayer.serialize) {\r\n                serializationObject.effectLayers.push(effectLayer.serialize());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    public addFromContainer(container: AbstractScene): void {\r\n        if (!container.effectLayers) {\r\n            return;\r\n        }\r\n        container.effectLayers.forEach((o) => {\r\n            this.scene.addEffectLayer(o);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    public removeFromContainer(container: AbstractScene, dispose?: boolean): void {\r\n        if (!container.effectLayers) {\r\n            return;\r\n        }\r\n        container.effectLayers.forEach((o) => {\r\n            this.scene.removeEffectLayer(o);\r\n            if (dispose) {\r\n                o.dispose();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const layers = this.scene.effectLayers;\r\n        while (layers.length) {\r\n            layers[0].dispose();\r\n        }\r\n    }\r\n\r\n    private _isReadyForMesh(mesh: AbstractMesh, hardwareInstancedRendering: boolean): boolean {\r\n        const currentRenderPassId = this._engine.currentRenderPassId;\r\n        const layers = this.scene.effectLayers;\r\n        for (const layer of layers) {\r\n            if (!layer.hasMesh(mesh)) {\r\n                continue;\r\n            }\r\n\r\n            const renderTarget = <RenderTargetTexture>(<any>layer)._mainTexture;\r\n            this._engine.currentRenderPassId = renderTarget.renderPassId;\r\n\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (!layer.isReady(subMesh, hardwareInstancedRendering)) {\r\n                    this._engine.currentRenderPassId = currentRenderPassId;\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        this._engine.currentRenderPassId = currentRenderPassId;\r\n        return true;\r\n    }\r\n\r\n    private _renderMainTexture(camera: Camera): boolean {\r\n        this._renderEffects = false;\r\n        this._needStencil = false;\r\n\r\n        let needRebind = false;\r\n\r\n        const layers = this.scene.effectLayers;\r\n        if (layers && layers.length > 0) {\r\n            this._previousStencilState = this._engine.getStencilBuffer();\r\n            for (const effectLayer of layers) {\r\n                if (\r\n                    effectLayer.shouldRender() &&\r\n                    (!effectLayer.camera ||\r\n                        (effectLayer.camera.cameraRigMode === Camera.RIG_MODE_NONE && camera === effectLayer.camera) ||\r\n                        (effectLayer.camera.cameraRigMode !== Camera.RIG_MODE_NONE && effectLayer.camera._rigCameras.indexOf(camera) > -1))\r\n                ) {\r\n                    this._renderEffects = true;\r\n                    this._needStencil = this._needStencil || effectLayer.needStencil();\r\n\r\n                    const renderTarget = <RenderTargetTexture>(<any>effectLayer)._mainTexture;\r\n                    if (renderTarget._shouldRender()) {\r\n                        this.scene.incrementRenderId();\r\n                        renderTarget.render(false, false);\r\n                        needRebind = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.scene.incrementRenderId();\r\n        }\r\n\r\n        return needRebind;\r\n    }\r\n\r\n    private _setStencil() {\r\n        // Activate effect Layer stencil\r\n        if (this._needStencil) {\r\n            this._engine.setStencilBuffer(true);\r\n        }\r\n    }\r\n\r\n    private _setStencilBack() {\r\n        // Restore effect Layer stencil\r\n        if (this._needStencil) {\r\n            this._engine.setStencilBuffer(this._previousStencilState);\r\n        }\r\n    }\r\n\r\n    private _draw(renderingGroupId: number): void {\r\n        if (this._renderEffects) {\r\n            this._engine.setDepthBuffer(false);\r\n\r\n            const layers = this.scene.effectLayers;\r\n            for (let i = 0; i < layers.length; i++) {\r\n                const effectLayer = layers[i];\r\n                if (effectLayer.renderingGroupId === renderingGroupId) {\r\n                    if (effectLayer.shouldRender()) {\r\n                        effectLayer.render();\r\n                    }\r\n                }\r\n            }\r\n            this._engine.setDepthBuffer(true);\r\n        }\r\n    }\r\n\r\n    private _drawCamera(): void {\r\n        if (this._renderEffects) {\r\n            this._draw(-1);\r\n        }\r\n    }\r\n    private _drawRenderingGroup(index: number): void {\r\n        if (!this.scene._isInIntermediateRendering() && this._renderEffects) {\r\n            this._draw(index);\r\n        }\r\n    }\r\n}\r\n\r\nEffectLayer._SceneComponentInitialization = (scene: Scene) => {\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_EFFECTLAYER) as EffectLayerSceneComponent;\r\n    if (!component) {\r\n        component = new EffectLayerSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n};\r\n"],"mappings":";AAAA,SAASA,MAAM,QAAQ,sBAAoB;AAM3C,SAASC,uBAAuB,QAAQ,sBAAoB;AAC5D,SAASC,WAAW,QAAQ,kBAAgB;AAC5C,SAASC,aAAa,QAAQ,qBAAmB;AAEjD,SAASC,WAAW,QAAQ,2BAAyB;AACrD;AACAD,aAAa,CAACE,SAAS,CAACJ,uBAAuB,CAACK,gBAAgB,EAAE,CAACC,UAAe,EAAEC,KAAY,EAAEC,SAAyB,EAAEC,OAAe,KAAI;EAC5I,IAAIH,UAAU,CAACI,YAAY,EAAE;IACzB,IAAI,CAACF,SAAS,CAACE,YAAY,EAAE;MACzBF,SAAS,CAACE,YAAY,GAAG,IAAIC,KAAK,EAAe;;IAGrD,KAAK,IAAIC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGN,UAAU,CAACI,YAAY,CAACG,MAAM,EAAED,KAAK,EAAE,EAAE;MACjE,MAAME,WAAW,GAAGb,WAAW,CAACc,KAAK,CAACT,UAAU,CAACI,YAAY,CAACE,KAAK,CAAC,EAAEL,KAAK,EAAEE,OAAO,CAAC;MACrFD,SAAS,CAACE,YAAY,CAACM,IAAI,CAACF,WAAW,CAAC;;;AAGpD,CAAC,CAAC;AA0BFZ,aAAa,CAACe,SAAS,CAACC,iBAAiB,GAAG,UAAUC,QAAqB;EACvE,MAAMP,KAAK,GAAG,IAAI,CAACF,YAAY,CAACU,OAAO,CAACD,QAAQ,CAAC;EACjD,IAAIP,KAAK,KAAK,CAAC,CAAC,EAAE;IACd,IAAI,CAACF,YAAY,CAACW,MAAM,CAACT,KAAK,EAAE,CAAC,CAAC;;EAGtC,OAAOA,KAAK;AAChB,CAAC;AAEDV,aAAa,CAACe,SAAS,CAACK,cAAc,GAAG,UAAUC,cAA2B;EAC1E,IAAI,CAACb,YAAY,CAACM,IAAI,CAACO,cAAc,CAAC;AAC1C,CAAC;AAED;;;;AAIA,OAAM,MAAOC,yBAAyB;EAgBlC;;;;EAIAC,YAAYlB,KAAa;IAnBzB;;;IAGgB,KAAAmB,IAAI,GAAG1B,uBAAuB,CAACK,gBAAgB;IAQvD,KAAAsB,cAAc,GAAG,KAAK;IACtB,KAAAC,YAAY,GAAG,KAAK;IACpB,KAAAC,qBAAqB,GAAG,KAAK;IAOjC,IAAI,CAACtB,KAAK,GAAGA,KAAK,IAAWJ,WAAW,CAAC2B,gBAAgB;IACzD,IAAI,CAAC,IAAI,CAACvB,KAAK,EAAE;MACb;;IAEJ,IAAI,CAACwB,OAAO,GAAG,IAAI,CAACxB,KAAK,CAACyB,SAAS,EAAE;IACrC,IAAI,CAACzB,KAAK,CAACG,YAAY,GAAG,IAAIC,KAAK,EAAe;EACtD;EAEA;;;EAGOsB,QAAQA,CAAA;IACX,IAAI,CAAC1B,KAAK,CAAC2B,oBAAoB,CAACC,YAAY,CAACnC,uBAAuB,CAACoC,+BAA+B,EAAE,IAAI,EAAE,IAAI,CAACC,eAAe,CAAC;IAEjI,IAAI,CAAC9B,KAAK,CAAC+B,4BAA4B,CAACH,YAAY,CAACnC,uBAAuB,CAACuC,uCAAuC,EAAE,IAAI,EAAE,IAAI,CAACC,kBAAkB,CAAC;IAEpJ,IAAI,CAACjC,KAAK,CAACkC,sBAAsB,CAACN,YAAY,CAACnC,uBAAuB,CAAC0C,iCAAiC,EAAE,IAAI,EAAE,IAAI,CAACC,WAAW,CAAC;IAEjI,IAAI,CAACpC,KAAK,CAACqC,6BAA6B,CAACT,YAAY,CAACnC,uBAAuB,CAAC6C,6CAA6C,EAAE,IAAI,EAAE,IAAI,CAACC,mBAAmB,CAAC;IAE5J,IAAI,CAACvC,KAAK,CAACwC,qBAAqB,CAACZ,YAAY,CAACnC,uBAAuB,CAACgD,gCAAgC,EAAE,IAAI,EAAE,IAAI,CAACC,eAAe,CAAC;IACnI,IAAI,CAAC1C,KAAK,CAACwC,qBAAqB,CAACZ,YAAY,CAACnC,uBAAuB,CAACkD,qCAAqC,EAAE,IAAI,EAAE,IAAI,CAACC,WAAW,CAAC;EACxI;EAEA;;;;EAIOC,OAAOA,CAAA;IACV,MAAMC,MAAM,GAAG,IAAI,CAAC9C,KAAK,CAACG,YAAY;IACtC,KAAK,MAAMI,WAAW,IAAIuC,MAAM,EAAE;MAC9BvC,WAAW,CAACwC,QAAQ,EAAE;;EAE9B;EAEA;;;;EAIOC,SAASA,CAACC,mBAAwB;IACrC;IACAA,mBAAmB,CAAC9C,YAAY,GAAG,EAAE;IAErC,MAAM2C,MAAM,GAAG,IAAI,CAAC9C,KAAK,CAACG,YAAY;IACtC,KAAK,MAAMI,WAAW,IAAIuC,MAAM,EAAE;MAC9B,IAAIvC,WAAW,CAACyC,SAAS,EAAE;QACvBC,mBAAmB,CAAC9C,YAAY,CAACM,IAAI,CAACF,WAAW,CAACyC,SAAS,EAAE,CAAC;;;EAG1E;EAEA;;;;EAIOE,gBAAgBA,CAACjD,SAAwB;IAC5C,IAAI,CAACA,SAAS,CAACE,YAAY,EAAE;MACzB;;IAEJF,SAAS,CAACE,YAAY,CAACgD,OAAO,CAAEC,CAAC,IAAI;MACjC,IAAI,CAACpD,KAAK,CAACe,cAAc,CAACqC,CAAC,CAAC;IAChC,CAAC,CAAC;EACN;EAEA;;;;;EAKOC,mBAAmBA,CAACpD,SAAwB,EAAEqD,OAAiB;IAClE,IAAI,CAACrD,SAAS,CAACE,YAAY,EAAE;MACzB;;IAEJF,SAAS,CAACE,YAAY,CAACgD,OAAO,CAAEC,CAAC,IAAI;MACjC,IAAI,CAACpD,KAAK,CAACW,iBAAiB,CAACyC,CAAC,CAAC;MAC/B,IAAIE,OAAO,EAAE;QACTF,CAAC,CAACE,OAAO,EAAE;;IAEnB,CAAC,CAAC;EACN;EAEA;;;EAGOA,OAAOA,CAAA;IACV,MAAMR,MAAM,GAAG,IAAI,CAAC9C,KAAK,CAACG,YAAY;IACtC,OAAO2C,MAAM,CAACxC,MAAM,EAAE;MAClBwC,MAAM,CAAC,CAAC,CAAC,CAACQ,OAAO,EAAE;;EAE3B;EAEQxB,eAAeA,CAACyB,IAAkB,EAAEC,0BAAmC;IAC3E,MAAMC,mBAAmB,GAAG,IAAI,CAACjC,OAAO,CAACiC,mBAAmB;IAC5D,MAAMX,MAAM,GAAG,IAAI,CAAC9C,KAAK,CAACG,YAAY;IACtC,KAAK,MAAMuD,KAAK,IAAIZ,MAAM,EAAE;MACxB,IAAI,CAACY,KAAK,CAACC,OAAO,CAACJ,IAAI,CAAC,EAAE;QACtB;;MAGJ,MAAMK,YAAY,GAA8BF,KAAM,CAACG,YAAY;MACnE,IAAI,CAACrC,OAAO,CAACiC,mBAAmB,GAAGG,YAAY,CAACE,YAAY;MAE5D,KAAK,MAAMC,OAAO,IAAIR,IAAI,CAACS,SAAS,EAAE;QAClC,IAAI,CAACN,KAAK,CAACO,OAAO,CAACF,OAAO,EAAEP,0BAA0B,CAAC,EAAE;UACrD,IAAI,CAAChC,OAAO,CAACiC,mBAAmB,GAAGA,mBAAmB;UACtD,OAAO,KAAK;;;;IAIxB,IAAI,CAACjC,OAAO,CAACiC,mBAAmB,GAAGA,mBAAmB;IACtD,OAAO,IAAI;EACf;EAEQxB,kBAAkBA,CAACiC,MAAc;IACrC,IAAI,CAAC9C,cAAc,GAAG,KAAK;IAC3B,IAAI,CAACC,YAAY,GAAG,KAAK;IAEzB,IAAI8C,UAAU,GAAG,KAAK;IAEtB,MAAMrB,MAAM,GAAG,IAAI,CAAC9C,KAAK,CAACG,YAAY;IACtC,IAAI2C,MAAM,IAAIA,MAAM,CAACxC,MAAM,GAAG,CAAC,EAAE;MAC7B,IAAI,CAACgB,qBAAqB,GAAG,IAAI,CAACE,OAAO,CAAC4C,gBAAgB,EAAE;MAC5D,KAAK,MAAM7D,WAAW,IAAIuC,MAAM,EAAE;QAC9B,IACIvC,WAAW,CAAC8D,YAAY,EAAE,KACzB,CAAC9D,WAAW,CAAC2D,MAAM,IACf3D,WAAW,CAAC2D,MAAM,CAACI,aAAa,KAAK9E,MAAM,CAAC+E,aAAa,IAAIL,MAAM,KAAK3D,WAAW,CAAC2D,MAAO,IAC3F3D,WAAW,CAAC2D,MAAM,CAACI,aAAa,KAAK9E,MAAM,CAAC+E,aAAa,IAAIhE,WAAW,CAAC2D,MAAM,CAACM,WAAW,CAAC3D,OAAO,CAACqD,MAAM,CAAC,GAAG,CAAC,CAAE,CAAC,EACzH;UACE,IAAI,CAAC9C,cAAc,GAAG,IAAI;UAC1B,IAAI,CAACC,YAAY,GAAG,IAAI,CAACA,YAAY,IAAId,WAAW,CAACkE,WAAW,EAAE;UAElE,MAAMb,YAAY,GAA8BrD,WAAY,CAACsD,YAAY;UACzE,IAAID,YAAY,CAACc,aAAa,EAAE,EAAE;YAC9B,IAAI,CAAC1E,KAAK,CAAC2E,iBAAiB,EAAE;YAC9Bf,YAAY,CAACgB,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC;YACjCT,UAAU,GAAG,IAAI;;;;MAK7B,IAAI,CAACnE,KAAK,CAAC2E,iBAAiB,EAAE;;IAGlC,OAAOR,UAAU;EACrB;EAEQ/B,WAAWA,CAAA;IACf;IACA,IAAI,IAAI,CAACf,YAAY,EAAE;MACnB,IAAI,CAACG,OAAO,CAACqD,gBAAgB,CAAC,IAAI,CAAC;;EAE3C;EAEQnC,eAAeA,CAAA;IACnB;IACA,IAAI,IAAI,CAACrB,YAAY,EAAE;MACnB,IAAI,CAACG,OAAO,CAACqD,gBAAgB,CAAC,IAAI,CAACvD,qBAAqB,CAAC;;EAEjE;EAEQwD,KAAKA,CAACC,gBAAwB;IAClC,IAAI,IAAI,CAAC3D,cAAc,EAAE;MACrB,IAAI,CAACI,OAAO,CAACwD,cAAc,CAAC,KAAK,CAAC;MAElC,MAAMlC,MAAM,GAAG,IAAI,CAAC9C,KAAK,CAACG,YAAY;MACtC,KAAK,IAAI8E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnC,MAAM,CAACxC,MAAM,EAAE2E,CAAC,EAAE,EAAE;QACpC,MAAM1E,WAAW,GAAGuC,MAAM,CAACmC,CAAC,CAAC;QAC7B,IAAI1E,WAAW,CAACwE,gBAAgB,KAAKA,gBAAgB,EAAE;UACnD,IAAIxE,WAAW,CAAC8D,YAAY,EAAE,EAAE;YAC5B9D,WAAW,CAACqE,MAAM,EAAE;;;;MAIhC,IAAI,CAACpD,OAAO,CAACwD,cAAc,CAAC,IAAI,CAAC;;EAEzC;EAEQpC,WAAWA,CAAA;IACf,IAAI,IAAI,CAACxB,cAAc,EAAE;MACrB,IAAI,CAAC0D,KAAK,CAAC,CAAC,CAAC,CAAC;;EAEtB;EACQvC,mBAAmBA,CAAClC,KAAa;IACrC,IAAI,CAAC,IAAI,CAACL,KAAK,CAACkF,0BAA0B,EAAE,IAAI,IAAI,CAAC9D,cAAc,EAAE;MACjE,IAAI,CAAC0D,KAAK,CAACzE,KAAK,CAAC;;EAEzB;;AAGJX,WAAW,CAACyF,6BAA6B,GAAInF,KAAY,IAAI;EACzD,IAAIoF,SAAS,GAAGpF,KAAK,CAACqF,aAAa,CAAC5F,uBAAuB,CAACK,gBAAgB,CAA8B;EAC1G,IAAI,CAACsF,SAAS,EAAE;IACZA,SAAS,GAAG,IAAInE,yBAAyB,CAACjB,KAAK,CAAC;IAChDA,KAAK,CAACsF,aAAa,CAACF,SAAS,CAAC;;AAEtC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}