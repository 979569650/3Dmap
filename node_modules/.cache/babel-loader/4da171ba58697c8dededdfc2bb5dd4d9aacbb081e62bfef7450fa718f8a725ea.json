{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { WebGPUDataBuffer } from \"../../Meshes/WebGPU/webgpuDataBuffer.js\";\nimport { FromHalfFloat } from \"../../Misc/textureTools.js\";\nimport { allocateAndCopyTypedBuffer } from \"../Extensions/engine.readTexture.js\";\nimport * as WebGPUConstants from \"./webgpuConstants.js\";\n/** @internal */\nexport class WebGPUBufferManager {\n  static _IsGPUBuffer(buffer) {\n    return buffer.underlyingResource === undefined;\n  }\n  static _FlagsToString(flags, suffix = \"\") {\n    let result = suffix;\n    for (let i = 0; i <= 9; ++i) {\n      if (flags & 1 << i) {\n        if (result) {\n          result += \"_\";\n        }\n        result += WebGPUConstants.BufferUsage[1 << i];\n      }\n    }\n    return result;\n  }\n  constructor(device) {\n    this._deferredReleaseBuffers = [];\n    this._device = device;\n  }\n  createRawBuffer(viewOrSize, flags, mappedAtCreation = false, label) {\n    const alignedLength = viewOrSize.byteLength !== undefined ? viewOrSize.byteLength + 3 & ~3 : viewOrSize + 3 & ~3; // 4 bytes alignments (because of the upload which requires this)\n    const verticesBufferDescriptor = {\n      label: WebGPUBufferManager._FlagsToString(flags, label !== null && label !== void 0 ? label : \"Buffer\") + \"_size\" + alignedLength,\n      mappedAtCreation,\n      size: alignedLength,\n      usage: flags\n    };\n    return this._device.createBuffer(verticesBufferDescriptor);\n  }\n  createBuffer(viewOrSize, flags, label) {\n    const isView = viewOrSize.byteLength !== undefined;\n    const buffer = this.createRawBuffer(viewOrSize, flags, undefined, label);\n    const dataBuffer = new WebGPUDataBuffer(buffer);\n    dataBuffer.references = 1;\n    dataBuffer.capacity = isView ? viewOrSize.byteLength : viewOrSize;\n    if (isView) {\n      this.setSubData(dataBuffer, 0, viewOrSize);\n    }\n    return dataBuffer;\n  }\n  setRawData(buffer, dstByteOffset, src, srcByteOffset, byteLength) {\n    this._device.queue.writeBuffer(buffer, dstByteOffset, src.buffer, srcByteOffset, byteLength);\n  }\n  setSubData(dataBuffer, dstByteOffset, src, srcByteOffset = 0, byteLength = 0) {\n    const buffer = dataBuffer.underlyingResource;\n    byteLength = byteLength || src.byteLength;\n    byteLength = Math.min(byteLength, dataBuffer.capacity - dstByteOffset);\n    // After Migration to Canary\n    let chunkStart = src.byteOffset + srcByteOffset;\n    let chunkEnd = chunkStart + byteLength;\n    // 4 bytes alignments for upload\n    const alignedLength = byteLength + 3 & ~3;\n    if (alignedLength !== byteLength) {\n      const tempView = new Uint8Array(src.buffer.slice(chunkStart, chunkEnd));\n      src = new Uint8Array(alignedLength);\n      src.set(tempView);\n      srcByteOffset = 0;\n      chunkStart = 0;\n      chunkEnd = alignedLength;\n      byteLength = alignedLength;\n    }\n    // Chunk\n    const maxChunk = 1024 * 1024 * 15;\n    let offset = 0;\n    while (chunkEnd - (chunkStart + offset) > maxChunk) {\n      this._device.queue.writeBuffer(buffer, dstByteOffset + offset, src.buffer, chunkStart + offset, maxChunk);\n      offset += maxChunk;\n    }\n    this._device.queue.writeBuffer(buffer, dstByteOffset + offset, src.buffer, chunkStart + offset, byteLength - offset);\n  }\n  _getHalfFloatAsFloatRGBAArrayBuffer(dataLength, arrayBuffer, destArray) {\n    if (!destArray) {\n      destArray = new Float32Array(dataLength);\n    }\n    const srcData = new Uint16Array(arrayBuffer);\n    while (dataLength--) {\n      destArray[dataLength] = FromHalfFloat(srcData[dataLength]);\n    }\n    return destArray;\n  }\n  readDataFromBuffer(gpuBuffer, size, width, height, bytesPerRow, bytesPerRowAligned, type = 0, offset = 0, buffer = null, destroyBuffer = true, noDataConversion = false) {\n    const floatFormat = type === 1 ? 2 : type === 2 ? 1 : 0;\n    return new Promise((resolve, reject) => {\n      gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read, offset, size).then(() => {\n        const copyArrayBuffer = gpuBuffer.getMappedRange(offset, size);\n        let data = buffer;\n        if (noDataConversion) {\n          if (data === null) {\n            data = allocateAndCopyTypedBuffer(type, size, true, copyArrayBuffer);\n          } else {\n            data = allocateAndCopyTypedBuffer(type, data.buffer, undefined, copyArrayBuffer);\n          }\n        } else {\n          if (data === null) {\n            switch (floatFormat) {\n              case 0:\n                // byte format\n                data = new Uint8Array(size);\n                data.set(new Uint8Array(copyArrayBuffer));\n                break;\n              case 1:\n                // half float\n                // TODO WEBGPU use computer shaders (or render pass) to make the conversion?\n                data = this._getHalfFloatAsFloatRGBAArrayBuffer(size / 2, copyArrayBuffer);\n                break;\n              case 2:\n                // float\n                data = new Float32Array(size / 4);\n                data.set(new Float32Array(copyArrayBuffer));\n                break;\n            }\n          } else {\n            switch (floatFormat) {\n              case 0:\n                // byte format\n                data = new Uint8Array(data.buffer);\n                data.set(new Uint8Array(copyArrayBuffer));\n                break;\n              case 1:\n                // half float\n                // TODO WEBGPU use computer shaders (or render pass) to make the conversion?\n                data = this._getHalfFloatAsFloatRGBAArrayBuffer(size / 2, copyArrayBuffer, buffer);\n                break;\n              case 2:\n                // float\n                data = new Float32Array(data.buffer);\n                data.set(new Float32Array(copyArrayBuffer));\n                break;\n            }\n          }\n        }\n        if (bytesPerRow !== bytesPerRowAligned) {\n          // TODO WEBGPU use computer shaders (or render pass) to build the final buffer data?\n          if (floatFormat === 1 && !noDataConversion) {\n            // half float have been converted to float above\n            bytesPerRow *= 2;\n            bytesPerRowAligned *= 2;\n          }\n          const data2 = new Uint8Array(data.buffer);\n          let offset = bytesPerRow,\n            offset2 = 0;\n          for (let y = 1; y < height; ++y) {\n            offset2 = y * bytesPerRowAligned;\n            for (let x = 0; x < bytesPerRow; ++x) {\n              data2[offset++] = data2[offset2++];\n            }\n          }\n          if (floatFormat !== 0 && !noDataConversion) {\n            data = new Float32Array(data2.buffer, 0, offset / 4);\n          } else {\n            data = new Uint8Array(data2.buffer, 0, offset);\n          }\n        }\n        gpuBuffer.unmap();\n        if (destroyBuffer) {\n          this.releaseBuffer(gpuBuffer);\n        }\n        resolve(data);\n      }, reason => reject(reason));\n    });\n  }\n  releaseBuffer(buffer) {\n    if (WebGPUBufferManager._IsGPUBuffer(buffer)) {\n      this._deferredReleaseBuffers.push(buffer);\n      return true;\n    }\n    buffer.references--;\n    if (buffer.references === 0) {\n      this._deferredReleaseBuffers.push(buffer.underlyingResource);\n      return true;\n    }\n    return false;\n  }\n  destroyDeferredBuffers() {\n    for (let i = 0; i < this._deferredReleaseBuffers.length; ++i) {\n      this._deferredReleaseBuffers[i].destroy();\n    }\n    this._deferredReleaseBuffers.length = 0;\n  }\n}","map":{"version":3,"names":["WebGPUDataBuffer","FromHalfFloat","allocateAndCopyTypedBuffer","WebGPUConstants","WebGPUBufferManager","_IsGPUBuffer","buffer","underlyingResource","undefined","_FlagsToString","flags","suffix","result","i","BufferUsage","constructor","device","_deferredReleaseBuffers","_device","createRawBuffer","viewOrSize","mappedAtCreation","label","alignedLength","byteLength","verticesBufferDescriptor","size","usage","createBuffer","isView","dataBuffer","references","capacity","setSubData","setRawData","dstByteOffset","src","srcByteOffset","queue","writeBuffer","Math","min","chunkStart","byteOffset","chunkEnd","tempView","Uint8Array","slice","set","maxChunk","offset","_getHalfFloatAsFloatRGBAArrayBuffer","dataLength","arrayBuffer","destArray","Float32Array","srcData","Uint16Array","readDataFromBuffer","gpuBuffer","width","height","bytesPerRow","bytesPerRowAligned","type","destroyBuffer","noDataConversion","floatFormat","Promise","resolve","reject","mapAsync","MapMode","Read","then","copyArrayBuffer","getMappedRange","data","data2","offset2","y","x","unmap","releaseBuffer","reason","push","destroyDeferredBuffers","length","destroy"],"sources":["../../../../../dev/core/src/Engines/WebGPU/webgpuBufferManager.ts"],"sourcesContent":["import type { DataBuffer } from \"../../Buffers/dataBuffer\";\r\nimport { WebGPUDataBuffer } from \"../../Meshes/WebGPU/webgpuDataBuffer\";\r\nimport { FromHalfFloat } from \"../../Misc/textureTools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../constants\";\r\nimport { allocateAndCopyTypedBuffer } from \"../Extensions/engine.readTexture\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\n\r\n/** @internal */\r\nexport class WebGPUBufferManager {\r\n    private _device: GPUDevice;\r\n    private _deferredReleaseBuffers: Array<GPUBuffer> = [];\r\n\r\n    private static _IsGPUBuffer(buffer: DataBuffer | GPUBuffer): buffer is GPUBuffer {\r\n        return (buffer as DataBuffer).underlyingResource === undefined;\r\n    }\r\n\r\n    private static _FlagsToString(flags: GPUBufferUsageFlags, suffix = \"\") {\r\n        let result = suffix;\r\n\r\n        for (let i = 0; i <= 9; ++i) {\r\n            if (flags & (1 << i)) {\r\n                if (result) {\r\n                    result += \"_\";\r\n                }\r\n                result += WebGPUConstants.BufferUsage[1 << i];\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    constructor(device: GPUDevice) {\r\n        this._device = device;\r\n    }\r\n\r\n    public createRawBuffer(viewOrSize: ArrayBufferView | number, flags: GPUBufferUsageFlags, mappedAtCreation = false, label?: string): GPUBuffer {\r\n        const alignedLength = (viewOrSize as ArrayBufferView).byteLength !== undefined ? ((viewOrSize as ArrayBufferView).byteLength + 3) & ~3 : ((viewOrSize as number) + 3) & ~3; // 4 bytes alignments (because of the upload which requires this)\r\n        const verticesBufferDescriptor = {\r\n            label: WebGPUBufferManager._FlagsToString(flags, label ?? \"Buffer\") + \"_size\" + alignedLength,\r\n            mappedAtCreation,\r\n            size: alignedLength,\r\n            usage: flags,\r\n        };\r\n\r\n        return this._device.createBuffer(verticesBufferDescriptor);\r\n    }\r\n\r\n    public createBuffer(viewOrSize: ArrayBufferView | number, flags: GPUBufferUsageFlags, label?: string): WebGPUDataBuffer {\r\n        const isView = (viewOrSize as ArrayBufferView).byteLength !== undefined;\r\n        const buffer = this.createRawBuffer(viewOrSize, flags, undefined, label);\r\n        const dataBuffer = new WebGPUDataBuffer(buffer);\r\n        dataBuffer.references = 1;\r\n        dataBuffer.capacity = isView ? (viewOrSize as ArrayBufferView).byteLength : (viewOrSize as number);\r\n\r\n        if (isView) {\r\n            this.setSubData(dataBuffer, 0, viewOrSize as ArrayBufferView);\r\n        }\r\n\r\n        return dataBuffer;\r\n    }\r\n\r\n    public setRawData(buffer: GPUBuffer, dstByteOffset: number, src: ArrayBufferView, srcByteOffset: number, byteLength: number): void {\r\n        this._device.queue.writeBuffer(buffer, dstByteOffset, src.buffer, srcByteOffset, byteLength);\r\n    }\r\n\r\n    public setSubData(dataBuffer: WebGPUDataBuffer, dstByteOffset: number, src: ArrayBufferView, srcByteOffset = 0, byteLength = 0): void {\r\n        const buffer = dataBuffer.underlyingResource as GPUBuffer;\r\n\r\n        byteLength = byteLength || src.byteLength;\r\n        byteLength = Math.min(byteLength, dataBuffer.capacity - dstByteOffset);\r\n\r\n        // After Migration to Canary\r\n        let chunkStart = src.byteOffset + srcByteOffset;\r\n        let chunkEnd = chunkStart + byteLength;\r\n\r\n        // 4 bytes alignments for upload\r\n        const alignedLength = (byteLength + 3) & ~3;\r\n        if (alignedLength !== byteLength) {\r\n            const tempView = new Uint8Array(src.buffer.slice(chunkStart, chunkEnd));\r\n            src = new Uint8Array(alignedLength);\r\n            (src as Uint8Array).set(tempView);\r\n            srcByteOffset = 0;\r\n            chunkStart = 0;\r\n            chunkEnd = alignedLength;\r\n            byteLength = alignedLength;\r\n        }\r\n\r\n        // Chunk\r\n        const maxChunk = 1024 * 1024 * 15;\r\n        let offset = 0;\r\n        while (chunkEnd - (chunkStart + offset) > maxChunk) {\r\n            this._device.queue.writeBuffer(buffer, dstByteOffset + offset, src.buffer, chunkStart + offset, maxChunk);\r\n            offset += maxChunk;\r\n        }\r\n\r\n        this._device.queue.writeBuffer(buffer, dstByteOffset + offset, src.buffer, chunkStart + offset, byteLength - offset);\r\n    }\r\n\r\n    private _getHalfFloatAsFloatRGBAArrayBuffer(dataLength: number, arrayBuffer: ArrayBuffer, destArray?: Float32Array): Float32Array {\r\n        if (!destArray) {\r\n            destArray = new Float32Array(dataLength);\r\n        }\r\n        const srcData = new Uint16Array(arrayBuffer);\r\n        while (dataLength--) {\r\n            destArray[dataLength] = FromHalfFloat(srcData[dataLength]);\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    public readDataFromBuffer(\r\n        gpuBuffer: GPUBuffer,\r\n        size: number,\r\n        width: number,\r\n        height: number,\r\n        bytesPerRow: number,\r\n        bytesPerRowAligned: number,\r\n        type = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        offset = 0,\r\n        buffer: Nullable<ArrayBufferView> = null,\r\n        destroyBuffer = true,\r\n        noDataConversion = false\r\n    ): Promise<ArrayBufferView> {\r\n        const floatFormat = type === Constants.TEXTURETYPE_FLOAT ? 2 : type === Constants.TEXTURETYPE_HALF_FLOAT ? 1 : 0;\r\n        return new Promise((resolve, reject) => {\r\n            gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read, offset, size).then(\r\n                () => {\r\n                    const copyArrayBuffer = gpuBuffer.getMappedRange(offset, size);\r\n                    let data: Nullable<ArrayBufferView> | Uint8Array | Float32Array = buffer;\r\n                    if (noDataConversion) {\r\n                        if (data === null) {\r\n                            data = allocateAndCopyTypedBuffer(type, size, true, copyArrayBuffer);\r\n                        } else {\r\n                            data = allocateAndCopyTypedBuffer(type, data.buffer, undefined, copyArrayBuffer);\r\n                        }\r\n                    } else {\r\n                        if (data === null) {\r\n                            switch (floatFormat) {\r\n                                case 0: // byte format\r\n                                    data = new Uint8Array(size);\r\n                                    (data as Uint8Array).set(new Uint8Array(copyArrayBuffer));\r\n                                    break;\r\n                                case 1: // half float\r\n                                    // TODO WEBGPU use computer shaders (or render pass) to make the conversion?\r\n                                    data = this._getHalfFloatAsFloatRGBAArrayBuffer(size / 2, copyArrayBuffer);\r\n                                    break;\r\n                                case 2: // float\r\n                                    data = new Float32Array(size / 4);\r\n                                    (data as Float32Array).set(new Float32Array(copyArrayBuffer));\r\n                                    break;\r\n                            }\r\n                        } else {\r\n                            switch (floatFormat) {\r\n                                case 0: // byte format\r\n                                    data = new Uint8Array(data.buffer);\r\n                                    (data as Uint8Array).set(new Uint8Array(copyArrayBuffer));\r\n                                    break;\r\n                                case 1: // half float\r\n                                    // TODO WEBGPU use computer shaders (or render pass) to make the conversion?\r\n                                    data = this._getHalfFloatAsFloatRGBAArrayBuffer(size / 2, copyArrayBuffer, buffer as Float32Array);\r\n                                    break;\r\n                                case 2: // float\r\n                                    data = new Float32Array(data.buffer);\r\n                                    (data as Float32Array).set(new Float32Array(copyArrayBuffer));\r\n                                    break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (bytesPerRow !== bytesPerRowAligned) {\r\n                        // TODO WEBGPU use computer shaders (or render pass) to build the final buffer data?\r\n                        if (floatFormat === 1 && !noDataConversion) {\r\n                            // half float have been converted to float above\r\n                            bytesPerRow *= 2;\r\n                            bytesPerRowAligned *= 2;\r\n                        }\r\n                        const data2 = new Uint8Array(data!.buffer);\r\n                        let offset = bytesPerRow,\r\n                            offset2 = 0;\r\n                        for (let y = 1; y < height; ++y) {\r\n                            offset2 = y * bytesPerRowAligned;\r\n                            for (let x = 0; x < bytesPerRow; ++x) {\r\n                                data2[offset++] = data2[offset2++];\r\n                            }\r\n                        }\r\n                        if (floatFormat !== 0 && !noDataConversion) {\r\n                            data = new Float32Array(data2.buffer, 0, offset / 4);\r\n                        } else {\r\n                            data = new Uint8Array(data2.buffer, 0, offset);\r\n                        }\r\n                    }\r\n                    gpuBuffer.unmap();\r\n                    if (destroyBuffer) {\r\n                        this.releaseBuffer(gpuBuffer);\r\n                    }\r\n                    resolve(data!);\r\n                },\r\n                (reason) => reject(reason)\r\n            );\r\n        });\r\n    }\r\n\r\n    public releaseBuffer(buffer: DataBuffer | GPUBuffer): boolean {\r\n        if (WebGPUBufferManager._IsGPUBuffer(buffer)) {\r\n            this._deferredReleaseBuffers.push(buffer);\r\n            return true;\r\n        }\r\n\r\n        buffer.references--;\r\n\r\n        if (buffer.references === 0) {\r\n            this._deferredReleaseBuffers.push(buffer.underlyingResource as GPUBuffer);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public destroyDeferredBuffers(): void {\r\n        for (let i = 0; i < this._deferredReleaseBuffers.length; ++i) {\r\n            this._deferredReleaseBuffers[i].destroy();\r\n        }\r\n\r\n        this._deferredReleaseBuffers.length = 0;\r\n    }\r\n}\r\n"],"mappings":";;;;AACA,SAASA,gBAAgB,QAAQ,yCAAuC;AACxE,SAASC,aAAa,QAAQ,4BAA0B;AAGxD,SAASC,0BAA0B,QAAQ,qCAAmC;AAC9E,OAAO,KAAKC,eAAe,MAAM,sBAAoB;AAErD;AACA,OAAM,MAAOC,mBAAmB;EAIpB,OAAOC,YAAYA,CAACC,MAA8B;IACtD,OAAQA,MAAqB,CAACC,kBAAkB,KAAKC,SAAS;EAClE;EAEQ,OAAOC,cAAcA,CAACC,KAA0B,EAAEC,MAAM,GAAG,EAAE;IACjE,IAAIC,MAAM,GAAGD,MAAM;IAEnB,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE,EAAEA,CAAC,EAAE;MACzB,IAAIH,KAAK,GAAI,CAAC,IAAIG,CAAE,EAAE;QAClB,IAAID,MAAM,EAAE;UACRA,MAAM,IAAI,GAAG;;QAEjBA,MAAM,IAAIT,eAAe,CAACW,WAAW,CAAC,CAAC,IAAID,CAAC,CAAC;;;IAIrD,OAAOD,MAAM;EACjB;EAEAG,YAAYC,MAAiB;IArBrB,KAAAC,uBAAuB,GAAqB,EAAE;IAsBlD,IAAI,CAACC,OAAO,GAAGF,MAAM;EACzB;EAEOG,eAAeA,CAACC,UAAoC,EAAEV,KAA0B,EAAEW,gBAAgB,GAAG,KAAK,EAAEC,KAAc;IAC7H,MAAMC,aAAa,GAAIH,UAA8B,CAACI,UAAU,KAAKhB,SAAS,GAAKY,UAA8B,CAACI,UAAU,GAAG,CAAC,GAAI,CAAC,CAAC,GAAKJ,UAAqB,GAAG,CAAC,GAAI,CAAC,CAAC,CAAC,CAAC;IAC5K,MAAMK,wBAAwB,GAAG;MAC7BH,KAAK,EAAElB,mBAAmB,CAACK,cAAc,CAACC,KAAK,EAAEY,KAAK,aAALA,KAAK,cAALA,KAAK,GAAI,QAAQ,CAAC,GAAG,OAAO,GAAGC,aAAa;MAC7FF,gBAAgB;MAChBK,IAAI,EAAEH,aAAa;MACnBI,KAAK,EAAEjB;KACV;IAED,OAAO,IAAI,CAACQ,OAAO,CAACU,YAAY,CAACH,wBAAwB,CAAC;EAC9D;EAEOG,YAAYA,CAACR,UAAoC,EAAEV,KAA0B,EAAEY,KAAc;IAChG,MAAMO,MAAM,GAAIT,UAA8B,CAACI,UAAU,KAAKhB,SAAS;IACvE,MAAMF,MAAM,GAAG,IAAI,CAACa,eAAe,CAACC,UAAU,EAAEV,KAAK,EAAEF,SAAS,EAAEc,KAAK,CAAC;IACxE,MAAMQ,UAAU,GAAG,IAAI9B,gBAAgB,CAACM,MAAM,CAAC;IAC/CwB,UAAU,CAACC,UAAU,GAAG,CAAC;IACzBD,UAAU,CAACE,QAAQ,GAAGH,MAAM,GAAIT,UAA8B,CAACI,UAAU,GAAIJ,UAAqB;IAElG,IAAIS,MAAM,EAAE;MACR,IAAI,CAACI,UAAU,CAACH,UAAU,EAAE,CAAC,EAAEV,UAA6B,CAAC;;IAGjE,OAAOU,UAAU;EACrB;EAEOI,UAAUA,CAAC5B,MAAiB,EAAE6B,aAAqB,EAAEC,GAAoB,EAAEC,aAAqB,EAAEb,UAAkB;IACvH,IAAI,CAACN,OAAO,CAACoB,KAAK,CAACC,WAAW,CAACjC,MAAM,EAAE6B,aAAa,EAAEC,GAAG,CAAC9B,MAAM,EAAE+B,aAAa,EAAEb,UAAU,CAAC;EAChG;EAEOS,UAAUA,CAACH,UAA4B,EAAEK,aAAqB,EAAEC,GAAoB,EAAEC,aAAa,GAAG,CAAC,EAAEb,UAAU,GAAG,CAAC;IAC1H,MAAMlB,MAAM,GAAGwB,UAAU,CAACvB,kBAA+B;IAEzDiB,UAAU,GAAGA,UAAU,IAAIY,GAAG,CAACZ,UAAU;IACzCA,UAAU,GAAGgB,IAAI,CAACC,GAAG,CAACjB,UAAU,EAAEM,UAAU,CAACE,QAAQ,GAAGG,aAAa,CAAC;IAEtE;IACA,IAAIO,UAAU,GAAGN,GAAG,CAACO,UAAU,GAAGN,aAAa;IAC/C,IAAIO,QAAQ,GAAGF,UAAU,GAAGlB,UAAU;IAEtC;IACA,MAAMD,aAAa,GAAIC,UAAU,GAAG,CAAC,GAAI,CAAC,CAAC;IAC3C,IAAID,aAAa,KAAKC,UAAU,EAAE;MAC9B,MAAMqB,QAAQ,GAAG,IAAIC,UAAU,CAACV,GAAG,CAAC9B,MAAM,CAACyC,KAAK,CAACL,UAAU,EAAEE,QAAQ,CAAC,CAAC;MACvER,GAAG,GAAG,IAAIU,UAAU,CAACvB,aAAa,CAAC;MAClCa,GAAkB,CAACY,GAAG,CAACH,QAAQ,CAAC;MACjCR,aAAa,GAAG,CAAC;MACjBK,UAAU,GAAG,CAAC;MACdE,QAAQ,GAAGrB,aAAa;MACxBC,UAAU,GAAGD,aAAa;;IAG9B;IACA,MAAM0B,QAAQ,GAAG,IAAI,GAAG,IAAI,GAAG,EAAE;IACjC,IAAIC,MAAM,GAAG,CAAC;IACd,OAAON,QAAQ,IAAIF,UAAU,GAAGQ,MAAM,CAAC,GAAGD,QAAQ,EAAE;MAChD,IAAI,CAAC/B,OAAO,CAACoB,KAAK,CAACC,WAAW,CAACjC,MAAM,EAAE6B,aAAa,GAAGe,MAAM,EAAEd,GAAG,CAAC9B,MAAM,EAAEoC,UAAU,GAAGQ,MAAM,EAAED,QAAQ,CAAC;MACzGC,MAAM,IAAID,QAAQ;;IAGtB,IAAI,CAAC/B,OAAO,CAACoB,KAAK,CAACC,WAAW,CAACjC,MAAM,EAAE6B,aAAa,GAAGe,MAAM,EAAEd,GAAG,CAAC9B,MAAM,EAAEoC,UAAU,GAAGQ,MAAM,EAAE1B,UAAU,GAAG0B,MAAM,CAAC;EACxH;EAEQC,mCAAmCA,CAACC,UAAkB,EAAEC,WAAwB,EAAEC,SAAwB;IAC9G,IAAI,CAACA,SAAS,EAAE;MACZA,SAAS,GAAG,IAAIC,YAAY,CAACH,UAAU,CAAC;;IAE5C,MAAMI,OAAO,GAAG,IAAIC,WAAW,CAACJ,WAAW,CAAC;IAC5C,OAAOD,UAAU,EAAE,EAAE;MACjBE,SAAS,CAACF,UAAU,CAAC,GAAGnD,aAAa,CAACuD,OAAO,CAACJ,UAAU,CAAC,CAAC;;IAG9D,OAAOE,SAAS;EACpB;EAEOI,kBAAkBA,CACrBC,SAAoB,EACpBjC,IAAY,EACZkC,KAAa,EACbC,MAAc,EACdC,WAAmB,EACnBC,kBAA0B,EAC1BC,IAAI,GAAG,GAAAd,MAAS,GAAC,GAAA5C,MAAA,SAAA2D,aACX,GAAG,IACT,EAAAC,gBACA,UAAa;IAGb,MAAMC,WAAW,GAAGH,IAAI,KAAK,QAAAA,IAAU;IACvC,OAAO,IAAII,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAI;MACnCX,SAAS,CAACY,QAAQ,CAACpE,eAAe,CAACqE,OAAO,CAACC,IAAI,EAAEvB,MAAM,EAAExB,IAAI,CAAC,CAACgD,IAAI,CAC/D,MAAK;QACD,MAAMC,eAAe,GAAGhB,SAAS,CAACiB,cAAc,CAAC1B,MAAM,EAAExB,IAAI,CAAC;QAC9D,IAAImD,IAAI,GAA0DvE,MAAM;QACxE,IAAI4D,gBAAgB,EAAE;UAClB,IAAIW,IAAI,KAAK,IAAI,EAAE;YACfA,IAAI,GAAG3E,0BAA0B,CAAC8D,IAAI,EAAEtC,IAAI,EAAE,IAAI,EAAEiD,eAAe,CAAC;WACvE,MAAM;YACHE,IAAI,GAAG3E,0BAA0B,CAAC8D,IAAI,EAAEa,IAAI,CAACvE,MAAM,EAAEE,SAAS,EAAEmE,eAAe,CAAC;;SAEvF,MAAM;UACH,IAAIE,IAAI,KAAK,IAAI,EAAE;YACf,QAAQV,WAAW;cACf,KAAK,CAAC;gBAAE;gBACJU,IAAI,GAAG,IAAI/B,UAAU,CAACpB,IAAI,CAAC;gBAC1BmD,IAAmB,CAAC7B,GAAG,CAAC,IAAIF,UAAU,CAAC6B,eAAe,CAAC,CAAC;gBACzD;cACJ,KAAK,CAAC;gBAAE;gBACJ;gBACAE,IAAI,GAAG,IAAI,CAAC1B,mCAAmC,CAACzB,IAAI,GAAG,CAAC,EAAEiD,eAAe,CAAC;gBAC1E;cACJ,KAAK,CAAC;gBAAE;gBACJE,IAAI,GAAG,IAAItB,YAAY,CAAC7B,IAAI,GAAG,CAAC,CAAC;gBAChCmD,IAAqB,CAAC7B,GAAG,CAAC,IAAIO,YAAY,CAACoB,eAAe,CAAC,CAAC;gBAC7D;;WAEX,MAAM;YACH,QAAQR,WAAW;cACf,KAAK,CAAC;gBAAE;gBACJU,IAAI,GAAG,IAAI/B,UAAU,CAAC+B,IAAI,CAACvE,MAAM,CAAC;gBACjCuE,IAAmB,CAAC7B,GAAG,CAAC,IAAIF,UAAU,CAAC6B,eAAe,CAAC,CAAC;gBACzD;cACJ,KAAK,CAAC;gBAAE;gBACJ;gBACAE,IAAI,GAAG,IAAI,CAAC1B,mCAAmC,CAACzB,IAAI,GAAG,CAAC,EAAEiD,eAAe,EAAErE,MAAsB,CAAC;gBAClG;cACJ,KAAK,CAAC;gBAAE;gBACJuE,IAAI,GAAG,IAAItB,YAAY,CAACsB,IAAI,CAACvE,MAAM,CAAC;gBACnCuE,IAAqB,CAAC7B,GAAG,CAAC,IAAIO,YAAY,CAACoB,eAAe,CAAC,CAAC;gBAC7D;;;;QAIhB,IAAIb,WAAW,KAAKC,kBAAkB,EAAE;UACpC;UACA,IAAII,WAAW,KAAK,CAAC,IAAI,CAACD,gBAAgB,EAAE;YACxC;YACAJ,WAAW,IAAI,CAAC;YAChBC,kBAAkB,IAAI,CAAC;;UAE3B,MAAMe,KAAK,GAAG,IAAIhC,UAAU,CAAC+B,IAAK,CAACvE,MAAM,CAAC;UAC1C,IAAI4C,MAAM,GAAGY,WAAW;YACpBiB,OAAO,GAAG,CAAC;UACf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnB,MAAM,EAAE,EAAEmB,CAAC,EAAE;YAC7BD,OAAO,GAAGC,CAAC,GAAGjB,kBAAkB;YAChC,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnB,WAAW,EAAE,EAAEmB,CAAC,EAAE;cAClCH,KAAK,CAAC5B,MAAM,EAAE,CAAC,GAAG4B,KAAK,CAACC,OAAO,EAAE,CAAC;;;UAG1C,IAAIZ,WAAW,KAAK,CAAC,IAAI,CAACD,gBAAgB,EAAE;YACxCW,IAAI,GAAG,IAAItB,YAAY,CAACuB,KAAK,CAACxE,MAAM,EAAE,CAAC,EAAE4C,MAAM,GAAG,CAAC,CAAC;WACvD,MAAM;YACH2B,IAAI,GAAG,IAAI/B,UAAU,CAACgC,KAAK,CAACxE,MAAM,EAAE,CAAC,EAAE4C,MAAM,CAAC;;;QAGtDS,SAAS,CAACuB,KAAK,EAAE;QACjB,IAAIjB,aAAa,EAAE;UACf,IAAI,CAACkB,aAAa,CAACxB,SAAS,CAAC;;QAEjCU,OAAO,CAACQ,IAAK,CAAC;MAClB,CAAC,EACAO,MAAM,IAAKd,MAAM,CAACc,MAAM,CAAC,CAC7B;IACL,CAAC,CAAC;EACN;EAEOD,aAAaA,CAAC7E,MAA8B;IAC/C,IAAIF,mBAAmB,CAACC,YAAY,CAACC,MAAM,CAAC,EAAE;MAC1C,IAAI,CAACW,uBAAuB,CAACoE,IAAI,CAAC/E,MAAM,CAAC;MACzC,OAAO,IAAI;;IAGfA,MAAM,CAACyB,UAAU,EAAE;IAEnB,IAAIzB,MAAM,CAACyB,UAAU,KAAK,CAAC,EAAE;MACzB,IAAI,CAACd,uBAAuB,CAACoE,IAAI,CAAC/E,MAAM,CAACC,kBAA+B,CAAC;MACzE,OAAO,IAAI;;IAGf,OAAO,KAAK;EAChB;EAEO+E,sBAAsBA,CAAA;IACzB,KAAK,IAAIzE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACI,uBAAuB,CAACsE,MAAM,EAAE,EAAE1E,CAAC,EAAE;MAC1D,IAAI,CAACI,uBAAuB,CAACJ,CAAC,CAAC,CAAC2E,OAAO,EAAE;;IAG7C,IAAI,CAACvE,uBAAuB,CAACsE,MAAM,GAAG,CAAC;EAC3C"},"metadata":{},"sourceType":"module","externalDependencies":[]}