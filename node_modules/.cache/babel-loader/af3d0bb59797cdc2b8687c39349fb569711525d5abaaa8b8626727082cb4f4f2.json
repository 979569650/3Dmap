{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { Tags } from \"../Misc/tags.js\";\nimport { Quaternion, Vector2, Vector3, Matrix } from \"../Maths/math.vector.js\";\nimport { _WarnImport } from \"./devTools.js\";\nimport { Color4, Color3 } from \"../Maths/math.color.js\";\nconst __decoratorInitialStore = {};\nconst __mergedStore = {};\nconst _copySource = function (creationFunction, source, instanciate, options = {}) {\n  const destination = creationFunction();\n  // Tags\n  if (Tags && Tags.HasTags(source)) {\n    Tags.AddTagsTo(destination, Tags.GetTags(source, true));\n  }\n  const classStore = getMergedStore(destination);\n  // Map from source texture uniqueId to destination texture\n  const textureMap = {};\n  // Properties\n  for (const property in classStore) {\n    const propertyDescriptor = classStore[property];\n    const sourceProperty = source[property];\n    const propertyType = propertyDescriptor.type;\n    if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\n      switch (propertyType) {\n        case 0: // Value\n        case 6: // Mesh reference\n        case 11:\n          // Camera reference\n          destination[property] = sourceProperty;\n          break;\n        case 1:\n          // Texture\n          if (options.cloneTexturesOnlyOnce && textureMap[sourceProperty.uniqueId]) {\n            destination[property] = textureMap[sourceProperty.uniqueId];\n          } else {\n            destination[property] = instanciate || sourceProperty.isRenderTarget ? sourceProperty : sourceProperty.clone();\n            textureMap[sourceProperty.uniqueId] = destination[property];\n          }\n          break;\n        case 2: // Color3\n        case 3: // FresnelParameters\n        case 4: // Vector2\n        case 5: // Vector3\n        case 7: // Color Curves\n        case 10: // Quaternion\n        case 12:\n          // Matrix\n          destination[property] = instanciate ? sourceProperty : sourceProperty.clone();\n          break;\n      }\n    }\n  }\n  return destination;\n};\nfunction getDirectStore(target) {\n  const classKey = target.getClassName();\n  if (!__decoratorInitialStore[classKey]) {\n    __decoratorInitialStore[classKey] = {};\n  }\n  return __decoratorInitialStore[classKey];\n}\n/**\n * Return the list of properties flagged as serializable\n * @param target host object\n */\nfunction getMergedStore(target) {\n  const classKey = target.getClassName();\n  if (__mergedStore[classKey]) {\n    return __mergedStore[classKey];\n  }\n  __mergedStore[classKey] = {};\n  const store = __mergedStore[classKey];\n  let currentTarget = target;\n  let currentKey = classKey;\n  while (currentKey) {\n    const initialStore = __decoratorInitialStore[currentKey];\n    for (const property in initialStore) {\n      store[property] = initialStore[property];\n    }\n    let parent;\n    let done = false;\n    do {\n      parent = Object.getPrototypeOf(currentTarget);\n      if (!parent.getClassName) {\n        done = true;\n        break;\n      }\n      if (parent.getClassName() !== currentKey) {\n        break;\n      }\n      currentTarget = parent;\n    } while (parent);\n    if (done) {\n      break;\n    }\n    currentKey = parent.getClassName();\n    currentTarget = parent;\n  }\n  return store;\n}\nfunction generateSerializableMember(type, sourceName) {\n  return (target, propertyKey) => {\n    const classStore = getDirectStore(target);\n    if (!classStore[propertyKey]) {\n      classStore[propertyKey] = {\n        type: type,\n        sourceName: sourceName\n      };\n    }\n  };\n}\nfunction generateExpandMember(setCallback, targetKey = null) {\n  return (target, propertyKey) => {\n    const key = targetKey || \"_\" + propertyKey;\n    Object.defineProperty(target, propertyKey, {\n      get: function () {\n        return this[key];\n      },\n      set: function (value) {\n        // does this object (i.e. vector3) has an equals function? use it!\n        // Note - not using \"with epsilon\" here, it is expected te behave like the internal cache does.\n        if (typeof this.equals === \"function\") {\n          if (this.equals(value)) {\n            return;\n          }\n        }\n        if (this[key] === value) {\n          return;\n        }\n        this[key] = value;\n        target[setCallback].apply(this);\n      },\n      enumerable: true,\n      configurable: true\n    });\n  };\n}\nexport function expandToProperty(callback, targetKey = null) {\n  return generateExpandMember(callback, targetKey);\n}\nexport function serialize(sourceName) {\n  return generateSerializableMember(0, sourceName); // value member\n}\n\nexport function serializeAsTexture(sourceName) {\n  return generateSerializableMember(1, sourceName); // texture member\n}\n\nexport function serializeAsColor3(sourceName) {\n  return generateSerializableMember(2, sourceName); // color3 member\n}\n\nexport function serializeAsFresnelParameters(sourceName) {\n  return generateSerializableMember(3, sourceName); // fresnel parameters member\n}\n\nexport function serializeAsVector2(sourceName) {\n  return generateSerializableMember(4, sourceName); // vector2 member\n}\n\nexport function serializeAsVector3(sourceName) {\n  return generateSerializableMember(5, sourceName); // vector3 member\n}\n\nexport function serializeAsMeshReference(sourceName) {\n  return generateSerializableMember(6, sourceName); // mesh reference member\n}\n\nexport function serializeAsColorCurves(sourceName) {\n  return generateSerializableMember(7, sourceName); // color curves\n}\n\nexport function serializeAsColor4(sourceName) {\n  return generateSerializableMember(8, sourceName); // color 4\n}\n\nexport function serializeAsImageProcessingConfiguration(sourceName) {\n  return generateSerializableMember(9, sourceName); // image processing\n}\n\nexport function serializeAsQuaternion(sourceName) {\n  return generateSerializableMember(10, sourceName); // quaternion member\n}\n\nexport function serializeAsMatrix(sourceName) {\n  return generateSerializableMember(12, sourceName); // matrix member\n}\n/**\n * Decorator used to define property that can be serialized as reference to a camera\n * @param sourceName defines the name of the property to decorate\n */\nexport function serializeAsCameraReference(sourceName) {\n  return generateSerializableMember(11, sourceName); // camera reference member\n}\n/**\n * Class used to help serialization objects\n */\nexport class SerializationHelper {\n  /**\n   * Appends the serialized animations from the source animations\n   * @param source Source containing the animations\n   * @param destination Target to store the animations\n   */\n  static AppendSerializedAnimations(source, destination) {\n    if (source.animations) {\n      destination.animations = [];\n      for (let animationIndex = 0; animationIndex < source.animations.length; animationIndex++) {\n        const animation = source.animations[animationIndex];\n        destination.animations.push(animation.serialize());\n      }\n    }\n  }\n  /**\n   * Static function used to serialized a specific entity\n   * @param entity defines the entity to serialize\n   * @param serializationObject defines the optional target object where serialization data will be stored\n   * @returns a JSON compatible object representing the serialization of the entity\n   */\n  static Serialize(entity, serializationObject) {\n    if (!serializationObject) {\n      serializationObject = {};\n    }\n    // Tags\n    if (Tags) {\n      serializationObject.tags = Tags.GetTags(entity);\n    }\n    const serializedProperties = getMergedStore(entity);\n    // Properties\n    for (const property in serializedProperties) {\n      const propertyDescriptor = serializedProperties[property];\n      const targetPropertyName = propertyDescriptor.sourceName || property;\n      const propertyType = propertyDescriptor.type;\n      const sourceProperty = entity[property];\n      if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\n        switch (propertyType) {\n          case 0:\n            // Value\n            serializationObject[targetPropertyName] = sourceProperty;\n            break;\n          case 1:\n            // Texture\n            serializationObject[targetPropertyName] = sourceProperty.serialize();\n            break;\n          case 2:\n            // Color3\n            serializationObject[targetPropertyName] = sourceProperty.asArray();\n            break;\n          case 3:\n            // FresnelParameters\n            serializationObject[targetPropertyName] = sourceProperty.serialize();\n            break;\n          case 4:\n            // Vector2\n            serializationObject[targetPropertyName] = sourceProperty.asArray();\n            break;\n          case 5:\n            // Vector3\n            serializationObject[targetPropertyName] = sourceProperty.asArray();\n            break;\n          case 6:\n            // Mesh reference\n            serializationObject[targetPropertyName] = sourceProperty.id;\n            break;\n          case 7:\n            // Color Curves\n            serializationObject[targetPropertyName] = sourceProperty.serialize();\n            break;\n          case 8:\n            // Color 4\n            serializationObject[targetPropertyName] = sourceProperty.asArray();\n            break;\n          case 9:\n            // Image Processing\n            serializationObject[targetPropertyName] = sourceProperty.serialize();\n            break;\n          case 10:\n            // Quaternion\n            serializationObject[targetPropertyName] = sourceProperty.asArray();\n            break;\n          case 11:\n            // Camera reference\n            serializationObject[targetPropertyName] = sourceProperty.id;\n            break;\n          case 12:\n            // Matrix\n            serializationObject[targetPropertyName] = sourceProperty.asArray();\n            break;\n        }\n      }\n    }\n    return serializationObject;\n  }\n  /**\n   * Given a source json and a destination object in a scene, this function will parse the source and will try to apply its content to the destination object\n   * @param source the source json data\n   * @param destination the destination object\n   * @param scene the scene where the object is\n   * @param rootUrl root url to use to load assets\n   */\n  static ParseProperties(source, destination, scene, rootUrl) {\n    if (!rootUrl) {\n      rootUrl = \"\";\n    }\n    const classStore = getMergedStore(destination);\n    // Properties\n    for (const property in classStore) {\n      const propertyDescriptor = classStore[property];\n      const sourceProperty = source[propertyDescriptor.sourceName || property];\n      const propertyType = propertyDescriptor.type;\n      if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\n        const dest = destination;\n        switch (propertyType) {\n          case 0:\n            // Value\n            dest[property] = sourceProperty;\n            break;\n          case 1:\n            // Texture\n            if (scene) {\n              dest[property] = SerializationHelper._TextureParser(sourceProperty, scene, rootUrl);\n            }\n            break;\n          case 2:\n            // Color3\n            dest[property] = Color3.FromArray(sourceProperty);\n            break;\n          case 3:\n            // FresnelParameters\n            dest[property] = SerializationHelper._FresnelParametersParser(sourceProperty);\n            break;\n          case 4:\n            // Vector2\n            dest[property] = Vector2.FromArray(sourceProperty);\n            break;\n          case 5:\n            // Vector3\n            dest[property] = Vector3.FromArray(sourceProperty);\n            break;\n          case 6:\n            // Mesh reference\n            if (scene) {\n              dest[property] = scene.getLastMeshById(sourceProperty);\n            }\n            break;\n          case 7:\n            // Color Curves\n            dest[property] = SerializationHelper._ColorCurvesParser(sourceProperty);\n            break;\n          case 8:\n            // Color 4\n            dest[property] = Color4.FromArray(sourceProperty);\n            break;\n          case 9:\n            // Image Processing\n            dest[property] = SerializationHelper._ImageProcessingConfigurationParser(sourceProperty);\n            break;\n          case 10:\n            // Quaternion\n            dest[property] = Quaternion.FromArray(sourceProperty);\n            break;\n          case 11:\n            // Camera reference\n            if (scene) {\n              dest[property] = scene.getCameraById(sourceProperty);\n            }\n            break;\n          case 12:\n            // Matrix\n            dest[property] = Matrix.FromArray(sourceProperty);\n            break;\n        }\n      }\n    }\n  }\n  /**\n   * Creates a new entity from a serialization data object\n   * @param creationFunction defines a function used to instanciated the new entity\n   * @param source defines the source serialization data\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root url for resources\n   * @returns a new entity\n   */\n  static Parse(creationFunction, source, scene, rootUrl = null) {\n    const destination = creationFunction();\n    // Tags\n    if (Tags) {\n      Tags.AddTagsTo(destination, source.tags);\n    }\n    SerializationHelper.ParseProperties(source, destination, scene, rootUrl);\n    return destination;\n  }\n  /**\n   * Clones an object\n   * @param creationFunction defines the function used to instanciate the new object\n   * @param source defines the source object\n   * @returns the cloned object\n   */\n  static Clone(creationFunction, source, options = {}) {\n    return _copySource(creationFunction, source, false, options);\n  }\n  /**\n   * Instanciates a new object based on a source one (some data will be shared between both object)\n   * @param creationFunction defines the function used to instanciate the new object\n   * @param source defines the source object\n   * @returns the new object\n   */\n  static Instanciate(creationFunction, source) {\n    return _copySource(creationFunction, source, true);\n  }\n}\n/**\n * Gets or sets a boolean to indicate if the UniqueId property should be serialized\n */\nSerializationHelper.AllowLoadingUniqueId = false;\n/**\n * @internal\n */\nSerializationHelper._ImageProcessingConfigurationParser = sourceProperty => {\n  throw _WarnImport(\"ImageProcessingConfiguration\");\n};\n/**\n * @internal\n */\nSerializationHelper._FresnelParametersParser = sourceProperty => {\n  throw _WarnImport(\"FresnelParameters\");\n};\n/**\n * @internal\n */\nSerializationHelper._ColorCurvesParser = sourceProperty => {\n  throw _WarnImport(\"ColorCurves\");\n};\n/**\n * @internal\n */\nSerializationHelper._TextureParser = (sourceProperty, scene, rootUrl) => {\n  throw _WarnImport(\"Texture\");\n};\n/**\n * Decorator used to redirect a function to a native implementation if available.\n * @internal\n */\nexport function nativeOverride(target, propertyKey, descriptor, predicate) {\n  // Cache the original JS function for later.\n  const jsFunc = descriptor.value;\n  // Override the JS function to check for a native override on first invocation. Setting descriptor.value overrides the function at the early stage of code being loaded/imported.\n  descriptor.value = (...params) => {\n    // Assume the resolved function will be the original JS function, then we will check for the Babylon Native context.\n    let func = jsFunc;\n    // Check if we are executing in a Babylon Native context (e.g. check the presence of the _native global property) and if so also check if a function override is available.\n    if (typeof _native !== \"undefined\" && _native[propertyKey]) {\n      const nativeFunc = _native[propertyKey];\n      // If a predicate was provided, then we'll need to invoke the predicate on each invocation of the underlying function to determine whether to call the native function or the JS function.\n      if (predicate) {\n        // The resolved function will execute the predicate and then either execute the native function or the JS function.\n        func = (...params) => predicate(...params) ? nativeFunc(...params) : jsFunc(...params);\n      } else {\n        // The resolved function will directly execute the native function.\n        func = nativeFunc;\n      }\n    }\n    // Override the JS function again with the final resolved target function.\n    target[propertyKey] = func;\n    // The JS function has now been overridden based on whether we're executing in the context of Babylon Native, but we still need to invoke that function.\n    // Future invocations of the function will just directly invoke the final overridden function, not any of the decorator setup logic above.\n    return func(...params);\n  };\n}\n/**\n * Decorator factory that applies the nativeOverride decorator, but determines whether to redirect to the native implementation based on a filter function that evaluates the function arguments.\n * @param predicate\n * @example @nativeOverride.filter((...[arg1]: Parameters<typeof someClass.someMethod>) => arg1.length > 20)\n *          public someMethod(arg1: string, arg2: number): string {\n * @internal\n */\nnativeOverride.filter = function (predicate) {\n  return (target, propertyKey, descriptor) => nativeOverride(target, propertyKey, descriptor, predicate);\n};","map":{"version":3,"names":["Tags","Quaternion","Vector2","Vector3","Matrix","_WarnImport","Color4","Color3","__decoratorInitialStore","__mergedStore","_copySource","creationFunction","source","instanciate","options","destination","HasTags","AddTagsTo","GetTags","classStore","getMergedStore","textureMap","property","propertyDescriptor","sourceProperty","propertyType","type","undefined","SerializationHelper","AllowLoadingUniqueId","cloneTexturesOnlyOnce","uniqueId","isRenderTarget","clone","getDirectStore","target","classKey","getClassName","store","currentTarget","currentKey","initialStore","parent","done","Object","getPrototypeOf","generateSerializableMember","sourceName","propertyKey","generateExpandMember","setCallback","targetKey","key","defineProperty","get","set","value","equals","apply","enumerable","configurable","expandToProperty","callback","serialize","serializeAsTexture","serializeAsColor3","serializeAsFresnelParameters","serializeAsVector2","serializeAsVector3","serializeAsMeshReference","serializeAsColorCurves","serializeAsColor4","serializeAsImageProcessingConfiguration","serializeAsQuaternion","serializeAsMatrix","serializeAsCameraReference","AppendSerializedAnimations","animations","animationIndex","length","animation","push","Serialize","entity","serializationObject","tags","serializedProperties","targetPropertyName","asArray","id","ParseProperties","scene","rootUrl","dest","_TextureParser","FromArray","_FresnelParametersParser","getLastMeshById","_ColorCurvesParser","_ImageProcessingConfigurationParser","getCameraById","Parse","Clone","Instanciate","nativeOverride","descriptor","predicate","jsFunc","params","func","_native","nativeFunc","filter"],"sources":["../../../../dev/core/src/Misc/decorators.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\n/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Tags } from \"../Misc/tags\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Quaternion, Vector2, Vector3, Matrix } from \"../Maths/math.vector\";\r\nimport { _WarnImport } from \"./devTools\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { Color4, Color3 } from \"../Maths/math.color\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\n\r\nimport type { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\r\nimport type { FresnelParameters } from \"../Materials/fresnelParameters\";\r\nimport type { ColorCurves } from \"../Materials/colorCurves\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\n\r\nconst __decoratorInitialStore = {};\r\nconst __mergedStore = {};\r\n\r\n/** @internal */\r\nexport interface CopySourceOptions {\r\n    /*\r\n     * if a texture is used in more than one channel (e.g diffuse and opacity),\r\n     * only clone it once and reuse it on the other channels. Default false\r\n     */\r\n    cloneTexturesOnlyOnce?: boolean;\r\n}\r\n\r\nconst _copySource = function <T>(creationFunction: () => T, source: T, instanciate: boolean, options: CopySourceOptions = {}): T {\r\n    const destination = creationFunction();\r\n\r\n    // Tags\r\n    if (Tags && Tags.HasTags(source)) {\r\n        Tags.AddTagsTo(destination, Tags.GetTags(source, true));\r\n    }\r\n\r\n    const classStore = getMergedStore(destination);\r\n\r\n    // Map from source texture uniqueId to destination texture\r\n    const textureMap: Record<number, any> = {};\r\n\r\n    // Properties\r\n    for (const property in classStore) {\r\n        const propertyDescriptor = classStore[property];\r\n        const sourceProperty = (<any>source)[property];\r\n        const propertyType = propertyDescriptor.type;\r\n\r\n        if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\r\n            switch (propertyType) {\r\n                case 0: // Value\r\n                case 6: // Mesh reference\r\n                case 11: // Camera reference\r\n                    (<any>destination)[property] = sourceProperty;\r\n                    break;\r\n                case 1: // Texture\r\n                    if (options.cloneTexturesOnlyOnce && textureMap[sourceProperty.uniqueId]) {\r\n                        (<any>destination)[property] = textureMap[sourceProperty.uniqueId];\r\n                    } else {\r\n                        (<any>destination)[property] = instanciate || sourceProperty.isRenderTarget ? sourceProperty : sourceProperty.clone();\r\n                        textureMap[sourceProperty.uniqueId] = (<any>destination)[property];\r\n                    }\r\n                    break;\r\n                case 2: // Color3\r\n                case 3: // FresnelParameters\r\n                case 4: // Vector2\r\n                case 5: // Vector3\r\n                case 7: // Color Curves\r\n                case 10: // Quaternion\r\n                case 12: // Matrix\r\n                    (<any>destination)[property] = instanciate ? sourceProperty : sourceProperty.clone();\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return destination;\r\n};\r\n\r\nfunction getDirectStore(target: any): any {\r\n    const classKey = target.getClassName();\r\n\r\n    if (!(<any>__decoratorInitialStore)[classKey]) {\r\n        (<any>__decoratorInitialStore)[classKey] = {};\r\n    }\r\n\r\n    return (<any>__decoratorInitialStore)[classKey];\r\n}\r\n\r\n/**\r\n * Return the list of properties flagged as serializable\r\n * @param target host object\r\n */\r\nfunction getMergedStore(target: any): any {\r\n    const classKey = target.getClassName();\r\n\r\n    if ((<any>__mergedStore)[classKey]) {\r\n        return (<any>__mergedStore)[classKey];\r\n    }\r\n\r\n    (<any>__mergedStore)[classKey] = {};\r\n\r\n    const store = (<any>__mergedStore)[classKey];\r\n    let currentTarget = target;\r\n    let currentKey = classKey;\r\n    while (currentKey) {\r\n        const initialStore = (<any>__decoratorInitialStore)[currentKey];\r\n        for (const property in initialStore) {\r\n            store[property] = initialStore[property];\r\n        }\r\n\r\n        let parent: any;\r\n        let done = false;\r\n\r\n        do {\r\n            parent = Object.getPrototypeOf(currentTarget);\r\n            if (!parent.getClassName) {\r\n                done = true;\r\n                break;\r\n            }\r\n\r\n            if (parent.getClassName() !== currentKey) {\r\n                break;\r\n            }\r\n\r\n            currentTarget = parent;\r\n        } while (parent);\r\n\r\n        if (done) {\r\n            break;\r\n        }\r\n\r\n        currentKey = parent.getClassName();\r\n        currentTarget = parent;\r\n    }\r\n\r\n    return store;\r\n}\r\n\r\nfunction generateSerializableMember(type: number, sourceName?: string) {\r\n    return (target: any, propertyKey: string | symbol) => {\r\n        const classStore = getDirectStore(target);\r\n\r\n        if (!classStore[propertyKey]) {\r\n            classStore[propertyKey] = { type: type, sourceName: sourceName };\r\n        }\r\n    };\r\n}\r\n\r\nfunction generateExpandMember(setCallback: string, targetKey: Nullable<string> = null) {\r\n    return (target: any, propertyKey: string) => {\r\n        const key = targetKey || \"_\" + propertyKey;\r\n        Object.defineProperty(target, propertyKey, {\r\n            get: function (this: any) {\r\n                return this[key];\r\n            },\r\n            set: function (this: any, value) {\r\n                // does this object (i.e. vector3) has an equals function? use it!\r\n                // Note - not using \"with epsilon\" here, it is expected te behave like the internal cache does.\r\n                if (typeof this.equals === \"function\") {\r\n                    if (this.equals(value)) {\r\n                        return;\r\n                    }\r\n                }\r\n                if (this[key] === value) {\r\n                    return;\r\n                }\r\n                this[key] = value;\r\n\r\n                target[setCallback].apply(this);\r\n            },\r\n            enumerable: true,\r\n            configurable: true,\r\n        });\r\n    };\r\n}\r\n\r\nexport function expandToProperty(callback: string, targetKey: Nullable<string> = null) {\r\n    return generateExpandMember(callback, targetKey);\r\n}\r\n\r\nexport function serialize(sourceName?: string) {\r\n    return generateSerializableMember(0, sourceName); // value member\r\n}\r\n\r\nexport function serializeAsTexture(sourceName?: string) {\r\n    return generateSerializableMember(1, sourceName); // texture member\r\n}\r\n\r\nexport function serializeAsColor3(sourceName?: string) {\r\n    return generateSerializableMember(2, sourceName); // color3 member\r\n}\r\n\r\nexport function serializeAsFresnelParameters(sourceName?: string) {\r\n    return generateSerializableMember(3, sourceName); // fresnel parameters member\r\n}\r\n\r\nexport function serializeAsVector2(sourceName?: string) {\r\n    return generateSerializableMember(4, sourceName); // vector2 member\r\n}\r\n\r\nexport function serializeAsVector3(sourceName?: string) {\r\n    return generateSerializableMember(5, sourceName); // vector3 member\r\n}\r\n\r\nexport function serializeAsMeshReference(sourceName?: string) {\r\n    return generateSerializableMember(6, sourceName); // mesh reference member\r\n}\r\n\r\nexport function serializeAsColorCurves(sourceName?: string) {\r\n    return generateSerializableMember(7, sourceName); // color curves\r\n}\r\n\r\nexport function serializeAsColor4(sourceName?: string) {\r\n    return generateSerializableMember(8, sourceName); // color 4\r\n}\r\n\r\nexport function serializeAsImageProcessingConfiguration(sourceName?: string) {\r\n    return generateSerializableMember(9, sourceName); // image processing\r\n}\r\n\r\nexport function serializeAsQuaternion(sourceName?: string) {\r\n    return generateSerializableMember(10, sourceName); // quaternion member\r\n}\r\n\r\nexport function serializeAsMatrix(sourceName?: string) {\r\n    return generateSerializableMember(12, sourceName); // matrix member\r\n}\r\n\r\n/**\r\n * Decorator used to define property that can be serialized as reference to a camera\r\n * @param sourceName defines the name of the property to decorate\r\n */\r\nexport function serializeAsCameraReference(sourceName?: string) {\r\n    return generateSerializableMember(11, sourceName); // camera reference member\r\n}\r\n\r\n/**\r\n * Class used to help serialization objects\r\n */\r\nexport class SerializationHelper {\r\n    /**\r\n     * Gets or sets a boolean to indicate if the UniqueId property should be serialized\r\n     */\r\n    public static AllowLoadingUniqueId = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _ImageProcessingConfigurationParser = (sourceProperty: any): ImageProcessingConfiguration => {\r\n        throw _WarnImport(\"ImageProcessingConfiguration\");\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _FresnelParametersParser = (sourceProperty: any): FresnelParameters => {\r\n        throw _WarnImport(\"FresnelParameters\");\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _ColorCurvesParser = (sourceProperty: any): ColorCurves => {\r\n        throw _WarnImport(\"ColorCurves\");\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _TextureParser = (sourceProperty: any, scene: Scene, rootUrl: string): Nullable<BaseTexture> => {\r\n        throw _WarnImport(\"Texture\");\r\n    };\r\n\r\n    /**\r\n     * Appends the serialized animations from the source animations\r\n     * @param source Source containing the animations\r\n     * @param destination Target to store the animations\r\n     */\r\n    public static AppendSerializedAnimations(source: IAnimatable, destination: any): void {\r\n        if (source.animations) {\r\n            destination.animations = [];\r\n            for (let animationIndex = 0; animationIndex < source.animations.length; animationIndex++) {\r\n                const animation = source.animations[animationIndex];\r\n\r\n                destination.animations.push(animation.serialize());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Static function used to serialized a specific entity\r\n     * @param entity defines the entity to serialize\r\n     * @param serializationObject defines the optional target object where serialization data will be stored\r\n     * @returns a JSON compatible object representing the serialization of the entity\r\n     */\r\n    public static Serialize<T>(entity: T, serializationObject?: any): any {\r\n        if (!serializationObject) {\r\n            serializationObject = {};\r\n        }\r\n\r\n        // Tags\r\n        if (Tags) {\r\n            serializationObject.tags = Tags.GetTags(entity);\r\n        }\r\n\r\n        const serializedProperties = getMergedStore(entity);\r\n\r\n        // Properties\r\n        for (const property in serializedProperties) {\r\n            const propertyDescriptor = serializedProperties[property];\r\n            const targetPropertyName = propertyDescriptor.sourceName || property;\r\n            const propertyType = propertyDescriptor.type;\r\n            const sourceProperty = (<any>entity)[property];\r\n\r\n            if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\r\n                switch (propertyType) {\r\n                    case 0: // Value\r\n                        serializationObject[targetPropertyName] = sourceProperty;\r\n                        break;\r\n                    case 1: // Texture\r\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\r\n                        break;\r\n                    case 2: // Color3\r\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\r\n                        break;\r\n                    case 3: // FresnelParameters\r\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\r\n                        break;\r\n                    case 4: // Vector2\r\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\r\n                        break;\r\n                    case 5: // Vector3\r\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\r\n                        break;\r\n                    case 6: // Mesh reference\r\n                        serializationObject[targetPropertyName] = sourceProperty.id;\r\n                        break;\r\n                    case 7: // Color Curves\r\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\r\n                        break;\r\n                    case 8: // Color 4\r\n                        serializationObject[targetPropertyName] = (<Color4>sourceProperty).asArray();\r\n                        break;\r\n                    case 9: // Image Processing\r\n                        serializationObject[targetPropertyName] = (<ImageProcessingConfiguration>sourceProperty).serialize();\r\n                        break;\r\n                    case 10: // Quaternion\r\n                        serializationObject[targetPropertyName] = (<Quaternion>sourceProperty).asArray();\r\n                        break;\r\n                    case 11: // Camera reference\r\n                        serializationObject[targetPropertyName] = (<Camera>sourceProperty).id;\r\n                        break;\r\n                    case 12: // Matrix\r\n                        serializationObject[targetPropertyName] = (<Matrix>sourceProperty).asArray();\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Given a source json and a destination object in a scene, this function will parse the source and will try to apply its content to the destination object\r\n     * @param source the source json data\r\n     * @param destination the destination object\r\n     * @param scene the scene where the object is\r\n     * @param rootUrl root url to use to load assets\r\n     */\r\n    public static ParseProperties(source: any, destination: any, scene: Nullable<Scene>, rootUrl: Nullable<string>) {\r\n        if (!rootUrl) {\r\n            rootUrl = \"\";\r\n        }\r\n\r\n        const classStore = getMergedStore(destination);\r\n\r\n        // Properties\r\n        for (const property in classStore) {\r\n            const propertyDescriptor = classStore[property];\r\n            const sourceProperty = source[propertyDescriptor.sourceName || property];\r\n            const propertyType = propertyDescriptor.type;\r\n\r\n            if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\r\n                const dest = <any>destination;\r\n                switch (propertyType) {\r\n                    case 0: // Value\r\n                        dest[property] = sourceProperty;\r\n                        break;\r\n                    case 1: // Texture\r\n                        if (scene) {\r\n                            dest[property] = SerializationHelper._TextureParser(sourceProperty, scene, rootUrl);\r\n                        }\r\n                        break;\r\n                    case 2: // Color3\r\n                        dest[property] = Color3.FromArray(sourceProperty);\r\n                        break;\r\n                    case 3: // FresnelParameters\r\n                        dest[property] = SerializationHelper._FresnelParametersParser(sourceProperty);\r\n                        break;\r\n                    case 4: // Vector2\r\n                        dest[property] = Vector2.FromArray(sourceProperty);\r\n                        break;\r\n                    case 5: // Vector3\r\n                        dest[property] = Vector3.FromArray(sourceProperty);\r\n                        break;\r\n                    case 6: // Mesh reference\r\n                        if (scene) {\r\n                            dest[property] = scene.getLastMeshById(sourceProperty);\r\n                        }\r\n                        break;\r\n                    case 7: // Color Curves\r\n                        dest[property] = SerializationHelper._ColorCurvesParser(sourceProperty);\r\n                        break;\r\n                    case 8: // Color 4\r\n                        dest[property] = Color4.FromArray(sourceProperty);\r\n                        break;\r\n                    case 9: // Image Processing\r\n                        dest[property] = SerializationHelper._ImageProcessingConfigurationParser(sourceProperty);\r\n                        break;\r\n                    case 10: // Quaternion\r\n                        dest[property] = Quaternion.FromArray(sourceProperty);\r\n                        break;\r\n                    case 11: // Camera reference\r\n                        if (scene) {\r\n                            dest[property] = scene.getCameraById(sourceProperty);\r\n                        }\r\n                        break;\r\n                    case 12: // Matrix\r\n                        dest[property] = Matrix.FromArray(sourceProperty);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new entity from a serialization data object\r\n     * @param creationFunction defines a function used to instanciated the new entity\r\n     * @param source defines the source serialization data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root url for resources\r\n     * @returns a new entity\r\n     */\r\n    public static Parse<T>(creationFunction: () => T, source: any, scene: Nullable<Scene>, rootUrl: Nullable<string> = null): T {\r\n        const destination = creationFunction();\r\n\r\n        // Tags\r\n        if (Tags) {\r\n            Tags.AddTagsTo(destination, source.tags);\r\n        }\r\n\r\n        SerializationHelper.ParseProperties(source, destination, scene, rootUrl);\r\n\r\n        return destination;\r\n    }\r\n\r\n    /**\r\n     * Clones an object\r\n     * @param creationFunction defines the function used to instanciate the new object\r\n     * @param source defines the source object\r\n     * @returns the cloned object\r\n     */\r\n    public static Clone<T>(creationFunction: () => T, source: T, options: CopySourceOptions = {}): T {\r\n        return _copySource(creationFunction, source, false, options);\r\n    }\r\n\r\n    /**\r\n     * Instanciates a new object based on a source one (some data will be shared between both object)\r\n     * @param creationFunction defines the function used to instanciate the new object\r\n     * @param source defines the source object\r\n     * @returns the new object\r\n     */\r\n    public static Instanciate<T>(creationFunction: () => T, source: T): T {\r\n        return _copySource(creationFunction, source, true);\r\n    }\r\n}\r\n\r\n/** @internal */\r\ndeclare const _native: any;\r\n\r\n/**\r\n * Decorator used to redirect a function to a native implementation if available.\r\n * @internal\r\n */\r\nexport function nativeOverride<T extends (...params: any[]) => boolean>(\r\n    target: any,\r\n    propertyKey: string,\r\n    descriptor: TypedPropertyDescriptor<(...params: Parameters<T>) => unknown>,\r\n    predicate?: T\r\n) {\r\n    // Cache the original JS function for later.\r\n    const jsFunc = descriptor.value!;\r\n\r\n    // Override the JS function to check for a native override on first invocation. Setting descriptor.value overrides the function at the early stage of code being loaded/imported.\r\n    descriptor.value = (...params: Parameters<T>): unknown => {\r\n        // Assume the resolved function will be the original JS function, then we will check for the Babylon Native context.\r\n        let func = jsFunc;\r\n\r\n        // Check if we are executing in a Babylon Native context (e.g. check the presence of the _native global property) and if so also check if a function override is available.\r\n        if (typeof _native !== \"undefined\" && _native[propertyKey]) {\r\n            const nativeFunc = _native[propertyKey] as (...params: Parameters<T>) => unknown;\r\n            // If a predicate was provided, then we'll need to invoke the predicate on each invocation of the underlying function to determine whether to call the native function or the JS function.\r\n            if (predicate) {\r\n                // The resolved function will execute the predicate and then either execute the native function or the JS function.\r\n                func = (...params: Parameters<T>) => (predicate(...params) ? nativeFunc(...params) : jsFunc(...params));\r\n            } else {\r\n                // The resolved function will directly execute the native function.\r\n                func = nativeFunc;\r\n            }\r\n        }\r\n\r\n        // Override the JS function again with the final resolved target function.\r\n        target[propertyKey] = func;\r\n\r\n        // The JS function has now been overridden based on whether we're executing in the context of Babylon Native, but we still need to invoke that function.\r\n        // Future invocations of the function will just directly invoke the final overridden function, not any of the decorator setup logic above.\r\n        return func(...params);\r\n    };\r\n}\r\n\r\n/**\r\n * Decorator factory that applies the nativeOverride decorator, but determines whether to redirect to the native implementation based on a filter function that evaluates the function arguments.\r\n * @param predicate\r\n * @example @nativeOverride.filter((...[arg1]: Parameters<typeof someClass.someMethod>) => arg1.length > 20)\r\n *          public someMethod(arg1: string, arg2: number): string {\r\n * @internal\r\n */\r\nnativeOverride.filter = function <T extends (...params: any) => boolean>(predicate: T) {\r\n    return (target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<(...params: Parameters<T>) => unknown>) =>\r\n        nativeOverride(target, propertyKey, descriptor, predicate);\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}