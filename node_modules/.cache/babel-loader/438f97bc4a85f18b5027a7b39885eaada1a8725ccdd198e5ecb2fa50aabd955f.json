{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Matrix, Vector3, Quaternion } from \"../../Maths/math.vector.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nlet anchorIdProvider = 0;\n/**\n * An implementation of the anchor system for WebXR.\n * For further information see https://github.com/immersive-web/anchors/\n */\nexport class WebXRAnchorSystem extends WebXRAbstractFeature {\n  /**\n   * Set the reference space to use for anchor creation, when not using a hit test.\n   * Will default to the session's reference space if not defined\n   */\n  set referenceSpaceForFrameAnchors(referenceSpace) {\n    this._referenceSpaceForFrameAnchors = referenceSpace;\n  }\n  /**\n   * constructs a new anchor system\n   * @param _xrSessionManager an instance of WebXRSessionManager\n   * @param _options configuration object for this feature\n   */\n  constructor(_xrSessionManager, _options = {}) {\n    super(_xrSessionManager);\n    this._options = _options;\n    this._lastFrameDetected = new Set();\n    this._trackedAnchors = [];\n    this._futureAnchors = [];\n    /**\n     * Observers registered here will be executed when a new anchor was added to the session\n     */\n    this.onAnchorAddedObservable = new Observable();\n    /**\n     * Observers registered here will be executed when an anchor was removed from the session\n     */\n    this.onAnchorRemovedObservable = new Observable();\n    /**\n     * Observers registered here will be executed when an existing anchor updates\n     * This can execute N times every frame\n     */\n    this.onAnchorUpdatedObservable = new Observable();\n    this._tmpVector = new Vector3();\n    this._tmpQuaternion = new Quaternion();\n    this.xrNativeFeatureName = \"anchors\";\n  }\n  _populateTmpTransformation(position, rotationQuaternion) {\n    this._tmpVector.copyFrom(position);\n    this._tmpQuaternion.copyFrom(rotationQuaternion);\n    if (!this._xrSessionManager.scene.useRightHandedSystem) {\n      this._tmpVector.z *= -1;\n      this._tmpQuaternion.z *= -1;\n      this._tmpQuaternion.w *= -1;\n    }\n    return {\n      position: this._tmpVector,\n      rotationQuaternion: this._tmpQuaternion\n    };\n  }\n  /**\n   * Create a new anchor point using a hit test result at a specific point in the scene\n   * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.\n   * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.\n   *\n   * @param hitTestResult The hit test result to use for this anchor creation\n   * @param position an optional position offset for this anchor\n   * @param rotationQuaternion an optional rotation offset for this anchor\n   * @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun\n   */\n  async addAnchorPointUsingHitTestResultAsync(hitTestResult, position = new Vector3(), rotationQuaternion = new Quaternion()) {\n    // convert to XR space (right handed) if needed\n    this._populateTmpTransformation(position, rotationQuaternion);\n    // the matrix that we'll use\n    const m = new XRRigidTransform({\n      x: this._tmpVector.x,\n      y: this._tmpVector.y,\n      z: this._tmpVector.z\n    }, {\n      x: this._tmpQuaternion.x,\n      y: this._tmpQuaternion.y,\n      z: this._tmpQuaternion.z,\n      w: this._tmpQuaternion.w\n    });\n    if (!hitTestResult.xrHitResult.createAnchor) {\n      this.detach();\n      throw new Error(\"Anchors not enabled in this environment/browser\");\n    } else {\n      try {\n        const nativeAnchor = await hitTestResult.xrHitResult.createAnchor(m);\n        return new Promise((resolve, reject) => {\n          this._futureAnchors.push({\n            nativeAnchor,\n            resolved: false,\n            submitted: true,\n            xrTransformation: m,\n            resolve,\n            reject\n          });\n        });\n      } catch (error) {\n        throw new Error(error);\n      }\n    }\n  }\n  /**\n   * Add a new anchor at a specific position and rotation\n   * This function will add a new anchor per default in the next available frame. Unless forced, the createAnchor function\n   * will be called in the next xrFrame loop to make sure that the anchor can be created correctly.\n   * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.\n   * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.\n   *\n   * @param position the position in which to add an anchor\n   * @param rotationQuaternion an optional rotation for the anchor transformation\n   * @param forceCreateInCurrentFrame force the creation of this anchor in the current frame. Must be called inside xrFrame loop!\n   * @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun\n   */\n  async addAnchorAtPositionAndRotationAsync(position, rotationQuaternion = new Quaternion(), forceCreateInCurrentFrame = false) {\n    // convert to XR space (right handed) if needed\n    this._populateTmpTransformation(position, rotationQuaternion);\n    // the matrix that we'll use\n    const xrTransformation = new XRRigidTransform({\n      x: this._tmpVector.x,\n      y: this._tmpVector.y,\n      z: this._tmpVector.z\n    }, {\n      x: this._tmpQuaternion.x,\n      y: this._tmpQuaternion.y,\n      z: this._tmpQuaternion.z,\n      w: this._tmpQuaternion.w\n    });\n    const xrAnchor = forceCreateInCurrentFrame && this.attached && this._xrSessionManager.currentFrame ? await this._createAnchorAtTransformation(xrTransformation, this._xrSessionManager.currentFrame) : undefined;\n    // add the transformation to the future anchors list\n    return new Promise((resolve, reject) => {\n      this._futureAnchors.push({\n        nativeAnchor: xrAnchor,\n        resolved: false,\n        submitted: false,\n        xrTransformation,\n        resolve,\n        reject\n      });\n    });\n  }\n  /**\n   * Get the list of anchors currently being tracked by the system\n   */\n  get anchors() {\n    return this._trackedAnchors;\n  }\n  /**\n   * detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    if (!this._options.doNotRemoveAnchorsOnSessionEnded) {\n      while (this._trackedAnchors.length) {\n        const toRemove = this._trackedAnchors.pop();\n        if (toRemove) {\n          try {\n            // try to natively remove it as well\n            toRemove.remove();\n          } catch (e) {\n            // no-op\n          }\n          // as the xr frame loop is removed, we need to notify manually\n          this.onAnchorRemovedObservable.notifyObservers(toRemove);\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * Dispose this feature and all of the resources attached\n   */\n  dispose() {\n    this._futureAnchors.length = 0;\n    super.dispose();\n    this.onAnchorAddedObservable.clear();\n    this.onAnchorRemovedObservable.clear();\n    this.onAnchorUpdatedObservable.clear();\n  }\n  _onXRFrame(frame) {\n    if (!this.attached || !frame) {\n      return;\n    }\n    const trackedAnchors = frame.trackedAnchors;\n    if (trackedAnchors) {\n      const toRemove = this._trackedAnchors.filter(anchor => !trackedAnchors.has(anchor.xrAnchor)).map(anchor => {\n        const index = this._trackedAnchors.indexOf(anchor);\n        return index;\n      });\n      let idxTracker = 0;\n      toRemove.forEach(index => {\n        const anchor = this._trackedAnchors.splice(index - idxTracker, 1)[0];\n        this.onAnchorRemovedObservable.notifyObservers(anchor);\n        idxTracker++;\n      });\n      // now check for new ones\n      trackedAnchors.forEach(xrAnchor => {\n        if (!this._lastFrameDetected.has(xrAnchor)) {\n          const newAnchor = {\n            id: anchorIdProvider++,\n            xrAnchor: xrAnchor,\n            remove: () => xrAnchor.delete()\n          };\n          const anchor = this._updateAnchorWithXRFrame(xrAnchor, newAnchor, frame);\n          this._trackedAnchors.push(anchor);\n          this.onAnchorAddedObservable.notifyObservers(anchor);\n          // search for the future anchor promise that matches this\n          const results = this._futureAnchors.filter(futureAnchor => futureAnchor.nativeAnchor === xrAnchor);\n          const result = results[0];\n          if (result) {\n            result.resolve(anchor);\n            result.resolved = true;\n          }\n        } else {\n          const index = this._findIndexInAnchorArray(xrAnchor);\n          const anchor = this._trackedAnchors[index];\n          try {\n            // anchors update every frame\n            this._updateAnchorWithXRFrame(xrAnchor, anchor, frame);\n            if (anchor.attachedNode) {\n              anchor.attachedNode.rotationQuaternion = anchor.attachedNode.rotationQuaternion || new Quaternion();\n              anchor.transformationMatrix.decompose(anchor.attachedNode.scaling, anchor.attachedNode.rotationQuaternion, anchor.attachedNode.position);\n            }\n            this.onAnchorUpdatedObservable.notifyObservers(anchor);\n          } catch (e) {\n            Tools.Warn(`Anchor could not be updated`);\n          }\n        }\n      });\n      this._lastFrameDetected = trackedAnchors;\n    }\n    // process future anchors\n    this._futureAnchors.forEach(futureAnchor => {\n      if (!futureAnchor.resolved && !futureAnchor.submitted) {\n        this._createAnchorAtTransformation(futureAnchor.xrTransformation, frame).then(nativeAnchor => {\n          futureAnchor.nativeAnchor = nativeAnchor;\n        }, error => {\n          futureAnchor.resolved = true;\n          futureAnchor.reject(error);\n        });\n        futureAnchor.submitted = true;\n      }\n    });\n  }\n  /**\n   * avoiding using Array.find for global support.\n   * @param xrAnchor the plane to find in the array\n   */\n  _findIndexInAnchorArray(xrAnchor) {\n    for (let i = 0; i < this._trackedAnchors.length; ++i) {\n      if (this._trackedAnchors[i].xrAnchor === xrAnchor) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  _updateAnchorWithXRFrame(xrAnchor, anchor, xrFrame) {\n    // matrix\n    const pose = xrFrame.getPose(xrAnchor.anchorSpace, this._xrSessionManager.referenceSpace);\n    if (pose) {\n      const mat = anchor.transformationMatrix || new Matrix();\n      Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\n      if (!this._xrSessionManager.scene.useRightHandedSystem) {\n        mat.toggleModelMatrixHandInPlace();\n      }\n      anchor.transformationMatrix = mat;\n      if (!this._options.worldParentNode) {\n        // Logger.Warn(\"Please provide a world parent node to apply world transformation\");\n      } else {\n        mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\n      }\n    }\n    return anchor;\n  }\n  async _createAnchorAtTransformation(xrTransformation, xrFrame) {\n    var _a;\n    if (xrFrame.createAnchor) {\n      try {\n        return xrFrame.createAnchor(xrTransformation, (_a = this._referenceSpaceForFrameAnchors) !== null && _a !== void 0 ? _a : this._xrSessionManager.referenceSpace);\n      } catch (error) {\n        throw new Error(error);\n      }\n    } else {\n      this.detach();\n      throw new Error(\"Anchors are not enabled in your browser\");\n    }\n  }\n}\n/**\n * The module's name\n */\nWebXRAnchorSystem.Name = WebXRFeatureName.ANCHOR_SYSTEM;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRAnchorSystem.Version = 1;\n// register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRAnchorSystem.Name, (xrSessionManager, options) => {\n  return () => new WebXRAnchorSystem(xrSessionManager, options);\n}, WebXRAnchorSystem.Version);","map":{"version":3,"names":["WebXRFeatureName","WebXRFeaturesManager","Observable","Matrix","Vector3","Quaternion","WebXRAbstractFeature","Tools","anchorIdProvider","WebXRAnchorSystem","referenceSpaceForFrameAnchors","referenceSpace","_referenceSpaceForFrameAnchors","constructor","_xrSessionManager","_options","_lastFrameDetected","Set","_trackedAnchors","_futureAnchors","onAnchorAddedObservable","onAnchorRemovedObservable","onAnchorUpdatedObservable","_tmpVector","_tmpQuaternion","xrNativeFeatureName","_populateTmpTransformation","position","rotationQuaternion","copyFrom","scene","useRightHandedSystem","z","w","addAnchorPointUsingHitTestResultAsync","hitTestResult","m","XRRigidTransform","x","y","xrHitResult","createAnchor","detach","Error","nativeAnchor","Promise","resolve","reject","push","resolved","submitted","xrTransformation","error","addAnchorAtPositionAndRotationAsync","forceCreateInCurrentFrame","xrAnchor","attached","currentFrame","_createAnchorAtTransformation","undefined","anchors","doNotRemoveAnchorsOnSessionEnded","length","toRemove","pop","remove","e","notifyObservers","dispose","clear","_onXRFrame","frame","trackedAnchors","filter","anchor","has","map","index","indexOf","idxTracker","forEach","splice","newAnchor","id","delete","_updateAnchorWithXRFrame","results","futureAnchor","result","_findIndexInAnchorArray","attachedNode","transformationMatrix","decompose","scaling","Warn","then","i","xrFrame","pose","getPose","anchorSpace","mat","FromArrayToRef","transform","matrix","toggleModelMatrixHandInPlace","worldParentNode","multiplyToRef","getWorldMatrix","_a","Name","ANCHOR_SYSTEM","Version","AddWebXRFeature","xrSessionManager","options"],"sources":["../../../../../dev/core/src/XR/features/WebXRAnchorSystem.ts"],"sourcesContent":["import { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Matrix, Vector3, Quaternion } from \"../../Maths/math.vector\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport type { IWebXRHitResult } from \"./WebXRHitTest\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Configuration options of the anchor system\r\n */\r\nexport interface IWebXRAnchorSystemOptions {\r\n    /**\r\n     * a node that will be used to convert local to world coordinates\r\n     */\r\n    worldParentNode?: TransformNode;\r\n\r\n    /**\r\n     * If set to true a reference of the created anchors will be kept until the next session starts\r\n     * If not defined, anchors will be removed from the array when the feature is detached or the session ended.\r\n     */\r\n    doNotRemoveAnchorsOnSessionEnded?: boolean;\r\n}\r\n\r\n/**\r\n * A babylon container for an XR Anchor\r\n */\r\nexport interface IWebXRAnchor {\r\n    /**\r\n     * A babylon-assigned ID for this anchor\r\n     */\r\n    id: number;\r\n    /**\r\n     * Transformation matrix to apply to an object attached to this anchor\r\n     */\r\n    transformationMatrix: Matrix;\r\n    /**\r\n     * The native anchor object\r\n     */\r\n    xrAnchor: XRAnchor;\r\n\r\n    /**\r\n     * if defined, this object will be constantly updated by the anchor's position and rotation\r\n     */\r\n    attachedNode?: TransformNode;\r\n\r\n    /**\r\n     * Remove this anchor from the scene\r\n     */\r\n    remove(): void;\r\n}\r\n\r\n/**\r\n * An internal interface for a future (promise based) anchor\r\n */\r\ninterface IWebXRFutureAnchor {\r\n    /**\r\n     * The native anchor\r\n     */\r\n    nativeAnchor?: XRAnchor;\r\n    /**\r\n     * Was this request submitted to the xr frame?\r\n     */\r\n    submitted: boolean;\r\n    /**\r\n     * Was this promise resolved already?\r\n     */\r\n    resolved: boolean;\r\n    /**\r\n     * A resolve function\r\n     */\r\n    resolve: (xrAnchor: IWebXRAnchor) => void;\r\n    /**\r\n     * A reject function\r\n     */\r\n    reject: (msg?: string) => void;\r\n    /**\r\n     * The XR Transformation of the future anchor\r\n     */\r\n    xrTransformation: XRRigidTransform;\r\n}\r\n\r\nlet anchorIdProvider = 0;\r\n\r\n/**\r\n * An implementation of the anchor system for WebXR.\r\n * For further information see https://github.com/immersive-web/anchors/\r\n */\r\nexport class WebXRAnchorSystem extends WebXRAbstractFeature {\r\n    private _lastFrameDetected: XRAnchorSet = new Set();\r\n\r\n    private _trackedAnchors: Array<IWebXRAnchor> = [];\r\n\r\n    private _referenceSpaceForFrameAnchors: XRReferenceSpace;\r\n\r\n    private _futureAnchors: IWebXRFutureAnchor[] = [];\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.ANCHOR_SYSTEM;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Observers registered here will be executed when a new anchor was added to the session\r\n     */\r\n    public onAnchorAddedObservable: Observable<IWebXRAnchor> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed when an anchor was removed from the session\r\n     */\r\n    public onAnchorRemovedObservable: Observable<IWebXRAnchor> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed when an existing anchor updates\r\n     * This can execute N times every frame\r\n     */\r\n    public onAnchorUpdatedObservable: Observable<IWebXRAnchor> = new Observable();\r\n\r\n    /**\r\n     * Set the reference space to use for anchor creation, when not using a hit test.\r\n     * Will default to the session's reference space if not defined\r\n     */\r\n    public set referenceSpaceForFrameAnchors(referenceSpace: XRReferenceSpace) {\r\n        this._referenceSpaceForFrameAnchors = referenceSpace;\r\n    }\r\n\r\n    /**\r\n     * constructs a new anchor system\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param _options configuration object for this feature\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private _options: IWebXRAnchorSystemOptions = {}) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"anchors\";\r\n    }\r\n\r\n    private _tmpVector = new Vector3();\r\n    private _tmpQuaternion = new Quaternion();\r\n\r\n    private _populateTmpTransformation(position: Vector3, rotationQuaternion: Quaternion) {\r\n        this._tmpVector.copyFrom(position);\r\n        this._tmpQuaternion.copyFrom(rotationQuaternion);\r\n        if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n            this._tmpVector.z *= -1;\r\n            this._tmpQuaternion.z *= -1;\r\n            this._tmpQuaternion.w *= -1;\r\n        }\r\n        return {\r\n            position: this._tmpVector,\r\n            rotationQuaternion: this._tmpQuaternion,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Create a new anchor point using a hit test result at a specific point in the scene\r\n     * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.\r\n     * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.\r\n     *\r\n     * @param hitTestResult The hit test result to use for this anchor creation\r\n     * @param position an optional position offset for this anchor\r\n     * @param rotationQuaternion an optional rotation offset for this anchor\r\n     * @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun\r\n     */\r\n    public async addAnchorPointUsingHitTestResultAsync(\r\n        hitTestResult: IWebXRHitResult,\r\n        position: Vector3 = new Vector3(),\r\n        rotationQuaternion: Quaternion = new Quaternion()\r\n    ): Promise<IWebXRAnchor> {\r\n        // convert to XR space (right handed) if needed\r\n        this._populateTmpTransformation(position, rotationQuaternion);\r\n        // the matrix that we'll use\r\n        const m = new XRRigidTransform(\r\n            { x: this._tmpVector.x, y: this._tmpVector.y, z: this._tmpVector.z },\r\n            { x: this._tmpQuaternion.x, y: this._tmpQuaternion.y, z: this._tmpQuaternion.z, w: this._tmpQuaternion.w }\r\n        );\r\n        if (!hitTestResult.xrHitResult.createAnchor) {\r\n            this.detach();\r\n            throw new Error(\"Anchors not enabled in this environment/browser\");\r\n        } else {\r\n            try {\r\n                const nativeAnchor = await hitTestResult.xrHitResult.createAnchor(m);\r\n                return new Promise<IWebXRAnchor>((resolve, reject) => {\r\n                    this._futureAnchors.push({\r\n                        nativeAnchor,\r\n                        resolved: false,\r\n                        submitted: true,\r\n                        xrTransformation: m,\r\n                        resolve,\r\n                        reject,\r\n                    });\r\n                });\r\n            } catch (error) {\r\n                throw new Error(error);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new anchor at a specific position and rotation\r\n     * This function will add a new anchor per default in the next available frame. Unless forced, the createAnchor function\r\n     * will be called in the next xrFrame loop to make sure that the anchor can be created correctly.\r\n     * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.\r\n     * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.\r\n     *\r\n     * @param position the position in which to add an anchor\r\n     * @param rotationQuaternion an optional rotation for the anchor transformation\r\n     * @param forceCreateInCurrentFrame force the creation of this anchor in the current frame. Must be called inside xrFrame loop!\r\n     * @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun\r\n     */\r\n    public async addAnchorAtPositionAndRotationAsync(\r\n        position: Vector3,\r\n        rotationQuaternion: Quaternion = new Quaternion(),\r\n        forceCreateInCurrentFrame = false\r\n    ): Promise<IWebXRAnchor> {\r\n        // convert to XR space (right handed) if needed\r\n        this._populateTmpTransformation(position, rotationQuaternion);\r\n        // the matrix that we'll use\r\n        const xrTransformation = new XRRigidTransform(\r\n            { x: this._tmpVector.x, y: this._tmpVector.y, z: this._tmpVector.z },\r\n            { x: this._tmpQuaternion.x, y: this._tmpQuaternion.y, z: this._tmpQuaternion.z, w: this._tmpQuaternion.w }\r\n        );\r\n        const xrAnchor =\r\n            forceCreateInCurrentFrame && this.attached && this._xrSessionManager.currentFrame\r\n                ? await this._createAnchorAtTransformation(xrTransformation, this._xrSessionManager.currentFrame)\r\n                : undefined;\r\n        // add the transformation to the future anchors list\r\n        return new Promise<IWebXRAnchor>((resolve, reject) => {\r\n            this._futureAnchors.push({\r\n                nativeAnchor: xrAnchor,\r\n                resolved: false,\r\n                submitted: false,\r\n                xrTransformation,\r\n                resolve,\r\n                reject,\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the list of anchors currently being tracked by the system\r\n     */\r\n    public get anchors(): IWebXRAnchor[] {\r\n        return this._trackedAnchors;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._options.doNotRemoveAnchorsOnSessionEnded) {\r\n            while (this._trackedAnchors.length) {\r\n                const toRemove = this._trackedAnchors.pop();\r\n                if (toRemove) {\r\n                    try {\r\n                        // try to natively remove it as well\r\n                        toRemove.remove();\r\n                    } catch (e) {\r\n                        // no-op\r\n                    }\r\n                    // as the xr frame loop is removed, we need to notify manually\r\n                    this.onAnchorRemovedObservable.notifyObservers(toRemove);\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        this._futureAnchors.length = 0;\r\n        super.dispose();\r\n        this.onAnchorAddedObservable.clear();\r\n        this.onAnchorRemovedObservable.clear();\r\n        this.onAnchorUpdatedObservable.clear();\r\n    }\r\n\r\n    protected _onXRFrame(frame: XRFrame) {\r\n        if (!this.attached || !frame) {\r\n            return;\r\n        }\r\n\r\n        const trackedAnchors = frame.trackedAnchors;\r\n        if (trackedAnchors) {\r\n            const toRemove = this._trackedAnchors\r\n                .filter((anchor) => !trackedAnchors.has(anchor.xrAnchor))\r\n                .map((anchor) => {\r\n                    const index = this._trackedAnchors.indexOf(anchor);\r\n                    return index;\r\n                });\r\n            let idxTracker = 0;\r\n            toRemove.forEach((index) => {\r\n                const anchor = this._trackedAnchors.splice(index - idxTracker, 1)[0];\r\n                this.onAnchorRemovedObservable.notifyObservers(anchor);\r\n                idxTracker++;\r\n            });\r\n            // now check for new ones\r\n            trackedAnchors.forEach((xrAnchor) => {\r\n                if (!this._lastFrameDetected.has(xrAnchor)) {\r\n                    const newAnchor: Partial<IWebXRAnchor> = {\r\n                        id: anchorIdProvider++,\r\n                        xrAnchor: xrAnchor,\r\n                        remove: () => xrAnchor.delete(),\r\n                    };\r\n                    const anchor = this._updateAnchorWithXRFrame(xrAnchor, newAnchor, frame);\r\n                    this._trackedAnchors.push(anchor);\r\n                    this.onAnchorAddedObservable.notifyObservers(anchor);\r\n                    // search for the future anchor promise that matches this\r\n                    const results = this._futureAnchors.filter((futureAnchor) => futureAnchor.nativeAnchor === xrAnchor);\r\n                    const result = results[0];\r\n                    if (result) {\r\n                        result.resolve(anchor);\r\n                        result.resolved = true;\r\n                    }\r\n                } else {\r\n                    const index = this._findIndexInAnchorArray(xrAnchor);\r\n                    const anchor = this._trackedAnchors[index];\r\n                    try {\r\n                        // anchors update every frame\r\n                        this._updateAnchorWithXRFrame(xrAnchor, anchor, frame);\r\n                        if (anchor.attachedNode) {\r\n                            anchor.attachedNode.rotationQuaternion = anchor.attachedNode.rotationQuaternion || new Quaternion();\r\n                            anchor.transformationMatrix.decompose(anchor.attachedNode.scaling, anchor.attachedNode.rotationQuaternion, anchor.attachedNode.position);\r\n                        }\r\n                        this.onAnchorUpdatedObservable.notifyObservers(anchor);\r\n                    } catch (e) {\r\n                        Tools.Warn(`Anchor could not be updated`);\r\n                    }\r\n                }\r\n            });\r\n            this._lastFrameDetected = trackedAnchors;\r\n        }\r\n\r\n        // process future anchors\r\n        this._futureAnchors.forEach((futureAnchor) => {\r\n            if (!futureAnchor.resolved && !futureAnchor.submitted) {\r\n                this._createAnchorAtTransformation(futureAnchor.xrTransformation, frame).then(\r\n                    (nativeAnchor) => {\r\n                        futureAnchor.nativeAnchor = nativeAnchor;\r\n                    },\r\n                    (error) => {\r\n                        futureAnchor.resolved = true;\r\n                        futureAnchor.reject(error);\r\n                    }\r\n                );\r\n                futureAnchor.submitted = true;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * avoiding using Array.find for global support.\r\n     * @param xrAnchor the plane to find in the array\r\n     */\r\n    private _findIndexInAnchorArray(xrAnchor: XRAnchor) {\r\n        for (let i = 0; i < this._trackedAnchors.length; ++i) {\r\n            if (this._trackedAnchors[i].xrAnchor === xrAnchor) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    private _updateAnchorWithXRFrame(xrAnchor: XRAnchor, anchor: Partial<IWebXRAnchor>, xrFrame: XRFrame): IWebXRAnchor {\r\n        // matrix\r\n        const pose = xrFrame.getPose(xrAnchor.anchorSpace, this._xrSessionManager.referenceSpace);\r\n        if (pose) {\r\n            const mat = anchor.transformationMatrix || new Matrix();\r\n            Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\r\n            if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                mat.toggleModelMatrixHandInPlace();\r\n            }\r\n            anchor.transformationMatrix = mat;\r\n            if (!this._options.worldParentNode) {\r\n                // Logger.Warn(\"Please provide a world parent node to apply world transformation\");\r\n            } else {\r\n                mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\r\n            }\r\n        }\r\n\r\n        return <IWebXRAnchor>anchor;\r\n    }\r\n\r\n    private async _createAnchorAtTransformation(xrTransformation: XRRigidTransform, xrFrame: XRFrame) {\r\n        if (xrFrame.createAnchor) {\r\n            try {\r\n                return xrFrame.createAnchor(xrTransformation, this._referenceSpaceForFrameAnchors ?? this._xrSessionManager.referenceSpace);\r\n            } catch (error) {\r\n                throw new Error(error);\r\n            }\r\n        } else {\r\n            this.detach();\r\n            throw new Error(\"Anchors are not enabled in your browser\");\r\n        }\r\n    }\r\n}\r\n\r\n// register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRAnchorSystem.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRAnchorSystem(xrSessionManager, options);\r\n    },\r\n    WebXRAnchorSystem.Version\r\n);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}