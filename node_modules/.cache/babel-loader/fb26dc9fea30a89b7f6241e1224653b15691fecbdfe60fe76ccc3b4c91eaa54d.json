{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { BackEase, EasingFunction } from \"../../Animations/easing.js\";\nimport { Animation } from \"../../Animations/animation.js\";\n/**\n * Add a bouncing effect to an ArcRotateCamera when reaching a specified minimum and maximum radius\n * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#bouncing-behavior\n */\nexport class BouncingBehavior {\n  constructor() {\n    /**\n     * The duration of the animation, in milliseconds\n     */\n    this.transitionDuration = 450;\n    /**\n     * Length of the distance animated by the transition when lower radius is reached\n     */\n    this.lowerRadiusTransitionRange = 2;\n    /**\n     * Length of the distance animated by the transition when upper radius is reached\n     */\n    this.upperRadiusTransitionRange = -2;\n    this._autoTransitionRange = false;\n    // Animations\n    this._radiusIsAnimating = false;\n    this._radiusBounceTransition = null;\n    this._animatables = new Array();\n  }\n  /**\n   * Gets the name of the behavior.\n   */\n  get name() {\n    return \"Bouncing\";\n  }\n  /**\n   * Gets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\n   */\n  get autoTransitionRange() {\n    return this._autoTransitionRange;\n  }\n  /**\n   * Sets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\n   * Transition ranges will be set to 5% of the bounding box diagonal in world space\n   */\n  set autoTransitionRange(value) {\n    if (this._autoTransitionRange === value) {\n      return;\n    }\n    this._autoTransitionRange = value;\n    const camera = this._attachedCamera;\n    if (!camera) {\n      return;\n    }\n    if (value) {\n      this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add(mesh => {\n        if (!mesh) {\n          return;\n        }\n        mesh.computeWorldMatrix(true);\n        const diagonal = mesh.getBoundingInfo().diagonalLength;\n        this.lowerRadiusTransitionRange = diagonal * 0.05;\n        this.upperRadiusTransitionRange = diagonal * 0.05;\n      });\n    } else if (this._onMeshTargetChangedObserver) {\n      camera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\n    }\n  }\n  /**\n   * Initializes the behavior.\n   */\n  init() {\n    // Do nothing\n  }\n  /**\n   * Attaches the behavior to its arc rotate camera.\n   * @param camera Defines the camera to attach the behavior to\n   */\n  attach(camera) {\n    this._attachedCamera = camera;\n    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\n      if (!this._attachedCamera) {\n        return;\n      }\n      // Add the bounce animation to the lower radius limit\n      if (this._isRadiusAtLimit(this._attachedCamera.lowerRadiusLimit)) {\n        this._applyBoundRadiusAnimation(this.lowerRadiusTransitionRange);\n      }\n      // Add the bounce animation to the upper radius limit\n      if (this._isRadiusAtLimit(this._attachedCamera.upperRadiusLimit)) {\n        this._applyBoundRadiusAnimation(this.upperRadiusTransitionRange);\n      }\n    });\n  }\n  /**\n   * Detaches the behavior from its current arc rotate camera.\n   */\n  detach() {\n    if (!this._attachedCamera) {\n      return;\n    }\n    if (this._onAfterCheckInputsObserver) {\n      this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\n    }\n    if (this._onMeshTargetChangedObserver) {\n      this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\n    }\n    this._attachedCamera = null;\n  }\n  /**\n   * Checks if the camera radius is at the specified limit. Takes into account animation locks.\n   * @param radiusLimit The limit to check against.\n   * @returns Bool to indicate if at limit.\n   */\n  _isRadiusAtLimit(radiusLimit) {\n    if (!this._attachedCamera) {\n      return false;\n    }\n    if (this._attachedCamera.radius === radiusLimit && !this._radiusIsAnimating) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Applies an animation to the radius of the camera, extending by the radiusDelta.\n   * @param radiusDelta The delta by which to animate to. Can be negative.\n   */\n  _applyBoundRadiusAnimation(radiusDelta) {\n    if (!this._attachedCamera) {\n      return;\n    }\n    if (!this._radiusBounceTransition) {\n      BouncingBehavior.EasingFunction.setEasingMode(BouncingBehavior.EasingMode);\n      this._radiusBounceTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, BouncingBehavior.EasingFunction);\n    }\n    // Prevent zoom until bounce has completed\n    this._cachedWheelPrecision = this._attachedCamera.wheelPrecision;\n    this._attachedCamera.wheelPrecision = Infinity;\n    this._attachedCamera.inertialRadiusOffset = 0;\n    // Animate to the radius limit\n    this.stopAllAnimations();\n    this._radiusIsAnimating = true;\n    const animatable = Animation.TransitionTo(\"radius\", this._attachedCamera.radius + radiusDelta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusBounceTransition, this.transitionDuration, () => this._clearAnimationLocks());\n    if (animatable) {\n      this._animatables.push(animatable);\n    }\n  }\n  /**\n   * Removes all animation locks. Allows new animations to be added to any of the camera properties.\n   */\n  _clearAnimationLocks() {\n    this._radiusIsAnimating = false;\n    if (this._attachedCamera) {\n      this._attachedCamera.wheelPrecision = this._cachedWheelPrecision;\n    }\n  }\n  /**\n   * Stops and removes all animations that have been applied to the camera\n   */\n  stopAllAnimations() {\n    if (this._attachedCamera) {\n      this._attachedCamera.animations = [];\n    }\n    while (this._animatables.length) {\n      this._animatables[0].onAnimationEnd = null;\n      this._animatables[0].stop();\n      this._animatables.shift();\n    }\n  }\n}\n/**\n * The easing function used by animations\n */\nBouncingBehavior.EasingFunction = new BackEase(0.3);\n/**\n * The easing mode used by animations\n */\nBouncingBehavior.EasingMode = EasingFunction.EASINGMODE_EASEOUT;","map":{"version":3,"names":["BackEase","EasingFunction","Animation","BouncingBehavior","constructor","transitionDuration","lowerRadiusTransitionRange","upperRadiusTransitionRange","_autoTransitionRange","_radiusIsAnimating","_radiusBounceTransition","_animatables","Array","name","autoTransitionRange","value","camera","_attachedCamera","_onMeshTargetChangedObserver","onMeshTargetChangedObservable","add","mesh","computeWorldMatrix","diagonal","getBoundingInfo","diagonalLength","remove","init","attach","_onAfterCheckInputsObserver","onAfterCheckInputsObservable","_isRadiusAtLimit","lowerRadiusLimit","_applyBoundRadiusAnimation","upperRadiusLimit","detach","radiusLimit","radius","radiusDelta","setEasingMode","EasingMode","CreateAnimation","ANIMATIONTYPE_FLOAT","_cachedWheelPrecision","wheelPrecision","Infinity","inertialRadiusOffset","stopAllAnimations","animatable","TransitionTo","getScene","_clearAnimationLocks","push","animations","length","onAnimationEnd","stop","shift","EASINGMODE_EASEOUT"],"sources":["../../../../../dev/core/src/Behaviors/Cameras/bouncingBehavior.ts"],"sourcesContent":["import type { Behavior } from \"../../Behaviors/behavior\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { BackEase, EasingFunction } from \"../../Animations/easing\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Animatable } from \"../../Animations/animatable\";\r\nimport { Animation } from \"../../Animations/animation\";\r\n\r\n/**\r\n * Add a bouncing effect to an ArcRotateCamera when reaching a specified minimum and maximum radius\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#bouncing-behavior\r\n */\r\nexport class BouncingBehavior implements Behavior<ArcRotateCamera> {\r\n    /**\r\n     * Gets the name of the behavior.\r\n     */\r\n    public get name(): string {\r\n        return \"Bouncing\";\r\n    }\r\n\r\n    /**\r\n     * The easing function used by animations\r\n     */\r\n    public static EasingFunction = new BackEase(0.3);\r\n\r\n    /**\r\n     * The easing mode used by animations\r\n     */\r\n    public static EasingMode = EasingFunction.EASINGMODE_EASEOUT;\r\n\r\n    /**\r\n     * The duration of the animation, in milliseconds\r\n     */\r\n    public transitionDuration = 450;\r\n\r\n    /**\r\n     * Length of the distance animated by the transition when lower radius is reached\r\n     */\r\n    public lowerRadiusTransitionRange = 2;\r\n\r\n    /**\r\n     * Length of the distance animated by the transition when upper radius is reached\r\n     */\r\n    public upperRadiusTransitionRange = -2;\r\n\r\n    private _autoTransitionRange = false;\r\n\r\n    /**\r\n     * Gets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\r\n     */\r\n    public get autoTransitionRange(): boolean {\r\n        return this._autoTransitionRange;\r\n    }\r\n\r\n    /**\r\n     * Sets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\r\n     * Transition ranges will be set to 5% of the bounding box diagonal in world space\r\n     */\r\n    public set autoTransitionRange(value: boolean) {\r\n        if (this._autoTransitionRange === value) {\r\n            return;\r\n        }\r\n\r\n        this._autoTransitionRange = value;\r\n\r\n        const camera = this._attachedCamera;\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add((mesh) => {\r\n                if (!mesh) {\r\n                    return;\r\n                }\r\n\r\n                mesh.computeWorldMatrix(true);\r\n                const diagonal = mesh.getBoundingInfo().diagonalLength;\r\n\r\n                this.lowerRadiusTransitionRange = diagonal * 0.05;\r\n                this.upperRadiusTransitionRange = diagonal * 0.05;\r\n            });\r\n        } else if (this._onMeshTargetChangedObserver) {\r\n            camera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n    }\r\n\r\n    // Connection\r\n    private _attachedCamera: Nullable<ArcRotateCamera>;\r\n    private _onAfterCheckInputsObserver: Nullable<Observer<Camera>>;\r\n    private _onMeshTargetChangedObserver: Nullable<Observer<Nullable<AbstractMesh>>>;\r\n\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    public init(): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    public attach(camera: ArcRotateCamera): void {\r\n        this._attachedCamera = camera;\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\r\n            if (!this._attachedCamera) {\r\n                return;\r\n            }\r\n\r\n            // Add the bounce animation to the lower radius limit\r\n            if (this._isRadiusAtLimit(this._attachedCamera.lowerRadiusLimit)) {\r\n                this._applyBoundRadiusAnimation(this.lowerRadiusTransitionRange);\r\n            }\r\n\r\n            // Add the bounce animation to the upper radius limit\r\n            if (this._isRadiusAtLimit(this._attachedCamera.upperRadiusLimit)) {\r\n                this._applyBoundRadiusAnimation(this.upperRadiusTransitionRange);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    public detach(): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n        if (this._onAfterCheckInputsObserver) {\r\n            this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        }\r\n        if (this._onMeshTargetChangedObserver) {\r\n            this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n        this._attachedCamera = null;\r\n    }\r\n\r\n    // Animations\r\n    private _radiusIsAnimating: boolean = false;\r\n    private _radiusBounceTransition: Nullable<Animation> = null;\r\n    private _animatables = new Array<Animatable>();\r\n    private _cachedWheelPrecision: number;\r\n\r\n    /**\r\n     * Checks if the camera radius is at the specified limit. Takes into account animation locks.\r\n     * @param radiusLimit The limit to check against.\r\n     * @returns Bool to indicate if at limit.\r\n     */\r\n    private _isRadiusAtLimit(radiusLimit: Nullable<number>): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        if (this._attachedCamera.radius === radiusLimit && !this._radiusIsAnimating) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Applies an animation to the radius of the camera, extending by the radiusDelta.\r\n     * @param radiusDelta The delta by which to animate to. Can be negative.\r\n     */\r\n    private _applyBoundRadiusAnimation(radiusDelta: number): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n\r\n        if (!this._radiusBounceTransition) {\r\n            BouncingBehavior.EasingFunction.setEasingMode(BouncingBehavior.EasingMode);\r\n            this._radiusBounceTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, BouncingBehavior.EasingFunction);\r\n        }\r\n        // Prevent zoom until bounce has completed\r\n        this._cachedWheelPrecision = this._attachedCamera.wheelPrecision;\r\n        this._attachedCamera.wheelPrecision = Infinity;\r\n        this._attachedCamera.inertialRadiusOffset = 0;\r\n\r\n        // Animate to the radius limit\r\n        this.stopAllAnimations();\r\n        this._radiusIsAnimating = true;\r\n        const animatable = Animation.TransitionTo(\r\n            \"radius\",\r\n            this._attachedCamera.radius + radiusDelta,\r\n            this._attachedCamera,\r\n            this._attachedCamera.getScene(),\r\n            60,\r\n            this._radiusBounceTransition,\r\n            this.transitionDuration,\r\n            () => this._clearAnimationLocks()\r\n        );\r\n\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all animation locks. Allows new animations to be added to any of the camera properties.\r\n     */\r\n    protected _clearAnimationLocks(): void {\r\n        this._radiusIsAnimating = false;\r\n\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.wheelPrecision = this._cachedWheelPrecision;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops and removes all animations that have been applied to the camera\r\n     */\r\n    public stopAllAnimations(): void {\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.animations = [];\r\n        }\r\n        while (this._animatables.length) {\r\n            this._animatables[0].onAnimationEnd = null;\r\n            this._animatables[0].stop();\r\n            this._animatables.shift();\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}