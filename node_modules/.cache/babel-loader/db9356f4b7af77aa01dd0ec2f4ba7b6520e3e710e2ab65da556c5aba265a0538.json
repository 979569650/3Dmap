{"ast":null,"code":"import \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\nimport { __decorate } from \"../../tslib.es6.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport \"../../Engines/Extensions/engine.videoTexture.js\";\nimport \"../../Engines/Extensions/engine.dynamicTexture.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { RegisterClass } from \"../../Misc/typeStore.js\";\nfunction removeSource(video) {\n  // Remove any <source> elements, etc.\n  while (video.firstChild) {\n    video.removeChild(video.firstChild);\n  }\n  // detach srcObject\n  video.srcObject = null;\n  // Set a blank src (https://html.spec.whatwg.org/multipage/media.html#best-practices-for-authors-using-media-elements)\n  video.src = \"\";\n  // Prevent non-important errors maybe (https://twitter.com/beraliv/status/1205214277956775936)\n  video.removeAttribute(\"src\");\n}\n/**\n * If you want to display a video in your scene, this is the special texture for that.\n * This special texture works similar to other textures, with the exception of a few parameters.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/videoTexture\n */\nexport class VideoTexture extends Texture {\n  /**\n   * Event triggered when a dom action is required by the user to play the video.\n   * This happens due to recent changes in browser policies preventing video to auto start.\n   */\n  get onUserActionRequestedObservable() {\n    if (!this._onUserActionRequestedObservable) {\n      this._onUserActionRequestedObservable = new Observable();\n    }\n    return this._onUserActionRequestedObservable;\n  }\n  _processError(reason) {\n    this._errorFound = true;\n    if (this._onError) {\n      this._onError(reason === null || reason === void 0 ? void 0 : reason.message);\n    } else {\n      Logger.Error(reason === null || reason === void 0 ? void 0 : reason.message);\n    }\n  }\n  _handlePlay() {\n    this._errorFound = false;\n    this.video.play().catch(reason => {\n      if ((reason === null || reason === void 0 ? void 0 : reason.name) === \"NotAllowedError\") {\n        if (this._onUserActionRequestedObservable && this._onUserActionRequestedObservable.hasObservers()) {\n          this._onUserActionRequestedObservable.notifyObservers(this);\n          return;\n        } else if (!this.video.muted) {\n          Logger.Warn(\"Unable to autoplay a video with sound. Trying again with muted turned true\");\n          this.video.muted = true;\n          this._errorFound = false;\n          this.video.play().catch(otherReason => {\n            this._processError(otherReason);\n          });\n          return;\n        }\n      }\n      this._processError(reason);\n    });\n  }\n  /**\n   * Creates a video texture.\n   * If you want to display a video in your scene, this is the special texture for that.\n   * This special texture works similar to other textures, with the exception of a few parameters.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/videoTexture\n   * @param name optional name, will detect from video source, if not defined\n   * @param src can be used to provide an url, array of urls or an already setup HTML video element.\n   * @param scene is obviously the current scene.\n   * @param generateMipMaps can be used to turn on mipmaps (Can be expensive for videoTextures because they are often updated).\n   * @param invertY is false by default but can be used to invert video on Y axis\n   * @param samplingMode controls the sampling method and is set to TRILINEAR_SAMPLINGMODE by default\n   * @param settings allows finer control over video usage\n   * @param onError defines a callback triggered when an error occurred during the loading session\n   * @param format defines the texture format to use (Engine.TEXTUREFORMAT_RGBA by default)\n   */\n  constructor(name, src, scene, generateMipMaps = false, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, settings = {}, onError, format = 5) {\n    var _a, _b;\n    super(null, scene, !generateMipMaps, invertY);\n    this._onUserActionRequestedObservable = null;\n    this._stillImageCaptured = false;\n    this._displayingPosterTexture = false;\n    this._frameId = -1;\n    this._currentSrc = null;\n    this._errorFound = false;\n    /**\n     * Serialize the flag to define this texture as a video texture\n     */\n    this.isVideo = true;\n    this._resizeInternalTexture = () => {\n      var _a;\n      // Cleanup the old texture before replacing it\n      if (this._texture != null) {\n        this._texture.dispose();\n      }\n      if (!this._getEngine().needPOTTextures || Tools.IsExponentOfTwo(this.video.videoWidth) && Tools.IsExponentOfTwo(this.video.videoHeight)) {\n        this.wrapU = Texture.WRAP_ADDRESSMODE;\n        this.wrapV = Texture.WRAP_ADDRESSMODE;\n      } else {\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\n        this._generateMipMaps = false;\n      }\n      this._texture = this._getEngine().createDynamicTexture(this.video.videoWidth, this.video.videoHeight, this._generateMipMaps, this.samplingMode);\n      this._texture.format = (_a = this._format) !== null && _a !== void 0 ? _a : 5;\n      // Reset the frame ID and update the new texture to ensure it pulls in the current video frame\n      this._frameId = -1;\n      this._updateInternalTexture();\n    };\n    this._createInternalTexture = () => {\n      if (this._texture != null) {\n        if (this._displayingPosterTexture) {\n          this._displayingPosterTexture = false;\n        } else {\n          return;\n        }\n      }\n      this.video.addEventListener(\"resize\", this._resizeInternalTexture);\n      this._resizeInternalTexture();\n      if (!this.video.autoplay && !this._settings.poster && !this._settings.independentVideoSource) {\n        const oldHandler = this.video.onplaying;\n        const oldMuted = this.video.muted;\n        this.video.muted = true;\n        this.video.onplaying = () => {\n          this.video.muted = oldMuted;\n          this.video.onplaying = oldHandler;\n          this._updateInternalTexture();\n          if (!this._errorFound) {\n            this.video.pause();\n          }\n          if (this.onLoadObservable.hasObservers()) {\n            this.onLoadObservable.notifyObservers(this);\n          }\n        };\n        this._handlePlay();\n      } else {\n        this._updateInternalTexture();\n        if (this.onLoadObservable.hasObservers()) {\n          this.onLoadObservable.notifyObservers(this);\n        }\n      }\n    };\n    this._reset = () => {\n      if (this._texture == null) {\n        return;\n      }\n      if (!this._displayingPosterTexture) {\n        this._texture.dispose();\n        this._texture = null;\n      }\n    };\n    this._updateInternalTexture = () => {\n      if (this._texture == null) {\n        return;\n      }\n      if (this.video.readyState < this.video.HAVE_CURRENT_DATA) {\n        return;\n      }\n      if (this._displayingPosterTexture) {\n        return;\n      }\n      const frameId = this.getScene().getFrameId();\n      if (this._frameId === frameId) {\n        return;\n      }\n      this._frameId = frameId;\n      this._getEngine().updateVideoTexture(this._texture, this._externalTexture ? this._externalTexture : this.video, this._invertY);\n    };\n    this._settings = Object.assign({\n      autoPlay: true,\n      loop: true,\n      autoUpdateTexture: true\n    }, settings);\n    this._onError = onError;\n    this._generateMipMaps = generateMipMaps;\n    this._initialSamplingMode = samplingMode;\n    this.autoUpdateTexture = this._settings.autoUpdateTexture;\n    this._currentSrc = src;\n    this.name = name || this._getName(src);\n    this.video = this._getVideo(src);\n    this._externalTexture = (_b = (_a = this._engine) === null || _a === void 0 ? void 0 : _a.createExternalTexture(this.video)) !== null && _b !== void 0 ? _b : null;\n    if (!this._settings.independentVideoSource) {\n      if (this._settings.poster) {\n        this.video.poster = this._settings.poster;\n      }\n      if (this._settings.autoPlay !== undefined) {\n        this.video.autoplay = this._settings.autoPlay;\n      }\n      if (this._settings.loop !== undefined) {\n        this.video.loop = this._settings.loop;\n      }\n      if (this._settings.muted !== undefined) {\n        this.video.muted = this._settings.muted;\n      }\n      this.video.setAttribute(\"playsinline\", \"\");\n      this.video.addEventListener(\"paused\", this._updateInternalTexture);\n      this.video.addEventListener(\"seeked\", this._updateInternalTexture);\n      this.video.addEventListener(\"emptied\", this._reset);\n      if (this._settings.autoPlay) {\n        this._handlePlay();\n      }\n    }\n    this._createInternalTextureOnEvent = this._settings.poster && !this._settings.autoPlay ? \"play\" : \"canplay\";\n    this.video.addEventListener(this._createInternalTextureOnEvent, this._createInternalTexture);\n    this._format = format;\n    const videoHasEnoughData = this.video.readyState >= this.video.HAVE_CURRENT_DATA;\n    if (this._settings.poster && (!this._settings.autoPlay || !videoHasEnoughData)) {\n      this._texture = this._getEngine().createTexture(this._settings.poster, false, !this.invertY, scene);\n      this._displayingPosterTexture = true;\n    } else if (videoHasEnoughData) {\n      this._createInternalTexture();\n    }\n  }\n  /**\n   * Get the current class name of the video texture useful for serialization or dynamic coding.\n   * @returns \"VideoTexture\"\n   */\n  getClassName() {\n    return \"VideoTexture\";\n  }\n  _getName(src) {\n    if (src instanceof HTMLVideoElement) {\n      return src.currentSrc;\n    }\n    if (typeof src === \"object\") {\n      return src.toString();\n    }\n    return src;\n  }\n  _getVideo(src) {\n    if (src.isNative) {\n      return src;\n    }\n    if (src instanceof HTMLVideoElement) {\n      Tools.SetCorsBehavior(src.currentSrc, src);\n      return src;\n    }\n    const video = document.createElement(\"video\");\n    if (typeof src === \"string\") {\n      Tools.SetCorsBehavior(src, video);\n      video.src = src;\n    } else {\n      Tools.SetCorsBehavior(src[0], video);\n      src.forEach(url => {\n        const source = document.createElement(\"source\");\n        source.src = url;\n        video.appendChild(source);\n      });\n    }\n    this.onDisposeObservable.addOnce(() => {\n      removeSource(video);\n    });\n    return video;\n  }\n  /**\n   * @internal Internal method to initiate `update`.\n   */\n  _rebuild() {\n    this.update();\n  }\n  /**\n   * Update Texture in the `auto` mode. Does not do anything if `settings.autoUpdateTexture` is false.\n   */\n  update() {\n    if (!this.autoUpdateTexture) {\n      // Expecting user to call `updateTexture` manually\n      return;\n    }\n    this.updateTexture(true);\n  }\n  /**\n   * Update Texture in `manual` mode. Does not do anything if not visible or paused.\n   * @param isVisible Visibility state, detected by user using `scene.getActiveMeshes()` or otherwise.\n   */\n  updateTexture(isVisible) {\n    if (!isVisible) {\n      return;\n    }\n    if (this.video.paused && this._stillImageCaptured) {\n      return;\n    }\n    this._stillImageCaptured = true;\n    this._updateInternalTexture();\n  }\n  /**\n   * Get the underlying external texture (if supported by the current engine, else null)\n   */\n  get externalTexture() {\n    return this._externalTexture;\n  }\n  /**\n   * Change video content. Changing video instance or setting multiple urls (as in constructor) is not supported.\n   * @param url New url.\n   */\n  updateURL(url) {\n    this.video.src = url;\n    this._currentSrc = url;\n  }\n  /**\n   * Clones the texture.\n   * @returns the cloned texture\n   */\n  clone() {\n    return new VideoTexture(this.name, this._currentSrc, this.getScene(), this._generateMipMaps, this.invertY, this.samplingMode, this._settings);\n  }\n  /**\n   * Dispose the texture and release its associated resources.\n   */\n  dispose() {\n    var _a;\n    super.dispose();\n    this._currentSrc = null;\n    if (this._onUserActionRequestedObservable) {\n      this._onUserActionRequestedObservable.clear();\n      this._onUserActionRequestedObservable = null;\n    }\n    this.video.removeEventListener(this._createInternalTextureOnEvent, this._createInternalTexture);\n    if (!this._settings.independentVideoSource) {\n      this.video.removeEventListener(\"paused\", this._updateInternalTexture);\n      this.video.removeEventListener(\"seeked\", this._updateInternalTexture);\n      this.video.removeEventListener(\"emptied\", this._reset);\n      this.video.removeEventListener(\"resize\", this._resizeInternalTexture);\n      this.video.pause();\n    }\n    (_a = this._externalTexture) === null || _a === void 0 ? void 0 : _a.dispose();\n  }\n  /**\n   * Creates a video texture straight from a stream.\n   * @param scene Define the scene the texture should be created in\n   * @param stream Define the stream the texture should be created from\n   * @param constraints video constraints\n   * @param invertY Defines if the video should be stored with invert Y set to true (true by default)\n   * @returns The created video texture as a promise\n   */\n  static CreateFromStreamAsync(scene, stream, constraints, invertY = true) {\n    const video = scene.getEngine().createVideoElement(constraints);\n    if (scene.getEngine()._badOS) {\n      // Yes... I know and I hope to remove it soon...\n      document.body.appendChild(video);\n      video.style.transform = \"scale(0.0001, 0.0001)\";\n      video.style.opacity = \"0\";\n      video.style.position = \"fixed\";\n      video.style.bottom = \"0px\";\n      video.style.right = \"0px\";\n    }\n    video.setAttribute(\"autoplay\", \"\");\n    video.setAttribute(\"muted\", \"true\");\n    video.setAttribute(\"playsinline\", \"\");\n    video.muted = true;\n    if (video.isNative) {\n      // No additional configuration needed for native\n    } else if (video.mozSrcObject !== undefined) {\n      // hack for Firefox < 19\n      video.mozSrcObject = stream;\n    } else {\n      if (typeof video.srcObject == \"object\") {\n        video.srcObject = stream;\n      } else {\n        // older API. See https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL#using_object_urls_for_media_streams\n        video.src = window.URL && window.URL.createObjectURL(stream);\n      }\n    }\n    return new Promise(resolve => {\n      const onPlaying = () => {\n        const videoTexture = new VideoTexture(\"video\", video, scene, true, invertY, undefined, undefined, undefined, 4);\n        if (scene.getEngine()._badOS) {\n          videoTexture.onDisposeObservable.addOnce(() => {\n            video.remove();\n          });\n        }\n        videoTexture.onDisposeObservable.addOnce(() => {\n          removeSource(video);\n        });\n        resolve(videoTexture);\n        video.removeEventListener(\"playing\", onPlaying);\n      };\n      video.addEventListener(\"playing\", onPlaying);\n      video.play();\n    });\n  }\n  /**\n   * Creates a video texture straight from your WebCam video feed.\n   * @param scene Define the scene the texture should be created in\n   * @param constraints Define the constraints to use to create the web cam feed from WebRTC\n   * @param audioConstaints Define the audio constraints to use to create the web cam feed from WebRTC\n   * @param invertY Defines if the video should be stored with invert Y set to true (true by default)\n   * @returns The created video texture as a promise\n   */\n  static async CreateFromWebCamAsync(scene, constraints, audioConstaints = false, invertY = true) {\n    if (navigator.mediaDevices) {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        video: constraints,\n        audio: audioConstaints\n      });\n      const videoTexture = await this.CreateFromStreamAsync(scene, stream, constraints, invertY);\n      videoTexture.onDisposeObservable.addOnce(() => {\n        stream.getTracks().forEach(track => {\n          track.stop();\n        });\n      });\n      return videoTexture;\n    }\n    return Promise.reject(\"No support for userMedia on this device\");\n  }\n  /**\n   * Creates a video texture straight from your WebCam video feed.\n   * @param scene Defines the scene the texture should be created in\n   * @param onReady Defines a callback to triggered once the texture will be ready\n   * @param constraints Defines the constraints to use to create the web cam feed from WebRTC\n   * @param audioConstaints Defines the audio constraints to use to create the web cam feed from WebRTC\n   * @param invertY Defines if the video should be stored with invert Y set to true (true by default)\n   */\n  static CreateFromWebCam(scene, onReady, constraints, audioConstaints = false, invertY = true) {\n    this.CreateFromWebCamAsync(scene, constraints, audioConstaints, invertY).then(function (videoTexture) {\n      if (onReady) {\n        onReady(videoTexture);\n      }\n    }).catch(function (err) {\n      Logger.Error(err.name);\n    });\n  }\n}\n__decorate([serialize(\"settings\")], VideoTexture.prototype, \"_settings\", void 0);\n__decorate([serialize(\"src\")], VideoTexture.prototype, \"_currentSrc\", void 0);\n__decorate([serialize()], VideoTexture.prototype, \"isVideo\", void 0);\nTexture._CreateVideoTexture = (name, src, scene, generateMipMaps = false, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, settings = {}, onError, format = 5) => {\n  return new VideoTexture(name, src, scene, generateMipMaps, invertY, samplingMode, settings, onError, format);\n};\n// Some exporters relies on Tools.Instantiate\nRegisterClass(\"BABYLON.VideoTexture\", VideoTexture);","map":{"version":3,"names":["Observable","Tools","Logger","Texture","serialize","RegisterClass","removeSource","video","firstChild","removeChild","srcObject","src","removeAttribute","VideoTexture","onUserActionRequestedObservable","_onUserActionRequestedObservable","_processError","reason","_errorFound","_onError","message","Error","_handlePlay","play","catch","name","hasObservers","notifyObservers","muted","Warn","otherReason","constructor","scene","generateMipMaps","invertY","samplingMode","TRILINEAR_SAMPLINGMODE","settings","onError","format","_stillImageCaptured","_displayingPosterTexture","_frameId","_currentSrc","isVideo","_resizeInternalTexture","_texture","dispose","_getEngine","needPOTTextures","IsExponentOfTwo","videoWidth","videoHeight","wrapU","WRAP_ADDRESSMODE","wrapV","CLAMP_ADDRESSMODE","_generateMipMaps","createDynamicTexture","_a","_format","_updateInternalTexture","_createInternalTexture","addEventListener","autoplay","_settings","poster","independentVideoSource","oldHandler","onplaying","oldMuted","pause","onLoadObservable","_reset","readyState","HAVE_CURRENT_DATA","frameId","getScene","getFrameId","updateVideoTexture","_externalTexture","_invertY","Object","assign","autoPlay","loop","autoUpdateTexture","_initialSamplingMode","_getName","_getVideo","_b","_engine","createExternalTexture","undefined","setAttribute","_createInternalTextureOnEvent","videoHasEnoughData","createTexture","getClassName","HTMLVideoElement","currentSrc","toString","isNative","SetCorsBehavior","document","createElement","forEach","url","source","appendChild","onDisposeObservable","addOnce","_rebuild","update","updateTexture","isVisible","paused","externalTexture","updateURL","clone","clear","removeEventListener","CreateFromStreamAsync","stream","constraints","getEngine","createVideoElement","_badOS","body","style","transform","opacity","position","bottom","right","mozSrcObject","window","URL","createObjectURL","Promise","resolve","onPlaying","videoTexture","remove","CreateFromWebCamAsync","audioConstaints","navigator","mediaDevices","getUserMedia","audio","getTracks","track","stop","reject","CreateFromWebCam","onReady","then","err","__decorate","_CreateVideoTexture"],"sources":["../../../../../dev/core/src/Materials/Textures/videoTexture.ts"],"sourcesContent":["import { Observable } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { ExternalTexture } from \"./externalTexture\";\r\n\r\nimport \"../../Engines/Extensions/engine.videoTexture\";\r\nimport \"../../Engines/Extensions/engine.dynamicTexture\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nfunction removeSource(video: HTMLVideoElement): void {\r\n    // Remove any <source> elements, etc.\r\n    while (video.firstChild) {\r\n        video.removeChild(video.firstChild);\r\n    }\r\n\r\n    // detach srcObject\r\n    video.srcObject = null;\r\n\r\n    // Set a blank src (https://html.spec.whatwg.org/multipage/media.html#best-practices-for-authors-using-media-elements)\r\n    video.src = \"\";\r\n\r\n    // Prevent non-important errors maybe (https://twitter.com/beraliv/status/1205214277956775936)\r\n    video.removeAttribute(\"src\");\r\n}\r\n\r\n/**\r\n * Settings for finer control over video usage\r\n */\r\nexport interface VideoTextureSettings {\r\n    /**\r\n     * Applies `autoplay` to video, if specified\r\n     */\r\n    autoPlay?: boolean;\r\n\r\n    /**\r\n     * Applies `muted` to video, if specified\r\n     */\r\n    muted?: boolean;\r\n\r\n    /**\r\n     * Applies `loop` to video, if specified\r\n     */\r\n    loop?: boolean;\r\n\r\n    /**\r\n     * Automatically updates internal texture from video at every frame in the render loop\r\n     */\r\n    autoUpdateTexture: boolean;\r\n\r\n    /**\r\n     * Image src displayed during the video loading or until the user interacts with the video.\r\n     */\r\n    poster?: string;\r\n\r\n    /**\r\n     * Defines the associated texture format.\r\n     */\r\n    format?: number;\r\n\r\n    /**\r\n     * Notify babylon to not modify any video settings and not control the video's playback.\r\n     * Set this to true if you are controlling the way the video is being played, stopped and paused.\r\n     */\r\n    independentVideoSource?: boolean;\r\n}\r\n\r\n/**\r\n * If you want to display a video in your scene, this is the special texture for that.\r\n * This special texture works similar to other textures, with the exception of a few parameters.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/videoTexture\r\n */\r\nexport class VideoTexture extends Texture {\r\n    /**\r\n     * Tells whether textures will be updated automatically or user is required to call `updateTexture` manually\r\n     */\r\n    public readonly autoUpdateTexture: boolean;\r\n\r\n    /**\r\n     * The video instance used by the texture internally\r\n     */\r\n    public readonly video: HTMLVideoElement;\r\n\r\n    private _externalTexture: Nullable<ExternalTexture>;\r\n    private _onUserActionRequestedObservable: Nullable<Observable<Texture>> = null;\r\n\r\n    /**\r\n     * Event triggered when a dom action is required by the user to play the video.\r\n     * This happens due to recent changes in browser policies preventing video to auto start.\r\n     */\r\n    public get onUserActionRequestedObservable(): Observable<Texture> {\r\n        if (!this._onUserActionRequestedObservable) {\r\n            this._onUserActionRequestedObservable = new Observable<Texture>();\r\n        }\r\n        return this._onUserActionRequestedObservable;\r\n    }\r\n\r\n    private _generateMipMaps: boolean;\r\n    private _stillImageCaptured = false;\r\n    private _displayingPosterTexture = false;\r\n    @serialize(\"settings\")\r\n    private _settings: VideoTextureSettings;\r\n    private _createInternalTextureOnEvent: string;\r\n    private _frameId = -1;\r\n    @serialize(\"src\")\r\n    private _currentSrc: Nullable<string | string[] | HTMLVideoElement> = null;\r\n    private _onError?: Nullable<(message?: string, exception?: any) => void>;\r\n    private _errorFound = false;\r\n\r\n    /**\r\n     * Serialize the flag to define this texture as a video texture\r\n     */\r\n    @serialize()\r\n    public readonly isVideo = true;\r\n\r\n    private _processError(reason: any) {\r\n        this._errorFound = true;\r\n        if (this._onError) {\r\n            this._onError(reason?.message);\r\n        } else {\r\n            Logger.Error(reason?.message);\r\n        }\r\n    }\r\n\r\n    private _handlePlay() {\r\n        this._errorFound = false;\r\n        this.video.play().catch((reason) => {\r\n            if (reason?.name === \"NotAllowedError\") {\r\n                if (this._onUserActionRequestedObservable && this._onUserActionRequestedObservable.hasObservers()) {\r\n                    this._onUserActionRequestedObservable.notifyObservers(this);\r\n                    return;\r\n                } else if (!this.video.muted) {\r\n                    Logger.Warn(\"Unable to autoplay a video with sound. Trying again with muted turned true\");\r\n                    this.video.muted = true;\r\n                    this._errorFound = false;\r\n                    this.video.play().catch((otherReason) => {\r\n                        this._processError(otherReason);\r\n                    });\r\n                    return;\r\n                }\r\n            }\r\n\r\n            this._processError(reason);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a video texture.\r\n     * If you want to display a video in your scene, this is the special texture for that.\r\n     * This special texture works similar to other textures, with the exception of a few parameters.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/videoTexture\r\n     * @param name optional name, will detect from video source, if not defined\r\n     * @param src can be used to provide an url, array of urls or an already setup HTML video element.\r\n     * @param scene is obviously the current scene.\r\n     * @param generateMipMaps can be used to turn on mipmaps (Can be expensive for videoTextures because they are often updated).\r\n     * @param invertY is false by default but can be used to invert video on Y axis\r\n     * @param samplingMode controls the sampling method and is set to TRILINEAR_SAMPLINGMODE by default\r\n     * @param settings allows finer control over video usage\r\n     * @param onError defines a callback triggered when an error occurred during the loading session\r\n     * @param format defines the texture format to use (Engine.TEXTUREFORMAT_RGBA by default)\r\n     */\r\n    constructor(\r\n        name: Nullable<string>,\r\n        src: string | string[] | HTMLVideoElement,\r\n        scene: Nullable<Scene>,\r\n        generateMipMaps = false,\r\n        invertY = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        settings: Partial<VideoTextureSettings> = {},\r\n        onError?: Nullable<(message?: string, exception?: any) => void>,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA\r\n    ) {\r\n        super(null, scene, !generateMipMaps, invertY);\r\n\r\n        this._settings = {\r\n            autoPlay: true,\r\n            loop: true,\r\n            autoUpdateTexture: true,\r\n            ...settings,\r\n        };\r\n\r\n        this._onError = onError;\r\n\r\n        this._generateMipMaps = generateMipMaps;\r\n        this._initialSamplingMode = samplingMode;\r\n        this.autoUpdateTexture = this._settings.autoUpdateTexture;\r\n\r\n        this._currentSrc = src;\r\n        this.name = name || this._getName(src);\r\n        this.video = this._getVideo(src);\r\n        this._externalTexture = this._engine?.createExternalTexture(this.video) ?? null;\r\n        if (!this._settings.independentVideoSource) {\r\n            if (this._settings.poster) {\r\n                this.video.poster = this._settings.poster;\r\n            }\r\n            if (this._settings.autoPlay !== undefined) {\r\n                this.video.autoplay = this._settings.autoPlay;\r\n            }\r\n            if (this._settings.loop !== undefined) {\r\n                this.video.loop = this._settings.loop;\r\n            }\r\n            if (this._settings.muted !== undefined) {\r\n                this.video.muted = this._settings.muted;\r\n            }\r\n\r\n            this.video.setAttribute(\"playsinline\", \"\");\r\n            this.video.addEventListener(\"paused\", this._updateInternalTexture);\r\n            this.video.addEventListener(\"seeked\", this._updateInternalTexture);\r\n            this.video.addEventListener(\"emptied\", this._reset);\r\n\r\n            if (this._settings.autoPlay) {\r\n                this._handlePlay();\r\n            }\r\n        }\r\n\r\n        this._createInternalTextureOnEvent = this._settings.poster && !this._settings.autoPlay ? \"play\" : \"canplay\";\r\n        this.video.addEventListener(this._createInternalTextureOnEvent, this._createInternalTexture);\r\n        this._format = format;\r\n\r\n        const videoHasEnoughData = this.video.readyState >= this.video.HAVE_CURRENT_DATA;\r\n        if (this._settings.poster && (!this._settings.autoPlay || !videoHasEnoughData)) {\r\n            this._texture = this._getEngine()!.createTexture(this._settings.poster!, false, !this.invertY, scene);\r\n            this._displayingPosterTexture = true;\r\n        } else if (videoHasEnoughData) {\r\n            this._createInternalTexture();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the video texture useful for serialization or dynamic coding.\r\n     * @returns \"VideoTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"VideoTexture\";\r\n    }\r\n\r\n    private _getName(src: string | string[] | HTMLVideoElement): string {\r\n        if (src instanceof HTMLVideoElement) {\r\n            return src.currentSrc;\r\n        }\r\n\r\n        if (typeof src === \"object\") {\r\n            return src.toString();\r\n        }\r\n\r\n        return src;\r\n    }\r\n\r\n    private _getVideo(src: string | string[] | HTMLVideoElement): HTMLVideoElement {\r\n        if ((<any>src).isNative) {\r\n            return <HTMLVideoElement>src;\r\n        }\r\n        if (src instanceof HTMLVideoElement) {\r\n            Tools.SetCorsBehavior(src.currentSrc, src);\r\n            return src;\r\n        }\r\n        const video: HTMLVideoElement = document.createElement(\"video\");\r\n        if (typeof src === \"string\") {\r\n            Tools.SetCorsBehavior(src, video);\r\n            video.src = src;\r\n        } else {\r\n            Tools.SetCorsBehavior(src[0], video);\r\n            src.forEach((url) => {\r\n                const source = document.createElement(\"source\");\r\n                source.src = url;\r\n                video.appendChild(source);\r\n            });\r\n        }\r\n\r\n        this.onDisposeObservable.addOnce(() => {\r\n            removeSource(video);\r\n        });\r\n\r\n        return video;\r\n    }\r\n\r\n    private _resizeInternalTexture = (): void => {\r\n        // Cleanup the old texture before replacing it\r\n        if (this._texture != null) {\r\n            this._texture.dispose();\r\n        }\r\n\r\n        if (!this._getEngine()!.needPOTTextures || (Tools.IsExponentOfTwo(this.video.videoWidth) && Tools.IsExponentOfTwo(this.video.videoHeight))) {\r\n            this.wrapU = Texture.WRAP_ADDRESSMODE;\r\n            this.wrapV = Texture.WRAP_ADDRESSMODE;\r\n        } else {\r\n            this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n            this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n            this._generateMipMaps = false;\r\n        }\r\n\r\n        this._texture = this._getEngine()!.createDynamicTexture(this.video.videoWidth, this.video.videoHeight, this._generateMipMaps, this.samplingMode);\r\n        this._texture.format = this._format ?? Constants.TEXTUREFORMAT_RGBA;\r\n\r\n        // Reset the frame ID and update the new texture to ensure it pulls in the current video frame\r\n        this._frameId = -1;\r\n        this._updateInternalTexture();\r\n    };\r\n\r\n    private _createInternalTexture = (): void => {\r\n        if (this._texture != null) {\r\n            if (this._displayingPosterTexture) {\r\n                this._displayingPosterTexture = false;\r\n            } else {\r\n                return;\r\n            }\r\n        }\r\n\r\n        this.video.addEventListener(\"resize\", this._resizeInternalTexture);\r\n        this._resizeInternalTexture();\r\n\r\n        if (!this.video.autoplay && !this._settings.poster && !this._settings.independentVideoSource) {\r\n            const oldHandler = this.video.onplaying;\r\n            const oldMuted = this.video.muted;\r\n            this.video.muted = true;\r\n            this.video.onplaying = () => {\r\n                this.video.muted = oldMuted;\r\n                this.video.onplaying = oldHandler;\r\n                this._updateInternalTexture();\r\n                if (!this._errorFound) {\r\n                    this.video.pause();\r\n                }\r\n                if (this.onLoadObservable.hasObservers()) {\r\n                    this.onLoadObservable.notifyObservers(this);\r\n                }\r\n            };\r\n            this._handlePlay();\r\n        } else {\r\n            this._updateInternalTexture();\r\n            if (this.onLoadObservable.hasObservers()) {\r\n                this.onLoadObservable.notifyObservers(this);\r\n            }\r\n        }\r\n    };\r\n\r\n    private _reset = (): void => {\r\n        if (this._texture == null) {\r\n            return;\r\n        }\r\n\r\n        if (!this._displayingPosterTexture) {\r\n            this._texture.dispose();\r\n            this._texture = null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @internal Internal method to initiate `update`.\r\n     */\r\n    public _rebuild(): void {\r\n        this.update();\r\n    }\r\n\r\n    /**\r\n     * Update Texture in the `auto` mode. Does not do anything if `settings.autoUpdateTexture` is false.\r\n     */\r\n    public update(): void {\r\n        if (!this.autoUpdateTexture) {\r\n            // Expecting user to call `updateTexture` manually\r\n            return;\r\n        }\r\n\r\n        this.updateTexture(true);\r\n    }\r\n\r\n    /**\r\n     * Update Texture in `manual` mode. Does not do anything if not visible or paused.\r\n     * @param isVisible Visibility state, detected by user using `scene.getActiveMeshes()` or otherwise.\r\n     */\r\n    public updateTexture(isVisible: boolean): void {\r\n        if (!isVisible) {\r\n            return;\r\n        }\r\n        if (this.video.paused && this._stillImageCaptured) {\r\n            return;\r\n        }\r\n        this._stillImageCaptured = true;\r\n        this._updateInternalTexture();\r\n    }\r\n\r\n    protected _updateInternalTexture = (): void => {\r\n        if (this._texture == null) {\r\n            return;\r\n        }\r\n        if (this.video.readyState < this.video.HAVE_CURRENT_DATA) {\r\n            return;\r\n        }\r\n        if (this._displayingPosterTexture) {\r\n            return;\r\n        }\r\n\r\n        const frameId = this.getScene()!.getFrameId();\r\n        if (this._frameId === frameId) {\r\n            return;\r\n        }\r\n\r\n        this._frameId = frameId;\r\n\r\n        this._getEngine()!.updateVideoTexture(this._texture, this._externalTexture ? this._externalTexture : this.video, this._invertY);\r\n    };\r\n\r\n    /**\r\n     * Get the underlying external texture (if supported by the current engine, else null)\r\n     */\r\n    public get externalTexture(): Nullable<ExternalTexture> {\r\n        return this._externalTexture;\r\n    }\r\n\r\n    /**\r\n     * Change video content. Changing video instance or setting multiple urls (as in constructor) is not supported.\r\n     * @param url New url.\r\n     */\r\n    public updateURL(url: string): void {\r\n        this.video.src = url;\r\n        this._currentSrc = url;\r\n    }\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): VideoTexture {\r\n        return new VideoTexture(this.name, this._currentSrc!, this.getScene(), this._generateMipMaps, this.invertY, this.samplingMode, this._settings);\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        this._currentSrc = null;\r\n\r\n        if (this._onUserActionRequestedObservable) {\r\n            this._onUserActionRequestedObservable.clear();\r\n            this._onUserActionRequestedObservable = null;\r\n        }\r\n\r\n        this.video.removeEventListener(this._createInternalTextureOnEvent, this._createInternalTexture);\r\n        if (!this._settings.independentVideoSource) {\r\n            this.video.removeEventListener(\"paused\", this._updateInternalTexture);\r\n            this.video.removeEventListener(\"seeked\", this._updateInternalTexture);\r\n            this.video.removeEventListener(\"emptied\", this._reset);\r\n            this.video.removeEventListener(\"resize\", this._resizeInternalTexture);\r\n            this.video.pause();\r\n        }\r\n\r\n        this._externalTexture?.dispose();\r\n    }\r\n\r\n    /**\r\n     * Creates a video texture straight from a stream.\r\n     * @param scene Define the scene the texture should be created in\r\n     * @param stream Define the stream the texture should be created from\r\n     * @param constraints video constraints\r\n     * @param invertY Defines if the video should be stored with invert Y set to true (true by default)\r\n     * @returns The created video texture as a promise\r\n     */\r\n    public static CreateFromStreamAsync(scene: Scene, stream: MediaStream, constraints: any, invertY = true): Promise<VideoTexture> {\r\n        const video = scene.getEngine().createVideoElement(constraints);\r\n\r\n        if (scene.getEngine()._badOS) {\r\n            // Yes... I know and I hope to remove it soon...\r\n            document.body.appendChild(video);\r\n            video.style.transform = \"scale(0.0001, 0.0001)\";\r\n            video.style.opacity = \"0\";\r\n            video.style.position = \"fixed\";\r\n            video.style.bottom = \"0px\";\r\n            video.style.right = \"0px\";\r\n        }\r\n\r\n        video.setAttribute(\"autoplay\", \"\");\r\n        video.setAttribute(\"muted\", \"true\");\r\n        video.setAttribute(\"playsinline\", \"\");\r\n        video.muted = true;\r\n\r\n        if (video.isNative) {\r\n            // No additional configuration needed for native\r\n        } else if (video.mozSrcObject !== undefined) {\r\n            // hack for Firefox < 19\r\n            video.mozSrcObject = stream;\r\n        } else {\r\n            if (typeof video.srcObject == \"object\") {\r\n                video.srcObject = stream;\r\n            } else {\r\n                // older API. See https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL#using_object_urls_for_media_streams\r\n                video.src = window.URL && window.URL.createObjectURL(stream as any);\r\n            }\r\n        }\r\n\r\n        return new Promise<VideoTexture>((resolve) => {\r\n            const onPlaying = () => {\r\n                const videoTexture = new VideoTexture(\"video\", video, scene, true, invertY, undefined, undefined, undefined, Constants.TEXTUREFORMAT_RGB);\r\n                if (scene.getEngine()._badOS) {\r\n                    videoTexture.onDisposeObservable.addOnce(() => {\r\n                        video.remove();\r\n                    });\r\n                }\r\n                videoTexture.onDisposeObservable.addOnce(() => {\r\n                    removeSource(video);\r\n                });\r\n\r\n                resolve(videoTexture);\r\n                video.removeEventListener(\"playing\", onPlaying);\r\n            };\r\n\r\n            video.addEventListener(\"playing\", onPlaying);\r\n            video.play();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a video texture straight from your WebCam video feed.\r\n     * @param scene Define the scene the texture should be created in\r\n     * @param constraints Define the constraints to use to create the web cam feed from WebRTC\r\n     * @param audioConstaints Define the audio constraints to use to create the web cam feed from WebRTC\r\n     * @param invertY Defines if the video should be stored with invert Y set to true (true by default)\r\n     * @returns The created video texture as a promise\r\n     */\r\n    public static async CreateFromWebCamAsync(\r\n        scene: Scene,\r\n        constraints: {\r\n            minWidth: number;\r\n            maxWidth: number;\r\n            minHeight: number;\r\n            maxHeight: number;\r\n            deviceId: string;\r\n        } & MediaTrackConstraints,\r\n        audioConstaints: boolean | MediaTrackConstraints = false,\r\n        invertY = true\r\n    ): Promise<VideoTexture> {\r\n        if (navigator.mediaDevices) {\r\n            const stream = await navigator.mediaDevices.getUserMedia({\r\n                video: constraints,\r\n                audio: audioConstaints,\r\n            });\r\n\r\n            const videoTexture = await this.CreateFromStreamAsync(scene, stream, constraints, invertY);\r\n            videoTexture.onDisposeObservable.addOnce(() => {\r\n                stream.getTracks().forEach((track) => {\r\n                    track.stop();\r\n                });\r\n            });\r\n\r\n            return videoTexture;\r\n        }\r\n\r\n        return Promise.reject(\"No support for userMedia on this device\");\r\n    }\r\n\r\n    /**\r\n     * Creates a video texture straight from your WebCam video feed.\r\n     * @param scene Defines the scene the texture should be created in\r\n     * @param onReady Defines a callback to triggered once the texture will be ready\r\n     * @param constraints Defines the constraints to use to create the web cam feed from WebRTC\r\n     * @param audioConstaints Defines the audio constraints to use to create the web cam feed from WebRTC\r\n     * @param invertY Defines if the video should be stored with invert Y set to true (true by default)\r\n     */\r\n    public static CreateFromWebCam(\r\n        scene: Scene,\r\n        onReady: (videoTexture: VideoTexture) => void,\r\n        constraints: {\r\n            minWidth: number;\r\n            maxWidth: number;\r\n            minHeight: number;\r\n            maxHeight: number;\r\n            deviceId: string;\r\n        } & MediaTrackConstraints,\r\n        audioConstaints: boolean | MediaTrackConstraints = false,\r\n        invertY = true\r\n    ): void {\r\n        this.CreateFromWebCamAsync(scene, constraints, audioConstaints, invertY)\r\n            .then(function (videoTexture) {\r\n                if (onReady) {\r\n                    onReady(videoTexture);\r\n                }\r\n            })\r\n            .catch(function (err) {\r\n                Logger.Error(err.name);\r\n            });\r\n    }\r\n}\r\n\r\nTexture._CreateVideoTexture = (\r\n    name: Nullable<string>,\r\n    src: string | string[] | HTMLVideoElement,\r\n    scene: Nullable<Scene>,\r\n    generateMipMaps = false,\r\n    invertY = false,\r\n    samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n    settings: Partial<VideoTextureSettings> = {},\r\n    onError?: Nullable<(message?: string, exception?: any) => void>,\r\n    format: number = Constants.TEXTUREFORMAT_RGBA\r\n) => {\r\n    return new VideoTexture(name, src, scene, generateMipMaps, invertY, samplingMode, settings, onError, format);\r\n};\r\n// Some exporters relies on Tools.Instantiate\r\nRegisterClass(\"BABYLON.VideoTexture\", VideoTexture);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}