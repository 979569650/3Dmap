{"ast":null,"code":"import { RichTypeNumber } from \"../../../flowGraphRichTypes.js\";\nimport { FlowGraphWithOnDoneExecutionBlock } from \"../../../flowGraphWithOnDoneExecutionBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\n/**\n * @experimental\n * A block that throttles the execution of its output flow.\n */\nexport class FlowGraphThrottleBlock extends FlowGraphWithOnDoneExecutionBlock {\n  constructor(config) {\n    super(config);\n    this.reset = this._registerSignalInput(\"reset\");\n    this.duration = this._registerDataInput(\"duration\", RichTypeNumber);\n    this.timeRemaining = this._registerDataOutput(\"timeRemaining\", RichTypeNumber);\n  }\n  _execute(context, callingSignal) {\n    const lastExecutedTime = context._getExecutionVariable(this, \"lastExecutedTime\");\n    const durationValue = this.duration.getValue(context);\n    const currentTime = Date.now();\n    if (callingSignal === this.reset || lastExecutedTime === undefined || currentTime - lastExecutedTime > durationValue) {\n      //activate the output flow\n      this.timeRemaining.setValue(0, context);\n      this.onDone._activateSignal(context);\n      context._setExecutionVariable(this, \"lastExecutedTime\", currentTime);\n    } else {\n      //activate the output flow after the remaining time\n      const remaining = durationValue - (currentTime - lastExecutedTime);\n      this.timeRemaining.setValue(remaining, context);\n    }\n  }\n  getClassName() {\n    return \"FGThrottleBlock\";\n  }\n}\nRegisterClass(\"FGThrottleBlock\", FlowGraphThrottleBlock);","map":{"version":3,"names":["RichTypeNumber","FlowGraphWithOnDoneExecutionBlock","RegisterClass","FlowGraphThrottleBlock","constructor","config","reset","_registerSignalInput","duration","_registerDataInput","timeRemaining","_registerDataOutput","_execute","context","callingSignal","lastExecutedTime","_getExecutionVariable","durationValue","getValue","currentTime","Date","now","undefined","setValue","onDone","_activateSignal","_setExecutionVariable","remaining","getClassName"],"sources":["../../../../../../../dev/core/src/FlowGraph/Blocks/Execution/ControlFlow/flowGraphThrottleBlock.ts"],"sourcesContent":["import type { FlowGraphContext } from \"../../../flowGraphContext\";\r\nimport type { FlowGraphDataConnection } from \"../../../flowGraphDataConnection\";\r\nimport { RichTypeNumber } from \"../../../flowGraphRichTypes\";\r\nimport type { FlowGraphSignalConnection } from \"../../../flowGraphSignalConnection\";\r\nimport { FlowGraphWithOnDoneExecutionBlock } from \"../../../flowGraphWithOnDoneExecutionBlock\";\r\nimport type { IFlowGraphBlockConfiguration } from \"../../../flowGraphBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\n/**\r\n * @experimental\r\n * A block that throttles the execution of its output flow.\r\n */\r\nexport class FlowGraphThrottleBlock extends FlowGraphWithOnDoneExecutionBlock {\r\n    /**\r\n     * Input connection: The duration of the throttle, in ms.\r\n     */\r\n    public readonly duration: FlowGraphDataConnection<number>;\r\n    /**\r\n     * Input connection: Resets the throttle.\r\n     */\r\n    public readonly reset: FlowGraphSignalConnection;\r\n    /**\r\n     * Output connection: The time remaining before the throttle is done, in ms.\r\n     */\r\n    public readonly timeRemaining: FlowGraphDataConnection<number>;\r\n\r\n    constructor(config?: IFlowGraphBlockConfiguration) {\r\n        super(config);\r\n        this.reset = this._registerSignalInput(\"reset\");\r\n        this.duration = this._registerDataInput(\"duration\", RichTypeNumber);\r\n        this.timeRemaining = this._registerDataOutput(\"timeRemaining\", RichTypeNumber);\r\n    }\r\n    public _execute(context: FlowGraphContext, callingSignal: FlowGraphSignalConnection): void {\r\n        const lastExecutedTime = context._getExecutionVariable(this, \"lastExecutedTime\");\r\n        const durationValue = this.duration.getValue(context);\r\n        const currentTime = Date.now();\r\n        if (callingSignal === this.reset || lastExecutedTime === undefined || currentTime - lastExecutedTime > durationValue) {\r\n            //activate the output flow\r\n            this.timeRemaining.setValue(0, context);\r\n            this.onDone._activateSignal(context);\r\n            context._setExecutionVariable(this, \"lastExecutedTime\", currentTime);\r\n        } else {\r\n            //activate the output flow after the remaining time\r\n            const remaining = durationValue - (currentTime - lastExecutedTime);\r\n            this.timeRemaining.setValue(remaining, context);\r\n        }\r\n    }\r\n    public getClassName(): string {\r\n        return \"FGThrottleBlock\";\r\n    }\r\n}\r\nRegisterClass(\"FGThrottleBlock\", FlowGraphThrottleBlock);\r\n"],"mappings":"AAEA,SAASA,cAAc,QAAQ,gCAA8B;AAE7D,SAASC,iCAAiC,QAAQ,+CAA6C;AAE/F,SAASC,aAAa,QAAQ,+BAA6B;AAC3D;;;;AAIA,OAAM,MAAOC,sBAAuB,SAAQF,iCAAiC;EAczEG,YAAYC,MAAqC;IAC7C,KAAK,CAACA,MAAM,CAAC;IACb,IAAI,CAACC,KAAK,GAAG,IAAI,CAACC,oBAAoB,CAAC,OAAO,CAAC;IAC/C,IAAI,CAACC,QAAQ,GAAG,IAAI,CAACC,kBAAkB,CAAC,UAAU,EAAET,cAAc,CAAC;IACnE,IAAI,CAACU,aAAa,GAAG,IAAI,CAACC,mBAAmB,CAAC,eAAe,EAAEX,cAAc,CAAC;EAClF;EACOY,QAAQA,CAACC,OAAyB,EAAEC,aAAwC;IAC/E,MAAMC,gBAAgB,GAAGF,OAAO,CAACG,qBAAqB,CAAC,IAAI,EAAE,kBAAkB,CAAC;IAChF,MAAMC,aAAa,GAAG,IAAI,CAACT,QAAQ,CAACU,QAAQ,CAACL,OAAO,CAAC;IACrD,MAAMM,WAAW,GAAGC,IAAI,CAACC,GAAG,EAAE;IAC9B,IAAIP,aAAa,KAAK,IAAI,CAACR,KAAK,IAAIS,gBAAgB,KAAKO,SAAS,IAAIH,WAAW,GAAGJ,gBAAgB,GAAGE,aAAa,EAAE;MAClH;MACA,IAAI,CAACP,aAAa,CAACa,QAAQ,CAAC,CAAC,EAAEV,OAAO,CAAC;MACvC,IAAI,CAACW,MAAM,CAACC,eAAe,CAACZ,OAAO,CAAC;MACpCA,OAAO,CAACa,qBAAqB,CAAC,IAAI,EAAE,kBAAkB,EAAEP,WAAW,CAAC;KACvE,MAAM;MACH;MACA,MAAMQ,SAAS,GAAGV,aAAa,IAAIE,WAAW,GAAGJ,gBAAgB,CAAC;MAClE,IAAI,CAACL,aAAa,CAACa,QAAQ,CAACI,SAAS,EAAEd,OAAO,CAAC;;EAEvD;EACOe,YAAYA,CAAA;IACf,OAAO,iBAAiB;EAC5B;;AAEJ1B,aAAa,CAAC,iBAAiB,EAAEC,sBAAsB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}