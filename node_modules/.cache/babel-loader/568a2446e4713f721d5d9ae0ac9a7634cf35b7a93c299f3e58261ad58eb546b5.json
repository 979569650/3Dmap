{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Plane } from \"./math.plane.js\";\n/**\n * Represents a camera frustum\n */\nexport class Frustum {\n  /**\n   * Gets the planes representing the frustum\n   * @param transform matrix to be applied to the returned planes\n   * @returns a new array of 6 Frustum planes computed by the given transformation matrix.\n   */\n  static GetPlanes(transform) {\n    const frustumPlanes = [];\n    for (let index = 0; index < 6; index++) {\n      frustumPlanes.push(new Plane(0.0, 0.0, 0.0, 0.0));\n    }\n    Frustum.GetPlanesToRef(transform, frustumPlanes);\n    return frustumPlanes;\n  }\n  /**\n   * Gets the near frustum plane transformed by the transform matrix\n   * @param transform transformation matrix to be applied to the resulting frustum plane\n   * @param frustumPlane the resulting frustum plane\n   */\n  static GetNearPlaneToRef(transform, frustumPlane) {\n    const m = transform.m;\n    frustumPlane.normal.x = m[3] + m[2];\n    frustumPlane.normal.y = m[7] + m[6];\n    frustumPlane.normal.z = m[11] + m[10];\n    frustumPlane.d = m[15] + m[14];\n    frustumPlane.normalize();\n  }\n  /**\n   * Gets the far frustum plane transformed by the transform matrix\n   * @param transform transformation matrix to be applied to the resulting frustum plane\n   * @param frustumPlane the resulting frustum plane\n   */\n  static GetFarPlaneToRef(transform, frustumPlane) {\n    const m = transform.m;\n    frustumPlane.normal.x = m[3] - m[2];\n    frustumPlane.normal.y = m[7] - m[6];\n    frustumPlane.normal.z = m[11] - m[10];\n    frustumPlane.d = m[15] - m[14];\n    frustumPlane.normalize();\n  }\n  /**\n   * Gets the left frustum plane transformed by the transform matrix\n   * @param transform transformation matrix to be applied to the resulting frustum plane\n   * @param frustumPlane the resulting frustum plane\n   */\n  static GetLeftPlaneToRef(transform, frustumPlane) {\n    const m = transform.m;\n    frustumPlane.normal.x = m[3] + m[0];\n    frustumPlane.normal.y = m[7] + m[4];\n    frustumPlane.normal.z = m[11] + m[8];\n    frustumPlane.d = m[15] + m[12];\n    frustumPlane.normalize();\n  }\n  /**\n   * Gets the right frustum plane transformed by the transform matrix\n   * @param transform transformation matrix to be applied to the resulting frustum plane\n   * @param frustumPlane the resulting frustum plane\n   */\n  static GetRightPlaneToRef(transform, frustumPlane) {\n    const m = transform.m;\n    frustumPlane.normal.x = m[3] - m[0];\n    frustumPlane.normal.y = m[7] - m[4];\n    frustumPlane.normal.z = m[11] - m[8];\n    frustumPlane.d = m[15] - m[12];\n    frustumPlane.normalize();\n  }\n  /**\n   * Gets the top frustum plane transformed by the transform matrix\n   * @param transform transformation matrix to be applied to the resulting frustum plane\n   * @param frustumPlane the resulting frustum plane\n   */\n  static GetTopPlaneToRef(transform, frustumPlane) {\n    const m = transform.m;\n    frustumPlane.normal.x = m[3] - m[1];\n    frustumPlane.normal.y = m[7] - m[5];\n    frustumPlane.normal.z = m[11] - m[9];\n    frustumPlane.d = m[15] - m[13];\n    frustumPlane.normalize();\n  }\n  /**\n   * Gets the bottom frustum plane transformed by the transform matrix\n   * @param transform transformation matrix to be applied to the resulting frustum plane\n   * @param frustumPlane the resulting frustum plane\n   */\n  static GetBottomPlaneToRef(transform, frustumPlane) {\n    const m = transform.m;\n    frustumPlane.normal.x = m[3] + m[1];\n    frustumPlane.normal.y = m[7] + m[5];\n    frustumPlane.normal.z = m[11] + m[9];\n    frustumPlane.d = m[15] + m[13];\n    frustumPlane.normalize();\n  }\n  /**\n   * Sets the given array \"frustumPlanes\" with the 6 Frustum planes computed by the given transformation matrix.\n   * @param transform transformation matrix to be applied to the resulting frustum planes\n   * @param frustumPlanes the resulting frustum planes\n   */\n  static GetPlanesToRef(transform, frustumPlanes) {\n    // Near\n    Frustum.GetNearPlaneToRef(transform, frustumPlanes[0]);\n    // Far\n    Frustum.GetFarPlaneToRef(transform, frustumPlanes[1]);\n    // Left\n    Frustum.GetLeftPlaneToRef(transform, frustumPlanes[2]);\n    // Right\n    Frustum.GetRightPlaneToRef(transform, frustumPlanes[3]);\n    // Top\n    Frustum.GetTopPlaneToRef(transform, frustumPlanes[4]);\n    // Bottom\n    Frustum.GetBottomPlaneToRef(transform, frustumPlanes[5]);\n  }\n  /**\n   * Tests if a point is located between the frustum planes.\n   * @param point defines the point to test\n   * @param frustumPlanes defines the frustum planes to test\n   * @returns true if the point is located between the frustum planes\n   */\n  static IsPointInFrustum(point, frustumPlanes) {\n    for (let i = 0; i < 6; i++) {\n      if (frustumPlanes[i].dotCoordinate(point) < 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n}","map":{"version":3,"names":["Plane","Frustum","GetPlanes","transform","frustumPlanes","index","push","GetPlanesToRef","GetNearPlaneToRef","frustumPlane","m","normal","x","y","z","d","normalize","GetFarPlaneToRef","GetLeftPlaneToRef","GetRightPlaneToRef","GetTopPlaneToRef","GetBottomPlaneToRef","IsPointInFrustum","point","i","dotCoordinate"],"sources":["../../../../dev/core/src/Maths/math.frustum.ts"],"sourcesContent":["import type { Matrix, Vector3 } from \"./math.vector\";\r\nimport type { DeepImmutable } from \"../types\";\r\nimport { Plane } from \"./math.plane\";\r\n\r\n/**\r\n * Represents a camera frustum\r\n */\r\nexport class Frustum {\r\n    /**\r\n     * Gets the planes representing the frustum\r\n     * @param transform matrix to be applied to the returned planes\r\n     * @returns a new array of 6 Frustum planes computed by the given transformation matrix.\r\n     */\r\n    public static GetPlanes(transform: DeepImmutable<Matrix>): Plane[] {\r\n        const frustumPlanes = [];\r\n        for (let index = 0; index < 6; index++) {\r\n            frustumPlanes.push(new Plane(0.0, 0.0, 0.0, 0.0));\r\n        }\r\n        Frustum.GetPlanesToRef(transform, frustumPlanes);\r\n        return frustumPlanes;\r\n    }\r\n\r\n    /**\r\n     * Gets the near frustum plane transformed by the transform matrix\r\n     * @param transform transformation matrix to be applied to the resulting frustum plane\r\n     * @param frustumPlane the resulting frustum plane\r\n     */\r\n    public static GetNearPlaneToRef(transform: DeepImmutable<Matrix>, frustumPlane: Plane): void {\r\n        const m = transform.m;\r\n        frustumPlane.normal.x = m[3] + m[2];\r\n        frustumPlane.normal.y = m[7] + m[6];\r\n        frustumPlane.normal.z = m[11] + m[10];\r\n        frustumPlane.d = m[15] + m[14];\r\n        frustumPlane.normalize();\r\n    }\r\n\r\n    /**\r\n     * Gets the far frustum plane transformed by the transform matrix\r\n     * @param transform transformation matrix to be applied to the resulting frustum plane\r\n     * @param frustumPlane the resulting frustum plane\r\n     */\r\n    public static GetFarPlaneToRef(transform: DeepImmutable<Matrix>, frustumPlane: Plane): void {\r\n        const m = transform.m;\r\n        frustumPlane.normal.x = m[3] - m[2];\r\n        frustumPlane.normal.y = m[7] - m[6];\r\n        frustumPlane.normal.z = m[11] - m[10];\r\n        frustumPlane.d = m[15] - m[14];\r\n        frustumPlane.normalize();\r\n    }\r\n\r\n    /**\r\n     * Gets the left frustum plane transformed by the transform matrix\r\n     * @param transform transformation matrix to be applied to the resulting frustum plane\r\n     * @param frustumPlane the resulting frustum plane\r\n     */\r\n    public static GetLeftPlaneToRef(transform: DeepImmutable<Matrix>, frustumPlane: Plane): void {\r\n        const m = transform.m;\r\n        frustumPlane.normal.x = m[3] + m[0];\r\n        frustumPlane.normal.y = m[7] + m[4];\r\n        frustumPlane.normal.z = m[11] + m[8];\r\n        frustumPlane.d = m[15] + m[12];\r\n        frustumPlane.normalize();\r\n    }\r\n\r\n    /**\r\n     * Gets the right frustum plane transformed by the transform matrix\r\n     * @param transform transformation matrix to be applied to the resulting frustum plane\r\n     * @param frustumPlane the resulting frustum plane\r\n     */\r\n    public static GetRightPlaneToRef(transform: DeepImmutable<Matrix>, frustumPlane: Plane): void {\r\n        const m = transform.m;\r\n        frustumPlane.normal.x = m[3] - m[0];\r\n        frustumPlane.normal.y = m[7] - m[4];\r\n        frustumPlane.normal.z = m[11] - m[8];\r\n        frustumPlane.d = m[15] - m[12];\r\n        frustumPlane.normalize();\r\n    }\r\n\r\n    /**\r\n     * Gets the top frustum plane transformed by the transform matrix\r\n     * @param transform transformation matrix to be applied to the resulting frustum plane\r\n     * @param frustumPlane the resulting frustum plane\r\n     */\r\n    public static GetTopPlaneToRef(transform: DeepImmutable<Matrix>, frustumPlane: Plane): void {\r\n        const m = transform.m;\r\n        frustumPlane.normal.x = m[3] - m[1];\r\n        frustumPlane.normal.y = m[7] - m[5];\r\n        frustumPlane.normal.z = m[11] - m[9];\r\n        frustumPlane.d = m[15] - m[13];\r\n        frustumPlane.normalize();\r\n    }\r\n\r\n    /**\r\n     * Gets the bottom frustum plane transformed by the transform matrix\r\n     * @param transform transformation matrix to be applied to the resulting frustum plane\r\n     * @param frustumPlane the resulting frustum plane\r\n     */\r\n    public static GetBottomPlaneToRef(transform: DeepImmutable<Matrix>, frustumPlane: Plane): void {\r\n        const m = transform.m;\r\n        frustumPlane.normal.x = m[3] + m[1];\r\n        frustumPlane.normal.y = m[7] + m[5];\r\n        frustumPlane.normal.z = m[11] + m[9];\r\n        frustumPlane.d = m[15] + m[13];\r\n        frustumPlane.normalize();\r\n    }\r\n\r\n    /**\r\n     * Sets the given array \"frustumPlanes\" with the 6 Frustum planes computed by the given transformation matrix.\r\n     * @param transform transformation matrix to be applied to the resulting frustum planes\r\n     * @param frustumPlanes the resulting frustum planes\r\n     */\r\n    public static GetPlanesToRef(transform: DeepImmutable<Matrix>, frustumPlanes: Plane[]): void {\r\n        // Near\r\n        Frustum.GetNearPlaneToRef(transform, frustumPlanes[0]);\r\n\r\n        // Far\r\n        Frustum.GetFarPlaneToRef(transform, frustumPlanes[1]);\r\n\r\n        // Left\r\n        Frustum.GetLeftPlaneToRef(transform, frustumPlanes[2]);\r\n\r\n        // Right\r\n        Frustum.GetRightPlaneToRef(transform, frustumPlanes[3]);\r\n\r\n        // Top\r\n        Frustum.GetTopPlaneToRef(transform, frustumPlanes[4]);\r\n\r\n        // Bottom\r\n        Frustum.GetBottomPlaneToRef(transform, frustumPlanes[5]);\r\n    }\r\n\r\n    /**\r\n     * Tests if a point is located between the frustum planes.\r\n     * @param point defines the point to test\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if the point is located between the frustum planes\r\n     */\r\n    public static IsPointInFrustum(point: Vector3, frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        for (let i = 0; i < 6; i++) {\r\n            if (frustumPlanes[i].dotCoordinate(point) < 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}