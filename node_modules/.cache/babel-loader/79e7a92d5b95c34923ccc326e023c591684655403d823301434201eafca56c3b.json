{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../tslib.es6.js\";\nimport { serialize, SerializationHelper } from \"../Misc/decorators.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { SubMesh } from \"../Meshes/subMesh.js\";\nimport { UniformBuffer } from \"./uniformBuffer.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Plane } from \"../Maths/math.plane.js\";\nimport { MaterialHelper } from \"./materialHelper.js\";\nimport { DrawWrapper } from \"./drawWrapper.js\";\nimport { MaterialStencilState } from \"./materialStencilState.js\";\nimport { ScenePerformancePriority } from \"../scene.js\";\nimport { MaterialPluginEvent } from \"./materialPluginEvent.js\";\n/**\n * Base class for the main features of a material in Babylon.js\n */\nexport class Material {\n  /**\n   * If the material can be rendered to several textures with MRT extension\n   */\n  get canRenderToMRT() {\n    // By default, shaders are not compatible with MRTs\n    // Base classes should override that if their shader supports MRT\n    return false;\n  }\n  /**\n   * Sets the alpha value of the material\n   */\n  set alpha(value) {\n    if (this._alpha === value) {\n      return;\n    }\n    const oldValue = this._alpha;\n    this._alpha = value;\n    // Only call dirty when there is a state change (no alpha / alpha)\n    if (oldValue === 1 || value === 1) {\n      this.markAsDirty(Material.MiscDirtyFlag + Material.PrePassDirtyFlag);\n    }\n  }\n  /**\n   * Gets the alpha value of the material\n   */\n  get alpha() {\n    return this._alpha;\n  }\n  /**\n   * Sets the culling state (true to enable culling, false to disable)\n   */\n  set backFaceCulling(value) {\n    if (this._backFaceCulling === value) {\n      return;\n    }\n    this._backFaceCulling = value;\n    this.markAsDirty(Material.TextureDirtyFlag);\n  }\n  /**\n   * Gets the culling state\n   */\n  get backFaceCulling() {\n    return this._backFaceCulling;\n  }\n  /**\n   * Sets the type of faces that should be culled (true for back faces, false for front faces)\n   */\n  set cullBackFaces(value) {\n    if (this._cullBackFaces === value) {\n      return;\n    }\n    this._cullBackFaces = value;\n    this.markAsDirty(Material.TextureDirtyFlag);\n  }\n  /**\n   * Gets the type of faces that should be culled\n   */\n  get cullBackFaces() {\n    return this._cullBackFaces;\n  }\n  /**\n   * Block the dirty-mechanism for this specific material\n   * When set to false after being true the material will be marked as dirty.\n   */\n  get blockDirtyMechanism() {\n    return this._blockDirtyMechanism;\n  }\n  set blockDirtyMechanism(value) {\n    if (this._blockDirtyMechanism === value) {\n      return;\n    }\n    this._blockDirtyMechanism = value;\n    if (!value) {\n      this.markDirty();\n    }\n  }\n  /**\n   * This allows you to modify the material without marking it as dirty after every change.\n   * This function should be used if you need to make more than one dirty-enabling change to the material - adding a texture, setting a new fill mode and so on.\n   * The callback will pass the material as an argument, so you can make your changes to it.\n   * @param callback the callback to be executed that will update the material\n   */\n  atomicMaterialsUpdate(callback) {\n    this.blockDirtyMechanism = true;\n    try {\n      callback(this);\n    } finally {\n      this.blockDirtyMechanism = false;\n    }\n  }\n  /**\n   * Gets a boolean indicating that current material needs to register RTT\n   */\n  get hasRenderTargetTextures() {\n    this._eventInfo.hasRenderTargetTextures = false;\n    this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);\n    return this._eventInfo.hasRenderTargetTextures;\n  }\n  /**\n   * Called during a dispose event\n   */\n  set onDispose(callback) {\n    if (this._onDisposeObserver) {\n      this.onDisposeObservable.remove(this._onDisposeObserver);\n    }\n    this._onDisposeObserver = this.onDisposeObservable.add(callback);\n  }\n  /**\n   * An event triggered when the material is bound\n   */\n  get onBindObservable() {\n    if (!this._onBindObservable) {\n      this._onBindObservable = new Observable();\n    }\n    return this._onBindObservable;\n  }\n  /**\n   * Called during a bind event\n   */\n  set onBind(callback) {\n    if (this._onBindObserver) {\n      this.onBindObservable.remove(this._onBindObserver);\n    }\n    this._onBindObserver = this.onBindObservable.add(callback);\n  }\n  /**\n   * An event triggered when the material is unbound\n   */\n  get onUnBindObservable() {\n    if (!this._onUnBindObservable) {\n      this._onUnBindObservable = new Observable();\n    }\n    return this._onUnBindObservable;\n  }\n  /**\n   * An event triggered when the effect is (re)created\n   */\n  get onEffectCreatedObservable() {\n    if (!this._onEffectCreatedObservable) {\n      this._onEffectCreatedObservable = new Observable();\n    }\n    return this._onEffectCreatedObservable;\n  }\n  /**\n   * Sets the value of the alpha mode.\n   *\n   * | Value | Type | Description |\n   * | --- | --- | --- |\n   * | 0 | ALPHA_DISABLE |   |\n   * | 1 | ALPHA_ADD |   |\n   * | 2 | ALPHA_COMBINE |   |\n   * | 3 | ALPHA_SUBTRACT |   |\n   * | 4 | ALPHA_MULTIPLY |   |\n   * | 5 | ALPHA_MAXIMIZED |   |\n   * | 6 | ALPHA_ONEONE |   |\n   * | 7 | ALPHA_PREMULTIPLIED |   |\n   * | 8 | ALPHA_PREMULTIPLIED_PORTERDUFF |   |\n   * | 9 | ALPHA_INTERPOLATE |   |\n   * | 10 | ALPHA_SCREENMODE |   |\n   *\n   */\n  set alphaMode(value) {\n    if (this._alphaMode === value) {\n      return;\n    }\n    this._alphaMode = value;\n    this.markAsDirty(Material.TextureDirtyFlag);\n  }\n  /**\n   * Gets the value of the alpha mode\n   */\n  get alphaMode() {\n    return this._alphaMode;\n  }\n  /**\n   * Sets the need depth pre-pass value\n   */\n  set needDepthPrePass(value) {\n    if (this._needDepthPrePass === value) {\n      return;\n    }\n    this._needDepthPrePass = value;\n    if (this._needDepthPrePass) {\n      this.checkReadyOnEveryCall = true;\n    }\n  }\n  /**\n   * Gets the depth pre-pass value\n   */\n  get needDepthPrePass() {\n    return this._needDepthPrePass;\n  }\n  /**\n   * Can this material render to prepass\n   */\n  get isPrePassCapable() {\n    return false;\n  }\n  /**\n   * Sets the state for enabling fog\n   */\n  set fogEnabled(value) {\n    if (this._fogEnabled === value) {\n      return;\n    }\n    this._fogEnabled = value;\n    this.markAsDirty(Material.MiscDirtyFlag);\n  }\n  /**\n   * Gets the value of the fog enabled state\n   */\n  get fogEnabled() {\n    return this._fogEnabled;\n  }\n  get wireframe() {\n    switch (this._fillMode) {\n      case Material.WireFrameFillMode:\n      case Material.LineListDrawMode:\n      case Material.LineLoopDrawMode:\n      case Material.LineStripDrawMode:\n        return true;\n    }\n    return this._scene.forceWireframe;\n  }\n  /**\n   * Sets the state of wireframe mode\n   */\n  set wireframe(value) {\n    this.fillMode = value ? Material.WireFrameFillMode : Material.TriangleFillMode;\n  }\n  /**\n   * Gets the value specifying if point clouds are enabled\n   */\n  get pointsCloud() {\n    switch (this._fillMode) {\n      case Material.PointFillMode:\n      case Material.PointListDrawMode:\n        return true;\n    }\n    return this._scene.forcePointsCloud;\n  }\n  /**\n   * Sets the state of point cloud mode\n   */\n  set pointsCloud(value) {\n    this.fillMode = value ? Material.PointFillMode : Material.TriangleFillMode;\n  }\n  /**\n   * Gets the material fill mode\n   */\n  get fillMode() {\n    return this._fillMode;\n  }\n  /**\n   * Sets the material fill mode\n   */\n  set fillMode(value) {\n    if (this._fillMode === value) {\n      return;\n    }\n    this._fillMode = value;\n    this.markAsDirty(Material.MiscDirtyFlag);\n  }\n  /** @internal */\n  _getDrawWrapper() {\n    return this._drawWrapper;\n  }\n  /**\n   * @internal\n   */\n  _setDrawWrapper(drawWrapper) {\n    this._drawWrapper = drawWrapper;\n  }\n  /**\n   * Creates a material instance\n   * @param name defines the name of the material\n   * @param scene defines the scene to reference\n   * @param doNotAdd specifies if the material should be added to the scene\n   */\n  constructor(name, scene, doNotAdd) {\n    /**\n     * Custom shadow depth material to use for shadow rendering instead of the in-built one\n     */\n    this.shadowDepthWrapper = null;\n    /**\n     * Gets or sets a boolean indicating that the material is allowed (if supported) to do shader hot swapping.\n     * This means that the material can keep using a previous shader while a new one is being compiled.\n     * This is mostly used when shader parallel compilation is supported (true by default)\n     */\n    this.allowShaderHotSwapping = true;\n    /**\n     * Gets or sets user defined metadata\n     */\n    this.metadata = null;\n    /**\n     * For internal use only. Please do not use.\n     */\n    this.reservedDataStore = null;\n    /**\n     * Specifies if the ready state should be checked on each call\n     */\n    this.checkReadyOnEveryCall = false;\n    /**\n     * Specifies if the ready state should be checked once\n     */\n    this.checkReadyOnlyOnce = false;\n    /**\n     * The state of the material\n     */\n    this.state = \"\";\n    /**\n     * The alpha value of the material\n     */\n    this._alpha = 1.0;\n    /**\n     * Specifies if back face culling is enabled\n     */\n    this._backFaceCulling = true;\n    /**\n     * Specifies if back or front faces should be culled (when culling is enabled)\n     */\n    this._cullBackFaces = true;\n    this._blockDirtyMechanism = false;\n    /**\n     * Callback triggered when the material is compiled\n     */\n    this.onCompiled = null;\n    /**\n     * Callback triggered when an error occurs\n     */\n    this.onError = null;\n    /**\n     * Callback triggered to get the render target textures\n     */\n    this.getRenderTargetTextures = null;\n    /**\n     * Specifies if the material should be serialized\n     */\n    this.doNotSerialize = false;\n    /**\n     * @internal\n     */\n    this._storeEffectOnSubMeshes = false;\n    /**\n     * Stores the animations for the material\n     */\n    this.animations = null;\n    /**\n     * An event triggered when the material is disposed\n     */\n    this.onDisposeObservable = new Observable();\n    /**\n     * An observer which watches for dispose events\n     */\n    this._onDisposeObserver = null;\n    this._onUnBindObservable = null;\n    /**\n     * An observer which watches for bind events\n     */\n    this._onBindObserver = null;\n    /**\n     * Stores the value of the alpha mode\n     */\n    this._alphaMode = 2;\n    /**\n     * Stores the state of the need depth pre-pass value\n     */\n    this._needDepthPrePass = false;\n    /**\n     * Specifies if depth writing should be disabled\n     */\n    this.disableDepthWrite = false;\n    /**\n     * Specifies if color writing should be disabled\n     */\n    this.disableColorWrite = false;\n    /**\n     * Specifies if depth writing should be forced\n     */\n    this.forceDepthWrite = false;\n    /**\n     * Specifies the depth function that should be used. 0 means the default engine function\n     */\n    this.depthFunction = 0;\n    /**\n     * Specifies if there should be a separate pass for culling\n     */\n    this.separateCullingPass = false;\n    /**\n     * Stores the state specifying if fog should be enabled\n     */\n    this._fogEnabled = true;\n    /**\n     * Stores the size of points\n     */\n    this.pointSize = 1.0;\n    /**\n     * Stores the z offset Factor value\n     */\n    this.zOffset = 0;\n    /**\n     * Stores the z offset Units value\n     */\n    this.zOffsetUnits = 0;\n    /**\n     * Gives access to the stencil properties of the material\n     */\n    this.stencil = new MaterialStencilState();\n    /**\n     * Specifies if uniform buffers should be used\n     */\n    this._useUBO = false;\n    /**\n     * Stores the fill mode state\n     */\n    this._fillMode = Material.TriangleFillMode;\n    /**\n     * Specifies if the depth write state should be cached\n     */\n    this._cachedDepthWriteState = false;\n    /**\n     * Specifies if the color write state should be cached\n     */\n    this._cachedColorWriteState = false;\n    /**\n     * Specifies if the depth function state should be cached\n     */\n    this._cachedDepthFunctionState = 0;\n    /** @internal */\n    this._indexInSceneMaterialArray = -1;\n    /** @internal */\n    this.meshMap = null;\n    /** @internal */\n    this._parentContainer = null;\n    /** @internal */\n    this._uniformBufferLayoutBuilt = false;\n    this._eventInfo = {}; // will be initialized before each event notification\n    /** @internal */\n    this._callbackPluginEventGeneric = () => void 0;\n    /** @internal */\n    this._callbackPluginEventIsReadyForSubMesh = () => void 0;\n    /** @internal */\n    this._callbackPluginEventPrepareDefines = () => void 0;\n    /** @internal */\n    this._callbackPluginEventPrepareDefinesBeforeAttributes = () => void 0;\n    /** @internal */\n    this._callbackPluginEventHardBindForSubMesh = () => void 0;\n    /** @internal */\n    this._callbackPluginEventBindForSubMesh = () => void 0;\n    /** @internal */\n    this._callbackPluginEventHasRenderTargetTextures = () => void 0;\n    /** @internal */\n    this._callbackPluginEventFillRenderTargetTextures = () => void 0;\n    /**\n     * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.\n     */\n    this._forceAlphaTest = false;\n    /**\n     * The transparency mode of the material.\n     */\n    this._transparencyMode = null;\n    this.name = name;\n    const setScene = scene || EngineStore.LastCreatedScene;\n    if (!setScene) {\n      return;\n    }\n    this._scene = setScene;\n    this._dirtyCallbacks = {};\n    this._dirtyCallbacks[1] = this._markAllSubMeshesAsTexturesDirty.bind(this);\n    this._dirtyCallbacks[2] = this._markAllSubMeshesAsLightsDirty.bind(this);\n    this._dirtyCallbacks[4] = this._markAllSubMeshesAsFresnelDirty.bind(this);\n    this._dirtyCallbacks[8] = this._markAllSubMeshesAsAttributesDirty.bind(this);\n    this._dirtyCallbacks[16] = this._markAllSubMeshesAsMiscDirty.bind(this);\n    this._dirtyCallbacks[32] = this._markAllSubMeshesAsPrePassDirty.bind(this);\n    this._dirtyCallbacks[63] = this._markAllSubMeshesAsAllDirty.bind(this);\n    this.id = name || Tools.RandomId();\n    this.uniqueId = this._scene.getUniqueId();\n    this._materialContext = this._scene.getEngine().createMaterialContext();\n    this._drawWrapper = new DrawWrapper(this._scene.getEngine(), false);\n    this._drawWrapper.materialContext = this._materialContext;\n    if (this._scene.useRightHandedSystem) {\n      this.sideOrientation = Material.ClockWiseSideOrientation;\n    } else {\n      this.sideOrientation = Material.CounterClockWiseSideOrientation;\n    }\n    this._uniformBuffer = new UniformBuffer(this._scene.getEngine(), undefined, undefined, name);\n    this._useUBO = this.getScene().getEngine().supportsUniformBuffers;\n    if (!doNotAdd) {\n      this._scene.addMaterial(this);\n    }\n    if (this._scene.useMaterialMeshMap) {\n      this.meshMap = {};\n    }\n    Material.OnEventObservable.notifyObservers(this, MaterialPluginEvent.Created);\n  }\n  /**\n   * Returns a string representation of the current material\n   * @param fullDetails defines a boolean indicating which levels of logging is desired\n   * @returns a string with material information\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  toString(fullDetails) {\n    const ret = \"Name: \" + this.name;\n    return ret;\n  }\n  /**\n   * Gets the class name of the material\n   * @returns a string with the class name of the material\n   */\n  getClassName() {\n    return \"Material\";\n  }\n  /** @internal */\n  get _isMaterial() {\n    return true;\n  }\n  /**\n   * Specifies if updates for the material been locked\n   */\n  get isFrozen() {\n    return this.checkReadyOnlyOnce;\n  }\n  /**\n   * Locks updates for the material\n   */\n  freeze() {\n    this.markDirty();\n    this.checkReadyOnlyOnce = true;\n  }\n  /**\n   * Unlocks updates for the material\n   */\n  unfreeze() {\n    this.markDirty();\n    this.checkReadyOnlyOnce = false;\n  }\n  /**\n   * Specifies if the material is ready to be used\n   * @param mesh defines the mesh to check\n   * @param useInstances specifies if instances should be used\n   * @returns a boolean indicating if the material is ready to be used\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  isReady(mesh, useInstances) {\n    return true;\n  }\n  /**\n   * Specifies that the submesh is ready to be used\n   * @param mesh defines the mesh to check\n   * @param subMesh defines which submesh to check\n   * @param useInstances specifies that instances should be used\n   * @returns a boolean indicating that the submesh is ready or not\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  isReadyForSubMesh(mesh, subMesh, useInstances) {\n    const defines = subMesh.materialDefines;\n    if (!defines) {\n      return false;\n    }\n    this._eventInfo.isReadyForSubMesh = true;\n    this._eventInfo.defines = defines;\n    this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);\n    return this._eventInfo.isReadyForSubMesh;\n  }\n  /**\n   * Returns the material effect\n   * @returns the effect associated with the material\n   */\n  getEffect() {\n    return this._drawWrapper.effect;\n  }\n  /**\n   * Returns the current scene\n   * @returns a Scene\n   */\n  getScene() {\n    return this._scene;\n  }\n  /**\n   * Gets the current transparency mode.\n   */\n  get transparencyMode() {\n    return this._transparencyMode;\n  }\n  /**\n   * Sets the transparency mode of the material.\n   *\n   * | Value | Type                                | Description |\n   * | ----- | ----------------------------------- | ----------- |\n   * | 0     | OPAQUE                              |             |\n   * | 1     | ALPHATEST                           |             |\n   * | 2     | ALPHABLEND                          |             |\n   * | 3     | ALPHATESTANDBLEND                   |             |\n   *\n   */\n  set transparencyMode(value) {\n    if (this._transparencyMode === value) {\n      return;\n    }\n    this._transparencyMode = value;\n    this._forceAlphaTest = value === Material.MATERIAL_ALPHATESTANDBLEND;\n    this._markAllSubMeshesAsTexturesAndMiscDirty();\n  }\n  /**\n   * Returns true if alpha blending should be disabled.\n   */\n  get _disableAlphaBlending() {\n    return this._transparencyMode === Material.MATERIAL_OPAQUE || this._transparencyMode === Material.MATERIAL_ALPHATEST;\n  }\n  /**\n   * Specifies whether or not this material should be rendered in alpha blend mode.\n   * @returns a boolean specifying if alpha blending is needed\n   */\n  needAlphaBlending() {\n    if (this._disableAlphaBlending) {\n      return false;\n    }\n    return this.alpha < 1.0;\n  }\n  /**\n   * Specifies if the mesh will require alpha blending\n   * @param mesh defines the mesh to check\n   * @returns a boolean specifying if alpha blending is needed for the mesh\n   */\n  needAlphaBlendingForMesh(mesh) {\n    if (mesh.visibility < 1.0) {\n      return true;\n    }\n    if (this._disableAlphaBlending) {\n      return false;\n    }\n    return mesh.hasVertexAlpha || this.needAlphaBlending();\n  }\n  /**\n   * Specifies whether or not this material should be rendered in alpha test mode.\n   * @returns a boolean specifying if an alpha test is needed.\n   */\n  needAlphaTesting() {\n    if (this._forceAlphaTest) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Specifies if material alpha testing should be turned on for the mesh\n   * @param mesh defines the mesh to check\n   */\n  _shouldTurnAlphaTestOn(mesh) {\n    return !this.needAlphaBlendingForMesh(mesh) && this.needAlphaTesting();\n  }\n  /**\n   * Gets the texture used for the alpha test\n   * @returns the texture to use for alpha testing\n   */\n  getAlphaTestTexture() {\n    return null;\n  }\n  /**\n   * Marks the material to indicate that it needs to be re-calculated\n   * @param forceMaterialDirty - Forces the material to be marked as dirty for all components (same as this.markAsDirty(Material.AllDirtyFlag)). You should use this flag if the material is frozen and you want to force a recompilation.\n   */\n  markDirty(forceMaterialDirty = false) {\n    const meshes = this.getScene().meshes;\n    for (const mesh of meshes) {\n      if (!mesh.subMeshes) {\n        continue;\n      }\n      for (const subMesh of mesh.subMeshes) {\n        if (subMesh.getMaterial() !== this) {\n          continue;\n        }\n        if (!subMesh.effect) {\n          continue;\n        }\n        subMesh.effect._wasPreviouslyReady = false;\n        subMesh.effect._wasPreviouslyUsingInstances = null;\n        subMesh.effect._forceRebindOnNextCall = forceMaterialDirty;\n      }\n    }\n    if (forceMaterialDirty) {\n      this.markAsDirty(Material.AllDirtyFlag);\n    }\n  }\n  /**\n   * @internal\n   */\n  _preBind(effect, overrideOrientation = null) {\n    const engine = this._scene.getEngine();\n    const orientation = overrideOrientation == null ? this.sideOrientation : overrideOrientation;\n    const reverse = orientation === Material.ClockWiseSideOrientation;\n    engine.enableEffect(effect ? effect : this._getDrawWrapper());\n    engine.setState(this.backFaceCulling, this.zOffset, false, reverse, this._scene._mirroredCameraPosition ? !this.cullBackFaces : this.cullBackFaces, this.stencil, this.zOffsetUnits);\n    return reverse;\n  }\n  /**\n   * Binds the material to the mesh\n   * @param world defines the world transformation matrix\n   * @param mesh defines the mesh to bind the material to\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  bind(world, mesh) {}\n  /**\n   * Initializes the uniform buffer layout for the shader.\n   */\n  buildUniformLayout() {\n    const ubo = this._uniformBuffer;\n    this._eventInfo.ubo = ubo;\n    this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareUniformBuffer, this._eventInfo);\n    ubo.create();\n    this._uniformBufferLayoutBuilt = true;\n  }\n  /**\n   * Binds the submesh to the material\n   * @param world defines the world transformation matrix\n   * @param mesh defines the mesh containing the submesh\n   * @param subMesh defines the submesh to bind the material to\n   */\n  bindForSubMesh(world, mesh, subMesh) {\n    const effect = subMesh.effect;\n    if (!effect) {\n      return;\n    }\n    this._eventInfo.subMesh = subMesh;\n    this._callbackPluginEventBindForSubMesh(this._eventInfo);\n    effect._forceRebindOnNextCall = false;\n  }\n  /**\n   * Binds the world matrix to the material\n   * @param world defines the world transformation matrix\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  bindOnlyWorldMatrix(world) {}\n  /**\n   * Binds the view matrix to the effect\n   * @param effect defines the effect to bind the view matrix to\n   */\n  bindView(effect) {\n    if (!this._useUBO) {\n      effect.setMatrix(\"view\", this.getScene().getViewMatrix());\n    } else {\n      this._needToBindSceneUbo = true;\n    }\n  }\n  /**\n   * Binds the view projection and projection matrices to the effect\n   * @param effect defines the effect to bind the view projection and projection matrices to\n   */\n  bindViewProjection(effect) {\n    if (!this._useUBO) {\n      effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\n      effect.setMatrix(\"projection\", this.getScene().getProjectionMatrix());\n    } else {\n      this._needToBindSceneUbo = true;\n    }\n  }\n  /**\n   * Binds the view matrix to the effect\n   * @param effect defines the effect to bind the view matrix to\n   * @param variableName name of the shader variable that will hold the eye position\n   */\n  bindEyePosition(effect, variableName) {\n    if (!this._useUBO) {\n      this._scene.bindEyePosition(effect, variableName);\n    } else {\n      this._needToBindSceneUbo = true;\n    }\n  }\n  /**\n   * Processes to execute after binding the material to a mesh\n   * @param mesh defines the rendered mesh\n   * @param effect\n   */\n  _afterBind(mesh, effect = null) {\n    this._scene._cachedMaterial = this;\n    if (this._needToBindSceneUbo) {\n      if (effect) {\n        this._needToBindSceneUbo = false;\n        MaterialHelper.BindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());\n        this._scene.finalizeSceneUbo();\n      }\n    }\n    if (mesh) {\n      this._scene._cachedVisibility = mesh.visibility;\n    } else {\n      this._scene._cachedVisibility = 1;\n    }\n    if (this._onBindObservable && mesh) {\n      this._onBindObservable.notifyObservers(mesh);\n    }\n    if (this.disableDepthWrite) {\n      const engine = this._scene.getEngine();\n      this._cachedDepthWriteState = engine.getDepthWrite();\n      engine.setDepthWrite(false);\n    }\n    if (this.disableColorWrite) {\n      const engine = this._scene.getEngine();\n      this._cachedColorWriteState = engine.getColorWrite();\n      engine.setColorWrite(false);\n    }\n    if (this.depthFunction !== 0) {\n      const engine = this._scene.getEngine();\n      this._cachedDepthFunctionState = engine.getDepthFunction() || 0;\n      engine.setDepthFunction(this.depthFunction);\n    }\n  }\n  /**\n   * Unbinds the material from the mesh\n   */\n  unbind() {\n    if (this._onUnBindObservable) {\n      this._onUnBindObservable.notifyObservers(this);\n    }\n    if (this.depthFunction !== 0) {\n      const engine = this._scene.getEngine();\n      engine.setDepthFunction(this._cachedDepthFunctionState);\n    }\n    if (this.disableDepthWrite) {\n      const engine = this._scene.getEngine();\n      engine.setDepthWrite(this._cachedDepthWriteState);\n    }\n    if (this.disableColorWrite) {\n      const engine = this._scene.getEngine();\n      engine.setColorWrite(this._cachedColorWriteState);\n    }\n  }\n  /**\n   * Returns the animatable textures.\n   * @returns - Array of animatable textures.\n   */\n  getAnimatables() {\n    this._eventInfo.animatables = [];\n    this._callbackPluginEventGeneric(MaterialPluginEvent.GetAnimatables, this._eventInfo);\n    return this._eventInfo.animatables;\n  }\n  /**\n   * Gets the active textures from the material\n   * @returns an array of textures\n   */\n  getActiveTextures() {\n    this._eventInfo.activeTextures = [];\n    this._callbackPluginEventGeneric(MaterialPluginEvent.GetActiveTextures, this._eventInfo);\n    return this._eventInfo.activeTextures;\n  }\n  /**\n   * Specifies if the material uses a texture\n   * @param texture defines the texture to check against the material\n   * @returns a boolean specifying if the material uses the texture\n   */\n  hasTexture(texture) {\n    this._eventInfo.hasTexture = false;\n    this._eventInfo.texture = texture;\n    this._callbackPluginEventGeneric(MaterialPluginEvent.HasTexture, this._eventInfo);\n    return this._eventInfo.hasTexture;\n  }\n  /**\n   * Makes a duplicate of the material, and gives it a new name\n   * @param name defines the new name for the duplicated material\n   * @returns the cloned material\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  clone(name) {\n    return null;\n  }\n  _clonePlugins(targetMaterial, rootUrl) {\n    const serializationObject = {};\n    // Create plugins in targetMaterial in case they don't exist\n    this._serializePlugins(serializationObject);\n    Material._parsePlugins(serializationObject, targetMaterial, this._scene, rootUrl);\n    // Copy the properties of the current plugins to the cloned material's plugins\n    if (this.pluginManager) {\n      for (const plugin of this.pluginManager._plugins) {\n        const targetPlugin = targetMaterial.pluginManager.getPlugin(plugin.name);\n        plugin.copyTo(targetPlugin);\n      }\n    }\n  }\n  /**\n   * Gets the meshes bound to the material\n   * @returns an array of meshes bound to the material\n   */\n  getBindedMeshes() {\n    if (this.meshMap) {\n      const result = new Array();\n      for (const meshId in this.meshMap) {\n        const mesh = this.meshMap[meshId];\n        if (mesh) {\n          result.push(mesh);\n        }\n      }\n      return result;\n    } else {\n      const meshes = this._scene.meshes;\n      return meshes.filter(mesh => mesh.material === this);\n    }\n  }\n  /**\n   * Force shader compilation\n   * @param mesh defines the mesh associated with this material\n   * @param onCompiled defines a function to execute once the material is compiled\n   * @param options defines the options to configure the compilation\n   * @param onError defines a function to execute if the material fails compiling\n   */\n  forceCompilation(mesh, onCompiled, options, onError) {\n    const localOptions = Object.assign({\n      clipPlane: false,\n      useInstances: false\n    }, options);\n    const scene = this.getScene();\n    const currentHotSwapingState = this.allowShaderHotSwapping;\n    this.allowShaderHotSwapping = false; // Turned off to let us evaluate the real compilation state\n    const checkReady = () => {\n      if (!this._scene || !this._scene.getEngine()) {\n        return;\n      }\n      const clipPlaneState = scene.clipPlane;\n      if (localOptions.clipPlane) {\n        scene.clipPlane = new Plane(0, 0, 0, 1);\n      }\n      if (this._storeEffectOnSubMeshes) {\n        let allDone = true,\n          lastError = null;\n        if (mesh.subMeshes) {\n          const tempSubMesh = new SubMesh(0, 0, 0, 0, 0, mesh, undefined, false, false);\n          if (tempSubMesh.materialDefines) {\n            tempSubMesh.materialDefines._renderId = -1;\n          }\n          if (!this.isReadyForSubMesh(mesh, tempSubMesh, localOptions.useInstances)) {\n            if (tempSubMesh.effect && tempSubMesh.effect.getCompilationError() && tempSubMesh.effect.allFallbacksProcessed()) {\n              lastError = tempSubMesh.effect.getCompilationError();\n            } else {\n              allDone = false;\n              setTimeout(checkReady, 16);\n            }\n          }\n        }\n        if (allDone) {\n          this.allowShaderHotSwapping = currentHotSwapingState;\n          if (lastError) {\n            if (onError) {\n              onError(lastError);\n            }\n          }\n          if (onCompiled) {\n            onCompiled(this);\n          }\n        }\n      } else {\n        if (this.isReady()) {\n          this.allowShaderHotSwapping = currentHotSwapingState;\n          if (onCompiled) {\n            onCompiled(this);\n          }\n        } else {\n          setTimeout(checkReady, 16);\n        }\n      }\n      if (localOptions.clipPlane) {\n        scene.clipPlane = clipPlaneState;\n      }\n    };\n    checkReady();\n  }\n  /**\n   * Force shader compilation\n   * @param mesh defines the mesh that will use this material\n   * @param options defines additional options for compiling the shaders\n   * @returns a promise that resolves when the compilation completes\n   */\n  forceCompilationAsync(mesh, options) {\n    return new Promise((resolve, reject) => {\n      this.forceCompilation(mesh, () => {\n        resolve();\n      }, options, reason => {\n        reject(reason);\n      });\n    });\n  }\n  /**\n   * Marks a define in the material to indicate that it needs to be re-computed\n   * @param flag defines a flag used to determine which parts of the material have to be marked as dirty\n   */\n  markAsDirty(flag) {\n    if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {\n      return;\n    }\n    Material._DirtyCallbackArray.length = 0;\n    if (flag & Material.TextureDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._TextureDirtyCallBack);\n    }\n    if (flag & Material.LightDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._LightsDirtyCallBack);\n    }\n    if (flag & Material.FresnelDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._FresnelDirtyCallBack);\n    }\n    if (flag & Material.AttributesDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._AttributeDirtyCallBack);\n    }\n    if (flag & Material.MiscDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._MiscDirtyCallBack);\n    }\n    if (flag & Material.PrePassDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._PrePassDirtyCallBack);\n    }\n    if (Material._DirtyCallbackArray.length) {\n      this._markAllSubMeshesAsDirty(Material._RunDirtyCallBacks);\n    }\n    this.getScene().resetCachedMaterial();\n  }\n  /**\n   * Resets the draw wrappers cache for all submeshes that are using this material\n   */\n  resetDrawCache() {\n    const meshes = this.getScene().meshes;\n    for (const mesh of meshes) {\n      if (!mesh.subMeshes) {\n        continue;\n      }\n      for (const subMesh of mesh.subMeshes) {\n        if (subMesh.getMaterial() !== this) {\n          continue;\n        }\n        subMesh.resetDrawCache();\n      }\n    }\n  }\n  /**\n   * Marks all submeshes of a material to indicate that their material defines need to be re-calculated\n   * @param func defines a function which checks material defines against the submeshes\n   */\n  _markAllSubMeshesAsDirty(func) {\n    if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {\n      return;\n    }\n    const meshes = this.getScene().meshes;\n    for (const mesh of meshes) {\n      if (!mesh.subMeshes) {\n        continue;\n      }\n      for (const subMesh of mesh.subMeshes) {\n        // We want to skip the submeshes which are not using this material or which have not yet rendered at least once\n        if (subMesh.getMaterial(false) !== this) {\n          continue;\n        }\n        for (const drawWrapper of subMesh._drawWrappers) {\n          if (!drawWrapper || !drawWrapper.defines || !drawWrapper.defines.markAllAsDirty) {\n            continue;\n          }\n          if (this._materialContext === drawWrapper.materialContext) {\n            func(drawWrapper.defines);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Indicates that the scene should check if the rendering now needs a prepass\n   */\n  _markScenePrePassDirty() {\n    if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {\n      return;\n    }\n    const prePassRenderer = this.getScene().enablePrePassRenderer();\n    if (prePassRenderer) {\n      prePassRenderer.markAsDirty();\n    }\n  }\n  /**\n   * Indicates that we need to re-calculated for all submeshes\n   */\n  _markAllSubMeshesAsAllDirty() {\n    this._markAllSubMeshesAsDirty(Material._AllDirtyCallBack);\n  }\n  /**\n   * Indicates that image processing needs to be re-calculated for all submeshes\n   */\n  _markAllSubMeshesAsImageProcessingDirty() {\n    this._markAllSubMeshesAsDirty(Material._ImageProcessingDirtyCallBack);\n  }\n  /**\n   * Indicates that textures need to be re-calculated for all submeshes\n   */\n  _markAllSubMeshesAsTexturesDirty() {\n    this._markAllSubMeshesAsDirty(Material._TextureDirtyCallBack);\n  }\n  /**\n   * Indicates that fresnel needs to be re-calculated for all submeshes\n   */\n  _markAllSubMeshesAsFresnelDirty() {\n    this._markAllSubMeshesAsDirty(Material._FresnelDirtyCallBack);\n  }\n  /**\n   * Indicates that fresnel and misc need to be re-calculated for all submeshes\n   */\n  _markAllSubMeshesAsFresnelAndMiscDirty() {\n    this._markAllSubMeshesAsDirty(Material._FresnelAndMiscDirtyCallBack);\n  }\n  /**\n   * Indicates that lights need to be re-calculated for all submeshes\n   */\n  _markAllSubMeshesAsLightsDirty() {\n    this._markAllSubMeshesAsDirty(Material._LightsDirtyCallBack);\n  }\n  /**\n   * Indicates that attributes need to be re-calculated for all submeshes\n   */\n  _markAllSubMeshesAsAttributesDirty() {\n    this._markAllSubMeshesAsDirty(Material._AttributeDirtyCallBack);\n  }\n  /**\n   * Indicates that misc needs to be re-calculated for all submeshes\n   */\n  _markAllSubMeshesAsMiscDirty() {\n    this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);\n  }\n  /**\n   * Indicates that prepass needs to be re-calculated for all submeshes\n   */\n  _markAllSubMeshesAsPrePassDirty() {\n    this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);\n  }\n  /**\n   * Indicates that textures and misc need to be re-calculated for all submeshes\n   */\n  _markAllSubMeshesAsTexturesAndMiscDirty() {\n    this._markAllSubMeshesAsDirty(Material._TextureAndMiscDirtyCallBack);\n  }\n  _checkScenePerformancePriority() {\n    if (this._scene.performancePriority !== ScenePerformancePriority.BackwardCompatible) {\n      this.checkReadyOnlyOnce = true;\n      // re-set the flag when the perf priority changes\n      const observer = this._scene.onScenePerformancePriorityChangedObservable.addOnce(() => {\n        this.checkReadyOnlyOnce = false;\n      });\n      // if this material is disposed before the scene is disposed, cleanup the observer\n      this.onDisposeObservable.add(() => {\n        this._scene.onScenePerformancePriorityChangedObservable.remove(observer);\n      });\n    }\n  }\n  /**\n   * Sets the required values to the prepass renderer.\n   * @param prePassRenderer defines the prepass renderer to setup.\n   * @returns true if the pre pass is needed.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  setPrePassRenderer(prePassRenderer) {\n    // Do Nothing by default\n    return false;\n  }\n  /**\n   * Disposes the material\n   * @param forceDisposeEffect specifies if effects should be forcefully disposed\n   * @param forceDisposeTextures specifies if textures should be forcefully disposed\n   * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\n   */\n  dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {\n    const scene = this.getScene();\n    // Animations\n    scene.stopAnimation(this);\n    scene.freeProcessedMaterials();\n    // Remove from scene\n    scene.removeMaterial(this);\n    this._eventInfo.forceDisposeTextures = forceDisposeTextures;\n    this._callbackPluginEventGeneric(MaterialPluginEvent.Disposed, this._eventInfo);\n    if (this._parentContainer) {\n      const index = this._parentContainer.materials.indexOf(this);\n      if (index > -1) {\n        this._parentContainer.materials.splice(index, 1);\n      }\n      this._parentContainer = null;\n    }\n    if (notBoundToMesh !== true) {\n      // Remove from meshes\n      if (this.meshMap) {\n        for (const meshId in this.meshMap) {\n          const mesh = this.meshMap[meshId];\n          if (mesh) {\n            mesh.material = null; // will set the entry in the map to undefined\n            this.releaseVertexArrayObject(mesh, forceDisposeEffect);\n          }\n        }\n      } else {\n        const meshes = scene.meshes;\n        for (const mesh of meshes) {\n          if (mesh.material === this && !mesh.sourceMesh) {\n            mesh.material = null;\n            this.releaseVertexArrayObject(mesh, forceDisposeEffect);\n          }\n        }\n      }\n    }\n    this._uniformBuffer.dispose();\n    // Shader are kept in cache for further use but we can get rid of this by using forceDisposeEffect\n    if (forceDisposeEffect && this._drawWrapper.effect) {\n      if (!this._storeEffectOnSubMeshes) {\n        this._drawWrapper.effect.dispose();\n      }\n      this._drawWrapper.effect = null;\n    }\n    this.metadata = null;\n    // Callback\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    if (this._onBindObservable) {\n      this._onBindObservable.clear();\n    }\n    if (this._onUnBindObservable) {\n      this._onUnBindObservable.clear();\n    }\n    if (this._onEffectCreatedObservable) {\n      this._onEffectCreatedObservable.clear();\n    }\n    if (this._eventInfo) {\n      this._eventInfo = {};\n    }\n  }\n  /**\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  releaseVertexArrayObject(mesh, forceDisposeEffect) {\n    const geometry = mesh.geometry;\n    if (geometry) {\n      if (this._storeEffectOnSubMeshes) {\n        if (mesh.subMeshes) {\n          for (const subMesh of mesh.subMeshes) {\n            geometry._releaseVertexArrayObject(subMesh.effect);\n            if (forceDisposeEffect && subMesh.effect) {\n              subMesh.effect.dispose();\n            }\n          }\n        }\n      } else {\n        geometry._releaseVertexArrayObject(this._drawWrapper.effect);\n      }\n    }\n  }\n  /**\n   * Serializes this material\n   * @returns the serialized material object\n   */\n  serialize() {\n    const serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.stencil = this.stencil.serialize();\n    serializationObject.uniqueId = this.uniqueId;\n    this._serializePlugins(serializationObject);\n    return serializationObject;\n  }\n  _serializePlugins(serializationObject) {\n    serializationObject.plugins = {};\n    if (this.pluginManager) {\n      for (const plugin of this.pluginManager._plugins) {\n        serializationObject.plugins[plugin.getClassName()] = plugin.serialize();\n      }\n    }\n  }\n  /**\n   * Creates a material from parsed material data\n   * @param parsedMaterial defines parsed material data\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures\n   * @returns a new material\n   */\n  static Parse(parsedMaterial, scene, rootUrl) {\n    if (!parsedMaterial.customType) {\n      parsedMaterial.customType = \"BABYLON.StandardMaterial\";\n    } else if (parsedMaterial.customType === \"BABYLON.PBRMaterial\" && parsedMaterial.overloadedAlbedo) {\n      parsedMaterial.customType = \"BABYLON.LegacyPBRMaterial\";\n      if (!BABYLON.LegacyPBRMaterial) {\n        Logger.Error(\"Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library.\");\n        return null;\n      }\n    }\n    const materialType = Tools.Instantiate(parsedMaterial.customType);\n    const material = materialType.Parse(parsedMaterial, scene, rootUrl);\n    material._loadedUniqueId = parsedMaterial.uniqueId;\n    return material;\n  }\n  static _parsePlugins(serializationObject, material, scene, rootUrl) {\n    var _a;\n    if (!serializationObject.plugins) {\n      return;\n    }\n    for (const pluginClassName in serializationObject.plugins) {\n      const pluginData = serializationObject.plugins[pluginClassName];\n      let plugin = (_a = material.pluginManager) === null || _a === void 0 ? void 0 : _a.getPlugin(pluginData.name);\n      if (!plugin) {\n        const pluginClassType = Tools.Instantiate(\"BABYLON.\" + pluginClassName);\n        if (pluginClassType) {\n          plugin = new pluginClassType(material);\n        }\n      }\n      plugin === null || plugin === void 0 ? void 0 : plugin.parse(pluginData, scene, rootUrl);\n    }\n  }\n}\n/**\n * Returns the triangle fill mode\n */\nMaterial.TriangleFillMode = 0;\n/**\n * Returns the wireframe mode\n */\nMaterial.WireFrameFillMode = 1;\n/**\n * Returns the point fill mode\n */\nMaterial.PointFillMode = 2;\n/**\n * Returns the point list draw mode\n */\nMaterial.PointListDrawMode = 3;\n/**\n * Returns the line list draw mode\n */\nMaterial.LineListDrawMode = 4;\n/**\n * Returns the line loop draw mode\n */\nMaterial.LineLoopDrawMode = 5;\n/**\n * Returns the line strip draw mode\n */\nMaterial.LineStripDrawMode = 6;\n/**\n * Returns the triangle strip draw mode\n */\nMaterial.TriangleStripDrawMode = 7;\n/**\n * Returns the triangle fan draw mode\n */\nMaterial.TriangleFanDrawMode = 8;\n/**\n * Stores the clock-wise side orientation\n */\nMaterial.ClockWiseSideOrientation = 0;\n/**\n * Stores the counter clock-wise side orientation\n */\nMaterial.CounterClockWiseSideOrientation = 1;\n/**\n * The dirty texture flag value\n */\nMaterial.TextureDirtyFlag = 1;\n/**\n * The dirty light flag value\n */\nMaterial.LightDirtyFlag = 2;\n/**\n * The dirty fresnel flag value\n */\nMaterial.FresnelDirtyFlag = 4;\n/**\n * The dirty attribute flag value\n */\nMaterial.AttributesDirtyFlag = 8;\n/**\n * The dirty misc flag value\n */\nMaterial.MiscDirtyFlag = 16;\n/**\n * The dirty prepass flag value\n */\nMaterial.PrePassDirtyFlag = 32;\n/**\n * The all dirty flag value\n */\nMaterial.AllDirtyFlag = 63;\n/**\n * MaterialTransparencyMode: No transparency mode, Alpha channel is not use.\n */\nMaterial.MATERIAL_OPAQUE = 0;\n/**\n * MaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.\n */\nMaterial.MATERIAL_ALPHATEST = 1;\n/**\n * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\n */\nMaterial.MATERIAL_ALPHABLEND = 2;\n/**\n * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\n * They are also discarded below the alpha cutoff threshold to improve performances.\n */\nMaterial.MATERIAL_ALPHATESTANDBLEND = 3;\n/**\n * The Whiteout method is used to blend normals.\n * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\n */\nMaterial.MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0;\n/**\n * The Reoriented Normal Mapping method is used to blend normals.\n * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\n */\nMaterial.MATERIAL_NORMALBLENDMETHOD_RNM = 1;\n/**\n * Event observable which raises global events common to all materials (like MaterialPluginEvent.Created)\n */\nMaterial.OnEventObservable = new Observable();\nMaterial._AllDirtyCallBack = defines => defines.markAllAsDirty();\nMaterial._ImageProcessingDirtyCallBack = defines => defines.markAsImageProcessingDirty();\nMaterial._TextureDirtyCallBack = defines => defines.markAsTexturesDirty();\nMaterial._FresnelDirtyCallBack = defines => defines.markAsFresnelDirty();\nMaterial._MiscDirtyCallBack = defines => defines.markAsMiscDirty();\nMaterial._PrePassDirtyCallBack = defines => defines.markAsPrePassDirty();\nMaterial._LightsDirtyCallBack = defines => defines.markAsLightDirty();\nMaterial._AttributeDirtyCallBack = defines => defines.markAsAttributesDirty();\nMaterial._FresnelAndMiscDirtyCallBack = defines => {\n  Material._FresnelDirtyCallBack(defines);\n  Material._MiscDirtyCallBack(defines);\n};\nMaterial._TextureAndMiscDirtyCallBack = defines => {\n  Material._TextureDirtyCallBack(defines);\n  Material._MiscDirtyCallBack(defines);\n};\nMaterial._DirtyCallbackArray = [];\nMaterial._RunDirtyCallBacks = defines => {\n  for (const cb of Material._DirtyCallbackArray) {\n    cb(defines);\n  }\n};\n__decorate([serialize()], Material.prototype, \"id\", void 0);\n__decorate([serialize()], Material.prototype, \"uniqueId\", void 0);\n__decorate([serialize()], Material.prototype, \"name\", void 0);\n__decorate([serialize()], Material.prototype, \"metadata\", void 0);\n__decorate([serialize()], Material.prototype, \"checkReadyOnEveryCall\", void 0);\n__decorate([serialize()], Material.prototype, \"checkReadyOnlyOnce\", void 0);\n__decorate([serialize()], Material.prototype, \"state\", void 0);\n__decorate([serialize(\"alpha\")], Material.prototype, \"_alpha\", void 0);\n__decorate([serialize(\"backFaceCulling\")], Material.prototype, \"_backFaceCulling\", void 0);\n__decorate([serialize(\"cullBackFaces\")], Material.prototype, \"_cullBackFaces\", void 0);\n__decorate([serialize()], Material.prototype, \"sideOrientation\", void 0);\n__decorate([serialize(\"alphaMode\")], Material.prototype, \"_alphaMode\", void 0);\n__decorate([serialize()], Material.prototype, \"_needDepthPrePass\", void 0);\n__decorate([serialize()], Material.prototype, \"disableDepthWrite\", void 0);\n__decorate([serialize()], Material.prototype, \"disableColorWrite\", void 0);\n__decorate([serialize()], Material.prototype, \"forceDepthWrite\", void 0);\n__decorate([serialize()], Material.prototype, \"depthFunction\", void 0);\n__decorate([serialize()], Material.prototype, \"separateCullingPass\", void 0);\n__decorate([serialize(\"fogEnabled\")], Material.prototype, \"_fogEnabled\", void 0);\n__decorate([serialize()], Material.prototype, \"pointSize\", void 0);\n__decorate([serialize()], Material.prototype, \"zOffset\", void 0);\n__decorate([serialize()], Material.prototype, \"zOffsetUnits\", void 0);\n__decorate([serialize()], Material.prototype, \"pointsCloud\", null);\n__decorate([serialize()], Material.prototype, \"fillMode\", null);\n__decorate([serialize()], Material.prototype, \"transparencyMode\", null);","map":{"version":3,"names":["serialize","SerializationHelper","Tools","Observable","EngineStore","SubMesh","UniformBuffer","Logger","Plane","MaterialHelper","DrawWrapper","MaterialStencilState","ScenePerformancePriority","MaterialPluginEvent","Material","canRenderToMRT","alpha","value","_alpha","oldValue","markAsDirty","MiscDirtyFlag","PrePassDirtyFlag","backFaceCulling","_backFaceCulling","TextureDirtyFlag","cullBackFaces","_cullBackFaces","blockDirtyMechanism","_blockDirtyMechanism","markDirty","atomicMaterialsUpdate","callback","hasRenderTargetTextures","_eventInfo","_callbackPluginEventHasRenderTargetTextures","onDispose","_onDisposeObserver","onDisposeObservable","remove","add","onBindObservable","_onBindObservable","onBind","_onBindObserver","onUnBindObservable","_onUnBindObservable","onEffectCreatedObservable","_onEffectCreatedObservable","alphaMode","_alphaMode","needDepthPrePass","_needDepthPrePass","checkReadyOnEveryCall","isPrePassCapable","fogEnabled","_fogEnabled","wireframe","_fillMode","WireFrameFillMode","LineListDrawMode","LineLoopDrawMode","LineStripDrawMode","_scene","forceWireframe","fillMode","TriangleFillMode","pointsCloud","PointFillMode","PointListDrawMode","forcePointsCloud","_getDrawWrapper","_drawWrapper","_setDrawWrapper","drawWrapper","constructor","name","scene","doNotAdd","shadowDepthWrapper","allowShaderHotSwapping","metadata","reservedDataStore","checkReadyOnlyOnce","state","onCompiled","onError","getRenderTargetTextures","doNotSerialize","_storeEffectOnSubMeshes","animations","disableDepthWrite","disableColorWrite","forceDepthWrite","depthFunction","separateCullingPass","pointSize","zOffset","zOffsetUnits","stencil","_useUBO","_cachedDepthWriteState","_cachedColorWriteState","_cachedDepthFunctionState","_indexInSceneMaterialArray","meshMap","_parentContainer","_uniformBufferLayoutBuilt","_callbackPluginEventGeneric","_callbackPluginEventIsReadyForSubMesh","_callbackPluginEventPrepareDefines","_callbackPluginEventPrepareDefinesBeforeAttributes","_callbackPluginEventHardBindForSubMesh","_callbackPluginEventBindForSubMesh","_callbackPluginEventFillRenderTargetTextures","_forceAlphaTest","_transparencyMode","setScene","LastCreatedScene","_dirtyCallbacks","_markAllSubMeshesAsTexturesDirty","bind","_markAllSubMeshesAsLightsDirty","_markAllSubMeshesAsFresnelDirty","_markAllSubMeshesAsAttributesDirty","_markAllSubMeshesAsMiscDirty","_markAllSubMeshesAsPrePassDirty","_markAllSubMeshesAsAllDirty","id","RandomId","uniqueId","getUniqueId","_materialContext","getEngine","createMaterialContext","materialContext","useRightHandedSystem","sideOrientation","ClockWiseSideOrientation","CounterClockWiseSideOrientation","_uniformBuffer","undefined","getScene","supportsUniformBuffers","addMaterial","useMaterialMeshMap","OnEventObservable","notifyObservers","Created","toString","fullDetails","ret","getClassName","_isMaterial","isFrozen","freeze","unfreeze","isReady","mesh","useInstances","isReadyForSubMesh","subMesh","defines","materialDefines","getEffect","effect","transparencyMode","MATERIAL_ALPHATESTANDBLEND","_markAllSubMeshesAsTexturesAndMiscDirty","_disableAlphaBlending","MATERIAL_OPAQUE","MATERIAL_ALPHATEST","needAlphaBlending","needAlphaBlendingForMesh","visibility","hasVertexAlpha","needAlphaTesting","_shouldTurnAlphaTestOn","getAlphaTestTexture","forceMaterialDirty","meshes","subMeshes","getMaterial","_wasPreviouslyReady","_wasPreviouslyUsingInstances","_forceRebindOnNextCall","AllDirtyFlag","_preBind","overrideOrientation","engine","orientation","reverse","enableEffect","setState","_mirroredCameraPosition","world","buildUniformLayout","ubo","PrepareUniformBuffer","create","bindForSubMesh","bindOnlyWorldMatrix","bindView","setMatrix","getViewMatrix","_needToBindSceneUbo","bindViewProjection","getTransformMatrix","getProjectionMatrix","bindEyePosition","variableName","_afterBind","_cachedMaterial","BindSceneUniformBuffer","getSceneUniformBuffer","finalizeSceneUbo","_cachedVisibility","getDepthWrite","setDepthWrite","getColorWrite","setColorWrite","getDepthFunction","setDepthFunction","unbind","getAnimatables","animatables","GetAnimatables","getActiveTextures","activeTextures","GetActiveTextures","hasTexture","texture","HasTexture","clone","_clonePlugins","targetMaterial","rootUrl","serializationObject","_serializePlugins","_parsePlugins","pluginManager","plugin","_plugins","targetPlugin","getPlugin","copyTo","getBindedMeshes","result","Array","meshId","push","filter","material","forceCompilation","options","localOptions","Object","assign","clipPlane","currentHotSwapingState","checkReady","clipPlaneState","allDone","lastError","tempSubMesh","_renderId","getCompilationError","allFallbacksProcessed","setTimeout","forceCompilationAsync","Promise","resolve","reject","reason","flag","blockMaterialDirtyMechanism","_DirtyCallbackArray","length","_TextureDirtyCallBack","LightDirtyFlag","_LightsDirtyCallBack","FresnelDirtyFlag","_FresnelDirtyCallBack","AttributesDirtyFlag","_AttributeDirtyCallBack","_MiscDirtyCallBack","_PrePassDirtyCallBack","_markAllSubMeshesAsDirty","_RunDirtyCallBacks","resetCachedMaterial","resetDrawCache","func","_drawWrappers","markAllAsDirty","_markScenePrePassDirty","prePassRenderer","enablePrePassRenderer","_AllDirtyCallBack","_markAllSubMeshesAsImageProcessingDirty","_ImageProcessingDirtyCallBack","_markAllSubMeshesAsFresnelAndMiscDirty","_FresnelAndMiscDirtyCallBack","_TextureAndMiscDirtyCallBack","_checkScenePerformancePriority","performancePriority","BackwardCompatible","observer","onScenePerformancePriorityChangedObservable","addOnce","setPrePassRenderer","dispose","forceDisposeEffect","forceDisposeTextures","notBoundToMesh","stopAnimation","freeProcessedMaterials","removeMaterial","Disposed","index","materials","indexOf","splice","releaseVertexArrayObject","sourceMesh","clear","geometry","_releaseVertexArrayObject","Serialize","plugins","Parse","parsedMaterial","customType","overloadedAlbedo","BABYLON","LegacyPBRMaterial","Error","materialType","Instantiate","_loadedUniqueId","pluginClassName","pluginData","_a","pluginClassType","parse","TriangleStripDrawMode","TriangleFanDrawMode","MATERIAL_ALPHABLEND","MATERIAL_NORMALBLENDMETHOD_WHITEOUT","MATERIAL_NORMALBLENDMETHOD_RNM","markAsImageProcessingDirty","markAsTexturesDirty","markAsFresnelDirty","markAsMiscDirty","markAsPrePassDirty","markAsLightDirty","markAsAttributesDirty","cb","__decorate"],"sources":["../../../../dev/core/src/Materials/material.ts"],"sourcesContent":["import { serialize, SerializationHelper } from \"../Misc/decorators\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { Effect } from \"./effect\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { MaterialDefines } from \"./materialDefines\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { IInspectable } from \"../Misc/iInspectable\";\r\nimport { Plane } from \"../Maths/math.plane\";\r\nimport type { ShadowDepthWrapper } from \"./shadowDepthWrapper\";\r\nimport { MaterialHelper } from \"./materialHelper\";\r\nimport type { IMaterialContext } from \"../Engines/IMaterialContext\";\r\nimport { DrawWrapper } from \"./drawWrapper\";\r\nimport { MaterialStencilState } from \"./materialStencilState\";\r\nimport { ScenePerformancePriority } from \"../scene\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractScene } from \"../abstractScene\";\r\nimport type {\r\n    MaterialPluginDisposed,\r\n    MaterialPluginIsReadyForSubMesh,\r\n    MaterialPluginGetDefineNames,\r\n    MaterialPluginBindForSubMesh,\r\n    MaterialPluginGetActiveTextures,\r\n    MaterialPluginHasTexture,\r\n    MaterialPluginGetAnimatables,\r\n    MaterialPluginPrepareDefines,\r\n    MaterialPluginPrepareEffect,\r\n    MaterialPluginPrepareUniformBuffer,\r\n    MaterialPluginCreated,\r\n    MaterialPluginFillRenderTargetTextures,\r\n    MaterialPluginHasRenderTargetTextures,\r\n    MaterialPluginHardBindForSubMesh,\r\n} from \"./materialPluginEvent\";\r\nimport { MaterialPluginEvent } from \"./materialPluginEvent\";\r\nimport type { ShaderCustomProcessingFunction } from \"../Engines/Processors/shaderProcessingOptions\";\r\nimport type { IClipPlanesHolder } from \"../Misc/interfaces/iClipPlanesHolder\";\r\n\r\nimport type { PrePassRenderer } from \"../Rendering/prePassRenderer\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { Animation } from \"../Animations/animation\";\r\nimport type { InstancedMesh } from \"../Meshes/instancedMesh\";\r\n\r\ndeclare let BABYLON: any;\r\n\r\n/**\r\n * Options for compiling materials.\r\n */\r\nexport interface IMaterialCompilationOptions {\r\n    /**\r\n     * Defines whether clip planes are enabled.\r\n     */\r\n    clipPlane: boolean;\r\n\r\n    /**\r\n     * Defines whether instances are enabled.\r\n     */\r\n    useInstances: boolean;\r\n}\r\n\r\n/**\r\n * Options passed when calling customShaderNameResolve\r\n */\r\nexport interface ICustomShaderNameResolveOptions {\r\n    /**\r\n     * If provided, will be called two times with the vertex and fragment code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<ShaderCustomProcessingFunction>;\r\n}\r\n\r\n/**\r\n * Base class for the main features of a material in Babylon.js\r\n */\r\nexport class Material implements IAnimatable, IClipPlanesHolder {\r\n    /**\r\n     * Returns the triangle fill mode\r\n     */\r\n    public static readonly TriangleFillMode = Constants.MATERIAL_TriangleFillMode;\r\n    /**\r\n     * Returns the wireframe mode\r\n     */\r\n    public static readonly WireFrameFillMode = Constants.MATERIAL_WireFrameFillMode;\r\n    /**\r\n     * Returns the point fill mode\r\n     */\r\n    public static readonly PointFillMode = Constants.MATERIAL_PointFillMode;\r\n    /**\r\n     * Returns the point list draw mode\r\n     */\r\n    public static readonly PointListDrawMode = Constants.MATERIAL_PointListDrawMode;\r\n    /**\r\n     * Returns the line list draw mode\r\n     */\r\n    public static readonly LineListDrawMode = Constants.MATERIAL_LineListDrawMode;\r\n    /**\r\n     * Returns the line loop draw mode\r\n     */\r\n    public static readonly LineLoopDrawMode = Constants.MATERIAL_LineLoopDrawMode;\r\n    /**\r\n     * Returns the line strip draw mode\r\n     */\r\n    public static readonly LineStripDrawMode = Constants.MATERIAL_LineStripDrawMode;\r\n    /**\r\n     * Returns the triangle strip draw mode\r\n     */\r\n    public static readonly TriangleStripDrawMode = Constants.MATERIAL_TriangleStripDrawMode;\r\n    /**\r\n     * Returns the triangle fan draw mode\r\n     */\r\n    public static readonly TriangleFanDrawMode = Constants.MATERIAL_TriangleFanDrawMode;\r\n\r\n    /**\r\n     * Stores the clock-wise side orientation\r\n     */\r\n    public static readonly ClockWiseSideOrientation = Constants.MATERIAL_ClockWiseSideOrientation;\r\n\r\n    /**\r\n     * Stores the counter clock-wise side orientation\r\n     */\r\n    public static readonly CounterClockWiseSideOrientation = Constants.MATERIAL_CounterClockWiseSideOrientation;\r\n\r\n    /**\r\n     * The dirty texture flag value\r\n     */\r\n    public static readonly TextureDirtyFlag = Constants.MATERIAL_TextureDirtyFlag;\r\n\r\n    /**\r\n     * The dirty light flag value\r\n     */\r\n    public static readonly LightDirtyFlag = Constants.MATERIAL_LightDirtyFlag;\r\n\r\n    /**\r\n     * The dirty fresnel flag value\r\n     */\r\n    public static readonly FresnelDirtyFlag = Constants.MATERIAL_FresnelDirtyFlag;\r\n\r\n    /**\r\n     * The dirty attribute flag value\r\n     */\r\n    public static readonly AttributesDirtyFlag = Constants.MATERIAL_AttributesDirtyFlag;\r\n\r\n    /**\r\n     * The dirty misc flag value\r\n     */\r\n    public static readonly MiscDirtyFlag = Constants.MATERIAL_MiscDirtyFlag;\r\n\r\n    /**\r\n     * The dirty prepass flag value\r\n     */\r\n    public static readonly PrePassDirtyFlag = Constants.MATERIAL_PrePassDirtyFlag;\r\n\r\n    /**\r\n     * The all dirty flag value\r\n     */\r\n    public static readonly AllDirtyFlag = Constants.MATERIAL_AllDirtyFlag;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: No transparency mode, Alpha channel is not use.\r\n     */\r\n    public static readonly MATERIAL_OPAQUE = 0;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.\r\n     */\r\n    public static readonly MATERIAL_ALPHATEST = 1;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     */\r\n    public static readonly MATERIAL_ALPHABLEND = 2;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     * They are also discarded below the alpha cutoff threshold to improve performances.\r\n     */\r\n    public static readonly MATERIAL_ALPHATESTANDBLEND = 3;\r\n\r\n    /**\r\n     * The Whiteout method is used to blend normals.\r\n     * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\r\n     */\r\n    public static readonly MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0;\r\n\r\n    /**\r\n     * The Reoriented Normal Mapping method is used to blend normals.\r\n     * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\r\n     */\r\n    public static readonly MATERIAL_NORMALBLENDMETHOD_RNM = 1;\r\n\r\n    /**\r\n     * Event observable which raises global events common to all materials (like MaterialPluginEvent.Created)\r\n     */\r\n    public static OnEventObservable = new Observable<Material>();\r\n\r\n    /**\r\n     * Custom callback helping to override the default shader used in the material.\r\n     */\r\n    public customShaderNameResolve: (\r\n        shaderName: string,\r\n        uniforms: string[],\r\n        uniformBuffers: string[],\r\n        samplers: string[],\r\n        defines: MaterialDefines | string[],\r\n        attributes?: string[],\r\n        options?: ICustomShaderNameResolveOptions\r\n    ) => string;\r\n\r\n    /**\r\n     * Custom shadow depth material to use for shadow rendering instead of the in-built one\r\n     */\r\n    public shadowDepthWrapper: Nullable<ShadowDepthWrapper> = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the material is allowed (if supported) to do shader hot swapping.\r\n     * This means that the material can keep using a previous shader while a new one is being compiled.\r\n     * This is mostly used when shader parallel compilation is supported (true by default)\r\n     */\r\n    public allowShaderHotSwapping = true;\r\n\r\n    /**\r\n     * The ID of the material\r\n     */\r\n    @serialize()\r\n    public id: string;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the material\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /** @internal */\r\n    public _loadedUniqueId: string;\r\n\r\n    /**\r\n     * The name of the material\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets user defined metadata\r\n     */\r\n    @serialize()\r\n    public metadata: any = null;\r\n\r\n    /** @internal */\r\n    public _internalMetadata: any;\r\n\r\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\r\n    public reservedDataStore: any = null;\r\n\r\n    /**\r\n     * Specifies if the ready state should be checked on each call\r\n     */\r\n    @serialize()\r\n    public checkReadyOnEveryCall = false;\r\n\r\n    /**\r\n     * Specifies if the ready state should be checked once\r\n     */\r\n    @serialize()\r\n    public checkReadyOnlyOnce = false;\r\n\r\n    /**\r\n     * The state of the material\r\n     */\r\n    @serialize()\r\n    public state = \"\";\r\n\r\n    /**\r\n     * If the material can be rendered to several textures with MRT extension\r\n     */\r\n    public get canRenderToMRT(): boolean {\r\n        // By default, shaders are not compatible with MRTs\r\n        // Base classes should override that if their shader supports MRT\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * The alpha value of the material\r\n     */\r\n    @serialize(\"alpha\")\r\n    protected _alpha = 1.0;\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/toolsAndResources/inspector#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    /**\r\n     * Sets the alpha value of the material\r\n     */\r\n    public set alpha(value: number) {\r\n        if (this._alpha === value) {\r\n            return;\r\n        }\r\n\r\n        const oldValue = this._alpha;\r\n        this._alpha = value;\r\n\r\n        // Only call dirty when there is a state change (no alpha / alpha)\r\n        if (oldValue === 1 || value === 1) {\r\n            this.markAsDirty(Material.MiscDirtyFlag + Material.PrePassDirtyFlag);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the alpha value of the material\r\n     */\r\n    public get alpha(): number {\r\n        return this._alpha;\r\n    }\r\n\r\n    /**\r\n     * Specifies if back face culling is enabled\r\n     */\r\n    @serialize(\"backFaceCulling\")\r\n    protected _backFaceCulling = true;\r\n\r\n    /**\r\n     * Sets the culling state (true to enable culling, false to disable)\r\n     */\r\n    public set backFaceCulling(value: boolean) {\r\n        if (this._backFaceCulling === value) {\r\n            return;\r\n        }\r\n        this._backFaceCulling = value;\r\n        this.markAsDirty(Material.TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the culling state\r\n     */\r\n    public get backFaceCulling(): boolean {\r\n        return this._backFaceCulling;\r\n    }\r\n\r\n    /**\r\n     * Specifies if back or front faces should be culled (when culling is enabled)\r\n     */\r\n    @serialize(\"cullBackFaces\")\r\n    protected _cullBackFaces = true;\r\n\r\n    /**\r\n     * Sets the type of faces that should be culled (true for back faces, false for front faces)\r\n     */\r\n    public set cullBackFaces(value: boolean) {\r\n        if (this._cullBackFaces === value) {\r\n            return;\r\n        }\r\n        this._cullBackFaces = value;\r\n        this.markAsDirty(Material.TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the type of faces that should be culled\r\n     */\r\n    public get cullBackFaces(): boolean {\r\n        return this._cullBackFaces;\r\n    }\r\n\r\n    private _blockDirtyMechanism = false;\r\n\r\n    /**\r\n     * Block the dirty-mechanism for this specific material\r\n     * When set to false after being true the material will be marked as dirty.\r\n     */\r\n    public get blockDirtyMechanism(): boolean {\r\n        return this._blockDirtyMechanism;\r\n    }\r\n\r\n    public set blockDirtyMechanism(value: boolean) {\r\n        if (this._blockDirtyMechanism === value) {\r\n            return;\r\n        }\r\n\r\n        this._blockDirtyMechanism = value;\r\n\r\n        if (!value) {\r\n            this.markDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This allows you to modify the material without marking it as dirty after every change.\r\n     * This function should be used if you need to make more than one dirty-enabling change to the material - adding a texture, setting a new fill mode and so on.\r\n     * The callback will pass the material as an argument, so you can make your changes to it.\r\n     * @param callback the callback to be executed that will update the material\r\n     */\r\n    public atomicMaterialsUpdate(callback: (material: this) => void): void {\r\n        this.blockDirtyMechanism = true;\r\n        try {\r\n            callback(this);\r\n        } finally {\r\n            this.blockDirtyMechanism = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stores the value for side orientation\r\n     */\r\n    @serialize()\r\n    public sideOrientation: number;\r\n\r\n    /**\r\n     * Callback triggered when the material is compiled\r\n     */\r\n    public onCompiled: Nullable<(effect: Effect) => void> = null;\r\n\r\n    /**\r\n     * Callback triggered when an error occurs\r\n     */\r\n    public onError: Nullable<(effect: Effect, errors: string) => void> = null;\r\n\r\n    /**\r\n     * Callback triggered to get the render target textures\r\n     */\r\n    public getRenderTargetTextures: Nullable<() => SmartArray<RenderTargetTexture>> = null;\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\r\n    public get hasRenderTargetTextures(): boolean {\r\n        this._eventInfo.hasRenderTargetTextures = false;\r\n        this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);\r\n        return this._eventInfo.hasRenderTargetTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material should be serialized\r\n     */\r\n    public doNotSerialize = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _storeEffectOnSubMeshes = false;\r\n\r\n    /**\r\n     * Stores the animations for the material\r\n     */\r\n    public animations: Nullable<Array<Animation>> = null;\r\n\r\n    /**\r\n     * An event triggered when the material is disposed\r\n     */\r\n    public onDisposeObservable = new Observable<Material>();\r\n\r\n    /**\r\n     * An observer which watches for dispose events\r\n     */\r\n    private _onDisposeObserver: Nullable<Observer<Material>> = null;\r\n    private _onUnBindObservable: Nullable<Observable<Material>> = null;\r\n\r\n    /**\r\n     * Called during a dispose event\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    private _onBindObservable: Nullable<Observable<AbstractMesh>>;\r\n\r\n    /**\r\n     * An event triggered when the material is bound\r\n     */\r\n    public get onBindObservable(): Observable<AbstractMesh> {\r\n        if (!this._onBindObservable) {\r\n            this._onBindObservable = new Observable<AbstractMesh>();\r\n        }\r\n\r\n        return this._onBindObservable;\r\n    }\r\n\r\n    /**\r\n     * An observer which watches for bind events\r\n     */\r\n    private _onBindObserver: Nullable<Observer<AbstractMesh>> = null;\r\n\r\n    /**\r\n     * Called during a bind event\r\n     */\r\n    public set onBind(callback: (Mesh: AbstractMesh) => void) {\r\n        if (this._onBindObserver) {\r\n            this.onBindObservable.remove(this._onBindObserver);\r\n        }\r\n        this._onBindObserver = this.onBindObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the material is unbound\r\n     */\r\n    public get onUnBindObservable(): Observable<Material> {\r\n        if (!this._onUnBindObservable) {\r\n            this._onUnBindObservable = new Observable<Material>();\r\n        }\r\n\r\n        return this._onUnBindObservable;\r\n    }\r\n\r\n    protected _onEffectCreatedObservable: Nullable<Observable<{ effect: Effect; subMesh: Nullable<SubMesh> }>>;\r\n\r\n    /**\r\n     * An event triggered when the effect is (re)created\r\n     */\r\n    public get onEffectCreatedObservable(): Observable<{ effect: Effect; subMesh: Nullable<SubMesh> }> {\r\n        if (!this._onEffectCreatedObservable) {\r\n            this._onEffectCreatedObservable = new Observable<{ effect: Effect; subMesh: Nullable<SubMesh> }>();\r\n        }\r\n\r\n        return this._onEffectCreatedObservable;\r\n    }\r\n\r\n    /**\r\n     * Stores the value of the alpha mode\r\n     */\r\n    @serialize(\"alphaMode\")\r\n    private _alphaMode: number = Constants.ALPHA_COMBINE;\r\n\r\n    /**\r\n     * Sets the value of the alpha mode.\r\n     *\r\n     * | Value | Type | Description |\r\n     * | --- | --- | --- |\r\n     * | 0 | ALPHA_DISABLE |   |\r\n     * | 1 | ALPHA_ADD |   |\r\n     * | 2 | ALPHA_COMBINE |   |\r\n     * | 3 | ALPHA_SUBTRACT |   |\r\n     * | 4 | ALPHA_MULTIPLY |   |\r\n     * | 5 | ALPHA_MAXIMIZED |   |\r\n     * | 6 | ALPHA_ONEONE |   |\r\n     * | 7 | ALPHA_PREMULTIPLIED |   |\r\n     * | 8 | ALPHA_PREMULTIPLIED_PORTERDUFF |   |\r\n     * | 9 | ALPHA_INTERPOLATE |   |\r\n     * | 10 | ALPHA_SCREENMODE |   |\r\n     *\r\n     */\r\n    public set alphaMode(value: number) {\r\n        if (this._alphaMode === value) {\r\n            return;\r\n        }\r\n        this._alphaMode = value;\r\n        this.markAsDirty(Material.TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the alpha mode\r\n     */\r\n    public get alphaMode(): number {\r\n        return this._alphaMode;\r\n    }\r\n\r\n    /**\r\n     * Stores the state of the need depth pre-pass value\r\n     */\r\n    @serialize()\r\n    private _needDepthPrePass = false;\r\n\r\n    /**\r\n     * Sets the need depth pre-pass value\r\n     */\r\n    public set needDepthPrePass(value: boolean) {\r\n        if (this._needDepthPrePass === value) {\r\n            return;\r\n        }\r\n        this._needDepthPrePass = value;\r\n        if (this._needDepthPrePass) {\r\n            this.checkReadyOnEveryCall = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the depth pre-pass value\r\n     */\r\n    public get needDepthPrePass(): boolean {\r\n        return this._needDepthPrePass;\r\n    }\r\n\r\n    /**\r\n     * Can this material render to prepass\r\n     */\r\n    public get isPrePassCapable(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if depth writing should be disabled\r\n     */\r\n    @serialize()\r\n    public disableDepthWrite = false;\r\n\r\n    /**\r\n     * Specifies if color writing should be disabled\r\n     */\r\n    @serialize()\r\n    public disableColorWrite = false;\r\n\r\n    /**\r\n     * Specifies if depth writing should be forced\r\n     */\r\n    @serialize()\r\n    public forceDepthWrite = false;\r\n\r\n    /**\r\n     * Specifies the depth function that should be used. 0 means the default engine function\r\n     */\r\n    @serialize()\r\n    public depthFunction = 0;\r\n\r\n    /**\r\n     * Specifies if there should be a separate pass for culling\r\n     */\r\n    @serialize()\r\n    public separateCullingPass = false;\r\n\r\n    /**\r\n     * Stores the state specifying if fog should be enabled\r\n     */\r\n    @serialize(\"fogEnabled\")\r\n    private _fogEnabled = true;\r\n\r\n    /**\r\n     * Sets the state for enabling fog\r\n     */\r\n    public set fogEnabled(value: boolean) {\r\n        if (this._fogEnabled === value) {\r\n            return;\r\n        }\r\n        this._fogEnabled = value;\r\n        this.markAsDirty(Material.MiscDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the fog enabled state\r\n     */\r\n    public get fogEnabled(): boolean {\r\n        return this._fogEnabled;\r\n    }\r\n\r\n    /**\r\n     * Stores the size of points\r\n     */\r\n    @serialize()\r\n    public pointSize = 1.0;\r\n\r\n    /**\r\n     * Stores the z offset Factor value\r\n     */\r\n    @serialize()\r\n    public zOffset = 0;\r\n\r\n    /**\r\n     * Stores the z offset Units value\r\n     */\r\n    @serialize()\r\n    public zOffsetUnits = 0;\r\n\r\n    public get wireframe(): boolean {\r\n        switch (this._fillMode) {\r\n            case Material.WireFrameFillMode:\r\n            case Material.LineListDrawMode:\r\n            case Material.LineLoopDrawMode:\r\n            case Material.LineStripDrawMode:\r\n                return true;\r\n        }\r\n\r\n        return this._scene.forceWireframe;\r\n    }\r\n\r\n    /**\r\n     * Sets the state of wireframe mode\r\n     */\r\n    public set wireframe(value: boolean) {\r\n        this.fillMode = value ? Material.WireFrameFillMode : Material.TriangleFillMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the value specifying if point clouds are enabled\r\n     */\r\n    @serialize()\r\n    public get pointsCloud(): boolean {\r\n        switch (this._fillMode) {\r\n            case Material.PointFillMode:\r\n            case Material.PointListDrawMode:\r\n                return true;\r\n        }\r\n\r\n        return this._scene.forcePointsCloud;\r\n    }\r\n\r\n    /**\r\n     * Sets the state of point cloud mode\r\n     */\r\n    public set pointsCloud(value: boolean) {\r\n        this.fillMode = value ? Material.PointFillMode : Material.TriangleFillMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the material fill mode\r\n     */\r\n    @serialize()\r\n    public get fillMode(): number {\r\n        return this._fillMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the material fill mode\r\n     */\r\n    public set fillMode(value: number) {\r\n        if (this._fillMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._fillMode = value;\r\n        this.markAsDirty(Material.MiscDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 1\r\n     */\r\n    public clipPlane: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 2\r\n     */\r\n    public clipPlane2: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 3\r\n     */\r\n    public clipPlane3: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 4\r\n     */\r\n    public clipPlane4: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 5\r\n     */\r\n    public clipPlane5: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 6\r\n     */\r\n    public clipPlane6: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gives access to the stencil properties of the material\r\n     */\r\n    public readonly stencil = new MaterialStencilState();\r\n\r\n    /**\r\n     * @internal\r\n     * Stores the effects for the material\r\n     */\r\n    protected _materialContext: IMaterialContext | undefined;\r\n\r\n    protected _drawWrapper: DrawWrapper;\r\n    /** @internal */\r\n    public _getDrawWrapper(): DrawWrapper {\r\n        return this._drawWrapper;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setDrawWrapper(drawWrapper: DrawWrapper) {\r\n        this._drawWrapper = drawWrapper;\r\n    }\r\n\r\n    /**\r\n     * Specifies if uniform buffers should be used\r\n     */\r\n    private _useUBO: boolean = false;\r\n\r\n    /**\r\n     * Stores a reference to the scene\r\n     */\r\n    private _scene: Scene;\r\n    protected _needToBindSceneUbo: boolean;\r\n\r\n    /**\r\n     * Stores the fill mode state\r\n     */\r\n    private _fillMode = Material.TriangleFillMode;\r\n\r\n    /**\r\n     * Specifies if the depth write state should be cached\r\n     */\r\n    private _cachedDepthWriteState: boolean = false;\r\n\r\n    /**\r\n     * Specifies if the color write state should be cached\r\n     */\r\n    private _cachedColorWriteState: boolean = false;\r\n\r\n    /**\r\n     * Specifies if the depth function state should be cached\r\n     */\r\n    private _cachedDepthFunctionState: number = 0;\r\n\r\n    /**\r\n     * Stores the uniform buffer\r\n     * @internal\r\n     */\r\n    public _uniformBuffer: UniformBuffer;\r\n\r\n    /** @internal */\r\n    public _indexInSceneMaterialArray = -1;\r\n\r\n    /** @internal */\r\n    public meshMap: Nullable<{ [id: string]: AbstractMesh | undefined }> = null;\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    /** @internal */\r\n    public _dirtyCallbacks: { [code: number]: () => void };\r\n\r\n    /** @internal */\r\n    public _uniformBufferLayoutBuilt = false;\r\n\r\n    protected _eventInfo: MaterialPluginCreated &\r\n        MaterialPluginDisposed &\r\n        MaterialPluginHasTexture &\r\n        MaterialPluginIsReadyForSubMesh &\r\n        MaterialPluginGetDefineNames &\r\n        MaterialPluginPrepareEffect &\r\n        MaterialPluginPrepareDefines &\r\n        MaterialPluginPrepareUniformBuffer &\r\n        MaterialPluginBindForSubMesh &\r\n        MaterialPluginGetAnimatables &\r\n        MaterialPluginGetActiveTextures &\r\n        MaterialPluginFillRenderTargetTextures &\r\n        MaterialPluginHasRenderTargetTextures &\r\n        MaterialPluginHardBindForSubMesh = {} as any; // will be initialized before each event notification\r\n\r\n    /** @internal */\r\n    public _callbackPluginEventGeneric: (\r\n        id: number,\r\n        info:\r\n            | MaterialPluginGetActiveTextures\r\n            | MaterialPluginGetAnimatables\r\n            | MaterialPluginHasTexture\r\n            | MaterialPluginDisposed\r\n            | MaterialPluginGetDefineNames\r\n            | MaterialPluginPrepareEffect\r\n            | MaterialPluginPrepareUniformBuffer\r\n    ) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventIsReadyForSubMesh: (eventData: MaterialPluginIsReadyForSubMesh) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventPrepareDefines: (eventData: MaterialPluginPrepareDefines) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventPrepareDefinesBeforeAttributes: (eventData: MaterialPluginPrepareDefines) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventHardBindForSubMesh: (eventData: MaterialPluginHardBindForSubMesh) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventBindForSubMesh: (eventData: MaterialPluginBindForSubMesh) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventHasRenderTargetTextures: (eventData: MaterialPluginHasRenderTargetTextures) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventFillRenderTargetTextures: (eventData: MaterialPluginFillRenderTargetTextures) => void = () => void 0;\r\n\r\n    /**\r\n     * Creates a material instance\r\n     * @param name defines the name of the material\r\n     * @param scene defines the scene to reference\r\n     * @param doNotAdd specifies if the material should be added to the scene\r\n     */\r\n    constructor(name: string, scene?: Nullable<Scene>, doNotAdd?: boolean) {\r\n        this.name = name;\r\n        const setScene = scene || EngineStore.LastCreatedScene;\r\n        if (!setScene) {\r\n            return;\r\n        }\r\n        this._scene = setScene;\r\n        this._dirtyCallbacks = {};\r\n\r\n        this._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag] = this._markAllSubMeshesAsTexturesDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_LightDirtyFlag] = this._markAllSubMeshesAsLightsDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_FresnelDirtyFlag] = this._markAllSubMeshesAsFresnelDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_AttributesDirtyFlag] = this._markAllSubMeshesAsAttributesDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_MiscDirtyFlag] = this._markAllSubMeshesAsMiscDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_PrePassDirtyFlag] = this._markAllSubMeshesAsPrePassDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_AllDirtyFlag] = this._markAllSubMeshesAsAllDirty.bind(this);\r\n\r\n        this.id = name || Tools.RandomId();\r\n        this.uniqueId = this._scene.getUniqueId();\r\n        this._materialContext = this._scene.getEngine().createMaterialContext();\r\n        this._drawWrapper = new DrawWrapper(this._scene.getEngine(), false);\r\n        this._drawWrapper.materialContext = this._materialContext;\r\n\r\n        if (this._scene.useRightHandedSystem) {\r\n            this.sideOrientation = Material.ClockWiseSideOrientation;\r\n        } else {\r\n            this.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n        }\r\n\r\n        this._uniformBuffer = new UniformBuffer(this._scene.getEngine(), undefined, undefined, name);\r\n        this._useUBO = this.getScene().getEngine().supportsUniformBuffers;\r\n\r\n        if (!doNotAdd) {\r\n            this._scene.addMaterial(this);\r\n        }\r\n\r\n        if (this._scene.useMaterialMeshMap) {\r\n            this.meshMap = {};\r\n        }\r\n\r\n        Material.OnEventObservable.notifyObservers(this, MaterialPluginEvent.Created);\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of the current material\r\n     * @param fullDetails defines a boolean indicating which levels of logging is desired\r\n     * @returns a string with material information\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public toString(fullDetails?: boolean): string {\r\n        const ret = \"Name: \" + this.name;\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the material\r\n     * @returns a string with the class name of the material\r\n     */\r\n    public getClassName(): string {\r\n        return \"Material\";\r\n    }\r\n\r\n    /** @internal */\r\n    public get _isMaterial() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Specifies if updates for the material been locked\r\n     */\r\n    public get isFrozen(): boolean {\r\n        return this.checkReadyOnlyOnce;\r\n    }\r\n\r\n    /**\r\n     * Locks updates for the material\r\n     */\r\n    public freeze(): void {\r\n        this.markDirty();\r\n        this.checkReadyOnlyOnce = true;\r\n    }\r\n\r\n    /**\r\n     * Unlocks updates for the material\r\n     */\r\n    public unfreeze(): void {\r\n        this.markDirty();\r\n        this.checkReadyOnlyOnce = false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param useInstances specifies if instances should be used\r\n     * @returns a boolean indicating if the material is ready to be used\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isReady(mesh?: AbstractMesh, useInstances?: boolean): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const defines = subMesh.materialDefines;\r\n        if (!defines) {\r\n            return false;\r\n        }\r\n\r\n        this._eventInfo.isReadyForSubMesh = true;\r\n        this._eventInfo.defines = defines;\r\n        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);\r\n\r\n        return this._eventInfo.isReadyForSubMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the material effect\r\n     * @returns the effect associated with the material\r\n     */\r\n    public getEffect(): Nullable<Effect> {\r\n        return this._drawWrapper.effect;\r\n    }\r\n\r\n    /**\r\n     * Returns the current scene\r\n     * @returns a Scene\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.\r\n     */\r\n    protected _forceAlphaTest = false;\r\n\r\n    /**\r\n     * The transparency mode of the material.\r\n     */\r\n    protected _transparencyMode: Nullable<number> = null;\r\n\r\n    /**\r\n     * Gets the current transparency mode.\r\n     */\r\n    @serialize()\r\n    public get transparencyMode(): Nullable<number> {\r\n        return this._transparencyMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the transparency mode of the material.\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 0     | OPAQUE                              |             |\r\n     * | 1     | ALPHATEST                           |             |\r\n     * | 2     | ALPHABLEND                          |             |\r\n     * | 3     | ALPHATESTANDBLEND                   |             |\r\n     *\r\n     */\r\n    public set transparencyMode(value: Nullable<number>) {\r\n        if (this._transparencyMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._transparencyMode = value;\r\n\r\n        this._forceAlphaTest = value === Material.MATERIAL_ALPHATESTANDBLEND;\r\n\r\n        this._markAllSubMeshesAsTexturesAndMiscDirty();\r\n    }\r\n\r\n    /**\r\n     * Returns true if alpha blending should be disabled.\r\n     */\r\n    protected get _disableAlphaBlending(): boolean {\r\n        return this._transparencyMode === Material.MATERIAL_OPAQUE || this._transparencyMode === Material.MATERIAL_ALPHATEST;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha blend mode.\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        if (this._disableAlphaBlending) {\r\n            return false;\r\n        }\r\n\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the mesh will require alpha blending\r\n     * @param mesh defines the mesh to check\r\n     * @returns a boolean specifying if alpha blending is needed for the mesh\r\n     */\r\n    public needAlphaBlendingForMesh(mesh: AbstractMesh): boolean {\r\n        if (mesh.visibility < 1.0) {\r\n            return true;\r\n        }\r\n\r\n        if (this._disableAlphaBlending) {\r\n            return false;\r\n        }\r\n\r\n        return mesh.hasVertexAlpha || this.needAlphaBlending();\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha test mode.\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        if (this._forceAlphaTest) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if material alpha testing should be turned on for the mesh\r\n     * @param mesh defines the mesh to check\r\n     */\r\n    protected _shouldTurnAlphaTestOn(mesh: AbstractMesh): boolean {\r\n        return !this.needAlphaBlendingForMesh(mesh) && this.needAlphaTesting();\r\n    }\r\n\r\n    /**\r\n     * Gets the texture used for the alpha test\r\n     * @returns the texture to use for alpha testing\r\n     */\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Marks the material to indicate that it needs to be re-calculated\r\n     * @param forceMaterialDirty - Forces the material to be marked as dirty for all components (same as this.markAsDirty(Material.AllDirtyFlag)). You should use this flag if the material is frozen and you want to force a recompilation.\r\n     */\r\n    public markDirty(forceMaterialDirty = false): void {\r\n        const meshes = this.getScene().meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (subMesh.getMaterial() !== this) {\r\n                    continue;\r\n                }\r\n\r\n                if (!subMesh.effect) {\r\n                    continue;\r\n                }\r\n\r\n                subMesh.effect._wasPreviouslyReady = false;\r\n                subMesh.effect._wasPreviouslyUsingInstances = null;\r\n                subMesh.effect._forceRebindOnNextCall = forceMaterialDirty;\r\n            }\r\n        }\r\n\r\n        if (forceMaterialDirty) {\r\n            this.markAsDirty(Material.AllDirtyFlag);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _preBind(effect?: Effect | DrawWrapper, overrideOrientation: Nullable<number> = null): boolean {\r\n        const engine = this._scene.getEngine();\r\n\r\n        const orientation = overrideOrientation == null ? this.sideOrientation : overrideOrientation;\r\n        const reverse = orientation === Material.ClockWiseSideOrientation;\r\n\r\n        engine.enableEffect(effect ? effect : this._getDrawWrapper());\r\n        engine.setState(\r\n            this.backFaceCulling,\r\n            this.zOffset,\r\n            false,\r\n            reverse,\r\n            this._scene._mirroredCameraPosition ? !this.cullBackFaces : this.cullBackFaces,\r\n            this.stencil,\r\n            this.zOffsetUnits\r\n        );\r\n\r\n        return reverse;\r\n    }\r\n\r\n    /**\r\n     * Binds the material to the mesh\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh to bind the material to\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public bind(world: Matrix, mesh?: Mesh): void {}\r\n\r\n    /**\r\n     * Initializes the uniform buffer layout for the shader.\r\n     */\r\n    public buildUniformLayout(): void {\r\n        const ubo = this._uniformBuffer;\r\n\r\n        this._eventInfo.ubo = ubo;\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareUniformBuffer, this._eventInfo);\r\n\r\n        ubo.create();\r\n\r\n        this._uniformBufferLayoutBuilt = true;\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to the material\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        this._eventInfo.subMesh = subMesh;\r\n        this._callbackPluginEventBindForSubMesh(this._eventInfo);\r\n        effect._forceRebindOnNextCall = false;\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public bindOnlyWorldMatrix(world: Matrix): void {}\r\n\r\n    /**\r\n     * Binds the view matrix to the effect\r\n     * @param effect defines the effect to bind the view matrix to\r\n     */\r\n    public bindView(effect: Effect): void {\r\n        if (!this._useUBO) {\r\n            effect.setMatrix(\"view\", this.getScene().getViewMatrix());\r\n        } else {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the view projection and projection matrices to the effect\r\n     * @param effect defines the effect to bind the view projection and projection matrices to\r\n     */\r\n    public bindViewProjection(effect: Effect): void {\r\n        if (!this._useUBO) {\r\n            effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\r\n            effect.setMatrix(\"projection\", this.getScene().getProjectionMatrix());\r\n        } else {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the view matrix to the effect\r\n     * @param effect defines the effect to bind the view matrix to\r\n     * @param variableName name of the shader variable that will hold the eye position\r\n     */\r\n    public bindEyePosition(effect: Effect, variableName?: string): void {\r\n        if (!this._useUBO) {\r\n            this._scene.bindEyePosition(effect, variableName);\r\n        } else {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Processes to execute after binding the material to a mesh\r\n     * @param mesh defines the rendered mesh\r\n     * @param effect\r\n     */\r\n    protected _afterBind(mesh?: Mesh, effect: Nullable<Effect> = null): void {\r\n        this._scene._cachedMaterial = this;\r\n        if (this._needToBindSceneUbo) {\r\n            if (effect) {\r\n                this._needToBindSceneUbo = false;\r\n                MaterialHelper.BindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());\r\n                this._scene.finalizeSceneUbo();\r\n            }\r\n        }\r\n        if (mesh) {\r\n            this._scene._cachedVisibility = mesh.visibility;\r\n        } else {\r\n            this._scene._cachedVisibility = 1;\r\n        }\r\n\r\n        if (this._onBindObservable && mesh) {\r\n            this._onBindObservable.notifyObservers(mesh);\r\n        }\r\n\r\n        if (this.disableDepthWrite) {\r\n            const engine = this._scene.getEngine();\r\n            this._cachedDepthWriteState = engine.getDepthWrite();\r\n            engine.setDepthWrite(false);\r\n        }\r\n\r\n        if (this.disableColorWrite) {\r\n            const engine = this._scene.getEngine();\r\n            this._cachedColorWriteState = engine.getColorWrite();\r\n            engine.setColorWrite(false);\r\n        }\r\n\r\n        if (this.depthFunction !== 0) {\r\n            const engine = this._scene.getEngine();\r\n            this._cachedDepthFunctionState = engine.getDepthFunction() || 0;\r\n            engine.setDepthFunction(this.depthFunction);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unbinds the material from the mesh\r\n     */\r\n    public unbind(): void {\r\n        if (this._onUnBindObservable) {\r\n            this._onUnBindObservable.notifyObservers(this);\r\n        }\r\n\r\n        if (this.depthFunction !== 0) {\r\n            const engine = this._scene.getEngine();\r\n            engine.setDepthFunction(this._cachedDepthFunctionState);\r\n        }\r\n\r\n        if (this.disableDepthWrite) {\r\n            const engine = this._scene.getEngine();\r\n            engine.setDepthWrite(this._cachedDepthWriteState);\r\n        }\r\n\r\n        if (this.disableColorWrite) {\r\n            const engine = this._scene.getEngine();\r\n            engine.setColorWrite(this._cachedColorWriteState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the animatable textures.\r\n     * @returns - Array of animatable textures.\r\n     */\r\n    public getAnimatables(): IAnimatable[] {\r\n        this._eventInfo.animatables = [];\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.GetAnimatables, this._eventInfo);\r\n        return this._eventInfo.animatables;\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        this._eventInfo.activeTextures = [];\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.GetActiveTextures, this._eventInfo);\r\n        return this._eventInfo.activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        this._eventInfo.hasTexture = false;\r\n        this._eventInfo.texture = texture;\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.HasTexture, this._eventInfo);\r\n        return this._eventInfo.hasTexture;\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public clone(name: string): Nullable<Material> {\r\n        return null;\r\n    }\r\n\r\n    protected _clonePlugins(targetMaterial: Material, rootUrl: string) {\r\n        const serializationObject: any = {};\r\n\r\n        // Create plugins in targetMaterial in case they don't exist\r\n        this._serializePlugins(serializationObject);\r\n\r\n        Material._parsePlugins(serializationObject, targetMaterial, this._scene, rootUrl);\r\n\r\n        // Copy the properties of the current plugins to the cloned material's plugins\r\n        if (this.pluginManager) {\r\n            for (const plugin of this.pluginManager._plugins) {\r\n                const targetPlugin = targetMaterial.pluginManager!.getPlugin(plugin.name)!;\r\n                plugin.copyTo(targetPlugin);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the meshes bound to the material\r\n     * @returns an array of meshes bound to the material\r\n     */\r\n    public getBindedMeshes(): AbstractMesh[] {\r\n        if (this.meshMap) {\r\n            const result = new Array<AbstractMesh>();\r\n            for (const meshId in this.meshMap) {\r\n                const mesh = this.meshMap[meshId];\r\n                if (mesh) {\r\n                    result.push(mesh);\r\n                }\r\n            }\r\n            return result;\r\n        } else {\r\n            const meshes = this._scene.meshes;\r\n            return meshes.filter((mesh) => mesh.material === this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force shader compilation\r\n     * @param mesh defines the mesh associated with this material\r\n     * @param onCompiled defines a function to execute once the material is compiled\r\n     * @param options defines the options to configure the compilation\r\n     * @param onError defines a function to execute if the material fails compiling\r\n     */\r\n    public forceCompilation(\r\n        mesh: AbstractMesh,\r\n        onCompiled?: (material: Material) => void,\r\n        options?: Partial<IMaterialCompilationOptions>,\r\n        onError?: (reason: string) => void\r\n    ): void {\r\n        const localOptions = {\r\n            clipPlane: false,\r\n            useInstances: false,\r\n            ...options,\r\n        };\r\n\r\n        const scene = this.getScene();\r\n        const currentHotSwapingState = this.allowShaderHotSwapping;\r\n        this.allowShaderHotSwapping = false; // Turned off to let us evaluate the real compilation state\r\n\r\n        const checkReady = () => {\r\n            if (!this._scene || !this._scene.getEngine()) {\r\n                return;\r\n            }\r\n\r\n            const clipPlaneState = scene.clipPlane;\r\n\r\n            if (localOptions.clipPlane) {\r\n                scene.clipPlane = new Plane(0, 0, 0, 1);\r\n            }\r\n\r\n            if (this._storeEffectOnSubMeshes) {\r\n                let allDone = true,\r\n                    lastError = null;\r\n                if (mesh.subMeshes) {\r\n                    const tempSubMesh = new SubMesh(0, 0, 0, 0, 0, mesh, undefined, false, false);\r\n                    if (tempSubMesh.materialDefines) {\r\n                        tempSubMesh.materialDefines._renderId = -1;\r\n                    }\r\n                    if (!this.isReadyForSubMesh(mesh, tempSubMesh, localOptions.useInstances)) {\r\n                        if (tempSubMesh.effect && tempSubMesh.effect.getCompilationError() && tempSubMesh.effect.allFallbacksProcessed()) {\r\n                            lastError = tempSubMesh.effect.getCompilationError();\r\n                        } else {\r\n                            allDone = false;\r\n                            setTimeout(checkReady, 16);\r\n                        }\r\n                    }\r\n                }\r\n                if (allDone) {\r\n                    this.allowShaderHotSwapping = currentHotSwapingState;\r\n                    if (lastError) {\r\n                        if (onError) {\r\n                            onError(lastError);\r\n                        }\r\n                    }\r\n                    if (onCompiled) {\r\n                        onCompiled(this);\r\n                    }\r\n                }\r\n            } else {\r\n                if (this.isReady()) {\r\n                    this.allowShaderHotSwapping = currentHotSwapingState;\r\n                    if (onCompiled) {\r\n                        onCompiled(this);\r\n                    }\r\n                } else {\r\n                    setTimeout(checkReady, 16);\r\n                }\r\n            }\r\n\r\n            if (localOptions.clipPlane) {\r\n                scene.clipPlane = clipPlaneState;\r\n            }\r\n        };\r\n\r\n        checkReady();\r\n    }\r\n\r\n    /**\r\n     * Force shader compilation\r\n     * @param mesh defines the mesh that will use this material\r\n     * @param options defines additional options for compiling the shaders\r\n     * @returns a promise that resolves when the compilation completes\r\n     */\r\n    public forceCompilationAsync(mesh: AbstractMesh, options?: Partial<IMaterialCompilationOptions>): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            this.forceCompilation(\r\n                mesh,\r\n                () => {\r\n                    resolve();\r\n                },\r\n                options,\r\n                (reason) => {\r\n                    reject(reason);\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    private static readonly _AllDirtyCallBack = (defines: MaterialDefines) => defines.markAllAsDirty();\r\n    private static readonly _ImageProcessingDirtyCallBack = (defines: MaterialDefines) => defines.markAsImageProcessingDirty();\r\n    private static readonly _TextureDirtyCallBack = (defines: MaterialDefines) => defines.markAsTexturesDirty();\r\n    private static readonly _FresnelDirtyCallBack = (defines: MaterialDefines) => defines.markAsFresnelDirty();\r\n    private static readonly _MiscDirtyCallBack = (defines: MaterialDefines) => defines.markAsMiscDirty();\r\n    private static readonly _PrePassDirtyCallBack = (defines: MaterialDefines) => defines.markAsPrePassDirty();\r\n    private static readonly _LightsDirtyCallBack = (defines: MaterialDefines) => defines.markAsLightDirty();\r\n    private static readonly _AttributeDirtyCallBack = (defines: MaterialDefines) => defines.markAsAttributesDirty();\r\n\r\n    private static _FresnelAndMiscDirtyCallBack = (defines: MaterialDefines) => {\r\n        Material._FresnelDirtyCallBack(defines);\r\n        Material._MiscDirtyCallBack(defines);\r\n    };\r\n\r\n    private static _TextureAndMiscDirtyCallBack = (defines: MaterialDefines) => {\r\n        Material._TextureDirtyCallBack(defines);\r\n        Material._MiscDirtyCallBack(defines);\r\n    };\r\n\r\n    private static readonly _DirtyCallbackArray: Array<(defines: MaterialDefines) => void> = [];\r\n    private static readonly _RunDirtyCallBacks = (defines: MaterialDefines) => {\r\n        for (const cb of Material._DirtyCallbackArray) {\r\n            cb(defines);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Marks a define in the material to indicate that it needs to be re-computed\r\n     * @param flag defines a flag used to determine which parts of the material have to be marked as dirty\r\n     */\r\n    public markAsDirty(flag: number): void {\r\n        if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        Material._DirtyCallbackArray.length = 0;\r\n\r\n        if (flag & Material.TextureDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._TextureDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.LightDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._LightsDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.FresnelDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._FresnelDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.AttributesDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._AttributeDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.MiscDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._MiscDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.PrePassDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._PrePassDirtyCallBack);\r\n        }\r\n\r\n        if (Material._DirtyCallbackArray.length) {\r\n            this._markAllSubMeshesAsDirty(Material._RunDirtyCallBacks);\r\n        }\r\n\r\n        this.getScene().resetCachedMaterial();\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache for all submeshes that are using this material\r\n     */\r\n    public resetDrawCache(): void {\r\n        const meshes = this.getScene().meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (subMesh.getMaterial() !== this) {\r\n                    continue;\r\n                }\r\n\r\n                subMesh.resetDrawCache();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Marks all submeshes of a material to indicate that their material defines need to be re-calculated\r\n     * @param func defines a function which checks material defines against the submeshes\r\n     */\r\n    protected _markAllSubMeshesAsDirty(func: (defines: MaterialDefines) => void) {\r\n        if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        const meshes = this.getScene().meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                // We want to skip the submeshes which are not using this material or which have not yet rendered at least once\r\n                if (subMesh.getMaterial(false) !== this) {\r\n                    continue;\r\n                }\r\n\r\n                for (const drawWrapper of subMesh._drawWrappers) {\r\n                    if (!drawWrapper || !drawWrapper.defines || !(drawWrapper.defines as MaterialDefines).markAllAsDirty) {\r\n                        continue;\r\n                    }\r\n                    if (this._materialContext === drawWrapper.materialContext) {\r\n                        func(drawWrapper.defines as MaterialDefines);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates that the scene should check if the rendering now needs a prepass\r\n     */\r\n    protected _markScenePrePassDirty() {\r\n        if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        const prePassRenderer = this.getScene().enablePrePassRenderer();\r\n        if (prePassRenderer) {\r\n            prePassRenderer.markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates that we need to re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsAllDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._AllDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that image processing needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsImageProcessingDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._ImageProcessingDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsTexturesDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._TextureDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that fresnel needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsFresnelDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._FresnelDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that fresnel and misc need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsFresnelAndMiscDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._FresnelAndMiscDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that lights need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsLightsDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._LightsDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that attributes need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsAttributesDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._AttributeDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that misc needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsMiscDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that prepass needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsPrePassDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures and misc need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsTexturesAndMiscDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._TextureAndMiscDirtyCallBack);\r\n    }\r\n\r\n    protected _checkScenePerformancePriority() {\r\n        if (this._scene.performancePriority !== ScenePerformancePriority.BackwardCompatible) {\r\n            this.checkReadyOnlyOnce = true;\r\n            // re-set the flag when the perf priority changes\r\n            const observer = this._scene.onScenePerformancePriorityChangedObservable.addOnce(() => {\r\n                this.checkReadyOnlyOnce = false;\r\n            });\r\n            // if this material is disposed before the scene is disposed, cleanup the observer\r\n            this.onDisposeObservable.add(() => {\r\n                this._scene.onScenePerformancePriorityChangedObservable.remove(observer);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the required values to the prepass renderer.\r\n     * @param prePassRenderer defines the prepass renderer to setup.\r\n     * @returns true if the pre pass is needed.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public setPrePassRenderer(prePassRenderer: PrePassRenderer): boolean {\r\n        // Do Nothing by default\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n        const scene = this.getScene();\r\n        // Animations\r\n        scene.stopAnimation(this);\r\n        scene.freeProcessedMaterials();\r\n\r\n        // Remove from scene\r\n        scene.removeMaterial(this);\r\n\r\n        this._eventInfo.forceDisposeTextures = forceDisposeTextures;\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.Disposed, this._eventInfo);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.materials.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.materials.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        if (notBoundToMesh !== true) {\r\n            // Remove from meshes\r\n            if (this.meshMap) {\r\n                for (const meshId in this.meshMap) {\r\n                    const mesh = this.meshMap[meshId];\r\n                    if (mesh) {\r\n                        mesh.material = null; // will set the entry in the map to undefined\r\n                        this.releaseVertexArrayObject(mesh, forceDisposeEffect);\r\n                    }\r\n                }\r\n            } else {\r\n                const meshes = scene.meshes;\r\n                for (const mesh of meshes) {\r\n                    if (mesh.material === this && !(mesh as InstancedMesh).sourceMesh) {\r\n                        mesh.material = null;\r\n                        this.releaseVertexArrayObject(mesh, forceDisposeEffect);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this._uniformBuffer.dispose();\r\n\r\n        // Shader are kept in cache for further use but we can get rid of this by using forceDisposeEffect\r\n        if (forceDisposeEffect && this._drawWrapper.effect) {\r\n            if (!this._storeEffectOnSubMeshes) {\r\n                this._drawWrapper.effect.dispose();\r\n            }\r\n\r\n            this._drawWrapper.effect = null;\r\n        }\r\n\r\n        this.metadata = null;\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n\r\n        this.onDisposeObservable.clear();\r\n        if (this._onBindObservable) {\r\n            this._onBindObservable.clear();\r\n        }\r\n\r\n        if (this._onUnBindObservable) {\r\n            this._onUnBindObservable.clear();\r\n        }\r\n\r\n        if (this._onEffectCreatedObservable) {\r\n            this._onEffectCreatedObservable.clear();\r\n        }\r\n\r\n        if (this._eventInfo) {\r\n            this._eventInfo = {} as any;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private releaseVertexArrayObject(mesh: AbstractMesh, forceDisposeEffect?: boolean) {\r\n        const geometry = (<Mesh>mesh).geometry;\r\n        if (geometry) {\r\n            if (this._storeEffectOnSubMeshes) {\r\n                if (mesh.subMeshes) {\r\n                    for (const subMesh of mesh.subMeshes) {\r\n                        geometry._releaseVertexArrayObject(subMesh.effect);\r\n                        if (forceDisposeEffect && subMesh.effect) {\r\n                            subMesh.effect.dispose();\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                geometry._releaseVertexArrayObject(this._drawWrapper.effect);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes this material\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        serializationObject.stencil = this.stencil.serialize();\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        this._serializePlugins(serializationObject);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    protected _serializePlugins(serializationObject: any) {\r\n        serializationObject.plugins = {};\r\n\r\n        if (this.pluginManager) {\r\n            for (const plugin of this.pluginManager._plugins) {\r\n                serializationObject.plugins[plugin.getClassName()] = plugin.serialize();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a material from parsed material data\r\n     * @param parsedMaterial defines parsed material data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures\r\n     * @returns a new material\r\n     */\r\n    public static Parse(parsedMaterial: any, scene: Scene, rootUrl: string): Nullable<Material> {\r\n        if (!parsedMaterial.customType) {\r\n            parsedMaterial.customType = \"BABYLON.StandardMaterial\";\r\n        } else if (parsedMaterial.customType === \"BABYLON.PBRMaterial\" && parsedMaterial.overloadedAlbedo) {\r\n            parsedMaterial.customType = \"BABYLON.LegacyPBRMaterial\";\r\n            if (!BABYLON.LegacyPBRMaterial) {\r\n                Logger.Error(\"Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library.\");\r\n                return null;\r\n            }\r\n        }\r\n\r\n        const materialType = Tools.Instantiate(parsedMaterial.customType);\r\n        const material = materialType.Parse(parsedMaterial, scene, rootUrl);\r\n        material._loadedUniqueId = parsedMaterial.uniqueId;\r\n\r\n        return material;\r\n    }\r\n\r\n    protected static _parsePlugins(serializationObject: any, material: Material, scene: Scene, rootUrl: string) {\r\n        if (!serializationObject.plugins) {\r\n            return;\r\n        }\r\n\r\n        for (const pluginClassName in serializationObject.plugins) {\r\n            const pluginData = serializationObject.plugins[pluginClassName];\r\n\r\n            let plugin = material.pluginManager?.getPlugin(pluginData.name);\r\n\r\n            if (!plugin) {\r\n                const pluginClassType = Tools.Instantiate(\"BABYLON.\" + pluginClassName);\r\n                if (pluginClassType) {\r\n                    plugin = new pluginClassType(material);\r\n                }\r\n            }\r\n\r\n            plugin?.parse(pluginData, scene, rootUrl);\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}