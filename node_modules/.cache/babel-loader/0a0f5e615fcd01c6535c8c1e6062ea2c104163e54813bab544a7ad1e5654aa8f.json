{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"@babylonjs/core/tslib.es6.js\";\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh.js\";\nimport { Control } from \"./control.js\";\nimport { MultiLinePoint } from \"../multiLinePoint.js\";\nimport { RegisterClass } from \"@babylonjs/core/Misc/typeStore.js\";\nimport { serialize } from \"@babylonjs/core/Misc/decorators.js\";\n/**\n * Class used to create multi line control\n */\nexport class MultiLine extends Control {\n  /**\n   * Creates a new MultiLine\n   * @param name defines the control name\n   */\n  constructor(name) {\n    super(name);\n    this.name = name;\n    this._lineWidth = 1;\n    /** Function called when a point is updated */\n    this.onPointUpdate = () => {\n      this._markAsDirty();\n    };\n    this._automaticSize = true;\n    this.isHitTestVisible = false;\n    this._horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this._verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\n    this._dash = [];\n    this._points = [];\n  }\n  /** Gets or sets dash pattern */\n  get dash() {\n    return this._dash;\n  }\n  set dash(value) {\n    if (this._dash === value) {\n      return;\n    }\n    this._dash = value;\n    this._markAsDirty();\n  }\n  /**\n   * Gets point stored at specified index\n   * @param index defines the index to look for\n   * @returns the requested point if found\n   */\n  getAt(index) {\n    if (!this._points[index]) {\n      this._points[index] = new MultiLinePoint(this);\n    }\n    return this._points[index];\n  }\n  /**\n   * Adds new points to the point collection\n   * @param items defines the list of items (mesh, control or 2d coordinates) to add\n   * @returns the list of created MultiLinePoint\n   */\n  add(...items) {\n    return items.map(item => this.push(item));\n  }\n  /**\n   * Adds a new point to the point collection\n   * @param item defines the item (mesh, control or 2d coordinates) to add\n   * @returns the created MultiLinePoint\n   */\n  push(item) {\n    const point = this.getAt(this._points.length);\n    if (item == null) {\n      return point;\n    }\n    if (item instanceof AbstractMesh) {\n      point.mesh = item;\n    } else if (item instanceof Control) {\n      point.control = item;\n    } else if (item.x != null && item.y != null) {\n      point.x = item.x;\n      point.y = item.y;\n    }\n    return point;\n  }\n  /**\n   * Remove a specific value or point from the active point collection\n   * @param value defines the value or point to remove\n   */\n  remove(value) {\n    let index;\n    if (value instanceof MultiLinePoint) {\n      index = this._points.indexOf(value);\n      if (index === -1) {\n        return;\n      }\n    } else {\n      index = value;\n    }\n    const point = this._points[index];\n    if (!point) {\n      return;\n    }\n    point.dispose();\n    this._points.splice(index, 1);\n  }\n  /**\n   * Resets this object to initial state (no point)\n   */\n  reset() {\n    while (this._points.length > 0) {\n      this.remove(this._points.length - 1);\n    }\n  }\n  /**\n   * Resets all links\n   */\n  resetLinks() {\n    this._points.forEach(point => {\n      if (point != null) {\n        point.resetLinks();\n      }\n    });\n  }\n  /** Gets or sets line width */\n  get lineWidth() {\n    return this._lineWidth;\n  }\n  set lineWidth(value) {\n    if (this._lineWidth === value) {\n      return;\n    }\n    this._lineWidth = value;\n    this._markAsDirty();\n  }\n  set horizontalAlignment(value) {\n    return;\n  }\n  set verticalAlignment(value) {\n    return;\n  }\n  _getTypeName() {\n    return \"MultiLine\";\n  }\n  _draw(context) {\n    context.save();\n    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\n      context.shadowColor = this.shadowColor;\n      context.shadowBlur = this.shadowBlur;\n      context.shadowOffsetX = this.shadowOffsetX;\n      context.shadowOffsetY = this.shadowOffsetY;\n    }\n    this._applyStates(context);\n    context.strokeStyle = this.color;\n    context.lineWidth = this._lineWidth;\n    context.setLineDash(this._dash);\n    context.beginPath();\n    let first = true; //first index is not necessarily 0\n    let previousPoint;\n    this._points.forEach(point => {\n      if (!point) {\n        return;\n      }\n      if (first) {\n        context.moveTo(point._point.x, point._point.y);\n        first = false;\n      } else {\n        if (point._point.z < 1 && previousPoint.z < 1) {\n          context.lineTo(point._point.x, point._point.y);\n        } else {\n          context.moveTo(point._point.x, point._point.y);\n        }\n      }\n      previousPoint = point._point;\n    });\n    context.stroke();\n    context.restore();\n  }\n  _additionalProcessing() {\n    this._minX = null;\n    this._minY = null;\n    this._maxX = null;\n    this._maxY = null;\n    this._points.forEach(point => {\n      if (!point) {\n        return;\n      }\n      point.translate();\n      if (this._minX == null || point._point.x < this._minX) {\n        this._minX = point._point.x;\n      }\n      if (this._minY == null || point._point.y < this._minY) {\n        this._minY = point._point.y;\n      }\n      if (this._maxX == null || point._point.x > this._maxX) {\n        this._maxX = point._point.x;\n      }\n      if (this._maxY == null || point._point.y > this._maxY) {\n        this._maxY = point._point.y;\n      }\n    });\n    if (this._minX == null) {\n      this._minX = 0;\n    }\n    if (this._minY == null) {\n      this._minY = 0;\n    }\n    if (this._maxX == null) {\n      this._maxX = 0;\n    }\n    if (this._maxY == null) {\n      this._maxY = 0;\n    }\n  }\n  _measure() {\n    if (this._minX == null || this._maxX == null || this._minY == null || this._maxY == null) {\n      return;\n    }\n    this._currentMeasure.width = Math.abs(this._maxX - this._minX) + this._lineWidth;\n    this._currentMeasure.height = Math.abs(this._maxY - this._minY) + this._lineWidth;\n  }\n  _computeAlignment() {\n    if (this._minX == null || this._minY == null) {\n      return;\n    }\n    this._currentMeasure.left = this._minX - this._lineWidth / 2;\n    this._currentMeasure.top = this._minY - this._lineWidth / 2;\n  }\n  dispose() {\n    this.reset();\n    super.dispose();\n  }\n}\n__decorate([serialize()], MultiLine.prototype, \"dash\", null);\nRegisterClass(\"BABYLON.GUI.MultiLine\", MultiLine);","map":{"version":3,"names":["AbstractMesh","Control","MultiLinePoint","RegisterClass","serialize","MultiLine","constructor","name","_lineWidth","onPointUpdate","_markAsDirty","_automaticSize","isHitTestVisible","_horizontalAlignment","HORIZONTAL_ALIGNMENT_LEFT","_verticalAlignment","VERTICAL_ALIGNMENT_TOP","_dash","_points","dash","value","getAt","index","add","items","map","item","push","point","length","mesh","control","x","y","remove","indexOf","dispose","splice","reset","resetLinks","forEach","lineWidth","horizontalAlignment","verticalAlignment","_getTypeName","_draw","context","save","shadowBlur","shadowOffsetX","shadowOffsetY","shadowColor","_applyStates","strokeStyle","color","setLineDash","beginPath","first","previousPoint","moveTo","_point","z","lineTo","stroke","restore","_additionalProcessing","_minX","_minY","_maxX","_maxY","translate","_measure","_currentMeasure","width","Math","abs","height","_computeAlignment","left","top","__decorate"],"sources":["../../../../../dev/gui/src/2D/controls/multiLine.ts"],"sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\n\r\nimport { Control } from \"./control\";\r\nimport { MultiLinePoint } from \"../multiLinePoint\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { Vector3 } from \"core/Maths/math.vector\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\n\r\n/**\r\n * Class used to create multi line control\r\n */\r\nexport class MultiLine extends Control {\r\n    private _lineWidth: number = 1;\r\n    private _dash: number[];\r\n    private _points: Nullable<MultiLinePoint>[];\r\n\r\n    private _minX: Nullable<number>;\r\n    private _minY: Nullable<number>;\r\n    private _maxX: Nullable<number>;\r\n    private _maxY: Nullable<number>;\r\n\r\n    /**\r\n     * Creates a new MultiLine\r\n     * @param name defines the control name\r\n     */\r\n    constructor(public name?: string) {\r\n        super(name);\r\n\r\n        this._automaticSize = true;\r\n        this.isHitTestVisible = false;\r\n        this._horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        this._verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n\r\n        this._dash = [];\r\n        this._points = [];\r\n    }\r\n\r\n    /** Gets or sets dash pattern */\r\n    @serialize()\r\n    public get dash(): Array<number> {\r\n        return this._dash;\r\n    }\r\n\r\n    public set dash(value: Array<number>) {\r\n        if (this._dash === value) {\r\n            return;\r\n        }\r\n\r\n        this._dash = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets point stored at specified index\r\n     * @param index defines the index to look for\r\n     * @returns the requested point if found\r\n     */\r\n    public getAt(index: number): MultiLinePoint {\r\n        if (!this._points[index]) {\r\n            this._points[index] = new MultiLinePoint(this);\r\n        }\r\n\r\n        return this._points[index] as MultiLinePoint;\r\n    }\r\n\r\n    /** Function called when a point is updated */\r\n    public onPointUpdate = (): void => {\r\n        this._markAsDirty();\r\n    };\r\n\r\n    /**\r\n     * Adds new points to the point collection\r\n     * @param items defines the list of items (mesh, control or 2d coordinates) to add\r\n     * @returns the list of created MultiLinePoint\r\n     */\r\n    public add(...items: (AbstractMesh | Control | { x: string | number; y: string | number })[]): MultiLinePoint[] {\r\n        return items.map((item) => this.push(item));\r\n    }\r\n\r\n    /**\r\n     * Adds a new point to the point collection\r\n     * @param item defines the item (mesh, control or 2d coordinates) to add\r\n     * @returns the created MultiLinePoint\r\n     */\r\n    public push(item?: AbstractMesh | Control | { x: string | number; y: string | number }): MultiLinePoint {\r\n        const point: MultiLinePoint = this.getAt(this._points.length);\r\n\r\n        if (item == null) {\r\n            return point;\r\n        }\r\n\r\n        if (item instanceof AbstractMesh) {\r\n            point.mesh = item;\r\n        } else if (item instanceof Control) {\r\n            point.control = item;\r\n        } else if (item.x != null && item.y != null) {\r\n            point.x = item.x;\r\n            point.y = item.y;\r\n        }\r\n\r\n        return point;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific value or point from the active point collection\r\n     * @param value defines the value or point to remove\r\n     */\r\n    public remove(value: number | MultiLinePoint): void {\r\n        let index: number;\r\n\r\n        if (value instanceof MultiLinePoint) {\r\n            index = this._points.indexOf(value);\r\n\r\n            if (index === -1) {\r\n                return;\r\n            }\r\n        } else {\r\n            index = value;\r\n        }\r\n\r\n        const point: Nullable<MultiLinePoint> = this._points[index];\r\n\r\n        if (!point) {\r\n            return;\r\n        }\r\n\r\n        point.dispose();\r\n\r\n        this._points.splice(index, 1);\r\n    }\r\n\r\n    /**\r\n     * Resets this object to initial state (no point)\r\n     */\r\n    public reset(): void {\r\n        while (this._points.length > 0) {\r\n            this.remove(this._points.length - 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets all links\r\n     */\r\n    public resetLinks(): void {\r\n        this._points.forEach((point) => {\r\n            if (point != null) {\r\n                point.resetLinks();\r\n            }\r\n        });\r\n    }\r\n\r\n    /** Gets or sets line width */\r\n    public get lineWidth(): number {\r\n        return this._lineWidth;\r\n    }\r\n\r\n    public set lineWidth(value: number) {\r\n        if (this._lineWidth === value) {\r\n            return;\r\n        }\r\n\r\n        this._lineWidth = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    public set horizontalAlignment(value: number) {\r\n        return;\r\n    }\r\n\r\n    public set verticalAlignment(value: number) {\r\n        return;\r\n    }\r\n\r\n    protected _getTypeName(): string {\r\n        return \"MultiLine\";\r\n    }\r\n\r\n    public _draw(context: ICanvasRenderingContext): void {\r\n        context.save();\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowColor = this.shadowColor;\r\n            context.shadowBlur = this.shadowBlur;\r\n            context.shadowOffsetX = this.shadowOffsetX;\r\n            context.shadowOffsetY = this.shadowOffsetY;\r\n        }\r\n\r\n        this._applyStates(context);\r\n\r\n        context.strokeStyle = this.color;\r\n        context.lineWidth = this._lineWidth;\r\n        context.setLineDash(this._dash);\r\n\r\n        context.beginPath();\r\n\r\n        let first: boolean = true; //first index is not necessarily 0\r\n        let previousPoint: Vector3;\r\n\r\n        this._points.forEach((point) => {\r\n            if (!point) {\r\n                return;\r\n            }\r\n\r\n            if (first) {\r\n                context.moveTo(point._point.x, point._point.y);\r\n\r\n                first = false;\r\n            } else {\r\n                if (point._point.z < 1 && previousPoint.z < 1) {\r\n                    context.lineTo(point._point.x, point._point.y);\r\n                } else {\r\n                    context.moveTo(point._point.x, point._point.y);\r\n                }\r\n            }\r\n            previousPoint = point._point;\r\n        });\r\n\r\n        context.stroke();\r\n\r\n        context.restore();\r\n    }\r\n\r\n    protected _additionalProcessing(): void {\r\n        this._minX = null;\r\n        this._minY = null;\r\n        this._maxX = null;\r\n        this._maxY = null;\r\n\r\n        this._points.forEach((point) => {\r\n            if (!point) {\r\n                return;\r\n            }\r\n\r\n            point.translate();\r\n\r\n            if (this._minX == null || point._point.x < this._minX) {\r\n                this._minX = point._point.x;\r\n            }\r\n            if (this._minY == null || point._point.y < this._minY) {\r\n                this._minY = point._point.y;\r\n            }\r\n            if (this._maxX == null || point._point.x > this._maxX) {\r\n                this._maxX = point._point.x;\r\n            }\r\n            if (this._maxY == null || point._point.y > this._maxY) {\r\n                this._maxY = point._point.y;\r\n            }\r\n        });\r\n\r\n        if (this._minX == null) {\r\n            this._minX = 0;\r\n        }\r\n        if (this._minY == null) {\r\n            this._minY = 0;\r\n        }\r\n        if (this._maxX == null) {\r\n            this._maxX = 0;\r\n        }\r\n        if (this._maxY == null) {\r\n            this._maxY = 0;\r\n        }\r\n    }\r\n\r\n    public _measure(): void {\r\n        if (this._minX == null || this._maxX == null || this._minY == null || this._maxY == null) {\r\n            return;\r\n        }\r\n\r\n        this._currentMeasure.width = Math.abs(this._maxX - this._minX) + this._lineWidth;\r\n        this._currentMeasure.height = Math.abs(this._maxY - this._minY) + this._lineWidth;\r\n    }\r\n\r\n    protected _computeAlignment(): void {\r\n        if (this._minX == null || this._minY == null) {\r\n            return;\r\n        }\r\n\r\n        this._currentMeasure.left = this._minX - this._lineWidth / 2;\r\n        this._currentMeasure.top = this._minY - this._lineWidth / 2;\r\n    }\r\n\r\n    public dispose(): void {\r\n        this.reset();\r\n\r\n        super.dispose();\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.MultiLine\", MultiLine);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}