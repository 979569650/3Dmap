{"ast":null,"code":"import { TransformNode } from \"../../Meshes/transformNode.js\";\nimport \"../joinedPhysicsEngineComponent.js\";\nObject.defineProperty(TransformNode.prototype, \"physicsBody\", {\n  get: function () {\n    return this._physicsBody;\n  },\n  set: function (value) {\n    if (this._physicsBody === value) {\n      return;\n    }\n    if (this._disposePhysicsObserver) {\n      this.onDisposeObservable.remove(this._disposePhysicsObserver);\n    }\n    this._physicsBody = value;\n    if (value) {\n      this._disposePhysicsObserver = this.onDisposeObservable.add(() => {\n        // Physics\n        if (this.physicsBody) {\n          this.physicsBody.dispose( /*!doNotRecurse*/);\n          this.physicsBody = null;\n        }\n      });\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\n/**\n * Gets the current physics body\n * @returns a physics body or null\n */\nTransformNode.prototype.getPhysicsBody = function () {\n  return this.physicsBody;\n};\n/**\n * Apply a physic impulse to the mesh\n * @param force defines the force to apply\n * @param contactPoint defines where to apply the force\n * @returns the current mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\n */\nTransformNode.prototype.applyImpulse = function (force, contactPoint) {\n  if (!this.physicsBody) {\n    throw new Error(\"No Physics Body for TransformNode\");\n  }\n  this.physicsBody.applyImpulse(force, contactPoint);\n  return this;\n};","map":{"version":3,"names":["TransformNode","Object","defineProperty","prototype","get","_physicsBody","set","value","_disposePhysicsObserver","onDisposeObservable","remove","add","physicsBody","dispose","enumerable","configurable","getPhysicsBody","applyImpulse","force","contactPoint","Error"],"sources":["../../../../../dev/core/src/Physics/v2/physicsEngineComponent.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Vector3 } from \"../../Maths/math.vector\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { Node } from \"../../node\";\r\nimport type { PhysicsBody } from \"./physicsBody\";\r\n\r\nimport \"../joinedPhysicsEngineComponent\";\r\n\r\ndeclare module \"../../Meshes/transformNode\" {\r\n    /**\r\n     *\r\n     */\r\n    /** @internal */\r\n    export interface TransformNode {\r\n        /** @internal */\r\n        _physicsBody: Nullable<PhysicsBody>;\r\n\r\n        /**\r\n         * @see\r\n         */\r\n        physicsBody: Nullable<PhysicsBody>;\r\n\r\n        /**\r\n         *\r\n         */\r\n        getPhysicsBody(): Nullable<PhysicsBody>;\r\n\r\n        /** Apply a physic impulse to the mesh\r\n         * @param force defines the force to apply\r\n         * @param contactPoint defines where to apply the force\r\n         * @returns the current mesh\r\n         */\r\n        applyImpulse(force: Vector3, contactPoint: Vector3): TransformNode;\r\n\r\n        /** @internal */\r\n        _disposePhysicsObserver: Nullable<Observer<Node>>;\r\n    }\r\n}\r\n\r\nObject.defineProperty(TransformNode.prototype, \"physicsBody\", {\r\n    get: function (this: TransformNode) {\r\n        return this._physicsBody;\r\n    },\r\n    set: function (this: TransformNode, value: Nullable<PhysicsBody>) {\r\n        if (this._physicsBody === value) {\r\n            return;\r\n        }\r\n        if (this._disposePhysicsObserver) {\r\n            this.onDisposeObservable.remove(this._disposePhysicsObserver);\r\n        }\r\n\r\n        this._physicsBody = value;\r\n\r\n        if (value) {\r\n            this._disposePhysicsObserver = this.onDisposeObservable.add(() => {\r\n                // Physics\r\n                if (this.physicsBody) {\r\n                    this.physicsBody.dispose(/*!doNotRecurse*/);\r\n                    this.physicsBody = null;\r\n                }\r\n            });\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\n/**\r\n * Gets the current physics body\r\n * @returns a physics body or null\r\n */\r\nTransformNode.prototype.getPhysicsBody = function (): Nullable<PhysicsBody> {\r\n    return this.physicsBody;\r\n};\r\n\r\n/**\r\n * Apply a physic impulse to the mesh\r\n * @param force defines the force to apply\r\n * @param contactPoint defines where to apply the force\r\n * @returns the current mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nTransformNode.prototype.applyImpulse = function (force: Vector3, contactPoint: Vector3): TransformNode {\r\n    if (!this.physicsBody) {\r\n        throw new Error(\"No Physics Body for TransformNode\");\r\n    }\r\n    this.physicsBody.applyImpulse(force, contactPoint);\r\n    return this;\r\n};\r\n"],"mappings":"AAGA,SAASA,aAAa,QAAQ,+BAA6B;AAI3D,OAAO,oCAAkC;AAiCzCC,MAAM,CAACC,cAAc,CAACF,aAAa,CAACG,SAAS,EAAE,aAAa,EAAE;EAC1DC,GAAG,EAAE,SAAAA,CAAA;IACD,OAAO,IAAI,CAACC,YAAY;EAC5B,CAAC;EACDC,GAAG,EAAE,SAAAA,CAA+BC,KAA4B;IAC5D,IAAI,IAAI,CAACF,YAAY,KAAKE,KAAK,EAAE;MAC7B;;IAEJ,IAAI,IAAI,CAACC,uBAAuB,EAAE;MAC9B,IAAI,CAACC,mBAAmB,CAACC,MAAM,CAAC,IAAI,CAACF,uBAAuB,CAAC;;IAGjE,IAAI,CAACH,YAAY,GAAGE,KAAK;IAEzB,IAAIA,KAAK,EAAE;MACP,IAAI,CAACC,uBAAuB,GAAG,IAAI,CAACC,mBAAmB,CAACE,GAAG,CAAC,MAAK;QAC7D;QACA,IAAI,IAAI,CAACC,WAAW,EAAE;UAClB,IAAI,CAACA,WAAW,CAACC,OAAO,CAAkB,CAAjB,kBAAkB;UAC3C,IAAI,CAACD,WAAW,GAAG,IAAI;;MAE/B,CAAC,CAAC;;EAEV,CAAC;EACDE,UAAU,EAAE,IAAI;EAChBC,YAAY,EAAE;CACjB,CAAC;AAEF;;;;AAIAf,aAAa,CAACG,SAAS,CAACa,cAAc,GAAG;EACrC,OAAO,IAAI,CAACJ,WAAW;AAC3B,CAAC;AAED;;;;;;;AAOAZ,aAAa,CAACG,SAAS,CAACc,YAAY,GAAG,UAAUC,KAAc,EAAEC,YAAqB;EAClF,IAAI,CAAC,IAAI,CAACP,WAAW,EAAE;IACnB,MAAM,IAAIQ,KAAK,CAAC,mCAAmC,CAAC;;EAExD,IAAI,CAACR,WAAW,CAACK,YAAY,CAACC,KAAK,EAAEC,YAAY,CAAC;EAClD,OAAO,IAAI;AACf,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}