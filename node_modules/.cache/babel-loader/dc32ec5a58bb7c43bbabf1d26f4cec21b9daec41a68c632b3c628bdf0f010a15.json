{"ast":null,"code":"import { __decorate } from \"@babylonjs/core/tslib.es6.js\";\nimport { Observable } from \"@babylonjs/core/Misc/observable.js\";\nimport { ClipboardEventTypes } from \"@babylonjs/core/Events/clipboardEvents.js\";\nimport { PointerEventTypes } from \"@babylonjs/core/Events/pointerEvents.js\";\nimport { Control } from \"./control.js\";\nimport { ValueAndUnit } from \"../valueAndUnit.js\";\nimport { RegisterClass } from \"@babylonjs/core/Misc/typeStore.js\";\nimport { TextWrapper } from \"./textWrapper.js\";\nimport { serialize } from \"@babylonjs/core/Misc/decorators.js\";\n/**\n * Class used to create input text control\n */\nexport class InputText extends Control {\n  /** Gets or sets the maximum width allowed by the control */\n  get maxWidth() {\n    return this._maxWidth.toString(this._host);\n  }\n  /** Gets the maximum width allowed by the control in pixels */\n  get maxWidthInPixels() {\n    return this._maxWidth.getValueInPixel(this._host, this._cachedParentMeasure.width);\n  }\n  set maxWidth(value) {\n    if (this._maxWidth.toString(this._host) === value) {\n      return;\n    }\n    if (this._maxWidth.fromString(value)) {\n      this._markAsDirty();\n    }\n  }\n  /** Gets or sets the text highlighter transparency; default: 0.4 */\n  get highligherOpacity() {\n    return this._highligherOpacity;\n  }\n  set highligherOpacity(value) {\n    if (this._highligherOpacity === value) {\n      return;\n    }\n    this._highligherOpacity = value;\n    this._markAsDirty();\n  }\n  /** Gets or sets a boolean indicating whether to select complete text by default on input focus */\n  get onFocusSelectAll() {\n    return this._onFocusSelectAll;\n  }\n  set onFocusSelectAll(value) {\n    if (this._onFocusSelectAll === value) {\n      return;\n    }\n    this._onFocusSelectAll = value;\n    this._markAsDirty();\n  }\n  /** Gets or sets the text hightlight color */\n  get textHighlightColor() {\n    return this._textHighlightColor;\n  }\n  set textHighlightColor(value) {\n    if (this._textHighlightColor === value) {\n      return;\n    }\n    this._textHighlightColor = value;\n    this._markAsDirty();\n  }\n  /** Gets or sets control margin */\n  get margin() {\n    return this._margin.toString(this._host);\n  }\n  /** Gets control margin in pixels */\n  get marginInPixels() {\n    return this._margin.getValueInPixel(this._host, this._cachedParentMeasure.width);\n  }\n  set margin(value) {\n    if (this._margin.toString(this._host) === value) {\n      return;\n    }\n    if (this._margin.fromString(value)) {\n      this._markAsDirty();\n    }\n  }\n  /** Gets or sets a boolean indicating if the control can auto stretch its width to adapt to the text */\n  get autoStretchWidth() {\n    return this._autoStretchWidth;\n  }\n  set autoStretchWidth(value) {\n    if (this._autoStretchWidth === value) {\n      return;\n    }\n    this._autoStretchWidth = value;\n    this._markAsDirty();\n  }\n  /** Gets or sets border thickness */\n  get thickness() {\n    return this._thickness;\n  }\n  set thickness(value) {\n    if (this._thickness === value) {\n      return;\n    }\n    this._thickness = value;\n    this._markAsDirty();\n  }\n  /** Gets or sets the background color when focused */\n  get focusedBackground() {\n    return this._focusedBackground;\n  }\n  set focusedBackground(value) {\n    if (this._focusedBackground === value) {\n      return;\n    }\n    this._focusedBackground = value;\n    this._markAsDirty();\n  }\n  /** Gets or sets the background color when focused */\n  get focusedColor() {\n    return this._focusedColor;\n  }\n  set focusedColor(value) {\n    if (this._focusedColor === value) {\n      return;\n    }\n    this._focusedColor = value;\n    this._markAsDirty();\n  }\n  /** Gets or sets the background color */\n  get background() {\n    return this._background;\n  }\n  set background(value) {\n    if (this._background === value) {\n      return;\n    }\n    this._background = value;\n    this._markAsDirty();\n  }\n  /** Gets or sets the placeholder color */\n  get placeholderColor() {\n    return this._placeholderColor;\n  }\n  set placeholderColor(value) {\n    if (this._placeholderColor === value) {\n      return;\n    }\n    this._placeholderColor = value;\n    this._markAsDirty();\n  }\n  /** Gets or sets the text displayed when the control is empty */\n  get placeholderText() {\n    return this._placeholderText;\n  }\n  set placeholderText(value) {\n    if (this._placeholderText === value) {\n      return;\n    }\n    this._placeholderText = value;\n    this._markAsDirty();\n  }\n  /** Gets or sets the dead key. 0 to disable. */\n  get deadKey() {\n    return this._deadKey;\n  }\n  set deadKey(flag) {\n    this._deadKey = flag;\n  }\n  /** Gets or sets the highlight text */\n  get highlightedText() {\n    return this._highlightedText;\n  }\n  set highlightedText(text) {\n    if (this._highlightedText === text) {\n      return;\n    }\n    this._highlightedText = text;\n    this._markAsDirty();\n  }\n  /** Gets or sets if the current key should be added */\n  get addKey() {\n    return this._addKey;\n  }\n  set addKey(flag) {\n    this._addKey = flag;\n  }\n  /** Gets or sets the value of the current key being entered */\n  get currentKey() {\n    return this._currentKey;\n  }\n  set currentKey(key) {\n    this._currentKey = key;\n  }\n  /** Gets or sets the text displayed in the control */\n  get text() {\n    return this._textWrapper.text;\n  }\n  set text(value) {\n    const valueAsString = value.toString(); // Forcing convertion\n    if (!this._textWrapper) {\n      this._textWrapper = new TextWrapper();\n    }\n    if (this._textWrapper.text === valueAsString) {\n      return;\n    }\n    this._textWrapper.text = valueAsString;\n    this._textHasChanged();\n  }\n  _textHasChanged() {\n    this._markAsDirty();\n    this.onTextChangedObservable.notifyObservers(this);\n  }\n  /** Gets or sets control width */\n  get width() {\n    return this._width.toString(this._host);\n  }\n  set width(value) {\n    if (this._width.toString(this._host) === value) {\n      return;\n    }\n    if (this._width.fromString(value)) {\n      this._markAsDirty();\n    }\n    this.autoStretchWidth = false;\n  }\n  /**\n   * Creates a new InputText\n   * @param name defines the control name\n   * @param text defines the text of the control\n   */\n  constructor(name, text = \"\") {\n    super(name);\n    this.name = name;\n    this._placeholderText = \"\";\n    this._background = \"#222222\";\n    this._focusedBackground = \"#000000\";\n    this._focusedColor = \"white\";\n    this._placeholderColor = \"gray\";\n    this._thickness = 1;\n    this._margin = new ValueAndUnit(10, ValueAndUnit.UNITMODE_PIXEL);\n    this._autoStretchWidth = true;\n    this._maxWidth = new ValueAndUnit(1, ValueAndUnit.UNITMODE_PERCENTAGE, false);\n    this._isFocused = false;\n    this._blinkIsEven = false;\n    this._cursorOffset = 0;\n    this._deadKey = false;\n    this._addKey = true;\n    this._currentKey = \"\";\n    this._isTextHighlightOn = false;\n    this._textHighlightColor = \"#d5e0ff\";\n    this._highligherOpacity = 0.4;\n    this._highlightedText = \"\";\n    this._startHighlightIndex = 0;\n    this._endHighlightIndex = 0;\n    this._cursorIndex = -1;\n    this._onFocusSelectAll = false;\n    this._isPointerDown = false;\n    /** Gets or sets a string representing the message displayed on mobile when the control gets the focus */\n    this.promptMessage = \"Please enter text:\";\n    /** Force disable prompt on mobile device */\n    this.disableMobilePrompt = false;\n    /** Observable raised when the text changes */\n    this.onTextChangedObservable = new Observable();\n    /** Observable raised just before an entered character is to be added */\n    this.onBeforeKeyAddObservable = new Observable();\n    /** Observable raised when the control gets the focus */\n    this.onFocusObservable = new Observable();\n    /** Observable raised when the control loses the focus */\n    this.onBlurObservable = new Observable();\n    /**Observable raised when the text is highlighted */\n    this.onTextHighlightObservable = new Observable();\n    /**Observable raised when copy event is triggered */\n    this.onTextCopyObservable = new Observable();\n    /** Observable raised when cut event is triggered */\n    this.onTextCutObservable = new Observable();\n    /** Observable raised when paste event is triggered */\n    this.onTextPasteObservable = new Observable();\n    /** Observable raised when a key event was processed */\n    this.onKeyboardEventProcessedObservable = new Observable();\n    this.text = text;\n    this.isPointerBlocker = true;\n  }\n  /** @internal */\n  onBlur() {\n    this._isFocused = false;\n    this._scrollLeft = null;\n    this._cursorOffset = 0;\n    clearTimeout(this._blinkTimeout);\n    this._markAsDirty();\n    this.onBlurObservable.notifyObservers(this);\n    this._host.unRegisterClipboardEvents();\n    if (this._onClipboardObserver) {\n      this._host.onClipboardObservable.remove(this._onClipboardObserver);\n    }\n    const scene = this._host.getScene();\n    if (this._onPointerDblTapObserver && scene) {\n      scene.onPointerObservable.remove(this._onPointerDblTapObserver);\n    }\n  }\n  /** @internal */\n  onFocus() {\n    if (!this._isEnabled) {\n      return;\n    }\n    this._scrollLeft = null;\n    this._isFocused = true;\n    this._blinkIsEven = false;\n    this._cursorOffset = 0;\n    this._markAsDirty();\n    this.onFocusObservable.notifyObservers(this);\n    if (this._focusedBy === \"touch\" && !this.disableMobilePrompt) {\n      const value = prompt(this.promptMessage);\n      if (value !== null) {\n        this.text = value;\n      }\n      this._host.focusedControl = null;\n      return;\n    }\n    this._host.registerClipboardEvents();\n    this._onClipboardObserver = this._host.onClipboardObservable.add(clipboardInfo => {\n      // process clipboard event, can be configured.\n      switch (clipboardInfo.type) {\n        case ClipboardEventTypes.COPY:\n          this._onCopyText(clipboardInfo.event);\n          this.onTextCopyObservable.notifyObservers(this);\n          break;\n        case ClipboardEventTypes.CUT:\n          this._onCutText(clipboardInfo.event);\n          this.onTextCutObservable.notifyObservers(this);\n          break;\n        case ClipboardEventTypes.PASTE:\n          this._onPasteText(clipboardInfo.event);\n          this.onTextPasteObservable.notifyObservers(this);\n          break;\n        default:\n          return;\n      }\n    });\n    const scene = this._host.getScene();\n    if (scene) {\n      //register the pointer double tap event\n      this._onPointerDblTapObserver = scene.onPointerObservable.add(pointerInfo => {\n        if (!this._isFocused) {\n          return;\n        }\n        if (pointerInfo.type === PointerEventTypes.POINTERDOUBLETAP) {\n          this._processDblClick(pointerInfo);\n        }\n      });\n    }\n    if (this._onFocusSelectAll) {\n      this._selectAllText();\n    }\n  }\n  /**\n   * Function to focus an inputText programmatically\n   */\n  focus() {\n    this._host.moveFocusToControl(this);\n  }\n  /**\n   * Function to unfocus an inputText programmatically\n   */\n  blur() {\n    this._host.focusedControl = null;\n  }\n  _getTypeName() {\n    return \"InputText\";\n  }\n  /**\n   * Function called to get the list of controls that should not steal the focus from this control\n   * @returns an array of controls\n   */\n  keepsFocusWith() {\n    if (!this._connectedVirtualKeyboard) {\n      return null;\n    }\n    return [this._connectedVirtualKeyboard];\n  }\n  /**\n   * @internal\n   */\n  processKey(keyCode, key, evt) {\n    var _a;\n    if (this.isReadOnly) {\n      return;\n    }\n    //return if clipboard event keys (i.e -ctr/cmd + c,v,x)\n    if (evt && (evt.ctrlKey || evt.metaKey) && (keyCode === 67 || keyCode === 86 || keyCode === 88)) {\n      return;\n    }\n    //select all\n    if (evt && (evt.ctrlKey || evt.metaKey) && keyCode === 65) {\n      this._selectAllText();\n      evt.preventDefault();\n      return;\n    }\n    // Specific cases\n    switch (keyCode) {\n      case 32:\n        //SPACE\n        key = \" \"; //ie11 key for space is \"Spacebar\"\n        break;\n      case 191:\n        //SLASH\n        if (evt) {\n          evt.preventDefault();\n        }\n        break;\n      case 8:\n        // BACKSPACE\n        if (this._textWrapper.text && this._textWrapper.length > 0) {\n          //delete the highlighted text\n          if (this.isTextHighlightOn) {\n            this._textWrapper.removePart(this._startHighlightIndex, this._endHighlightIndex);\n            this._textHasChanged();\n            this.isTextHighlightOn = false;\n            this._cursorOffset = this._textWrapper.length - this._startHighlightIndex;\n            this._blinkIsEven = false;\n            if (evt) {\n              evt.preventDefault();\n            }\n            return;\n          }\n          //delete single character\n          if (this._cursorOffset === 0) {\n            this.text = this._textWrapper.substr(0, this._textWrapper.length - 1);\n          } else {\n            const deletePosition = this._textWrapper.length - this._cursorOffset;\n            if (deletePosition > 0) {\n              this._textWrapper.removePart(deletePosition - 1, deletePosition);\n              this._textHasChanged();\n            }\n          }\n        }\n        if (evt) {\n          evt.preventDefault();\n        }\n        return;\n      case 46:\n        // DELETE\n        if (this.isTextHighlightOn) {\n          this._textWrapper.removePart(this._startHighlightIndex, this._endHighlightIndex);\n          this._textHasChanged();\n          this.isTextHighlightOn = false;\n          this._cursorOffset = this._textWrapper.length - this._startHighlightIndex;\n          if (evt) {\n            evt.preventDefault();\n          }\n          return;\n        }\n        if (this._textWrapper.text && this._textWrapper.length > 0 && this._cursorOffset > 0) {\n          const deletePosition = this._textWrapper.length - this._cursorOffset;\n          this._textWrapper.removePart(deletePosition, deletePosition + 1);\n          this._textHasChanged();\n          this._cursorOffset--;\n        }\n        if (evt) {\n          evt.preventDefault();\n        }\n        return;\n      case 13:\n        // RETURN\n        this._host.focusedControl = null;\n        this.isTextHighlightOn = false;\n        return;\n      case 35:\n        // END\n        this._cursorOffset = 0;\n        this._blinkIsEven = false;\n        this.isTextHighlightOn = false;\n        this._markAsDirty();\n        return;\n      case 36:\n        // HOME\n        this._cursorOffset = this._textWrapper.length;\n        this._blinkIsEven = false;\n        this.isTextHighlightOn = false;\n        this._markAsDirty();\n        return;\n      case 37:\n        // LEFT\n        this._cursorOffset++;\n        if (this._cursorOffset > this._textWrapper.length) {\n          this._cursorOffset = this._textWrapper.length;\n        }\n        if (evt && evt.shiftKey) {\n          // update the cursor\n          this._blinkIsEven = false;\n          // shift + ctrl/cmd + <-\n          if (evt.ctrlKey || evt.metaKey) {\n            if (!this.isTextHighlightOn) {\n              if (this._textWrapper.length === this._cursorOffset) {\n                return;\n              } else {\n                this._endHighlightIndex = this._textWrapper.length - this._cursorOffset + 1;\n              }\n            }\n            this._startHighlightIndex = 0;\n            this._cursorIndex = this._textWrapper.length - this._endHighlightIndex;\n            this._cursorOffset = this._textWrapper.length;\n            this.isTextHighlightOn = true;\n            this._markAsDirty();\n            return;\n          }\n          //store the starting point\n          if (!this.isTextHighlightOn) {\n            this.isTextHighlightOn = true;\n            this._cursorIndex = this._cursorOffset >= this._textWrapper.length ? this._textWrapper.length : this._cursorOffset - 1;\n          }\n          //if text is already highlighted\n          else if (this._cursorIndex === -1) {\n            this._cursorIndex = this._textWrapper.length - this._endHighlightIndex;\n            this._cursorOffset = this._startHighlightIndex === 0 ? this._textWrapper.length : this._textWrapper.length - this._startHighlightIndex + 1;\n          }\n          //set the highlight indexes\n          if (this._cursorIndex < this._cursorOffset) {\n            this._endHighlightIndex = this._textWrapper.length - this._cursorIndex;\n            this._startHighlightIndex = this._textWrapper.length - this._cursorOffset;\n          } else if (this._cursorIndex > this._cursorOffset) {\n            this._endHighlightIndex = this._textWrapper.length - this._cursorOffset;\n            this._startHighlightIndex = this._textWrapper.length - this._cursorIndex;\n          } else {\n            this.isTextHighlightOn = false;\n          }\n          this._markAsDirty();\n          return;\n        }\n        if (this.isTextHighlightOn) {\n          this._cursorOffset = this._textWrapper.length - this._startHighlightIndex;\n          this.isTextHighlightOn = false;\n        }\n        if (evt && (evt.ctrlKey || evt.metaKey)) {\n          this._cursorOffset = this._textWrapper.length;\n          evt.preventDefault();\n        }\n        this._blinkIsEven = false;\n        this.isTextHighlightOn = false;\n        this._cursorIndex = -1;\n        this._markAsDirty();\n        return;\n      case 39:\n        // RIGHT\n        this._cursorOffset--;\n        if (this._cursorOffset < 0) {\n          this._cursorOffset = 0;\n        }\n        if (evt && evt.shiftKey) {\n          //update the cursor\n          this._blinkIsEven = false;\n          //shift + ctrl/cmd + ->\n          if (evt.ctrlKey || evt.metaKey) {\n            if (!this.isTextHighlightOn) {\n              if (this._cursorOffset === 0) {\n                return;\n              } else {\n                this._startHighlightIndex = this._textWrapper.length - this._cursorOffset - 1;\n              }\n            }\n            this._endHighlightIndex = this._textWrapper.length;\n            this.isTextHighlightOn = true;\n            this._cursorIndex = this._textWrapper.length - this._startHighlightIndex;\n            this._cursorOffset = 0;\n            this._markAsDirty();\n            return;\n          }\n          if (!this.isTextHighlightOn) {\n            this.isTextHighlightOn = true;\n            this._cursorIndex = this._cursorOffset <= 0 ? 0 : this._cursorOffset + 1;\n          }\n          //if text is already highlighted\n          else if (this._cursorIndex === -1) {\n            this._cursorIndex = this._textWrapper.length - this._startHighlightIndex;\n            this._cursorOffset = this._textWrapper.length === this._endHighlightIndex ? 0 : this._textWrapper.length - this._endHighlightIndex - 1;\n          }\n          //set the highlight indexes\n          if (this._cursorIndex < this._cursorOffset) {\n            this._endHighlightIndex = this._textWrapper.length - this._cursorIndex;\n            this._startHighlightIndex = this._textWrapper.length - this._cursorOffset;\n          } else if (this._cursorIndex > this._cursorOffset) {\n            this._endHighlightIndex = this._textWrapper.length - this._cursorOffset;\n            this._startHighlightIndex = this._textWrapper.length - this._cursorIndex;\n          } else {\n            this.isTextHighlightOn = false;\n          }\n          this._markAsDirty();\n          return;\n        }\n        if (this.isTextHighlightOn) {\n          this._cursorOffset = this._textWrapper.length - this._endHighlightIndex;\n          this.isTextHighlightOn = false;\n        }\n        //ctr + ->\n        if (evt && (evt.ctrlKey || evt.metaKey)) {\n          this._cursorOffset = 0;\n          evt.preventDefault();\n        }\n        this._blinkIsEven = false;\n        this.isTextHighlightOn = false;\n        this._cursorIndex = -1;\n        this._markAsDirty();\n        return;\n    }\n    if (keyCode === 32) {\n      key = (_a = evt === null || evt === void 0 ? void 0 : evt.key) !== null && _a !== void 0 ? _a : \" \";\n    }\n    this._deadKey = key === \"Dead\";\n    // Printable characters\n    if (key && (keyCode === -1 ||\n    // Direct access\n    keyCode === 32 ||\n    // Space\n    keyCode === 34 ||\n    // \"    add support for single and double quotes\n    keyCode === 39 ||\n    // '\n    keyCode > 47 && keyCode < 64 ||\n    // Numbers\n    keyCode > 64 && keyCode < 91 ||\n    // Letters\n    keyCode > 159 && keyCode < 193 ||\n    // Special characters\n    keyCode > 218 && keyCode < 223 ||\n    // Special characters\n    keyCode > 95 && keyCode < 112)) {\n      // Numpad\n      this._currentKey = key;\n      this.onBeforeKeyAddObservable.notifyObservers(this);\n      key = this._currentKey;\n      if (this._addKey && !this._deadKey) {\n        if (this.isTextHighlightOn) {\n          this._textWrapper.removePart(this._startHighlightIndex, this._endHighlightIndex, key);\n          this._textHasChanged();\n          this._cursorOffset = this._textWrapper.length - (this._startHighlightIndex + 1);\n          this.isTextHighlightOn = false;\n          this._blinkIsEven = false;\n          this._markAsDirty();\n        } else if (this._cursorOffset === 0) {\n          this.text += this._deadKey && (evt === null || evt === void 0 ? void 0 : evt.key) ? evt.key : key;\n        } else {\n          const insertPosition = this._textWrapper.length - this._cursorOffset;\n          this._textWrapper.removePart(insertPosition, insertPosition, key);\n          this._textHasChanged();\n        }\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _updateValueFromCursorIndex(offset) {\n    //update the cursor\n    this._blinkIsEven = false;\n    if (this._cursorIndex === -1) {\n      this._cursorIndex = offset;\n    } else {\n      if (this._cursorIndex < this._cursorOffset) {\n        this._endHighlightIndex = this._textWrapper.length - this._cursorIndex;\n        this._startHighlightIndex = this._textWrapper.length - this._cursorOffset;\n      } else if (this._cursorIndex > this._cursorOffset) {\n        this._endHighlightIndex = this._textWrapper.length - this._cursorOffset;\n        this._startHighlightIndex = this._textWrapper.length - this._cursorIndex;\n      } else {\n        this.isTextHighlightOn = false;\n        this._markAsDirty();\n        return;\n      }\n    }\n    this.isTextHighlightOn = true;\n    this._markAsDirty();\n  }\n  /**\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _processDblClick(evt) {\n    //pre-find the start and end index of the word under cursor, speeds up the rendering\n    this._startHighlightIndex = this._textWrapper.length - this._cursorOffset;\n    this._endHighlightIndex = this._startHighlightIndex;\n    let moveLeft, moveRight;\n    do {\n      moveRight = this._endHighlightIndex < this._textWrapper.length && this._textWrapper.isWord(this._endHighlightIndex) ? ++this._endHighlightIndex : 0;\n      moveLeft = this._startHighlightIndex > 0 && this._textWrapper.isWord(this._startHighlightIndex - 1) ? --this._startHighlightIndex : 0;\n    } while (moveLeft || moveRight);\n    this._cursorOffset = this._textWrapper.length - this._startHighlightIndex;\n    this.isTextHighlightOn = true;\n    this._clickedCoordinate = null;\n    this._blinkIsEven = true;\n    this._cursorIndex = -1;\n    this._markAsDirty();\n  }\n  /** @internal */\n  _selectAllText() {\n    this._blinkIsEven = true;\n    this.isTextHighlightOn = true;\n    this._startHighlightIndex = 0;\n    this._endHighlightIndex = this._textWrapper.length;\n    this._cursorOffset = this._textWrapper.length;\n    this._cursorIndex = -1;\n    this._markAsDirty();\n  }\n  /**\n   * Handles the keyboard event\n   * @param evt Defines the KeyboardEvent\n   */\n  processKeyboard(evt) {\n    // process pressed key\n    this.processKey(evt.keyCode, evt.key, evt);\n    this.onKeyboardEventProcessedObservable.notifyObservers(evt);\n  }\n  /**\n   * @internal\n   */\n  _onCopyText(ev) {\n    this.isTextHighlightOn = false;\n    //when write permission to clipbaord data is denied\n    try {\n      ev.clipboardData && ev.clipboardData.setData(\"text/plain\", this._highlightedText);\n    } catch (_a) {} //pass\n    this._host.clipboardData = this._highlightedText;\n  }\n  /**\n   * @internal\n   */\n  _onCutText(ev) {\n    if (!this._highlightedText) {\n      return;\n    }\n    this._textWrapper.removePart(this._startHighlightIndex, this._endHighlightIndex);\n    this._textHasChanged();\n    this.isTextHighlightOn = false;\n    this._cursorOffset = this._textWrapper.length - this._startHighlightIndex;\n    //when write permission to clipbaord data is denied\n    try {\n      ev.clipboardData && ev.clipboardData.setData(\"text/plain\", this._highlightedText);\n    } catch (_a) {} //pass\n    this._host.clipboardData = this._highlightedText;\n    this._highlightedText = \"\";\n  }\n  /**\n   * @internal\n   */\n  _onPasteText(ev) {\n    let data = \"\";\n    if (ev.clipboardData && ev.clipboardData.types.indexOf(\"text/plain\") !== -1) {\n      data = ev.clipboardData.getData(\"text/plain\");\n    } else {\n      //get the cached data; returns blank string by default\n      data = this._host.clipboardData;\n    }\n    const insertPosition = this._textWrapper.length - this._cursorOffset;\n    this._textWrapper.removePart(insertPosition, insertPosition, data);\n    this._textHasChanged();\n  }\n  _draw(context) {\n    context.save();\n    this._applyStates(context);\n    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\n      context.shadowColor = this.shadowColor;\n      context.shadowBlur = this.shadowBlur;\n      context.shadowOffsetX = this.shadowOffsetX;\n      context.shadowOffsetY = this.shadowOffsetY;\n    }\n    // Background\n    if (this._isFocused) {\n      if (this._focusedBackground) {\n        context.fillStyle = this._isEnabled ? this._focusedBackground : this._disabledColor;\n        context.fillRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\n      }\n    } else if (this._background) {\n      context.fillStyle = this._isEnabled ? this._background : this._disabledColor;\n      context.fillRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\n    }\n    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\n      context.shadowBlur = 0;\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n    }\n    if (!this._fontOffset || this._wasDirty) {\n      this._fontOffset = Control._GetFontOffset(context.font);\n    }\n    // Text\n    const clipTextLeft = this._currentMeasure.left + this._margin.getValueInPixel(this._host, this._tempParentMeasure.width);\n    if (this.color) {\n      context.fillStyle = this.color;\n    }\n    let text = this._beforeRenderText(this._textWrapper);\n    if (!this._isFocused && !this._textWrapper.text && this._placeholderText) {\n      text = new TextWrapper();\n      text.text = this._placeholderText;\n      if (this._placeholderColor) {\n        context.fillStyle = this._placeholderColor;\n      }\n    }\n    this._textWidth = context.measureText(text.text).width;\n    const marginWidth = this._margin.getValueInPixel(this._host, this._tempParentMeasure.width) * 2;\n    if (this._autoStretchWidth) {\n      this.width = Math.min(this._maxWidth.getValueInPixel(this._host, this._tempParentMeasure.width), this._textWidth + marginWidth) + \"px\";\n      this._autoStretchWidth = true; // setting the width will have reset _autoStretchWidth to false!\n    }\n\n    const rootY = this._fontOffset.ascent + (this._currentMeasure.height - this._fontOffset.height) / 2;\n    const availableWidth = this._width.getValueInPixel(this._host, this._tempParentMeasure.width) - marginWidth;\n    context.save();\n    context.beginPath();\n    context.rect(clipTextLeft, this._currentMeasure.top + (this._currentMeasure.height - this._fontOffset.height) / 2, availableWidth + 2, this._currentMeasure.height);\n    context.clip();\n    if (this._isFocused && this._textWidth > availableWidth) {\n      const textLeft = clipTextLeft - this._textWidth + availableWidth;\n      if (!this._scrollLeft) {\n        this._scrollLeft = textLeft;\n      }\n    } else {\n      this._scrollLeft = clipTextLeft;\n    }\n    context.fillText(text.text, this._scrollLeft, this._currentMeasure.top + rootY);\n    // Cursor\n    if (this._isFocused) {\n      // Need to move cursor\n      if (this._clickedCoordinate) {\n        const rightPosition = this._scrollLeft + this._textWidth;\n        const absoluteCursorPosition = rightPosition - this._clickedCoordinate;\n        let currentSize = 0;\n        this._cursorOffset = 0;\n        let previousDist = 0;\n        do {\n          if (this._cursorOffset) {\n            previousDist = Math.abs(absoluteCursorPosition - currentSize);\n          }\n          this._cursorOffset++;\n          currentSize = context.measureText(text.substr(text.length - this._cursorOffset, this._cursorOffset)).width;\n        } while (currentSize < absoluteCursorPosition && text.length >= this._cursorOffset);\n        // Find closest move\n        if (Math.abs(absoluteCursorPosition - currentSize) > previousDist) {\n          this._cursorOffset--;\n        }\n        this._blinkIsEven = false;\n        this._clickedCoordinate = null;\n      }\n      // Render cursor\n      if (!this._blinkIsEven) {\n        const cursorOffsetText = text.substr(text.length - this._cursorOffset);\n        const cursorOffsetWidth = context.measureText(cursorOffsetText).width;\n        let cursorLeft = this._scrollLeft + this._textWidth - cursorOffsetWidth;\n        if (cursorLeft < clipTextLeft) {\n          this._scrollLeft += clipTextLeft - cursorLeft;\n          cursorLeft = clipTextLeft;\n          this._markAsDirty();\n        } else if (cursorLeft > clipTextLeft + availableWidth) {\n          this._scrollLeft += clipTextLeft + availableWidth - cursorLeft;\n          cursorLeft = clipTextLeft + availableWidth;\n          this._markAsDirty();\n        }\n        if (!this.isTextHighlightOn) {\n          context.fillRect(cursorLeft, this._currentMeasure.top + (this._currentMeasure.height - this._fontOffset.height) / 2, 2, this._fontOffset.height);\n        }\n      }\n      clearTimeout(this._blinkTimeout);\n      this._blinkTimeout = setTimeout(() => {\n        this._blinkIsEven = !this._blinkIsEven;\n        this._markAsDirty();\n      }, 500);\n      //show the highlighted text\n      if (this.isTextHighlightOn) {\n        clearTimeout(this._blinkTimeout);\n        const highlightCursorOffsetWidth = context.measureText(text.substring(this._startHighlightIndex)).width;\n        let highlightCursorLeft = this._scrollLeft + this._textWidth - highlightCursorOffsetWidth;\n        this._highlightedText = text.substring(this._startHighlightIndex, this._endHighlightIndex);\n        let width = context.measureText(text.substring(this._startHighlightIndex, this._endHighlightIndex)).width;\n        if (highlightCursorLeft < clipTextLeft) {\n          width = width - (clipTextLeft - highlightCursorLeft);\n          if (!width) {\n            // when using left arrow on text.length > availableWidth;\n            // assigns the width of the first letter after clipTextLeft\n            width = context.measureText(text.charAt(text.length - this._cursorOffset)).width;\n          }\n          highlightCursorLeft = clipTextLeft;\n        }\n        //for transparancy\n        context.globalAlpha = this._highligherOpacity;\n        context.fillStyle = this._textHighlightColor;\n        context.fillRect(highlightCursorLeft, this._currentMeasure.top + (this._currentMeasure.height - this._fontOffset.height) / 2, width, this._fontOffset.height);\n        context.globalAlpha = 1.0;\n      }\n    }\n    context.restore();\n    // Border\n    if (this._thickness) {\n      if (this._isFocused) {\n        if (this.focusedColor) {\n          context.strokeStyle = this.focusedColor;\n        }\n      } else {\n        if (this.color) {\n          context.strokeStyle = this.color;\n        }\n      }\n      context.lineWidth = this._thickness;\n      context.strokeRect(this._currentMeasure.left + this._thickness / 2, this._currentMeasure.top + this._thickness / 2, this._currentMeasure.width - this._thickness, this._currentMeasure.height - this._thickness);\n    }\n    context.restore();\n  }\n  _onPointerDown(target, coordinates, pointerId, buttonIndex, pi) {\n    if (!super._onPointerDown(target, coordinates, pointerId, buttonIndex, pi)) {\n      return false;\n    }\n    if (this.isReadOnly) {\n      return true;\n    }\n    this._clickedCoordinate = coordinates.x;\n    this.isTextHighlightOn = false;\n    this._highlightedText = \"\";\n    this._cursorIndex = -1;\n    this._isPointerDown = true;\n    this._host._capturingControl[pointerId] = this;\n    this._focusedBy = pi.event.pointerType;\n    if (this._host.focusedControl === this) {\n      // Move cursor\n      clearTimeout(this._blinkTimeout);\n      this._markAsDirty();\n      return true;\n    }\n    if (!this._isEnabled) {\n      return false;\n    }\n    this._host.focusedControl = this;\n    return true;\n  }\n  _onPointerMove(target, coordinates, pointerId, pi) {\n    if (this._host.focusedControl === this && this._isPointerDown && !this.isReadOnly) {\n      this._clickedCoordinate = coordinates.x;\n      this._markAsDirty();\n      this._updateValueFromCursorIndex(this._cursorOffset);\n    }\n    super._onPointerMove(target, coordinates, pointerId, pi);\n  }\n  _onPointerUp(target, coordinates, pointerId, buttonIndex, notifyClick) {\n    this._isPointerDown = false;\n    delete this._host._capturingControl[pointerId];\n    super._onPointerUp(target, coordinates, pointerId, buttonIndex, notifyClick);\n  }\n  _beforeRenderText(textWrapper) {\n    return textWrapper;\n  }\n  /** @internal */\n  set isTextHighlightOn(value) {\n    if (this._isTextHighlightOn === value) {\n      return;\n    }\n    if (value) {\n      this.onTextHighlightObservable.notifyObservers(this);\n    }\n    this._isTextHighlightOn = value;\n  }\n  /** @internal */\n  get isTextHighlightOn() {\n    return this._isTextHighlightOn;\n  }\n  dispose() {\n    super.dispose();\n    this.onBlurObservable.clear();\n    this.onFocusObservable.clear();\n    this.onTextChangedObservable.clear();\n    this.onTextCopyObservable.clear();\n    this.onTextCutObservable.clear();\n    this.onTextPasteObservable.clear();\n    this.onTextHighlightObservable.clear();\n    this.onKeyboardEventProcessedObservable.clear();\n  }\n}\n__decorate([serialize()], InputText.prototype, \"promptMessage\", void 0);\n__decorate([serialize()], InputText.prototype, \"disableMobilePrompt\", void 0);\n__decorate([serialize()], InputText.prototype, \"maxWidth\", null);\n__decorate([serialize()], InputText.prototype, \"highligherOpacity\", null);\n__decorate([serialize()], InputText.prototype, \"onFocusSelectAll\", null);\n__decorate([serialize()], InputText.prototype, \"textHighlightColor\", null);\n__decorate([serialize()], InputText.prototype, \"margin\", null);\n__decorate([serialize()], InputText.prototype, \"autoStretchWidth\", null);\n__decorate([serialize()], InputText.prototype, \"thickness\", null);\n__decorate([serialize()], InputText.prototype, \"focusedBackground\", null);\n__decorate([serialize()], InputText.prototype, \"focusedColor\", null);\n__decorate([serialize()], InputText.prototype, \"background\", null);\n__decorate([serialize()], InputText.prototype, \"placeholderColor\", null);\n__decorate([serialize()], InputText.prototype, \"placeholderText\", null);\n__decorate([serialize()], InputText.prototype, \"deadKey\", null);\n__decorate([serialize()], InputText.prototype, \"text\", null);\n__decorate([serialize()], InputText.prototype, \"width\", null);\nRegisterClass(\"BABYLON.GUI.InputText\", InputText);","map":{"version":3,"names":["Observable","ClipboardEventTypes","PointerEventTypes","Control","ValueAndUnit","RegisterClass","TextWrapper","serialize","InputText","maxWidth","_maxWidth","toString","_host","maxWidthInPixels","getValueInPixel","_cachedParentMeasure","width","value","fromString","_markAsDirty","highligherOpacity","_highligherOpacity","onFocusSelectAll","_onFocusSelectAll","textHighlightColor","_textHighlightColor","margin","_margin","marginInPixels","autoStretchWidth","_autoStretchWidth","thickness","_thickness","focusedBackground","_focusedBackground","focusedColor","_focusedColor","background","_background","placeholderColor","_placeholderColor","placeholderText","_placeholderText","deadKey","_deadKey","flag","highlightedText","_highlightedText","text","addKey","_addKey","currentKey","_currentKey","key","_textWrapper","valueAsString","_textHasChanged","onTextChangedObservable","notifyObservers","_width","constructor","name","UNITMODE_PIXEL","UNITMODE_PERCENTAGE","_isFocused","_blinkIsEven","_cursorOffset","_isTextHighlightOn","_startHighlightIndex","_endHighlightIndex","_cursorIndex","_isPointerDown","promptMessage","disableMobilePrompt","onBeforeKeyAddObservable","onFocusObservable","onBlurObservable","onTextHighlightObservable","onTextCopyObservable","onTextCutObservable","onTextPasteObservable","onKeyboardEventProcessedObservable","isPointerBlocker","onBlur","_scrollLeft","clearTimeout","_blinkTimeout","unRegisterClipboardEvents","_onClipboardObserver","onClipboardObservable","remove","scene","getScene","_onPointerDblTapObserver","onPointerObservable","onFocus","_isEnabled","_focusedBy","prompt","focusedControl","registerClipboardEvents","add","clipboardInfo","type","COPY","_onCopyText","event","CUT","_onCutText","PASTE","_onPasteText","pointerInfo","POINTERDOUBLETAP","_processDblClick","_selectAllText","focus","moveFocusToControl","blur","_getTypeName","keepsFocusWith","_connectedVirtualKeyboard","processKey","keyCode","evt","isReadOnly","ctrlKey","metaKey","preventDefault","length","isTextHighlightOn","removePart","substr","deletePosition","shiftKey","_a","insertPosition","_updateValueFromCursorIndex","offset","moveLeft","moveRight","isWord","_clickedCoordinate","processKeyboard","ev","clipboardData","setData","data","types","indexOf","getData","_draw","context","save","_applyStates","shadowBlur","shadowOffsetX","shadowOffsetY","shadowColor","fillStyle","_disabledColor","fillRect","_currentMeasure","left","top","height","_fontOffset","_wasDirty","_GetFontOffset","font","clipTextLeft","_tempParentMeasure","color","_beforeRenderText","_textWidth","measureText","marginWidth","Math","min","rootY","ascent","availableWidth","beginPath","rect","clip","textLeft","fillText","rightPosition","absoluteCursorPosition","currentSize","previousDist","abs","cursorOffsetText","cursorOffsetWidth","cursorLeft","setTimeout","highlightCursorOffsetWidth","substring","highlightCursorLeft","charAt","globalAlpha","restore","strokeStyle","lineWidth","strokeRect","_onPointerDown","target","coordinates","pointerId","buttonIndex","pi","x","_capturingControl","pointerType","_onPointerMove","_onPointerUp","notifyClick","textWrapper","dispose","clear","__decorate"],"sources":["../../../../../dev/gui/src/2D/controls/inputText.ts"],"sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport type { Vector2 } from \"core/Maths/math.vector\";\r\nimport type { ClipboardInfo } from \"core/Events/clipboardEvents\";\r\nimport { ClipboardEventTypes } from \"core/Events/clipboardEvents\";\r\nimport type { PointerInfo, PointerInfoBase } from \"core/Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"core/Events/pointerEvents\";\r\n\r\nimport { Control } from \"./control\";\r\nimport type { IFocusableControl } from \"./focusableControl\";\r\nimport { ValueAndUnit } from \"../valueAndUnit\";\r\nimport type { VirtualKeyboard } from \"./virtualKeyboard\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { TextWrapper } from \"./textWrapper\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport type { IKeyboardEvent, IPointerEvent } from \"core/Events/deviceInputEvents\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\n\r\n/**\r\n * Class used to create input text control\r\n */\r\nexport class InputText extends Control implements IFocusableControl {\r\n    protected _textWrapper: TextWrapper;\r\n    protected _placeholderText = \"\";\r\n    protected _background = \"#222222\";\r\n    protected _focusedBackground = \"#000000\";\r\n    protected _focusedColor = \"white\";\r\n    protected _placeholderColor = \"gray\";\r\n    protected _thickness = 1;\r\n    protected _margin = new ValueAndUnit(10, ValueAndUnit.UNITMODE_PIXEL);\r\n    protected _autoStretchWidth = true;\r\n    protected _maxWidth = new ValueAndUnit(1, ValueAndUnit.UNITMODE_PERCENTAGE, false);\r\n    protected _isFocused = false;\r\n    /** the type of device that most recently focused the input: \"mouse\", \"touch\" or \"pen\" */\r\n    protected _focusedBy: string;\r\n    protected _blinkTimeout: number;\r\n    protected _blinkIsEven = false;\r\n    private _cursorOffset = 0;\r\n    protected _scrollLeft: Nullable<number>;\r\n    protected _textWidth: number;\r\n    protected _clickedCoordinate: Nullable<number>;\r\n    protected _deadKey = false;\r\n    protected _addKey = true;\r\n    protected _currentKey = \"\";\r\n    protected _isTextHighlightOn = false;\r\n    protected _textHighlightColor = \"#d5e0ff\";\r\n    protected _highligherOpacity = 0.4;\r\n    protected _highlightedText = \"\";\r\n    private _startHighlightIndex = 0;\r\n    private _endHighlightIndex = 0;\r\n    private _cursorIndex = -1;\r\n    protected _onFocusSelectAll = false;\r\n    protected _isPointerDown = false;\r\n    protected _onClipboardObserver: Nullable<Observer<ClipboardInfo>>;\r\n    protected _onPointerDblTapObserver: Nullable<Observer<PointerInfo>>;\r\n\r\n    /** @internal */\r\n    public _connectedVirtualKeyboard: Nullable<VirtualKeyboard>;\r\n\r\n    /** Gets or sets a string representing the message displayed on mobile when the control gets the focus */\r\n    @serialize()\r\n    public promptMessage = \"Please enter text:\";\r\n    /** Force disable prompt on mobile device */\r\n    @serialize()\r\n    public disableMobilePrompt = false;\r\n\r\n    /** Observable raised when the text changes */\r\n    public onTextChangedObservable = new Observable<InputText>();\r\n    /** Observable raised just before an entered character is to be added */\r\n    public onBeforeKeyAddObservable = new Observable<InputText>();\r\n    /** Observable raised when the control gets the focus */\r\n    public onFocusObservable = new Observable<InputText>();\r\n    /** Observable raised when the control loses the focus */\r\n    public onBlurObservable = new Observable<InputText>();\r\n    /**Observable raised when the text is highlighted */\r\n    public onTextHighlightObservable = new Observable<InputText>();\r\n    /**Observable raised when copy event is triggered */\r\n    public onTextCopyObservable = new Observable<InputText>();\r\n    /** Observable raised when cut event is triggered */\r\n    public onTextCutObservable = new Observable<InputText>();\r\n    /** Observable raised when paste event is triggered */\r\n    public onTextPasteObservable = new Observable<InputText>();\r\n    /** Observable raised when a key event was processed */\r\n    public onKeyboardEventProcessedObservable = new Observable<IKeyboardEvent>();\r\n\r\n    /** Gets or sets the maximum width allowed by the control */\r\n    @serialize()\r\n    public get maxWidth(): string | number {\r\n        return this._maxWidth.toString(this._host);\r\n    }\r\n\r\n    /** Gets the maximum width allowed by the control in pixels */\r\n    public get maxWidthInPixels(): number {\r\n        return this._maxWidth.getValueInPixel(this._host, this._cachedParentMeasure.width);\r\n    }\r\n\r\n    public set maxWidth(value: string | number) {\r\n        if (this._maxWidth.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._maxWidth.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /** Gets or sets the text highlighter transparency; default: 0.4 */\r\n    @serialize()\r\n    public get highligherOpacity(): number {\r\n        return this._highligherOpacity;\r\n    }\r\n\r\n    public set highligherOpacity(value: number) {\r\n        if (this._highligherOpacity === value) {\r\n            return;\r\n        }\r\n        this._highligherOpacity = value;\r\n        this._markAsDirty();\r\n    }\r\n    /** Gets or sets a boolean indicating whether to select complete text by default on input focus */\r\n    @serialize()\r\n    public get onFocusSelectAll(): boolean {\r\n        return this._onFocusSelectAll;\r\n    }\r\n\r\n    public set onFocusSelectAll(value: boolean) {\r\n        if (this._onFocusSelectAll === value) {\r\n            return;\r\n        }\r\n\r\n        this._onFocusSelectAll = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the text hightlight color */\r\n    @serialize()\r\n    public get textHighlightColor(): string {\r\n        return this._textHighlightColor;\r\n    }\r\n\r\n    public set textHighlightColor(value: string) {\r\n        if (this._textHighlightColor === value) {\r\n            return;\r\n        }\r\n        this._textHighlightColor = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets control margin */\r\n    @serialize()\r\n    public get margin(): string {\r\n        return this._margin.toString(this._host);\r\n    }\r\n\r\n    /** Gets control margin in pixels */\r\n    public get marginInPixels(): number {\r\n        return this._margin.getValueInPixel(this._host, this._cachedParentMeasure.width);\r\n    }\r\n\r\n    public set margin(value: string) {\r\n        if (this._margin.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._margin.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if the control can auto stretch its width to adapt to the text */\r\n    @serialize()\r\n    public get autoStretchWidth(): boolean {\r\n        return this._autoStretchWidth;\r\n    }\r\n\r\n    public set autoStretchWidth(value: boolean) {\r\n        if (this._autoStretchWidth === value) {\r\n            return;\r\n        }\r\n\r\n        this._autoStretchWidth = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets border thickness */\r\n    @serialize()\r\n    public get thickness(): number {\r\n        return this._thickness;\r\n    }\r\n\r\n    public set thickness(value: number) {\r\n        if (this._thickness === value) {\r\n            return;\r\n        }\r\n\r\n        this._thickness = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the background color when focused */\r\n    @serialize()\r\n    public get focusedBackground(): string {\r\n        return this._focusedBackground;\r\n    }\r\n\r\n    public set focusedBackground(value: string) {\r\n        if (this._focusedBackground === value) {\r\n            return;\r\n        }\r\n\r\n        this._focusedBackground = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the background color when focused */\r\n    @serialize()\r\n    public get focusedColor(): string {\r\n        return this._focusedColor;\r\n    }\r\n\r\n    public set focusedColor(value: string) {\r\n        if (this._focusedColor === value) {\r\n            return;\r\n        }\r\n\r\n        this._focusedColor = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the background color */\r\n    @serialize()\r\n    public get background(): string {\r\n        return this._background;\r\n    }\r\n\r\n    public set background(value: string) {\r\n        if (this._background === value) {\r\n            return;\r\n        }\r\n\r\n        this._background = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the placeholder color */\r\n    @serialize()\r\n    public get placeholderColor(): string {\r\n        return this._placeholderColor;\r\n    }\r\n\r\n    public set placeholderColor(value: string) {\r\n        if (this._placeholderColor === value) {\r\n            return;\r\n        }\r\n\r\n        this._placeholderColor = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the text displayed when the control is empty */\r\n    @serialize()\r\n    public get placeholderText(): string {\r\n        return this._placeholderText;\r\n    }\r\n\r\n    public set placeholderText(value: string) {\r\n        if (this._placeholderText === value) {\r\n            return;\r\n        }\r\n        this._placeholderText = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the dead key. 0 to disable. */\r\n    @serialize()\r\n    public get deadKey(): boolean {\r\n        return this._deadKey;\r\n    }\r\n\r\n    public set deadKey(flag: boolean) {\r\n        this._deadKey = flag;\r\n    }\r\n\r\n    /** Gets or sets the highlight text */\r\n    public get highlightedText(): string {\r\n        return this._highlightedText;\r\n    }\r\n    public set highlightedText(text: string) {\r\n        if (this._highlightedText === text) {\r\n            return;\r\n        }\r\n        this._highlightedText = text;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets if the current key should be added */\r\n    public get addKey(): boolean {\r\n        return this._addKey;\r\n    }\r\n\r\n    public set addKey(flag: boolean) {\r\n        this._addKey = flag;\r\n    }\r\n\r\n    /** Gets or sets the value of the current key being entered */\r\n    public get currentKey(): string {\r\n        return this._currentKey;\r\n    }\r\n\r\n    public set currentKey(key: string) {\r\n        this._currentKey = key;\r\n    }\r\n\r\n    /** Gets or sets the text displayed in the control */\r\n    @serialize()\r\n    public get text(): string {\r\n        return this._textWrapper.text;\r\n    }\r\n\r\n    public set text(value: string) {\r\n        const valueAsString = value.toString(); // Forcing convertion\r\n\r\n        if (!this._textWrapper) {\r\n            this._textWrapper = new TextWrapper();\r\n        }\r\n\r\n        if (this._textWrapper.text === valueAsString) {\r\n            return;\r\n        }\r\n        this._textWrapper.text = valueAsString;\r\n        this._textHasChanged();\r\n    }\r\n\r\n    protected _textHasChanged(): void {\r\n        this._markAsDirty();\r\n        this.onTextChangedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /** Gets or sets control width */\r\n    @serialize()\r\n    public get width(): string | number {\r\n        return this._width.toString(this._host);\r\n    }\r\n\r\n    public set width(value: string | number) {\r\n        if (this._width.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._width.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n\r\n        this.autoStretchWidth = false;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InputText\r\n     * @param name defines the control name\r\n     * @param text defines the text of the control\r\n     */\r\n    constructor(public name?: string, text: string = \"\") {\r\n        super(name);\r\n\r\n        this.text = text;\r\n        this.isPointerBlocker = true;\r\n    }\r\n\r\n    /** @internal */\r\n    public onBlur(): void {\r\n        this._isFocused = false;\r\n        this._scrollLeft = null;\r\n        this._cursorOffset = 0;\r\n        clearTimeout(this._blinkTimeout);\r\n        this._markAsDirty();\r\n\r\n        this.onBlurObservable.notifyObservers(this);\r\n\r\n        this._host.unRegisterClipboardEvents();\r\n        if (this._onClipboardObserver) {\r\n            this._host.onClipboardObservable.remove(this._onClipboardObserver);\r\n        }\r\n        const scene = this._host.getScene();\r\n        if (this._onPointerDblTapObserver && scene) {\r\n            scene.onPointerObservable.remove(this._onPointerDblTapObserver);\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public onFocus(): void {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n        this._scrollLeft = null;\r\n        this._isFocused = true;\r\n        this._blinkIsEven = false;\r\n        this._cursorOffset = 0;\r\n        this._markAsDirty();\r\n\r\n        this.onFocusObservable.notifyObservers(this);\r\n\r\n        if (this._focusedBy === \"touch\" && !this.disableMobilePrompt) {\r\n            const value = prompt(this.promptMessage);\r\n\r\n            if (value !== null) {\r\n                this.text = value;\r\n            }\r\n            this._host.focusedControl = null;\r\n            return;\r\n        }\r\n\r\n        this._host.registerClipboardEvents();\r\n\r\n        this._onClipboardObserver = this._host.onClipboardObservable.add((clipboardInfo) => {\r\n            // process clipboard event, can be configured.\r\n            switch (clipboardInfo.type) {\r\n                case ClipboardEventTypes.COPY:\r\n                    this._onCopyText(clipboardInfo.event);\r\n                    this.onTextCopyObservable.notifyObservers(this);\r\n                    break;\r\n                case ClipboardEventTypes.CUT:\r\n                    this._onCutText(clipboardInfo.event);\r\n                    this.onTextCutObservable.notifyObservers(this);\r\n                    break;\r\n                case ClipboardEventTypes.PASTE:\r\n                    this._onPasteText(clipboardInfo.event);\r\n                    this.onTextPasteObservable.notifyObservers(this);\r\n                    break;\r\n                default:\r\n                    return;\r\n            }\r\n        });\r\n\r\n        const scene = this._host.getScene();\r\n        if (scene) {\r\n            //register the pointer double tap event\r\n            this._onPointerDblTapObserver = scene.onPointerObservable.add((pointerInfo) => {\r\n                if (!this._isFocused) {\r\n                    return;\r\n                }\r\n                if (pointerInfo.type === PointerEventTypes.POINTERDOUBLETAP) {\r\n                    this._processDblClick(pointerInfo);\r\n                }\r\n            });\r\n        }\r\n\r\n        if (this._onFocusSelectAll) {\r\n            this._selectAllText();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function to focus an inputText programmatically\r\n     */\r\n    public focus() {\r\n        this._host.moveFocusToControl(this);\r\n    }\r\n\r\n    /**\r\n     * Function to unfocus an inputText programmatically\r\n     */\r\n    public blur() {\r\n        this._host.focusedControl = null;\r\n    }\r\n\r\n    protected _getTypeName(): string {\r\n        return \"InputText\";\r\n    }\r\n\r\n    /**\r\n     * Function called to get the list of controls that should not steal the focus from this control\r\n     * @returns an array of controls\r\n     */\r\n    public keepsFocusWith(): Nullable<Control[]> {\r\n        if (!this._connectedVirtualKeyboard) {\r\n            return null;\r\n        }\r\n        return [this._connectedVirtualKeyboard];\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public processKey(keyCode: number, key?: string, evt?: IKeyboardEvent) {\r\n        if (this.isReadOnly) {\r\n            return;\r\n        }\r\n\r\n        //return if clipboard event keys (i.e -ctr/cmd + c,v,x)\r\n        if (evt && (evt.ctrlKey || evt.metaKey) && (keyCode === 67 || keyCode === 86 || keyCode === 88)) {\r\n            return;\r\n        }\r\n\r\n        //select all\r\n        if (evt && (evt.ctrlKey || evt.metaKey) && keyCode === 65) {\r\n            this._selectAllText();\r\n            evt.preventDefault();\r\n            return;\r\n        }\r\n        // Specific cases\r\n        switch (keyCode) {\r\n            case 32: //SPACE\r\n                key = \" \"; //ie11 key for space is \"Spacebar\"\r\n                break;\r\n            case 191: //SLASH\r\n                if (evt) {\r\n                    evt.preventDefault();\r\n                }\r\n                break;\r\n            case 8: // BACKSPACE\r\n                if (this._textWrapper.text && this._textWrapper.length > 0) {\r\n                    //delete the highlighted text\r\n                    if (this.isTextHighlightOn) {\r\n                        this._textWrapper.removePart(this._startHighlightIndex, this._endHighlightIndex);\r\n                        this._textHasChanged();\r\n                        this.isTextHighlightOn = false;\r\n                        this._cursorOffset = this._textWrapper.length - this._startHighlightIndex;\r\n                        this._blinkIsEven = false;\r\n                        if (evt) {\r\n                            evt.preventDefault();\r\n                        }\r\n                        return;\r\n                    }\r\n                    //delete single character\r\n                    if (this._cursorOffset === 0) {\r\n                        this.text = this._textWrapper.substr(0, this._textWrapper.length - 1);\r\n                    } else {\r\n                        const deletePosition = this._textWrapper.length - this._cursorOffset;\r\n                        if (deletePosition > 0) {\r\n                            this._textWrapper.removePart(deletePosition - 1, deletePosition);\r\n                            this._textHasChanged();\r\n                        }\r\n                    }\r\n                }\r\n                if (evt) {\r\n                    evt.preventDefault();\r\n                }\r\n                return;\r\n            case 46: // DELETE\r\n                if (this.isTextHighlightOn) {\r\n                    this._textWrapper.removePart(this._startHighlightIndex, this._endHighlightIndex);\r\n                    this._textHasChanged();\r\n                    this.isTextHighlightOn = false;\r\n                    this._cursorOffset = this._textWrapper.length - this._startHighlightIndex;\r\n                    if (evt) {\r\n                        evt.preventDefault();\r\n                    }\r\n                    return;\r\n                }\r\n                if (this._textWrapper.text && this._textWrapper.length > 0 && this._cursorOffset > 0) {\r\n                    const deletePosition = this._textWrapper.length - this._cursorOffset;\r\n                    this._textWrapper.removePart(deletePosition, deletePosition + 1);\r\n                    this._textHasChanged();\r\n                    this._cursorOffset--;\r\n                }\r\n                if (evt) {\r\n                    evt.preventDefault();\r\n                }\r\n                return;\r\n            case 13: // RETURN\r\n                this._host.focusedControl = null;\r\n                this.isTextHighlightOn = false;\r\n                return;\r\n            case 35: // END\r\n                this._cursorOffset = 0;\r\n                this._blinkIsEven = false;\r\n                this.isTextHighlightOn = false;\r\n                this._markAsDirty();\r\n                return;\r\n            case 36: // HOME\r\n                this._cursorOffset = this._textWrapper.length;\r\n                this._blinkIsEven = false;\r\n                this.isTextHighlightOn = false;\r\n                this._markAsDirty();\r\n                return;\r\n            case 37: // LEFT\r\n                this._cursorOffset++;\r\n                if (this._cursorOffset > this._textWrapper.length) {\r\n                    this._cursorOffset = this._textWrapper.length;\r\n                }\r\n\r\n                if (evt && evt.shiftKey) {\r\n                    // update the cursor\r\n                    this._blinkIsEven = false;\r\n                    // shift + ctrl/cmd + <-\r\n                    if (evt.ctrlKey || evt.metaKey) {\r\n                        if (!this.isTextHighlightOn) {\r\n                            if (this._textWrapper.length === this._cursorOffset) {\r\n                                return;\r\n                            } else {\r\n                                this._endHighlightIndex = this._textWrapper.length - this._cursorOffset + 1;\r\n                            }\r\n                        }\r\n                        this._startHighlightIndex = 0;\r\n                        this._cursorIndex = this._textWrapper.length - this._endHighlightIndex;\r\n                        this._cursorOffset = this._textWrapper.length;\r\n                        this.isTextHighlightOn = true;\r\n                        this._markAsDirty();\r\n                        return;\r\n                    }\r\n                    //store the starting point\r\n                    if (!this.isTextHighlightOn) {\r\n                        this.isTextHighlightOn = true;\r\n                        this._cursorIndex = this._cursorOffset >= this._textWrapper.length ? this._textWrapper.length : this._cursorOffset - 1;\r\n                    }\r\n                    //if text is already highlighted\r\n                    else if (this._cursorIndex === -1) {\r\n                        this._cursorIndex = this._textWrapper.length - this._endHighlightIndex;\r\n                        this._cursorOffset = this._startHighlightIndex === 0 ? this._textWrapper.length : this._textWrapper.length - this._startHighlightIndex + 1;\r\n                    }\r\n                    //set the highlight indexes\r\n                    if (this._cursorIndex < this._cursorOffset) {\r\n                        this._endHighlightIndex = this._textWrapper.length - this._cursorIndex;\r\n                        this._startHighlightIndex = this._textWrapper.length - this._cursorOffset;\r\n                    } else if (this._cursorIndex > this._cursorOffset) {\r\n                        this._endHighlightIndex = this._textWrapper.length - this._cursorOffset;\r\n                        this._startHighlightIndex = this._textWrapper.length - this._cursorIndex;\r\n                    } else {\r\n                        this.isTextHighlightOn = false;\r\n                    }\r\n                    this._markAsDirty();\r\n                    return;\r\n                }\r\n                if (this.isTextHighlightOn) {\r\n                    this._cursorOffset = this._textWrapper.length - this._startHighlightIndex;\r\n                    this.isTextHighlightOn = false;\r\n                }\r\n                if (evt && (evt.ctrlKey || evt.metaKey)) {\r\n                    this._cursorOffset = this._textWrapper.length;\r\n                    evt.preventDefault();\r\n                }\r\n                this._blinkIsEven = false;\r\n                this.isTextHighlightOn = false;\r\n                this._cursorIndex = -1;\r\n                this._markAsDirty();\r\n                return;\r\n            case 39: // RIGHT\r\n                this._cursorOffset--;\r\n                if (this._cursorOffset < 0) {\r\n                    this._cursorOffset = 0;\r\n                }\r\n                if (evt && evt.shiftKey) {\r\n                    //update the cursor\r\n                    this._blinkIsEven = false;\r\n                    //shift + ctrl/cmd + ->\r\n                    if (evt.ctrlKey || evt.metaKey) {\r\n                        if (!this.isTextHighlightOn) {\r\n                            if (this._cursorOffset === 0) {\r\n                                return;\r\n                            } else {\r\n                                this._startHighlightIndex = this._textWrapper.length - this._cursorOffset - 1;\r\n                            }\r\n                        }\r\n                        this._endHighlightIndex = this._textWrapper.length;\r\n                        this.isTextHighlightOn = true;\r\n                        this._cursorIndex = this._textWrapper.length - this._startHighlightIndex;\r\n                        this._cursorOffset = 0;\r\n                        this._markAsDirty();\r\n                        return;\r\n                    }\r\n\r\n                    if (!this.isTextHighlightOn) {\r\n                        this.isTextHighlightOn = true;\r\n                        this._cursorIndex = this._cursorOffset <= 0 ? 0 : this._cursorOffset + 1;\r\n                    }\r\n                    //if text is already highlighted\r\n                    else if (this._cursorIndex === -1) {\r\n                        this._cursorIndex = this._textWrapper.length - this._startHighlightIndex;\r\n                        this._cursorOffset = this._textWrapper.length === this._endHighlightIndex ? 0 : this._textWrapper.length - this._endHighlightIndex - 1;\r\n                    }\r\n                    //set the highlight indexes\r\n                    if (this._cursorIndex < this._cursorOffset) {\r\n                        this._endHighlightIndex = this._textWrapper.length - this._cursorIndex;\r\n                        this._startHighlightIndex = this._textWrapper.length - this._cursorOffset;\r\n                    } else if (this._cursorIndex > this._cursorOffset) {\r\n                        this._endHighlightIndex = this._textWrapper.length - this._cursorOffset;\r\n                        this._startHighlightIndex = this._textWrapper.length - this._cursorIndex;\r\n                    } else {\r\n                        this.isTextHighlightOn = false;\r\n                    }\r\n                    this._markAsDirty();\r\n                    return;\r\n                }\r\n                if (this.isTextHighlightOn) {\r\n                    this._cursorOffset = this._textWrapper.length - this._endHighlightIndex;\r\n                    this.isTextHighlightOn = false;\r\n                }\r\n                //ctr + ->\r\n                if (evt && (evt.ctrlKey || evt.metaKey)) {\r\n                    this._cursorOffset = 0;\r\n                    evt.preventDefault();\r\n                }\r\n                this._blinkIsEven = false;\r\n                this.isTextHighlightOn = false;\r\n                this._cursorIndex = -1;\r\n                this._markAsDirty();\r\n                return;\r\n        }\r\n        if (keyCode === 32) {\r\n            key = evt?.key ?? \" \";\r\n        }\r\n        this._deadKey = key === \"Dead\";\r\n        // Printable characters\r\n        if (\r\n            key &&\r\n            (keyCode === -1 || // Direct access\r\n                keyCode === 32 || // Space\r\n                keyCode === 34 || // \"    add support for single and double quotes\r\n                keyCode === 39 || // '\r\n                (keyCode > 47 && keyCode < 64) || // Numbers\r\n                (keyCode > 64 && keyCode < 91) || // Letters\r\n                (keyCode > 159 && keyCode < 193) || // Special characters\r\n                (keyCode > 218 && keyCode < 223) || // Special characters\r\n                (keyCode > 95 && keyCode < 112))\r\n        ) {\r\n            // Numpad\r\n            this._currentKey = key;\r\n            this.onBeforeKeyAddObservable.notifyObservers(this);\r\n            key = this._currentKey;\r\n            if (this._addKey && !this._deadKey) {\r\n                if (this.isTextHighlightOn) {\r\n                    this._textWrapper.removePart(this._startHighlightIndex, this._endHighlightIndex, key);\r\n                    this._textHasChanged();\r\n                    this._cursorOffset = this._textWrapper.length - (this._startHighlightIndex + 1);\r\n                    this.isTextHighlightOn = false;\r\n                    this._blinkIsEven = false;\r\n                    this._markAsDirty();\r\n                } else if (this._cursorOffset === 0) {\r\n                    this.text += this._deadKey && evt?.key ? evt.key : key;\r\n                } else {\r\n                    const insertPosition = this._textWrapper.length - this._cursorOffset;\r\n                    this._textWrapper.removePart(insertPosition, insertPosition, key);\r\n                    this._textHasChanged();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _updateValueFromCursorIndex(offset: number) {\r\n        //update the cursor\r\n        this._blinkIsEven = false;\r\n\r\n        if (this._cursorIndex === -1) {\r\n            this._cursorIndex = offset;\r\n        } else {\r\n            if (this._cursorIndex < this._cursorOffset) {\r\n                this._endHighlightIndex = this._textWrapper.length - this._cursorIndex;\r\n                this._startHighlightIndex = this._textWrapper.length - this._cursorOffset;\r\n            } else if (this._cursorIndex > this._cursorOffset) {\r\n                this._endHighlightIndex = this._textWrapper.length - this._cursorOffset;\r\n                this._startHighlightIndex = this._textWrapper.length - this._cursorIndex;\r\n            } else {\r\n                this.isTextHighlightOn = false;\r\n                this._markAsDirty();\r\n                return;\r\n            }\r\n        }\r\n        this.isTextHighlightOn = true;\r\n        this._markAsDirty();\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _processDblClick(evt: PointerInfo) {\r\n        //pre-find the start and end index of the word under cursor, speeds up the rendering\r\n        this._startHighlightIndex = this._textWrapper.length - this._cursorOffset;\r\n        this._endHighlightIndex = this._startHighlightIndex;\r\n        let moveLeft, moveRight;\r\n        do {\r\n            moveRight = this._endHighlightIndex < this._textWrapper.length && this._textWrapper.isWord(this._endHighlightIndex) ? ++this._endHighlightIndex : 0;\r\n            moveLeft = this._startHighlightIndex > 0 && this._textWrapper.isWord(this._startHighlightIndex - 1) ? --this._startHighlightIndex : 0;\r\n        } while (moveLeft || moveRight);\r\n\r\n        this._cursorOffset = this._textWrapper.length - this._startHighlightIndex;\r\n\r\n        this.isTextHighlightOn = true;\r\n        this._clickedCoordinate = null;\r\n        this._blinkIsEven = true;\r\n        this._cursorIndex = -1;\r\n        this._markAsDirty();\r\n    }\r\n    /** @internal */\r\n    protected _selectAllText() {\r\n        this._blinkIsEven = true;\r\n        this.isTextHighlightOn = true;\r\n\r\n        this._startHighlightIndex = 0;\r\n        this._endHighlightIndex = this._textWrapper.length;\r\n        this._cursorOffset = this._textWrapper.length;\r\n        this._cursorIndex = -1;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Handles the keyboard event\r\n     * @param evt Defines the KeyboardEvent\r\n     */\r\n    public processKeyboard(evt: IKeyboardEvent): void {\r\n        // process pressed key\r\n        this.processKey(evt.keyCode, evt.key, evt);\r\n\r\n        this.onKeyboardEventProcessedObservable.notifyObservers(evt);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _onCopyText(ev: ClipboardEvent): void {\r\n        this.isTextHighlightOn = false;\r\n        //when write permission to clipbaord data is denied\r\n        try {\r\n            ev.clipboardData && ev.clipboardData.setData(\"text/plain\", this._highlightedText);\r\n        } catch {} //pass\r\n        this._host.clipboardData = this._highlightedText;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _onCutText(ev: ClipboardEvent): void {\r\n        if (!this._highlightedText) {\r\n            return;\r\n        }\r\n        this._textWrapper.removePart(this._startHighlightIndex, this._endHighlightIndex);\r\n        this._textHasChanged();\r\n        this.isTextHighlightOn = false;\r\n        this._cursorOffset = this._textWrapper.length - this._startHighlightIndex;\r\n        //when write permission to clipbaord data is denied\r\n        try {\r\n            ev.clipboardData && ev.clipboardData.setData(\"text/plain\", this._highlightedText);\r\n        } catch {} //pass\r\n\r\n        this._host.clipboardData = this._highlightedText;\r\n        this._highlightedText = \"\";\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _onPasteText(ev: ClipboardEvent): void {\r\n        let data: string = \"\";\r\n        if (ev.clipboardData && ev.clipboardData.types.indexOf(\"text/plain\") !== -1) {\r\n            data = ev.clipboardData.getData(\"text/plain\");\r\n        } else {\r\n            //get the cached data; returns blank string by default\r\n            data = this._host.clipboardData;\r\n        }\r\n        const insertPosition = this._textWrapper.length - this._cursorOffset;\r\n        this._textWrapper.removePart(insertPosition, insertPosition, data);\r\n        this._textHasChanged();\r\n    }\r\n\r\n    public _draw(context: ICanvasRenderingContext): void {\r\n        context.save();\r\n\r\n        this._applyStates(context);\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowColor = this.shadowColor;\r\n            context.shadowBlur = this.shadowBlur;\r\n            context.shadowOffsetX = this.shadowOffsetX;\r\n            context.shadowOffsetY = this.shadowOffsetY;\r\n        }\r\n\r\n        // Background\r\n        if (this._isFocused) {\r\n            if (this._focusedBackground) {\r\n                context.fillStyle = this._isEnabled ? this._focusedBackground : this._disabledColor;\r\n\r\n                context.fillRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\r\n            }\r\n        } else if (this._background) {\r\n            context.fillStyle = this._isEnabled ? this._background : this._disabledColor;\r\n\r\n            context.fillRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\r\n        }\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowBlur = 0;\r\n            context.shadowOffsetX = 0;\r\n            context.shadowOffsetY = 0;\r\n        }\r\n\r\n        if (!this._fontOffset || this._wasDirty) {\r\n            this._fontOffset = Control._GetFontOffset(context.font);\r\n        }\r\n\r\n        // Text\r\n        const clipTextLeft = this._currentMeasure.left + this._margin.getValueInPixel(this._host, this._tempParentMeasure.width);\r\n        if (this.color) {\r\n            context.fillStyle = this.color;\r\n        }\r\n\r\n        let text = this._beforeRenderText(this._textWrapper);\r\n\r\n        if (!this._isFocused && !this._textWrapper.text && this._placeholderText) {\r\n            text = new TextWrapper();\r\n            text.text = this._placeholderText;\r\n\r\n            if (this._placeholderColor) {\r\n                context.fillStyle = this._placeholderColor;\r\n            }\r\n        }\r\n\r\n        this._textWidth = context.measureText(text.text).width;\r\n        const marginWidth = this._margin.getValueInPixel(this._host, this._tempParentMeasure.width) * 2;\r\n        if (this._autoStretchWidth) {\r\n            this.width = Math.min(this._maxWidth.getValueInPixel(this._host, this._tempParentMeasure.width), this._textWidth + marginWidth) + \"px\";\r\n            this._autoStretchWidth = true; // setting the width will have reset _autoStretchWidth to false!\r\n        }\r\n\r\n        const rootY = this._fontOffset.ascent + (this._currentMeasure.height - this._fontOffset.height) / 2;\r\n        const availableWidth = this._width.getValueInPixel(this._host, this._tempParentMeasure.width) - marginWidth;\r\n\r\n        context.save();\r\n        context.beginPath();\r\n        context.rect(clipTextLeft, this._currentMeasure.top + (this._currentMeasure.height - this._fontOffset.height) / 2, availableWidth + 2, this._currentMeasure.height);\r\n        context.clip();\r\n\r\n        if (this._isFocused && this._textWidth > availableWidth) {\r\n            const textLeft = clipTextLeft - this._textWidth + availableWidth;\r\n            if (!this._scrollLeft) {\r\n                this._scrollLeft = textLeft;\r\n            }\r\n        } else {\r\n            this._scrollLeft = clipTextLeft;\r\n        }\r\n\r\n        context.fillText(text.text, this._scrollLeft, this._currentMeasure.top + rootY);\r\n\r\n        // Cursor\r\n        if (this._isFocused) {\r\n            // Need to move cursor\r\n            if (this._clickedCoordinate) {\r\n                const rightPosition = this._scrollLeft + this._textWidth;\r\n                const absoluteCursorPosition = rightPosition - this._clickedCoordinate;\r\n                let currentSize = 0;\r\n                this._cursorOffset = 0;\r\n                let previousDist = 0;\r\n                do {\r\n                    if (this._cursorOffset) {\r\n                        previousDist = Math.abs(absoluteCursorPosition - currentSize);\r\n                    }\r\n                    this._cursorOffset++;\r\n                    currentSize = context.measureText(text.substr(text.length - this._cursorOffset, this._cursorOffset)).width;\r\n                } while (currentSize < absoluteCursorPosition && text.length >= this._cursorOffset);\r\n\r\n                // Find closest move\r\n                if (Math.abs(absoluteCursorPosition - currentSize) > previousDist) {\r\n                    this._cursorOffset--;\r\n                }\r\n\r\n                this._blinkIsEven = false;\r\n                this._clickedCoordinate = null;\r\n            }\r\n\r\n            // Render cursor\r\n            if (!this._blinkIsEven) {\r\n                const cursorOffsetText = text.substr(text.length - this._cursorOffset);\r\n                const cursorOffsetWidth = context.measureText(cursorOffsetText).width;\r\n                let cursorLeft = this._scrollLeft + this._textWidth - cursorOffsetWidth;\r\n\r\n                if (cursorLeft < clipTextLeft) {\r\n                    this._scrollLeft += clipTextLeft - cursorLeft;\r\n                    cursorLeft = clipTextLeft;\r\n                    this._markAsDirty();\r\n                } else if (cursorLeft > clipTextLeft + availableWidth) {\r\n                    this._scrollLeft += clipTextLeft + availableWidth - cursorLeft;\r\n                    cursorLeft = clipTextLeft + availableWidth;\r\n                    this._markAsDirty();\r\n                }\r\n                if (!this.isTextHighlightOn) {\r\n                    context.fillRect(cursorLeft, this._currentMeasure.top + (this._currentMeasure.height - this._fontOffset.height) / 2, 2, this._fontOffset.height);\r\n                }\r\n            }\r\n\r\n            clearTimeout(this._blinkTimeout);\r\n            this._blinkTimeout = <any>setTimeout(() => {\r\n                this._blinkIsEven = !this._blinkIsEven;\r\n                this._markAsDirty();\r\n            }, 500);\r\n\r\n            //show the highlighted text\r\n            if (this.isTextHighlightOn) {\r\n                clearTimeout(this._blinkTimeout);\r\n                const highlightCursorOffsetWidth = context.measureText(text.substring(this._startHighlightIndex)).width;\r\n                let highlightCursorLeft = this._scrollLeft + this._textWidth - highlightCursorOffsetWidth;\r\n                this._highlightedText = text.substring(this._startHighlightIndex, this._endHighlightIndex);\r\n                let width = context.measureText(text.substring(this._startHighlightIndex, this._endHighlightIndex)).width;\r\n                if (highlightCursorLeft < clipTextLeft) {\r\n                    width = width - (clipTextLeft - highlightCursorLeft);\r\n                    if (!width) {\r\n                        // when using left arrow on text.length > availableWidth;\r\n                        // assigns the width of the first letter after clipTextLeft\r\n                        width = context.measureText(text.charAt(text.length - this._cursorOffset)).width;\r\n                    }\r\n                    highlightCursorLeft = clipTextLeft;\r\n                }\r\n                //for transparancy\r\n                context.globalAlpha = this._highligherOpacity;\r\n                context.fillStyle = this._textHighlightColor;\r\n                context.fillRect(highlightCursorLeft, this._currentMeasure.top + (this._currentMeasure.height - this._fontOffset.height) / 2, width, this._fontOffset.height);\r\n                context.globalAlpha = 1.0;\r\n            }\r\n        }\r\n        context.restore();\r\n\r\n        // Border\r\n        if (this._thickness) {\r\n            if (this._isFocused) {\r\n                if (this.focusedColor) {\r\n                    context.strokeStyle = this.focusedColor;\r\n                }\r\n            } else {\r\n                if (this.color) {\r\n                    context.strokeStyle = this.color;\r\n                }\r\n            }\r\n\r\n            context.lineWidth = this._thickness;\r\n\r\n            context.strokeRect(\r\n                this._currentMeasure.left + this._thickness / 2,\r\n                this._currentMeasure.top + this._thickness / 2,\r\n                this._currentMeasure.width - this._thickness,\r\n                this._currentMeasure.height - this._thickness\r\n            );\r\n        }\r\n\r\n        context.restore();\r\n    }\r\n\r\n    public _onPointerDown(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, pi: PointerInfoBase): boolean {\r\n        if (!super._onPointerDown(target, coordinates, pointerId, buttonIndex, pi)) {\r\n            return false;\r\n        }\r\n\r\n        if (this.isReadOnly) {\r\n            return true;\r\n        }\r\n\r\n        this._clickedCoordinate = coordinates.x;\r\n        this.isTextHighlightOn = false;\r\n        this._highlightedText = \"\";\r\n        this._cursorIndex = -1;\r\n        this._isPointerDown = true;\r\n        this._host._capturingControl[pointerId] = this;\r\n        this._focusedBy = (pi.event as IPointerEvent).pointerType;\r\n        if (this._host.focusedControl === this) {\r\n            // Move cursor\r\n            clearTimeout(this._blinkTimeout);\r\n            this._markAsDirty();\r\n            return true;\r\n        }\r\n        if (!this._isEnabled) {\r\n            return false;\r\n        }\r\n        this._host.focusedControl = this;\r\n\r\n        return true;\r\n    }\r\n    public _onPointerMove(target: Control, coordinates: Vector2, pointerId: number, pi: PointerInfoBase): void {\r\n        if (this._host.focusedControl === this && this._isPointerDown && !this.isReadOnly) {\r\n            this._clickedCoordinate = coordinates.x;\r\n            this._markAsDirty();\r\n            this._updateValueFromCursorIndex(this._cursorOffset);\r\n        }\r\n        super._onPointerMove(target, coordinates, pointerId, pi);\r\n    }\r\n\r\n    public _onPointerUp(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, notifyClick: boolean): void {\r\n        this._isPointerDown = false;\r\n        delete this._host._capturingControl[pointerId];\r\n        super._onPointerUp(target, coordinates, pointerId, buttonIndex, notifyClick);\r\n    }\r\n\r\n    protected _beforeRenderText(textWrapper: TextWrapper): TextWrapper {\r\n        return textWrapper;\r\n    }\r\n\r\n    /** @internal */\r\n    private set isTextHighlightOn(value: boolean) {\r\n        if (this._isTextHighlightOn === value) {\r\n            return;\r\n        }\r\n        if (value) {\r\n            this.onTextHighlightObservable.notifyObservers(this);\r\n        }\r\n        this._isTextHighlightOn = value;\r\n    }\r\n\r\n    /** @internal */\r\n    private get isTextHighlightOn(): boolean {\r\n        return this._isTextHighlightOn;\r\n    }\r\n\r\n    public dispose() {\r\n        super.dispose();\r\n\r\n        this.onBlurObservable.clear();\r\n        this.onFocusObservable.clear();\r\n        this.onTextChangedObservable.clear();\r\n        this.onTextCopyObservable.clear();\r\n        this.onTextCutObservable.clear();\r\n        this.onTextPasteObservable.clear();\r\n        this.onTextHighlightObservable.clear();\r\n        this.onKeyboardEventProcessedObservable.clear();\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.InputText\", InputText);\r\n"],"mappings":";AAEA,SAASA,UAAU,QAAE;AAGrB,SAASC,mBAAmB,QAAE;AAE9B,SAASC,iBAAiB,QAAE;AAE5B,SAASC,OAAO,QAAQ,cAAY;AAEpC,SAASC,YAAY,QAAQ,oBAAkB;AAE/C,SAASC,aAAa,QAAE;AACxB,SAASC,WAAW,QAAQ,kBAAgB;AAC5C,SAASC,SAAS,QAAE;AAIpB;;;AAGA,OAAM,MAAOC,SAAU,SAAQL,OAAO;EAgElC;EAEA,IAAWM,QAAQA,CAAA;IACf,OAAO,IAAI,CAACC,SAAS,CAACC,QAAQ,CAAC,IAAI,CAACC,KAAK,CAAC;EAC9C;EAEA;EACA,IAAWC,gBAAgBA,CAAA;IACvB,OAAO,IAAI,CAACH,SAAS,CAACI,eAAe,CAAC,IAAI,CAACF,KAAK,EAAE,IAAI,CAACG,oBAAoB,CAACC,KAAK,CAAC;EACtF;EAEA,IAAWP,QAAQA,CAACQ,KAAsB;IACtC,IAAI,IAAI,CAACP,SAAS,CAACC,QAAQ,CAAC,IAAI,CAACC,KAAK,CAAC,KAAKK,KAAK,EAAE;MAC/C;;IAGJ,IAAI,IAAI,CAACP,SAAS,CAACQ,UAAU,CAACD,KAAK,CAAC,EAAE;MAClC,IAAI,CAACE,YAAY,EAAE;;EAE3B;EAEA;EAEA,IAAWC,iBAAiBA,CAAA;IACxB,OAAO,IAAI,CAACC,kBAAkB;EAClC;EAEA,IAAWD,iBAAiBA,CAACH,KAAa;IACtC,IAAI,IAAI,CAACI,kBAAkB,KAAKJ,KAAK,EAAE;MACnC;;IAEJ,IAAI,CAACI,kBAAkB,GAAGJ,KAAK;IAC/B,IAAI,CAACE,YAAY,EAAE;EACvB;EACA;EAEA,IAAWG,gBAAgBA,CAAA;IACvB,OAAO,IAAI,CAACC,iBAAiB;EACjC;EAEA,IAAWD,gBAAgBA,CAACL,KAAc;IACtC,IAAI,IAAI,CAACM,iBAAiB,KAAKN,KAAK,EAAE;MAClC;;IAGJ,IAAI,CAACM,iBAAiB,GAAGN,KAAK;IAC9B,IAAI,CAACE,YAAY,EAAE;EACvB;EAEA;EAEA,IAAWK,kBAAkBA,CAAA;IACzB,OAAO,IAAI,CAACC,mBAAmB;EACnC;EAEA,IAAWD,kBAAkBA,CAACP,KAAa;IACvC,IAAI,IAAI,CAACQ,mBAAmB,KAAKR,KAAK,EAAE;MACpC;;IAEJ,IAAI,CAACQ,mBAAmB,GAAGR,KAAK;IAChC,IAAI,CAACE,YAAY,EAAE;EACvB;EAEA;EAEA,IAAWO,MAAMA,CAAA;IACb,OAAO,IAAI,CAACC,OAAO,CAAChB,QAAQ,CAAC,IAAI,CAACC,KAAK,CAAC;EAC5C;EAEA;EACA,IAAWgB,cAAcA,CAAA;IACrB,OAAO,IAAI,CAACD,OAAO,CAACb,eAAe,CAAC,IAAI,CAACF,KAAK,EAAE,IAAI,CAACG,oBAAoB,CAACC,KAAK,CAAC;EACpF;EAEA,IAAWU,MAAMA,CAACT,KAAa;IAC3B,IAAI,IAAI,CAACU,OAAO,CAAChB,QAAQ,CAAC,IAAI,CAACC,KAAK,CAAC,KAAKK,KAAK,EAAE;MAC7C;;IAGJ,IAAI,IAAI,CAACU,OAAO,CAACT,UAAU,CAACD,KAAK,CAAC,EAAE;MAChC,IAAI,CAACE,YAAY,EAAE;;EAE3B;EAEA;EAEA,IAAWU,gBAAgBA,CAAA;IACvB,OAAO,IAAI,CAACC,iBAAiB;EACjC;EAEA,IAAWD,gBAAgBA,CAACZ,KAAc;IACtC,IAAI,IAAI,CAACa,iBAAiB,KAAKb,KAAK,EAAE;MAClC;;IAGJ,IAAI,CAACa,iBAAiB,GAAGb,KAAK;IAC9B,IAAI,CAACE,YAAY,EAAE;EACvB;EAEA;EAEA,IAAWY,SAASA,CAAA;IAChB,OAAO,IAAI,CAACC,UAAU;EAC1B;EAEA,IAAWD,SAASA,CAACd,KAAa;IAC9B,IAAI,IAAI,CAACe,UAAU,KAAKf,KAAK,EAAE;MAC3B;;IAGJ,IAAI,CAACe,UAAU,GAAGf,KAAK;IACvB,IAAI,CAACE,YAAY,EAAE;EACvB;EAEA;EAEA,IAAWc,iBAAiBA,CAAA;IACxB,OAAO,IAAI,CAACC,kBAAkB;EAClC;EAEA,IAAWD,iBAAiBA,CAAChB,KAAa;IACtC,IAAI,IAAI,CAACiB,kBAAkB,KAAKjB,KAAK,EAAE;MACnC;;IAGJ,IAAI,CAACiB,kBAAkB,GAAGjB,KAAK;IAC/B,IAAI,CAACE,YAAY,EAAE;EACvB;EAEA;EAEA,IAAWgB,YAAYA,CAAA;IACnB,OAAO,IAAI,CAACC,aAAa;EAC7B;EAEA,IAAWD,YAAYA,CAAClB,KAAa;IACjC,IAAI,IAAI,CAACmB,aAAa,KAAKnB,KAAK,EAAE;MAC9B;;IAGJ,IAAI,CAACmB,aAAa,GAAGnB,KAAK;IAC1B,IAAI,CAACE,YAAY,EAAE;EACvB;EAEA;EAEA,IAAWkB,UAAUA,CAAA;IACjB,OAAO,IAAI,CAACC,WAAW;EAC3B;EAEA,IAAWD,UAAUA,CAACpB,KAAa;IAC/B,IAAI,IAAI,CAACqB,WAAW,KAAKrB,KAAK,EAAE;MAC5B;;IAGJ,IAAI,CAACqB,WAAW,GAAGrB,KAAK;IACxB,IAAI,CAACE,YAAY,EAAE;EACvB;EAEA;EAEA,IAAWoB,gBAAgBA,CAAA;IACvB,OAAO,IAAI,CAACC,iBAAiB;EACjC;EAEA,IAAWD,gBAAgBA,CAACtB,KAAa;IACrC,IAAI,IAAI,CAACuB,iBAAiB,KAAKvB,KAAK,EAAE;MAClC;;IAGJ,IAAI,CAACuB,iBAAiB,GAAGvB,KAAK;IAC9B,IAAI,CAACE,YAAY,EAAE;EACvB;EAEA;EAEA,IAAWsB,eAAeA,CAAA;IACtB,OAAO,IAAI,CAACC,gBAAgB;EAChC;EAEA,IAAWD,eAAeA,CAACxB,KAAa;IACpC,IAAI,IAAI,CAACyB,gBAAgB,KAAKzB,KAAK,EAAE;MACjC;;IAEJ,IAAI,CAACyB,gBAAgB,GAAGzB,KAAK;IAC7B,IAAI,CAACE,YAAY,EAAE;EACvB;EAEA;EAEA,IAAWwB,OAAOA,CAAA;IACd,OAAO,IAAI,CAACC,QAAQ;EACxB;EAEA,IAAWD,OAAOA,CAACE,IAAa;IAC5B,IAAI,CAACD,QAAQ,GAAGC,IAAI;EACxB;EAEA;EACA,IAAWC,eAAeA,CAAA;IACtB,OAAO,IAAI,CAACC,gBAAgB;EAChC;EACA,IAAWD,eAAeA,CAACE,IAAY;IACnC,IAAI,IAAI,CAACD,gBAAgB,KAAKC,IAAI,EAAE;MAChC;;IAEJ,IAAI,CAACD,gBAAgB,GAAGC,IAAI;IAC5B,IAAI,CAAC7B,YAAY,EAAE;EACvB;EAEA;EACA,IAAW8B,MAAMA,CAAA;IACb,OAAO,IAAI,CAACC,OAAO;EACvB;EAEA,IAAWD,MAAMA,CAACJ,IAAa;IAC3B,IAAI,CAACK,OAAO,GAAGL,IAAI;EACvB;EAEA;EACA,IAAWM,UAAUA,CAAA;IACjB,OAAO,IAAI,CAACC,WAAW;EAC3B;EAEA,IAAWD,UAAUA,CAACE,GAAW;IAC7B,IAAI,CAACD,WAAW,GAAGC,GAAG;EAC1B;EAEA;EAEA,IAAWL,IAAIA,CAAA;IACX,OAAO,IAAI,CAACM,YAAY,CAACN,IAAI;EACjC;EAEA,IAAWA,IAAIA,CAAC/B,KAAa;IACzB,MAAMsC,aAAa,GAAGtC,KAAK,CAACN,QAAQ,EAAE,CAAC,CAAC;IAExC,IAAI,CAAC,IAAI,CAAC2C,YAAY,EAAE;MACpB,IAAI,CAACA,YAAY,GAAG,IAAIhD,WAAW,EAAE;;IAGzC,IAAI,IAAI,CAACgD,YAAY,CAACN,IAAI,KAAKO,aAAa,EAAE;MAC1C;;IAEJ,IAAI,CAACD,YAAY,CAACN,IAAI,GAAGO,aAAa;IACtC,IAAI,CAACC,eAAe,EAAE;EAC1B;EAEUA,eAAeA,CAAA;IACrB,IAAI,CAACrC,YAAY,EAAE;IACnB,IAAI,CAACsC,uBAAuB,CAACC,eAAe,CAAC,IAAI,CAAC;EACtD;EAEA;EAEA,IAAW1C,KAAKA,CAAA;IACZ,OAAO,IAAI,CAAC2C,MAAM,CAAChD,QAAQ,CAAC,IAAI,CAACC,KAAK,CAAC;EAC3C;EAEA,IAAWI,KAAKA,CAACC,KAAsB;IACnC,IAAI,IAAI,CAAC0C,MAAM,CAAChD,QAAQ,CAAC,IAAI,CAACC,KAAK,CAAC,KAAKK,KAAK,EAAE;MAC5C;;IAGJ,IAAI,IAAI,CAAC0C,MAAM,CAACzC,UAAU,CAACD,KAAK,CAAC,EAAE;MAC/B,IAAI,CAACE,YAAY,EAAE;;IAGvB,IAAI,CAACU,gBAAgB,GAAG,KAAK;EACjC;EAEA;;;;;EAKA+B,YAAmBC,IAAa,EAAEb,IAAA,GAAe,EAAE;IAC/C,KAAK,CAACa,IAAI,CAAC;IADI,KAAAA,IAAI,GAAJA,IAAI;IAlVb,KAAAnB,gBAAgB,GAAG,EAAE;IACrB,KAAAJ,WAAW,GAAG,SAAS;IACvB,KAAAJ,kBAAkB,GAAG,SAAS;IAC9B,KAAAE,aAAa,GAAG,OAAO;IACvB,KAAAI,iBAAiB,GAAG,MAAM;IAC1B,KAAAR,UAAU,GAAG,CAAC;IACd,KAAAL,OAAO,GAAG,IAAIvB,YAAY,CAAC,EAAE,EAAEA,YAAY,CAAC0D,cAAc,CAAC;IAC3D,KAAAhC,iBAAiB,GAAG,IAAI;IACxB,KAAApB,SAAS,GAAG,IAAIN,YAAY,CAAC,CAAC,EAAEA,YAAY,CAAC2D,mBAAmB,EAAE,KAAK,CAAC;IACxE,KAAAC,UAAU,GAAG,KAAK;IAIlB,KAAAC,YAAY,GAAG,KAAK;IACtB,KAAAC,aAAa,GAAG,CAAC;IAIf,KAAAtB,QAAQ,GAAG,KAAK;IAChB,KAAAM,OAAO,GAAG,IAAI;IACd,KAAAE,WAAW,GAAG,EAAE;IAChB,KAAAe,kBAAkB,GAAG,KAAK;IAC1B,KAAA1C,mBAAmB,GAAG,SAAS;IAC/B,KAAAJ,kBAAkB,GAAG,GAAG;IACxB,KAAA0B,gBAAgB,GAAG,EAAE;IACvB,KAAAqB,oBAAoB,GAAG,CAAC;IACxB,KAAAC,kBAAkB,GAAG,CAAC;IACtB,KAAAC,YAAY,GAAG,CAAC,CAAC;IACf,KAAA/C,iBAAiB,GAAG,KAAK;IACzB,KAAAgD,cAAc,GAAG,KAAK;IAOhC;IAEO,KAAAC,aAAa,GAAG,oBAAoB;IAC3C;IAEO,KAAAC,mBAAmB,GAAG,KAAK;IAElC;IACO,KAAAhB,uBAAuB,GAAG,IAAIzD,UAAU,EAAa;IAC5D;IACO,KAAA0E,wBAAwB,GAAG,IAAI1E,UAAU,EAAa;IAC7D;IACO,KAAA2E,iBAAiB,GAAG,IAAI3E,UAAU,EAAa;IACtD;IACO,KAAA4E,gBAAgB,GAAG,IAAI5E,UAAU,EAAa;IACrD;IACO,KAAA6E,yBAAyB,GAAG,IAAI7E,UAAU,EAAa;IAC9D;IACO,KAAA8E,oBAAoB,GAAG,IAAI9E,UAAU,EAAa;IACzD;IACO,KAAA+E,mBAAmB,GAAG,IAAI/E,UAAU,EAAa;IACxD;IACO,KAAAgF,qBAAqB,GAAG,IAAIhF,UAAU,EAAa;IAC1D;IACO,KAAAiF,kCAAkC,GAAG,IAAIjF,UAAU,EAAkB;IAyRxE,IAAI,CAACgD,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACkC,gBAAgB,GAAG,IAAI;EAChC;EAEA;EACOC,MAAMA,CAAA;IACT,IAAI,CAACnB,UAAU,GAAG,KAAK;IACvB,IAAI,CAACoB,WAAW,GAAG,IAAI;IACvB,IAAI,CAAClB,aAAa,GAAG,CAAC;IACtBmB,YAAY,CAAC,IAAI,CAACC,aAAa,CAAC;IAChC,IAAI,CAACnE,YAAY,EAAE;IAEnB,IAAI,CAACyD,gBAAgB,CAAClB,eAAe,CAAC,IAAI,CAAC;IAE3C,IAAI,CAAC9C,KAAK,CAAC2E,yBAAyB,EAAE;IACtC,IAAI,IAAI,CAACC,oBAAoB,EAAE;MAC3B,IAAI,CAAC5E,KAAK,CAAC6E,qBAAqB,CAACC,MAAM,CAAC,IAAI,CAACF,oBAAoB,CAAC;;IAEtE,MAAMG,KAAK,GAAG,IAAI,CAAC/E,KAAK,CAACgF,QAAQ,EAAE;IACnC,IAAI,IAAI,CAACC,wBAAwB,IAAIF,KAAK,EAAE;MACxCA,KAAK,CAACG,mBAAmB,CAACJ,MAAM,CAAC,IAAI,CAACG,wBAAwB,CAAC;;EAEvE;EAEA;EACOE,OAAOA,CAAA;IACV,IAAI,CAAC,IAAI,CAACC,UAAU,EAAE;MAClB;;IAEJ,IAAI,CAACZ,WAAW,GAAG,IAAI;IACvB,IAAI,CAACpB,UAAU,GAAG,IAAI;IACtB,IAAI,CAACC,YAAY,GAAG,KAAK;IACzB,IAAI,CAACC,aAAa,GAAG,CAAC;IACtB,IAAI,CAAC/C,YAAY,EAAE;IAEnB,IAAI,CAACwD,iBAAiB,CAACjB,eAAe,CAAC,IAAI,CAAC;IAE5C,IAAI,IAAI,CAACuC,UAAU,KAAK,OAAO,IAAI,CAAC,IAAI,CAACxB,mBAAmB,EAAE;MAC1D,MAAMxD,KAAK,GAAGiF,MAAM,CAAC,IAAI,CAAC1B,aAAa,CAAC;MAExC,IAAIvD,KAAK,KAAK,IAAI,EAAE;QAChB,IAAI,CAAC+B,IAAI,GAAG/B,KAAK;;MAErB,IAAI,CAACL,KAAK,CAACuF,cAAc,GAAG,IAAI;MAChC;;IAGJ,IAAI,CAACvF,KAAK,CAACwF,uBAAuB,EAAE;IAEpC,IAAI,CAACZ,oBAAoB,GAAG,IAAI,CAAC5E,KAAK,CAAC6E,qBAAqB,CAACY,GAAG,CAAEC,aAAa,IAAI;MAC/E;MACA,QAAQA,aAAa,CAACC,IAAI;QACtB,KAAKtG,mBAAmB,CAACuG,IAAI;UACzB,IAAI,CAACC,WAAW,CAACH,aAAa,CAACI,KAAK,CAAC;UACrC,IAAI,CAAC5B,oBAAoB,CAACpB,eAAe,CAAC,IAAI,CAAC;UAC/C;QACJ,KAAKzD,mBAAmB,CAAC0G,GAAG;UACxB,IAAI,CAACC,UAAU,CAACN,aAAa,CAACI,KAAK,CAAC;UACpC,IAAI,CAAC3B,mBAAmB,CAACrB,eAAe,CAAC,IAAI,CAAC;UAC9C;QACJ,KAAKzD,mBAAmB,CAAC4G,KAAK;UAC1B,IAAI,CAACC,YAAY,CAACR,aAAa,CAACI,KAAK,CAAC;UACtC,IAAI,CAAC1B,qBAAqB,CAACtB,eAAe,CAAC,IAAI,CAAC;UAChD;QACJ;UACI;;IAEZ,CAAC,CAAC;IAEF,MAAMiC,KAAK,GAAG,IAAI,CAAC/E,KAAK,CAACgF,QAAQ,EAAE;IACnC,IAAID,KAAK,EAAE;MACP;MACA,IAAI,CAACE,wBAAwB,GAAGF,KAAK,CAACG,mBAAmB,CAACO,GAAG,CAAEU,WAAW,IAAI;QAC1E,IAAI,CAAC,IAAI,CAAC/C,UAAU,EAAE;UAClB;;QAEJ,IAAI+C,WAAW,CAACR,IAAI,KAAKrG,iBAAiB,CAAC8G,gBAAgB,EAAE;UACzD,IAAI,CAACC,gBAAgB,CAACF,WAAW,CAAC;;MAE1C,CAAC,CAAC;;IAGN,IAAI,IAAI,CAACxF,iBAAiB,EAAE;MACxB,IAAI,CAAC2F,cAAc,EAAE;;EAE7B;EAEA;;;EAGOC,KAAKA,CAAA;IACR,IAAI,CAACvG,KAAK,CAACwG,kBAAkB,CAAC,IAAI,CAAC;EACvC;EAEA;;;EAGOC,IAAIA,CAAA;IACP,IAAI,CAACzG,KAAK,CAACuF,cAAc,GAAG,IAAI;EACpC;EAEUmB,YAAYA,CAAA;IAClB,OAAO,WAAW;EACtB;EAEA;;;;EAIOC,cAAcA,CAAA;IACjB,IAAI,CAAC,IAAI,CAACC,yBAAyB,EAAE;MACjC,OAAO,IAAI;;IAEf,OAAO,CAAC,IAAI,CAACA,yBAAyB,CAAC;EAC3C;EAEA;;;EAGOC,UAAUA,CAACC,OAAe,EAAErE,GAAY,EAAEsE,GAAoB;;IACjE,IAAI,IAAI,CAACC,UAAU,EAAE;MACjB;;IAGJ;IACA,IAAID,GAAG,KAAKA,GAAG,CAACE,OAAO,IAAIF,GAAG,CAACG,OAAO,CAAC,KAAKJ,OAAO,KAAK,EAAE,IAAIA,OAAO,KAAK,EAAE,IAAIA,OAAO,KAAK,EAAE,CAAC,EAAE;MAC7F;;IAGJ;IACA,IAAIC,GAAG,KAAKA,GAAG,CAACE,OAAO,IAAIF,GAAG,CAACG,OAAO,CAAC,IAAIJ,OAAO,KAAK,EAAE,EAAE;MACvD,IAAI,CAACR,cAAc,EAAE;MACrBS,GAAG,CAACI,cAAc,EAAE;MACpB;;IAEJ;IACA,QAAQL,OAAO;MACX,KAAK,EAAE;QAAE;QACLrE,GAAG,GAAG,GAAG,CAAC,CAAC;QACX;MACJ,KAAK,GAAG;QAAE;QACN,IAAIsE,GAAG,EAAE;UACLA,GAAG,CAACI,cAAc,EAAE;;QAExB;MACJ,KAAK,CAAC;QAAE;QACJ,IAAI,IAAI,CAACzE,YAAY,CAACN,IAAI,IAAI,IAAI,CAACM,YAAY,CAAC0E,MAAM,GAAG,CAAC,EAAE;UACxD;UACA,IAAI,IAAI,CAACC,iBAAiB,EAAE;YACxB,IAAI,CAAC3E,YAAY,CAAC4E,UAAU,CAAC,IAAI,CAAC9D,oBAAoB,EAAE,IAAI,CAACC,kBAAkB,CAAC;YAChF,IAAI,CAACb,eAAe,EAAE;YACtB,IAAI,CAACyE,iBAAiB,GAAG,KAAK;YAC9B,IAAI,CAAC/D,aAAa,GAAG,IAAI,CAACZ,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC5D,oBAAoB;YACzE,IAAI,CAACH,YAAY,GAAG,KAAK;YACzB,IAAI0D,GAAG,EAAE;cACLA,GAAG,CAACI,cAAc,EAAE;;YAExB;;UAEJ;UACA,IAAI,IAAI,CAAC7D,aAAa,KAAK,CAAC,EAAE;YAC1B,IAAI,CAAClB,IAAI,GAAG,IAAI,CAACM,YAAY,CAAC6E,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC7E,YAAY,CAAC0E,MAAM,GAAG,CAAC,CAAC;WACxE,MAAM;YACH,MAAMI,cAAc,GAAG,IAAI,CAAC9E,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC9D,aAAa;YACpE,IAAIkE,cAAc,GAAG,CAAC,EAAE;cACpB,IAAI,CAAC9E,YAAY,CAAC4E,UAAU,CAACE,cAAc,GAAG,CAAC,EAAEA,cAAc,CAAC;cAChE,IAAI,CAAC5E,eAAe,EAAE;;;;QAIlC,IAAImE,GAAG,EAAE;UACLA,GAAG,CAACI,cAAc,EAAE;;QAExB;MACJ,KAAK,EAAE;QAAE;QACL,IAAI,IAAI,CAACE,iBAAiB,EAAE;UACxB,IAAI,CAAC3E,YAAY,CAAC4E,UAAU,CAAC,IAAI,CAAC9D,oBAAoB,EAAE,IAAI,CAACC,kBAAkB,CAAC;UAChF,IAAI,CAACb,eAAe,EAAE;UACtB,IAAI,CAACyE,iBAAiB,GAAG,KAAK;UAC9B,IAAI,CAAC/D,aAAa,GAAG,IAAI,CAACZ,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC5D,oBAAoB;UACzE,IAAIuD,GAAG,EAAE;YACLA,GAAG,CAACI,cAAc,EAAE;;UAExB;;QAEJ,IAAI,IAAI,CAACzE,YAAY,CAACN,IAAI,IAAI,IAAI,CAACM,YAAY,CAAC0E,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC9D,aAAa,GAAG,CAAC,EAAE;UAClF,MAAMkE,cAAc,GAAG,IAAI,CAAC9E,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC9D,aAAa;UACpE,IAAI,CAACZ,YAAY,CAAC4E,UAAU,CAACE,cAAc,EAAEA,cAAc,GAAG,CAAC,CAAC;UAChE,IAAI,CAAC5E,eAAe,EAAE;UACtB,IAAI,CAACU,aAAa,EAAE;;QAExB,IAAIyD,GAAG,EAAE;UACLA,GAAG,CAACI,cAAc,EAAE;;QAExB;MACJ,KAAK,EAAE;QAAE;QACL,IAAI,CAACnH,KAAK,CAACuF,cAAc,GAAG,IAAI;QAChC,IAAI,CAAC8B,iBAAiB,GAAG,KAAK;QAC9B;MACJ,KAAK,EAAE;QAAE;QACL,IAAI,CAAC/D,aAAa,GAAG,CAAC;QACtB,IAAI,CAACD,YAAY,GAAG,KAAK;QACzB,IAAI,CAACgE,iBAAiB,GAAG,KAAK;QAC9B,IAAI,CAAC9G,YAAY,EAAE;QACnB;MACJ,KAAK,EAAE;QAAE;QACL,IAAI,CAAC+C,aAAa,GAAG,IAAI,CAACZ,YAAY,CAAC0E,MAAM;QAC7C,IAAI,CAAC/D,YAAY,GAAG,KAAK;QACzB,IAAI,CAACgE,iBAAiB,GAAG,KAAK;QAC9B,IAAI,CAAC9G,YAAY,EAAE;QACnB;MACJ,KAAK,EAAE;QAAE;QACL,IAAI,CAAC+C,aAAa,EAAE;QACpB,IAAI,IAAI,CAACA,aAAa,GAAG,IAAI,CAACZ,YAAY,CAAC0E,MAAM,EAAE;UAC/C,IAAI,CAAC9D,aAAa,GAAG,IAAI,CAACZ,YAAY,CAAC0E,MAAM;;QAGjD,IAAIL,GAAG,IAAIA,GAAG,CAACU,QAAQ,EAAE;UACrB;UACA,IAAI,CAACpE,YAAY,GAAG,KAAK;UACzB;UACA,IAAI0D,GAAG,CAACE,OAAO,IAAIF,GAAG,CAACG,OAAO,EAAE;YAC5B,IAAI,CAAC,IAAI,CAACG,iBAAiB,EAAE;cACzB,IAAI,IAAI,CAAC3E,YAAY,CAAC0E,MAAM,KAAK,IAAI,CAAC9D,aAAa,EAAE;gBACjD;eACH,MAAM;gBACH,IAAI,CAACG,kBAAkB,GAAG,IAAI,CAACf,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC9D,aAAa,GAAG,CAAC;;;YAGnF,IAAI,CAACE,oBAAoB,GAAG,CAAC;YAC7B,IAAI,CAACE,YAAY,GAAG,IAAI,CAAChB,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC3D,kBAAkB;YACtE,IAAI,CAACH,aAAa,GAAG,IAAI,CAACZ,YAAY,CAAC0E,MAAM;YAC7C,IAAI,CAACC,iBAAiB,GAAG,IAAI;YAC7B,IAAI,CAAC9G,YAAY,EAAE;YACnB;;UAEJ;UACA,IAAI,CAAC,IAAI,CAAC8G,iBAAiB,EAAE;YACzB,IAAI,CAACA,iBAAiB,GAAG,IAAI;YAC7B,IAAI,CAAC3D,YAAY,GAAG,IAAI,CAACJ,aAAa,IAAI,IAAI,CAACZ,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC1E,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC9D,aAAa,GAAG,CAAC;;UAE1H;UAAA,KACK,IAAI,IAAI,CAACI,YAAY,KAAK,CAAC,CAAC,EAAE;YAC/B,IAAI,CAACA,YAAY,GAAG,IAAI,CAAChB,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC3D,kBAAkB;YACtE,IAAI,CAACH,aAAa,GAAG,IAAI,CAACE,oBAAoB,KAAK,CAAC,GAAG,IAAI,CAACd,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC1E,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC5D,oBAAoB,GAAG,CAAC;;UAE9I;UACA,IAAI,IAAI,CAACE,YAAY,GAAG,IAAI,CAACJ,aAAa,EAAE;YACxC,IAAI,CAACG,kBAAkB,GAAG,IAAI,CAACf,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC1D,YAAY;YACtE,IAAI,CAACF,oBAAoB,GAAG,IAAI,CAACd,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC9D,aAAa;WAC5E,MAAM,IAAI,IAAI,CAACI,YAAY,GAAG,IAAI,CAACJ,aAAa,EAAE;YAC/C,IAAI,CAACG,kBAAkB,GAAG,IAAI,CAACf,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC9D,aAAa;YACvE,IAAI,CAACE,oBAAoB,GAAG,IAAI,CAACd,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC1D,YAAY;WAC3E,MAAM;YACH,IAAI,CAAC2D,iBAAiB,GAAG,KAAK;;UAElC,IAAI,CAAC9G,YAAY,EAAE;UACnB;;QAEJ,IAAI,IAAI,CAAC8G,iBAAiB,EAAE;UACxB,IAAI,CAAC/D,aAAa,GAAG,IAAI,CAACZ,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC5D,oBAAoB;UACzE,IAAI,CAAC6D,iBAAiB,GAAG,KAAK;;QAElC,IAAIN,GAAG,KAAKA,GAAG,CAACE,OAAO,IAAIF,GAAG,CAACG,OAAO,CAAC,EAAE;UACrC,IAAI,CAAC5D,aAAa,GAAG,IAAI,CAACZ,YAAY,CAAC0E,MAAM;UAC7CL,GAAG,CAACI,cAAc,EAAE;;QAExB,IAAI,CAAC9D,YAAY,GAAG,KAAK;QACzB,IAAI,CAACgE,iBAAiB,GAAG,KAAK;QAC9B,IAAI,CAAC3D,YAAY,GAAG,CAAC,CAAC;QACtB,IAAI,CAACnD,YAAY,EAAE;QACnB;MACJ,KAAK,EAAE;QAAE;QACL,IAAI,CAAC+C,aAAa,EAAE;QACpB,IAAI,IAAI,CAACA,aAAa,GAAG,CAAC,EAAE;UACxB,IAAI,CAACA,aAAa,GAAG,CAAC;;QAE1B,IAAIyD,GAAG,IAAIA,GAAG,CAACU,QAAQ,EAAE;UACrB;UACA,IAAI,CAACpE,YAAY,GAAG,KAAK;UACzB;UACA,IAAI0D,GAAG,CAACE,OAAO,IAAIF,GAAG,CAACG,OAAO,EAAE;YAC5B,IAAI,CAAC,IAAI,CAACG,iBAAiB,EAAE;cACzB,IAAI,IAAI,CAAC/D,aAAa,KAAK,CAAC,EAAE;gBAC1B;eACH,MAAM;gBACH,IAAI,CAACE,oBAAoB,GAAG,IAAI,CAACd,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC9D,aAAa,GAAG,CAAC;;;YAGrF,IAAI,CAACG,kBAAkB,GAAG,IAAI,CAACf,YAAY,CAAC0E,MAAM;YAClD,IAAI,CAACC,iBAAiB,GAAG,IAAI;YAC7B,IAAI,CAAC3D,YAAY,GAAG,IAAI,CAAChB,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC5D,oBAAoB;YACxE,IAAI,CAACF,aAAa,GAAG,CAAC;YACtB,IAAI,CAAC/C,YAAY,EAAE;YACnB;;UAGJ,IAAI,CAAC,IAAI,CAAC8G,iBAAiB,EAAE;YACzB,IAAI,CAACA,iBAAiB,GAAG,IAAI;YAC7B,IAAI,CAAC3D,YAAY,GAAG,IAAI,CAACJ,aAAa,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,CAACA,aAAa,GAAG,CAAC;;UAE5E;UAAA,KACK,IAAI,IAAI,CAACI,YAAY,KAAK,CAAC,CAAC,EAAE;YAC/B,IAAI,CAACA,YAAY,GAAG,IAAI,CAAChB,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC5D,oBAAoB;YACxE,IAAI,CAACF,aAAa,GAAG,IAAI,CAACZ,YAAY,CAAC0E,MAAM,KAAK,IAAI,CAAC3D,kBAAkB,GAAG,CAAC,GAAG,IAAI,CAACf,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC3D,kBAAkB,GAAG,CAAC;;UAE1I;UACA,IAAI,IAAI,CAACC,YAAY,GAAG,IAAI,CAACJ,aAAa,EAAE;YACxC,IAAI,CAACG,kBAAkB,GAAG,IAAI,CAACf,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC1D,YAAY;YACtE,IAAI,CAACF,oBAAoB,GAAG,IAAI,CAACd,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC9D,aAAa;WAC5E,MAAM,IAAI,IAAI,CAACI,YAAY,GAAG,IAAI,CAACJ,aAAa,EAAE;YAC/C,IAAI,CAACG,kBAAkB,GAAG,IAAI,CAACf,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC9D,aAAa;YACvE,IAAI,CAACE,oBAAoB,GAAG,IAAI,CAACd,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC1D,YAAY;WAC3E,MAAM;YACH,IAAI,CAAC2D,iBAAiB,GAAG,KAAK;;UAElC,IAAI,CAAC9G,YAAY,EAAE;UACnB;;QAEJ,IAAI,IAAI,CAAC8G,iBAAiB,EAAE;UACxB,IAAI,CAAC/D,aAAa,GAAG,IAAI,CAACZ,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC3D,kBAAkB;UACvE,IAAI,CAAC4D,iBAAiB,GAAG,KAAK;;QAElC;QACA,IAAIN,GAAG,KAAKA,GAAG,CAACE,OAAO,IAAIF,GAAG,CAACG,OAAO,CAAC,EAAE;UACrC,IAAI,CAAC5D,aAAa,GAAG,CAAC;UACtByD,GAAG,CAACI,cAAc,EAAE;;QAExB,IAAI,CAAC9D,YAAY,GAAG,KAAK;QACzB,IAAI,CAACgE,iBAAiB,GAAG,KAAK;QAC9B,IAAI,CAAC3D,YAAY,GAAG,CAAC,CAAC;QACtB,IAAI,CAACnD,YAAY,EAAE;QACnB;;IAER,IAAIuG,OAAO,KAAK,EAAE,EAAE;MAChBrE,GAAG,GAAG,CAAAiF,EAAA,GAAAX,GAAG,aAAHA,GAAG,uBAAHA,GAAG,CAAEtE,GAAG,cAAAiF,EAAA,cAAAA,EAAA,GAAI,GAAG;;IAEzB,IAAI,CAAC1F,QAAQ,GAAGS,GAAG,KAAK,MAAM;IAC9B;IACA,IACIA,GAAG,KACFqE,OAAO,KAAK,CAAC,CAAC;IAAI;IACfA,OAAO,KAAK,EAAE;IAAI;IAClBA,OAAO,KAAK,EAAE;IAAI;IAClBA,OAAO,KAAK,EAAE;IAAI;IACjBA,OAAO,GAAG,EAAE,IAAIA,OAAO,GAAG,EAAG;IAAI;IACjCA,OAAO,GAAG,EAAE,IAAIA,OAAO,GAAG,EAAG;IAAI;IACjCA,OAAO,GAAG,GAAG,IAAIA,OAAO,GAAG,GAAI;IAAI;IACnCA,OAAO,GAAG,GAAG,IAAIA,OAAO,GAAG,GAAI;IAAI;IACnCA,OAAO,GAAG,EAAE,IAAIA,OAAO,GAAG,GAAI,CAAC,EACtC;MACE;MACA,IAAI,CAACtE,WAAW,GAAGC,GAAG;MACtB,IAAI,CAACqB,wBAAwB,CAAChB,eAAe,CAAC,IAAI,CAAC;MACnDL,GAAG,GAAG,IAAI,CAACD,WAAW;MACtB,IAAI,IAAI,CAACF,OAAO,IAAI,CAAC,IAAI,CAACN,QAAQ,EAAE;QAChC,IAAI,IAAI,CAACqF,iBAAiB,EAAE;UACxB,IAAI,CAAC3E,YAAY,CAAC4E,UAAU,CAAC,IAAI,CAAC9D,oBAAoB,EAAE,IAAI,CAACC,kBAAkB,EAAEhB,GAAG,CAAC;UACrF,IAAI,CAACG,eAAe,EAAE;UACtB,IAAI,CAACU,aAAa,GAAG,IAAI,CAACZ,YAAY,CAAC0E,MAAM,IAAI,IAAI,CAAC5D,oBAAoB,GAAG,CAAC,CAAC;UAC/E,IAAI,CAAC6D,iBAAiB,GAAG,KAAK;UAC9B,IAAI,CAAChE,YAAY,GAAG,KAAK;UACzB,IAAI,CAAC9C,YAAY,EAAE;SACtB,MAAM,IAAI,IAAI,CAAC+C,aAAa,KAAK,CAAC,EAAE;UACjC,IAAI,CAAClB,IAAI,IAAI,IAAI,CAACJ,QAAQ,KAAI+E,GAAG,aAAHA,GAAG,uBAAHA,GAAG,CAAEtE,GAAG,IAAGsE,GAAG,CAACtE,GAAG,GAAGA,GAAG;SACzD,MAAM;UACH,MAAMkF,cAAc,GAAG,IAAI,CAACjF,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC9D,aAAa;UACpE,IAAI,CAACZ,YAAY,CAAC4E,UAAU,CAACK,cAAc,EAAEA,cAAc,EAAElF,GAAG,CAAC;UACjE,IAAI,CAACG,eAAe,EAAE;;;;EAItC;EAEA;;;EAGUgF,2BAA2BA,CAACC,MAAc;IAChD;IACA,IAAI,CAACxE,YAAY,GAAG,KAAK;IAEzB,IAAI,IAAI,CAACK,YAAY,KAAK,CAAC,CAAC,EAAE;MAC1B,IAAI,CAACA,YAAY,GAAGmE,MAAM;KAC7B,MAAM;MACH,IAAI,IAAI,CAACnE,YAAY,GAAG,IAAI,CAACJ,aAAa,EAAE;QACxC,IAAI,CAACG,kBAAkB,GAAG,IAAI,CAACf,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC1D,YAAY;QACtE,IAAI,CAACF,oBAAoB,GAAG,IAAI,CAACd,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC9D,aAAa;OAC5E,MAAM,IAAI,IAAI,CAACI,YAAY,GAAG,IAAI,CAACJ,aAAa,EAAE;QAC/C,IAAI,CAACG,kBAAkB,GAAG,IAAI,CAACf,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC9D,aAAa;QACvE,IAAI,CAACE,oBAAoB,GAAG,IAAI,CAACd,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC1D,YAAY;OAC3E,MAAM;QACH,IAAI,CAAC2D,iBAAiB,GAAG,KAAK;QAC9B,IAAI,CAAC9G,YAAY,EAAE;QACnB;;;IAGR,IAAI,CAAC8G,iBAAiB,GAAG,IAAI;IAC7B,IAAI,CAAC9G,YAAY,EAAE;EACvB;EACA;;;EAGA;EACU8F,gBAAgBA,CAACU,GAAgB;IACvC;IACA,IAAI,CAACvD,oBAAoB,GAAG,IAAI,CAACd,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC9D,aAAa;IACzE,IAAI,CAACG,kBAAkB,GAAG,IAAI,CAACD,oBAAoB;IACnD,IAAIsE,QAAQ,EAAEC,SAAS;IACvB,GAAG;MACCA,SAAS,GAAG,IAAI,CAACtE,kBAAkB,GAAG,IAAI,CAACf,YAAY,CAAC0E,MAAM,IAAI,IAAI,CAAC1E,YAAY,CAACsF,MAAM,CAAC,IAAI,CAACvE,kBAAkB,CAAC,GAAG,EAAE,IAAI,CAACA,kBAAkB,GAAG,CAAC;MACnJqE,QAAQ,GAAG,IAAI,CAACtE,oBAAoB,GAAG,CAAC,IAAI,IAAI,CAACd,YAAY,CAACsF,MAAM,CAAC,IAAI,CAACxE,oBAAoB,GAAG,CAAC,CAAC,GAAG,EAAE,IAAI,CAACA,oBAAoB,GAAG,CAAC;KACxI,QAAQsE,QAAQ,IAAIC,SAAS;IAE9B,IAAI,CAACzE,aAAa,GAAG,IAAI,CAACZ,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC5D,oBAAoB;IAEzE,IAAI,CAAC6D,iBAAiB,GAAG,IAAI;IAC7B,IAAI,CAACY,kBAAkB,GAAG,IAAI;IAC9B,IAAI,CAAC5E,YAAY,GAAG,IAAI;IACxB,IAAI,CAACK,YAAY,GAAG,CAAC,CAAC;IACtB,IAAI,CAACnD,YAAY,EAAE;EACvB;EACA;EACU+F,cAAcA,CAAA;IACpB,IAAI,CAACjD,YAAY,GAAG,IAAI;IACxB,IAAI,CAACgE,iBAAiB,GAAG,IAAI;IAE7B,IAAI,CAAC7D,oBAAoB,GAAG,CAAC;IAC7B,IAAI,CAACC,kBAAkB,GAAG,IAAI,CAACf,YAAY,CAAC0E,MAAM;IAClD,IAAI,CAAC9D,aAAa,GAAG,IAAI,CAACZ,YAAY,CAAC0E,MAAM;IAC7C,IAAI,CAAC1D,YAAY,GAAG,CAAC,CAAC;IACtB,IAAI,CAACnD,YAAY,EAAE;EACvB;EAEA;;;;EAIO2H,eAAeA,CAACnB,GAAmB;IACtC;IACA,IAAI,CAACF,UAAU,CAACE,GAAG,CAACD,OAAO,EAAEC,GAAG,CAACtE,GAAG,EAAEsE,GAAG,CAAC;IAE1C,IAAI,CAAC1C,kCAAkC,CAACvB,eAAe,CAACiE,GAAG,CAAC;EAChE;EAEA;;;EAGUlB,WAAWA,CAACsC,EAAkB;IACpC,IAAI,CAACd,iBAAiB,GAAG,KAAK;IAC9B;IACA,IAAI;MACAc,EAAE,CAACC,aAAa,IAAID,EAAE,CAACC,aAAa,CAACC,OAAO,CAAC,YAAY,EAAE,IAAI,CAAClG,gBAAgB,CAAC;KACpF,CAAC,OAAAuF,EAAA,EAAM,EAAE,CAAC;IACX,IAAI,CAAC1H,KAAK,CAACoI,aAAa,GAAG,IAAI,CAACjG,gBAAgB;EACpD;EACA;;;EAGU6D,UAAUA,CAACmC,EAAkB;IACnC,IAAI,CAAC,IAAI,CAAChG,gBAAgB,EAAE;MACxB;;IAEJ,IAAI,CAACO,YAAY,CAAC4E,UAAU,CAAC,IAAI,CAAC9D,oBAAoB,EAAE,IAAI,CAACC,kBAAkB,CAAC;IAChF,IAAI,CAACb,eAAe,EAAE;IACtB,IAAI,CAACyE,iBAAiB,GAAG,KAAK;IAC9B,IAAI,CAAC/D,aAAa,GAAG,IAAI,CAACZ,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC5D,oBAAoB;IACzE;IACA,IAAI;MACA2E,EAAE,CAACC,aAAa,IAAID,EAAE,CAACC,aAAa,CAACC,OAAO,CAAC,YAAY,EAAE,IAAI,CAAClG,gBAAgB,CAAC;KACpF,CAAC,OAAAuF,EAAA,EAAM,EAAE,CAAC;IAEX,IAAI,CAAC1H,KAAK,CAACoI,aAAa,GAAG,IAAI,CAACjG,gBAAgB;IAChD,IAAI,CAACA,gBAAgB,GAAG,EAAE;EAC9B;EACA;;;EAGU+D,YAAYA,CAACiC,EAAkB;IACrC,IAAIG,IAAI,GAAW,EAAE;IACrB,IAAIH,EAAE,CAACC,aAAa,IAAID,EAAE,CAACC,aAAa,CAACG,KAAK,CAACC,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,EAAE;MACzEF,IAAI,GAAGH,EAAE,CAACC,aAAa,CAACK,OAAO,CAAC,YAAY,CAAC;KAChD,MAAM;MACH;MACAH,IAAI,GAAG,IAAI,CAACtI,KAAK,CAACoI,aAAa;;IAEnC,MAAMT,cAAc,GAAG,IAAI,CAACjF,YAAY,CAAC0E,MAAM,GAAG,IAAI,CAAC9D,aAAa;IACpE,IAAI,CAACZ,YAAY,CAAC4E,UAAU,CAACK,cAAc,EAAEA,cAAc,EAAEW,IAAI,CAAC;IAClE,IAAI,CAAC1F,eAAe,EAAE;EAC1B;EAEO8F,KAAKA,CAACC,OAAgC;IACzCA,OAAO,CAACC,IAAI,EAAE;IAEd,IAAI,CAACC,YAAY,CAACF,OAAO,CAAC;IAC1B,IAAI,IAAI,CAACG,UAAU,IAAI,IAAI,CAACC,aAAa,IAAI,IAAI,CAACC,aAAa,EAAE;MAC7DL,OAAO,CAACM,WAAW,GAAG,IAAI,CAACA,WAAW;MACtCN,OAAO,CAACG,UAAU,GAAG,IAAI,CAACA,UAAU;MACpCH,OAAO,CAACI,aAAa,GAAG,IAAI,CAACA,aAAa;MAC1CJ,OAAO,CAACK,aAAa,GAAG,IAAI,CAACA,aAAa;;IAG9C;IACA,IAAI,IAAI,CAAC5F,UAAU,EAAE;MACjB,IAAI,IAAI,CAAC9B,kBAAkB,EAAE;QACzBqH,OAAO,CAACO,SAAS,GAAG,IAAI,CAAC9D,UAAU,GAAG,IAAI,CAAC9D,kBAAkB,GAAG,IAAI,CAAC6H,cAAc;QAEnFR,OAAO,CAACS,QAAQ,CAAC,IAAI,CAACC,eAAe,CAACC,IAAI,EAAE,IAAI,CAACD,eAAe,CAACE,GAAG,EAAE,IAAI,CAACF,eAAe,CAACjJ,KAAK,EAAE,IAAI,CAACiJ,eAAe,CAACG,MAAM,CAAC;;KAErI,MAAM,IAAI,IAAI,CAAC9H,WAAW,EAAE;MACzBiH,OAAO,CAACO,SAAS,GAAG,IAAI,CAAC9D,UAAU,GAAG,IAAI,CAAC1D,WAAW,GAAG,IAAI,CAACyH,cAAc;MAE5ER,OAAO,CAACS,QAAQ,CAAC,IAAI,CAACC,eAAe,CAACC,IAAI,EAAE,IAAI,CAACD,eAAe,CAACE,GAAG,EAAE,IAAI,CAACF,eAAe,CAACjJ,KAAK,EAAE,IAAI,CAACiJ,eAAe,CAACG,MAAM,CAAC;;IAGlI,IAAI,IAAI,CAACV,UAAU,IAAI,IAAI,CAACC,aAAa,IAAI,IAAI,CAACC,aAAa,EAAE;MAC7DL,OAAO,CAACG,UAAU,GAAG,CAAC;MACtBH,OAAO,CAACI,aAAa,GAAG,CAAC;MACzBJ,OAAO,CAACK,aAAa,GAAG,CAAC;;IAG7B,IAAI,CAAC,IAAI,CAACS,WAAW,IAAI,IAAI,CAACC,SAAS,EAAE;MACrC,IAAI,CAACD,WAAW,GAAGlK,OAAO,CAACoK,cAAc,CAAChB,OAAO,CAACiB,IAAI,CAAC;;IAG3D;IACA,MAAMC,YAAY,GAAG,IAAI,CAACR,eAAe,CAACC,IAAI,GAAG,IAAI,CAACvI,OAAO,CAACb,eAAe,CAAC,IAAI,CAACF,KAAK,EAAE,IAAI,CAAC8J,kBAAkB,CAAC1J,KAAK,CAAC;IACxH,IAAI,IAAI,CAAC2J,KAAK,EAAE;MACZpB,OAAO,CAACO,SAAS,GAAG,IAAI,CAACa,KAAK;;IAGlC,IAAI3H,IAAI,GAAG,IAAI,CAAC4H,iBAAiB,CAAC,IAAI,CAACtH,YAAY,CAAC;IAEpD,IAAI,CAAC,IAAI,CAACU,UAAU,IAAI,CAAC,IAAI,CAACV,YAAY,CAACN,IAAI,IAAI,IAAI,CAACN,gBAAgB,EAAE;MACtEM,IAAI,GAAG,IAAI1C,WAAW,EAAE;MACxB0C,IAAI,CAACA,IAAI,GAAG,IAAI,CAACN,gBAAgB;MAEjC,IAAI,IAAI,CAACF,iBAAiB,EAAE;QACxB+G,OAAO,CAACO,SAAS,GAAG,IAAI,CAACtH,iBAAiB;;;IAIlD,IAAI,CAACqI,UAAU,GAAGtB,OAAO,CAACuB,WAAW,CAAC9H,IAAI,CAACA,IAAI,CAAC,CAAChC,KAAK;IACtD,MAAM+J,WAAW,GAAG,IAAI,CAACpJ,OAAO,CAACb,eAAe,CAAC,IAAI,CAACF,KAAK,EAAE,IAAI,CAAC8J,kBAAkB,CAAC1J,KAAK,CAAC,GAAG,CAAC;IAC/F,IAAI,IAAI,CAACc,iBAAiB,EAAE;MACxB,IAAI,CAACd,KAAK,GAAGgK,IAAI,CAACC,GAAG,CAAC,IAAI,CAACvK,SAAS,CAACI,eAAe,CAAC,IAAI,CAACF,KAAK,EAAE,IAAI,CAAC8J,kBAAkB,CAAC1J,KAAK,CAAC,EAAE,IAAI,CAAC6J,UAAU,GAAGE,WAAW,CAAC,GAAG,IAAI;MACtI,IAAI,CAACjJ,iBAAiB,GAAG,IAAI,CAAC,CAAC;;;IAGnC,MAAMoJ,KAAK,GAAG,IAAI,CAACb,WAAW,CAACc,MAAM,GAAG,CAAC,IAAI,CAAClB,eAAe,CAACG,MAAM,GAAG,IAAI,CAACC,WAAW,CAACD,MAAM,IAAI,CAAC;IACnG,MAAMgB,cAAc,GAAG,IAAI,CAACzH,MAAM,CAAC7C,eAAe,CAAC,IAAI,CAACF,KAAK,EAAE,IAAI,CAAC8J,kBAAkB,CAAC1J,KAAK,CAAC,GAAG+J,WAAW;IAE3GxB,OAAO,CAACC,IAAI,EAAE;IACdD,OAAO,CAAC8B,SAAS,EAAE;IACnB9B,OAAO,CAAC+B,IAAI,CAACb,YAAY,EAAE,IAAI,CAACR,eAAe,CAACE,GAAG,GAAG,CAAC,IAAI,CAACF,eAAe,CAACG,MAAM,GAAG,IAAI,CAACC,WAAW,CAACD,MAAM,IAAI,CAAC,EAAEgB,cAAc,GAAG,CAAC,EAAE,IAAI,CAACnB,eAAe,CAACG,MAAM,CAAC;IACnKb,OAAO,CAACgC,IAAI,EAAE;IAEd,IAAI,IAAI,CAACvH,UAAU,IAAI,IAAI,CAAC6G,UAAU,GAAGO,cAAc,EAAE;MACrD,MAAMI,QAAQ,GAAGf,YAAY,GAAG,IAAI,CAACI,UAAU,GAAGO,cAAc;MAChE,IAAI,CAAC,IAAI,CAAChG,WAAW,EAAE;QACnB,IAAI,CAACA,WAAW,GAAGoG,QAAQ;;KAElC,MAAM;MACH,IAAI,CAACpG,WAAW,GAAGqF,YAAY;;IAGnClB,OAAO,CAACkC,QAAQ,CAACzI,IAAI,CAACA,IAAI,EAAE,IAAI,CAACoC,WAAW,EAAE,IAAI,CAAC6E,eAAe,CAACE,GAAG,GAAGe,KAAK,CAAC;IAE/E;IACA,IAAI,IAAI,CAAClH,UAAU,EAAE;MACjB;MACA,IAAI,IAAI,CAAC6E,kBAAkB,EAAE;QACzB,MAAM6C,aAAa,GAAG,IAAI,CAACtG,WAAW,GAAG,IAAI,CAACyF,UAAU;QACxD,MAAMc,sBAAsB,GAAGD,aAAa,GAAG,IAAI,CAAC7C,kBAAkB;QACtE,IAAI+C,WAAW,GAAG,CAAC;QACnB,IAAI,CAAC1H,aAAa,GAAG,CAAC;QACtB,IAAI2H,YAAY,GAAG,CAAC;QACpB,GAAG;UACC,IAAI,IAAI,CAAC3H,aAAa,EAAE;YACpB2H,YAAY,GAAGb,IAAI,CAACc,GAAG,CAACH,sBAAsB,GAAGC,WAAW,CAAC;;UAEjE,IAAI,CAAC1H,aAAa,EAAE;UACpB0H,WAAW,GAAGrC,OAAO,CAACuB,WAAW,CAAC9H,IAAI,CAACmF,MAAM,CAACnF,IAAI,CAACgF,MAAM,GAAG,IAAI,CAAC9D,aAAa,EAAE,IAAI,CAACA,aAAa,CAAC,CAAC,CAAClD,KAAK;SAC7G,QAAQ4K,WAAW,GAAGD,sBAAsB,IAAI3I,IAAI,CAACgF,MAAM,IAAI,IAAI,CAAC9D,aAAa;QAElF;QACA,IAAI8G,IAAI,CAACc,GAAG,CAACH,sBAAsB,GAAGC,WAAW,CAAC,GAAGC,YAAY,EAAE;UAC/D,IAAI,CAAC3H,aAAa,EAAE;;QAGxB,IAAI,CAACD,YAAY,GAAG,KAAK;QACzB,IAAI,CAAC4E,kBAAkB,GAAG,IAAI;;MAGlC;MACA,IAAI,CAAC,IAAI,CAAC5E,YAAY,EAAE;QACpB,MAAM8H,gBAAgB,GAAG/I,IAAI,CAACmF,MAAM,CAACnF,IAAI,CAACgF,MAAM,GAAG,IAAI,CAAC9D,aAAa,CAAC;QACtE,MAAM8H,iBAAiB,GAAGzC,OAAO,CAACuB,WAAW,CAACiB,gBAAgB,CAAC,CAAC/K,KAAK;QACrE,IAAIiL,UAAU,GAAG,IAAI,CAAC7G,WAAW,GAAG,IAAI,CAACyF,UAAU,GAAGmB,iBAAiB;QAEvE,IAAIC,UAAU,GAAGxB,YAAY,EAAE;UAC3B,IAAI,CAACrF,WAAW,IAAIqF,YAAY,GAAGwB,UAAU;UAC7CA,UAAU,GAAGxB,YAAY;UACzB,IAAI,CAACtJ,YAAY,EAAE;SACtB,MAAM,IAAI8K,UAAU,GAAGxB,YAAY,GAAGW,cAAc,EAAE;UACnD,IAAI,CAAChG,WAAW,IAAIqF,YAAY,GAAGW,cAAc,GAAGa,UAAU;UAC9DA,UAAU,GAAGxB,YAAY,GAAGW,cAAc;UAC1C,IAAI,CAACjK,YAAY,EAAE;;QAEvB,IAAI,CAAC,IAAI,CAAC8G,iBAAiB,EAAE;UACzBsB,OAAO,CAACS,QAAQ,CAACiC,UAAU,EAAE,IAAI,CAAChC,eAAe,CAACE,GAAG,GAAG,CAAC,IAAI,CAACF,eAAe,CAACG,MAAM,GAAG,IAAI,CAACC,WAAW,CAACD,MAAM,IAAI,CAAC,EAAE,CAAC,EAAE,IAAI,CAACC,WAAW,CAACD,MAAM,CAAC;;;MAIxJ/E,YAAY,CAAC,IAAI,CAACC,aAAa,CAAC;MAChC,IAAI,CAACA,aAAa,GAAQ4G,UAAU,CAAC,MAAK;QACtC,IAAI,CAACjI,YAAY,GAAG,CAAC,IAAI,CAACA,YAAY;QACtC,IAAI,CAAC9C,YAAY,EAAE;MACvB,CAAC,EAAE,GAAG,CAAC;MAEP;MACA,IAAI,IAAI,CAAC8G,iBAAiB,EAAE;QACxB5C,YAAY,CAAC,IAAI,CAACC,aAAa,CAAC;QAChC,MAAM6G,0BAA0B,GAAG5C,OAAO,CAACuB,WAAW,CAAC9H,IAAI,CAACoJ,SAAS,CAAC,IAAI,CAAChI,oBAAoB,CAAC,CAAC,CAACpD,KAAK;QACvG,IAAIqL,mBAAmB,GAAG,IAAI,CAACjH,WAAW,GAAG,IAAI,CAACyF,UAAU,GAAGsB,0BAA0B;QACzF,IAAI,CAACpJ,gBAAgB,GAAGC,IAAI,CAACoJ,SAAS,CAAC,IAAI,CAAChI,oBAAoB,EAAE,IAAI,CAACC,kBAAkB,CAAC;QAC1F,IAAIrD,KAAK,GAAGuI,OAAO,CAACuB,WAAW,CAAC9H,IAAI,CAACoJ,SAAS,CAAC,IAAI,CAAChI,oBAAoB,EAAE,IAAI,CAACC,kBAAkB,CAAC,CAAC,CAACrD,KAAK;QACzG,IAAIqL,mBAAmB,GAAG5B,YAAY,EAAE;UACpCzJ,KAAK,GAAGA,KAAK,IAAIyJ,YAAY,GAAG4B,mBAAmB,CAAC;UACpD,IAAI,CAACrL,KAAK,EAAE;YACR;YACA;YACAA,KAAK,GAAGuI,OAAO,CAACuB,WAAW,CAAC9H,IAAI,CAACsJ,MAAM,CAACtJ,IAAI,CAACgF,MAAM,GAAG,IAAI,CAAC9D,aAAa,CAAC,CAAC,CAAClD,KAAK;;UAEpFqL,mBAAmB,GAAG5B,YAAY;;QAEtC;QACAlB,OAAO,CAACgD,WAAW,GAAG,IAAI,CAAClL,kBAAkB;QAC7CkI,OAAO,CAACO,SAAS,GAAG,IAAI,CAACrI,mBAAmB;QAC5C8H,OAAO,CAACS,QAAQ,CAACqC,mBAAmB,EAAE,IAAI,CAACpC,eAAe,CAACE,GAAG,GAAG,CAAC,IAAI,CAACF,eAAe,CAACG,MAAM,GAAG,IAAI,CAACC,WAAW,CAACD,MAAM,IAAI,CAAC,EAAEpJ,KAAK,EAAE,IAAI,CAACqJ,WAAW,CAACD,MAAM,CAAC;QAC7Jb,OAAO,CAACgD,WAAW,GAAG,GAAG;;;IAGjChD,OAAO,CAACiD,OAAO,EAAE;IAEjB;IACA,IAAI,IAAI,CAACxK,UAAU,EAAE;MACjB,IAAI,IAAI,CAACgC,UAAU,EAAE;QACjB,IAAI,IAAI,CAAC7B,YAAY,EAAE;UACnBoH,OAAO,CAACkD,WAAW,GAAG,IAAI,CAACtK,YAAY;;OAE9C,MAAM;QACH,IAAI,IAAI,CAACwI,KAAK,EAAE;UACZpB,OAAO,CAACkD,WAAW,GAAG,IAAI,CAAC9B,KAAK;;;MAIxCpB,OAAO,CAACmD,SAAS,GAAG,IAAI,CAAC1K,UAAU;MAEnCuH,OAAO,CAACoD,UAAU,CACd,IAAI,CAAC1C,eAAe,CAACC,IAAI,GAAG,IAAI,CAAClI,UAAU,GAAG,CAAC,EAC/C,IAAI,CAACiI,eAAe,CAACE,GAAG,GAAG,IAAI,CAACnI,UAAU,GAAG,CAAC,EAC9C,IAAI,CAACiI,eAAe,CAACjJ,KAAK,GAAG,IAAI,CAACgB,UAAU,EAC5C,IAAI,CAACiI,eAAe,CAACG,MAAM,GAAG,IAAI,CAACpI,UAAU,CAChD;;IAGLuH,OAAO,CAACiD,OAAO,EAAE;EACrB;EAEOI,cAAcA,CAACC,MAAe,EAAEC,WAAoB,EAAEC,SAAiB,EAAEC,WAAmB,EAAEC,EAAmB;IACpH,IAAI,CAAC,KAAK,CAACL,cAAc,CAACC,MAAM,EAAEC,WAAW,EAAEC,SAAS,EAAEC,WAAW,EAAEC,EAAE,CAAC,EAAE;MACxE,OAAO,KAAK;;IAGhB,IAAI,IAAI,CAACrF,UAAU,EAAE;MACjB,OAAO,IAAI;;IAGf,IAAI,CAACiB,kBAAkB,GAAGiE,WAAW,CAACI,CAAC;IACvC,IAAI,CAACjF,iBAAiB,GAAG,KAAK;IAC9B,IAAI,CAAClF,gBAAgB,GAAG,EAAE;IAC1B,IAAI,CAACuB,YAAY,GAAG,CAAC,CAAC;IACtB,IAAI,CAACC,cAAc,GAAG,IAAI;IAC1B,IAAI,CAAC3D,KAAK,CAACuM,iBAAiB,CAACJ,SAAS,CAAC,GAAG,IAAI;IAC9C,IAAI,CAAC9G,UAAU,GAAIgH,EAAE,CAACvG,KAAuB,CAAC0G,WAAW;IACzD,IAAI,IAAI,CAACxM,KAAK,CAACuF,cAAc,KAAK,IAAI,EAAE;MACpC;MACAd,YAAY,CAAC,IAAI,CAACC,aAAa,CAAC;MAChC,IAAI,CAACnE,YAAY,EAAE;MACnB,OAAO,IAAI;;IAEf,IAAI,CAAC,IAAI,CAAC6E,UAAU,EAAE;MAClB,OAAO,KAAK;;IAEhB,IAAI,CAACpF,KAAK,CAACuF,cAAc,GAAG,IAAI;IAEhC,OAAO,IAAI;EACf;EACOkH,cAAcA,CAACR,MAAe,EAAEC,WAAoB,EAAEC,SAAiB,EAAEE,EAAmB;IAC/F,IAAI,IAAI,CAACrM,KAAK,CAACuF,cAAc,KAAK,IAAI,IAAI,IAAI,CAAC5B,cAAc,IAAI,CAAC,IAAI,CAACqD,UAAU,EAAE;MAC/E,IAAI,CAACiB,kBAAkB,GAAGiE,WAAW,CAACI,CAAC;MACvC,IAAI,CAAC/L,YAAY,EAAE;MACnB,IAAI,CAACqH,2BAA2B,CAAC,IAAI,CAACtE,aAAa,CAAC;;IAExD,KAAK,CAACmJ,cAAc,CAACR,MAAM,EAAEC,WAAW,EAAEC,SAAS,EAAEE,EAAE,CAAC;EAC5D;EAEOK,YAAYA,CAACT,MAAe,EAAEC,WAAoB,EAAEC,SAAiB,EAAEC,WAAmB,EAAEO,WAAoB;IACnH,IAAI,CAAChJ,cAAc,GAAG,KAAK;IAC3B,OAAO,IAAI,CAAC3D,KAAK,CAACuM,iBAAiB,CAACJ,SAAS,CAAC;IAC9C,KAAK,CAACO,YAAY,CAACT,MAAM,EAAEC,WAAW,EAAEC,SAAS,EAAEC,WAAW,EAAEO,WAAW,CAAC;EAChF;EAEU3C,iBAAiBA,CAAC4C,WAAwB;IAChD,OAAOA,WAAW;EACtB;EAEA;EACA,IAAYvF,iBAAiBA,CAAChH,KAAc;IACxC,IAAI,IAAI,CAACkD,kBAAkB,KAAKlD,KAAK,EAAE;MACnC;;IAEJ,IAAIA,KAAK,EAAE;MACP,IAAI,CAAC4D,yBAAyB,CAACnB,eAAe,CAAC,IAAI,CAAC;;IAExD,IAAI,CAACS,kBAAkB,GAAGlD,KAAK;EACnC;EAEA;EACA,IAAYgH,iBAAiBA,CAAA;IACzB,OAAO,IAAI,CAAC9D,kBAAkB;EAClC;EAEOsJ,OAAOA,CAAA;IACV,KAAK,CAACA,OAAO,EAAE;IAEf,IAAI,CAAC7I,gBAAgB,CAAC8I,KAAK,EAAE;IAC7B,IAAI,CAAC/I,iBAAiB,CAAC+I,KAAK,EAAE;IAC9B,IAAI,CAACjK,uBAAuB,CAACiK,KAAK,EAAE;IACpC,IAAI,CAAC5I,oBAAoB,CAAC4I,KAAK,EAAE;IACjC,IAAI,CAAC3I,mBAAmB,CAAC2I,KAAK,EAAE;IAChC,IAAI,CAAC1I,qBAAqB,CAAC0I,KAAK,EAAE;IAClC,IAAI,CAAC7I,yBAAyB,CAAC6I,KAAK,EAAE;IACtC,IAAI,CAACzI,kCAAkC,CAACyI,KAAK,EAAE;EACnD;;AAvhCOC,UAAA,EADNpN,SAAS,EAAE,C,+CACgC;AAGrCoN,UAAA,EADNpN,SAAS,EAAE,C,qDACuB;AAuBnCoN,UAAA,EADCpN,SAAS,EAAE,C,wCAGX;AAmBDoN,UAAA,EADCpN,SAAS,EAAE,C,iDAGX;AAWDoN,UAAA,EADCpN,SAAS,EAAE,C,gDAGX;AAaDoN,UAAA,EADCpN,SAAS,EAAE,C,kDAGX;AAYDoN,UAAA,EADCpN,SAAS,EAAE,C,sCAGX;AAmBDoN,UAAA,EADCpN,SAAS,EAAE,C,gDAGX;AAaDoN,UAAA,EADCpN,SAAS,EAAE,C,yCAGX;AAaDoN,UAAA,EADCpN,SAAS,EAAE,C,iDAGX;AAaDoN,UAAA,EADCpN,SAAS,EAAE,C,4CAGX;AAaDoN,UAAA,EADCpN,SAAS,EAAE,C,0CAGX;AAaDoN,UAAA,EADCpN,SAAS,EAAE,C,gDAGX;AAaDoN,UAAA,EADCpN,SAAS,EAAE,C,+CAGX;AAYDoN,UAAA,EADCpN,SAAS,EAAE,C,uCAGX;AAsCDoN,UAAA,EADCpN,SAAS,EAAE,C,oCAGX;AAuBDoN,UAAA,EADCpN,SAAS,EAAE,C,qCAGX;AAgwBLF,aAAa,CAAC,uBAAuB,EAAEG,SAAS,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}