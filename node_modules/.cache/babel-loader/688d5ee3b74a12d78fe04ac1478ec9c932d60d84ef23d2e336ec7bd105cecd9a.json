{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { Vector2, Vector3 } from \"../Maths/math.vector.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial.js\";\nimport { Effect } from \"../Materials/effect.js\";\nimport { CreatePlane } from \"../Meshes/Builders/planeBuilder.js\";\nimport \"../Shaders/spriteMap.fragment.js\";\nimport \"../Shaders/spriteMap.vertex.js\";\n/**\n * Class used to manage a grid restricted sprite deployment on an Output plane.\n */\nexport class SpriteMap {\n  /** Returns the Number of Sprites in the System */\n  get spriteCount() {\n    return this.sprites.length;\n  }\n  /** Returns the Position of Output Plane*/\n  get position() {\n    return this._output.position;\n  }\n  /** Returns the Position of Output Plane*/\n  set position(v) {\n    this._output.position = v;\n  }\n  /** Returns the Rotation of Output Plane*/\n  get rotation() {\n    return this._output.rotation;\n  }\n  /** Returns the Rotation of Output Plane*/\n  set rotation(v) {\n    this._output.rotation = v;\n  }\n  /** Sets the AnimationMap*/\n  get animationMap() {\n    return this._animationMap;\n  }\n  /** Sets the AnimationMap*/\n  set animationMap(v) {\n    const buffer = v._texture._bufferView;\n    const am = this._createTileAnimationBuffer(buffer);\n    this._animationMap.dispose();\n    this._animationMap = am;\n    this._material.setTexture(\"animationMap\", this._animationMap);\n  }\n  /**\n   * Creates a new SpriteMap\n   * @param name defines the SpriteMaps Name\n   * @param atlasJSON is the JSON file that controls the Sprites Frames and Meta\n   * @param spriteSheet is the Texture that the Sprites are on.\n   * @param options a basic deployment configuration\n   * @param scene The Scene that the map is deployed on\n   */\n  constructor(name, atlasJSON, spriteSheet, options, scene) {\n    this.name = name;\n    this.sprites = [];\n    this.atlasJSON = atlasJSON;\n    this.sprites = this.atlasJSON[\"frames\"];\n    this.spriteSheet = spriteSheet;\n    /**\n     * Run through the options and set what ever defaults are needed that where not declared.\n     */\n    this.options = options;\n    options.stageSize = options.stageSize || new Vector2(1, 1);\n    options.outputSize = options.outputSize || options.stageSize;\n    options.outputPosition = options.outputPosition || Vector3.Zero();\n    options.outputRotation = options.outputRotation || Vector3.Zero();\n    options.layerCount = options.layerCount || 1;\n    options.maxAnimationFrames = options.maxAnimationFrames || 0;\n    options.baseTile = options.baseTile || 0;\n    options.flipU = options.flipU || false;\n    options.colorMultiply = options.colorMultiply || new Vector3(1, 1, 1);\n    this._scene = scene;\n    this._frameMap = this._createFrameBuffer();\n    this._tileMaps = new Array();\n    for (let i = 0; i < options.layerCount; i++) {\n      this._tileMaps.push(this._createTileBuffer(null, i));\n    }\n    this._animationMap = this._createTileAnimationBuffer(null);\n    const defines = [];\n    defines.push(\"#define LAYERS \" + options.layerCount);\n    if (options.flipU) {\n      defines.push(\"#define FLIPU\");\n    }\n    defines.push(`#define MAX_ANIMATION_FRAMES ${options.maxAnimationFrames}.0`);\n    const shaderString = Effect.ShadersStore[\"spriteMapPixelShader\"];\n    let layerSampleString;\n    if (!scene.getEngine()._features.supportSwitchCaseInShader) {\n      layerSampleString = \"\";\n      for (let i = 0; i < options.layerCount; i++) {\n        layerSampleString += `if (${i} == i) { frameID = texture2D(tileMaps[${i}], (tileID + 0.5) / stageSize, 0.).x; }`;\n      }\n    } else {\n      layerSampleString = \"switch(i) {\";\n      for (let i = 0; i < options.layerCount; i++) {\n        layerSampleString += \"case \" + i + \" : frameID = texture(tileMaps[\" + i + \"], (tileID + 0.5) / stageSize, 0.).x;\";\n        layerSampleString += \"break;\";\n      }\n      layerSampleString += \"}\";\n    }\n    Effect.ShadersStore[\"spriteMap\" + this.name + \"PixelShader\"] = shaderString.replace(\"#define LAYER_ID_SWITCH\", layerSampleString);\n    this._material = new ShaderMaterial(\"spriteMap:\" + this.name, this._scene, {\n      vertex: \"spriteMap\",\n      fragment: \"spriteMap\" + this.name\n    }, {\n      defines,\n      attributes: [\"position\", \"normal\", \"uv\"],\n      uniforms: [\"worldViewProjection\", \"time\", \"stageSize\", \"outputSize\", \"spriteMapSize\", \"spriteCount\", \"time\", \"colorMul\", \"mousePosition\", \"curTile\", \"flipU\"],\n      samplers: [\"spriteSheet\", \"frameMap\", \"tileMaps\", \"animationMap\"],\n      needAlphaBlending: true\n    });\n    this._time = 0;\n    this._material.setFloat(\"spriteCount\", this.spriteCount);\n    this._material.setVector2(\"stageSize\", options.stageSize);\n    this._material.setVector2(\"outputSize\", options.outputSize);\n    this._material.setTexture(\"spriteSheet\", this.spriteSheet);\n    this._material.setVector2(\"spriteMapSize\", new Vector2(1, 1));\n    this._material.setVector3(\"colorMul\", options.colorMultiply);\n    let tickSave = 0;\n    const bindSpriteTexture = () => {\n      if (this.spriteSheet && this.spriteSheet.isReady()) {\n        if (this.spriteSheet._texture) {\n          this._material.setVector2(\"spriteMapSize\", new Vector2(this.spriteSheet._texture.baseWidth || 1, this.spriteSheet._texture.baseHeight || 1));\n          return;\n        }\n      }\n      if (tickSave < 100) {\n        setTimeout(() => {\n          tickSave++;\n          bindSpriteTexture();\n        }, 100);\n      }\n    };\n    bindSpriteTexture();\n    this._material.setVector3(\"colorMul\", options.colorMultiply);\n    this._material.setTexture(\"frameMap\", this._frameMap);\n    this._material.setTextureArray(\"tileMaps\", this._tileMaps);\n    this._material.setTexture(\"animationMap\", this._animationMap);\n    this._material.setFloat(\"time\", this._time);\n    this._output = CreatePlane(name + \":output\", {\n      size: 1,\n      updatable: true\n    }, scene);\n    this._output.scaling.x = options.outputSize.x;\n    this._output.scaling.y = options.outputSize.y;\n    this.position = options.outputPosition;\n    this.rotation = options.outputRotation;\n    const obfunction = () => {\n      this._time += this._scene.getEngine().getDeltaTime();\n      this._material.setFloat(\"time\", this._time);\n    };\n    this._scene.onBeforeRenderObservable.add(obfunction);\n    this._output.material = this._material;\n  }\n  /**\n   * Returns tileID location\n   * @returns Vector2 the cell position ID\n   */\n  getTileID() {\n    const p = this.getMousePosition();\n    p.multiplyInPlace(this.options.stageSize || Vector2.Zero());\n    p.x = Math.floor(p.x);\n    p.y = Math.floor(p.y);\n    return p;\n  }\n  /**\n   * Gets the UV location of the mouse over the SpriteMap.\n   * @returns Vector2 the UV position of the mouse interaction\n   */\n  getMousePosition() {\n    const out = this._output;\n    const pickinfo = this._scene.pick(this._scene.pointerX, this._scene.pointerY, mesh => {\n      if (mesh !== out) {\n        return false;\n      }\n      return true;\n    });\n    if (!pickinfo || !pickinfo.hit || !pickinfo.getTextureCoordinates) {\n      return new Vector2(-1, -1);\n    }\n    const coords = pickinfo.getTextureCoordinates();\n    if (coords) {\n      return coords;\n    }\n    return new Vector2(-1, -1);\n  }\n  /**\n   * Creates the \"frame\" texture Buffer\n   * -------------------------------------\n   * Structure of frames\n   *  \"filename\": \"Falling-Water-2.png\",\n   * \"frame\": {\"x\":69,\"y\":103,\"w\":24,\"h\":32},\n   * \"rotated\": true,\n   * \"trimmed\": true,\n   * \"spriteSourceSize\": {\"x\":4,\"y\":0,\"w\":24,\"h\":32},\n   * \"sourceSize\": {\"w\":32,\"h\":32}\n   * @returns RawTexture of the frameMap\n   */\n  _createFrameBuffer() {\n    const data = new Array();\n    //Do two Passes\n    for (let i = 0; i < this.spriteCount; i++) {\n      data.push(0, 0, 0, 0); //frame\n      data.push(0, 0, 0, 0); //spriteSourceSize\n      data.push(0, 0, 0, 0); //sourceSize, rotated, trimmed\n      data.push(0, 0, 0, 0); //Keep it pow2 cause I\"m cool like that... it helps with sampling accuracy as well. Plus then we have 4 other parameters for future stuff.\n    }\n    //Second Pass\n    for (let i = 0; i < this.spriteCount; i++) {\n      const f = this.sprites[i][\"frame\"];\n      const sss = this.sprites[i][\"spriteSourceSize\"];\n      const ss = this.sprites[i][\"sourceSize\"];\n      const r = this.sprites[i][\"rotated\"] ? 1 : 0;\n      const t = this.sprites[i][\"trimmed\"] ? 1 : 0;\n      //frame\n      data[i * 4] = f.x;\n      data[i * 4 + 1] = f.y;\n      data[i * 4 + 2] = f.w;\n      data[i * 4 + 3] = f.h;\n      //spriteSourceSize\n      data[i * 4 + this.spriteCount * 4] = sss.x;\n      data[i * 4 + 1 + this.spriteCount * 4] = sss.y;\n      data[i * 4 + 3 + this.spriteCount * 4] = sss.h;\n      //sourceSize, rotated, trimmed\n      data[i * 4 + this.spriteCount * 8] = ss.w;\n      data[i * 4 + 1 + this.spriteCount * 8] = ss.h;\n      data[i * 4 + 2 + this.spriteCount * 8] = r;\n      data[i * 4 + 3 + this.spriteCount * 8] = t;\n    }\n    const floatArray = new Float32Array(data);\n    const t = RawTexture.CreateRGBATexture(floatArray, this.spriteCount, 4, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\n    return t;\n  }\n  /**\n   * Creates the tileMap texture Buffer\n   * @param buffer normally and array of numbers, or a false to generate from scratch\n   * @param _layer indicates what layer for a logic trigger dealing with the baseTile.  The system uses this\n   * @returns RawTexture of the tileMap\n   */\n  _createTileBuffer(buffer, _layer = 0) {\n    let data = new Array();\n    const _ty = this.options.stageSize.y || 0;\n    const _tx = this.options.stageSize.x || 0;\n    if (!buffer) {\n      let bt = this.options.baseTile;\n      if (_layer != 0) {\n        bt = 0;\n      }\n      for (let y = 0; y < _ty; y++) {\n        for (let x = 0; x < _tx * 4; x += 4) {\n          data.push(bt, 0, 0, 0);\n        }\n      }\n    } else {\n      data = buffer;\n    }\n    const floatArray = new Float32Array(data);\n    const t = RawTexture.CreateRGBATexture(floatArray, _tx, _ty, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\n    return t;\n  }\n  /**\n   * Modifies the data of the tileMaps\n   * @param _layer is the ID of the layer you want to edit on the SpriteMap\n   * @param pos is the iVector2 Coordinates of the Tile\n   * @param tile The SpriteIndex of the new Tile\n   */\n  changeTiles(_layer = 0, pos, tile = 0) {\n    const buffer = this._tileMaps[_layer]._texture._bufferView;\n    if (buffer === null) {\n      return;\n    }\n    let p = new Array();\n    if (pos instanceof Vector2) {\n      p.push(pos);\n    } else {\n      p = pos;\n    }\n    const _tx = this.options.stageSize.x || 0;\n    for (let i = 0; i < p.length; i++) {\n      const _p = p[i];\n      _p.x = Math.floor(_p.x);\n      _p.y = Math.floor(_p.y);\n      const id = _p.x * 4 + _p.y * (_tx * 4);\n      buffer[id] = tile;\n    }\n    const t = this._createTileBuffer(buffer);\n    this._tileMaps[_layer].dispose();\n    this._tileMaps[_layer] = t;\n    this._material.setTextureArray(\"tileMap\", this._tileMaps);\n  }\n  /**\n   * Creates the animationMap texture Buffer\n   * @param buffer normally and array of numbers, or a false to generate from scratch\n   * @returns RawTexture of the animationMap\n   */\n  _createTileAnimationBuffer(buffer) {\n    const data = new Array();\n    let floatArray;\n    if (!buffer) {\n      for (let i = 0; i < this.spriteCount; i++) {\n        data.push(0, 0, 0, 0);\n        let count = 1;\n        while (count < (this.options.maxAnimationFrames || 4)) {\n          data.push(0, 0, 0, 0);\n          count++;\n        }\n      }\n      floatArray = new Float32Array(data);\n    } else {\n      floatArray = buffer;\n    }\n    const t = RawTexture.CreateRGBATexture(floatArray, this.spriteCount, this.options.maxAnimationFrames || 4, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\n    return t;\n  }\n  /**\n   * Modifies the data of the animationMap\n   * @param cellID is the Index of the Sprite\n   * @param _frame is the target Animation frame\n   * @param toCell is the Target Index of the next frame of the animation\n   * @param time is a value between 0-1 that is the trigger for when the frame should change tiles\n   * @param speed is a global scalar of the time variable on the map.\n   */\n  addAnimationToTile(cellID = 0, _frame = 0, toCell = 0, time = 0, speed = 1) {\n    const buffer = this._animationMap._texture._bufferView;\n    const id = cellID * 4 + this.spriteCount * 4 * _frame;\n    if (!buffer) {\n      return;\n    }\n    buffer[id] = toCell;\n    buffer[id + 1] = time;\n    buffer[id + 2] = speed;\n    const t = this._createTileAnimationBuffer(buffer);\n    this._animationMap.dispose();\n    this._animationMap = t;\n    this._material.setTexture(\"animationMap\", this._animationMap);\n  }\n  /**\n   * Exports the .tilemaps file\n   */\n  saveTileMaps() {\n    let maps = \"\";\n    for (let i = 0; i < this._tileMaps.length; i++) {\n      if (i > 0) {\n        maps += \"\\n\\r\";\n      }\n      maps += this._tileMaps[i]._texture._bufferView.toString();\n    }\n    const hiddenElement = document.createElement(\"a\");\n    hiddenElement.href = \"data:octet/stream;charset=utf-8,\" + encodeURI(maps);\n    hiddenElement.target = \"_blank\";\n    hiddenElement.download = this.name + \".tilemaps\";\n    hiddenElement.click();\n    hiddenElement.remove();\n  }\n  /**\n   * Imports the .tilemaps file\n   * @param url of the .tilemaps file\n   */\n  loadTileMaps(url) {\n    const xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url);\n    const _lc = this.options.layerCount || 0;\n    xhr.onload = () => {\n      const data = xhr.response.split(\"\\n\\r\");\n      for (let i = 0; i < _lc; i++) {\n        const d = data[i].split(\",\").map(Number);\n        const t = this._createTileBuffer(d);\n        this._tileMaps[i].dispose();\n        this._tileMaps[i] = t;\n      }\n      this._material.setTextureArray(\"tileMap\", this._tileMaps);\n    };\n    xhr.send();\n  }\n  /**\n   * Release associated resources\n   */\n  dispose() {\n    this._output.dispose();\n    this._material.dispose();\n    this._animationMap.dispose();\n    this._tileMaps.forEach(tm => {\n      tm.dispose();\n    });\n    this._frameMap.dispose();\n  }\n}","map":{"version":3,"names":["Engine","Vector2","Vector3","Texture","RawTexture","ShaderMaterial","Effect","CreatePlane","SpriteMap","spriteCount","sprites","length","position","_output","v","rotation","animationMap","_animationMap","buffer","_texture","_bufferView","am","_createTileAnimationBuffer","dispose","_material","setTexture","constructor","name","atlasJSON","spriteSheet","options","scene","stageSize","outputSize","outputPosition","Zero","outputRotation","layerCount","maxAnimationFrames","baseTile","flipU","colorMultiply","_scene","_frameMap","_createFrameBuffer","_tileMaps","Array","i","push","_createTileBuffer","defines","shaderString","ShadersStore","layerSampleString","getEngine","_features","supportSwitchCaseInShader","replace","vertex","fragment","attributes","uniforms","samplers","needAlphaBlending","_time","setFloat","setVector2","setVector3","tickSave","bindSpriteTexture","isReady","baseWidth","baseHeight","setTimeout","setTextureArray","size","updatable","scaling","x","y","obfunction","getDeltaTime","onBeforeRenderObservable","add","material","getTileID","p","getMousePosition","multiplyInPlace","Math","floor","out","pickinfo","pick","pointerX","pointerY","mesh","hit","getTextureCoordinates","coords","data","f","sss","ss","r","t","w","h","floatArray","Float32Array","CreateRGBATexture","NEAREST_NEAREST","TEXTURETYPE_FLOAT","_layer","_ty","_tx","bt","changeTiles","pos","tile","_p","id","count","addAnimationToTile","cellID","_frame","toCell","time","speed","saveTileMaps","maps","toString","hiddenElement","document","createElement","href","encodeURI","target","download","click","remove","loadTileMaps","url","xhr","XMLHttpRequest","open","_lc","onload","response","split","d","map","Number","send","forEach","tm"],"sources":["../../../../dev/core/src/Sprites/spriteMap.ts"],"sourcesContent":["import { Engine } from \"../Engines/engine\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Vector2, Vector3 } from \"../Maths/math.vector\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport type { ISpriteJSONSprite, ISpriteJSONAtlas } from \"./ISprites\";\r\nimport { Effect } from \"../Materials/effect\";\r\n\r\nimport { CreatePlane } from \"../Meshes/Builders/planeBuilder\";\r\nimport \"../Shaders/spriteMap.fragment\";\r\nimport \"../Shaders/spriteMap.vertex\";\r\n\r\n/**\r\n * Defines the basic options interface of a SpriteMap\r\n */\r\nexport interface ISpriteMapOptions {\r\n    /**\r\n     * Vector2 of the number of cells in the grid.\r\n     */\r\n    stageSize?: Vector2;\r\n\r\n    /**\r\n     * Vector2 of the size of the output plane in World Units.\r\n     */\r\n    outputSize?: Vector2;\r\n\r\n    /**\r\n     * Vector3 of the position of the output plane in World Units.\r\n     */\r\n    outputPosition?: Vector3;\r\n\r\n    /**\r\n     * Vector3 of the rotation of the output plane.\r\n     */\r\n    outputRotation?: Vector3;\r\n\r\n    /**\r\n     * number of layers that the system will reserve in resources.\r\n     */\r\n    layerCount?: number;\r\n\r\n    /**\r\n     * number of max animation frames a single cell will reserve in resources.\r\n     */\r\n    maxAnimationFrames?: number;\r\n\r\n    /**\r\n     * number cell index of the base tile when the system compiles.\r\n     */\r\n    baseTile?: number;\r\n\r\n    /**\r\n     * boolean flip the sprite after its been repositioned by the framing data.\r\n     */\r\n    flipU?: boolean;\r\n\r\n    /**\r\n     * Vector3 scalar of the global RGB values of the SpriteMap.\r\n     */\r\n    colorMultiply?: Vector3;\r\n}\r\n\r\n/**\r\n * Defines the IDisposable interface in order to be cleanable from resources.\r\n */\r\nexport interface ISpriteMap extends IDisposable {\r\n    /**\r\n     * String name of the SpriteMap.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * The JSON Array file from a https://www.codeandweb.com/texturepacker export.  Or similar structure.\r\n     */\r\n    atlasJSON: ISpriteJSONAtlas;\r\n\r\n    /**\r\n     * Texture of the SpriteMap.\r\n     */\r\n    spriteSheet: Texture;\r\n\r\n    /**\r\n     * The parameters to initialize the SpriteMap with.\r\n     */\r\n    options: ISpriteMapOptions;\r\n}\r\n\r\n/**\r\n * Class used to manage a grid restricted sprite deployment on an Output plane.\r\n */\r\nexport class SpriteMap implements ISpriteMap {\r\n    /** The Name of the spriteMap */\r\n    public name: string;\r\n\r\n    /** The JSON file with the frame and meta data */\r\n    public atlasJSON: ISpriteJSONAtlas;\r\n\r\n    /** The systems Sprite Sheet Texture */\r\n    public spriteSheet: Texture;\r\n\r\n    /** Arguments passed with the Constructor */\r\n    public options: ISpriteMapOptions;\r\n\r\n    /** Public Sprite Storage array, parsed from atlasJSON */\r\n    public sprites: Array<ISpriteJSONSprite>;\r\n\r\n    /** Returns the Number of Sprites in the System */\r\n    public get spriteCount(): number {\r\n        return this.sprites.length;\r\n    }\r\n\r\n    /** Returns the Position of Output Plane*/\r\n    public get position(): Vector3 {\r\n        return this._output.position;\r\n    }\r\n\r\n    /** Returns the Position of Output Plane*/\r\n    public set position(v: Vector3) {\r\n        this._output.position = v;\r\n    }\r\n\r\n    /** Returns the Rotation of Output Plane*/\r\n    public get rotation(): Vector3 {\r\n        return this._output.rotation;\r\n    }\r\n\r\n    /** Returns the Rotation of Output Plane*/\r\n    public set rotation(v: Vector3) {\r\n        this._output.rotation = v;\r\n    }\r\n\r\n    /** Sets the AnimationMap*/\r\n    public get animationMap() {\r\n        return this._animationMap;\r\n    }\r\n\r\n    /** Sets the AnimationMap*/\r\n    public set animationMap(v: RawTexture) {\r\n        const buffer = v!._texture!._bufferView;\r\n        const am = this._createTileAnimationBuffer(buffer);\r\n        this._animationMap.dispose();\r\n        this._animationMap = am;\r\n        this._material.setTexture(\"animationMap\", this._animationMap);\r\n    }\r\n\r\n    /** Scene that the SpriteMap was created in */\r\n    private _scene: Scene;\r\n\r\n    /** Texture Buffer of Float32 that holds tile frame data*/\r\n    private _frameMap: RawTexture;\r\n\r\n    /** Texture Buffers of Float32 that holds tileMap data*/\r\n    private _tileMaps: RawTexture[];\r\n\r\n    /** Texture Buffer of Float32 that holds Animation Data*/\r\n    private _animationMap: RawTexture;\r\n\r\n    /** Custom ShaderMaterial Central to the System*/\r\n    private _material: ShaderMaterial;\r\n\r\n    /** Custom ShaderMaterial Central to the System*/\r\n    private _output: Mesh;\r\n\r\n    /** Systems Time Ticker*/\r\n    private _time: number;\r\n\r\n    /**\r\n     * Creates a new SpriteMap\r\n     * @param name defines the SpriteMaps Name\r\n     * @param atlasJSON is the JSON file that controls the Sprites Frames and Meta\r\n     * @param spriteSheet is the Texture that the Sprites are on.\r\n     * @param options a basic deployment configuration\r\n     * @param scene The Scene that the map is deployed on\r\n     */\r\n    constructor(name: string, atlasJSON: ISpriteJSONAtlas, spriteSheet: Texture, options: ISpriteMapOptions, scene: Scene) {\r\n        this.name = name;\r\n        this.sprites = [];\r\n        this.atlasJSON = atlasJSON;\r\n        this.sprites = this.atlasJSON[\"frames\"];\r\n        this.spriteSheet = spriteSheet;\r\n\r\n        /**\r\n         * Run through the options and set what ever defaults are needed that where not declared.\r\n         */\r\n        this.options = options;\r\n        options.stageSize = options.stageSize || new Vector2(1, 1);\r\n        options.outputSize = options.outputSize || options.stageSize;\r\n        options.outputPosition = options.outputPosition || Vector3.Zero();\r\n        options.outputRotation = options.outputRotation || Vector3.Zero();\r\n        options.layerCount = options.layerCount || 1;\r\n        options.maxAnimationFrames = options.maxAnimationFrames || 0;\r\n        options.baseTile = options.baseTile || 0;\r\n        options.flipU = options.flipU || false;\r\n        options.colorMultiply = options.colorMultiply || new Vector3(1, 1, 1);\r\n\r\n        this._scene = scene;\r\n\r\n        this._frameMap = this._createFrameBuffer();\r\n\r\n        this._tileMaps = new Array();\r\n        for (let i = 0; i < options.layerCount; i++) {\r\n            this._tileMaps.push(this._createTileBuffer(null, i));\r\n        }\r\n\r\n        this._animationMap = this._createTileAnimationBuffer(null);\r\n\r\n        const defines = [];\r\n        defines.push(\"#define LAYERS \" + options.layerCount);\r\n\r\n        if (options.flipU) {\r\n            defines.push(\"#define FLIPU\");\r\n        }\r\n\r\n        defines.push(`#define MAX_ANIMATION_FRAMES ${options.maxAnimationFrames}.0`);\r\n\r\n        const shaderString: string = Effect.ShadersStore[\"spriteMapPixelShader\"];\r\n\r\n        let layerSampleString: string;\r\n        if (!scene.getEngine()._features.supportSwitchCaseInShader) {\r\n            layerSampleString = \"\";\r\n            for (let i = 0; i < options.layerCount; i++) {\r\n                layerSampleString += `if (${i} == i) { frameID = texture2D(tileMaps[${i}], (tileID + 0.5) / stageSize, 0.).x; }`;\r\n            }\r\n        } else {\r\n            layerSampleString = \"switch(i) {\";\r\n            for (let i = 0; i < options.layerCount; i++) {\r\n                layerSampleString += \"case \" + i + \" : frameID = texture(tileMaps[\" + i + \"], (tileID + 0.5) / stageSize, 0.).x;\";\r\n                layerSampleString += \"break;\";\r\n            }\r\n            layerSampleString += \"}\";\r\n        }\r\n\r\n        Effect.ShadersStore[\"spriteMap\" + this.name + \"PixelShader\"] = shaderString.replace(\"#define LAYER_ID_SWITCH\", layerSampleString);\r\n\r\n        this._material = new ShaderMaterial(\r\n            \"spriteMap:\" + this.name,\r\n            this._scene,\r\n            {\r\n                vertex: \"spriteMap\",\r\n                fragment: \"spriteMap\" + this.name,\r\n            },\r\n            {\r\n                defines,\r\n                attributes: [\"position\", \"normal\", \"uv\"],\r\n                uniforms: [\"worldViewProjection\", \"time\", \"stageSize\", \"outputSize\", \"spriteMapSize\", \"spriteCount\", \"time\", \"colorMul\", \"mousePosition\", \"curTile\", \"flipU\"],\r\n                samplers: [\"spriteSheet\", \"frameMap\", \"tileMaps\", \"animationMap\"],\r\n                needAlphaBlending: true,\r\n            }\r\n        );\r\n\r\n        this._time = 0;\r\n\r\n        this._material.setFloat(\"spriteCount\", this.spriteCount);\r\n        this._material.setVector2(\"stageSize\", options.stageSize);\r\n        this._material.setVector2(\"outputSize\", options.outputSize);\r\n        this._material.setTexture(\"spriteSheet\", this.spriteSheet);\r\n        this._material.setVector2(\"spriteMapSize\", new Vector2(1, 1));\r\n        this._material.setVector3(\"colorMul\", options.colorMultiply);\r\n\r\n        let tickSave = 0;\r\n\r\n        const bindSpriteTexture = () => {\r\n            if (this.spriteSheet && this.spriteSheet.isReady()) {\r\n                if (this.spriteSheet._texture) {\r\n                    this._material.setVector2(\"spriteMapSize\", new Vector2(this.spriteSheet._texture.baseWidth || 1, this.spriteSheet._texture.baseHeight || 1));\r\n                    return;\r\n                }\r\n            }\r\n            if (tickSave < 100) {\r\n                setTimeout(() => {\r\n                    tickSave++;\r\n                    bindSpriteTexture();\r\n                }, 100);\r\n            }\r\n        };\r\n\r\n        bindSpriteTexture();\r\n\r\n        this._material.setVector3(\"colorMul\", options.colorMultiply);\r\n        this._material.setTexture(\"frameMap\", this._frameMap);\r\n        this._material.setTextureArray(\"tileMaps\", this._tileMaps);\r\n        this._material.setTexture(\"animationMap\", this._animationMap);\r\n        this._material.setFloat(\"time\", this._time);\r\n\r\n        this._output = CreatePlane(name + \":output\", { size: 1, updatable: true }, scene);\r\n        this._output.scaling.x = options.outputSize.x;\r\n        this._output.scaling.y = options.outputSize.y;\r\n        this.position = options.outputPosition;\r\n        this.rotation = options.outputRotation;\r\n\r\n        const obfunction = () => {\r\n            this._time += this._scene.getEngine().getDeltaTime();\r\n            this._material.setFloat(\"time\", this._time);\r\n        };\r\n\r\n        this._scene.onBeforeRenderObservable.add(obfunction);\r\n        this._output.material = this._material;\r\n    }\r\n\r\n    /**\r\n     * Returns tileID location\r\n     * @returns Vector2 the cell position ID\r\n     */\r\n    public getTileID(): Vector2 {\r\n        const p = this.getMousePosition();\r\n        p.multiplyInPlace(this.options.stageSize || Vector2.Zero());\r\n        p.x = Math.floor(p.x);\r\n        p.y = Math.floor(p.y);\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Gets the UV location of the mouse over the SpriteMap.\r\n     * @returns Vector2 the UV position of the mouse interaction\r\n     */\r\n    public getMousePosition(): Vector2 {\r\n        const out = this._output;\r\n        const pickinfo: Nullable<PickingInfo> = this._scene.pick(this._scene.pointerX, this._scene.pointerY, (mesh) => {\r\n            if (mesh !== out) {\r\n                return false;\r\n            }\r\n            return true;\r\n        });\r\n\r\n        if (!pickinfo || !pickinfo.hit || !pickinfo.getTextureCoordinates) {\r\n            return new Vector2(-1, -1);\r\n        }\r\n\r\n        const coords = pickinfo.getTextureCoordinates();\r\n        if (coords) {\r\n            return coords;\r\n        }\r\n\r\n        return new Vector2(-1, -1);\r\n    }\r\n\r\n    /**\r\n     * Creates the \"frame\" texture Buffer\r\n     * -------------------------------------\r\n     * Structure of frames\r\n     *  \"filename\": \"Falling-Water-2.png\",\r\n     * \"frame\": {\"x\":69,\"y\":103,\"w\":24,\"h\":32},\r\n     * \"rotated\": true,\r\n     * \"trimmed\": true,\r\n     * \"spriteSourceSize\": {\"x\":4,\"y\":0,\"w\":24,\"h\":32},\r\n     * \"sourceSize\": {\"w\":32,\"h\":32}\r\n     * @returns RawTexture of the frameMap\r\n     */\r\n    private _createFrameBuffer(): RawTexture {\r\n        const data = new Array();\r\n        //Do two Passes\r\n        for (let i = 0; i < this.spriteCount; i++) {\r\n            data.push(0, 0, 0, 0); //frame\r\n            data.push(0, 0, 0, 0); //spriteSourceSize\r\n            data.push(0, 0, 0, 0); //sourceSize, rotated, trimmed\r\n            data.push(0, 0, 0, 0); //Keep it pow2 cause I\"m cool like that... it helps with sampling accuracy as well. Plus then we have 4 other parameters for future stuff.\r\n        }\r\n        //Second Pass\r\n        for (let i = 0; i < this.spriteCount; i++) {\r\n            const f = this.sprites[i][\"frame\"];\r\n            const sss = this.sprites[i][\"spriteSourceSize\"];\r\n            const ss = this.sprites[i][\"sourceSize\"];\r\n            const r = this.sprites[i][\"rotated\"] ? 1 : 0;\r\n            const t = this.sprites[i][\"trimmed\"] ? 1 : 0;\r\n\r\n            //frame\r\n            data[i * 4] = f.x;\r\n            data[i * 4 + 1] = f.y;\r\n            data[i * 4 + 2] = f.w;\r\n            data[i * 4 + 3] = f.h;\r\n            //spriteSourceSize\r\n            data[i * 4 + this.spriteCount * 4] = sss.x;\r\n            data[i * 4 + 1 + this.spriteCount * 4] = sss.y;\r\n            data[i * 4 + 3 + this.spriteCount * 4] = sss.h;\r\n            //sourceSize, rotated, trimmed\r\n            data[i * 4 + this.spriteCount * 8] = ss.w;\r\n            data[i * 4 + 1 + this.spriteCount * 8] = ss.h;\r\n            data[i * 4 + 2 + this.spriteCount * 8] = r;\r\n            data[i * 4 + 3 + this.spriteCount * 8] = t;\r\n        }\r\n\r\n        const floatArray = new Float32Array(data);\r\n\r\n        const t = RawTexture.CreateRGBATexture(floatArray, this.spriteCount, 4, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\r\n\r\n        return t;\r\n    }\r\n\r\n    /**\r\n     * Creates the tileMap texture Buffer\r\n     * @param buffer normally and array of numbers, or a false to generate from scratch\r\n     * @param _layer indicates what layer for a logic trigger dealing with the baseTile.  The system uses this\r\n     * @returns RawTexture of the tileMap\r\n     */\r\n    private _createTileBuffer(buffer: any, _layer: number = 0): RawTexture {\r\n        let data = new Array();\r\n        const _ty = this.options.stageSize!.y || 0;\r\n        const _tx = this.options.stageSize!.x || 0;\r\n\r\n        if (!buffer) {\r\n            let bt = this.options.baseTile;\r\n            if (_layer != 0) {\r\n                bt = 0;\r\n            }\r\n\r\n            for (let y = 0; y < _ty; y++) {\r\n                for (let x = 0; x < _tx * 4; x += 4) {\r\n                    data.push(bt, 0, 0, 0);\r\n                }\r\n            }\r\n        } else {\r\n            data = buffer;\r\n        }\r\n\r\n        const floatArray = new Float32Array(data);\r\n        const t = RawTexture.CreateRGBATexture(floatArray, _tx, _ty, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\r\n\r\n        return t;\r\n    }\r\n\r\n    /**\r\n     * Modifies the data of the tileMaps\r\n     * @param _layer is the ID of the layer you want to edit on the SpriteMap\r\n     * @param pos is the iVector2 Coordinates of the Tile\r\n     * @param tile The SpriteIndex of the new Tile\r\n     */\r\n    public changeTiles(_layer: number = 0, pos: Vector2 | Vector2[], tile: number = 0): void {\r\n        const buffer = this._tileMaps[_layer]!._texture!._bufferView;\r\n        if (buffer === null) {\r\n            return;\r\n        }\r\n\r\n        let p = new Array();\r\n        if (pos instanceof Vector2) {\r\n            p.push(pos);\r\n        } else {\r\n            p = pos;\r\n        }\r\n\r\n        const _tx = this.options.stageSize!.x || 0;\r\n\r\n        for (let i = 0; i < p.length; i++) {\r\n            const _p = p[i];\r\n            _p.x = Math.floor(_p.x);\r\n            _p.y = Math.floor(_p.y);\r\n            const id: number = _p.x * 4 + _p.y * (_tx * 4);\r\n            (buffer as any)[id] = tile;\r\n        }\r\n\r\n        const t = this._createTileBuffer(buffer);\r\n        this._tileMaps[_layer].dispose();\r\n        this._tileMaps[_layer] = t;\r\n        this._material.setTextureArray(\"tileMap\", this._tileMaps);\r\n    }\r\n\r\n    /**\r\n     * Creates the animationMap texture Buffer\r\n     * @param buffer normally and array of numbers, or a false to generate from scratch\r\n     * @returns RawTexture of the animationMap\r\n     */\r\n    private _createTileAnimationBuffer(buffer: Nullable<ArrayBufferView>): RawTexture {\r\n        const data = new Array();\r\n        let floatArray;\r\n        if (!buffer) {\r\n            for (let i = 0; i < this.spriteCount; i++) {\r\n                data.push(0, 0, 0, 0);\r\n                let count = 1;\r\n                while (count < (this.options.maxAnimationFrames || 4)) {\r\n                    data.push(0, 0, 0, 0);\r\n                    count++;\r\n                }\r\n            }\r\n            floatArray = new Float32Array(data);\r\n        } else {\r\n            floatArray = buffer;\r\n        }\r\n\r\n        const t = RawTexture.CreateRGBATexture(\r\n            floatArray,\r\n            this.spriteCount,\r\n            this.options.maxAnimationFrames || 4,\r\n            this._scene,\r\n            false,\r\n            false,\r\n            Texture.NEAREST_NEAREST,\r\n            Engine.TEXTURETYPE_FLOAT\r\n        );\r\n\r\n        return t;\r\n    }\r\n\r\n    /**\r\n     * Modifies the data of the animationMap\r\n     * @param cellID is the Index of the Sprite\r\n     * @param _frame is the target Animation frame\r\n     * @param toCell is the Target Index of the next frame of the animation\r\n     * @param time is a value between 0-1 that is the trigger for when the frame should change tiles\r\n     * @param speed is a global scalar of the time variable on the map.\r\n     */\r\n    public addAnimationToTile(cellID: number = 0, _frame: number = 0, toCell: number = 0, time: number = 0, speed: number = 1): void {\r\n        const buffer: any = this._animationMap!._texture!._bufferView;\r\n        const id: number = cellID * 4 + this.spriteCount * 4 * _frame;\r\n        if (!buffer) {\r\n            return;\r\n        }\r\n        buffer[id] = toCell;\r\n        buffer[id + 1] = time;\r\n        buffer[id + 2] = speed;\r\n        const t = this._createTileAnimationBuffer(buffer);\r\n        this._animationMap.dispose();\r\n        this._animationMap = t;\r\n        this._material.setTexture(\"animationMap\", this._animationMap);\r\n    }\r\n\r\n    /**\r\n     * Exports the .tilemaps file\r\n     */\r\n    public saveTileMaps(): void {\r\n        let maps = \"\";\r\n        for (let i = 0; i < this._tileMaps.length; i++) {\r\n            if (i > 0) {\r\n                maps += \"\\n\\r\";\r\n            }\r\n\r\n            maps += this._tileMaps[i]!._texture!._bufferView!.toString();\r\n        }\r\n        const hiddenElement = document.createElement(\"a\");\r\n        hiddenElement.href = \"data:octet/stream;charset=utf-8,\" + encodeURI(maps);\r\n        hiddenElement.target = \"_blank\";\r\n        hiddenElement.download = this.name + \".tilemaps\";\r\n        hiddenElement.click();\r\n        hiddenElement.remove();\r\n    }\r\n\r\n    /**\r\n     * Imports the .tilemaps file\r\n     * @param url of the .tilemaps file\r\n     */\r\n    public loadTileMaps(url: string): void {\r\n        const xhr = new XMLHttpRequest();\r\n        xhr.open(\"GET\", url);\r\n\r\n        const _lc = this.options!.layerCount || 0;\r\n\r\n        xhr.onload = () => {\r\n            const data = xhr.response.split(\"\\n\\r\");\r\n            for (let i = 0; i < _lc; i++) {\r\n                const d = data[i].split(\",\").map(Number);\r\n                const t = this._createTileBuffer(d);\r\n                this._tileMaps[i].dispose();\r\n                this._tileMaps[i] = t;\r\n            }\r\n            this._material.setTextureArray(\"tileMap\", this._tileMaps);\r\n        };\r\n        xhr.send();\r\n    }\r\n\r\n    /**\r\n     * Release associated resources\r\n     */\r\n    public dispose(): void {\r\n        this._output.dispose();\r\n        this._material.dispose();\r\n        this._animationMap.dispose();\r\n        this._tileMaps.forEach((tm) => {\r\n            tm.dispose();\r\n        });\r\n        this._frameMap.dispose();\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}