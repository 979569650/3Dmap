{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { RawTexture } from \"../Textures/rawTexture.js\";\nimport { MaterialPluginBase } from \"../materialPluginBase.js\";\nimport { Vector2, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { MaterialDefines } from \"../materialDefines.js\";\nimport { RegisterClass } from \"../../Misc/typeStore.js\";\nimport { GreasedLineMeshColorDistributionType, GreasedLineMeshColorMode } from \"./greasedLineMaterialInterfaces.js\";\nimport { GreasedLineMaterialDefaults } from \"./greasedLineMaterialDefaults.js\";\nimport { GreasedLineTools } from \"../../Misc/greasedLineTools.js\";\n/**\n * @internal\n */\nexport class MaterialGreasedLineDefines extends MaterialDefines {\n  constructor() {\n    super(...arguments);\n    /**\n     * The material has a color option specified\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    this.GREASED_LINE_HAS_COLOR = false;\n    /**\n     * The material's size attenuation optiom\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    this.GREASED_LINE_SIZE_ATTENUATION = false;\n    /**\n     * The type of color distribution is set to line this value equals to true.\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = false;\n    /**\n     * True if scene is in right handed coordinate system.\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = false;\n    /**\n     * True if the line is in camera facing mode\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    this.GREASED_LINE_CAMERA_FACING = true;\n  }\n}\n/**\n * GreasedLinePluginMaterial for GreasedLineMesh/GreasedLineRibbonMesh.\n * Use the GreasedLineBuilder.CreateGreasedLineMaterial function to create and instance of this class.\n */\nexport class GreasedLinePluginMaterial extends MaterialPluginBase {\n  /**\n   * Creates a new instance of the GreasedLinePluginMaterial\n   * @param material base material for the plugin\n   * @param scene the scene\n   * @param options plugin options\n   */\n  constructor(material, scene, options) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;\n    options = options || {\n      color: GreasedLineMaterialDefaults.DEFAULT_COLOR\n    };\n    const defines = new MaterialGreasedLineDefines();\n    defines.GREASED_LINE_HAS_COLOR = !!options.color && !options.useColors;\n    defines.GREASED_LINE_SIZE_ATTENUATION = (_a = options.sizeAttenuation) !== null && _a !== void 0 ? _a : false;\n    defines.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = options.colorDistributionType === GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_LINE;\n    defines.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = (scene !== null && scene !== void 0 ? scene : material.getScene()).useRightHandedSystem;\n    defines.GREASED_LINE_CAMERA_FACING = (_b = options.cameraFacing) !== null && _b !== void 0 ? _b : true;\n    super(material, GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME, 200, defines);\n    /**\n     * You can provide a colorsTexture to use instead of one generated from the 'colors' option\n     */\n    this.colorsTexture = null;\n    this._scene = scene !== null && scene !== void 0 ? scene : material.getScene();\n    this._engine = this._scene.getEngine();\n    this._cameraFacing = (_c = options.cameraFacing) !== null && _c !== void 0 ? _c : true;\n    this.visibility = (_d = options.visibility) !== null && _d !== void 0 ? _d : 1;\n    this.useDash = (_e = options.useDash) !== null && _e !== void 0 ? _e : false;\n    this.dashRatio = (_f = options.dashRatio) !== null && _f !== void 0 ? _f : 0.5;\n    this.dashOffset = (_g = options.dashOffset) !== null && _g !== void 0 ? _g : 0;\n    this.width = options.width ? options.width : options.sizeAttenuation ? GreasedLineMaterialDefaults.DEFAULT_WIDTH_ATTENUATED : GreasedLineMaterialDefaults.DEFAULT_WIDTH;\n    this._sizeAttenuation = (_h = options.sizeAttenuation) !== null && _h !== void 0 ? _h : false;\n    this.colorMode = (_j = options.colorMode) !== null && _j !== void 0 ? _j : GreasedLineMeshColorMode.COLOR_MODE_SET;\n    this._color = (_k = options.color) !== null && _k !== void 0 ? _k : null;\n    this.useColors = (_l = options.useColors) !== null && _l !== void 0 ? _l : false;\n    this._colorsDistributionType = (_m = options.colorDistributionType) !== null && _m !== void 0 ? _m : GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_SEGMENT;\n    this.colorsSampling = (_o = options.colorsSampling) !== null && _o !== void 0 ? _o : RawTexture.NEAREST_NEAREST;\n    this._colors = (_p = options.colors) !== null && _p !== void 0 ? _p : null;\n    this.dashCount = (_q = options.dashCount) !== null && _q !== void 0 ? _q : 1; // calculate the _dashArray value, call the setter\n    this.resolution = (_r = options.resolution) !== null && _r !== void 0 ? _r : new Vector2(this._engine.getRenderWidth(), this._engine.getRenderHeight()); // calculate aspect call the setter\n    if (options.colorsTexture) {\n      this.colorsTexture = options.colorsTexture; // colorsTexture from options takes precedence\n    } else {\n      if (this._colors) {\n        this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${material.name}-colors-texture`, this._colors, this.colorsSampling, this._scene);\n      } else {\n        this._color = (_s = this._color) !== null && _s !== void 0 ? _s : GreasedLineMaterialDefaults.DEFAULT_COLOR;\n        GreasedLineTools.PrepareEmptyColorsTexture(this._scene);\n      }\n    }\n    this._engine.onDisposeObservable.add(() => {\n      GreasedLineTools.DisposeEmptyColorsTexture();\n    });\n    this._enable(true); // always enabled\n  }\n  /**\n   * Get the shader attributes\n   * @param attributes array which will be filled with the attributes\n   */\n  getAttributes(attributes) {\n    attributes.push(\"grl_offsets\");\n    attributes.push(\"grl_widths\");\n    attributes.push(\"grl_colorPointers\");\n    attributes.push(\"grl_counters\");\n    if (this._cameraFacing) {\n      attributes.push(\"grl_previousAndSide\");\n      attributes.push(\"grl_nextAndCounters\");\n    } else {\n      attributes.push(\"grl_slopes\");\n    }\n  }\n  /**\n   * Get the shader samplers\n   * @param samplers\n   */\n  getSamplers(samplers) {\n    samplers.push(\"grl_colors\");\n  }\n  /**\n   * Get the shader textures\n   * @param activeTextures\n   */\n  getActiveTextures(activeTextures) {\n    if (this.colorsTexture) {\n      activeTextures.push(this.colorsTexture);\n    }\n  }\n  /**\n   * Get the shader uniforms\n   * @returns uniforms\n   */\n  getUniforms() {\n    const ubo = [{\n      name: \"grl_singleColor\",\n      size: 3,\n      type: \"vec3\"\n    }, {\n      name: \"grl_dashOptions\",\n      size: 4,\n      type: \"vec4\"\n    }, {\n      name: \"grl_colorMode_visibility_colorsWidth_useColors\",\n      size: 4,\n      type: \"vec4\"\n    }];\n    if (this._cameraFacing) {\n      ubo.push({\n        name: \"grl_projection\",\n        size: 16,\n        type: \"mat4\"\n      }, {\n        name: \"grl_aspect_resolution_lineWidth\",\n        size: 4,\n        type: \"vec4\"\n      });\n    }\n    return {\n      ubo,\n      vertex: this._cameraFacing ? `\n                uniform vec4 grl_aspect_resolution_lineWidth;\n                uniform mat4 grl_projection;\n                ` : \"\",\n      fragment: `\n                uniform vec4 grl_dashOptions;\n                uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                uniform vec3 grl_singleColor;\n                `\n    };\n  }\n  // only getter, it doesn't make sense to use this plugin on a mesh other than GreasedLineMesh\n  // and it doesn't make sense to disable it on the mesh\n  get isEnabled() {\n    return true;\n  }\n  /**\n   * Bind the uniform buffer\n   * @param uniformBuffer\n   */\n  bindForSubMesh(uniformBuffer) {\n    var _a;\n    if (this._cameraFacing) {\n      const activeCamera = this._scene.activeCamera;\n      if (activeCamera) {\n        const projection = activeCamera.getProjectionMatrix();\n        uniformBuffer.updateMatrix(\"grl_projection\", projection);\n      } else {\n        throw Error(\"GreasedLinePluginMaterial requires an active camera.\");\n      }\n      const resolutionLineWidth = TmpVectors.Vector4[0];\n      resolutionLineWidth.x = this._aspect;\n      resolutionLineWidth.y = this._resolution.x;\n      resolutionLineWidth.z = this._resolution.y;\n      resolutionLineWidth.w = this.width;\n      uniformBuffer.updateVector4(\"grl_aspect_resolution_lineWidth\", resolutionLineWidth);\n    }\n    const dashOptions = TmpVectors.Vector4[0];\n    dashOptions.x = GreasedLineTools.BooleanToNumber(this.useDash);\n    dashOptions.y = this._dashArray;\n    dashOptions.z = this.dashOffset;\n    dashOptions.w = this.dashRatio;\n    uniformBuffer.updateVector4(\"grl_dashOptions\", dashOptions);\n    const colorModeVisibilityColorsWidthUseColors = TmpVectors.Vector4[1];\n    colorModeVisibilityColorsWidthUseColors.x = this.colorMode;\n    colorModeVisibilityColorsWidthUseColors.y = this.visibility;\n    colorModeVisibilityColorsWidthUseColors.z = this.colorsTexture ? this.colorsTexture.getSize().width : 0;\n    colorModeVisibilityColorsWidthUseColors.w = GreasedLineTools.BooleanToNumber(this.useColors);\n    uniformBuffer.updateVector4(\"grl_colorMode_visibility_colorsWidth_useColors\", colorModeVisibilityColorsWidthUseColors);\n    if (this._color) {\n      uniformBuffer.updateColor3(\"grl_singleColor\", this._color);\n    }\n    uniformBuffer.setTexture(\"grl_colors\", (_a = this.colorsTexture) !== null && _a !== void 0 ? _a : GreasedLineMaterialDefaults.EmptyColorsTexture);\n  }\n  /**\n   * Prepare the defines\n   * @param defines\n   * @param _scene\n   * @param _mesh\n   */\n  prepareDefines(defines, _scene, _mesh) {\n    defines.GREASED_LINE_HAS_COLOR = !!this.color && !this.useColors;\n    defines.GREASED_LINE_SIZE_ATTENUATION = this._sizeAttenuation;\n    defines.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = this._colorsDistributionType === GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_LINE;\n    defines.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = _scene.useRightHandedSystem;\n    defines.GREASED_LINE_CAMERA_FACING = this._cameraFacing;\n  }\n  /**\n   * Get the class name\n   * @returns class name\n   */\n  getClassName() {\n    return GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME;\n  }\n  /**\n   * Get shader code\n   * @param shaderType vertex/fragment\n   * @returns shader code\n   */\n  getCustomCode(shaderType) {\n    if (shaderType === \"vertex\") {\n      const obj = {\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        CUSTOM_VERTEX_DEFINITIONS: `\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                `,\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        CUSTOM_VERTEX_UPDATE_POSITION: `\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                `,\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        CUSTOM_VERTEX_MAIN_END: `\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n\n\n                    mat4 grlMatrix = viewProjection * world;\n                    vec4 grlFinalPosition = grlMatrix * vec4( positionUpdated , 1.0 );\n                    vec4 grlPrevPos = grlMatrix * vec4( grlPrevious + grlPositionOffset, 1.0 );\n                    vec4 grlNextPos = grlMatrix * vec4( grlNext + grlPositionOffset, 1.0 );\n\n                    vec2 grlCurrentP = grlFix( grlFinalPosition, grlAspect );\n                    vec2 grlPrevP = grlFix( grlPrevPos, grlAspect );\n                    vec2 grlNextP = grlFix( grlNextPos, grlAspect );\n\n                    float grlWidth = grlBaseWidth * grl_widths;\n\n                    vec2 grlDir;\n                    if( grlNextP == grlCurrentP ) grlDir = normalize( grlCurrentP - grlPrevP );\n                    else if( grlPrevP == grlCurrentP ) grlDir = normalize( grlNextP - grlCurrentP );\n                    else {\n                        vec2 grlDir1 = normalize( grlCurrentP - grlPrevP );\n                        vec2 grlDir2 = normalize( grlNextP - grlCurrentP );\n                        grlDir = normalize( grlDir1 + grlDir2 );\n                    }\n                    vec4 grlNormal = vec4( -grlDir.y, grlDir.x, 0., 1. );\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= ( vec4( grl_aspect_resolution_lineWidth.yz, 0., 1. ) * grl_projection ).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                `\n      };\n      this._cameraFacing && (obj[\"!gl_Position\\\\=viewProjection\\\\*worldPos;\"] = \"//\"); // not needed for camera facing GRL\n      return obj;\n    }\n    if (shaderType === \"fragment\") {\n      return {\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        CUSTOM_FRAGMENT_DEFINITIONS: `\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                `,\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        CUSTOM_FRAGMENT_MAIN_END: `\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    gl_FragColor.a *= step(grlCounters, grlVisibility);\n                    if( gl_FragColor.a == 0. ) discard;\n\n                    if(grlUseDash == 1.){\n                        gl_FragColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (gl_FragColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_SET}.) {\n                            gl_FragColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.) {\n                            gl_FragColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.) {\n                            gl_FragColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlColorPointer/grlColorsWidth, 0.), 0.);\n                            #endif\n                            if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_SET}.) {\n                                gl_FragColor = grlColor;\n                            } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.) {\n                                gl_FragColor += grlColor;\n                            } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.) {\n                                gl_FragColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n                `\n      };\n    }\n    return null;\n  }\n  /**\n   * Disposes the plugin material.\n   */\n  dispose() {\n    var _a;\n    (_a = this.colorsTexture) === null || _a === void 0 ? void 0 : _a.dispose();\n    super.dispose();\n  }\n  /**\n   * Returns the colors used to colorize the line\n   */\n  get colors() {\n    return this._colors;\n  }\n  /**\n   * Sets the colors used to colorize the line\n   */\n  set colors(value) {\n    this.setColors(value);\n  }\n  /**\n   * Creates or updates the colors texture\n   * @param colors color table RGBA\n   * @param lazy if lazy, the colors are not updated\n   * @param forceNewTexture force creation of a new texture\n   * @returns\n   */\n  setColors(colors, lazy = false, forceNewTexture = false) {\n    var _a, _b, _c, _d;\n    const origColorsCount = (_b = (_a = this._colors) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;\n    this._colors = colors;\n    if (colors === null || colors.length === 0) {\n      (_c = this.colorsTexture) === null || _c === void 0 ? void 0 : _c.dispose();\n      return;\n    }\n    if (lazy && !forceNewTexture) {\n      return;\n    }\n    if (this.colorsTexture && origColorsCount === colors.length && !forceNewTexture) {\n      const colorArray = GreasedLineTools.Color3toRGBAUint8(colors);\n      this.colorsTexture.update(colorArray);\n    } else {\n      (_d = this.colorsTexture) === null || _d === void 0 ? void 0 : _d.dispose();\n      this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this._material.name}-colors-texture`, colors, this.colorsSampling, this._scene);\n    }\n  }\n  /**\n   * Updates the material. Use when material created in lazy mode.\n   */\n  updateLazy() {\n    if (this._colors) {\n      this.setColors(this._colors, false, true);\n    }\n  }\n  /**\n   * Gets the number of dashes in the line\n   */\n  get dashCount() {\n    return this._dashCount;\n  }\n  /**\n   * Sets the number of dashes in the line\n   * @param value dash\n   */\n  set dashCount(value) {\n    this._dashCount = value;\n    this._dashArray = 1 / value;\n  }\n  /**\n   * If set to true the line will be rendered always with the same width regardless how far it is located from the camera.\n   * Not supported for non camera facing lines.\n   */\n  get sizeAttenuation() {\n    return this._sizeAttenuation;\n  }\n  /**\n   * Turn on/off size attenuation of the width option and widths array.\n   * Not supported for non camera facing lines.\n   * @param value If set to true the line will be rendered always with the same width regardless how far it is located from the camera.\n   */\n  set sizeAttenuation(value) {\n    this._sizeAttenuation = value;\n    this.markAllDefinesAsDirty();\n  }\n  /**\n   * Gets the color of the line\n   */\n  get color() {\n    return this._color;\n  }\n  /**\n   * Sets the color of the line\n   * @param value Color3 or null to clear the color. You need to clear the color if you use colors and useColors = true\n   */\n  set color(value) {\n    this.setColor(value);\n  }\n  /**\n   * Sets the color of the line. If set the whole line will be mixed with this color according to the colorMode option.\n   * @param value color\n   */\n  setColor(value, doNotMarkDirty = false) {\n    if (this._color === null && value !== null || this._color !== null && value === null) {\n      this._color = value;\n      !doNotMarkDirty && this.markAllDefinesAsDirty();\n    } else {\n      this._color = value;\n    }\n  }\n  /**\n   * Gets the color distributiopn type\n   */\n  get colorsDistributionType() {\n    return this._colorsDistributionType;\n  }\n  /**\n   * Sets the color distribution type\n   * @see GreasedLineMeshColorDistributionType\n   * @param value color distribution type\n   */\n  set colorsDistributionType(value) {\n    this._colorsDistributionType = value;\n    this.markAllDefinesAsDirty();\n  }\n  /**\n   * Gets the resolution\n   */\n  get resolution() {\n    return this._resolution;\n  }\n  /**\n   * Sets the resolution\n   * @param value resolution of the screen for GreasedLine\n   */\n  set resolution(value) {\n    this._aspect = value.x / value.y;\n    this._resolution = value;\n  }\n  /**\n   * Serializes this plugin material\n   * @returns serializationObjec\n   */\n  serialize() {\n    const serializationObject = super.serialize();\n    const greasedLineMaterialOptions = {\n      colorDistributionType: this._colorsDistributionType,\n      colorsSampling: this.colorsSampling,\n      colorMode: this.colorMode,\n      dashCount: this._dashCount,\n      dashOffset: this.dashOffset,\n      dashRatio: this.dashRatio,\n      resolution: this._resolution,\n      sizeAttenuation: this._sizeAttenuation,\n      useColors: this.useColors,\n      useDash: this.useDash,\n      visibility: this.visibility,\n      width: this.width\n    };\n    this._colors && (greasedLineMaterialOptions.colors = this._colors);\n    this._color && (greasedLineMaterialOptions.color = this._color);\n    serializationObject.greasedLineMaterialOptions = greasedLineMaterialOptions;\n    return serializationObject;\n  }\n  /**\n   * Parses a serialized objects\n   * @param source serialized object\n   * @param scene scene\n   * @param rootUrl root url for textures\n   */\n  parse(source, scene, rootUrl) {\n    var _a;\n    super.parse(source, scene, rootUrl);\n    const greasedLineMaterialOptions = source.greasedLineMaterialOptions;\n    (_a = this.colorsTexture) === null || _a === void 0 ? void 0 : _a.dispose();\n    greasedLineMaterialOptions.color && this.setColor(greasedLineMaterialOptions.color, true);\n    greasedLineMaterialOptions.colorDistributionType && (this.colorsDistributionType = greasedLineMaterialOptions.colorDistributionType);\n    greasedLineMaterialOptions.colors && (this.colors = greasedLineMaterialOptions.colors);\n    greasedLineMaterialOptions.colorsSampling && (this.colorsSampling = greasedLineMaterialOptions.colorsSampling);\n    greasedLineMaterialOptions.colorMode && (this.colorMode = greasedLineMaterialOptions.colorMode);\n    greasedLineMaterialOptions.useColors && (this.useColors = greasedLineMaterialOptions.useColors);\n    greasedLineMaterialOptions.visibility && (this.visibility = greasedLineMaterialOptions.visibility);\n    greasedLineMaterialOptions.useDash && (this.useDash = greasedLineMaterialOptions.useDash);\n    greasedLineMaterialOptions.dashCount && (this.dashCount = greasedLineMaterialOptions.dashCount);\n    greasedLineMaterialOptions.dashRatio && (this.dashRatio = greasedLineMaterialOptions.dashRatio);\n    greasedLineMaterialOptions.dashOffset && (this.dashOffset = greasedLineMaterialOptions.dashOffset);\n    greasedLineMaterialOptions.width && (this.width = greasedLineMaterialOptions.width);\n    greasedLineMaterialOptions.sizeAttenuation && (this.sizeAttenuation = greasedLineMaterialOptions.sizeAttenuation);\n    greasedLineMaterialOptions.resolution && (this.resolution = greasedLineMaterialOptions.resolution);\n    if (this.colors) {\n      this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this._material.name}-colors-texture`, this.colors, this.colorsSampling, scene);\n    } else {\n      GreasedLineTools.PrepareEmptyColorsTexture(scene);\n    }\n    this.markAllDefinesAsDirty();\n  }\n  /**\n   * Makes a duplicate of the current configuration into another one.\n   * @param plugin define the config where to copy the info\n   */\n  copyTo(plugin) {\n    var _a;\n    const dest = plugin;\n    (_a = dest.colorsTexture) === null || _a === void 0 ? void 0 : _a.dispose();\n    if (this._colors) {\n      dest.colorsTexture = GreasedLineTools.CreateColorsTexture(`${dest._material.name}-colors-texture`, this._colors, dest.colorsSampling, this._scene);\n    }\n    dest.setColor(this.color, true);\n    dest.colorsDistributionType = this.colorsDistributionType;\n    dest.colorsSampling = this.colorsSampling;\n    dest.colorMode = this.colorMode;\n    dest.useColors = this.useColors;\n    dest.visibility = this.visibility;\n    dest.useDash = this.useDash;\n    dest.dashCount = this.dashCount;\n    dest.dashRatio = this.dashRatio;\n    dest.dashOffset = this.dashOffset;\n    dest.width = this.width;\n    dest.sizeAttenuation = this.sizeAttenuation;\n    dest.resolution = this.resolution;\n    dest.markAllDefinesAsDirty();\n  }\n}\n/**\n * Plugin name\n */\nGreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME = \"GreasedLinePluginMaterial\";\nRegisterClass(`BABYLON.${GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME}`, GreasedLinePluginMaterial);","map":{"version":3,"names":["RawTexture","MaterialPluginBase","Vector2","TmpVectors","MaterialDefines","RegisterClass","GreasedLineMeshColorDistributionType","GreasedLineMeshColorMode","GreasedLineMaterialDefaults","GreasedLineTools","MaterialGreasedLineDefines","constructor","GREASED_LINE_HAS_COLOR","GREASED_LINE_SIZE_ATTENUATION","GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE","GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM","GREASED_LINE_CAMERA_FACING","GreasedLinePluginMaterial","material","scene","options","color","DEFAULT_COLOR","defines","useColors","_a","sizeAttenuation","colorDistributionType","COLOR_DISTRIBUTION_TYPE_LINE","getScene","useRightHandedSystem","_b","cameraFacing","GREASED_LINE_MATERIAL_NAME","colorsTexture","_scene","_engine","getEngine","_cameraFacing","_c","visibility","_d","useDash","_e","dashRatio","_f","dashOffset","_g","width","DEFAULT_WIDTH_ATTENUATED","DEFAULT_WIDTH","_sizeAttenuation","_h","colorMode","_j","COLOR_MODE_SET","_color","_k","_l","_colorsDistributionType","_m","COLOR_DISTRIBUTION_TYPE_SEGMENT","colorsSampling","_o","NEAREST_NEAREST","_colors","_p","colors","dashCount","_q","resolution","_r","getRenderWidth","getRenderHeight","CreateColorsTexture","name","_s","PrepareEmptyColorsTexture","onDisposeObservable","add","DisposeEmptyColorsTexture","_enable","getAttributes","attributes","push","getSamplers","samplers","getActiveTextures","activeTextures","getUniforms","ubo","size","type","vertex","fragment","isEnabled","bindForSubMesh","uniformBuffer","activeCamera","projection","getProjectionMatrix","updateMatrix","Error","resolutionLineWidth","Vector4","x","_aspect","y","_resolution","z","w","updateVector4","dashOptions","BooleanToNumber","_dashArray","colorModeVisibilityColorsWidthUseColors","getSize","updateColor3","setTexture","EmptyColorsTexture","prepareDefines","_mesh","getClassName","getCustomCode","shaderType","obj","CUSTOM_VERTEX_DEFINITIONS","CUSTOM_VERTEX_UPDATE_POSITION","CUSTOM_VERTEX_MAIN_END","CUSTOM_FRAGMENT_DEFINITIONS","CUSTOM_FRAGMENT_MAIN_END","COLOR_MODE_ADD","COLOR_MODE_MULTIPLY","dispose","value","setColors","lazy","forceNewTexture","origColorsCount","length","colorArray","Color3toRGBAUint8","update","_material","updateLazy","_dashCount","markAllDefinesAsDirty","setColor","doNotMarkDirty","colorsDistributionType","serialize","serializationObject","greasedLineMaterialOptions","parse","source","rootUrl","copyTo","plugin","dest"],"sources":["../../../../../dev/core/src/Materials/GreasedLine/greasedLinePluginMaterial.ts"],"sourcesContent":["import type { Engine } from \"../../Engines/engine\";\r\nimport { RawTexture } from \"../Textures/rawTexture\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { UniformBuffer } from \"../uniformBuffer\";\r\nimport { Vector2, TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Color3 } from \"../../Maths/math.color\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Material } from \"../material\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { BaseTexture } from \"../Textures/baseTexture\";\r\nimport { RegisterClass } from \"../../Misc/typeStore\";\r\nimport type { GreasedLineMaterialOptions, IGreasedLineMaterial } from \"./greasedLineMaterialInterfaces\";\r\nimport { GreasedLineMeshColorDistributionType, GreasedLineMeshColorMode } from \"./greasedLineMaterialInterfaces\";\r\nimport { GreasedLineMaterialDefaults } from \"./greasedLineMaterialDefaults\";\r\nimport { GreasedLineTools } from \"../../Misc/greasedLineTools\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialGreasedLineDefines extends MaterialDefines {\r\n    /**\r\n     * The material has a color option specified\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GREASED_LINE_HAS_COLOR = false;\r\n    /**\r\n     * The material's size attenuation optiom\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GREASED_LINE_SIZE_ATTENUATION = false;\r\n    /**\r\n     * The type of color distribution is set to line this value equals to true.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = false;\r\n    /**\r\n     * True if scene is in right handed coordinate system.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = false;\r\n\r\n    /**\r\n     * True if the line is in camera facing mode\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GREASED_LINE_CAMERA_FACING = true;\r\n}\r\n\r\n/**\r\n * GreasedLinePluginMaterial for GreasedLineMesh/GreasedLineRibbonMesh.\r\n * Use the GreasedLineBuilder.CreateGreasedLineMaterial function to create and instance of this class.\r\n */\r\nexport class GreasedLinePluginMaterial extends MaterialPluginBase implements IGreasedLineMaterial {\r\n    /**\r\n     * Plugin name\r\n     */\r\n    public static readonly GREASED_LINE_MATERIAL_NAME = \"GreasedLinePluginMaterial\";\r\n\r\n    /**\r\n     * Whether to use the colors option to colorize the line\r\n     */\r\n    public useColors: boolean;\r\n\r\n    /**\r\n     * Normalized value of how much of the line will be visible\r\n     * 0 - 0% of the line will be visible\r\n     * 1 - 100% of the line will be visible\r\n     */\r\n    public visibility: number;\r\n\r\n    /**\r\n     * Dash offset\r\n     */\r\n    public dashOffset: number;\r\n\r\n    /**\r\n     * Length of the dash. 0 to 1. 0.5 means half empty, half drawn.\r\n     */\r\n    public dashRatio: number;\r\n\r\n    /**\r\n     * Line base width. At each point the line width is calculated by widths[pointIndex] * width\r\n     */\r\n    public width: number;\r\n\r\n    /**\r\n     * The type of sampling of the colors texture. The values are the same when using with textures.\r\n     */\r\n    public colorsSampling: number;\r\n\r\n    /**\r\n     * Turns on/off dash mode\r\n     */\r\n    public useDash: boolean;\r\n\r\n    /**\r\n     * The mixing mode of the color paramater. Default value is GreasedLineMeshColorMode.SET\r\n     * @see GreasedLineMeshColorMode\r\n     */\r\n    public colorMode: GreasedLineMeshColorMode;\r\n\r\n    /**\r\n     * You can provide a colorsTexture to use instead of one generated from the 'colors' option\r\n     */\r\n    public colorsTexture: Nullable<RawTexture> = null;\r\n\r\n    private _scene: Scene;\r\n    private _dashCount: number;\r\n    private _dashArray: number;\r\n    private _color: Nullable<Color3>;\r\n    private _colors: Nullable<Color3[]>;\r\n    private _colorsDistributionType: GreasedLineMeshColorDistributionType;\r\n    private _resolution: Vector2;\r\n    private _aspect: number;\r\n    private _sizeAttenuation: boolean;\r\n\r\n    private _cameraFacing: boolean;\r\n\r\n    private _engine: Engine;\r\n\r\n    /**\r\n     * Creates a new instance of the GreasedLinePluginMaterial\r\n     * @param material base material for the plugin\r\n     * @param scene the scene\r\n     * @param options plugin options\r\n     */\r\n    constructor(material: Material, scene?: Scene, options?: GreasedLineMaterialOptions) {\r\n        options = options || {\r\n            color: GreasedLineMaterialDefaults.DEFAULT_COLOR,\r\n        };\r\n\r\n        const defines = new MaterialGreasedLineDefines();\r\n        defines.GREASED_LINE_HAS_COLOR = !!options.color && !options.useColors;\r\n        defines.GREASED_LINE_SIZE_ATTENUATION = options.sizeAttenuation ?? false;\r\n        defines.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = options.colorDistributionType === GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_LINE;\r\n        defines.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = (scene ?? material.getScene()).useRightHandedSystem;\r\n        defines.GREASED_LINE_CAMERA_FACING = options.cameraFacing ?? true;\r\n        super(material, GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME, 200, defines);\r\n\r\n        this._scene = scene ?? material.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._cameraFacing = options.cameraFacing ?? true;\r\n\r\n        this.visibility = options.visibility ?? 1;\r\n        this.useDash = options.useDash ?? false;\r\n        this.dashRatio = options.dashRatio ?? 0.5;\r\n        this.dashOffset = options.dashOffset ?? 0;\r\n        this.width = options.width ? options.width : options.sizeAttenuation ? GreasedLineMaterialDefaults.DEFAULT_WIDTH_ATTENUATED : GreasedLineMaterialDefaults.DEFAULT_WIDTH;\r\n        this._sizeAttenuation = options.sizeAttenuation ?? false;\r\n        this.colorMode = options.colorMode ?? GreasedLineMeshColorMode.COLOR_MODE_SET;\r\n        this._color = options.color ?? null;\r\n        this.useColors = options.useColors ?? false;\r\n        this._colorsDistributionType = options.colorDistributionType ?? GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_SEGMENT;\r\n        this.colorsSampling = options.colorsSampling ?? RawTexture.NEAREST_NEAREST;\r\n        this._colors = options.colors ?? null;\r\n\r\n        this.dashCount = options.dashCount ?? 1; // calculate the _dashArray value, call the setter\r\n        this.resolution = options.resolution ?? new Vector2(this._engine.getRenderWidth(), this._engine.getRenderHeight()); // calculate aspect call the setter\r\n\r\n        if (options.colorsTexture) {\r\n            this.colorsTexture = options.colorsTexture; // colorsTexture from options takes precedence\r\n        } else {\r\n            if (this._colors) {\r\n                this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${material.name}-colors-texture`, this._colors, this.colorsSampling, this._scene);\r\n            } else {\r\n                this._color = this._color ?? GreasedLineMaterialDefaults.DEFAULT_COLOR;\r\n                GreasedLineTools.PrepareEmptyColorsTexture(this._scene);\r\n            }\r\n        }\r\n\r\n        this._engine.onDisposeObservable.add(() => {\r\n            GreasedLineTools.DisposeEmptyColorsTexture();\r\n        });\r\n\r\n        this._enable(true); // always enabled\r\n    }\r\n\r\n    /**\r\n     * Get the shader attributes\r\n     * @param attributes array which will be filled with the attributes\r\n     */\r\n    getAttributes(attributes: string[]) {\r\n        attributes.push(\"grl_offsets\");\r\n        attributes.push(\"grl_widths\");\r\n        attributes.push(\"grl_colorPointers\");\r\n        attributes.push(\"grl_counters\");\r\n        if (this._cameraFacing) {\r\n            attributes.push(\"grl_previousAndSide\");\r\n            attributes.push(\"grl_nextAndCounters\");\r\n        } else {\r\n            attributes.push(\"grl_slopes\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the shader samplers\r\n     * @param samplers\r\n     */\r\n    getSamplers(samplers: string[]) {\r\n        samplers.push(\"grl_colors\");\r\n    }\r\n\r\n    /**\r\n     * Get the shader textures\r\n     * @param activeTextures\r\n     */\r\n    public getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this.colorsTexture) {\r\n            activeTextures.push(this.colorsTexture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the shader uniforms\r\n     * @returns uniforms\r\n     */\r\n    getUniforms() {\r\n        const ubo = [\r\n            { name: \"grl_singleColor\", size: 3, type: \"vec3\" },\r\n            { name: \"grl_dashOptions\", size: 4, type: \"vec4\" },\r\n            { name: \"grl_colorMode_visibility_colorsWidth_useColors\", size: 4, type: \"vec4\" },\r\n        ];\r\n        if (this._cameraFacing) {\r\n            ubo.push({ name: \"grl_projection\", size: 16, type: \"mat4\" }, { name: \"grl_aspect_resolution_lineWidth\", size: 4, type: \"vec4\" });\r\n        }\r\n\r\n        return {\r\n            ubo,\r\n            vertex: this._cameraFacing\r\n                ? `\r\n                uniform vec4 grl_aspect_resolution_lineWidth;\r\n                uniform mat4 grl_projection;\r\n                `\r\n                : \"\",\r\n            fragment: `\r\n                uniform vec4 grl_dashOptions;\r\n                uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\r\n                uniform vec3 grl_singleColor;\r\n                `,\r\n        };\r\n    }\r\n\r\n    // only getter, it doesn't make sense to use this plugin on a mesh other than GreasedLineMesh\r\n    // and it doesn't make sense to disable it on the mesh\r\n    get isEnabled() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Bind the uniform buffer\r\n     * @param uniformBuffer\r\n     */\r\n    bindForSubMesh(uniformBuffer: UniformBuffer) {\r\n        if (this._cameraFacing) {\r\n            const activeCamera = this._scene.activeCamera;\r\n\r\n            if (activeCamera) {\r\n                const projection = activeCamera.getProjectionMatrix();\r\n                uniformBuffer.updateMatrix(\"grl_projection\", projection);\r\n            } else {\r\n                throw Error(\"GreasedLinePluginMaterial requires an active camera.\");\r\n            }\r\n\r\n            const resolutionLineWidth = TmpVectors.Vector4[0];\r\n            resolutionLineWidth.x = this._aspect;\r\n            resolutionLineWidth.y = this._resolution.x;\r\n            resolutionLineWidth.z = this._resolution.y;\r\n            resolutionLineWidth.w = this.width;\r\n            uniformBuffer.updateVector4(\"grl_aspect_resolution_lineWidth\", resolutionLineWidth);\r\n        }\r\n\r\n        const dashOptions = TmpVectors.Vector4[0];\r\n        dashOptions.x = GreasedLineTools.BooleanToNumber(this.useDash);\r\n        dashOptions.y = this._dashArray;\r\n        dashOptions.z = this.dashOffset;\r\n        dashOptions.w = this.dashRatio;\r\n        uniformBuffer.updateVector4(\"grl_dashOptions\", dashOptions);\r\n\r\n        const colorModeVisibilityColorsWidthUseColors = TmpVectors.Vector4[1];\r\n        colorModeVisibilityColorsWidthUseColors.x = this.colorMode;\r\n        colorModeVisibilityColorsWidthUseColors.y = this.visibility;\r\n        colorModeVisibilityColorsWidthUseColors.z = this.colorsTexture ? this.colorsTexture.getSize().width : 0;\r\n        colorModeVisibilityColorsWidthUseColors.w = GreasedLineTools.BooleanToNumber(this.useColors);\r\n        uniformBuffer.updateVector4(\"grl_colorMode_visibility_colorsWidth_useColors\", colorModeVisibilityColorsWidthUseColors);\r\n\r\n        if (this._color) {\r\n            uniformBuffer.updateColor3(\"grl_singleColor\", this._color);\r\n        }\r\n\r\n        uniformBuffer.setTexture(\"grl_colors\", this.colorsTexture ?? GreasedLineMaterialDefaults.EmptyColorsTexture);\r\n    }\r\n\r\n    /**\r\n     * Prepare the defines\r\n     * @param defines\r\n     * @param _scene\r\n     * @param _mesh\r\n     */\r\n    prepareDefines(defines: MaterialGreasedLineDefines, _scene: Scene, _mesh: AbstractMesh) {\r\n        defines.GREASED_LINE_HAS_COLOR = !!this.color && !this.useColors;\r\n        defines.GREASED_LINE_SIZE_ATTENUATION = this._sizeAttenuation;\r\n        defines.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = this._colorsDistributionType === GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_LINE;\r\n        defines.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = _scene.useRightHandedSystem;\r\n        defines.GREASED_LINE_CAMERA_FACING = this._cameraFacing;\r\n    }\r\n\r\n    /**\r\n     * Get the class name\r\n     * @returns class name\r\n     */\r\n    getClassName() {\r\n        return GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME;\r\n    }\r\n\r\n    /**\r\n     * Get shader code\r\n     * @param shaderType vertex/fragment\r\n     * @returns shader code\r\n     */\r\n    getCustomCode(shaderType: string): Nullable<{ [pointName: string]: string }> {\r\n        if (shaderType === \"vertex\") {\r\n            const obj: any = {\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                CUSTOM_VERTEX_DEFINITIONS: `\r\n                attribute float grl_widths;\r\n                attribute vec3 grl_offsets;\r\n                attribute float grl_colorPointers;\r\n\r\n                varying float grlCounters;\r\n                varying float grlColorPointer;\r\n\r\n                #ifdef GREASED_LINE_CAMERA_FACING\r\n                    attribute vec4 grl_previousAndSide;\r\n                    attribute vec4 grl_nextAndCounters;\r\n\r\n                    vec2 grlFix( vec4 i, float aspect ) {\r\n                        vec2 res = i.xy / i.w;\r\n                        res.x *= aspect;\r\n                        return res;\r\n                    }\r\n                #else\r\n                    attribute vec3 grl_slopes;\r\n                    attribute float grl_counters;\r\n                #endif\r\n                `,\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                CUSTOM_VERTEX_UPDATE_POSITION: `\r\n                #ifdef GREASED_LINE_CAMERA_FACING\r\n                    vec3 grlPositionOffset = grl_offsets;\r\n                    positionUpdated += grlPositionOffset;\r\n                #else\r\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\r\n                #endif\r\n                `,\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                CUSTOM_VERTEX_MAIN_END: `\r\n                grlColorPointer = grl_colorPointers;\r\n\r\n                #ifdef GREASED_LINE_CAMERA_FACING\r\n\r\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\r\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\r\n\r\n\r\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\r\n                    float grlSide = grl_previousAndSide.w;\r\n\r\n                    vec3 grlNext = grl_nextAndCounters.xyz;\r\n                    grlCounters = grl_nextAndCounters.w;\r\n\r\n\r\n                    mat4 grlMatrix = viewProjection * world;\r\n                    vec4 grlFinalPosition = grlMatrix * vec4( positionUpdated , 1.0 );\r\n                    vec4 grlPrevPos = grlMatrix * vec4( grlPrevious + grlPositionOffset, 1.0 );\r\n                    vec4 grlNextPos = grlMatrix * vec4( grlNext + grlPositionOffset, 1.0 );\r\n\r\n                    vec2 grlCurrentP = grlFix( grlFinalPosition, grlAspect );\r\n                    vec2 grlPrevP = grlFix( grlPrevPos, grlAspect );\r\n                    vec2 grlNextP = grlFix( grlNextPos, grlAspect );\r\n\r\n                    float grlWidth = grlBaseWidth * grl_widths;\r\n\r\n                    vec2 grlDir;\r\n                    if( grlNextP == grlCurrentP ) grlDir = normalize( grlCurrentP - grlPrevP );\r\n                    else if( grlPrevP == grlCurrentP ) grlDir = normalize( grlNextP - grlCurrentP );\r\n                    else {\r\n                        vec2 grlDir1 = normalize( grlCurrentP - grlPrevP );\r\n                        vec2 grlDir2 = normalize( grlNextP - grlCurrentP );\r\n                        grlDir = normalize( grlDir1 + grlDir2 );\r\n                    }\r\n                    vec4 grlNormal = vec4( -grlDir.y, grlDir.x, 0., 1. );\r\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\r\n                        grlNormal.xy *= -.5 * grlWidth;\r\n                    #else\r\n                        grlNormal.xy *= .5 * grlWidth;\r\n                    #endif\r\n\r\n                    grlNormal *= grl_projection;\r\n\r\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\r\n                        grlNormal.xy *= grlFinalPosition.w;\r\n                        grlNormal.xy /= ( vec4( grl_aspect_resolution_lineWidth.yz, 0., 1. ) * grl_projection ).xy;\r\n                    #endif\r\n\r\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\r\n                    gl_Position = grlFinalPosition;\r\n\r\n                    vPositionW = vec3(grlFinalPosition);\r\n                #else\r\n                    grlCounters = grl_counters;\r\n                #endif\r\n                `,\r\n            };\r\n            this._cameraFacing && (obj[\"!gl_Position\\\\=viewProjection\\\\*worldPos;\"] = \"//\"); // not needed for camera facing GRL\r\n            return obj;\r\n        }\r\n\r\n        if (shaderType === \"fragment\") {\r\n            return {\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                CUSTOM_FRAGMENT_DEFINITIONS: `\r\n                    varying float grlCounters;\r\n                    varying float grlColorPointer;\r\n                    uniform sampler2D grl_colors;\r\n                `,\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                CUSTOM_FRAGMENT_MAIN_END: `\r\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\r\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\r\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\r\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\r\n\r\n                    float grlUseDash = grl_dashOptions.x;\r\n                    float grlDashArray = grl_dashOptions.y;\r\n                    float grlDashOffset = grl_dashOptions.z;\r\n                    float grlDashRatio = grl_dashOptions.w;\r\n\r\n                    gl_FragColor.a *= step(grlCounters, grlVisibility);\r\n                    if( gl_FragColor.a == 0. ) discard;\r\n\r\n                    if(grlUseDash == 1.){\r\n                        gl_FragColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\r\n                        if (gl_FragColor.a == 0.) discard;\r\n                    }\r\n\r\n                    #ifdef GREASED_LINE_HAS_COLOR\r\n                        if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_SET}.) {\r\n                            gl_FragColor.rgb = grl_singleColor;\r\n                        } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.) {\r\n                            gl_FragColor.rgb += grl_singleColor;\r\n                        } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.) {\r\n                            gl_FragColor.rgb *= grl_singleColor;\r\n                        }\r\n                    #else\r\n                        if (grlUseColors == 1.) {\r\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\r\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\r\n                            #else\r\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlColorPointer/grlColorsWidth, 0.), 0.);\r\n                            #endif\r\n                            if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_SET}.) {\r\n                                gl_FragColor = grlColor;\r\n                            } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.) {\r\n                                gl_FragColor += grlColor;\r\n                            } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.) {\r\n                                gl_FragColor *= grlColor;\r\n                            }\r\n                        }\r\n                    #endif\r\n\r\n                `,\r\n            };\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Disposes the plugin material.\r\n     */\r\n    public dispose(): void {\r\n        this.colorsTexture?.dispose();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Returns the colors used to colorize the line\r\n     */\r\n    get colors() {\r\n        return this._colors;\r\n    }\r\n\r\n    /**\r\n     * Sets the colors used to colorize the line\r\n     */\r\n    set colors(value: Nullable<Color3[]>) {\r\n        this.setColors(value);\r\n    }\r\n\r\n    /**\r\n     * Creates or updates the colors texture\r\n     * @param colors color table RGBA\r\n     * @param lazy if lazy, the colors are not updated\r\n     * @param forceNewTexture force creation of a new texture\r\n     * @returns\r\n     */\r\n    public setColors(colors: Nullable<Color3[]>, lazy = false, forceNewTexture = false): void {\r\n        const origColorsCount = this._colors?.length ?? 0;\r\n\r\n        this._colors = colors;\r\n\r\n        if (colors === null || colors.length === 0) {\r\n            this.colorsTexture?.dispose();\r\n            return;\r\n        }\r\n\r\n        if (lazy && !forceNewTexture) {\r\n            return;\r\n        }\r\n\r\n        if (this.colorsTexture && origColorsCount === colors.length && !forceNewTexture) {\r\n            const colorArray = GreasedLineTools.Color3toRGBAUint8(colors);\r\n            this.colorsTexture.update(colorArray);\r\n        } else {\r\n            this.colorsTexture?.dispose();\r\n            this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this._material.name}-colors-texture`, colors, this.colorsSampling, this._scene);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the material. Use when material created in lazy mode.\r\n     */\r\n    public updateLazy() {\r\n        if (this._colors) {\r\n            this.setColors(this._colors, false, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the number of dashes in the line\r\n     */\r\n    get dashCount() {\r\n        return this._dashCount;\r\n    }\r\n    /**\r\n     * Sets the number of dashes in the line\r\n     * @param value dash\r\n     */\r\n    set dashCount(value: number) {\r\n        this._dashCount = value;\r\n        this._dashArray = 1 / value;\r\n    }\r\n\r\n    /**\r\n     * If set to true the line will be rendered always with the same width regardless how far it is located from the camera.\r\n     * Not supported for non camera facing lines.\r\n     */\r\n    get sizeAttenuation() {\r\n        return this._sizeAttenuation;\r\n    }\r\n\r\n    /**\r\n     * Turn on/off size attenuation of the width option and widths array.\r\n     * Not supported for non camera facing lines.\r\n     * @param value If set to true the line will be rendered always with the same width regardless how far it is located from the camera.\r\n     */\r\n    set sizeAttenuation(value: boolean) {\r\n        this._sizeAttenuation = value;\r\n        this.markAllDefinesAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets the color of the line\r\n     */\r\n    get color() {\r\n        return this._color;\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the line\r\n     * @param value Color3 or null to clear the color. You need to clear the color if you use colors and useColors = true\r\n     */\r\n    set color(value: Nullable<Color3>) {\r\n        this.setColor(value);\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the line. If set the whole line will be mixed with this color according to the colorMode option.\r\n     * @param value color\r\n     */\r\n    public setColor(value: Nullable<Color3>, doNotMarkDirty = false) {\r\n        if ((this._color === null && value !== null) || (this._color !== null && value === null)) {\r\n            this._color = value;\r\n            !doNotMarkDirty && this.markAllDefinesAsDirty();\r\n        } else {\r\n            this._color = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the color distributiopn type\r\n     */\r\n    get colorsDistributionType() {\r\n        return this._colorsDistributionType;\r\n    }\r\n\r\n    /**\r\n     * Sets the color distribution type\r\n     * @see GreasedLineMeshColorDistributionType\r\n     * @param value color distribution type\r\n     */\r\n    set colorsDistributionType(value: GreasedLineMeshColorDistributionType) {\r\n        this._colorsDistributionType = value;\r\n        this.markAllDefinesAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets the resolution\r\n     */\r\n    get resolution() {\r\n        return this._resolution;\r\n    }\r\n\r\n    /**\r\n     * Sets the resolution\r\n     * @param value resolution of the screen for GreasedLine\r\n     */\r\n    set resolution(value: Vector2) {\r\n        this._aspect = value.x / value.y;\r\n        this._resolution = value;\r\n    }\r\n\r\n    /**\r\n     * Serializes this plugin material\r\n     * @returns serializationObjec\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        const greasedLineMaterialOptions: GreasedLineMaterialOptions = {\r\n            colorDistributionType: this._colorsDistributionType,\r\n            colorsSampling: this.colorsSampling,\r\n            colorMode: this.colorMode,\r\n            dashCount: this._dashCount,\r\n            dashOffset: this.dashOffset,\r\n            dashRatio: this.dashRatio,\r\n            resolution: this._resolution,\r\n            sizeAttenuation: this._sizeAttenuation,\r\n            useColors: this.useColors,\r\n            useDash: this.useDash,\r\n            visibility: this.visibility,\r\n            width: this.width,\r\n        };\r\n\r\n        this._colors && (greasedLineMaterialOptions.colors = this._colors);\r\n        this._color && (greasedLineMaterialOptions.color = this._color);\r\n\r\n        serializationObject.greasedLineMaterialOptions = greasedLineMaterialOptions;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized objects\r\n     * @param source serialized object\r\n     * @param scene scene\r\n     * @param rootUrl root url for textures\r\n     */\r\n    public parse(source: any, scene: Scene, rootUrl: string): void {\r\n        super.parse(source, scene, rootUrl);\r\n        const greasedLineMaterialOptions = <GreasedLineMaterialOptions>source.greasedLineMaterialOptions;\r\n\r\n        this.colorsTexture?.dispose();\r\n\r\n        greasedLineMaterialOptions.color && this.setColor(greasedLineMaterialOptions.color, true);\r\n        greasedLineMaterialOptions.colorDistributionType && (this.colorsDistributionType = greasedLineMaterialOptions.colorDistributionType);\r\n        greasedLineMaterialOptions.colors && (this.colors = greasedLineMaterialOptions.colors);\r\n        greasedLineMaterialOptions.colorsSampling && (this.colorsSampling = greasedLineMaterialOptions.colorsSampling);\r\n        greasedLineMaterialOptions.colorMode && (this.colorMode = greasedLineMaterialOptions.colorMode);\r\n        greasedLineMaterialOptions.useColors && (this.useColors = greasedLineMaterialOptions.useColors);\r\n        greasedLineMaterialOptions.visibility && (this.visibility = greasedLineMaterialOptions.visibility);\r\n        greasedLineMaterialOptions.useDash && (this.useDash = greasedLineMaterialOptions.useDash);\r\n        greasedLineMaterialOptions.dashCount && (this.dashCount = greasedLineMaterialOptions.dashCount);\r\n        greasedLineMaterialOptions.dashRatio && (this.dashRatio = greasedLineMaterialOptions.dashRatio);\r\n        greasedLineMaterialOptions.dashOffset && (this.dashOffset = greasedLineMaterialOptions.dashOffset);\r\n        greasedLineMaterialOptions.width && (this.width = greasedLineMaterialOptions.width);\r\n        greasedLineMaterialOptions.sizeAttenuation && (this.sizeAttenuation = greasedLineMaterialOptions.sizeAttenuation);\r\n        greasedLineMaterialOptions.resolution && (this.resolution = greasedLineMaterialOptions.resolution);\r\n\r\n        if (this.colors) {\r\n            this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this._material.name}-colors-texture`, this.colors, this.colorsSampling, scene);\r\n        } else {\r\n            GreasedLineTools.PrepareEmptyColorsTexture(scene);\r\n        }\r\n\r\n        this.markAllDefinesAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current configuration into another one.\r\n     * @param plugin define the config where to copy the info\r\n     */\r\n    public copyTo(plugin: MaterialPluginBase): void {\r\n        const dest = plugin as GreasedLinePluginMaterial;\r\n\r\n        dest.colorsTexture?.dispose();\r\n\r\n        if (this._colors) {\r\n            dest.colorsTexture = GreasedLineTools.CreateColorsTexture(`${dest._material.name}-colors-texture`, this._colors, dest.colorsSampling, this._scene);\r\n        }\r\n\r\n        dest.setColor(this.color, true);\r\n        dest.colorsDistributionType = this.colorsDistributionType;\r\n        dest.colorsSampling = this.colorsSampling;\r\n        dest.colorMode = this.colorMode;\r\n        dest.useColors = this.useColors;\r\n        dest.visibility = this.visibility;\r\n        dest.useDash = this.useDash;\r\n        dest.dashCount = this.dashCount;\r\n        dest.dashRatio = this.dashRatio;\r\n        dest.dashOffset = this.dashOffset;\r\n        dest.width = this.width;\r\n        dest.sizeAttenuation = this.sizeAttenuation;\r\n        dest.resolution = this.resolution;\r\n\r\n        dest.markAllDefinesAsDirty();\r\n    }\r\n}\r\n\r\nRegisterClass(`BABYLON.${GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME}`, GreasedLinePluginMaterial);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}