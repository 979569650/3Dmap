{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../tslib.es6.js\";\nimport { GetClass } from \"../../Misc/typeStore.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { UniqueIdGenerator } from \"../../Misc/uniqueIdGenerator.js\";\nimport { NodeGeometryConnectionPoint, NodeGeometryConnectionPointDirection } from \"./nodeGeometryBlockConnectionPoint.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { PrecisionDate } from \"../../Misc/precisionDate.js\";\n/**\n * Defines a block that can be used inside a node based geometry\n */\nexport class NodeGeometryBlock {\n  /**\n   * Gets the time spent to build this block (in ms)\n   */\n  get buildExecutionTime() {\n    return this._buildExecutionTime;\n  }\n  /**\n   * Gets the list of input points\n   */\n  get inputs() {\n    return this._inputs;\n  }\n  /** Gets the list of output points */\n  get outputs() {\n    return this._outputs;\n  }\n  /**\n   * Gets or set the name of the block\n   */\n  get name() {\n    return this._name;\n  }\n  set name(value) {\n    this._name = value;\n  }\n  /**\n   * Gets a boolean indicating if this block is an input\n   */\n  get isInput() {\n    return this._isInput;\n  }\n  /**\n   * Gets a boolean indicating if this block is a teleport out\n   */\n  get isTeleportOut() {\n    return this._isTeleportOut;\n  }\n  /**\n   * Gets a boolean indicating if this block is a teleport in\n   */\n  get isTeleportIn() {\n    return this._isTeleportIn;\n  }\n  /**\n   * Gets a boolean indicating if this block is a debug block\n   */\n  get isDebug() {\n    return this._isDebug;\n  }\n  /**\n   * Gets a boolean indicating that this block can only be used once per NodeGeometry\n   */\n  get isUnique() {\n    return this._isUnique;\n  }\n  /**\n   * Gets the current class name e.g. \"NodeGeometryBlock\"\n   * @returns the class name\n   */\n  getClassName() {\n    return \"NodeGeometryBlock\";\n  }\n  _inputRename(name) {\n    return name;\n  }\n  _outputRename(name) {\n    return name;\n  }\n  /**\n   * Checks if the current block is an ancestor of a given block\n   * @param block defines the potential descendant block to check\n   * @returns true if block is a descendant\n   */\n  isAnAncestorOf(block) {\n    for (const output of this._outputs) {\n      if (!output.hasEndpoints) {\n        continue;\n      }\n      for (const endpoint of output.endpoints) {\n        if (endpoint.ownerBlock === block) {\n          return true;\n        }\n        if (endpoint.ownerBlock.isAnAncestorOf(block)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks if the current block is an ancestor of a given type\n   * @param type defines the potential type to check\n   * @returns true if block is a descendant\n   */\n  isAnAncestorOfType(type) {\n    if (this.getClassName() === type) {\n      return true;\n    }\n    for (const output of this._outputs) {\n      if (!output.hasEndpoints) {\n        continue;\n      }\n      for (const endpoint of output.endpoints) {\n        if (endpoint.ownerBlock.isAnAncestorOfType(type)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Get the first descendant using a predicate\n   * @param predicate defines the predicate to check\n   * @returns descendant or null if none found\n   */\n  getDescendantOfPredicate(predicate) {\n    if (predicate(this)) {\n      return this;\n    }\n    for (const output of this._outputs) {\n      if (!output.hasEndpoints) {\n        continue;\n      }\n      for (const endpoint of output.endpoints) {\n        const descendant = endpoint.ownerBlock.getDescendantOfPredicate(predicate);\n        if (descendant) {\n          return descendant;\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Creates a new NodeGeometryBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    this._name = \"\";\n    this._isInput = false;\n    this._isTeleportOut = false;\n    this._isTeleportIn = false;\n    this._isDebug = false;\n    this._isUnique = false;\n    this._buildExecutionTime = 0;\n    /**\n     * Gets an observable raised when the block is built\n     */\n    this.onBuildObservable = new Observable();\n    /** @internal */\n    this._inputs = new Array();\n    /** @internal */\n    this._outputs = new Array();\n    /** @internal */\n    this._codeVariableName = \"\";\n    /** Gets or sets a boolean indicating that this input can be edited from a collapsed frame */\n    this.visibleOnFrame = false;\n    this._name = name;\n    this.uniqueId = UniqueIdGenerator.UniqueId;\n  }\n  /**\n   * Register a new input. Must be called inside a block constructor\n   * @param name defines the connection point name\n   * @param type defines the connection point type\n   * @param isOptional defines a boolean indicating that this input can be omitted\n   * @param value value to return if there is no connection\n   * @param valueMin min value accepted for value\n   * @param valueMax max value accepted for value\n   * @returns the current block\n   */\n  registerInput(name, type, isOptional = false, value, valueMin, valueMax) {\n    const point = new NodeGeometryConnectionPoint(name, this, NodeGeometryConnectionPointDirection.Input);\n    point.type = type;\n    point.isOptional = isOptional;\n    point.defaultValue = value;\n    point.value = value;\n    point.valueMin = valueMin;\n    point.valueMax = valueMax;\n    this._inputs.push(point);\n    return this;\n  }\n  /**\n   * Register a new output. Must be called inside a block constructor\n   * @param name defines the connection point name\n   * @param type defines the connection point type\n   * @param point an already created connection point. If not provided, create a new one\n   * @returns the current block\n   */\n  registerOutput(name, type, point) {\n    point = point !== null && point !== void 0 ? point : new NodeGeometryConnectionPoint(name, this, NodeGeometryConnectionPointDirection.Output);\n    point.type = type;\n    this._outputs.push(point);\n    return this;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _buildBlock(state) {\n    // Empty. Must be defined by child nodes\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _customBuildStep(state) {\n    // Must be implemented by children\n  }\n  /**\n   * Build the current node and generate the vertex data\n   * @param state defines the current generation state\n   * @returns true if already built\n   */\n  build(state) {\n    if (this._buildId === state.buildId) {\n      return true;\n    }\n    if (this._outputs.length > 0) {\n      if (!this._outputs.some(o => o.hasEndpoints) && !this.isDebug) {\n        return false;\n      }\n    }\n    this._buildId = state.buildId;\n    // Check if \"parent\" blocks are compiled\n    for (const input of this._inputs) {\n      if (!input.connectedPoint) {\n        if (!input.isOptional) {\n          // Emit a warning\n          state.notConnectedNonOptionalInputs.push(input);\n        }\n        continue;\n      }\n      const block = input.connectedPoint.ownerBlock;\n      if (block && block !== this) {\n        block.build(state);\n      }\n    }\n    this._customBuildStep(state);\n    // Logs\n    if (state.verbose) {\n      console.log(`Building ${this.name} [${this.getClassName()}]`);\n    }\n    const now = PrecisionDate.Now;\n    this._buildBlock(state);\n    this._buildExecutionTime = PrecisionDate.Now - now;\n    // Compile connected blocks\n    for (const output of this._outputs) {\n      for (const endpoint of output.endpoints) {\n        const block = endpoint.ownerBlock;\n        if (block) {\n          block.build(state);\n        }\n      }\n    }\n    this.onBuildObservable.notifyObservers(this);\n    return false;\n  }\n  _linkConnectionTypes(inputIndex0, inputIndex1, looseCoupling = false) {\n    if (looseCoupling) {\n      this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];\n    } else {\n      this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];\n    }\n    this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   */\n  initialize() {\n    // Do nothing\n  }\n  /**\n   * Lets the block try to connect some inputs automatically\n   */\n  autoConfigure() {\n    // Do nothing\n  }\n  /**\n   * Find an input by its name\n   * @param name defines the name of the input to look for\n   * @returns the input or null if not found\n   */\n  getInputByName(name) {\n    const filter = this._inputs.filter(e => e.name === name);\n    if (filter.length) {\n      return filter[0];\n    }\n    return null;\n  }\n  /**\n   * Find an output by its name\n   * @param name defines the name of the output to look for\n   * @returns the output or null if not found\n   */\n  getOutputByName(name) {\n    const filter = this._outputs.filter(e => e.name === name);\n    if (filter.length) {\n      return filter[0];\n    }\n    return null;\n  }\n  /**\n   * Serializes this block in a JSON representation\n   * @returns the serialized block object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.customType = \"BABYLON.\" + this.getClassName();\n    serializationObject.id = this.uniqueId;\n    serializationObject.name = this.name;\n    serializationObject.inputs = [];\n    serializationObject.outputs = [];\n    for (const input of this.inputs) {\n      serializationObject.inputs.push(input.serialize());\n    }\n    for (const output of this.outputs) {\n      serializationObject.outputs.push(output.serialize(false));\n    }\n    return serializationObject;\n  }\n  /**\n   * @internal\n   */\n  _deserialize(serializationObject) {\n    this._name = serializationObject.name;\n    this.comments = serializationObject.comments;\n    this.visibleOnFrame = !!serializationObject.visibleOnFrame;\n    this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);\n  }\n  _deserializePortDisplayNamesAndExposedOnFrame(serializationObject) {\n    const serializedInputs = serializationObject.inputs;\n    const serializedOutputs = serializationObject.outputs;\n    if (serializedInputs) {\n      serializedInputs.forEach(port => {\n        const input = this.inputs.find(i => i.name === port.name);\n        if (!input) {\n          return;\n        }\n        if (port.displayName) {\n          input.displayName = port.displayName;\n        }\n        if (port.isExposedOnFrame) {\n          input.isExposedOnFrame = port.isExposedOnFrame;\n          input.exposedPortPosition = port.exposedPortPosition;\n        }\n        if (port.value !== undefined && port.value !== null) {\n          if (port.valueType === \"number\") {\n            input.value = port.value;\n          } else {\n            const valueType = GetClass(port.valueType);\n            if (valueType) {\n              input.value = valueType.FromArray(port.value);\n            }\n          }\n        }\n      });\n    }\n    if (serializedOutputs) {\n      serializedOutputs.forEach((port, i) => {\n        if (port.displayName) {\n          this.outputs[i].displayName = port.displayName;\n        }\n        if (port.isExposedOnFrame) {\n          this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;\n          this.outputs[i].exposedPortPosition = port.exposedPortPosition;\n        }\n      });\n    }\n  }\n  _dumpPropertiesCode() {\n    const variableName = this._codeVariableName;\n    return `${variableName}.visibleOnFrame = ${this.visibleOnFrame};\\n`;\n  }\n  /**\n   * @internal\n   */\n  _dumpCodeForOutputConnections(alreadyDumped) {\n    let codeString = \"\";\n    if (alreadyDumped.indexOf(this) !== -1) {\n      return codeString;\n    }\n    alreadyDumped.push(this);\n    for (const input of this.inputs) {\n      if (!input.isConnected) {\n        continue;\n      }\n      const connectedOutput = input.connectedPoint;\n      const connectedBlock = connectedOutput.ownerBlock;\n      codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);\n      codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(input.name)});\\n`;\n    }\n    return codeString;\n  }\n  /**\n   * @internal\n   */\n  _dumpCode(uniqueNames, alreadyDumped) {\n    alreadyDumped.push(this);\n    // Get unique name\n    const nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, \"\");\n    this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;\n    if (uniqueNames.indexOf(this._codeVariableName) !== -1) {\n      let index = 0;\n      do {\n        index++;\n        this._codeVariableName = nameAsVariableName + index;\n      } while (uniqueNames.indexOf(this._codeVariableName) !== -1);\n    }\n    uniqueNames.push(this._codeVariableName);\n    // Declaration\n    let codeString = `\\n// ${this.getClassName()}\\n`;\n    if (this.comments) {\n      codeString += `// ${this.comments}\\n`;\n    }\n    codeString += `var ${this._codeVariableName} = new BABYLON.${this.getClassName()}(\"${this.name}\");\\n`;\n    // Properties\n    codeString += this._dumpPropertiesCode();\n    // Inputs\n    for (const input of this.inputs) {\n      if (!input.isConnected) {\n        continue;\n      }\n      const connectedOutput = input.connectedPoint;\n      const connectedBlock = connectedOutput.ownerBlock;\n      if (alreadyDumped.indexOf(connectedBlock) === -1) {\n        codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\n      }\n    }\n    // Outputs\n    for (const output of this.outputs) {\n      if (!output.hasEndpoints) {\n        continue;\n      }\n      for (const endpoint of output.endpoints) {\n        const connectedBlock = endpoint.ownerBlock;\n        if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {\n          codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\n        }\n      }\n    }\n    return codeString;\n  }\n  /**\n   * Clone the current block to a new identical block\n   * @returns a copy of the current block\n   */\n  clone() {\n    const serializationObject = this.serialize();\n    const blockType = GetClass(serializationObject.customType);\n    if (blockType) {\n      const block = new blockType();\n      block._deserialize(serializationObject);\n      return block;\n    }\n    return null;\n  }\n  /**\n   * Release resources\n   */\n  dispose() {\n    for (const input of this.inputs) {\n      input.dispose();\n    }\n    for (const output of this.outputs) {\n      output.dispose();\n    }\n    this.onBuildObservable.clear();\n  }\n}\n__decorate([serialize(\"comment\")], NodeGeometryBlock.prototype, \"comments\", void 0);","map":{"version":3,"names":["GetClass","serialize","UniqueIdGenerator","NodeGeometryConnectionPoint","NodeGeometryConnectionPointDirection","Observable","PrecisionDate","NodeGeometryBlock","buildExecutionTime","_buildExecutionTime","inputs","_inputs","outputs","_outputs","name","_name","value","isInput","_isInput","isTeleportOut","_isTeleportOut","isTeleportIn","_isTeleportIn","isDebug","_isDebug","isUnique","_isUnique","getClassName","_inputRename","_outputRename","isAnAncestorOf","block","output","hasEndpoints","endpoint","endpoints","ownerBlock","isAnAncestorOfType","type","getDescendantOfPredicate","predicate","descendant","constructor","onBuildObservable","Array","_codeVariableName","visibleOnFrame","uniqueId","UniqueId","registerInput","isOptional","valueMin","valueMax","point","Input","defaultValue","push","registerOutput","Output","_buildBlock","state","_customBuildStep","build","_buildId","buildId","length","some","o","input","connectedPoint","notConnectedNonOptionalInputs","verbose","console","log","now","Now","notifyObservers","_linkConnectionTypes","inputIndex0","inputIndex1","looseCoupling","_acceptedConnectionPointType","_linkedConnectionSource","initialize","autoConfigure","getInputByName","filter","e","getOutputByName","serializationObject","customType","id","_deserialize","comments","_deserializePortDisplayNamesAndExposedOnFrame","serializedInputs","serializedOutputs","forEach","port","find","i","displayName","isExposedOnFrame","exposedPortPosition","undefined","valueType","FromArray","_dumpPropertiesCode","variableName","_dumpCodeForOutputConnections","alreadyDumped","codeString","indexOf","isConnected","connectedOutput","connectedBlock","_dumpCode","uniqueNames","nameAsVariableName","replace","index","clone","blockType","dispose","clear","__decorate"],"sources":["../../../../../dev/core/src/Meshes/Node/nodeGeometryBlock.ts"],"sourcesContent":["import { GetClass } from \"../../Misc/typeStore\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport { UniqueIdGenerator } from \"../../Misc/uniqueIdGenerator\";\r\nimport type { NodeGeometryBlockConnectionPointTypes } from \"./Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryConnectionPoint, NodeGeometryConnectionPointDirection } from \"./nodeGeometryBlockConnectionPoint\";\r\nimport type { NodeGeometryBuildState } from \"./nodeGeometryBuildState\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Defines a block that can be used inside a node based geometry\r\n */\r\nexport class NodeGeometryBlock {\r\n    private _name = \"\";\r\n    private _buildId: number;\r\n    protected _isInput = false;\r\n    protected _isTeleportOut = false;\r\n    protected _isTeleportIn = false;\r\n    protected _isDebug = false;\r\n    protected _isUnique = false;\r\n    private _buildExecutionTime: number = 0;\r\n\r\n    /**\r\n     * Gets an observable raised when the block is built\r\n     */\r\n    public onBuildObservable = new Observable<NodeGeometryBlock>();\r\n\r\n    /** @internal */\r\n    public _inputs = new Array<NodeGeometryConnectionPoint>();\r\n    /** @internal */\r\n    public _outputs = new Array<NodeGeometryConnectionPoint>();\r\n    /** @internal */\r\n    public _preparationId: number;\r\n    /** @internal */\r\n    public _codeVariableName = \"\";\r\n\r\n    /**\r\n     * Gets the time spent to build this block (in ms)\r\n     */\r\n    public get buildExecutionTime() {\r\n        return this._buildExecutionTime;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of input points\r\n     */\r\n    public get inputs(): NodeGeometryConnectionPoint[] {\r\n        return this._inputs;\r\n    }\r\n\r\n    /** Gets the list of output points */\r\n    public get outputs(): NodeGeometryConnectionPoint[] {\r\n        return this._outputs;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the unique id of the node\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Gets or set the name of the block\r\n     */\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    public set name(value: string) {\r\n        this._name = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this block is an input\r\n     */\r\n    public get isInput(): boolean {\r\n        return this._isInput;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this block is a teleport out\r\n     */\r\n    public get isTeleportOut(): boolean {\r\n        return this._isTeleportOut;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this block is a teleport in\r\n     */\r\n    public get isTeleportIn(): boolean {\r\n        return this._isTeleportIn;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this block is a debug block\r\n     */\r\n    public get isDebug(): boolean {\r\n        return this._isDebug;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block can only be used once per NodeGeometry\r\n     */\r\n    public get isUnique() {\r\n        return this._isUnique;\r\n    }\r\n\r\n    /**\r\n     * A free comment about the block\r\n     */\r\n    @serialize(\"comment\")\r\n    public comments: string;\r\n\r\n    /** Gets or sets a boolean indicating that this input can be edited from a collapsed frame */\r\n    public visibleOnFrame = false;\r\n\r\n    /**\r\n     * Gets the current class name e.g. \"NodeGeometryBlock\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"NodeGeometryBlock\";\r\n    }\r\n\r\n    protected _inputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    protected _outputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * Checks if the current block is an ancestor of a given block\r\n     * @param block defines the potential descendant block to check\r\n     * @returns true if block is a descendant\r\n     */\r\n    public isAnAncestorOf(block: NodeGeometryBlock): boolean {\r\n        for (const output of this._outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                if (endpoint.ownerBlock === block) {\r\n                    return true;\r\n                }\r\n                if (endpoint.ownerBlock.isAnAncestorOf(block)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the current block is an ancestor of a given type\r\n     * @param type defines the potential type to check\r\n     * @returns true if block is a descendant\r\n     */\r\n    public isAnAncestorOfType(type: string): boolean {\r\n        if (this.getClassName() === type) {\r\n            return true;\r\n        }\r\n\r\n        for (const output of this._outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                if (endpoint.ownerBlock.isAnAncestorOfType(type)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the first descendant using a predicate\r\n     * @param predicate defines the predicate to check\r\n     * @returns descendant or null if none found\r\n     */\r\n    public getDescendantOfPredicate(predicate: (block: NodeGeometryBlock) => boolean): Nullable<NodeGeometryBlock> {\r\n        if (predicate(this)) {\r\n            return this;\r\n        }\r\n\r\n        for (const output of this._outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                const descendant = endpoint.ownerBlock.getDescendantOfPredicate(predicate);\r\n\r\n                if (descendant) {\r\n                    return descendant;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates a new NodeGeometryBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        this._name = name;\r\n        this.uniqueId = UniqueIdGenerator.UniqueId;\r\n    }\r\n\r\n    /**\r\n     * Register a new input. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param isOptional defines a boolean indicating that this input can be omitted\r\n     * @param value value to return if there is no connection\r\n     * @param valueMin min value accepted for value\r\n     * @param valueMax max value accepted for value\r\n     * @returns the current block\r\n     */\r\n    public registerInput(name: string, type: NodeGeometryBlockConnectionPointTypes, isOptional: boolean = false, value?: any, valueMin?: any, valueMax?: any) {\r\n        const point = new NodeGeometryConnectionPoint(name, this, NodeGeometryConnectionPointDirection.Input);\r\n        point.type = type;\r\n        point.isOptional = isOptional;\r\n        point.defaultValue = value;\r\n        point.value = value;\r\n        point.valueMin = valueMin;\r\n        point.valueMax = valueMax;\r\n\r\n        this._inputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Register a new output. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param point an already created connection point. If not provided, create a new one\r\n     * @returns the current block\r\n     */\r\n    public registerOutput(name: string, type: NodeGeometryBlockConnectionPointTypes, point?: NodeGeometryConnectionPoint) {\r\n        point = point ?? new NodeGeometryConnectionPoint(name, this, NodeGeometryConnectionPointDirection.Output);\r\n        point.type = type;\r\n\r\n        this._outputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        // Empty. Must be defined by child nodes\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _customBuildStep(state: NodeGeometryBuildState): void {\r\n        // Must be implemented by children\r\n    }\r\n\r\n    /**\r\n     * Build the current node and generate the vertex data\r\n     * @param state defines the current generation state\r\n     * @returns true if already built\r\n     */\r\n    public build(state: NodeGeometryBuildState): boolean {\r\n        if (this._buildId === state.buildId) {\r\n            return true;\r\n        }\r\n\r\n        if (this._outputs.length > 0) {\r\n            if (!this._outputs.some((o) => o.hasEndpoints) && !this.isDebug) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        this._buildId = state.buildId;\r\n\r\n        // Check if \"parent\" blocks are compiled\r\n        for (const input of this._inputs) {\r\n            if (!input.connectedPoint) {\r\n                if (!input.isOptional) {\r\n                    // Emit a warning\r\n                    state.notConnectedNonOptionalInputs.push(input);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            const block = input.connectedPoint.ownerBlock;\r\n            if (block && block !== this) {\r\n                block.build(state);\r\n            }\r\n        }\r\n\r\n        this._customBuildStep(state);\r\n\r\n        // Logs\r\n        if (state.verbose) {\r\n            console.log(`Building ${this.name} [${this.getClassName()}]`);\r\n        }\r\n\r\n        const now = PrecisionDate.Now;\r\n        this._buildBlock(state);\r\n        this._buildExecutionTime = PrecisionDate.Now - now;\r\n\r\n        // Compile connected blocks\r\n        for (const output of this._outputs) {\r\n            for (const endpoint of output.endpoints) {\r\n                const block = endpoint.ownerBlock;\r\n\r\n                if (block) {\r\n                    block.build(state);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.onBuildObservable.notifyObservers(this);\r\n\r\n        return false;\r\n    }\r\n\r\n    protected _linkConnectionTypes(inputIndex0: number, inputIndex1: number, looseCoupling = false) {\r\n        if (looseCoupling) {\r\n            this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];\r\n        } else {\r\n            this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];\r\n        }\r\n        this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     */\r\n    public initialize() {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Lets the block try to connect some inputs automatically\r\n     */\r\n    public autoConfigure() {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Find an input by its name\r\n     * @param name defines the name of the input to look for\r\n     * @returns the input or null if not found\r\n     */\r\n    public getInputByName(name: string) {\r\n        const filter = this._inputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Find an output by its name\r\n     * @param name defines the name of the output to look for\r\n     * @returns the output or null if not found\r\n     */\r\n    public getOutputByName(name: string) {\r\n        const filter = this._outputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.customType = \"BABYLON.\" + this.getClassName();\r\n        serializationObject.id = this.uniqueId;\r\n        serializationObject.name = this.name;\r\n\r\n        serializationObject.inputs = [];\r\n        serializationObject.outputs = [];\r\n\r\n        for (const input of this.inputs) {\r\n            serializationObject.inputs.push(input.serialize());\r\n        }\r\n\r\n        for (const output of this.outputs) {\r\n            serializationObject.outputs.push(output.serialize(false));\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _deserialize(serializationObject: any) {\r\n        this._name = serializationObject.name;\r\n        this.comments = serializationObject.comments;\r\n        this.visibleOnFrame = !!serializationObject.visibleOnFrame;\r\n        this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);\r\n    }\r\n\r\n    private _deserializePortDisplayNamesAndExposedOnFrame(serializationObject: any) {\r\n        const serializedInputs = serializationObject.inputs;\r\n        const serializedOutputs = serializationObject.outputs;\r\n        if (serializedInputs) {\r\n            serializedInputs.forEach((port: any) => {\r\n                const input = this.inputs.find((i) => i.name === port.name);\r\n\r\n                if (!input) {\r\n                    return;\r\n                }\r\n\r\n                if (port.displayName) {\r\n                    input.displayName = port.displayName;\r\n                }\r\n                if (port.isExposedOnFrame) {\r\n                    input.isExposedOnFrame = port.isExposedOnFrame;\r\n                    input.exposedPortPosition = port.exposedPortPosition;\r\n                }\r\n                if (port.value !== undefined && port.value !== null) {\r\n                    if (port.valueType === \"number\") {\r\n                        input.value = port.value;\r\n                    } else {\r\n                        const valueType = GetClass(port.valueType);\r\n\r\n                        if (valueType) {\r\n                            input.value = valueType.FromArray(port.value);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        if (serializedOutputs) {\r\n            serializedOutputs.forEach((port: any, i: number) => {\r\n                if (port.displayName) {\r\n                    this.outputs[i].displayName = port.displayName;\r\n                }\r\n                if (port.isExposedOnFrame) {\r\n                    this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;\r\n                    this.outputs[i].exposedPortPosition = port.exposedPortPosition;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const variableName = this._codeVariableName;\r\n        return `${variableName}.visibleOnFrame = ${this.visibleOnFrame};\\n`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _dumpCodeForOutputConnections(alreadyDumped: NodeGeometryBlock[]) {\r\n        let codeString = \"\";\r\n\r\n        if (alreadyDumped.indexOf(this) !== -1) {\r\n            return codeString;\r\n        }\r\n\r\n        alreadyDumped.push(this);\r\n\r\n        for (const input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            const connectedOutput = input.connectedPoint!;\r\n            const connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);\r\n            codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(\r\n                input.name\r\n            )});\\n`;\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _dumpCode(uniqueNames: string[], alreadyDumped: NodeGeometryBlock[]) {\r\n        alreadyDumped.push(this);\r\n\r\n        // Get unique name\r\n        const nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, \"\");\r\n        this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;\r\n\r\n        if (uniqueNames.indexOf(this._codeVariableName) !== -1) {\r\n            let index = 0;\r\n            do {\r\n                index++;\r\n                this._codeVariableName = nameAsVariableName + index;\r\n            } while (uniqueNames.indexOf(this._codeVariableName) !== -1);\r\n        }\r\n\r\n        uniqueNames.push(this._codeVariableName);\r\n\r\n        // Declaration\r\n        let codeString = `\\n// ${this.getClassName()}\\n`;\r\n        if (this.comments) {\r\n            codeString += `// ${this.comments}\\n`;\r\n        }\r\n        codeString += `var ${this._codeVariableName} = new BABYLON.${this.getClassName()}(\"${this.name}\");\\n`;\r\n\r\n        // Properties\r\n        codeString += this._dumpPropertiesCode();\r\n\r\n        // Inputs\r\n        for (const input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            const connectedOutput = input.connectedPoint!;\r\n            const connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            if (alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Outputs\r\n        for (const output of this.outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                const connectedBlock = endpoint.ownerBlock;\r\n                if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                    codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n                }\r\n            }\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Clone the current block to a new identical block\r\n     * @returns a copy of the current block\r\n     */\r\n    public clone() {\r\n        const serializationObject = this.serialize();\r\n\r\n        const blockType = GetClass(serializationObject.customType);\r\n        if (blockType) {\r\n            const block: NodeGeometryBlock = new blockType();\r\n            block._deserialize(serializationObject);\r\n\r\n            return block;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        for (const input of this.inputs) {\r\n            input.dispose();\r\n        }\r\n\r\n        for (const output of this.outputs) {\r\n            output.dispose();\r\n        }\r\n\r\n        this.onBuildObservable.clear();\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}