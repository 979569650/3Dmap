{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"./Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialConnectionPoint, NodeMaterialConnectionPointDirection } from \"./nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets.js\";\nimport { UniqueIdGenerator } from \"../../Misc/uniqueIdGenerator.js\";\nimport { GetClass } from \"../../Misc/typeStore.js\";\n/**\n * Defines a block that can be used inside a node based material\n */\nexport class NodeMaterialBlock {\n  /**\n   * Gets the name of the block\n   */\n  get name() {\n    return this._name;\n  }\n  /**\n   * Sets the name of the block. Will check if the name is valid.\n   */\n  set name(newName) {\n    if (!this.validateBlockName(newName)) {\n      return;\n    }\n    this._name = newName;\n  }\n  /**\n   * Gets a boolean indicating that this block can only be used once per NodeMaterial\n   */\n  get isUnique() {\n    return this._isUnique;\n  }\n  /**\n   * Gets a boolean indicating that this block is an end block (e.g. it is generating a system value)\n   */\n  get isFinalMerger() {\n    return this._isFinalMerger;\n  }\n  /**\n   * Gets a boolean indicating that this block is an input (e.g. it sends data to the shader)\n   */\n  get isInput() {\n    return this._isInput;\n  }\n  /**\n   * Gets a boolean indicating if this block is a teleport out\n   */\n  get isTeleportOut() {\n    return this._isTeleportOut;\n  }\n  /**\n   * Gets a boolean indicating if this block is a teleport in\n   */\n  get isTeleportIn() {\n    return this._isTeleportIn;\n  }\n  /**\n   * Gets or sets the build Id\n   */\n  get buildId() {\n    return this._buildId;\n  }\n  set buildId(value) {\n    this._buildId = value;\n  }\n  /**\n   * Gets or sets the target of the block\n   */\n  get target() {\n    return this._target;\n  }\n  set target(value) {\n    if ((this._target & value) !== 0) {\n      return;\n    }\n    this._target = value;\n  }\n  /**\n   * Gets the list of input points\n   */\n  get inputs() {\n    return this._inputs;\n  }\n  /** Gets the list of output points */\n  get outputs() {\n    return this._outputs;\n  }\n  /**\n   * Find an input by its name\n   * @param name defines the name of the input to look for\n   * @returns the input or null if not found\n   */\n  getInputByName(name) {\n    const filter = this._inputs.filter(e => e.name === name);\n    if (filter.length) {\n      return filter[0];\n    }\n    return null;\n  }\n  /**\n   * Find an output by its name\n   * @param name defines the name of the output to look for\n   * @returns the output or null if not found\n   */\n  getOutputByName(name) {\n    const filter = this._outputs.filter(e => e.name === name);\n    if (filter.length) {\n      return filter[0];\n    }\n    return null;\n  }\n  /**\n   * Creates a new NodeMaterialBlock\n   * @param name defines the block name\n   * @param target defines the target of that block (Vertex by default)\n   * @param isFinalMerger defines a boolean indicating that this block is an end block (e.g. it is generating a system value). Default is false\n   */\n  constructor(name, target = NodeMaterialBlockTargets.Vertex, isFinalMerger = false) {\n    this._isFinalMerger = false;\n    this._isInput = false;\n    this._isTeleportOut = false;\n    this._isTeleportIn = false;\n    this._name = \"\";\n    this._isUnique = false;\n    /** Gets or sets a boolean indicating that only one input can be connected at a time */\n    this.inputsAreExclusive = false;\n    /** @internal */\n    this._codeVariableName = \"\";\n    /** @internal */\n    this._inputs = new Array();\n    /** @internal */\n    this._outputs = new Array();\n    /**\n     * Gets or sets the comments associated with this block\n     */\n    this.comments = \"\";\n    /** Gets or sets a boolean indicating that this input can be edited in the Inspector (false by default) */\n    this.visibleInInspector = false;\n    /** Gets or sets a boolean indicating that this input can be edited from a collapsed frame */\n    this.visibleOnFrame = false;\n    this._target = target;\n    this._originalTargetIsNeutral = target === NodeMaterialBlockTargets.Neutral;\n    this._isFinalMerger = isFinalMerger;\n    this._isInput = this.getClassName() === \"InputBlock\";\n    this._isTeleportOut = this.getClassName() === \"NodeMaterialTeleportOutBlock\";\n    this._isTeleportIn = this.getClassName() === \"NodeMaterialTeleportInBlock\";\n    this._name = name;\n    this.uniqueId = UniqueIdGenerator.UniqueId;\n  }\n  /** @internal */\n  _setInitialTarget(target) {\n    this._target = target;\n    this._originalTargetIsNeutral = target === NodeMaterialBlockTargets.Neutral;\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  initialize(state) {\n    // Do nothing\n  }\n  /**\n   * Bind data to effect. Will only be called for blocks with isBindable === true\n   * @param effect defines the effect to bind data to\n   * @param nodeMaterial defines the hosting NodeMaterial\n   * @param mesh defines the mesh that will be rendered\n   * @param subMesh defines the submesh that will be rendered\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  bind(effect, nodeMaterial, mesh, subMesh) {\n    // Do nothing\n  }\n  _declareOutput(output, state) {\n    return `${state._getGLType(output.type)} ${output.associatedVariableName}`;\n  }\n  _writeVariable(currentPoint) {\n    const connectionPoint = currentPoint.connectedPoint;\n    if (connectionPoint) {\n      return `${currentPoint.associatedVariableName}`;\n    }\n    return `0.`;\n  }\n  _writeFloat(value) {\n    let stringVersion = value.toString();\n    if (stringVersion.indexOf(\".\") === -1) {\n      stringVersion += \".0\";\n    }\n    return `${stringVersion}`;\n  }\n  /**\n   * Gets the current class name e.g. \"NodeMaterialBlock\"\n   * @returns the class name\n   */\n  getClassName() {\n    return \"NodeMaterialBlock\";\n  }\n  /** Gets a boolean indicating that this connection will be used in the fragment shader */\n  isConnectedInFragmentShader() {\n    return this.outputs.some(o => o.isConnectedInFragmentShader);\n  }\n  /**\n   * Register a new input. Must be called inside a block constructor\n   * @param name defines the connection point name\n   * @param type defines the connection point type\n   * @param isOptional defines a boolean indicating that this input can be omitted\n   * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\n   * @param point an already created connection point. If not provided, create a new one\n   * @returns the current block\n   */\n  registerInput(name, type, isOptional = false, target, point) {\n    point = point !== null && point !== void 0 ? point : new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Input);\n    point.type = type;\n    point.isOptional = isOptional;\n    if (target) {\n      point.target = target;\n    }\n    this._inputs.push(point);\n    return this;\n  }\n  /**\n   * Register a new output. Must be called inside a block constructor\n   * @param name defines the connection point name\n   * @param type defines the connection point type\n   * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\n   * @param point an already created connection point. If not provided, create a new one\n   * @returns the current block\n   */\n  registerOutput(name, type, target, point) {\n    point = point !== null && point !== void 0 ? point : new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Output);\n    point.type = type;\n    if (target) {\n      point.target = target;\n    }\n    this._outputs.push(point);\n    return this;\n  }\n  /**\n   * Will return the first available input e.g. the first one which is not an uniform or an attribute\n   * @param forOutput defines an optional connection point to check compatibility with\n   * @returns the first available input or null\n   */\n  getFirstAvailableInput(forOutput = null) {\n    for (const input of this._inputs) {\n      if (!input.connectedPoint) {\n        if (!forOutput || forOutput.type === input.type || input.type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\n          return input;\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Will return the first available output e.g. the first one which is not yet connected and not a varying\n   * @param forBlock defines an optional block to check compatibility with\n   * @returns the first available input or null\n   */\n  getFirstAvailableOutput(forBlock = null) {\n    for (const output of this._outputs) {\n      if (!forBlock || !forBlock.target || forBlock.target === NodeMaterialBlockTargets.Neutral || (forBlock.target & output.target) !== 0) {\n        return output;\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets the sibling of the given output\n   * @param current defines the current output\n   * @returns the next output in the list or null\n   */\n  getSiblingOutput(current) {\n    const index = this._outputs.indexOf(current);\n    if (index === -1 || index >= this._outputs.length) {\n      return null;\n    }\n    return this._outputs[index + 1];\n  }\n  /**\n   * Checks if the current block is an ancestor of a given block\n   * @param block defines the potential descendant block to check\n   * @returns true if block is a descendant\n   */\n  isAnAncestorOf(block) {\n    for (const output of this._outputs) {\n      if (!output.hasEndpoints) {\n        continue;\n      }\n      for (const endpoint of output.endpoints) {\n        if (endpoint.ownerBlock === block) {\n          return true;\n        }\n        if (endpoint.ownerBlock.isAnAncestorOf(block)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Connect current block with another block\n   * @param other defines the block to connect with\n   * @param options define the various options to help pick the right connections\n   * @param options.input\n   * @param options.output\n   * @param options.outputSwizzle\n   * @returns the current block\n   */\n  connectTo(other, options) {\n    if (this._outputs.length === 0) {\n      return;\n    }\n    let output = options && options.output ? this.getOutputByName(options.output) : this.getFirstAvailableOutput(other);\n    let notFound = true;\n    while (notFound) {\n      const input = options && options.input ? other.getInputByName(options.input) : other.getFirstAvailableInput(output);\n      if (output && input && output.canConnectTo(input)) {\n        output.connectTo(input);\n        notFound = false;\n      } else if (!output) {\n        throw \"Unable to find a compatible match\";\n      } else {\n        output = this.getSiblingOutput(output);\n      }\n    }\n    return this;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _buildBlock(state) {\n    // Empty. Must be defined by child nodes\n  }\n  /**\n   * Add uniforms, samplers and uniform buffers at compilation time\n   * @param state defines the state to update\n   * @param nodeMaterial defines the node material requesting the update\n   * @param defines defines the material defines to update\n   * @param uniformBuffers defines the list of uniform buffer names\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  updateUniformsAndSamples(state, nodeMaterial, defines, uniformBuffers) {\n    // Do nothing\n  }\n  /**\n   * Add potential fallbacks if shader compilation fails\n   * @param mesh defines the mesh to be rendered\n   * @param fallbacks defines the current prioritized list of fallbacks\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  provideFallbacks(mesh, fallbacks) {\n    // Do nothing\n  }\n  /**\n   * Initialize defines for shader compilation\n   * @param mesh defines the mesh to be rendered\n   * @param nodeMaterial defines the node material requesting the update\n   * @param defines defines the material defines to update\n   * @param useInstances specifies that instances should be used\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  initializeDefines(mesh, nodeMaterial, defines, useInstances = false) {}\n  /**\n   * Update defines for shader compilation\n   * @param mesh defines the mesh to be rendered\n   * @param nodeMaterial defines the node material requesting the update\n   * @param defines defines the material defines to update\n   * @param useInstances specifies that instances should be used\n   * @param subMesh defines which submesh to render\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  prepareDefines(mesh, nodeMaterial, defines, useInstances = false, subMesh) {\n    // Do nothing\n  }\n  /**\n   * Lets the block try to connect some inputs automatically\n   * @param material defines the hosting NodeMaterial\n   * @param additionalFilteringInfo optional additional filtering condition when looking for compatible blocks\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  autoConfigure(material, additionalFilteringInfo = () => true) {\n    // Do nothing\n  }\n  /**\n   * Function called when a block is declared as repeatable content generator\n   * @param vertexShaderState defines the current compilation state for the vertex shader\n   * @param fragmentShaderState defines the current compilation state for the fragment shader\n   * @param mesh defines the mesh to be rendered\n   * @param defines defines the material defines to update\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  replaceRepeatableContent(vertexShaderState, fragmentShaderState, mesh, defines) {\n    // Do nothing\n  }\n  /** Gets a boolean indicating that the code of this block will be promoted to vertex shader even if connected to fragment output */\n  get willBeGeneratedIntoVertexShaderFromFragmentShader() {\n    if (this.isInput || this.isFinalMerger) {\n      return false;\n    }\n    if (this._outputs.some(o => o.isDirectlyConnectedToVertexOutput)) {\n      return false;\n    }\n    if (this.target === NodeMaterialBlockTargets.Vertex) {\n      return false;\n    }\n    if (this.target === NodeMaterialBlockTargets.VertexAndFragment || this.target === NodeMaterialBlockTargets.Neutral) {\n      if (this._outputs.some(o => o.isConnectedInVertexShader)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks if the block is ready\n   * @param mesh defines the mesh to be rendered\n   * @param nodeMaterial defines the node material requesting the update\n   * @param defines defines the material defines to update\n   * @param useInstances specifies that instances should be used\n   * @returns true if the block is ready\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  isReady(mesh, nodeMaterial, defines, useInstances = false) {\n    return true;\n  }\n  _linkConnectionTypes(inputIndex0, inputIndex1, looseCoupling = false) {\n    if (looseCoupling) {\n      this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];\n    } else {\n      this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];\n    }\n    this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];\n  }\n  _processBuild(block, state, input, activeBlocks) {\n    block.build(state, activeBlocks);\n    const localBlockIsFragment = state._vertexState != null;\n    const otherBlockWasGeneratedInVertexShader = block._buildTarget === NodeMaterialBlockTargets.Vertex && block.target !== NodeMaterialBlockTargets.VertexAndFragment;\n    if (localBlockIsFragment && ((block.target & block._buildTarget) === 0 || (block.target & input.target) === 0 || this.target !== NodeMaterialBlockTargets.VertexAndFragment && otherBlockWasGeneratedInVertexShader)) {\n      // context switch! We need a varying\n      if (!block.isInput && state.target !== block._buildTarget ||\n      // block was already emitted by vertex shader\n      block.isInput && block.isAttribute && !block._noContextSwitch // block is an attribute\n      ) {\n        const connectedPoint = input.connectedPoint;\n        if (state._vertexState._emitVaryingFromString(\"v_\" + connectedPoint.associatedVariableName, state._getGLType(connectedPoint.type))) {\n          state._vertexState.compilationString += `${\"v_\" + connectedPoint.associatedVariableName} = ${connectedPoint.associatedVariableName};\\n`;\n        }\n        input.associatedVariableName = \"v_\" + connectedPoint.associatedVariableName;\n        input._enforceAssociatedVariableName = true;\n      }\n    }\n  }\n  /**\n   * Validates the new name for the block node.\n   * @param newName the new name to be given to the node.\n   * @returns false if the name is a reserve word, else true.\n   */\n  validateBlockName(newName) {\n    const reservedNames = [\"position\", \"normal\", \"tangent\", \"particle_positionw\", \"uv\", \"uv2\", \"uv3\", \"uv4\", \"uv5\", \"uv6\", \"position2d\", \"particle_uv\", \"matricesIndices\", \"matricesWeights\", \"world0\", \"world1\", \"world2\", \"world3\", \"particle_color\", \"particle_texturemask\"];\n    for (const reservedName of reservedNames) {\n      if (newName === reservedName) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _customBuildStep(state, activeBlocks) {\n    // Must be implemented by children\n  }\n  /**\n   * Compile the current node and generate the shader code\n   * @param state defines the current compilation state (uniforms, samplers, current string)\n   * @param activeBlocks defines the list of active blocks (i.e. blocks to compile)\n   * @returns true if already built\n   */\n  build(state, activeBlocks) {\n    if (this._buildId === state.sharedData.buildId) {\n      return true;\n    }\n    if (!this.isInput) {\n      /** Prepare outputs */\n      for (const output of this._outputs) {\n        if (!output.associatedVariableName) {\n          output.associatedVariableName = state._getFreeVariableName(output.name);\n        }\n      }\n    }\n    // Check if \"parent\" blocks are compiled\n    for (const input of this._inputs) {\n      if (!input.connectedPoint) {\n        if (!input.isOptional) {\n          // Emit a warning\n          state.sharedData.checks.notConnectedNonOptionalInputs.push(input);\n        }\n        continue;\n      }\n      if (this.target !== NodeMaterialBlockTargets.Neutral) {\n        if ((input.target & this.target) === 0) {\n          continue;\n        }\n        if ((input.target & state.target) === 0) {\n          continue;\n        }\n      }\n      const block = input.connectedPoint.ownerBlock;\n      if (block && block !== this) {\n        this._processBuild(block, state, input, activeBlocks);\n      }\n    }\n    this._customBuildStep(state, activeBlocks);\n    if (this._buildId === state.sharedData.buildId) {\n      return true; // Need to check again as inputs can be connected multiple time to this endpoint\n    }\n    // Logs\n    if (state.sharedData.verbose) {\n      console.log(`${state.target === NodeMaterialBlockTargets.Vertex ? \"Vertex shader\" : \"Fragment shader\"}: Building ${this.name} [${this.getClassName()}]`);\n    }\n    // Checks final outputs\n    if (this.isFinalMerger) {\n      switch (state.target) {\n        case NodeMaterialBlockTargets.Vertex:\n          state.sharedData.checks.emitVertex = true;\n          break;\n        case NodeMaterialBlockTargets.Fragment:\n          state.sharedData.checks.emitFragment = true;\n          break;\n      }\n    }\n    if (!this.isInput && state.sharedData.emitComments) {\n      state.compilationString += `\\n//${this.name}\\n`;\n    }\n    this._buildBlock(state);\n    this._buildId = state.sharedData.buildId;\n    this._buildTarget = state.target;\n    // Compile connected blocks\n    for (const output of this._outputs) {\n      if ((output.target & state.target) === 0) {\n        continue;\n      }\n      for (const endpoint of output.endpoints) {\n        const block = endpoint.ownerBlock;\n        if (block && (block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1) {\n          this._processBuild(block, state, endpoint, activeBlocks);\n        }\n      }\n    }\n    return false;\n  }\n  _inputRename(name) {\n    return name;\n  }\n  _outputRename(name) {\n    return name;\n  }\n  _dumpPropertiesCode() {\n    const variableName = this._codeVariableName;\n    return `${variableName}.visibleInInspector = ${this.visibleInInspector};\\n${variableName}.visibleOnFrame = ${this.visibleOnFrame};\\n${variableName}.target = ${this.target};\\n`;\n  }\n  /**\n   * @internal\n   */\n  _dumpCode(uniqueNames, alreadyDumped) {\n    alreadyDumped.push(this);\n    // Get unique name\n    const nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, \"\");\n    this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;\n    if (uniqueNames.indexOf(this._codeVariableName) !== -1) {\n      let index = 0;\n      do {\n        index++;\n        this._codeVariableName = nameAsVariableName + index;\n      } while (uniqueNames.indexOf(this._codeVariableName) !== -1);\n    }\n    uniqueNames.push(this._codeVariableName);\n    // Declaration\n    let codeString = `\\n// ${this.getClassName()}\\n`;\n    if (this.comments) {\n      codeString += `// ${this.comments}\\n`;\n    }\n    codeString += `var ${this._codeVariableName} = new BABYLON.${this.getClassName()}(\"${this.name}\");\\n`;\n    // Properties\n    codeString += this._dumpPropertiesCode();\n    // Inputs\n    for (const input of this.inputs) {\n      if (!input.isConnected) {\n        continue;\n      }\n      const connectedOutput = input.connectedPoint;\n      const connectedBlock = connectedOutput.ownerBlock;\n      if (alreadyDumped.indexOf(connectedBlock) === -1) {\n        codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\n      }\n    }\n    // Outputs\n    for (const output of this.outputs) {\n      if (!output.hasEndpoints) {\n        continue;\n      }\n      for (const endpoint of output.endpoints) {\n        const connectedBlock = endpoint.ownerBlock;\n        if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {\n          codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\n        }\n      }\n    }\n    return codeString;\n  }\n  /**\n   * @internal\n   */\n  _dumpCodeForOutputConnections(alreadyDumped) {\n    let codeString = \"\";\n    if (alreadyDumped.indexOf(this) !== -1) {\n      return codeString;\n    }\n    alreadyDumped.push(this);\n    for (const input of this.inputs) {\n      if (!input.isConnected) {\n        continue;\n      }\n      const connectedOutput = input.connectedPoint;\n      const connectedBlock = connectedOutput.ownerBlock;\n      codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);\n      codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(input.name)});\\n`;\n    }\n    return codeString;\n  }\n  /**\n   * Clone the current block to a new identical block\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a copy of the current block\n   */\n  clone(scene, rootUrl = \"\") {\n    const serializationObject = this.serialize();\n    const blockType = GetClass(serializationObject.customType);\n    if (blockType) {\n      const block = new blockType();\n      block._deserialize(serializationObject, scene, rootUrl);\n      return block;\n    }\n    return null;\n  }\n  /**\n   * Serializes this block in a JSON representation\n   * @returns the serialized block object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.customType = \"BABYLON.\" + this.getClassName();\n    serializationObject.id = this.uniqueId;\n    serializationObject.name = this.name;\n    serializationObject.comments = this.comments;\n    serializationObject.visibleInInspector = this.visibleInInspector;\n    serializationObject.visibleOnFrame = this.visibleOnFrame;\n    serializationObject.target = this.target;\n    serializationObject.inputs = [];\n    serializationObject.outputs = [];\n    for (const input of this.inputs) {\n      serializationObject.inputs.push(input.serialize());\n    }\n    for (const output of this.outputs) {\n      serializationObject.outputs.push(output.serialize(false));\n    }\n    return serializationObject;\n  }\n  /**\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _deserialize(serializationObject, scene, rootUrl) {\n    var _a;\n    this.name = serializationObject.name;\n    this.comments = serializationObject.comments;\n    this.visibleInInspector = !!serializationObject.visibleInInspector;\n    this.visibleOnFrame = !!serializationObject.visibleOnFrame;\n    this._target = (_a = serializationObject.target) !== null && _a !== void 0 ? _a : this.target;\n    this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);\n  }\n  _deserializePortDisplayNamesAndExposedOnFrame(serializationObject) {\n    const serializedInputs = serializationObject.inputs;\n    const serializedOutputs = serializationObject.outputs;\n    if (serializedInputs) {\n      serializedInputs.forEach((port, i) => {\n        if (port.displayName) {\n          this.inputs[i].displayName = port.displayName;\n        }\n        if (port.isExposedOnFrame) {\n          this.inputs[i].isExposedOnFrame = port.isExposedOnFrame;\n          this.inputs[i].exposedPortPosition = port.exposedPortPosition;\n        }\n      });\n    }\n    if (serializedOutputs) {\n      serializedOutputs.forEach((port, i) => {\n        if (port.displayName) {\n          this.outputs[i].displayName = port.displayName;\n        }\n        if (port.isExposedOnFrame) {\n          this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;\n          this.outputs[i].exposedPortPosition = port.exposedPortPosition;\n        }\n      });\n    }\n  }\n  /**\n   * Release resources\n   */\n  dispose() {\n    for (const input of this.inputs) {\n      input.dispose();\n    }\n    for (const output of this.outputs) {\n      output.dispose();\n    }\n  }\n}","map":{"version":3,"names":["NodeMaterialBlockConnectionPointTypes","NodeMaterialConnectionPoint","NodeMaterialConnectionPointDirection","NodeMaterialBlockTargets","UniqueIdGenerator","GetClass","NodeMaterialBlock","name","_name","newName","validateBlockName","isUnique","_isUnique","isFinalMerger","_isFinalMerger","isInput","_isInput","isTeleportOut","_isTeleportOut","isTeleportIn","_isTeleportIn","buildId","_buildId","value","target","_target","inputs","_inputs","outputs","_outputs","getInputByName","filter","e","length","getOutputByName","constructor","Vertex","inputsAreExclusive","_codeVariableName","Array","comments","visibleInInspector","visibleOnFrame","_originalTargetIsNeutral","Neutral","getClassName","uniqueId","UniqueId","_setInitialTarget","initialize","state","bind","effect","nodeMaterial","mesh","subMesh","_declareOutput","output","_getGLType","type","associatedVariableName","_writeVariable","currentPoint","connectionPoint","connectedPoint","_writeFloat","stringVersion","toString","indexOf","isConnectedInFragmentShader","some","o","registerInput","isOptional","point","Input","push","registerOutput","Output","getFirstAvailableInput","forOutput","input","AutoDetect","getFirstAvailableOutput","forBlock","getSiblingOutput","current","index","isAnAncestorOf","block","hasEndpoints","endpoint","endpoints","ownerBlock","connectTo","other","options","notFound","canConnectTo","_buildBlock","updateUniformsAndSamples","defines","uniformBuffers","provideFallbacks","fallbacks","initializeDefines","useInstances","prepareDefines","autoConfigure","material","additionalFilteringInfo","replaceRepeatableContent","vertexShaderState","fragmentShaderState","willBeGeneratedIntoVertexShaderFromFragmentShader","isDirectlyConnectedToVertexOutput","VertexAndFragment","isConnectedInVertexShader","isReady","_linkConnectionTypes","inputIndex0","inputIndex1","looseCoupling","_acceptedConnectionPointType","_linkedConnectionSource","_processBuild","activeBlocks","build","localBlockIsFragment","_vertexState","otherBlockWasGeneratedInVertexShader","_buildTarget","isAttribute","_noContextSwitch","_emitVaryingFromString","compilationString","_enforceAssociatedVariableName","reservedNames","reservedName","_customBuildStep","sharedData","_getFreeVariableName","checks","notConnectedNonOptionalInputs","verbose","console","log","emitVertex","Fragment","emitFragment","emitComments","_inputRename","_outputRename","_dumpPropertiesCode","variableName","_dumpCode","uniqueNames","alreadyDumped","nameAsVariableName","replace","codeString","isConnected","connectedOutput","connectedBlock","_dumpCodeForOutputConnections","clone","scene","rootUrl","serializationObject","serialize","blockType","customType","_deserialize","id","_a","_deserializePortDisplayNamesAndExposedOnFrame","serializedInputs","serializedOutputs","forEach","port","i","displayName","isExposedOnFrame","exposedPortPosition","dispose"],"sources":["../../../../../dev/core/src/Materials/Node/nodeMaterialBlock.ts"],"sourcesContent":["import { NodeMaterialBlockConnectionPointTypes } from \"./Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"./nodeMaterialBuildState\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { NodeMaterialConnectionPoint, NodeMaterialConnectionPointDirection } from \"./nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets\";\r\nimport type { Effect } from \"../effect\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"./nodeMaterial\";\r\nimport type { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport { UniqueIdGenerator } from \"../../Misc/uniqueIdGenerator\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { GetClass } from \"../../Misc/typeStore\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\n\r\n/**\r\n * Defines a block that can be used inside a node based material\r\n */\r\nexport class NodeMaterialBlock {\r\n    private _buildId: number;\r\n    private _buildTarget: NodeMaterialBlockTargets;\r\n    protected _target: NodeMaterialBlockTargets;\r\n    private _isFinalMerger = false;\r\n    private _isInput = false;\r\n    private _isTeleportOut = false;\r\n    private _isTeleportIn = false;\r\n    private _name = \"\";\r\n    protected _isUnique = false;\r\n\r\n    /** Gets or sets a boolean indicating that only one input can be connected at a time */\r\n    public inputsAreExclusive = false;\r\n\r\n    /** @internal */\r\n    public _codeVariableName = \"\";\r\n\r\n    /** @internal */\r\n    public _inputs = new Array<NodeMaterialConnectionPoint>();\r\n    /** @internal */\r\n    public _outputs = new Array<NodeMaterialConnectionPoint>();\r\n\r\n    /** @internal */\r\n    public _preparationId: number;\r\n\r\n    /** @internal */\r\n    public readonly _originalTargetIsNeutral: boolean;\r\n\r\n    /**\r\n     * Gets the name of the block\r\n     */\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    /**\r\n     * Sets the name of the block. Will check if the name is valid.\r\n     */\r\n    public set name(newName: string) {\r\n        if (!this.validateBlockName(newName)) {\r\n            return;\r\n        }\r\n\r\n        this._name = newName;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the unique id of the node\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Gets or sets the comments associated with this block\r\n     */\r\n    public comments: string = \"\";\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block can only be used once per NodeMaterial\r\n     */\r\n    public get isUnique() {\r\n        return this._isUnique;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block is an end block (e.g. it is generating a system value)\r\n     */\r\n    public get isFinalMerger(): boolean {\r\n        return this._isFinalMerger;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block is an input (e.g. it sends data to the shader)\r\n     */\r\n    public get isInput(): boolean {\r\n        return this._isInput;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this block is a teleport out\r\n     */\r\n    public get isTeleportOut(): boolean {\r\n        return this._isTeleportOut;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this block is a teleport in\r\n     */\r\n    public get isTeleportIn(): boolean {\r\n        return this._isTeleportIn;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the build Id\r\n     */\r\n    public get buildId(): number {\r\n        return this._buildId;\r\n    }\r\n\r\n    public set buildId(value: number) {\r\n        this._buildId = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the target of the block\r\n     */\r\n    public get target() {\r\n        return this._target;\r\n    }\r\n\r\n    public set target(value: NodeMaterialBlockTargets) {\r\n        if ((this._target & value) !== 0) {\r\n            return;\r\n        }\r\n        this._target = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of input points\r\n     */\r\n    public get inputs(): NodeMaterialConnectionPoint[] {\r\n        return this._inputs;\r\n    }\r\n\r\n    /** Gets the list of output points */\r\n    public get outputs(): NodeMaterialConnectionPoint[] {\r\n        return this._outputs;\r\n    }\r\n\r\n    /**\r\n     * Find an input by its name\r\n     * @param name defines the name of the input to look for\r\n     * @returns the input or null if not found\r\n     */\r\n    public getInputByName(name: string) {\r\n        const filter = this._inputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Find an output by its name\r\n     * @param name defines the name of the output to look for\r\n     * @returns the output or null if not found\r\n     */\r\n    public getOutputByName(name: string) {\r\n        const filter = this._outputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating that this input can be edited in the Inspector (false by default) */\r\n    public visibleInInspector = false;\r\n\r\n    /** Gets or sets a boolean indicating that this input can be edited from a collapsed frame */\r\n    public visibleOnFrame = false;\r\n\r\n    /**\r\n     * Creates a new NodeMaterialBlock\r\n     * @param name defines the block name\r\n     * @param target defines the target of that block (Vertex by default)\r\n     * @param isFinalMerger defines a boolean indicating that this block is an end block (e.g. it is generating a system value). Default is false\r\n     */\r\n    public constructor(name: string, target = NodeMaterialBlockTargets.Vertex, isFinalMerger = false) {\r\n        this._target = target;\r\n        this._originalTargetIsNeutral = target === NodeMaterialBlockTargets.Neutral;\r\n        this._isFinalMerger = isFinalMerger;\r\n        this._isInput = this.getClassName() === \"InputBlock\";\r\n        this._isTeleportOut = this.getClassName() === \"NodeMaterialTeleportOutBlock\";\r\n        this._isTeleportIn = this.getClassName() === \"NodeMaterialTeleportInBlock\";\r\n        this._name = name;\r\n        this.uniqueId = UniqueIdGenerator.UniqueId;\r\n    }\r\n\r\n    /** @internal */\r\n    public _setInitialTarget(target: NodeMaterialBlockTargets): void {\r\n        this._target = target;\r\n        (this._originalTargetIsNeutral as boolean) = target === NodeMaterialBlockTargets.Neutral;\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Bind data to effect. Will only be called for blocks with isBindable === true\r\n     * @param effect defines the effect to bind data to\r\n     * @param nodeMaterial defines the hosting NodeMaterial\r\n     * @param mesh defines the mesh that will be rendered\r\n     * @param subMesh defines the submesh that will be rendered\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh, subMesh?: SubMesh) {\r\n        // Do nothing\r\n    }\r\n\r\n    protected _declareOutput(output: NodeMaterialConnectionPoint, state: NodeMaterialBuildState): string {\r\n        return `${state._getGLType(output.type)} ${output.associatedVariableName}`;\r\n    }\r\n\r\n    protected _writeVariable(currentPoint: NodeMaterialConnectionPoint): string {\r\n        const connectionPoint = currentPoint.connectedPoint;\r\n\r\n        if (connectionPoint) {\r\n            return `${currentPoint.associatedVariableName}`;\r\n        }\r\n\r\n        return `0.`;\r\n    }\r\n\r\n    protected _writeFloat(value: number) {\r\n        let stringVersion = value.toString();\r\n\r\n        if (stringVersion.indexOf(\".\") === -1) {\r\n            stringVersion += \".0\";\r\n        }\r\n        return `${stringVersion}`;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name e.g. \"NodeMaterialBlock\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"NodeMaterialBlock\";\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection will be used in the fragment shader */\r\n    public isConnectedInFragmentShader() {\r\n        return this.outputs.some((o) => o.isConnectedInFragmentShader);\r\n    }\r\n\r\n    /**\r\n     * Register a new input. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param isOptional defines a boolean indicating that this input can be omitted\r\n     * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\r\n     * @param point an already created connection point. If not provided, create a new one\r\n     * @returns the current block\r\n     */\r\n    public registerInput(\r\n        name: string,\r\n        type: NodeMaterialBlockConnectionPointTypes,\r\n        isOptional: boolean = false,\r\n        target?: NodeMaterialBlockTargets,\r\n        point?: NodeMaterialConnectionPoint\r\n    ) {\r\n        point = point ?? new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Input);\r\n        point.type = type;\r\n        point.isOptional = isOptional;\r\n        if (target) {\r\n            point.target = target;\r\n        }\r\n\r\n        this._inputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Register a new output. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\r\n     * @param point an already created connection point. If not provided, create a new one\r\n     * @returns the current block\r\n     */\r\n    public registerOutput(name: string, type: NodeMaterialBlockConnectionPointTypes, target?: NodeMaterialBlockTargets, point?: NodeMaterialConnectionPoint) {\r\n        point = point ?? new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Output);\r\n        point.type = type;\r\n        if (target) {\r\n            point.target = target;\r\n        }\r\n\r\n        this._outputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Will return the first available input e.g. the first one which is not an uniform or an attribute\r\n     * @param forOutput defines an optional connection point to check compatibility with\r\n     * @returns the first available input or null\r\n     */\r\n    public getFirstAvailableInput(forOutput: Nullable<NodeMaterialConnectionPoint> = null) {\r\n        for (const input of this._inputs) {\r\n            if (!input.connectedPoint) {\r\n                if (!forOutput || forOutput.type === input.type || input.type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n                    return input;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Will return the first available output e.g. the first one which is not yet connected and not a varying\r\n     * @param forBlock defines an optional block to check compatibility with\r\n     * @returns the first available input or null\r\n     */\r\n    public getFirstAvailableOutput(forBlock: Nullable<NodeMaterialBlock> = null) {\r\n        for (const output of this._outputs) {\r\n            if (!forBlock || !forBlock.target || forBlock.target === NodeMaterialBlockTargets.Neutral || (forBlock.target & output.target) !== 0) {\r\n                return output;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the sibling of the given output\r\n     * @param current defines the current output\r\n     * @returns the next output in the list or null\r\n     */\r\n    public getSiblingOutput(current: NodeMaterialConnectionPoint) {\r\n        const index = this._outputs.indexOf(current);\r\n\r\n        if (index === -1 || index >= this._outputs.length) {\r\n            return null;\r\n        }\r\n\r\n        return this._outputs[index + 1];\r\n    }\r\n\r\n    /**\r\n     * Checks if the current block is an ancestor of a given block\r\n     * @param block defines the potential descendant block to check\r\n     * @returns true if block is a descendant\r\n     */\r\n    public isAnAncestorOf(block: NodeMaterialBlock): boolean {\r\n        for (const output of this._outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                if (endpoint.ownerBlock === block) {\r\n                    return true;\r\n                }\r\n                if (endpoint.ownerBlock.isAnAncestorOf(block)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Connect current block with another block\r\n     * @param other defines the block to connect with\r\n     * @param options define the various options to help pick the right connections\r\n     * @param options.input\r\n     * @param options.output\r\n     * @param options.outputSwizzle\r\n     * @returns the current block\r\n     */\r\n    public connectTo(\r\n        other: NodeMaterialBlock,\r\n        options?: {\r\n            input?: string;\r\n            output?: string;\r\n            outputSwizzle?: string;\r\n        }\r\n    ) {\r\n        if (this._outputs.length === 0) {\r\n            return;\r\n        }\r\n\r\n        let output = options && options.output ? this.getOutputByName(options.output) : this.getFirstAvailableOutput(other);\r\n\r\n        let notFound = true;\r\n        while (notFound) {\r\n            const input = options && options.input ? other.getInputByName(options.input) : other.getFirstAvailableInput(output);\r\n\r\n            if (output && input && output.canConnectTo(input)) {\r\n                output.connectTo(input);\r\n                notFound = false;\r\n            } else if (!output) {\r\n                throw \"Unable to find a compatible match\";\r\n            } else {\r\n                output = this.getSiblingOutput(output);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        // Empty. Must be defined by child nodes\r\n    }\r\n\r\n    /**\r\n     * Add uniforms, samplers and uniform buffers at compilation time\r\n     * @param state defines the state to update\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param uniformBuffers defines the list of uniform buffer names\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public updateUniformsAndSamples(state: NodeMaterialBuildState, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, uniformBuffers: string[]) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Add potential fallbacks if shader compilation fails\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param fallbacks defines the current prioritized list of fallbacks\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public provideFallbacks(mesh: AbstractMesh, fallbacks: EffectFallbacks) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Initialize defines for shader compilation\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param useInstances specifies that instances should be used\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public initializeDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances: boolean = false) {}\r\n\r\n    /**\r\n     * Update defines for shader compilation\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param useInstances specifies that instances should be used\r\n     * @param subMesh defines which submesh to render\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances: boolean = false, subMesh?: SubMesh) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Lets the block try to connect some inputs automatically\r\n     * @param material defines the hosting NodeMaterial\r\n     * @param additionalFilteringInfo optional additional filtering condition when looking for compatible blocks\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Function called when a block is declared as repeatable content generator\r\n     * @param vertexShaderState defines the current compilation state for the vertex shader\r\n     * @param fragmentShaderState defines the current compilation state for the fragment shader\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param defines defines the material defines to update\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public replaceRepeatableContent(vertexShaderState: NodeMaterialBuildState, fragmentShaderState: NodeMaterialBuildState, mesh: AbstractMesh, defines: NodeMaterialDefines) {\r\n        // Do nothing\r\n    }\r\n\r\n    /** Gets a boolean indicating that the code of this block will be promoted to vertex shader even if connected to fragment output */\r\n    public get willBeGeneratedIntoVertexShaderFromFragmentShader(): boolean {\r\n        if (this.isInput || this.isFinalMerger) {\r\n            return false;\r\n        }\r\n\r\n        if (this._outputs.some((o) => o.isDirectlyConnectedToVertexOutput)) {\r\n            return false;\r\n        }\r\n\r\n        if (this.target === NodeMaterialBlockTargets.Vertex) {\r\n            return false;\r\n        }\r\n\r\n        if (this.target === NodeMaterialBlockTargets.VertexAndFragment || this.target === NodeMaterialBlockTargets.Neutral) {\r\n            if (this._outputs.some((o) => o.isConnectedInVertexShader)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the block is ready\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns true if the block is ready\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isReady(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances: boolean = false) {\r\n        return true;\r\n    }\r\n\r\n    protected _linkConnectionTypes(inputIndex0: number, inputIndex1: number, looseCoupling = false) {\r\n        if (looseCoupling) {\r\n            this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];\r\n        } else {\r\n            this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];\r\n        }\r\n        this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];\r\n    }\r\n\r\n    private _processBuild(block: NodeMaterialBlock, state: NodeMaterialBuildState, input: NodeMaterialConnectionPoint, activeBlocks: NodeMaterialBlock[]) {\r\n        block.build(state, activeBlocks);\r\n\r\n        const localBlockIsFragment = state._vertexState != null;\r\n        const otherBlockWasGeneratedInVertexShader = block._buildTarget === NodeMaterialBlockTargets.Vertex && block.target !== NodeMaterialBlockTargets.VertexAndFragment;\r\n\r\n        if (\r\n            localBlockIsFragment &&\r\n            ((block.target & block._buildTarget) === 0 ||\r\n                (block.target & input.target) === 0 ||\r\n                (this.target !== NodeMaterialBlockTargets.VertexAndFragment && otherBlockWasGeneratedInVertexShader))\r\n        ) {\r\n            // context switch! We need a varying\r\n            if (\r\n                (!block.isInput && state.target !== block._buildTarget) || // block was already emitted by vertex shader\r\n                (block.isInput && (block as InputBlock).isAttribute && !(block as InputBlock)._noContextSwitch) // block is an attribute\r\n            ) {\r\n                const connectedPoint = input.connectedPoint!;\r\n                if (state._vertexState._emitVaryingFromString(\"v_\" + connectedPoint.associatedVariableName, state._getGLType(connectedPoint.type))) {\r\n                    state._vertexState.compilationString += `${\"v_\" + connectedPoint.associatedVariableName} = ${connectedPoint.associatedVariableName};\\n`;\r\n                }\r\n                input.associatedVariableName = \"v_\" + connectedPoint.associatedVariableName;\r\n                input._enforceAssociatedVariableName = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates the new name for the block node.\r\n     * @param newName the new name to be given to the node.\r\n     * @returns false if the name is a reserve word, else true.\r\n     */\r\n    public validateBlockName(newName: string) {\r\n        const reservedNames: Array<string> = [\r\n            \"position\",\r\n            \"normal\",\r\n            \"tangent\",\r\n            \"particle_positionw\",\r\n            \"uv\",\r\n            \"uv2\",\r\n            \"uv3\",\r\n            \"uv4\",\r\n            \"uv5\",\r\n            \"uv6\",\r\n            \"position2d\",\r\n            \"particle_uv\",\r\n            \"matricesIndices\",\r\n            \"matricesWeights\",\r\n            \"world0\",\r\n            \"world1\",\r\n            \"world2\",\r\n            \"world3\",\r\n            \"particle_color\",\r\n            \"particle_texturemask\",\r\n        ];\r\n        for (const reservedName of reservedNames) {\r\n            if (newName === reservedName) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _customBuildStep(state: NodeMaterialBuildState, activeBlocks: NodeMaterialBlock[]): void {\r\n        // Must be implemented by children\r\n    }\r\n\r\n    /**\r\n     * Compile the current node and generate the shader code\r\n     * @param state defines the current compilation state (uniforms, samplers, current string)\r\n     * @param activeBlocks defines the list of active blocks (i.e. blocks to compile)\r\n     * @returns true if already built\r\n     */\r\n    public build(state: NodeMaterialBuildState, activeBlocks: NodeMaterialBlock[]): boolean {\r\n        if (this._buildId === state.sharedData.buildId) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.isInput) {\r\n            /** Prepare outputs */\r\n            for (const output of this._outputs) {\r\n                if (!output.associatedVariableName) {\r\n                    output.associatedVariableName = state._getFreeVariableName(output.name);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Check if \"parent\" blocks are compiled\r\n        for (const input of this._inputs) {\r\n            if (!input.connectedPoint) {\r\n                if (!input.isOptional) {\r\n                    // Emit a warning\r\n                    state.sharedData.checks.notConnectedNonOptionalInputs.push(input);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            if (this.target !== NodeMaterialBlockTargets.Neutral) {\r\n                if ((input.target & this.target!) === 0) {\r\n                    continue;\r\n                }\r\n\r\n                if ((input.target & state.target!) === 0) {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            const block = input.connectedPoint.ownerBlock;\r\n            if (block && block !== this) {\r\n                this._processBuild(block, state, input, activeBlocks);\r\n            }\r\n        }\r\n\r\n        this._customBuildStep(state, activeBlocks);\r\n\r\n        if (this._buildId === state.sharedData.buildId) {\r\n            return true; // Need to check again as inputs can be connected multiple time to this endpoint\r\n        }\r\n\r\n        // Logs\r\n        if (state.sharedData.verbose) {\r\n            console.log(`${state.target === NodeMaterialBlockTargets.Vertex ? \"Vertex shader\" : \"Fragment shader\"}: Building ${this.name} [${this.getClassName()}]`);\r\n        }\r\n\r\n        // Checks final outputs\r\n        if (this.isFinalMerger) {\r\n            switch (state.target) {\r\n                case NodeMaterialBlockTargets.Vertex:\r\n                    state.sharedData.checks.emitVertex = true;\r\n                    break;\r\n                case NodeMaterialBlockTargets.Fragment:\r\n                    state.sharedData.checks.emitFragment = true;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        if (!this.isInput && state.sharedData.emitComments) {\r\n            state.compilationString += `\\n//${this.name}\\n`;\r\n        }\r\n\r\n        this._buildBlock(state);\r\n\r\n        this._buildId = state.sharedData.buildId;\r\n        this._buildTarget = state.target;\r\n\r\n        // Compile connected blocks\r\n        for (const output of this._outputs) {\r\n            if ((output.target & state.target) === 0) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                const block = endpoint.ownerBlock;\r\n\r\n                if (block && (block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1) {\r\n                    this._processBuild(block, state, endpoint, activeBlocks);\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    protected _inputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    protected _outputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const variableName = this._codeVariableName;\r\n        return `${variableName}.visibleInInspector = ${this.visibleInInspector};\\n${variableName}.visibleOnFrame = ${this.visibleOnFrame};\\n${variableName}.target = ${this.target};\\n`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _dumpCode(uniqueNames: string[], alreadyDumped: NodeMaterialBlock[]) {\r\n        alreadyDumped.push(this);\r\n\r\n        // Get unique name\r\n        const nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, \"\");\r\n        this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;\r\n\r\n        if (uniqueNames.indexOf(this._codeVariableName) !== -1) {\r\n            let index = 0;\r\n            do {\r\n                index++;\r\n                this._codeVariableName = nameAsVariableName + index;\r\n            } while (uniqueNames.indexOf(this._codeVariableName) !== -1);\r\n        }\r\n\r\n        uniqueNames.push(this._codeVariableName);\r\n\r\n        // Declaration\r\n        let codeString = `\\n// ${this.getClassName()}\\n`;\r\n        if (this.comments) {\r\n            codeString += `// ${this.comments}\\n`;\r\n        }\r\n        codeString += `var ${this._codeVariableName} = new BABYLON.${this.getClassName()}(\"${this.name}\");\\n`;\r\n\r\n        // Properties\r\n        codeString += this._dumpPropertiesCode();\r\n\r\n        // Inputs\r\n        for (const input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            const connectedOutput = input.connectedPoint!;\r\n            const connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            if (alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Outputs\r\n        for (const output of this.outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                const connectedBlock = endpoint.ownerBlock;\r\n                if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                    codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n                }\r\n            }\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _dumpCodeForOutputConnections(alreadyDumped: NodeMaterialBlock[]) {\r\n        let codeString = \"\";\r\n\r\n        if (alreadyDumped.indexOf(this) !== -1) {\r\n            return codeString;\r\n        }\r\n\r\n        alreadyDumped.push(this);\r\n\r\n        for (const input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            const connectedOutput = input.connectedPoint!;\r\n            const connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);\r\n            codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(\r\n                input.name\r\n            )});\\n`;\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Clone the current block to a new identical block\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a copy of the current block\r\n     */\r\n    public clone(scene: Scene, rootUrl: string = \"\") {\r\n        const serializationObject = this.serialize();\r\n\r\n        const blockType = GetClass(serializationObject.customType);\r\n        if (blockType) {\r\n            const block: NodeMaterialBlock = new blockType();\r\n            block._deserialize(serializationObject, scene, rootUrl);\r\n\r\n            return block;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.customType = \"BABYLON.\" + this.getClassName();\r\n        serializationObject.id = this.uniqueId;\r\n        serializationObject.name = this.name;\r\n        serializationObject.comments = this.comments;\r\n        serializationObject.visibleInInspector = this.visibleInInspector;\r\n        serializationObject.visibleOnFrame = this.visibleOnFrame;\r\n        serializationObject.target = this.target;\r\n\r\n        serializationObject.inputs = [];\r\n        serializationObject.outputs = [];\r\n\r\n        for (const input of this.inputs) {\r\n            serializationObject.inputs.push(input.serialize());\r\n        }\r\n\r\n        for (const output of this.outputs) {\r\n            serializationObject.outputs.push(output.serialize(false));\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        this.name = serializationObject.name;\r\n        this.comments = serializationObject.comments;\r\n        this.visibleInInspector = !!serializationObject.visibleInInspector;\r\n        this.visibleOnFrame = !!serializationObject.visibleOnFrame;\r\n        this._target = serializationObject.target ?? this.target;\r\n        this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);\r\n    }\r\n\r\n    private _deserializePortDisplayNamesAndExposedOnFrame(serializationObject: any) {\r\n        const serializedInputs = serializationObject.inputs;\r\n        const serializedOutputs = serializationObject.outputs;\r\n        if (serializedInputs) {\r\n            serializedInputs.forEach((port: any, i: number) => {\r\n                if (port.displayName) {\r\n                    this.inputs[i].displayName = port.displayName;\r\n                }\r\n                if (port.isExposedOnFrame) {\r\n                    this.inputs[i].isExposedOnFrame = port.isExposedOnFrame;\r\n                    this.inputs[i].exposedPortPosition = port.exposedPortPosition;\r\n                }\r\n            });\r\n        }\r\n        if (serializedOutputs) {\r\n            serializedOutputs.forEach((port: any, i: number) => {\r\n                if (port.displayName) {\r\n                    this.outputs[i].displayName = port.displayName;\r\n                }\r\n                if (port.isExposedOnFrame) {\r\n                    this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;\r\n                    this.outputs[i].exposedPortPosition = port.exposedPortPosition;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        for (const input of this.inputs) {\r\n            input.dispose();\r\n        }\r\n\r\n        for (const output of this.outputs) {\r\n            output.dispose();\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}