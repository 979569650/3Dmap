{"ast":null,"code":"import { Texture } from \"./texture.js\";\nimport \"../../Engines/Extensions/engine.rawTexture.js\";\n/**\n * Class used to store 2D array textures containing user data\n */\nexport class RawTexture2DArray extends Texture {\n  /**\n   * Gets the number of layers of the texture\n   */\n  get depth() {\n    return this._depth;\n  }\n  /**\n   * Create a new RawTexture2DArray\n   * @param data defines the data of the texture\n   * @param width defines the width of the texture\n   * @param height defines the height of the texture\n   * @param depth defines the number of layers of the texture\n   * @param format defines the texture format to use\n   * @param scene defines the hosting scene\n   * @param generateMipMaps defines a boolean indicating if mip levels should be generated (true by default)\n   * @param invertY defines if texture must be stored with Y axis inverted\n   * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)\n   * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\n   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n   */\n  constructor(data, width, height, depth, /** Gets or sets the texture format to use */\n  format, scene, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, textureType = 0, creationFlags) {\n    super(null, scene, !generateMipMaps, invertY);\n    this.format = format;\n    this._texture = scene.getEngine().createRawTexture2DArray(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, null, textureType, creationFlags);\n    this._depth = depth;\n    this.is2DArray = true;\n  }\n  /**\n   * Update the texture with new data\n   * @param data defines the data to store in the texture\n   */\n  update(data) {\n    if (!this._texture) {\n      return;\n    }\n    this._getEngine().updateRawTexture2DArray(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type);\n  }\n  /**\n   * Creates a RGBA texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param depth defines the number of layers of the texture\n   * @param scene defines the scene the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n   * @returns the RGBA texture\n   */\n  static CreateRGBATexture(data, width, height, depth, scene, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0) {\n    return new RawTexture2DArray(data, width, height, depth, 5, scene, generateMipMaps, invertY, samplingMode, type);\n  }\n}","map":{"version":3,"names":["Texture","RawTexture2DArray","depth","_depth","constructor","data","width","height","format","scene","generateMipMaps","invertY","samplingMode","TRILINEAR_SAMPLINGMODE","textureType","creationFlags","_texture","getEngine","createRawTexture2DArray","is2DArray","update","_getEngine","updateRawTexture2DArray","type","CreateRGBATexture"],"sources":["../../../../../dev/core/src/Materials/Textures/rawTexture2DArray.ts"],"sourcesContent":["import { Texture } from \"./texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\nimport type { Scene } from \"../../scene\";\r\n\r\n/**\r\n * Class used to store 2D array textures containing user data\r\n */\r\nexport class RawTexture2DArray extends Texture {\r\n    private _depth: number;\r\n\r\n    /**\r\n     * Gets the number of layers of the texture\r\n     */\r\n    public get depth() {\r\n        return this._depth;\r\n    }\r\n\r\n    /**\r\n     * Create a new RawTexture2DArray\r\n     * @param data defines the data of the texture\r\n     * @param width defines the width of the texture\r\n     * @param height defines the height of the texture\r\n     * @param depth defines the number of layers of the texture\r\n     * @param format defines the texture format to use\r\n     * @param scene defines the hosting scene\r\n     * @param generateMipMaps defines a boolean indicating if mip levels should be generated (true by default)\r\n     * @param invertY defines if texture must be stored with Y axis inverted\r\n     * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)\r\n     * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     */\r\n    constructor(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        /** Gets or sets the texture format to use */\r\n        public format: number,\r\n        scene: Scene,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        creationFlags?: number\r\n    ) {\r\n        super(null, scene, !generateMipMaps, invertY);\r\n\r\n        this._texture = scene.getEngine().createRawTexture2DArray(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, null, textureType, creationFlags);\r\n\r\n        this._depth = depth;\r\n        this.is2DArray = true;\r\n    }\r\n\r\n    /**\r\n     * Update the texture with new data\r\n     * @param data defines the data to store in the texture\r\n     */\r\n    public update(data: ArrayBufferView): void {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n        this._getEngine()!.updateRawTexture2DArray(this._texture, data, this._texture.format, this._texture!.invertY, null, this._texture.type);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param depth defines the number of layers of the texture\r\n     * @param scene defines the scene the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBATexture(\r\n        data: ArrayBufferView,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        scene: Scene,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ): RawTexture2DArray {\r\n        return new RawTexture2DArray(data, width, height, depth, Constants.TEXTUREFORMAT_RGBA, scene, generateMipMaps, invertY, samplingMode, type);\r\n    }\r\n}\r\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,cAAY;AAEpC,OAAO,+CAA6C;AAKpD;;;AAGA,OAAM,MAAOC,iBAAkB,SAAQD,OAAO;EAG1C;;;EAGA,IAAWE,KAAKA,CAAA;IACZ,OAAO,IAAI,CAACC,MAAM;EACtB;EAEA;;;;;;;;;;;;;;EAcAC,YACIC,IAA+B,EAC/BC,KAAa,EACbC,MAAc,EACdL,KAAa,EACb;EACOM,MAAc,EACrBC,KAAY,EACZC,eAAA,GAA2B,IAAI,EAC/BC,OAAA,GAAmB,KAAK,EACxBC,YAAA,GAAuBZ,OAAO,CAACa,sBAAsB,EACrDC,WAAW,GAAG,GAAAC,aAAU;IAGxB,KAAK,CAAC,IAAI,EAAEN,KAAK,EAAE,CAACC,eAAe,EAAEC,OAAO,CAAC;IARtC,KAAAH,MAAM,GAANA,MAAM;IAUb,IAAI,CAACQ,QAAQ,GAAGP,KAAK,CAACQ,SAAS,EAAE,CAACC,uBAAuB,CAACb,IAAI,EAAEC,KAAK,EAAEC,MAAM,EAAEL,KAAK,EAAEM,MAAM,EAAEE,eAAe,EAAEC,OAAO,EAAEC,YAAY,EAAE,IAAI,EAAEE,WAAW,EAAEC,aAAa,CAAC;IAEvK,IAAI,CAACZ,MAAM,GAAGD,KAAK;IACnB,IAAI,CAACiB,SAAS,GAAG,IAAI;EACzB;EAEA;;;;EAIOC,MAAMA,CAACf,IAAqB;IAC/B,IAAI,CAAC,IAAI,CAACW,QAAQ,EAAE;MAChB;;IAEJ,IAAI,CAACK,UAAU,EAAG,CAACC,uBAAuB,CAAC,IAAI,CAACN,QAAQ,EAAEX,IAAI,EAAE,IAAI,CAACW,QAAQ,CAACR,MAAM,EAAE,IAAI,CAACQ,QAAS,CAACL,OAAO,EAAE,IAAI,EAAE,IAAI,CAACK,QAAQ,CAACO,IAAI,CAAC;EAC3I;EAEA;;;;;;;;;;;;;EAaO,OAAOC,iBAAiBA,CAC3BnB,IAAqB,EACrBC,KAAa,EACbC,MAAc,EACdL,KAAa,EACbO,KAAY,EACZC,eAAA,GAA2B,IAAI,EAC/BC,OAAA,GAAmB,KAAK,EACxBC,YAAA,GAAuB,GAAAW,IAAA,GAAU;IAGjC,OAAO,IAAItB,iBAAiB,CAACI,IAAI,EAAEC,KAAK,EAAEC,MAAM,EAAEL,KAAK,EAAE,GAAAO,KAAA,EAAUC,eAAA,EAAAC,OAAoB,EAAKC,YAAE,EAAAW,IAAiB;EACnH"},"metadata":{},"sourceType":"module","externalDependencies":[]}