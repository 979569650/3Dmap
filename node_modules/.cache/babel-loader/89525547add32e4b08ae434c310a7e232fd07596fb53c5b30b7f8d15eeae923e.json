{"ast":null,"code":"import { Scene } from \"../scene.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { PrePassRenderer } from \"./prePassRenderer.js\";\nimport { Logger } from \"../Misc/logger.js\";\nObject.defineProperty(Scene.prototype, \"prePassRenderer\", {\n  get: function () {\n    return this._prePassRenderer;\n  },\n  set: function (value) {\n    if (value && value.isSupported) {\n      this._prePassRenderer = value;\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\nScene.prototype.enablePrePassRenderer = function () {\n  if (this._prePassRenderer) {\n    return this._prePassRenderer;\n  }\n  this._prePassRenderer = new PrePassRenderer(this);\n  if (!this._prePassRenderer.isSupported) {\n    this._prePassRenderer = null;\n    Logger.Error(\"PrePassRenderer needs WebGL 2 support.\\n\" + \"Maybe you tried to use the following features that need the PrePassRenderer :\\n\" + \" + Subsurface Scattering\");\n  }\n  return this._prePassRenderer;\n};\nScene.prototype.disablePrePassRenderer = function () {\n  if (!this._prePassRenderer) {\n    return;\n  }\n  this._prePassRenderer.dispose();\n  this._prePassRenderer = null;\n};\n/**\n * Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful\n * in several rendering techniques.\n */\nexport class PrePassRendererSceneComponent {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  constructor(scene) {\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_PREPASSRENDERER;\n    this.scene = scene;\n  }\n  /**\n   * Registers the component in a given scene\n   */\n  register() {\n    this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_PREPASS, this, this._beforeCameraDraw);\n    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS, this, this._afterCameraDraw);\n    this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_PREPASS, this, this._beforeRenderTargetDraw);\n    this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS, this, this._afterRenderTargetDraw);\n    this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PREPASS, this, this._beforeClearStage);\n    this.scene._beforeRenderTargetClearStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETCLEAR_PREPASS, this, this._beforeRenderTargetClearStage);\n    this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_PREPASS, this, this._beforeRenderingMeshStage);\n    this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_PREPASS, this, this._afterRenderingMeshStage);\n  }\n  _beforeRenderTargetDraw(renderTarget, faceIndex, layer) {\n    if (this.scene.prePassRenderer && !renderTarget.noPrePassRenderer) {\n      this.scene.prePassRenderer._setRenderTarget(renderTarget._prePassRenderTarget);\n      this.scene.prePassRenderer._beforeDraw(undefined, faceIndex, layer);\n    }\n  }\n  _afterRenderTargetDraw(renderTarget, faceIndex, layer) {\n    if (this.scene.prePassRenderer && !renderTarget.noPrePassRenderer) {\n      this.scene.prePassRenderer._afterDraw(faceIndex, layer);\n    }\n  }\n  _beforeRenderTargetClearStage(renderTarget) {\n    if (this.scene.prePassRenderer && !renderTarget.noPrePassRenderer) {\n      if (!renderTarget._prePassRenderTarget) {\n        renderTarget._prePassRenderTarget = this.scene.prePassRenderer._createRenderTarget(renderTarget.name + \"_prePassRTT\", renderTarget);\n      }\n      this.scene.prePassRenderer._setRenderTarget(renderTarget._prePassRenderTarget);\n      this.scene.prePassRenderer._clear();\n    }\n  }\n  _beforeCameraDraw(camera) {\n    if (this.scene.prePassRenderer) {\n      this.scene.prePassRenderer._setRenderTarget(null);\n      this.scene.prePassRenderer._beforeDraw(camera);\n    }\n  }\n  _afterCameraDraw() {\n    if (this.scene.prePassRenderer) {\n      this.scene.prePassRenderer._afterDraw();\n    }\n  }\n  _beforeClearStage() {\n    if (this.scene.prePassRenderer) {\n      this.scene.prePassRenderer._setRenderTarget(null);\n      this.scene.prePassRenderer._clear();\n    }\n  }\n  _beforeRenderingMeshStage(mesh, subMesh, batch, effect) {\n    if (!effect) {\n      return;\n    }\n    // Render to MRT\n    const scene = mesh.getScene();\n    if (scene.prePassRenderer) {\n      scene.prePassRenderer.bindAttachmentsForEffect(effect, subMesh);\n    }\n  }\n  _afterRenderingMeshStage(mesh) {\n    const scene = mesh.getScene();\n    if (scene.prePassRenderer) {\n      scene.prePassRenderer.restoreAttachments();\n    }\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  rebuild() {\n    // Release textures first\n    this.scene.disablePrePassRenderer();\n    // Re-enable\n    this.scene.enablePrePassRenderer();\n  }\n  /**\n   * Disposes the component and the associated resources\n   */\n  dispose() {\n    this.scene.disablePrePassRenderer();\n  }\n}\nPrePassRenderer._SceneComponentInitialization = scene => {\n  // Register the G Buffer component to the scene.\n  let component = scene._getComponent(SceneComponentConstants.NAME_PREPASSRENDERER);\n  if (!component) {\n    component = new PrePassRendererSceneComponent(scene);\n    scene._addComponent(component);\n  }\n};","map":{"version":3,"names":["Scene","SceneComponentConstants","PrePassRenderer","Logger","Object","defineProperty","prototype","get","_prePassRenderer","set","value","isSupported","enumerable","configurable","enablePrePassRenderer","Error","disablePrePassRenderer","dispose","PrePassRendererSceneComponent","constructor","scene","name","NAME_PREPASSRENDERER","register","_beforeCameraDrawStage","registerStep","STEP_BEFORECAMERADRAW_PREPASS","_beforeCameraDraw","_afterCameraDrawStage","STEP_AFTERCAMERADRAW_PREPASS","_afterCameraDraw","_beforeRenderTargetDrawStage","STEP_BEFORERENDERTARGETDRAW_PREPASS","_beforeRenderTargetDraw","_afterRenderTargetDrawStage","_afterRenderTargetDraw","_beforeClearStage","STEP_BEFORECLEAR_PREPASS","_beforeRenderTargetClearStage","STEP_BEFORERENDERTARGETCLEAR_PREPASS","_beforeRenderingMeshStage","STEP_BEFORERENDERINGMESH_PREPASS","_afterRenderingMeshStage","STEP_AFTERRENDERINGMESH_PREPASS","renderTarget","faceIndex","layer","prePassRenderer","noPrePassRenderer","_setRenderTarget","_prePassRenderTarget","_beforeDraw","undefined","_afterDraw","_createRenderTarget","_clear","camera","mesh","subMesh","batch","effect","getScene","bindAttachmentsForEffect","restoreAttachments","rebuild","_SceneComponentInitialization","component","_getComponent","_addComponent"],"sources":["../../../../dev/core/src/Rendering/prePassRendererSceneComponent.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { PrePassRenderer } from \"./prePassRenderer\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { _InstancesBatch } from \"../Meshes/mesh\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { PrePassRenderTarget } from \"../Materials/Textures/prePassRenderTarget\";\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /** @internal (Backing field) */\r\n        _prePassRenderer: Nullable<PrePassRenderer>;\r\n\r\n        /**\r\n         * Gets or Sets the current prepass renderer associated to the scene.\r\n         */\r\n        prePassRenderer: Nullable<PrePassRenderer>;\r\n\r\n        /**\r\n         * Enables the prepass and associates it with the scene\r\n         * @returns the PrePassRenderer\r\n         */\r\n        enablePrePassRenderer(): Nullable<PrePassRenderer>;\r\n\r\n        /**\r\n         * Disables the prepass associated with the scene\r\n         */\r\n        disablePrePassRenderer(): void;\r\n    }\r\n}\r\n\r\ndeclare module \"../Materials/Textures/renderTargetTexture\" {\r\n    export interface RenderTargetTexture {\r\n        /**\r\n         * Gets or sets a boolean indicating that the prepass renderer should not be used with this render target\r\n         */\r\n        noPrePassRenderer: boolean;\r\n        /** @internal */\r\n        _prePassRenderTarget: Nullable<PrePassRenderTarget>;\r\n    }\r\n}\r\n\r\nObject.defineProperty(Scene.prototype, \"prePassRenderer\", {\r\n    get: function (this: Scene) {\r\n        return this._prePassRenderer;\r\n    },\r\n    set: function (this: Scene, value: Nullable<PrePassRenderer>) {\r\n        if (value && value.isSupported) {\r\n            this._prePassRenderer = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nScene.prototype.enablePrePassRenderer = function (): Nullable<PrePassRenderer> {\r\n    if (this._prePassRenderer) {\r\n        return this._prePassRenderer;\r\n    }\r\n\r\n    this._prePassRenderer = new PrePassRenderer(this);\r\n\r\n    if (!this._prePassRenderer.isSupported) {\r\n        this._prePassRenderer = null;\r\n        Logger.Error(\"PrePassRenderer needs WebGL 2 support.\\n\" + \"Maybe you tried to use the following features that need the PrePassRenderer :\\n\" + \" + Subsurface Scattering\");\r\n    }\r\n\r\n    return this._prePassRenderer;\r\n};\r\n\r\nScene.prototype.disablePrePassRenderer = function (): void {\r\n    if (!this._prePassRenderer) {\r\n        return;\r\n    }\r\n\r\n    this._prePassRenderer.dispose();\r\n    this._prePassRenderer = null;\r\n};\r\n\r\n/**\r\n * Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful\r\n * in several rendering techniques.\r\n */\r\nexport class PrePassRendererSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_PREPASSRENDERER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_PREPASS, this, this._beforeCameraDraw);\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS, this, this._afterCameraDraw);\r\n        this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_PREPASS, this, this._beforeRenderTargetDraw);\r\n        this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS, this, this._afterRenderTargetDraw);\r\n\r\n        this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PREPASS, this, this._beforeClearStage);\r\n        this.scene._beforeRenderTargetClearStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETCLEAR_PREPASS, this, this._beforeRenderTargetClearStage);\r\n\r\n        this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_PREPASS, this, this._beforeRenderingMeshStage);\r\n        this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_PREPASS, this, this._afterRenderingMeshStage);\r\n    }\r\n\r\n    private _beforeRenderTargetDraw(renderTarget: RenderTargetTexture, faceIndex?: number, layer?: number) {\r\n        if (this.scene.prePassRenderer && !renderTarget.noPrePassRenderer) {\r\n            this.scene.prePassRenderer._setRenderTarget(renderTarget._prePassRenderTarget);\r\n            this.scene.prePassRenderer._beforeDraw(undefined, faceIndex, layer);\r\n        }\r\n    }\r\n\r\n    private _afterRenderTargetDraw(renderTarget: RenderTargetTexture, faceIndex?: number, layer?: number) {\r\n        if (this.scene.prePassRenderer && !renderTarget.noPrePassRenderer) {\r\n            this.scene.prePassRenderer._afterDraw(faceIndex, layer);\r\n        }\r\n    }\r\n\r\n    private _beforeRenderTargetClearStage(renderTarget: RenderTargetTexture) {\r\n        if (this.scene.prePassRenderer && !renderTarget.noPrePassRenderer) {\r\n            if (!renderTarget._prePassRenderTarget) {\r\n                renderTarget._prePassRenderTarget = this.scene.prePassRenderer._createRenderTarget(renderTarget.name + \"_prePassRTT\", renderTarget);\r\n            }\r\n            this.scene.prePassRenderer._setRenderTarget(renderTarget._prePassRenderTarget);\r\n            this.scene.prePassRenderer._clear();\r\n        }\r\n    }\r\n\r\n    private _beforeCameraDraw(camera: Camera) {\r\n        if (this.scene.prePassRenderer) {\r\n            this.scene.prePassRenderer._setRenderTarget(null);\r\n            this.scene.prePassRenderer._beforeDraw(camera);\r\n        }\r\n    }\r\n\r\n    private _afterCameraDraw() {\r\n        if (this.scene.prePassRenderer) {\r\n            this.scene.prePassRenderer._afterDraw();\r\n        }\r\n    }\r\n\r\n    private _beforeClearStage() {\r\n        if (this.scene.prePassRenderer) {\r\n            this.scene.prePassRenderer._setRenderTarget(null);\r\n            this.scene.prePassRenderer._clear();\r\n        }\r\n    }\r\n\r\n    private _beforeRenderingMeshStage(mesh: AbstractMesh, subMesh: SubMesh, batch: _InstancesBatch, effect: Nullable<Effect>) {\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        // Render to MRT\r\n        const scene = mesh.getScene();\r\n        if (scene.prePassRenderer) {\r\n            scene.prePassRenderer.bindAttachmentsForEffect(effect, subMesh);\r\n        }\r\n    }\r\n\r\n    private _afterRenderingMeshStage(mesh: AbstractMesh) {\r\n        const scene = mesh.getScene();\r\n\r\n        if (scene.prePassRenderer) {\r\n            scene.prePassRenderer.restoreAttachments();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Release textures first\r\n        this.scene.disablePrePassRenderer();\r\n\r\n        // Re-enable\r\n        this.scene.enablePrePassRenderer();\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources\r\n     */\r\n    public dispose(): void {\r\n        this.scene.disablePrePassRenderer();\r\n    }\r\n}\r\n\r\nPrePassRenderer._SceneComponentInitialization = (scene: Scene) => {\r\n    // Register the G Buffer component to the scene.\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_PREPASSRENDERER) as PrePassRendererSceneComponent;\r\n    if (!component) {\r\n        component = new PrePassRendererSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n};\r\n"],"mappings":"AACA,SAASA,KAAK,QAAQ,aAAW;AAEjC,SAASC,uBAAuB,QAAQ,sBAAoB;AAC5D,SAASC,eAAe,QAAQ,sBAAoB;AACpD,SAASC,MAAM,QAAQ,mBAAiB;AA2CxCC,MAAM,CAACC,cAAc,CAACL,KAAK,CAACM,SAAS,EAAE,iBAAiB,EAAE;EACtDC,GAAG,EAAE,SAAAA,CAAA;IACD,OAAO,IAAI,CAACC,gBAAgB;EAChC,CAAC;EACDC,GAAG,EAAE,SAAAA,CAAuBC,KAAgC;IACxD,IAAIA,KAAK,IAAIA,KAAK,CAACC,WAAW,EAAE;MAC5B,IAAI,CAACH,gBAAgB,GAAGE,KAAK;;EAErC,CAAC;EACDE,UAAU,EAAE,IAAI;EAChBC,YAAY,EAAE;CACjB,CAAC;AAEFb,KAAK,CAACM,SAAS,CAACQ,qBAAqB,GAAG;EACpC,IAAI,IAAI,CAACN,gBAAgB,EAAE;IACvB,OAAO,IAAI,CAACA,gBAAgB;;EAGhC,IAAI,CAACA,gBAAgB,GAAG,IAAIN,eAAe,CAAC,IAAI,CAAC;EAEjD,IAAI,CAAC,IAAI,CAACM,gBAAgB,CAACG,WAAW,EAAE;IACpC,IAAI,CAACH,gBAAgB,GAAG,IAAI;IAC5BL,MAAM,CAACY,KAAK,CAAC,0CAA0C,GAAG,iFAAiF,GAAG,0BAA0B,CAAC;;EAG7K,OAAO,IAAI,CAACP,gBAAgB;AAChC,CAAC;AAEDR,KAAK,CAACM,SAAS,CAACU,sBAAsB,GAAG;EACrC,IAAI,CAAC,IAAI,CAACR,gBAAgB,EAAE;IACxB;;EAGJ,IAAI,CAACA,gBAAgB,CAACS,OAAO,EAAE;EAC/B,IAAI,CAACT,gBAAgB,GAAG,IAAI;AAChC,CAAC;AAED;;;;AAIA,OAAM,MAAOU,6BAA6B;EAWtC;;;;EAIAC,YAAYC,KAAY;IAdxB;;;IAGgB,KAAAC,IAAI,GAAGpB,uBAAuB,CAACqB,oBAAoB;IAY/D,IAAI,CAACF,KAAK,GAAGA,KAAK;EACtB;EAEA;;;EAGOG,QAAQA,CAAA;IACX,IAAI,CAACH,KAAK,CAACI,sBAAsB,CAACC,YAAY,CAACxB,uBAAuB,CAACyB,6BAA6B,EAAE,IAAI,EAAE,IAAI,CAACC,iBAAiB,CAAC;IACnI,IAAI,CAACP,KAAK,CAACQ,qBAAqB,CAACH,YAAY,CAACxB,uBAAuB,CAAC4B,4BAA4B,EAAE,IAAI,EAAE,IAAI,CAACC,gBAAgB,CAAC;IAChI,IAAI,CAACV,KAAK,CAACW,4BAA4B,CAACN,YAAY,CAACxB,uBAAuB,CAAC+B,mCAAmC,EAAE,IAAI,EAAE,IAAI,CAACC,uBAAuB,CAAC;IACrJ,IAAI,CAACb,KAAK,CAACc,2BAA2B,CAACT,YAAY,CAACxB,uBAAuB,CAAC4B,4BAA4B,EAAE,IAAI,EAAE,IAAI,CAACM,sBAAsB,CAAC;IAE5I,IAAI,CAACf,KAAK,CAACgB,iBAAiB,CAACX,YAAY,CAACxB,uBAAuB,CAACoC,wBAAwB,EAAE,IAAI,EAAE,IAAI,CAACD,iBAAiB,CAAC;IACzH,IAAI,CAAChB,KAAK,CAACkB,6BAA6B,CAACb,YAAY,CAACxB,uBAAuB,CAACsC,oCAAoC,EAAE,IAAI,EAAE,IAAI,CAACD,6BAA6B,CAAC;IAE7J,IAAI,CAAClB,KAAK,CAACoB,yBAAyB,CAACf,YAAY,CAACxB,uBAAuB,CAACwC,gCAAgC,EAAE,IAAI,EAAE,IAAI,CAACD,yBAAyB,CAAC;IACjJ,IAAI,CAACpB,KAAK,CAACsB,wBAAwB,CAACjB,YAAY,CAACxB,uBAAuB,CAAC0C,+BAA+B,EAAE,IAAI,EAAE,IAAI,CAACD,wBAAwB,CAAC;EAClJ;EAEQT,uBAAuBA,CAACW,YAAiC,EAAEC,SAAkB,EAAEC,KAAc;IACjG,IAAI,IAAI,CAAC1B,KAAK,CAAC2B,eAAe,IAAI,CAACH,YAAY,CAACI,iBAAiB,EAAE;MAC/D,IAAI,CAAC5B,KAAK,CAAC2B,eAAe,CAACE,gBAAgB,CAACL,YAAY,CAACM,oBAAoB,CAAC;MAC9E,IAAI,CAAC9B,KAAK,CAAC2B,eAAe,CAACI,WAAW,CAACC,SAAS,EAAEP,SAAS,EAAEC,KAAK,CAAC;;EAE3E;EAEQX,sBAAsBA,CAACS,YAAiC,EAAEC,SAAkB,EAAEC,KAAc;IAChG,IAAI,IAAI,CAAC1B,KAAK,CAAC2B,eAAe,IAAI,CAACH,YAAY,CAACI,iBAAiB,EAAE;MAC/D,IAAI,CAAC5B,KAAK,CAAC2B,eAAe,CAACM,UAAU,CAACR,SAAS,EAAEC,KAAK,CAAC;;EAE/D;EAEQR,6BAA6BA,CAACM,YAAiC;IACnE,IAAI,IAAI,CAACxB,KAAK,CAAC2B,eAAe,IAAI,CAACH,YAAY,CAACI,iBAAiB,EAAE;MAC/D,IAAI,CAACJ,YAAY,CAACM,oBAAoB,EAAE;QACpCN,YAAY,CAACM,oBAAoB,GAAG,IAAI,CAAC9B,KAAK,CAAC2B,eAAe,CAACO,mBAAmB,CAACV,YAAY,CAACvB,IAAI,GAAG,aAAa,EAAEuB,YAAY,CAAC;;MAEvI,IAAI,CAACxB,KAAK,CAAC2B,eAAe,CAACE,gBAAgB,CAACL,YAAY,CAACM,oBAAoB,CAAC;MAC9E,IAAI,CAAC9B,KAAK,CAAC2B,eAAe,CAACQ,MAAM,EAAE;;EAE3C;EAEQ5B,iBAAiBA,CAAC6B,MAAc;IACpC,IAAI,IAAI,CAACpC,KAAK,CAAC2B,eAAe,EAAE;MAC5B,IAAI,CAAC3B,KAAK,CAAC2B,eAAe,CAACE,gBAAgB,CAAC,IAAI,CAAC;MACjD,IAAI,CAAC7B,KAAK,CAAC2B,eAAe,CAACI,WAAW,CAACK,MAAM,CAAC;;EAEtD;EAEQ1B,gBAAgBA,CAAA;IACpB,IAAI,IAAI,CAACV,KAAK,CAAC2B,eAAe,EAAE;MAC5B,IAAI,CAAC3B,KAAK,CAAC2B,eAAe,CAACM,UAAU,EAAE;;EAE/C;EAEQjB,iBAAiBA,CAAA;IACrB,IAAI,IAAI,CAAChB,KAAK,CAAC2B,eAAe,EAAE;MAC5B,IAAI,CAAC3B,KAAK,CAAC2B,eAAe,CAACE,gBAAgB,CAAC,IAAI,CAAC;MACjD,IAAI,CAAC7B,KAAK,CAAC2B,eAAe,CAACQ,MAAM,EAAE;;EAE3C;EAEQf,yBAAyBA,CAACiB,IAAkB,EAAEC,OAAgB,EAAEC,KAAsB,EAAEC,MAAwB;IACpH,IAAI,CAACA,MAAM,EAAE;MACT;;IAGJ;IACA,MAAMxC,KAAK,GAAGqC,IAAI,CAACI,QAAQ,EAAE;IAC7B,IAAIzC,KAAK,CAAC2B,eAAe,EAAE;MACvB3B,KAAK,CAAC2B,eAAe,CAACe,wBAAwB,CAACF,MAAM,EAAEF,OAAO,CAAC;;EAEvE;EAEQhB,wBAAwBA,CAACe,IAAkB;IAC/C,MAAMrC,KAAK,GAAGqC,IAAI,CAACI,QAAQ,EAAE;IAE7B,IAAIzC,KAAK,CAAC2B,eAAe,EAAE;MACvB3B,KAAK,CAAC2B,eAAe,CAACgB,kBAAkB,EAAE;;EAElD;EAEA;;;;EAIOC,OAAOA,CAAA;IACV;IACA,IAAI,CAAC5C,KAAK,CAACJ,sBAAsB,EAAE;IAEnC;IACA,IAAI,CAACI,KAAK,CAACN,qBAAqB,EAAE;EACtC;EAEA;;;EAGOG,OAAOA,CAAA;IACV,IAAI,CAACG,KAAK,CAACJ,sBAAsB,EAAE;EACvC;;AAGJd,eAAe,CAAC+D,6BAA6B,GAAI7C,KAAY,IAAI;EAC7D;EACA,IAAI8C,SAAS,GAAG9C,KAAK,CAAC+C,aAAa,CAAClE,uBAAuB,CAACqB,oBAAoB,CAAkC;EAClH,IAAI,CAAC4C,SAAS,EAAE;IACZA,SAAS,GAAG,IAAIhD,6BAA6B,CAACE,KAAK,CAAC;IACpDA,KAAK,CAACgD,aAAa,CAACF,SAAS,CAAC;;AAEtC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}