{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { CubeTexture } from \"../../../Textures/cubeTexture.js\";\nimport { Texture } from \"../../../Textures/texture.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\nimport { Scalar } from \"../../../../Maths/math.scalar.js\";\n/**\n * Block used to implement the refraction part of the sub surface module of the PBR material\n */\nexport class RefractionBlock extends NodeMaterialBlock {\n  /**\n   * Create a new RefractionBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Fragment);\n    /**\n     * This parameters will make the material used its opacity to control how much it is refracting against not.\n     * Materials half opaque for instance using refraction could benefit from this control.\n     */\n    this.linkRefractionWithTransparency = false;\n    /**\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\n     */\n    this.invertRefractionY = false;\n    /**\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\n     */\n    this.useThicknessAsDepth = false;\n    this._isUnique = true;\n    this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"tintAtDistance\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"volumeIndexOfRefraction\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"refraction\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"refraction\", this, NodeMaterialConnectionPointDirection.Output, RefractionBlock, \"RefractionBlock\"));\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  initialize(state) {\n    state._excludeVariableName(\"vRefractionPosition\");\n    state._excludeVariableName(\"vRefractionSize\");\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"RefractionBlock\";\n  }\n  /**\n   * Gets the intensity input component\n   */\n  get intensity() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the tint at distance input component\n   */\n  get tintAtDistance() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the volume index of refraction input component\n   */\n  get volumeIndexOfRefraction() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the view input component\n   */\n  get view() {\n    return this.viewConnectionPoint;\n  }\n  /**\n   * Gets the refraction object output component\n   */\n  get refraction() {\n    return this._outputs[0];\n  }\n  /**\n   * Returns true if the block has a texture\n   */\n  get hasTexture() {\n    return !!this._getTexture();\n  }\n  _getTexture() {\n    if (this.texture) {\n      return this.texture;\n    }\n    return this._scene.environmentTexture;\n  }\n  autoConfigure(material, additionalFilteringInfo = () => true) {\n    if (!this.intensity.isConnected) {\n      const intensityInput = new InputBlock(\"Refraction intensity\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\n      intensityInput.value = 1;\n      intensityInput.output.connectTo(this.intensity);\n    }\n    if (this.view && !this.view.isConnected) {\n      let viewInput = material.getInputBlockByPredicate(b => b.systemValue === NodeMaterialSystemValues.View && additionalFilteringInfo(b));\n      if (!viewInput) {\n        viewInput = new InputBlock(\"view\");\n        viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\n      }\n      viewInput.output.connectTo(this.view);\n    }\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    super.prepareDefines(mesh, nodeMaterial, defines);\n    const refractionTexture = this._getTexture();\n    const refraction = refractionTexture && refractionTexture.getTextureMatrix;\n    defines.setValue(\"SS_REFRACTION\", refraction, true);\n    if (!refraction) {\n      return;\n    }\n    defines.setValue(this._define3DName, refractionTexture.isCube, true);\n    defines.setValue(this._defineLODRefractionAlpha, refractionTexture.lodLevelInAlpha, true);\n    defines.setValue(this._defineLinearSpecularRefraction, refractionTexture.linearSpecularLOD, true);\n    defines.setValue(this._defineOppositeZ, this._scene.useRightHandedSystem && refractionTexture.isCube ? !refractionTexture.invertZ : refractionTexture.invertZ, true);\n    defines.setValue(\"SS_LINKREFRACTIONTOTRANSPARENCY\", this.linkRefractionWithTransparency, true);\n    defines.setValue(\"SS_GAMMAREFRACTION\", refractionTexture.gammaSpace, true);\n    defines.setValue(\"SS_RGBDREFRACTION\", refractionTexture.isRGBD, true);\n    defines.setValue(\"SS_USE_LOCAL_REFRACTIONMAP_CUBIC\", refractionTexture.boundingBoxSize ? true : false, true);\n    defines.setValue(\"SS_USE_THICKNESS_AS_DEPTH\", this.useThicknessAsDepth, true);\n  }\n  isReady() {\n    const texture = this._getTexture();\n    if (texture && !texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n    return true;\n  }\n  bind(effect, nodeMaterial, mesh) {\n    var _a, _b, _c, _d;\n    super.bind(effect, nodeMaterial, mesh);\n    const refractionTexture = this._getTexture();\n    if (!refractionTexture) {\n      return;\n    }\n    if (refractionTexture.isCube) {\n      effect.setTexture(this._cubeSamplerName, refractionTexture);\n    } else {\n      effect.setTexture(this._2DSamplerName, refractionTexture);\n    }\n    effect.setMatrix(this._refractionMatrixName, refractionTexture.getRefractionTextureMatrix());\n    let depth = 1.0;\n    if (!refractionTexture.isCube) {\n      if (refractionTexture.depth) {\n        depth = refractionTexture.depth;\n      }\n    }\n    const indexOfRefraction = (_d = (_b = (_a = this.volumeIndexOfRefraction.connectInputBlock) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : (_c = this.indexOfRefractionConnectionPoint.connectInputBlock) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : 1.5;\n    effect.setFloat4(this._vRefractionInfosName, refractionTexture.level, 1 / indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);\n    effect.setFloat4(this._vRefractionMicrosurfaceInfosName, refractionTexture.getSize().width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset, 1 / indexOfRefraction);\n    const width = refractionTexture.getSize().width;\n    effect.setFloat2(this._vRefractionFilteringInfoName, width, Scalar.Log2(width));\n    if (refractionTexture.boundingBoxSize) {\n      const cubeTexture = refractionTexture;\n      effect.setVector3(\"vRefractionPosition\", cubeTexture.boundingBoxPosition);\n      effect.setVector3(\"vRefractionSize\", cubeTexture.boundingBoxSize);\n    }\n  }\n  /**\n   * Gets the main code of the block (fragment side)\n   * @param state current state of the node material building\n   * @returns the shader code\n   */\n  getCode(state) {\n    const code = \"\";\n    state.sharedData.blockingBlocks.push(this);\n    state.sharedData.textureBlocks.push(this);\n    // Samplers\n    this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\n    state.samplers.push(this._cubeSamplerName);\n    this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\n    state.samplers.push(this._2DSamplerName);\n    this._define3DName = state._getFreeDefineName(\"SS_REFRACTIONMAP_3D\");\n    state._samplerDeclaration += `#ifdef ${this._define3DName}\\n`;\n    state._samplerDeclaration += `uniform samplerCube ${this._cubeSamplerName};\\n`;\n    state._samplerDeclaration += `#else\\n`;\n    state._samplerDeclaration += `uniform sampler2D ${this._2DSamplerName};\\n`;\n    state._samplerDeclaration += `#endif\\n`;\n    // Fragment\n    state.sharedData.blocksWithDefines.push(this);\n    state.sharedData.bindableBlocks.push(this);\n    this._defineLODRefractionAlpha = state._getFreeDefineName(\"SS_LODINREFRACTIONALPHA\");\n    this._defineLinearSpecularRefraction = state._getFreeDefineName(\"SS_LINEARSPECULARREFRACTION\");\n    this._defineOppositeZ = state._getFreeDefineName(\"SS_REFRACTIONMAP_OPPOSITEZ\");\n    this._refractionMatrixName = state._getFreeVariableName(\"refractionMatrix\");\n    state._emitUniformFromString(this._refractionMatrixName, \"mat4\");\n    state._emitFunction(\"sampleRefraction\", `\n            #ifdef ${this._define3DName}\n                #define sampleRefraction(s, c) textureCube(s, c)\n            #else\n                #define sampleRefraction(s, c) texture2D(s, c)\n            #endif\\n`, `//${this.name}`);\n    state._emitFunction(\"sampleRefractionLod\", `\n            #ifdef ${this._define3DName}\n                #define sampleRefractionLod(s, c, l) textureCubeLodEXT(s, c, l)\n            #else\n                #define sampleRefractionLod(s, c, l) texture2DLodEXT(s, c, l)\n            #endif\\n`, `//${this.name}`);\n    this._vRefractionMicrosurfaceInfosName = state._getFreeVariableName(\"vRefractionMicrosurfaceInfos\");\n    state._emitUniformFromString(this._vRefractionMicrosurfaceInfosName, \"vec4\");\n    this._vRefractionInfosName = state._getFreeVariableName(\"vRefractionInfos\");\n    state._emitUniformFromString(this._vRefractionInfosName, \"vec4\");\n    this._vRefractionFilteringInfoName = state._getFreeVariableName(\"vRefractionFilteringInfo\");\n    state._emitUniformFromString(this._vRefractionFilteringInfoName, \"vec2\");\n    state._emitUniformFromString(\"vRefractionPosition\", \"vec3\");\n    state._emitUniformFromString(\"vRefractionSize\", \"vec3\");\n    return code;\n  }\n  _buildBlock(state) {\n    this._scene = state.sharedData.scene;\n    return this;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode();\n    if (this.texture) {\n      if (this.texture.isCube) {\n        codeString = `${this._codeVariableName}.texture = new BABYLON.CubeTexture(\"${this.texture.name}\");\\n`;\n      } else {\n        codeString = `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\");\\n`;\n      }\n      codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\n`;\n    }\n    codeString += `${this._codeVariableName}.linkRefractionWithTransparency = ${this.linkRefractionWithTransparency};\\n`;\n    codeString += `${this._codeVariableName}.invertRefractionY = ${this.invertRefractionY};\\n`;\n    codeString += `${this._codeVariableName}.useThicknessAsDepth = ${this.useThicknessAsDepth};\\n`;\n    return codeString;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    if (this.texture && !this.texture.isRenderTarget) {\n      serializationObject.texture = this.texture.serialize();\n    }\n    serializationObject.linkRefractionWithTransparency = this.linkRefractionWithTransparency;\n    serializationObject.invertRefractionY = this.invertRefractionY;\n    serializationObject.useThicknessAsDepth = this.useThicknessAsDepth;\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    if (serializationObject.texture) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n      if (serializationObject.texture.isCube) {\n        this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\n      } else {\n        this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n      }\n    }\n    this.linkRefractionWithTransparency = serializationObject.linkRefractionWithTransparency;\n    this.invertRefractionY = serializationObject.invertRefractionY;\n    this.useThicknessAsDepth = !!serializationObject.useThicknessAsDepth;\n  }\n}\n__decorate([editableInPropertyPage(\"Link refraction to transparency\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    update: true\n  }\n})], RefractionBlock.prototype, \"linkRefractionWithTransparency\", void 0);\n__decorate([editableInPropertyPage(\"Invert refraction Y\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    update: true\n  }\n})], RefractionBlock.prototype, \"invertRefractionY\", void 0);\n__decorate([editableInPropertyPage(\"Use thickness as depth\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    update: true\n  }\n})], RefractionBlock.prototype, \"useThicknessAsDepth\", void 0);\nRegisterClass(\"BABYLON.RefractionBlock\", RefractionBlock);","map":{"version":3,"names":["NodeMaterialBlockConnectionPointTypes","NodeMaterialConnectionPointDirection","NodeMaterialBlockTargets","RegisterClass","InputBlock","NodeMaterialConnectionPointCustomObject","editableInPropertyPage","PropertyTypeForEdition","NodeMaterialBlock","CubeTexture","Texture","NodeMaterialSystemValues","Scalar","RefractionBlock","constructor","name","Fragment","linkRefractionWithTransparency","invertRefractionY","useThicknessAsDepth","_isUnique","registerInput","Float","registerOutput","Object","Output","initialize","state","_excludeVariableName","getClassName","intensity","_inputs","tintAtDistance","volumeIndexOfRefraction","view","viewConnectionPoint","refraction","_outputs","hasTexture","_getTexture","texture","_scene","environmentTexture","autoConfigure","material","additionalFilteringInfo","isConnected","intensityInput","value","output","connectTo","viewInput","getInputBlockByPredicate","b","systemValue","View","setAsSystemValue","prepareDefines","mesh","nodeMaterial","defines","refractionTexture","getTextureMatrix","setValue","_define3DName","isCube","_defineLODRefractionAlpha","lodLevelInAlpha","_defineLinearSpecularRefraction","linearSpecularLOD","_defineOppositeZ","useRightHandedSystem","invertZ","gammaSpace","isRGBD","boundingBoxSize","isReady","isReadyOrNotBlocking","bind","effect","setTexture","_cubeSamplerName","_2DSamplerName","setMatrix","_refractionMatrixName","getRefractionTextureMatrix","depth","indexOfRefraction","_d","_b","_a","connectInputBlock","_c","indexOfRefractionConnectionPoint","setFloat4","_vRefractionInfosName","level","_vRefractionMicrosurfaceInfosName","getSize","width","lodGenerationScale","lodGenerationOffset","setFloat2","_vRefractionFilteringInfoName","Log2","cubeTexture","setVector3","boundingBoxPosition","getCode","code","sharedData","blockingBlocks","push","textureBlocks","_getFreeVariableName","samplers","_getFreeDefineName","_samplerDeclaration","blocksWithDefines","bindableBlocks","_emitUniformFromString","_emitFunction","_buildBlock","scene","_dumpPropertiesCode","codeString","_codeVariableName","coordinatesMode","serialize","serializationObject","isRenderTarget","_deserialize","rootUrl","url","indexOf","Parse","__decorate","Boolean","notifiers","update"],"sources":["../../../../../../../dev/core/src/Materials/Node/Blocks/PBR/refractionBlock.ts"],"sourcesContent":["import { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { CubeTexture } from \"../../../Textures/cubeTexture\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport { Scalar } from \"../../../../Maths/math.scalar\";\r\n\r\n/**\r\n * Block used to implement the refraction part of the sub surface module of the PBR material\r\n */\r\nexport class RefractionBlock extends NodeMaterialBlock {\r\n    /** @internal */\r\n    public _define3DName: string;\r\n    /** @internal */\r\n    public _refractionMatrixName: string;\r\n    /** @internal */\r\n    public _defineLODRefractionAlpha: string;\r\n    /** @internal */\r\n    public _defineLinearSpecularRefraction: string;\r\n    /** @internal */\r\n    public _defineOppositeZ: string;\r\n    /** @internal */\r\n    public _cubeSamplerName: string;\r\n    /** @internal */\r\n    public _2DSamplerName: string;\r\n    /** @internal */\r\n    public _vRefractionMicrosurfaceInfosName: string;\r\n    /** @internal */\r\n    public _vRefractionInfosName: string;\r\n    /** @internal */\r\n    public _vRefractionFilteringInfoName: string;\r\n\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * The properties below are set by the main PBR block prior to calling methods of this class.\r\n     * This is to avoid having to add them as inputs here whereas they are already inputs of the main block, so already known.\r\n     * It's less burden on the user side in the editor part.\r\n     */\r\n\r\n    /** @internal */\r\n    public viewConnectionPoint: NodeMaterialConnectionPoint;\r\n\r\n    /** @internal */\r\n    public indexOfRefractionConnectionPoint: NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * This parameters will make the material used its opacity to control how much it is refracting against not.\r\n     * Materials half opaque for instance using refraction could benefit from this control.\r\n     */\r\n    @editableInPropertyPage(\"Link refraction to transparency\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { update: true } })\r\n    public linkRefractionWithTransparency: boolean = false;\r\n\r\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\r\n    @editableInPropertyPage(\"Invert refraction Y\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { update: true } })\r\n    public invertRefractionY: boolean = false;\r\n\r\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\r\n    @editableInPropertyPage(\"Use thickness as depth\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { update: true } })\r\n    public useThicknessAsDepth: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Create a new RefractionBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"tintAtDistance\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"volumeIndexOfRefraction\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\r\n            \"refraction\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"refraction\", this, NodeMaterialConnectionPointDirection.Output, RefractionBlock, \"RefractionBlock\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"vRefractionPosition\");\r\n        state._excludeVariableName(\"vRefractionSize\");\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"RefractionBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the intensity input component\r\n     */\r\n    public get intensity(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the tint at distance input component\r\n     */\r\n    public get tintAtDistance(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the volume index of refraction input component\r\n     */\r\n    public get volumeIndexOfRefraction(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the view input component\r\n     */\r\n    public get view(): NodeMaterialConnectionPoint {\r\n        return this.viewConnectionPoint;\r\n    }\r\n\r\n    /**\r\n     * Gets the refraction object output component\r\n     */\r\n    public get refraction(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Returns true if the block has a texture\r\n     */\r\n    public get hasTexture(): boolean {\r\n        return !!this._getTexture();\r\n    }\r\n\r\n    protected _getTexture(): Nullable<BaseTexture> {\r\n        if (this.texture) {\r\n            return this.texture;\r\n        }\r\n\r\n        return this._scene.environmentTexture;\r\n    }\r\n\r\n    public autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        if (!this.intensity.isConnected) {\r\n            const intensityInput = new InputBlock(\"Refraction intensity\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\r\n            intensityInput.value = 1;\r\n            intensityInput.output.connectTo(this.intensity);\r\n        }\r\n\r\n        if (this.view && !this.view.isConnected) {\r\n            let viewInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.View && additionalFilteringInfo(b));\r\n\r\n            if (!viewInput) {\r\n                viewInput = new InputBlock(\"view\");\r\n                viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\r\n            }\r\n            viewInput.output.connectTo(this.view);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        super.prepareDefines(mesh, nodeMaterial, defines);\r\n\r\n        const refractionTexture = this._getTexture();\r\n        const refraction = refractionTexture && refractionTexture.getTextureMatrix;\r\n\r\n        defines.setValue(\"SS_REFRACTION\", refraction, true);\r\n\r\n        if (!refraction) {\r\n            return;\r\n        }\r\n\r\n        defines.setValue(this._define3DName, refractionTexture!.isCube, true);\r\n        defines.setValue(this._defineLODRefractionAlpha, refractionTexture!.lodLevelInAlpha, true);\r\n        defines.setValue(this._defineLinearSpecularRefraction, refractionTexture!.linearSpecularLOD, true);\r\n        defines.setValue(this._defineOppositeZ, this._scene.useRightHandedSystem && refractionTexture.isCube ? !refractionTexture!.invertZ : refractionTexture!.invertZ, true);\r\n\r\n        defines.setValue(\"SS_LINKREFRACTIONTOTRANSPARENCY\", this.linkRefractionWithTransparency, true);\r\n        defines.setValue(\"SS_GAMMAREFRACTION\", refractionTexture!.gammaSpace, true);\r\n        defines.setValue(\"SS_RGBDREFRACTION\", refractionTexture!.isRGBD, true);\r\n        defines.setValue(\"SS_USE_LOCAL_REFRACTIONMAP_CUBIC\", (<any>refractionTexture).boundingBoxSize ? true : false, true);\r\n        defines.setValue(\"SS_USE_THICKNESS_AS_DEPTH\", this.useThicknessAsDepth, true);\r\n    }\r\n\r\n    public isReady() {\r\n        const texture = this._getTexture();\r\n\r\n        if (texture && !texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        super.bind(effect, nodeMaterial, mesh);\r\n\r\n        const refractionTexture = this._getTexture();\r\n\r\n        if (!refractionTexture) {\r\n            return;\r\n        }\r\n\r\n        if (refractionTexture.isCube) {\r\n            effect.setTexture(this._cubeSamplerName, refractionTexture);\r\n        } else {\r\n            effect.setTexture(this._2DSamplerName, refractionTexture);\r\n        }\r\n\r\n        effect.setMatrix(this._refractionMatrixName, refractionTexture.getRefractionTextureMatrix());\r\n\r\n        let depth = 1.0;\r\n        if (!refractionTexture.isCube) {\r\n            if ((<any>refractionTexture).depth) {\r\n                depth = (<any>refractionTexture).depth;\r\n            }\r\n        }\r\n\r\n        const indexOfRefraction = this.volumeIndexOfRefraction.connectInputBlock?.value ?? this.indexOfRefractionConnectionPoint.connectInputBlock?.value ?? 1.5;\r\n\r\n        effect.setFloat4(this._vRefractionInfosName, refractionTexture.level, 1 / indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);\r\n\r\n        effect.setFloat4(\r\n            this._vRefractionMicrosurfaceInfosName,\r\n            refractionTexture.getSize().width,\r\n            refractionTexture.lodGenerationScale,\r\n            refractionTexture.lodGenerationOffset,\r\n            1 / indexOfRefraction\r\n        );\r\n\r\n        const width = refractionTexture.getSize().width;\r\n\r\n        effect.setFloat2(this._vRefractionFilteringInfoName, width, Scalar.Log2(width));\r\n\r\n        if ((<any>refractionTexture).boundingBoxSize) {\r\n            const cubeTexture = <CubeTexture>refractionTexture;\r\n            effect.setVector3(\"vRefractionPosition\", cubeTexture.boundingBoxPosition);\r\n            effect.setVector3(\"vRefractionSize\", cubeTexture.boundingBoxSize);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the main code of the block (fragment side)\r\n     * @param state current state of the node material building\r\n     * @returns the shader code\r\n     */\r\n    public getCode(state: NodeMaterialBuildState): string {\r\n        const code = \"\";\r\n\r\n        state.sharedData.blockingBlocks.push(this);\r\n        state.sharedData.textureBlocks.push(this);\r\n\r\n        // Samplers\r\n        this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\r\n        state.samplers.push(this._cubeSamplerName);\r\n\r\n        this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\r\n        state.samplers.push(this._2DSamplerName);\r\n\r\n        this._define3DName = state._getFreeDefineName(\"SS_REFRACTIONMAP_3D\");\r\n\r\n        state._samplerDeclaration += `#ifdef ${this._define3DName}\\n`;\r\n        state._samplerDeclaration += `uniform samplerCube ${this._cubeSamplerName};\\n`;\r\n        state._samplerDeclaration += `#else\\n`;\r\n        state._samplerDeclaration += `uniform sampler2D ${this._2DSamplerName};\\n`;\r\n        state._samplerDeclaration += `#endif\\n`;\r\n\r\n        // Fragment\r\n        state.sharedData.blocksWithDefines.push(this);\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        this._defineLODRefractionAlpha = state._getFreeDefineName(\"SS_LODINREFRACTIONALPHA\");\r\n        this._defineLinearSpecularRefraction = state._getFreeDefineName(\"SS_LINEARSPECULARREFRACTION\");\r\n        this._defineOppositeZ = state._getFreeDefineName(\"SS_REFRACTIONMAP_OPPOSITEZ\");\r\n\r\n        this._refractionMatrixName = state._getFreeVariableName(\"refractionMatrix\");\r\n\r\n        state._emitUniformFromString(this._refractionMatrixName, \"mat4\");\r\n\r\n        state._emitFunction(\r\n            \"sampleRefraction\",\r\n            `\r\n            #ifdef ${this._define3DName}\r\n                #define sampleRefraction(s, c) textureCube(s, c)\r\n            #else\r\n                #define sampleRefraction(s, c) texture2D(s, c)\r\n            #endif\\n`,\r\n            `//${this.name}`\r\n        );\r\n\r\n        state._emitFunction(\r\n            \"sampleRefractionLod\",\r\n            `\r\n            #ifdef ${this._define3DName}\r\n                #define sampleRefractionLod(s, c, l) textureCubeLodEXT(s, c, l)\r\n            #else\r\n                #define sampleRefractionLod(s, c, l) texture2DLodEXT(s, c, l)\r\n            #endif\\n`,\r\n            `//${this.name}`\r\n        );\r\n\r\n        this._vRefractionMicrosurfaceInfosName = state._getFreeVariableName(\"vRefractionMicrosurfaceInfos\");\r\n\r\n        state._emitUniformFromString(this._vRefractionMicrosurfaceInfosName, \"vec4\");\r\n\r\n        this._vRefractionInfosName = state._getFreeVariableName(\"vRefractionInfos\");\r\n\r\n        state._emitUniformFromString(this._vRefractionInfosName, \"vec4\");\r\n\r\n        this._vRefractionFilteringInfoName = state._getFreeVariableName(\"vRefractionFilteringInfo\");\r\n\r\n        state._emitUniformFromString(this._vRefractionFilteringInfoName, \"vec2\");\r\n\r\n        state._emitUniformFromString(\"vRefractionPosition\", \"vec3\");\r\n        state._emitUniformFromString(\"vRefractionSize\", \"vec3\");\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        this._scene = state.sharedData.scene;\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        if (this.texture) {\r\n            if (this.texture.isCube) {\r\n                codeString = `${this._codeVariableName}.texture = new BABYLON.CubeTexture(\"${this.texture.name}\");\\n`;\r\n            } else {\r\n                codeString = `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\");\\n`;\r\n            }\r\n            codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\n`;\r\n        }\r\n\r\n        codeString += `${this._codeVariableName}.linkRefractionWithTransparency = ${this.linkRefractionWithTransparency};\\n`;\r\n        codeString += `${this._codeVariableName}.invertRefractionY = ${this.invertRefractionY};\\n`;\r\n        codeString += `${this._codeVariableName}.useThicknessAsDepth = ${this.useThicknessAsDepth};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        if (this.texture && !this.texture.isRenderTarget) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        serializationObject.linkRefractionWithTransparency = this.linkRefractionWithTransparency;\r\n        serializationObject.invertRefractionY = this.invertRefractionY;\r\n        serializationObject.useThicknessAsDepth = this.useThicknessAsDepth;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        if (serializationObject.texture) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            if (serializationObject.texture.isCube) {\r\n                this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\r\n            } else {\r\n                this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\r\n            }\r\n        }\r\n\r\n        this.linkRefractionWithTransparency = serializationObject.linkRefractionWithTransparency;\r\n        this.invertRefractionY = serializationObject.invertRefractionY;\r\n        this.useThicknessAsDepth = !!serializationObject.useThicknessAsDepth;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.RefractionBlock\", RefractionBlock);\r\n"],"mappings":";;AAAA,SAASA,qCAAqC,QAAQ,sDAAoD;AAG1G,SAASC,oCAAoC,QAAQ,2CAAyC;AAC9F,SAASC,wBAAwB,QAAQ,yCAAuC;AAEhF,SAASC,aAAa,QAAQ,+BAA6B;AAC3D,SAASC,UAAU,QAAQ,wBAAsB;AACjD,SAASC,uCAAuC,QAAQ,kDAAgD;AAMxG,SAASC,sBAAsB,EAAEC,sBAAsB,QAAQ,yCAAuC;AAEtG,SAASC,iBAAiB,QAAQ,4BAA0B;AAC5D,SAASC,WAAW,QAAQ,kCAAgC;AAC5D,SAASC,OAAO,QAAQ,8BAA4B;AACpD,SAASC,wBAAwB,QAAQ,yCAAuC;AAChF,SAASC,MAAM,QAAQ,kCAAgC;AAEvD;;;AAGA,OAAM,MAAOC,eAAgB,SAAQL,iBAAiB;EA4DlD;;;;EAIAM,YAAmBC,IAAY;IAC3B,KAAK,CAACA,IAAI,EAAEb,wBAAwB,CAACc,QAAQ,CAAC;IA7BlD;;;;IAKO,KAAAC,8BAA8B,GAAY,KAAK;IAEtD;;;IAIO,KAAAC,iBAAiB,GAAY,KAAK;IAEzC;;;IAIO,KAAAC,mBAAmB,GAAY,KAAK;IAcvC,IAAI,CAACC,SAAS,GAAG,IAAI;IAErB,IAAI,CAACC,aAAa,CAAC,WAAW,EAAErB,qCAAqC,CAACsB,KAAK,EAAE,KAAK,EAAEpB,wBAAwB,CAACc,QAAQ,CAAC;IACtH,IAAI,CAACK,aAAa,CAAC,gBAAgB,EAAErB,qCAAqC,CAACsB,KAAK,EAAE,IAAI,EAAEpB,wBAAwB,CAACc,QAAQ,CAAC;IAC1H,IAAI,CAACK,aAAa,CAAC,yBAAyB,EAAErB,qCAAqC,CAACsB,KAAK,EAAE,IAAI,EAAEpB,wBAAwB,CAACc,QAAQ,CAAC;IAEnI,IAAI,CAACO,cAAc,CACf,YAAY,EACZvB,qCAAqC,CAACwB,MAAM,EAC5CtB,wBAAwB,CAACc,QAAQ,EACjC,IAAIX,uCAAuC,CAAC,YAAY,EAAE,IAAI,EAAEJ,oCAAoC,CAACwB,MAAM,EAAEZ,eAAe,EAAE,iBAAiB,CAAC,CACnJ;EACL;EAEA;;;;EAIOa,UAAUA,CAACC,KAA6B;IAC3CA,KAAK,CAACC,oBAAoB,CAAC,qBAAqB,CAAC;IACjDD,KAAK,CAACC,oBAAoB,CAAC,iBAAiB,CAAC;EACjD;EAEA;;;;EAIOC,YAAYA,CAAA;IACf,OAAO,iBAAiB;EAC5B;EAEA;;;EAGA,IAAWC,SAASA,CAAA;IAChB,OAAO,IAAI,CAACC,OAAO,CAAC,CAAC,CAAC;EAC1B;EAEA;;;EAGA,IAAWC,cAAcA,CAAA;IACrB,OAAO,IAAI,CAACD,OAAO,CAAC,CAAC,CAAC;EAC1B;EAEA;;;EAGA,IAAWE,uBAAuBA,CAAA;IAC9B,OAAO,IAAI,CAACF,OAAO,CAAC,CAAC,CAAC;EAC1B;EAEA;;;EAGA,IAAWG,IAAIA,CAAA;IACX,OAAO,IAAI,CAACC,mBAAmB;EACnC;EAEA;;;EAGA,IAAWC,UAAUA,CAAA;IACjB,OAAO,IAAI,CAACC,QAAQ,CAAC,CAAC,CAAC;EAC3B;EAEA;;;EAGA,IAAWC,UAAUA,CAAA;IACjB,OAAO,CAAC,CAAC,IAAI,CAACC,WAAW,EAAE;EAC/B;EAEUA,WAAWA,CAAA;IACjB,IAAI,IAAI,CAACC,OAAO,EAAE;MACd,OAAO,IAAI,CAACA,OAAO;;IAGvB,OAAO,IAAI,CAACC,MAAM,CAACC,kBAAkB;EACzC;EAEOC,aAAaA,CAACC,QAAsB,EAAEC,uBAAA,GAAgEA,CAAA,KAAM,IAAI;IACnH,IAAI,CAAC,IAAI,CAACf,SAAS,CAACgB,WAAW,EAAE;MAC7B,MAAMC,cAAc,GAAG,IAAI3C,UAAU,CAAC,sBAAsB,EAAEF,wBAAwB,CAACc,QAAQ,EAAEhB,qCAAqC,CAACsB,KAAK,CAAC;MAC7IyB,cAAc,CAACC,KAAK,GAAG,CAAC;MACxBD,cAAc,CAACE,MAAM,CAACC,SAAS,CAAC,IAAI,CAACpB,SAAS,CAAC;;IAGnD,IAAI,IAAI,CAACI,IAAI,IAAI,CAAC,IAAI,CAACA,IAAI,CAACY,WAAW,EAAE;MACrC,IAAIK,SAAS,GAAGP,QAAQ,CAACQ,wBAAwB,CAAEC,CAAC,IAAKA,CAAC,CAACC,WAAW,KAAK3C,wBAAwB,CAAC4C,IAAI,IAAIV,uBAAuB,CAACQ,CAAC,CAAC,CAAC;MAEvI,IAAI,CAACF,SAAS,EAAE;QACZA,SAAS,GAAG,IAAI/C,UAAU,CAAC,MAAM,CAAC;QAClC+C,SAAS,CAACK,gBAAgB,CAAC7C,wBAAwB,CAAC4C,IAAI,CAAC;;MAE7DJ,SAAS,CAACF,MAAM,CAACC,SAAS,CAAC,IAAI,CAAChB,IAAI,CAAC;;EAE7C;EAEOuB,cAAcA,CAACC,IAAkB,EAAEC,YAA0B,EAAEC,OAA4B;IAC9F,KAAK,CAACH,cAAc,CAACC,IAAI,EAAEC,YAAY,EAAEC,OAAO,CAAC;IAEjD,MAAMC,iBAAiB,GAAG,IAAI,CAACtB,WAAW,EAAE;IAC5C,MAAMH,UAAU,GAAGyB,iBAAiB,IAAIA,iBAAiB,CAACC,gBAAgB;IAE1EF,OAAO,CAACG,QAAQ,CAAC,eAAe,EAAE3B,UAAU,EAAE,IAAI,CAAC;IAEnD,IAAI,CAACA,UAAU,EAAE;MACb;;IAGJwB,OAAO,CAACG,QAAQ,CAAC,IAAI,CAACC,aAAa,EAAEH,iBAAkB,CAACI,MAAM,EAAE,IAAI,CAAC;IACrEL,OAAO,CAACG,QAAQ,CAAC,IAAI,CAACG,yBAAyB,EAAEL,iBAAkB,CAACM,eAAe,EAAE,IAAI,CAAC;IAC1FP,OAAO,CAACG,QAAQ,CAAC,IAAI,CAACK,+BAA+B,EAAEP,iBAAkB,CAACQ,iBAAiB,EAAE,IAAI,CAAC;IAClGT,OAAO,CAACG,QAAQ,CAAC,IAAI,CAACO,gBAAgB,EAAE,IAAI,CAAC7B,MAAM,CAAC8B,oBAAoB,IAAIV,iBAAiB,CAACI,MAAM,GAAG,CAACJ,iBAAkB,CAACW,OAAO,GAAGX,iBAAkB,CAACW,OAAO,EAAE,IAAI,CAAC;IAEtKZ,OAAO,CAACG,QAAQ,CAAC,iCAAiC,EAAE,IAAI,CAAC9C,8BAA8B,EAAE,IAAI,CAAC;IAC9F2C,OAAO,CAACG,QAAQ,CAAC,oBAAoB,EAAEF,iBAAkB,CAACY,UAAU,EAAE,IAAI,CAAC;IAC3Eb,OAAO,CAACG,QAAQ,CAAC,mBAAmB,EAAEF,iBAAkB,CAACa,MAAM,EAAE,IAAI,CAAC;IACtEd,OAAO,CAACG,QAAQ,CAAC,kCAAkC,EAAQF,iBAAkB,CAACc,eAAe,GAAG,IAAI,GAAG,KAAK,EAAE,IAAI,CAAC;IACnHf,OAAO,CAACG,QAAQ,CAAC,2BAA2B,EAAE,IAAI,CAAC5C,mBAAmB,EAAE,IAAI,CAAC;EACjF;EAEOyD,OAAOA,CAAA;IACV,MAAMpC,OAAO,GAAG,IAAI,CAACD,WAAW,EAAE;IAElC,IAAIC,OAAO,IAAI,CAACA,OAAO,CAACqC,oBAAoB,EAAE,EAAE;MAC5C,OAAO,KAAK;;IAGhB,OAAO,IAAI;EACf;EAEOC,IAAIA,CAACC,MAAc,EAAEpB,YAA0B,EAAED,IAAW;;IAC/D,KAAK,CAACoB,IAAI,CAACC,MAAM,EAAEpB,YAAY,EAAED,IAAI,CAAC;IAEtC,MAAMG,iBAAiB,GAAG,IAAI,CAACtB,WAAW,EAAE;IAE5C,IAAI,CAACsB,iBAAiB,EAAE;MACpB;;IAGJ,IAAIA,iBAAiB,CAACI,MAAM,EAAE;MAC1Bc,MAAM,CAACC,UAAU,CAAC,IAAI,CAACC,gBAAgB,EAAEpB,iBAAiB,CAAC;KAC9D,MAAM;MACHkB,MAAM,CAACC,UAAU,CAAC,IAAI,CAACE,cAAc,EAAErB,iBAAiB,CAAC;;IAG7DkB,MAAM,CAACI,SAAS,CAAC,IAAI,CAACC,qBAAqB,EAAEvB,iBAAiB,CAACwB,0BAA0B,EAAE,CAAC;IAE5F,IAAIC,KAAK,GAAG,GAAG;IACf,IAAI,CAACzB,iBAAiB,CAACI,MAAM,EAAE;MAC3B,IAAUJ,iBAAkB,CAACyB,KAAK,EAAE;QAChCA,KAAK,GAASzB,iBAAkB,CAACyB,KAAK;;;IAI9C,MAAMC,iBAAiB,GAAG,CAAAC,EAAA,IAAAC,EAAA,IAAAC,EAAA,OAAI,CAACzD,uBAAuB,CAAC0D,iBAAiB,cAAAD,EAAA,uBAAAA,EAAA,CAAE1C,KAAK,cAAAyC,EAAA,cAAAA,EAAA,GAAI,CAAAG,EAAA,OAAI,CAACC,gCAAgC,CAACF,iBAAiB,cAAAC,EAAA,uBAAAA,EAAA,CAAE5C,KAAK,cAAAwC,EAAA,cAAAA,EAAA,GAAI,GAAG;IAExJT,MAAM,CAACe,SAAS,CAAC,IAAI,CAACC,qBAAqB,EAAElC,iBAAiB,CAACmC,KAAK,EAAE,CAAC,GAAGT,iBAAiB,EAAED,KAAK,EAAE,IAAI,CAACpE,iBAAiB,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;IAEpI6D,MAAM,CAACe,SAAS,CACZ,IAAI,CAACG,iCAAiC,EACtCpC,iBAAiB,CAACqC,OAAO,EAAE,CAACC,KAAK,EACjCtC,iBAAiB,CAACuC,kBAAkB,EACpCvC,iBAAiB,CAACwC,mBAAmB,EACrC,CAAC,GAAGd,iBAAiB,CACxB;IAED,MAAMY,KAAK,GAAGtC,iBAAiB,CAACqC,OAAO,EAAE,CAACC,KAAK;IAE/CpB,MAAM,CAACuB,SAAS,CAAC,IAAI,CAACC,6BAA6B,EAAEJ,KAAK,EAAEvF,MAAM,CAAC4F,IAAI,CAACL,KAAK,CAAC,CAAC;IAE/E,IAAUtC,iBAAkB,CAACc,eAAe,EAAE;MAC1C,MAAM8B,WAAW,GAAgB5C,iBAAiB;MAClDkB,MAAM,CAAC2B,UAAU,CAAC,qBAAqB,EAAED,WAAW,CAACE,mBAAmB,CAAC;MACzE5B,MAAM,CAAC2B,UAAU,CAAC,iBAAiB,EAAED,WAAW,CAAC9B,eAAe,CAAC;;EAEzE;EAEA;;;;;EAKOiC,OAAOA,CAACjF,KAA6B;IACxC,MAAMkF,IAAI,GAAG,EAAE;IAEflF,KAAK,CAACmF,UAAU,CAACC,cAAc,CAACC,IAAI,CAAC,IAAI,CAAC;IAC1CrF,KAAK,CAACmF,UAAU,CAACG,aAAa,CAACD,IAAI,CAAC,IAAI,CAAC;IAEzC;IACA,IAAI,CAAC/B,gBAAgB,GAAGtD,KAAK,CAACuF,oBAAoB,CAAC,IAAI,CAACnG,IAAI,GAAG,aAAa,CAAC;IAC7EY,KAAK,CAACwF,QAAQ,CAACH,IAAI,CAAC,IAAI,CAAC/B,gBAAgB,CAAC;IAE1C,IAAI,CAACC,cAAc,GAAGvD,KAAK,CAACuF,oBAAoB,CAAC,IAAI,CAACnG,IAAI,GAAG,WAAW,CAAC;IACzEY,KAAK,CAACwF,QAAQ,CAACH,IAAI,CAAC,IAAI,CAAC9B,cAAc,CAAC;IAExC,IAAI,CAAClB,aAAa,GAAGrC,KAAK,CAACyF,kBAAkB,CAAC,qBAAqB,CAAC;IAEpEzF,KAAK,CAAC0F,mBAAmB,IAAI,UAAU,IAAI,CAACrD,aAAa,IAAI;IAC7DrC,KAAK,CAAC0F,mBAAmB,IAAI,uBAAuB,IAAI,CAACpC,gBAAgB,KAAK;IAC9EtD,KAAK,CAAC0F,mBAAmB,IAAI,SAAS;IACtC1F,KAAK,CAAC0F,mBAAmB,IAAI,qBAAqB,IAAI,CAACnC,cAAc,KAAK;IAC1EvD,KAAK,CAAC0F,mBAAmB,IAAI,UAAU;IAEvC;IACA1F,KAAK,CAACmF,UAAU,CAACQ,iBAAiB,CAACN,IAAI,CAAC,IAAI,CAAC;IAC7CrF,KAAK,CAACmF,UAAU,CAACS,cAAc,CAACP,IAAI,CAAC,IAAI,CAAC;IAE1C,IAAI,CAAC9C,yBAAyB,GAAGvC,KAAK,CAACyF,kBAAkB,CAAC,yBAAyB,CAAC;IACpF,IAAI,CAAChD,+BAA+B,GAAGzC,KAAK,CAACyF,kBAAkB,CAAC,6BAA6B,CAAC;IAC9F,IAAI,CAAC9C,gBAAgB,GAAG3C,KAAK,CAACyF,kBAAkB,CAAC,4BAA4B,CAAC;IAE9E,IAAI,CAAChC,qBAAqB,GAAGzD,KAAK,CAACuF,oBAAoB,CAAC,kBAAkB,CAAC;IAE3EvF,KAAK,CAAC6F,sBAAsB,CAAC,IAAI,CAACpC,qBAAqB,EAAE,MAAM,CAAC;IAEhEzD,KAAK,CAAC8F,aAAa,CACf,kBAAkB,EAClB;qBACS,IAAI,CAACzD,aAAa;;;;qBAIlB,EACT,KAAK,IAAI,CAACjD,IAAI,EAAE,CACnB;IAEDY,KAAK,CAAC8F,aAAa,CACf,qBAAqB,EACrB;qBACS,IAAI,CAACzD,aAAa;;;;qBAIlB,EACT,KAAK,IAAI,CAACjD,IAAI,EAAE,CACnB;IAED,IAAI,CAACkF,iCAAiC,GAAGtE,KAAK,CAACuF,oBAAoB,CAAC,8BAA8B,CAAC;IAEnGvF,KAAK,CAAC6F,sBAAsB,CAAC,IAAI,CAACvB,iCAAiC,EAAE,MAAM,CAAC;IAE5E,IAAI,CAACF,qBAAqB,GAAGpE,KAAK,CAACuF,oBAAoB,CAAC,kBAAkB,CAAC;IAE3EvF,KAAK,CAAC6F,sBAAsB,CAAC,IAAI,CAACzB,qBAAqB,EAAE,MAAM,CAAC;IAEhE,IAAI,CAACQ,6BAA6B,GAAG5E,KAAK,CAACuF,oBAAoB,CAAC,0BAA0B,CAAC;IAE3FvF,KAAK,CAAC6F,sBAAsB,CAAC,IAAI,CAACjB,6BAA6B,EAAE,MAAM,CAAC;IAExE5E,KAAK,CAAC6F,sBAAsB,CAAC,qBAAqB,EAAE,MAAM,CAAC;IAC3D7F,KAAK,CAAC6F,sBAAsB,CAAC,iBAAiB,EAAE,MAAM,CAAC;IAEvD,OAAOX,IAAI;EACf;EAEUa,WAAWA,CAAC/F,KAA6B;IAC/C,IAAI,CAACc,MAAM,GAAGd,KAAK,CAACmF,UAAU,CAACa,KAAK;IAEpC,OAAO,IAAI;EACf;EAEUC,mBAAmBA,CAAA;IACzB,IAAIC,UAAU,GAAG,KAAK,CAACD,mBAAmB,EAAE;IAE5C,IAAI,IAAI,CAACpF,OAAO,EAAE;MACd,IAAI,IAAI,CAACA,OAAO,CAACyB,MAAM,EAAE;QACrB4D,UAAU,GAAG,GAAG,IAAI,CAACC,iBAAiB,uCAAuC,IAAI,CAACtF,OAAO,CAACzB,IAAI,OAAO;OACxG,MAAM;QACH8G,UAAU,GAAG,GAAG,IAAI,CAACC,iBAAiB,mCAAmC,IAAI,CAACtF,OAAO,CAACzB,IAAI,OAAO;;MAErG8G,UAAU,IAAI,GAAG,IAAI,CAACC,iBAAiB,8BAA8B,IAAI,CAACtF,OAAO,CAACuF,eAAe,KAAK;;IAG1GF,UAAU,IAAI,GAAG,IAAI,CAACC,iBAAiB,qCAAqC,IAAI,CAAC7G,8BAA8B,KAAK;IACpH4G,UAAU,IAAI,GAAG,IAAI,CAACC,iBAAiB,wBAAwB,IAAI,CAAC5G,iBAAiB,KAAK;IAC1F2G,UAAU,IAAI,GAAG,IAAI,CAACC,iBAAiB,0BAA0B,IAAI,CAAC3G,mBAAmB,KAAK;IAE9F,OAAO0G,UAAU;EACrB;EAEOG,SAASA,CAAA;IACZ,MAAMC,mBAAmB,GAAG,KAAK,CAACD,SAAS,EAAE;IAE7C,IAAI,IAAI,CAACxF,OAAO,IAAI,CAAC,IAAI,CAACA,OAAO,CAAC0F,cAAc,EAAE;MAC9CD,mBAAmB,CAACzF,OAAO,GAAG,IAAI,CAACA,OAAO,CAACwF,SAAS,EAAE;;IAG1DC,mBAAmB,CAAChH,8BAA8B,GAAG,IAAI,CAACA,8BAA8B;IACxFgH,mBAAmB,CAAC/G,iBAAiB,GAAG,IAAI,CAACA,iBAAiB;IAC9D+G,mBAAmB,CAAC9G,mBAAmB,GAAG,IAAI,CAACA,mBAAmB;IAElE,OAAO8G,mBAAmB;EAC9B;EAEOE,YAAYA,CAACF,mBAAwB,EAAEN,KAAY,EAAES,OAAe;IACvE,KAAK,CAACD,YAAY,CAACF,mBAAmB,EAAEN,KAAK,EAAES,OAAO,CAAC;IAEvD,IAAIH,mBAAmB,CAACzF,OAAO,EAAE;MAC7B4F,OAAO,GAAGH,mBAAmB,CAACzF,OAAO,CAAC6F,GAAG,CAACC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,EAAE,GAAGF,OAAO;MAC/E,IAAIH,mBAAmB,CAACzF,OAAO,CAACyB,MAAM,EAAE;QACpC,IAAI,CAACzB,OAAO,GAAG/B,WAAW,CAAC8H,KAAK,CAACN,mBAAmB,CAACzF,OAAO,EAAEmF,KAAK,EAAES,OAAO,CAAC;OAChF,MAAM;QACH,IAAI,CAAC5F,OAAO,GAAG9B,OAAO,CAAC6H,KAAK,CAACN,mBAAmB,CAACzF,OAAO,EAAEmF,KAAK,EAAES,OAAO,CAAC;;;IAIjF,IAAI,CAACnH,8BAA8B,GAAGgH,mBAAmB,CAAChH,8BAA8B;IACxF,IAAI,CAACC,iBAAiB,GAAG+G,mBAAmB,CAAC/G,iBAAiB;IAC9D,IAAI,CAACC,mBAAmB,GAAG,CAAC,CAAC8G,mBAAmB,CAAC9G,mBAAmB;EACxE;;AAlVOqH,UAAA,EADNlI,sBAAsB,CAAC,iCAAiC,EAAEC,sBAAsB,CAACkI,OAAO,EAAE,UAAU,EAAE;EAAEC,SAAS,EAAE;IAAEC,MAAM,EAAE;EAAI;AAAE,CAAE,CAAC,C,sEAChF;AAMhDH,UAAA,EADNlI,sBAAsB,CAAC,qBAAqB,EAAEC,sBAAsB,CAACkI,OAAO,EAAE,UAAU,EAAE;EAAEC,SAAS,EAAE;IAAEC,MAAM,EAAE;EAAI;AAAE,CAAE,CAAC,C,yDACjF;AAMnCH,UAAA,EADNlI,sBAAsB,CAAC,wBAAwB,EAAEC,sBAAsB,CAACkI,OAAO,EAAE,UAAU,EAAE;EAAEC,SAAS,EAAE;IAAEC,MAAM,EAAE;EAAI;AAAE,CAAE,CAAC,C,2DAClF;AAyUhDxI,aAAa,CAAC,yBAAyB,EAAEU,eAAe,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}