{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { CreateLineSystem } from \"../Meshes/Builders/linesBuilder.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial.js\";\nimport { DynamicTexture } from \"../Materials/Textures/dynamicTexture.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Effect } from \"../Materials/effect.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { ExtrudeShapeCustom } from \"../Meshes/Builders/shapeBuilder.js\";\n/**\n * Class used to render a debug view of a given skeleton\n * @see http://www.babylonjs-playground.com/#1BZJVJ#8\n */\nexport class SkeletonViewer {\n  /** public static method to create a BoneWeight Shader\n   * @param options The constructor options\n   * @param scene The scene that the shader is scoped to\n   * @returns The created ShaderMaterial\n   * @see http://www.babylonjs-playground.com/#1BZJVJ#395\n   */\n  static CreateBoneWeightShader(options, scene) {\n    var _a, _c, _d, _e, _f, _g;\n    const skeleton = options.skeleton;\n    const colorBase = (_a = options.colorBase) !== null && _a !== void 0 ? _a : Color3.Black();\n    const colorZero = (_c = options.colorZero) !== null && _c !== void 0 ? _c : Color3.Blue();\n    const colorQuarter = (_d = options.colorQuarter) !== null && _d !== void 0 ? _d : Color3.Green();\n    const colorHalf = (_e = options.colorHalf) !== null && _e !== void 0 ? _e : Color3.Yellow();\n    const colorFull = (_f = options.colorFull) !== null && _f !== void 0 ? _f : Color3.Red();\n    const targetBoneIndex = (_g = options.targetBoneIndex) !== null && _g !== void 0 ? _g : 0;\n    Effect.ShadersStore[\"boneWeights:\" + skeleton.name + \"VertexShader\"] = `precision highp float;\n\n        attribute vec3 position;\n        attribute vec2 uv;\n\n        uniform mat4 view;\n        uniform mat4 projection;\n        uniform mat4 worldViewProjection;\n\n        #include<bonesDeclaration>\n        #if NUM_BONE_INFLUENCERS == 0\n            attribute vec4 matricesIndices;\n            attribute vec4 matricesWeights;\n        #endif\n        #include<bakedVertexAnimationDeclaration>\n\n        #include<instancesDeclaration>\n\n        varying vec3 vColor;\n\n        uniform vec3 colorBase;\n        uniform vec3 colorZero;\n        uniform vec3 colorQuarter;\n        uniform vec3 colorHalf;\n        uniform vec3 colorFull;\n\n        uniform float targetBoneIndex;\n\n        void main() {\n            vec3 positionUpdated = position;\n\n            #include<instancesVertex>\n            #include<bonesVertex>\n            #include<bakedVertexAnimation>\n\n            vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\n\n            vec3 color = colorBase;\n            float totalWeight = 0.;\n            if(matricesIndices[0] == targetBoneIndex && matricesWeights[0] > 0.){\n                totalWeight += matricesWeights[0];\n            }\n            if(matricesIndices[1] == targetBoneIndex && matricesWeights[1] > 0.){\n                totalWeight += matricesWeights[1];\n            }\n            if(matricesIndices[2] == targetBoneIndex && matricesWeights[2] > 0.){\n                totalWeight += matricesWeights[2];\n            }\n            if(matricesIndices[3] == targetBoneIndex && matricesWeights[3] > 0.){\n                totalWeight += matricesWeights[3];\n            }\n\n            color = mix(color, colorZero, smoothstep(0., 0.25, totalWeight));\n            color = mix(color, colorQuarter, smoothstep(0.25, 0.5, totalWeight));\n            color = mix(color, colorHalf, smoothstep(0.5, 0.75, totalWeight));\n            color = mix(color, colorFull, smoothstep(0.75, 1.0, totalWeight));\n            vColor = color;\n\n        gl_Position = projection * view * worldPos;\n        }`;\n    Effect.ShadersStore[\"boneWeights:\" + skeleton.name + \"FragmentShader\"] = `\n            precision highp float;\n            varying vec3 vPosition;\n\n            varying vec3 vColor;\n\n            void main() {\n                vec4 color = vec4(vColor, 1.0);\n                gl_FragColor = color;\n            }\n        `;\n    const shader = new ShaderMaterial(\"boneWeight:\" + skeleton.name, scene, {\n      vertex: \"boneWeights:\" + skeleton.name,\n      fragment: \"boneWeights:\" + skeleton.name\n    }, {\n      attributes: [\"position\", \"normal\", \"matricesIndices\", \"matricesWeights\"],\n      uniforms: [\"world\", \"worldView\", \"worldViewProjection\", \"view\", \"projection\", \"viewProjection\", \"colorBase\", \"colorZero\", \"colorQuarter\", \"colorHalf\", \"colorFull\", \"targetBoneIndex\"]\n    });\n    shader.setColor3(\"colorBase\", colorBase);\n    shader.setColor3(\"colorZero\", colorZero);\n    shader.setColor3(\"colorQuarter\", colorQuarter);\n    shader.setColor3(\"colorHalf\", colorHalf);\n    shader.setColor3(\"colorFull\", colorFull);\n    shader.setFloat(\"targetBoneIndex\", targetBoneIndex);\n    shader.getClassName = () => {\n      return \"BoneWeightShader\";\n    };\n    shader.transparencyMode = Material.MATERIAL_OPAQUE;\n    return shader;\n  }\n  /** public static method to create a BoneWeight Shader\n   * @param options The constructor options\n   * @param scene The scene that the shader is scoped to\n   * @returns The created ShaderMaterial\n   */\n  static CreateSkeletonMapShader(options, scene) {\n    var _a;\n    const skeleton = options.skeleton;\n    const colorMap = (_a = options.colorMap) !== null && _a !== void 0 ? _a : [{\n      color: new Color3(1, 0.38, 0.18),\n      location: 0\n    }, {\n      color: new Color3(0.59, 0.18, 1.0),\n      location: 0.2\n    }, {\n      color: new Color3(0.59, 1, 0.18),\n      location: 0.4\n    }, {\n      color: new Color3(1, 0.87, 0.17),\n      location: 0.6\n    }, {\n      color: new Color3(1, 0.17, 0.42),\n      location: 0.8\n    }, {\n      color: new Color3(0.17, 0.68, 1.0),\n      location: 1.0\n    }];\n    const bufferWidth = skeleton.bones.length + 1;\n    const colorMapBuffer = SkeletonViewer._CreateBoneMapColorBuffer(bufferWidth, colorMap, scene);\n    const shader = new ShaderMaterial(\"boneWeights:\" + skeleton.name, scene, {\n      vertexSource: `precision highp float;\n\n            attribute vec3 position;\n            attribute vec2 uv;\n\n            uniform mat4 view;\n            uniform mat4 projection;\n            uniform mat4 worldViewProjection;\n            uniform float colorMap[` + skeleton.bones.length * 4 + `];\n\n            #include<bonesDeclaration>\n            #if NUM_BONE_INFLUENCERS == 0\n                attribute vec4 matricesIndices;\n                attribute vec4 matricesWeights;\n            #endif\n            #include<bakedVertexAnimationDeclaration>\n            #include<instancesDeclaration>\n\n            varying vec3 vColor;\n\n            void main() {\n                vec3 positionUpdated = position;\n\n                #include<instancesVertex>\n                #include<bonesVertex>\n                #include<bakedVertexAnimation>\n\n                vec3 color = vec3(0.);\n                bool first = true;\n\n                for (int i = 0; i < 4; i++) {\n                    int boneIdx = int(matricesIndices[i]);\n                    float boneWgt = matricesWeights[i];\n\n                    vec3 c = vec3(colorMap[boneIdx * 4 + 0], colorMap[boneIdx * 4 + 1], colorMap[boneIdx * 4 + 2]);\n\n                    if (boneWgt > 0.) {\n                        if (first) {\n                            first = false;\n                            color = c;\n                        } else {\n                            color = mix(color, c, boneWgt);\n                        }\n                    }\n                }\n\n                vColor = color;\n\n                vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\n\n                gl_Position = projection * view * worldPos;\n            }`,\n      fragmentSource: `\n            precision highp float;\n            varying vec3 vColor;\n\n            void main() {\n                vec4 color = vec4( vColor, 1.0 );\n                gl_FragColor = color;\n            }\n            `\n    }, {\n      attributes: [\"position\", \"normal\", \"matricesIndices\", \"matricesWeights\"],\n      uniforms: [\"world\", \"worldView\", \"worldViewProjection\", \"view\", \"projection\", \"viewProjection\", \"colorMap\"]\n    });\n    shader.setFloats(\"colorMap\", colorMapBuffer);\n    shader.getClassName = () => {\n      return \"SkeletonMapShader\";\n    };\n    shader.transparencyMode = Material.MATERIAL_OPAQUE;\n    return shader;\n  }\n  /** private static method to create a BoneWeight Shader\n   * @param size The size of the buffer to create (usually the bone count)\n   * @param colorMap The gradient data to generate\n   * @param scene The scene that the shader is scoped to\n   * @returns an Array of floats from the color gradient values\n   */\n  static _CreateBoneMapColorBuffer(size, colorMap, scene) {\n    const tempGrad = new DynamicTexture(\"temp\", {\n      width: size,\n      height: 1\n    }, scene, false);\n    const ctx = tempGrad.getContext();\n    const grad = ctx.createLinearGradient(0, 0, size, 0);\n    colorMap.forEach(stop => {\n      grad.addColorStop(stop.location, stop.color.toHexString());\n    });\n    ctx.fillStyle = grad;\n    ctx.fillRect(0, 0, size, 1);\n    tempGrad.update();\n    const buffer = [];\n    const data = ctx.getImageData(0, 0, size, 1).data;\n    const rUnit = 1 / 255;\n    for (let i = 0; i < data.length; i++) {\n      buffer.push(data[i] * rUnit);\n    }\n    tempGrad.dispose();\n    return buffer;\n  }\n  /** Gets the Scene. */\n  get scene() {\n    return this._scene;\n  }\n  /** Gets the utilityLayer. */\n  get utilityLayer() {\n    return this._utilityLayer;\n  }\n  /** Checks Ready Status. */\n  get isReady() {\n    return this._ready;\n  }\n  /** Sets Ready Status. */\n  set ready(value) {\n    this._ready = value;\n  }\n  /** Gets the debugMesh */\n  get debugMesh() {\n    return this._debugMesh;\n  }\n  /** Sets the debugMesh */\n  set debugMesh(value) {\n    this._debugMesh = value;\n  }\n  /** Gets the displayMode */\n  get displayMode() {\n    return this.options.displayMode || SkeletonViewer.DISPLAY_LINES;\n  }\n  /** Sets the displayMode */\n  set displayMode(value) {\n    if (value > SkeletonViewer.DISPLAY_SPHERE_AND_SPURS) {\n      value = SkeletonViewer.DISPLAY_LINES;\n    }\n    this.options.displayMode = value;\n  }\n  /**\n   * Creates a new SkeletonViewer\n   * @param skeleton defines the skeleton to render\n   * @param mesh defines the mesh attached to the skeleton\n   * @param scene defines the hosting scene\n   * @param autoUpdateBonesMatrices defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)\n   * @param renderingGroupId defines the rendering group id to use with the viewer\n   * @param options All of the extra constructor options for the SkeletonViewer\n   */\n  constructor( /** defines the skeleton to render */\n  skeleton, /** defines the mesh attached to the skeleton */\n  mesh, /** The Scene scope*/\n  scene, /** defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)  */\n  autoUpdateBonesMatrices = true, /** defines the rendering group id to use with the viewer */\n  renderingGroupId = 3, /** is the options for the viewer */\n  options = {}) {\n    var _a, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;\n    this.skeleton = skeleton;\n    this.mesh = mesh;\n    this.autoUpdateBonesMatrices = autoUpdateBonesMatrices;\n    this.renderingGroupId = renderingGroupId;\n    this.options = options;\n    /** Gets or sets the color used to render the skeleton */\n    this.color = Color3.White();\n    /** Array of the points of the skeleton fo the line view. */\n    this._debugLines = new Array();\n    /** The local axes Meshes. */\n    this._localAxes = null;\n    /** If SkeletonViewer is enabled. */\n    this._isEnabled = true;\n    /** SkeletonViewer render observable. */\n    this._obs = null;\n    this._scene = scene;\n    this._ready = false;\n    //Defaults\n    options.pauseAnimations = (_a = options.pauseAnimations) !== null && _a !== void 0 ? _a : true;\n    options.returnToRest = (_c = options.returnToRest) !== null && _c !== void 0 ? _c : false;\n    options.displayMode = (_d = options.displayMode) !== null && _d !== void 0 ? _d : SkeletonViewer.DISPLAY_LINES;\n    options.displayOptions = (_e = options.displayOptions) !== null && _e !== void 0 ? _e : {};\n    options.displayOptions.midStep = (_f = options.displayOptions.midStep) !== null && _f !== void 0 ? _f : 0.235;\n    options.displayOptions.midStepFactor = (_g = options.displayOptions.midStepFactor) !== null && _g !== void 0 ? _g : 0.155;\n    options.displayOptions.sphereBaseSize = (_h = options.displayOptions.sphereBaseSize) !== null && _h !== void 0 ? _h : 0.15;\n    options.displayOptions.sphereScaleUnit = (_j = options.displayOptions.sphereScaleUnit) !== null && _j !== void 0 ? _j : 2;\n    options.displayOptions.sphereFactor = (_k = options.displayOptions.sphereFactor) !== null && _k !== void 0 ? _k : 0.865;\n    options.displayOptions.spurFollowsChild = (_l = options.displayOptions.spurFollowsChild) !== null && _l !== void 0 ? _l : false;\n    options.displayOptions.showLocalAxes = (_m = options.displayOptions.showLocalAxes) !== null && _m !== void 0 ? _m : false;\n    options.displayOptions.localAxesSize = (_o = options.displayOptions.localAxesSize) !== null && _o !== void 0 ? _o : 0.075;\n    options.computeBonesUsingShaders = (_p = options.computeBonesUsingShaders) !== null && _p !== void 0 ? _p : true;\n    options.useAllBones = (_q = options.useAllBones) !== null && _q !== void 0 ? _q : true;\n    const initialMeshBoneIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);\n    const initialMeshBoneWeights = mesh.getVerticesData(VertexBuffer.MatricesWeightsKind);\n    this._boneIndices = new Set();\n    if (!options.useAllBones) {\n      if (initialMeshBoneIndices && initialMeshBoneWeights) {\n        for (let i = 0; i < initialMeshBoneIndices.length; ++i) {\n          const index = initialMeshBoneIndices[i],\n            weight = initialMeshBoneWeights[i];\n          if (weight !== 0) {\n            this._boneIndices.add(index);\n          }\n        }\n      }\n    }\n    /* Create Utility Layer */\n    this._utilityLayer = new UtilityLayerRenderer(this._scene, false);\n    this._utilityLayer.pickUtilitySceneFirst = false;\n    this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = true;\n    let displayMode = this.options.displayMode || 0;\n    if (displayMode > SkeletonViewer.DISPLAY_SPHERE_AND_SPURS) {\n      displayMode = SkeletonViewer.DISPLAY_LINES;\n    }\n    this.displayMode = displayMode;\n    //Prep the Systems\n    this.update();\n    this._bindObs();\n  }\n  /** The Dynamic bindings for the update functions */\n  _bindObs() {\n    switch (this.displayMode) {\n      case SkeletonViewer.DISPLAY_LINES:\n        {\n          this._obs = this.scene.onBeforeRenderObservable.add(() => {\n            this._displayLinesUpdate();\n          });\n          break;\n        }\n    }\n  }\n  /** Update the viewer to sync with current skeleton state, only used to manually update. */\n  update() {\n    switch (this.displayMode) {\n      case SkeletonViewer.DISPLAY_LINES:\n        {\n          this._displayLinesUpdate();\n          break;\n        }\n      case SkeletonViewer.DISPLAY_SPHERES:\n        {\n          this._buildSpheresAndSpurs(true);\n          break;\n        }\n      case SkeletonViewer.DISPLAY_SPHERE_AND_SPURS:\n        {\n          this._buildSpheresAndSpurs(false);\n          break;\n        }\n    }\n    this._buildLocalAxes();\n  }\n  /** Gets or sets a boolean indicating if the viewer is enabled */\n  set isEnabled(value) {\n    if (this.isEnabled === value) {\n      return;\n    }\n    this._isEnabled = value;\n    if (this.debugMesh) {\n      this.debugMesh.setEnabled(value);\n    }\n    if (value && !this._obs) {\n      this._bindObs();\n    } else if (!value && this._obs) {\n      this.scene.onBeforeRenderObservable.remove(this._obs);\n      this._obs = null;\n    }\n  }\n  get isEnabled() {\n    return this._isEnabled;\n  }\n  _getBonePosition(position, bone, meshMat, x = 0, y = 0, z = 0) {\n    const tmat = TmpVectors.Matrix[0];\n    const parentBone = bone.getParent();\n    tmat.copyFrom(bone.getLocalMatrix());\n    if (x !== 0 || y !== 0 || z !== 0) {\n      const tmat2 = TmpVectors.Matrix[1];\n      Matrix.IdentityToRef(tmat2);\n      tmat2.setTranslationFromFloats(x, y, z);\n      tmat2.multiplyToRef(tmat, tmat);\n    }\n    if (parentBone) {\n      tmat.multiplyToRef(parentBone.getAbsoluteMatrix(), tmat);\n    }\n    tmat.multiplyToRef(meshMat, tmat);\n    position.x = tmat.m[12];\n    position.y = tmat.m[13];\n    position.z = tmat.m[14];\n  }\n  _getLinesForBonesWithLength(bones, meshMat) {\n    const len = bones.length;\n    const mesh = this.mesh;\n    const meshPos = mesh.position;\n    let idx = 0;\n    for (let i = 0; i < len; i++) {\n      const bone = bones[i];\n      let points = this._debugLines[idx];\n      if (bone._index === -1 || !this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones) {\n        continue;\n      }\n      if (!points) {\n        points = [Vector3.Zero(), Vector3.Zero()];\n        this._debugLines[idx] = points;\n      }\n      this._getBonePosition(points[0], bone, meshMat);\n      this._getBonePosition(points[1], bone, meshMat, 0, bone.length, 0);\n      points[0].subtractInPlace(meshPos);\n      points[1].subtractInPlace(meshPos);\n      idx++;\n    }\n  }\n  _getLinesForBonesNoLength(bones) {\n    const len = bones.length;\n    let boneNum = 0;\n    const mesh = this.mesh;\n    const meshPos = mesh.position;\n    for (let i = len - 1; i >= 0; i--) {\n      const childBone = bones[i];\n      const parentBone = childBone.getParent();\n      if (!parentBone || !this._boneIndices.has(childBone.getIndex()) && !this.options.useAllBones) {\n        continue;\n      }\n      let points = this._debugLines[boneNum];\n      if (!points) {\n        points = [Vector3.Zero(), Vector3.Zero()];\n        this._debugLines[boneNum] = points;\n      }\n      childBone.getAbsolutePositionToRef(mesh, points[0]);\n      parentBone.getAbsolutePositionToRef(mesh, points[1]);\n      points[0].subtractInPlace(meshPos);\n      points[1].subtractInPlace(meshPos);\n      boneNum++;\n    }\n  }\n  /**\n   * function to revert the mesh and scene back to the initial state.\n   * @param animationState\n   */\n  _revert(animationState) {\n    if (this.options.pauseAnimations) {\n      this.scene.animationsEnabled = animationState;\n      this.utilityLayer.utilityLayerScene.animationsEnabled = animationState;\n    }\n  }\n  /**\n   * function to get the absolute bind pose of a bone by accumulating transformations up the bone hierarchy.\n   * @param bone\n   * @param matrix\n   */\n  _getAbsoluteBindPoseToRef(bone, matrix) {\n    if (bone === null || bone._index === -1) {\n      matrix.copyFrom(Matrix.Identity());\n      return;\n    }\n    this._getAbsoluteBindPoseToRef(bone.getParent(), matrix);\n    bone.getBindMatrix().multiplyToRef(matrix, matrix);\n    return;\n  }\n  /**\n   * function to build and bind sphere joint points and spur bone representations.\n   * @param spheresOnly\n   */\n  _buildSpheresAndSpurs(spheresOnly = true) {\n    var _a, _c;\n    if (this._debugMesh) {\n      this._debugMesh.dispose();\n      this._debugMesh = null;\n      this.ready = false;\n    }\n    this._ready = false;\n    const utilityLayerScene = (_a = this.utilityLayer) === null || _a === void 0 ? void 0 : _a.utilityLayerScene;\n    const bones = this.skeleton.bones;\n    const spheres = [];\n    const spurs = [];\n    const animationState = this.scene.animationsEnabled;\n    try {\n      if (this.options.pauseAnimations) {\n        this.scene.animationsEnabled = false;\n        utilityLayerScene.animationsEnabled = false;\n      }\n      if (this.options.returnToRest) {\n        this.skeleton.returnToRest();\n      }\n      if (this.autoUpdateBonesMatrices) {\n        this.skeleton.computeAbsoluteMatrices();\n      }\n      let longestBoneLength = Number.NEGATIVE_INFINITY;\n      const displayOptions = this.options.displayOptions || {};\n      for (let i = 0; i < bones.length; i++) {\n        const bone = bones[i];\n        if (bone._index === -1 || !this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones) {\n          continue;\n        }\n        const boneAbsoluteBindPoseTransform = new Matrix();\n        this._getAbsoluteBindPoseToRef(bone, boneAbsoluteBindPoseTransform);\n        const anchorPoint = new Vector3();\n        boneAbsoluteBindPoseTransform.decompose(undefined, undefined, anchorPoint);\n        bone.children.forEach(bc => {\n          const childAbsoluteBindPoseTransform = new Matrix();\n          bc.getLocalMatrix().multiplyToRef(boneAbsoluteBindPoseTransform, childAbsoluteBindPoseTransform);\n          const childPoint = new Vector3();\n          childAbsoluteBindPoseTransform.decompose(undefined, undefined, childPoint);\n          const distanceFromParent = Vector3.Distance(anchorPoint, childPoint);\n          if (distanceFromParent > longestBoneLength) {\n            longestBoneLength = distanceFromParent;\n          }\n          if (spheresOnly) {\n            return;\n          }\n          const dir = childPoint.clone().subtract(anchorPoint.clone());\n          const h = dir.length();\n          const up = dir.normalize().scale(h);\n          const midStep = displayOptions.midStep || 0.165;\n          const midStepFactor = displayOptions.midStepFactor || 0.215;\n          const up0 = up.scale(midStep);\n          const spur = ExtrudeShapeCustom(\"skeletonViewer\", {\n            shape: [new Vector3(1, -1, 0), new Vector3(1, 1, 0), new Vector3(-1, 1, 0), new Vector3(-1, -1, 0), new Vector3(1, -1, 0)],\n            path: [Vector3.Zero(), up0, up],\n            scaleFunction: i => {\n              switch (i) {\n                case 0:\n                case 2:\n                  return 0;\n                case 1:\n                  return h * midStepFactor;\n              }\n              return 0;\n            },\n            sideOrientation: Mesh.DEFAULTSIDE,\n            updatable: false\n          }, utilityLayerScene);\n          const numVertices = spur.getTotalVertices();\n          const mwk = [],\n            mik = [];\n          for (let i = 0; i < numVertices; i++) {\n            mwk.push(1, 0, 0, 0);\n            // Select verts at end of spur (ie vert 10 to 14) and bind to child\n            // bone if spurFollowsChild is enabled.\n            if (displayOptions.spurFollowsChild && i > 9) {\n              mik.push(bc.getIndex(), 0, 0, 0);\n            } else {\n              mik.push(bone.getIndex(), 0, 0, 0);\n            }\n          }\n          spur.position = anchorPoint.clone();\n          spur.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\n          spur.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\n          spur.convertToFlatShadedMesh();\n          spurs.push(spur);\n        });\n        const sphereBaseSize = displayOptions.sphereBaseSize || 0.2;\n        const sphere = CreateSphere(\"skeletonViewer\", {\n          segments: 6,\n          diameter: sphereBaseSize,\n          updatable: true\n        }, utilityLayerScene);\n        const numVertices = sphere.getTotalVertices();\n        const mwk = [],\n          mik = [];\n        for (let i = 0; i < numVertices; i++) {\n          mwk.push(1, 0, 0, 0);\n          mik.push(bone.getIndex(), 0, 0, 0);\n        }\n        sphere.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\n        sphere.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\n        sphere.position = anchorPoint.clone();\n        spheres.push([sphere, bone]);\n      }\n      const sphereScaleUnit = displayOptions.sphereScaleUnit || 2;\n      const sphereFactor = displayOptions.sphereFactor || 0.85;\n      const meshes = [];\n      for (let i = 0; i < spheres.length; i++) {\n        const [sphere, bone] = spheres[i];\n        const scale = 1 / (sphereScaleUnit / longestBoneLength);\n        let _stepsOut = 0;\n        let _b = bone;\n        while (_b.getParent() && _b.getParent().getIndex() !== -1) {\n          _stepsOut++;\n          _b = _b.getParent();\n        }\n        sphere.scaling.scaleInPlace(scale * Math.pow(sphereFactor, _stepsOut));\n        meshes.push(sphere);\n      }\n      this.debugMesh = Mesh.MergeMeshes(meshes.concat(spurs), true, true);\n      if (this.debugMesh) {\n        this.debugMesh.renderingGroupId = this.renderingGroupId;\n        this.debugMesh.skeleton = this.skeleton;\n        this.debugMesh.parent = this.mesh;\n        this.debugMesh.computeBonesUsingShaders = (_c = this.options.computeBonesUsingShaders) !== null && _c !== void 0 ? _c : true;\n        this.debugMesh.alwaysSelectAsActiveMesh = true;\n      }\n      const light = this.utilityLayer._getSharedGizmoLight();\n      light.intensity = 0.7;\n      this._revert(animationState);\n      this.ready = true;\n    } catch (err) {\n      console.error(err);\n      this._revert(animationState);\n      this.dispose();\n    }\n  }\n  _buildLocalAxes() {\n    var _a;\n    if (this._localAxes) {\n      this._localAxes.dispose();\n    }\n    this._localAxes = null;\n    const displayOptions = this.options.displayOptions || {};\n    if (!displayOptions.showLocalAxes) {\n      return;\n    }\n    const targetScene = this._utilityLayer.utilityLayerScene;\n    const size = displayOptions.localAxesSize || 0.075;\n    const lines = [];\n    const colors = [];\n    const red = new Color4(1, 0, 0, 1);\n    const green = new Color4(0, 1, 0, 1);\n    const blue = new Color4(0, 0, 1, 1);\n    const mwk = [];\n    const mik = [];\n    const vertsPerBone = 6;\n    for (const i in this.skeleton.bones) {\n      const bone = this.skeleton.bones[i];\n      if (bone._index === -1 || !this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones) {\n        continue;\n      }\n      const boneAbsoluteBindPoseTransform = new Matrix();\n      const boneOrigin = new Vector3();\n      this._getAbsoluteBindPoseToRef(bone, boneAbsoluteBindPoseTransform);\n      boneAbsoluteBindPoseTransform.decompose(undefined, TmpVectors.Quaternion[0], boneOrigin);\n      const m = new Matrix();\n      TmpVectors.Quaternion[0].toRotationMatrix(m);\n      const boneAxisX = Vector3.TransformCoordinates(new Vector3(0 + size, 0, 0), m);\n      const boneAxisY = Vector3.TransformCoordinates(new Vector3(0, 0 + size, 0), m);\n      const boneAxisZ = Vector3.TransformCoordinates(new Vector3(0, 0, 0 + size), m);\n      const axisX = [boneOrigin, boneOrigin.add(boneAxisX)];\n      const axisY = [boneOrigin, boneOrigin.add(boneAxisY)];\n      const axisZ = [boneOrigin, boneOrigin.add(boneAxisZ)];\n      const linePoints = [axisX, axisY, axisZ];\n      const lineColors = [[red, red], [green, green], [blue, blue]];\n      lines.push(...linePoints);\n      colors.push(...lineColors);\n      for (let j = 0; j < vertsPerBone; j++) {\n        mwk.push(1, 0, 0, 0);\n        mik.push(bone.getIndex(), 0, 0, 0);\n      }\n    }\n    this._localAxes = CreateLineSystem(\"localAxes\", {\n      lines: lines,\n      colors: colors,\n      updatable: true\n    }, targetScene);\n    this._localAxes.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\n    this._localAxes.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\n    this._localAxes.skeleton = this.skeleton;\n    this._localAxes.renderingGroupId = this.renderingGroupId + 1;\n    this._localAxes.parent = this.mesh;\n    this._localAxes.computeBonesUsingShaders = (_a = this.options.computeBonesUsingShaders) !== null && _a !== void 0 ? _a : true;\n  }\n  /** Update the viewer to sync with current skeleton state, only used for the line display. */\n  _displayLinesUpdate() {\n    if (!this._utilityLayer) {\n      return;\n    }\n    if (this.autoUpdateBonesMatrices) {\n      this.skeleton.computeAbsoluteMatrices();\n    }\n    if (this.skeleton.bones[0].length === undefined) {\n      this._getLinesForBonesNoLength(this.skeleton.bones);\n    } else {\n      this._getLinesForBonesWithLength(this.skeleton.bones, this.mesh.getWorldMatrix());\n    }\n    const targetScene = this._utilityLayer.utilityLayerScene;\n    if (targetScene) {\n      if (!this._debugMesh) {\n        this._debugMesh = CreateLineSystem(\"\", {\n          lines: this._debugLines,\n          updatable: true,\n          instance: null\n        }, targetScene);\n        this._debugMesh.renderingGroupId = this.renderingGroupId;\n      } else {\n        CreateLineSystem(\"\", {\n          lines: this._debugLines,\n          updatable: true,\n          instance: this._debugMesh\n        }, targetScene);\n      }\n      this._debugMesh.position.copyFrom(this.mesh.position);\n      this._debugMesh.color = this.color;\n    }\n  }\n  /** Changes the displayMode of the skeleton viewer\n   * @param mode The displayMode numerical value\n   */\n  changeDisplayMode(mode) {\n    const wasEnabled = this.isEnabled ? true : false;\n    if (this.displayMode !== mode) {\n      this.isEnabled = false;\n      if (this._debugMesh) {\n        this._debugMesh.dispose();\n        this._debugMesh = null;\n        this.ready = false;\n      }\n      this.displayMode = mode;\n      this.update();\n      this._bindObs();\n      this.isEnabled = wasEnabled;\n    }\n  }\n  /** Sets a display option of the skeleton viewer\n   *\n   * | Option           | Type    | Default | Description |\n   * | ---------------- | ------- | ------- | ----------- |\n   * | midStep          | float   | 0.235   | A percentage between a bone and its child that determines the widest part of a spur. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\n   * | midStepFactor    | float   | 0.15    | Mid step width expressed as a factor of the length. A value of 0.5 makes the spur width half of the spur length. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\n   * | sphereBaseSize   | float   | 2       | Sphere base size. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\n   * | sphereScaleUnit  | float   | 0.865   | Sphere scale factor used to scale spheres in relation to the longest bone. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\n   * | spurFollowsChild | boolean | false   | Whether a spur should attach its far end to the child bone. |\n   * | showLocalAxes    | boolean | false   | Displays local axes on all bones. |\n   * | localAxesSize    | float   | 0.075   | Determines the length of each local axis. |\n   *\n   * @param option String of the option name\n   * @param value The numerical option value\n   */\n  changeDisplayOptions(option, value) {\n    const wasEnabled = this.isEnabled ? true : false;\n    this.options.displayOptions[option] = value;\n    this.isEnabled = false;\n    if (this._debugMesh) {\n      this._debugMesh.dispose();\n      this._debugMesh = null;\n      this.ready = false;\n    }\n    this.update();\n    this._bindObs();\n    this.isEnabled = wasEnabled;\n  }\n  /** Release associated resources */\n  dispose() {\n    this.isEnabled = false;\n    if (this._debugMesh) {\n      this._debugMesh.dispose();\n      this._debugMesh = null;\n    }\n    if (this._utilityLayer) {\n      this._utilityLayer.dispose();\n      this._utilityLayer = null;\n    }\n    this.ready = false;\n  }\n}\n/** public Display constants BABYLON.SkeletonViewer.DISPLAY_LINES */\nSkeletonViewer.DISPLAY_LINES = 0;\n/** public Display constants BABYLON.SkeletonViewer.DISPLAY_SPHERES */\nSkeletonViewer.DISPLAY_SPHERES = 1;\n/** public Display constants BABYLON.SkeletonViewer.DISPLAY_SPHERE_AND_SPURS */\nSkeletonViewer.DISPLAY_SPHERE_AND_SPURS = 2;","map":{"version":3,"names":["Vector3","Matrix","TmpVectors","Color3","Color4","Mesh","CreateLineSystem","UtilityLayerRenderer","Material","ShaderMaterial","DynamicTexture","VertexBuffer","Effect","CreateSphere","ExtrudeShapeCustom","SkeletonViewer","CreateBoneWeightShader","options","scene","skeleton","colorBase","_a","Black","colorZero","_c","Blue","colorQuarter","_d","Green","colorHalf","_e","Yellow","colorFull","_f","Red","targetBoneIndex","_g","ShadersStore","name","shader","vertex","fragment","attributes","uniforms","setColor3","setFloat","getClassName","transparencyMode","MATERIAL_OPAQUE","CreateSkeletonMapShader","colorMap","color","location","bufferWidth","bones","length","colorMapBuffer","_CreateBoneMapColorBuffer","vertexSource","fragmentSource","setFloats","size","tempGrad","width","height","ctx","getContext","grad","createLinearGradient","forEach","stop","addColorStop","toHexString","fillStyle","fillRect","update","buffer","data","getImageData","rUnit","i","push","dispose","_scene","utilityLayer","_utilityLayer","isReady","_ready","ready","value","debugMesh","_debugMesh","displayMode","DISPLAY_LINES","DISPLAY_SPHERE_AND_SPURS","constructor","mesh","autoUpdateBonesMatrices","renderingGroupId","White","_debugLines","Array","_localAxes","_isEnabled","_obs","pauseAnimations","returnToRest","displayOptions","midStep","midStepFactor","sphereBaseSize","_h","sphereScaleUnit","_j","sphereFactor","_k","spurFollowsChild","_l","showLocalAxes","_m","localAxesSize","_o","computeBonesUsingShaders","_p","useAllBones","_q","initialMeshBoneIndices","getVerticesData","MatricesIndicesKind","initialMeshBoneWeights","MatricesWeightsKind","_boneIndices","Set","index","weight","add","pickUtilitySceneFirst","utilityLayerScene","autoClearDepthAndStencil","_bindObs","onBeforeRenderObservable","_displayLinesUpdate","DISPLAY_SPHERES","_buildSpheresAndSpurs","_buildLocalAxes","isEnabled","setEnabled","remove","_getBonePosition","position","bone","meshMat","x","y","z","tmat","parentBone","getParent","copyFrom","getLocalMatrix","tmat2","IdentityToRef","setTranslationFromFloats","multiplyToRef","getAbsoluteMatrix","m","_getLinesForBonesWithLength","len","meshPos","idx","points","_index","has","getIndex","Zero","subtractInPlace","_getLinesForBonesNoLength","boneNum","childBone","getAbsolutePositionToRef","_revert","animationState","animationsEnabled","_getAbsoluteBindPoseToRef","matrix","Identity","getBindMatrix","spheresOnly","spheres","spurs","computeAbsoluteMatrices","longestBoneLength","Number","NEGATIVE_INFINITY","boneAbsoluteBindPoseTransform","anchorPoint","decompose","undefined","children","bc","childAbsoluteBindPoseTransform","childPoint","distanceFromParent","Distance","dir","clone","subtract","h","up","normalize","scale","up0","spur","shape","path","scaleFunction","sideOrientation","DEFAULTSIDE","updatable","numVertices","getTotalVertices","mwk","mik","setVerticesData","convertToFlatShadedMesh","sphere","segments","diameter","meshes","_stepsOut","_b","scaling","scaleInPlace","Math","pow","MergeMeshes","concat","parent","alwaysSelectAsActiveMesh","light","_getSharedGizmoLight","intensity","err","console","error","targetScene","lines","colors","red","green","blue","vertsPerBone","boneOrigin","Quaternion","toRotationMatrix","boneAxisX","TransformCoordinates","boneAxisY","boneAxisZ","axisX","axisY","axisZ","linePoints","lineColors","j","getWorldMatrix","instance","changeDisplayMode","mode","wasEnabled","changeDisplayOptions","option"],"sources":["../../../../dev/core/src/Debug/skeletonViewer.ts"],"sourcesContent":["import { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Bone } from \"../Bones/bone\";\r\nimport type { Skeleton } from \"../Bones/skeleton\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { LinesMesh } from \"../Meshes/linesMesh\";\r\nimport { CreateLineSystem } from \"../Meshes/Builders/linesBuilder\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport { DynamicTexture } from \"../Materials/Textures/dynamicTexture\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Effect } from \"../Materials/effect\";\r\n\r\nimport type { ISkeletonViewerOptions, IBoneWeightShaderOptions, ISkeletonMapShaderOptions, ISkeletonMapShaderColorMapKnot } from \"./ISkeletonViewer\";\r\nimport type { Observer } from \"../Misc/observable\";\r\n\r\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder\";\r\nimport { ExtrudeShapeCustom } from \"../Meshes/Builders/shapeBuilder\";\r\n\r\n/**\r\n * Class used to render a debug view of a given skeleton\r\n * @see http://www.babylonjs-playground.com/#1BZJVJ#8\r\n */\r\nexport class SkeletonViewer {\r\n    /** public Display constants BABYLON.SkeletonViewer.DISPLAY_LINES */\r\n    public static readonly DISPLAY_LINES = 0;\r\n    /** public Display constants BABYLON.SkeletonViewer.DISPLAY_SPHERES */\r\n    public static readonly DISPLAY_SPHERES = 1;\r\n    /** public Display constants BABYLON.SkeletonViewer.DISPLAY_SPHERE_AND_SPURS */\r\n    public static readonly DISPLAY_SPHERE_AND_SPURS = 2;\r\n\r\n    /** public static method to create a BoneWeight Shader\r\n     * @param options The constructor options\r\n     * @param scene The scene that the shader is scoped to\r\n     * @returns The created ShaderMaterial\r\n     * @see http://www.babylonjs-playground.com/#1BZJVJ#395\r\n     */\r\n    static CreateBoneWeightShader(options: IBoneWeightShaderOptions, scene: Scene): ShaderMaterial {\r\n        const skeleton: Skeleton = options.skeleton;\r\n        const colorBase: Color3 = options.colorBase ?? Color3.Black();\r\n        const colorZero: Color3 = options.colorZero ?? Color3.Blue();\r\n        const colorQuarter: Color3 = options.colorQuarter ?? Color3.Green();\r\n        const colorHalf: Color3 = options.colorHalf ?? Color3.Yellow();\r\n        const colorFull: Color3 = options.colorFull ?? Color3.Red();\r\n        const targetBoneIndex: number = options.targetBoneIndex ?? 0;\r\n\r\n        Effect.ShadersStore[\"boneWeights:\" + skeleton.name + \"VertexShader\"] = `precision highp float;\r\n\r\n        attribute vec3 position;\r\n        attribute vec2 uv;\r\n\r\n        uniform mat4 view;\r\n        uniform mat4 projection;\r\n        uniform mat4 worldViewProjection;\r\n\r\n        #include<bonesDeclaration>\r\n        #if NUM_BONE_INFLUENCERS == 0\r\n            attribute vec4 matricesIndices;\r\n            attribute vec4 matricesWeights;\r\n        #endif\r\n        #include<bakedVertexAnimationDeclaration>\r\n\r\n        #include<instancesDeclaration>\r\n\r\n        varying vec3 vColor;\r\n\r\n        uniform vec3 colorBase;\r\n        uniform vec3 colorZero;\r\n        uniform vec3 colorQuarter;\r\n        uniform vec3 colorHalf;\r\n        uniform vec3 colorFull;\r\n\r\n        uniform float targetBoneIndex;\r\n\r\n        void main() {\r\n            vec3 positionUpdated = position;\r\n\r\n            #include<instancesVertex>\r\n            #include<bonesVertex>\r\n            #include<bakedVertexAnimation>\r\n\r\n            vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\r\n\r\n            vec3 color = colorBase;\r\n            float totalWeight = 0.;\r\n            if(matricesIndices[0] == targetBoneIndex && matricesWeights[0] > 0.){\r\n                totalWeight += matricesWeights[0];\r\n            }\r\n            if(matricesIndices[1] == targetBoneIndex && matricesWeights[1] > 0.){\r\n                totalWeight += matricesWeights[1];\r\n            }\r\n            if(matricesIndices[2] == targetBoneIndex && matricesWeights[2] > 0.){\r\n                totalWeight += matricesWeights[2];\r\n            }\r\n            if(matricesIndices[3] == targetBoneIndex && matricesWeights[3] > 0.){\r\n                totalWeight += matricesWeights[3];\r\n            }\r\n\r\n            color = mix(color, colorZero, smoothstep(0., 0.25, totalWeight));\r\n            color = mix(color, colorQuarter, smoothstep(0.25, 0.5, totalWeight));\r\n            color = mix(color, colorHalf, smoothstep(0.5, 0.75, totalWeight));\r\n            color = mix(color, colorFull, smoothstep(0.75, 1.0, totalWeight));\r\n            vColor = color;\r\n\r\n        gl_Position = projection * view * worldPos;\r\n        }`;\r\n        Effect.ShadersStore[\"boneWeights:\" + skeleton.name + \"FragmentShader\"] = `\r\n            precision highp float;\r\n            varying vec3 vPosition;\r\n\r\n            varying vec3 vColor;\r\n\r\n            void main() {\r\n                vec4 color = vec4(vColor, 1.0);\r\n                gl_FragColor = color;\r\n            }\r\n        `;\r\n        const shader: ShaderMaterial = new ShaderMaterial(\r\n            \"boneWeight:\" + skeleton.name,\r\n            scene,\r\n            {\r\n                vertex: \"boneWeights:\" + skeleton.name,\r\n                fragment: \"boneWeights:\" + skeleton.name,\r\n            },\r\n            {\r\n                attributes: [\"position\", \"normal\", \"matricesIndices\", \"matricesWeights\"],\r\n                uniforms: [\r\n                    \"world\",\r\n                    \"worldView\",\r\n                    \"worldViewProjection\",\r\n                    \"view\",\r\n                    \"projection\",\r\n                    \"viewProjection\",\r\n                    \"colorBase\",\r\n                    \"colorZero\",\r\n                    \"colorQuarter\",\r\n                    \"colorHalf\",\r\n                    \"colorFull\",\r\n                    \"targetBoneIndex\",\r\n                ],\r\n            }\r\n        );\r\n\r\n        shader.setColor3(\"colorBase\", colorBase);\r\n        shader.setColor3(\"colorZero\", colorZero);\r\n        shader.setColor3(\"colorQuarter\", colorQuarter);\r\n        shader.setColor3(\"colorHalf\", colorHalf);\r\n        shader.setColor3(\"colorFull\", colorFull);\r\n        shader.setFloat(\"targetBoneIndex\", targetBoneIndex);\r\n\r\n        shader.getClassName = (): string => {\r\n            return \"BoneWeightShader\";\r\n        };\r\n\r\n        shader.transparencyMode = Material.MATERIAL_OPAQUE;\r\n\r\n        return shader;\r\n    }\r\n\r\n    /** public static method to create a BoneWeight Shader\r\n     * @param options The constructor options\r\n     * @param scene The scene that the shader is scoped to\r\n     * @returns The created ShaderMaterial\r\n     */\r\n    static CreateSkeletonMapShader(options: ISkeletonMapShaderOptions, scene: Scene) {\r\n        const skeleton: Skeleton = options.skeleton;\r\n        const colorMap: ISkeletonMapShaderColorMapKnot[] = options.colorMap ?? [\r\n            {\r\n                color: new Color3(1, 0.38, 0.18),\r\n                location: 0,\r\n            },\r\n            {\r\n                color: new Color3(0.59, 0.18, 1.0),\r\n                location: 0.2,\r\n            },\r\n            {\r\n                color: new Color3(0.59, 1, 0.18),\r\n                location: 0.4,\r\n            },\r\n            {\r\n                color: new Color3(1, 0.87, 0.17),\r\n                location: 0.6,\r\n            },\r\n            {\r\n                color: new Color3(1, 0.17, 0.42),\r\n                location: 0.8,\r\n            },\r\n            {\r\n                color: new Color3(0.17, 0.68, 1.0),\r\n                location: 1.0,\r\n            },\r\n        ];\r\n\r\n        const bufferWidth: number = skeleton.bones.length + 1;\r\n        const colorMapBuffer: number[] = SkeletonViewer._CreateBoneMapColorBuffer(bufferWidth, colorMap, scene);\r\n        const shader = new ShaderMaterial(\r\n            \"boneWeights:\" + skeleton.name,\r\n            scene,\r\n            {\r\n                vertexSource:\r\n                    `precision highp float;\r\n\r\n            attribute vec3 position;\r\n            attribute vec2 uv;\r\n\r\n            uniform mat4 view;\r\n            uniform mat4 projection;\r\n            uniform mat4 worldViewProjection;\r\n            uniform float colorMap[` +\r\n                    skeleton.bones.length * 4 +\r\n                    `];\r\n\r\n            #include<bonesDeclaration>\r\n            #if NUM_BONE_INFLUENCERS == 0\r\n                attribute vec4 matricesIndices;\r\n                attribute vec4 matricesWeights;\r\n            #endif\r\n            #include<bakedVertexAnimationDeclaration>\r\n            #include<instancesDeclaration>\r\n\r\n            varying vec3 vColor;\r\n\r\n            void main() {\r\n                vec3 positionUpdated = position;\r\n\r\n                #include<instancesVertex>\r\n                #include<bonesVertex>\r\n                #include<bakedVertexAnimation>\r\n\r\n                vec3 color = vec3(0.);\r\n                bool first = true;\r\n\r\n                for (int i = 0; i < 4; i++) {\r\n                    int boneIdx = int(matricesIndices[i]);\r\n                    float boneWgt = matricesWeights[i];\r\n\r\n                    vec3 c = vec3(colorMap[boneIdx * 4 + 0], colorMap[boneIdx * 4 + 1], colorMap[boneIdx * 4 + 2]);\r\n\r\n                    if (boneWgt > 0.) {\r\n                        if (first) {\r\n                            first = false;\r\n                            color = c;\r\n                        } else {\r\n                            color = mix(color, c, boneWgt);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                vColor = color;\r\n\r\n                vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\r\n\r\n                gl_Position = projection * view * worldPos;\r\n            }`,\r\n                fragmentSource: `\r\n            precision highp float;\r\n            varying vec3 vColor;\r\n\r\n            void main() {\r\n                vec4 color = vec4( vColor, 1.0 );\r\n                gl_FragColor = color;\r\n            }\r\n            `,\r\n            },\r\n            {\r\n                attributes: [\"position\", \"normal\", \"matricesIndices\", \"matricesWeights\"],\r\n                uniforms: [\"world\", \"worldView\", \"worldViewProjection\", \"view\", \"projection\", \"viewProjection\", \"colorMap\"],\r\n            }\r\n        );\r\n\r\n        shader.setFloats(\"colorMap\", colorMapBuffer);\r\n\r\n        shader.getClassName = (): string => {\r\n            return \"SkeletonMapShader\";\r\n        };\r\n\r\n        shader.transparencyMode = Material.MATERIAL_OPAQUE;\r\n\r\n        return shader;\r\n    }\r\n\r\n    /** private static method to create a BoneWeight Shader\r\n     * @param size The size of the buffer to create (usually the bone count)\r\n     * @param colorMap The gradient data to generate\r\n     * @param scene The scene that the shader is scoped to\r\n     * @returns an Array of floats from the color gradient values\r\n     */\r\n    private static _CreateBoneMapColorBuffer(size: number, colorMap: ISkeletonMapShaderColorMapKnot[], scene: Scene) {\r\n        const tempGrad = new DynamicTexture(\"temp\", { width: size, height: 1 }, scene, false);\r\n        const ctx = tempGrad.getContext();\r\n        const grad = ctx.createLinearGradient(0, 0, size, 0);\r\n\r\n        colorMap.forEach((stop) => {\r\n            grad.addColorStop(stop.location, stop.color.toHexString());\r\n        });\r\n\r\n        ctx.fillStyle = grad;\r\n        ctx.fillRect(0, 0, size, 1);\r\n        tempGrad.update();\r\n        const buffer: number[] = [];\r\n        const data: Uint8ClampedArray = ctx.getImageData(0, 0, size, 1).data;\r\n        const rUnit = 1 / 255;\r\n        for (let i = 0; i < data.length; i++) {\r\n            buffer.push(data[i] * rUnit);\r\n        }\r\n        tempGrad.dispose();\r\n        return buffer;\r\n    }\r\n\r\n    /** If SkeletonViewer scene scope. */\r\n    private _scene: Scene;\r\n\r\n    /** Gets or sets the color used to render the skeleton */\r\n    public color: Color3 = Color3.White();\r\n\r\n    /** Array of the points of the skeleton fo the line view. */\r\n    private _debugLines = new Array<Array<Vector3>>();\r\n\r\n    /** The SkeletonViewers Mesh. */\r\n    private _debugMesh: Nullable<LinesMesh>;\r\n\r\n    /** The local axes Meshes. */\r\n    private _localAxes: Nullable<LinesMesh> = null;\r\n\r\n    /** If SkeletonViewer is enabled. */\r\n    private _isEnabled = true;\r\n\r\n    /** If SkeletonViewer is ready. */\r\n    private _ready: boolean;\r\n\r\n    /** SkeletonViewer render observable. */\r\n    private _obs: Nullable<Observer<Scene>> = null;\r\n\r\n    /** The Utility Layer to render the gizmos in. */\r\n    private _utilityLayer: Nullable<UtilityLayerRenderer>;\r\n\r\n    private _boneIndices: Set<number>;\r\n\r\n    /** Gets the Scene. */\r\n    get scene(): Scene {\r\n        return this._scene;\r\n    }\r\n    /** Gets the utilityLayer. */\r\n    get utilityLayer(): Nullable<UtilityLayerRenderer> {\r\n        return this._utilityLayer;\r\n    }\r\n    /** Checks Ready Status. */\r\n    get isReady(): Boolean {\r\n        return this._ready;\r\n    }\r\n    /** Sets Ready Status. */\r\n    set ready(value: boolean) {\r\n        this._ready = value;\r\n    }\r\n    /** Gets the debugMesh */\r\n    get debugMesh(): Nullable<AbstractMesh> | Nullable<LinesMesh> {\r\n        return this._debugMesh;\r\n    }\r\n    /** Sets the debugMesh */\r\n    set debugMesh(value: Nullable<AbstractMesh> | Nullable<LinesMesh>) {\r\n        this._debugMesh = value as any;\r\n    }\r\n    /** Gets the displayMode */\r\n    get displayMode(): number {\r\n        return this.options.displayMode || SkeletonViewer.DISPLAY_LINES;\r\n    }\r\n    /** Sets the displayMode */\r\n    set displayMode(value: number) {\r\n        if (value > SkeletonViewer.DISPLAY_SPHERE_AND_SPURS) {\r\n            value = SkeletonViewer.DISPLAY_LINES;\r\n        }\r\n        this.options.displayMode = value;\r\n    }\r\n    /**\r\n     * Creates a new SkeletonViewer\r\n     * @param skeleton defines the skeleton to render\r\n     * @param mesh defines the mesh attached to the skeleton\r\n     * @param scene defines the hosting scene\r\n     * @param autoUpdateBonesMatrices defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)\r\n     * @param renderingGroupId defines the rendering group id to use with the viewer\r\n     * @param options All of the extra constructor options for the SkeletonViewer\r\n     */\r\n    constructor(\r\n        /** defines the skeleton to render */\r\n        public skeleton: Skeleton,\r\n        /** defines the mesh attached to the skeleton */\r\n        public mesh: AbstractMesh,\r\n        /** The Scene scope*/\r\n        scene: Scene,\r\n        /** defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)  */\r\n        public autoUpdateBonesMatrices: boolean = true,\r\n        /** defines the rendering group id to use with the viewer */\r\n        public renderingGroupId: number = 3,\r\n        /** is the options for the viewer */\r\n        public options: Partial<ISkeletonViewerOptions> = {}\r\n    ) {\r\n        this._scene = scene;\r\n        this._ready = false;\r\n\r\n        //Defaults\r\n        options.pauseAnimations = options.pauseAnimations ?? true;\r\n        options.returnToRest = options.returnToRest ?? false;\r\n        options.displayMode = options.displayMode ?? SkeletonViewer.DISPLAY_LINES;\r\n        options.displayOptions = options.displayOptions ?? {};\r\n        options.displayOptions.midStep = options.displayOptions.midStep ?? 0.235;\r\n        options.displayOptions.midStepFactor = options.displayOptions.midStepFactor ?? 0.155;\r\n        options.displayOptions.sphereBaseSize = options.displayOptions.sphereBaseSize ?? 0.15;\r\n        options.displayOptions.sphereScaleUnit = options.displayOptions.sphereScaleUnit ?? 2;\r\n        options.displayOptions.sphereFactor = options.displayOptions.sphereFactor ?? 0.865;\r\n        options.displayOptions.spurFollowsChild = options.displayOptions.spurFollowsChild ?? false;\r\n        options.displayOptions.showLocalAxes = options.displayOptions.showLocalAxes ?? false;\r\n        options.displayOptions.localAxesSize = options.displayOptions.localAxesSize ?? 0.075;\r\n        options.computeBonesUsingShaders = options.computeBonesUsingShaders ?? true;\r\n        options.useAllBones = options.useAllBones ?? true;\r\n\r\n        const initialMeshBoneIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);\r\n        const initialMeshBoneWeights = mesh.getVerticesData(VertexBuffer.MatricesWeightsKind);\r\n        this._boneIndices = new Set();\r\n\r\n        if (!options.useAllBones) {\r\n            if (initialMeshBoneIndices && initialMeshBoneWeights) {\r\n                for (let i = 0; i < initialMeshBoneIndices.length; ++i) {\r\n                    const index = initialMeshBoneIndices[i],\r\n                        weight = initialMeshBoneWeights[i];\r\n                    if (weight !== 0) {\r\n                        this._boneIndices.add(index);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /* Create Utility Layer */\r\n        this._utilityLayer = new UtilityLayerRenderer(this._scene, false);\r\n        this._utilityLayer.pickUtilitySceneFirst = false;\r\n        this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = true;\r\n\r\n        let displayMode = this.options.displayMode || 0;\r\n        if (displayMode > SkeletonViewer.DISPLAY_SPHERE_AND_SPURS) {\r\n            displayMode = SkeletonViewer.DISPLAY_LINES;\r\n        }\r\n        this.displayMode = displayMode;\r\n        //Prep the Systems\r\n        this.update();\r\n        this._bindObs();\r\n    }\r\n\r\n    /** The Dynamic bindings for the update functions */\r\n    private _bindObs(): void {\r\n        switch (this.displayMode) {\r\n            case SkeletonViewer.DISPLAY_LINES: {\r\n                this._obs = this.scene.onBeforeRenderObservable.add(() => {\r\n                    this._displayLinesUpdate();\r\n                });\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Update the viewer to sync with current skeleton state, only used to manually update. */\r\n    public update(): void {\r\n        switch (this.displayMode) {\r\n            case SkeletonViewer.DISPLAY_LINES: {\r\n                this._displayLinesUpdate();\r\n                break;\r\n            }\r\n            case SkeletonViewer.DISPLAY_SPHERES: {\r\n                this._buildSpheresAndSpurs(true);\r\n                break;\r\n            }\r\n            case SkeletonViewer.DISPLAY_SPHERE_AND_SPURS: {\r\n                this._buildSpheresAndSpurs(false);\r\n                break;\r\n            }\r\n        }\r\n\r\n        this._buildLocalAxes();\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if the viewer is enabled */\r\n    public set isEnabled(value: boolean) {\r\n        if (this.isEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._isEnabled = value;\r\n\r\n        if (this.debugMesh) {\r\n            this.debugMesh.setEnabled(value);\r\n        }\r\n\r\n        if (value && !this._obs) {\r\n            this._bindObs();\r\n        } else if (!value && this._obs) {\r\n            this.scene.onBeforeRenderObservable.remove(this._obs);\r\n            this._obs = null;\r\n        }\r\n    }\r\n\r\n    public get isEnabled(): boolean {\r\n        return this._isEnabled;\r\n    }\r\n\r\n    private _getBonePosition(position: Vector3, bone: Bone, meshMat: Matrix, x = 0, y = 0, z = 0): void {\r\n        const tmat = TmpVectors.Matrix[0];\r\n        const parentBone = bone.getParent();\r\n        tmat.copyFrom(bone.getLocalMatrix());\r\n\r\n        if (x !== 0 || y !== 0 || z !== 0) {\r\n            const tmat2 = TmpVectors.Matrix[1];\r\n            Matrix.IdentityToRef(tmat2);\r\n            tmat2.setTranslationFromFloats(x, y, z);\r\n            tmat2.multiplyToRef(tmat, tmat);\r\n        }\r\n\r\n        if (parentBone) {\r\n            tmat.multiplyToRef(parentBone.getAbsoluteMatrix(), tmat);\r\n        }\r\n\r\n        tmat.multiplyToRef(meshMat, tmat);\r\n\r\n        position.x = tmat.m[12];\r\n        position.y = tmat.m[13];\r\n        position.z = tmat.m[14];\r\n    }\r\n\r\n    private _getLinesForBonesWithLength(bones: Bone[], meshMat: Matrix): void {\r\n        const len = bones.length;\r\n\r\n        const mesh = this.mesh;\r\n        const meshPos = mesh.position;\r\n        let idx = 0;\r\n        for (let i = 0; i < len; i++) {\r\n            const bone = bones[i];\r\n            let points = this._debugLines[idx];\r\n\r\n            if (bone._index === -1 || (!this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones)) {\r\n                continue;\r\n            }\r\n            if (!points) {\r\n                points = [Vector3.Zero(), Vector3.Zero()];\r\n                this._debugLines[idx] = points;\r\n            }\r\n            this._getBonePosition(points[0], bone, meshMat);\r\n            this._getBonePosition(points[1], bone, meshMat, 0, bone.length, 0);\r\n            points[0].subtractInPlace(meshPos);\r\n            points[1].subtractInPlace(meshPos);\r\n            idx++;\r\n        }\r\n    }\r\n\r\n    private _getLinesForBonesNoLength(bones: Bone[]): void {\r\n        const len = bones.length;\r\n        let boneNum = 0;\r\n\r\n        const mesh = this.mesh;\r\n        const meshPos = mesh.position;\r\n        for (let i = len - 1; i >= 0; i--) {\r\n            const childBone = bones[i];\r\n            const parentBone = childBone.getParent();\r\n            if (!parentBone || (!this._boneIndices.has(childBone.getIndex()) && !this.options.useAllBones)) {\r\n                continue;\r\n            }\r\n            let points = this._debugLines[boneNum];\r\n            if (!points) {\r\n                points = [Vector3.Zero(), Vector3.Zero()];\r\n                this._debugLines[boneNum] = points;\r\n            }\r\n            childBone.getAbsolutePositionToRef(mesh, points[0]);\r\n            parentBone.getAbsolutePositionToRef(mesh, points[1]);\r\n            points[0].subtractInPlace(meshPos);\r\n            points[1].subtractInPlace(meshPos);\r\n            boneNum++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * function to revert the mesh and scene back to the initial state.\r\n     * @param animationState\r\n     */\r\n    private _revert(animationState: boolean): void {\r\n        if (this.options.pauseAnimations) {\r\n            this.scene.animationsEnabled = animationState;\r\n            this.utilityLayer!.utilityLayerScene!.animationsEnabled = animationState;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * function to get the absolute bind pose of a bone by accumulating transformations up the bone hierarchy.\r\n     * @param bone\r\n     * @param matrix\r\n     */\r\n    private _getAbsoluteBindPoseToRef(bone: Nullable<Bone>, matrix: Matrix) {\r\n        if (bone === null || bone._index === -1) {\r\n            matrix.copyFrom(Matrix.Identity());\r\n            return;\r\n        }\r\n\r\n        this._getAbsoluteBindPoseToRef(bone.getParent(), matrix);\r\n        bone.getBindMatrix().multiplyToRef(matrix, matrix);\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * function to build and bind sphere joint points and spur bone representations.\r\n     * @param spheresOnly\r\n     */\r\n    private _buildSpheresAndSpurs(spheresOnly = true): void {\r\n        if (this._debugMesh) {\r\n            this._debugMesh.dispose();\r\n            this._debugMesh = null;\r\n            this.ready = false;\r\n        }\r\n\r\n        this._ready = false;\r\n        const utilityLayerScene = this.utilityLayer?.utilityLayerScene!;\r\n        const bones: Bone[] = this.skeleton.bones;\r\n        const spheres: Array<[Mesh, Bone]> = [];\r\n        const spurs: Mesh[] = [];\r\n\r\n        const animationState = this.scene.animationsEnabled;\r\n\r\n        try {\r\n            if (this.options.pauseAnimations) {\r\n                this.scene.animationsEnabled = false;\r\n                utilityLayerScene.animationsEnabled = false;\r\n            }\r\n\r\n            if (this.options.returnToRest) {\r\n                this.skeleton.returnToRest();\r\n            }\r\n\r\n            if (this.autoUpdateBonesMatrices) {\r\n                this.skeleton.computeAbsoluteMatrices();\r\n            }\r\n\r\n            let longestBoneLength = Number.NEGATIVE_INFINITY;\r\n            const displayOptions = this.options.displayOptions || {};\r\n\r\n            for (let i = 0; i < bones.length; i++) {\r\n                const bone = bones[i];\r\n\r\n                if (bone._index === -1 || (!this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones)) {\r\n                    continue;\r\n                }\r\n\r\n                const boneAbsoluteBindPoseTransform = new Matrix();\r\n                this._getAbsoluteBindPoseToRef(bone, boneAbsoluteBindPoseTransform);\r\n\r\n                const anchorPoint = new Vector3();\r\n\r\n                boneAbsoluteBindPoseTransform.decompose(undefined, undefined, anchorPoint);\r\n\r\n                bone.children.forEach((bc) => {\r\n                    const childAbsoluteBindPoseTransform: Matrix = new Matrix();\r\n                    bc.getLocalMatrix().multiplyToRef(boneAbsoluteBindPoseTransform, childAbsoluteBindPoseTransform);\r\n                    const childPoint = new Vector3();\r\n                    childAbsoluteBindPoseTransform.decompose(undefined, undefined, childPoint);\r\n                    const distanceFromParent = Vector3.Distance(anchorPoint, childPoint);\r\n                    if (distanceFromParent > longestBoneLength) {\r\n                        longestBoneLength = distanceFromParent;\r\n                    }\r\n                    if (spheresOnly) {\r\n                        return;\r\n                    }\r\n\r\n                    const dir = childPoint.clone().subtract(anchorPoint.clone());\r\n                    const h = dir.length();\r\n                    const up = dir.normalize().scale(h);\r\n\r\n                    const midStep = displayOptions.midStep || 0.165;\r\n                    const midStepFactor = displayOptions.midStepFactor || 0.215;\r\n\r\n                    const up0 = up.scale(midStep);\r\n\r\n                    const spur = ExtrudeShapeCustom(\r\n                        \"skeletonViewer\",\r\n                        {\r\n                            shape: [new Vector3(1, -1, 0), new Vector3(1, 1, 0), new Vector3(-1, 1, 0), new Vector3(-1, -1, 0), new Vector3(1, -1, 0)],\r\n                            path: [Vector3.Zero(), up0, up],\r\n                            scaleFunction: (i: number) => {\r\n                                switch (i) {\r\n                                    case 0:\r\n                                    case 2:\r\n                                        return 0;\r\n                                    case 1:\r\n                                        return h * midStepFactor;\r\n                                }\r\n                                return 0;\r\n                            },\r\n                            sideOrientation: Mesh.DEFAULTSIDE,\r\n                            updatable: false,\r\n                        },\r\n                        utilityLayerScene\r\n                    );\r\n\r\n                    const numVertices = spur.getTotalVertices();\r\n                    const mwk: number[] = [],\r\n                        mik: number[] = [];\r\n\r\n                    for (let i = 0; i < numVertices; i++) {\r\n                        mwk.push(1, 0, 0, 0);\r\n\r\n                        // Select verts at end of spur (ie vert 10 to 14) and bind to child\r\n                        // bone if spurFollowsChild is enabled.\r\n                        if (displayOptions.spurFollowsChild && i > 9) {\r\n                            mik.push(bc.getIndex(), 0, 0, 0);\r\n                        } else {\r\n                            mik.push(bone.getIndex(), 0, 0, 0);\r\n                        }\r\n                    }\r\n\r\n                    spur.position = anchorPoint.clone();\r\n\r\n                    spur.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\r\n                    spur.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\r\n                    spur.convertToFlatShadedMesh();\r\n\r\n                    spurs.push(spur);\r\n                });\r\n\r\n                const sphereBaseSize = displayOptions.sphereBaseSize || 0.2;\r\n\r\n                const sphere = CreateSphere(\r\n                    \"skeletonViewer\",\r\n                    {\r\n                        segments: 6,\r\n                        diameter: sphereBaseSize,\r\n                        updatable: true,\r\n                    },\r\n                    utilityLayerScene\r\n                );\r\n\r\n                const numVertices = sphere.getTotalVertices();\r\n\r\n                const mwk: number[] = [],\r\n                    mik: number[] = [];\r\n\r\n                for (let i = 0; i < numVertices; i++) {\r\n                    mwk.push(1, 0, 0, 0);\r\n                    mik.push(bone.getIndex(), 0, 0, 0);\r\n                }\r\n\r\n                sphere.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\r\n                sphere.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\r\n\r\n                sphere.position = anchorPoint.clone();\r\n                spheres.push([sphere, bone]);\r\n            }\r\n\r\n            const sphereScaleUnit = displayOptions.sphereScaleUnit || 2;\r\n            const sphereFactor = displayOptions.sphereFactor || 0.85;\r\n\r\n            const meshes = [];\r\n            for (let i = 0; i < spheres.length; i++) {\r\n                const [sphere, bone] = spheres[i];\r\n                const scale = 1 / (sphereScaleUnit / longestBoneLength);\r\n\r\n                let _stepsOut = 0;\r\n                let _b = bone;\r\n\r\n                while (_b.getParent() && (_b.getParent() as Bone).getIndex() !== -1) {\r\n                    _stepsOut++;\r\n                    _b = _b.getParent() as Bone;\r\n                }\r\n                sphere.scaling.scaleInPlace(scale * Math.pow(sphereFactor, _stepsOut));\r\n                meshes.push(sphere);\r\n            }\r\n\r\n            this.debugMesh = Mesh.MergeMeshes(meshes.concat(spurs), true, true);\r\n            if (this.debugMesh) {\r\n                this.debugMesh.renderingGroupId = this.renderingGroupId;\r\n                this.debugMesh.skeleton = this.skeleton;\r\n                this.debugMesh.parent = this.mesh;\r\n                this.debugMesh.computeBonesUsingShaders = this.options.computeBonesUsingShaders ?? true;\r\n                this.debugMesh.alwaysSelectAsActiveMesh = true;\r\n            }\r\n\r\n            const light = this.utilityLayer!._getSharedGizmoLight();\r\n            light.intensity = 0.7;\r\n\r\n            this._revert(animationState);\r\n            this.ready = true;\r\n        } catch (err) {\r\n            console.error(err);\r\n            this._revert(animationState);\r\n            this.dispose();\r\n        }\r\n    }\r\n\r\n    private _buildLocalAxes(): void {\r\n        if (this._localAxes) {\r\n            this._localAxes.dispose();\r\n        }\r\n\r\n        this._localAxes = null;\r\n\r\n        const displayOptions = this.options.displayOptions || {};\r\n\r\n        if (!displayOptions.showLocalAxes) {\r\n            return;\r\n        }\r\n\r\n        const targetScene = this._utilityLayer!.utilityLayerScene;\r\n        const size = displayOptions.localAxesSize || 0.075;\r\n        const lines = [];\r\n        const colors = [];\r\n        const red = new Color4(1, 0, 0, 1);\r\n        const green = new Color4(0, 1, 0, 1);\r\n        const blue = new Color4(0, 0, 1, 1);\r\n\r\n        const mwk: number[] = [];\r\n        const mik: number[] = [];\r\n        const vertsPerBone = 6;\r\n\r\n        for (const i in this.skeleton.bones) {\r\n            const bone = this.skeleton.bones[i];\r\n\r\n            if (bone._index === -1 || (!this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones)) {\r\n                continue;\r\n            }\r\n\r\n            const boneAbsoluteBindPoseTransform = new Matrix();\r\n            const boneOrigin = new Vector3();\r\n\r\n            this._getAbsoluteBindPoseToRef(bone, boneAbsoluteBindPoseTransform);\r\n            boneAbsoluteBindPoseTransform.decompose(undefined, TmpVectors.Quaternion[0], boneOrigin);\r\n\r\n            const m = new Matrix();\r\n            TmpVectors.Quaternion[0].toRotationMatrix(m);\r\n\r\n            const boneAxisX = Vector3.TransformCoordinates(new Vector3(0 + size, 0, 0), m);\r\n            const boneAxisY = Vector3.TransformCoordinates(new Vector3(0, 0 + size, 0), m);\r\n            const boneAxisZ = Vector3.TransformCoordinates(new Vector3(0, 0, 0 + size), m);\r\n\r\n            const axisX = [boneOrigin, boneOrigin.add(boneAxisX)];\r\n            const axisY = [boneOrigin, boneOrigin.add(boneAxisY)];\r\n            const axisZ = [boneOrigin, boneOrigin.add(boneAxisZ)];\r\n\r\n            const linePoints = [axisX, axisY, axisZ];\r\n            const lineColors = [\r\n                [red, red],\r\n                [green, green],\r\n                [blue, blue],\r\n            ];\r\n\r\n            lines.push(...linePoints);\r\n            colors.push(...lineColors);\r\n\r\n            for (let j = 0; j < vertsPerBone; j++) {\r\n                mwk.push(1, 0, 0, 0);\r\n                mik.push(bone.getIndex(), 0, 0, 0);\r\n            }\r\n        }\r\n\r\n        this._localAxes = CreateLineSystem(\"localAxes\", { lines: lines, colors: colors, updatable: true }, targetScene);\r\n        this._localAxes.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\r\n        this._localAxes.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\r\n        this._localAxes.skeleton = this.skeleton;\r\n        this._localAxes.renderingGroupId = this.renderingGroupId + 1;\r\n        this._localAxes.parent = this.mesh;\r\n        this._localAxes.computeBonesUsingShaders = this.options.computeBonesUsingShaders ?? true;\r\n    }\r\n\r\n    /** Update the viewer to sync with current skeleton state, only used for the line display. */\r\n    private _displayLinesUpdate(): void {\r\n        if (!this._utilityLayer) {\r\n            return;\r\n        }\r\n\r\n        if (this.autoUpdateBonesMatrices) {\r\n            this.skeleton.computeAbsoluteMatrices();\r\n        }\r\n\r\n        if (this.skeleton.bones[0].length === undefined) {\r\n            this._getLinesForBonesNoLength(this.skeleton.bones);\r\n        } else {\r\n            this._getLinesForBonesWithLength(this.skeleton.bones, this.mesh.getWorldMatrix());\r\n        }\r\n\r\n        const targetScene = this._utilityLayer.utilityLayerScene;\r\n\r\n        if (targetScene) {\r\n            if (!this._debugMesh) {\r\n                this._debugMesh = CreateLineSystem(\"\", { lines: this._debugLines, updatable: true, instance: null }, targetScene);\r\n                this._debugMesh.renderingGroupId = this.renderingGroupId;\r\n            } else {\r\n                CreateLineSystem(\"\", { lines: this._debugLines, updatable: true, instance: this._debugMesh }, targetScene);\r\n            }\r\n            this._debugMesh.position.copyFrom(this.mesh.position);\r\n            this._debugMesh.color = this.color;\r\n        }\r\n    }\r\n    /** Changes the displayMode of the skeleton viewer\r\n     * @param mode The displayMode numerical value\r\n     */\r\n    public changeDisplayMode(mode: number): void {\r\n        const wasEnabled = this.isEnabled ? true : false;\r\n        if (this.displayMode !== mode) {\r\n            this.isEnabled = false;\r\n            if (this._debugMesh) {\r\n                this._debugMesh.dispose();\r\n                this._debugMesh = null;\r\n                this.ready = false;\r\n            }\r\n            this.displayMode = mode;\r\n\r\n            this.update();\r\n            this._bindObs();\r\n            this.isEnabled = wasEnabled;\r\n        }\r\n    }\r\n\r\n    /** Sets a display option of the skeleton viewer\r\n     *\r\n     * | Option           | Type    | Default | Description |\r\n     * | ---------------- | ------- | ------- | ----------- |\r\n     * | midStep          | float   | 0.235   | A percentage between a bone and its child that determines the widest part of a spur. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\r\n     * | midStepFactor    | float   | 0.15    | Mid step width expressed as a factor of the length. A value of 0.5 makes the spur width half of the spur length. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\r\n     * | sphereBaseSize   | float   | 2       | Sphere base size. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\r\n     * | sphereScaleUnit  | float   | 0.865   | Sphere scale factor used to scale spheres in relation to the longest bone. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\r\n     * | spurFollowsChild | boolean | false   | Whether a spur should attach its far end to the child bone. |\r\n     * | showLocalAxes    | boolean | false   | Displays local axes on all bones. |\r\n     * | localAxesSize    | float   | 0.075   | Determines the length of each local axis. |\r\n     *\r\n     * @param option String of the option name\r\n     * @param value The numerical option value\r\n     */\r\n    public changeDisplayOptions(option: string, value: number): void {\r\n        const wasEnabled = this.isEnabled ? true : false;\r\n        (this.options.displayOptions as any)[option] = value;\r\n        this.isEnabled = false;\r\n        if (this._debugMesh) {\r\n            this._debugMesh.dispose();\r\n            this._debugMesh = null;\r\n            this.ready = false;\r\n        }\r\n        this.update();\r\n        this._bindObs();\r\n        this.isEnabled = wasEnabled;\r\n    }\r\n\r\n    /** Release associated resources */\r\n    public dispose(): void {\r\n        this.isEnabled = false;\r\n        if (this._debugMesh) {\r\n            this._debugMesh.dispose();\r\n            this._debugMesh = null;\r\n        }\r\n\r\n        if (this._utilityLayer) {\r\n            this._utilityLayer.dispose();\r\n            this._utilityLayer = null;\r\n        }\r\n\r\n        this.ready = false;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}