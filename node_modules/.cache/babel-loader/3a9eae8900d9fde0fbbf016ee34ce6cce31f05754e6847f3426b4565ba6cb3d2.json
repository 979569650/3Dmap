{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { Matrix, Quaternion, Vector3 } from \"../../../../Maths/math.vector.js\";\nimport { InstantiateBaseBlock } from \"./instantiateBaseBlock.js\";\n/**\n * Block used to clone geometry along a line\n */\nexport class InstantiateLinearBlock extends InstantiateBaseBlock {\n  /**\n   * Create a new Instantiate Linear Block\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    // Direction is magnitude per step\n    this.registerInput(\"direction\", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(1, 0, 0));\n    // Rotation is magnitude per step\n    this.registerInput(\"rotation\", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(0, 0, 0));\n    // Scaling is magnitude per step\n    this.registerInput(\"scaling\", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(0, 0, 0));\n    this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"InstantiateLinearBlock\";\n  }\n  /**\n   * Gets the direction input component\n   */\n  get direction() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the rotation input component\n   */\n  get rotation() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the scaling input component\n   */\n  get scaling() {\n    return this._inputs[4];\n  }\n  _buildBlock(state) {\n    const func = state => {\n      state.pushExecutionContext(this);\n      state.pushInstancingContext(this);\n      const iterationCount = this.count.getConnectedValue(state);\n      const additionalVertexData = [];\n      const transformMatrix = Matrix.Identity();\n      const transformOffset = Vector3.Zero();\n      const rotationOffset = Vector3.Zero();\n      const scaleOffset = Vector3.Zero();\n      for (this._currentIndex = 0; this._currentIndex < iterationCount; this._currentIndex++) {\n        const instanceGeometry = this.instance.getConnectedValue(state);\n        if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {\n          continue;\n        }\n        // Clone the instance\n        const clone = instanceGeometry.clone();\n        const direction = this.direction.getConnectedValue(state);\n        const rotation = this.rotation.getConnectedValue(state);\n        const scale = state.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);\n        transformOffset.copyFrom(direction.clone().scale(this._currentIndex));\n        rotationOffset.copyFrom(rotation.clone().scale(this._currentIndex));\n        scaleOffset.copyFrom(scale.clone().scale(this._currentIndex));\n        scaleOffset.addInPlaceFromFloats(1, 1, 1);\n        Matrix.ComposeToRef(scaleOffset, Quaternion.FromEulerAngles(rotationOffset.x, rotationOffset.y, rotationOffset.z), transformOffset, transformMatrix);\n        state._instantiateWithMatrix(clone, transformMatrix, additionalVertexData);\n      }\n      // Merge\n      if (additionalVertexData.length) {\n        if (additionalVertexData.length === 1) {\n          this._vertexData = additionalVertexData[0];\n        } else {\n          // We do not merge the main one as user can use a merge node if wanted\n          const main = additionalVertexData.splice(0, 1)[0];\n          this._vertexData = main.merge(additionalVertexData, true, false, true, true);\n        }\n      }\n      state.restoreExecutionContext();\n      state.restoreInstancingContext();\n      // Storage\n      return this._vertexData;\n    };\n    if (this.evaluateContext) {\n      this.output._storedFunction = func;\n    } else {\n      this.output._storedFunction = null;\n      this.output._storedValue = func(state);\n    }\n  }\n}\nRegisterClass(\"BABYLON.InstantiateLinearBlock\", InstantiateLinearBlock);","map":{"version":3,"names":["RegisterClass","NodeGeometryBlockConnectionPointTypes","Matrix","Quaternion","Vector3","InstantiateBaseBlock","InstantiateLinearBlock","constructor","name","registerInput","scaling","acceptedConnectionPointTypes","push","Float","getClassName","direction","_inputs","rotation","_buildBlock","state","func","pushExecutionContext","pushInstancingContext","iterationCount","count","getConnectedValue","additionalVertexData","transformMatrix","Identity","transformOffset","Zero","rotationOffset","scaleOffset","_currentIndex","instanceGeometry","instance","positions","length","clone","scale","adaptInput","OneReadOnly","copyFrom","addInPlaceFromFloats","ComposeToRef","FromEulerAngles","x","y","z","_instantiateWithMatrix","_vertexData","main","splice","merge","restoreExecutionContext","restoreInstancingContext","evaluateContext","output","_storedFunction","_storedValue"],"sources":["../../../../../../../dev/core/src/Meshes/Node/Blocks/Instances/instantiateLinearBlock.ts"],"sourcesContent":["import type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { Matrix, Quaternion, Vector3 } from \"../../../../Maths/math.vector\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport type { VertexData } from \"core/Meshes/mesh.vertexData\";\r\nimport { InstantiateBaseBlock } from \"./instantiateBaseBlock\";\r\n\r\n/**\r\n * Block used to clone geometry along a line\r\n */\r\nexport class InstantiateLinearBlock extends InstantiateBaseBlock {\r\n    /**\r\n     * Create a new Instantiate Linear Block\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n        // Direction is magnitude per step\r\n        this.registerInput(\"direction\", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(1, 0, 0));\r\n\r\n        // Rotation is magnitude per step\r\n        this.registerInput(\"rotation\", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(0, 0, 0));\r\n\r\n        // Scaling is magnitude per step\r\n        this.registerInput(\"scaling\", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(0, 0, 0));\r\n        this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"InstantiateLinearBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the direction input component\r\n     */\r\n    public get direction(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the rotation input component\r\n     */\r\n    public get rotation(): NodeGeometryConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the scaling input component\r\n     */\r\n    public get scaling(): NodeGeometryConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            state.pushExecutionContext(this);\r\n            state.pushInstancingContext(this);\r\n\r\n            const iterationCount = this.count.getConnectedValue(state) as number;\r\n\r\n            const additionalVertexData: VertexData[] = [];\r\n\r\n            const transformMatrix = Matrix.Identity();\r\n            const transformOffset = Vector3.Zero();\r\n            const rotationOffset = Vector3.Zero();\r\n            const scaleOffset = Vector3.Zero();\r\n\r\n            for (this._currentIndex = 0; this._currentIndex < iterationCount; this._currentIndex++) {\r\n                const instanceGeometry = this.instance.getConnectedValue(state) as VertexData;\r\n\r\n                if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {\r\n                    continue;\r\n                }\r\n                // Clone the instance\r\n                const clone = instanceGeometry.clone();\r\n\r\n                const direction = this.direction.getConnectedValue(state) as Vector3;\r\n                const rotation = this.rotation.getConnectedValue(state) as Vector3;\r\n                const scale = state.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);\r\n\r\n                transformOffset.copyFrom(direction.clone().scale(this._currentIndex));\r\n                rotationOffset.copyFrom(rotation.clone().scale(this._currentIndex));\r\n                scaleOffset.copyFrom(scale.clone().scale(this._currentIndex));\r\n                scaleOffset.addInPlaceFromFloats(1, 1, 1);\r\n\r\n                Matrix.ComposeToRef(scaleOffset, Quaternion.FromEulerAngles(rotationOffset.x, rotationOffset.y, rotationOffset.z), transformOffset, transformMatrix);\r\n\r\n                state._instantiateWithMatrix(clone, transformMatrix, additionalVertexData);\r\n            }\r\n\r\n            // Merge\r\n            if (additionalVertexData.length) {\r\n                if (additionalVertexData.length === 1) {\r\n                    this._vertexData = additionalVertexData[0];\r\n                } else {\r\n                    // We do not merge the main one as user can use a merge node if wanted\r\n                    const main = additionalVertexData.splice(0, 1)[0];\r\n                    this._vertexData = main.merge(additionalVertexData, true, false, true, true);\r\n                }\r\n            }\r\n\r\n            state.restoreExecutionContext();\r\n            state.restoreInstancingContext();\r\n            // Storage\r\n            return this._vertexData;\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.output._storedFunction = func;\r\n        } else {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = func(state);\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.InstantiateLinearBlock\", InstantiateLinearBlock);\r\n"],"mappings":";AACA,SAASA,aAAa,QAAQ,+BAA6B;AAC3D,SAASC,qCAAqC,QAAQ,iDAA+C;AACrG,SAASC,MAAM,EAAEC,UAAU,EAAEC,OAAO,QAAQ,kCAAgC;AAG5E,SAASC,oBAAoB,QAAQ,2BAAyB;AAE9D;;;AAGA,OAAM,MAAOC,sBAAuB,SAAQD,oBAAoB;EAC5D;;;;EAIAE,YAAmBC,IAAY;IAC3B,KAAK,CAACA,IAAI,CAAC;IACX;IACA,IAAI,CAACC,aAAa,CAAC,WAAW,EAAER,qCAAqC,CAACG,OAAO,EAAE,IAAI,EAAE,IAAIA,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAE1G;IACA,IAAI,CAACK,aAAa,CAAC,UAAU,EAAER,qCAAqC,CAACG,OAAO,EAAE,IAAI,EAAE,IAAIA,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAEzG;IACA,IAAI,CAACK,aAAa,CAAC,SAAS,EAAER,qCAAqC,CAACG,OAAO,EAAE,IAAI,EAAE,IAAIA,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IACxG,IAAI,CAACM,OAAO,CAACC,4BAA4B,CAACC,IAAI,CAACX,qCAAqC,CAACY,KAAK,CAAC;EAC/F;EAEA;;;;EAIOC,YAAYA,CAAA;IACf,OAAO,wBAAwB;EACnC;EAEA;;;EAGA,IAAWC,SAASA,CAAA;IAChB,OAAO,IAAI,CAACC,OAAO,CAAC,CAAC,CAAC;EAC1B;EAEA;;;EAGA,IAAWC,QAAQA,CAAA;IACf,OAAO,IAAI,CAACD,OAAO,CAAC,CAAC,CAAC;EAC1B;EAEA;;;EAGA,IAAWN,OAAOA,CAAA;IACd,OAAO,IAAI,CAACM,OAAO,CAAC,CAAC,CAAC;EAC1B;EAEUE,WAAWA,CAACC,KAA6B;IAC/C,MAAMC,IAAI,GAAID,KAA6B,IAAI;MAC3CA,KAAK,CAACE,oBAAoB,CAAC,IAAI,CAAC;MAChCF,KAAK,CAACG,qBAAqB,CAAC,IAAI,CAAC;MAEjC,MAAMC,cAAc,GAAG,IAAI,CAACC,KAAK,CAACC,iBAAiB,CAACN,KAAK,CAAW;MAEpE,MAAMO,oBAAoB,GAAiB,EAAE;MAE7C,MAAMC,eAAe,GAAGzB,MAAM,CAAC0B,QAAQ,EAAE;MACzC,MAAMC,eAAe,GAAGzB,OAAO,CAAC0B,IAAI,EAAE;MACtC,MAAMC,cAAc,GAAG3B,OAAO,CAAC0B,IAAI,EAAE;MACrC,MAAME,WAAW,GAAG5B,OAAO,CAAC0B,IAAI,EAAE;MAElC,KAAK,IAAI,CAACG,aAAa,GAAG,CAAC,EAAE,IAAI,CAACA,aAAa,GAAGV,cAAc,EAAE,IAAI,CAACU,aAAa,EAAE,EAAE;QACpF,MAAMC,gBAAgB,GAAG,IAAI,CAACC,QAAQ,CAACV,iBAAiB,CAACN,KAAK,CAAe;QAE7E,IAAI,CAACe,gBAAgB,IAAI,CAACA,gBAAgB,CAACE,SAAS,IAAIF,gBAAgB,CAACE,SAAS,CAACC,MAAM,KAAK,CAAC,EAAE;UAC7F;;QAEJ;QACA,MAAMC,KAAK,GAAGJ,gBAAgB,CAACI,KAAK,EAAE;QAEtC,MAAMvB,SAAS,GAAG,IAAI,CAACA,SAAS,CAACU,iBAAiB,CAACN,KAAK,CAAY;QACpE,MAAMF,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAACQ,iBAAiB,CAACN,KAAK,CAAY;QAClE,MAAMoB,KAAK,GAAGpB,KAAK,CAACqB,UAAU,CAAC,IAAI,CAAC9B,OAAO,EAAET,qCAAqC,CAACG,OAAO,EAAEA,OAAO,CAACqC,WAAW,CAAC;QAEhHZ,eAAe,CAACa,QAAQ,CAAC3B,SAAS,CAACuB,KAAK,EAAE,CAACC,KAAK,CAAC,IAAI,CAACN,aAAa,CAAC,CAAC;QACrEF,cAAc,CAACW,QAAQ,CAACzB,QAAQ,CAACqB,KAAK,EAAE,CAACC,KAAK,CAAC,IAAI,CAACN,aAAa,CAAC,CAAC;QACnED,WAAW,CAACU,QAAQ,CAACH,KAAK,CAACD,KAAK,EAAE,CAACC,KAAK,CAAC,IAAI,CAACN,aAAa,CAAC,CAAC;QAC7DD,WAAW,CAACW,oBAAoB,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QAEzCzC,MAAM,CAAC0C,YAAY,CAACZ,WAAW,EAAE7B,UAAU,CAAC0C,eAAe,CAACd,cAAc,CAACe,CAAC,EAAEf,cAAc,CAACgB,CAAC,EAAEhB,cAAc,CAACiB,CAAC,CAAC,EAAEnB,eAAe,EAAEF,eAAe,CAAC;QAEpJR,KAAK,CAAC8B,sBAAsB,CAACX,KAAK,EAAEX,eAAe,EAAED,oBAAoB,CAAC;;MAG9E;MACA,IAAIA,oBAAoB,CAACW,MAAM,EAAE;QAC7B,IAAIX,oBAAoB,CAACW,MAAM,KAAK,CAAC,EAAE;UACnC,IAAI,CAACa,WAAW,GAAGxB,oBAAoB,CAAC,CAAC,CAAC;SAC7C,MAAM;UACH;UACA,MAAMyB,IAAI,GAAGzB,oBAAoB,CAAC0B,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;UACjD,IAAI,CAACF,WAAW,GAAGC,IAAI,CAACE,KAAK,CAAC3B,oBAAoB,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC;;;MAIpFP,KAAK,CAACmC,uBAAuB,EAAE;MAC/BnC,KAAK,CAACoC,wBAAwB,EAAE;MAChC;MACA,OAAO,IAAI,CAACL,WAAW;IAC3B,CAAC;IAED,IAAI,IAAI,CAACM,eAAe,EAAE;MACtB,IAAI,CAACC,MAAM,CAACC,eAAe,GAAGtC,IAAI;KACrC,MAAM;MACH,IAAI,CAACqC,MAAM,CAACC,eAAe,GAAG,IAAI;MAClC,IAAI,CAACD,MAAM,CAACE,YAAY,GAAGvC,IAAI,CAACD,KAAK,CAAC;;EAE9C;;AAGJnB,aAAa,CAAC,gCAAgC,EAAEM,sBAAsB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}