{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"./Enums/nodeGeometryConnectionPointTypes.js\";\n/**\n * Enum used to define the compatibility state between two connection points\n */\nexport var NodeGeometryConnectionPointCompatibilityStates;\n(function (NodeGeometryConnectionPointCompatibilityStates) {\n  /** Points are compatibles */\n  NodeGeometryConnectionPointCompatibilityStates[NodeGeometryConnectionPointCompatibilityStates[\"Compatible\"] = 0] = \"Compatible\";\n  /** Points are incompatible because of their types */\n  NodeGeometryConnectionPointCompatibilityStates[NodeGeometryConnectionPointCompatibilityStates[\"TypeIncompatible\"] = 1] = \"TypeIncompatible\";\n  /** Points are incompatible because they are in the same hierarchy **/\n  NodeGeometryConnectionPointCompatibilityStates[NodeGeometryConnectionPointCompatibilityStates[\"HierarchyIssue\"] = 2] = \"HierarchyIssue\";\n})(NodeGeometryConnectionPointCompatibilityStates || (NodeGeometryConnectionPointCompatibilityStates = {}));\n/**\n * Defines the direction of a connection point\n */\nexport var NodeGeometryConnectionPointDirection;\n(function (NodeGeometryConnectionPointDirection) {\n  /** Input */\n  NodeGeometryConnectionPointDirection[NodeGeometryConnectionPointDirection[\"Input\"] = 0] = \"Input\";\n  /** Output */\n  NodeGeometryConnectionPointDirection[NodeGeometryConnectionPointDirection[\"Output\"] = 1] = \"Output\";\n})(NodeGeometryConnectionPointDirection || (NodeGeometryConnectionPointDirection = {}));\n/**\n * Defines a connection point for a block\n */\nexport class NodeGeometryConnectionPoint {\n  /** Gets the direction of the point */\n  get direction() {\n    return this._direction;\n  }\n  /**\n   * Gets or sets the connection point type (default is float)\n   */\n  get type() {\n    if (this._type === NodeGeometryBlockConnectionPointTypes.AutoDetect) {\n      if (this._ownerBlock.isInput) {\n        return this._ownerBlock.type;\n      }\n      if (this._connectedPoint) {\n        return this._connectedPoint.type;\n      }\n      if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {\n        return this._linkedConnectionSource.type;\n      }\n    }\n    if (this._type === NodeGeometryBlockConnectionPointTypes.BasedOnInput) {\n      if (this._typeConnectionSource) {\n        if (!this._typeConnectionSource.isConnected && this._defaultConnectionPointType) {\n          return this._defaultConnectionPointType;\n        }\n        return this._typeConnectionSource.type;\n      } else if (this._defaultConnectionPointType) {\n        return this._defaultConnectionPointType;\n      }\n    }\n    return this._type;\n  }\n  set type(value) {\n    this._type = value;\n  }\n  /**\n   * Gets a boolean indicating that the current point is connected to another NodeMaterialBlock\n   */\n  get isConnected() {\n    return this.connectedPoint !== null || this.hasEndpoints;\n  }\n  /** Get the other side of the connection (if any) */\n  get connectedPoint() {\n    return this._connectedPoint;\n  }\n  /** Get the block that owns this connection point */\n  get ownerBlock() {\n    return this._ownerBlock;\n  }\n  /** Get the block connected on the other side of this connection (if any) */\n  get sourceBlock() {\n    if (!this._connectedPoint) {\n      return null;\n    }\n    return this._connectedPoint.ownerBlock;\n  }\n  /** Get the block connected on the endpoints of this connection (if any) */\n  get connectedBlocks() {\n    if (this._endpoints.length === 0) {\n      return [];\n    }\n    return this._endpoints.map(e => e.ownerBlock);\n  }\n  /** Gets the list of connected endpoints */\n  get endpoints() {\n    return this._endpoints;\n  }\n  /** Gets a boolean indicating if that output point is connected to at least one input */\n  get hasEndpoints() {\n    return this._endpoints && this._endpoints.length > 0;\n  }\n  /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */\n  get innerType() {\n    if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {\n      return this.type;\n    }\n    return this._type;\n  }\n  /**\n   * Gets the value represented by this connection point\n   * @param state current evaluation state\n   * @returns the connected value or the value if nothing is connected\n   */\n  getConnectedValue(state) {\n    var _a, _b, _c;\n    if (this.isConnected) {\n      if ((_a = this._connectedPoint) === null || _a === void 0 ? void 0 : _a._storedFunction) {\n        return (_b = this._connectedPoint) === null || _b === void 0 ? void 0 : _b._storedFunction(state);\n      }\n      return (_c = this._connectedPoint) === null || _c === void 0 ? void 0 : _c._storedValue;\n    }\n    return this.value;\n  }\n  /**\n   * Creates a new connection point\n   * @param name defines the connection point name\n   * @param ownerBlock defines the block hosting this connection point\n   * @param direction defines the direction of the connection point\n   */\n  constructor(name, ownerBlock, direction) {\n    /** @internal */\n    this._connectedPoint = null;\n    /** @internal */\n    this._storedValue = null;\n    /** @internal */\n    this._storedFunction = null;\n    /** @internal */\n    this._acceptedConnectionPointType = null;\n    this._endpoints = new Array();\n    this._type = NodeGeometryBlockConnectionPointTypes.Geometry;\n    /** @internal */\n    this._linkedConnectionSource = null;\n    /** @internal */\n    this._typeConnectionSource = null;\n    /** @internal */\n    this._defaultConnectionPointType = null;\n    /**\n     * Gets or sets the additional types supported by this connection point\n     */\n    this.acceptedConnectionPointTypes = new Array();\n    /**\n     * Gets or sets the additional types excluded by this connection point\n     */\n    this.excludedConnectionPointTypes = new Array();\n    /**\n     * Observable triggered when this point is connected\n     */\n    this.onConnectionObservable = new Observable();\n    /**\n     * Gets or sets a boolean indicating that this connection point is exposed on a frame\n     */\n    this.isExposedOnFrame = false;\n    /**\n     * Gets or sets number indicating the position that the port is exposed to on a frame\n     */\n    this.exposedPortPosition = -1;\n    /**\n     * Gets the default value used for this point at creation time\n     */\n    this.defaultValue = null;\n    /**\n     * Gets or sets the default value used for this point if nothing is connected\n     */\n    this.value = null;\n    /**\n     * Gets or sets the min value accepted for this point if nothing is connected\n     */\n    this.valueMin = null;\n    /**\n     * Gets or sets the max value accepted for this point if nothing is connected\n     */\n    this.valueMax = null;\n    this._ownerBlock = ownerBlock;\n    this.name = name;\n    this._direction = direction;\n  }\n  /**\n   * Gets the current class name e.g. \"NodeMaterialConnectionPoint\"\n   * @returns the class name\n   */\n  getClassName() {\n    return \"NodeGeometryConnectionPoint\";\n  }\n  /**\n   * Gets a boolean indicating if the current point can be connected to another point\n   * @param connectionPoint defines the other connection point\n   * @returns a boolean\n   */\n  canConnectTo(connectionPoint) {\n    return this.checkCompatibilityState(connectionPoint) === NodeGeometryConnectionPointCompatibilityStates.Compatible;\n  }\n  /**\n   * Gets a number indicating if the current point can be connected to another point\n   * @param connectionPoint defines the other connection point\n   * @returns a number defining the compatibility state\n   */\n  checkCompatibilityState(connectionPoint) {\n    const ownerBlock = this._ownerBlock;\n    const otherBlock = connectionPoint.ownerBlock;\n    if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeGeometryBlockConnectionPointTypes.AutoDetect) {\n      // Accepted types\n      if (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1) {\n        return NodeGeometryConnectionPointCompatibilityStates.Compatible;\n      } else {\n        return NodeGeometryConnectionPointCompatibilityStates.TypeIncompatible;\n      }\n    }\n    // Excluded\n    if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {\n      return NodeGeometryConnectionPointCompatibilityStates.TypeIncompatible;\n    }\n    // Check hierarchy\n    let targetBlock = otherBlock;\n    let sourceBlock = ownerBlock;\n    if (this.direction === NodeGeometryConnectionPointDirection.Input) {\n      targetBlock = ownerBlock;\n      sourceBlock = otherBlock;\n    }\n    if (targetBlock.isAnAncestorOf(sourceBlock)) {\n      return NodeGeometryConnectionPointCompatibilityStates.HierarchyIssue;\n    }\n    return NodeGeometryConnectionPointCompatibilityStates.Compatible;\n  }\n  /**\n   * Connect this point to another connection point\n   * @param connectionPoint defines the other connection point\n   * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)\n   * @returns the current connection point\n   */\n  connectTo(connectionPoint, ignoreConstraints = false) {\n    if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {\n      throw \"Cannot connect these two connectors.\";\n    }\n    this._endpoints.push(connectionPoint);\n    connectionPoint._connectedPoint = this;\n    this.onConnectionObservable.notifyObservers(connectionPoint);\n    connectionPoint.onConnectionObservable.notifyObservers(this);\n    return this;\n  }\n  /**\n   * Disconnect this point from one of his endpoint\n   * @param endpoint defines the other connection point\n   * @returns the current connection point\n   */\n  disconnectFrom(endpoint) {\n    const index = this._endpoints.indexOf(endpoint);\n    if (index === -1) {\n      return this;\n    }\n    this._endpoints.splice(index, 1);\n    endpoint._connectedPoint = null;\n    return this;\n  }\n  /**\n   * Fill the list of excluded connection point types with all types other than those passed in the parameter\n   * @param mask Types (ORed values of NodeMaterialBlockConnectionPointTypes) that are allowed, and thus will not be pushed to the excluded list\n   */\n  addExcludedConnectionPointFromAllowedTypes(mask) {\n    let bitmask = 1;\n    while (bitmask < NodeGeometryBlockConnectionPointTypes.All) {\n      if (!(mask & bitmask)) {\n        this.excludedConnectionPointTypes.push(bitmask);\n      }\n      bitmask = bitmask << 1;\n    }\n  }\n  /**\n   * Serializes this point in a JSON representation\n   * @param isInput defines if the connection point is an input (default is true)\n   * @returns the serialized point object\n   */\n  serialize(isInput = true) {\n    const serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.displayName = this.displayName;\n    if (this.value !== undefined && this.value !== null) {\n      if (this.value.asArray) {\n        serializationObject.valueType = \"BABYLON.\" + this.value.getClassName();\n        serializationObject.value = this.value.asArray();\n      } else {\n        serializationObject.valueType = \"number\";\n        serializationObject.value = this.value;\n      }\n    }\n    if (isInput && this.connectedPoint) {\n      serializationObject.inputName = this.name;\n      serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;\n      serializationObject.targetConnectionName = this.connectedPoint.name;\n    }\n    return serializationObject;\n  }\n  /**\n   * Release resources\n   */\n  dispose() {\n    this.onConnectionObservable.clear();\n  }\n}","map":{"version":3,"names":["Observable","NodeGeometryBlockConnectionPointTypes","NodeGeometryConnectionPointCompatibilityStates","NodeGeometryConnectionPointDirection","NodeGeometryConnectionPoint","direction","_direction","type","_type","AutoDetect","_ownerBlock","isInput","_connectedPoint","_linkedConnectionSource","isConnected","BasedOnInput","_typeConnectionSource","_defaultConnectionPointType","value","connectedPoint","hasEndpoints","ownerBlock","sourceBlock","connectedBlocks","_endpoints","length","map","e","endpoints","innerType","getConnectedValue","state","_a","_storedFunction","_b","_c","_storedValue","constructor","name","_acceptedConnectionPointType","Array","Geometry","acceptedConnectionPointTypes","excludedConnectionPointTypes","onConnectionObservable","isExposedOnFrame","exposedPortPosition","defaultValue","valueMin","valueMax","getClassName","canConnectTo","connectionPoint","checkCompatibilityState","Compatible","otherBlock","indexOf","TypeIncompatible","targetBlock","Input","isAnAncestorOf","HierarchyIssue","connectTo","ignoreConstraints","push","notifyObservers","disconnectFrom","endpoint","index","splice","addExcludedConnectionPointFromAllowedTypes","mask","bitmask","All","serialize","serializationObject","displayName","undefined","asArray","valueType","inputName","targetBlockId","uniqueId","targetConnectionName","dispose","clear"],"sources":["../../../../../dev/core/src/Meshes/Node/nodeGeometryBlockConnectionPoint.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { NodeGeometryBlock } from \"./nodeGeometryBlock\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"./Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { GeometryInputBlock } from \"./Blocks/geometryInputBlock\";\r\nimport type { NodeGeometryBuildState } from \"./nodeGeometryBuildState\";\r\n\r\n/**\r\n * Enum used to define the compatibility state between two connection points\r\n */\r\nexport enum NodeGeometryConnectionPointCompatibilityStates {\r\n    /** Points are compatibles */\r\n    Compatible,\r\n    /** Points are incompatible because of their types */\r\n    TypeIncompatible,\r\n    /** Points are incompatible because they are in the same hierarchy **/\r\n    HierarchyIssue,\r\n}\r\n\r\n/**\r\n * Defines the direction of a connection point\r\n */\r\nexport enum NodeGeometryConnectionPointDirection {\r\n    /** Input */\r\n    Input,\r\n    /** Output */\r\n    Output,\r\n}\r\n\r\n/**\r\n * Defines a connection point for a block\r\n */\r\nexport class NodeGeometryConnectionPoint {\r\n    /** @internal */\r\n    public _ownerBlock: NodeGeometryBlock;\r\n    /** @internal */\r\n    public _connectedPoint: Nullable<NodeGeometryConnectionPoint> = null;\r\n    /** @internal */\r\n    public _storedValue: any = null;\r\n    /** @internal */\r\n    public _storedFunction: Nullable<(state: NodeGeometryBuildState) => any> = null;\r\n\r\n    /** @internal */\r\n    public _acceptedConnectionPointType: Nullable<NodeGeometryConnectionPoint> = null;\r\n\r\n    private _endpoints = new Array<NodeGeometryConnectionPoint>();\r\n    private _direction: NodeGeometryConnectionPointDirection;\r\n    private _type = NodeGeometryBlockConnectionPointTypes.Geometry;\r\n\r\n    /** @internal */\r\n    public _linkedConnectionSource: Nullable<NodeGeometryConnectionPoint> = null;\r\n\r\n    /** @internal */\r\n    public _typeConnectionSource: Nullable<NodeGeometryConnectionPoint> = null;\r\n\r\n    /** @internal */\r\n    public _defaultConnectionPointType: Nullable<NodeGeometryBlockConnectionPointTypes> = null;\r\n\r\n    /** Gets the direction of the point */\r\n    public get direction() {\r\n        return this._direction;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the additional types supported by this connection point\r\n     */\r\n    public acceptedConnectionPointTypes = new Array<NodeGeometryBlockConnectionPointTypes>();\r\n\r\n    /**\r\n     * Gets or sets the additional types excluded by this connection point\r\n     */\r\n    public excludedConnectionPointTypes = new Array<NodeGeometryBlockConnectionPointTypes>();\r\n\r\n    /**\r\n     * Observable triggered when this point is connected\r\n     */\r\n    public onConnectionObservable = new Observable<NodeGeometryConnectionPoint>();\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is exposed on a frame\r\n     */\r\n    public isExposedOnFrame: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets number indicating the position that the port is exposed to on a frame\r\n     */\r\n    public exposedPortPosition: number = -1;\r\n\r\n    /**\r\n     * Gets the default value used for this point at creation time\r\n     */\r\n    public defaultValue: Nullable<any> = null;\r\n\r\n    /**\r\n     * Gets or sets the default value used for this point if nothing is connected\r\n     */\r\n    public value: Nullable<any> = null;\r\n\r\n    /**\r\n     * Gets or sets the min value accepted for this point if nothing is connected\r\n     */\r\n    public valueMin: Nullable<any> = null;\r\n\r\n    /**\r\n     * Gets or sets the max value accepted for this point if nothing is connected\r\n     */\r\n    public valueMax: Nullable<any> = null;\r\n\r\n    /**\r\n     * Gets or sets the connection point type (default is float)\r\n     */\r\n    public get type(): NodeGeometryBlockConnectionPointTypes {\r\n        if (this._type === NodeGeometryBlockConnectionPointTypes.AutoDetect) {\r\n            if (this._ownerBlock.isInput) {\r\n                return (this._ownerBlock as GeometryInputBlock).type;\r\n            }\r\n\r\n            if (this._connectedPoint) {\r\n                return this._connectedPoint.type;\r\n            }\r\n\r\n            if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {\r\n                return this._linkedConnectionSource.type;\r\n            }\r\n        }\r\n\r\n        if (this._type === NodeGeometryBlockConnectionPointTypes.BasedOnInput) {\r\n            if (this._typeConnectionSource) {\r\n                if (!this._typeConnectionSource.isConnected && this._defaultConnectionPointType) {\r\n                    return this._defaultConnectionPointType;\r\n                }\r\n                return this._typeConnectionSource.type;\r\n            } else if (this._defaultConnectionPointType) {\r\n                return this._defaultConnectionPointType;\r\n            }\r\n        }\r\n\r\n        return this._type;\r\n    }\r\n\r\n    public set type(value: NodeGeometryBlockConnectionPointTypes) {\r\n        this._type = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the connection point name\r\n     */\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets the connection point display name\r\n     */\r\n    public displayName: string;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point can be omitted\r\n     */\r\n    public isOptional: boolean;\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current point is connected to another NodeMaterialBlock\r\n     */\r\n    public get isConnected(): boolean {\r\n        return this.connectedPoint !== null || this.hasEndpoints;\r\n    }\r\n\r\n    /** Get the other side of the connection (if any) */\r\n    public get connectedPoint(): Nullable<NodeGeometryConnectionPoint> {\r\n        return this._connectedPoint;\r\n    }\r\n\r\n    /** Get the block that owns this connection point */\r\n    public get ownerBlock(): NodeGeometryBlock {\r\n        return this._ownerBlock;\r\n    }\r\n\r\n    /** Get the block connected on the other side of this connection (if any) */\r\n    public get sourceBlock(): Nullable<NodeGeometryBlock> {\r\n        if (!this._connectedPoint) {\r\n            return null;\r\n        }\r\n\r\n        return this._connectedPoint.ownerBlock;\r\n    }\r\n\r\n    /** Get the block connected on the endpoints of this connection (if any) */\r\n    public get connectedBlocks(): Array<NodeGeometryBlock> {\r\n        if (this._endpoints.length === 0) {\r\n            return [];\r\n        }\r\n\r\n        return this._endpoints.map((e) => e.ownerBlock);\r\n    }\r\n\r\n    /** Gets the list of connected endpoints */\r\n    public get endpoints() {\r\n        return this._endpoints;\r\n    }\r\n\r\n    /** Gets a boolean indicating if that output point is connected to at least one input */\r\n    public get hasEndpoints(): boolean {\r\n        return this._endpoints && this._endpoints.length > 0;\r\n    }\r\n\r\n    /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */\r\n    public get innerType() {\r\n        if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {\r\n            return this.type;\r\n        }\r\n        return this._type;\r\n    }\r\n\r\n    /**\r\n     * Gets the value represented by this connection point\r\n     * @param state current evaluation state\r\n     * @returns the connected value or the value if nothing is connected\r\n     */\r\n    public getConnectedValue(state: NodeGeometryBuildState) {\r\n        if (this.isConnected) {\r\n            if (this._connectedPoint?._storedFunction) {\r\n                return this._connectedPoint?._storedFunction(state);\r\n            }\r\n            return this._connectedPoint?._storedValue;\r\n        }\r\n        return this.value;\r\n    }\r\n\r\n    /**\r\n     * Creates a new connection point\r\n     * @param name defines the connection point name\r\n     * @param ownerBlock defines the block hosting this connection point\r\n     * @param direction defines the direction of the connection point\r\n     */\r\n    public constructor(name: string, ownerBlock: NodeGeometryBlock, direction: NodeGeometryConnectionPointDirection) {\r\n        this._ownerBlock = ownerBlock;\r\n        this.name = name;\r\n        this._direction = direction;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name e.g. \"NodeMaterialConnectionPoint\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"NodeGeometryConnectionPoint\";\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a boolean\r\n     */\r\n    public canConnectTo(connectionPoint: NodeGeometryConnectionPoint) {\r\n        return this.checkCompatibilityState(connectionPoint) === NodeGeometryConnectionPointCompatibilityStates.Compatible;\r\n    }\r\n\r\n    /**\r\n     * Gets a number indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a number defining the compatibility state\r\n     */\r\n    public checkCompatibilityState(connectionPoint: NodeGeometryConnectionPoint): NodeGeometryConnectionPointCompatibilityStates {\r\n        const ownerBlock = this._ownerBlock;\r\n        const otherBlock = connectionPoint.ownerBlock;\r\n\r\n        if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeGeometryBlockConnectionPointTypes.AutoDetect) {\r\n            // Accepted types\r\n            if (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1) {\r\n                return NodeGeometryConnectionPointCompatibilityStates.Compatible;\r\n            } else {\r\n                return NodeGeometryConnectionPointCompatibilityStates.TypeIncompatible;\r\n            }\r\n        }\r\n\r\n        // Excluded\r\n        if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {\r\n            return NodeGeometryConnectionPointCompatibilityStates.TypeIncompatible;\r\n        }\r\n\r\n        // Check hierarchy\r\n        let targetBlock = otherBlock;\r\n        let sourceBlock = ownerBlock;\r\n        if (this.direction === NodeGeometryConnectionPointDirection.Input) {\r\n            targetBlock = ownerBlock;\r\n            sourceBlock = otherBlock;\r\n        }\r\n\r\n        if (targetBlock.isAnAncestorOf(sourceBlock)) {\r\n            return NodeGeometryConnectionPointCompatibilityStates.HierarchyIssue;\r\n        }\r\n\r\n        return NodeGeometryConnectionPointCompatibilityStates.Compatible;\r\n    }\r\n\r\n    /**\r\n     * Connect this point to another connection point\r\n     * @param connectionPoint defines the other connection point\r\n     * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)\r\n     * @returns the current connection point\r\n     */\r\n    public connectTo(connectionPoint: NodeGeometryConnectionPoint, ignoreConstraints = false): NodeGeometryConnectionPoint {\r\n        if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {\r\n            throw \"Cannot connect these two connectors.\";\r\n        }\r\n\r\n        this._endpoints.push(connectionPoint);\r\n        connectionPoint._connectedPoint = this;\r\n\r\n        this.onConnectionObservable.notifyObservers(connectionPoint);\r\n        connectionPoint.onConnectionObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disconnect this point from one of his endpoint\r\n     * @param endpoint defines the other connection point\r\n     * @returns the current connection point\r\n     */\r\n    public disconnectFrom(endpoint: NodeGeometryConnectionPoint): NodeGeometryConnectionPoint {\r\n        const index = this._endpoints.indexOf(endpoint);\r\n\r\n        if (index === -1) {\r\n            return this;\r\n        }\r\n\r\n        this._endpoints.splice(index, 1);\r\n        endpoint._connectedPoint = null;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Fill the list of excluded connection point types with all types other than those passed in the parameter\r\n     * @param mask Types (ORed values of NodeMaterialBlockConnectionPointTypes) that are allowed, and thus will not be pushed to the excluded list\r\n     */\r\n    public addExcludedConnectionPointFromAllowedTypes(mask: number): void {\r\n        let bitmask = 1;\r\n        while (bitmask < NodeGeometryBlockConnectionPointTypes.All) {\r\n            if (!(mask & bitmask)) {\r\n                this.excludedConnectionPointTypes.push(bitmask);\r\n            }\r\n            bitmask = bitmask << 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes this point in a JSON representation\r\n     * @param isInput defines if the connection point is an input (default is true)\r\n     * @returns the serialized point object\r\n     */\r\n    public serialize(isInput = true): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.displayName = this.displayName;\r\n        if (this.value !== undefined && this.value !== null) {\r\n            if (this.value.asArray) {\r\n                serializationObject.valueType = \"BABYLON.\" + this.value.getClassName();\r\n                serializationObject.value = this.value.asArray();\r\n            } else {\r\n                serializationObject.valueType = \"number\";\r\n                serializationObject.value = this.value;\r\n            }\r\n        }\r\n\r\n        if (isInput && this.connectedPoint) {\r\n            serializationObject.inputName = this.name;\r\n            serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;\r\n            serializationObject.targetConnectionName = this.connectedPoint.name;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        this.onConnectionObservable.clear();\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}