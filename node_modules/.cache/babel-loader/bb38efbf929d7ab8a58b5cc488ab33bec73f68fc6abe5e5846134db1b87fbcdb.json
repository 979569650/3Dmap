{"ast":null,"code":"import { Vector3 } from \"../Maths/math.vector.js\";\nimport { Plane } from \"../Maths/math.plane.js\";\nconst intersectBoxAASphere = (boxMin, boxMax, sphereCenter, sphereRadius) => {\n  if (boxMin.x > sphereCenter.x + sphereRadius) {\n    return false;\n  }\n  if (sphereCenter.x - sphereRadius > boxMax.x) {\n    return false;\n  }\n  if (boxMin.y > sphereCenter.y + sphereRadius) {\n    return false;\n  }\n  if (sphereCenter.y - sphereRadius > boxMax.y) {\n    return false;\n  }\n  if (boxMin.z > sphereCenter.z + sphereRadius) {\n    return false;\n  }\n  if (sphereCenter.z - sphereRadius > boxMax.z) {\n    return false;\n  }\n  return true;\n};\nconst getLowestRoot = function () {\n  const result = {\n    root: 0,\n    found: false\n  };\n  return function (a, b, c, maxR) {\n    result.root = 0;\n    result.found = false;\n    const determinant = b * b - 4.0 * a * c;\n    if (determinant < 0) {\n      return result;\n    }\n    const sqrtD = Math.sqrt(determinant);\n    let r1 = (-b - sqrtD) / (2.0 * a);\n    let r2 = (-b + sqrtD) / (2.0 * a);\n    if (r1 > r2) {\n      const temp = r2;\n      r2 = r1;\n      r1 = temp;\n    }\n    if (r1 > 0 && r1 < maxR) {\n      result.root = r1;\n      result.found = true;\n      return result;\n    }\n    if (r2 > 0 && r2 < maxR) {\n      result.root = r2;\n      result.found = true;\n      return result;\n    }\n    return result;\n  };\n}();\n/** @internal */\nexport class Collider {\n  constructor() {\n    // Implementation of the \"Improved Collision detection and Response\" algorithm proposed by Kasper Fauerby\n    // https://www.peroxide.dk/papers/collision/collision.pdf\n    this._collisionPoint = Vector3.Zero();\n    this._planeIntersectionPoint = Vector3.Zero();\n    this._tempVector = Vector3.Zero();\n    this._tempVector2 = Vector3.Zero();\n    this._tempVector3 = Vector3.Zero();\n    this._tempVector4 = Vector3.Zero();\n    this._edge = Vector3.Zero();\n    this._baseToVertex = Vector3.Zero();\n    this._destinationPoint = Vector3.Zero();\n    this._slidePlaneNormal = Vector3.Zero();\n    this._displacementVector = Vector3.Zero();\n    /** @internal */\n    this._radius = Vector3.One();\n    /** @internal */\n    this._retry = 0;\n    /** @internal */\n    this._basePointWorld = Vector3.Zero();\n    this._velocityWorld = Vector3.Zero();\n    this._normalizedVelocity = Vector3.Zero();\n    this._collisionMask = -1;\n  }\n  get collisionMask() {\n    return this._collisionMask;\n  }\n  set collisionMask(mask) {\n    this._collisionMask = !isNaN(mask) ? mask : -1;\n  }\n  /**\n   * Gets the plane normal used to compute the sliding response (in local space)\n   */\n  get slidePlaneNormal() {\n    return this._slidePlaneNormal;\n  }\n  // Methods\n  /**\n   * @internal\n   */\n  _initialize(source, dir, e) {\n    this._velocity = dir;\n    this._velocitySquaredLength = this._velocity.lengthSquared();\n    const len = Math.sqrt(this._velocitySquaredLength);\n    if (len === 0 || len === 1.0) {\n      this._normalizedVelocity.copyFromFloats(dir._x, dir._y, dir._z);\n    } else {\n      dir.scaleToRef(1.0 / len, this._normalizedVelocity);\n    }\n    this._basePoint = source;\n    source.multiplyToRef(this._radius, this._basePointWorld);\n    dir.multiplyToRef(this._radius, this._velocityWorld);\n    this._velocityWorldLength = this._velocityWorld.length();\n    this._epsilon = e;\n    this.collisionFound = false;\n  }\n  /**\n   * @internal\n   */\n  _checkPointInTriangle(point, pa, pb, pc, n) {\n    pa.subtractToRef(point, this._tempVector);\n    pb.subtractToRef(point, this._tempVector2);\n    Vector3.CrossToRef(this._tempVector, this._tempVector2, this._tempVector4);\n    let d = Vector3.Dot(this._tempVector4, n);\n    if (d < 0) {\n      return false;\n    }\n    pc.subtractToRef(point, this._tempVector3);\n    Vector3.CrossToRef(this._tempVector2, this._tempVector3, this._tempVector4);\n    d = Vector3.Dot(this._tempVector4, n);\n    if (d < 0) {\n      return false;\n    }\n    Vector3.CrossToRef(this._tempVector3, this._tempVector, this._tempVector4);\n    d = Vector3.Dot(this._tempVector4, n);\n    return d >= 0;\n  }\n  /**\n   * @internal\n   */\n  _canDoCollision(sphereCenter, sphereRadius, vecMin, vecMax) {\n    const distance = Vector3.Distance(this._basePointWorld, sphereCenter);\n    const max = Math.max(this._radius.x, this._radius.y, this._radius.z);\n    if (distance > this._velocityWorldLength + max + sphereRadius) {\n      return false;\n    }\n    if (!intersectBoxAASphere(vecMin, vecMax, this._basePointWorld, this._velocityWorldLength + max)) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * @internal\n   */\n  _testTriangle(faceIndex, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh) {\n    let t0;\n    let embeddedInPlane = false;\n    //defensive programming, actually not needed.\n    if (!trianglePlaneArray) {\n      trianglePlaneArray = [];\n    }\n    if (!trianglePlaneArray[faceIndex]) {\n      trianglePlaneArray[faceIndex] = new Plane(0, 0, 0, 0);\n      trianglePlaneArray[faceIndex].copyFromPoints(p1, p2, p3);\n    }\n    const trianglePlane = trianglePlaneArray[faceIndex];\n    if (!hasMaterial && !trianglePlane.isFrontFacingTo(this._normalizedVelocity, 0)) {\n      return;\n    }\n    const signedDistToTrianglePlane = trianglePlane.signedDistanceTo(this._basePoint);\n    const normalDotVelocity = Vector3.Dot(trianglePlane.normal, this._velocity);\n    // if DoubleSidedCheck is false(default), a double sided face will be consided 2 times.\n    // if true, it discard the faces having normal not facing velocity\n    if (Collider.DoubleSidedCheck && normalDotVelocity > 0.0001) {\n      return;\n    }\n    if (normalDotVelocity == 0) {\n      if (Math.abs(signedDistToTrianglePlane) >= 1.0) {\n        return;\n      }\n      embeddedInPlane = true;\n      t0 = 0;\n    } else {\n      t0 = (-1.0 - signedDistToTrianglePlane) / normalDotVelocity;\n      let t1 = (1.0 - signedDistToTrianglePlane) / normalDotVelocity;\n      if (t0 > t1) {\n        const temp = t1;\n        t1 = t0;\n        t0 = temp;\n      }\n      if (t0 > 1.0 || t1 < 0.0) {\n        return;\n      }\n      if (t0 < 0) {\n        t0 = 0;\n      }\n      if (t0 > 1.0) {\n        t0 = 1.0;\n      }\n    }\n    this._collisionPoint.copyFromFloats(0, 0, 0);\n    let found = false;\n    let t = 1.0;\n    if (!embeddedInPlane) {\n      this._basePoint.subtractToRef(trianglePlane.normal, this._planeIntersectionPoint);\n      this._velocity.scaleToRef(t0, this._tempVector);\n      this._planeIntersectionPoint.addInPlace(this._tempVector);\n      if (this._checkPointInTriangle(this._planeIntersectionPoint, p1, p2, p3, trianglePlane.normal)) {\n        found = true;\n        t = t0;\n        this._collisionPoint.copyFrom(this._planeIntersectionPoint);\n      }\n    }\n    if (!found) {\n      let a = this._velocitySquaredLength;\n      this._basePoint.subtractToRef(p1, this._tempVector);\n      let b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\n      let c = this._tempVector.lengthSquared() - 1.0;\n      let lowestRoot = getLowestRoot(a, b, c, t);\n      if (lowestRoot.found) {\n        t = lowestRoot.root;\n        found = true;\n        this._collisionPoint.copyFrom(p1);\n      }\n      this._basePoint.subtractToRef(p2, this._tempVector);\n      b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\n      c = this._tempVector.lengthSquared() - 1.0;\n      lowestRoot = getLowestRoot(a, b, c, t);\n      if (lowestRoot.found) {\n        t = lowestRoot.root;\n        found = true;\n        this._collisionPoint.copyFrom(p2);\n      }\n      this._basePoint.subtractToRef(p3, this._tempVector);\n      b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\n      c = this._tempVector.lengthSquared() - 1.0;\n      lowestRoot = getLowestRoot(a, b, c, t);\n      if (lowestRoot.found) {\n        t = lowestRoot.root;\n        found = true;\n        this._collisionPoint.copyFrom(p3);\n      }\n      p2.subtractToRef(p1, this._edge);\n      p1.subtractToRef(this._basePoint, this._baseToVertex);\n      let edgeSquaredLength = this._edge.lengthSquared();\n      let edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\n      let edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\n      a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\n      b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\n      c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n      lowestRoot = getLowestRoot(a, b, c, t);\n      if (lowestRoot.found) {\n        const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\n        if (f >= 0.0 && f <= 1.0) {\n          t = lowestRoot.root;\n          found = true;\n          this._edge.scaleInPlace(f);\n          p1.addToRef(this._edge, this._collisionPoint);\n        }\n      }\n      p3.subtractToRef(p2, this._edge);\n      p2.subtractToRef(this._basePoint, this._baseToVertex);\n      edgeSquaredLength = this._edge.lengthSquared();\n      edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\n      edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\n      a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\n      b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\n      c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n      lowestRoot = getLowestRoot(a, b, c, t);\n      if (lowestRoot.found) {\n        const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\n        if (f >= 0.0 && f <= 1.0) {\n          t = lowestRoot.root;\n          found = true;\n          this._edge.scaleInPlace(f);\n          p2.addToRef(this._edge, this._collisionPoint);\n        }\n      }\n      p1.subtractToRef(p3, this._edge);\n      p3.subtractToRef(this._basePoint, this._baseToVertex);\n      edgeSquaredLength = this._edge.lengthSquared();\n      edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\n      edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\n      a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\n      b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\n      c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n      lowestRoot = getLowestRoot(a, b, c, t);\n      if (lowestRoot.found) {\n        const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\n        if (f >= 0.0 && f <= 1.0) {\n          t = lowestRoot.root;\n          found = true;\n          this._edge.scaleInPlace(f);\n          p3.addToRef(this._edge, this._collisionPoint);\n        }\n      }\n    }\n    if (found) {\n      const distToCollisionSquared = t * t * this._velocitySquaredLength;\n      if (!this.collisionFound || distToCollisionSquared < this._nearestDistanceSquared) {\n        // if collisionResponse is false, collision is not found but the collidedMesh is set anyway.\n        // onCollide observable are triggered if collideMesh is set\n        // this allow trigger volumes to be created.\n        if (hostMesh.collisionResponse) {\n          if (!this.intersectionPoint) {\n            this.intersectionPoint = this._collisionPoint.clone();\n          } else {\n            this.intersectionPoint.copyFrom(this._collisionPoint);\n          }\n          this._nearestDistanceSquared = distToCollisionSquared;\n          this._nearestDistance = Math.sqrt(distToCollisionSquared);\n          this.collisionFound = true;\n        }\n        this.collidedMesh = hostMesh;\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _collide(trianglePlaneArray, pts, indices, indexStart, indexEnd, decal, hasMaterial, hostMesh, invertTriangles, triangleStrip = false) {\n    if (triangleStrip) {\n      if (!indices || indices.length === 0) {\n        for (let i = 0; i < pts.length - 2; i += 1) {\n          const p1 = pts[i];\n          const p2 = pts[i + 1];\n          const p3 = pts[i + 2];\n          // stay defensive and don't check against undefined positions.\n          if (!p1 || !p2 || !p3) {\n            continue;\n          }\n          // Handles strip faces one on two is reversed\n          if ((invertTriangles ? 1 : 0) ^ i % 2) {\n            this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\n          } else {\n            this._testTriangle(i, trianglePlaneArray, p2, p1, p3, hasMaterial, hostMesh);\n          }\n        }\n      } else {\n        for (let i = indexStart; i < indexEnd - 2; i += 1) {\n          const indexA = indices[i];\n          const indexB = indices[i + 1];\n          const indexC = indices[i + 2];\n          if (indexC === 0xffffffff) {\n            i += 2;\n            continue;\n          }\n          const p1 = pts[indexA];\n          const p2 = pts[indexB];\n          const p3 = pts[indexC];\n          // stay defensive and don't check against undefined positions.\n          if (!p1 || !p2 || !p3) {\n            continue;\n          }\n          // Handles strip faces one on two is reversed\n          if ((invertTriangles ? 1 : 0) ^ i % 2) {\n            this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\n          } else {\n            this._testTriangle(i, trianglePlaneArray, p2, p1, p3, hasMaterial, hostMesh);\n          }\n        }\n      }\n    } else if (!indices || indices.length === 0) {\n      for (let i = 0; i < pts.length; i += 3) {\n        const p1 = pts[i];\n        const p2 = pts[i + 1];\n        const p3 = pts[i + 2];\n        if (invertTriangles) {\n          this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\n        } else {\n          this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);\n        }\n      }\n    } else {\n      for (let i = indexStart; i < indexEnd; i += 3) {\n        const p1 = pts[indices[i] - decal];\n        const p2 = pts[indices[i + 1] - decal];\n        const p3 = pts[indices[i + 2] - decal];\n        if (invertTriangles) {\n          this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\n        } else {\n          this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);\n        }\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _getResponse(pos, vel) {\n    pos.addToRef(vel, this._destinationPoint);\n    vel.scaleInPlace(this._nearestDistance / vel.length());\n    this._basePoint.addToRef(vel, pos);\n    pos.subtractToRef(this.intersectionPoint, this._slidePlaneNormal);\n    this._slidePlaneNormal.normalize();\n    this._slidePlaneNormal.scaleToRef(this._epsilon, this._displacementVector);\n    pos.addInPlace(this._displacementVector);\n    this.intersectionPoint.addInPlace(this._displacementVector);\n    this._slidePlaneNormal.scaleInPlace(Plane.SignedDistanceToPlaneFromPositionAndNormal(this.intersectionPoint, this._slidePlaneNormal, this._destinationPoint));\n    this._destinationPoint.subtractInPlace(this._slidePlaneNormal);\n    this._destinationPoint.subtractToRef(this.intersectionPoint, vel);\n  }\n}\n/**\n * If true, it check for double sided faces and only returns 1 collision instead of 2\n */\nCollider.DoubleSidedCheck = false;","map":{"version":3,"names":["Vector3","Plane","intersectBoxAASphere","boxMin","boxMax","sphereCenter","sphereRadius","x","y","z","getLowestRoot","result","root","found","a","b","c","maxR","determinant","sqrtD","Math","sqrt","r1","r2","temp","Collider","constructor","_collisionPoint","Zero","_planeIntersectionPoint","_tempVector","_tempVector2","_tempVector3","_tempVector4","_edge","_baseToVertex","_destinationPoint","_slidePlaneNormal","_displacementVector","_radius","One","_retry","_basePointWorld","_velocityWorld","_normalizedVelocity","_collisionMask","collisionMask","mask","isNaN","slidePlaneNormal","_initialize","source","dir","e","_velocity","_velocitySquaredLength","lengthSquared","len","copyFromFloats","_x","_y","_z","scaleToRef","_basePoint","multiplyToRef","_velocityWorldLength","length","_epsilon","collisionFound","_checkPointInTriangle","point","pa","pb","pc","n","subtractToRef","CrossToRef","d","Dot","_canDoCollision","vecMin","vecMax","distance","Distance","max","_testTriangle","faceIndex","trianglePlaneArray","p1","p2","p3","hasMaterial","hostMesh","t0","embeddedInPlane","copyFromPoints","trianglePlane","isFrontFacingTo","signedDistToTrianglePlane","signedDistanceTo","normalDotVelocity","normal","DoubleSidedCheck","abs","t1","t","addInPlace","copyFrom","lowestRoot","edgeSquaredLength","edgeDotVelocity","edgeDotBaseToVertex","f","scaleInPlace","addToRef","distToCollisionSquared","_nearestDistanceSquared","collisionResponse","intersectionPoint","clone","_nearestDistance","collidedMesh","_collide","pts","indices","indexStart","indexEnd","decal","invertTriangles","triangleStrip","i","indexA","indexB","indexC","_getResponse","pos","vel","normalize","SignedDistanceToPlaneFromPositionAndNormal","subtractInPlace"],"sources":["../../../../dev/core/src/Collisions/collider.ts"],"sourcesContent":["import type { Nullable, IndicesArray } from \"../types\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Plane } from \"../Maths/math.plane\";\r\n\r\nconst intersectBoxAASphere = (boxMin: Vector3, boxMax: Vector3, sphereCenter: Vector3, sphereRadius: number): boolean => {\r\n    if (boxMin.x > sphereCenter.x + sphereRadius) {\r\n        return false;\r\n    }\r\n\r\n    if (sphereCenter.x - sphereRadius > boxMax.x) {\r\n        return false;\r\n    }\r\n\r\n    if (boxMin.y > sphereCenter.y + sphereRadius) {\r\n        return false;\r\n    }\r\n\r\n    if (sphereCenter.y - sphereRadius > boxMax.y) {\r\n        return false;\r\n    }\r\n\r\n    if (boxMin.z > sphereCenter.z + sphereRadius) {\r\n        return false;\r\n    }\r\n\r\n    if (sphereCenter.z - sphereRadius > boxMax.z) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nconst getLowestRoot: (a: number, b: number, c: number, maxR: number) => { root: number; found: boolean } = (function () {\r\n    const result = { root: 0, found: false };\r\n    return function (a: number, b: number, c: number, maxR: number) {\r\n        result.root = 0;\r\n        result.found = false;\r\n        const determinant = b * b - 4.0 * a * c;\r\n        if (determinant < 0) {\r\n            return result;\r\n        }\r\n\r\n        const sqrtD = Math.sqrt(determinant);\r\n        let r1 = (-b - sqrtD) / (2.0 * a);\r\n        let r2 = (-b + sqrtD) / (2.0 * a);\r\n\r\n        if (r1 > r2) {\r\n            const temp = r2;\r\n            r2 = r1;\r\n            r1 = temp;\r\n        }\r\n\r\n        if (r1 > 0 && r1 < maxR) {\r\n            result.root = r1;\r\n            result.found = true;\r\n            return result;\r\n        }\r\n\r\n        if (r2 > 0 && r2 < maxR) {\r\n            result.root = r2;\r\n            result.found = true;\r\n            return result;\r\n        }\r\n\r\n        return result;\r\n    };\r\n})();\r\n\r\n/** @internal */\r\nexport class Collider {\r\n    // Implementation of the \"Improved Collision detection and Response\" algorithm proposed by Kasper Fauerby\r\n    // https://www.peroxide.dk/papers/collision/collision.pdf\r\n\r\n    /** Define if a collision was found */\r\n    public collisionFound: boolean;\r\n\r\n    /**\r\n     * Define last intersection point in local space\r\n     */\r\n    public intersectionPoint: Vector3;\r\n\r\n    /**\r\n     * Define last collided mesh\r\n     */\r\n    public collidedMesh: Nullable<AbstractMesh>;\r\n\r\n    /**\r\n     * If true, it check for double sided faces and only returns 1 collision instead of 2\r\n     */\r\n    public static DoubleSidedCheck = false;\r\n\r\n    private _collisionPoint = Vector3.Zero();\r\n    private _planeIntersectionPoint = Vector3.Zero();\r\n    private _tempVector = Vector3.Zero();\r\n    private _tempVector2 = Vector3.Zero();\r\n    private _tempVector3 = Vector3.Zero();\r\n    private _tempVector4 = Vector3.Zero();\r\n    private _edge = Vector3.Zero();\r\n    private _baseToVertex = Vector3.Zero();\r\n    private _destinationPoint = Vector3.Zero();\r\n    private _slidePlaneNormal = Vector3.Zero();\r\n    private _displacementVector = Vector3.Zero();\r\n\r\n    /** @internal */\r\n    public _radius = Vector3.One();\r\n    /** @internal */\r\n    public _retry = 0;\r\n    private _velocity: Vector3;\r\n    private _basePoint: Vector3;\r\n    private _epsilon: number;\r\n    /** @internal */\r\n    public _velocityWorldLength: number;\r\n    /** @internal */\r\n    public _basePointWorld = Vector3.Zero();\r\n    private _velocityWorld = Vector3.Zero();\r\n    private _normalizedVelocity = Vector3.Zero();\r\n    /** @internal */\r\n    public _initialVelocity: Vector3;\r\n    /** @internal */\r\n    public _initialPosition: Vector3;\r\n    private _nearestDistance: number;\r\n\r\n    private _collisionMask = -1;\r\n    private _velocitySquaredLength: number;\r\n    private _nearestDistanceSquared: number;\r\n\r\n    public get collisionMask(): number {\r\n        return this._collisionMask;\r\n    }\r\n\r\n    public set collisionMask(mask: number) {\r\n        this._collisionMask = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the plane normal used to compute the sliding response (in local space)\r\n     */\r\n    public get slidePlaneNormal(): Vector3 {\r\n        return this._slidePlaneNormal;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * @internal\r\n     */\r\n    public _initialize(source: Vector3, dir: Vector3, e: number): void {\r\n        this._velocity = dir;\r\n        this._velocitySquaredLength = this._velocity.lengthSquared();\r\n        const len = Math.sqrt(this._velocitySquaredLength);\r\n        if (len === 0 || len === 1.0) {\r\n            this._normalizedVelocity.copyFromFloats(dir._x, dir._y, dir._z);\r\n        } else {\r\n            dir.scaleToRef(1.0 / len, this._normalizedVelocity);\r\n        }\r\n        this._basePoint = source;\r\n\r\n        source.multiplyToRef(this._radius, this._basePointWorld);\r\n        dir.multiplyToRef(this._radius, this._velocityWorld);\r\n\r\n        this._velocityWorldLength = this._velocityWorld.length();\r\n\r\n        this._epsilon = e;\r\n        this.collisionFound = false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _checkPointInTriangle(point: Vector3, pa: Vector3, pb: Vector3, pc: Vector3, n: Vector3): boolean {\r\n        pa.subtractToRef(point, this._tempVector);\r\n        pb.subtractToRef(point, this._tempVector2);\r\n\r\n        Vector3.CrossToRef(this._tempVector, this._tempVector2, this._tempVector4);\r\n        let d = Vector3.Dot(this._tempVector4, n);\r\n        if (d < 0) {\r\n            return false;\r\n        }\r\n\r\n        pc.subtractToRef(point, this._tempVector3);\r\n        Vector3.CrossToRef(this._tempVector2, this._tempVector3, this._tempVector4);\r\n        d = Vector3.Dot(this._tempVector4, n);\r\n        if (d < 0) {\r\n            return false;\r\n        }\r\n\r\n        Vector3.CrossToRef(this._tempVector3, this._tempVector, this._tempVector4);\r\n        d = Vector3.Dot(this._tempVector4, n);\r\n        return d >= 0;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _canDoCollision(sphereCenter: Vector3, sphereRadius: number, vecMin: Vector3, vecMax: Vector3): boolean {\r\n        const distance = Vector3.Distance(this._basePointWorld, sphereCenter);\r\n\r\n        const max = Math.max(this._radius.x, this._radius.y, this._radius.z);\r\n\r\n        if (distance > this._velocityWorldLength + max + sphereRadius) {\r\n            return false;\r\n        }\r\n\r\n        if (!intersectBoxAASphere(vecMin, vecMax, this._basePointWorld, this._velocityWorldLength + max)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _testTriangle(faceIndex: number, trianglePlaneArray: Array<Plane>, p1: Vector3, p2: Vector3, p3: Vector3, hasMaterial: boolean, hostMesh: AbstractMesh): void {\r\n        let t0;\r\n        let embeddedInPlane = false;\r\n\r\n        //defensive programming, actually not needed.\r\n        if (!trianglePlaneArray) {\r\n            trianglePlaneArray = [];\r\n        }\r\n\r\n        if (!trianglePlaneArray[faceIndex]) {\r\n            trianglePlaneArray[faceIndex] = new Plane(0, 0, 0, 0);\r\n            trianglePlaneArray[faceIndex].copyFromPoints(p1, p2, p3);\r\n        }\r\n\r\n        const trianglePlane = trianglePlaneArray[faceIndex];\r\n\r\n        if (!hasMaterial && !trianglePlane.isFrontFacingTo(this._normalizedVelocity, 0)) {\r\n            return;\r\n        }\r\n\r\n        const signedDistToTrianglePlane = trianglePlane.signedDistanceTo(this._basePoint);\r\n        const normalDotVelocity = Vector3.Dot(trianglePlane.normal, this._velocity);\r\n\r\n        // if DoubleSidedCheck is false(default), a double sided face will be consided 2 times.\r\n        // if true, it discard the faces having normal not facing velocity\r\n        if (Collider.DoubleSidedCheck && normalDotVelocity > 0.0001) {\r\n            return;\r\n        }\r\n\r\n        if (normalDotVelocity == 0) {\r\n            if (Math.abs(signedDistToTrianglePlane) >= 1.0) {\r\n                return;\r\n            }\r\n            embeddedInPlane = true;\r\n            t0 = 0;\r\n        } else {\r\n            t0 = (-1.0 - signedDistToTrianglePlane) / normalDotVelocity;\r\n            let t1 = (1.0 - signedDistToTrianglePlane) / normalDotVelocity;\r\n\r\n            if (t0 > t1) {\r\n                const temp = t1;\r\n                t1 = t0;\r\n                t0 = temp;\r\n            }\r\n\r\n            if (t0 > 1.0 || t1 < 0.0) {\r\n                return;\r\n            }\r\n\r\n            if (t0 < 0) {\r\n                t0 = 0;\r\n            }\r\n            if (t0 > 1.0) {\r\n                t0 = 1.0;\r\n            }\r\n        }\r\n\r\n        this._collisionPoint.copyFromFloats(0, 0, 0);\r\n\r\n        let found = false;\r\n        let t = 1.0;\r\n\r\n        if (!embeddedInPlane) {\r\n            this._basePoint.subtractToRef(trianglePlane.normal, this._planeIntersectionPoint);\r\n            this._velocity.scaleToRef(t0, this._tempVector);\r\n            this._planeIntersectionPoint.addInPlace(this._tempVector);\r\n\r\n            if (this._checkPointInTriangle(this._planeIntersectionPoint, p1, p2, p3, trianglePlane.normal)) {\r\n                found = true;\r\n                t = t0;\r\n                this._collisionPoint.copyFrom(this._planeIntersectionPoint);\r\n            }\r\n        }\r\n\r\n        if (!found) {\r\n            let a = this._velocitySquaredLength;\r\n\r\n            this._basePoint.subtractToRef(p1, this._tempVector);\r\n            let b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\r\n            let c = this._tempVector.lengthSquared() - 1.0;\r\n\r\n            let lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                t = lowestRoot.root;\r\n                found = true;\r\n                this._collisionPoint.copyFrom(p1);\r\n            }\r\n\r\n            this._basePoint.subtractToRef(p2, this._tempVector);\r\n            b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\r\n            c = this._tempVector.lengthSquared() - 1.0;\r\n\r\n            lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                t = lowestRoot.root;\r\n                found = true;\r\n                this._collisionPoint.copyFrom(p2);\r\n            }\r\n\r\n            this._basePoint.subtractToRef(p3, this._tempVector);\r\n            b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\r\n            c = this._tempVector.lengthSquared() - 1.0;\r\n\r\n            lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                t = lowestRoot.root;\r\n                found = true;\r\n                this._collisionPoint.copyFrom(p3);\r\n            }\r\n\r\n            p2.subtractToRef(p1, this._edge);\r\n            p1.subtractToRef(this._basePoint, this._baseToVertex);\r\n            let edgeSquaredLength = this._edge.lengthSquared();\r\n            let edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\r\n            let edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\r\n\r\n            a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\r\n            b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\r\n            c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\r\n\r\n            lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\r\n\r\n                if (f >= 0.0 && f <= 1.0) {\r\n                    t = lowestRoot.root;\r\n                    found = true;\r\n                    this._edge.scaleInPlace(f);\r\n                    p1.addToRef(this._edge, this._collisionPoint);\r\n                }\r\n            }\r\n\r\n            p3.subtractToRef(p2, this._edge);\r\n            p2.subtractToRef(this._basePoint, this._baseToVertex);\r\n            edgeSquaredLength = this._edge.lengthSquared();\r\n            edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\r\n            edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\r\n\r\n            a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\r\n            b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\r\n            c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\r\n            lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\r\n\r\n                if (f >= 0.0 && f <= 1.0) {\r\n                    t = lowestRoot.root;\r\n                    found = true;\r\n                    this._edge.scaleInPlace(f);\r\n                    p2.addToRef(this._edge, this._collisionPoint);\r\n                }\r\n            }\r\n\r\n            p1.subtractToRef(p3, this._edge);\r\n            p3.subtractToRef(this._basePoint, this._baseToVertex);\r\n            edgeSquaredLength = this._edge.lengthSquared();\r\n            edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\r\n            edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\r\n\r\n            a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\r\n            b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\r\n            c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\r\n\r\n            lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\r\n\r\n                if (f >= 0.0 && f <= 1.0) {\r\n                    t = lowestRoot.root;\r\n                    found = true;\r\n                    this._edge.scaleInPlace(f);\r\n                    p3.addToRef(this._edge, this._collisionPoint);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (found) {\r\n            const distToCollisionSquared = t * t * this._velocitySquaredLength;\r\n\r\n            if (!this.collisionFound || distToCollisionSquared < this._nearestDistanceSquared) {\r\n                // if collisionResponse is false, collision is not found but the collidedMesh is set anyway.\r\n                // onCollide observable are triggered if collideMesh is set\r\n                // this allow trigger volumes to be created.\r\n                if (hostMesh.collisionResponse) {\r\n                    if (!this.intersectionPoint) {\r\n                        this.intersectionPoint = this._collisionPoint.clone();\r\n                    } else {\r\n                        this.intersectionPoint.copyFrom(this._collisionPoint);\r\n                    }\r\n                    this._nearestDistanceSquared = distToCollisionSquared;\r\n                    this._nearestDistance = Math.sqrt(distToCollisionSquared);\r\n                    this.collisionFound = true;\r\n                }\r\n                this.collidedMesh = hostMesh;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _collide(\r\n        trianglePlaneArray: Array<Plane>,\r\n        pts: Vector3[],\r\n        indices: IndicesArray,\r\n        indexStart: number,\r\n        indexEnd: number,\r\n        decal: number,\r\n        hasMaterial: boolean,\r\n        hostMesh: AbstractMesh,\r\n        invertTriangles?: boolean,\r\n        triangleStrip: boolean = false\r\n    ): void {\r\n        if (triangleStrip) {\r\n            if (!indices || indices.length === 0) {\r\n                for (let i = 0; i < pts.length - 2; i += 1) {\r\n                    const p1 = pts[i];\r\n                    const p2 = pts[i + 1];\r\n                    const p3 = pts[i + 2];\r\n\r\n                    // stay defensive and don't check against undefined positions.\r\n                    if (!p1 || !p2 || !p3) {\r\n                        continue;\r\n                    }\r\n                    // Handles strip faces one on two is reversed\r\n                    if ((invertTriangles ? 1 : 0) ^ i % 2) {\r\n                        this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\r\n                    } else {\r\n                        this._testTriangle(i, trianglePlaneArray, p2, p1, p3, hasMaterial, hostMesh);\r\n                    }\r\n                }\r\n            } else {\r\n                for (let i = indexStart; i < indexEnd - 2; i += 1) {\r\n                    const indexA = indices[i];\r\n                    const indexB = indices[i + 1];\r\n                    const indexC = indices[i + 2];\r\n\r\n                    if (indexC === 0xffffffff) {\r\n                        i += 2;\r\n                        continue;\r\n                    }\r\n\r\n                    const p1 = pts[indexA];\r\n                    const p2 = pts[indexB];\r\n                    const p3 = pts[indexC];\r\n\r\n                    // stay defensive and don't check against undefined positions.\r\n                    if (!p1 || !p2 || !p3) {\r\n                        continue;\r\n                    }\r\n\r\n                    // Handles strip faces one on two is reversed\r\n                    if ((invertTriangles ? 1 : 0) ^ i % 2) {\r\n                        this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\r\n                    } else {\r\n                        this._testTriangle(i, trianglePlaneArray, p2, p1, p3, hasMaterial, hostMesh);\r\n                    }\r\n                }\r\n            }\r\n        } else if (!indices || indices.length === 0) {\r\n            for (let i = 0; i < pts.length; i += 3) {\r\n                const p1 = pts[i];\r\n                const p2 = pts[i + 1];\r\n                const p3 = pts[i + 2];\r\n\r\n                if (invertTriangles) {\r\n                    this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\r\n                } else {\r\n                    this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);\r\n                }\r\n            }\r\n        } else {\r\n            for (let i = indexStart; i < indexEnd; i += 3) {\r\n                const p1 = pts[indices[i] - decal];\r\n                const p2 = pts[indices[i + 1] - decal];\r\n                const p3 = pts[indices[i + 2] - decal];\r\n\r\n                if (invertTriangles) {\r\n                    this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\r\n                } else {\r\n                    this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getResponse(pos: Vector3, vel: Vector3): void {\r\n        pos.addToRef(vel, this._destinationPoint);\r\n        vel.scaleInPlace(this._nearestDistance / vel.length());\r\n\r\n        this._basePoint.addToRef(vel, pos);\r\n        pos.subtractToRef(this.intersectionPoint, this._slidePlaneNormal);\r\n        this._slidePlaneNormal.normalize();\r\n        this._slidePlaneNormal.scaleToRef(this._epsilon, this._displacementVector);\r\n\r\n        pos.addInPlace(this._displacementVector);\r\n        this.intersectionPoint.addInPlace(this._displacementVector);\r\n\r\n        this._slidePlaneNormal.scaleInPlace(Plane.SignedDistanceToPlaneFromPositionAndNormal(this.intersectionPoint, this._slidePlaneNormal, this._destinationPoint));\r\n        this._destinationPoint.subtractInPlace(this._slidePlaneNormal);\r\n\r\n        this._destinationPoint.subtractToRef(this.intersectionPoint, vel);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}