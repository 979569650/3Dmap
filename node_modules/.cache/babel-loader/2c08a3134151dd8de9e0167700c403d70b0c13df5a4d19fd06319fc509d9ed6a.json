{"ast":null,"code":"import \"core-js/modules/es.array.unshift.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\n/**\n * Class used to explode meshes (ie. to have a center and move them away from that center to better see the overall organization)\n */\nexport class MeshExploder {\n  /**\n   * Explodes meshes from a center mesh.\n   * @param meshes The meshes to explode.\n   * @param centerMesh The mesh to be center of explosion.\n   */\n  constructor(meshes, centerMesh) {\n    this._meshesOrigins = [];\n    this._toCenterVectors = [];\n    this._scaledDirection = new Vector3(1, 1, 1);\n    this._newPosition = Vector3.Zero();\n    this._centerPosition = Vector3.Zero();\n    this._meshes = meshes.slice();\n    if (centerMesh) {\n      this._centerMesh = centerMesh;\n    } else {\n      this._setCenterMesh();\n    }\n    this._centerMesh.computeWorldMatrix(true);\n    const centerMeshIndex = this._meshes.indexOf(this._centerMesh);\n    if (centerMeshIndex >= 0) {\n      this._meshes.splice(centerMeshIndex, 1);\n    }\n    this._centerPosition = this._centerMesh.getAbsolutePosition().clone();\n    for (let index = 0; index < this._meshes.length; index++) {\n      if (this._meshes[index]) {\n        const mesh = this._meshes[index];\n        this._meshesOrigins[index] = mesh.getAbsolutePosition().clone();\n        this._toCenterVectors[index] = Vector3.Zero();\n        if (mesh.hasBoundingInfo && this._centerMesh.hasBoundingInfo) {\n          mesh.computeWorldMatrix(true);\n          mesh.getBoundingInfo().boundingBox.centerWorld.subtractToRef(this._centerMesh.getBoundingInfo().boundingBox.centerWorld, this._toCenterVectors[index]);\n        }\n      }\n    }\n  }\n  _setCenterMesh() {\n    let averageCenter = Vector3.Zero();\n    const totalCenters = Vector3.Zero();\n    let shortestToCenter = Number.MAX_VALUE;\n    for (let index = 0; index < this._meshes.length; index++) {\n      if (this._meshes[index]) {\n        const mesh = this._meshes[index];\n        const boundingInfo = mesh.getBoundingInfo();\n        if (boundingInfo) {\n          totalCenters.addInPlace(boundingInfo.boundingBox.centerWorld);\n        }\n      }\n    }\n    averageCenter = totalCenters.scale(1 / this._meshes.length);\n    for (let index = 0; index < this._meshes.length; index++) {\n      if (this._meshes[index]) {\n        const mesh = this._meshes[index];\n        const boundingInfo = mesh.getBoundingInfo();\n        if (boundingInfo) {\n          const distanceToCenter = boundingInfo.boundingBox.centerWorld.subtract(averageCenter).lengthSquared();\n          if (distanceToCenter < shortestToCenter) {\n            this._centerMesh = mesh;\n            shortestToCenter = distanceToCenter;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Get class name\n   * @returns \"MeshExploder\"\n   */\n  getClassName() {\n    return \"MeshExploder\";\n  }\n  /**\n   * \"Exploded meshes\"\n   * @returns Array of meshes with the centerMesh at index 0.\n   */\n  getMeshes() {\n    const meshArray = this._meshes.slice();\n    meshArray.unshift(this._centerMesh);\n    return meshArray;\n  }\n  /**\n   * Explodes meshes giving a specific direction\n   * @param direction Number to multiply distance of each mesh's origin from center. Use a negative number to implode, or zero to reset.\n   */\n  explode(direction = 1.0) {\n    for (let index = 0; index < this._meshes.length; index++) {\n      if (this._meshes[index] && this._meshesOrigins[index] && this._toCenterVectors[index]) {\n        this._toCenterVectors[index].scaleToRef(direction, this._scaledDirection);\n        this._meshesOrigins[index].addToRef(this._scaledDirection, this._newPosition);\n        this._meshes[index].setAbsolutePosition(this._newPosition);\n      }\n    }\n    this._centerMesh.setAbsolutePosition(this._centerPosition);\n  }\n}","map":{"version":3,"names":["Vector3","MeshExploder","constructor","meshes","centerMesh","_meshesOrigins","_toCenterVectors","_scaledDirection","_newPosition","Zero","_centerPosition","_meshes","slice","_centerMesh","_setCenterMesh","computeWorldMatrix","centerMeshIndex","indexOf","splice","getAbsolutePosition","clone","index","length","mesh","hasBoundingInfo","getBoundingInfo","boundingBox","centerWorld","subtractToRef","averageCenter","totalCenters","shortestToCenter","Number","MAX_VALUE","boundingInfo","addInPlace","scale","distanceToCenter","subtract","lengthSquared","getClassName","getMeshes","meshArray","unshift","explode","direction","scaleToRef","addToRef","setAbsolutePosition"],"sources":["../../../../dev/core/src/Misc/meshExploder.ts"],"sourcesContent":["import type { Mesh } from \"../Meshes/mesh\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\n\r\n/**\r\n * Class used to explode meshes (ie. to have a center and move them away from that center to better see the overall organization)\r\n */\r\nexport class MeshExploder {\r\n    private _centerMesh: Mesh;\r\n    private _meshes: Array<Mesh>;\r\n    private _meshesOrigins: Array<Vector3> = [];\r\n    private _toCenterVectors: Array<Vector3> = [];\r\n    private _scaledDirection = new Vector3(1, 1, 1);\r\n    private _newPosition = Vector3.Zero();\r\n    private _centerPosition = Vector3.Zero();\r\n\r\n    /**\r\n     * Explodes meshes from a center mesh.\r\n     * @param meshes The meshes to explode.\r\n     * @param centerMesh The mesh to be center of explosion.\r\n     */\r\n    constructor(meshes: Array<Mesh>, centerMesh?: Mesh) {\r\n        this._meshes = meshes.slice();\r\n\r\n        if (centerMesh) {\r\n            this._centerMesh = centerMesh;\r\n        } else {\r\n            this._setCenterMesh();\r\n        }\r\n        this._centerMesh.computeWorldMatrix(true);\r\n\r\n        const centerMeshIndex = this._meshes.indexOf(this._centerMesh);\r\n        if (centerMeshIndex >= 0) {\r\n            this._meshes.splice(centerMeshIndex, 1);\r\n        }\r\n        this._centerPosition = this._centerMesh.getAbsolutePosition().clone();\r\n        for (let index = 0; index < this._meshes.length; index++) {\r\n            if (this._meshes[index]) {\r\n                const mesh = this._meshes[index];\r\n                this._meshesOrigins[index] = mesh.getAbsolutePosition().clone();\r\n                this._toCenterVectors[index] = Vector3.Zero();\r\n                if (mesh.hasBoundingInfo && this._centerMesh.hasBoundingInfo) {\r\n                    mesh.computeWorldMatrix(true);\r\n                    mesh.getBoundingInfo().boundingBox.centerWorld.subtractToRef(this._centerMesh.getBoundingInfo().boundingBox.centerWorld, this._toCenterVectors[index]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setCenterMesh(): void {\r\n        let averageCenter = Vector3.Zero();\r\n        const totalCenters = Vector3.Zero();\r\n        let shortestToCenter = Number.MAX_VALUE;\r\n        for (let index = 0; index < this._meshes.length; index++) {\r\n            if (this._meshes[index]) {\r\n                const mesh = this._meshes[index];\r\n                const boundingInfo = mesh.getBoundingInfo();\r\n                if (boundingInfo) {\r\n                    totalCenters.addInPlace(boundingInfo.boundingBox.centerWorld);\r\n                }\r\n            }\r\n        }\r\n        averageCenter = totalCenters.scale(1 / this._meshes.length);\r\n        for (let index = 0; index < this._meshes.length; index++) {\r\n            if (this._meshes[index]) {\r\n                const mesh = this._meshes[index];\r\n                const boundingInfo = mesh.getBoundingInfo();\r\n                if (boundingInfo) {\r\n                    const distanceToCenter = boundingInfo.boundingBox.centerWorld.subtract(averageCenter).lengthSquared();\r\n                    if (distanceToCenter < shortestToCenter) {\r\n                        this._centerMesh = mesh;\r\n                        shortestToCenter = distanceToCenter;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get class name\r\n     * @returns \"MeshExploder\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"MeshExploder\";\r\n    }\r\n\r\n    /**\r\n     * \"Exploded meshes\"\r\n     * @returns Array of meshes with the centerMesh at index 0.\r\n     */\r\n    public getMeshes(): Array<Mesh> {\r\n        const meshArray = this._meshes.slice();\r\n        meshArray.unshift(this._centerMesh);\r\n        return meshArray;\r\n    }\r\n\r\n    /**\r\n     * Explodes meshes giving a specific direction\r\n     * @param direction Number to multiply distance of each mesh's origin from center. Use a negative number to implode, or zero to reset.\r\n     */\r\n    public explode(direction: number = 1.0): void {\r\n        for (let index = 0; index < this._meshes.length; index++) {\r\n            if (this._meshes[index] && this._meshesOrigins[index] && this._toCenterVectors[index]) {\r\n                this._toCenterVectors[index].scaleToRef(direction, this._scaledDirection);\r\n                this._meshesOrigins[index].addToRef(this._scaledDirection, this._newPosition);\r\n                this._meshes[index].setAbsolutePosition(this._newPosition);\r\n            }\r\n        }\r\n        this._centerMesh.setAbsolutePosition(this._centerPosition);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}