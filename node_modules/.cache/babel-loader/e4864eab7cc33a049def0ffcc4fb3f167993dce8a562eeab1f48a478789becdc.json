{"ast":null,"code":"import { FreeCamera } from \"./freeCamera.js\";\nimport { Quaternion, Vector3 } from \"../Maths/math.vector.js\";\nimport { Node } from \"../node.js\";\nimport \"./Inputs/freeCameraDeviceOrientationInput.js\";\nimport { Axis } from \"../Maths/math.axis.js\";\nNode.AddNodeConstructor(\"DeviceOrientationCamera\", (name, scene) => {\n  return () => new DeviceOrientationCamera(name, Vector3.Zero(), scene);\n});\n// We're mainly based on the logic defined into the FreeCamera code\n/**\n * This is a camera specifically designed to react to device orientation events such as a modern mobile device\n * being tilted forward or back and left or right.\n */\nexport class DeviceOrientationCamera extends FreeCamera {\n  /**\n   * Creates a new device orientation camera\n   * @param name The name of the camera\n   * @param position The start position camera\n   * @param scene The scene the camera belongs to\n   */\n  constructor(name, position, scene) {\n    super(name, position, scene);\n    this._tmpDragQuaternion = new Quaternion();\n    this._disablePointerInputWhenUsingDeviceOrientation = true;\n    this._dragFactor = 0;\n    this._quaternionCache = new Quaternion();\n    this.inputs.addDeviceOrientation();\n    // When the orientation sensor fires it's first event, disable mouse input\n    if (this.inputs._deviceOrientationInput) {\n      this.inputs._deviceOrientationInput._onDeviceOrientationChangedObservable.addOnce(() => {\n        if (this._disablePointerInputWhenUsingDeviceOrientation) {\n          if (this.inputs._mouseInput) {\n            this.inputs._mouseInput._allowCameraRotation = false;\n            this.inputs._mouseInput.onPointerMovedObservable.add(e => {\n              if (this._dragFactor != 0) {\n                if (!this._initialQuaternion) {\n                  this._initialQuaternion = new Quaternion();\n                }\n                // Rotate the initial space around the y axis to allow users to \"turn around\" via touch/mouse\n                Quaternion.FromEulerAnglesToRef(0, e.offsetX * this._dragFactor, 0, this._tmpDragQuaternion);\n                this._initialQuaternion.multiplyToRef(this._tmpDragQuaternion, this._initialQuaternion);\n              }\n            });\n          }\n        }\n      });\n    }\n  }\n  /**\n   * Gets or sets a boolean indicating that pointer input must be disabled on first orientation sensor update (Default: true)\n   */\n  get disablePointerInputWhenUsingDeviceOrientation() {\n    return this._disablePointerInputWhenUsingDeviceOrientation;\n  }\n  set disablePointerInputWhenUsingDeviceOrientation(value) {\n    this._disablePointerInputWhenUsingDeviceOrientation = value;\n  }\n  /**\n   * Enabled turning on the y axis when the orientation sensor is active\n   * @param dragFactor the factor that controls the turn speed (default: 1/300)\n   */\n  enableHorizontalDragging(dragFactor = 1 / 300) {\n    this._dragFactor = dragFactor;\n  }\n  /**\n   * Gets the current instance class name (\"DeviceOrientationCamera\").\n   * This helps avoiding instanceof at run time.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"DeviceOrientationCamera\";\n  }\n  /**\n   * @internal\n   * Checks and applies the current values of the inputs to the camera. (Internal use only)\n   */\n  _checkInputs() {\n    super._checkInputs();\n    this._quaternionCache.copyFrom(this.rotationQuaternion);\n    if (this._initialQuaternion) {\n      this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\n    }\n  }\n  /**\n   * Reset the camera to its default orientation on the specified axis only.\n   * @param axis The axis to reset\n   */\n  resetToCurrentRotation(axis = Axis.Y) {\n    //can only work if this camera has a rotation quaternion already.\n    if (!this.rotationQuaternion) {\n      return;\n    }\n    if (!this._initialQuaternion) {\n      this._initialQuaternion = new Quaternion();\n    }\n    this._initialQuaternion.copyFrom(this._quaternionCache || this.rotationQuaternion);\n    [\"x\", \"y\", \"z\"].forEach(axisName => {\n      if (!axis[axisName]) {\n        this._initialQuaternion[axisName] = 0;\n      } else {\n        this._initialQuaternion[axisName] *= -1;\n      }\n    });\n    this._initialQuaternion.normalize();\n    //force rotation update\n    this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\n  }\n}","map":{"version":3,"names":["FreeCamera","Quaternion","Vector3","Node","Axis","AddNodeConstructor","name","scene","DeviceOrientationCamera","Zero","constructor","position","_tmpDragQuaternion","_disablePointerInputWhenUsingDeviceOrientation","_dragFactor","_quaternionCache","inputs","addDeviceOrientation","_deviceOrientationInput","_onDeviceOrientationChangedObservable","addOnce","_mouseInput","_allowCameraRotation","onPointerMovedObservable","add","e","_initialQuaternion","FromEulerAnglesToRef","offsetX","multiplyToRef","disablePointerInputWhenUsingDeviceOrientation","value","enableHorizontalDragging","dragFactor","getClassName","_checkInputs","copyFrom","rotationQuaternion","resetToCurrentRotation","axis","Y","forEach","axisName","normalize"],"sources":["../../../../dev/core/src/Cameras/deviceOrientationCamera.ts"],"sourcesContent":["import { FreeCamera } from \"./freeCamera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\n\r\nimport \"./Inputs/freeCameraDeviceOrientationInput\";\r\nimport { Axis } from \"../Maths/math.axis\";\r\n\r\nNode.AddNodeConstructor(\"DeviceOrientationCamera\", (name, scene) => {\r\n    return () => new DeviceOrientationCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n// We're mainly based on the logic defined into the FreeCamera code\r\n/**\r\n * This is a camera specifically designed to react to device orientation events such as a modern mobile device\r\n * being tilted forward or back and left or right.\r\n */\r\nexport class DeviceOrientationCamera extends FreeCamera {\r\n    private _initialQuaternion: Quaternion;\r\n    private _quaternionCache: Quaternion;\r\n    private _tmpDragQuaternion = new Quaternion();\r\n    private _disablePointerInputWhenUsingDeviceOrientation = true;\r\n\r\n    /**\r\n     * Creates a new device orientation camera\r\n     * @param name The name of the camera\r\n     * @param position The start position camera\r\n     * @param scene The scene the camera belongs to\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene) {\r\n        super(name, position, scene);\r\n        this._quaternionCache = new Quaternion();\r\n        this.inputs.addDeviceOrientation();\r\n\r\n        // When the orientation sensor fires it's first event, disable mouse input\r\n        if (this.inputs._deviceOrientationInput) {\r\n            this.inputs._deviceOrientationInput._onDeviceOrientationChangedObservable.addOnce(() => {\r\n                if (this._disablePointerInputWhenUsingDeviceOrientation) {\r\n                    if (this.inputs._mouseInput) {\r\n                        this.inputs._mouseInput._allowCameraRotation = false;\r\n                        this.inputs._mouseInput.onPointerMovedObservable.add((e) => {\r\n                            if (this._dragFactor != 0) {\r\n                                if (!this._initialQuaternion) {\r\n                                    this._initialQuaternion = new Quaternion();\r\n                                }\r\n                                // Rotate the initial space around the y axis to allow users to \"turn around\" via touch/mouse\r\n                                Quaternion.FromEulerAnglesToRef(0, e.offsetX * this._dragFactor, 0, this._tmpDragQuaternion);\r\n                                this._initialQuaternion.multiplyToRef(this._tmpDragQuaternion, this._initialQuaternion);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that pointer input must be disabled on first orientation sensor update (Default: true)\r\n     */\r\n    public get disablePointerInputWhenUsingDeviceOrientation() {\r\n        return this._disablePointerInputWhenUsingDeviceOrientation;\r\n    }\r\n\r\n    public set disablePointerInputWhenUsingDeviceOrientation(value: boolean) {\r\n        this._disablePointerInputWhenUsingDeviceOrientation = value;\r\n    }\r\n\r\n    private _dragFactor = 0;\r\n    /**\r\n     * Enabled turning on the y axis when the orientation sensor is active\r\n     * @param dragFactor the factor that controls the turn speed (default: 1/300)\r\n     */\r\n    public enableHorizontalDragging(dragFactor = 1 / 300) {\r\n        this._dragFactor = dragFactor;\r\n    }\r\n\r\n    /**\r\n     * Gets the current instance class name (\"DeviceOrientationCamera\").\r\n     * This helps avoiding instanceof at run time.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"DeviceOrientationCamera\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Checks and applies the current values of the inputs to the camera. (Internal use only)\r\n     */\r\n    public _checkInputs(): void {\r\n        super._checkInputs();\r\n        this._quaternionCache.copyFrom(this.rotationQuaternion);\r\n        if (this._initialQuaternion) {\r\n            this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reset the camera to its default orientation on the specified axis only.\r\n     * @param axis The axis to reset\r\n     */\r\n    public resetToCurrentRotation(axis: Axis = Axis.Y): void {\r\n        //can only work if this camera has a rotation quaternion already.\r\n        if (!this.rotationQuaternion) {\r\n            return;\r\n        }\r\n\r\n        if (!this._initialQuaternion) {\r\n            this._initialQuaternion = new Quaternion();\r\n        }\r\n\r\n        this._initialQuaternion.copyFrom(this._quaternionCache || this.rotationQuaternion);\r\n\r\n        [\"x\", \"y\", \"z\"].forEach((axisName) => {\r\n            if (!(<any>axis)[axisName]) {\r\n                (<any>this._initialQuaternion)[axisName] = 0;\r\n            } else {\r\n                (<any>this._initialQuaternion)[axisName] *= -1;\r\n            }\r\n        });\r\n        this._initialQuaternion.normalize();\r\n        //force rotation update\r\n        this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}