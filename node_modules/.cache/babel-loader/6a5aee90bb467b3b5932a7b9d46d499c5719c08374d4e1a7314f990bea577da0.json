{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterial } from \"../nodeMaterial.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { Texture } from \"../../Textures/texture.js\";\nimport \"../../../Shaders/ShadersInclude/helperFunctions.js\";\nimport { ImageSourceBlock } from \"./Dual/imageSourceBlock.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../nodeMaterialConnectionPointCustomObject.js\";\nimport { EngineStore } from \"../../../Engines/engineStore.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../Decorators/nodeDecorator.js\";\n/**\n * Block used to read a texture with triplanar mapping (see \"boxmap\" in https://iquilezles.org/articles/biplanar/)\n */\nexport class TriPlanarBlock extends NodeMaterialBlock {\n  /**\n   * Gets or sets the texture associated with the node\n   */\n  get texture() {\n    var _a;\n    if (this.source.isConnected) {\n      return ((_a = this.source.connectedPoint) === null || _a === void 0 ? void 0 : _a.ownerBlock).texture;\n    }\n    return this._texture;\n  }\n  set texture(texture) {\n    var _a;\n    if (this._texture === texture) {\n      return;\n    }\n    const scene = (_a = texture === null || texture === void 0 ? void 0 : texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;\n    if (!texture && scene) {\n      scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this._texture);\n      });\n    }\n    this._texture = texture;\n    if (texture && scene) {\n      scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(texture);\n      });\n    }\n  }\n  /**\n   * Gets the textureY associated with the node\n   */\n  get textureY() {\n    var _a;\n    if (this.sourceY.isConnected) {\n      return ((_a = this.sourceY.connectedPoint) === null || _a === void 0 ? void 0 : _a.ownerBlock).texture;\n    }\n    return null;\n  }\n  /**\n   * Gets the textureZ associated with the node\n   */\n  get textureZ() {\n    var _a, _b;\n    if ((_a = this.sourceZ) === null || _a === void 0 ? void 0 : _a.isConnected) {\n      return ((_b = this.sourceY.connectedPoint) === null || _b === void 0 ? void 0 : _b.ownerBlock).texture;\n    }\n    return null;\n  }\n  _getImageSourceBlock(connectionPoint) {\n    return (connectionPoint === null || connectionPoint === void 0 ? void 0 : connectionPoint.isConnected) ? connectionPoint.connectedPoint.ownerBlock : null;\n  }\n  /**\n   * Gets the sampler name associated with this texture\n   */\n  get samplerName() {\n    const imageSourceBlock = this._getImageSourceBlock(this.source);\n    if (imageSourceBlock) {\n      return imageSourceBlock.samplerName;\n    }\n    return this._samplerName;\n  }\n  /**\n   * Gets the samplerY name associated with this texture\n   */\n  get samplerYName() {\n    var _a, _b;\n    return (_b = (_a = this._getImageSourceBlock(this.sourceY)) === null || _a === void 0 ? void 0 : _a.samplerName) !== null && _b !== void 0 ? _b : null;\n  }\n  /**\n   * Gets the samplerZ name associated with this texture\n   */\n  get samplerZName() {\n    var _a, _b;\n    return (_b = (_a = this._getImageSourceBlock(this.sourceZ)) === null || _a === void 0 ? void 0 : _a.samplerName) !== null && _b !== void 0 ? _b : null;\n  }\n  /**\n   * Gets a boolean indicating that this block is linked to an ImageSourceBlock\n   */\n  get hasImageSource() {\n    return this.source.isConnected;\n  }\n  /**\n   * Gets or sets a boolean indicating if content needs to be converted to gamma space\n   */\n  set convertToGammaSpace(value) {\n    var _a;\n    if (value === this._convertToGammaSpace) {\n      return;\n    }\n    this._convertToGammaSpace = value;\n    if (this.texture) {\n      const scene = (_a = this.texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;\n      scene === null || scene === void 0 ? void 0 : scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this.texture);\n      });\n    }\n  }\n  get convertToGammaSpace() {\n    return this._convertToGammaSpace;\n  }\n  /**\n   * Gets or sets a boolean indicating if content needs to be converted to linear space\n   */\n  set convertToLinearSpace(value) {\n    var _a;\n    if (value === this._convertToLinearSpace) {\n      return;\n    }\n    this._convertToLinearSpace = value;\n    if (this.texture) {\n      const scene = (_a = this.texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;\n      scene === null || scene === void 0 ? void 0 : scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this.texture);\n      });\n    }\n  }\n  get convertToLinearSpace() {\n    return this._convertToLinearSpace;\n  }\n  /**\n   * Create a new TriPlanarBlock\n   * @param name defines the block name\n   */\n  constructor(name, hideSourceZ = false) {\n    super(name, NodeMaterialBlockTargets.Neutral);\n    /**\n     * Project the texture(s) for a better fit to a cube\n     */\n    this.projectAsCube = false;\n    this._convertToGammaSpace = false;\n    this._convertToLinearSpace = false;\n    /**\n     * Gets or sets a boolean indicating if multiplication of texture with level should be disabled\n     */\n    this.disableLevelMultiplication = false;\n    this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);\n    this.registerInput(\"normal\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);\n    this.registerInput(\"sharpness\", NodeMaterialBlockConnectionPointTypes.Float, true);\n    this.registerInput(\"source\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(\"source\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\"));\n    this.registerInput(\"sourceY\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(\"sourceY\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\"));\n    if (!hideSourceZ) {\n      this.registerInput(\"sourceZ\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(\"sourceZ\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\"));\n    }\n    this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"level\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n    this._inputs[1].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"TriPlanarBlock\";\n  }\n  /**\n   * Gets the position input component\n   */\n  get position() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the normal input component\n   */\n  get normal() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the sharpness input component\n   */\n  get sharpness() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the source input component\n   */\n  get source() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the sourceY input component\n   */\n  get sourceY() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the sourceZ input component\n   */\n  get sourceZ() {\n    return this._inputs[5];\n  }\n  /**\n   * Gets the rgba output component\n   */\n  get rgba() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the rgb output component\n   */\n  get rgb() {\n    return this._outputs[1];\n  }\n  /**\n   * Gets the r output component\n   */\n  get r() {\n    return this._outputs[2];\n  }\n  /**\n   * Gets the g output component\n   */\n  get g() {\n    return this._outputs[3];\n  }\n  /**\n   * Gets the b output component\n   */\n  get b() {\n    return this._outputs[4];\n  }\n  /**\n   * Gets the a output component\n   */\n  get a() {\n    return this._outputs[5];\n  }\n  /**\n   * Gets the level output component\n   */\n  get level() {\n    return this._outputs[6];\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    if (!defines._areTexturesDirty) {\n      return;\n    }\n    const toGamma = this.convertToGammaSpace && this.texture && !this.texture.gammaSpace;\n    const toLinear = this.convertToLinearSpace && this.texture && this.texture.gammaSpace;\n    // Not a bug... Name defines the texture space not the required conversion\n    defines.setValue(this._linearDefineName, toGamma, true);\n    defines.setValue(this._gammaDefineName, toLinear, true);\n  }\n  isReady() {\n    if (this.texture && !this.texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n    return true;\n  }\n  bind(effect) {\n    if (!this.texture) {\n      return;\n    }\n    effect.setFloat(this._textureInfoName, this.texture.level);\n    if (!this._imageSource) {\n      effect.setTexture(this._samplerName, this.texture);\n    }\n  }\n  _generateTextureLookup(state) {\n    var _a, _b;\n    const samplerName = this.samplerName;\n    const samplerYName = (_a = this.samplerYName) !== null && _a !== void 0 ? _a : samplerName;\n    const samplerZName = (_b = this.samplerZName) !== null && _b !== void 0 ? _b : samplerName;\n    const sharpness = this.sharpness.isConnected ? this.sharpness.associatedVariableName : \"1.0\";\n    const x = state._getFreeVariableName(\"x\");\n    const y = state._getFreeVariableName(\"y\");\n    const z = state._getFreeVariableName(\"z\");\n    const w = state._getFreeVariableName(\"w\");\n    const n = state._getFreeVariableName(\"n\");\n    const uvx = state._getFreeVariableName(\"uvx\");\n    const uvy = state._getFreeVariableName(\"uvy\");\n    const uvz = state._getFreeVariableName(\"uvz\");\n    state.compilationString += `\n            vec3 ${n} = ${this.normal.associatedVariableName}.xyz;\n\n            vec2 ${uvx} = ${this.position.associatedVariableName}.yz;\n            vec2 ${uvy} = ${this.position.associatedVariableName}.zx;\n            vec2 ${uvz} = ${this.position.associatedVariableName}.xy;\n        `;\n    if (this.projectAsCube) {\n      state.compilationString += `\n                ${uvx}.xy = ${uvx}.yx;\n\n                if (${n}.x >= 0.0) {\n                    ${uvx}.x = -${uvx}.x;\n                }\n                if (${n}.y < 0.0) {\n                    ${uvy}.y = -${uvy}.y;\n                }\n                if (${n}.z < 0.0) {\n                    ${uvz}.x = -${uvz}.x;\n                }\n            `;\n    }\n    state.compilationString += `\n            vec4 ${x} = texture2D(${samplerName}, ${uvx});\n            vec4 ${y} = texture2D(${samplerYName}, ${uvy});\n            vec4 ${z} = texture2D(${samplerZName}, ${uvz});\n           \n            // blend weights\n            vec3 ${w} = pow(abs(${n}), vec3(${sharpness}));\n\n            // blend and return\n            vec4 ${this._tempTextureRead} = (${x}*${w}.x + ${y}*${w}.y + ${z}*${w}.z) / (${w}.x + ${w}.y + ${w}.z);        \n        `;\n  }\n  _generateConversionCode(state, output, swizzle) {\n    if (swizzle !== \"a\") {\n      // no conversion if the output is \"a\" (alpha)\n      if (!this.texture || !this.texture.gammaSpace) {\n        state.compilationString += `#ifdef ${this._linearDefineName}\n                    ${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\n                    #endif\n                `;\n      }\n      state.compilationString += `#ifdef ${this._gammaDefineName}\n                ${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\n                #endif\n            `;\n    }\n  }\n  _writeOutput(state, output, swizzle) {\n    let complement = \"\";\n    if (!this.disableLevelMultiplication) {\n      complement = ` * ${this._textureInfoName}`;\n    }\n    state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle}${complement};\\n`;\n    this._generateConversionCode(state, output, swizzle);\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    if (this.source.isConnected) {\n      this._imageSource = this.source.connectedPoint.ownerBlock;\n    } else {\n      this._imageSource = null;\n    }\n    this._textureInfoName = state._getFreeVariableName(\"textureInfoName\");\n    this.level.associatedVariableName = this._textureInfoName;\n    this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\n    this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\n    this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\n    if (!this._imageSource) {\n      this._samplerName = state._getFreeVariableName(this.name + \"Sampler\");\n      state._emit2DSampler(this._samplerName);\n    }\n    // Declarations\n    state.sharedData.blockingBlocks.push(this);\n    state.sharedData.textureBlocks.push(this);\n    state.sharedData.blocksWithDefines.push(this);\n    state.sharedData.bindableBlocks.push(this);\n    const comments = `//${this.name}`;\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n    state._emitUniformFromString(this._textureInfoName, \"float\");\n    this._generateTextureLookup(state);\n    for (const output of this._outputs) {\n      if (output.hasEndpoints && output.name !== \"level\") {\n        this._writeOutput(state, output, output.name);\n      }\n    }\n    return this;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode();\n    codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\\n`;\n    codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\\n`;\n    codeString += `${this._codeVariableName}.disableLevelMultiplication = ${this.disableLevelMultiplication};\\n`;\n    codeString += `${this._codeVariableName}.projectAsCube = ${this.projectAsCube};\\n`;\n    if (!this.texture) {\n      return codeString;\n    }\n    codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});\\n`;\n    codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};\\n`;\n    codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};\\n`;\n    codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};\\n`;\n    codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};\\n`;\n    codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};\\n`;\n    codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};\\n`;\n    codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};\\n`;\n    codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};\\n`;\n    codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};\\n`;\n    codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\n`;\n    return codeString;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.convertToGammaSpace = this.convertToGammaSpace;\n    serializationObject.convertToLinearSpace = this.convertToLinearSpace;\n    serializationObject.disableLevelMultiplication = this.disableLevelMultiplication;\n    serializationObject.projectAsCube = this.projectAsCube;\n    if (!this.hasImageSource && this.texture && !this.texture.isRenderTarget && this.texture.getClassName() !== \"VideoTexture\") {\n      serializationObject.texture = this.texture.serialize();\n    }\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    this.convertToGammaSpace = serializationObject.convertToGammaSpace;\n    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\n    this.disableLevelMultiplication = !!serializationObject.disableLevelMultiplication;\n    this.projectAsCube = !!serializationObject.projectAsCube;\n    if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime && serializationObject.texture.url !== undefined) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n    }\n  }\n}\n__decorate([editableInPropertyPage(\"Project as cube\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    update: true\n  }\n})], TriPlanarBlock.prototype, \"projectAsCube\", void 0);\nRegisterClass(\"BABYLON.TriPlanarBlock\", TriPlanarBlock);","map":{"version":3,"names":["NodeMaterialBlock","NodeMaterialBlockConnectionPointTypes","NodeMaterialBlockTargets","NodeMaterialConnectionPointDirection","NodeMaterial","RegisterClass","Texture","ImageSourceBlock","NodeMaterialConnectionPointCustomObject","EngineStore","editableInPropertyPage","PropertyTypeForEdition","TriPlanarBlock","texture","source","isConnected","_a","connectedPoint","ownerBlock","_texture","scene","getScene","LastCreatedScene","markAllMaterialsAsDirty","mat","hasTexture","textureY","sourceY","textureZ","sourceZ","_b","_getImageSourceBlock","connectionPoint","samplerName","imageSourceBlock","_samplerName","samplerYName","samplerZName","hasImageSource","convertToGammaSpace","value","_convertToGammaSpace","convertToLinearSpace","_convertToLinearSpace","constructor","name","hideSourceZ","Neutral","projectAsCube","disableLevelMultiplication","registerInput","AutoDetect","Float","Object","VertexAndFragment","Input","registerOutput","Color4","Color3","_inputs","addExcludedConnectionPointFromAllowedTypes","Vector3","Vector4","getClassName","position","normal","sharpness","rgba","_outputs","rgb","r","g","b","a","level","prepareDefines","mesh","nodeMaterial","defines","_areTexturesDirty","toGamma","gammaSpace","toLinear","setValue","_linearDefineName","_gammaDefineName","isReady","isReadyOrNotBlocking","bind","effect","setFloat","_textureInfoName","_imageSource","setTexture","_generateTextureLookup","state","associatedVariableName","x","_getFreeVariableName","y","z","w","n","uvx","uvy","uvz","compilationString","_tempTextureRead","_generateConversionCode","output","swizzle","_writeOutput","complement","_declareOutput","_buildBlock","_getFreeDefineName","_emit2DSampler","sharedData","blockingBlocks","push","textureBlocks","blocksWithDefines","bindableBlocks","comments","_emitFunctionFromInclude","_emitUniformFromString","hasEndpoints","_dumpPropertiesCode","codeString","_codeVariableName","noMipmap","invertY","samplingMode","wrapU","wrapV","uAng","vAng","wAng","uOffset","vOffset","uScale","vScale","coordinatesMode","serialize","serializationObject","isRenderTarget","_deserialize","rootUrl","IgnoreTexturesAtLoadTime","url","undefined","indexOf","Parse","__decorate","Boolean","notifiers","update"],"sources":["../../../../../../dev/core/src/Materials/Node/Blocks/triPlanarBlock.ts"],"sourcesContent":["import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport type { AbstractMesh } from \"../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterialDefines } from \"../nodeMaterial\";\r\nimport { NodeMaterial } from \"../nodeMaterial\";\r\nimport type { Effect } from \"../../effect\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { Texture } from \"../../Textures/texture\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport \"../../../Shaders/ShadersInclude/helperFunctions\";\r\nimport { ImageSourceBlock } from \"./Dual/imageSourceBlock\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../nodeMaterialConnectionPointCustomObject\";\r\nimport { EngineStore } from \"../../../Engines/engineStore\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Block used to read a texture with triplanar mapping (see \"boxmap\" in https://iquilezles.org/articles/biplanar/)\r\n */\r\nexport class TriPlanarBlock extends NodeMaterialBlock {\r\n    private _linearDefineName: string;\r\n    private _gammaDefineName: string;\r\n    protected _tempTextureRead: string;\r\n    private _samplerName: string;\r\n    private _textureInfoName: string;\r\n    private _imageSource: Nullable<ImageSourceBlock>;\r\n\r\n    /**\r\n     * Project the texture(s) for a better fit to a cube\r\n     */\r\n    @editableInPropertyPage(\"Project as cube\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { update: true } })\r\n    public projectAsCube: boolean = false;\r\n\r\n    protected _texture: Nullable<Texture>;\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public get texture(): Nullable<Texture> {\r\n        if (this.source.isConnected) {\r\n            return (this.source.connectedPoint?.ownerBlock as ImageSourceBlock).texture;\r\n        }\r\n        return this._texture;\r\n    }\r\n\r\n    public set texture(texture: Nullable<Texture>) {\r\n        if (this._texture === texture) {\r\n            return;\r\n        }\r\n\r\n        const scene = texture?.getScene() ?? EngineStore.LastCreatedScene;\r\n\r\n        if (!texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this._texture!);\r\n            });\r\n        }\r\n\r\n        this._texture = texture;\r\n\r\n        if (texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(texture);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the textureY associated with the node\r\n     */\r\n    public get textureY(): Nullable<Texture> {\r\n        if (this.sourceY.isConnected) {\r\n            return (this.sourceY.connectedPoint?.ownerBlock as ImageSourceBlock).texture;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the textureZ associated with the node\r\n     */\r\n    public get textureZ(): Nullable<Texture> {\r\n        if (this.sourceZ?.isConnected) {\r\n            return (this.sourceY.connectedPoint?.ownerBlock as ImageSourceBlock).texture;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    protected _getImageSourceBlock(connectionPoint: Nullable<NodeMaterialConnectionPoint>): Nullable<ImageSourceBlock> {\r\n        return connectionPoint?.isConnected ? (connectionPoint.connectedPoint!.ownerBlock as ImageSourceBlock) : null;\r\n    }\r\n\r\n    /**\r\n     * Gets the sampler name associated with this texture\r\n     */\r\n    public get samplerName(): string {\r\n        const imageSourceBlock = this._getImageSourceBlock(this.source);\r\n        if (imageSourceBlock) {\r\n            return imageSourceBlock.samplerName;\r\n        }\r\n        return this._samplerName;\r\n    }\r\n\r\n    /**\r\n     * Gets the samplerY name associated with this texture\r\n     */\r\n    public get samplerYName(): Nullable<string> {\r\n        return this._getImageSourceBlock(this.sourceY)?.samplerName ?? null;\r\n    }\r\n\r\n    /**\r\n     * Gets the samplerZ name associated with this texture\r\n     */\r\n    public get samplerZName(): Nullable<string> {\r\n        return this._getImageSourceBlock(this.sourceZ)?.samplerName ?? null;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block is linked to an ImageSourceBlock\r\n     */\r\n    public get hasImageSource(): boolean {\r\n        return this.source.isConnected;\r\n    }\r\n\r\n    private _convertToGammaSpace = false;\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\r\n     */\r\n    public set convertToGammaSpace(value: boolean) {\r\n        if (value === this._convertToGammaSpace) {\r\n            return;\r\n        }\r\n\r\n        this._convertToGammaSpace = value;\r\n        if (this.texture) {\r\n            const scene = this.texture.getScene() ?? EngineStore.LastCreatedScene;\r\n            scene?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this.texture!);\r\n            });\r\n        }\r\n    }\r\n    public get convertToGammaSpace(): boolean {\r\n        return this._convertToGammaSpace;\r\n    }\r\n\r\n    private _convertToLinearSpace = false;\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\r\n     */\r\n    public set convertToLinearSpace(value: boolean) {\r\n        if (value === this._convertToLinearSpace) {\r\n            return;\r\n        }\r\n\r\n        this._convertToLinearSpace = value;\r\n        if (this.texture) {\r\n            const scene = this.texture.getScene() ?? EngineStore.LastCreatedScene;\r\n            scene?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this.texture!);\r\n            });\r\n        }\r\n    }\r\n    public get convertToLinearSpace(): boolean {\r\n        return this._convertToLinearSpace;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if multiplication of texture with level should be disabled\r\n     */\r\n    public disableLevelMultiplication = false;\r\n\r\n    /**\r\n     * Create a new TriPlanarBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string, hideSourceZ = false) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);\r\n        this.registerInput(\"normal\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);\r\n        this.registerInput(\"sharpness\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\r\n            \"source\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"source\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\")\r\n        );\r\n        this.registerInput(\r\n            \"sourceY\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"sourceY\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\")\r\n        );\r\n        if (!hideSourceZ) {\r\n            this.registerInput(\r\n                \"sourceZ\",\r\n                NodeMaterialBlockConnectionPointTypes.Object,\r\n                true,\r\n                NodeMaterialBlockTargets.VertexAndFragment,\r\n                new NodeMaterialConnectionPointCustomObject(\"sourceZ\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\")\r\n            );\r\n        }\r\n\r\n        this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerOutput(\"level\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n        this._inputs[1].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"TriPlanarBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the position input component\r\n     */\r\n    public get position(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the normal input component\r\n     */\r\n    public get normal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the sharpness input component\r\n     */\r\n    public get sharpness(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the source input component\r\n     */\r\n    public get source(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the sourceY input component\r\n     */\r\n    public get sourceY(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the sourceZ input component\r\n     */\r\n    public get sourceZ(): Nullable<NodeMaterialConnectionPoint> {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba output component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb output component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the r output component\r\n     */\r\n    public get r(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the g output component\r\n     */\r\n    public get g(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the b output component\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the a output component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the level output component\r\n     */\r\n    public get level(): NodeMaterialConnectionPoint {\r\n        return this._outputs[6];\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        if (!defines._areTexturesDirty) {\r\n            return;\r\n        }\r\n\r\n        const toGamma = this.convertToGammaSpace && this.texture && !this.texture.gammaSpace;\r\n        const toLinear = this.convertToLinearSpace && this.texture && this.texture.gammaSpace;\r\n\r\n        // Not a bug... Name defines the texture space not the required conversion\r\n        defines.setValue(this._linearDefineName, toGamma, true);\r\n        defines.setValue(this._gammaDefineName, toLinear, true);\r\n    }\r\n\r\n    public isReady() {\r\n        if (this.texture && !this.texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public bind(effect: Effect) {\r\n        if (!this.texture) {\r\n            return;\r\n        }\r\n\r\n        effect.setFloat(this._textureInfoName, this.texture.level);\r\n\r\n        if (!this._imageSource) {\r\n            effect.setTexture(this._samplerName, this.texture);\r\n        }\r\n    }\r\n\r\n    protected _generateTextureLookup(state: NodeMaterialBuildState): void {\r\n        const samplerName = this.samplerName;\r\n        const samplerYName = this.samplerYName ?? samplerName;\r\n        const samplerZName = this.samplerZName ?? samplerName;\r\n\r\n        const sharpness = this.sharpness.isConnected ? this.sharpness.associatedVariableName : \"1.0\";\r\n\r\n        const x = state._getFreeVariableName(\"x\");\r\n        const y = state._getFreeVariableName(\"y\");\r\n        const z = state._getFreeVariableName(\"z\");\r\n        const w = state._getFreeVariableName(\"w\");\r\n        const n = state._getFreeVariableName(\"n\");\r\n        const uvx = state._getFreeVariableName(\"uvx\");\r\n        const uvy = state._getFreeVariableName(\"uvy\");\r\n        const uvz = state._getFreeVariableName(\"uvz\");\r\n\r\n        state.compilationString += `\r\n            vec3 ${n} = ${this.normal.associatedVariableName}.xyz;\r\n\r\n            vec2 ${uvx} = ${this.position.associatedVariableName}.yz;\r\n            vec2 ${uvy} = ${this.position.associatedVariableName}.zx;\r\n            vec2 ${uvz} = ${this.position.associatedVariableName}.xy;\r\n        `;\r\n\r\n        if (this.projectAsCube) {\r\n            state.compilationString += `\r\n                ${uvx}.xy = ${uvx}.yx;\r\n\r\n                if (${n}.x >= 0.0) {\r\n                    ${uvx}.x = -${uvx}.x;\r\n                }\r\n                if (${n}.y < 0.0) {\r\n                    ${uvy}.y = -${uvy}.y;\r\n                }\r\n                if (${n}.z < 0.0) {\r\n                    ${uvz}.x = -${uvz}.x;\r\n                }\r\n            `;\r\n        }\r\n\r\n        state.compilationString += `\r\n            vec4 ${x} = texture2D(${samplerName}, ${uvx});\r\n            vec4 ${y} = texture2D(${samplerYName}, ${uvy});\r\n            vec4 ${z} = texture2D(${samplerZName}, ${uvz});\r\n           \r\n            // blend weights\r\n            vec3 ${w} = pow(abs(${n}), vec3(${sharpness}));\r\n\r\n            // blend and return\r\n            vec4 ${this._tempTextureRead} = (${x}*${w}.x + ${y}*${w}.y + ${z}*${w}.z) / (${w}.x + ${w}.y + ${w}.z);        \r\n        `;\r\n    }\r\n\r\n    private _generateConversionCode(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string): void {\r\n        if (swizzle !== \"a\") {\r\n            // no conversion if the output is \"a\" (alpha)\r\n            if (!this.texture || !this.texture.gammaSpace) {\r\n                state.compilationString += `#ifdef ${this._linearDefineName}\r\n                    ${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\r\n                    #endif\r\n                `;\r\n            }\r\n\r\n            state.compilationString += `#ifdef ${this._gammaDefineName}\r\n                ${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\r\n                #endif\r\n            `;\r\n        }\r\n    }\r\n\r\n    private _writeOutput(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string) {\r\n        let complement = \"\";\r\n\r\n        if (!this.disableLevelMultiplication) {\r\n            complement = ` * ${this._textureInfoName}`;\r\n        }\r\n\r\n        state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle}${complement};\\n`;\r\n        this._generateConversionCode(state, output, swizzle);\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (this.source.isConnected) {\r\n            this._imageSource = this.source.connectedPoint!.ownerBlock as ImageSourceBlock;\r\n        } else {\r\n            this._imageSource = null;\r\n        }\r\n\r\n        this._textureInfoName = state._getFreeVariableName(\"textureInfoName\");\r\n\r\n        this.level.associatedVariableName = this._textureInfoName;\r\n\r\n        this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\r\n        this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\r\n        this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\r\n\r\n        if (!this._imageSource) {\r\n            this._samplerName = state._getFreeVariableName(this.name + \"Sampler\");\r\n\r\n            state._emit2DSampler(this._samplerName);\r\n        }\r\n\r\n        // Declarations\r\n        state.sharedData.blockingBlocks.push(this);\r\n        state.sharedData.textureBlocks.push(this);\r\n        state.sharedData.blocksWithDefines.push(this);\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        state._emitUniformFromString(this._textureInfoName, \"float\");\r\n\r\n        this._generateTextureLookup(state);\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints && output.name !== \"level\") {\r\n                this._writeOutput(state, output, output.name);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\\n`;\r\n        codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\\n`;\r\n        codeString += `${this._codeVariableName}.disableLevelMultiplication = ${this.disableLevelMultiplication};\\n`;\r\n        codeString += `${this._codeVariableName}.projectAsCube = ${this.projectAsCube};\\n`;\r\n\r\n        if (!this.texture) {\r\n            return codeString;\r\n        }\r\n\r\n        codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n        serializationObject.disableLevelMultiplication = this.disableLevelMultiplication;\r\n        serializationObject.projectAsCube = this.projectAsCube;\r\n        if (!this.hasImageSource && this.texture && !this.texture.isRenderTarget && this.texture.getClassName() !== \"VideoTexture\") {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\r\n        this.disableLevelMultiplication = !!serializationObject.disableLevelMultiplication;\r\n        this.projectAsCube = !!serializationObject.projectAsCube;\r\n\r\n        if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime && serializationObject.texture.url !== undefined) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl) as Texture;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TriPlanarBlock\", TriPlanarBlock);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}