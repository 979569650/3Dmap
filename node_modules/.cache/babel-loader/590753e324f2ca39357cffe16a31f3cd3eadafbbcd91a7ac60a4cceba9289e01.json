{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Scene } from \"../scene.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { Matrix } from \"../Maths/math.vector.js\";\nimport { SmartArray } from \"../Misc/smartArray.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport { UniformBuffer } from \"../Materials/uniformBuffer.js\";\nimport { CreateBoxVertexData } from \"../Meshes/Builders/boxBuilder.js\";\nimport \"../Shaders/boundingBoxRenderer.fragment.js\";\nimport \"../Shaders/boundingBoxRenderer.vertex.js\";\nObject.defineProperty(Scene.prototype, \"forceShowBoundingBoxes\", {\n  get: function () {\n    return this._forceShowBoundingBoxes || false;\n  },\n  set: function (value) {\n    this._forceShowBoundingBoxes = value;\n    // Lazyly creates a BB renderer if needed.\n    if (value) {\n      this.getBoundingBoxRenderer();\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\nScene.prototype.getBoundingBoxRenderer = function () {\n  if (!this._boundingBoxRenderer) {\n    this._boundingBoxRenderer = new BoundingBoxRenderer(this);\n  }\n  return this._boundingBoxRenderer;\n};\nObject.defineProperty(AbstractMesh.prototype, \"showBoundingBox\", {\n  get: function () {\n    return this._showBoundingBox || false;\n  },\n  set: function (value) {\n    this._showBoundingBox = value;\n    // Lazyly creates a BB renderer if needed.\n    if (value) {\n      this.getScene().getBoundingBoxRenderer();\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\n/**\n * Component responsible of rendering the bounding box of the meshes in a scene.\n * This is usually used through the mesh.showBoundingBox or the scene.forceShowBoundingBoxes properties\n */\nexport class BoundingBoxRenderer {\n  /**\n   * Instantiates a new bounding box renderer in a scene.\n   * @param scene the scene the  renderer renders in\n   */\n  constructor(scene) {\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_BOUNDINGBOXRENDERER;\n    /**\n     * Color of the bounding box lines placed in front of an object\n     */\n    this.frontColor = new Color3(1, 1, 1);\n    /**\n     * Color of the bounding box lines placed behind an object\n     */\n    this.backColor = new Color3(0.1, 0.1, 0.1);\n    /**\n     * Defines if the renderer should show the back lines or not\n     */\n    this.showBackLines = true;\n    /**\n     * Observable raised before rendering a bounding box\n     */\n    this.onBeforeBoxRenderingObservable = new Observable();\n    /**\n     * Observable raised after rendering a bounding box\n     */\n    this.onAfterBoxRenderingObservable = new Observable();\n    /**\n     * Observable raised after resources are created\n     */\n    this.onResourcesReadyObservable = new Observable();\n    /**\n     * When false, no bounding boxes will be rendered\n     */\n    this.enabled = true;\n    /**\n     * @internal\n     */\n    this.renderList = new SmartArray(32);\n    this._vertexBuffers = {};\n    this._fillIndexBuffer = null;\n    this._fillIndexData = null;\n    this.scene = scene;\n    scene._addComponent(this);\n    this._uniformBufferFront = new UniformBuffer(this.scene.getEngine(), undefined, undefined, \"BoundingBoxRendererFront\", !this.scene.getEngine().isWebGPU);\n    this._buildUniformLayout(this._uniformBufferFront);\n    this._uniformBufferBack = new UniformBuffer(this.scene.getEngine(), undefined, undefined, \"BoundingBoxRendererBack\", !this.scene.getEngine().isWebGPU);\n    this._buildUniformLayout(this._uniformBufferBack);\n  }\n  _buildUniformLayout(ubo) {\n    ubo.addUniform(\"color\", 4);\n    ubo.addUniform(\"world\", 16);\n    ubo.addUniform(\"viewProjection\", 16);\n    ubo.addUniform(\"viewProjectionR\", 16);\n    ubo.create();\n  }\n  /**\n   * Registers the component in a given scene\n   */\n  register() {\n    this.scene._beforeEvaluateActiveMeshStage.registerStep(SceneComponentConstants.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER, this, this.reset);\n    this.scene._preActiveMeshStage.registerStep(SceneComponentConstants.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER, this, this._preActiveMesh);\n    this.scene._evaluateSubMeshStage.registerStep(SceneComponentConstants.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER, this, this._evaluateSubMesh);\n    this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER, this, this.render);\n  }\n  _evaluateSubMesh(mesh, subMesh) {\n    if (mesh.showSubMeshesBoundingBox) {\n      const boundingInfo = subMesh.getBoundingInfo();\n      if (boundingInfo !== null && boundingInfo !== undefined) {\n        boundingInfo.boundingBox._tag = mesh.renderingGroupId;\n        this.renderList.push(boundingInfo.boundingBox);\n      }\n    }\n  }\n  _preActiveMesh(mesh) {\n    if (mesh.showBoundingBox || this.scene.forceShowBoundingBoxes) {\n      const boundingInfo = mesh.getBoundingInfo();\n      boundingInfo.boundingBox._tag = mesh.renderingGroupId;\n      this.renderList.push(boundingInfo.boundingBox);\n    }\n  }\n  _prepareResources() {\n    if (this._colorShader) {\n      return;\n    }\n    this._colorShader = new ShaderMaterial(\"colorShader\", this.scene, \"boundingBoxRenderer\", {\n      attributes: [VertexBuffer.PositionKind],\n      uniforms: [\"world\", \"viewProjection\", \"viewProjectionR\", \"color\"],\n      uniformBuffers: [\"BoundingBoxRenderer\"]\n    }, false);\n    this._colorShader.doNotSerialize = true;\n    this._colorShader.reservedDataStore = {\n      hidden: true\n    };\n    this._colorShaderForOcclusionQuery = new ShaderMaterial(\"colorShaderOccQuery\", this.scene, \"boundingBoxRenderer\", {\n      attributes: [VertexBuffer.PositionKind],\n      uniforms: [\"world\", \"viewProjection\", \"viewProjectionR\", \"color\"],\n      uniformBuffers: [\"BoundingBoxRenderer\"]\n    }, true);\n    this._colorShaderForOcclusionQuery.doNotSerialize = true;\n    this._colorShaderForOcclusionQuery.reservedDataStore = {\n      hidden: true\n    };\n    const engine = this.scene.getEngine();\n    const boxdata = CreateBoxVertexData({\n      size: 1.0\n    });\n    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, boxdata.positions, VertexBuffer.PositionKind, false);\n    this._createIndexBuffer();\n    this._fillIndexData = boxdata.indices;\n    this.onResourcesReadyObservable.notifyObservers(this);\n  }\n  _createIndexBuffer() {\n    const engine = this.scene.getEngine();\n    this._indexBuffer = engine.createIndexBuffer([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 7, 1, 6, 2, 5, 3, 4]);\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  rebuild() {\n    const vb = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (vb) {\n      vb._rebuild();\n    }\n    this._createIndexBuffer();\n  }\n  /**\n   * @internal\n   */\n  reset() {\n    this.renderList.reset();\n  }\n  /**\n   * Render the bounding boxes of a specific rendering group\n   * @param renderingGroupId defines the rendering group to render\n   */\n  render(renderingGroupId) {\n    var _a, _b;\n    if (this.renderList.length === 0 || !this.enabled) {\n      return;\n    }\n    this._prepareResources();\n    if (!this._colorShader.isReady()) {\n      return;\n    }\n    const engine = this.scene.getEngine();\n    engine.setDepthWrite(false);\n    const transformMatrix = this.scene.getTransformMatrix();\n    for (let boundingBoxIndex = 0; boundingBoxIndex < this.renderList.length; boundingBoxIndex++) {\n      const boundingBox = this.renderList.data[boundingBoxIndex];\n      if (boundingBox._tag !== renderingGroupId) {\n        continue;\n      }\n      this._createWrappersForBoundingBox(boundingBox);\n      this.onBeforeBoxRenderingObservable.notifyObservers(boundingBox);\n      const min = boundingBox.minimum;\n      const max = boundingBox.maximum;\n      const diff = max.subtract(min);\n      const median = min.add(diff.scale(0.5));\n      const worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix());\n      const useReverseDepthBuffer = engine.useReverseDepthBuffer;\n      if (this.showBackLines) {\n        const drawWrapperBack = (_a = boundingBox._drawWrapperBack) !== null && _a !== void 0 ? _a : this._colorShader._getDrawWrapper();\n        this._colorShader._preBind(drawWrapperBack);\n        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect());\n        // Back\n        if (useReverseDepthBuffer) {\n          engine.setDepthFunctionToLessOrEqual();\n        } else {\n          engine.setDepthFunctionToGreaterOrEqual();\n        }\n        this._uniformBufferBack.bindToEffect(drawWrapperBack.effect, \"BoundingBoxRenderer\");\n        this._uniformBufferBack.updateColor4(\"color\", this.backColor, 1);\n        this._uniformBufferBack.updateMatrix(\"world\", worldMatrix);\n        this._uniformBufferBack.updateMatrix(\"viewProjection\", transformMatrix);\n        this._uniformBufferBack.update();\n        // Draw order\n        engine.drawElementsType(Material.LineListDrawMode, 0, 24);\n      }\n      const drawWrapperFront = (_b = boundingBox._drawWrapperFront) !== null && _b !== void 0 ? _b : this._colorShader._getDrawWrapper();\n      this._colorShader._preBind(drawWrapperFront);\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect());\n      // Front\n      if (useReverseDepthBuffer) {\n        engine.setDepthFunctionToGreater();\n      } else {\n        engine.setDepthFunctionToLess();\n      }\n      this._uniformBufferFront.bindToEffect(drawWrapperFront.effect, \"BoundingBoxRenderer\");\n      this._uniformBufferFront.updateColor4(\"color\", this.frontColor, 1);\n      this._uniformBufferFront.updateMatrix(\"world\", worldMatrix);\n      this._uniformBufferFront.updateMatrix(\"viewProjection\", transformMatrix);\n      this._uniformBufferFront.update();\n      // Draw order\n      engine.drawElementsType(Material.LineListDrawMode, 0, 24);\n      this.onAfterBoxRenderingObservable.notifyObservers(boundingBox);\n    }\n    this._colorShader.unbind();\n    engine.setDepthFunctionToLessOrEqual();\n    engine.setDepthWrite(true);\n  }\n  _createWrappersForBoundingBox(boundingBox) {\n    if (!boundingBox._drawWrapperFront) {\n      const engine = this.scene.getEngine();\n      boundingBox._drawWrapperFront = new DrawWrapper(engine);\n      boundingBox._drawWrapperBack = new DrawWrapper(engine);\n      boundingBox._drawWrapperFront.setEffect(this._colorShader.getEffect());\n      boundingBox._drawWrapperBack.setEffect(this._colorShader.getEffect());\n    }\n  }\n  /**\n   * In case of occlusion queries, we can render the occlusion bounding box through this method\n   * @param mesh Define the mesh to render the occlusion bounding box for\n   */\n  renderOcclusionBoundingBox(mesh) {\n    const engine = this.scene.getEngine();\n    if (this._renderPassIdForOcclusionQuery === undefined) {\n      this._renderPassIdForOcclusionQuery = engine.createRenderPassId(`Render pass for occlusion query`);\n    }\n    const currentRenderPassId = engine.currentRenderPassId;\n    engine.currentRenderPassId = this._renderPassIdForOcclusionQuery;\n    this._prepareResources();\n    const subMesh = mesh.subMeshes[0];\n    if (!this._colorShaderForOcclusionQuery.isReady(mesh, undefined, subMesh) || !mesh.hasBoundingInfo) {\n      engine.currentRenderPassId = currentRenderPassId;\n      return;\n    }\n    if (!this._fillIndexBuffer) {\n      this._fillIndexBuffer = engine.createIndexBuffer(this._fillIndexData);\n    }\n    const useReverseDepthBuffer = engine.useReverseDepthBuffer;\n    engine.setDepthWrite(false);\n    engine.setColorWrite(false);\n    const boundingBox = mesh.getBoundingInfo().boundingBox;\n    const min = boundingBox.minimum;\n    const max = boundingBox.maximum;\n    const diff = max.subtract(min);\n    const median = min.add(diff.scale(0.5));\n    const worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix());\n    const drawWrapper = subMesh._drawWrapper;\n    this._colorShaderForOcclusionQuery._preBind(drawWrapper);\n    engine.bindBuffers(this._vertexBuffers, this._fillIndexBuffer, drawWrapper.effect);\n    if (useReverseDepthBuffer) {\n      engine.setDepthFunctionToGreater();\n    } else {\n      engine.setDepthFunctionToLess();\n    }\n    this.scene.resetCachedMaterial();\n    this._uniformBufferFront.bindToEffect(drawWrapper.effect, \"BoundingBoxRenderer\");\n    this._uniformBufferFront.updateMatrix(\"world\", worldMatrix);\n    this._uniformBufferFront.updateMatrix(\"viewProjection\", this.scene.getTransformMatrix());\n    this._uniformBufferFront.update();\n    engine.drawElementsType(Material.TriangleFillMode, 0, 36);\n    this._colorShaderForOcclusionQuery.unbind();\n    engine.setDepthFunctionToLessOrEqual();\n    engine.setDepthWrite(true);\n    engine.setColorWrite(true);\n    engine.currentRenderPassId = currentRenderPassId;\n  }\n  /**\n   * Dispose and release the resources attached to this renderer.\n   */\n  dispose() {\n    if (this._renderPassIdForOcclusionQuery !== undefined) {\n      this.scene.getEngine().releaseRenderPassId(this._renderPassIdForOcclusionQuery);\n      this._renderPassIdForOcclusionQuery = undefined;\n    }\n    if (!this._colorShader) {\n      return;\n    }\n    this.onBeforeBoxRenderingObservable.clear();\n    this.onAfterBoxRenderingObservable.clear();\n    this.onResourcesReadyObservable.clear();\n    this.renderList.dispose();\n    this._colorShader.dispose();\n    this._colorShaderForOcclusionQuery.dispose();\n    this._uniformBufferFront.dispose();\n    this._uniformBufferBack.dispose();\n    const buffer = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (buffer) {\n      buffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n    this.scene.getEngine()._releaseBuffer(this._indexBuffer);\n    if (this._fillIndexBuffer) {\n      this.scene.getEngine()._releaseBuffer(this._fillIndexBuffer);\n      this._fillIndexBuffer = null;\n    }\n  }\n}","map":{"version":3,"names":["Scene","VertexBuffer","AbstractMesh","Matrix","SmartArray","SceneComponentConstants","Material","ShaderMaterial","Color3","Observable","DrawWrapper","UniformBuffer","CreateBoxVertexData","Object","defineProperty","prototype","get","_forceShowBoundingBoxes","set","value","getBoundingBoxRenderer","enumerable","configurable","_boundingBoxRenderer","BoundingBoxRenderer","_showBoundingBox","getScene","constructor","scene","name","NAME_BOUNDINGBOXRENDERER","frontColor","backColor","showBackLines","onBeforeBoxRenderingObservable","onAfterBoxRenderingObservable","onResourcesReadyObservable","enabled","renderList","_vertexBuffers","_fillIndexBuffer","_fillIndexData","_addComponent","_uniformBufferFront","getEngine","undefined","isWebGPU","_buildUniformLayout","_uniformBufferBack","ubo","addUniform","create","register","_beforeEvaluateActiveMeshStage","registerStep","STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER","reset","_preActiveMeshStage","STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER","_preActiveMesh","_evaluateSubMeshStage","STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER","_evaluateSubMesh","_afterRenderingGroupDrawStage","STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER","render","mesh","subMesh","showSubMeshesBoundingBox","boundingInfo","getBoundingInfo","boundingBox","_tag","renderingGroupId","push","showBoundingBox","forceShowBoundingBoxes","_prepareResources","_colorShader","attributes","PositionKind","uniforms","uniformBuffers","doNotSerialize","reservedDataStore","hidden","_colorShaderForOcclusionQuery","engine","boxdata","size","positions","_createIndexBuffer","indices","notifyObservers","_indexBuffer","createIndexBuffer","rebuild","vb","_rebuild","length","isReady","setDepthWrite","transformMatrix","getTransformMatrix","boundingBoxIndex","data","_createWrappersForBoundingBox","min","minimum","max","maximum","diff","subtract","median","add","scale","worldMatrix","Scaling","x","y","z","multiply","Translation","getWorldMatrix","useReverseDepthBuffer","drawWrapperBack","_a","_drawWrapperBack","_getDrawWrapper","_preBind","bindBuffers","getEffect","setDepthFunctionToLessOrEqual","setDepthFunctionToGreaterOrEqual","bindToEffect","effect","updateColor4","updateMatrix","update","drawElementsType","LineListDrawMode","drawWrapperFront","_b","_drawWrapperFront","setDepthFunctionToGreater","setDepthFunctionToLess","unbind","setEffect","renderOcclusionBoundingBox","_renderPassIdForOcclusionQuery","createRenderPassId","currentRenderPassId","subMeshes","hasBoundingInfo","setColorWrite","drawWrapper","_drawWrapper","resetCachedMaterial","TriangleFillMode","dispose","releaseRenderPassId","clear","buffer","_releaseBuffer"],"sources":["../../../../dev/core/src/Rendering/boundingBoxRenderer.ts"],"sourcesContent":["import { Scene } from \"../scene\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Matrix } from \"../Maths/math.vector\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport type { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport type { BoundingBox } from \"../Culling/boundingBox\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport { CreateBoxVertexData } from \"../Meshes/Builders/boxBuilder\";\r\n\r\nimport \"../Shaders/boundingBoxRenderer.fragment\";\r\nimport \"../Shaders/boundingBoxRenderer.vertex\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @internal (Backing field) */\r\n        _boundingBoxRenderer: BoundingBoxRenderer;\r\n\r\n        /** @internal (Backing field) */\r\n        _forceShowBoundingBoxes: boolean;\r\n\r\n        /**\r\n         * Gets or sets a boolean indicating if all bounding boxes must be rendered\r\n         */\r\n        forceShowBoundingBoxes: boolean;\r\n\r\n        /**\r\n         * Gets the bounding box renderer associated with the scene\r\n         * @returns a BoundingBoxRenderer\r\n         */\r\n        getBoundingBoxRenderer(): BoundingBoxRenderer;\r\n    }\r\n}\r\n\r\nObject.defineProperty(Scene.prototype, \"forceShowBoundingBoxes\", {\r\n    get: function (this: Scene) {\r\n        return this._forceShowBoundingBoxes || false;\r\n    },\r\n    set: function (this: Scene, value: boolean) {\r\n        this._forceShowBoundingBoxes = value;\r\n        // Lazyly creates a BB renderer if needed.\r\n        if (value) {\r\n            this.getBoundingBoxRenderer();\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nScene.prototype.getBoundingBoxRenderer = function (): BoundingBoxRenderer {\r\n    if (!this._boundingBoxRenderer) {\r\n        this._boundingBoxRenderer = new BoundingBoxRenderer(this);\r\n    }\r\n\r\n    return this._boundingBoxRenderer;\r\n};\r\n\r\ndeclare module \"../Meshes/abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /** @internal (Backing field) */\r\n        _showBoundingBox: boolean;\r\n\r\n        /**\r\n         * Gets or sets a boolean indicating if the bounding box must be rendered as well (false by default)\r\n         */\r\n        showBoundingBox: boolean;\r\n    }\r\n}\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"showBoundingBox\", {\r\n    get: function (this: AbstractMesh) {\r\n        return this._showBoundingBox || false;\r\n    },\r\n    set: function (this: AbstractMesh, value: boolean) {\r\n        this._showBoundingBox = value;\r\n        // Lazyly creates a BB renderer if needed.\r\n        if (value) {\r\n            this.getScene().getBoundingBoxRenderer();\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\n/**\r\n * Component responsible of rendering the bounding box of the meshes in a scene.\r\n * This is usually used through the mesh.showBoundingBox or the scene.forceShowBoundingBoxes properties\r\n */\r\nexport class BoundingBoxRenderer implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_BOUNDINGBOXRENDERER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Color of the bounding box lines placed in front of an object\r\n     */\r\n    public frontColor = new Color3(1, 1, 1);\r\n    /**\r\n     * Color of the bounding box lines placed behind an object\r\n     */\r\n    public backColor = new Color3(0.1, 0.1, 0.1);\r\n    /**\r\n     * Defines if the renderer should show the back lines or not\r\n     */\r\n    public showBackLines = true;\r\n\r\n    /**\r\n     * Observable raised before rendering a bounding box\r\n     */\r\n    public onBeforeBoxRenderingObservable = new Observable<BoundingBox>();\r\n\r\n    /**\r\n     * Observable raised after rendering a bounding box\r\n     */\r\n    public onAfterBoxRenderingObservable = new Observable<BoundingBox>();\r\n\r\n    /**\r\n     * Observable raised after resources are created\r\n     */\r\n    public onResourcesReadyObservable = new Observable<BoundingBoxRenderer>();\r\n\r\n    /**\r\n     * When false, no bounding boxes will be rendered\r\n     */\r\n    public enabled = true;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public renderList = new SmartArray<BoundingBox>(32);\r\n\r\n    private _colorShader: ShaderMaterial;\r\n    private _colorShaderForOcclusionQuery: ShaderMaterial;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: DataBuffer;\r\n    private _fillIndexBuffer: Nullable<DataBuffer> = null;\r\n    private _fillIndexData: Nullable<IndicesArray> = null;\r\n    private _uniformBufferFront: UniformBuffer;\r\n    private _uniformBufferBack: UniformBuffer;\r\n    private _renderPassIdForOcclusionQuery: number;\r\n\r\n    /**\r\n     * Instantiates a new bounding box renderer in a scene.\r\n     * @param scene the scene the  renderer renders in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        scene._addComponent(this);\r\n        this._uniformBufferFront = new UniformBuffer(this.scene.getEngine(), undefined, undefined, \"BoundingBoxRendererFront\", !this.scene.getEngine().isWebGPU);\r\n        this._buildUniformLayout(this._uniformBufferFront);\r\n        this._uniformBufferBack = new UniformBuffer(this.scene.getEngine(), undefined, undefined, \"BoundingBoxRendererBack\", !this.scene.getEngine().isWebGPU);\r\n        this._buildUniformLayout(this._uniformBufferBack);\r\n    }\r\n\r\n    private _buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"color\", 4);\r\n        ubo.addUniform(\"world\", 16);\r\n        ubo.addUniform(\"viewProjection\", 16);\r\n        ubo.addUniform(\"viewProjectionR\", 16);\r\n        ubo.create();\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeEvaluateActiveMeshStage.registerStep(SceneComponentConstants.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER, this, this.reset);\r\n\r\n        this.scene._preActiveMeshStage.registerStep(SceneComponentConstants.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER, this, this._preActiveMesh);\r\n\r\n        this.scene._evaluateSubMeshStage.registerStep(SceneComponentConstants.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER, this, this._evaluateSubMesh);\r\n\r\n        this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER, this, this.render);\r\n    }\r\n\r\n    private _evaluateSubMesh(mesh: AbstractMesh, subMesh: SubMesh): void {\r\n        if (mesh.showSubMeshesBoundingBox) {\r\n            const boundingInfo = subMesh.getBoundingInfo();\r\n            if (boundingInfo !== null && boundingInfo !== undefined) {\r\n                boundingInfo.boundingBox._tag = mesh.renderingGroupId;\r\n                this.renderList.push(boundingInfo.boundingBox);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _preActiveMesh(mesh: AbstractMesh): void {\r\n        if (mesh.showBoundingBox || this.scene.forceShowBoundingBoxes) {\r\n            const boundingInfo = mesh.getBoundingInfo();\r\n            boundingInfo.boundingBox._tag = mesh.renderingGroupId;\r\n            this.renderList.push(boundingInfo.boundingBox);\r\n        }\r\n    }\r\n\r\n    private _prepareResources(): void {\r\n        if (this._colorShader) {\r\n            return;\r\n        }\r\n\r\n        this._colorShader = new ShaderMaterial(\r\n            \"colorShader\",\r\n            this.scene,\r\n            \"boundingBoxRenderer\",\r\n            {\r\n                attributes: [VertexBuffer.PositionKind],\r\n                uniforms: [\"world\", \"viewProjection\", \"viewProjectionR\", \"color\"],\r\n                uniformBuffers: [\"BoundingBoxRenderer\"],\r\n            },\r\n            false\r\n        );\r\n        this._colorShader.doNotSerialize = true;\r\n\r\n        this._colorShader.reservedDataStore = {\r\n            hidden: true,\r\n        };\r\n\r\n        this._colorShaderForOcclusionQuery = new ShaderMaterial(\r\n            \"colorShaderOccQuery\",\r\n            this.scene,\r\n            \"boundingBoxRenderer\",\r\n            {\r\n                attributes: [VertexBuffer.PositionKind],\r\n                uniforms: [\"world\", \"viewProjection\", \"viewProjectionR\", \"color\"],\r\n                uniformBuffers: [\"BoundingBoxRenderer\"],\r\n            },\r\n            true\r\n        );\r\n        this._colorShaderForOcclusionQuery.doNotSerialize = true;\r\n\r\n        this._colorShaderForOcclusionQuery.reservedDataStore = {\r\n            hidden: true,\r\n        };\r\n\r\n        const engine = this.scene.getEngine();\r\n        const boxdata = CreateBoxVertexData({ size: 1.0 });\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, <FloatArray>boxdata.positions, VertexBuffer.PositionKind, false);\r\n        this._createIndexBuffer();\r\n        this._fillIndexData = boxdata.indices;\r\n        this.onResourcesReadyObservable.notifyObservers(this);\r\n    }\r\n\r\n    private _createIndexBuffer(): void {\r\n        const engine = this.scene.getEngine();\r\n        this._indexBuffer = engine.createIndexBuffer([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 7, 1, 6, 2, 5, 3, 4]);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public reset(): void {\r\n        this.renderList.reset();\r\n    }\r\n\r\n    /**\r\n     * Render the bounding boxes of a specific rendering group\r\n     * @param renderingGroupId defines the rendering group to render\r\n     */\r\n    public render(renderingGroupId: number): void {\r\n        if (this.renderList.length === 0 || !this.enabled) {\r\n            return;\r\n        }\r\n\r\n        this._prepareResources();\r\n\r\n        if (!this._colorShader.isReady()) {\r\n            return;\r\n        }\r\n\r\n        const engine = this.scene.getEngine();\r\n        engine.setDepthWrite(false);\r\n\r\n        const transformMatrix = this.scene.getTransformMatrix();\r\n\r\n        for (let boundingBoxIndex = 0; boundingBoxIndex < this.renderList.length; boundingBoxIndex++) {\r\n            const boundingBox = this.renderList.data[boundingBoxIndex];\r\n            if (boundingBox._tag !== renderingGroupId) {\r\n                continue;\r\n            }\r\n\r\n            this._createWrappersForBoundingBox(boundingBox);\r\n            this.onBeforeBoxRenderingObservable.notifyObservers(boundingBox);\r\n\r\n            const min = boundingBox.minimum;\r\n            const max = boundingBox.maximum;\r\n            const diff = max.subtract(min);\r\n            const median = min.add(diff.scale(0.5));\r\n\r\n            const worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix());\r\n\r\n            const useReverseDepthBuffer = engine.useReverseDepthBuffer;\r\n\r\n            if (this.showBackLines) {\r\n                const drawWrapperBack = boundingBox._drawWrapperBack ?? this._colorShader._getDrawWrapper();\r\n\r\n                this._colorShader._preBind(drawWrapperBack);\r\n\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, <Effect>this._colorShader.getEffect());\r\n\r\n                // Back\r\n                if (useReverseDepthBuffer) {\r\n                    engine.setDepthFunctionToLessOrEqual();\r\n                } else {\r\n                    engine.setDepthFunctionToGreaterOrEqual();\r\n                }\r\n                this._uniformBufferBack.bindToEffect(drawWrapperBack.effect!, \"BoundingBoxRenderer\");\r\n                this._uniformBufferBack.updateColor4(\"color\", this.backColor, 1);\r\n                this._uniformBufferBack.updateMatrix(\"world\", worldMatrix);\r\n                this._uniformBufferBack.updateMatrix(\"viewProjection\", transformMatrix);\r\n                this._uniformBufferBack.update();\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Material.LineListDrawMode, 0, 24);\r\n            }\r\n\r\n            const drawWrapperFront = boundingBox._drawWrapperFront ?? this._colorShader._getDrawWrapper();\r\n\r\n            this._colorShader._preBind(drawWrapperFront);\r\n\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, <Effect>this._colorShader.getEffect());\r\n\r\n            // Front\r\n            if (useReverseDepthBuffer) {\r\n                engine.setDepthFunctionToGreater();\r\n            } else {\r\n                engine.setDepthFunctionToLess();\r\n            }\r\n            this._uniformBufferFront.bindToEffect(drawWrapperFront.effect!, \"BoundingBoxRenderer\");\r\n            this._uniformBufferFront.updateColor4(\"color\", this.frontColor, 1);\r\n            this._uniformBufferFront.updateMatrix(\"world\", worldMatrix);\r\n            this._uniformBufferFront.updateMatrix(\"viewProjection\", transformMatrix);\r\n            this._uniformBufferFront.update();\r\n\r\n            // Draw order\r\n            engine.drawElementsType(Material.LineListDrawMode, 0, 24);\r\n\r\n            this.onAfterBoxRenderingObservable.notifyObservers(boundingBox);\r\n        }\r\n        this._colorShader.unbind();\r\n        engine.setDepthFunctionToLessOrEqual();\r\n        engine.setDepthWrite(true);\r\n    }\r\n\r\n    private _createWrappersForBoundingBox(boundingBox: BoundingBox): void {\r\n        if (!boundingBox._drawWrapperFront) {\r\n            const engine = this.scene.getEngine();\r\n\r\n            boundingBox._drawWrapperFront = new DrawWrapper(engine);\r\n            boundingBox._drawWrapperBack = new DrawWrapper(engine);\r\n\r\n            boundingBox._drawWrapperFront.setEffect(this._colorShader.getEffect());\r\n            boundingBox._drawWrapperBack.setEffect(this._colorShader.getEffect());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * In case of occlusion queries, we can render the occlusion bounding box through this method\r\n     * @param mesh Define the mesh to render the occlusion bounding box for\r\n     */\r\n    public renderOcclusionBoundingBox(mesh: AbstractMesh): void {\r\n        const engine = this.scene.getEngine();\r\n\r\n        if (this._renderPassIdForOcclusionQuery === undefined) {\r\n            this._renderPassIdForOcclusionQuery = engine.createRenderPassId(`Render pass for occlusion query`);\r\n        }\r\n\r\n        const currentRenderPassId = engine.currentRenderPassId;\r\n\r\n        engine.currentRenderPassId = this._renderPassIdForOcclusionQuery;\r\n\r\n        this._prepareResources();\r\n\r\n        const subMesh = mesh.subMeshes[0];\r\n\r\n        if (!this._colorShaderForOcclusionQuery.isReady(mesh, undefined, subMesh) || !mesh.hasBoundingInfo) {\r\n            engine.currentRenderPassId = currentRenderPassId;\r\n            return;\r\n        }\r\n\r\n        if (!this._fillIndexBuffer) {\r\n            this._fillIndexBuffer = engine.createIndexBuffer(this._fillIndexData!);\r\n        }\r\n\r\n        const useReverseDepthBuffer = engine.useReverseDepthBuffer;\r\n\r\n        engine.setDepthWrite(false);\r\n        engine.setColorWrite(false);\r\n\r\n        const boundingBox = mesh.getBoundingInfo().boundingBox;\r\n        const min = boundingBox.minimum;\r\n        const max = boundingBox.maximum;\r\n        const diff = max.subtract(min);\r\n        const median = min.add(diff.scale(0.5));\r\n\r\n        const worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix());\r\n\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        this._colorShaderForOcclusionQuery._preBind(drawWrapper);\r\n\r\n        engine.bindBuffers(this._vertexBuffers, this._fillIndexBuffer, <Effect>drawWrapper.effect);\r\n\r\n        if (useReverseDepthBuffer) {\r\n            engine.setDepthFunctionToGreater();\r\n        } else {\r\n            engine.setDepthFunctionToLess();\r\n        }\r\n\r\n        this.scene.resetCachedMaterial();\r\n\r\n        this._uniformBufferFront.bindToEffect(drawWrapper.effect!, \"BoundingBoxRenderer\");\r\n        this._uniformBufferFront.updateMatrix(\"world\", worldMatrix);\r\n        this._uniformBufferFront.updateMatrix(\"viewProjection\", this.scene.getTransformMatrix());\r\n        this._uniformBufferFront.update();\r\n\r\n        engine.drawElementsType(Material.TriangleFillMode, 0, 36);\r\n\r\n        this._colorShaderForOcclusionQuery.unbind();\r\n        engine.setDepthFunctionToLessOrEqual();\r\n        engine.setDepthWrite(true);\r\n        engine.setColorWrite(true);\r\n\r\n        engine.currentRenderPassId = currentRenderPassId;\r\n    }\r\n\r\n    /**\r\n     * Dispose and release the resources attached to this renderer.\r\n     */\r\n    public dispose(): void {\r\n        if (this._renderPassIdForOcclusionQuery !== undefined) {\r\n            this.scene.getEngine().releaseRenderPassId(this._renderPassIdForOcclusionQuery);\r\n            this._renderPassIdForOcclusionQuery = undefined as any;\r\n        }\r\n\r\n        if (!this._colorShader) {\r\n            return;\r\n        }\r\n\r\n        this.onBeforeBoxRenderingObservable.clear();\r\n        this.onAfterBoxRenderingObservable.clear();\r\n        this.onResourcesReadyObservable.clear();\r\n\r\n        this.renderList.dispose();\r\n\r\n        this._colorShader.dispose();\r\n        this._colorShaderForOcclusionQuery.dispose();\r\n\r\n        this._uniformBufferFront.dispose();\r\n        this._uniformBufferBack.dispose();\r\n\r\n        const buffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (buffer) {\r\n            buffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n        this.scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n\r\n        if (this._fillIndexBuffer) {\r\n            this.scene.getEngine()._releaseBuffer(this._fillIndexBuffer);\r\n            this._fillIndexBuffer = null;\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}