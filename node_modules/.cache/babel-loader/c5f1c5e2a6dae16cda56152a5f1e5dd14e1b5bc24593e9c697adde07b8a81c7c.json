{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"@babylonjs/core/tslib.es6.js\";\nimport { serializeAsColor4, serializeAsVector3, serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"@babylonjs/core/Misc/decorators.js\";\nimport { Vector3, TmpVectors } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { MaterialDefines } from \"@babylonjs/core/Materials/materialDefines.js\";\nimport { MaterialHelper } from \"@babylonjs/core/Materials/materialHelper.js\";\nimport { PushMaterial } from \"@babylonjs/core/Materials/pushMaterial.js\";\nimport { VertexBuffer } from \"@babylonjs/core/Buffers/buffer.js\";\nimport { RegisterClass } from \"@babylonjs/core/Misc/typeStore.js\";\nimport { Color3, Color4 } from \"@babylonjs/core/Maths/math.color.js\";\nimport \"./shaders/fluent.vertex.js\";\nimport \"./shaders/fluent.fragment.js\";\n/** @internal */\nexport class FluentMaterialDefines extends MaterialDefines {\n  constructor() {\n    super();\n    this.INNERGLOW = false;\n    this.BORDER = false;\n    this.HOVERLIGHT = false;\n    this.TEXTURE = false;\n    this.rebuild();\n  }\n}\n/**\n * Class used to render controls with fluent design\n */\nexport class FluentMaterial extends PushMaterial {\n  /**\n   * Creates a new Fluent material\n   * @param name defines the name of the material\n   * @param scene defines the hosting scene\n   */\n  constructor(name, scene) {\n    super(name, scene);\n    /**\n     * Gets or sets inner glow intensity. A value of 0 means no glow (default is 0.5)\n     */\n    this.innerGlowColorIntensity = 0.5;\n    /**\n     * Gets or sets the inner glow color (white by default)\n     */\n    this.innerGlowColor = new Color3(1.0, 1.0, 1.0);\n    /**\n     * Gets or sets the albedo color (Default is Color3(0.3, 0.35, 0.4))\n     */\n    this.albedoColor = new Color3(0.3, 0.35, 0.4);\n    /**\n     * Gets or sets a boolean indicating if borders must be rendered (default is false)\n     */\n    this.renderBorders = false;\n    /**\n     * Gets or sets border width (default is 0.5)\n     */\n    this.borderWidth = 0.5;\n    /**\n     * Gets or sets a value indicating the smoothing value applied to border edges (0.02 by default)\n     */\n    this.edgeSmoothingValue = 0.02;\n    /**\n     * Gets or sets the minimum value that can be applied to border width (default is 0.1)\n     */\n    this.borderMinValue = 0.1;\n    /**\n     * Gets or sets a boolean indicating if hover light must be rendered (default is false)\n     */\n    this.renderHoverLight = false;\n    /**\n     * Gets or sets the radius used to render the hover light (default is 0.01)\n     */\n    this.hoverRadius = 0.01;\n    /**\n     * Gets or sets the color used to render the hover light (default is Color4(0.3, 0.3, 0.3, 1.0))\n     */\n    this.hoverColor = new Color4(0.3, 0.3, 0.3, 1.0);\n    /**\n     * Gets or sets the hover light position in world space (default is Vector3.Zero())\n     */\n    this.hoverPosition = Vector3.Zero();\n  }\n  needAlphaBlending() {\n    return this.alpha !== 1.0;\n  }\n  needAlphaTesting() {\n    return false;\n  }\n  getAlphaTestTexture() {\n    return null;\n  }\n  isReadyForSubMesh(mesh, subMesh) {\n    if (this.isFrozen) {\n      if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {\n        return true;\n      }\n    }\n    if (!subMesh.materialDefines) {\n      subMesh.materialDefines = new FluentMaterialDefines();\n    }\n    const scene = this.getScene();\n    const defines = subMesh.materialDefines;\n    if (!this.checkReadyOnEveryCall && subMesh.effect) {\n      if (defines._renderId === scene.getRenderId()) {\n        return true;\n      }\n    }\n    if (defines._areTexturesDirty) {\n      defines.INNERGLOW = this.innerGlowColorIntensity > 0;\n      defines.BORDER = this.renderBorders;\n      defines.HOVERLIGHT = this.renderHoverLight;\n      if (this._albedoTexture) {\n        if (!this._albedoTexture.isReadyOrNotBlocking()) {\n          return false;\n        } else {\n          defines.TEXTURE = true;\n        }\n      } else {\n        defines.TEXTURE = false;\n      }\n    }\n    const engine = scene.getEngine();\n    // Get correct effect\n    if (defines.isDirty) {\n      defines.markAsProcessed();\n      scene.resetCachedMaterial();\n      //Attributes\n      const attribs = [VertexBuffer.PositionKind];\n      attribs.push(VertexBuffer.NormalKind);\n      attribs.push(VertexBuffer.UVKind);\n      const shaderName = \"fluent\";\n      const uniforms = [\"world\", \"viewProjection\", \"innerGlowColor\", \"albedoColor\", \"borderWidth\", \"edgeSmoothingValue\", \"scaleFactor\", \"borderMinValue\", \"hoverColor\", \"hoverPosition\", \"hoverRadius\", \"textureMatrix\"];\n      const samplers = [\"albedoSampler\"];\n      const uniformBuffers = new Array();\n      MaterialHelper.PrepareUniformsAndSamplersList({\n        uniformsNames: uniforms,\n        uniformBuffersNames: uniformBuffers,\n        samplers: samplers,\n        defines: defines,\n        maxSimultaneousLights: 4\n      });\n      const join = defines.toString();\n      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {\n        attributes: attribs,\n        uniformsNames: uniforms,\n        uniformBuffersNames: uniformBuffers,\n        samplers: samplers,\n        defines: join,\n        fallbacks: null,\n        onCompiled: this.onCompiled,\n        onError: this.onError,\n        indexParameters: {\n          maxSimultaneousLights: 4\n        }\n      }, engine), defines, this._materialContext);\n    }\n    if (!subMesh.effect || !subMesh.effect.isReady()) {\n      return false;\n    }\n    defines._renderId = scene.getRenderId();\n    subMesh.effect._wasPreviouslyReady = true;\n    return true;\n  }\n  bindForSubMesh(world, mesh, subMesh) {\n    const scene = this.getScene();\n    const defines = subMesh.materialDefines;\n    if (!defines) {\n      return;\n    }\n    const effect = subMesh.effect;\n    if (!effect) {\n      return;\n    }\n    this._activeEffect = effect;\n    // Matrices\n    this.bindOnlyWorldMatrix(world);\n    this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n    if (this._mustRebind(scene, effect)) {\n      this._activeEffect.setColor4(\"albedoColor\", this.albedoColor, this.alpha);\n      if (defines.INNERGLOW) {\n        this._activeEffect.setColor4(\"innerGlowColor\", this.innerGlowColor, this.innerGlowColorIntensity);\n      }\n      if (defines.BORDER) {\n        this._activeEffect.setFloat(\"borderWidth\", this.borderWidth);\n        this._activeEffect.setFloat(\"edgeSmoothingValue\", this.edgeSmoothingValue);\n        this._activeEffect.setFloat(\"borderMinValue\", this.borderMinValue);\n        mesh.getBoundingInfo().boundingBox.extendSize.multiplyToRef(mesh.scaling, TmpVectors.Vector3[0]);\n        this._activeEffect.setVector3(\"scaleFactor\", TmpVectors.Vector3[0]);\n      }\n      if (defines.HOVERLIGHT) {\n        this._activeEffect.setDirectColor4(\"hoverColor\", this.hoverColor);\n        this._activeEffect.setFloat(\"hoverRadius\", this.hoverRadius);\n        this._activeEffect.setVector3(\"hoverPosition\", this.hoverPosition);\n      }\n      if (defines.TEXTURE && this._albedoTexture) {\n        this._activeEffect.setTexture(\"albedoSampler\", this._albedoTexture);\n        const matrix = this._albedoTexture.getTextureMatrix();\n        this._activeEffect.setMatrix(\"textureMatrix\", matrix);\n      }\n    }\n    this._afterBind(mesh, this._activeEffect);\n  }\n  getActiveTextures() {\n    const activeTextures = super.getActiveTextures();\n    return activeTextures;\n  }\n  hasTexture(texture) {\n    if (super.hasTexture(texture)) {\n      return true;\n    }\n    return false;\n  }\n  dispose(forceDisposeEffect) {\n    super.dispose(forceDisposeEffect);\n  }\n  clone(name) {\n    return SerializationHelper.Clone(() => new FluentMaterial(name, this.getScene()), this);\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.customType = \"BABYLON.GUI.FluentMaterial\";\n    return serializationObject;\n  }\n  getClassName() {\n    return \"FluentMaterial\";\n  }\n  // Statics\n  static Parse(source, scene, rootUrl) {\n    return SerializationHelper.Parse(() => new FluentMaterial(source.name, scene), source, scene, rootUrl);\n  }\n}\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], FluentMaterial.prototype, \"innerGlowColorIntensity\", void 0);\n__decorate([serializeAsColor3()], FluentMaterial.prototype, \"innerGlowColor\", void 0);\n__decorate([serializeAsColor3()], FluentMaterial.prototype, \"albedoColor\", void 0);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], FluentMaterial.prototype, \"renderBorders\", void 0);\n__decorate([serialize()], FluentMaterial.prototype, \"borderWidth\", void 0);\n__decorate([serialize()], FluentMaterial.prototype, \"edgeSmoothingValue\", void 0);\n__decorate([serialize()], FluentMaterial.prototype, \"borderMinValue\", void 0);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], FluentMaterial.prototype, \"renderHoverLight\", void 0);\n__decorate([serialize()], FluentMaterial.prototype, \"hoverRadius\", void 0);\n__decorate([serializeAsColor4()], FluentMaterial.prototype, \"hoverColor\", void 0);\n__decorate([serializeAsVector3()], FluentMaterial.prototype, \"hoverPosition\", void 0);\n__decorate([serializeAsTexture(\"albedoTexture\")], FluentMaterial.prototype, \"_albedoTexture\", void 0);\n__decorate([expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")], FluentMaterial.prototype, \"albedoTexture\", void 0);\nRegisterClass(\"BABYLON.GUI.FluentMaterial\", FluentMaterial);","map":{"version":3,"names":["serializeAsColor4","serializeAsVector3","serializeAsTexture","serialize","expandToProperty","serializeAsColor3","SerializationHelper","Vector3","TmpVectors","MaterialDefines","MaterialHelper","PushMaterial","VertexBuffer","RegisterClass","Color3","Color4","FluentMaterialDefines","constructor","INNERGLOW","BORDER","HOVERLIGHT","TEXTURE","rebuild","FluentMaterial","name","scene","innerGlowColorIntensity","innerGlowColor","albedoColor","renderBorders","borderWidth","edgeSmoothingValue","borderMinValue","renderHoverLight","hoverRadius","hoverColor","hoverPosition","Zero","needAlphaBlending","alpha","needAlphaTesting","getAlphaTestTexture","isReadyForSubMesh","mesh","subMesh","isFrozen","effect","_wasPreviouslyReady","materialDefines","getScene","defines","checkReadyOnEveryCall","_renderId","getRenderId","_areTexturesDirty","_albedoTexture","isReadyOrNotBlocking","engine","getEngine","isDirty","markAsProcessed","resetCachedMaterial","attribs","PositionKind","push","NormalKind","UVKind","shaderName","uniforms","samplers","uniformBuffers","Array","PrepareUniformsAndSamplersList","uniformsNames","uniformBuffersNames","maxSimultaneousLights","join","toString","setEffect","createEffect","attributes","fallbacks","onCompiled","onError","indexParameters","_materialContext","isReady","bindForSubMesh","world","_activeEffect","bindOnlyWorldMatrix","setMatrix","getTransformMatrix","_mustRebind","setColor4","setFloat","getBoundingInfo","boundingBox","extendSize","multiplyToRef","scaling","setVector3","setDirectColor4","setTexture","matrix","getTextureMatrix","_afterBind","getActiveTextures","activeTextures","hasTexture","texture","dispose","forceDisposeEffect","clone","Clone","serializationObject","customType","getClassName","Parse","source","rootUrl","__decorate"],"sources":["../../../../../../dev/gui/src/3D/materials/fluent/fluentMaterial.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsColor4, serializeAsVector3, serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"core/Misc/decorators\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Vector3, TmpVectors } from \"core/Maths/math.vector\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialHelper } from \"core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { Color3, Color4 } from \"core/Maths/math.color\";\r\n\r\nimport \"./shaders/fluent.vertex\";\r\nimport \"./shaders/fluent.fragment\";\r\n\r\n/** @internal */\r\nexport class FluentMaterialDefines extends MaterialDefines {\r\n    public INNERGLOW = false;\r\n    public BORDER = false;\r\n    public HOVERLIGHT = false;\r\n    public TEXTURE = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\n/**\r\n * Class used to render controls with fluent design\r\n */\r\nexport class FluentMaterial extends PushMaterial {\r\n    /**\r\n     * Gets or sets inner glow intensity. A value of 0 means no glow (default is 0.5)\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public innerGlowColorIntensity = 0.5;\r\n\r\n    /**\r\n     * Gets or sets the inner glow color (white by default)\r\n     */\r\n    @serializeAsColor3()\r\n    public innerGlowColor = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * Gets or sets the albedo color (Default is Color3(0.3, 0.35, 0.4))\r\n     */\r\n    @serializeAsColor3()\r\n    public albedoColor = new Color3(0.3, 0.35, 0.4);\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if borders must be rendered (default is false)\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public renderBorders = false;\r\n\r\n    /**\r\n     * Gets or sets border width (default is 0.5)\r\n     */\r\n    @serialize()\r\n    public borderWidth = 0.5;\r\n\r\n    /**\r\n     * Gets or sets a value indicating the smoothing value applied to border edges (0.02 by default)\r\n     */\r\n    @serialize()\r\n    public edgeSmoothingValue = 0.02;\r\n\r\n    /**\r\n     * Gets or sets the minimum value that can be applied to border width (default is 0.1)\r\n     */\r\n    @serialize()\r\n    public borderMinValue = 0.1;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if hover light must be rendered (default is false)\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public renderHoverLight = false;\r\n\r\n    /**\r\n     * Gets or sets the radius used to render the hover light (default is 0.01)\r\n     */\r\n    @serialize()\r\n    public hoverRadius = 0.01;\r\n\r\n    /**\r\n     * Gets or sets the color used to render the hover light (default is Color4(0.3, 0.3, 0.3, 1.0))\r\n     */\r\n    @serializeAsColor4()\r\n    public hoverColor = new Color4(0.3, 0.3, 0.3, 1.0);\r\n\r\n    /**\r\n     * Gets or sets the hover light position in world space (default is Vector3.Zero())\r\n     */\r\n    @serializeAsVector3()\r\n    public hoverPosition = Vector3.Zero();\r\n\r\n    @serializeAsTexture(\"albedoTexture\")\r\n    private _albedoTexture: Nullable<BaseTexture>;\r\n\r\n    /** Gets or sets the texture to use for albedo color */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    public albedoTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Creates a new Fluent material\r\n     * @param name defines the name of the material\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha !== 1.0;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new FluentMaterialDefines();\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const defines = <FluentMaterialDefines>subMesh.materialDefines;\r\n        if (!this.checkReadyOnEveryCall && subMesh.effect) {\r\n            if (defines._renderId === scene.getRenderId()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (defines._areTexturesDirty) {\r\n            defines.INNERGLOW = this.innerGlowColorIntensity > 0;\r\n            defines.BORDER = this.renderBorders;\r\n            defines.HOVERLIGHT = this.renderHoverLight;\r\n\r\n            if (this._albedoTexture) {\r\n                if (!this._albedoTexture.isReadyOrNotBlocking()) {\r\n                    return false;\r\n                } else {\r\n                    defines.TEXTURE = true;\r\n                }\r\n            } else {\r\n                defines.TEXTURE = false;\r\n            }\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n            attribs.push(VertexBuffer.NormalKind);\r\n            attribs.push(VertexBuffer.UVKind);\r\n\r\n            const shaderName = \"fluent\";\r\n\r\n            const uniforms = [\r\n                \"world\",\r\n                \"viewProjection\",\r\n                \"innerGlowColor\",\r\n                \"albedoColor\",\r\n                \"borderWidth\",\r\n                \"edgeSmoothingValue\",\r\n                \"scaleFactor\",\r\n                \"borderMinValue\",\r\n                \"hoverColor\",\r\n                \"hoverPosition\",\r\n                \"hoverRadius\",\r\n                \"textureMatrix\",\r\n            ];\r\n\r\n            const samplers = [\"albedoSampler\"];\r\n            const uniformBuffers = new Array<string>();\r\n\r\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: 4,\r\n            });\r\n\r\n            const join = defines.toString();\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: null,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: 4 },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <FluentMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        if (this._mustRebind(scene, effect)) {\r\n            this._activeEffect.setColor4(\"albedoColor\", this.albedoColor, this.alpha);\r\n\r\n            if (defines.INNERGLOW) {\r\n                this._activeEffect.setColor4(\"innerGlowColor\", this.innerGlowColor, this.innerGlowColorIntensity);\r\n            }\r\n\r\n            if (defines.BORDER) {\r\n                this._activeEffect.setFloat(\"borderWidth\", this.borderWidth);\r\n                this._activeEffect.setFloat(\"edgeSmoothingValue\", this.edgeSmoothingValue);\r\n                this._activeEffect.setFloat(\"borderMinValue\", this.borderMinValue);\r\n\r\n                mesh.getBoundingInfo().boundingBox.extendSize.multiplyToRef(mesh.scaling, TmpVectors.Vector3[0]);\r\n                this._activeEffect.setVector3(\"scaleFactor\", TmpVectors.Vector3[0]);\r\n            }\r\n\r\n            if (defines.HOVERLIGHT) {\r\n                this._activeEffect.setDirectColor4(\"hoverColor\", this.hoverColor);\r\n                this._activeEffect.setFloat(\"hoverRadius\", this.hoverRadius);\r\n                this._activeEffect.setVector3(\"hoverPosition\", this.hoverPosition);\r\n            }\r\n\r\n            if (defines.TEXTURE && this._albedoTexture) {\r\n                this._activeEffect.setTexture(\"albedoSampler\", this._albedoTexture);\r\n                const matrix = this._albedoTexture.getTextureMatrix();\r\n                this._activeEffect.setMatrix(\"textureMatrix\", matrix);\r\n            }\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): FluentMaterial {\r\n        return SerializationHelper.Clone(() => new FluentMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.GUI.FluentMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"FluentMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): FluentMaterial {\r\n        return SerializationHelper.Parse(() => new FluentMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GUI.FluentMaterial\", FluentMaterial);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}