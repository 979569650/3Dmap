{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Observable } from \"@babylonjs/core/Misc/observable.js\";\nimport { Vector3 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { PointerEventTypes } from \"@babylonjs/core/Events/pointerEvents.js\";\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh.js\";\nimport { Vector3WithInfo } from \"../vector3WithInfo.js\";\n/**\n * Class used as base class for controls\n */\nexport class Control3D {\n  /** Gets or sets the control position in world space */\n  get position() {\n    if (!this._node) {\n      return Vector3.Zero();\n    }\n    return this._node.position;\n  }\n  set position(value) {\n    if (!this._node) {\n      return;\n    }\n    this._node.position = value;\n  }\n  /** Gets or sets the control scaling in world space */\n  get scaling() {\n    if (!this._node) {\n      return new Vector3(1, 1, 1);\n    }\n    return this._node.scaling;\n  }\n  set scaling(value) {\n    if (!this._node) {\n      return;\n    }\n    this._isScaledByManager = false;\n    this._node.scaling = value;\n  }\n  /**\n   * Gets the list of attached behaviors\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors\n   */\n  get behaviors() {\n    return this._behaviors;\n  }\n  /**\n   * Attach a behavior to the control\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors\n   * @param behavior defines the behavior to attach\n   * @returns the current control\n   */\n  addBehavior(behavior) {\n    const index = this._behaviors.indexOf(behavior);\n    if (index !== -1) {\n      return this;\n    }\n    behavior.init();\n    const scene = this._host.scene;\n    if (scene.isLoading) {\n      // We defer the attach when the scene will be loaded\n      scene.onDataLoadedObservable.addOnce(() => {\n        behavior.attach(this);\n      });\n    } else {\n      behavior.attach(this);\n    }\n    this._behaviors.push(behavior);\n    return this;\n  }\n  /**\n   * Remove an attached behavior\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors\n   * @param behavior defines the behavior to attach\n   * @returns the current control\n   */\n  removeBehavior(behavior) {\n    const index = this._behaviors.indexOf(behavior);\n    if (index === -1) {\n      return this;\n    }\n    this._behaviors[index].detach();\n    this._behaviors.splice(index, 1);\n    return this;\n  }\n  /**\n   * Gets an attached behavior by name\n   * @param name defines the name of the behavior to look for\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors\n   * @returns null if behavior was not found else the requested behavior\n   */\n  getBehaviorByName(name) {\n    for (const behavior of this._behaviors) {\n      if (behavior.name === name) {\n        return behavior;\n      }\n    }\n    return null;\n  }\n  /** Gets or sets a boolean indicating if the control is visible */\n  get isVisible() {\n    return this._isVisible;\n  }\n  set isVisible(value) {\n    if (this._isVisible === value) {\n      return;\n    }\n    this._isVisible = value;\n    const mesh = this.mesh;\n    if (mesh) {\n      mesh.setEnabled(value);\n    }\n  }\n  /**\n   * Creates a new control\n   * @param name defines the control name\n   */\n  constructor( /** Defines the control name */\n  name) {\n    this.name = name;\n    this._downCount = 0;\n    this._enterCount = -1;\n    this._downPointerIds = {}; // Store number of pointer downs per ID, from near and far interactions\n    this._isVisible = true;\n    /** @internal */\n    this._isScaledByManager = false;\n    /**\n     * An event triggered when the pointer moves over the control\n     */\n    this.onPointerMoveObservable = new Observable();\n    /**\n     * An event triggered when the pointer moves out of the control\n     */\n    this.onPointerOutObservable = new Observable();\n    /**\n     * An event triggered when the pointer taps the control\n     */\n    this.onPointerDownObservable = new Observable();\n    /**\n     * An event triggered when pointer is up\n     */\n    this.onPointerUpObservable = new Observable();\n    /**\n     * An event triggered when a control is clicked on (with a mouse)\n     */\n    this.onPointerClickObservable = new Observable();\n    /**\n     * An event triggered when pointer enters the control\n     */\n    this.onPointerEnterObservable = new Observable();\n    // Behaviors\n    this._behaviors = new Array();\n  }\n  /**\n   * Gets a string representing the class name\n   */\n  get typeName() {\n    return this._getTypeName();\n  }\n  /**\n   * Get the current class name of the control.\n   * @returns current class name\n   */\n  getClassName() {\n    return this._getTypeName();\n  }\n  _getTypeName() {\n    return \"Control3D\";\n  }\n  /**\n   * Gets the transform node used by this control\n   */\n  get node() {\n    return this._node;\n  }\n  /**\n   * Gets the mesh used to render this control\n   */\n  get mesh() {\n    if (this._node instanceof AbstractMesh) {\n      return this._node;\n    }\n    return null;\n  }\n  /**\n   * Link the control as child of the given node\n   * @param node defines the node to link to. Use null to unlink the control\n   * @returns the current control\n   */\n  linkToTransformNode(node) {\n    if (this._node) {\n      this._node.parent = node;\n    }\n    return this;\n  }\n  /**\n   * @internal*\n   */\n  _prepareNode(scene) {\n    if (!this._node) {\n      this._node = this._createNode(scene);\n      if (!this.node) {\n        return;\n      }\n      this._injectGUI3DReservedDataStore(this.node).control = this; // Store the control on the reservedDataStore field in order to get it when picking\n      const mesh = this.mesh;\n      if (mesh) {\n        mesh.isPickable = true;\n        this._affectMaterial(mesh);\n      }\n    }\n  }\n  _injectGUI3DReservedDataStore(node) {\n    var _a, _b;\n    node.reservedDataStore = (_a = node.reservedDataStore) !== null && _a !== void 0 ? _a : {};\n    node.reservedDataStore.GUI3D = (_b = node.reservedDataStore.GUI3D) !== null && _b !== void 0 ? _b : {};\n    return node.reservedDataStore.GUI3D;\n  }\n  /**\n   * Node creation.\n   * Can be overriden by children\n   * @param scene defines the scene where the node must be attached\n   * @returns the attached node or null if none. Must return a Mesh or AbstractMesh if there is an attached visible object\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _createNode(scene) {\n    // Do nothing by default\n    return null;\n  }\n  /**\n   * Affect a material to the given mesh\n   * @param mesh defines the mesh which will represent the control\n   */\n  _affectMaterial(mesh) {\n    mesh.material = null;\n  }\n  _isTouchButton3D(control) {\n    return control._generatePointerEventType !== undefined;\n  }\n  // Pointers\n  /**\n   * @internal\n   */\n  _onPointerMove(target, coordinates) {\n    this.onPointerMoveObservable.notifyObservers(coordinates, -1, target, this);\n  }\n  /**\n   * @internal\n   */\n  _onPointerEnter(target) {\n    if (this._enterCount === -1) {\n      // -1 is for touch input, we are now sure we are with a mouse or pencil\n      this._enterCount = 0;\n    }\n    this._enterCount++;\n    if (this._enterCount > 1) {\n      return false;\n    }\n    this.onPointerEnterObservable.notifyObservers(this, -1, target, this);\n    if (this.pointerEnterAnimation) {\n      this.pointerEnterAnimation();\n    }\n    return true;\n  }\n  /**\n   * @internal\n   */\n  _onPointerOut(target) {\n    this._enterCount--;\n    if (this._enterCount > 0) {\n      return;\n    }\n    this._enterCount = 0;\n    this.onPointerOutObservable.notifyObservers(this, -1, target, this);\n    if (this.pointerOutAnimation) {\n      this.pointerOutAnimation();\n    }\n  }\n  /**\n   * @internal\n   */\n  _onPointerDown(target, coordinates, pointerId, buttonIndex) {\n    this._downCount++;\n    this._downPointerIds[pointerId] = this._downPointerIds[pointerId] + 1 || 1;\n    if (this._downCount !== 1) {\n      return false;\n    }\n    this.onPointerDownObservable.notifyObservers(new Vector3WithInfo(coordinates, buttonIndex), -1, target, this);\n    if (this.pointerDownAnimation) {\n      this.pointerDownAnimation();\n    }\n    return true;\n  }\n  /**\n   * @internal\n   */\n  _onPointerUp(target, coordinates, pointerId, buttonIndex, notifyClick) {\n    this._downCount--;\n    this._downPointerIds[pointerId]--;\n    if (this._downPointerIds[pointerId] <= 0) {\n      delete this._downPointerIds[pointerId];\n    }\n    if (this._downCount < 0) {\n      // Handle if forcePointerUp was called prior to this\n      this._downCount = 0;\n      return;\n    }\n    if (this._downCount == 0) {\n      if (notifyClick && (this._enterCount > 0 || this._enterCount === -1)) {\n        this.onPointerClickObservable.notifyObservers(new Vector3WithInfo(coordinates, buttonIndex), -1, target, this);\n      }\n      this.onPointerUpObservable.notifyObservers(new Vector3WithInfo(coordinates, buttonIndex), -1, target, this);\n      if (this.pointerUpAnimation) {\n        this.pointerUpAnimation();\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  forcePointerUp(pointerId = null) {\n    if (pointerId !== null) {\n      this._onPointerUp(this, Vector3.Zero(), pointerId, 0, true);\n    } else {\n      for (const key in this._downPointerIds) {\n        this._onPointerUp(this, Vector3.Zero(), +key, 0, true);\n      }\n      if (this._downCount > 0) {\n        this._downCount = 1;\n        this._onPointerUp(this, Vector3.Zero(), 0, 0, true);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _processObservables(type, pickedPoint, originMeshPosition, pointerId, buttonIndex) {\n    if (this._isTouchButton3D(this) && originMeshPosition) {\n      type = this._generatePointerEventType(type, originMeshPosition, this._downCount);\n    }\n    if (type === PointerEventTypes.POINTERMOVE) {\n      this._onPointerMove(this, pickedPoint);\n      const previousControlOver = this._host._lastControlOver[pointerId];\n      if (previousControlOver && previousControlOver !== this) {\n        previousControlOver._onPointerOut(this);\n      }\n      if (previousControlOver !== this) {\n        this._onPointerEnter(this);\n      }\n      this._host._lastControlOver[pointerId] = this;\n      return true;\n    }\n    if (type === PointerEventTypes.POINTERDOWN) {\n      this._onPointerDown(this, pickedPoint, pointerId, buttonIndex);\n      this._host._lastControlDown[pointerId] = this;\n      this._host._lastPickedControl = this;\n      return true;\n    }\n    if (type === PointerEventTypes.POINTERUP || type === PointerEventTypes.POINTERDOUBLETAP) {\n      if (this._host._lastControlDown[pointerId]) {\n        this._host._lastControlDown[pointerId]._onPointerUp(this, pickedPoint, pointerId, buttonIndex, true);\n      }\n      delete this._host._lastControlDown[pointerId];\n      return true;\n    }\n    return false;\n  }\n  /** @internal */\n  _disposeNode() {\n    if (this._node) {\n      this._node.dispose();\n      this._node = null;\n    }\n  }\n  /**\n   * Releases all associated resources\n   */\n  dispose() {\n    this.onPointerDownObservable.clear();\n    this.onPointerEnterObservable.clear();\n    this.onPointerMoveObservable.clear();\n    this.onPointerOutObservable.clear();\n    this.onPointerUpObservable.clear();\n    this.onPointerClickObservable.clear();\n    this._disposeNode();\n    // Behaviors\n    for (const behavior of this._behaviors) {\n      behavior.detach();\n    }\n  }\n}","map":{"version":3,"names":["Observable","Vector3","PointerEventTypes","AbstractMesh","Vector3WithInfo","Control3D","position","_node","Zero","value","scaling","_isScaledByManager","behaviors","_behaviors","addBehavior","behavior","index","indexOf","init","scene","_host","isLoading","onDataLoadedObservable","addOnce","attach","push","removeBehavior","detach","splice","getBehaviorByName","name","isVisible","_isVisible","mesh","setEnabled","constructor","_downCount","_enterCount","_downPointerIds","onPointerMoveObservable","onPointerOutObservable","onPointerDownObservable","onPointerUpObservable","onPointerClickObservable","onPointerEnterObservable","Array","typeName","_getTypeName","getClassName","node","linkToTransformNode","parent","_prepareNode","_createNode","_injectGUI3DReservedDataStore","control","isPickable","_affectMaterial","reservedDataStore","_a","GUI3D","_b","material","_isTouchButton3D","_generatePointerEventType","undefined","_onPointerMove","target","coordinates","notifyObservers","_onPointerEnter","pointerEnterAnimation","_onPointerOut","pointerOutAnimation","_onPointerDown","pointerId","buttonIndex","pointerDownAnimation","_onPointerUp","notifyClick","pointerUpAnimation","forcePointerUp","key","_processObservables","type","pickedPoint","originMeshPosition","POINTERMOVE","previousControlOver","_lastControlOver","POINTERDOWN","_lastControlDown","_lastPickedControl","POINTERUP","POINTERDOUBLETAP","_disposeNode","dispose","clear"],"sources":["../../../../../dev/gui/src/3D/controls/control3D.ts"],"sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { PointerEventTypes } from \"core/Events/pointerEvents\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { IBehaviorAware, Behavior } from \"core/Behaviors/behavior\";\r\nimport type { IDisposable, Scene } from \"core/scene\";\r\n\r\nimport type { GUI3DManager } from \"../gui3DManager\";\r\nimport { Vector3WithInfo } from \"../vector3WithInfo\";\r\nimport type { Container3D } from \"./container3D\";\r\n\r\nimport type { TouchButton3D } from \"./touchButton3D\";\r\n\r\n/**\r\n * Class used as base class for controls\r\n */\r\nexport class Control3D implements IDisposable, IBehaviorAware<Control3D> {\r\n    private _node: Nullable<TransformNode>;\r\n    private _downCount = 0;\r\n    private _enterCount = -1;\r\n    private _downPointerIds: { [id: number]: number } = {}; // Store number of pointer downs per ID, from near and far interactions\r\n\r\n    protected _isVisible = true;\r\n\r\n    /** @internal */\r\n    public _host: GUI3DManager;\r\n    /** @internal */\r\n    public _isScaledByManager = false;\r\n\r\n    /** Gets or sets the control position in world space */\r\n    public get position(): Vector3 {\r\n        if (!this._node) {\r\n            return Vector3.Zero();\r\n        }\r\n\r\n        return this._node.position;\r\n    }\r\n\r\n    public set position(value: Vector3) {\r\n        if (!this._node) {\r\n            return;\r\n        }\r\n\r\n        this._node.position = value;\r\n    }\r\n\r\n    /** Gets or sets the control scaling in world space */\r\n    public get scaling(): Vector3 {\r\n        if (!this._node) {\r\n            return new Vector3(1, 1, 1);\r\n        }\r\n\r\n        return this._node.scaling;\r\n    }\r\n\r\n    public set scaling(value: Vector3) {\r\n        if (!this._node) {\r\n            return;\r\n        }\r\n\r\n        this._isScaledByManager = false;\r\n        this._node.scaling = value;\r\n    }\r\n\r\n    /** Callback used to start pointer enter animation */\r\n    public pointerEnterAnimation: () => void;\r\n    /** Callback used to start pointer out animation */\r\n    public pointerOutAnimation: () => void;\r\n    /** Callback used to start pointer down animation */\r\n    public pointerDownAnimation: () => void;\r\n    /** Callback used to start pointer up animation */\r\n    public pointerUpAnimation: () => void;\r\n\r\n    /**\r\n     * An event triggered when the pointer moves over the control\r\n     */\r\n    public onPointerMoveObservable = new Observable<Vector3>();\r\n\r\n    /**\r\n     * An event triggered when the pointer moves out of the control\r\n     */\r\n    public onPointerOutObservable = new Observable<Control3D>();\r\n\r\n    /**\r\n     * An event triggered when the pointer taps the control\r\n     */\r\n    public onPointerDownObservable = new Observable<Vector3WithInfo>();\r\n\r\n    /**\r\n     * An event triggered when pointer is up\r\n     */\r\n    public onPointerUpObservable = new Observable<Vector3WithInfo>();\r\n\r\n    /**\r\n     * An event triggered when a control is clicked on (with a mouse)\r\n     */\r\n    public onPointerClickObservable = new Observable<Vector3WithInfo>();\r\n\r\n    /**\r\n     * An event triggered when pointer enters the control\r\n     */\r\n    public onPointerEnterObservable = new Observable<Control3D>();\r\n\r\n    /**\r\n     * Gets or sets the parent container\r\n     */\r\n    public parent: Nullable<Container3D>;\r\n\r\n    // Behaviors\r\n    private _behaviors = new Array<Behavior<Control3D>>();\r\n\r\n    /**\r\n     * Gets the list of attached behaviors\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors\r\n     */\r\n    public get behaviors(): Behavior<Control3D>[] {\r\n        return this._behaviors;\r\n    }\r\n\r\n    /**\r\n     * Attach a behavior to the control\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors\r\n     * @param behavior defines the behavior to attach\r\n     * @returns the current control\r\n     */\r\n    public addBehavior(behavior: Behavior<Control3D>): Control3D {\r\n        const index = this._behaviors.indexOf(behavior);\r\n\r\n        if (index !== -1) {\r\n            return this;\r\n        }\r\n\r\n        behavior.init();\r\n        const scene = this._host.scene;\r\n        if (scene.isLoading) {\r\n            // We defer the attach when the scene will be loaded\r\n            scene.onDataLoadedObservable.addOnce(() => {\r\n                behavior.attach(this);\r\n            });\r\n        } else {\r\n            behavior.attach(this);\r\n        }\r\n        this._behaviors.push(behavior);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove an attached behavior\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors\r\n     * @param behavior defines the behavior to attach\r\n     * @returns the current control\r\n     */\r\n    public removeBehavior(behavior: Behavior<Control3D>): Control3D {\r\n        const index = this._behaviors.indexOf(behavior);\r\n\r\n        if (index === -1) {\r\n            return this;\r\n        }\r\n\r\n        this._behaviors[index].detach();\r\n        this._behaviors.splice(index, 1);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets an attached behavior by name\r\n     * @param name defines the name of the behavior to look for\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors\r\n     * @returns null if behavior was not found else the requested behavior\r\n     */\r\n    public getBehaviorByName(name: string): Nullable<Behavior<Control3D>> {\r\n        for (const behavior of this._behaviors) {\r\n            if (behavior.name === name) {\r\n                return behavior;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if the control is visible */\r\n    public get isVisible(): boolean {\r\n        return this._isVisible;\r\n    }\r\n\r\n    public set isVisible(value: boolean) {\r\n        if (this._isVisible === value) {\r\n            return;\r\n        }\r\n\r\n        this._isVisible = value;\r\n\r\n        const mesh = this.mesh;\r\n        if (mesh) {\r\n            mesh.setEnabled(value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new control\r\n     * @param name defines the control name\r\n     */\r\n    constructor(\r\n        /** Defines the control name */\r\n        public name?: string\r\n    ) {}\r\n\r\n    /**\r\n     * Gets a string representing the class name\r\n     */\r\n    public get typeName(): string {\r\n        return this._getTypeName();\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the control.\r\n     * @returns current class name\r\n     */\r\n    public getClassName(): string {\r\n        return this._getTypeName();\r\n    }\r\n\r\n    protected _getTypeName(): string {\r\n        return \"Control3D\";\r\n    }\r\n\r\n    /**\r\n     * Gets the transform node used by this control\r\n     */\r\n    public get node(): Nullable<TransformNode> {\r\n        return this._node;\r\n    }\r\n\r\n    /**\r\n     * Gets the mesh used to render this control\r\n     */\r\n    public get mesh(): Nullable<AbstractMesh> {\r\n        if (this._node instanceof AbstractMesh) {\r\n            return this._node as AbstractMesh;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Link the control as child of the given node\r\n     * @param node defines the node to link to. Use null to unlink the control\r\n     * @returns the current control\r\n     */\r\n    public linkToTransformNode(node: Nullable<TransformNode>): Control3D {\r\n        if (this._node) {\r\n            this._node.parent = node;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal*\r\n     */\r\n    public _prepareNode(scene: Scene): void {\r\n        if (!this._node) {\r\n            this._node = this._createNode(scene);\r\n\r\n            if (!this.node) {\r\n                return;\r\n            }\r\n            this._injectGUI3DReservedDataStore(this.node).control = this; // Store the control on the reservedDataStore field in order to get it when picking\r\n\r\n            const mesh = this.mesh;\r\n            if (mesh) {\r\n                mesh.isPickable = true;\r\n\r\n                this._affectMaterial(mesh);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _injectGUI3DReservedDataStore(node: TransformNode): any {\r\n        node.reservedDataStore = node.reservedDataStore ?? {};\r\n        node.reservedDataStore.GUI3D = node.reservedDataStore.GUI3D ?? {};\r\n        return node.reservedDataStore.GUI3D;\r\n    }\r\n\r\n    /**\r\n     * Node creation.\r\n     * Can be overriden by children\r\n     * @param scene defines the scene where the node must be attached\r\n     * @returns the attached node or null if none. Must return a Mesh or AbstractMesh if there is an attached visible object\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _createNode(scene: Scene): Nullable<TransformNode> {\r\n        // Do nothing by default\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Affect a material to the given mesh\r\n     * @param mesh defines the mesh which will represent the control\r\n     */\r\n    protected _affectMaterial(mesh: AbstractMesh) {\r\n        mesh.material = null;\r\n    }\r\n\r\n    private _isTouchButton3D(control: Control3D): control is TouchButton3D {\r\n        return (control as TouchButton3D)._generatePointerEventType !== undefined;\r\n    }\r\n\r\n    // Pointers\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _onPointerMove(target: Control3D, coordinates: Vector3): void {\r\n        this.onPointerMoveObservable.notifyObservers(coordinates, -1, target, this);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _onPointerEnter(target: Control3D): boolean {\r\n        if (this._enterCount === -1) {\r\n            // -1 is for touch input, we are now sure we are with a mouse or pencil\r\n            this._enterCount = 0;\r\n        }\r\n\r\n        this._enterCount++;\r\n\r\n        if (this._enterCount > 1) {\r\n            return false;\r\n        }\r\n\r\n        this.onPointerEnterObservable.notifyObservers(this, -1, target, this);\r\n\r\n        if (this.pointerEnterAnimation) {\r\n            this.pointerEnterAnimation();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _onPointerOut(target: Control3D): void {\r\n        this._enterCount--;\r\n\r\n        if (this._enterCount > 0) {\r\n            return;\r\n        }\r\n\r\n        this._enterCount = 0;\r\n\r\n        this.onPointerOutObservable.notifyObservers(this, -1, target, this);\r\n\r\n        if (this.pointerOutAnimation) {\r\n            this.pointerOutAnimation();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _onPointerDown(target: Control3D, coordinates: Vector3, pointerId: number, buttonIndex: number): boolean {\r\n        this._downCount++;\r\n        this._downPointerIds[pointerId] = this._downPointerIds[pointerId] + 1 || 1;\r\n\r\n        if (this._downCount !== 1) {\r\n            return false;\r\n        }\r\n\r\n        this.onPointerDownObservable.notifyObservers(new Vector3WithInfo(coordinates, buttonIndex), -1, target, this);\r\n\r\n        if (this.pointerDownAnimation) {\r\n            this.pointerDownAnimation();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _onPointerUp(target: Control3D, coordinates: Vector3, pointerId: number, buttonIndex: number, notifyClick: boolean): void {\r\n        this._downCount--;\r\n        this._downPointerIds[pointerId]--;\r\n\r\n        if (this._downPointerIds[pointerId] <= 0) {\r\n            delete this._downPointerIds[pointerId];\r\n        }\r\n\r\n        if (this._downCount < 0) {\r\n            // Handle if forcePointerUp was called prior to this\r\n            this._downCount = 0;\r\n            return;\r\n        }\r\n\r\n        if (this._downCount == 0) {\r\n            if (notifyClick && (this._enterCount > 0 || this._enterCount === -1)) {\r\n                this.onPointerClickObservable.notifyObservers(new Vector3WithInfo(coordinates, buttonIndex), -1, target, this);\r\n            }\r\n            this.onPointerUpObservable.notifyObservers(new Vector3WithInfo(coordinates, buttonIndex), -1, target, this);\r\n\r\n            if (this.pointerUpAnimation) {\r\n                this.pointerUpAnimation();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public forcePointerUp(pointerId: Nullable<number> = null) {\r\n        if (pointerId !== null) {\r\n            this._onPointerUp(this, Vector3.Zero(), pointerId, 0, true);\r\n        } else {\r\n            for (const key in this._downPointerIds) {\r\n                this._onPointerUp(this, Vector3.Zero(), +key as number, 0, true);\r\n            }\r\n            if (this._downCount > 0) {\r\n                this._downCount = 1;\r\n                this._onPointerUp(this, Vector3.Zero(), 0, 0, true);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _processObservables(type: number, pickedPoint: Vector3, originMeshPosition: Nullable<Vector3>, pointerId: number, buttonIndex: number): boolean {\r\n        if (this._isTouchButton3D(this) && originMeshPosition) {\r\n            type = this._generatePointerEventType(type, originMeshPosition, this._downCount);\r\n        }\r\n\r\n        if (type === PointerEventTypes.POINTERMOVE) {\r\n            this._onPointerMove(this, pickedPoint);\r\n\r\n            const previousControlOver = this._host._lastControlOver[pointerId];\r\n            if (previousControlOver && previousControlOver !== this) {\r\n                previousControlOver._onPointerOut(this);\r\n            }\r\n\r\n            if (previousControlOver !== this) {\r\n                this._onPointerEnter(this);\r\n            }\r\n\r\n            this._host._lastControlOver[pointerId] = this;\r\n            return true;\r\n        }\r\n\r\n        if (type === PointerEventTypes.POINTERDOWN) {\r\n            this._onPointerDown(this, pickedPoint, pointerId, buttonIndex);\r\n            this._host._lastControlDown[pointerId] = this;\r\n            this._host._lastPickedControl = this;\r\n            return true;\r\n        }\r\n\r\n        if (type === PointerEventTypes.POINTERUP || type === PointerEventTypes.POINTERDOUBLETAP) {\r\n            if (this._host._lastControlDown[pointerId]) {\r\n                this._host._lastControlDown[pointerId]._onPointerUp(this, pickedPoint, pointerId, buttonIndex, true);\r\n            }\r\n            delete this._host._lastControlDown[pointerId];\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _disposeNode(): void {\r\n        if (this._node) {\r\n            this._node.dispose();\r\n            this._node = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Releases all associated resources\r\n     */\r\n    public dispose() {\r\n        this.onPointerDownObservable.clear();\r\n        this.onPointerEnterObservable.clear();\r\n        this.onPointerMoveObservable.clear();\r\n        this.onPointerOutObservable.clear();\r\n        this.onPointerUpObservable.clear();\r\n        this.onPointerClickObservable.clear();\r\n\r\n        this._disposeNode();\r\n\r\n        // Behaviors\r\n        for (const behavior of this._behaviors) {\r\n            behavior.detach();\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}