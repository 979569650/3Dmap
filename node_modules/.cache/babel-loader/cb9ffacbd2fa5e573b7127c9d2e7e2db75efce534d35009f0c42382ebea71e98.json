{"ast":null,"code":"import { Observable } from \"@babylonjs/core/Misc/observable.js\";\nimport { Vector2, Vector3, TmpVectors } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { PointerEventTypes } from \"@babylonjs/core/Events/pointerEvents.js\";\nimport { ClipboardEventTypes, ClipboardInfo } from \"@babylonjs/core/Events/clipboardEvents.js\";\nimport { KeyboardEventTypes } from \"@babylonjs/core/Events/keyboardEvents.js\";\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture.js\";\nimport { DynamicTexture } from \"@babylonjs/core/Materials/Textures/dynamicTexture.js\";\nimport { Layer } from \"@babylonjs/core/Layers/layer.js\";\nimport { Container } from \"./controls/container.js\";\nimport { Control } from \"./controls/control.js\";\nimport { Style } from \"./style.js\";\nimport { Measure } from \"./measure.js\";\nimport { Constants } from \"@babylonjs/core/Engines/constants.js\";\nimport { Viewport } from \"@babylonjs/core/Maths/math.viewport.js\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { WebRequest } from \"@babylonjs/core/Misc/webRequest.js\";\nimport { RandomGUID } from \"@babylonjs/core/Misc/guid.js\";\nimport { GetClass } from \"@babylonjs/core/Misc/typeStore.js\";\nimport { DecodeBase64ToBinary } from \"@babylonjs/core/Misc/stringTools.js\";\n/**\n * Class used to create texture to support 2D GUI elements\n * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui\n */\nexport class AdvancedDynamicTexture extends DynamicTexture {\n  /** Gets the number of layout calls made the last time the ADT has been rendered */\n  get numLayoutCalls() {\n    return this._numLayoutCalls;\n  }\n  /** Gets the number of render calls made the last time the ADT has been rendered */\n  get numRenderCalls() {\n    return this._numRenderCalls;\n  }\n  /**\n   * Gets or sets a number used to scale rendering size (2 means that the texture will be twice bigger).\n   * Useful when you want more antialiasing\n   */\n  get renderScale() {\n    return this._renderScale;\n  }\n  set renderScale(value) {\n    if (value === this._renderScale) {\n      return;\n    }\n    this._renderScale = value;\n    this._onResize();\n  }\n  /** Gets or sets the background color */\n  get background() {\n    return this._background;\n  }\n  set background(value) {\n    if (this._background === value) {\n      return;\n    }\n    this._background = value;\n    this.markAsDirty();\n  }\n  /**\n   * Gets or sets the ideal width used to design controls.\n   * The GUI will then rescale everything accordingly\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\n   */\n  get idealWidth() {\n    return this._idealWidth;\n  }\n  set idealWidth(value) {\n    if (this._idealWidth === value) {\n      return;\n    }\n    this._idealWidth = value;\n    this.markAsDirty();\n    this._rootContainer._markAllAsDirty();\n  }\n  /**\n   * Gets or sets the ideal height used to design controls.\n   * The GUI will then rescale everything accordingly\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\n   */\n  get idealHeight() {\n    return this._idealHeight;\n  }\n  set idealHeight(value) {\n    if (this._idealHeight === value) {\n      return;\n    }\n    this._idealHeight = value;\n    this.markAsDirty();\n    this._rootContainer._markAllAsDirty();\n  }\n  /**\n   * Gets or sets a boolean indicating if the smallest ideal value must be used if idealWidth and idealHeight are both set\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\n   */\n  get useSmallestIdeal() {\n    return this._useSmallestIdeal;\n  }\n  set useSmallestIdeal(value) {\n    if (this._useSmallestIdeal === value) {\n      return;\n    }\n    this._useSmallestIdeal = value;\n    this.markAsDirty();\n    this._rootContainer._markAllAsDirty();\n  }\n  /**\n   * Gets or sets a boolean indicating if adaptive scaling must be used\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\n   */\n  get renderAtIdealSize() {\n    return this._renderAtIdealSize;\n  }\n  set renderAtIdealSize(value) {\n    if (this._renderAtIdealSize === value) {\n      return;\n    }\n    this._renderAtIdealSize = value;\n    this._onResize();\n  }\n  /**\n   * Gets the ratio used when in \"ideal mode\"\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\n   * */\n  get idealRatio() {\n    let rwidth = 0;\n    let rheight = 0;\n    if (this._idealWidth) {\n      rwidth = this.getSize().width / this._idealWidth;\n    }\n    if (this._idealHeight) {\n      rheight = this.getSize().height / this._idealHeight;\n    }\n    if (this._useSmallestIdeal && this._idealWidth && this._idealHeight) {\n      return window.innerWidth < window.innerHeight ? rwidth : rheight;\n    }\n    if (this._idealWidth) {\n      // horizontal\n      return rwidth;\n    }\n    if (this._idealHeight) {\n      // vertical\n      return rheight;\n    }\n    return 1;\n  }\n  /**\n   * Gets the underlying layer used to render the texture when in fullscreen mode\n   */\n  get layer() {\n    return this._layerToDispose;\n  }\n  /**\n   * Gets the root container control\n   */\n  get rootContainer() {\n    return this._rootContainer;\n  }\n  /**\n   * Returns an array containing the root container.\n   * This is mostly used to let the Inspector introspects the ADT\n   * @returns an array containing the rootContainer\n   */\n  getChildren() {\n    return [this._rootContainer];\n  }\n  /**\n   * Will return all controls that are inside this texture\n   * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered\n   * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored\n   * @returns all child controls\n   */\n  getDescendants(directDescendantsOnly, predicate) {\n    return this._rootContainer.getDescendants(directDescendantsOnly, predicate);\n  }\n  /**\n   * Will return all controls with the given type name\n   * @param typeName defines the type name to search for\n   * @returns an array of all controls found\n   */\n  getControlsByType(typeName) {\n    return this._rootContainer.getDescendants(false, control => control.typeName === typeName);\n  }\n  /**\n   * Will return the first control with the given name\n   * @param name defines the name to search for\n   * @returns the first control found or null\n   */\n  getControlByName(name) {\n    return this._getControlByKey(\"name\", name);\n  }\n  _getControlByKey(key, value) {\n    return this._rootContainer.getDescendants().find(control => control[key] === value) || null;\n  }\n  /**\n   * Gets or sets the current focused control\n   */\n  get focusedControl() {\n    return this._focusedControl;\n  }\n  set focusedControl(control) {\n    if (this._focusedControl == control) {\n      return;\n    }\n    if (this._focusedControl) {\n      this._focusedControl.onBlur();\n    }\n    if (control) {\n      control.onFocus();\n    }\n    this._focusedControl = control;\n  }\n  /**\n   * Gets or sets a boolean indicating if the texture must be rendered in background or foreground when in fullscreen mode\n   */\n  get isForeground() {\n    if (!this.layer) {\n      return true;\n    }\n    return !this.layer.isBackground;\n  }\n  set isForeground(value) {\n    if (!this.layer) {\n      return;\n    }\n    if (this.layer.isBackground === !value) {\n      return;\n    }\n    this.layer.isBackground = !value;\n  }\n  /**\n   * Gets or set information about clipboardData\n   */\n  get clipboardData() {\n    return this._clipboardData;\n  }\n  set clipboardData(value) {\n    this._clipboardData = value;\n  }\n  /**\n   * Creates a new AdvancedDynamicTexture\n   * @param name defines the name of the texture\n   * @param width defines the width of the texture\n   * @param height defines the height of the texture\n   * @param scene defines the hosting scene\n   * @param generateMipMaps defines a boolean indicating if mipmaps must be generated (false by default)\n   * @param samplingMode defines the texture sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\n   * @param invertY defines if the texture needs to be inverted on the y axis during loading (true by default)\n   */\n  constructor(name, width = 0, height = 0, scene, generateMipMaps = false, samplingMode = Texture.NEAREST_SAMPLINGMODE, invertY = true) {\n    super(name, {\n      width: width,\n      height: height\n    }, scene, generateMipMaps, samplingMode, Constants.TEXTUREFORMAT_RGBA, invertY);\n    /** Observable that fires when the GUI is ready */\n    this.onGuiReadyObservable = new Observable();\n    this._isDirty = false;\n    /** @internal */\n    this._rootContainer = new Container(\"root\");\n    /** @internal */\n    this._lastControlOver = {};\n    /** @internal */\n    this._lastControlDown = {};\n    /** @internal */\n    this._capturingControl = {};\n    /** @internal */\n    this._linkedControls = new Array();\n    /** @internal */\n    this._isFullscreen = false;\n    this._fullscreenViewport = new Viewport(0, 0, 1, 1);\n    this._idealWidth = 0;\n    this._idealHeight = 0;\n    this._useSmallestIdeal = false;\n    this._renderAtIdealSize = false;\n    this._blockNextFocusCheck = false;\n    this._renderScale = 1;\n    this._cursorChanged = false;\n    this._defaultMousePointerId = 0;\n    this._rootChildrenHaveChanged = false;\n    /** @internal */\n    this._capturedPointerIds = new Set();\n    /** @internal */\n    this._numLayoutCalls = 0;\n    /** @internal */\n    this._numRenderCalls = 0;\n    /**\n     * Define type to string to ensure compatibility across browsers\n     * Safari doesn't support DataTransfer constructor\n     */\n    this._clipboardData = \"\";\n    /**\n     * Observable event triggered each time an clipboard event is received from the rendering canvas\n     */\n    this.onClipboardObservable = new Observable();\n    /**\n     * Observable event triggered each time a pointer down is intercepted by a control\n     */\n    this.onControlPickedObservable = new Observable();\n    /**\n     * Observable event triggered before layout is evaluated\n     */\n    this.onBeginLayoutObservable = new Observable();\n    /**\n     * Observable event triggered after the layout was evaluated\n     */\n    this.onEndLayoutObservable = new Observable();\n    /**\n     * Observable event triggered before the texture is rendered\n     */\n    this.onBeginRenderObservable = new Observable();\n    /**\n     * Observable event triggered after the texture was rendered\n     */\n    this.onEndRenderObservable = new Observable();\n    /**\n     * Gets or sets a boolean defining if alpha is stored as premultiplied\n     */\n    this.premulAlpha = false;\n    /**\n     * Gets or sets a boolean indicating that the canvas must be reverted on Y when updating the texture\n     */\n    this.applyYInversionOnUpdate = true;\n    /**\n     * If this is set, even when a control is pointer blocker, some events can still be passed through to the scene.\n     * Options from values are PointerEventTypes\n     * POINTERDOWN, POINTERUP, POINTERMOVE, POINTERWHEEL, POINTERPICK, POINTERTAP, POINTERDOUBLETAP\n     */\n    this.skipBlockEvents = 0;\n    /**\n     * If set to true, every scene render will trigger a pointer event for the GUI\n     * if it is linked to a mesh or has controls linked to a mesh. This will allow\n     * you to catch the pointer moving around the GUI due to camera or mesh movements,\n     * but it has a performance cost.\n     */\n    this.checkPointerEveryFrame = false;\n    this._useInvalidateRectOptimization = true;\n    // Invalidated rectangle which is the combination of all invalidated controls after they have been rotated into absolute position\n    this._invalidatedRectangle = null;\n    this._clearMeasure = new Measure(0, 0, 0, 0);\n    /**\n     * @internal\n     */\n    this._onClipboardCopy = rawEvt => {\n      const evt = rawEvt;\n      const ev = new ClipboardInfo(ClipboardEventTypes.COPY, evt);\n      this.onClipboardObservable.notifyObservers(ev);\n      evt.preventDefault();\n    };\n    /**\n     * @internal\n     */\n    this._onClipboardCut = rawEvt => {\n      const evt = rawEvt;\n      const ev = new ClipboardInfo(ClipboardEventTypes.CUT, evt);\n      this.onClipboardObservable.notifyObservers(ev);\n      evt.preventDefault();\n    };\n    /**\n     * @internal\n     */\n    this._onClipboardPaste = rawEvt => {\n      const evt = rawEvt;\n      const ev = new ClipboardInfo(ClipboardEventTypes.PASTE, evt);\n      this.onClipboardObservable.notifyObservers(ev);\n      evt.preventDefault();\n    };\n    /**\n     * Recreate the content of the ADT from a JSON object\n     * @param serializedObject define the JSON serialized object to restore from\n     * @param scaleToSize defines whether to scale to texture to the saved size\n     * @deprecated Please use parseSerializedObject instead\n     */\n    this.parseContent = this.parseSerializedObject;\n    scene = this.getScene();\n    if (!scene || !this._texture) {\n      return;\n    }\n    this.applyYInversionOnUpdate = invertY;\n    this._rootElement = scene.getEngine().getInputElement();\n    this._renderObserver = scene.onBeforeCameraRenderObservable.add(camera => this._checkUpdate(camera));\n    /** Whenever a control is added or removed to the root, we have to recheck the camera projection as it can have changed  */\n    this._controlAddedObserver = this._rootContainer.onControlAddedObservable.add(control => {\n      if (control) {\n        this._rootChildrenHaveChanged = true;\n      }\n    });\n    this._controlRemovedObserver = this._rootContainer.onControlRemovedObservable.add(control => {\n      if (control) {\n        this._rootChildrenHaveChanged = true;\n      }\n    });\n    this._preKeyboardObserver = scene.onPreKeyboardObservable.add(info => {\n      if (!this._focusedControl) {\n        return;\n      }\n      if (info.type === KeyboardEventTypes.KEYDOWN) {\n        this._focusedControl.processKeyboard(info.event);\n      }\n      info.skipOnPointerObservable = true;\n    });\n    this._rootContainer._link(this);\n    this.hasAlpha = true;\n    if (!width || !height) {\n      this._resizeObserver = scene.getEngine().onResizeObservable.add(() => this._onResize());\n      this._onResize();\n    }\n    this._texture.isReady = true;\n  }\n  /**\n   * Get the current class name of the texture useful for serialization or dynamic coding.\n   * @returns \"AdvancedDynamicTexture\"\n   */\n  getClassName() {\n    return \"AdvancedDynamicTexture\";\n  }\n  /**\n   * Function used to execute a function on all controls\n   * @param func defines the function to execute\n   * @param container defines the container where controls belong. If null the root container will be used\n   */\n  executeOnAllControls(func, container) {\n    if (!container) {\n      container = this._rootContainer;\n    }\n    func(container);\n    for (const child of container.children) {\n      if (child.children) {\n        this.executeOnAllControls(func, child);\n        continue;\n      }\n      func(child);\n    }\n  }\n  /**\n   * Gets or sets a boolean indicating if the InvalidateRect optimization should be turned on\n   */\n  get useInvalidateRectOptimization() {\n    return this._useInvalidateRectOptimization;\n  }\n  set useInvalidateRectOptimization(value) {\n    this._useInvalidateRectOptimization = value;\n  }\n  /**\n   * Invalidates a rectangle area on the gui texture\n   * @param invalidMinX left most position of the rectangle to invalidate in the texture\n   * @param invalidMinY top most position of the rectangle to invalidate in the texture\n   * @param invalidMaxX right most position of the rectangle to invalidate in the texture\n   * @param invalidMaxY bottom most position of the rectangle to invalidate in the texture\n   */\n  invalidateRect(invalidMinX, invalidMinY, invalidMaxX, invalidMaxY) {\n    if (!this._useInvalidateRectOptimization) {\n      return;\n    }\n    if (!this._invalidatedRectangle) {\n      this._invalidatedRectangle = new Measure(invalidMinX, invalidMinY, invalidMaxX - invalidMinX + 1, invalidMaxY - invalidMinY + 1);\n    } else {\n      // Compute intersection\n      const maxX = Math.ceil(Math.max(this._invalidatedRectangle.left + this._invalidatedRectangle.width - 1, invalidMaxX));\n      const maxY = Math.ceil(Math.max(this._invalidatedRectangle.top + this._invalidatedRectangle.height - 1, invalidMaxY));\n      this._invalidatedRectangle.left = Math.floor(Math.min(this._invalidatedRectangle.left, invalidMinX));\n      this._invalidatedRectangle.top = Math.floor(Math.min(this._invalidatedRectangle.top, invalidMinY));\n      this._invalidatedRectangle.width = maxX - this._invalidatedRectangle.left + 1;\n      this._invalidatedRectangle.height = maxY - this._invalidatedRectangle.top + 1;\n    }\n  }\n  /**\n   * Marks the texture as dirty forcing a complete update\n   */\n  markAsDirty() {\n    this._isDirty = true;\n  }\n  /**\n   * Helper function used to create a new style\n   * @returns a new style\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#styles\n   */\n  createStyle() {\n    return new Style(this);\n  }\n  /**\n   * Adds a new control to the root container\n   * @param control defines the control to add\n   * @returns the current texture\n   */\n  addControl(control) {\n    this._rootContainer.addControl(control);\n    return this;\n  }\n  /**\n   * Removes a control from the root container\n   * @param control defines the control to remove\n   * @returns the current texture\n   */\n  removeControl(control) {\n    this._rootContainer.removeControl(control);\n    return this;\n  }\n  /**\n   * Moves overlapped controls towards a position where it is not overlapping anymore.\n   * Please note that this method alters linkOffsetXInPixels and linkOffsetYInPixels.\n   * @param overlapGroup the overlap group which will be processed or undefined to process all overlap groups\n   * @param deltaStep the step size (speed) to reach the target non overlapping position (default 0.1)\n   * @param repelFactor how much is the control repelled by other controls\n   */\n  moveToNonOverlappedPosition(overlapGroup, deltaStep = 1, repelFactor = 1) {\n    let controlsForGroup;\n    if (Array.isArray(overlapGroup)) {\n      controlsForGroup = overlapGroup;\n    } else {\n      const descendants = this.getDescendants(true);\n      // get only the controls with an overlapGroup property set\n      // if the overlapGroup parameter is set, filter the controls and get only the controls belonging to that overlapGroup\n      controlsForGroup = overlapGroup === undefined ? descendants.filter(c => c.overlapGroup !== undefined) : descendants.filter(c => c.overlapGroup === overlapGroup);\n    }\n    controlsForGroup.forEach(control1 => {\n      var _a;\n      let velocity = Vector2.Zero();\n      const center = new Vector2(control1.centerX, control1.centerY);\n      controlsForGroup.forEach(control2 => {\n        if (control1 !== control2 && AdvancedDynamicTexture._Overlaps(control1, control2)) {\n          // if the two controls overlaps get a direction vector from one control's center to another control's center\n          const diff = center.subtract(new Vector2(control2.centerX, control2.centerY));\n          const diffLength = diff.length();\n          if (diffLength > 0) {\n            // calculate the velocity\n            velocity = velocity.add(diff.normalize().scale(repelFactor / diffLength));\n          }\n        }\n      });\n      if (velocity.length() > 0) {\n        // move the control along the direction vector away from the overlapping control\n        velocity = velocity.normalize().scale(deltaStep * ((_a = control1.overlapDeltaMultiplier) !== null && _a !== void 0 ? _a : 1));\n        control1.linkOffsetXInPixels += velocity.x;\n        control1.linkOffsetYInPixels += velocity.y;\n      }\n    });\n  }\n  /**\n   * Release all resources\n   */\n  dispose() {\n    const scene = this.getScene();\n    if (!scene) {\n      return;\n    }\n    this._rootElement = null;\n    scene.onBeforeCameraRenderObservable.remove(this._renderObserver);\n    if (this._resizeObserver) {\n      scene.getEngine().onResizeObservable.remove(this._resizeObserver);\n    }\n    if (this._prePointerObserver) {\n      scene.onPrePointerObservable.remove(this._prePointerObserver);\n    }\n    if (this._sceneRenderObserver) {\n      scene.onBeforeRenderObservable.remove(this._sceneRenderObserver);\n    }\n    if (this._pointerObserver) {\n      scene.onPointerObservable.remove(this._pointerObserver);\n    }\n    if (this._preKeyboardObserver) {\n      scene.onPreKeyboardObservable.remove(this._preKeyboardObserver);\n    }\n    if (this._canvasPointerOutObserver) {\n      scene.getEngine().onCanvasPointerOutObservable.remove(this._canvasPointerOutObserver);\n    }\n    if (this._canvasBlurObserver) {\n      scene.getEngine().onCanvasBlurObservable.remove(this._canvasBlurObserver);\n    }\n    if (this._controlAddedObserver) {\n      this._rootContainer.onControlAddedObservable.remove(this._controlAddedObserver);\n    }\n    if (this._controlRemovedObserver) {\n      this._rootContainer.onControlRemovedObservable.remove(this._controlRemovedObserver);\n    }\n    if (this._layerToDispose) {\n      this._layerToDispose.texture = null;\n      this._layerToDispose.dispose();\n      this._layerToDispose = null;\n    }\n    this._rootContainer.dispose();\n    this.onClipboardObservable.clear();\n    this.onControlPickedObservable.clear();\n    this.onBeginRenderObservable.clear();\n    this.onEndRenderObservable.clear();\n    this.onBeginLayoutObservable.clear();\n    this.onEndLayoutObservable.clear();\n    this.onGuiReadyObservable.clear();\n    super.dispose();\n  }\n  _onResize() {\n    const scene = this.getScene();\n    if (!scene) {\n      return;\n    }\n    // Check size\n    const engine = scene.getEngine();\n    const textureSize = this.getSize();\n    let renderWidth = engine.getRenderWidth() * this._renderScale;\n    let renderHeight = engine.getRenderHeight() * this._renderScale;\n    if (this._renderAtIdealSize) {\n      if (this._idealWidth) {\n        renderHeight = renderHeight * this._idealWidth / renderWidth;\n        renderWidth = this._idealWidth;\n      } else if (this._idealHeight) {\n        renderWidth = renderWidth * this._idealHeight / renderHeight;\n        renderHeight = this._idealHeight;\n      }\n    }\n    if (textureSize.width !== renderWidth || textureSize.height !== renderHeight) {\n      this.scaleTo(renderWidth, renderHeight);\n      this.markAsDirty();\n      if (this._idealWidth || this._idealHeight) {\n        this._rootContainer._markAllAsDirty();\n      }\n    }\n    this.invalidateRect(0, 0, textureSize.width - 1, textureSize.height - 1);\n  }\n  /** @internal */\n  _getGlobalViewport() {\n    const size = this.getSize();\n    const globalViewPort = this._fullscreenViewport.toGlobal(size.width, size.height);\n    const targetX = Math.round(globalViewPort.width * (1 / this.rootContainer.scaleX));\n    const targetY = Math.round(globalViewPort.height * (1 / this.rootContainer.scaleY));\n    globalViewPort.x += (globalViewPort.width - targetX) / 2;\n    globalViewPort.y += (globalViewPort.height - targetY) / 2;\n    globalViewPort.width = targetX;\n    globalViewPort.height = targetY;\n    return globalViewPort;\n  }\n  /**\n   * Get screen coordinates for a vector3\n   * @param position defines the position to project\n   * @param worldMatrix defines the world matrix to use\n   * @returns the projected position\n   */\n  getProjectedPosition(position, worldMatrix) {\n    const result = this.getProjectedPositionWithZ(position, worldMatrix);\n    return new Vector2(result.x, result.y);\n  }\n  /**\n   * Get screen coordinates for a vector3\n   * @param position defines the position to project\n   * @param worldMatrix defines the world matrix to use\n   * @returns the projected position with Z\n   */\n  getProjectedPositionWithZ(position, worldMatrix) {\n    const scene = this.getScene();\n    if (!scene) {\n      return Vector3.Zero();\n    }\n    const globalViewport = this._getGlobalViewport();\n    const projectedPosition = Vector3.Project(position, worldMatrix, scene.getTransformMatrix(), globalViewport);\n    return new Vector3(projectedPosition.x, projectedPosition.y, projectedPosition.z);\n  }\n  _checkUpdate(camera, skipUpdate) {\n    if (this._layerToDispose) {\n      if ((camera.layerMask & this._layerToDispose.layerMask) === 0) {\n        return;\n      }\n    }\n    if (this._isFullscreen && this._linkedControls.length) {\n      const scene = this.getScene();\n      if (!scene) {\n        return;\n      }\n      const globalViewport = this._getGlobalViewport();\n      for (const control of this._linkedControls) {\n        if (!control.isVisible) {\n          continue;\n        }\n        const mesh = control._linkedMesh;\n        if (!mesh || mesh.isDisposed()) {\n          Tools.SetImmediate(() => {\n            control.linkWithMesh(null);\n          });\n          continue;\n        }\n        const position = mesh.getBoundingInfo ? mesh.getBoundingInfo().boundingSphere.center : Vector3.ZeroReadOnly;\n        const projectedPosition = Vector3.Project(position, mesh.getWorldMatrix(), scene.getTransformMatrix(), globalViewport);\n        if (projectedPosition.z < 0 || projectedPosition.z > 1) {\n          control.notRenderable = true;\n          continue;\n        }\n        control.notRenderable = false;\n        if (this.useInvalidateRectOptimization) {\n          control.invalidateRect();\n        }\n        control._moveToProjectedPosition(projectedPosition);\n      }\n    }\n    if (!this._isDirty && !this._rootContainer.isDirty) {\n      return;\n    }\n    this._isDirty = false;\n    this._render(skipUpdate);\n    if (!skipUpdate) {\n      this.update(this.applyYInversionOnUpdate, this.premulAlpha, AdvancedDynamicTexture.AllowGPUOptimizations);\n    }\n  }\n  _render(skipRender) {\n    var _a;\n    const textureSize = this.getSize();\n    const renderWidth = textureSize.width;\n    const renderHeight = textureSize.height;\n    const context = this.getContext();\n    context.font = \"18px Arial\";\n    context.strokeStyle = \"white\";\n    if (this.onGuiReadyObservable.hasObservers()) {\n      this._checkGuiIsReady();\n    }\n    /** We have to recheck the camera projection in the case the root control's children have changed  */\n    if (this._rootChildrenHaveChanged) {\n      const camera = (_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.activeCamera;\n      if (camera) {\n        this._rootChildrenHaveChanged = false;\n        this._checkUpdate(camera, true);\n      }\n    }\n    // Layout\n    this.onBeginLayoutObservable.notifyObservers(this);\n    const measure = new Measure(0, 0, renderWidth, renderHeight);\n    this._numLayoutCalls = 0;\n    this._rootContainer._layout(measure, context);\n    this.onEndLayoutObservable.notifyObservers(this);\n    this._isDirty = false; // Restoring the dirty state that could have been set by controls during layout processing\n    if (skipRender) {\n      return;\n    }\n    // Clear\n    if (this._invalidatedRectangle) {\n      this._clearMeasure.copyFrom(this._invalidatedRectangle);\n    } else {\n      this._clearMeasure.copyFromFloats(0, 0, renderWidth, renderHeight);\n    }\n    context.clearRect(this._clearMeasure.left, this._clearMeasure.top, this._clearMeasure.width, this._clearMeasure.height);\n    if (this._background) {\n      context.save();\n      context.fillStyle = this._background;\n      context.fillRect(this._clearMeasure.left, this._clearMeasure.top, this._clearMeasure.width, this._clearMeasure.height);\n      context.restore();\n    }\n    // Render\n    this.onBeginRenderObservable.notifyObservers(this);\n    this._numRenderCalls = 0;\n    this._rootContainer._render(context, this._invalidatedRectangle);\n    this.onEndRenderObservable.notifyObservers(this);\n    this._invalidatedRectangle = null;\n  }\n  /**\n   * @internal\n   */\n  _changeCursor(cursor) {\n    if (this._rootElement) {\n      this._rootElement.style.cursor = cursor;\n      this._cursorChanged = true;\n    }\n  }\n  /**\n   * @internal\n   */\n  _registerLastControlDown(control, pointerId) {\n    this._lastControlDown[pointerId] = control;\n    this.onControlPickedObservable.notifyObservers(control);\n  }\n  _doPicking(x, y, pi, type, pointerId, buttonIndex, deltaX, deltaY) {\n    const scene = this.getScene();\n    if (!scene) {\n      return;\n    }\n    const engine = scene.getEngine();\n    const textureSize = this.getSize();\n    if (this._isFullscreen) {\n      const camera = scene.cameraToUseForPointers || scene.activeCamera;\n      if (!camera) {\n        return;\n      }\n      const viewport = camera.viewport;\n      x = x * (textureSize.width / (engine.getRenderWidth() * viewport.width));\n      y = y * (textureSize.height / (engine.getRenderHeight() * viewport.height));\n    }\n    if (this._capturingControl[pointerId]) {\n      if (this._capturingControl[pointerId].isPointerBlocker) {\n        this._shouldBlockPointer = true;\n      }\n      this._capturingControl[pointerId]._processObservables(type, x, y, pi, pointerId, buttonIndex);\n      return;\n    }\n    this._cursorChanged = false;\n    if (!this._rootContainer._processPicking(x, y, pi, type, pointerId, buttonIndex, deltaX, deltaY)) {\n      if (!scene.doNotHandleCursors) {\n        this._changeCursor(\"\");\n      }\n      if (type === PointerEventTypes.POINTERMOVE) {\n        if (this._lastControlOver[pointerId]) {\n          this._lastControlOver[pointerId]._onPointerOut(this._lastControlOver[pointerId], pi);\n          delete this._lastControlOver[pointerId];\n        }\n      }\n    }\n    if (!this._cursorChanged && !scene.doNotHandleCursors) {\n      this._changeCursor(\"\");\n    }\n    this._manageFocus();\n  }\n  /**\n   * @internal\n   */\n  _cleanControlAfterRemovalFromList(list, control) {\n    for (const pointerId in list) {\n      if (!Object.prototype.hasOwnProperty.call(list, pointerId)) {\n        continue;\n      }\n      const lastControlOver = list[pointerId];\n      if (lastControlOver === control) {\n        delete list[pointerId];\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _cleanControlAfterRemoval(control) {\n    this._cleanControlAfterRemovalFromList(this._lastControlDown, control);\n    this._cleanControlAfterRemovalFromList(this._lastControlOver, control);\n  }\n  /**\n   * This function will run a pointer event on this ADT and will trigger any pointer events on any controls\n   * This will work on a fullscreen ADT only. For mesh based ADT, simulate pointer events using the scene directly.\n   * @param x pointer X on the canvas for the picking\n   * @param y pointer Y on the canvas for the picking\n   * @param pi optional pointer information\n   */\n  pick(x, y, pi = null) {\n    if (this._isFullscreen && this._scene) {\n      this._translateToPicking(this._scene, new Viewport(0, 0, 0, 0), pi, x, y);\n    }\n  }\n  _translateToPicking(scene, tempViewport, pi, x = scene.pointerX, y = scene.pointerY) {\n    const camera = scene.cameraToUseForPointers || scene.activeCamera;\n    const engine = scene.getEngine();\n    const originalCameraToUseForPointers = scene.cameraToUseForPointers;\n    if (!camera) {\n      tempViewport.x = 0;\n      tempViewport.y = 0;\n      tempViewport.width = engine.getRenderWidth();\n      tempViewport.height = engine.getRenderHeight();\n    } else {\n      if (camera.rigCameras.length) {\n        // rig camera - we need to find the camera to use for this event\n        const rigViewport = new Viewport(0, 0, 1, 1);\n        camera.rigCameras.forEach(rigCamera => {\n          // generate the viewport of this camera\n          rigCamera.viewport.toGlobalToRef(engine.getRenderWidth(), engine.getRenderHeight(), rigViewport);\n          const transformedX = x / engine.getHardwareScalingLevel() - rigViewport.x;\n          const transformedY = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - rigViewport.y - rigViewport.height);\n          // check if the pointer is in the camera's viewport\n          if (transformedX < 0 || transformedY < 0 || x > rigViewport.width || y > rigViewport.height) {\n            // out of viewport - don't use this camera\n            return;\n          }\n          // set the camera to use for pointers until this pointer loop is over\n          scene.cameraToUseForPointers = rigCamera;\n          // set the viewport\n          tempViewport.x = rigViewport.x;\n          tempViewport.y = rigViewport.y;\n          tempViewport.width = rigViewport.width;\n          tempViewport.height = rigViewport.height;\n        });\n      } else {\n        camera.viewport.toGlobalToRef(engine.getRenderWidth(), engine.getRenderHeight(), tempViewport);\n      }\n    }\n    const transformedX = x / engine.getHardwareScalingLevel() - tempViewport.x;\n    const transformedY = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - tempViewport.y - tempViewport.height);\n    this._shouldBlockPointer = false;\n    // Do picking modifies _shouldBlockPointer\n    if (pi) {\n      const pointerId = pi.event.pointerId || this._defaultMousePointerId;\n      this._doPicking(transformedX, transformedY, pi, pi.type, pointerId, pi.event.button, pi.event.deltaX, pi.event.deltaY);\n      // Avoid overwriting a true skipOnPointerObservable to false\n      if (this._shouldBlockPointer && !(pi.type & this.skipBlockEvents) || this._capturingControl[pointerId]) {\n        pi.skipOnPointerObservable = true;\n      }\n    } else {\n      this._doPicking(transformedX, transformedY, null, PointerEventTypes.POINTERMOVE, this._defaultMousePointerId, 0);\n    }\n    // if overridden by a rig camera - reset back to the original value\n    scene.cameraToUseForPointers = originalCameraToUseForPointers;\n  }\n  /** Attach to all scene events required to support pointer events */\n  attach() {\n    const scene = this.getScene();\n    if (!scene) {\n      return;\n    }\n    const tempViewport = new Viewport(0, 0, 0, 0);\n    this._prePointerObserver = scene.onPrePointerObservable.add(pi => {\n      if (scene.isPointerCaptured(pi.event.pointerId) && pi.type === PointerEventTypes.POINTERUP && !this._capturedPointerIds.has(pi.event.pointerId)) {\n        return;\n      }\n      if (pi.type !== PointerEventTypes.POINTERMOVE && pi.type !== PointerEventTypes.POINTERUP && pi.type !== PointerEventTypes.POINTERDOWN && pi.type !== PointerEventTypes.POINTERWHEEL) {\n        return;\n      }\n      if (pi.type === PointerEventTypes.POINTERMOVE) {\n        // Avoid pointerMove events firing while the pointer is captured by the scene\n        if (scene.isPointerCaptured(pi.event.pointerId)) {\n          return;\n        }\n        if (pi.event.pointerId) {\n          this._defaultMousePointerId = pi.event.pointerId; // This is required to make sure we have the correct pointer ID for wheel\n        }\n      }\n\n      this._translateToPicking(scene, tempViewport, pi);\n    });\n    this._attachPickingToSceneRender(scene, () => this._translateToPicking(scene, tempViewport, null), false);\n    this._attachToOnPointerOut(scene);\n    this._attachToOnBlur(scene);\n  }\n  /**\n   * Register the clipboard Events onto the canvas\n   */\n  registerClipboardEvents() {\n    self.addEventListener(\"copy\", this._onClipboardCopy, false);\n    self.addEventListener(\"cut\", this._onClipboardCut, false);\n    self.addEventListener(\"paste\", this._onClipboardPaste, false);\n  }\n  /**\n   * Unregister the clipboard Events from the canvas\n   */\n  unRegisterClipboardEvents() {\n    self.removeEventListener(\"copy\", this._onClipboardCopy);\n    self.removeEventListener(\"cut\", this._onClipboardCut);\n    self.removeEventListener(\"paste\", this._onClipboardPaste);\n  }\n  /**\n   * Transform uvs from mesh space to texture space, taking the texture into account\n   * @param uv the uvs in mesh space\n   * @returns the uvs in texture space\n   */\n  _transformUvs(uv) {\n    const textureMatrix = this.getTextureMatrix();\n    let result;\n    if (textureMatrix.isIdentityAs3x2()) {\n      result = uv;\n    } else {\n      const homogeneousTextureMatrix = TmpVectors.Matrix[0];\n      textureMatrix.getRowToRef(0, TmpVectors.Vector4[0]);\n      textureMatrix.getRowToRef(1, TmpVectors.Vector4[1]);\n      textureMatrix.getRowToRef(2, TmpVectors.Vector4[2]);\n      const r0 = TmpVectors.Vector4[0];\n      const r1 = TmpVectors.Vector4[1];\n      const r2 = TmpVectors.Vector4[2];\n      homogeneousTextureMatrix.setRowFromFloats(0, r0.x, r0.y, 0, 0);\n      homogeneousTextureMatrix.setRowFromFloats(1, r1.x, r1.y, 0, 0);\n      homogeneousTextureMatrix.setRowFromFloats(2, 0, 0, 1, 0);\n      homogeneousTextureMatrix.setRowFromFloats(3, r2.x, r2.y, 0, 1);\n      result = TmpVectors.Vector2[0];\n      Vector2.TransformToRef(uv, homogeneousTextureMatrix, result);\n    }\n    // In wrap and mirror mode, the texture coordinate for coordinates more than 1 is the fractional part of the coordinate\n    if (this.wrapU === Texture.WRAP_ADDRESSMODE || this.wrapU === Texture.MIRROR_ADDRESSMODE) {\n      if (result.x > 1) {\n        let fX = result.x - Math.trunc(result.x);\n        // In mirror mode, the sign of the texture coordinate depends on the integer part -\n        // odd integers means it is mirrored from the original coordinate\n        if (this.wrapU === Texture.MIRROR_ADDRESSMODE && Math.trunc(result.x) % 2 === 1) {\n          fX = 1 - fX;\n        }\n        result.x = fX;\n      }\n    }\n    if (this.wrapV === Texture.WRAP_ADDRESSMODE || this.wrapV === Texture.MIRROR_ADDRESSMODE) {\n      if (result.y > 1) {\n        let fY = result.y - Math.trunc(result.y);\n        if (this.wrapV === Texture.MIRROR_ADDRESSMODE && Math.trunc(result.x) % 2 === 1) {\n          fY = 1 - fY;\n        }\n        result.y = fY;\n      }\n    }\n    return result;\n  }\n  /**\n   * Connect the texture to a hosting mesh to enable interactions\n   * @param mesh defines the mesh to attach to\n   * @param supportPointerMove defines a boolean indicating if pointer move events must be catched as well\n   */\n  attachToMesh(mesh, supportPointerMove = true) {\n    const scene = this.getScene();\n    if (!scene) {\n      return;\n    }\n    if (this._pointerObserver) {\n      scene.onPointerObservable.remove(this._pointerObserver);\n    }\n    this._pointerObserver = scene.onPointerObservable.add(pi => {\n      if (pi.type !== PointerEventTypes.POINTERMOVE && pi.type !== PointerEventTypes.POINTERUP && pi.type !== PointerEventTypes.POINTERDOWN && pi.type !== PointerEventTypes.POINTERWHEEL) {\n        return;\n      }\n      if (pi.type === PointerEventTypes.POINTERMOVE && pi.event.pointerId) {\n        this._defaultMousePointerId = pi.event.pointerId; // This is required to make sure we have the correct pointer ID for wheel\n      }\n\n      const pointerId = pi.event.pointerId || this._defaultMousePointerId;\n      if (pi.pickInfo && pi.pickInfo.hit && pi.pickInfo.pickedMesh === mesh) {\n        let uv = pi.pickInfo.getTextureCoordinates();\n        if (uv) {\n          uv = this._transformUvs(uv);\n          const size = this.getSize();\n          this._doPicking(uv.x * size.width, (this.applyYInversionOnUpdate ? 1.0 - uv.y : uv.y) * size.height, pi, pi.type, pointerId, pi.event.button, pi.event.deltaX, pi.event.deltaY);\n        }\n      } else if (pi.type === PointerEventTypes.POINTERUP) {\n        if (this._lastControlDown[pointerId]) {\n          this._lastControlDown[pointerId]._forcePointerUp(pointerId);\n        }\n        delete this._lastControlDown[pointerId];\n        if (this.focusedControl) {\n          const friendlyControls = this.focusedControl.keepsFocusWith();\n          let canMoveFocus = true;\n          if (friendlyControls) {\n            for (const control of friendlyControls) {\n              // Same host, no need to keep the focus\n              if (this === control._host) {\n                continue;\n              }\n              // Different hosts\n              const otherHost = control._host;\n              if (otherHost._lastControlOver[pointerId] && otherHost._lastControlOver[pointerId].isAscendant(control)) {\n                canMoveFocus = false;\n                break;\n              }\n            }\n          }\n          if (canMoveFocus) {\n            this.focusedControl = null;\n          }\n        }\n      } else if (pi.type === PointerEventTypes.POINTERMOVE) {\n        if (this._lastControlOver[pointerId]) {\n          this._lastControlOver[pointerId]._onPointerOut(this._lastControlOver[pointerId], pi, true);\n        }\n        delete this._lastControlOver[pointerId];\n      }\n    });\n    mesh.enablePointerMoveEvents = supportPointerMove;\n    this._attachPickingToSceneRender(scene, () => {\n      const pointerId = this._defaultMousePointerId;\n      const pick = scene === null || scene === void 0 ? void 0 : scene.pick(scene.pointerX, scene.pointerY);\n      if (pick && pick.hit && pick.pickedMesh === mesh) {\n        let uv = pick.getTextureCoordinates();\n        if (uv) {\n          uv = this._transformUvs(uv);\n          const size = this.getSize();\n          this._doPicking(uv.x * size.width, (this.applyYInversionOnUpdate ? 1.0 - uv.y : uv.y) * size.height, null, PointerEventTypes.POINTERMOVE, pointerId, 0);\n        }\n      } else {\n        if (this._lastControlOver[pointerId]) {\n          this._lastControlOver[pointerId]._onPointerOut(this._lastControlOver[pointerId], null, true);\n        }\n        delete this._lastControlOver[pointerId];\n      }\n    }, true);\n    this._attachToOnPointerOut(scene);\n    this._attachToOnBlur(scene);\n  }\n  /**\n   * Move the focus to a specific control\n   * @param control defines the control which will receive the focus\n   */\n  moveFocusToControl(control) {\n    this.focusedControl = control;\n    this._lastPickedControl = control;\n    this._blockNextFocusCheck = true;\n  }\n  _manageFocus() {\n    if (this._blockNextFocusCheck) {\n      this._blockNextFocusCheck = false;\n      this._lastPickedControl = this._focusedControl;\n      return;\n    }\n    // Focus management\n    if (this._focusedControl) {\n      if (this._focusedControl !== this._lastPickedControl) {\n        if (this._lastPickedControl.isFocusInvisible) {\n          return;\n        }\n        this.focusedControl = null;\n      }\n    }\n  }\n  _attachPickingToSceneRender(scene, pickFunction, forcePicking) {\n    this._sceneRenderObserver = scene.onBeforeRenderObservable.add(() => {\n      if (!this.checkPointerEveryFrame) {\n        return;\n      }\n      if (this._linkedControls.length > 0 || forcePicking) {\n        pickFunction();\n      }\n    });\n  }\n  _attachToOnPointerOut(scene) {\n    this._canvasPointerOutObserver = scene.getEngine().onCanvasPointerOutObservable.add(pointerEvent => {\n      if (this._lastControlOver[pointerEvent.pointerId]) {\n        this._lastControlOver[pointerEvent.pointerId]._onPointerOut(this._lastControlOver[pointerEvent.pointerId], null);\n      }\n      delete this._lastControlOver[pointerEvent.pointerId];\n      if (this._lastControlDown[pointerEvent.pointerId] && this._lastControlDown[pointerEvent.pointerId] !== this._capturingControl[pointerEvent.pointerId]) {\n        this._lastControlDown[pointerEvent.pointerId]._forcePointerUp(pointerEvent.pointerId);\n        delete this._lastControlDown[pointerEvent.pointerId];\n      }\n    });\n  }\n  _attachToOnBlur(scene) {\n    this._canvasBlurObserver = scene.getEngine().onCanvasBlurObservable.add(() => {\n      Object.entries(this._lastControlDown).forEach(([, value]) => {\n        value._onCanvasBlur();\n      });\n      this.focusedControl = null;\n      this._lastControlDown = {};\n    });\n  }\n  /**\n   * Serializes the entire GUI system\n   * @returns an object with the JSON serialized data\n   */\n  serializeContent() {\n    const size = this.getSize();\n    const serializationObject = {\n      root: {},\n      width: size.width,\n      height: size.height\n    };\n    this._rootContainer.serialize(serializationObject.root);\n    return serializationObject;\n  }\n  /**\n   * Recreate the content of the ADT from a JSON object\n   * @param serializedObject define the JSON serialized object to restore from\n   * @param scaleToSize defines whether to scale to texture to the saved size\n   */\n  parseSerializedObject(serializedObject, scaleToSize) {\n    this._rootContainer = Control.Parse(serializedObject.root, this);\n    if (scaleToSize) {\n      const width = serializedObject.width;\n      const height = serializedObject.height;\n      if (typeof width === \"number\" && typeof height === \"number\" && width >= 0 && height >= 0) {\n        this.scaleTo(width, height);\n      } else {\n        // scales the GUI to a default size if none was available in the serialized content\n        this.scaleTo(1920, 1080);\n      }\n    }\n  }\n  /**\n   * Clones the ADT\n   * @param newName defines the name of the new ADT\n   * @returns the clone of the ADT\n   */\n  clone(newName) {\n    const scene = this.getScene();\n    if (!scene) {\n      return this;\n    }\n    const size = this.getSize();\n    const data = this.serializeContent();\n    const clone = new AdvancedDynamicTexture(newName !== null && newName !== void 0 ? newName : \"Clone of \" + this.name, size.width, size.height, scene, !this.noMipmap, this.samplingMode);\n    clone.parseSerializedObject(data);\n    return clone;\n  }\n  /**\n   * Recreate the content of the ADT from a snippet saved by the GUI editor\n   * @param snippetId defines the snippet to load\n   * @param scaleToSize defines whether to scale to texture to the saved size\n   * @param appendToAdt if provided the snippet will be appended to the adt. Otherwise a fullscreen ADT will be created.\n   * @returns a promise that will resolve on success\n   */\n  static async ParseFromSnippetAsync(snippetId, scaleToSize, appendToAdt) {\n    const adt = appendToAdt !== null && appendToAdt !== void 0 ? appendToAdt : AdvancedDynamicTexture.CreateFullscreenUI(\"ADT from snippet\");\n    if (snippetId === \"_BLANK\") {\n      return adt;\n    }\n    const serialized = await AdvancedDynamicTexture._LoadURLContentAsync(AdvancedDynamicTexture.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"), true);\n    adt.parseSerializedObject(serialized, scaleToSize);\n    return adt;\n  }\n  /**\n   * Recreate the content of the ADT from a snippet saved by the GUI editor\n   * @param snippetId defines the snippet to load\n   * @param scaleToSize defines whether to scale to texture to the saved size\n   * @returns a promise that will resolve on success\n   */\n  parseFromSnippetAsync(snippetId, scaleToSize) {\n    return AdvancedDynamicTexture.ParseFromSnippetAsync(snippetId, scaleToSize, this);\n  }\n  /**\n   * Recreate the content of the ADT from a url json\n   * @param url defines the url to load\n   * @param scaleToSize defines whether to scale to texture to the saved size\n   * @param appendToAdt if provided the snippet will be appended to the adt. Otherwise a fullscreen ADT will be created.\n   * @returns a promise that will resolve on success\n   */\n  static async ParseFromFileAsync(url, scaleToSize, appendToAdt) {\n    const adt = appendToAdt !== null && appendToAdt !== void 0 ? appendToAdt : AdvancedDynamicTexture.CreateFullscreenUI(\"ADT from URL\");\n    const serialized = await AdvancedDynamicTexture._LoadURLContentAsync(url);\n    adt.parseSerializedObject(serialized, scaleToSize);\n    return adt;\n  }\n  /**\n   * Recreate the content of the ADT from a url json\n   * @param url defines the url to load\n   * @param scaleToSize defines whether to scale to texture to the saved size\n   * @returns a promise that will resolve on success\n   */\n  parseFromURLAsync(url, scaleToSize) {\n    return AdvancedDynamicTexture.ParseFromFileAsync(url, scaleToSize, this);\n  }\n  static _LoadURLContentAsync(url, snippet = false) {\n    if (url === \"\") {\n      return Promise.reject(\"No URL provided\");\n    }\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            let gui;\n            if (snippet) {\n              const payload = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n              gui = payload.encodedGui ? new TextDecoder(\"utf-8\").decode(DecodeBase64ToBinary(payload.encodedGui)) : payload.gui;\n            } else {\n              gui = request.responseText;\n            }\n            const serializationObject = JSON.parse(gui);\n            resolve(serializationObject);\n          } else {\n            reject(\"Unable to load\");\n          }\n        }\n      });\n      request.open(\"GET\", url);\n      request.send();\n    });\n  }\n  // Statics\n  /**\n   * Compares two rectangle based controls for pixel overlap\n   * @param control1 The first control to compare\n   * @param control2 The second control to compare\n   * @returns true if overlaps, otherwise false\n   */\n  static _Overlaps(control1, control2) {\n    return !(control1.centerX > control2.centerX + control2.widthInPixels || control1.centerX + control1.widthInPixels < control2.centerX || control1.centerY + control1.heightInPixels < control2.centerY || control1.centerY > control2.centerY + control2.heightInPixels);\n  }\n  /**\n   * Creates a new AdvancedDynamicTexture in projected mode (ie. attached to a mesh)\n   * @param mesh defines the mesh which will receive the texture\n   * @param width defines the texture width (1024 by default)\n   * @param height defines the texture height (1024 by default)\n   * @param supportPointerMove defines a boolean indicating if the texture must capture move events (true by default)\n   * @param onlyAlphaTesting defines a boolean indicating that alpha blending will not be used (only alpha testing) (false by default)\n   * @param invertY defines if the texture needs to be inverted on the y axis during loading (true by default)\n   * @param materialSetupCallback defines a custom way of creating and setting up the material on the mesh\n   * @returns a new AdvancedDynamicTexture\n   */\n  static CreateForMesh(mesh, width = 1024, height = 1024, supportPointerMove = true, onlyAlphaTesting = false, invertY, materialSetupCallback = this._CreateMaterial) {\n    // use a unique ID in name so serialization will work even if you create two ADTs for a single mesh\n    const uniqueId = RandomGUID();\n    const result = new AdvancedDynamicTexture(`AdvancedDynamicTexture for ${mesh.name} [${uniqueId}]`, width, height, mesh.getScene(), true, Texture.TRILINEAR_SAMPLINGMODE, invertY);\n    materialSetupCallback(mesh, uniqueId, result, onlyAlphaTesting);\n    result.attachToMesh(mesh, supportPointerMove);\n    return result;\n  }\n  static _CreateMaterial(mesh, uniqueId, texture, onlyAlphaTesting) {\n    const internalClassType = GetClass(\"BABYLON.StandardMaterial\");\n    if (!internalClassType) {\n      throw \"StandardMaterial needs to be imported before as it contains a side-effect required by your code.\";\n    }\n    const material = new internalClassType(`AdvancedDynamicTextureMaterial for ${mesh.name} [${uniqueId}]`, mesh.getScene());\n    material.backFaceCulling = false;\n    material.diffuseColor = Color3.Black();\n    material.specularColor = Color3.Black();\n    if (onlyAlphaTesting) {\n      material.diffuseTexture = texture;\n      material.emissiveTexture = texture;\n      texture.hasAlpha = true;\n    } else {\n      material.emissiveTexture = texture;\n      material.opacityTexture = texture;\n    }\n    mesh.material = material;\n  }\n  /**\n   * Creates a new AdvancedDynamicTexture in projected mode (ie. attached to a mesh) BUT do not create a new material for the mesh. You will be responsible for connecting the texture\n   * @param mesh defines the mesh which will receive the texture\n   * @param width defines the texture width (1024 by default)\n   * @param height defines the texture height (1024 by default)\n   * @param supportPointerMove defines a boolean indicating if the texture must capture move events (true by default)\n   * @param invertY defines if the texture needs to be inverted on the y axis during loading (true by default)\n   * @returns a new AdvancedDynamicTexture\n   */\n  static CreateForMeshTexture(mesh, width = 1024, height = 1024, supportPointerMove = true, invertY) {\n    const result = new AdvancedDynamicTexture(mesh.name + \" AdvancedDynamicTexture\", width, height, mesh.getScene(), true, Texture.TRILINEAR_SAMPLINGMODE, invertY);\n    result.attachToMesh(mesh, supportPointerMove);\n    return result;\n  }\n  /**\n   * Creates a new AdvancedDynamicTexture in fullscreen mode.\n   * In this mode the texture will rely on a layer for its rendering.\n   * This allows it to be treated like any other layer.\n   * As such, if you have a multi camera setup, you can set the layerMask on the GUI as well.\n   * LayerMask is set through advancedTexture.layer.layerMask\n   * @param name defines name for the texture\n   * @param foreground defines a boolean indicating if the texture must be rendered in foreground (default is true)\n   * @param scene defines the hosting scene\n   * @param sampling defines the texture sampling mode (Texture.BILINEAR_SAMPLINGMODE by default)\n   * @param adaptiveScaling defines whether to automatically scale root to match hardwarescaling (false by default)\n   * @returns a new AdvancedDynamicTexture\n   */\n  static CreateFullscreenUI(name, foreground = true, scene = null, sampling = Texture.BILINEAR_SAMPLINGMODE, adaptiveScaling = false) {\n    const result = new AdvancedDynamicTexture(name, 0, 0, scene, false, sampling);\n    // Display\n    const resultScene = result.getScene();\n    const layer = new Layer(name + \"_layer\", null, resultScene, !foreground);\n    layer.texture = result;\n    result._layerToDispose = layer;\n    result._isFullscreen = true;\n    if (adaptiveScaling && resultScene) {\n      const newScale = 1 / resultScene.getEngine().getHardwareScalingLevel();\n      result._rootContainer.scaleX = newScale;\n      result._rootContainer.scaleY = newScale;\n    }\n    // Attach\n    result.attach();\n    return result;\n  }\n  /**\n   * Scales the texture\n   * @param ratio the scale factor to apply to both width and height\n   */\n  scale(ratio) {\n    super.scale(ratio);\n    this.markAsDirty();\n  }\n  /**\n   * Resizes the texture\n   * @param width the new width\n   * @param height the new height\n   */\n  scaleTo(width, height) {\n    super.scaleTo(width, height);\n    this.markAsDirty();\n  }\n  _checkGuiIsReady() {\n    if (this.guiIsReady()) {\n      this.onGuiReadyObservable.notifyObservers(this);\n      this.onGuiReadyObservable.clear();\n    }\n  }\n  /**\n   * Returns true if all the GUI components are ready to render\n   */\n  guiIsReady() {\n    return this._rootContainer.isReady();\n  }\n}\n/** Define the Uurl to load snippets */\nAdvancedDynamicTexture.SnippetUrl = Constants.SnippetUrl;\n/** Indicates if some optimizations can be performed in GUI GPU management (the downside is additional memory/GPU texture memory used) */\nAdvancedDynamicTexture.AllowGPUOptimizations = true;","map":{"version":3,"names":["Observable","Vector2","Vector3","TmpVectors","Tools","PointerEventTypes","ClipboardEventTypes","ClipboardInfo","KeyboardEventTypes","Texture","DynamicTexture","Layer","Container","Control","Style","Measure","Constants","Viewport","Color3","WebRequest","RandomGUID","GetClass","DecodeBase64ToBinary","AdvancedDynamicTexture","numLayoutCalls","_numLayoutCalls","numRenderCalls","_numRenderCalls","renderScale","_renderScale","value","_onResize","background","_background","markAsDirty","idealWidth","_idealWidth","_rootContainer","_markAllAsDirty","idealHeight","_idealHeight","useSmallestIdeal","_useSmallestIdeal","renderAtIdealSize","_renderAtIdealSize","idealRatio","rwidth","rheight","getSize","width","height","window","innerWidth","innerHeight","layer","_layerToDispose","rootContainer","getChildren","getDescendants","directDescendantsOnly","predicate","getControlsByType","typeName","control","getControlByName","name","_getControlByKey","key","find","focusedControl","_focusedControl","onBlur","onFocus","isForeground","isBackground","clipboardData","_clipboardData","constructor","scene","generateMipMaps","samplingMode","NEAREST_SAMPLINGMODE","invertY","TEXTUREFORMAT_RGBA","onGuiReadyObservable","_isDirty","_lastControlOver","_lastControlDown","_capturingControl","_linkedControls","Array","_isFullscreen","_fullscreenViewport","_blockNextFocusCheck","_cursorChanged","_defaultMousePointerId","_rootChildrenHaveChanged","_capturedPointerIds","Set","onClipboardObservable","onControlPickedObservable","onBeginLayoutObservable","onEndLayoutObservable","onBeginRenderObservable","onEndRenderObservable","premulAlpha","applyYInversionOnUpdate","skipBlockEvents","checkPointerEveryFrame","_useInvalidateRectOptimization","_invalidatedRectangle","_clearMeasure","_onClipboardCopy","rawEvt","evt","ev","COPY","notifyObservers","preventDefault","_onClipboardCut","CUT","_onClipboardPaste","PASTE","parseContent","parseSerializedObject","getScene","_texture","_rootElement","getEngine","getInputElement","_renderObserver","onBeforeCameraRenderObservable","add","camera","_checkUpdate","_controlAddedObserver","onControlAddedObservable","_controlRemovedObserver","onControlRemovedObservable","_preKeyboardObserver","onPreKeyboardObservable","info","type","KEYDOWN","processKeyboard","event","skipOnPointerObservable","_link","hasAlpha","_resizeObserver","onResizeObservable","isReady","getClassName","executeOnAllControls","func","container","child","children","useInvalidateRectOptimization","invalidateRect","invalidMinX","invalidMinY","invalidMaxX","invalidMaxY","maxX","Math","ceil","max","left","maxY","top","floor","min","createStyle","addControl","removeControl","moveToNonOverlappedPosition","overlapGroup","deltaStep","repelFactor","controlsForGroup","isArray","descendants","undefined","filter","c","forEach","control1","velocity","Zero","center","centerX","centerY","control2","_Overlaps","diff","subtract","diffLength","length","normalize","scale","_a","overlapDeltaMultiplier","linkOffsetXInPixels","x","linkOffsetYInPixels","y","dispose","remove","_prePointerObserver","onPrePointerObservable","_sceneRenderObserver","onBeforeRenderObservable","_pointerObserver","onPointerObservable","_canvasPointerOutObserver","onCanvasPointerOutObservable","_canvasBlurObserver","onCanvasBlurObservable","texture","clear","engine","textureSize","renderWidth","getRenderWidth","renderHeight","getRenderHeight","scaleTo","_getGlobalViewport","size","globalViewPort","toGlobal","targetX","round","scaleX","targetY","scaleY","getProjectedPosition","position","worldMatrix","result","getProjectedPositionWithZ","globalViewport","projectedPosition","Project","getTransformMatrix","z","skipUpdate","layerMask","isVisible","mesh","_linkedMesh","isDisposed","SetImmediate","linkWithMesh","getBoundingInfo","boundingSphere","ZeroReadOnly","getWorldMatrix","notRenderable","_moveToProjectedPosition","isDirty","_render","update","AllowGPUOptimizations","skipRender","context","getContext","font","strokeStyle","hasObservers","_checkGuiIsReady","activeCamera","measure","_layout","copyFrom","copyFromFloats","clearRect","save","fillStyle","fillRect","restore","_changeCursor","cursor","style","_registerLastControlDown","pointerId","_doPicking","pi","buttonIndex","deltaX","deltaY","cameraToUseForPointers","viewport","isPointerBlocker","_shouldBlockPointer","_processObservables","_processPicking","doNotHandleCursors","POINTERMOVE","_onPointerOut","_manageFocus","_cleanControlAfterRemovalFromList","list","Object","prototype","hasOwnProperty","call","lastControlOver","_cleanControlAfterRemoval","pick","_scene","_translateToPicking","tempViewport","pointerX","pointerY","originalCameraToUseForPointers","rigCameras","rigViewport","rigCamera","toGlobalToRef","transformedX","getHardwareScalingLevel","transformedY","button","attach","isPointerCaptured","POINTERUP","has","POINTERDOWN","POINTERWHEEL","_attachPickingToSceneRender","_attachToOnPointerOut","_attachToOnBlur","registerClipboardEvents","self","addEventListener","unRegisterClipboardEvents","removeEventListener","_transformUvs","uv","textureMatrix","getTextureMatrix","isIdentityAs3x2","homogeneousTextureMatrix","Matrix","getRowToRef","Vector4","r0","r1","r2","setRowFromFloats","TransformToRef","wrapU","WRAP_ADDRESSMODE","MIRROR_ADDRESSMODE","fX","trunc","wrapV","fY","attachToMesh","supportPointerMove","pickInfo","hit","pickedMesh","getTextureCoordinates","_forcePointerUp","friendlyControls","keepsFocusWith","canMoveFocus","_host","otherHost","isAscendant","enablePointerMoveEvents","moveFocusToControl","_lastPickedControl","isFocusInvisible","pickFunction","forcePicking","pointerEvent","entries","_onCanvasBlur","serializeContent","serializationObject","root","serialize","serializedObject","scaleToSize","Parse","clone","newName","data","noMipmap","ParseFromSnippetAsync","snippetId","appendToAdt","adt","CreateFullscreenUI","serialized","_LoadURLContentAsync","SnippetUrl","replace","parseFromSnippetAsync","ParseFromFileAsync","url","parseFromURLAsync","snippet","Promise","reject","resolve","request","readyState","status","gui","payload","JSON","parse","responseText","jsonPayload","encodedGui","TextDecoder","decode","open","send","widthInPixels","heightInPixels","CreateForMesh","onlyAlphaTesting","materialSetupCallback","_CreateMaterial","uniqueId","TRILINEAR_SAMPLINGMODE","internalClassType","material","backFaceCulling","diffuseColor","Black","specularColor","diffuseTexture","emissiveTexture","opacityTexture","CreateForMeshTexture","foreground","sampling","BILINEAR_SAMPLINGMODE","adaptiveScaling","resultScene","newScale","ratio","guiIsReady"],"sources":["../../../../dev/gui/src/2D/advancedDynamicTexture.ts"],"sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Vector2, Vector3, TmpVectors } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { PointerInfoPre, PointerInfo, PointerInfoBase } from \"core/Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"core/Events/pointerEvents\";\r\nimport { ClipboardEventTypes, ClipboardInfo } from \"core/Events/clipboardEvents\";\r\nimport type { KeyboardInfoPre } from \"core/Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"core/Events/keyboardEvents\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { DynamicTexture } from \"core/Materials/Textures/dynamicTexture\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Layer } from \"core/Layers/layer\";\r\nimport type { Engine } from \"core/Engines/engine\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport { Container } from \"./controls/container\";\r\nimport { Control } from \"./controls/control\";\r\nimport type { IFocusableControl } from \"./controls/focusableControl\";\r\nimport { Style } from \"./style\";\r\nimport { Measure } from \"./measure\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { Viewport } from \"core/Maths/math.viewport\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { WebRequest } from \"core/Misc/webRequest\";\r\nimport type { IPointerEvent, IWheelEvent } from \"core/Events/deviceInputEvents\";\r\nimport { RandomGUID } from \"core/Misc/guid\";\r\nimport { GetClass } from \"core/Misc/typeStore\";\r\nimport { DecodeBase64ToBinary } from \"core/Misc/stringTools\";\r\n\r\nimport type { StandardMaterial } from \"core/Materials/standardMaterial\";\r\n\r\n/**\r\n * Class used to create texture to support 2D GUI elements\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui\r\n */\r\nexport class AdvancedDynamicTexture extends DynamicTexture {\r\n    /** Define the Uurl to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Indicates if some optimizations can be performed in GUI GPU management (the downside is additional memory/GPU texture memory used) */\r\n    public static AllowGPUOptimizations = true;\r\n\r\n    /** Snippet ID if the content was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /** Observable that fires when the GUI is ready */\r\n    public onGuiReadyObservable = new Observable<AdvancedDynamicTexture>();\r\n\r\n    private _isDirty = false;\r\n    private _renderObserver: Nullable<Observer<Camera>>;\r\n    private _resizeObserver: Nullable<Observer<Engine>>;\r\n    private _preKeyboardObserver: Nullable<Observer<KeyboardInfoPre>>;\r\n    private _prePointerObserver: Nullable<Observer<PointerInfoPre>>;\r\n    private _sceneRenderObserver: Nullable<Observer<Scene>>;\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>>;\r\n    private _canvasPointerOutObserver: Nullable<Observer<PointerEvent>>;\r\n    private _canvasBlurObserver: Nullable<Observer<Engine>>;\r\n    private _controlAddedObserver: Nullable<Observer<Nullable<Control>>>;\r\n    private _controlRemovedObserver: Nullable<Observer<Nullable<Control>>>;\r\n    private _background: string;\r\n    /** @internal */\r\n    public _rootContainer = new Container(\"root\");\r\n    /** @internal */\r\n    public _lastPickedControl: Control;\r\n    /** @internal */\r\n    public _lastControlOver: { [pointerId: number]: Control } = {};\r\n    /** @internal */\r\n    public _lastControlDown: { [pointerId: number]: Control } = {};\r\n    /** @internal */\r\n    public _capturingControl: { [pointerId: number]: Control } = {};\r\n    /** @internal */\r\n    public _shouldBlockPointer: boolean;\r\n    /** @internal */\r\n    public _layerToDispose: Nullable<Layer>;\r\n    /** @internal */\r\n    public _linkedControls = new Array<Control>();\r\n    /** @internal */\r\n    public _isFullscreen = false;\r\n    private _fullscreenViewport = new Viewport(0, 0, 1, 1);\r\n    private _idealWidth = 0;\r\n    private _idealHeight = 0;\r\n    private _useSmallestIdeal: boolean = false;\r\n    private _renderAtIdealSize = false;\r\n    private _focusedControl: Nullable<IFocusableControl>;\r\n    private _blockNextFocusCheck = false;\r\n    private _renderScale = 1;\r\n    private _rootElement: Nullable<HTMLElement>;\r\n    private _cursorChanged = false;\r\n    private _defaultMousePointerId = 0;\r\n    private _rootChildrenHaveChanged: boolean = false;\r\n\r\n    /** @internal */\r\n    public _capturedPointerIds = new Set<number>();\r\n\r\n    /** @internal */\r\n    public _numLayoutCalls = 0;\r\n    /** Gets the number of layout calls made the last time the ADT has been rendered */\r\n    public get numLayoutCalls(): number {\r\n        return this._numLayoutCalls;\r\n    }\r\n\r\n    /** @internal */\r\n    public _numRenderCalls = 0;\r\n    /** Gets the number of render calls made the last time the ADT has been rendered */\r\n    public get numRenderCalls(): number {\r\n        return this._numRenderCalls;\r\n    }\r\n\r\n    /**\r\n     * Define type to string to ensure compatibility across browsers\r\n     * Safari doesn't support DataTransfer constructor\r\n     */\r\n    private _clipboardData: string = \"\";\r\n    /**\r\n     * Observable event triggered each time an clipboard event is received from the rendering canvas\r\n     */\r\n    public onClipboardObservable = new Observable<ClipboardInfo>();\r\n    /**\r\n     * Observable event triggered each time a pointer down is intercepted by a control\r\n     */\r\n    public onControlPickedObservable = new Observable<Control>();\r\n    /**\r\n     * Observable event triggered before layout is evaluated\r\n     */\r\n    public onBeginLayoutObservable = new Observable<AdvancedDynamicTexture>();\r\n    /**\r\n     * Observable event triggered after the layout was evaluated\r\n     */\r\n    public onEndLayoutObservable = new Observable<AdvancedDynamicTexture>();\r\n    /**\r\n     * Observable event triggered before the texture is rendered\r\n     */\r\n    public onBeginRenderObservable = new Observable<AdvancedDynamicTexture>();\r\n    /**\r\n     * Observable event triggered after the texture was rendered\r\n     */\r\n    public onEndRenderObservable = new Observable<AdvancedDynamicTexture>();\r\n    /**\r\n     * Gets or sets a boolean defining if alpha is stored as premultiplied\r\n     */\r\n    public premulAlpha = false;\r\n    /**\r\n     * Gets or sets a boolean indicating that the canvas must be reverted on Y when updating the texture\r\n     */\r\n    public applyYInversionOnUpdate = true;\r\n    /**\r\n     * Gets or sets a number used to scale rendering size (2 means that the texture will be twice bigger).\r\n     * Useful when you want more antialiasing\r\n     */\r\n    public get renderScale(): number {\r\n        return this._renderScale;\r\n    }\r\n    public set renderScale(value: number) {\r\n        if (value === this._renderScale) {\r\n            return;\r\n        }\r\n        this._renderScale = value;\r\n        this._onResize();\r\n    }\r\n    /** Gets or sets the background color */\r\n    public get background(): string {\r\n        return this._background;\r\n    }\r\n    public set background(value: string) {\r\n        if (this._background === value) {\r\n            return;\r\n        }\r\n        this._background = value;\r\n        this.markAsDirty();\r\n    }\r\n    /**\r\n     * Gets or sets the ideal width used to design controls.\r\n     * The GUI will then rescale everything accordingly\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\r\n     */\r\n    public get idealWidth(): number {\r\n        return this._idealWidth;\r\n    }\r\n    public set idealWidth(value: number) {\r\n        if (this._idealWidth === value) {\r\n            return;\r\n        }\r\n        this._idealWidth = value;\r\n        this.markAsDirty();\r\n        this._rootContainer._markAllAsDirty();\r\n    }\r\n    /**\r\n     * Gets or sets the ideal height used to design controls.\r\n     * The GUI will then rescale everything accordingly\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\r\n     */\r\n    public get idealHeight(): number {\r\n        return this._idealHeight;\r\n    }\r\n    public set idealHeight(value: number) {\r\n        if (this._idealHeight === value) {\r\n            return;\r\n        }\r\n        this._idealHeight = value;\r\n        this.markAsDirty();\r\n        this._rootContainer._markAllAsDirty();\r\n    }\r\n    /**\r\n     * Gets or sets a boolean indicating if the smallest ideal value must be used if idealWidth and idealHeight are both set\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\r\n     */\r\n    public get useSmallestIdeal(): boolean {\r\n        return this._useSmallestIdeal;\r\n    }\r\n    public set useSmallestIdeal(value: boolean) {\r\n        if (this._useSmallestIdeal === value) {\r\n            return;\r\n        }\r\n        this._useSmallestIdeal = value;\r\n        this.markAsDirty();\r\n        this._rootContainer._markAllAsDirty();\r\n    }\r\n    /**\r\n     * Gets or sets a boolean indicating if adaptive scaling must be used\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\r\n     */\r\n    public get renderAtIdealSize(): boolean {\r\n        return this._renderAtIdealSize;\r\n    }\r\n    public set renderAtIdealSize(value: boolean) {\r\n        if (this._renderAtIdealSize === value) {\r\n            return;\r\n        }\r\n        this._renderAtIdealSize = value;\r\n        this._onResize();\r\n    }\r\n\r\n    /**\r\n     * Gets the ratio used when in \"ideal mode\"\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\r\n     * */\r\n    public get idealRatio(): number {\r\n        let rwidth: number = 0;\r\n        let rheight: number = 0;\r\n\r\n        if (this._idealWidth) {\r\n            rwidth = this.getSize().width / this._idealWidth;\r\n        }\r\n\r\n        if (this._idealHeight) {\r\n            rheight = this.getSize().height / this._idealHeight;\r\n        }\r\n\r\n        if (this._useSmallestIdeal && this._idealWidth && this._idealHeight) {\r\n            return window.innerWidth < window.innerHeight ? rwidth : rheight;\r\n        }\r\n\r\n        if (this._idealWidth) {\r\n            // horizontal\r\n            return rwidth;\r\n        }\r\n\r\n        if (this._idealHeight) {\r\n            // vertical\r\n            return rheight;\r\n        }\r\n\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Gets the underlying layer used to render the texture when in fullscreen mode\r\n     */\r\n    public get layer(): Nullable<Layer> {\r\n        return this._layerToDispose;\r\n    }\r\n    /**\r\n     * Gets the root container control\r\n     */\r\n    public get rootContainer(): Container {\r\n        return this._rootContainer;\r\n    }\r\n    /**\r\n     * Returns an array containing the root container.\r\n     * This is mostly used to let the Inspector introspects the ADT\r\n     * @returns an array containing the rootContainer\r\n     */\r\n    public getChildren(): Array<Container> {\r\n        return [this._rootContainer];\r\n    }\r\n    /**\r\n     * Will return all controls that are inside this texture\r\n     * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered\r\n     * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored\r\n     * @returns all child controls\r\n     */\r\n    public getDescendants(directDescendantsOnly?: boolean, predicate?: (control: Control) => boolean): Control[] {\r\n        return this._rootContainer.getDescendants(directDescendantsOnly, predicate);\r\n    }\r\n\r\n    /**\r\n     * Will return all controls with the given type name\r\n     * @param typeName defines the type name to search for\r\n     * @returns an array of all controls found\r\n     */\r\n    public getControlsByType(typeName: string): Control[] {\r\n        return this._rootContainer.getDescendants(false, (control) => control.typeName === typeName);\r\n    }\r\n\r\n    /**\r\n     * Will return the first control with the given name\r\n     * @param name defines the name to search for\r\n     * @returns the first control found or null\r\n     */\r\n    public getControlByName(name: string): Nullable<Control> {\r\n        return this._getControlByKey(\"name\", name);\r\n    }\r\n\r\n    private _getControlByKey(key: string, value: any): Nullable<Control> {\r\n        return this._rootContainer.getDescendants().find((control) => control[key as keyof Control] === value) || null;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current focused control\r\n     */\r\n    public get focusedControl(): Nullable<IFocusableControl> {\r\n        return this._focusedControl;\r\n    }\r\n    public set focusedControl(control: Nullable<IFocusableControl>) {\r\n        if (this._focusedControl == control) {\r\n            return;\r\n        }\r\n        if (this._focusedControl) {\r\n            this._focusedControl.onBlur();\r\n        }\r\n        if (control) {\r\n            control.onFocus();\r\n        }\r\n        this._focusedControl = control;\r\n    }\r\n    /**\r\n     * Gets or sets a boolean indicating if the texture must be rendered in background or foreground when in fullscreen mode\r\n     */\r\n    public get isForeground(): boolean {\r\n        if (!this.layer) {\r\n            return true;\r\n        }\r\n        return !this.layer.isBackground;\r\n    }\r\n    public set isForeground(value: boolean) {\r\n        if (!this.layer) {\r\n            return;\r\n        }\r\n        if (this.layer.isBackground === !value) {\r\n            return;\r\n        }\r\n        this.layer.isBackground = !value;\r\n    }\r\n    /**\r\n     * Gets or set information about clipboardData\r\n     */\r\n    public get clipboardData(): string {\r\n        return this._clipboardData;\r\n    }\r\n    public set clipboardData(value: string) {\r\n        this._clipboardData = value;\r\n    }\r\n\r\n    /**\r\n     * If this is set, even when a control is pointer blocker, some events can still be passed through to the scene.\r\n     * Options from values are PointerEventTypes\r\n     * POINTERDOWN, POINTERUP, POINTERMOVE, POINTERWHEEL, POINTERPICK, POINTERTAP, POINTERDOUBLETAP\r\n     */\r\n    public skipBlockEvents = 0;\r\n\r\n    /**\r\n     * If set to true, every scene render will trigger a pointer event for the GUI\r\n     * if it is linked to a mesh or has controls linked to a mesh. This will allow\r\n     * you to catch the pointer moving around the GUI due to camera or mesh movements,\r\n     * but it has a performance cost.\r\n     */\r\n    public checkPointerEveryFrame = false;\r\n    /**\r\n     * Creates a new AdvancedDynamicTexture\r\n     * @param name defines the name of the texture\r\n     * @param width defines the width of the texture\r\n     * @param height defines the height of the texture\r\n     * @param scene defines the hosting scene\r\n     * @param generateMipMaps defines a boolean indicating if mipmaps must be generated (false by default)\r\n     * @param samplingMode defines the texture sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading (true by default)\r\n     */\r\n    constructor(name: string, width = 0, height = 0, scene?: Nullable<Scene>, generateMipMaps = false, samplingMode = Texture.NEAREST_SAMPLINGMODE, invertY = true) {\r\n        super(name, { width: width, height: height }, scene, generateMipMaps, samplingMode, Constants.TEXTUREFORMAT_RGBA, invertY);\r\n        scene = this.getScene();\r\n        if (!scene || !this._texture) {\r\n            return;\r\n        }\r\n        this.applyYInversionOnUpdate = invertY;\r\n        this._rootElement = scene.getEngine().getInputElement();\r\n        this._renderObserver = scene.onBeforeCameraRenderObservable.add((camera: Camera) => this._checkUpdate(camera));\r\n\r\n        /** Whenever a control is added or removed to the root, we have to recheck the camera projection as it can have changed  */\r\n        this._controlAddedObserver = this._rootContainer.onControlAddedObservable.add((control) => {\r\n            if (control) {\r\n                this._rootChildrenHaveChanged = true;\r\n            }\r\n        });\r\n        this._controlRemovedObserver = this._rootContainer.onControlRemovedObservable.add((control) => {\r\n            if (control) {\r\n                this._rootChildrenHaveChanged = true;\r\n            }\r\n        });\r\n        this._preKeyboardObserver = scene.onPreKeyboardObservable.add((info) => {\r\n            if (!this._focusedControl) {\r\n                return;\r\n            }\r\n            if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                this._focusedControl.processKeyboard(info.event);\r\n            }\r\n            info.skipOnPointerObservable = true;\r\n        });\r\n        this._rootContainer._link(this);\r\n        this.hasAlpha = true;\r\n        if (!width || !height) {\r\n            this._resizeObserver = scene.getEngine().onResizeObservable.add(() => this._onResize());\r\n            this._onResize();\r\n        }\r\n        this._texture.isReady = true;\r\n    }\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"AdvancedDynamicTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"AdvancedDynamicTexture\";\r\n    }\r\n    /**\r\n     * Function used to execute a function on all controls\r\n     * @param func defines the function to execute\r\n     * @param container defines the container where controls belong. If null the root container will be used\r\n     */\r\n    public executeOnAllControls(func: (control: Control) => void, container?: Container) {\r\n        if (!container) {\r\n            container = this._rootContainer;\r\n        }\r\n        func(container);\r\n        for (const child of container.children) {\r\n            if ((<any>child).children) {\r\n                this.executeOnAllControls(func, <Container>child);\r\n                continue;\r\n            }\r\n            func(child);\r\n        }\r\n    }\r\n\r\n    private _useInvalidateRectOptimization = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the InvalidateRect optimization should be turned on\r\n     */\r\n    public get useInvalidateRectOptimization(): boolean {\r\n        return this._useInvalidateRectOptimization;\r\n    }\r\n\r\n    public set useInvalidateRectOptimization(value: boolean) {\r\n        this._useInvalidateRectOptimization = value;\r\n    }\r\n\r\n    // Invalidated rectangle which is the combination of all invalidated controls after they have been rotated into absolute position\r\n    private _invalidatedRectangle: Nullable<Measure> = null;\r\n    /**\r\n     * Invalidates a rectangle area on the gui texture\r\n     * @param invalidMinX left most position of the rectangle to invalidate in the texture\r\n     * @param invalidMinY top most position of the rectangle to invalidate in the texture\r\n     * @param invalidMaxX right most position of the rectangle to invalidate in the texture\r\n     * @param invalidMaxY bottom most position of the rectangle to invalidate in the texture\r\n     */\r\n    public invalidateRect(invalidMinX: number, invalidMinY: number, invalidMaxX: number, invalidMaxY: number) {\r\n        if (!this._useInvalidateRectOptimization) {\r\n            return;\r\n        }\r\n        if (!this._invalidatedRectangle) {\r\n            this._invalidatedRectangle = new Measure(invalidMinX, invalidMinY, invalidMaxX - invalidMinX + 1, invalidMaxY - invalidMinY + 1);\r\n        } else {\r\n            // Compute intersection\r\n            const maxX = Math.ceil(Math.max(this._invalidatedRectangle.left + this._invalidatedRectangle.width - 1, invalidMaxX));\r\n            const maxY = Math.ceil(Math.max(this._invalidatedRectangle.top + this._invalidatedRectangle.height - 1, invalidMaxY));\r\n            this._invalidatedRectangle.left = Math.floor(Math.min(this._invalidatedRectangle.left, invalidMinX));\r\n            this._invalidatedRectangle.top = Math.floor(Math.min(this._invalidatedRectangle.top, invalidMinY));\r\n            this._invalidatedRectangle.width = maxX - this._invalidatedRectangle.left + 1;\r\n            this._invalidatedRectangle.height = maxY - this._invalidatedRectangle.top + 1;\r\n        }\r\n    }\r\n    /**\r\n     * Marks the texture as dirty forcing a complete update\r\n     */\r\n    public markAsDirty() {\r\n        this._isDirty = true;\r\n    }\r\n    /**\r\n     * Helper function used to create a new style\r\n     * @returns a new style\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#styles\r\n     */\r\n    public createStyle(): Style {\r\n        return new Style(this);\r\n    }\r\n    /**\r\n     * Adds a new control to the root container\r\n     * @param control defines the control to add\r\n     * @returns the current texture\r\n     */\r\n    public addControl(control: Control): AdvancedDynamicTexture {\r\n        this._rootContainer.addControl(control);\r\n        return this;\r\n    }\r\n    /**\r\n     * Removes a control from the root container\r\n     * @param control defines the control to remove\r\n     * @returns the current texture\r\n     */\r\n    public removeControl(control: Control): AdvancedDynamicTexture {\r\n        this._rootContainer.removeControl(control);\r\n        return this;\r\n    }\r\n    /**\r\n     * Moves overlapped controls towards a position where it is not overlapping anymore.\r\n     * Please note that this method alters linkOffsetXInPixels and linkOffsetYInPixels.\r\n     * @param overlapGroup the overlap group which will be processed or undefined to process all overlap groups\r\n     * @param deltaStep the step size (speed) to reach the target non overlapping position (default 0.1)\r\n     * @param repelFactor how much is the control repelled by other controls\r\n     */\r\n    public moveToNonOverlappedPosition(overlapGroup?: number | Control[], deltaStep = 1, repelFactor = 1) {\r\n        let controlsForGroup: Control[];\r\n        if (Array.isArray(overlapGroup)) {\r\n            controlsForGroup = overlapGroup;\r\n        } else {\r\n            const descendants = this.getDescendants(true);\r\n            // get only the controls with an overlapGroup property set\r\n            // if the overlapGroup parameter is set, filter the controls and get only the controls belonging to that overlapGroup\r\n            controlsForGroup = overlapGroup === undefined ? descendants.filter((c) => c.overlapGroup !== undefined) : descendants.filter((c) => c.overlapGroup === overlapGroup);\r\n        }\r\n\r\n        controlsForGroup.forEach((control1) => {\r\n            let velocity = Vector2.Zero();\r\n            const center = new Vector2(control1.centerX, control1.centerY);\r\n\r\n            controlsForGroup.forEach((control2) => {\r\n                if (control1 !== control2 && AdvancedDynamicTexture._Overlaps(control1, control2)) {\r\n                    // if the two controls overlaps get a direction vector from one control's center to another control's center\r\n                    const diff = center.subtract(new Vector2(control2.centerX, control2.centerY));\r\n                    const diffLength = diff.length();\r\n\r\n                    if (diffLength > 0) {\r\n                        // calculate the velocity\r\n                        velocity = velocity.add(diff.normalize().scale(repelFactor / diffLength));\r\n                    }\r\n                }\r\n            });\r\n\r\n            if (velocity.length() > 0) {\r\n                // move the control along the direction vector away from the overlapping control\r\n                velocity = velocity.normalize().scale(deltaStep * (control1.overlapDeltaMultiplier ?? 1));\r\n                control1.linkOffsetXInPixels += velocity.x;\r\n                control1.linkOffsetYInPixels += velocity.y;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public dispose(): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this._rootElement = null;\r\n        scene.onBeforeCameraRenderObservable.remove(this._renderObserver);\r\n        if (this._resizeObserver) {\r\n            scene.getEngine().onResizeObservable.remove(this._resizeObserver);\r\n        }\r\n        if (this._prePointerObserver) {\r\n            scene.onPrePointerObservable.remove(this._prePointerObserver);\r\n        }\r\n        if (this._sceneRenderObserver) {\r\n            scene.onBeforeRenderObservable.remove(this._sceneRenderObserver);\r\n        }\r\n        if (this._pointerObserver) {\r\n            scene.onPointerObservable.remove(this._pointerObserver);\r\n        }\r\n        if (this._preKeyboardObserver) {\r\n            scene.onPreKeyboardObservable.remove(this._preKeyboardObserver);\r\n        }\r\n        if (this._canvasPointerOutObserver) {\r\n            scene.getEngine().onCanvasPointerOutObservable.remove(this._canvasPointerOutObserver);\r\n        }\r\n        if (this._canvasBlurObserver) {\r\n            scene.getEngine().onCanvasBlurObservable.remove(this._canvasBlurObserver);\r\n        }\r\n        if (this._controlAddedObserver) {\r\n            this._rootContainer.onControlAddedObservable.remove(this._controlAddedObserver);\r\n        }\r\n        if (this._controlRemovedObserver) {\r\n            this._rootContainer.onControlRemovedObservable.remove(this._controlRemovedObserver);\r\n        }\r\n        if (this._layerToDispose) {\r\n            this._layerToDispose.texture = null;\r\n            this._layerToDispose.dispose();\r\n            this._layerToDispose = null;\r\n        }\r\n        this._rootContainer.dispose();\r\n        this.onClipboardObservable.clear();\r\n        this.onControlPickedObservable.clear();\r\n        this.onBeginRenderObservable.clear();\r\n        this.onEndRenderObservable.clear();\r\n        this.onBeginLayoutObservable.clear();\r\n        this.onEndLayoutObservable.clear();\r\n        this.onGuiReadyObservable.clear();\r\n        super.dispose();\r\n    }\r\n    private _onResize(): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        // Check size\r\n        const engine = scene.getEngine();\r\n        const textureSize = this.getSize();\r\n        let renderWidth = engine.getRenderWidth() * this._renderScale;\r\n        let renderHeight = engine.getRenderHeight() * this._renderScale;\r\n\r\n        if (this._renderAtIdealSize) {\r\n            if (this._idealWidth) {\r\n                renderHeight = (renderHeight * this._idealWidth) / renderWidth;\r\n                renderWidth = this._idealWidth;\r\n            } else if (this._idealHeight) {\r\n                renderWidth = (renderWidth * this._idealHeight) / renderHeight;\r\n                renderHeight = this._idealHeight;\r\n            }\r\n        }\r\n        if (textureSize.width !== renderWidth || textureSize.height !== renderHeight) {\r\n            this.scaleTo(renderWidth, renderHeight);\r\n            this.markAsDirty();\r\n            if (this._idealWidth || this._idealHeight) {\r\n                this._rootContainer._markAllAsDirty();\r\n            }\r\n        }\r\n        this.invalidateRect(0, 0, textureSize.width - 1, textureSize.height - 1);\r\n    }\r\n    /** @internal */\r\n    public _getGlobalViewport(): Viewport {\r\n        const size = this.getSize();\r\n        const globalViewPort = this._fullscreenViewport.toGlobal(size.width, size.height);\r\n\r\n        const targetX = Math.round(globalViewPort.width * (1 / this.rootContainer.scaleX));\r\n        const targetY = Math.round(globalViewPort.height * (1 / this.rootContainer.scaleY));\r\n\r\n        globalViewPort.x += (globalViewPort.width - targetX) / 2;\r\n        globalViewPort.y += (globalViewPort.height - targetY) / 2;\r\n\r\n        globalViewPort.width = targetX;\r\n        globalViewPort.height = targetY;\r\n\r\n        return globalViewPort;\r\n    }\r\n    /**\r\n     * Get screen coordinates for a vector3\r\n     * @param position defines the position to project\r\n     * @param worldMatrix defines the world matrix to use\r\n     * @returns the projected position\r\n     */\r\n    public getProjectedPosition(position: Vector3, worldMatrix: Matrix): Vector2 {\r\n        const result = this.getProjectedPositionWithZ(position, worldMatrix);\r\n        return new Vector2(result.x, result.y);\r\n    }\r\n\r\n    /**\r\n     * Get screen coordinates for a vector3\r\n     * @param position defines the position to project\r\n     * @param worldMatrix defines the world matrix to use\r\n     * @returns the projected position with Z\r\n     */\r\n    public getProjectedPositionWithZ(position: Vector3, worldMatrix: Matrix): Vector3 {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return Vector3.Zero();\r\n        }\r\n        const globalViewport = this._getGlobalViewport();\r\n        const projectedPosition = Vector3.Project(position, worldMatrix, scene.getTransformMatrix(), globalViewport);\r\n        return new Vector3(projectedPosition.x, projectedPosition.y, projectedPosition.z);\r\n    }\r\n\r\n    private _checkUpdate(camera: Camera, skipUpdate?: boolean): void {\r\n        if (this._layerToDispose) {\r\n            if ((camera.layerMask & this._layerToDispose.layerMask) === 0) {\r\n                return;\r\n            }\r\n        }\r\n        if (this._isFullscreen && this._linkedControls.length) {\r\n            const scene = this.getScene();\r\n            if (!scene) {\r\n                return;\r\n            }\r\n            const globalViewport = this._getGlobalViewport();\r\n            for (const control of this._linkedControls) {\r\n                if (!control.isVisible) {\r\n                    continue;\r\n                }\r\n                const mesh = control._linkedMesh as AbstractMesh;\r\n                if (!mesh || mesh.isDisposed()) {\r\n                    Tools.SetImmediate(() => {\r\n                        control.linkWithMesh(null);\r\n                    });\r\n                    continue;\r\n                }\r\n                const position = mesh.getBoundingInfo ? mesh.getBoundingInfo().boundingSphere.center : (Vector3.ZeroReadOnly as Vector3);\r\n                const projectedPosition = Vector3.Project(position, mesh.getWorldMatrix(), scene.getTransformMatrix(), globalViewport);\r\n                if (projectedPosition.z < 0 || projectedPosition.z > 1) {\r\n                    control.notRenderable = true;\r\n                    continue;\r\n                }\r\n                control.notRenderable = false;\r\n                if (this.useInvalidateRectOptimization) {\r\n                    control.invalidateRect();\r\n                }\r\n\r\n                control._moveToProjectedPosition(projectedPosition);\r\n            }\r\n        }\r\n        if (!this._isDirty && !this._rootContainer.isDirty) {\r\n            return;\r\n        }\r\n        this._isDirty = false;\r\n        this._render(skipUpdate);\r\n        if (!skipUpdate) {\r\n            this.update(this.applyYInversionOnUpdate, this.premulAlpha, AdvancedDynamicTexture.AllowGPUOptimizations);\r\n        }\r\n    }\r\n\r\n    private _clearMeasure = new Measure(0, 0, 0, 0);\r\n\r\n    private _render(skipRender?: boolean): void {\r\n        const textureSize = this.getSize();\r\n        const renderWidth = textureSize.width;\r\n        const renderHeight = textureSize.height;\r\n\r\n        const context = this.getContext();\r\n        context.font = \"18px Arial\";\r\n        context.strokeStyle = \"white\";\r\n\r\n        if (this.onGuiReadyObservable.hasObservers()) {\r\n            this._checkGuiIsReady();\r\n        }\r\n\r\n        /** We have to recheck the camera projection in the case the root control's children have changed  */\r\n        if (this._rootChildrenHaveChanged) {\r\n            const camera = this.getScene()?.activeCamera;\r\n            if (camera) {\r\n                this._rootChildrenHaveChanged = false;\r\n                this._checkUpdate(camera, true);\r\n            }\r\n        }\r\n\r\n        // Layout\r\n        this.onBeginLayoutObservable.notifyObservers(this);\r\n        const measure = new Measure(0, 0, renderWidth, renderHeight);\r\n        this._numLayoutCalls = 0;\r\n        this._rootContainer._layout(measure, context);\r\n        this.onEndLayoutObservable.notifyObservers(this);\r\n        this._isDirty = false; // Restoring the dirty state that could have been set by controls during layout processing\r\n\r\n        if (skipRender) {\r\n            return;\r\n        }\r\n\r\n        // Clear\r\n        if (this._invalidatedRectangle) {\r\n            this._clearMeasure.copyFrom(this._invalidatedRectangle);\r\n        } else {\r\n            this._clearMeasure.copyFromFloats(0, 0, renderWidth, renderHeight);\r\n        }\r\n        context.clearRect(this._clearMeasure.left, this._clearMeasure.top, this._clearMeasure.width, this._clearMeasure.height);\r\n        if (this._background) {\r\n            context.save();\r\n            context.fillStyle = this._background;\r\n            context.fillRect(this._clearMeasure.left, this._clearMeasure.top, this._clearMeasure.width, this._clearMeasure.height);\r\n            context.restore();\r\n        }\r\n\r\n        // Render\r\n        this.onBeginRenderObservable.notifyObservers(this);\r\n        this._numRenderCalls = 0;\r\n        this._rootContainer._render(context, this._invalidatedRectangle);\r\n        this.onEndRenderObservable.notifyObservers(this);\r\n        this._invalidatedRectangle = null;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _changeCursor(cursor: string) {\r\n        if (this._rootElement) {\r\n            this._rootElement.style.cursor = cursor;\r\n            this._cursorChanged = true;\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _registerLastControlDown(control: Control, pointerId: number) {\r\n        this._lastControlDown[pointerId] = control;\r\n        this.onControlPickedObservable.notifyObservers(control);\r\n    }\r\n    private _doPicking(x: number, y: number, pi: Nullable<PointerInfoBase>, type: number, pointerId: number, buttonIndex: number, deltaX?: number, deltaY?: number): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        const engine = scene.getEngine();\r\n        const textureSize = this.getSize();\r\n        if (this._isFullscreen) {\r\n            const camera = scene.cameraToUseForPointers || scene.activeCamera;\r\n            if (!camera) {\r\n                return;\r\n            }\r\n            const viewport = camera.viewport;\r\n            x = x * (textureSize.width / (engine.getRenderWidth() * viewport.width));\r\n            y = y * (textureSize.height / (engine.getRenderHeight() * viewport.height));\r\n        }\r\n        if (this._capturingControl[pointerId]) {\r\n            if (this._capturingControl[pointerId].isPointerBlocker) {\r\n                this._shouldBlockPointer = true;\r\n            }\r\n            this._capturingControl[pointerId]._processObservables(type, x, y, pi, pointerId, buttonIndex);\r\n            return;\r\n        }\r\n\r\n        this._cursorChanged = false;\r\n        if (!this._rootContainer._processPicking(x, y, pi, type, pointerId, buttonIndex, deltaX, deltaY)) {\r\n            if (!scene.doNotHandleCursors) {\r\n                this._changeCursor(\"\");\r\n            }\r\n            if (type === PointerEventTypes.POINTERMOVE) {\r\n                if (this._lastControlOver[pointerId]) {\r\n                    this._lastControlOver[pointerId]._onPointerOut(this._lastControlOver[pointerId], pi);\r\n                    delete this._lastControlOver[pointerId];\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!this._cursorChanged && !scene.doNotHandleCursors) {\r\n            this._changeCursor(\"\");\r\n        }\r\n        this._manageFocus();\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cleanControlAfterRemovalFromList(list: { [pointerId: number]: Control }, control: Control) {\r\n        for (const pointerId in list) {\r\n            if (!Object.prototype.hasOwnProperty.call(list, pointerId)) {\r\n                continue;\r\n            }\r\n            const lastControlOver = list[pointerId];\r\n            if (lastControlOver === control) {\r\n                delete list[pointerId];\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cleanControlAfterRemoval(control: Control) {\r\n        this._cleanControlAfterRemovalFromList(this._lastControlDown, control);\r\n        this._cleanControlAfterRemovalFromList(this._lastControlOver, control);\r\n    }\r\n\r\n    /**\r\n     * This function will run a pointer event on this ADT and will trigger any pointer events on any controls\r\n     * This will work on a fullscreen ADT only. For mesh based ADT, simulate pointer events using the scene directly.\r\n     * @param x pointer X on the canvas for the picking\r\n     * @param y pointer Y on the canvas for the picking\r\n     * @param pi optional pointer information\r\n     */\r\n    public pick(x: number, y: number, pi: Nullable<PointerInfoPre> = null) {\r\n        if (this._isFullscreen && this._scene) {\r\n            this._translateToPicking(this._scene, new Viewport(0, 0, 0, 0), pi, x, y);\r\n        }\r\n    }\r\n\r\n    private _translateToPicking(scene: Scene, tempViewport: Viewport, pi: Nullable<PointerInfoPre>, x: number = scene.pointerX, y: number = scene.pointerY) {\r\n        const camera = scene.cameraToUseForPointers || scene.activeCamera;\r\n        const engine = scene.getEngine();\r\n        const originalCameraToUseForPointers = scene.cameraToUseForPointers;\r\n\r\n        if (!camera) {\r\n            tempViewport.x = 0;\r\n            tempViewport.y = 0;\r\n            tempViewport.width = engine.getRenderWidth();\r\n            tempViewport.height = engine.getRenderHeight();\r\n        } else {\r\n            if (camera.rigCameras.length) {\r\n                // rig camera - we need to find the camera to use for this event\r\n                const rigViewport = new Viewport(0, 0, 1, 1);\r\n                camera.rigCameras.forEach((rigCamera) => {\r\n                    // generate the viewport of this camera\r\n                    rigCamera.viewport.toGlobalToRef(engine.getRenderWidth(), engine.getRenderHeight(), rigViewport);\r\n                    const transformedX = x / engine.getHardwareScalingLevel() - rigViewport.x;\r\n                    const transformedY = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - rigViewport.y - rigViewport.height);\r\n                    // check if the pointer is in the camera's viewport\r\n                    if (transformedX < 0 || transformedY < 0 || x > rigViewport.width || y > rigViewport.height) {\r\n                        // out of viewport - don't use this camera\r\n                        return;\r\n                    }\r\n                    // set the camera to use for pointers until this pointer loop is over\r\n                    scene.cameraToUseForPointers = rigCamera;\r\n                    // set the viewport\r\n                    tempViewport.x = rigViewport.x;\r\n                    tempViewport.y = rigViewport.y;\r\n                    tempViewport.width = rigViewport.width;\r\n                    tempViewport.height = rigViewport.height;\r\n                });\r\n            } else {\r\n                camera.viewport.toGlobalToRef(engine.getRenderWidth(), engine.getRenderHeight(), tempViewport);\r\n            }\r\n        }\r\n\r\n        const transformedX = x / engine.getHardwareScalingLevel() - tempViewport.x;\r\n        const transformedY = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - tempViewport.y - tempViewport.height);\r\n        this._shouldBlockPointer = false;\r\n        // Do picking modifies _shouldBlockPointer\r\n        if (pi) {\r\n            const pointerId = (pi.event as IPointerEvent).pointerId || this._defaultMousePointerId;\r\n            this._doPicking(transformedX, transformedY, pi, pi.type, pointerId, pi.event.button, (<IWheelEvent>pi.event).deltaX, (<IWheelEvent>pi.event).deltaY);\r\n            // Avoid overwriting a true skipOnPointerObservable to false\r\n            if ((this._shouldBlockPointer && !(pi.type & this.skipBlockEvents)) || this._capturingControl[pointerId]) {\r\n                pi.skipOnPointerObservable = true;\r\n            }\r\n        } else {\r\n            this._doPicking(transformedX, transformedY, null, PointerEventTypes.POINTERMOVE, this._defaultMousePointerId, 0);\r\n        }\r\n        // if overridden by a rig camera - reset back to the original value\r\n        scene.cameraToUseForPointers = originalCameraToUseForPointers;\r\n    }\r\n\r\n    /** Attach to all scene events required to support pointer events */\r\n    public attach(): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const tempViewport = new Viewport(0, 0, 0, 0);\r\n\r\n        this._prePointerObserver = scene.onPrePointerObservable.add((pi) => {\r\n            if (\r\n                scene.isPointerCaptured((<IPointerEvent>pi.event).pointerId) &&\r\n                pi.type === PointerEventTypes.POINTERUP &&\r\n                !this._capturedPointerIds.has((pi.event as IPointerEvent).pointerId)\r\n            ) {\r\n                return;\r\n            }\r\n            if (\r\n                pi.type !== PointerEventTypes.POINTERMOVE &&\r\n                pi.type !== PointerEventTypes.POINTERUP &&\r\n                pi.type !== PointerEventTypes.POINTERDOWN &&\r\n                pi.type !== PointerEventTypes.POINTERWHEEL\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            if (pi.type === PointerEventTypes.POINTERMOVE) {\r\n                // Avoid pointerMove events firing while the pointer is captured by the scene\r\n                if (scene.isPointerCaptured((<IPointerEvent>pi.event).pointerId)) {\r\n                    return;\r\n                }\r\n                if ((pi.event as IPointerEvent).pointerId) {\r\n                    this._defaultMousePointerId = (pi.event as IPointerEvent).pointerId; // This is required to make sure we have the correct pointer ID for wheel\r\n                }\r\n            }\r\n            this._translateToPicking(scene, tempViewport, pi);\r\n        });\r\n        this._attachPickingToSceneRender(scene, () => this._translateToPicking(scene, tempViewport, null), false);\r\n        this._attachToOnPointerOut(scene);\r\n        this._attachToOnBlur(scene);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _onClipboardCopy = (rawEvt: Event) => {\r\n        const evt = rawEvt as ClipboardEvent;\r\n        const ev = new ClipboardInfo(ClipboardEventTypes.COPY, evt);\r\n        this.onClipboardObservable.notifyObservers(ev);\r\n        evt.preventDefault();\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    private _onClipboardCut = (rawEvt: Event) => {\r\n        const evt = rawEvt as ClipboardEvent;\r\n        const ev = new ClipboardInfo(ClipboardEventTypes.CUT, evt);\r\n        this.onClipboardObservable.notifyObservers(ev);\r\n        evt.preventDefault();\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    private _onClipboardPaste = (rawEvt: Event) => {\r\n        const evt = rawEvt as ClipboardEvent;\r\n        const ev = new ClipboardInfo(ClipboardEventTypes.PASTE, evt);\r\n        this.onClipboardObservable.notifyObservers(ev);\r\n        evt.preventDefault();\r\n    };\r\n    /**\r\n     * Register the clipboard Events onto the canvas\r\n     */\r\n    public registerClipboardEvents(): void {\r\n        self.addEventListener(\"copy\", this._onClipboardCopy, false);\r\n        self.addEventListener(\"cut\", this._onClipboardCut, false);\r\n        self.addEventListener(\"paste\", this._onClipboardPaste, false);\r\n    }\r\n    /**\r\n     * Unregister the clipboard Events from the canvas\r\n     */\r\n    public unRegisterClipboardEvents(): void {\r\n        self.removeEventListener(\"copy\", this._onClipboardCopy);\r\n        self.removeEventListener(\"cut\", this._onClipboardCut);\r\n        self.removeEventListener(\"paste\", this._onClipboardPaste);\r\n    }\r\n\r\n    /**\r\n     * Transform uvs from mesh space to texture space, taking the texture into account\r\n     * @param uv the uvs in mesh space\r\n     * @returns the uvs in texture space\r\n     */\r\n    private _transformUvs(uv: Vector2): Vector2 {\r\n        const textureMatrix = this.getTextureMatrix();\r\n        let result;\r\n        if (textureMatrix.isIdentityAs3x2()) {\r\n            result = uv;\r\n        } else {\r\n            const homogeneousTextureMatrix = TmpVectors.Matrix[0];\r\n\r\n            textureMatrix.getRowToRef(0, TmpVectors.Vector4[0]);\r\n            textureMatrix.getRowToRef(1, TmpVectors.Vector4[1]);\r\n            textureMatrix.getRowToRef(2, TmpVectors.Vector4[2]);\r\n\r\n            const r0 = TmpVectors.Vector4[0];\r\n            const r1 = TmpVectors.Vector4[1];\r\n            const r2 = TmpVectors.Vector4[2];\r\n\r\n            homogeneousTextureMatrix.setRowFromFloats(0, r0.x, r0.y, 0, 0);\r\n            homogeneousTextureMatrix.setRowFromFloats(1, r1.x, r1.y, 0, 0);\r\n            homogeneousTextureMatrix.setRowFromFloats(2, 0, 0, 1, 0);\r\n            homogeneousTextureMatrix.setRowFromFloats(3, r2.x, r2.y, 0, 1);\r\n\r\n            result = TmpVectors.Vector2[0];\r\n            Vector2.TransformToRef(uv, homogeneousTextureMatrix, result);\r\n        }\r\n\r\n        // In wrap and mirror mode, the texture coordinate for coordinates more than 1 is the fractional part of the coordinate\r\n        if (this.wrapU === Texture.WRAP_ADDRESSMODE || this.wrapU === Texture.MIRROR_ADDRESSMODE) {\r\n            if (result.x > 1) {\r\n                let fX = result.x - Math.trunc(result.x);\r\n                // In mirror mode, the sign of the texture coordinate depends on the integer part -\r\n                // odd integers means it is mirrored from the original coordinate\r\n                if (this.wrapU === Texture.MIRROR_ADDRESSMODE && Math.trunc(result.x) % 2 === 1) {\r\n                    fX = 1 - fX;\r\n                }\r\n                result.x = fX;\r\n            }\r\n        }\r\n        if (this.wrapV === Texture.WRAP_ADDRESSMODE || this.wrapV === Texture.MIRROR_ADDRESSMODE) {\r\n            if (result.y > 1) {\r\n                let fY = result.y - Math.trunc(result.y);\r\n                if (this.wrapV === Texture.MIRROR_ADDRESSMODE && Math.trunc(result.x) % 2 === 1) {\r\n                    fY = 1 - fY;\r\n                }\r\n                result.y = fY;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Connect the texture to a hosting mesh to enable interactions\r\n     * @param mesh defines the mesh to attach to\r\n     * @param supportPointerMove defines a boolean indicating if pointer move events must be catched as well\r\n     */\r\n    public attachToMesh(mesh: AbstractMesh, supportPointerMove = true): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        if (this._pointerObserver) {\r\n            scene.onPointerObservable.remove(this._pointerObserver);\r\n        }\r\n\r\n        this._pointerObserver = scene.onPointerObservable.add((pi) => {\r\n            if (\r\n                pi.type !== PointerEventTypes.POINTERMOVE &&\r\n                pi.type !== PointerEventTypes.POINTERUP &&\r\n                pi.type !== PointerEventTypes.POINTERDOWN &&\r\n                pi.type !== PointerEventTypes.POINTERWHEEL\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            if (pi.type === PointerEventTypes.POINTERMOVE && (pi.event as IPointerEvent).pointerId) {\r\n                this._defaultMousePointerId = (pi.event as IPointerEvent).pointerId; // This is required to make sure we have the correct pointer ID for wheel\r\n            }\r\n\r\n            const pointerId = (pi.event as IPointerEvent).pointerId || this._defaultMousePointerId;\r\n            if (pi.pickInfo && pi.pickInfo.hit && pi.pickInfo.pickedMesh === mesh) {\r\n                let uv = pi.pickInfo.getTextureCoordinates();\r\n                if (uv) {\r\n                    uv = this._transformUvs(uv);\r\n                    const size = this.getSize();\r\n                    this._doPicking(\r\n                        uv.x * size.width,\r\n                        (this.applyYInversionOnUpdate ? 1.0 - uv.y : uv.y) * size.height,\r\n                        pi,\r\n                        pi.type,\r\n                        pointerId,\r\n                        pi.event.button,\r\n                        (<IWheelEvent>pi.event).deltaX,\r\n                        (<IWheelEvent>pi.event).deltaY\r\n                    );\r\n                }\r\n            } else if (pi.type === PointerEventTypes.POINTERUP) {\r\n                if (this._lastControlDown[pointerId]) {\r\n                    this._lastControlDown[pointerId]._forcePointerUp(pointerId);\r\n                }\r\n                delete this._lastControlDown[pointerId];\r\n                if (this.focusedControl) {\r\n                    const friendlyControls = this.focusedControl.keepsFocusWith();\r\n                    let canMoveFocus = true;\r\n                    if (friendlyControls) {\r\n                        for (const control of friendlyControls) {\r\n                            // Same host, no need to keep the focus\r\n                            if (this === control._host) {\r\n                                continue;\r\n                            }\r\n                            // Different hosts\r\n                            const otherHost = control._host;\r\n                            if (otherHost._lastControlOver[pointerId] && otherHost._lastControlOver[pointerId].isAscendant(control)) {\r\n                                canMoveFocus = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (canMoveFocus) {\r\n                        this.focusedControl = null;\r\n                    }\r\n                }\r\n            } else if (pi.type === PointerEventTypes.POINTERMOVE) {\r\n                if (this._lastControlOver[pointerId]) {\r\n                    this._lastControlOver[pointerId]._onPointerOut(this._lastControlOver[pointerId], pi, true);\r\n                }\r\n                delete this._lastControlOver[pointerId];\r\n            }\r\n        });\r\n        mesh.enablePointerMoveEvents = supportPointerMove;\r\n        this._attachPickingToSceneRender(\r\n            scene,\r\n            () => {\r\n                const pointerId = this._defaultMousePointerId;\r\n                const pick = scene?.pick(scene.pointerX, scene.pointerY);\r\n                if (pick && pick.hit && pick.pickedMesh === mesh) {\r\n                    let uv = pick.getTextureCoordinates();\r\n                    if (uv) {\r\n                        uv = this._transformUvs(uv);\r\n                        const size = this.getSize();\r\n                        this._doPicking(uv.x * size.width, (this.applyYInversionOnUpdate ? 1.0 - uv.y : uv.y) * size.height, null, PointerEventTypes.POINTERMOVE, pointerId, 0);\r\n                    }\r\n                } else {\r\n                    if (this._lastControlOver[pointerId]) {\r\n                        this._lastControlOver[pointerId]._onPointerOut(this._lastControlOver[pointerId], null, true);\r\n                    }\r\n                    delete this._lastControlOver[pointerId];\r\n                }\r\n            },\r\n            true\r\n        );\r\n        this._attachToOnPointerOut(scene);\r\n        this._attachToOnBlur(scene);\r\n    }\r\n    /**\r\n     * Move the focus to a specific control\r\n     * @param control defines the control which will receive the focus\r\n     */\r\n    public moveFocusToControl(control: IFocusableControl): void {\r\n        this.focusedControl = control;\r\n        this._lastPickedControl = <any>control;\r\n        this._blockNextFocusCheck = true;\r\n    }\r\n    private _manageFocus(): void {\r\n        if (this._blockNextFocusCheck) {\r\n            this._blockNextFocusCheck = false;\r\n            this._lastPickedControl = <any>this._focusedControl;\r\n            return;\r\n        }\r\n        // Focus management\r\n        if (this._focusedControl) {\r\n            if (this._focusedControl !== <any>this._lastPickedControl) {\r\n                if (this._lastPickedControl.isFocusInvisible) {\r\n                    return;\r\n                }\r\n                this.focusedControl = null;\r\n            }\r\n        }\r\n    }\r\n    private _attachPickingToSceneRender(scene: Scene, pickFunction: () => void, forcePicking: boolean) {\r\n        this._sceneRenderObserver = scene.onBeforeRenderObservable.add(() => {\r\n            if (!this.checkPointerEveryFrame) {\r\n                return;\r\n            }\r\n            if (this._linkedControls.length > 0 || forcePicking) {\r\n                pickFunction();\r\n            }\r\n        });\r\n    }\r\n    private _attachToOnPointerOut(scene: Scene): void {\r\n        this._canvasPointerOutObserver = scene.getEngine().onCanvasPointerOutObservable.add((pointerEvent) => {\r\n            if (this._lastControlOver[pointerEvent.pointerId]) {\r\n                this._lastControlOver[pointerEvent.pointerId]._onPointerOut(this._lastControlOver[pointerEvent.pointerId], null);\r\n            }\r\n            delete this._lastControlOver[pointerEvent.pointerId];\r\n            if (this._lastControlDown[pointerEvent.pointerId] && this._lastControlDown[pointerEvent.pointerId] !== this._capturingControl[pointerEvent.pointerId]) {\r\n                this._lastControlDown[pointerEvent.pointerId]._forcePointerUp(pointerEvent.pointerId);\r\n                delete this._lastControlDown[pointerEvent.pointerId];\r\n            }\r\n        });\r\n    }\r\n    private _attachToOnBlur(scene: Scene): void {\r\n        this._canvasBlurObserver = scene.getEngine().onCanvasBlurObservable.add(() => {\r\n            Object.entries(this._lastControlDown).forEach(([, value]) => {\r\n                value._onCanvasBlur();\r\n            });\r\n            this.focusedControl = null;\r\n            this._lastControlDown = {};\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Serializes the entire GUI system\r\n     * @returns an object with the JSON serialized data\r\n     */\r\n    public serializeContent(): any {\r\n        const size = this.getSize();\r\n        const serializationObject = {\r\n            root: {},\r\n            width: size.width,\r\n            height: size.height,\r\n        };\r\n\r\n        this._rootContainer.serialize(serializationObject.root);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a JSON object\r\n     * @param serializedObject define the JSON serialized object to restore from\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     */\r\n    public parseSerializedObject(serializedObject: any, scaleToSize?: boolean) {\r\n        this._rootContainer = Control.Parse(serializedObject.root, this) as Container;\r\n        if (scaleToSize) {\r\n            const width = serializedObject.width;\r\n            const height = serializedObject.height;\r\n            if (typeof width === \"number\" && typeof height === \"number\" && width >= 0 && height >= 0) {\r\n                this.scaleTo(width, height);\r\n            } else {\r\n                // scales the GUI to a default size if none was available in the serialized content\r\n                this.scaleTo(1920, 1080);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones the ADT\r\n     * @param newName defines the name of the new ADT\r\n     * @returns the clone of the ADT\r\n     */\r\n    public clone(newName?: string): AdvancedDynamicTexture {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n        const size = this.getSize();\r\n        const data = this.serializeContent();\r\n        const clone = new AdvancedDynamicTexture(newName ?? \"Clone of \" + this.name, size.width, size.height, scene, !this.noMipmap, this.samplingMode);\r\n        clone.parseSerializedObject(data);\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a JSON object\r\n     * @param serializedObject define the JSON serialized object to restore from\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     * @deprecated Please use parseSerializedObject instead\r\n     */\r\n    public parseContent = this.parseSerializedObject;\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a snippet saved by the GUI editor\r\n     * @param snippetId defines the snippet to load\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     * @param appendToAdt if provided the snippet will be appended to the adt. Otherwise a fullscreen ADT will be created.\r\n     * @returns a promise that will resolve on success\r\n     */\r\n    public static async ParseFromSnippetAsync(snippetId: string, scaleToSize?: boolean, appendToAdt?: AdvancedDynamicTexture): Promise<AdvancedDynamicTexture> {\r\n        const adt = appendToAdt ?? AdvancedDynamicTexture.CreateFullscreenUI(\"ADT from snippet\");\r\n        if (snippetId === \"_BLANK\") {\r\n            return adt;\r\n        }\r\n\r\n        const serialized = await AdvancedDynamicTexture._LoadURLContentAsync(AdvancedDynamicTexture.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"), true);\r\n        adt.parseSerializedObject(serialized, scaleToSize);\r\n        return adt;\r\n    }\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a snippet saved by the GUI editor\r\n     * @param snippetId defines the snippet to load\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     * @returns a promise that will resolve on success\r\n     */\r\n    public parseFromSnippetAsync(snippetId: string, scaleToSize?: boolean): Promise<AdvancedDynamicTexture> {\r\n        return AdvancedDynamicTexture.ParseFromSnippetAsync(snippetId, scaleToSize, this);\r\n    }\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a url json\r\n     * @param url defines the url to load\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     * @param appendToAdt if provided the snippet will be appended to the adt. Otherwise a fullscreen ADT will be created.\r\n     * @returns a promise that will resolve on success\r\n     */\r\n    public static async ParseFromFileAsync(url: string, scaleToSize?: boolean, appendToAdt?: AdvancedDynamicTexture): Promise<AdvancedDynamicTexture> {\r\n        const adt = appendToAdt ?? AdvancedDynamicTexture.CreateFullscreenUI(\"ADT from URL\");\r\n        const serialized = await AdvancedDynamicTexture._LoadURLContentAsync(url);\r\n        adt.parseSerializedObject(serialized, scaleToSize);\r\n        return adt;\r\n    }\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a url json\r\n     * @param url defines the url to load\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     * @returns a promise that will resolve on success\r\n     */\r\n    public parseFromURLAsync(url: string, scaleToSize?: boolean): Promise<AdvancedDynamicTexture> {\r\n        return AdvancedDynamicTexture.ParseFromFileAsync(url, scaleToSize, this);\r\n    }\r\n\r\n    private static _LoadURLContentAsync(url: string, snippet: boolean = false): Promise<any> {\r\n        if (url === \"\") {\r\n            return Promise.reject(\"No URL provided\");\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        let gui;\r\n                        if (snippet) {\r\n                            const payload = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                            gui = payload.encodedGui ? new TextDecoder(\"utf-8\").decode(DecodeBase64ToBinary(payload.encodedGui)) : payload.gui;\r\n                        } else {\r\n                            gui = request.responseText;\r\n                        }\r\n                        const serializationObject = JSON.parse(gui);\r\n                        resolve(serializationObject);\r\n                    } else {\r\n                        reject(\"Unable to load\");\r\n                    }\r\n                }\r\n            });\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Compares two rectangle based controls for pixel overlap\r\n     * @param control1 The first control to compare\r\n     * @param control2 The second control to compare\r\n     * @returns true if overlaps, otherwise false\r\n     */\r\n    private static _Overlaps(control1: Control, control2: Control) {\r\n        return !(\r\n            control1.centerX > control2.centerX + control2.widthInPixels ||\r\n            control1.centerX + control1.widthInPixels < control2.centerX ||\r\n            control1.centerY + control1.heightInPixels < control2.centerY ||\r\n            control1.centerY > control2.centerY + control2.heightInPixels\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a new AdvancedDynamicTexture in projected mode (ie. attached to a mesh)\r\n     * @param mesh defines the mesh which will receive the texture\r\n     * @param width defines the texture width (1024 by default)\r\n     * @param height defines the texture height (1024 by default)\r\n     * @param supportPointerMove defines a boolean indicating if the texture must capture move events (true by default)\r\n     * @param onlyAlphaTesting defines a boolean indicating that alpha blending will not be used (only alpha testing) (false by default)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading (true by default)\r\n     * @param materialSetupCallback defines a custom way of creating and setting up the material on the mesh\r\n     * @returns a new AdvancedDynamicTexture\r\n     */\r\n    public static CreateForMesh(\r\n        mesh: AbstractMesh,\r\n        width = 1024,\r\n        height = 1024,\r\n        supportPointerMove = true,\r\n        onlyAlphaTesting = false,\r\n        invertY?: boolean,\r\n        materialSetupCallback: (mesh: AbstractMesh, uniqueId: string, texture: AdvancedDynamicTexture, onlyAlphaTesting: boolean) => void = this._CreateMaterial\r\n    ): AdvancedDynamicTexture {\r\n        // use a unique ID in name so serialization will work even if you create two ADTs for a single mesh\r\n        const uniqueId = RandomGUID();\r\n        const result = new AdvancedDynamicTexture(\r\n            `AdvancedDynamicTexture for ${mesh.name} [${uniqueId}]`,\r\n            width,\r\n            height,\r\n            mesh.getScene(),\r\n            true,\r\n            Texture.TRILINEAR_SAMPLINGMODE,\r\n            invertY\r\n        );\r\n\r\n        materialSetupCallback(mesh, uniqueId, result, onlyAlphaTesting);\r\n\r\n        result.attachToMesh(mesh, supportPointerMove);\r\n        return result;\r\n    }\r\n\r\n    private static _CreateMaterial(mesh: AbstractMesh, uniqueId: string, texture: AdvancedDynamicTexture, onlyAlphaTesting: boolean): void {\r\n        const internalClassType = GetClass(\"BABYLON.StandardMaterial\");\r\n        if (!internalClassType) {\r\n            throw \"StandardMaterial needs to be imported before as it contains a side-effect required by your code.\";\r\n        }\r\n\r\n        const material: StandardMaterial = new internalClassType(`AdvancedDynamicTextureMaterial for ${mesh.name} [${uniqueId}]`, mesh.getScene());\r\n        material.backFaceCulling = false;\r\n        material.diffuseColor = Color3.Black();\r\n        material.specularColor = Color3.Black();\r\n        if (onlyAlphaTesting) {\r\n            material.diffuseTexture = texture;\r\n            material.emissiveTexture = texture;\r\n            texture.hasAlpha = true;\r\n        } else {\r\n            material.emissiveTexture = texture;\r\n            material.opacityTexture = texture;\r\n        }\r\n        mesh.material = material;\r\n    }\r\n\r\n    /**\r\n     * Creates a new AdvancedDynamicTexture in projected mode (ie. attached to a mesh) BUT do not create a new material for the mesh. You will be responsible for connecting the texture\r\n     * @param mesh defines the mesh which will receive the texture\r\n     * @param width defines the texture width (1024 by default)\r\n     * @param height defines the texture height (1024 by default)\r\n     * @param supportPointerMove defines a boolean indicating if the texture must capture move events (true by default)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading (true by default)\r\n     * @returns a new AdvancedDynamicTexture\r\n     */\r\n    public static CreateForMeshTexture(mesh: AbstractMesh, width = 1024, height = 1024, supportPointerMove = true, invertY?: boolean): AdvancedDynamicTexture {\r\n        const result = new AdvancedDynamicTexture(mesh.name + \" AdvancedDynamicTexture\", width, height, mesh.getScene(), true, Texture.TRILINEAR_SAMPLINGMODE, invertY);\r\n        result.attachToMesh(mesh, supportPointerMove);\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a new AdvancedDynamicTexture in fullscreen mode.\r\n     * In this mode the texture will rely on a layer for its rendering.\r\n     * This allows it to be treated like any other layer.\r\n     * As such, if you have a multi camera setup, you can set the layerMask on the GUI as well.\r\n     * LayerMask is set through advancedTexture.layer.layerMask\r\n     * @param name defines name for the texture\r\n     * @param foreground defines a boolean indicating if the texture must be rendered in foreground (default is true)\r\n     * @param scene defines the hosting scene\r\n     * @param sampling defines the texture sampling mode (Texture.BILINEAR_SAMPLINGMODE by default)\r\n     * @param adaptiveScaling defines whether to automatically scale root to match hardwarescaling (false by default)\r\n     * @returns a new AdvancedDynamicTexture\r\n     */\r\n    public static CreateFullscreenUI(\r\n        name: string,\r\n        foreground: boolean = true,\r\n        scene: Nullable<Scene> = null,\r\n        sampling = Texture.BILINEAR_SAMPLINGMODE,\r\n        adaptiveScaling: boolean = false\r\n    ): AdvancedDynamicTexture {\r\n        const result = new AdvancedDynamicTexture(name, 0, 0, scene, false, sampling);\r\n        // Display\r\n        const resultScene = result.getScene();\r\n        const layer = new Layer(name + \"_layer\", null, resultScene, !foreground);\r\n        layer.texture = result;\r\n        result._layerToDispose = layer;\r\n        result._isFullscreen = true;\r\n\r\n        if (adaptiveScaling && resultScene) {\r\n            const newScale = 1 / resultScene.getEngine().getHardwareScalingLevel();\r\n            result._rootContainer.scaleX = newScale;\r\n            result._rootContainer.scaleY = newScale;\r\n        }\r\n\r\n        // Attach\r\n        result.attach();\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Scales the texture\r\n     * @param ratio the scale factor to apply to both width and height\r\n     */\r\n    public scale(ratio: number): void {\r\n        super.scale(ratio);\r\n        this.markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Resizes the texture\r\n     * @param width the new width\r\n     * @param height the new height\r\n     */\r\n    public scaleTo(width: number, height: number): void {\r\n        super.scaleTo(width, height);\r\n        this.markAsDirty();\r\n    }\r\n\r\n    private _checkGuiIsReady() {\r\n        if (this.guiIsReady()) {\r\n            this.onGuiReadyObservable.notifyObservers(this);\r\n\r\n            this.onGuiReadyObservable.clear();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if all the GUI components are ready to render\r\n     */\r\n    public guiIsReady(): boolean {\r\n        return this._rootContainer.isReady();\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}