{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { Matrix, TmpVectors, Vector3 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Container3D } from \"./container3D.js\";\n/**\n * Class used to create a stack panel in 3D on XY plane\n */\nexport class StackPanel3D extends Container3D {\n  /**\n   * Gets or sets a boolean indicating if the stack panel is vertical or horizontal (horizontal by default)\n   */\n  get isVertical() {\n    return this._isVertical;\n  }\n  set isVertical(value) {\n    if (this._isVertical === value) {\n      return;\n    }\n    this._isVertical = value;\n    Tools.SetImmediate(() => {\n      this._arrangeChildren();\n    });\n  }\n  /**\n   * Creates new StackPanel\n   * @param isVertical\n   */\n  constructor(isVertical = false) {\n    super();\n    this._isVertical = false;\n    /**\n     * Gets or sets the distance between elements\n     */\n    this.margin = 0.1;\n    this._isVertical = isVertical;\n  }\n  _arrangeChildren() {\n    let width = 0;\n    let height = 0;\n    let controlCount = 0;\n    const extendSizes = [];\n    const currentInverseWorld = Matrix.Invert(this.node.computeWorldMatrix(true));\n    // Measure\n    for (const child of this._children) {\n      if (!child.mesh) {\n        continue;\n      }\n      controlCount++;\n      child.mesh.computeWorldMatrix(true);\n      child.mesh.getWorldMatrix().multiplyToRef(currentInverseWorld, TmpVectors.Matrix[0]);\n      const boundingBox = child.mesh.getBoundingInfo().boundingBox;\n      const extendSize = Vector3.TransformNormal(boundingBox.extendSize, TmpVectors.Matrix[0]);\n      extendSizes.push(extendSize);\n      if (this._isVertical) {\n        height += extendSize.y;\n      } else {\n        width += extendSize.x;\n      }\n    }\n    if (this._isVertical) {\n      height += (controlCount - 1) * this.margin / 2;\n    } else {\n      width += (controlCount - 1) * this.margin / 2;\n    }\n    // Arrange\n    let offset;\n    if (this._isVertical) {\n      offset = -height;\n    } else {\n      offset = -width;\n    }\n    let index = 0;\n    for (const child of this._children) {\n      if (!child.mesh) {\n        continue;\n      }\n      controlCount--;\n      const extendSize = extendSizes[index++];\n      if (this._isVertical) {\n        child.position.y = offset + extendSize.y;\n        child.position.x = 0;\n        offset += extendSize.y * 2;\n      } else {\n        child.position.x = offset + extendSize.x;\n        child.position.y = 0;\n        offset += extendSize.x * 2;\n      }\n      offset += controlCount > 0 ? this.margin : 0;\n    }\n  }\n}","map":{"version":3,"names":["Tools","Matrix","TmpVectors","Vector3","Container3D","StackPanel3D","isVertical","_isVertical","value","SetImmediate","_arrangeChildren","constructor","margin","width","height","controlCount","extendSizes","currentInverseWorld","Invert","node","computeWorldMatrix","child","_children","mesh","getWorldMatrix","multiplyToRef","boundingBox","getBoundingInfo","extendSize","TransformNormal","push","y","x","offset","index","position"],"sources":["../../../../../dev/gui/src/3D/controls/stackPanel3D.ts"],"sourcesContent":["import { Tools } from \"core/Misc/tools\";\r\nimport { Matrix, TmpVectors, Vector3 } from \"core/Maths/math.vector\";\r\n\r\nimport { Container3D } from \"./container3D\";\r\n\r\n/**\r\n * Class used to create a stack panel in 3D on XY plane\r\n */\r\nexport class StackPanel3D extends Container3D {\r\n    private _isVertical = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the stack panel is vertical or horizontal (horizontal by default)\r\n     */\r\n    public get isVertical(): boolean {\r\n        return this._isVertical;\r\n    }\r\n\r\n    public set isVertical(value: boolean) {\r\n        if (this._isVertical === value) {\r\n            return;\r\n        }\r\n\r\n        this._isVertical = value;\r\n\r\n        Tools.SetImmediate(() => {\r\n            this._arrangeChildren();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the distance between elements\r\n     */\r\n    public margin = 0.1;\r\n\r\n    /**\r\n     * Creates new StackPanel\r\n     * @param isVertical\r\n     */\r\n    public constructor(isVertical = false) {\r\n        super();\r\n\r\n        this._isVertical = isVertical;\r\n    }\r\n\r\n    protected _arrangeChildren() {\r\n        let width = 0;\r\n        let height = 0;\r\n        let controlCount = 0;\r\n        const extendSizes = [];\r\n\r\n        const currentInverseWorld = Matrix.Invert(this.node!.computeWorldMatrix(true));\r\n\r\n        // Measure\r\n        for (const child of this._children) {\r\n            if (!child.mesh) {\r\n                continue;\r\n            }\r\n\r\n            controlCount++;\r\n            child.mesh.computeWorldMatrix(true);\r\n            child.mesh.getWorldMatrix().multiplyToRef(currentInverseWorld, TmpVectors.Matrix[0]);\r\n\r\n            const boundingBox = child.mesh.getBoundingInfo().boundingBox;\r\n            const extendSize = Vector3.TransformNormal(boundingBox.extendSize, TmpVectors.Matrix[0]);\r\n            extendSizes.push(extendSize);\r\n\r\n            if (this._isVertical) {\r\n                height += extendSize.y;\r\n            } else {\r\n                width += extendSize.x;\r\n            }\r\n        }\r\n\r\n        if (this._isVertical) {\r\n            height += ((controlCount - 1) * this.margin) / 2;\r\n        } else {\r\n            width += ((controlCount - 1) * this.margin) / 2;\r\n        }\r\n\r\n        // Arrange\r\n        let offset: number;\r\n        if (this._isVertical) {\r\n            offset = -height;\r\n        } else {\r\n            offset = -width;\r\n        }\r\n\r\n        let index = 0;\r\n        for (const child of this._children) {\r\n            if (!child.mesh) {\r\n                continue;\r\n            }\r\n            controlCount--;\r\n            const extendSize = extendSizes[index++];\r\n\r\n            if (this._isVertical) {\r\n                child.position.y = offset + extendSize.y;\r\n                child.position.x = 0;\r\n                offset += extendSize.y * 2;\r\n            } else {\r\n                child.position.x = offset + extendSize.x;\r\n                child.position.y = 0;\r\n                offset += extendSize.x * 2;\r\n            }\r\n\r\n            offset += controlCount > 0 ? this.margin : 0;\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}