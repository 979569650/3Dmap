{"ast":null,"code":"import { Matrix, Quaternion, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { Epsilon } from \"../../Maths/math.constants.js\";\n/**\n * A behavior that when attached to a mesh will follow a camera\n * @since 5.0.0\n */\nexport class FollowBehavior {\n  constructor() {\n    // Memory cache to avoid GC usage\n    this._tmpQuaternion = new Quaternion();\n    this._tmpVectors = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];\n    this._tmpMatrix = new Matrix();\n    this._tmpInvertView = new Matrix();\n    this._tmpForward = new Vector3();\n    this._tmpNodeForward = new Vector3();\n    this._tmpPosition = new Vector3();\n    this._workingPosition = new Vector3();\n    this._workingQuaternion = new Quaternion();\n    this._lastTick = -1;\n    this._recenterNextUpdate = true;\n    /**\n     * Set to false if the node should strictly follow the camera without any interpolation time\n     */\n    this.interpolatePose = true;\n    /**\n     * Rate of interpolation of position and rotation of the attached node.\n     * Higher values will give a slower interpolation.\n     */\n    this.lerpTime = 500;\n    /**\n     * If the behavior should ignore the pitch and roll of the camera.\n     */\n    this.ignoreCameraPitchAndRoll = false;\n    /**\n     * Pitch offset from camera (relative to Max Distance)\n     * Is only effective if `ignoreCameraPitchAndRoll` is set to `true`.\n     */\n    this.pitchOffset = 15;\n    /**\n     * The vertical angle from the camera forward axis to the owner will not exceed this value\n     */\n    this.maxViewVerticalDegrees = 30;\n    /**\n     * The horizontal angle from the camera forward axis to the owner will not exceed this value\n     */\n    this.maxViewHorizontalDegrees = 30;\n    /**\n     * The attached node will not reorient until the angle between its forward vector and the vector to the camera is greater than this value\n     */\n    this.orientToCameraDeadzoneDegrees = 60;\n    /**\n     * Option to ignore distance clamping\n     */\n    this.ignoreDistanceClamp = false;\n    /**\n     * Option to ignore angle clamping\n     */\n    this.ignoreAngleClamp = false;\n    /**\n     * Max vertical distance between the attachedNode and camera\n     */\n    this.verticalMaxDistance = 0;\n    /**\n     *  Default distance from eye to attached node, i.e. the sphere radius\n     */\n    this.defaultDistance = 0.8;\n    /**\n     *  Max distance from eye to attached node, i.e. the sphere radius\n     */\n    this.maximumDistance = 2;\n    /**\n     *  Min distance from eye to attached node, i.e. the sphere radius\n     */\n    this.minimumDistance = 0.3;\n    /**\n     * Ignore vertical movement and lock the Y position of the object.\n     */\n    this.useFixedVerticalOffset = false;\n    /**\n     * Fixed vertical position offset distance.\n     */\n    this.fixedVerticalOffset = 0;\n    /**\n     * Enables/disables the behavior\n     * @internal\n     */\n    this._enabled = true;\n  }\n  /**\n   * The camera that should be followed by this behavior\n   */\n  get followedCamera() {\n    return this._followedCamera || this._scene.activeCamera;\n  }\n  set followedCamera(camera) {\n    this._followedCamera = camera;\n  }\n  /**\n   *  The name of the behavior\n   */\n  get name() {\n    return \"Follow\";\n  }\n  /**\n   *  Initializes the behavior\n   */\n  init() {}\n  /**\n   * Attaches the follow behavior\n   * @param ownerNode The mesh that will be following once attached\n   * @param followedCamera The camera that should be followed by the node\n   */\n  attach(ownerNode, followedCamera) {\n    this._scene = ownerNode.getScene();\n    this.attachedNode = ownerNode;\n    if (followedCamera) {\n      this.followedCamera = followedCamera;\n    }\n    this._addObservables();\n  }\n  /**\n   *  Detaches the behavior from the mesh\n   */\n  detach() {\n    this.attachedNode = null;\n    this._removeObservables();\n  }\n  /**\n   * Recenters the attached node in front of the camera on the next update\n   */\n  recenter() {\n    this._recenterNextUpdate = true;\n  }\n  _angleBetweenVectorAndPlane(vector, normal) {\n    // Work on copies\n    this._tmpVectors[0].copyFrom(vector);\n    vector = this._tmpVectors[0];\n    this._tmpVectors[1].copyFrom(normal);\n    normal = this._tmpVectors[1];\n    vector.normalize();\n    normal.normalize();\n    return Math.PI / 2 - Math.acos(Vector3.Dot(vector, normal));\n  }\n  _length2D(vector) {\n    return Math.sqrt(vector.x * vector.x + vector.z * vector.z);\n  }\n  _distanceClamp(currentToTarget, moveToDefault = false) {\n    let minDistance = this.minimumDistance;\n    let maxDistance = this.maximumDistance;\n    const defaultDistance = this.defaultDistance;\n    const direction = this._tmpVectors[0];\n    direction.copyFrom(currentToTarget);\n    let currentDistance = direction.length();\n    direction.normalizeFromLength(currentDistance);\n    if (this.ignoreCameraPitchAndRoll) {\n      // If we don't account for pitch offset, the casted object will float up/down as the reference\n      // gets closer to it because we will still be casting in the direction of the pitched offset.\n      // To fix this, only modify the XZ position of the object.\n      minDistance = this._length2D(direction) * minDistance;\n      maxDistance = this._length2D(direction) * maxDistance;\n      const currentDistance2D = this._length2D(currentToTarget);\n      direction.scaleInPlace(currentDistance / currentDistance2D);\n      currentDistance = currentDistance2D;\n    }\n    let clampedDistance = currentDistance;\n    if (moveToDefault) {\n      clampedDistance = defaultDistance;\n    } else {\n      clampedDistance = Scalar.Clamp(currentDistance, minDistance, maxDistance);\n    }\n    currentToTarget.copyFrom(direction).scaleInPlace(clampedDistance);\n    return currentDistance !== clampedDistance;\n  }\n  _applyVerticalClamp(currentToTarget) {\n    if (this.verticalMaxDistance !== 0) {\n      currentToTarget.y = Scalar.Clamp(currentToTarget.y, -this.verticalMaxDistance, this.verticalMaxDistance);\n    }\n  }\n  _toOrientationQuatToRef(vector, quaternion) {\n    Quaternion.RotationYawPitchRollToRef(Math.atan2(vector.x, vector.z), Math.atan2(vector.y, Math.sqrt(vector.z * vector.z + vector.x * vector.x)), 0, quaternion);\n  }\n  _applyPitchOffset(invertView) {\n    const forward = this._tmpVectors[0];\n    const right = this._tmpVectors[1];\n    forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n    right.copyFromFloats(1, 0, 0);\n    Vector3.TransformNormalToRef(forward, invertView, forward);\n    forward.y = 0;\n    forward.normalize();\n    Vector3.TransformNormalToRef(right, invertView, right);\n    Quaternion.RotationAxisToRef(right, this.pitchOffset * Math.PI / 180, this._tmpQuaternion);\n    forward.rotateByQuaternionToRef(this._tmpQuaternion, forward);\n    this._toOrientationQuatToRef(forward, this._tmpQuaternion);\n    this._tmpQuaternion.toRotationMatrix(this._tmpMatrix);\n    // Since we already extracted position from the invert view matrix, we can\n    // disregard the position part of the matrix in the copy\n    invertView.copyFrom(this._tmpMatrix);\n  }\n  _angularClamp(invertView, currentToTarget) {\n    const forward = this._tmpVectors[5];\n    forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n    const right = this._tmpVectors[6];\n    right.copyFromFloats(1, 0, 0);\n    // forward and right are related to camera frame of reference\n    Vector3.TransformNormalToRef(forward, invertView, forward);\n    Vector3.TransformNormalToRef(right, invertView, right);\n    // Up is global Z\n    const up = Vector3.UpReadOnly;\n    const dist = currentToTarget.length();\n    if (dist < Epsilon) {\n      return false;\n    }\n    let angularClamped = false;\n    const rotationQuat = this._tmpQuaternion;\n    // X-axis leashing\n    if (this.ignoreCameraPitchAndRoll) {\n      const angle = Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);\n      Quaternion.RotationAxisToRef(right, angle, rotationQuat);\n      currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\n    } else {\n      const angle = -Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);\n      const minMaxAngle = this.maxViewVerticalDegrees * Math.PI / 180 * 0.5;\n      if (angle < -minMaxAngle) {\n        Quaternion.RotationAxisToRef(right, -angle - minMaxAngle, rotationQuat);\n        currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\n        angularClamped = true;\n      } else if (angle > minMaxAngle) {\n        Quaternion.RotationAxisToRef(right, -angle + minMaxAngle, rotationQuat);\n        currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\n        angularClamped = true;\n      }\n    }\n    // Y-axis leashing\n    const angle = this._angleBetweenVectorAndPlane(currentToTarget, right) * (this._scene.useRightHandedSystem ? -1 : 1);\n    const minMaxAngle = this.maxViewHorizontalDegrees * Math.PI / 180 * 0.5;\n    if (angle < -minMaxAngle) {\n      Quaternion.RotationAxisToRef(up, -angle - minMaxAngle, rotationQuat);\n      currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\n      angularClamped = true;\n    } else if (angle > minMaxAngle) {\n      Quaternion.RotationAxisToRef(up, -angle + minMaxAngle, rotationQuat);\n      currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\n      angularClamped = true;\n    }\n    return angularClamped;\n  }\n  _orientationClamp(currentToTarget, rotationQuaternion) {\n    var _a;\n    // Construct a rotation quat from up vector and target vector\n    const toFollowed = this._tmpVectors[0];\n    toFollowed.copyFrom(currentToTarget).scaleInPlace(-1).normalize();\n    const up = this._tmpVectors[1];\n    const right = this._tmpVectors[2];\n    // We use global up vector to orient the following node (global +Y)\n    up.copyFromFloats(0, 1, 0);\n    // Gram-Schmidt to create an orthonormal frame\n    Vector3.CrossToRef(toFollowed, up, right);\n    const length = right.length();\n    if (length < Epsilon) {\n      return;\n    }\n    right.normalizeFromLength(length);\n    Vector3.CrossToRef(right, toFollowed, up);\n    if ((_a = this.attachedNode) === null || _a === void 0 ? void 0 : _a.getScene().useRightHandedSystem) {\n      Quaternion.FromLookDirectionRHToRef(toFollowed, up, rotationQuaternion);\n    } else {\n      Quaternion.FromLookDirectionLHToRef(toFollowed, up, rotationQuaternion);\n    }\n  }\n  _passedOrientationDeadzone(currentToTarget, forward) {\n    const leashToFollow = this._tmpVectors[5];\n    leashToFollow.copyFrom(currentToTarget);\n    leashToFollow.normalize();\n    const angle = Math.abs(Vector3.GetAngleBetweenVectorsOnPlane(forward, leashToFollow, Vector3.UpReadOnly));\n    return angle * 180 / Math.PI > this.orientToCameraDeadzoneDegrees;\n  }\n  _updateLeashing(camera) {\n    if (this.attachedNode && this._enabled) {\n      const oldParent = this.attachedNode.parent;\n      this.attachedNode.setParent(null);\n      const worldMatrix = this.attachedNode.getWorldMatrix();\n      const currentToTarget = this._workingPosition;\n      const rotationQuaternion = this._workingQuaternion;\n      const pivot = this.attachedNode.getPivotPoint();\n      const invertView = this._tmpInvertView;\n      invertView.copyFrom(camera.getViewMatrix());\n      invertView.invert();\n      Vector3.TransformCoordinatesToRef(pivot, worldMatrix, currentToTarget);\n      const position = this._tmpPosition;\n      position.copyFromFloats(0, 0, 0);\n      Vector3.TransformCoordinatesToRef(position, worldMatrix, position);\n      position.scaleInPlace(-1).subtractInPlace(pivot);\n      currentToTarget.subtractInPlace(camera.globalPosition);\n      if (this.ignoreCameraPitchAndRoll) {\n        this._applyPitchOffset(invertView);\n      }\n      let angularClamped = false;\n      const forward = this._tmpForward;\n      forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n      Vector3.TransformNormalToRef(forward, invertView, forward);\n      const nodeForward = this._tmpNodeForward;\n      nodeForward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n      Vector3.TransformNormalToRef(nodeForward, worldMatrix, nodeForward);\n      if (this._recenterNextUpdate) {\n        currentToTarget.copyFrom(forward).scaleInPlace(this.defaultDistance);\n      } else {\n        if (this.ignoreAngleClamp) {\n          const currentDistance = currentToTarget.length();\n          currentToTarget.copyFrom(forward).scaleInPlace(currentDistance);\n        } else {\n          angularClamped = this._angularClamp(invertView, currentToTarget);\n        }\n      }\n      let distanceClamped = false;\n      if (!this.ignoreDistanceClamp) {\n        distanceClamped = this._distanceClamp(currentToTarget, angularClamped);\n        this._applyVerticalClamp(currentToTarget);\n      }\n      if (this.useFixedVerticalOffset) {\n        currentToTarget.y = position.y - camera.globalPosition.y + this.fixedVerticalOffset;\n      }\n      if (angularClamped || distanceClamped || this._passedOrientationDeadzone(currentToTarget, nodeForward) || this._recenterNextUpdate) {\n        this._orientationClamp(currentToTarget, rotationQuaternion);\n      }\n      this._workingPosition.subtractInPlace(pivot);\n      this._recenterNextUpdate = false;\n      this.attachedNode.setParent(oldParent);\n    }\n  }\n  _updateTransformToGoal(elapsed) {\n    if (!this.attachedNode || !this.followedCamera || !this._enabled) {\n      return;\n    }\n    if (!this.attachedNode.rotationQuaternion) {\n      this.attachedNode.rotationQuaternion = Quaternion.Identity();\n    }\n    const oldParent = this.attachedNode.parent;\n    this.attachedNode.setParent(null);\n    if (!this.interpolatePose) {\n      this.attachedNode.position.copyFrom(this.followedCamera.globalPosition).addInPlace(this._workingPosition);\n      this.attachedNode.rotationQuaternion.copyFrom(this._workingQuaternion);\n      return;\n    }\n    // position\n    const currentDirection = new Vector3();\n    currentDirection.copyFrom(this.attachedNode.position).subtractInPlace(this.followedCamera.globalPosition);\n    Vector3.SmoothToRef(currentDirection, this._workingPosition, elapsed, this.lerpTime, currentDirection);\n    currentDirection.addInPlace(this.followedCamera.globalPosition);\n    this.attachedNode.position.copyFrom(currentDirection);\n    // rotation\n    const currentRotation = new Quaternion();\n    currentRotation.copyFrom(this.attachedNode.rotationQuaternion);\n    Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this.attachedNode.rotationQuaternion);\n    this.attachedNode.setParent(oldParent);\n  }\n  _addObservables() {\n    this._lastTick = Date.now();\n    this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {\n      if (!this.followedCamera) {\n        return;\n      }\n      const tick = Date.now();\n      this._updateLeashing(this.followedCamera);\n      this._updateTransformToGoal(tick - this._lastTick);\n      this._lastTick = tick;\n    });\n  }\n  _removeObservables() {\n    if (this._onBeforeRender) {\n      this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);\n    }\n  }\n}","map":{"version":3,"names":["Matrix","Quaternion","Vector3","Scalar","Epsilon","FollowBehavior","constructor","_tmpQuaternion","_tmpVectors","_tmpMatrix","_tmpInvertView","_tmpForward","_tmpNodeForward","_tmpPosition","_workingPosition","_workingQuaternion","_lastTick","_recenterNextUpdate","interpolatePose","lerpTime","ignoreCameraPitchAndRoll","pitchOffset","maxViewVerticalDegrees","maxViewHorizontalDegrees","orientToCameraDeadzoneDegrees","ignoreDistanceClamp","ignoreAngleClamp","verticalMaxDistance","defaultDistance","maximumDistance","minimumDistance","useFixedVerticalOffset","fixedVerticalOffset","_enabled","followedCamera","_followedCamera","_scene","activeCamera","camera","name","init","attach","ownerNode","getScene","attachedNode","_addObservables","detach","_removeObservables","recenter","_angleBetweenVectorAndPlane","vector","normal","copyFrom","normalize","Math","PI","acos","Dot","_length2D","sqrt","x","z","_distanceClamp","currentToTarget","moveToDefault","minDistance","maxDistance","direction","currentDistance","length","normalizeFromLength","currentDistance2D","scaleInPlace","clampedDistance","Clamp","_applyVerticalClamp","y","_toOrientationQuatToRef","quaternion","RotationYawPitchRollToRef","atan2","_applyPitchOffset","invertView","forward","right","copyFromFloats","useRightHandedSystem","TransformNormalToRef","RotationAxisToRef","rotateByQuaternionToRef","toRotationMatrix","_angularClamp","up","UpReadOnly","dist","angularClamped","rotationQuat","angle","GetAngleBetweenVectorsOnPlane","minMaxAngle","_orientationClamp","rotationQuaternion","toFollowed","CrossToRef","_a","FromLookDirectionRHToRef","FromLookDirectionLHToRef","_passedOrientationDeadzone","leashToFollow","abs","_updateLeashing","oldParent","parent","setParent","worldMatrix","getWorldMatrix","pivot","getPivotPoint","getViewMatrix","invert","TransformCoordinatesToRef","position","subtractInPlace","globalPosition","nodeForward","distanceClamped","_updateTransformToGoal","elapsed","Identity","addInPlace","currentDirection","SmoothToRef","currentRotation","Date","now","_onBeforeRender","onBeforeRenderObservable","add","tick","remove"],"sources":["../../../../../dev/core/src/Behaviors/Meshes/followBehavior.ts"],"sourcesContent":["import type { Behavior } from \"../behavior\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport { Matrix, Quaternion, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\n\r\n/**\r\n * A behavior that when attached to a mesh will follow a camera\r\n * @since 5.0.0\r\n */\r\nexport class FollowBehavior implements Behavior<TransformNode> {\r\n    private _scene: Scene;\r\n\r\n    // Memory cache to avoid GC usage\r\n    private _tmpQuaternion: Quaternion = new Quaternion();\r\n    private _tmpVectors: Vector3[] = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];\r\n    private _tmpMatrix: Matrix = new Matrix();\r\n    private _tmpInvertView: Matrix = new Matrix();\r\n    private _tmpForward: Vector3 = new Vector3();\r\n    private _tmpNodeForward: Vector3 = new Vector3();\r\n    private _tmpPosition: Vector3 = new Vector3();\r\n\r\n    private _followedCamera: Nullable<Camera>;\r\n    private _onBeforeRender: Nullable<Observer<Scene>>;\r\n\r\n    private _workingPosition: Vector3 = new Vector3();\r\n    private _workingQuaternion: Quaternion = new Quaternion();\r\n    private _lastTick: number = -1;\r\n    private _recenterNextUpdate = true;\r\n\r\n    /**\r\n     * Attached node of this behavior\r\n     */\r\n    public attachedNode: Nullable<TransformNode>;\r\n\r\n    /**\r\n     * Set to false if the node should strictly follow the camera without any interpolation time\r\n     */\r\n    public interpolatePose = true;\r\n\r\n    /**\r\n     * Rate of interpolation of position and rotation of the attached node.\r\n     * Higher values will give a slower interpolation.\r\n     */\r\n    public lerpTime = 500;\r\n\r\n    /**\r\n     * If the behavior should ignore the pitch and roll of the camera.\r\n     */\r\n    public ignoreCameraPitchAndRoll = false;\r\n\r\n    /**\r\n     * Pitch offset from camera (relative to Max Distance)\r\n     * Is only effective if `ignoreCameraPitchAndRoll` is set to `true`.\r\n     */\r\n    public pitchOffset = 15;\r\n\r\n    /**\r\n     * The vertical angle from the camera forward axis to the owner will not exceed this value\r\n     */\r\n    public maxViewVerticalDegrees = 30;\r\n\r\n    /**\r\n     * The horizontal angle from the camera forward axis to the owner will not exceed this value\r\n     */\r\n    public maxViewHorizontalDegrees = 30;\r\n    /**\r\n     * The attached node will not reorient until the angle between its forward vector and the vector to the camera is greater than this value\r\n     */\r\n    public orientToCameraDeadzoneDegrees = 60;\r\n    /**\r\n     * Option to ignore distance clamping\r\n     */\r\n    public ignoreDistanceClamp = false;\r\n    /**\r\n     * Option to ignore angle clamping\r\n     */\r\n    public ignoreAngleClamp = false;\r\n    /**\r\n     * Max vertical distance between the attachedNode and camera\r\n     */\r\n    public verticalMaxDistance = 0;\r\n    /**\r\n     *  Default distance from eye to attached node, i.e. the sphere radius\r\n     */\r\n    public defaultDistance = 0.8;\r\n    /**\r\n     *  Max distance from eye to attached node, i.e. the sphere radius\r\n     */\r\n    public maximumDistance = 2;\r\n    /**\r\n     *  Min distance from eye to attached node, i.e. the sphere radius\r\n     */\r\n    public minimumDistance = 0.3;\r\n\r\n    /**\r\n     * Ignore vertical movement and lock the Y position of the object.\r\n     */\r\n    public useFixedVerticalOffset = false;\r\n\r\n    /**\r\n     * Fixed vertical position offset distance.\r\n     */\r\n    public fixedVerticalOffset = 0;\r\n\r\n    /**\r\n     * Enables/disables the behavior\r\n     * @internal\r\n     */\r\n    public _enabled = true;\r\n\r\n    /**\r\n     * The camera that should be followed by this behavior\r\n     */\r\n    public get followedCamera(): Nullable<Camera> {\r\n        return this._followedCamera || this._scene.activeCamera;\r\n    }\r\n\r\n    public set followedCamera(camera: Nullable<Camera>) {\r\n        this._followedCamera = camera;\r\n    }\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"Follow\";\r\n    }\r\n\r\n    /**\r\n     *  Initializes the behavior\r\n     */\r\n    public init() {}\r\n\r\n    /**\r\n     * Attaches the follow behavior\r\n     * @param ownerNode The mesh that will be following once attached\r\n     * @param followedCamera The camera that should be followed by the node\r\n     */\r\n    public attach(ownerNode: TransformNode, followedCamera?: Camera): void {\r\n        this._scene = ownerNode.getScene();\r\n        this.attachedNode = ownerNode;\r\n\r\n        if (followedCamera) {\r\n            this.followedCamera = followedCamera;\r\n        }\r\n\r\n        this._addObservables();\r\n    }\r\n\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    public detach(): void {\r\n        this.attachedNode = null;\r\n        this._removeObservables();\r\n    }\r\n\r\n    /**\r\n     * Recenters the attached node in front of the camera on the next update\r\n     */\r\n    public recenter() {\r\n        this._recenterNextUpdate = true;\r\n    }\r\n\r\n    private _angleBetweenVectorAndPlane(vector: Vector3, normal: Vector3) {\r\n        // Work on copies\r\n        this._tmpVectors[0].copyFrom(vector);\r\n        vector = this._tmpVectors[0];\r\n        this._tmpVectors[1].copyFrom(normal);\r\n        normal = this._tmpVectors[1];\r\n\r\n        vector.normalize();\r\n        normal.normalize();\r\n\r\n        return Math.PI / 2 - Math.acos(Vector3.Dot(vector, normal));\r\n    }\r\n\r\n    private _length2D(vector: Vector3) {\r\n        return Math.sqrt(vector.x * vector.x + vector.z * vector.z);\r\n    }\r\n\r\n    private _distanceClamp(currentToTarget: Vector3, moveToDefault: boolean = false) {\r\n        let minDistance = this.minimumDistance;\r\n        let maxDistance = this.maximumDistance;\r\n        const defaultDistance = this.defaultDistance;\r\n\r\n        const direction = this._tmpVectors[0];\r\n        direction.copyFrom(currentToTarget);\r\n        let currentDistance = direction.length();\r\n        direction.normalizeFromLength(currentDistance);\r\n\r\n        if (this.ignoreCameraPitchAndRoll) {\r\n            // If we don't account for pitch offset, the casted object will float up/down as the reference\r\n            // gets closer to it because we will still be casting in the direction of the pitched offset.\r\n            // To fix this, only modify the XZ position of the object.\r\n            minDistance = this._length2D(direction) * minDistance;\r\n            maxDistance = this._length2D(direction) * maxDistance;\r\n\r\n            const currentDistance2D = this._length2D(currentToTarget);\r\n            direction.scaleInPlace(currentDistance / currentDistance2D);\r\n            currentDistance = currentDistance2D;\r\n        }\r\n\r\n        let clampedDistance = currentDistance;\r\n\r\n        if (moveToDefault) {\r\n            clampedDistance = defaultDistance;\r\n        } else {\r\n            clampedDistance = Scalar.Clamp(currentDistance, minDistance, maxDistance);\r\n        }\r\n\r\n        currentToTarget.copyFrom(direction).scaleInPlace(clampedDistance);\r\n\r\n        return currentDistance !== clampedDistance;\r\n    }\r\n\r\n    private _applyVerticalClamp(currentToTarget: Vector3) {\r\n        if (this.verticalMaxDistance !== 0) {\r\n            currentToTarget.y = Scalar.Clamp(currentToTarget.y, -this.verticalMaxDistance, this.verticalMaxDistance);\r\n        }\r\n    }\r\n\r\n    private _toOrientationQuatToRef(vector: Vector3, quaternion: Quaternion) {\r\n        Quaternion.RotationYawPitchRollToRef(Math.atan2(vector.x, vector.z), Math.atan2(vector.y, Math.sqrt(vector.z * vector.z + vector.x * vector.x)), 0, quaternion);\r\n    }\r\n\r\n    private _applyPitchOffset(invertView: Matrix) {\r\n        const forward = this._tmpVectors[0];\r\n        const right = this._tmpVectors[1];\r\n        forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n        right.copyFromFloats(1, 0, 0);\r\n        Vector3.TransformNormalToRef(forward, invertView, forward);\r\n        forward.y = 0;\r\n        forward.normalize();\r\n        Vector3.TransformNormalToRef(right, invertView, right);\r\n\r\n        Quaternion.RotationAxisToRef(right, (this.pitchOffset * Math.PI) / 180, this._tmpQuaternion);\r\n        forward.rotateByQuaternionToRef(this._tmpQuaternion, forward);\r\n        this._toOrientationQuatToRef(forward, this._tmpQuaternion);\r\n        this._tmpQuaternion.toRotationMatrix(this._tmpMatrix);\r\n\r\n        // Since we already extracted position from the invert view matrix, we can\r\n        // disregard the position part of the matrix in the copy\r\n        invertView.copyFrom(this._tmpMatrix);\r\n    }\r\n\r\n    private _angularClamp(invertView: Matrix, currentToTarget: Vector3): boolean {\r\n        const forward = this._tmpVectors[5];\r\n        forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n        const right = this._tmpVectors[6];\r\n        right.copyFromFloats(1, 0, 0);\r\n\r\n        // forward and right are related to camera frame of reference\r\n        Vector3.TransformNormalToRef(forward, invertView, forward);\r\n        Vector3.TransformNormalToRef(right, invertView, right);\r\n\r\n        // Up is global Z\r\n        const up = Vector3.UpReadOnly;\r\n\r\n        const dist = currentToTarget.length();\r\n\r\n        if (dist < Epsilon) {\r\n            return false;\r\n        }\r\n\r\n        let angularClamped = false;\r\n        const rotationQuat = this._tmpQuaternion;\r\n\r\n        // X-axis leashing\r\n        if (this.ignoreCameraPitchAndRoll) {\r\n            const angle = Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);\r\n            Quaternion.RotationAxisToRef(right, angle, rotationQuat);\r\n            currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\r\n        } else {\r\n            const angle = -Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);\r\n            const minMaxAngle = ((this.maxViewVerticalDegrees * Math.PI) / 180) * 0.5;\r\n            if (angle < -minMaxAngle) {\r\n                Quaternion.RotationAxisToRef(right, -angle - minMaxAngle, rotationQuat);\r\n                currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\r\n                angularClamped = true;\r\n            } else if (angle > minMaxAngle) {\r\n                Quaternion.RotationAxisToRef(right, -angle + minMaxAngle, rotationQuat);\r\n                currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\r\n                angularClamped = true;\r\n            }\r\n        }\r\n\r\n        // Y-axis leashing\r\n        const angle = this._angleBetweenVectorAndPlane(currentToTarget, right) * (this._scene.useRightHandedSystem ? -1 : 1);\r\n        const minMaxAngle = ((this.maxViewHorizontalDegrees * Math.PI) / 180) * 0.5;\r\n        if (angle < -minMaxAngle) {\r\n            Quaternion.RotationAxisToRef(up, -angle - minMaxAngle, rotationQuat);\r\n            currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\r\n            angularClamped = true;\r\n        } else if (angle > minMaxAngle) {\r\n            Quaternion.RotationAxisToRef(up, -angle + minMaxAngle, rotationQuat);\r\n            currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\r\n            angularClamped = true;\r\n        }\r\n\r\n        return angularClamped;\r\n    }\r\n\r\n    private _orientationClamp(currentToTarget: Vector3, rotationQuaternion: Quaternion) {\r\n        // Construct a rotation quat from up vector and target vector\r\n        const toFollowed = this._tmpVectors[0];\r\n        toFollowed.copyFrom(currentToTarget).scaleInPlace(-1).normalize();\r\n\r\n        const up = this._tmpVectors[1];\r\n        const right = this._tmpVectors[2];\r\n        // We use global up vector to orient the following node (global +Y)\r\n        up.copyFromFloats(0, 1, 0);\r\n\r\n        // Gram-Schmidt to create an orthonormal frame\r\n        Vector3.CrossToRef(toFollowed, up, right);\r\n        const length = right.length();\r\n\r\n        if (length < Epsilon) {\r\n            return;\r\n        }\r\n\r\n        right.normalizeFromLength(length);\r\n\r\n        Vector3.CrossToRef(right, toFollowed, up);\r\n        if (this.attachedNode?.getScene().useRightHandedSystem) {\r\n            Quaternion.FromLookDirectionRHToRef(toFollowed, up, rotationQuaternion);\r\n        } else {\r\n            Quaternion.FromLookDirectionLHToRef(toFollowed, up, rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    private _passedOrientationDeadzone(currentToTarget: Vector3, forward: Vector3) {\r\n        const leashToFollow = this._tmpVectors[5];\r\n        leashToFollow.copyFrom(currentToTarget);\r\n        leashToFollow.normalize();\r\n\r\n        const angle = Math.abs(Vector3.GetAngleBetweenVectorsOnPlane(forward, leashToFollow, Vector3.UpReadOnly));\r\n        return (angle * 180) / Math.PI > this.orientToCameraDeadzoneDegrees;\r\n    }\r\n\r\n    private _updateLeashing(camera: Camera) {\r\n        if (this.attachedNode && this._enabled) {\r\n            const oldParent = this.attachedNode.parent;\r\n            this.attachedNode.setParent(null);\r\n\r\n            const worldMatrix = this.attachedNode.getWorldMatrix();\r\n            const currentToTarget = this._workingPosition;\r\n            const rotationQuaternion = this._workingQuaternion;\r\n            const pivot = this.attachedNode.getPivotPoint();\r\n            const invertView = this._tmpInvertView;\r\n            invertView.copyFrom(camera.getViewMatrix());\r\n            invertView.invert();\r\n\r\n            Vector3.TransformCoordinatesToRef(pivot, worldMatrix, currentToTarget);\r\n            const position = this._tmpPosition;\r\n            position.copyFromFloats(0, 0, 0);\r\n            Vector3.TransformCoordinatesToRef(position, worldMatrix, position);\r\n            position.scaleInPlace(-1).subtractInPlace(pivot);\r\n            currentToTarget.subtractInPlace(camera.globalPosition);\r\n\r\n            if (this.ignoreCameraPitchAndRoll) {\r\n                this._applyPitchOffset(invertView);\r\n            }\r\n\r\n            let angularClamped = false;\r\n            const forward = this._tmpForward;\r\n            forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n            Vector3.TransformNormalToRef(forward, invertView, forward);\r\n\r\n            const nodeForward = this._tmpNodeForward;\r\n            nodeForward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n            Vector3.TransformNormalToRef(nodeForward, worldMatrix, nodeForward);\r\n\r\n            if (this._recenterNextUpdate) {\r\n                currentToTarget.copyFrom(forward).scaleInPlace(this.defaultDistance);\r\n            } else {\r\n                if (this.ignoreAngleClamp) {\r\n                    const currentDistance = currentToTarget.length();\r\n                    currentToTarget.copyFrom(forward).scaleInPlace(currentDistance);\r\n                } else {\r\n                    angularClamped = this._angularClamp(invertView, currentToTarget);\r\n                }\r\n            }\r\n\r\n            let distanceClamped = false;\r\n            if (!this.ignoreDistanceClamp) {\r\n                distanceClamped = this._distanceClamp(currentToTarget, angularClamped);\r\n                this._applyVerticalClamp(currentToTarget);\r\n            }\r\n\r\n            if (this.useFixedVerticalOffset) {\r\n                currentToTarget.y = position.y - camera.globalPosition.y + this.fixedVerticalOffset;\r\n            }\r\n\r\n            if (angularClamped || distanceClamped || this._passedOrientationDeadzone(currentToTarget, nodeForward) || this._recenterNextUpdate) {\r\n                this._orientationClamp(currentToTarget, rotationQuaternion);\r\n            }\r\n\r\n            this._workingPosition.subtractInPlace(pivot);\r\n            this._recenterNextUpdate = false;\r\n\r\n            this.attachedNode.setParent(oldParent);\r\n        }\r\n    }\r\n\r\n    private _updateTransformToGoal(elapsed: number) {\r\n        if (!this.attachedNode || !this.followedCamera || !this._enabled) {\r\n            return;\r\n        }\r\n\r\n        if (!this.attachedNode.rotationQuaternion) {\r\n            this.attachedNode.rotationQuaternion = Quaternion.Identity();\r\n        }\r\n\r\n        const oldParent = this.attachedNode.parent;\r\n        this.attachedNode.setParent(null);\r\n\r\n        if (!this.interpolatePose) {\r\n            this.attachedNode.position.copyFrom(this.followedCamera.globalPosition).addInPlace(this._workingPosition);\r\n            this.attachedNode.rotationQuaternion.copyFrom(this._workingQuaternion);\r\n            return;\r\n        }\r\n\r\n        // position\r\n        const currentDirection = new Vector3();\r\n        currentDirection.copyFrom(this.attachedNode.position).subtractInPlace(this.followedCamera.globalPosition);\r\n        Vector3.SmoothToRef(currentDirection, this._workingPosition, elapsed, this.lerpTime, currentDirection);\r\n        currentDirection.addInPlace(this.followedCamera.globalPosition);\r\n        this.attachedNode.position.copyFrom(currentDirection);\r\n\r\n        // rotation\r\n        const currentRotation = new Quaternion();\r\n        currentRotation.copyFrom(this.attachedNode.rotationQuaternion);\r\n        Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this.attachedNode.rotationQuaternion);\r\n\r\n        this.attachedNode.setParent(oldParent);\r\n    }\r\n\r\n    private _addObservables() {\r\n        this._lastTick = Date.now();\r\n        this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {\r\n            if (!this.followedCamera) {\r\n                return;\r\n            }\r\n\r\n            const tick = Date.now();\r\n            this._updateLeashing(this.followedCamera);\r\n            this._updateTransformToGoal(tick - this._lastTick);\r\n            this._lastTick = tick;\r\n        });\r\n    }\r\n\r\n    private _removeObservables() {\r\n        if (this._onBeforeRender) {\r\n            this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}