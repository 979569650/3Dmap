{"ast":null,"code":"import { Observable } from \"../Misc/observable.js\";\nimport { PointerEventTypes } from \"../Events/pointerEvents.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { SixDofDragBehavior } from \"../Behaviors/Meshes/sixDofDragBehavior.js\";\nimport { Gizmo, GizmoCoordinatesMode } from \"./gizmo.js\";\nimport { RotationGizmo } from \"./rotationGizmo.js\";\nimport { PositionGizmo } from \"./positionGizmo.js\";\nimport { ScaleGizmo } from \"./scaleGizmo.js\";\nimport { BoundingBoxGizmo } from \"./boundingBoxGizmo.js\";\n/**\n * Helps setup gizmo's in the scene to rotate/scale/position nodes\n */\nexport class GizmoManager {\n  /**\n   * Utility layer that the bounding box gizmo belongs to\n   */\n  get keepDepthUtilityLayer() {\n    return this._defaultKeepDepthUtilityLayer;\n  }\n  /**\n   * Utility layer that all gizmos besides bounding box belong to\n   */\n  get utilityLayer() {\n    return this._defaultUtilityLayer;\n  }\n  /**\n   * True when the mouse pointer is hovering a gizmo mesh\n   */\n  get isHovered() {\n    let hovered = false;\n    for (const key in this.gizmos) {\n      const gizmo = this.gizmos[key];\n      if (gizmo && gizmo.isHovered) {\n        hovered = true;\n        break;\n      }\n    }\n    return hovered;\n  }\n  /**\n   * Ratio for the scale of the gizmo (Default: 1)\n   */\n  set scaleRatio(value) {\n    this._scaleRatio = value;\n    [this.gizmos.positionGizmo, this.gizmos.rotationGizmo, this.gizmos.scaleGizmo].forEach(gizmo => {\n      if (gizmo) {\n        gizmo.scaleRatio = value;\n      }\n    });\n  }\n  get scaleRatio() {\n    return this._scaleRatio;\n  }\n  /**\n   * Set the coordinate system to use. By default it's local.\n   * But it's possible for a user to tweak so its local for translation and world for rotation.\n   * In that case, setting the coordinate system will change `updateGizmoRotationToMatchAttachedMesh` and `updateGizmoPositionToMatchAttachedMesh`\n   */\n  set coordinatesMode(coordinatesMode) {\n    this._coordinatesMode = coordinatesMode;\n    [this.gizmos.positionGizmo, this.gizmos.rotationGizmo, this.gizmos.scaleGizmo].forEach(gizmo => {\n      if (gizmo) {\n        gizmo.coordinatesMode = coordinatesMode;\n      }\n    });\n  }\n  get coordinatesMode() {\n    return this._coordinatesMode;\n  }\n  /**\n   * Instantiates a gizmo manager\n   * @param _scene the scene to overlay the gizmos on top of\n   * @param thickness display gizmo axis thickness\n   * @param utilityLayer the layer where gizmos are rendered\n   * @param keepDepthUtilityLayer the layer where occluded gizmos are rendered\n   */\n  constructor(_scene, thickness = 1, utilityLayer = UtilityLayerRenderer.DefaultUtilityLayer, keepDepthUtilityLayer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer) {\n    this._scene = _scene;\n    /** When true, the gizmo will be detached from the current object when a pointer down occurs with an empty picked mesh */\n    this.clearGizmoOnEmptyPointerEvent = false;\n    /** When true (default), picking to attach a new mesh is enabled. This works in sync with inspector autopicking. */\n    this.enableAutoPicking = true;\n    /** Fires an event when the manager is attached to a mesh */\n    this.onAttachedToMeshObservable = new Observable();\n    /** Fires an event when the manager is attached to a node */\n    this.onAttachedToNodeObservable = new Observable();\n    this._gizmosEnabled = {\n      positionGizmo: false,\n      rotationGizmo: false,\n      scaleGizmo: false,\n      boundingBoxGizmo: false\n    };\n    this._pointerObservers = [];\n    this._attachedMesh = null;\n    this._attachedNode = null;\n    this._boundingBoxColor = Color3.FromHexString(\"#0984e3\");\n    this._thickness = 1;\n    this._scaleRatio = 1;\n    this._coordinatesMode = GizmoCoordinatesMode.Local;\n    /** Node Caching for quick lookup */\n    this._gizmoAxisCache = new Map();\n    /**\n     * When bounding box gizmo is enabled, this can be used to track drag/end events\n     */\n    this.boundingBoxDragBehavior = new SixDofDragBehavior();\n    /**\n     * Array of meshes which will have the gizmo attached when a pointer selected them. If null, all meshes are attachable. (Default: null)\n     */\n    this.attachableMeshes = null;\n    /**\n     * Array of nodes which will have the gizmo attached when a pointer selected them. If null, all nodes are attachable. (Default: null)\n     */\n    this.attachableNodes = null;\n    /**\n     * If pointer events should perform attaching/detaching a gizmo, if false this can be done manually via attachToMesh/attachToNode. (Default: true)\n     */\n    this.usePointerToAttachGizmos = true;\n    this._defaultUtilityLayer = utilityLayer;\n    this._defaultKeepDepthUtilityLayer = keepDepthUtilityLayer;\n    this._defaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\n    this._thickness = thickness;\n    this.gizmos = {\n      positionGizmo: null,\n      rotationGizmo: null,\n      scaleGizmo: null,\n      boundingBoxGizmo: null\n    };\n    const attachToMeshPointerObserver = this._attachToMeshPointerObserver(_scene);\n    const gizmoAxisPointerObserver = Gizmo.GizmoAxisPointerObserver(this._defaultUtilityLayer, this._gizmoAxisCache);\n    this._pointerObservers = [attachToMeshPointerObserver, gizmoAxisPointerObserver];\n  }\n  /**\n   * Subscribes to pointer down events, for attaching and detaching mesh\n   * @param scene The scene layer the observer will be added to\n   */\n  _attachToMeshPointerObserver(scene) {\n    // Instantiate/dispose gizmos based on pointer actions\n    const pointerObserver = scene.onPointerObservable.add(pointerInfo => {\n      if (!this.usePointerToAttachGizmos) {\n        return;\n      }\n      if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {\n        if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh) {\n          if (this.enableAutoPicking) {\n            let node = pointerInfo.pickInfo.pickedMesh;\n            if (this.attachableMeshes == null) {\n              // Attach to the most parent node\n              while (node && node.parent != null) {\n                node = node.parent;\n              }\n            } else {\n              // Attach to the parent node that is an attachableMesh\n              let found = false;\n              this.attachableMeshes.forEach(mesh => {\n                if (node && (node == mesh || node.isDescendantOf(mesh))) {\n                  node = mesh;\n                  found = true;\n                }\n              });\n              if (!found) {\n                node = null;\n              }\n            }\n            if (node instanceof AbstractMesh) {\n              if (this._attachedMesh != node) {\n                this.attachToMesh(node);\n              }\n            } else {\n              if (this.clearGizmoOnEmptyPointerEvent) {\n                this.attachToMesh(null);\n              }\n            }\n          }\n        } else {\n          if (this.clearGizmoOnEmptyPointerEvent) {\n            this.attachToMesh(null);\n          }\n        }\n      }\n    });\n    return pointerObserver;\n  }\n  /**\n   * Attaches a set of gizmos to the specified mesh\n   * @param mesh The mesh the gizmo's should be attached to\n   */\n  attachToMesh(mesh) {\n    if (this._attachedMesh) {\n      this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n    }\n    if (this._attachedNode) {\n      this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n    }\n    this._attachedMesh = mesh;\n    this._attachedNode = null;\n    for (const key in this.gizmos) {\n      const gizmo = this.gizmos[key];\n      if (gizmo && this._gizmosEnabled[key]) {\n        gizmo.attachedMesh = mesh;\n      }\n    }\n    if (this.boundingBoxGizmoEnabled && this._attachedMesh) {\n      this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);\n    }\n    this.onAttachedToMeshObservable.notifyObservers(mesh);\n  }\n  /**\n   * Attaches a set of gizmos to the specified node\n   * @param node The node the gizmo's should be attached to\n   */\n  attachToNode(node) {\n    if (this._attachedMesh) {\n      this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n    }\n    if (this._attachedNode) {\n      this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n    }\n    this._attachedMesh = null;\n    this._attachedNode = node;\n    for (const key in this.gizmos) {\n      const gizmo = this.gizmos[key];\n      if (gizmo && this._gizmosEnabled[key]) {\n        gizmo.attachedNode = node;\n      }\n    }\n    if (this.boundingBoxGizmoEnabled && this._attachedNode) {\n      this._attachedNode.addBehavior(this.boundingBoxDragBehavior);\n    }\n    this.onAttachedToNodeObservable.notifyObservers(node);\n  }\n  /**\n   * If the position gizmo is enabled\n   */\n  set positionGizmoEnabled(value) {\n    if (value) {\n      if (!this.gizmos.positionGizmo) {\n        this.gizmos.positionGizmo = new PositionGizmo(this._defaultUtilityLayer, this._thickness, this);\n      }\n      if (this._attachedNode) {\n        this.gizmos.positionGizmo.attachedNode = this._attachedNode;\n      } else {\n        this.gizmos.positionGizmo.attachedMesh = this._attachedMesh;\n      }\n    } else if (this.gizmos.positionGizmo) {\n      this.gizmos.positionGizmo.attachedNode = null;\n    }\n    this._gizmosEnabled.positionGizmo = value;\n  }\n  get positionGizmoEnabled() {\n    return this._gizmosEnabled.positionGizmo;\n  }\n  /**\n   * If the rotation gizmo is enabled\n   */\n  set rotationGizmoEnabled(value) {\n    if (value) {\n      if (!this.gizmos.rotationGizmo) {\n        this.gizmos.rotationGizmo = new RotationGizmo(this._defaultUtilityLayer, 32, false, this._thickness, this);\n      }\n      if (this._attachedNode) {\n        this.gizmos.rotationGizmo.attachedNode = this._attachedNode;\n      } else {\n        this.gizmos.rotationGizmo.attachedMesh = this._attachedMesh;\n      }\n    } else if (this.gizmos.rotationGizmo) {\n      this.gizmos.rotationGizmo.attachedNode = null;\n    }\n    this._gizmosEnabled.rotationGizmo = value;\n  }\n  get rotationGizmoEnabled() {\n    return this._gizmosEnabled.rotationGizmo;\n  }\n  /**\n   * If the scale gizmo is enabled\n   */\n  set scaleGizmoEnabled(value) {\n    if (value) {\n      this.gizmos.scaleGizmo = this.gizmos.scaleGizmo || new ScaleGizmo(this._defaultUtilityLayer, this._thickness, this);\n      if (this._attachedNode) {\n        this.gizmos.scaleGizmo.attachedNode = this._attachedNode;\n      } else {\n        this.gizmos.scaleGizmo.attachedMesh = this._attachedMesh;\n      }\n    } else if (this.gizmos.scaleGizmo) {\n      this.gizmos.scaleGizmo.attachedNode = null;\n    }\n    this._gizmosEnabled.scaleGizmo = value;\n  }\n  get scaleGizmoEnabled() {\n    return this._gizmosEnabled.scaleGizmo;\n  }\n  /**\n   * If the boundingBox gizmo is enabled\n   */\n  set boundingBoxGizmoEnabled(value) {\n    if (value) {\n      this.gizmos.boundingBoxGizmo = this.gizmos.boundingBoxGizmo || new BoundingBoxGizmo(this._boundingBoxColor, this._defaultKeepDepthUtilityLayer);\n      if (this._attachedMesh) {\n        this.gizmos.boundingBoxGizmo.attachedMesh = this._attachedMesh;\n      } else {\n        this.gizmos.boundingBoxGizmo.attachedNode = this._attachedNode;\n      }\n      if (this._attachedMesh) {\n        this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n        this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);\n      } else if (this._attachedNode) {\n        this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n        this._attachedNode.addBehavior(this.boundingBoxDragBehavior);\n      }\n    } else if (this.gizmos.boundingBoxGizmo) {\n      if (this._attachedMesh) {\n        this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n      } else if (this._attachedNode) {\n        this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n      }\n      this.gizmos.boundingBoxGizmo.attachedNode = null;\n    }\n    this._gizmosEnabled.boundingBoxGizmo = value;\n  }\n  get boundingBoxGizmoEnabled() {\n    return this._gizmosEnabled.boundingBoxGizmo;\n  }\n  /**\n   * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\n   * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\n   */\n  addToAxisCache(gizmoAxisCache) {\n    if (gizmoAxisCache.size > 0) {\n      gizmoAxisCache.forEach((v, k) => {\n        this._gizmoAxisCache.set(k, v);\n      });\n    }\n  }\n  /**\n   * Disposes of the gizmo manager\n   */\n  dispose() {\n    var _a, _b;\n    this._pointerObservers.forEach(observer => {\n      this._scene.onPointerObservable.remove(observer);\n    });\n    for (const key in this.gizmos) {\n      const gizmo = this.gizmos[key];\n      if (gizmo) {\n        gizmo.dispose();\n      }\n    }\n    if (this._defaultKeepDepthUtilityLayer !== UtilityLayerRenderer._DefaultKeepDepthUtilityLayer) {\n      (_a = this._defaultKeepDepthUtilityLayer) === null || _a === void 0 ? void 0 : _a.dispose();\n    }\n    if (this._defaultUtilityLayer !== UtilityLayerRenderer._DefaultUtilityLayer) {\n      (_b = this._defaultUtilityLayer) === null || _b === void 0 ? void 0 : _b.dispose();\n    }\n    this.boundingBoxDragBehavior.detach();\n    this.onAttachedToMeshObservable.clear();\n  }\n}","map":{"version":3,"names":["Observable","PointerEventTypes","AbstractMesh","UtilityLayerRenderer","Color3","SixDofDragBehavior","Gizmo","GizmoCoordinatesMode","RotationGizmo","PositionGizmo","ScaleGizmo","BoundingBoxGizmo","GizmoManager","keepDepthUtilityLayer","_defaultKeepDepthUtilityLayer","utilityLayer","_defaultUtilityLayer","isHovered","hovered","key","gizmos","gizmo","scaleRatio","value","_scaleRatio","positionGizmo","rotationGizmo","scaleGizmo","forEach","coordinatesMode","_coordinatesMode","constructor","_scene","thickness","DefaultUtilityLayer","DefaultKeepDepthUtilityLayer","clearGizmoOnEmptyPointerEvent","enableAutoPicking","onAttachedToMeshObservable","onAttachedToNodeObservable","_gizmosEnabled","boundingBoxGizmo","_pointerObservers","_attachedMesh","_attachedNode","_boundingBoxColor","FromHexString","_thickness","Local","_gizmoAxisCache","Map","boundingBoxDragBehavior","attachableMeshes","attachableNodes","usePointerToAttachGizmos","utilityLayerScene","autoClearDepthAndStencil","attachToMeshPointerObserver","_attachToMeshPointerObserver","gizmoAxisPointerObserver","GizmoAxisPointerObserver","scene","pointerObserver","onPointerObservable","add","pointerInfo","type","POINTERDOWN","pickInfo","pickedMesh","node","parent","found","mesh","isDescendantOf","attachToMesh","removeBehavior","attachedMesh","boundingBoxGizmoEnabled","addBehavior","notifyObservers","attachToNode","attachedNode","positionGizmoEnabled","rotationGizmoEnabled","scaleGizmoEnabled","addToAxisCache","gizmoAxisCache","size","v","k","set","dispose","observer","remove","_DefaultKeepDepthUtilityLayer","_a","_DefaultUtilityLayer","_b","detach","clear"],"sources":["../../../../dev/core/src/Gizmos/gizmoManager.ts"],"sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport type { Node } from \"../node\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { SixDofDragBehavior } from \"../Behaviors/Meshes/sixDofDragBehavior\";\r\nimport type { GizmoAxisCache, IGizmo } from \"./gizmo\";\r\nimport { Gizmo, GizmoCoordinatesMode } from \"./gizmo\";\r\nimport type { IRotationGizmo } from \"./rotationGizmo\";\r\nimport { RotationGizmo } from \"./rotationGizmo\";\r\nimport type { IPositionGizmo } from \"./positionGizmo\";\r\nimport { PositionGizmo } from \"./positionGizmo\";\r\nimport type { IScaleGizmo } from \"./scaleGizmo\";\r\nimport { ScaleGizmo } from \"./scaleGizmo\";\r\nimport type { IBoundingBoxGizmo } from \"./boundingBoxGizmo\";\r\nimport { BoundingBoxGizmo } from \"./boundingBoxGizmo\";\r\n\r\n/**\r\n * Helps setup gizmo's in the scene to rotate/scale/position nodes\r\n */\r\nexport class GizmoManager implements IDisposable {\r\n    /**\r\n     * Gizmo's created by the gizmo manager, gizmo will be null until gizmo has been enabled for the first time\r\n     */\r\n    public gizmos: {\r\n        positionGizmo: Nullable<IPositionGizmo>;\r\n        rotationGizmo: Nullable<IRotationGizmo>;\r\n        scaleGizmo: Nullable<IScaleGizmo>;\r\n        boundingBoxGizmo: Nullable<IBoundingBoxGizmo>;\r\n    };\r\n\r\n    /** When true, the gizmo will be detached from the current object when a pointer down occurs with an empty picked mesh */\r\n    public clearGizmoOnEmptyPointerEvent = false;\r\n\r\n    /** When true (default), picking to attach a new mesh is enabled. This works in sync with inspector autopicking. */\r\n    public enableAutoPicking = true;\r\n\r\n    /** Fires an event when the manager is attached to a mesh */\r\n    public onAttachedToMeshObservable = new Observable<Nullable<AbstractMesh>>();\r\n\r\n    /** Fires an event when the manager is attached to a node */\r\n    public onAttachedToNodeObservable = new Observable<Nullable<Node>>();\r\n\r\n    protected _gizmosEnabled = { positionGizmo: false, rotationGizmo: false, scaleGizmo: false, boundingBoxGizmo: false };\r\n    protected _pointerObservers: Observer<PointerInfo>[] = [];\r\n    protected _attachedMesh: Nullable<AbstractMesh> = null;\r\n    protected _attachedNode: Nullable<Node> = null;\r\n    protected _boundingBoxColor = Color3.FromHexString(\"#0984e3\");\r\n    protected _defaultUtilityLayer: UtilityLayerRenderer;\r\n    protected _defaultKeepDepthUtilityLayer: UtilityLayerRenderer;\r\n    protected _thickness: number = 1;\r\n    protected _scaleRatio: number = 1;\r\n    protected _coordinatesMode = GizmoCoordinatesMode.Local;\r\n\r\n    /** Node Caching for quick lookup */\r\n    private _gizmoAxisCache: Map<Mesh, GizmoAxisCache> = new Map();\r\n    /**\r\n     * When bounding box gizmo is enabled, this can be used to track drag/end events\r\n     */\r\n    public boundingBoxDragBehavior = new SixDofDragBehavior();\r\n    /**\r\n     * Array of meshes which will have the gizmo attached when a pointer selected them. If null, all meshes are attachable. (Default: null)\r\n     */\r\n    public attachableMeshes: Nullable<Array<AbstractMesh>> = null;\r\n    /**\r\n     * Array of nodes which will have the gizmo attached when a pointer selected them. If null, all nodes are attachable. (Default: null)\r\n     */\r\n    public attachableNodes: Nullable<Array<Node>> = null;\r\n    /**\r\n     * If pointer events should perform attaching/detaching a gizmo, if false this can be done manually via attachToMesh/attachToNode. (Default: true)\r\n     */\r\n    public usePointerToAttachGizmos = true;\r\n\r\n    /**\r\n     * Utility layer that the bounding box gizmo belongs to\r\n     */\r\n    public get keepDepthUtilityLayer() {\r\n        return this._defaultKeepDepthUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * Utility layer that all gizmos besides bounding box belong to\r\n     */\r\n    public get utilityLayer() {\r\n        return this._defaultUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * True when the mouse pointer is hovering a gizmo mesh\r\n     */\r\n    public get isHovered() {\r\n        let hovered = false;\r\n        for (const key in this.gizmos) {\r\n            const gizmo = <Nullable<IGizmo>>(<any>this.gizmos)[key];\r\n            if (gizmo && gizmo.isHovered) {\r\n                hovered = true;\r\n                break;\r\n            }\r\n        }\r\n        return hovered;\r\n    }\r\n\r\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\r\n    public set scaleRatio(value: number) {\r\n        this._scaleRatio = value;\r\n        [this.gizmos.positionGizmo, this.gizmos.rotationGizmo, this.gizmos.scaleGizmo].forEach((gizmo) => {\r\n            if (gizmo) {\r\n                gizmo.scaleRatio = value;\r\n            }\r\n        });\r\n    }\r\n    public get scaleRatio() {\r\n        return this._scaleRatio;\r\n    }\r\n\r\n    /**\r\n     * Set the coordinate system to use. By default it's local.\r\n     * But it's possible for a user to tweak so its local for translation and world for rotation.\r\n     * In that case, setting the coordinate system will change `updateGizmoRotationToMatchAttachedMesh` and `updateGizmoPositionToMatchAttachedMesh`\r\n     */\r\n    public set coordinatesMode(coordinatesMode: GizmoCoordinatesMode) {\r\n        this._coordinatesMode = coordinatesMode;\r\n        [this.gizmos.positionGizmo, this.gizmos.rotationGizmo, this.gizmos.scaleGizmo].forEach((gizmo) => {\r\n            if (gizmo) {\r\n                gizmo.coordinatesMode = coordinatesMode;\r\n            }\r\n        });\r\n    }\r\n\r\n    public get coordinatesMode(): GizmoCoordinatesMode {\r\n        return this._coordinatesMode;\r\n    }\r\n    /**\r\n     * Instantiates a gizmo manager\r\n     * @param _scene the scene to overlay the gizmos on top of\r\n     * @param thickness display gizmo axis thickness\r\n     * @param utilityLayer the layer where gizmos are rendered\r\n     * @param keepDepthUtilityLayer the layer where occluded gizmos are rendered\r\n     */\r\n    constructor(\r\n        private _scene: Scene,\r\n        thickness: number = 1,\r\n        utilityLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer,\r\n        keepDepthUtilityLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer\r\n    ) {\r\n        this._defaultUtilityLayer = utilityLayer;\r\n        this._defaultKeepDepthUtilityLayer = keepDepthUtilityLayer;\r\n        this._defaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\r\n        this._thickness = thickness;\r\n        this.gizmos = { positionGizmo: null, rotationGizmo: null, scaleGizmo: null, boundingBoxGizmo: null };\r\n\r\n        const attachToMeshPointerObserver = this._attachToMeshPointerObserver(_scene);\r\n        const gizmoAxisPointerObserver = Gizmo.GizmoAxisPointerObserver(this._defaultUtilityLayer, this._gizmoAxisCache);\r\n        this._pointerObservers = [attachToMeshPointerObserver, gizmoAxisPointerObserver];\r\n    }\r\n\r\n    /**\r\n     * Subscribes to pointer down events, for attaching and detaching mesh\r\n     * @param scene The scene layer the observer will be added to\r\n     */\r\n    private _attachToMeshPointerObserver(scene: Scene): Observer<PointerInfo> {\r\n        // Instantiate/dispose gizmos based on pointer actions\r\n        const pointerObserver = scene.onPointerObservable.add((pointerInfo) => {\r\n            if (!this.usePointerToAttachGizmos) {\r\n                return;\r\n            }\r\n            if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {\r\n                if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh) {\r\n                    if (this.enableAutoPicking) {\r\n                        let node: Nullable<Node> = pointerInfo.pickInfo.pickedMesh;\r\n                        if (this.attachableMeshes == null) {\r\n                            // Attach to the most parent node\r\n                            while (node && node.parent != null) {\r\n                                node = node.parent;\r\n                            }\r\n                        } else {\r\n                            // Attach to the parent node that is an attachableMesh\r\n                            let found = false;\r\n                            this.attachableMeshes.forEach((mesh) => {\r\n                                if (node && (node == mesh || node.isDescendantOf(mesh))) {\r\n                                    node = mesh;\r\n                                    found = true;\r\n                                }\r\n                            });\r\n                            if (!found) {\r\n                                node = null;\r\n                            }\r\n                        }\r\n                        if (node instanceof AbstractMesh) {\r\n                            if (this._attachedMesh != node) {\r\n                                this.attachToMesh(node);\r\n                            }\r\n                        } else {\r\n                            if (this.clearGizmoOnEmptyPointerEvent) {\r\n                                this.attachToMesh(null);\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (this.clearGizmoOnEmptyPointerEvent) {\r\n                        this.attachToMesh(null);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        return pointerObserver!;\r\n    }\r\n\r\n    /**\r\n     * Attaches a set of gizmos to the specified mesh\r\n     * @param mesh The mesh the gizmo's should be attached to\r\n     */\r\n    public attachToMesh(mesh: Nullable<AbstractMesh>) {\r\n        if (this._attachedMesh) {\r\n            this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\r\n        }\r\n        if (this._attachedNode) {\r\n            this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\r\n        }\r\n        this._attachedMesh = mesh;\r\n        this._attachedNode = null;\r\n        for (const key in this.gizmos) {\r\n            const gizmo = <Nullable<IGizmo>>(<any>this.gizmos)[key];\r\n            if (gizmo && (<any>this._gizmosEnabled)[key]) {\r\n                gizmo.attachedMesh = mesh;\r\n            }\r\n        }\r\n        if (this.boundingBoxGizmoEnabled && this._attachedMesh) {\r\n            this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);\r\n        }\r\n        this.onAttachedToMeshObservable.notifyObservers(mesh);\r\n    }\r\n\r\n    /**\r\n     * Attaches a set of gizmos to the specified node\r\n     * @param node The node the gizmo's should be attached to\r\n     */\r\n    public attachToNode(node: Nullable<Node>) {\r\n        if (this._attachedMesh) {\r\n            this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\r\n        }\r\n        if (this._attachedNode) {\r\n            this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\r\n        }\r\n        this._attachedMesh = null;\r\n        this._attachedNode = node;\r\n        for (const key in this.gizmos) {\r\n            const gizmo = <Nullable<IGizmo>>(<any>this.gizmos)[key];\r\n            if (gizmo && (<any>this._gizmosEnabled)[key]) {\r\n                gizmo.attachedNode = node;\r\n            }\r\n        }\r\n        if (this.boundingBoxGizmoEnabled && this._attachedNode) {\r\n            this._attachedNode.addBehavior(this.boundingBoxDragBehavior);\r\n        }\r\n        this.onAttachedToNodeObservable.notifyObservers(node);\r\n    }\r\n\r\n    /**\r\n     * If the position gizmo is enabled\r\n     */\r\n    public set positionGizmoEnabled(value: boolean) {\r\n        if (value) {\r\n            if (!this.gizmos.positionGizmo) {\r\n                this.gizmos.positionGizmo = new PositionGizmo(this._defaultUtilityLayer, this._thickness, this);\r\n            }\r\n            if (this._attachedNode) {\r\n                this.gizmos.positionGizmo.attachedNode = this._attachedNode;\r\n            } else {\r\n                this.gizmos.positionGizmo.attachedMesh = this._attachedMesh;\r\n            }\r\n        } else if (this.gizmos.positionGizmo) {\r\n            this.gizmos.positionGizmo.attachedNode = null;\r\n        }\r\n        this._gizmosEnabled.positionGizmo = value;\r\n    }\r\n    public get positionGizmoEnabled(): boolean {\r\n        return this._gizmosEnabled.positionGizmo;\r\n    }\r\n    /**\r\n     * If the rotation gizmo is enabled\r\n     */\r\n    public set rotationGizmoEnabled(value: boolean) {\r\n        if (value) {\r\n            if (!this.gizmos.rotationGizmo) {\r\n                this.gizmos.rotationGizmo = new RotationGizmo(this._defaultUtilityLayer, 32, false, this._thickness, this);\r\n            }\r\n            if (this._attachedNode) {\r\n                this.gizmos.rotationGizmo.attachedNode = this._attachedNode;\r\n            } else {\r\n                this.gizmos.rotationGizmo.attachedMesh = this._attachedMesh;\r\n            }\r\n        } else if (this.gizmos.rotationGizmo) {\r\n            this.gizmos.rotationGizmo.attachedNode = null;\r\n        }\r\n        this._gizmosEnabled.rotationGizmo = value;\r\n    }\r\n    public get rotationGizmoEnabled(): boolean {\r\n        return this._gizmosEnabled.rotationGizmo;\r\n    }\r\n    /**\r\n     * If the scale gizmo is enabled\r\n     */\r\n    public set scaleGizmoEnabled(value: boolean) {\r\n        if (value) {\r\n            this.gizmos.scaleGizmo = this.gizmos.scaleGizmo || new ScaleGizmo(this._defaultUtilityLayer, this._thickness, this);\r\n            if (this._attachedNode) {\r\n                this.gizmos.scaleGizmo.attachedNode = this._attachedNode;\r\n            } else {\r\n                this.gizmos.scaleGizmo.attachedMesh = this._attachedMesh;\r\n            }\r\n        } else if (this.gizmos.scaleGizmo) {\r\n            this.gizmos.scaleGizmo.attachedNode = null;\r\n        }\r\n        this._gizmosEnabled.scaleGizmo = value;\r\n    }\r\n    public get scaleGizmoEnabled(): boolean {\r\n        return this._gizmosEnabled.scaleGizmo;\r\n    }\r\n    /**\r\n     * If the boundingBox gizmo is enabled\r\n     */\r\n    public set boundingBoxGizmoEnabled(value: boolean) {\r\n        if (value) {\r\n            this.gizmos.boundingBoxGizmo = this.gizmos.boundingBoxGizmo || new BoundingBoxGizmo(this._boundingBoxColor, this._defaultKeepDepthUtilityLayer);\r\n            if (this._attachedMesh) {\r\n                this.gizmos.boundingBoxGizmo.attachedMesh = this._attachedMesh;\r\n            } else {\r\n                this.gizmos.boundingBoxGizmo.attachedNode = this._attachedNode;\r\n            }\r\n\r\n            if (this._attachedMesh) {\r\n                this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\r\n                this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);\r\n            } else if (this._attachedNode) {\r\n                this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\r\n                this._attachedNode.addBehavior(this.boundingBoxDragBehavior);\r\n            }\r\n        } else if (this.gizmos.boundingBoxGizmo) {\r\n            if (this._attachedMesh) {\r\n                this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\r\n            } else if (this._attachedNode) {\r\n                this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\r\n            }\r\n            this.gizmos.boundingBoxGizmo.attachedNode = null;\r\n        }\r\n        this._gizmosEnabled.boundingBoxGizmo = value;\r\n    }\r\n    public get boundingBoxGizmoEnabled(): boolean {\r\n        return this._gizmosEnabled.boundingBoxGizmo;\r\n    }\r\n\r\n    /**\r\n     * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\r\n     * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\r\n     */\r\n    public addToAxisCache(gizmoAxisCache: Map<Mesh, GizmoAxisCache>) {\r\n        if (gizmoAxisCache.size > 0) {\r\n            gizmoAxisCache.forEach((v, k) => {\r\n                this._gizmoAxisCache.set(k, v);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the gizmo manager\r\n     */\r\n    public dispose() {\r\n        this._pointerObservers.forEach((observer) => {\r\n            this._scene.onPointerObservable.remove(observer);\r\n        });\r\n        for (const key in this.gizmos) {\r\n            const gizmo = <Nullable<IGizmo>>(<any>this.gizmos)[key];\r\n            if (gizmo) {\r\n                gizmo.dispose();\r\n            }\r\n        }\r\n        if (this._defaultKeepDepthUtilityLayer !== UtilityLayerRenderer._DefaultKeepDepthUtilityLayer) {\r\n            this._defaultKeepDepthUtilityLayer?.dispose();\r\n        }\r\n        if (this._defaultUtilityLayer !== UtilityLayerRenderer._DefaultUtilityLayer) {\r\n            this._defaultUtilityLayer?.dispose();\r\n        }\r\n        this.boundingBoxDragBehavior.detach();\r\n        this.onAttachedToMeshObservable.clear();\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}