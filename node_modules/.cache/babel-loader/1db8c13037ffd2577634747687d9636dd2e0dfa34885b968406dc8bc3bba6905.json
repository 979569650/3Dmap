{"ast":null,"code":"import { InternalTexture } from \"./internalTexture.js\";\n/**\n * Class used to store an external texture (like GPUExternalTexture in WebGPU)\n */\nexport class ExternalTexture {\n  /**\n   * Checks if a texture is an external or internal texture\n   * @param texture the external or internal texture\n   * @returns true if the texture is an external texture, else false\n   */\n  static IsExternalTexture(texture) {\n    return texture.underlyingResource !== undefined;\n  }\n  /**\n   * Get the class name of the texture.\n   * @returns \"ExternalTexture\"\n   */\n  getClassName() {\n    return \"ExternalTexture\";\n  }\n  /**\n   * Gets the underlying texture object\n   */\n  get underlyingResource() {\n    return this._video;\n  }\n  /**\n   * Constructs the texture\n   * @param video The video the texture should be wrapped around\n   */\n  constructor(video) {\n    /**\n     * Gets a boolean indicating if the texture uses mipmaps\n     */\n    this.useMipMaps = false;\n    /**\n     * The type of the underlying texture is implementation dependent, so return \"UNDEFINED\" for the type\n     */\n    this.type = 16;\n    this._video = video;\n    this.uniqueId = InternalTexture._Counter++;\n  }\n  /**\n   * Get if the texture is ready to be used (downloaded, converted, mip mapped...).\n   * @returns true if fully ready\n   */\n  isReady() {\n    return this._video.readyState >= this._video.HAVE_CURRENT_DATA;\n  }\n  /**\n   * Dispose the texture and release its associated resources.\n   */\n  dispose() {}\n}","map":{"version":3,"names":["InternalTexture","ExternalTexture","IsExternalTexture","texture","underlyingResource","undefined","getClassName","_video","constructor","video","useMipMaps","type","uniqueId","_Counter","isReady","readyState","HAVE_CURRENT_DATA","dispose"],"sources":["../../../../../dev/core/src/Materials/Textures/externalTexture.ts"],"sourcesContent":["import { Constants } from \"../../Engines/constants\";\r\nimport { InternalTexture } from \"./internalTexture\";\r\n\r\n/**\r\n * Class used to store an external texture (like GPUExternalTexture in WebGPU)\r\n */\r\nexport class ExternalTexture {\r\n    /**\r\n     * Checks if a texture is an external or internal texture\r\n     * @param texture the external or internal texture\r\n     * @returns true if the texture is an external texture, else false\r\n     */\r\n    public static IsExternalTexture(texture: ExternalTexture | InternalTexture): texture is ExternalTexture {\r\n        return (texture as ExternalTexture).underlyingResource !== undefined;\r\n    }\r\n\r\n    private _video: HTMLVideoElement;\r\n\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"ExternalTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"ExternalTexture\";\r\n    }\r\n\r\n    /**\r\n     * Gets the underlying texture object\r\n     */\r\n    public get underlyingResource(): any {\r\n        return this._video;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the texture uses mipmaps\r\n     */\r\n    public useMipMaps: boolean = false;\r\n\r\n    /**\r\n     * The type of the underlying texture is implementation dependent, so return \"UNDEFINED\" for the type\r\n     */\r\n    public readonly type = Constants.TEXTURETYPE_UNDEFINED;\r\n\r\n    /**\r\n     * Gets the unique id of this texture\r\n     */\r\n    public readonly uniqueId: number;\r\n\r\n    /**\r\n     * Constructs the texture\r\n     * @param video The video the texture should be wrapped around\r\n     */\r\n    constructor(video: HTMLVideoElement) {\r\n        this._video = video;\r\n        this.uniqueId = InternalTexture._Counter++;\r\n    }\r\n\r\n    /**\r\n     * Get if the texture is ready to be used (downloaded, converted, mip mapped...).\r\n     * @returns true if fully ready\r\n     */\r\n    public isReady(): boolean {\r\n        return this._video.readyState >= this._video.HAVE_CURRENT_DATA;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {}\r\n}\r\n"],"mappings":"AACA,SAASA,eAAe,QAAQ,sBAAoB;AAEpD;;;AAGA,OAAM,MAAOC,eAAe;EACxB;;;;;EAKO,OAAOC,iBAAiBA,CAACC,OAA0C;IACtE,OAAQA,OAA2B,CAACC,kBAAkB,KAAKC,SAAS;EACxE;EAIA;;;;EAIOC,YAAYA,CAAA;IACf,OAAO,iBAAiB;EAC5B;EAEA;;;EAGA,IAAWF,kBAAkBA,CAAA;IACzB,OAAO,IAAI,CAACG,MAAM;EACtB;EAiBA;;;;EAIAC,YAAYC,KAAuB;IAnBnC;;;IAGO,KAAAC,UAAU,GAAY,KAAK;IAElC;;;IAGgB,KAAAC,IAAI,GAAG;IAYnB,IAAI,CAACJ,MAAM,GAAGE,KAAK;IACnB,IAAI,CAACG,QAAQ,GAAGZ,eAAe,CAACa,QAAQ,EAAE;EAC9C;EAEA;;;;EAIOC,OAAOA,CAAA;IACV,OAAO,IAAI,CAACP,MAAM,CAACQ,UAAU,IAAI,IAAI,CAACR,MAAM,CAACS,iBAAiB;EAClE;EAEA;;;EAGOC,OAAOA,CAAA,GAAU"},"metadata":{},"sourceType":"module","externalDependencies":[]}