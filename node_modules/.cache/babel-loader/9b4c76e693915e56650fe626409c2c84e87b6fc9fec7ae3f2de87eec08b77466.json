{"ast":null,"code":"import { Texture } from \"../../Materials/Textures/texture.js\";\nimport { Vector2 } from \"../../Maths/math.vector.js\";\nimport { PostProcess } from \"../../PostProcesses/postProcess.js\";\nimport { Observable } from \"../../Misc/observable.js\";\n/** @internal */\nexport class FluidRenderingTextures {\n  get blurNumIterations() {\n    return this._blurNumIterations;\n  }\n  set blurNumIterations(numIterations) {\n    if (this._blurNumIterations === numIterations) {\n      return;\n    }\n    this._blurNumIterations = numIterations;\n    if (this._blurPostProcesses !== null) {\n      const blurX = this._blurPostProcesses[0];\n      const blurY = this._blurPostProcesses[1];\n      this._blurPostProcesses = [];\n      for (let i = 0; i < this._blurNumIterations * 2; ++i) {\n        this._blurPostProcesses[i] = i & 1 ? blurY : blurX;\n      }\n    }\n  }\n  get renderTarget() {\n    return this._rt;\n  }\n  get renderTargetBlur() {\n    return this._rtBlur;\n  }\n  get texture() {\n    return this._texture;\n  }\n  get textureBlur() {\n    return this._textureBlurred;\n  }\n  constructor(name, scene, width, height, blurTextureSizeX, blurTextureSizeY, textureType = 1, textureFormat = 6, blurTextureType = 1, blurTextureFormat = 6, useStandardBlur = false, camera = null, generateDepthBuffer = true, samples = 1) {\n    this.enableBlur = true;\n    this.blurSizeDivisor = 1;\n    this.blurFilterSize = 7;\n    this._blurNumIterations = 3;\n    this.blurMaxFilterSize = 100;\n    this.blurDepthScale = 10;\n    this.particleSize = 0.02;\n    this.onDisposeObservable = new Observable();\n    this._name = name;\n    this._scene = scene;\n    this._camera = camera;\n    this._engine = scene.getEngine();\n    this._width = width;\n    this._height = height;\n    this._blurTextureSizeX = blurTextureSizeX;\n    this._blurTextureSizeY = blurTextureSizeY;\n    this._textureType = textureType;\n    this._textureFormat = textureFormat;\n    this._blurTextureType = blurTextureType;\n    this._blurTextureFormat = blurTextureFormat;\n    this._useStandardBlur = useStandardBlur;\n    this._generateDepthBuffer = generateDepthBuffer;\n    this._samples = samples;\n    this._postProcessRunningIndex = 0;\n    this.enableBlur = blurTextureSizeX !== 0 && blurTextureSizeY !== 0;\n    this._rt = null;\n    this._texture = null;\n    this._rtBlur = null;\n    this._textureBlurred = null;\n    this._blurPostProcesses = null;\n  }\n  initialize() {\n    this.dispose();\n    this._createRenderTarget();\n    if (this.enableBlur && this._texture) {\n      const [rtBlur, textureBlurred, blurPostProcesses] = this._createBlurPostProcesses(this._texture, this._blurTextureType, this._blurTextureFormat, this.blurSizeDivisor, this._name, this._useStandardBlur);\n      this._rtBlur = rtBlur;\n      this._textureBlurred = textureBlurred;\n      this._blurPostProcesses = blurPostProcesses;\n    }\n  }\n  applyBlurPostProcesses() {\n    if (this.enableBlur && this._blurPostProcesses) {\n      this._postProcessRunningIndex = 0;\n      this._scene.postProcessManager.directRender(this._blurPostProcesses, this._rtBlur, true);\n      this._engine.unBindFramebuffer(this._rtBlur);\n    }\n  }\n  _createRenderTarget() {\n    this._rt = this._engine.createRenderTargetTexture({\n      width: this._width,\n      height: this._height\n    }, {\n      generateMipMaps: false,\n      type: this._textureType,\n      format: this._textureFormat,\n      samplingMode: 1,\n      generateDepthBuffer: this._generateDepthBuffer,\n      generateStencilBuffer: false,\n      samples: this._samples,\n      label: `FluidRenderingRTT-${this._name}`\n    });\n    const renderTexture = this._rt.texture;\n    renderTexture.incrementReferences();\n    this._texture = new Texture(null, this._scene);\n    this._texture.name = \"rtt\" + this._name;\n    this._texture._texture = renderTexture;\n    this._texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._texture.anisotropicFilteringLevel = 1;\n  }\n  _createBlurPostProcesses(textureBlurSource, textureType, textureFormat, blurSizeDivisor, debugName, useStandardBlur = false) {\n    const engine = this._scene.getEngine();\n    const targetSize = new Vector2(Math.floor(this._blurTextureSizeX / blurSizeDivisor), Math.floor(this._blurTextureSizeY / blurSizeDivisor));\n    const useBilinearFiltering = textureType === 1 && engine.getCaps().textureFloatLinearFiltering || textureType === 2 && engine.getCaps().textureHalfFloatLinearFiltering;\n    const rtBlur = this._engine.createRenderTargetTexture({\n      width: targetSize.x,\n      height: targetSize.y\n    }, {\n      generateMipMaps: false,\n      type: textureType,\n      format: textureFormat,\n      samplingMode: useBilinearFiltering ? 2 : 1,\n      generateDepthBuffer: false,\n      generateStencilBuffer: false,\n      samples: this._samples,\n      label: `FluidRenderingRTTBlur-${debugName}`\n    });\n    const renderTexture = rtBlur.texture;\n    renderTexture.incrementReferences();\n    const texture = new Texture(null, this._scene);\n    texture.name = \"rttBlurred\" + debugName;\n    texture._texture = renderTexture;\n    texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n    texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n    texture.anisotropicFilteringLevel = 1;\n    if (useStandardBlur) {\n      const kernelBlurXPostprocess = new PostProcess(\"BilateralBlurX\", \"fluidRenderingStandardBlur\", [\"filterSize\", \"blurDir\"], null, 1, null, 1, engine, true, null, textureType, undefined, undefined, undefined, textureFormat);\n      kernelBlurXPostprocess.samples = this._samples;\n      kernelBlurXPostprocess.externalTextureSamplerBinding = true;\n      kernelBlurXPostprocess.onApplyObservable.add(effect => {\n        if (this._postProcessRunningIndex === 0) {\n          effect.setTexture(\"textureSampler\", textureBlurSource);\n        } else {\n          effect._bindTexture(\"textureSampler\", kernelBlurXPostprocess.inputTexture.texture);\n        }\n        effect.setInt(\"filterSize\", this.blurFilterSize);\n        effect.setFloat2(\"blurDir\", 1 / this._blurTextureSizeX, 0);\n        this._postProcessRunningIndex++;\n      });\n      kernelBlurXPostprocess.onSizeChangedObservable.add(() => {\n        kernelBlurXPostprocess._textures.forEach(rt => {\n          rt.texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n          rt.texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n        });\n      });\n      this._fixReusablePostProcess(kernelBlurXPostprocess);\n      const kernelBlurYPostprocess = new PostProcess(\"BilateralBlurY\", \"fluidRenderingStandardBlur\", [\"filterSize\", \"blurDir\"], null, 1, null, 1, engine, true, null, textureType, undefined, undefined, undefined, textureFormat);\n      kernelBlurYPostprocess.samples = this._samples;\n      kernelBlurYPostprocess.onApplyObservable.add(effect => {\n        effect.setInt(\"filterSize\", this.blurFilterSize);\n        effect.setFloat2(\"blurDir\", 0, 1 / this._blurTextureSizeY);\n        this._postProcessRunningIndex++;\n      });\n      kernelBlurYPostprocess.onSizeChangedObservable.add(() => {\n        kernelBlurYPostprocess._textures.forEach(rt => {\n          rt.texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n          rt.texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n        });\n      });\n      this._fixReusablePostProcess(kernelBlurYPostprocess);\n      kernelBlurXPostprocess.autoClear = false;\n      kernelBlurYPostprocess.autoClear = false;\n      const blurList = [];\n      for (let i = 0; i < this._blurNumIterations * 2; ++i) {\n        blurList[i] = i & 1 ? kernelBlurYPostprocess : kernelBlurXPostprocess;\n      }\n      return [rtBlur, texture, blurList];\n    } else {\n      const uniforms = [\"maxFilterSize\", \"blurDir\", \"projectedParticleConstant\", \"depthThreshold\"];\n      const kernelBlurXPostprocess = new PostProcess(\"BilateralBlurX\", \"fluidRenderingBilateralBlur\", uniforms, null, 1, null, 1, engine, true, null, textureType, undefined, undefined, undefined, textureFormat);\n      kernelBlurXPostprocess.samples = this._samples;\n      kernelBlurXPostprocess.externalTextureSamplerBinding = true;\n      kernelBlurXPostprocess.onApplyObservable.add(effect => {\n        if (this._postProcessRunningIndex === 0) {\n          effect.setTexture(\"textureSampler\", textureBlurSource);\n        } else {\n          effect._bindTexture(\"textureSampler\", kernelBlurXPostprocess.inputTexture.texture);\n        }\n        effect.setInt(\"maxFilterSize\", this.blurMaxFilterSize);\n        effect.setFloat2(\"blurDir\", 1 / this._blurTextureSizeX, 0);\n        effect.setFloat(\"projectedParticleConstant\", this._getProjectedParticleConstant());\n        effect.setFloat(\"depthThreshold\", this._getDepthThreshold());\n        this._postProcessRunningIndex++;\n      });\n      kernelBlurXPostprocess.onSizeChangedObservable.add(() => {\n        kernelBlurXPostprocess._textures.forEach(rt => {\n          rt.texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n          rt.texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n        });\n      });\n      this._fixReusablePostProcess(kernelBlurXPostprocess);\n      const kernelBlurYPostprocess = new PostProcess(\"BilateralBlurY\", \"fluidRenderingBilateralBlur\", uniforms, null, 1, null, 1, engine, true, null, textureType, undefined, undefined, undefined, textureFormat);\n      kernelBlurYPostprocess.samples = this._samples;\n      kernelBlurYPostprocess.onApplyObservable.add(effect => {\n        effect.setInt(\"maxFilterSize\", this.blurMaxFilterSize);\n        effect.setFloat2(\"blurDir\", 0, 1 / this._blurTextureSizeY);\n        effect.setFloat(\"projectedParticleConstant\", this._getProjectedParticleConstant());\n        effect.setFloat(\"depthThreshold\", this._getDepthThreshold());\n        this._postProcessRunningIndex++;\n      });\n      kernelBlurYPostprocess.onSizeChangedObservable.add(() => {\n        kernelBlurYPostprocess._textures.forEach(rt => {\n          rt.texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n          rt.texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n        });\n      });\n      this._fixReusablePostProcess(kernelBlurYPostprocess);\n      kernelBlurXPostprocess.autoClear = false;\n      kernelBlurYPostprocess.autoClear = false;\n      const blurList = [];\n      for (let i = 0; i < this._blurNumIterations * 2; ++i) {\n        blurList[i] = i & 1 ? kernelBlurYPostprocess : kernelBlurXPostprocess;\n      }\n      return [rtBlur, texture, blurList];\n    }\n  }\n  _fixReusablePostProcess(pp) {\n    if (!pp.isReusable()) {\n      return;\n    }\n    pp.onActivateObservable.add(() => {\n      // undo what calling activate() does which will make sure we will retrieve the right texture when getting the input for the post process\n      pp._currentRenderTextureInd = (pp._currentRenderTextureInd + 1) % 2;\n    });\n    pp.onApplyObservable.add(() => {\n      // now we can advance to the next texture\n      pp._currentRenderTextureInd = (pp._currentRenderTextureInd + 1) % 2;\n    });\n  }\n  _getProjectedParticleConstant() {\n    var _a, _b;\n    return this.blurFilterSize * this.particleSize * 0.05 * (this._height / 2) / Math.tan(((_b = (_a = this._camera) === null || _a === void 0 ? void 0 : _a.fov) !== null && _b !== void 0 ? _b : 45 * Math.PI / 180) / 2);\n  }\n  _getDepthThreshold() {\n    return this.particleSize / 2 * this.blurDepthScale;\n  }\n  dispose() {\n    var _a, _b, _c, _d;\n    if (this.onDisposeObservable.hasObservers()) {\n      this.onDisposeObservable.notifyObservers(this);\n    }\n    (_a = this._rt) === null || _a === void 0 ? void 0 : _a.dispose();\n    this._rt = null;\n    (_b = this._texture) === null || _b === void 0 ? void 0 : _b.dispose();\n    this._texture = null;\n    (_c = this._rtBlur) === null || _c === void 0 ? void 0 : _c.dispose();\n    this._rtBlur = null;\n    (_d = this._textureBlurred) === null || _d === void 0 ? void 0 : _d.dispose();\n    this._textureBlurred = null;\n    if (this._blurPostProcesses) {\n      this._blurPostProcesses[0].dispose();\n      this._blurPostProcesses[1].dispose();\n    }\n    this._blurPostProcesses = null;\n  }\n}","map":{"version":3,"names":["Texture","Vector2","PostProcess","Observable","FluidRenderingTextures","blurNumIterations","_blurNumIterations","numIterations","_blurPostProcesses","blurX","blurY","i","renderTarget","_rt","renderTargetBlur","_rtBlur","texture","_texture","textureBlur","_textureBlurred","constructor","name","scene","width","height","blurTextureSizeX","blurTextureSizeY","textureType","textureFormat","blurTextureType","blurTextureFormat","useStandardBlur","camera","generateDepthBuffer","samples","enableBlur","blurSizeDivisor","blurFilterSize","blurMaxFilterSize","blurDepthScale","particleSize","onDisposeObservable","_name","_scene","_camera","_engine","getEngine","_width","_height","_blurTextureSizeX","_blurTextureSizeY","_textureType","_textureFormat","_blurTextureType","_blurTextureFormat","_useStandardBlur","_generateDepthBuffer","_samples","_postProcessRunningIndex","initialize","dispose","_createRenderTarget","rtBlur","textureBlurred","blurPostProcesses","_createBlurPostProcesses","applyBlurPostProcesses","postProcessManager","directRender","unBindFramebuffer","createRenderTargetTexture","generateMipMaps","type","format","samplingMode","generateStencilBuffer","label","renderTexture","incrementReferences","wrapU","CLAMP_ADDRESSMODE","wrapV","anisotropicFilteringLevel","textureBlurSource","debugName","engine","targetSize","Math","floor","useBilinearFiltering","getCaps","textureFloatLinearFiltering","textureHalfFloatLinearFiltering","x","y","kernelBlurXPostprocess","undefined","externalTextureSamplerBinding","onApplyObservable","add","effect","setTexture","_bindTexture","inputTexture","setInt","setFloat2","onSizeChangedObservable","_textures","forEach","rt","_fixReusablePostProcess","kernelBlurYPostprocess","autoClear","blurList","uniforms","setFloat","_getProjectedParticleConstant","_getDepthThreshold","pp","isReusable","onActivateObservable","_currentRenderTextureInd","tan","_b","_a","fov","PI","hasObservers","notifyObservers","_c","_d"],"sources":["../../../../../dev/core/src/Rendering/fluidRenderer/fluidRenderingTextures.ts"],"sourcesContent":["import type { Camera } from \"core/Cameras/camera\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport type { Engine } from \"core/Engines/engine\";\r\nimport type { RenderTargetWrapper } from \"core/Engines/renderTargetWrapper\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { ThinTexture } from \"core/Materials/Textures/thinTexture\";\r\nimport { Vector2 } from \"core/Maths/math.vector\";\r\nimport { PostProcess } from \"core/PostProcesses/postProcess\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Observable } from \"core/Misc/observable\";\r\n\r\n/** @internal */\r\nexport class FluidRenderingTextures {\r\n    protected _name: string;\r\n    protected _scene: Scene;\r\n    protected _camera: Nullable<Camera>;\r\n    protected _engine: Engine;\r\n    protected _width: number;\r\n    protected _height: number;\r\n    protected _blurTextureSizeX: number;\r\n    protected _blurTextureSizeY: number;\r\n    protected _textureType: number;\r\n    protected _textureFormat: number;\r\n    protected _blurTextureType: number;\r\n    protected _blurTextureFormat: number;\r\n    protected _useStandardBlur: boolean;\r\n    protected _generateDepthBuffer: boolean;\r\n    protected _samples: number;\r\n    protected _postProcessRunningIndex: number;\r\n\r\n    protected _rt: Nullable<RenderTargetWrapper>;\r\n    protected _texture: Nullable<Texture>;\r\n    protected _rtBlur: Nullable<RenderTargetWrapper>;\r\n    protected _textureBlurred: Nullable<Texture>;\r\n    protected _blurPostProcesses: Nullable<PostProcess[]>;\r\n\r\n    public enableBlur = true;\r\n\r\n    public blurSizeDivisor = 1;\r\n\r\n    public blurFilterSize = 7;\r\n\r\n    private _blurNumIterations = 3;\r\n\r\n    public get blurNumIterations() {\r\n        return this._blurNumIterations;\r\n    }\r\n\r\n    public set blurNumIterations(numIterations: number) {\r\n        if (this._blurNumIterations === numIterations) {\r\n            return;\r\n        }\r\n\r\n        this._blurNumIterations = numIterations;\r\n        if (this._blurPostProcesses !== null) {\r\n            const blurX = this._blurPostProcesses[0];\r\n            const blurY = this._blurPostProcesses[1];\r\n\r\n            this._blurPostProcesses = [];\r\n            for (let i = 0; i < this._blurNumIterations * 2; ++i) {\r\n                this._blurPostProcesses[i] = i & 1 ? blurY : blurX;\r\n            }\r\n        }\r\n    }\r\n\r\n    public blurMaxFilterSize = 100;\r\n\r\n    public blurDepthScale = 10;\r\n\r\n    public particleSize = 0.02;\r\n\r\n    public onDisposeObservable: Observable<FluidRenderingTextures> = new Observable<FluidRenderingTextures>();\r\n\r\n    public get renderTarget() {\r\n        return this._rt;\r\n    }\r\n\r\n    public get renderTargetBlur() {\r\n        return this._rtBlur;\r\n    }\r\n\r\n    public get texture() {\r\n        return this._texture;\r\n    }\r\n\r\n    public get textureBlur() {\r\n        return this._textureBlurred;\r\n    }\r\n\r\n    constructor(\r\n        name: string,\r\n        scene: Scene,\r\n        width: number,\r\n        height: number,\r\n        blurTextureSizeX: number,\r\n        blurTextureSizeY: number,\r\n        textureType: number = Constants.TEXTURETYPE_FLOAT,\r\n        textureFormat: number = Constants.TEXTUREFORMAT_R,\r\n        blurTextureType: number = Constants.TEXTURETYPE_FLOAT,\r\n        blurTextureFormat: number = Constants.TEXTUREFORMAT_R,\r\n        useStandardBlur = false,\r\n        camera: Nullable<Camera> = null,\r\n        generateDepthBuffer = true,\r\n        samples = 1\r\n    ) {\r\n        this._name = name;\r\n        this._scene = scene;\r\n        this._camera = camera;\r\n        this._engine = scene.getEngine();\r\n        this._width = width;\r\n        this._height = height;\r\n        this._blurTextureSizeX = blurTextureSizeX;\r\n        this._blurTextureSizeY = blurTextureSizeY;\r\n        this._textureType = textureType;\r\n        this._textureFormat = textureFormat;\r\n        this._blurTextureType = blurTextureType;\r\n        this._blurTextureFormat = blurTextureFormat;\r\n        this._useStandardBlur = useStandardBlur;\r\n        this._generateDepthBuffer = generateDepthBuffer;\r\n        this._samples = samples;\r\n        this._postProcessRunningIndex = 0;\r\n        this.enableBlur = blurTextureSizeX !== 0 && blurTextureSizeY !== 0;\r\n\r\n        this._rt = null;\r\n        this._texture = null;\r\n        this._rtBlur = null;\r\n        this._textureBlurred = null;\r\n        this._blurPostProcesses = null;\r\n    }\r\n\r\n    public initialize(): void {\r\n        this.dispose();\r\n\r\n        this._createRenderTarget();\r\n\r\n        if (this.enableBlur && this._texture) {\r\n            const [rtBlur, textureBlurred, blurPostProcesses] = this._createBlurPostProcesses(\r\n                this._texture,\r\n                this._blurTextureType,\r\n                this._blurTextureFormat,\r\n                this.blurSizeDivisor,\r\n                this._name,\r\n                this._useStandardBlur\r\n            );\r\n            this._rtBlur = rtBlur;\r\n            this._textureBlurred = textureBlurred;\r\n            this._blurPostProcesses = blurPostProcesses;\r\n        }\r\n    }\r\n\r\n    public applyBlurPostProcesses(): void {\r\n        if (this.enableBlur && this._blurPostProcesses) {\r\n            this._postProcessRunningIndex = 0;\r\n            this._scene.postProcessManager.directRender(this._blurPostProcesses, this._rtBlur, true);\r\n            this._engine.unBindFramebuffer(this._rtBlur!);\r\n        }\r\n    }\r\n\r\n    protected _createRenderTarget(): void {\r\n        this._rt = this._engine.createRenderTargetTexture(\r\n            { width: this._width, height: this._height },\r\n            {\r\n                generateMipMaps: false,\r\n                type: this._textureType,\r\n                format: this._textureFormat,\r\n                samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                generateDepthBuffer: this._generateDepthBuffer,\r\n                generateStencilBuffer: false,\r\n                samples: this._samples,\r\n                label: `FluidRenderingRTT-${this._name}`,\r\n            }\r\n        );\r\n\r\n        const renderTexture = this._rt.texture!;\r\n\r\n        renderTexture.incrementReferences();\r\n\r\n        this._texture = new Texture(null, this._scene);\r\n        this._texture.name = \"rtt\" + this._name;\r\n        this._texture._texture = renderTexture;\r\n        this._texture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._texture.anisotropicFilteringLevel = 1;\r\n    }\r\n\r\n    protected _createBlurPostProcesses(\r\n        textureBlurSource: ThinTexture,\r\n        textureType: number,\r\n        textureFormat: number,\r\n        blurSizeDivisor: number,\r\n        debugName: string,\r\n        useStandardBlur = false\r\n    ): [RenderTargetWrapper, Texture, PostProcess[]] {\r\n        const engine = this._scene.getEngine();\r\n        const targetSize = new Vector2(Math.floor(this._blurTextureSizeX / blurSizeDivisor), Math.floor(this._blurTextureSizeY / blurSizeDivisor));\r\n        const useBilinearFiltering =\r\n            (textureType === Constants.TEXTURETYPE_FLOAT && engine.getCaps().textureFloatLinearFiltering) ||\r\n            (textureType === Constants.TEXTURETYPE_HALF_FLOAT && engine.getCaps().textureHalfFloatLinearFiltering);\r\n\r\n        const rtBlur = this._engine.createRenderTargetTexture(\r\n            { width: targetSize.x, height: targetSize.y },\r\n            {\r\n                generateMipMaps: false,\r\n                type: textureType,\r\n                format: textureFormat,\r\n                samplingMode: useBilinearFiltering ? Constants.TEXTURE_BILINEAR_SAMPLINGMODE : Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                generateDepthBuffer: false,\r\n                generateStencilBuffer: false,\r\n                samples: this._samples,\r\n                label: `FluidRenderingRTTBlur-${debugName}`,\r\n            }\r\n        );\r\n\r\n        const renderTexture = rtBlur.texture!;\r\n\r\n        renderTexture.incrementReferences();\r\n\r\n        const texture = new Texture(null, this._scene);\r\n        texture.name = \"rttBlurred\" + debugName;\r\n        texture._texture = renderTexture;\r\n        texture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        texture.anisotropicFilteringLevel = 1;\r\n\r\n        if (useStandardBlur) {\r\n            const kernelBlurXPostprocess = new PostProcess(\r\n                \"BilateralBlurX\",\r\n                \"fluidRenderingStandardBlur\",\r\n                [\"filterSize\", \"blurDir\"],\r\n                null,\r\n                1,\r\n                null,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                engine,\r\n                true,\r\n                null,\r\n                textureType,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                textureFormat\r\n            );\r\n            kernelBlurXPostprocess.samples = this._samples;\r\n            kernelBlurXPostprocess.externalTextureSamplerBinding = true;\r\n            kernelBlurXPostprocess.onApplyObservable.add((effect) => {\r\n                if (this._postProcessRunningIndex === 0) {\r\n                    effect.setTexture(\"textureSampler\", textureBlurSource);\r\n                } else {\r\n                    effect._bindTexture(\"textureSampler\", kernelBlurXPostprocess.inputTexture.texture);\r\n                }\r\n                effect.setInt(\"filterSize\", this.blurFilterSize);\r\n                effect.setFloat2(\"blurDir\", 1 / this._blurTextureSizeX, 0);\r\n                this._postProcessRunningIndex++;\r\n            });\r\n            kernelBlurXPostprocess.onSizeChangedObservable.add(() => {\r\n                kernelBlurXPostprocess._textures.forEach((rt) => {\r\n                    rt.texture!.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n                    rt.texture!.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n                });\r\n            });\r\n            this._fixReusablePostProcess(kernelBlurXPostprocess);\r\n\r\n            const kernelBlurYPostprocess = new PostProcess(\r\n                \"BilateralBlurY\",\r\n                \"fluidRenderingStandardBlur\",\r\n                [\"filterSize\", \"blurDir\"],\r\n                null,\r\n                1,\r\n                null,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                engine,\r\n                true,\r\n                null,\r\n                textureType,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                textureFormat\r\n            );\r\n            kernelBlurYPostprocess.samples = this._samples;\r\n            kernelBlurYPostprocess.onApplyObservable.add((effect) => {\r\n                effect.setInt(\"filterSize\", this.blurFilterSize);\r\n                effect.setFloat2(\"blurDir\", 0, 1 / this._blurTextureSizeY);\r\n                this._postProcessRunningIndex++;\r\n            });\r\n            kernelBlurYPostprocess.onSizeChangedObservable.add(() => {\r\n                kernelBlurYPostprocess._textures.forEach((rt) => {\r\n                    rt.texture!.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n                    rt.texture!.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n                });\r\n            });\r\n            this._fixReusablePostProcess(kernelBlurYPostprocess);\r\n\r\n            kernelBlurXPostprocess.autoClear = false;\r\n            kernelBlurYPostprocess.autoClear = false;\r\n\r\n            const blurList = [];\r\n            for (let i = 0; i < this._blurNumIterations * 2; ++i) {\r\n                blurList[i] = i & 1 ? kernelBlurYPostprocess : kernelBlurXPostprocess;\r\n            }\r\n\r\n            return [rtBlur, texture, blurList];\r\n        } else {\r\n            const uniforms: string[] = [\"maxFilterSize\", \"blurDir\", \"projectedParticleConstant\", \"depthThreshold\"];\r\n\r\n            const kernelBlurXPostprocess = new PostProcess(\r\n                \"BilateralBlurX\",\r\n                \"fluidRenderingBilateralBlur\",\r\n                uniforms,\r\n                null,\r\n                1,\r\n                null,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                engine,\r\n                true,\r\n                null,\r\n                textureType,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                textureFormat\r\n            );\r\n            kernelBlurXPostprocess.samples = this._samples;\r\n            kernelBlurXPostprocess.externalTextureSamplerBinding = true;\r\n            kernelBlurXPostprocess.onApplyObservable.add((effect) => {\r\n                if (this._postProcessRunningIndex === 0) {\r\n                    effect.setTexture(\"textureSampler\", textureBlurSource);\r\n                } else {\r\n                    effect._bindTexture(\"textureSampler\", kernelBlurXPostprocess.inputTexture.texture);\r\n                }\r\n                effect.setInt(\"maxFilterSize\", this.blurMaxFilterSize);\r\n                effect.setFloat2(\"blurDir\", 1 / this._blurTextureSizeX, 0);\r\n                effect.setFloat(\"projectedParticleConstant\", this._getProjectedParticleConstant());\r\n                effect.setFloat(\"depthThreshold\", this._getDepthThreshold());\r\n                this._postProcessRunningIndex++;\r\n            });\r\n            kernelBlurXPostprocess.onSizeChangedObservable.add(() => {\r\n                kernelBlurXPostprocess._textures.forEach((rt) => {\r\n                    rt.texture!.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n                    rt.texture!.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n                });\r\n            });\r\n            this._fixReusablePostProcess(kernelBlurXPostprocess);\r\n\r\n            const kernelBlurYPostprocess = new PostProcess(\r\n                \"BilateralBlurY\",\r\n                \"fluidRenderingBilateralBlur\",\r\n                uniforms,\r\n                null,\r\n                1,\r\n                null,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                engine,\r\n                true,\r\n                null,\r\n                textureType,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                textureFormat\r\n            );\r\n            kernelBlurYPostprocess.samples = this._samples;\r\n            kernelBlurYPostprocess.onApplyObservable.add((effect) => {\r\n                effect.setInt(\"maxFilterSize\", this.blurMaxFilterSize);\r\n                effect.setFloat2(\"blurDir\", 0, 1 / this._blurTextureSizeY);\r\n                effect.setFloat(\"projectedParticleConstant\", this._getProjectedParticleConstant());\r\n                effect.setFloat(\"depthThreshold\", this._getDepthThreshold());\r\n                this._postProcessRunningIndex++;\r\n            });\r\n            kernelBlurYPostprocess.onSizeChangedObservable.add(() => {\r\n                kernelBlurYPostprocess._textures.forEach((rt) => {\r\n                    rt.texture!.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n                    rt.texture!.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n                });\r\n            });\r\n            this._fixReusablePostProcess(kernelBlurYPostprocess);\r\n\r\n            kernelBlurXPostprocess.autoClear = false;\r\n            kernelBlurYPostprocess.autoClear = false;\r\n\r\n            const blurList = [];\r\n            for (let i = 0; i < this._blurNumIterations * 2; ++i) {\r\n                blurList[i] = i & 1 ? kernelBlurYPostprocess : kernelBlurXPostprocess;\r\n            }\r\n\r\n            return [rtBlur, texture, blurList];\r\n        }\r\n    }\r\n\r\n    private _fixReusablePostProcess(pp: PostProcess) {\r\n        if (!pp.isReusable()) {\r\n            return;\r\n        }\r\n\r\n        pp.onActivateObservable.add(() => {\r\n            // undo what calling activate() does which will make sure we will retrieve the right texture when getting the input for the post process\r\n            pp._currentRenderTextureInd = (pp._currentRenderTextureInd + 1) % 2;\r\n        });\r\n        pp.onApplyObservable.add(() => {\r\n            // now we can advance to the next texture\r\n            pp._currentRenderTextureInd = (pp._currentRenderTextureInd + 1) % 2;\r\n        });\r\n    }\r\n\r\n    private _getProjectedParticleConstant() {\r\n        return (this.blurFilterSize * this.particleSize * 0.05 * (this._height / 2)) / Math.tan((this._camera?.fov ?? (45 * Math.PI) / 180) / 2);\r\n    }\r\n\r\n    private _getDepthThreshold() {\r\n        return (this.particleSize / 2) * this.blurDepthScale;\r\n    }\r\n\r\n    public dispose(): void {\r\n        if (this.onDisposeObservable.hasObservers()) {\r\n            this.onDisposeObservable.notifyObservers(this);\r\n        }\r\n\r\n        this._rt?.dispose();\r\n        this._rt = null;\r\n        this._texture?.dispose();\r\n        this._texture = null;\r\n        this._rtBlur?.dispose();\r\n        this._rtBlur = null;\r\n        this._textureBlurred?.dispose();\r\n        this._textureBlurred = null;\r\n        if (this._blurPostProcesses) {\r\n            this._blurPostProcesses[0].dispose();\r\n            this._blurPostProcesses[1].dispose();\r\n        }\r\n        this._blurPostProcesses = null;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}