{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { FlowGraphBlock } from \"./flowGraphBlock.js\";\nimport { FlowGraphConnectionType } from \"./flowGraphConnection.js\";\nimport { FlowGraphSignalConnection } from \"./flowGraphSignalConnection.js\";\n/**\n * @experimental\n * A block that executes some action. Always has an input signal (which is not used by event blocks).\n * Can have one or more output signals.\n */\nexport class FlowGraphExecutionBlock extends FlowGraphBlock {\n  constructor(config) {\n    super(config);\n    this.onStart = this._registerSignalInput(\"onStart\");\n  }\n  configure() {\n    super.configure();\n    this.signalInputs = [];\n    this.signalOutputs = [];\n  }\n  _registerSignalInput(name) {\n    const input = new FlowGraphSignalConnection(name, FlowGraphConnectionType.Input, this);\n    this.signalInputs.push(input);\n    return input;\n  }\n  _registerSignalOutput(name) {\n    const output = new FlowGraphSignalConnection(name, FlowGraphConnectionType.Output, this);\n    this.signalOutputs.push(output);\n    return output;\n  }\n  serialize(serializationObject = {}) {\n    super.serialize(serializationObject);\n    serializationObject.signalInputs = [];\n    serializationObject.signalOutputs = [];\n    for (const input of this.signalInputs) {\n      const serializedInput = {};\n      input.serialize(serializedInput);\n      serializationObject.signalInputs.push(serializedInput);\n    }\n    for (const output of this.signalOutputs) {\n      const serializedOutput = {};\n      output.serialize(serializedOutput);\n      serializationObject.signalOutputs.push(serializedOutput);\n    }\n  }\n  getClassName() {\n    return \"FGExecutionBlock\";\n  }\n  static Parse(serializationObject = {}) {\n    const block = super.Parse(serializationObject);\n    for (let i = 0; i < serializationObject.signalInputs.length; i++) {\n      block.signalInputs[i].deserialize(serializationObject.signalInputs[i]);\n    }\n    for (let i = 0; i < serializationObject.signalOutputs.length; i++) {\n      block.signalOutputs[i].deserialize(serializationObject.signalOutputs[i]);\n    }\n    return block;\n  }\n}","map":{"version":3,"names":["FlowGraphBlock","FlowGraphConnectionType","FlowGraphSignalConnection","FlowGraphExecutionBlock","constructor","config","onStart","_registerSignalInput","configure","signalInputs","signalOutputs","name","input","Input","push","_registerSignalOutput","output","Output","serialize","serializationObject","serializedInput","serializedOutput","getClassName","Parse","block","i","length","deserialize"],"sources":["../../../../dev/core/src/FlowGraph/flowGraphExecutionBlock.ts"],"sourcesContent":["import type { IFlowGraphBlockConfiguration } from \"./flowGraphBlock\";\r\nimport { FlowGraphBlock } from \"./flowGraphBlock\";\r\nimport { FlowGraphConnectionType } from \"./flowGraphConnection\";\r\nimport type { FlowGraphContext } from \"./flowGraphContext\";\r\nimport { FlowGraphSignalConnection } from \"./flowGraphSignalConnection\";\r\n\r\n/**\r\n * @experimental\r\n * A block that executes some action. Always has an input signal (which is not used by event blocks).\r\n * Can have one or more output signals.\r\n */\r\nexport abstract class FlowGraphExecutionBlock extends FlowGraphBlock {\r\n    /**\r\n     * Input connection: The input signal of the block.\r\n     */\r\n    public readonly onStart: FlowGraphSignalConnection;\r\n\r\n    public signalInputs: FlowGraphSignalConnection[];\r\n    public signalOutputs: FlowGraphSignalConnection[];\r\n\r\n    protected constructor(config?: IFlowGraphBlockConfiguration) {\r\n        super(config);\r\n        this.onStart = this._registerSignalInput(\"onStart\");\r\n    }\r\n\r\n    public configure() {\r\n        super.configure();\r\n        this.signalInputs = [];\r\n        this.signalOutputs = [];\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Executes the flow graph execution block.\r\n     */\r\n    public abstract _execute(context: FlowGraphContext, callingSignal: FlowGraphSignalConnection): void;\r\n\r\n    protected _registerSignalInput(name: string): FlowGraphSignalConnection {\r\n        const input = new FlowGraphSignalConnection(name, FlowGraphConnectionType.Input, this);\r\n        this.signalInputs.push(input);\r\n        return input;\r\n    }\r\n\r\n    protected _registerSignalOutput(name: string): FlowGraphSignalConnection {\r\n        const output = new FlowGraphSignalConnection(name, FlowGraphConnectionType.Output, this);\r\n        this.signalOutputs.push(output);\r\n        return output;\r\n    }\r\n\r\n    public serialize(serializationObject: any = {}) {\r\n        super.serialize(serializationObject);\r\n        serializationObject.signalInputs = [];\r\n        serializationObject.signalOutputs = [];\r\n        for (const input of this.signalInputs) {\r\n            const serializedInput: any = {};\r\n            input.serialize(serializedInput);\r\n            serializationObject.signalInputs.push(serializedInput);\r\n        }\r\n        for (const output of this.signalOutputs) {\r\n            const serializedOutput: any = {};\r\n            output.serialize(serializedOutput);\r\n            serializationObject.signalOutputs.push(serializedOutput);\r\n        }\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"FGExecutionBlock\";\r\n    }\r\n\r\n    public static Parse(serializationObject: any = {}) {\r\n        const block = super.Parse(serializationObject) as FlowGraphExecutionBlock;\r\n        for (let i = 0; i < serializationObject.signalInputs.length; i++) {\r\n            block.signalInputs[i].deserialize(serializationObject.signalInputs[i]);\r\n        }\r\n        for (let i = 0; i < serializationObject.signalOutputs.length; i++) {\r\n            block.signalOutputs[i].deserialize(serializationObject.signalOutputs[i]);\r\n        }\r\n        return block;\r\n    }\r\n}\r\n"],"mappings":";AACA,SAASA,cAAc,QAAQ,qBAAmB;AAClD,SAASC,uBAAuB,QAAQ,0BAAwB;AAEhE,SAASC,yBAAyB,QAAQ,gCAA8B;AAExE;;;;;AAKA,OAAM,MAAgBC,uBAAwB,SAAQH,cAAc;EAShEI,YAAsBC,MAAqC;IACvD,KAAK,CAACA,MAAM,CAAC;IACb,IAAI,CAACC,OAAO,GAAG,IAAI,CAACC,oBAAoB,CAAC,SAAS,CAAC;EACvD;EAEOC,SAASA,CAAA;IACZ,KAAK,CAACA,SAAS,EAAE;IACjB,IAAI,CAACC,YAAY,GAAG,EAAE;IACtB,IAAI,CAACC,aAAa,GAAG,EAAE;EAC3B;EAQUH,oBAAoBA,CAACI,IAAY;IACvC,MAAMC,KAAK,GAAG,IAAIV,yBAAyB,CAACS,IAAI,EAAEV,uBAAuB,CAACY,KAAK,EAAE,IAAI,CAAC;IACtF,IAAI,CAACJ,YAAY,CAACK,IAAI,CAACF,KAAK,CAAC;IAC7B,OAAOA,KAAK;EAChB;EAEUG,qBAAqBA,CAACJ,IAAY;IACxC,MAAMK,MAAM,GAAG,IAAId,yBAAyB,CAACS,IAAI,EAAEV,uBAAuB,CAACgB,MAAM,EAAE,IAAI,CAAC;IACxF,IAAI,CAACP,aAAa,CAACI,IAAI,CAACE,MAAM,CAAC;IAC/B,OAAOA,MAAM;EACjB;EAEOE,SAASA,CAACC,mBAAA,GAA2B,EAAE;IAC1C,KAAK,CAACD,SAAS,CAACC,mBAAmB,CAAC;IACpCA,mBAAmB,CAACV,YAAY,GAAG,EAAE;IACrCU,mBAAmB,CAACT,aAAa,GAAG,EAAE;IACtC,KAAK,MAAME,KAAK,IAAI,IAAI,CAACH,YAAY,EAAE;MACnC,MAAMW,eAAe,GAAQ,EAAE;MAC/BR,KAAK,CAACM,SAAS,CAACE,eAAe,CAAC;MAChCD,mBAAmB,CAACV,YAAY,CAACK,IAAI,CAACM,eAAe,CAAC;;IAE1D,KAAK,MAAMJ,MAAM,IAAI,IAAI,CAACN,aAAa,EAAE;MACrC,MAAMW,gBAAgB,GAAQ,EAAE;MAChCL,MAAM,CAACE,SAAS,CAACG,gBAAgB,CAAC;MAClCF,mBAAmB,CAACT,aAAa,CAACI,IAAI,CAACO,gBAAgB,CAAC;;EAEhE;EAEOC,YAAYA,CAAA;IACf,OAAO,kBAAkB;EAC7B;EAEO,OAAOC,KAAKA,CAACJ,mBAAA,GAA2B,EAAE;IAC7C,MAAMK,KAAK,GAAG,KAAK,CAACD,KAAK,CAACJ,mBAAmB,CAA4B;IACzE,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,mBAAmB,CAACV,YAAY,CAACiB,MAAM,EAAED,CAAC,EAAE,EAAE;MAC9DD,KAAK,CAACf,YAAY,CAACgB,CAAC,CAAC,CAACE,WAAW,CAACR,mBAAmB,CAACV,YAAY,CAACgB,CAAC,CAAC,CAAC;;IAE1E,KAAK,IAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,mBAAmB,CAACT,aAAa,CAACgB,MAAM,EAAED,CAAC,EAAE,EAAE;MAC/DD,KAAK,CAACd,aAAa,CAACe,CAAC,CAAC,CAACE,WAAW,CAACR,mBAAmB,CAACT,aAAa,CAACe,CAAC,CAAC,CAAC;;IAE5E,OAAOD,KAAK;EAChB"},"metadata":{},"sourceType":"module","externalDependencies":[]}