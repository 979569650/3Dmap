{"ast":null,"code":"import \"core-js/modules/web.dom-exception.stack.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { GetDOMTextContent, IsWindowObjectExist } from \"../Misc/domManagement.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor.js\";\nimport { ShaderStore as EngineShaderStore } from \"../Engines/shaderStore.js\";\nimport { ShaderLanguage } from \"./shaderLanguage.js\";\n/**\n * Effect containing vertex and fragment shader that can be executed on an object.\n */\nexport class Effect {\n  /**\n   * Gets or sets the relative url used to load shaders if using the engine in non-minified mode\n   */\n  static get ShadersRepository() {\n    return EngineShaderStore.ShadersRepository;\n  }\n  static set ShadersRepository(repo) {\n    EngineShaderStore.ShadersRepository = repo;\n  }\n  /**\n   * Observable that will be called when effect is bound.\n   */\n  get onBindObservable() {\n    if (!this._onBindObservable) {\n      this._onBindObservable = new Observable();\n    }\n    return this._onBindObservable;\n  }\n  /**\n   * Instantiates an effect.\n   * An effect can be used to create/manage/execute vertex and fragment shaders.\n   * @param baseName Name of the effect.\n   * @param attributesNamesOrOptions List of attribute names that will be passed to the shader or set of all options to create the effect.\n   * @param uniformsNamesOrEngine List of uniform variable names that will be passed to the shader or the engine that will be used to render effect.\n   * @param samplers List of sampler variables that will be passed to the shader.\n   * @param engine Engine to be used to render the effect\n   * @param defines Define statements to be added to the shader.\n   * @param fallbacks Possible fallbacks for this effect to improve performance when needed.\n   * @param onCompiled Callback that will be called when the shader is compiled.\n   * @param onError Callback that will be called if an error occurs during shader compilation.\n   * @param indexParameters Parameters to be used with Babylons include syntax to iterate over an array (eg. \\{lights: 10\\})\n   * @param key Effect Key identifying uniquely compiled shader variants\n   * @param shaderLanguage the language the shader is written in (default: GLSL)\n   */\n  constructor(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers = null, engine, defines = null, fallbacks = null, onCompiled = null, onError = null, indexParameters, key = \"\", shaderLanguage = ShaderLanguage.GLSL) {\n    var _a, _b, _c;\n    /**\n     * Name of the effect.\n     */\n    this.name = null;\n    /**\n     * String container all the define statements that should be set on the shader.\n     */\n    this.defines = \"\";\n    /**\n     * Callback that will be called when the shader is compiled.\n     */\n    this.onCompiled = null;\n    /**\n     * Callback that will be called if an error occurs during shader compilation.\n     */\n    this.onError = null;\n    /**\n     * Callback that will be called when effect is bound.\n     */\n    this.onBind = null;\n    /**\n     * Unique ID of the effect.\n     */\n    this.uniqueId = 0;\n    /**\n     * Observable that will be called when the shader is compiled.\n     * It is recommended to use executeWhenCompile() or to make sure that scene.isReady() is called to get this observable raised.\n     */\n    this.onCompileObservable = new Observable();\n    /**\n     * Observable that will be called if an error occurs during shader compilation.\n     */\n    this.onErrorObservable = new Observable();\n    /** @internal */\n    this._onBindObservable = null;\n    /**\n     * @internal\n     * Specifies if the effect was previously ready\n     */\n    this._wasPreviouslyReady = false;\n    /**\n     * @internal\n     * Forces the code from bindForSubMesh to be fully run the next time it is called\n     * It is used in frozen mode to make sure the effect is properly rebound when a new effect is created\n     */\n    this._forceRebindOnNextCall = false;\n    /**\n     * @internal\n     * Specifies if the effect was previously using instances\n     */\n    this._wasPreviouslyUsingInstances = null;\n    this._isDisposed = false;\n    /** @internal */\n    this._bonesComputationForcedToCPU = false;\n    /** @internal */\n    this._uniformBuffersNames = {};\n    /** @internal */\n    this._multiTarget = false;\n    this._samplers = {};\n    this._isReady = false;\n    this._compilationError = \"\";\n    this._allFallbacksProcessed = false;\n    this._uniforms = {};\n    /**\n     * Key for the effect.\n     * @internal\n     */\n    this._key = \"\";\n    this._fallbacks = null;\n    this._vertexSourceCodeOverride = \"\";\n    this._fragmentSourceCodeOverride = \"\";\n    this._transformFeedbackVaryings = null;\n    /**\n     * Compiled shader to webGL program.\n     * @internal\n     */\n    this._pipelineContext = null;\n    /** @internal */\n    this._vertexSourceCode = \"\";\n    /** @internal */\n    this._fragmentSourceCode = \"\";\n    /** @internal */\n    this._vertexSourceCodeBeforeMigration = \"\";\n    /** @internal */\n    this._fragmentSourceCodeBeforeMigration = \"\";\n    /** @internal */\n    this._rawVertexSourceCode = \"\";\n    /** @internal */\n    this._rawFragmentSourceCode = \"\";\n    this._processCodeAfterIncludes = undefined;\n    this._processFinalCode = null;\n    this.name = baseName;\n    this._key = key;\n    if (attributesNamesOrOptions.attributes) {\n      const options = attributesNamesOrOptions;\n      this._engine = uniformsNamesOrEngine;\n      this._attributesNames = options.attributes;\n      this._uniformsNames = options.uniformsNames.concat(options.samplers);\n      this._samplerList = options.samplers.slice();\n      this.defines = options.defines;\n      this.onError = options.onError;\n      this.onCompiled = options.onCompiled;\n      this._fallbacks = options.fallbacks;\n      this._indexParameters = options.indexParameters;\n      this._transformFeedbackVaryings = options.transformFeedbackVaryings || null;\n      this._multiTarget = !!options.multiTarget;\n      this._shaderLanguage = (_a = options.shaderLanguage) !== null && _a !== void 0 ? _a : ShaderLanguage.GLSL;\n      if (options.uniformBuffersNames) {\n        this._uniformBuffersNamesList = options.uniformBuffersNames.slice();\n        for (let i = 0; i < options.uniformBuffersNames.length; i++) {\n          this._uniformBuffersNames[options.uniformBuffersNames[i]] = i;\n        }\n      }\n      this._processFinalCode = (_b = options.processFinalCode) !== null && _b !== void 0 ? _b : null;\n      this._processCodeAfterIncludes = (_c = options.processCodeAfterIncludes) !== null && _c !== void 0 ? _c : undefined;\n    } else {\n      this._engine = engine;\n      this.defines = defines == null ? \"\" : defines;\n      this._uniformsNames = uniformsNamesOrEngine.concat(samplers);\n      this._samplerList = samplers ? samplers.slice() : [];\n      this._attributesNames = attributesNamesOrOptions;\n      this._uniformBuffersNamesList = [];\n      this._shaderLanguage = shaderLanguage;\n      this.onError = onError;\n      this.onCompiled = onCompiled;\n      this._indexParameters = indexParameters;\n      this._fallbacks = fallbacks;\n    }\n    this._attributeLocationByName = {};\n    this.uniqueId = Effect._UniqueIdSeed++;\n    this._processShaderCode();\n  }\n  /** @internal */\n  _processShaderCode(shaderProcessor = null, keepExistingPipelineContext = false) {\n    let vertexSource;\n    let fragmentSource;\n    const baseName = this.name;\n    const hostDocument = IsWindowObjectExist() ? this._engine.getHostDocument() : null;\n    if (baseName.vertexSource) {\n      vertexSource = \"source:\" + baseName.vertexSource;\n    } else if (baseName.vertexElement) {\n      vertexSource = hostDocument ? hostDocument.getElementById(baseName.vertexElement) : null;\n      if (!vertexSource) {\n        vertexSource = baseName.vertexElement;\n      }\n    } else {\n      vertexSource = baseName.vertex || baseName;\n    }\n    if (baseName.fragmentSource) {\n      fragmentSource = \"source:\" + baseName.fragmentSource;\n    } else if (baseName.fragmentElement) {\n      fragmentSource = hostDocument ? hostDocument.getElementById(baseName.fragmentElement) : null;\n      if (!fragmentSource) {\n        fragmentSource = baseName.fragmentElement;\n      }\n    } else {\n      fragmentSource = baseName.fragment || baseName;\n    }\n    this._processingContext = this._engine._getShaderProcessingContext(this._shaderLanguage);\n    let processorOptions = {\n      defines: this.defines.split(\"\\n\"),\n      indexParameters: this._indexParameters,\n      isFragment: false,\n      shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,\n      processor: shaderProcessor !== null && shaderProcessor !== void 0 ? shaderProcessor : this._engine._getShaderProcessor(this._shaderLanguage),\n      supportsUniformBuffers: this._engine.supportsUniformBuffers,\n      shadersRepository: EngineShaderStore.GetShadersRepository(this._shaderLanguage),\n      includesShadersStore: EngineShaderStore.GetIncludesShadersStore(this._shaderLanguage),\n      version: (this._engine.version * 100).toString(),\n      platformName: this._engine.shaderPlatformName,\n      processingContext: this._processingContext,\n      isNDCHalfZRange: this._engine.isNDCHalfZRange,\n      useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\n      processCodeAfterIncludes: this._processCodeAfterIncludes\n    };\n    const shaderCodes = [undefined, undefined];\n    const shadersLoaded = () => {\n      if (shaderCodes[0] && shaderCodes[1]) {\n        processorOptions.isFragment = true;\n        const [migratedVertexCode, fragmentCode] = shaderCodes;\n        ShaderProcessor.Process(fragmentCode, processorOptions, (migratedFragmentCode, codeBeforeMigration) => {\n          this._fragmentSourceCodeBeforeMigration = codeBeforeMigration;\n          if (this._processFinalCode) {\n            migratedFragmentCode = this._processFinalCode(\"fragment\", migratedFragmentCode);\n          }\n          const finalShaders = ShaderProcessor.Finalize(migratedVertexCode, migratedFragmentCode, processorOptions);\n          processorOptions = null;\n          this._useFinalCode(finalShaders.vertexCode, finalShaders.fragmentCode, baseName, keepExistingPipelineContext);\n        }, this._engine);\n      }\n    };\n    this._loadShader(vertexSource, \"Vertex\", \"\", vertexCode => {\n      ShaderProcessor.Initialize(processorOptions);\n      ShaderProcessor.Process(vertexCode, processorOptions, (migratedVertexCode, codeBeforeMigration) => {\n        this._rawVertexSourceCode = vertexCode;\n        this._vertexSourceCodeBeforeMigration = codeBeforeMigration;\n        if (this._processFinalCode) {\n          migratedVertexCode = this._processFinalCode(\"vertex\", migratedVertexCode);\n        }\n        shaderCodes[0] = migratedVertexCode;\n        shadersLoaded();\n      }, this._engine);\n    });\n    this._loadShader(fragmentSource, \"Fragment\", \"Pixel\", fragmentCode => {\n      this._rawFragmentSourceCode = fragmentCode;\n      shaderCodes[1] = fragmentCode;\n      shadersLoaded();\n    });\n  }\n  _useFinalCode(migratedVertexCode, migratedFragmentCode, baseName, keepExistingPipelineContext = false) {\n    if (baseName) {\n      const vertex = baseName.vertexElement || baseName.vertex || baseName.spectorName || baseName;\n      const fragment = baseName.fragmentElement || baseName.fragment || baseName.spectorName || baseName;\n      this._vertexSourceCode = (this._shaderLanguage === ShaderLanguage.WGSL ? \"//\" : \"\") + \"#define SHADER_NAME vertex:\" + vertex + \"\\n\" + migratedVertexCode;\n      this._fragmentSourceCode = (this._shaderLanguage === ShaderLanguage.WGSL ? \"//\" : \"\") + \"#define SHADER_NAME fragment:\" + fragment + \"\\n\" + migratedFragmentCode;\n    } else {\n      this._vertexSourceCode = migratedVertexCode;\n      this._fragmentSourceCode = migratedFragmentCode;\n    }\n    this._prepareEffect(keepExistingPipelineContext);\n  }\n  /**\n   * Unique key for this effect\n   */\n  get key() {\n    return this._key;\n  }\n  /**\n   * If the effect has been compiled and prepared.\n   * @returns if the effect is compiled and prepared.\n   */\n  isReady() {\n    try {\n      return this._isReadyInternal();\n    } catch (_a) {\n      return false;\n    }\n  }\n  _isReadyInternal() {\n    if (this._isReady) {\n      return true;\n    }\n    if (this._pipelineContext) {\n      return this._pipelineContext.isReady;\n    }\n    return false;\n  }\n  /**\n   * The engine the effect was initialized with.\n   * @returns the engine.\n   */\n  getEngine() {\n    return this._engine;\n  }\n  /**\n   * The pipeline context for this effect\n   * @returns the associated pipeline context\n   */\n  getPipelineContext() {\n    return this._pipelineContext;\n  }\n  /**\n   * The set of names of attribute variables for the shader.\n   * @returns An array of attribute names.\n   */\n  getAttributesNames() {\n    return this._attributesNames;\n  }\n  /**\n   * Returns the attribute at the given index.\n   * @param index The index of the attribute.\n   * @returns The location of the attribute.\n   */\n  getAttributeLocation(index) {\n    return this._attributes[index];\n  }\n  /**\n   * Returns the attribute based on the name of the variable.\n   * @param name of the attribute to look up.\n   * @returns the attribute location.\n   */\n  getAttributeLocationByName(name) {\n    return this._attributeLocationByName[name];\n  }\n  /**\n   * The number of attributes.\n   * @returns the number of attributes.\n   */\n  getAttributesCount() {\n    return this._attributes.length;\n  }\n  /**\n   * Gets the index of a uniform variable.\n   * @param uniformName of the uniform to look up.\n   * @returns the index.\n   */\n  getUniformIndex(uniformName) {\n    return this._uniformsNames.indexOf(uniformName);\n  }\n  /**\n   * Returns the attribute based on the name of the variable.\n   * @param uniformName of the uniform to look up.\n   * @returns the location of the uniform.\n   */\n  getUniform(uniformName) {\n    return this._uniforms[uniformName];\n  }\n  /**\n   * Returns an array of sampler variable names\n   * @returns The array of sampler variable names.\n   */\n  getSamplers() {\n    return this._samplerList;\n  }\n  /**\n   * Returns an array of uniform variable names\n   * @returns The array of uniform variable names.\n   */\n  getUniformNames() {\n    return this._uniformsNames;\n  }\n  /**\n   * Returns an array of uniform buffer variable names\n   * @returns The array of uniform buffer variable names.\n   */\n  getUniformBuffersNames() {\n    return this._uniformBuffersNamesList;\n  }\n  /**\n   * Returns the index parameters used to create the effect\n   * @returns The index parameters object\n   */\n  getIndexParameters() {\n    return this._indexParameters;\n  }\n  /**\n   * The error from the last compilation.\n   * @returns the error string.\n   */\n  getCompilationError() {\n    return this._compilationError;\n  }\n  /**\n   * Gets a boolean indicating that all fallbacks were used during compilation\n   * @returns true if all fallbacks were used\n   */\n  allFallbacksProcessed() {\n    return this._allFallbacksProcessed;\n  }\n  /**\n   * Adds a callback to the onCompiled observable and call the callback immediately if already ready.\n   * @param func The callback to be used.\n   */\n  executeWhenCompiled(func) {\n    if (this.isReady()) {\n      func(this);\n      return;\n    }\n    this.onCompileObservable.add(effect => {\n      func(effect);\n    });\n    if (!this._pipelineContext || this._pipelineContext.isAsync) {\n      setTimeout(() => {\n        this._checkIsReady(null);\n      }, 16);\n    }\n  }\n  _checkIsReady(previousPipelineContext) {\n    try {\n      if (this._isReadyInternal()) {\n        return;\n      }\n    } catch (e) {\n      this._processCompilationErrors(e, previousPipelineContext);\n      return;\n    }\n    if (this._isDisposed) {\n      return;\n    }\n    setTimeout(() => {\n      this._checkIsReady(previousPipelineContext);\n    }, 16);\n  }\n  _loadShader(shader, key, optionalKey, callback) {\n    if (typeof HTMLElement !== \"undefined\") {\n      // DOM element ?\n      if (shader instanceof HTMLElement) {\n        const shaderCode = GetDOMTextContent(shader);\n        callback(shaderCode);\n        return;\n      }\n    }\n    // Direct source ?\n    if (shader.substr(0, 7) === \"source:\") {\n      callback(shader.substr(7));\n      return;\n    }\n    // Base64 encoded ?\n    if (shader.substr(0, 7) === \"base64:\") {\n      const shaderBinary = window.atob(shader.substr(7));\n      callback(shaderBinary);\n      return;\n    }\n    const shaderStore = EngineShaderStore.GetShadersStore(this._shaderLanguage);\n    // Is in local store ?\n    if (shaderStore[shader + key + \"Shader\"]) {\n      callback(shaderStore[shader + key + \"Shader\"]);\n      return;\n    }\n    if (optionalKey && shaderStore[shader + optionalKey + \"Shader\"]) {\n      callback(shaderStore[shader + optionalKey + \"Shader\"]);\n      return;\n    }\n    let shaderUrl;\n    if (shader[0] === \".\" || shader[0] === \"/\" || shader.indexOf(\"http\") > -1) {\n      shaderUrl = shader;\n    } else {\n      shaderUrl = EngineShaderStore.GetShadersRepository(this._shaderLanguage) + shader;\n    }\n    // Vertex shader\n    this._engine._loadFile(shaderUrl + \".\" + key.toLowerCase() + \".fx\", callback);\n  }\n  /**\n   * Gets the vertex shader source code of this effect\n   * This is the final source code that will be compiled, after all the processing has been done (pre-processing applied, code injection/replacement, etc)\n   */\n  get vertexSourceCode() {\n    var _a, _b;\n    return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._vertexSourceCodeOverride : (_b = (_a = this._pipelineContext) === null || _a === void 0 ? void 0 : _a._getVertexShaderCode()) !== null && _b !== void 0 ? _b : this._vertexSourceCode;\n  }\n  /**\n   * Gets the fragment shader source code of this effect\n   * This is the final source code that will be compiled, after all the processing has been done (pre-processing applied, code injection/replacement, etc)\n   */\n  get fragmentSourceCode() {\n    var _a, _b;\n    return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._fragmentSourceCodeOverride : (_b = (_a = this._pipelineContext) === null || _a === void 0 ? void 0 : _a._getFragmentShaderCode()) !== null && _b !== void 0 ? _b : this._fragmentSourceCode;\n  }\n  /**\n   * Gets the vertex shader source code before migration.\n   * This is the source code after the include directives have been replaced by their contents but before the code is migrated, i.e. before ShaderProcess._ProcessShaderConversion is executed.\n   * This method is, among other things, responsible for parsing #if/#define directives as well as converting GLES2 syntax to GLES3 (in the case of WebGL).\n   */\n  get vertexSourceCodeBeforeMigration() {\n    return this._vertexSourceCodeBeforeMigration;\n  }\n  /**\n   * Gets the fragment shader source code before migration.\n   * This is the source code after the include directives have been replaced by their contents but before the code is migrated, i.e. before ShaderProcess._ProcessShaderConversion is executed.\n   * This method is, among other things, responsible for parsing #if/#define directives as well as converting GLES2 syntax to GLES3 (in the case of WebGL).\n   */\n  get fragmentSourceCodeBeforeMigration() {\n    return this._fragmentSourceCodeBeforeMigration;\n  }\n  /**\n   * Gets the vertex shader source code before it has been modified by any processing\n   */\n  get rawVertexSourceCode() {\n    return this._rawVertexSourceCode;\n  }\n  /**\n   * Gets the fragment shader source code before it has been modified by any processing\n   */\n  get rawFragmentSourceCode() {\n    return this._rawFragmentSourceCode;\n  }\n  /**\n   * Recompiles the webGL program\n   * @param vertexSourceCode The source code for the vertex shader.\n   * @param fragmentSourceCode The source code for the fragment shader.\n   * @param onCompiled Callback called when completed.\n   * @param onError Callback called on error.\n   * @internal\n   */\n  _rebuildProgram(vertexSourceCode, fragmentSourceCode, onCompiled, onError) {\n    this._isReady = false;\n    this._vertexSourceCodeOverride = vertexSourceCode;\n    this._fragmentSourceCodeOverride = fragmentSourceCode;\n    this.onError = (effect, error) => {\n      if (onError) {\n        onError(error);\n      }\n    };\n    this.onCompiled = () => {\n      const scenes = this.getEngine().scenes;\n      if (scenes) {\n        for (let i = 0; i < scenes.length; i++) {\n          scenes[i].markAllMaterialsAsDirty(63);\n        }\n      }\n      this._pipelineContext._handlesSpectorRebuildCallback(onCompiled);\n    };\n    this._fallbacks = null;\n    this._prepareEffect();\n  }\n  /**\n   * Prepares the effect\n   * @internal\n   */\n  _prepareEffect(keepExistingPipelineContext = false) {\n    var _a;\n    const attributesNames = this._attributesNames;\n    const defines = this.defines;\n    const previousPipelineContext = this._pipelineContext;\n    this._isReady = false;\n    try {\n      const engine = this._engine;\n      this._pipelineContext = (_a = keepExistingPipelineContext ? previousPipelineContext : undefined) !== null && _a !== void 0 ? _a : engine.createPipelineContext(this._processingContext);\n      this._pipelineContext._name = this._key.replace(/\\r/g, \"\").replace(/\\n/g, \"|\");\n      const rebuildRebind = (vertexSourceCode, fragmentSourceCode, onCompiled, onError) => this._rebuildProgram(vertexSourceCode, fragmentSourceCode, onCompiled, onError);\n      if (this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride) {\n        engine._preparePipelineContext(this._pipelineContext, this._vertexSourceCodeOverride, this._fragmentSourceCodeOverride, true, this._rawVertexSourceCode, this._rawFragmentSourceCode, rebuildRebind, null, this._transformFeedbackVaryings, this._key);\n      } else {\n        engine._preparePipelineContext(this._pipelineContext, this._vertexSourceCode, this._fragmentSourceCode, false, this._rawVertexSourceCode, this._rawFragmentSourceCode, rebuildRebind, defines, this._transformFeedbackVaryings, this._key);\n      }\n      engine._executeWhenRenderingStateIsCompiled(this._pipelineContext, () => {\n        this._attributes = [];\n        this._pipelineContext._fillEffectInformation(this, this._uniformBuffersNames, this._uniformsNames, this._uniforms, this._samplerList, this._samplers, attributesNames, this._attributes);\n        // Caches attribute locations.\n        if (attributesNames) {\n          for (let i = 0; i < attributesNames.length; i++) {\n            const name = attributesNames[i];\n            this._attributeLocationByName[name] = this._attributes[i];\n          }\n        }\n        engine.bindSamplers(this);\n        this._compilationError = \"\";\n        this._isReady = true;\n        if (this.onCompiled) {\n          this.onCompiled(this);\n        }\n        this.onCompileObservable.notifyObservers(this);\n        this.onCompileObservable.clear();\n        // Unbind mesh reference in fallbacks\n        if (this._fallbacks) {\n          this._fallbacks.unBindMesh();\n        }\n        if (previousPipelineContext && !keepExistingPipelineContext) {\n          this.getEngine()._deletePipelineContext(previousPipelineContext);\n        }\n      });\n      if (this._pipelineContext.isAsync) {\n        this._checkIsReady(previousPipelineContext);\n      }\n    } catch (e) {\n      this._processCompilationErrors(e, previousPipelineContext);\n    }\n  }\n  _getShaderCodeAndErrorLine(code, error, isFragment) {\n    const regexp = isFragment ? /FRAGMENT SHADER ERROR: 0:(\\d+?):/ : /VERTEX SHADER ERROR: 0:(\\d+?):/;\n    let errorLine = null;\n    if (error && code) {\n      const res = error.match(regexp);\n      if (res && res.length === 2) {\n        const lineNumber = parseInt(res[1]);\n        const lines = code.split(\"\\n\", -1);\n        if (lines.length >= lineNumber) {\n          errorLine = `Offending line [${lineNumber}] in ${isFragment ? \"fragment\" : \"vertex\"} code: ${lines[lineNumber - 1]}`;\n        }\n      }\n    }\n    return [code, errorLine];\n  }\n  _processCompilationErrors(e, previousPipelineContext = null) {\n    var _a, _b, _c;\n    this._compilationError = e.message;\n    const attributesNames = this._attributesNames;\n    const fallbacks = this._fallbacks;\n    // Let's go through fallbacks then\n    Logger.Error(\"Unable to compile effect:\");\n    Logger.Error(\"Uniforms: \" + this._uniformsNames.map(function (uniform) {\n      return \" \" + uniform;\n    }));\n    Logger.Error(\"Attributes: \" + attributesNames.map(function (attribute) {\n      return \" \" + attribute;\n    }));\n    Logger.Error(\"Defines:\\n\" + this.defines);\n    if (Effect.LogShaderCodeOnCompilationError) {\n      let lineErrorVertex = null,\n        lineErrorFragment = null,\n        code = null;\n      if ((_a = this._pipelineContext) === null || _a === void 0 ? void 0 : _a._getVertexShaderCode()) {\n        [code, lineErrorVertex] = this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(), this._compilationError, false);\n        if (code) {\n          Logger.Error(\"Vertex code:\");\n          Logger.Error(code);\n        }\n      }\n      if ((_b = this._pipelineContext) === null || _b === void 0 ? void 0 : _b._getFragmentShaderCode()) {\n        [code, lineErrorFragment] = this._getShaderCodeAndErrorLine((_c = this._pipelineContext) === null || _c === void 0 ? void 0 : _c._getFragmentShaderCode(), this._compilationError, true);\n        if (code) {\n          Logger.Error(\"Fragment code:\");\n          Logger.Error(code);\n        }\n      }\n      if (lineErrorVertex) {\n        Logger.Error(lineErrorVertex);\n      }\n      if (lineErrorFragment) {\n        Logger.Error(lineErrorFragment);\n      }\n    }\n    Logger.Error(\"Error: \" + this._compilationError);\n    const notifyErrors = () => {\n      if (this.onError) {\n        this.onError(this, this._compilationError);\n      }\n      this.onErrorObservable.notifyObservers(this);\n    };\n    // In case a previous compilation was successful, we need to restore the previous pipeline context\n    if (previousPipelineContext) {\n      this._pipelineContext = previousPipelineContext;\n      this._isReady = true;\n      notifyErrors();\n    }\n    // Lets try to compile fallbacks as long as we have some.\n    if (fallbacks) {\n      this._pipelineContext = null;\n      if (fallbacks.hasMoreFallbacks) {\n        this._allFallbacksProcessed = false;\n        Logger.Error(\"Trying next fallback.\");\n        this.defines = fallbacks.reduce(this.defines, this);\n        this._prepareEffect();\n      } else {\n        // Sorry we did everything we can\n        this._allFallbacksProcessed = true;\n        notifyErrors();\n        this.onErrorObservable.clear();\n        // Unbind mesh reference in fallbacks\n        if (this._fallbacks) {\n          this._fallbacks.unBindMesh();\n        }\n      }\n    } else {\n      this._allFallbacksProcessed = true;\n      // In case of error, without any prior successful compilation, let s notify observers\n      if (!previousPipelineContext) {\n        notifyErrors();\n      }\n    }\n  }\n  /**\n   * Checks if the effect is supported. (Must be called after compilation)\n   */\n  get isSupported() {\n    return this._compilationError === \"\";\n  }\n  /**\n   * Binds a texture to the engine to be used as output of the shader.\n   * @param channel Name of the output variable.\n   * @param texture Texture to bind.\n   * @internal\n   */\n  _bindTexture(channel, texture) {\n    this._engine._bindTexture(this._samplers[channel], texture, channel);\n  }\n  /**\n   * Sets a texture on the engine to be used in the shader.\n   * @param channel Name of the sampler variable.\n   * @param texture Texture to set.\n   */\n  setTexture(channel, texture) {\n    this._engine.setTexture(this._samplers[channel], this._uniforms[channel], texture, channel);\n  }\n  /**\n   * Sets a depth stencil texture from a render target on the engine to be used in the shader.\n   * @param channel Name of the sampler variable.\n   * @param texture Texture to set.\n   */\n  setDepthStencilTexture(channel, texture) {\n    this._engine.setDepthStencilTexture(this._samplers[channel], this._uniforms[channel], texture, channel);\n  }\n  /**\n   * Sets an array of textures on the engine to be used in the shader.\n   * @param channel Name of the variable.\n   * @param textures Textures to set.\n   */\n  setTextureArray(channel, textures) {\n    const exName = channel + \"Ex\";\n    if (this._samplerList.indexOf(exName + \"0\") === -1) {\n      const initialPos = this._samplerList.indexOf(channel);\n      for (let index = 1; index < textures.length; index++) {\n        const currentExName = exName + (index - 1).toString();\n        this._samplerList.splice(initialPos + index, 0, currentExName);\n      }\n      // Reset every channels\n      let channelIndex = 0;\n      for (const key of this._samplerList) {\n        this._samplers[key] = channelIndex;\n        channelIndex += 1;\n      }\n    }\n    this._engine.setTextureArray(this._samplers[channel], this._uniforms[channel], textures, channel);\n  }\n  /**\n   * Sets a texture to be the input of the specified post process. (To use the output, pass in the next post process in the pipeline)\n   * @param channel Name of the sampler variable.\n   * @param postProcess Post process to get the input texture from.\n   */\n  setTextureFromPostProcess(channel, postProcess) {\n    this._engine.setTextureFromPostProcess(this._samplers[channel], postProcess, channel);\n  }\n  /**\n   * (Warning! setTextureFromPostProcessOutput may be desired instead)\n   * Sets the input texture of the passed in post process to be input of this effect. (To use the output of the passed in post process use setTextureFromPostProcessOutput)\n   * @param channel Name of the sampler variable.\n   * @param postProcess Post process to get the output texture from.\n   */\n  setTextureFromPostProcessOutput(channel, postProcess) {\n    this._engine.setTextureFromPostProcessOutput(this._samplers[channel], postProcess, channel);\n  }\n  /**\n   * Binds a buffer to a uniform.\n   * @param buffer Buffer to bind.\n   * @param name Name of the uniform variable to bind to.\n   */\n  bindUniformBuffer(buffer, name) {\n    const bufferName = this._uniformBuffersNames[name];\n    if (bufferName === undefined || Effect._BaseCache[bufferName] === buffer && this._engine._features.useUBOBindingCache) {\n      return;\n    }\n    Effect._BaseCache[bufferName] = buffer;\n    this._engine.bindUniformBufferBase(buffer, bufferName, name);\n  }\n  /**\n   * Binds block to a uniform.\n   * @param blockName Name of the block to bind.\n   * @param index Index to bind.\n   */\n  bindUniformBlock(blockName, index) {\n    this._engine.bindUniformBlock(this._pipelineContext, blockName, index);\n  }\n  /**\n   * Sets an integer value on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param value Value to be set.\n   * @returns this effect.\n   */\n  setInt(uniformName, value) {\n    this._pipelineContext.setInt(uniformName, value);\n    return this;\n  }\n  /**\n   * Sets an int2 value on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param x First int in int2.\n   * @param y Second int in int2.\n   * @returns this effect.\n   */\n  setInt2(uniformName, x, y) {\n    this._pipelineContext.setInt2(uniformName, x, y);\n    return this;\n  }\n  /**\n   * Sets an int3 value on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param x First int in int3.\n   * @param y Second int in int3.\n   * @param z Third int in int3.\n   * @returns this effect.\n   */\n  setInt3(uniformName, x, y, z) {\n    this._pipelineContext.setInt3(uniformName, x, y, z);\n    return this;\n  }\n  /**\n   * Sets an int4 value on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param x First int in int4.\n   * @param y Second int in int4.\n   * @param z Third int in int4.\n   * @param w Fourth int in int4.\n   * @returns this effect.\n   */\n  setInt4(uniformName, x, y, z, w) {\n    this._pipelineContext.setInt4(uniformName, x, y, z, w);\n    return this;\n  }\n  /**\n   * Sets an int array on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setIntArray(uniformName, array) {\n    this._pipelineContext.setIntArray(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setIntArray2(uniformName, array) {\n    this._pipelineContext.setIntArray2(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setIntArray3(uniformName, array) {\n    this._pipelineContext.setIntArray3(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setIntArray4(uniformName, array) {\n    this._pipelineContext.setIntArray4(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an unsigned integer value on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param value Value to be set.\n   * @returns this effect.\n   */\n  setUInt(uniformName, value) {\n    this._pipelineContext.setUInt(uniformName, value);\n    return this;\n  }\n  /**\n   * Sets an unsigned int2 value on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param x First unsigned int in uint2.\n   * @param y Second unsigned int in uint2.\n   * @returns this effect.\n   */\n  setUInt2(uniformName, x, y) {\n    this._pipelineContext.setUInt2(uniformName, x, y);\n    return this;\n  }\n  /**\n   * Sets an unsigned int3 value on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param x First unsigned int in uint3.\n   * @param y Second unsigned int in uint3.\n   * @param z Third unsigned int in uint3.\n   * @returns this effect.\n   */\n  setUInt3(uniformName, x, y, z) {\n    this._pipelineContext.setUInt3(uniformName, x, y, z);\n    return this;\n  }\n  /**\n   * Sets an unsigned int4 value on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param x First unsigned int in uint4.\n   * @param y Second unsigned int in uint4.\n   * @param z Third unsigned int in uint4.\n   * @param w Fourth unsigned int in uint4.\n   * @returns this effect.\n   */\n  setUInt4(uniformName, x, y, z, w) {\n    this._pipelineContext.setUInt4(uniformName, x, y, z, w);\n    return this;\n  }\n  /**\n   * Sets an unsigned int array on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setUIntArray(uniformName, array) {\n    this._pipelineContext.setUIntArray(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an unsigned int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setUIntArray2(uniformName, array) {\n    this._pipelineContext.setUIntArray2(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an unsigned int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setUIntArray3(uniformName, array) {\n    this._pipelineContext.setUIntArray3(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an unsigned int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setUIntArray4(uniformName, array) {\n    this._pipelineContext.setUIntArray4(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an float array on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setFloatArray(uniformName, array) {\n    this._pipelineContext.setArray(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an float array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setFloatArray2(uniformName, array) {\n    this._pipelineContext.setArray2(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an float array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setFloatArray3(uniformName, array) {\n    this._pipelineContext.setArray3(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an float array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setFloatArray4(uniformName, array) {\n    this._pipelineContext.setArray4(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an array on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setArray(uniformName, array) {\n    this._pipelineContext.setArray(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setArray2(uniformName, array) {\n    this._pipelineContext.setArray2(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setArray3(uniformName, array) {\n    this._pipelineContext.setArray3(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setArray4(uniformName, array) {\n    this._pipelineContext.setArray4(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets matrices on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param matrices matrices to be set.\n   * @returns this effect.\n   */\n  setMatrices(uniformName, matrices) {\n    this._pipelineContext.setMatrices(uniformName, matrices);\n    return this;\n  }\n  /**\n   * Sets matrix on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param matrix matrix to be set.\n   * @returns this effect.\n   */\n  setMatrix(uniformName, matrix) {\n    this._pipelineContext.setMatrix(uniformName, matrix);\n    return this;\n  }\n  /**\n   * Sets a 3x3 matrix on a uniform variable. (Specified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)\n   * @param uniformName Name of the variable.\n   * @param matrix matrix to be set.\n   * @returns this effect.\n   */\n  setMatrix3x3(uniformName, matrix) {\n    // the cast is ok because it is gl.uniformMatrix3fv() which is called at the end, and this function accepts Float32Array and Array<number>\n    this._pipelineContext.setMatrix3x3(uniformName, matrix);\n    return this;\n  }\n  /**\n   * Sets a 2x2 matrix on a uniform variable. (Specified as [1,2,3,4] will result in [1,2][3,4] matrix)\n   * @param uniformName Name of the variable.\n   * @param matrix matrix to be set.\n   * @returns this effect.\n   */\n  setMatrix2x2(uniformName, matrix) {\n    // the cast is ok because it is gl.uniformMatrix3fv() which is called at the end, and this function accepts Float32Array and Array<number>\n    this._pipelineContext.setMatrix2x2(uniformName, matrix);\n    return this;\n  }\n  /**\n   * Sets a float on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param value value to be set.\n   * @returns this effect.\n   */\n  setFloat(uniformName, value) {\n    this._pipelineContext.setFloat(uniformName, value);\n    return this;\n  }\n  /**\n   * Sets a boolean on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param bool value to be set.\n   * @returns this effect.\n   */\n  setBool(uniformName, bool) {\n    this._pipelineContext.setInt(uniformName, bool ? 1 : 0);\n    return this;\n  }\n  /**\n   * Sets a Vector2 on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param vector2 vector2 to be set.\n   * @returns this effect.\n   */\n  setVector2(uniformName, vector2) {\n    this._pipelineContext.setVector2(uniformName, vector2);\n    return this;\n  }\n  /**\n   * Sets a float2 on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param x First float in float2.\n   * @param y Second float in float2.\n   * @returns this effect.\n   */\n  setFloat2(uniformName, x, y) {\n    this._pipelineContext.setFloat2(uniformName, x, y);\n    return this;\n  }\n  /**\n   * Sets a Vector3 on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param vector3 Value to be set.\n   * @returns this effect.\n   */\n  setVector3(uniformName, vector3) {\n    this._pipelineContext.setVector3(uniformName, vector3);\n    return this;\n  }\n  /**\n   * Sets a float3 on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param x First float in float3.\n   * @param y Second float in float3.\n   * @param z Third float in float3.\n   * @returns this effect.\n   */\n  setFloat3(uniformName, x, y, z) {\n    this._pipelineContext.setFloat3(uniformName, x, y, z);\n    return this;\n  }\n  /**\n   * Sets a Vector4 on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param vector4 Value to be set.\n   * @returns this effect.\n   */\n  setVector4(uniformName, vector4) {\n    this._pipelineContext.setVector4(uniformName, vector4);\n    return this;\n  }\n  /**\n   * Sets a Quaternion on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param quaternion Value to be set.\n   * @returns this effect.\n   */\n  setQuaternion(uniformName, quaternion) {\n    this._pipelineContext.setQuaternion(uniformName, quaternion);\n    return this;\n  }\n  /**\n   * Sets a float4 on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param x First float in float4.\n   * @param y Second float in float4.\n   * @param z Third float in float4.\n   * @param w Fourth float in float4.\n   * @returns this effect.\n   */\n  setFloat4(uniformName, x, y, z, w) {\n    this._pipelineContext.setFloat4(uniformName, x, y, z, w);\n    return this;\n  }\n  /**\n   * Sets a Color3 on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param color3 Value to be set.\n   * @returns this effect.\n   */\n  setColor3(uniformName, color3) {\n    this._pipelineContext.setColor3(uniformName, color3);\n    return this;\n  }\n  /**\n   * Sets a Color4 on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param color3 Value to be set.\n   * @param alpha Alpha value to be set.\n   * @returns this effect.\n   */\n  setColor4(uniformName, color3, alpha) {\n    this._pipelineContext.setColor4(uniformName, color3, alpha);\n    return this;\n  }\n  /**\n   * Sets a Color4 on a uniform variable\n   * @param uniformName defines the name of the variable\n   * @param color4 defines the value to be set\n   * @returns this effect.\n   */\n  setDirectColor4(uniformName, color4) {\n    this._pipelineContext.setDirectColor4(uniformName, color4);\n    return this;\n  }\n  /**\n   * Release all associated resources.\n   **/\n  dispose() {\n    if (this._pipelineContext) {\n      this._pipelineContext.dispose();\n    }\n    this._engine._releaseEffect(this);\n    this._isDisposed = true;\n  }\n  /**\n   * This function will add a new shader to the shader store\n   * @param name the name of the shader\n   * @param pixelShader optional pixel shader content\n   * @param vertexShader optional vertex shader content\n   * @param shaderLanguage the language the shader is written in (default: GLSL)\n   */\n  static RegisterShader(name, pixelShader, vertexShader, shaderLanguage = ShaderLanguage.GLSL) {\n    if (pixelShader) {\n      EngineShaderStore.GetShadersStore(shaderLanguage)[`${name}PixelShader`] = pixelShader;\n    }\n    if (vertexShader) {\n      EngineShaderStore.GetShadersStore(shaderLanguage)[`${name}VertexShader`] = vertexShader;\n    }\n  }\n  /**\n   * Resets the cache of effects.\n   */\n  static ResetCache() {\n    Effect._BaseCache = {};\n  }\n}\n/**\n * Enable logging of the shader code when a compilation error occurs\n */\nEffect.LogShaderCodeOnCompilationError = true;\nEffect._UniqueIdSeed = 0;\nEffect._BaseCache = {};\n/**\n * Store of each shader (The can be looked up using effect.key)\n */\nEffect.ShadersStore = EngineShaderStore.ShadersStore;\n/**\n * Store of each included file for a shader (The can be looked up using effect.key)\n */\nEffect.IncludesShadersStore = EngineShaderStore.IncludesShadersStore;","map":{"version":3,"names":["Observable","GetDOMTextContent","IsWindowObjectExist","Logger","ShaderProcessor","ShaderStore","EngineShaderStore","ShaderLanguage","Effect","ShadersRepository","repo","onBindObservable","_onBindObservable","constructor","baseName","attributesNamesOrOptions","uniformsNamesOrEngine","samplers","engine","defines","fallbacks","onCompiled","onError","indexParameters","key","shaderLanguage","GLSL","name","onBind","uniqueId","onCompileObservable","onErrorObservable","_wasPreviouslyReady","_forceRebindOnNextCall","_wasPreviouslyUsingInstances","_isDisposed","_bonesComputationForcedToCPU","_uniformBuffersNames","_multiTarget","_samplers","_isReady","_compilationError","_allFallbacksProcessed","_uniforms","_key","_fallbacks","_vertexSourceCodeOverride","_fragmentSourceCodeOverride","_transformFeedbackVaryings","_pipelineContext","_vertexSourceCode","_fragmentSourceCode","_vertexSourceCodeBeforeMigration","_fragmentSourceCodeBeforeMigration","_rawVertexSourceCode","_rawFragmentSourceCode","_processCodeAfterIncludes","undefined","_processFinalCode","attributes","options","_engine","_attributesNames","_uniformsNames","uniformsNames","concat","_samplerList","slice","_indexParameters","transformFeedbackVaryings","multiTarget","_shaderLanguage","_a","uniformBuffersNames","_uniformBuffersNamesList","i","length","_b","processFinalCode","_c","processCodeAfterIncludes","_attributeLocationByName","_UniqueIdSeed","_processShaderCode","shaderProcessor","keepExistingPipelineContext","vertexSource","fragmentSource","hostDocument","getHostDocument","vertexElement","getElementById","vertex","fragmentElement","fragment","_processingContext","_getShaderProcessingContext","processorOptions","split","isFragment","shouldUseHighPrecisionShader","_shouldUseHighPrecisionShader","processor","_getShaderProcessor","supportsUniformBuffers","shadersRepository","GetShadersRepository","includesShadersStore","GetIncludesShadersStore","version","toString","platformName","shaderPlatformName","processingContext","isNDCHalfZRange","useReverseDepthBuffer","shaderCodes","shadersLoaded","migratedVertexCode","fragmentCode","Process","migratedFragmentCode","codeBeforeMigration","finalShaders","Finalize","_useFinalCode","vertexCode","_loadShader","Initialize","spectorName","WGSL","_prepareEffect","isReady","_isReadyInternal","getEngine","getPipelineContext","getAttributesNames","getAttributeLocation","index","_attributes","getAttributeLocationByName","getAttributesCount","getUniformIndex","uniformName","indexOf","getUniform","getSamplers","getUniformNames","getUniformBuffersNames","getIndexParameters","getCompilationError","allFallbacksProcessed","executeWhenCompiled","func","add","effect","isAsync","setTimeout","_checkIsReady","previousPipelineContext","e","_processCompilationErrors","shader","optionalKey","callback","HTMLElement","shaderCode","substr","shaderBinary","window","atob","shaderStore","GetShadersStore","shaderUrl","_loadFile","toLowerCase","vertexSourceCode","_getVertexShaderCode","fragmentSourceCode","_getFragmentShaderCode","vertexSourceCodeBeforeMigration","fragmentSourceCodeBeforeMigration","rawVertexSourceCode","rawFragmentSourceCode","_rebuildProgram","error","scenes","markAllMaterialsAsDirty","_handlesSpectorRebuildCallback","attributesNames","createPipelineContext","_name","replace","rebuildRebind","_preparePipelineContext","_executeWhenRenderingStateIsCompiled","_fillEffectInformation","bindSamplers","notifyObservers","clear","unBindMesh","_deletePipelineContext","_getShaderCodeAndErrorLine","code","regexp","errorLine","res","match","lineNumber","parseInt","lines","message","Error","map","uniform","attribute","LogShaderCodeOnCompilationError","lineErrorVertex","lineErrorFragment","notifyErrors","hasMoreFallbacks","reduce","isSupported","_bindTexture","channel","texture","setTexture","setDepthStencilTexture","setTextureArray","textures","exName","initialPos","currentExName","splice","channelIndex","setTextureFromPostProcess","postProcess","setTextureFromPostProcessOutput","bindUniformBuffer","buffer","bufferName","_BaseCache","_features","useUBOBindingCache","bindUniformBufferBase","bindUniformBlock","blockName","setInt","value","setInt2","x","y","setInt3","z","setInt4","w","setIntArray","array","setIntArray2","setIntArray3","setIntArray4","setUInt","setUInt2","setUInt3","setUInt4","setUIntArray","setUIntArray2","setUIntArray3","setUIntArray4","setFloatArray","setArray","setFloatArray2","setArray2","setFloatArray3","setArray3","setFloatArray4","setArray4","setMatrices","matrices","setMatrix","matrix","setMatrix3x3","setMatrix2x2","setFloat","setBool","bool","setVector2","vector2","setFloat2","setVector3","vector3","setFloat3","setVector4","vector4","setQuaternion","quaternion","setFloat4","setColor3","color3","setColor4","alpha","setDirectColor4","color4","dispose","_releaseEffect","RegisterShader","pixelShader","vertexShader","ResetCache","ShadersStore","IncludesShadersStore"],"sources":["../../../../dev/core/src/Materials/effect.ts"],"sourcesContent":["import { Observable } from \"../Misc/observable\";\r\nimport type { FloatArray, Nullable } from \"../types\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { GetDOMTextContent, IsWindowObjectExist } from \"../Misc/domManagement\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { IDisposable } from \"../scene\";\r\nimport type { IPipelineContext } from \"../Engines/IPipelineContext\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor\";\r\nimport type { IShaderProcessor } from \"../Engines/Processors/iShaderProcessor\";\r\nimport type { ProcessingOptions, ShaderCustomProcessingFunction, ShaderProcessingContext } from \"../Engines/Processors/shaderProcessingOptions\";\r\nimport type { IMatrixLike, IVector2Like, IVector3Like, IVector4Like, IColor3Like, IColor4Like, IQuaternionLike } from \"../Maths/math.like\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport type { IEffectFallbacks } from \"./iEffectFallbacks\";\r\nimport { ShaderStore as EngineShaderStore } from \"../Engines/shaderStore\";\r\nimport { ShaderLanguage } from \"./shaderLanguage\";\r\n\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport type { ThinTexture } from \"../Materials/Textures/thinTexture\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { PostProcess } from \"../PostProcesses/postProcess\";\r\n\r\n/**\r\n * Options to be used when creating an effect.\r\n */\r\nexport interface IEffectCreationOptions {\r\n    /**\r\n     * Attributes that will be used in the shader.\r\n     */\r\n    attributes: string[];\r\n    /**\r\n     * Uniform variable names that will be set in the shader.\r\n     */\r\n    uniformsNames: string[];\r\n    /**\r\n     * Uniform buffer variable names that will be set in the shader.\r\n     */\r\n    uniformBuffersNames: string[];\r\n    /**\r\n     * Sampler texture variable names that will be set in the shader.\r\n     */\r\n    samplers: string[];\r\n    /**\r\n     * Define statements that will be set in the shader.\r\n     */\r\n    defines: any;\r\n    /**\r\n     * Possible fallbacks for this effect to improve performance when needed.\r\n     */\r\n    fallbacks: Nullable<IEffectFallbacks>;\r\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\r\n    onCompiled: Nullable<(effect: Effect) => void>;\r\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\r\n    onError: Nullable<(effect: Effect, errors: string) => void>;\r\n    /**\r\n     * Parameters to be used with Babylons include syntax to iterate over an array (eg. \\{lights: 10\\})\r\n     */\r\n    indexParameters?: any;\r\n    /**\r\n     * Max number of lights that can be used in the shader.\r\n     */\r\n    maxSimultaneousLights?: number;\r\n    /**\r\n     * See https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/transformFeedbackVaryings\r\n     */\r\n    transformFeedbackVaryings?: Nullable<string[]>;\r\n    /**\r\n     * If provided, will be called two times with the vertex and fragment code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<ShaderCustomProcessingFunction>;\r\n    /**\r\n     * If provided, will be called two times with the vertex and fragment code so that this code can be updated after the #include have been processed\r\n     */\r\n    processCodeAfterIncludes?: Nullable<ShaderCustomProcessingFunction>;\r\n    /**\r\n     * Is this effect rendering to several color attachments ?\r\n     */\r\n    multiTarget?: boolean;\r\n    /**\r\n     * The language the shader is written in (default: GLSL)\r\n     */\r\n    shaderLanguage?: ShaderLanguage;\r\n}\r\n\r\n/**\r\n * Effect containing vertex and fragment shader that can be executed on an object.\r\n */\r\nexport class Effect implements IDisposable {\r\n    /**\r\n     * Gets or sets the relative url used to load shaders if using the engine in non-minified mode\r\n     */\r\n    public static get ShadersRepository(): string {\r\n        return EngineShaderStore.ShadersRepository;\r\n    }\r\n    public static set ShadersRepository(repo: string) {\r\n        EngineShaderStore.ShadersRepository = repo;\r\n    }\r\n    /**\r\n     * Enable logging of the shader code when a compilation error occurs\r\n     */\r\n    public static LogShaderCodeOnCompilationError = true;\r\n    /**\r\n     * Name of the effect.\r\n     */\r\n    public name: any = null;\r\n    /**\r\n     * String container all the define statements that should be set on the shader.\r\n     */\r\n    public defines: string = \"\";\r\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\r\n    public onCompiled: Nullable<(effect: Effect) => void> = null;\r\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\r\n    public onError: Nullable<(effect: Effect, errors: string) => void> = null;\r\n    /**\r\n     * Callback that will be called when effect is bound.\r\n     */\r\n    public onBind: Nullable<(effect: Effect) => void> = null;\r\n    /**\r\n     * Unique ID of the effect.\r\n     */\r\n    public uniqueId = 0;\r\n    /**\r\n     * Observable that will be called when the shader is compiled.\r\n     * It is recommended to use executeWhenCompile() or to make sure that scene.isReady() is called to get this observable raised.\r\n     */\r\n    public onCompileObservable = new Observable<Effect>();\r\n    /**\r\n     * Observable that will be called if an error occurs during shader compilation.\r\n     */\r\n    public onErrorObservable = new Observable<Effect>();\r\n\r\n    /** @internal */\r\n    public _onBindObservable: Nullable<Observable<Effect>> = null;\r\n\r\n    /**\r\n     * @internal\r\n     * Specifies if the effect was previously ready\r\n     */\r\n    public _wasPreviouslyReady = false;\r\n\r\n    /**\r\n     * @internal\r\n     * Forces the code from bindForSubMesh to be fully run the next time it is called\r\n     * It is used in frozen mode to make sure the effect is properly rebound when a new effect is created\r\n     */\r\n    public _forceRebindOnNextCall = false;\r\n\r\n    /**\r\n     * @internal\r\n     * Specifies if the effect was previously using instances\r\n     */\r\n    public _wasPreviouslyUsingInstances: Nullable<boolean> = null;\r\n\r\n    private _isDisposed = false;\r\n\r\n    /**\r\n     * Observable that will be called when effect is bound.\r\n     */\r\n    public get onBindObservable(): Observable<Effect> {\r\n        if (!this._onBindObservable) {\r\n            this._onBindObservable = new Observable<Effect>();\r\n        }\r\n\r\n        return this._onBindObservable;\r\n    }\r\n\r\n    /** @internal */\r\n    public _bonesComputationForcedToCPU = false;\r\n    /** @internal */\r\n    public _uniformBuffersNames: { [key: string]: number } = {};\r\n    /** @internal */\r\n    public _samplerList: string[];\r\n    /** @internal */\r\n    public _multiTarget: boolean = false;\r\n\r\n    private static _UniqueIdSeed = 0;\r\n    /** @internal */\r\n    public _engine: Engine;\r\n    private _uniformBuffersNamesList: string[];\r\n    private _uniformsNames: string[];\r\n    private _samplers: { [key: string]: number } = {};\r\n    private _isReady = false;\r\n    private _compilationError = \"\";\r\n    private _allFallbacksProcessed = false;\r\n    private _attributesNames: string[];\r\n    private _attributes: number[];\r\n    private _attributeLocationByName: { [name: string]: number };\r\n    private _uniforms: { [key: string]: Nullable<WebGLUniformLocation> } = {};\r\n    /**\r\n     * Key for the effect.\r\n     * @internal\r\n     */\r\n    public _key: string = \"\";\r\n    private _indexParameters: any;\r\n    private _fallbacks: Nullable<IEffectFallbacks> = null;\r\n    private _vertexSourceCodeOverride: string = \"\";\r\n    private _fragmentSourceCodeOverride: string = \"\";\r\n    private _transformFeedbackVaryings: Nullable<string[]> = null;\r\n    private _shaderLanguage: ShaderLanguage;\r\n    /**\r\n     * Compiled shader to webGL program.\r\n     * @internal\r\n     */\r\n    public _pipelineContext: Nullable<IPipelineContext> = null;\r\n    /** @internal */\r\n    public _vertexSourceCode: string = \"\";\r\n    /** @internal */\r\n    public _fragmentSourceCode: string = \"\";\r\n\r\n    /** @internal */\r\n    private _vertexSourceCodeBeforeMigration: string = \"\";\r\n    /** @internal */\r\n    private _fragmentSourceCodeBeforeMigration: string = \"\";\r\n\r\n    /** @internal */\r\n    private _rawVertexSourceCode: string = \"\";\r\n    /** @internal */\r\n    private _rawFragmentSourceCode: string = \"\";\r\n\r\n    private static _BaseCache: { [key: number]: DataBuffer } = {};\r\n    private _processingContext: Nullable<ShaderProcessingContext>;\r\n\r\n    private _processCodeAfterIncludes: ShaderCustomProcessingFunction | undefined = undefined;\r\n    private _processFinalCode: Nullable<ShaderCustomProcessingFunction> = null;\r\n\r\n    /**\r\n     * Instantiates an effect.\r\n     * An effect can be used to create/manage/execute vertex and fragment shaders.\r\n     * @param baseName Name of the effect.\r\n     * @param attributesNamesOrOptions List of attribute names that will be passed to the shader or set of all options to create the effect.\r\n     * @param uniformsNamesOrEngine List of uniform variable names that will be passed to the shader or the engine that will be used to render effect.\r\n     * @param samplers List of sampler variables that will be passed to the shader.\r\n     * @param engine Engine to be used to render the effect\r\n     * @param defines Define statements to be added to the shader.\r\n     * @param fallbacks Possible fallbacks for this effect to improve performance when needed.\r\n     * @param onCompiled Callback that will be called when the shader is compiled.\r\n     * @param onError Callback that will be called if an error occurs during shader compilation.\r\n     * @param indexParameters Parameters to be used with Babylons include syntax to iterate over an array (eg. \\{lights: 10\\})\r\n     * @param key Effect Key identifying uniquely compiled shader variants\r\n     * @param shaderLanguage the language the shader is written in (default: GLSL)\r\n     */\r\n    constructor(\r\n        baseName: any,\r\n        attributesNamesOrOptions: string[] | IEffectCreationOptions,\r\n        uniformsNamesOrEngine: string[] | ThinEngine,\r\n        samplers: Nullable<string[]> = null,\r\n        engine?: ThinEngine,\r\n        defines: Nullable<string> = null,\r\n        fallbacks: Nullable<IEffectFallbacks> = null,\r\n        onCompiled: Nullable<(effect: Effect) => void> = null,\r\n        onError: Nullable<(effect: Effect, errors: string) => void> = null,\r\n        indexParameters?: any,\r\n        key: string = \"\",\r\n        shaderLanguage = ShaderLanguage.GLSL\r\n    ) {\r\n        this.name = baseName;\r\n        this._key = key;\r\n\r\n        if ((<IEffectCreationOptions>attributesNamesOrOptions).attributes) {\r\n            const options = <IEffectCreationOptions>attributesNamesOrOptions;\r\n            this._engine = <Engine>uniformsNamesOrEngine;\r\n\r\n            this._attributesNames = options.attributes;\r\n            this._uniformsNames = options.uniformsNames.concat(options.samplers);\r\n            this._samplerList = options.samplers.slice();\r\n            this.defines = options.defines;\r\n            this.onError = options.onError;\r\n            this.onCompiled = options.onCompiled;\r\n            this._fallbacks = options.fallbacks;\r\n            this._indexParameters = options.indexParameters;\r\n            this._transformFeedbackVaryings = options.transformFeedbackVaryings || null;\r\n            this._multiTarget = !!options.multiTarget;\r\n            this._shaderLanguage = options.shaderLanguage ?? ShaderLanguage.GLSL;\r\n\r\n            if (options.uniformBuffersNames) {\r\n                this._uniformBuffersNamesList = options.uniformBuffersNames.slice();\r\n                for (let i = 0; i < options.uniformBuffersNames.length; i++) {\r\n                    this._uniformBuffersNames[options.uniformBuffersNames[i]] = i;\r\n                }\r\n            }\r\n\r\n            this._processFinalCode = options.processFinalCode ?? null;\r\n            this._processCodeAfterIncludes = options.processCodeAfterIncludes ?? undefined;\r\n        } else {\r\n            this._engine = <Engine>engine;\r\n            this.defines = defines == null ? \"\" : defines;\r\n            this._uniformsNames = (<string[]>uniformsNamesOrEngine).concat(<string[]>samplers);\r\n            this._samplerList = samplers ? <string[]>samplers.slice() : [];\r\n            this._attributesNames = <string[]>attributesNamesOrOptions;\r\n            this._uniformBuffersNamesList = [];\r\n            this._shaderLanguage = shaderLanguage;\r\n\r\n            this.onError = onError;\r\n            this.onCompiled = onCompiled;\r\n\r\n            this._indexParameters = indexParameters;\r\n            this._fallbacks = fallbacks;\r\n        }\r\n\r\n        this._attributeLocationByName = {};\r\n\r\n        this.uniqueId = Effect._UniqueIdSeed++;\r\n\r\n        this._processShaderCode();\r\n    }\r\n\r\n    /** @internal */\r\n    public _processShaderCode(shaderProcessor: Nullable<IShaderProcessor> = null, keepExistingPipelineContext = false) {\r\n        let vertexSource: any;\r\n        let fragmentSource: any;\r\n\r\n        const baseName = this.name;\r\n        const hostDocument = IsWindowObjectExist() ? this._engine.getHostDocument() : null;\r\n\r\n        if (baseName.vertexSource) {\r\n            vertexSource = \"source:\" + baseName.vertexSource;\r\n        } else if (baseName.vertexElement) {\r\n            vertexSource = hostDocument ? hostDocument.getElementById(baseName.vertexElement) : null;\r\n\r\n            if (!vertexSource) {\r\n                vertexSource = baseName.vertexElement;\r\n            }\r\n        } else {\r\n            vertexSource = baseName.vertex || baseName;\r\n        }\r\n\r\n        if (baseName.fragmentSource) {\r\n            fragmentSource = \"source:\" + baseName.fragmentSource;\r\n        } else if (baseName.fragmentElement) {\r\n            fragmentSource = hostDocument ? hostDocument.getElementById(baseName.fragmentElement) : null;\r\n\r\n            if (!fragmentSource) {\r\n                fragmentSource = baseName.fragmentElement;\r\n            }\r\n        } else {\r\n            fragmentSource = baseName.fragment || baseName;\r\n        }\r\n\r\n        this._processingContext = this._engine._getShaderProcessingContext(this._shaderLanguage);\r\n\r\n        let processorOptions: ProcessingOptions = {\r\n            defines: this.defines.split(\"\\n\"),\r\n            indexParameters: this._indexParameters,\r\n            isFragment: false,\r\n            shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,\r\n            processor: shaderProcessor ?? this._engine._getShaderProcessor(this._shaderLanguage),\r\n            supportsUniformBuffers: this._engine.supportsUniformBuffers,\r\n            shadersRepository: EngineShaderStore.GetShadersRepository(this._shaderLanguage),\r\n            includesShadersStore: EngineShaderStore.GetIncludesShadersStore(this._shaderLanguage),\r\n            version: (this._engine.version * 100).toString(),\r\n            platformName: this._engine.shaderPlatformName,\r\n            processingContext: this._processingContext,\r\n            isNDCHalfZRange: this._engine.isNDCHalfZRange,\r\n            useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\r\n            processCodeAfterIncludes: this._processCodeAfterIncludes,\r\n        };\r\n\r\n        const shaderCodes: [string | undefined, string | undefined] = [undefined, undefined];\r\n        const shadersLoaded = () => {\r\n            if (shaderCodes[0] && shaderCodes[1]) {\r\n                processorOptions.isFragment = true;\r\n                const [migratedVertexCode, fragmentCode] = shaderCodes;\r\n                ShaderProcessor.Process(\r\n                    fragmentCode,\r\n                    processorOptions,\r\n                    (migratedFragmentCode, codeBeforeMigration) => {\r\n                        this._fragmentSourceCodeBeforeMigration = codeBeforeMigration;\r\n                        if (this._processFinalCode) {\r\n                            migratedFragmentCode = this._processFinalCode(\"fragment\", migratedFragmentCode);\r\n                        }\r\n                        const finalShaders = ShaderProcessor.Finalize(migratedVertexCode, migratedFragmentCode, processorOptions);\r\n                        processorOptions = null as any;\r\n                        this._useFinalCode(finalShaders.vertexCode, finalShaders.fragmentCode, baseName, keepExistingPipelineContext);\r\n                    },\r\n                    this._engine\r\n                );\r\n            }\r\n        };\r\n        this._loadShader(vertexSource, \"Vertex\", \"\", (vertexCode) => {\r\n            ShaderProcessor.Initialize(processorOptions);\r\n            ShaderProcessor.Process(\r\n                vertexCode,\r\n                processorOptions,\r\n                (migratedVertexCode, codeBeforeMigration) => {\r\n                    this._rawVertexSourceCode = vertexCode;\r\n                    this._vertexSourceCodeBeforeMigration = codeBeforeMigration;\r\n                    if (this._processFinalCode) {\r\n                        migratedVertexCode = this._processFinalCode(\"vertex\", migratedVertexCode);\r\n                    }\r\n                    shaderCodes[0] = migratedVertexCode;\r\n                    shadersLoaded();\r\n                },\r\n                this._engine\r\n            );\r\n        });\r\n        this._loadShader(fragmentSource, \"Fragment\", \"Pixel\", (fragmentCode) => {\r\n            this._rawFragmentSourceCode = fragmentCode;\r\n            shaderCodes[1] = fragmentCode;\r\n            shadersLoaded();\r\n        });\r\n    }\r\n\r\n    private _useFinalCode(migratedVertexCode: string, migratedFragmentCode: string, baseName: any, keepExistingPipelineContext = false) {\r\n        if (baseName) {\r\n            const vertex = baseName.vertexElement || baseName.vertex || baseName.spectorName || baseName;\r\n            const fragment = baseName.fragmentElement || baseName.fragment || baseName.spectorName || baseName;\r\n\r\n            this._vertexSourceCode = (this._shaderLanguage === ShaderLanguage.WGSL ? \"//\" : \"\") + \"#define SHADER_NAME vertex:\" + vertex + \"\\n\" + migratedVertexCode;\r\n            this._fragmentSourceCode = (this._shaderLanguage === ShaderLanguage.WGSL ? \"//\" : \"\") + \"#define SHADER_NAME fragment:\" + fragment + \"\\n\" + migratedFragmentCode;\r\n        } else {\r\n            this._vertexSourceCode = migratedVertexCode;\r\n            this._fragmentSourceCode = migratedFragmentCode;\r\n        }\r\n        this._prepareEffect(keepExistingPipelineContext);\r\n    }\r\n\r\n    /**\r\n     * Unique key for this effect\r\n     */\r\n    public get key(): string {\r\n        return this._key;\r\n    }\r\n\r\n    /**\r\n     * If the effect has been compiled and prepared.\r\n     * @returns if the effect is compiled and prepared.\r\n     */\r\n    public isReady(): boolean {\r\n        try {\r\n            return this._isReadyInternal();\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private _isReadyInternal(): boolean {\r\n        if (this._isReady) {\r\n            return true;\r\n        }\r\n        if (this._pipelineContext) {\r\n            return this._pipelineContext.isReady;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * The engine the effect was initialized with.\r\n     * @returns the engine.\r\n     */\r\n    public getEngine(): Engine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * The pipeline context for this effect\r\n     * @returns the associated pipeline context\r\n     */\r\n    public getPipelineContext(): Nullable<IPipelineContext> {\r\n        return this._pipelineContext;\r\n    }\r\n\r\n    /**\r\n     * The set of names of attribute variables for the shader.\r\n     * @returns An array of attribute names.\r\n     */\r\n    public getAttributesNames(): string[] {\r\n        return this._attributesNames;\r\n    }\r\n\r\n    /**\r\n     * Returns the attribute at the given index.\r\n     * @param index The index of the attribute.\r\n     * @returns The location of the attribute.\r\n     */\r\n    public getAttributeLocation(index: number): number {\r\n        return this._attributes[index];\r\n    }\r\n\r\n    /**\r\n     * Returns the attribute based on the name of the variable.\r\n     * @param name of the attribute to look up.\r\n     * @returns the attribute location.\r\n     */\r\n    public getAttributeLocationByName(name: string): number {\r\n        return this._attributeLocationByName[name];\r\n    }\r\n\r\n    /**\r\n     * The number of attributes.\r\n     * @returns the number of attributes.\r\n     */\r\n    public getAttributesCount(): number {\r\n        return this._attributes.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the index of a uniform variable.\r\n     * @param uniformName of the uniform to look up.\r\n     * @returns the index.\r\n     */\r\n    public getUniformIndex(uniformName: string): number {\r\n        return this._uniformsNames.indexOf(uniformName);\r\n    }\r\n\r\n    /**\r\n     * Returns the attribute based on the name of the variable.\r\n     * @param uniformName of the uniform to look up.\r\n     * @returns the location of the uniform.\r\n     */\r\n    public getUniform(uniformName: string): Nullable<WebGLUniformLocation> {\r\n        return this._uniforms[uniformName];\r\n    }\r\n\r\n    /**\r\n     * Returns an array of sampler variable names\r\n     * @returns The array of sampler variable names.\r\n     */\r\n    public getSamplers(): string[] {\r\n        return this._samplerList;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of uniform variable names\r\n     * @returns The array of uniform variable names.\r\n     */\r\n    public getUniformNames(): string[] {\r\n        return this._uniformsNames;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of uniform buffer variable names\r\n     * @returns The array of uniform buffer variable names.\r\n     */\r\n    public getUniformBuffersNames(): string[] {\r\n        return this._uniformBuffersNamesList;\r\n    }\r\n\r\n    /**\r\n     * Returns the index parameters used to create the effect\r\n     * @returns The index parameters object\r\n     */\r\n    public getIndexParameters(): any {\r\n        return this._indexParameters;\r\n    }\r\n\r\n    /**\r\n     * The error from the last compilation.\r\n     * @returns the error string.\r\n     */\r\n    public getCompilationError(): string {\r\n        return this._compilationError;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that all fallbacks were used during compilation\r\n     * @returns true if all fallbacks were used\r\n     */\r\n    public allFallbacksProcessed(): boolean {\r\n        return this._allFallbacksProcessed;\r\n    }\r\n\r\n    /**\r\n     * Adds a callback to the onCompiled observable and call the callback immediately if already ready.\r\n     * @param func The callback to be used.\r\n     */\r\n    public executeWhenCompiled(func: (effect: Effect) => void): void {\r\n        if (this.isReady()) {\r\n            func(this);\r\n            return;\r\n        }\r\n\r\n        this.onCompileObservable.add((effect) => {\r\n            func(effect);\r\n        });\r\n\r\n        if (!this._pipelineContext || this._pipelineContext.isAsync) {\r\n            setTimeout(() => {\r\n                this._checkIsReady(null);\r\n            }, 16);\r\n        }\r\n    }\r\n\r\n    private _checkIsReady(previousPipelineContext: Nullable<IPipelineContext>) {\r\n        try {\r\n            if (this._isReadyInternal()) {\r\n                return;\r\n            }\r\n        } catch (e) {\r\n            this._processCompilationErrors(e, previousPipelineContext);\r\n            return;\r\n        }\r\n\r\n        if (this._isDisposed) {\r\n            return;\r\n        }\r\n\r\n        setTimeout(() => {\r\n            this._checkIsReady(previousPipelineContext);\r\n        }, 16);\r\n    }\r\n\r\n    private _loadShader(shader: any, key: string, optionalKey: string, callback: (data: any) => void): void {\r\n        if (typeof HTMLElement !== \"undefined\") {\r\n            // DOM element ?\r\n            if (shader instanceof HTMLElement) {\r\n                const shaderCode = GetDOMTextContent(shader);\r\n                callback(shaderCode);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Direct source ?\r\n        if (shader.substr(0, 7) === \"source:\") {\r\n            callback(shader.substr(7));\r\n            return;\r\n        }\r\n\r\n        // Base64 encoded ?\r\n        if (shader.substr(0, 7) === \"base64:\") {\r\n            const shaderBinary = window.atob(shader.substr(7));\r\n            callback(shaderBinary);\r\n            return;\r\n        }\r\n\r\n        const shaderStore = EngineShaderStore.GetShadersStore(this._shaderLanguage);\r\n\r\n        // Is in local store ?\r\n        if (shaderStore[shader + key + \"Shader\"]) {\r\n            callback(shaderStore[shader + key + \"Shader\"]);\r\n            return;\r\n        }\r\n\r\n        if (optionalKey && shaderStore[shader + optionalKey + \"Shader\"]) {\r\n            callback(shaderStore[shader + optionalKey + \"Shader\"]);\r\n            return;\r\n        }\r\n\r\n        let shaderUrl;\r\n\r\n        if (shader[0] === \".\" || shader[0] === \"/\" || shader.indexOf(\"http\") > -1) {\r\n            shaderUrl = shader;\r\n        } else {\r\n            shaderUrl = EngineShaderStore.GetShadersRepository(this._shaderLanguage) + shader;\r\n        }\r\n\r\n        // Vertex shader\r\n        this._engine._loadFile(shaderUrl + \".\" + key.toLowerCase() + \".fx\", callback);\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex shader source code of this effect\r\n     * This is the final source code that will be compiled, after all the processing has been done (pre-processing applied, code injection/replacement, etc)\r\n     */\r\n    public get vertexSourceCode(): string {\r\n        return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride\r\n            ? this._vertexSourceCodeOverride\r\n            : this._pipelineContext?._getVertexShaderCode() ?? this._vertexSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Gets the fragment shader source code of this effect\r\n     * This is the final source code that will be compiled, after all the processing has been done (pre-processing applied, code injection/replacement, etc)\r\n     */\r\n    public get fragmentSourceCode(): string {\r\n        return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride\r\n            ? this._fragmentSourceCodeOverride\r\n            : this._pipelineContext?._getFragmentShaderCode() ?? this._fragmentSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex shader source code before migration.\r\n     * This is the source code after the include directives have been replaced by their contents but before the code is migrated, i.e. before ShaderProcess._ProcessShaderConversion is executed.\r\n     * This method is, among other things, responsible for parsing #if/#define directives as well as converting GLES2 syntax to GLES3 (in the case of WebGL).\r\n     */\r\n    public get vertexSourceCodeBeforeMigration(): string {\r\n        return this._vertexSourceCodeBeforeMigration;\r\n    }\r\n\r\n    /**\r\n     * Gets the fragment shader source code before migration.\r\n     * This is the source code after the include directives have been replaced by their contents but before the code is migrated, i.e. before ShaderProcess._ProcessShaderConversion is executed.\r\n     * This method is, among other things, responsible for parsing #if/#define directives as well as converting GLES2 syntax to GLES3 (in the case of WebGL).\r\n     */\r\n    public get fragmentSourceCodeBeforeMigration(): string {\r\n        return this._fragmentSourceCodeBeforeMigration;\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex shader source code before it has been modified by any processing\r\n     */\r\n    public get rawVertexSourceCode(): string {\r\n        return this._rawVertexSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Gets the fragment shader source code before it has been modified by any processing\r\n     */\r\n    public get rawFragmentSourceCode(): string {\r\n        return this._rawFragmentSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Recompiles the webGL program\r\n     * @param vertexSourceCode The source code for the vertex shader.\r\n     * @param fragmentSourceCode The source code for the fragment shader.\r\n     * @param onCompiled Callback called when completed.\r\n     * @param onError Callback called on error.\r\n     * @internal\r\n     */\r\n    public _rebuildProgram(vertexSourceCode: string, fragmentSourceCode: string, onCompiled: (pipelineContext: IPipelineContext) => void, onError: (message: string) => void) {\r\n        this._isReady = false;\r\n\r\n        this._vertexSourceCodeOverride = vertexSourceCode;\r\n        this._fragmentSourceCodeOverride = fragmentSourceCode;\r\n        this.onError = (effect, error) => {\r\n            if (onError) {\r\n                onError(error);\r\n            }\r\n        };\r\n        this.onCompiled = () => {\r\n            const scenes = this.getEngine().scenes;\r\n            if (scenes) {\r\n                for (let i = 0; i < scenes.length; i++) {\r\n                    scenes[i].markAllMaterialsAsDirty(Constants.MATERIAL_AllDirtyFlag);\r\n                }\r\n            }\r\n\r\n            this._pipelineContext!._handlesSpectorRebuildCallback(onCompiled);\r\n        };\r\n        this._fallbacks = null;\r\n        this._prepareEffect();\r\n    }\r\n\r\n    /**\r\n     * Prepares the effect\r\n     * @internal\r\n     */\r\n    public _prepareEffect(keepExistingPipelineContext = false) {\r\n        const attributesNames = this._attributesNames;\r\n        const defines = this.defines;\r\n\r\n        const previousPipelineContext = this._pipelineContext;\r\n\r\n        this._isReady = false;\r\n\r\n        try {\r\n            const engine = this._engine;\r\n\r\n            this._pipelineContext = (keepExistingPipelineContext ? previousPipelineContext : undefined) ?? engine.createPipelineContext(this._processingContext);\r\n            this._pipelineContext._name = this._key.replace(/\\r/g, \"\").replace(/\\n/g, \"|\");\r\n\r\n            const rebuildRebind = (\r\n                vertexSourceCode: string,\r\n                fragmentSourceCode: string,\r\n                onCompiled: (pipelineContext: IPipelineContext) => void,\r\n                onError: (message: string) => void\r\n            ) => this._rebuildProgram(vertexSourceCode, fragmentSourceCode, onCompiled, onError);\r\n            if (this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride) {\r\n                engine._preparePipelineContext(\r\n                    this._pipelineContext,\r\n                    this._vertexSourceCodeOverride,\r\n                    this._fragmentSourceCodeOverride,\r\n                    true,\r\n                    this._rawVertexSourceCode,\r\n                    this._rawFragmentSourceCode,\r\n                    rebuildRebind,\r\n                    null,\r\n                    this._transformFeedbackVaryings,\r\n                    this._key\r\n                );\r\n            } else {\r\n                engine._preparePipelineContext(\r\n                    this._pipelineContext,\r\n                    this._vertexSourceCode,\r\n                    this._fragmentSourceCode,\r\n                    false,\r\n                    this._rawVertexSourceCode,\r\n                    this._rawFragmentSourceCode,\r\n                    rebuildRebind,\r\n                    defines,\r\n                    this._transformFeedbackVaryings,\r\n                    this._key\r\n                );\r\n            }\r\n\r\n            engine._executeWhenRenderingStateIsCompiled(this._pipelineContext, () => {\r\n                this._attributes = [];\r\n                this._pipelineContext!._fillEffectInformation(\r\n                    this,\r\n                    this._uniformBuffersNames,\r\n                    this._uniformsNames,\r\n                    this._uniforms,\r\n                    this._samplerList,\r\n                    this._samplers,\r\n                    attributesNames,\r\n                    this._attributes\r\n                );\r\n\r\n                // Caches attribute locations.\r\n                if (attributesNames) {\r\n                    for (let i = 0; i < attributesNames.length; i++) {\r\n                        const name = attributesNames[i];\r\n                        this._attributeLocationByName[name] = this._attributes[i];\r\n                    }\r\n                }\r\n\r\n                engine.bindSamplers(this);\r\n\r\n                this._compilationError = \"\";\r\n                this._isReady = true;\r\n                if (this.onCompiled) {\r\n                    this.onCompiled(this);\r\n                }\r\n                this.onCompileObservable.notifyObservers(this);\r\n                this.onCompileObservable.clear();\r\n\r\n                // Unbind mesh reference in fallbacks\r\n                if (this._fallbacks) {\r\n                    this._fallbacks.unBindMesh();\r\n                }\r\n\r\n                if (previousPipelineContext && !keepExistingPipelineContext) {\r\n                    this.getEngine()._deletePipelineContext(previousPipelineContext);\r\n                }\r\n            });\r\n\r\n            if (this._pipelineContext.isAsync) {\r\n                this._checkIsReady(previousPipelineContext);\r\n            }\r\n        } catch (e) {\r\n            this._processCompilationErrors(e, previousPipelineContext);\r\n        }\r\n    }\r\n\r\n    private _getShaderCodeAndErrorLine(code: Nullable<string>, error: Nullable<string>, isFragment: boolean): [Nullable<string>, Nullable<string>] {\r\n        const regexp = isFragment ? /FRAGMENT SHADER ERROR: 0:(\\d+?):/ : /VERTEX SHADER ERROR: 0:(\\d+?):/;\r\n\r\n        let errorLine = null;\r\n\r\n        if (error && code) {\r\n            const res = error.match(regexp);\r\n            if (res && res.length === 2) {\r\n                const lineNumber = parseInt(res[1]);\r\n                const lines = code.split(\"\\n\", -1);\r\n                if (lines.length >= lineNumber) {\r\n                    errorLine = `Offending line [${lineNumber}] in ${isFragment ? \"fragment\" : \"vertex\"} code: ${lines[lineNumber - 1]}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return [code, errorLine];\r\n    }\r\n\r\n    private _processCompilationErrors(e: any, previousPipelineContext: Nullable<IPipelineContext> = null) {\r\n        this._compilationError = e.message;\r\n        const attributesNames = this._attributesNames;\r\n        const fallbacks = this._fallbacks;\r\n\r\n        // Let's go through fallbacks then\r\n        Logger.Error(\"Unable to compile effect:\");\r\n        Logger.Error(\r\n            \"Uniforms: \" +\r\n                this._uniformsNames.map(function (uniform) {\r\n                    return \" \" + uniform;\r\n                })\r\n        );\r\n        Logger.Error(\r\n            \"Attributes: \" +\r\n                attributesNames.map(function (attribute) {\r\n                    return \" \" + attribute;\r\n                })\r\n        );\r\n        Logger.Error(\"Defines:\\n\" + this.defines);\r\n        if (Effect.LogShaderCodeOnCompilationError) {\r\n            let lineErrorVertex = null,\r\n                lineErrorFragment = null,\r\n                code = null;\r\n            if (this._pipelineContext?._getVertexShaderCode()) {\r\n                [code, lineErrorVertex] = this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(), this._compilationError, false);\r\n                if (code) {\r\n                    Logger.Error(\"Vertex code:\");\r\n                    Logger.Error(code);\r\n                }\r\n            }\r\n            if (this._pipelineContext?._getFragmentShaderCode()) {\r\n                [code, lineErrorFragment] = this._getShaderCodeAndErrorLine(this._pipelineContext?._getFragmentShaderCode(), this._compilationError, true);\r\n                if (code) {\r\n                    Logger.Error(\"Fragment code:\");\r\n                    Logger.Error(code);\r\n                }\r\n            }\r\n            if (lineErrorVertex) {\r\n                Logger.Error(lineErrorVertex);\r\n            }\r\n            if (lineErrorFragment) {\r\n                Logger.Error(lineErrorFragment);\r\n            }\r\n        }\r\n        Logger.Error(\"Error: \" + this._compilationError);\r\n\r\n        const notifyErrors = () => {\r\n            if (this.onError) {\r\n                this.onError(this, this._compilationError);\r\n            }\r\n            this.onErrorObservable.notifyObservers(this);\r\n        };\r\n\r\n        // In case a previous compilation was successful, we need to restore the previous pipeline context\r\n        if (previousPipelineContext) {\r\n            this._pipelineContext = previousPipelineContext;\r\n            this._isReady = true;\r\n            notifyErrors();\r\n        }\r\n\r\n        // Lets try to compile fallbacks as long as we have some.\r\n        if (fallbacks) {\r\n            this._pipelineContext = null;\r\n            if (fallbacks.hasMoreFallbacks) {\r\n                this._allFallbacksProcessed = false;\r\n                Logger.Error(\"Trying next fallback.\");\r\n                this.defines = fallbacks.reduce(this.defines, this);\r\n                this._prepareEffect();\r\n            } else {\r\n                // Sorry we did everything we can\r\n                this._allFallbacksProcessed = true;\r\n                notifyErrors();\r\n                this.onErrorObservable.clear();\r\n\r\n                // Unbind mesh reference in fallbacks\r\n                if (this._fallbacks) {\r\n                    this._fallbacks.unBindMesh();\r\n                }\r\n            }\r\n        } else {\r\n            this._allFallbacksProcessed = true;\r\n\r\n            // In case of error, without any prior successful compilation, let s notify observers\r\n            if (!previousPipelineContext) {\r\n                notifyErrors();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if the effect is supported. (Must be called after compilation)\r\n     */\r\n    public get isSupported(): boolean {\r\n        return this._compilationError === \"\";\r\n    }\r\n\r\n    /**\r\n     * Binds a texture to the engine to be used as output of the shader.\r\n     * @param channel Name of the output variable.\r\n     * @param texture Texture to bind.\r\n     * @internal\r\n     */\r\n    public _bindTexture(channel: string, texture: Nullable<InternalTexture>): void {\r\n        this._engine._bindTexture(this._samplers[channel], texture, channel);\r\n    }\r\n\r\n    /**\r\n     * Sets a texture on the engine to be used in the shader.\r\n     * @param channel Name of the sampler variable.\r\n     * @param texture Texture to set.\r\n     */\r\n    public setTexture(channel: string, texture: Nullable<ThinTexture>): void {\r\n        this._engine.setTexture(this._samplers[channel], this._uniforms[channel], texture, channel);\r\n    }\r\n\r\n    /**\r\n     * Sets a depth stencil texture from a render target on the engine to be used in the shader.\r\n     * @param channel Name of the sampler variable.\r\n     * @param texture Texture to set.\r\n     */\r\n    public setDepthStencilTexture(channel: string, texture: Nullable<RenderTargetTexture>): void {\r\n        this._engine.setDepthStencilTexture(this._samplers[channel], this._uniforms[channel], texture, channel);\r\n    }\r\n\r\n    /**\r\n     * Sets an array of textures on the engine to be used in the shader.\r\n     * @param channel Name of the variable.\r\n     * @param textures Textures to set.\r\n     */\r\n    public setTextureArray(channel: string, textures: ThinTexture[]): void {\r\n        const exName = channel + \"Ex\";\r\n        if (this._samplerList.indexOf(exName + \"0\") === -1) {\r\n            const initialPos = this._samplerList.indexOf(channel);\r\n            for (let index = 1; index < textures.length; index++) {\r\n                const currentExName = exName + (index - 1).toString();\r\n                this._samplerList.splice(initialPos + index, 0, currentExName);\r\n            }\r\n\r\n            // Reset every channels\r\n            let channelIndex = 0;\r\n            for (const key of this._samplerList) {\r\n                this._samplers[key] = channelIndex;\r\n                channelIndex += 1;\r\n            }\r\n        }\r\n\r\n        this._engine.setTextureArray(this._samplers[channel], this._uniforms[channel], textures, channel);\r\n    }\r\n\r\n    /**\r\n     * Sets a texture to be the input of the specified post process. (To use the output, pass in the next post process in the pipeline)\r\n     * @param channel Name of the sampler variable.\r\n     * @param postProcess Post process to get the input texture from.\r\n     */\r\n    public setTextureFromPostProcess(channel: string, postProcess: Nullable<PostProcess>): void {\r\n        this._engine.setTextureFromPostProcess(this._samplers[channel], postProcess, channel);\r\n    }\r\n\r\n    /**\r\n     * (Warning! setTextureFromPostProcessOutput may be desired instead)\r\n     * Sets the input texture of the passed in post process to be input of this effect. (To use the output of the passed in post process use setTextureFromPostProcessOutput)\r\n     * @param channel Name of the sampler variable.\r\n     * @param postProcess Post process to get the output texture from.\r\n     */\r\n    public setTextureFromPostProcessOutput(channel: string, postProcess: Nullable<PostProcess>): void {\r\n        this._engine.setTextureFromPostProcessOutput(this._samplers[channel], postProcess, channel);\r\n    }\r\n\r\n    /**\r\n     * Binds a buffer to a uniform.\r\n     * @param buffer Buffer to bind.\r\n     * @param name Name of the uniform variable to bind to.\r\n     */\r\n    public bindUniformBuffer(buffer: DataBuffer, name: string): void {\r\n        const bufferName = this._uniformBuffersNames[name];\r\n        if (bufferName === undefined || (Effect._BaseCache[bufferName] === buffer && this._engine._features.useUBOBindingCache)) {\r\n            return;\r\n        }\r\n        Effect._BaseCache[bufferName] = buffer;\r\n        this._engine.bindUniformBufferBase(buffer, bufferName, name);\r\n    }\r\n\r\n    /**\r\n     * Binds block to a uniform.\r\n     * @param blockName Name of the block to bind.\r\n     * @param index Index to bind.\r\n     */\r\n    public bindUniformBlock(blockName: string, index: number): void {\r\n        this._engine.bindUniformBlock(this._pipelineContext!, blockName, index);\r\n    }\r\n\r\n    /**\r\n     * Sets an integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setInt(uniformName: string, value: number): Effect {\r\n        this._pipelineContext!.setInt(uniformName, value);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int2 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int2.\r\n     * @param y Second int in int2.\r\n     * @returns this effect.\r\n     */\r\n    public setInt2(uniformName: string, x: number, y: number): Effect {\r\n        this._pipelineContext!.setInt2(uniformName, x, y);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int3 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int3.\r\n     * @param y Second int in int3.\r\n     * @param z Third int in int3.\r\n     * @returns this effect.\r\n     */\r\n    public setInt3(uniformName: string, x: number, y: number, z: number): Effect {\r\n        this._pipelineContext!.setInt3(uniformName, x, y, z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int4 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int4.\r\n     * @param y Second int in int4.\r\n     * @param z Third int in int4.\r\n     * @param w Fourth int in int4.\r\n     * @returns this effect.\r\n     */\r\n    public setInt4(uniformName: string, x: number, y: number, z: number, w: number): Effect {\r\n        this._pipelineContext!.setInt4(uniformName, x, y, z, w);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray(uniformName: string, array: Int32Array): Effect {\r\n        this._pipelineContext!.setIntArray(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray2(uniformName: string, array: Int32Array): Effect {\r\n        this._pipelineContext!.setIntArray2(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray3(uniformName: string, array: Int32Array): Effect {\r\n        this._pipelineContext!.setIntArray3(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray4(uniformName: string, array: Int32Array): Effect {\r\n        this._pipelineContext!.setIntArray4(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setUInt(uniformName: string, value: number): Effect {\r\n        this._pipelineContext!.setUInt(uniformName, value);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int2 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint2.\r\n     * @param y Second unsigned int in uint2.\r\n     * @returns this effect.\r\n     */\r\n    public setUInt2(uniformName: string, x: number, y: number): Effect {\r\n        this._pipelineContext!.setUInt2(uniformName, x, y);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int3 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint3.\r\n     * @param y Second unsigned int in uint3.\r\n     * @param z Third unsigned int in uint3.\r\n     * @returns this effect.\r\n     */\r\n    public setUInt3(uniformName: string, x: number, y: number, z: number): Effect {\r\n        this._pipelineContext!.setUInt3(uniformName, x, y, z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int4 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint4.\r\n     * @param y Second unsigned int in uint4.\r\n     * @param z Third unsigned int in uint4.\r\n     * @param w Fourth unsigned int in uint4.\r\n     * @returns this effect.\r\n     */\r\n    public setUInt4(uniformName: string, x: number, y: number, z: number, w: number): Effect {\r\n        this._pipelineContext!.setUInt4(uniformName, x, y, z, w);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setUIntArray(uniformName: string, array: Uint32Array): Effect {\r\n        this._pipelineContext!.setUIntArray(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setUIntArray2(uniformName: string, array: Uint32Array): Effect {\r\n        this._pipelineContext!.setUIntArray2(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setUIntArray3(uniformName: string, array: Uint32Array): Effect {\r\n        this._pipelineContext!.setUIntArray3(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setUIntArray4(uniformName: string, array: Uint32Array): Effect {\r\n        this._pipelineContext!.setUIntArray4(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray(uniformName: string, array: FloatArray): Effect {\r\n        this._pipelineContext!.setArray(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray2(uniformName: string, array: FloatArray): Effect {\r\n        this._pipelineContext!.setArray2(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray3(uniformName: string, array: FloatArray): Effect {\r\n        this._pipelineContext!.setArray3(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray4(uniformName: string, array: FloatArray): Effect {\r\n        this._pipelineContext!.setArray4(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray(uniformName: string, array: number[]): Effect {\r\n        this._pipelineContext!.setArray(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray2(uniformName: string, array: number[]): Effect {\r\n        this._pipelineContext!.setArray2(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray3(uniformName: string, array: number[]): Effect {\r\n        this._pipelineContext!.setArray3(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray4(uniformName: string, array: number[]): Effect {\r\n        this._pipelineContext!.setArray4(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets matrices on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrices matrices to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrices(uniformName: string, matrices: Float32Array | Array<number>): Effect {\r\n        this._pipelineContext!.setMatrices(uniformName, matrices as Float32Array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets matrix on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrix(uniformName: string, matrix: IMatrixLike): Effect {\r\n        this._pipelineContext!.setMatrix(uniformName, matrix);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a 3x3 matrix on a uniform variable. (Specified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrix3x3(uniformName: string, matrix: Float32Array | Array<number>): Effect {\r\n        // the cast is ok because it is gl.uniformMatrix3fv() which is called at the end, and this function accepts Float32Array and Array<number>\r\n        this._pipelineContext!.setMatrix3x3(uniformName, matrix as Float32Array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a 2x2 matrix on a uniform variable. (Specified as [1,2,3,4] will result in [1,2][3,4] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrix2x2(uniformName: string, matrix: Float32Array | Array<number>): Effect {\r\n        // the cast is ok because it is gl.uniformMatrix3fv() which is called at the end, and this function accepts Float32Array and Array<number>\r\n        this._pipelineContext!.setMatrix2x2(uniformName, matrix as Float32Array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat(uniformName: string, value: number): Effect {\r\n        this._pipelineContext!.setFloat(uniformName, value);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a boolean on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param bool value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setBool(uniformName: string, bool: boolean): Effect {\r\n        this._pipelineContext!.setInt(uniformName, bool ? 1 : 0);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector2 vector2 to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setVector2(uniformName: string, vector2: IVector2Like): Effect {\r\n        this._pipelineContext!.setVector2(uniformName, vector2);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float2.\r\n     * @param y Second float in float2.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat2(uniformName: string, x: number, y: number): Effect {\r\n        this._pipelineContext!.setFloat2(uniformName, x, y);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector3 Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setVector3(uniformName: string, vector3: IVector3Like): Effect {\r\n        this._pipelineContext!.setVector3(uniformName, vector3);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float3.\r\n     * @param y Second float in float3.\r\n     * @param z Third float in float3.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat3(uniformName: string, x: number, y: number, z: number): Effect {\r\n        this._pipelineContext!.setFloat3(uniformName, x, y, z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector4 Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setVector4(uniformName: string, vector4: IVector4Like): Effect {\r\n        this._pipelineContext!.setVector4(uniformName, vector4);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Quaternion on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param quaternion Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setQuaternion(uniformName: string, quaternion: IQuaternionLike): Effect {\r\n        this._pipelineContext!.setQuaternion(uniformName, quaternion);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float4.\r\n     * @param y Second float in float4.\r\n     * @param z Third float in float4.\r\n     * @param w Fourth float in float4.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat4(uniformName: string, x: number, y: number, z: number, w: number): Effect {\r\n        this._pipelineContext!.setFloat4(uniformName, x, y, z, w);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Color3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setColor3(uniformName: string, color3: IColor3Like): Effect {\r\n        this._pipelineContext!.setColor3(uniformName, color3);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     * @param alpha Alpha value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setColor4(uniformName: string, color3: IColor3Like, alpha: number): Effect {\r\n        this._pipelineContext!.setColor4(uniformName, color3, alpha);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable\r\n     * @param uniformName defines the name of the variable\r\n     * @param color4 defines the value to be set\r\n     * @returns this effect.\r\n     */\r\n    public setDirectColor4(uniformName: string, color4: IColor4Like): Effect {\r\n        this._pipelineContext!.setDirectColor4(uniformName, color4);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources.\r\n     **/\r\n    public dispose() {\r\n        if (this._pipelineContext) {\r\n            this._pipelineContext.dispose();\r\n        }\r\n        this._engine._releaseEffect(this);\r\n\r\n        this._isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * This function will add a new shader to the shader store\r\n     * @param name the name of the shader\r\n     * @param pixelShader optional pixel shader content\r\n     * @param vertexShader optional vertex shader content\r\n     * @param shaderLanguage the language the shader is written in (default: GLSL)\r\n     */\r\n    public static RegisterShader(name: string, pixelShader?: string, vertexShader?: string, shaderLanguage = ShaderLanguage.GLSL) {\r\n        if (pixelShader) {\r\n            EngineShaderStore.GetShadersStore(shaderLanguage)[`${name}PixelShader`] = pixelShader;\r\n        }\r\n\r\n        if (vertexShader) {\r\n            EngineShaderStore.GetShadersStore(shaderLanguage)[`${name}VertexShader`] = vertexShader;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Store of each shader (The can be looked up using effect.key)\r\n     */\r\n    public static ShadersStore: { [key: string]: string } = EngineShaderStore.ShadersStore;\r\n    /**\r\n     * Store of each included file for a shader (The can be looked up using effect.key)\r\n     */\r\n    public static IncludesShadersStore: { [key: string]: string } = EngineShaderStore.IncludesShadersStore;\r\n\r\n    /**\r\n     * Resets the cache of effects.\r\n     */\r\n    public static ResetCache() {\r\n        Effect._BaseCache = {};\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}