{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { Curve3 } from \"../Maths/math.path.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector.js\";\nimport { CreateTextShapePaths } from \"../Meshes/Builders/textBuilder.js\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { GreasedLineMaterialDefaults } from \"../Materials/GreasedLine/greasedLineMaterialDefaults.js\";\n/**\n * Tool functions for GreasedLine\n */\nexport class GreasedLineTools {\n  /**\n   * Converts GreasedLinePoints to number[][]\n   * @param points GreasedLinePoints\n   * @returns number[][] with x, y, z coordinates of the points, like [[x, y, z, x, y, z, ...], [x, y, z, ...]]\n   */\n  static ConvertPoints(points) {\n    if (points.length && Array.isArray(points) && typeof points[0] === \"number\") {\n      return [points];\n    } else if (points.length && Array.isArray(points[0]) && typeof points[0][0] === \"number\") {\n      return points;\n    } else if (points.length && !Array.isArray(points[0]) && points[0] instanceof Vector3) {\n      const positions = [];\n      for (let j = 0; j < points.length; j++) {\n        const p = points[j];\n        positions.push(p.x, p.y, p.z);\n      }\n      return [positions];\n    } else if (points.length > 0 && Array.isArray(points[0]) && points[0].length > 0 && points[0][0] instanceof Vector3) {\n      const positions = [];\n      const vectorPoints = points;\n      vectorPoints.forEach(p => {\n        positions.push(p.flatMap(p2 => [p2.x, p2.y, p2.z]));\n      });\n      return positions;\n    } else if (points instanceof Float32Array) {\n      return [Array.from(points)];\n    } else if (points.length && points[0] instanceof Float32Array) {\n      const positions = [];\n      points.forEach(p => {\n        positions.push(Array.from(p));\n      });\n      return positions;\n    }\n    return [];\n  }\n  /**\n   * Omit zero length lines predicate for the MeshesToLines function\n   * @param p1 point1 position of the face\n   * @param p2 point2 position of the face\n   * @param p3 point3 position of the face\n   * @returns original points or null if any edge length is zero\n   */\n  static OmitZeroLengthPredicate(p1, p2, p3) {\n    const fileredPoints = [];\n    // edge1\n    if (p2.subtract(p1).lengthSquared() > 0) {\n      fileredPoints.push([p1, p2]);\n    }\n    // edge2\n    if (p3.subtract(p2).lengthSquared() > 0) {\n      fileredPoints.push([p2, p3]);\n    }\n    // edge3\n    if (p1.subtract(p3).lengthSquared() > 0) {\n      fileredPoints.push([p3, p1]);\n    }\n    return fileredPoints.length === 0 ? null : fileredPoints;\n  }\n  /**\n   * Omit duplicate lines predicate for the MeshesToLines function\n   * @param p1 point1 position of the face\n   * @param p2 point2 position of the face\n   * @param p3 point3 position of the face\n   * @returns original points or null if any edge length is zero\n   */\n  static OmitDuplicatesPredicate(p1, p2, p3, points) {\n    const fileredPoints = [];\n    // edge1\n    if (!GreasedLineTools._SearchInPoints(p1, p2, points)) {\n      fileredPoints.push([p1, p2]);\n    }\n    // edge2\n    if (!GreasedLineTools._SearchInPoints(p2, p3, points)) {\n      fileredPoints.push([p2, p3]);\n    }\n    // edge3\n    if (!GreasedLineTools._SearchInPoints(p3, p1, points)) {\n      fileredPoints.push([p3, p1]);\n    }\n    return fileredPoints.length === 0 ? null : fileredPoints;\n  }\n  static _SearchInPoints(p1, p2, points) {\n    var _a, _b, _c;\n    for (const ps of points) {\n      for (let i = 0; i < ps.length; i++) {\n        if ((_a = ps[i]) === null || _a === void 0 ? void 0 : _a.equals(p1)) {\n          // find the first point\n          // if it has a sibling of p2 the line already exists\n          if (((_b = ps[i + 1]) === null || _b === void 0 ? void 0 : _b.equals(p2)) || ((_c = ps[i - 1]) === null || _c === void 0 ? void 0 : _c.equals(p2))) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Gets mesh triangles as line positions\n   * @param meshes array of meshes\n   * @param predicate predicate function which decides whether to include the mesh triangle/face in the ouput\n   * @returns array of arrays of points\n   */\n  static MeshesToLines(meshes, predicate) {\n    const points = [];\n    meshes.forEach((m, meshIndex) => {\n      const vertices = m.getVerticesData(VertexBuffer.PositionKind);\n      const indices = m.getIndices();\n      if (vertices && indices) {\n        for (let i = 0, ii = 0; i < indices.length; i++) {\n          const vi1 = indices[ii++] * 3;\n          const vi2 = indices[ii++] * 3;\n          const vi3 = indices[ii++] * 3;\n          const p1 = new Vector3(vertices[vi1], vertices[vi1 + 1], vertices[vi1 + 2]);\n          const p2 = new Vector3(vertices[vi2], vertices[vi2 + 1], vertices[vi2 + 2]);\n          const p3 = new Vector3(vertices[vi3], vertices[vi3 + 1], vertices[vi3 + 2]);\n          if (predicate) {\n            const pointsFromPredicate = predicate(p1, p2, p3, points, i, vi1, m, meshIndex, vertices, indices);\n            if (pointsFromPredicate) {\n              for (const p of pointsFromPredicate) {\n                points.push(p);\n              }\n            }\n          } else {\n            points.push([p1, p2], [p2, p3], [p3, p1]);\n          }\n        }\n      }\n    });\n    return points;\n  }\n  /**\n   * Converts number coordinates to Vector3s\n   * @param points number array of x, y, z, x, y z, ... coordinates\n   * @returns Vector3 array\n   */\n  static ToVector3Array(points) {\n    if (Array.isArray(points[0])) {\n      const array = [];\n      const inputArray = points;\n      for (const subInputArray of inputArray) {\n        const subArray = [];\n        for (let i = 0; i < subInputArray.length; i += 3) {\n          subArray.push(new Vector3(subInputArray[i], subInputArray[i + 1], subInputArray[i + 2]));\n        }\n        array.push(subArray);\n      }\n      return array;\n    }\n    const inputArray = points;\n    const array = [];\n    for (let i = 0; i < inputArray.length; i += 3) {\n      array.push(new Vector3(inputArray[i], inputArray[i + 1], inputArray[i + 2]));\n    }\n    return array;\n  }\n  /**\n   * Gets a number array from a Vector3 array.\n   * You can you for example to convert your Vector3[] offsets to the required number[] for the offsets option.\n   * @param points Vector3 array\n   * @returns an array of x, y, z coordinates as numbers [x, y, z, x, y, z, x, y, z, ....]\n   */\n  static ToNumberArray(points) {\n    return points.flatMap(v => [v.x, v.y, v.z]);\n  }\n  /**\n   * Calculates the sum of points of every line and the number of points in each line.\n   * This function is useful when you are drawing multiple lines in one mesh and you want\n   * to know the counts. For example for creating an offsets table.\n   * @param points point array\n   * @returns points count info\n   */\n  static GetPointsCountInfo(points) {\n    const counts = new Array(points.length);\n    let total = 0;\n    for (let n = points.length; n--;) {\n      counts[n] = points[n].length / 3;\n      total += counts[n];\n    }\n    return {\n      total,\n      counts\n    };\n  }\n  /**\n   * Gets the length of the line counting all it's segments length\n   * @param data array of line points\n   * @returns length of the line\n   */\n  static GetLineLength(data) {\n    if (data.length === 0) {\n      return 0;\n    }\n    let points;\n    if (typeof data[0] === \"number\") {\n      points = GreasedLineTools.ToVector3Array(data);\n    } else {\n      points = data;\n    }\n    const tmp = TmpVectors.Vector3[0];\n    let length = 0;\n    for (let index = 0; index < points.length - 1; index++) {\n      const point1 = points[index];\n      const point2 = points[index + 1];\n      length += point2.subtractToRef(point1, tmp).length();\n    }\n    return length;\n  }\n  /**\n   * Divides a segment into smaller segments.\n   * A segment is a part of the line between it's two points.\n   * @param point1 first point of the line\n   * @param point2 second point of the line\n   * @param segmentCount number of segments we want to have in the divided line\n   * @returns\n   */\n  static SegmentizeSegmentByCount(point1, point2, segmentCount) {\n    const dividedLinePoints = [];\n    const diff = point2.subtract(point1);\n    const divisor = TmpVectors.Vector3[0];\n    divisor.setAll(segmentCount);\n    const segmentVector = TmpVectors.Vector3[1];\n    diff.divideToRef(divisor, segmentVector);\n    let nextPoint = point1.clone();\n    dividedLinePoints.push(nextPoint);\n    for (let index = 0; index < segmentCount; index++) {\n      nextPoint = nextPoint.clone();\n      dividedLinePoints.push(nextPoint.addInPlace(segmentVector));\n    }\n    return dividedLinePoints;\n  }\n  /**\n   * Divides a line into segments.\n   * A segment is a part of the line between it's two points.\n   * @param what line points\n   * @param segmentLength length of each segment of the resulting line (distance between two line points)\n   * @returns line point\n   */\n  static SegmentizeLineBySegmentLength(what, segmentLength) {\n    const subLines = what[0] instanceof Vector3 ? GreasedLineTools.GetLineSegments(what) : typeof what[0] === \"number\" ? GreasedLineTools.GetLineSegments(GreasedLineTools.ToVector3Array(what)) : what;\n    const points = [];\n    subLines.forEach(s => {\n      if (s.length > segmentLength) {\n        const segments = GreasedLineTools.SegmentizeSegmentByCount(s.point1, s.point2, Math.ceil(s.length / segmentLength));\n        segments.forEach(seg => {\n          points.push(seg);\n        });\n      } else {\n        points.push(s.point1);\n        points.push(s.point2);\n      }\n    });\n    return points;\n  }\n  /**\n   * Divides a line into segments.\n   * A segment is a part of the line between it's two points.\n   * @param what line points\n   * @param segmentCount number of segments\n   * @returns line point\n   */\n  static SegmentizeLineBySegmentCount(what, segmentCount) {\n    const points = typeof what[0] === \"number\" ? GreasedLineTools.ToVector3Array(what) : what;\n    const segmentLength = GreasedLineTools.GetLineLength(points) / segmentCount;\n    return GreasedLineTools.SegmentizeLineBySegmentLength(points, segmentLength);\n  }\n  /**\n   * Gets line segments.\n   * A segment is a part of the line between it's two points.\n   * @param points line points\n   * @returns segments information of the line segment including starting point, ending point and the distance between them\n   */\n  static GetLineSegments(points) {\n    const segments = [];\n    for (let index = 0; index < points.length - 1; index++) {\n      const point1 = points[index];\n      const point2 = points[index + 1];\n      const length = point2.subtract(point1).length();\n      segments.push({\n        point1,\n        point2,\n        length\n      });\n    }\n    return segments;\n  }\n  /**\n   * Gets the minimum and the maximum length of a line segment in the line.\n   * A segment is a part of the line between it's two points.\n   * @param points line points\n   * @returns\n   */\n  static GetMinMaxSegmentLength(points) {\n    const subLines = GreasedLineTools.GetLineSegments(points);\n    const sorted = subLines.sort(s => s.length);\n    return {\n      min: sorted[0].length,\n      max: sorted[sorted.length - 1].length\n    };\n  }\n  /**\n   * Finds the last visible position in world space of the line according to the visibility parameter\n   * @param lineSegments segments of the line\n   * @param lineLength total length of the line\n   * @param visbility normalized value of visibility\n   * @returns world space coordinate of the last visible piece of the line\n   */\n  static GetPositionOnLineByVisibility(lineSegments, lineLength, visbility, localSpace = false) {\n    const lengthVisibilityRatio = lineLength * visbility;\n    let sumSegmentLengths = 0;\n    let segmentIndex = 0;\n    const lineSegmentsLength = lineSegments.length;\n    for (let i = 0; i < lineSegmentsLength; i++) {\n      if (lengthVisibilityRatio <= sumSegmentLengths + lineSegments[i].length) {\n        segmentIndex = i;\n        break;\n      }\n      sumSegmentLengths += lineSegments[i].length;\n    }\n    const s = (lengthVisibilityRatio - sumSegmentLengths) / lineSegments[segmentIndex].length;\n    lineSegments[segmentIndex].point2.subtractToRef(lineSegments[segmentIndex].point1, TmpVectors.Vector3[0]);\n    TmpVectors.Vector3[1] = TmpVectors.Vector3[0].multiplyByFloats(s, s, s);\n    if (!localSpace) {\n      TmpVectors.Vector3[1].addInPlace(lineSegments[segmentIndex].point1);\n    }\n    return TmpVectors.Vector3[1].clone();\n  }\n  /**\n   * Creates lines in a shape of circle/arc.\n   * A segment is a part of the line between it's two points.\n   * @param radiusX radiusX of the circle\n   * @param segments number of segments in the circle\n   * @param z z coordinate of the points. Defaults to 0.\n   * @param radiusY radiusY of the circle - you can draw an oval if using different values\n   * @param segmentAngle angle offset of the segments. Defaults to Math.PI * 2 / segments. Change this value to draw a part of the circle.\n   * @returns line points\n   */\n  static GetCircleLinePoints(radiusX, segments, z = 0, radiusY = radiusX, segmentAngle = Math.PI * 2 / segments) {\n    const points = [];\n    for (let i = 0; i <= segments; i++) {\n      points.push(new Vector3(Math.cos(i * segmentAngle) * radiusX, Math.sin(i * segmentAngle) * radiusY, z));\n    }\n    return points;\n  }\n  /**\n   * Gets line points in a shape of a bezier curve\n   * @param p0 bezier point0\n   * @param p1 bezier point1\n   * @param p2 bezier point2\n   * @param segments number of segments in the curve\n   * @returns\n   */\n  static GetBezierLinePoints(p0, p1, p2, segments) {\n    return Curve3.CreateQuadraticBezier(p0, p1, p2, segments).getPoints().flatMap(v => [v.x, v.y, v.z]);\n  }\n  /**\n   *\n   * @param position position of the arrow cap (mainly you want to create a triangle, set widthUp and widthDown to the same value and omit widthStartUp and widthStartDown)\n   * @param direction direction which the arrow points to\n   * @param length length (size) of the arrow cap itself\n   * @param widthUp the arrow width above the line\n   * @param widthDown the arrow width belove the line\n   * @param widthStartUp the arrow width at the start of the arrow above the line. In most scenarios this is 0.\n   * @param widthStartDown the arrow width at the start of the arrow below the line. In most scenarios this is 0.\n   * @returns\n   */\n  static GetArrowCap(position, direction, length, widthUp, widthDown, widthStartUp = 0, widthStartDown = 0) {\n    const points = [position.clone(), position.add(direction.multiplyByFloats(length, length, length))];\n    const widths = [widthUp, widthDown, widthStartUp, widthStartDown];\n    return {\n      points,\n      widths\n    };\n  }\n  /**\n   * Gets 3D positions of points from a text and font\n   * @param text Text\n   * @param size Size of the font\n   * @param resolution Resolution of the font\n   * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)\n   * @param z z coordinate\n   * @param includeInner include the inner parts of the font in the result. Default true. If false, only the outlines will be returned.\n   * @returns number[][] of 3D positions\n   */\n  static GetPointsFromText(text, size, resolution, fontData, z = 0, includeInner = true) {\n    const allPoints = [];\n    const shapePaths = CreateTextShapePaths(text, size, resolution, fontData);\n    for (const sp of shapePaths) {\n      for (const p of sp.paths) {\n        const points = [];\n        const points2d = p.getPoints();\n        for (const p2d of points2d) {\n          points.push(p2d.x, p2d.y, z);\n        }\n        allPoints.push(points);\n      }\n      if (includeInner) {\n        for (const h of sp.holes) {\n          const holes = [];\n          const points2d = h.getPoints();\n          for (const p2d of points2d) {\n            holes.push(p2d.x, p2d.y, z);\n          }\n          allPoints.push(holes);\n        }\n      }\n    }\n    return allPoints;\n  }\n  /**\n   * Converts an array of Color3 to Uint8Array\n   * @param colors Arrray of Color3\n   * @returns Uin8Array of colors [r, g, b, a, r, g, b, a, ...]\n   */\n  static Color3toRGBAUint8(colors) {\n    const colorTable = new Uint8Array(colors.length * 4);\n    for (let i = 0, j = 0; i < colors.length; i++) {\n      colorTable[j++] = colors[i].r * 255;\n      colorTable[j++] = colors[i].g * 255;\n      colorTable[j++] = colors[i].b * 255;\n      colorTable[j++] = 255;\n    }\n    return colorTable;\n  }\n  /**\n   * Creates a RawTexture from an RGBA color array and sets it on the plugin material instance.\n   * @param name name of the texture\n   * @param colors Uint8Array of colors\n   */\n  static CreateColorsTexture(name, colors, colorsSampling, scene) {\n    const colorsArray = GreasedLineTools.Color3toRGBAUint8(colors);\n    const colorsTexture = new RawTexture(colorsArray, colors.length, 1, Engine.TEXTUREFORMAT_RGBA, scene, false, true, colorsSampling);\n    colorsTexture.name = name;\n    return colorsTexture;\n  }\n  /**\n   * A minimum size texture for the colors sampler2D when there is no colors texture defined yet.\n   * For fast switching using the useColors property without the need to use defines.\n   * @param scene Scene\n   */\n  static PrepareEmptyColorsTexture(scene) {\n    if (!GreasedLineMaterialDefaults.EmptyColorsTexture) {\n      const colorsArray = new Uint8Array(4);\n      GreasedLineMaterialDefaults.EmptyColorsTexture = new RawTexture(colorsArray, 1, 1, Engine.TEXTUREFORMAT_RGBA, scene, false, false, RawTexture.NEAREST_NEAREST);\n      GreasedLineMaterialDefaults.EmptyColorsTexture.name = \"grlEmptyColorsTexture\";\n    }\n  }\n  /**\n   * Diposes the shared empty colors texture\n   */\n  static DisposeEmptyColorsTexture() {\n    var _a;\n    (_a = GreasedLineMaterialDefaults.EmptyColorsTexture) === null || _a === void 0 ? void 0 : _a.dispose();\n    GreasedLineMaterialDefaults.EmptyColorsTexture = null;\n  }\n  /**\n   * Converts boolean to number.\n   * @param bool\n   * @returns 1 if true, 0 if false.\n   */\n  static BooleanToNumber(bool) {\n    return bool ? 1 : 0;\n  }\n}","map":{"version":3,"names":["Curve3","VertexBuffer","TmpVectors","Vector3","CreateTextShapePaths","RawTexture","Engine","GreasedLineMaterialDefaults","GreasedLineTools","ConvertPoints","points","length","Array","isArray","positions","j","p","push","x","y","z","vectorPoints","forEach","flatMap","p2","Float32Array","from","OmitZeroLengthPredicate","p1","p3","fileredPoints","subtract","lengthSquared","OmitDuplicatesPredicate","_SearchInPoints","ps","i","_a","equals","_b","_c","MeshesToLines","meshes","predicate","m","meshIndex","vertices","getVerticesData","PositionKind","indices","getIndices","ii","vi1","vi2","vi3","pointsFromPredicate","ToVector3Array","array","inputArray","subInputArray","subArray","ToNumberArray","v","GetPointsCountInfo","counts","total","n","GetLineLength","data","tmp","index","point1","point2","subtractToRef","SegmentizeSegmentByCount","segmentCount","dividedLinePoints","diff","divisor","setAll","segmentVector","divideToRef","nextPoint","clone","addInPlace","SegmentizeLineBySegmentLength","what","segmentLength","subLines","GetLineSegments","s","segments","Math","ceil","seg","SegmentizeLineBySegmentCount","GetMinMaxSegmentLength","sorted","sort","min","max","GetPositionOnLineByVisibility","lineSegments","lineLength","visbility","localSpace","lengthVisibilityRatio","sumSegmentLengths","segmentIndex","lineSegmentsLength","multiplyByFloats","GetCircleLinePoints","radiusX","radiusY","segmentAngle","PI","cos","sin","GetBezierLinePoints","p0","CreateQuadraticBezier","getPoints","GetArrowCap","position","direction","widthUp","widthDown","widthStartUp","widthStartDown","add","widths","GetPointsFromText","text","size","resolution","fontData","includeInner","allPoints","shapePaths","sp","paths","points2d","p2d","h","holes","Color3toRGBAUint8","colors","colorTable","Uint8Array","r","g","b","CreateColorsTexture","name","colorsSampling","scene","colorsArray","colorsTexture","TEXTUREFORMAT_RGBA","PrepareEmptyColorsTexture","EmptyColorsTexture","NEAREST_NEAREST","DisposeEmptyColorsTexture","dispose","BooleanToNumber","bool"],"sources":["../../../../dev/core/src/Misc/greasedLineTools.ts"],"sourcesContent":["import { Curve3 } from \"../Maths/math.path\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { IFontData } from \"../Meshes/Builders/textBuilder\";\r\nimport { CreateTextShapePaths } from \"../Meshes/Builders/textBuilder\";\r\nimport type { FloatArray, IndicesArray } from \"../types\";\r\nimport type { GreasedLinePoints } from \"../Meshes/GreasedLine/greasedLineBaseMesh\";\r\nimport type { Color3 } from \"../Maths/math.color\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { GreasedLineMaterialDefaults } from \"../Materials/GreasedLine/greasedLineMaterialDefaults\";\r\n\r\n/**\r\n * Tool functions for GreasedLine\r\n */\r\nexport class GreasedLineTools {\r\n    /**\r\n     * Converts GreasedLinePoints to number[][]\r\n     * @param points GreasedLinePoints\r\n     * @returns number[][] with x, y, z coordinates of the points, like [[x, y, z, x, y, z, ...], [x, y, z, ...]]\r\n     */\r\n    public static ConvertPoints(points: GreasedLinePoints): number[][] {\r\n        if (points.length && Array.isArray(points) && typeof points[0] === \"number\") {\r\n            return [<number[]>points];\r\n        } else if (points.length && Array.isArray(points[0]) && typeof points[0][0] === \"number\") {\r\n            return <number[][]>points;\r\n        } else if (points.length && !Array.isArray(points[0]) && points[0] instanceof Vector3) {\r\n            const positions: number[] = [];\r\n            for (let j = 0; j < points.length; j++) {\r\n                const p = points[j] as Vector3;\r\n                positions.push(p.x, p.y, p.z);\r\n            }\r\n            return [positions];\r\n        } else if (points.length > 0 && Array.isArray(points[0]) && points[0].length > 0 && points[0][0] instanceof Vector3) {\r\n            const positions: number[][] = [];\r\n            const vectorPoints = points as Vector3[][];\r\n            vectorPoints.forEach((p) => {\r\n                positions.push(p.flatMap((p2) => [p2.x, p2.y, p2.z]));\r\n            });\r\n            return positions;\r\n        } else if (points instanceof Float32Array) {\r\n            return [Array.from(points)];\r\n        } else if (points.length && points[0] instanceof Float32Array) {\r\n            const positions: number[][] = [];\r\n            points.forEach((p) => {\r\n                positions.push(Array.from(p as Float32Array));\r\n            });\r\n            return positions;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Omit zero length lines predicate for the MeshesToLines function\r\n     * @param p1 point1 position of the face\r\n     * @param p2 point2 position of the face\r\n     * @param p3 point3 position of the face\r\n     * @returns original points or null if any edge length is zero\r\n     */\r\n    public static OmitZeroLengthPredicate(p1: Vector3, p2: Vector3, p3: Vector3) {\r\n        const fileredPoints = [];\r\n        // edge1\r\n        if (p2.subtract(p1).lengthSquared() > 0) {\r\n            fileredPoints.push([p1, p2]);\r\n        }\r\n        // edge2\r\n        if (p3.subtract(p2).lengthSquared() > 0) {\r\n            fileredPoints.push([p2, p3]);\r\n        }\r\n        // edge3\r\n        if (p1.subtract(p3).lengthSquared() > 0) {\r\n            fileredPoints.push([p3, p1]);\r\n        }\r\n        return fileredPoints.length === 0 ? null : fileredPoints;\r\n    }\r\n\r\n    /**\r\n     * Omit duplicate lines predicate for the MeshesToLines function\r\n     * @param p1 point1 position of the face\r\n     * @param p2 point2 position of the face\r\n     * @param p3 point3 position of the face\r\n     * @returns original points or null if any edge length is zero\r\n     */\r\n    public static OmitDuplicatesPredicate(p1: Vector3, p2: Vector3, p3: Vector3, points: Vector3[][]) {\r\n        const fileredPoints = [];\r\n        // edge1\r\n        if (!GreasedLineTools._SearchInPoints(p1, p2, points)) {\r\n            fileredPoints.push([p1, p2]);\r\n        }\r\n        // edge2\r\n        if (!GreasedLineTools._SearchInPoints(p2, p3, points)) {\r\n            fileredPoints.push([p2, p3]);\r\n        }\r\n        // edge3\r\n        if (!GreasedLineTools._SearchInPoints(p3, p1, points)) {\r\n            fileredPoints.push([p3, p1]);\r\n        }\r\n        return fileredPoints.length === 0 ? null : fileredPoints;\r\n    }\r\n\r\n    private static _SearchInPoints(p1: Vector3, p2: Vector3, points: Vector3[][]) {\r\n        for (const ps of points) {\r\n            for (let i = 0; i < ps.length; i++) {\r\n                if (ps[i]?.equals(p1)) {\r\n                    // find the first point\r\n                    // if it has a sibling of p2 the line already exists\r\n                    if (ps[i + 1]?.equals(p2) || ps[i - 1]?.equals(p2)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets mesh triangles as line positions\r\n     * @param meshes array of meshes\r\n     * @param predicate predicate function which decides whether to include the mesh triangle/face in the ouput\r\n     * @returns array of arrays of points\r\n     */\r\n    public static MeshesToLines(\r\n        meshes: AbstractMesh[],\r\n        predicate?: (\r\n            p1: Vector3,\r\n            p2: Vector3,\r\n            p3: Vector3,\r\n            points: Vector3[][],\r\n            indiceIndex: number,\r\n            vertexIndex: number,\r\n            mesh: AbstractMesh,\r\n            meshIndex: number,\r\n            vertices: FloatArray,\r\n            indices: IndicesArray\r\n        ) => Vector3[][]\r\n    ) {\r\n        const points: Vector3[][] = [];\r\n\r\n        meshes.forEach((m, meshIndex) => {\r\n            const vertices = m.getVerticesData(VertexBuffer.PositionKind);\r\n            const indices = m.getIndices();\r\n            if (vertices && indices) {\r\n                for (let i = 0, ii = 0; i < indices.length; i++) {\r\n                    const vi1 = indices[ii++] * 3;\r\n                    const vi2 = indices[ii++] * 3;\r\n                    const vi3 = indices[ii++] * 3;\r\n\r\n                    const p1 = new Vector3(vertices[vi1], vertices[vi1 + 1], vertices[vi1 + 2]);\r\n                    const p2 = new Vector3(vertices[vi2], vertices[vi2 + 1], vertices[vi2 + 2]);\r\n                    const p3 = new Vector3(vertices[vi3], vertices[vi3 + 1], vertices[vi3 + 2]);\r\n\r\n                    if (predicate) {\r\n                        const pointsFromPredicate = predicate(p1, p2, p3, points, i, vi1, m, meshIndex, vertices, indices);\r\n                        if (pointsFromPredicate) {\r\n                            for (const p of pointsFromPredicate) {\r\n                                points.push(p);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        points.push([p1, p2], [p2, p3], [p3, p1]);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        return points;\r\n    }\r\n\r\n    /**\r\n     * Converts number coordinates to Vector3s\r\n     * @param points number array of x, y, z, x, y z, ... coordinates\r\n     * @returns Vector3 array\r\n     */\r\n    public static ToVector3Array(points: number[] | number[][]) {\r\n        if (Array.isArray(points[0])) {\r\n            const array: Vector3[][] = [];\r\n            const inputArray = points as number[][];\r\n            for (const subInputArray of inputArray) {\r\n                const subArray: Vector3[] = [];\r\n                for (let i = 0; i < subInputArray.length; i += 3) {\r\n                    subArray.push(new Vector3(subInputArray[i], subInputArray[i + 1], subInputArray[i + 2]));\r\n                }\r\n                array.push(subArray);\r\n            }\r\n            return array;\r\n        }\r\n\r\n        const inputArray = points as number[];\r\n        const array: Vector3[] = [];\r\n        for (let i = 0; i < inputArray.length; i += 3) {\r\n            array.push(new Vector3(inputArray[i], inputArray[i + 1], inputArray[i + 2]));\r\n        }\r\n        return array;\r\n    }\r\n\r\n    /**\r\n     * Gets a number array from a Vector3 array.\r\n     * You can you for example to convert your Vector3[] offsets to the required number[] for the offsets option.\r\n     * @param points Vector3 array\r\n     * @returns an array of x, y, z coordinates as numbers [x, y, z, x, y, z, x, y, z, ....]\r\n     */\r\n    public static ToNumberArray(points: Vector3[]) {\r\n        return points.flatMap((v) => [v.x, v.y, v.z]);\r\n    }\r\n\r\n    /**\r\n     * Calculates the sum of points of every line and the number of points in each line.\r\n     * This function is useful when you are drawing multiple lines in one mesh and you want\r\n     * to know the counts. For example for creating an offsets table.\r\n     * @param points point array\r\n     * @returns points count info\r\n     */\r\n    public static GetPointsCountInfo(points: number[][]): { total: number; counts: number[] } {\r\n        const counts = new Array(points.length);\r\n        let total = 0;\r\n        for (let n = points.length; n--; ) {\r\n            counts[n] = points[n].length / 3;\r\n            total += counts[n];\r\n        }\r\n        return { total, counts };\r\n    }\r\n\r\n    /**\r\n     * Gets the length of the line counting all it's segments length\r\n     * @param data array of line points\r\n     * @returns length of the line\r\n     */\r\n    public static GetLineLength(data: Vector3[] | number[]): number {\r\n        if (data.length === 0) {\r\n            return 0;\r\n        }\r\n\r\n        let points: Vector3[];\r\n        if (typeof data[0] === \"number\") {\r\n            points = GreasedLineTools.ToVector3Array(<number[]>data) as Vector3[];\r\n        } else {\r\n            points = data as Vector3[];\r\n        }\r\n\r\n        const tmp = TmpVectors.Vector3[0];\r\n        let length = 0;\r\n        for (let index = 0; index < points.length - 1; index++) {\r\n            const point1 = points[index];\r\n            const point2 = points[index + 1];\r\n            length += point2.subtractToRef(point1, tmp).length();\r\n        }\r\n        return length;\r\n    }\r\n\r\n    /**\r\n     * Divides a segment into smaller segments.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param point1 first point of the line\r\n     * @param point2 second point of the line\r\n     * @param segmentCount number of segments we want to have in the divided line\r\n     * @returns\r\n     */\r\n    public static SegmentizeSegmentByCount(point1: Vector3, point2: Vector3, segmentCount: number): Vector3[] {\r\n        const dividedLinePoints: Vector3[] = [];\r\n        const diff = point2.subtract(point1);\r\n        const divisor = TmpVectors.Vector3[0];\r\n        divisor.setAll(segmentCount);\r\n        const segmentVector = TmpVectors.Vector3[1];\r\n        diff.divideToRef(divisor, segmentVector);\r\n\r\n        let nextPoint = point1.clone();\r\n        dividedLinePoints.push(nextPoint);\r\n        for (let index = 0; index < segmentCount; index++) {\r\n            nextPoint = nextPoint.clone();\r\n            dividedLinePoints.push(nextPoint.addInPlace(segmentVector));\r\n        }\r\n\r\n        return dividedLinePoints;\r\n    }\r\n\r\n    /**\r\n     * Divides a line into segments.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param what line points\r\n     * @param segmentLength length of each segment of the resulting line (distance between two line points)\r\n     * @returns line point\r\n     */\r\n    public static SegmentizeLineBySegmentLength(what: Vector3[] | number[] | { point1: Vector3; point2: Vector3; length: number }[], segmentLength: number): Vector3[] {\r\n        const subLines =\r\n            what[0] instanceof Vector3\r\n                ? GreasedLineTools.GetLineSegments(what as Vector3[])\r\n                : typeof what[0] === \"number\"\r\n                ? GreasedLineTools.GetLineSegments(GreasedLineTools.ToVector3Array(what as number[]) as Vector3[])\r\n                : (what as { point1: Vector3; point2: Vector3; length: number }[]);\r\n        const points: Vector3[] = [];\r\n        subLines.forEach((s) => {\r\n            if (s.length > segmentLength) {\r\n                const segments = GreasedLineTools.SegmentizeSegmentByCount(s.point1, s.point2, Math.ceil(s.length / segmentLength));\r\n                segments.forEach((seg) => {\r\n                    points.push(seg);\r\n                });\r\n            } else {\r\n                points.push(s.point1);\r\n                points.push(s.point2);\r\n            }\r\n        });\r\n        return points;\r\n    }\r\n\r\n    /**\r\n     * Divides a line into segments.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param what line points\r\n     * @param segmentCount number of segments\r\n     * @returns line point\r\n     */\r\n    public static SegmentizeLineBySegmentCount(what: Vector3[] | number[], segmentCount: number): Vector3[] {\r\n        const points = <Vector3[]>(typeof what[0] === \"number\" ? GreasedLineTools.ToVector3Array(<number[]>what) : what);\r\n        const segmentLength = GreasedLineTools.GetLineLength(points) / segmentCount;\r\n        return GreasedLineTools.SegmentizeLineBySegmentLength(points, segmentLength);\r\n    }\r\n    /**\r\n     * Gets line segments.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param points line points\r\n     * @returns segments information of the line segment including starting point, ending point and the distance between them\r\n     */\r\n    public static GetLineSegments(points: Vector3[]): { point1: Vector3; point2: Vector3; length: number }[] {\r\n        const segments = [];\r\n        for (let index = 0; index < points.length - 1; index++) {\r\n            const point1 = points[index];\r\n            const point2 = points[index + 1];\r\n            const length = point2.subtract(point1).length();\r\n            segments.push({ point1, point2, length });\r\n        }\r\n\r\n        return segments;\r\n    }\r\n\r\n    /**\r\n     * Gets the minimum and the maximum length of a line segment in the line.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param points line points\r\n     * @returns\r\n     */\r\n    public static GetMinMaxSegmentLength(points: Vector3[]): { min: number; max: number } {\r\n        const subLines = GreasedLineTools.GetLineSegments(points);\r\n        const sorted = subLines.sort((s) => s.length);\r\n        return {\r\n            min: sorted[0].length,\r\n            max: sorted[sorted.length - 1].length,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Finds the last visible position in world space of the line according to the visibility parameter\r\n     * @param lineSegments segments of the line\r\n     * @param lineLength total length of the line\r\n     * @param visbility normalized value of visibility\r\n     * @returns world space coordinate of the last visible piece of the line\r\n     */\r\n    public static GetPositionOnLineByVisibility(lineSegments: { point1: Vector3; point2: Vector3; length: number }[], lineLength: number, visbility: number, localSpace = false) {\r\n        const lengthVisibilityRatio = lineLength * visbility;\r\n        let sumSegmentLengths = 0;\r\n        let segmentIndex = 0;\r\n\r\n        const lineSegmentsLength = lineSegments.length;\r\n        for (let i = 0; i < lineSegmentsLength; i++) {\r\n            if (lengthVisibilityRatio <= sumSegmentLengths + lineSegments[i].length) {\r\n                segmentIndex = i;\r\n                break;\r\n            }\r\n            sumSegmentLengths += lineSegments[i].length;\r\n        }\r\n\r\n        const s = (lengthVisibilityRatio - sumSegmentLengths) / lineSegments[segmentIndex].length;\r\n\r\n        lineSegments[segmentIndex].point2.subtractToRef(lineSegments[segmentIndex].point1, TmpVectors.Vector3[0]);\r\n        TmpVectors.Vector3[1] = TmpVectors.Vector3[0].multiplyByFloats(s, s, s);\r\n        if (!localSpace) {\r\n            TmpVectors.Vector3[1].addInPlace(lineSegments[segmentIndex].point1);\r\n        }\r\n\r\n        return TmpVectors.Vector3[1].clone();\r\n    }\r\n\r\n    /**\r\n     * Creates lines in a shape of circle/arc.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param radiusX radiusX of the circle\r\n     * @param segments number of segments in the circle\r\n     * @param z z coordinate of the points. Defaults to 0.\r\n     * @param radiusY radiusY of the circle - you can draw an oval if using different values\r\n     * @param segmentAngle angle offset of the segments. Defaults to Math.PI * 2 / segments. Change this value to draw a part of the circle.\r\n     * @returns line points\r\n     */\r\n    public static GetCircleLinePoints(radiusX: number, segments: number, z = 0, radiusY = radiusX, segmentAngle = (Math.PI * 2) / segments) {\r\n        const points: Vector3[] = [];\r\n        for (let i = 0; i <= segments; i++) {\r\n            points.push(new Vector3(Math.cos(i * segmentAngle) * radiusX, Math.sin(i * segmentAngle) * radiusY, z));\r\n        }\r\n        return points;\r\n    }\r\n\r\n    /**\r\n     * Gets line points in a shape of a bezier curve\r\n     * @param p0 bezier point0\r\n     * @param p1 bezier point1\r\n     * @param p2 bezier point2\r\n     * @param segments number of segments in the curve\r\n     * @returns\r\n     */\r\n    public static GetBezierLinePoints(p0: Vector3, p1: Vector3, p2: Vector3, segments: number) {\r\n        return Curve3.CreateQuadraticBezier(p0, p1, p2, segments)\r\n            .getPoints()\r\n            .flatMap((v) => [v.x, v.y, v.z]);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param position position of the arrow cap (mainly you want to create a triangle, set widthUp and widthDown to the same value and omit widthStartUp and widthStartDown)\r\n     * @param direction direction which the arrow points to\r\n     * @param length length (size) of the arrow cap itself\r\n     * @param widthUp the arrow width above the line\r\n     * @param widthDown the arrow width belove the line\r\n     * @param widthStartUp the arrow width at the start of the arrow above the line. In most scenarios this is 0.\r\n     * @param widthStartDown the arrow width at the start of the arrow below the line. In most scenarios this is 0.\r\n     * @returns\r\n     */\r\n    public static GetArrowCap(position: Vector3, direction: Vector3, length: number, widthUp: number, widthDown: number, widthStartUp = 0, widthStartDown = 0) {\r\n        const points = [position.clone(), position.add(direction.multiplyByFloats(length, length, length))];\r\n        const widths = [widthUp, widthDown, widthStartUp, widthStartDown];\r\n\r\n        return {\r\n            points,\r\n            widths,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets 3D positions of points from a text and font\r\n     * @param text Text\r\n     * @param size Size of the font\r\n     * @param resolution Resolution of the font\r\n     * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)\r\n     * @param z z coordinate\r\n     * @param includeInner include the inner parts of the font in the result. Default true. If false, only the outlines will be returned.\r\n     * @returns number[][] of 3D positions\r\n     */\r\n    public static GetPointsFromText(text: string, size: number, resolution: number, fontData: IFontData, z = 0, includeInner = true) {\r\n        const allPoints = [];\r\n        const shapePaths = CreateTextShapePaths(text, size, resolution, fontData);\r\n\r\n        for (const sp of shapePaths) {\r\n            for (const p of sp.paths) {\r\n                const points = [];\r\n                const points2d = p.getPoints();\r\n                for (const p2d of points2d) {\r\n                    points.push(p2d.x, p2d.y, z);\r\n                }\r\n                allPoints.push(points);\r\n            }\r\n\r\n            if (includeInner) {\r\n                for (const h of sp.holes) {\r\n                    const holes = [];\r\n                    const points2d = h.getPoints();\r\n                    for (const p2d of points2d) {\r\n                        holes.push(p2d.x, p2d.y, z);\r\n                    }\r\n                    allPoints.push(holes);\r\n                }\r\n            }\r\n        }\r\n\r\n        return allPoints;\r\n    }\r\n\r\n    /**\r\n     * Converts an array of Color3 to Uint8Array\r\n     * @param colors Arrray of Color3\r\n     * @returns Uin8Array of colors [r, g, b, a, r, g, b, a, ...]\r\n     */\r\n    public static Color3toRGBAUint8(colors: Color3[]) {\r\n        const colorTable: Uint8Array = new Uint8Array(colors.length * 4);\r\n        for (let i = 0, j = 0; i < colors.length; i++) {\r\n            colorTable[j++] = colors[i].r * 255;\r\n            colorTable[j++] = colors[i].g * 255;\r\n            colorTable[j++] = colors[i].b * 255;\r\n            colorTable[j++] = 255;\r\n        }\r\n\r\n        return colorTable;\r\n    }\r\n\r\n    /**\r\n     * Creates a RawTexture from an RGBA color array and sets it on the plugin material instance.\r\n     * @param name name of the texture\r\n     * @param colors Uint8Array of colors\r\n     */\r\n    public static CreateColorsTexture(name: string, colors: Color3[], colorsSampling: number, scene: Scene) {\r\n        const colorsArray = GreasedLineTools.Color3toRGBAUint8(colors);\r\n        const colorsTexture = new RawTexture(colorsArray, colors.length, 1, Engine.TEXTUREFORMAT_RGBA, scene, false, true, colorsSampling);\r\n        colorsTexture.name = name;\r\n        return colorsTexture;\r\n    }\r\n\r\n    /**\r\n     * A minimum size texture for the colors sampler2D when there is no colors texture defined yet.\r\n     * For fast switching using the useColors property without the need to use defines.\r\n     * @param scene Scene\r\n     */\r\n    public static PrepareEmptyColorsTexture(scene: Scene) {\r\n        if (!GreasedLineMaterialDefaults.EmptyColorsTexture) {\r\n            const colorsArray = new Uint8Array(4);\r\n            GreasedLineMaterialDefaults.EmptyColorsTexture = new RawTexture(colorsArray, 1, 1, Engine.TEXTUREFORMAT_RGBA, scene, false, false, RawTexture.NEAREST_NEAREST);\r\n            GreasedLineMaterialDefaults.EmptyColorsTexture.name = \"grlEmptyColorsTexture\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Diposes the shared empty colors texture\r\n     */\r\n    public static DisposeEmptyColorsTexture() {\r\n        GreasedLineMaterialDefaults.EmptyColorsTexture?.dispose();\r\n        GreasedLineMaterialDefaults.EmptyColorsTexture = null;\r\n    }\r\n\r\n    /**\r\n     * Converts boolean to number.\r\n     * @param bool\r\n     * @returns 1 if true, 0 if false.\r\n     */\r\n    public static BooleanToNumber(bool?: boolean) {\r\n        return bool ? 1 : 0;\r\n    }\r\n}\r\n"],"mappings":";;;;AAAA,SAASA,MAAM,QAAQ,uBAAqB;AAC5C,SAASC,YAAY,QAAQ,sBAAoB;AACjD,SAASC,UAAU,EAAEC,OAAO,QAAQ,yBAAuB;AAG3D,SAASC,oBAAoB,QAAQ,mCAAiC;AAItE,SAASC,UAAU,QAAQ,qCAAmC;AAE9D,SAASC,MAAM,QAAQ,sBAAoB;AAC3C,SAASC,2BAA2B,QAAQ,yDAAuD;AAEnG;;;AAGA,OAAM,MAAOC,gBAAgB;EACzB;;;;;EAKO,OAAOC,aAAaA,CAACC,MAAyB;IACjD,IAAIA,MAAM,CAACC,MAAM,IAAIC,KAAK,CAACC,OAAO,CAACH,MAAM,CAAC,IAAI,OAAOA,MAAM,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;MACzE,OAAO,CAAWA,MAAM,CAAC;KAC5B,MAAM,IAAIA,MAAM,CAACC,MAAM,IAAIC,KAAK,CAACC,OAAO,CAACH,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,OAAOA,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;MACtF,OAAmBA,MAAM;KAC5B,MAAM,IAAIA,MAAM,CAACC,MAAM,IAAI,CAACC,KAAK,CAACC,OAAO,CAACH,MAAM,CAAC,CAAC,CAAC,CAAC,IAAIA,MAAM,CAAC,CAAC,CAAC,YAAYP,OAAO,EAAE;MACnF,MAAMW,SAAS,GAAa,EAAE;MAC9B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,MAAM,CAACC,MAAM,EAAEI,CAAC,EAAE,EAAE;QACpC,MAAMC,CAAC,GAAGN,MAAM,CAACK,CAAC,CAAY;QAC9BD,SAAS,CAACG,IAAI,CAACD,CAAC,CAACE,CAAC,EAAEF,CAAC,CAACG,CAAC,EAAEH,CAAC,CAACI,CAAC,CAAC;;MAEjC,OAAO,CAACN,SAAS,CAAC;KACrB,MAAM,IAAIJ,MAAM,CAACC,MAAM,GAAG,CAAC,IAAIC,KAAK,CAACC,OAAO,CAACH,MAAM,CAAC,CAAC,CAAC,CAAC,IAAIA,MAAM,CAAC,CAAC,CAAC,CAACC,MAAM,GAAG,CAAC,IAAID,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,YAAYP,OAAO,EAAE;MACjH,MAAMW,SAAS,GAAe,EAAE;MAChC,MAAMO,YAAY,GAAGX,MAAqB;MAC1CW,YAAY,CAACC,OAAO,CAAEN,CAAC,IAAI;QACvBF,SAAS,CAACG,IAAI,CAACD,CAAC,CAACO,OAAO,CAAEC,EAAE,IAAK,CAACA,EAAE,CAACN,CAAC,EAAEM,EAAE,CAACL,CAAC,EAAEK,EAAE,CAACJ,CAAC,CAAC,CAAC,CAAC;MACzD,CAAC,CAAC;MACF,OAAON,SAAS;KACnB,MAAM,IAAIJ,MAAM,YAAYe,YAAY,EAAE;MACvC,OAAO,CAACb,KAAK,CAACc,IAAI,CAAChB,MAAM,CAAC,CAAC;KAC9B,MAAM,IAAIA,MAAM,CAACC,MAAM,IAAID,MAAM,CAAC,CAAC,CAAC,YAAYe,YAAY,EAAE;MAC3D,MAAMX,SAAS,GAAe,EAAE;MAChCJ,MAAM,CAACY,OAAO,CAAEN,CAAC,IAAI;QACjBF,SAAS,CAACG,IAAI,CAACL,KAAK,CAACc,IAAI,CAACV,CAAiB,CAAC,CAAC;MACjD,CAAC,CAAC;MACF,OAAOF,SAAS;;IAGpB,OAAO,EAAE;EACb;EAEA;;;;;;;EAOO,OAAOa,uBAAuBA,CAACC,EAAW,EAAEJ,EAAW,EAAEK,EAAW;IACvE,MAAMC,aAAa,GAAG,EAAE;IACxB;IACA,IAAIN,EAAE,CAACO,QAAQ,CAACH,EAAE,CAAC,CAACI,aAAa,EAAE,GAAG,CAAC,EAAE;MACrCF,aAAa,CAACb,IAAI,CAAC,CAACW,EAAE,EAAEJ,EAAE,CAAC,CAAC;;IAEhC;IACA,IAAIK,EAAE,CAACE,QAAQ,CAACP,EAAE,CAAC,CAACQ,aAAa,EAAE,GAAG,CAAC,EAAE;MACrCF,aAAa,CAACb,IAAI,CAAC,CAACO,EAAE,EAAEK,EAAE,CAAC,CAAC;;IAEhC;IACA,IAAID,EAAE,CAACG,QAAQ,CAACF,EAAE,CAAC,CAACG,aAAa,EAAE,GAAG,CAAC,EAAE;MACrCF,aAAa,CAACb,IAAI,CAAC,CAACY,EAAE,EAAED,EAAE,CAAC,CAAC;;IAEhC,OAAOE,aAAa,CAACnB,MAAM,KAAK,CAAC,GAAG,IAAI,GAAGmB,aAAa;EAC5D;EAEA;;;;;;;EAOO,OAAOG,uBAAuBA,CAACL,EAAW,EAAEJ,EAAW,EAAEK,EAAW,EAAEnB,MAAmB;IAC5F,MAAMoB,aAAa,GAAG,EAAE;IACxB;IACA,IAAI,CAACtB,gBAAgB,CAAC0B,eAAe,CAACN,EAAE,EAAEJ,EAAE,EAAEd,MAAM,CAAC,EAAE;MACnDoB,aAAa,CAACb,IAAI,CAAC,CAACW,EAAE,EAAEJ,EAAE,CAAC,CAAC;;IAEhC;IACA,IAAI,CAAChB,gBAAgB,CAAC0B,eAAe,CAACV,EAAE,EAAEK,EAAE,EAAEnB,MAAM,CAAC,EAAE;MACnDoB,aAAa,CAACb,IAAI,CAAC,CAACO,EAAE,EAAEK,EAAE,CAAC,CAAC;;IAEhC;IACA,IAAI,CAACrB,gBAAgB,CAAC0B,eAAe,CAACL,EAAE,EAAED,EAAE,EAAElB,MAAM,CAAC,EAAE;MACnDoB,aAAa,CAACb,IAAI,CAAC,CAACY,EAAE,EAAED,EAAE,CAAC,CAAC;;IAEhC,OAAOE,aAAa,CAACnB,MAAM,KAAK,CAAC,GAAG,IAAI,GAAGmB,aAAa;EAC5D;EAEQ,OAAOI,eAAeA,CAACN,EAAW,EAAEJ,EAAW,EAAEd,MAAmB;;IACxE,KAAK,MAAMyB,EAAE,IAAIzB,MAAM,EAAE;MACrB,KAAK,IAAI0B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,EAAE,CAACxB,MAAM,EAAEyB,CAAC,EAAE,EAAE;QAChC,IAAI,CAAAC,EAAA,GAAAF,EAAE,CAACC,CAAC,CAAC,cAAAC,EAAA,uBAAAA,EAAA,CAAEC,MAAM,CAACV,EAAE,CAAC,EAAE;UACnB;UACA;UACA,IAAI,EAAAW,EAAA,GAAAJ,EAAE,CAACC,CAAC,GAAG,CAAC,CAAC,cAAAG,EAAA,uBAAAA,EAAA,CAAED,MAAM,CAACd,EAAE,CAAC,MAAI,CAAAgB,EAAA,GAAAL,EAAE,CAACC,CAAC,GAAG,CAAC,CAAC,cAAAI,EAAA,uBAAAA,EAAA,CAAEF,MAAM,CAACd,EAAE,CAAC,GAAE;YAChD,OAAO,IAAI;;;;;IAK3B,OAAO,KAAK;EAChB;EAEA;;;;;;EAMO,OAAOiB,aAAaA,CACvBC,MAAsB,EACtBC,SAWgB;IAEhB,MAAMjC,MAAM,GAAgB,EAAE;IAE9BgC,MAAM,CAACpB,OAAO,CAAC,CAACsB,CAAC,EAAEC,SAAS,KAAI;MAC5B,MAAMC,QAAQ,GAAGF,CAAC,CAACG,eAAe,CAAC9C,YAAY,CAAC+C,YAAY,CAAC;MAC7D,MAAMC,OAAO,GAAGL,CAAC,CAACM,UAAU,EAAE;MAC9B,IAAIJ,QAAQ,IAAIG,OAAO,EAAE;QACrB,KAAK,IAAIb,CAAC,GAAG,CAAC,EAAEe,EAAE,GAAG,CAAC,EAAEf,CAAC,GAAGa,OAAO,CAACtC,MAAM,EAAEyB,CAAC,EAAE,EAAE;UAC7C,MAAMgB,GAAG,GAAGH,OAAO,CAACE,EAAE,EAAE,CAAC,GAAG,CAAC;UAC7B,MAAME,GAAG,GAAGJ,OAAO,CAACE,EAAE,EAAE,CAAC,GAAG,CAAC;UAC7B,MAAMG,GAAG,GAAGL,OAAO,CAACE,EAAE,EAAE,CAAC,GAAG,CAAC;UAE7B,MAAMvB,EAAE,GAAG,IAAIzB,OAAO,CAAC2C,QAAQ,CAACM,GAAG,CAAC,EAAEN,QAAQ,CAACM,GAAG,GAAG,CAAC,CAAC,EAAEN,QAAQ,CAACM,GAAG,GAAG,CAAC,CAAC,CAAC;UAC3E,MAAM5B,EAAE,GAAG,IAAIrB,OAAO,CAAC2C,QAAQ,CAACO,GAAG,CAAC,EAAEP,QAAQ,CAACO,GAAG,GAAG,CAAC,CAAC,EAAEP,QAAQ,CAACO,GAAG,GAAG,CAAC,CAAC,CAAC;UAC3E,MAAMxB,EAAE,GAAG,IAAI1B,OAAO,CAAC2C,QAAQ,CAACQ,GAAG,CAAC,EAAER,QAAQ,CAACQ,GAAG,GAAG,CAAC,CAAC,EAAER,QAAQ,CAACQ,GAAG,GAAG,CAAC,CAAC,CAAC;UAE3E,IAAIX,SAAS,EAAE;YACX,MAAMY,mBAAmB,GAAGZ,SAAS,CAACf,EAAE,EAAEJ,EAAE,EAAEK,EAAE,EAAEnB,MAAM,EAAE0B,CAAC,EAAEgB,GAAG,EAAER,CAAC,EAAEC,SAAS,EAAEC,QAAQ,EAAEG,OAAO,CAAC;YAClG,IAAIM,mBAAmB,EAAE;cACrB,KAAK,MAAMvC,CAAC,IAAIuC,mBAAmB,EAAE;gBACjC7C,MAAM,CAACO,IAAI,CAACD,CAAC,CAAC;;;WAGzB,MAAM;YACHN,MAAM,CAACO,IAAI,CAAC,CAACW,EAAE,EAAEJ,EAAE,CAAC,EAAE,CAACA,EAAE,EAAEK,EAAE,CAAC,EAAE,CAACA,EAAE,EAAED,EAAE,CAAC,CAAC;;;;IAIzD,CAAC,CAAC;IAEF,OAAOlB,MAAM;EACjB;EAEA;;;;;EAKO,OAAO8C,cAAcA,CAAC9C,MAA6B;IACtD,IAAIE,KAAK,CAACC,OAAO,CAACH,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;MAC1B,MAAM+C,KAAK,GAAgB,EAAE;MAC7B,MAAMC,UAAU,GAAGhD,MAAoB;MACvC,KAAK,MAAMiD,aAAa,IAAID,UAAU,EAAE;QACpC,MAAME,QAAQ,GAAc,EAAE;QAC9B,KAAK,IAAIxB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuB,aAAa,CAAChD,MAAM,EAAEyB,CAAC,IAAI,CAAC,EAAE;UAC9CwB,QAAQ,CAAC3C,IAAI,CAAC,IAAId,OAAO,CAACwD,aAAa,CAACvB,CAAC,CAAC,EAAEuB,aAAa,CAACvB,CAAC,GAAG,CAAC,CAAC,EAAEuB,aAAa,CAACvB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;QAE5FqB,KAAK,CAACxC,IAAI,CAAC2C,QAAQ,CAAC;;MAExB,OAAOH,KAAK;;IAGhB,MAAMC,UAAU,GAAGhD,MAAkB;IACrC,MAAM+C,KAAK,GAAc,EAAE;IAC3B,KAAK,IAAIrB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsB,UAAU,CAAC/C,MAAM,EAAEyB,CAAC,IAAI,CAAC,EAAE;MAC3CqB,KAAK,CAACxC,IAAI,CAAC,IAAId,OAAO,CAACuD,UAAU,CAACtB,CAAC,CAAC,EAAEsB,UAAU,CAACtB,CAAC,GAAG,CAAC,CAAC,EAAEsB,UAAU,CAACtB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;IAEhF,OAAOqB,KAAK;EAChB;EAEA;;;;;;EAMO,OAAOI,aAAaA,CAACnD,MAAiB;IACzC,OAAOA,MAAM,CAACa,OAAO,CAAEuC,CAAC,IAAK,CAACA,CAAC,CAAC5C,CAAC,EAAE4C,CAAC,CAAC3C,CAAC,EAAE2C,CAAC,CAAC1C,CAAC,CAAC,CAAC;EACjD;EAEA;;;;;;;EAOO,OAAO2C,kBAAkBA,CAACrD,MAAkB;IAC/C,MAAMsD,MAAM,GAAG,IAAIpD,KAAK,CAACF,MAAM,CAACC,MAAM,CAAC;IACvC,IAAIsD,KAAK,GAAG,CAAC;IACb,KAAK,IAAIC,CAAC,GAAGxD,MAAM,CAACC,MAAM,EAAEuD,CAAC,EAAE,GAAI;MAC/BF,MAAM,CAACE,CAAC,CAAC,GAAGxD,MAAM,CAACwD,CAAC,CAAC,CAACvD,MAAM,GAAG,CAAC;MAChCsD,KAAK,IAAID,MAAM,CAACE,CAAC,CAAC;;IAEtB,OAAO;MAAED,KAAK;MAAED;IAAM,CAAE;EAC5B;EAEA;;;;;EAKO,OAAOG,aAAaA,CAACC,IAA0B;IAClD,IAAIA,IAAI,CAACzD,MAAM,KAAK,CAAC,EAAE;MACnB,OAAO,CAAC;;IAGZ,IAAID,MAAiB;IACrB,IAAI,OAAO0D,IAAI,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;MAC7B1D,MAAM,GAAGF,gBAAgB,CAACgD,cAAc,CAAWY,IAAI,CAAc;KACxE,MAAM;MACH1D,MAAM,GAAG0D,IAAiB;;IAG9B,MAAMC,GAAG,GAAGnE,UAAU,CAACC,OAAO,CAAC,CAAC,CAAC;IACjC,IAAIQ,MAAM,GAAG,CAAC;IACd,KAAK,IAAI2D,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG5D,MAAM,CAACC,MAAM,GAAG,CAAC,EAAE2D,KAAK,EAAE,EAAE;MACpD,MAAMC,MAAM,GAAG7D,MAAM,CAAC4D,KAAK,CAAC;MAC5B,MAAME,MAAM,GAAG9D,MAAM,CAAC4D,KAAK,GAAG,CAAC,CAAC;MAChC3D,MAAM,IAAI6D,MAAM,CAACC,aAAa,CAACF,MAAM,EAAEF,GAAG,CAAC,CAAC1D,MAAM,EAAE;;IAExD,OAAOA,MAAM;EACjB;EAEA;;;;;;;;EAQO,OAAO+D,wBAAwBA,CAACH,MAAe,EAAEC,MAAe,EAAEG,YAAoB;IACzF,MAAMC,iBAAiB,GAAc,EAAE;IACvC,MAAMC,IAAI,GAAGL,MAAM,CAACzC,QAAQ,CAACwC,MAAM,CAAC;IACpC,MAAMO,OAAO,GAAG5E,UAAU,CAACC,OAAO,CAAC,CAAC,CAAC;IACrC2E,OAAO,CAACC,MAAM,CAACJ,YAAY,CAAC;IAC5B,MAAMK,aAAa,GAAG9E,UAAU,CAACC,OAAO,CAAC,CAAC,CAAC;IAC3C0E,IAAI,CAACI,WAAW,CAACH,OAAO,EAAEE,aAAa,CAAC;IAExC,IAAIE,SAAS,GAAGX,MAAM,CAACY,KAAK,EAAE;IAC9BP,iBAAiB,CAAC3D,IAAI,CAACiE,SAAS,CAAC;IACjC,KAAK,IAAIZ,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGK,YAAY,EAAEL,KAAK,EAAE,EAAE;MAC/CY,SAAS,GAAGA,SAAS,CAACC,KAAK,EAAE;MAC7BP,iBAAiB,CAAC3D,IAAI,CAACiE,SAAS,CAACE,UAAU,CAACJ,aAAa,CAAC,CAAC;;IAG/D,OAAOJ,iBAAiB;EAC5B;EAEA;;;;;;;EAOO,OAAOS,6BAA6BA,CAACC,IAAmF,EAAEC,aAAqB;IAClJ,MAAMC,QAAQ,GACVF,IAAI,CAAC,CAAC,CAAC,YAAYnF,OAAO,GACpBK,gBAAgB,CAACiF,eAAe,CAACH,IAAiB,CAAC,GACnD,OAAOA,IAAI,CAAC,CAAC,CAAC,KAAK,QAAQ,GAC3B9E,gBAAgB,CAACiF,eAAe,CAACjF,gBAAgB,CAACgD,cAAc,CAAC8B,IAAgB,CAAc,CAAC,GAC/FA,IAA+D;IAC1E,MAAM5E,MAAM,GAAc,EAAE;IAC5B8E,QAAQ,CAAClE,OAAO,CAAEoE,CAAC,IAAI;MACnB,IAAIA,CAAC,CAAC/E,MAAM,GAAG4E,aAAa,EAAE;QAC1B,MAAMI,QAAQ,GAAGnF,gBAAgB,CAACkE,wBAAwB,CAACgB,CAAC,CAACnB,MAAM,EAAEmB,CAAC,CAAClB,MAAM,EAAEoB,IAAI,CAACC,IAAI,CAACH,CAAC,CAAC/E,MAAM,GAAG4E,aAAa,CAAC,CAAC;QACnHI,QAAQ,CAACrE,OAAO,CAAEwE,GAAG,IAAI;UACrBpF,MAAM,CAACO,IAAI,CAAC6E,GAAG,CAAC;QACpB,CAAC,CAAC;OACL,MAAM;QACHpF,MAAM,CAACO,IAAI,CAACyE,CAAC,CAACnB,MAAM,CAAC;QACrB7D,MAAM,CAACO,IAAI,CAACyE,CAAC,CAAClB,MAAM,CAAC;;IAE7B,CAAC,CAAC;IACF,OAAO9D,MAAM;EACjB;EAEA;;;;;;;EAOO,OAAOqF,4BAA4BA,CAACT,IAA0B,EAAEX,YAAoB;IACvF,MAAMjE,MAAM,GAAe,OAAO4E,IAAI,CAAC,CAAC,CAAC,KAAK,QAAQ,GAAG9E,gBAAgB,CAACgD,cAAc,CAAW8B,IAAI,CAAC,GAAGA,IAAK;IAChH,MAAMC,aAAa,GAAG/E,gBAAgB,CAAC2D,aAAa,CAACzD,MAAM,CAAC,GAAGiE,YAAY;IAC3E,OAAOnE,gBAAgB,CAAC6E,6BAA6B,CAAC3E,MAAM,EAAE6E,aAAa,CAAC;EAChF;EACA;;;;;;EAMO,OAAOE,eAAeA,CAAC/E,MAAiB;IAC3C,MAAMiF,QAAQ,GAAG,EAAE;IACnB,KAAK,IAAIrB,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG5D,MAAM,CAACC,MAAM,GAAG,CAAC,EAAE2D,KAAK,EAAE,EAAE;MACpD,MAAMC,MAAM,GAAG7D,MAAM,CAAC4D,KAAK,CAAC;MAC5B,MAAME,MAAM,GAAG9D,MAAM,CAAC4D,KAAK,GAAG,CAAC,CAAC;MAChC,MAAM3D,MAAM,GAAG6D,MAAM,CAACzC,QAAQ,CAACwC,MAAM,CAAC,CAAC5D,MAAM,EAAE;MAC/CgF,QAAQ,CAAC1E,IAAI,CAAC;QAAEsD,MAAM;QAAEC,MAAM;QAAE7D;MAAM,CAAE,CAAC;;IAG7C,OAAOgF,QAAQ;EACnB;EAEA;;;;;;EAMO,OAAOK,sBAAsBA,CAACtF,MAAiB;IAClD,MAAM8E,QAAQ,GAAGhF,gBAAgB,CAACiF,eAAe,CAAC/E,MAAM,CAAC;IACzD,MAAMuF,MAAM,GAAGT,QAAQ,CAACU,IAAI,CAAER,CAAC,IAAKA,CAAC,CAAC/E,MAAM,CAAC;IAC7C,OAAO;MACHwF,GAAG,EAAEF,MAAM,CAAC,CAAC,CAAC,CAACtF,MAAM;MACrByF,GAAG,EAAEH,MAAM,CAACA,MAAM,CAACtF,MAAM,GAAG,CAAC,CAAC,CAACA;KAClC;EACL;EAEA;;;;;;;EAOO,OAAO0F,6BAA6BA,CAACC,YAAoE,EAAEC,UAAkB,EAAEC,SAAiB,EAAEC,UAAU,GAAG,KAAK;IACvK,MAAMC,qBAAqB,GAAGH,UAAU,GAAGC,SAAS;IACpD,IAAIG,iBAAiB,GAAG,CAAC;IACzB,IAAIC,YAAY,GAAG,CAAC;IAEpB,MAAMC,kBAAkB,GAAGP,YAAY,CAAC3F,MAAM;IAC9C,KAAK,IAAIyB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyE,kBAAkB,EAAEzE,CAAC,EAAE,EAAE;MACzC,IAAIsE,qBAAqB,IAAIC,iBAAiB,GAAGL,YAAY,CAAClE,CAAC,CAAC,CAACzB,MAAM,EAAE;QACrEiG,YAAY,GAAGxE,CAAC;QAChB;;MAEJuE,iBAAiB,IAAIL,YAAY,CAAClE,CAAC,CAAC,CAACzB,MAAM;;IAG/C,MAAM+E,CAAC,GAAG,CAACgB,qBAAqB,GAAGC,iBAAiB,IAAIL,YAAY,CAACM,YAAY,CAAC,CAACjG,MAAM;IAEzF2F,YAAY,CAACM,YAAY,CAAC,CAACpC,MAAM,CAACC,aAAa,CAAC6B,YAAY,CAACM,YAAY,CAAC,CAACrC,MAAM,EAAErE,UAAU,CAACC,OAAO,CAAC,CAAC,CAAC,CAAC;IACzGD,UAAU,CAACC,OAAO,CAAC,CAAC,CAAC,GAAGD,UAAU,CAACC,OAAO,CAAC,CAAC,CAAC,CAAC2G,gBAAgB,CAACpB,CAAC,EAAEA,CAAC,EAAEA,CAAC,CAAC;IACvE,IAAI,CAACe,UAAU,EAAE;MACbvG,UAAU,CAACC,OAAO,CAAC,CAAC,CAAC,CAACiF,UAAU,CAACkB,YAAY,CAACM,YAAY,CAAC,CAACrC,MAAM,CAAC;;IAGvE,OAAOrE,UAAU,CAACC,OAAO,CAAC,CAAC,CAAC,CAACgF,KAAK,EAAE;EACxC;EAEA;;;;;;;;;;EAUO,OAAO4B,mBAAmBA,CAACC,OAAe,EAAErB,QAAgB,EAAEvE,CAAC,GAAG,CAAC,EAAE6F,OAAO,GAAGD,OAAO,EAAEE,YAAY,GAAItB,IAAI,CAACuB,EAAE,GAAG,CAAC,GAAIxB,QAAQ;IAClI,MAAMjF,MAAM,GAAc,EAAE;IAC5B,KAAK,IAAI0B,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIuD,QAAQ,EAAEvD,CAAC,EAAE,EAAE;MAChC1B,MAAM,CAACO,IAAI,CAAC,IAAId,OAAO,CAACyF,IAAI,CAACwB,GAAG,CAAChF,CAAC,GAAG8E,YAAY,CAAC,GAAGF,OAAO,EAAEpB,IAAI,CAACyB,GAAG,CAACjF,CAAC,GAAG8E,YAAY,CAAC,GAAGD,OAAO,EAAE7F,CAAC,CAAC,CAAC;;IAE3G,OAAOV,MAAM;EACjB;EAEA;;;;;;;;EAQO,OAAO4G,mBAAmBA,CAACC,EAAW,EAAE3F,EAAW,EAAEJ,EAAW,EAAEmE,QAAgB;IACrF,OAAO3F,MAAM,CAACwH,qBAAqB,CAACD,EAAE,EAAE3F,EAAE,EAAEJ,EAAE,EAAEmE,QAAQ,CAAC,CACpD8B,SAAS,EAAE,CACXlG,OAAO,CAAEuC,CAAC,IAAK,CAACA,CAAC,CAAC5C,CAAC,EAAE4C,CAAC,CAAC3C,CAAC,EAAE2C,CAAC,CAAC1C,CAAC,CAAC,CAAC;EACxC;EAEA;;;;;;;;;;;EAWO,OAAOsG,WAAWA,CAACC,QAAiB,EAAEC,SAAkB,EAAEjH,MAAc,EAAEkH,OAAe,EAAEC,SAAiB,EAAEC,YAAY,GAAG,CAAC,EAAEC,cAAc,GAAG,CAAC;IACrJ,MAAMtH,MAAM,GAAG,CAACiH,QAAQ,CAACxC,KAAK,EAAE,EAAEwC,QAAQ,CAACM,GAAG,CAACL,SAAS,CAACd,gBAAgB,CAACnG,MAAM,EAAEA,MAAM,EAAEA,MAAM,CAAC,CAAC,CAAC;IACnG,MAAMuH,MAAM,GAAG,CAACL,OAAO,EAAEC,SAAS,EAAEC,YAAY,EAAEC,cAAc,CAAC;IAEjE,OAAO;MACHtH,MAAM;MACNwH;KACH;EACL;EAEA;;;;;;;;;;EAUO,OAAOC,iBAAiBA,CAACC,IAAY,EAAEC,IAAY,EAAEC,UAAkB,EAAEC,QAAmB,EAAEnH,CAAC,GAAG,CAAC,EAAEoH,YAAY,GAAG,IAAI;IAC3H,MAAMC,SAAS,GAAG,EAAE;IACpB,MAAMC,UAAU,GAAGtI,oBAAoB,CAACgI,IAAI,EAAEC,IAAI,EAAEC,UAAU,EAAEC,QAAQ,CAAC;IAEzE,KAAK,MAAMI,EAAE,IAAID,UAAU,EAAE;MACzB,KAAK,MAAM1H,CAAC,IAAI2H,EAAE,CAACC,KAAK,EAAE;QACtB,MAAMlI,MAAM,GAAG,EAAE;QACjB,MAAMmI,QAAQ,GAAG7H,CAAC,CAACyG,SAAS,EAAE;QAC9B,KAAK,MAAMqB,GAAG,IAAID,QAAQ,EAAE;UACxBnI,MAAM,CAACO,IAAI,CAAC6H,GAAG,CAAC5H,CAAC,EAAE4H,GAAG,CAAC3H,CAAC,EAAEC,CAAC,CAAC;;QAEhCqH,SAAS,CAACxH,IAAI,CAACP,MAAM,CAAC;;MAG1B,IAAI8H,YAAY,EAAE;QACd,KAAK,MAAMO,CAAC,IAAIJ,EAAE,CAACK,KAAK,EAAE;UACtB,MAAMA,KAAK,GAAG,EAAE;UAChB,MAAMH,QAAQ,GAAGE,CAAC,CAACtB,SAAS,EAAE;UAC9B,KAAK,MAAMqB,GAAG,IAAID,QAAQ,EAAE;YACxBG,KAAK,CAAC/H,IAAI,CAAC6H,GAAG,CAAC5H,CAAC,EAAE4H,GAAG,CAAC3H,CAAC,EAAEC,CAAC,CAAC;;UAE/BqH,SAAS,CAACxH,IAAI,CAAC+H,KAAK,CAAC;;;;IAKjC,OAAOP,SAAS;EACpB;EAEA;;;;;EAKO,OAAOQ,iBAAiBA,CAACC,MAAgB;IAC5C,MAAMC,UAAU,GAAe,IAAIC,UAAU,CAACF,MAAM,CAACvI,MAAM,GAAG,CAAC,CAAC;IAChE,KAAK,IAAIyB,CAAC,GAAG,CAAC,EAAErB,CAAC,GAAG,CAAC,EAAEqB,CAAC,GAAG8G,MAAM,CAACvI,MAAM,EAAEyB,CAAC,EAAE,EAAE;MAC3C+G,UAAU,CAACpI,CAAC,EAAE,CAAC,GAAGmI,MAAM,CAAC9G,CAAC,CAAC,CAACiH,CAAC,GAAG,GAAG;MACnCF,UAAU,CAACpI,CAAC,EAAE,CAAC,GAAGmI,MAAM,CAAC9G,CAAC,CAAC,CAACkH,CAAC,GAAG,GAAG;MACnCH,UAAU,CAACpI,CAAC,EAAE,CAAC,GAAGmI,MAAM,CAAC9G,CAAC,CAAC,CAACmH,CAAC,GAAG,GAAG;MACnCJ,UAAU,CAACpI,CAAC,EAAE,CAAC,GAAG,GAAG;;IAGzB,OAAOoI,UAAU;EACrB;EAEA;;;;;EAKO,OAAOK,mBAAmBA,CAACC,IAAY,EAAEP,MAAgB,EAAEQ,cAAsB,EAAEC,KAAY;IAClG,MAAMC,WAAW,GAAGpJ,gBAAgB,CAACyI,iBAAiB,CAACC,MAAM,CAAC;IAC9D,MAAMW,aAAa,GAAG,IAAIxJ,UAAU,CAACuJ,WAAW,EAAEV,MAAM,CAACvI,MAAM,EAAE,CAAC,EAAEL,MAAM,CAACwJ,kBAAkB,EAAEH,KAAK,EAAE,KAAK,EAAE,IAAI,EAAED,cAAc,CAAC;IAClIG,aAAa,CAACJ,IAAI,GAAGA,IAAI;IACzB,OAAOI,aAAa;EACxB;EAEA;;;;;EAKO,OAAOE,yBAAyBA,CAACJ,KAAY;IAChD,IAAI,CAACpJ,2BAA2B,CAACyJ,kBAAkB,EAAE;MACjD,MAAMJ,WAAW,GAAG,IAAIR,UAAU,CAAC,CAAC,CAAC;MACrC7I,2BAA2B,CAACyJ,kBAAkB,GAAG,IAAI3J,UAAU,CAACuJ,WAAW,EAAE,CAAC,EAAE,CAAC,EAAEtJ,MAAM,CAACwJ,kBAAkB,EAAEH,KAAK,EAAE,KAAK,EAAE,KAAK,EAAEtJ,UAAU,CAAC4J,eAAe,CAAC;MAC9J1J,2BAA2B,CAACyJ,kBAAkB,CAACP,IAAI,GAAG,uBAAuB;;EAErF;EAEA;;;EAGO,OAAOS,yBAAyBA,CAAA;;IACnC,CAAA7H,EAAA,GAAA9B,2BAA2B,CAACyJ,kBAAkB,cAAA3H,EAAA,uBAAAA,EAAA,CAAE8H,OAAO,EAAE;IACzD5J,2BAA2B,CAACyJ,kBAAkB,GAAG,IAAI;EACzD;EAEA;;;;;EAKO,OAAOI,eAAeA,CAACC,IAAc;IACxC,OAAOA,IAAI,GAAG,CAAC,GAAG,CAAC;EACvB"},"metadata":{},"sourceType":"module","externalDependencies":[]}