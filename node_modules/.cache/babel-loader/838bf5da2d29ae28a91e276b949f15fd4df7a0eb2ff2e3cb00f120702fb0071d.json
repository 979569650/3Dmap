{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../tslib.es6.js\";\nimport { PostProcess } from \"./postProcess.js\";\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer.js\";\nimport { serialize, SerializationHelper } from \"../Misc/decorators.js\";\nimport { ScreenSpaceReflectionsConfiguration } from \"../Rendering/screenSpaceReflectionsConfiguration.js\";\nimport \"../Shaders/screenSpaceReflection.fragment.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\n/**\n * The ScreenSpaceReflectionPostProcess performs realtime reflections using only and only the available informations on the screen (positions and normals).\n * Basically, the screen space reflection post-process will compute reflections according the material's reflectivity.\n * @deprecated Use the new SSRRenderingPipeline instead.\n */\nexport class ScreenSpaceReflectionPostProcess extends PostProcess {\n  get _geometryBufferRenderer() {\n    if (!this._forceGeometryBuffer) {\n      return null;\n    }\n    return this._scene.geometryBufferRenderer;\n  }\n  get _prePassRenderer() {\n    if (this._forceGeometryBuffer) {\n      return null;\n    }\n    return this._scene.prePassRenderer;\n  }\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"ScreenSpaceReflectionPostProcess\" string\n   */\n  getClassName() {\n    return \"ScreenSpaceReflectionPostProcess\";\n  }\n  /**\n   * Creates a new instance of ScreenSpaceReflectionPostProcess.\n   * @param name The name of the effect.\n   * @param scene The scene containing the objects to calculate reflections.\n   * @param options The required width/height ratio to downsize to before computing the render pass.\n   * @param camera The camera to apply the render pass to.\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\n   * @param engine The engine which the post process will be applied. (default: current engine)\n   * @param reusable If the post process can be reused on the same frame. (default: false)\n   * @param textureType Type of textures used when performing the post process. (default: 0)\n   * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: true)\n   * @param forceGeometryBuffer If this post process should use geometry buffer instead of prepass (default: false)\n   */\n  constructor(name, scene, options, camera, samplingMode, engine, reusable, textureType = 0, blockCompilation = false, forceGeometryBuffer = false) {\n    super(name, \"screenSpaceReflection\", [\"projection\", \"view\", \"threshold\", \"reflectionSpecularFalloffExponent\", \"strength\", \"stepSize\", \"roughnessFactor\"], [\"textureSampler\", \"normalSampler\", \"positionSampler\", \"reflectivitySampler\"], options, camera, samplingMode, engine, reusable, \"#define SSR_SUPPORTED\\n#define REFLECTION_SAMPLES 64\\n#define SMOOTH_STEPS 5\\n\", textureType, undefined, null, blockCompilation);\n    /**\n     * Gets or sets a reflection threshold mainly used to adjust the reflection's height.\n     */\n    this.threshold = 1.2;\n    /**\n     * Gets or sets the current reflection strength. 1.0 is an ideal value but can be increased/decreased for particular results.\n     */\n    this.strength = 1;\n    /**\n     * Gets or sets the falloff exponent used while computing fresnel. More the exponent is high, more the reflections will be discrete.\n     */\n    this.reflectionSpecularFalloffExponent = 3;\n    /**\n     * Gets or sets the step size used to iterate until the effect finds the color of the reflection's pixel. Typically in interval [0.1, 1.0]\n     */\n    this.step = 1.0;\n    /**\n     * Gets or sets the factor applied when computing roughness. Default value is 0.2.\n     */\n    this.roughnessFactor = 0.2;\n    this._forceGeometryBuffer = false;\n    this._enableSmoothReflections = false;\n    this._reflectionSamples = 64;\n    this._smoothSteps = 5;\n    this._forceGeometryBuffer = forceGeometryBuffer;\n    if (this._forceGeometryBuffer) {\n      // Get geometry buffer renderer and update effect\n      const geometryBufferRenderer = scene.enableGeometryBufferRenderer();\n      if (geometryBufferRenderer) {\n        if (geometryBufferRenderer.isSupported) {\n          geometryBufferRenderer.enablePosition = true;\n          geometryBufferRenderer.enableReflectivity = true;\n          if (geometryBufferRenderer.generateNormalsInWorldSpace) {\n            console.error(\"ScreenSpaceReflectionPostProcess does not support generateNormalsInWorldSpace=true for the geometry buffer renderer!\");\n          }\n        }\n      }\n    } else {\n      const prePassRenderer = scene.enablePrePassRenderer();\n      prePassRenderer === null || prePassRenderer === void 0 ? void 0 : prePassRenderer.markAsDirty();\n      if (prePassRenderer === null || prePassRenderer === void 0 ? void 0 : prePassRenderer.generateNormalsInWorldSpace) {\n        console.error(\"ScreenSpaceReflectionPostProcess does not support generateNormalsInWorldSpace=true for the prepass renderer!\");\n      }\n      this._prePassEffectConfiguration = new ScreenSpaceReflectionsConfiguration();\n    }\n    this._updateEffectDefines();\n    // On apply, send uniforms\n    this.onApply = effect => {\n      const geometryBufferRenderer = this._geometryBufferRenderer;\n      const prePassRenderer = this._prePassRenderer;\n      if (!prePassRenderer && !geometryBufferRenderer) {\n        return;\n      }\n      if (geometryBufferRenderer) {\n        // Samplers\n        const positionIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);\n        const roughnessIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE);\n        effect.setTexture(\"normalSampler\", geometryBufferRenderer.getGBuffer().textures[1]);\n        effect.setTexture(\"positionSampler\", geometryBufferRenderer.getGBuffer().textures[positionIndex]);\n        effect.setTexture(\"reflectivitySampler\", geometryBufferRenderer.getGBuffer().textures[roughnessIndex]);\n      } else if (prePassRenderer) {\n        // Samplers\n        const positionIndex = prePassRenderer.getIndex(1);\n        const roughnessIndex = prePassRenderer.getIndex(3);\n        const normalIndex = prePassRenderer.getIndex(6);\n        effect.setTexture(\"normalSampler\", prePassRenderer.getRenderTarget().textures[normalIndex]);\n        effect.setTexture(\"positionSampler\", prePassRenderer.getRenderTarget().textures[positionIndex]);\n        effect.setTexture(\"reflectivitySampler\", prePassRenderer.getRenderTarget().textures[roughnessIndex]);\n      }\n      // Uniforms\n      const camera = scene.activeCamera;\n      if (!camera) {\n        return;\n      }\n      const viewMatrix = camera.getViewMatrix(true);\n      const projectionMatrix = camera.getProjectionMatrix(true);\n      effect.setMatrix(\"projection\", projectionMatrix);\n      effect.setMatrix(\"view\", viewMatrix);\n      effect.setFloat(\"threshold\", this.threshold);\n      effect.setFloat(\"reflectionSpecularFalloffExponent\", this.reflectionSpecularFalloffExponent);\n      effect.setFloat(\"strength\", this.strength);\n      effect.setFloat(\"stepSize\", this.step);\n      effect.setFloat(\"roughnessFactor\", this.roughnessFactor);\n    };\n    this._isSceneRightHanded = scene.useRightHandedSystem;\n  }\n  /**\n   * Gets whether or not smoothing reflections is enabled.\n   * Enabling smoothing will require more GPU power and can generate a drop in FPS.\n   */\n  get enableSmoothReflections() {\n    return this._enableSmoothReflections;\n  }\n  /**\n   * Sets whether or not smoothing reflections is enabled.\n   * Enabling smoothing will require more GPU power and can generate a drop in FPS.\n   */\n  set enableSmoothReflections(enabled) {\n    if (enabled === this._enableSmoothReflections) {\n      return;\n    }\n    this._enableSmoothReflections = enabled;\n    this._updateEffectDefines();\n  }\n  /**\n   * Gets the number of samples taken while computing reflections. More samples count is high,\n   * more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].\n   */\n  get reflectionSamples() {\n    return this._reflectionSamples;\n  }\n  /**\n   * Sets the number of samples taken while computing reflections. More samples count is high,\n   * more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].\n   */\n  set reflectionSamples(samples) {\n    if (samples === this._reflectionSamples) {\n      return;\n    }\n    this._reflectionSamples = samples;\n    this._updateEffectDefines();\n  }\n  /**\n   * Gets the number of samples taken while smoothing reflections. More samples count is high,\n   * more the post-process will require GPU power and can generate a drop in FPS.\n   * Default value (5.0) work pretty well in all cases but can be adjusted.\n   */\n  get smoothSteps() {\n    return this._smoothSteps;\n  }\n  /*\n   * Sets the number of samples taken while smoothing reflections. More samples count is high,\n   * more the post-process will require GPU power and can generate a drop in FPS.\n   * Default value (5.0) work pretty well in all cases but can be adjusted.\n   */\n  set smoothSteps(steps) {\n    if (steps === this._smoothSteps) {\n      return;\n    }\n    this._smoothSteps = steps;\n    this._updateEffectDefines();\n  }\n  _updateEffectDefines() {\n    const defines = [];\n    if (this._geometryBufferRenderer || this._prePassRenderer) {\n      defines.push(\"#define SSR_SUPPORTED\");\n    }\n    if (this._enableSmoothReflections) {\n      defines.push(\"#define ENABLE_SMOOTH_REFLECTIONS\");\n    }\n    if (this._isSceneRightHanded) {\n      defines.push(\"#define RIGHT_HANDED_SCENE\");\n    }\n    defines.push(\"#define REFLECTION_SAMPLES \" + (this._reflectionSamples >> 0));\n    defines.push(\"#define SMOOTH_STEPS \" + (this._smoothSteps >> 0));\n    this.updateEffect(defines.join(\"\\n\"));\n  }\n  /**\n   * @internal\n   */\n  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {\n    return SerializationHelper.Parse(() => {\n      return new ScreenSpaceReflectionPostProcess(parsedPostProcess.name, scene, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.textureType, parsedPostProcess.reusable);\n    }, parsedPostProcess, scene, rootUrl);\n  }\n}\n__decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"threshold\", void 0);\n__decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"strength\", void 0);\n__decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"reflectionSpecularFalloffExponent\", void 0);\n__decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"step\", void 0);\n__decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"roughnessFactor\", void 0);\n__decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"enableSmoothReflections\", null);\n__decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"reflectionSamples\", null);\n__decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"smoothSteps\", null);\nRegisterClass(\"BABYLON.ScreenSpaceReflectionPostProcess\", ScreenSpaceReflectionPostProcess);","map":{"version":3,"names":["PostProcess","GeometryBufferRenderer","serialize","SerializationHelper","ScreenSpaceReflectionsConfiguration","RegisterClass","ScreenSpaceReflectionPostProcess","_geometryBufferRenderer","_forceGeometryBuffer","_scene","geometryBufferRenderer","_prePassRenderer","prePassRenderer","getClassName","constructor","name","scene","options","camera","samplingMode","engine","reusable","textureType","blockCompilation","forceGeometryBuffer","undefined","threshold","strength","reflectionSpecularFalloffExponent","step","roughnessFactor","_enableSmoothReflections","_reflectionSamples","_smoothSteps","enableGeometryBufferRenderer","isSupported","enablePosition","enableReflectivity","generateNormalsInWorldSpace","console","error","enablePrePassRenderer","markAsDirty","_prePassEffectConfiguration","_updateEffectDefines","onApply","effect","positionIndex","getTextureIndex","POSITION_TEXTURE_TYPE","roughnessIndex","REFLECTIVITY_TEXTURE_TYPE","setTexture","getGBuffer","textures","getIndex","normalIndex","getRenderTarget","activeCamera","viewMatrix","getViewMatrix","projectionMatrix","getProjectionMatrix","setMatrix","setFloat","_isSceneRightHanded","useRightHandedSystem","enableSmoothReflections","enabled","reflectionSamples","samples","smoothSteps","steps","defines","push","updateEffect","join","_Parse","parsedPostProcess","targetCamera","rootUrl","Parse","renderTargetSamplingMode","getEngine","__decorate"],"sources":["../../../../dev/core/src/PostProcesses/screenSpaceReflectionPostProcess.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer\";\r\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\r\nimport type { PrePassRenderer } from \"../Rendering/prePassRenderer\";\r\nimport { ScreenSpaceReflectionsConfiguration } from \"../Rendering/screenSpaceReflectionsConfiguration\";\r\n\r\nimport \"../Shaders/screenSpaceReflection.fragment\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * The ScreenSpaceReflectionPostProcess performs realtime reflections using only and only the available informations on the screen (positions and normals).\r\n * Basically, the screen space reflection post-process will compute reflections according the material's reflectivity.\r\n * @deprecated Use the new SSRRenderingPipeline instead.\r\n */\r\nexport class ScreenSpaceReflectionPostProcess extends PostProcess {\r\n    /**\r\n     * Gets or sets a reflection threshold mainly used to adjust the reflection's height.\r\n     */\r\n    @serialize()\r\n    public threshold: number = 1.2;\r\n    /**\r\n     * Gets or sets the current reflection strength. 1.0 is an ideal value but can be increased/decreased for particular results.\r\n     */\r\n    @serialize()\r\n    public strength: number = 1;\r\n    /**\r\n     * Gets or sets the falloff exponent used while computing fresnel. More the exponent is high, more the reflections will be discrete.\r\n     */\r\n    @serialize()\r\n    public reflectionSpecularFalloffExponent: number = 3;\r\n    /**\r\n     * Gets or sets the step size used to iterate until the effect finds the color of the reflection's pixel. Typically in interval [0.1, 1.0]\r\n     */\r\n    @serialize()\r\n    public step: number = 1.0;\r\n    /**\r\n     * Gets or sets the factor applied when computing roughness. Default value is 0.2.\r\n     */\r\n    @serialize()\r\n    public roughnessFactor: number = 0.2;\r\n\r\n    private _forceGeometryBuffer: boolean = false;\r\n    private get _geometryBufferRenderer(): Nullable<GeometryBufferRenderer> {\r\n        if (!this._forceGeometryBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.geometryBufferRenderer;\r\n    }\r\n\r\n    private get _prePassRenderer(): Nullable<PrePassRenderer> {\r\n        if (this._forceGeometryBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.prePassRenderer;\r\n    }\r\n\r\n    private _enableSmoothReflections: boolean = false;\r\n    private _reflectionSamples: number = 64;\r\n    private _smoothSteps: number = 5;\r\n    private _isSceneRightHanded: boolean;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"ScreenSpaceReflectionPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"ScreenSpaceReflectionPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ScreenSpaceReflectionPostProcess.\r\n     * @param name The name of the effect.\r\n     * @param scene The scene containing the objects to calculate reflections.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: true)\r\n     * @param forceGeometryBuffer If this post process should use geometry buffer instead of prepass (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Scene,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode?: number,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        blockCompilation = false,\r\n        forceGeometryBuffer = false\r\n    ) {\r\n        super(\r\n            name,\r\n            \"screenSpaceReflection\",\r\n            [\"projection\", \"view\", \"threshold\", \"reflectionSpecularFalloffExponent\", \"strength\", \"stepSize\", \"roughnessFactor\"],\r\n            [\"textureSampler\", \"normalSampler\", \"positionSampler\", \"reflectivitySampler\"],\r\n            options,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            \"#define SSR_SUPPORTED\\n#define REFLECTION_SAMPLES 64\\n#define SMOOTH_STEPS 5\\n\",\r\n            textureType,\r\n            undefined,\r\n            null,\r\n            blockCompilation\r\n        );\r\n\r\n        this._forceGeometryBuffer = forceGeometryBuffer;\r\n\r\n        if (this._forceGeometryBuffer) {\r\n            // Get geometry buffer renderer and update effect\r\n            const geometryBufferRenderer = scene.enableGeometryBufferRenderer();\r\n            if (geometryBufferRenderer) {\r\n                if (geometryBufferRenderer.isSupported) {\r\n                    geometryBufferRenderer.enablePosition = true;\r\n                    geometryBufferRenderer.enableReflectivity = true;\r\n\r\n                    if (geometryBufferRenderer.generateNormalsInWorldSpace) {\r\n                        console.error(\"ScreenSpaceReflectionPostProcess does not support generateNormalsInWorldSpace=true for the geometry buffer renderer!\");\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const prePassRenderer = scene.enablePrePassRenderer();\r\n            prePassRenderer?.markAsDirty();\r\n            if (prePassRenderer?.generateNormalsInWorldSpace) {\r\n                console.error(\"ScreenSpaceReflectionPostProcess does not support generateNormalsInWorldSpace=true for the prepass renderer!\");\r\n            }\r\n            this._prePassEffectConfiguration = new ScreenSpaceReflectionsConfiguration();\r\n        }\r\n\r\n        this._updateEffectDefines();\r\n\r\n        // On apply, send uniforms\r\n        this.onApply = (effect: Effect) => {\r\n            const geometryBufferRenderer = this._geometryBufferRenderer;\r\n            const prePassRenderer = this._prePassRenderer;\r\n\r\n            if (!prePassRenderer && !geometryBufferRenderer) {\r\n                return;\r\n            }\r\n\r\n            if (geometryBufferRenderer) {\r\n                // Samplers\r\n                const positionIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);\r\n                const roughnessIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE);\r\n\r\n                effect.setTexture(\"normalSampler\", geometryBufferRenderer.getGBuffer().textures[1]);\r\n                effect.setTexture(\"positionSampler\", geometryBufferRenderer.getGBuffer().textures[positionIndex]);\r\n                effect.setTexture(\"reflectivitySampler\", geometryBufferRenderer.getGBuffer().textures[roughnessIndex]);\r\n            } else if (prePassRenderer) {\r\n                // Samplers\r\n                const positionIndex = prePassRenderer.getIndex(Constants.PREPASS_POSITION_TEXTURE_TYPE);\r\n                const roughnessIndex = prePassRenderer.getIndex(Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE);\r\n                const normalIndex = prePassRenderer.getIndex(Constants.PREPASS_NORMAL_TEXTURE_TYPE);\r\n\r\n                effect.setTexture(\"normalSampler\", prePassRenderer.getRenderTarget().textures[normalIndex]);\r\n                effect.setTexture(\"positionSampler\", prePassRenderer.getRenderTarget().textures[positionIndex]);\r\n                effect.setTexture(\"reflectivitySampler\", prePassRenderer.getRenderTarget().textures[roughnessIndex]);\r\n            }\r\n\r\n            // Uniforms\r\n            const camera = scene.activeCamera;\r\n            if (!camera) {\r\n                return;\r\n            }\r\n\r\n            const viewMatrix = camera.getViewMatrix(true);\r\n            const projectionMatrix = camera.getProjectionMatrix(true);\r\n\r\n            effect.setMatrix(\"projection\", projectionMatrix);\r\n            effect.setMatrix(\"view\", viewMatrix);\r\n            effect.setFloat(\"threshold\", this.threshold);\r\n            effect.setFloat(\"reflectionSpecularFalloffExponent\", this.reflectionSpecularFalloffExponent);\r\n            effect.setFloat(\"strength\", this.strength);\r\n            effect.setFloat(\"stepSize\", this.step);\r\n            effect.setFloat(\"roughnessFactor\", this.roughnessFactor);\r\n        };\r\n\r\n        this._isSceneRightHanded = scene.useRightHandedSystem;\r\n    }\r\n\r\n    /**\r\n     * Gets whether or not smoothing reflections is enabled.\r\n     * Enabling smoothing will require more GPU power and can generate a drop in FPS.\r\n     */\r\n    @serialize()\r\n    public get enableSmoothReflections(): boolean {\r\n        return this._enableSmoothReflections;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not smoothing reflections is enabled.\r\n     * Enabling smoothing will require more GPU power and can generate a drop in FPS.\r\n     */\r\n    public set enableSmoothReflections(enabled: boolean) {\r\n        if (enabled === this._enableSmoothReflections) {\r\n            return;\r\n        }\r\n\r\n        this._enableSmoothReflections = enabled;\r\n        this._updateEffectDefines();\r\n    }\r\n\r\n    /**\r\n     * Gets the number of samples taken while computing reflections. More samples count is high,\r\n     * more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].\r\n     */\r\n    @serialize()\r\n    public get reflectionSamples(): number {\r\n        return this._reflectionSamples;\r\n    }\r\n\r\n    /**\r\n     * Sets the number of samples taken while computing reflections. More samples count is high,\r\n     * more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].\r\n     */\r\n    public set reflectionSamples(samples: number) {\r\n        if (samples === this._reflectionSamples) {\r\n            return;\r\n        }\r\n\r\n        this._reflectionSamples = samples;\r\n        this._updateEffectDefines();\r\n    }\r\n\r\n    /**\r\n     * Gets the number of samples taken while smoothing reflections. More samples count is high,\r\n     * more the post-process will require GPU power and can generate a drop in FPS.\r\n     * Default value (5.0) work pretty well in all cases but can be adjusted.\r\n     */\r\n    @serialize()\r\n    public get smoothSteps(): number {\r\n        return this._smoothSteps;\r\n    }\r\n\r\n    /*\r\n     * Sets the number of samples taken while smoothing reflections. More samples count is high,\r\n     * more the post-process will require GPU power and can generate a drop in FPS.\r\n     * Default value (5.0) work pretty well in all cases but can be adjusted.\r\n     */\r\n    public set smoothSteps(steps: number) {\r\n        if (steps === this._smoothSteps) {\r\n            return;\r\n        }\r\n\r\n        this._smoothSteps = steps;\r\n        this._updateEffectDefines();\r\n    }\r\n\r\n    private _updateEffectDefines(): void {\r\n        const defines: string[] = [];\r\n        if (this._geometryBufferRenderer || this._prePassRenderer) {\r\n            defines.push(\"#define SSR_SUPPORTED\");\r\n        }\r\n        if (this._enableSmoothReflections) {\r\n            defines.push(\"#define ENABLE_SMOOTH_REFLECTIONS\");\r\n        }\r\n        if (this._isSceneRightHanded) {\r\n            defines.push(\"#define RIGHT_HANDED_SCENE\");\r\n        }\r\n\r\n        defines.push(\"#define REFLECTION_SAMPLES \" + (this._reflectionSamples >> 0));\r\n        defines.push(\"#define SMOOTH_STEPS \" + (this._smoothSteps >> 0));\r\n\r\n        this.updateEffect(defines.join(\"\\n\"));\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string) {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new ScreenSpaceReflectionPostProcess(\r\n                    parsedPostProcess.name,\r\n                    scene,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    scene.getEngine(),\r\n                    parsedPostProcess.textureType,\r\n                    parsedPostProcess.reusable\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ScreenSpaceReflectionPostProcess\", ScreenSpaceReflectionPostProcess);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}