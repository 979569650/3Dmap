{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { FactorGradient, ColorGradient, Color3Gradient, GradientHelper } from \"../Misc/gradients.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3, Matrix, TmpVectors, Vector4 } from \"../Maths/math.vector.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer.js\";\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration.js\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { BoxParticleEmitter, HemisphericParticleEmitter, SphereParticleEmitter, SphereDirectedParticleEmitter, CylinderParticleEmitter, ConeParticleEmitter, PointParticleEmitter, MeshParticleEmitter, CylinderDirectedParticleEmitter } from \"../Particles/EmitterTypes/index.js\";\nimport { BaseParticleSystem } from \"./baseParticleSystem.js\";\nimport { Particle } from \"./particle.js\";\nimport { SubEmitter, SubEmitterType } from \"./subEmitter.js\";\nimport { SerializationHelper } from \"../Misc/decorators.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport \"../Shaders/particles.fragment.js\";\nimport \"../Shaders/particles.vertex.js\";\nimport { Color4, Color3, TmpColors } from \"../Maths/math.color.js\";\nimport { ThinEngine } from \"../Engines/thinEngine.js\";\nimport { MaterialHelper } from \"../Materials/materialHelper.js\";\nimport \"../Engines/Extensions/engine.alpha.js\";\nimport { addClipPlaneUniforms, prepareStringDefinesForClipPlanes, bindClipPlane } from \"../Materials/clipPlaneMaterialHelper.js\";\n/**\n * This represents a particle system in Babylon.\n * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\n * Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.\n * @example https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro\n */\nexport class ParticleSystem extends BaseParticleSystem {\n  /**\n   * Sets a callback that will be triggered when the system is disposed\n   */\n  set onDispose(callback) {\n    if (this._onDisposeObserver) {\n      this.onDisposeObservable.remove(this._onDisposeObserver);\n    }\n    this._onDisposeObserver = this.onDisposeObservable.add(callback);\n  }\n  /** Gets or sets a boolean indicating that ramp gradients must be used\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro#ramp-gradients\n   */\n  get useRampGradients() {\n    return this._useRampGradients;\n  }\n  set useRampGradients(value) {\n    if (this._useRampGradients === value) {\n      return;\n    }\n    this._useRampGradients = value;\n    this._resetEffect();\n  }\n  //end of Sub-emitter\n  /**\n   * Gets the current list of active particles\n   */\n  get particles() {\n    return this._particles;\n  }\n  /**\n   * Gets the number of particles active at the same time.\n   * @returns The number of active particles.\n   */\n  getActiveCount() {\n    return this._particles.length;\n  }\n  /**\n   * Returns the string \"ParticleSystem\"\n   * @returns a string containing the class name\n   */\n  getClassName() {\n    return \"ParticleSystem\";\n  }\n  /**\n   * Gets a boolean indicating that the system is stopping\n   * @returns true if the system is currently stopping\n   */\n  isStopping() {\n    return this._stopped && this.isAlive();\n  }\n  /**\n   * Gets the custom effect used to render the particles\n   * @param blendMode Blend mode for which the effect should be retrieved\n   * @returns The effect\n   */\n  getCustomEffect(blendMode = 0) {\n    var _a, _b;\n    return (_b = (_a = this._customWrappers[blendMode]) === null || _a === void 0 ? void 0 : _a.effect) !== null && _b !== void 0 ? _b : this._customWrappers[0].effect;\n  }\n  _getCustomDrawWrapper(blendMode = 0) {\n    var _a;\n    return (_a = this._customWrappers[blendMode]) !== null && _a !== void 0 ? _a : this._customWrappers[0];\n  }\n  /**\n   * Sets the custom effect used to render the particles\n   * @param effect The effect to set\n   * @param blendMode Blend mode for which the effect should be set\n   */\n  setCustomEffect(effect, blendMode = 0) {\n    this._customWrappers[blendMode] = new DrawWrapper(this._engine);\n    this._customWrappers[blendMode].effect = effect;\n    if (this._customWrappers[blendMode].drawContext) {\n      this._customWrappers[blendMode].drawContext.useInstancing = this._useInstancing;\n    }\n  }\n  /**\n   * Observable that will be called just before the particles are drawn\n   */\n  get onBeforeDrawParticlesObservable() {\n    if (!this._onBeforeDrawParticlesObservable) {\n      this._onBeforeDrawParticlesObservable = new Observable();\n    }\n    return this._onBeforeDrawParticlesObservable;\n  }\n  /**\n   * Gets the name of the particle vertex shader\n   */\n  get vertexShaderName() {\n    return \"particles\";\n  }\n  /**\n   * Gets the vertex buffers used by the particle system\n   */\n  get vertexBuffers() {\n    return this._vertexBuffers;\n  }\n  /**\n   * Gets the index buffer used by the particle system (or null if no index buffer is used (if _useInstancing=true))\n   */\n  get indexBuffer() {\n    return this._indexBuffer;\n  }\n  /**\n   * Instantiates a particle system.\n   * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\n   * @param name The name of the particle system\n   * @param capacity The max number of particles alive at the same time\n   * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene\n   * @param customEffect a custom effect used to change the way particles are rendered by default\n   * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture\n   * @param epsilon Offset used to render the particles\n   */\n  constructor(name, capacity, sceneOrEngine, customEffect = null, isAnimationSheetEnabled = false, epsilon = 0.01) {\n    super(name);\n    this._emitterInverseWorldMatrix = Matrix.Identity();\n    /**\n     * @internal\n     */\n    this._inheritedVelocityOffset = new Vector3();\n    /**\n     * An event triggered when the system is disposed\n     */\n    this.onDisposeObservable = new Observable();\n    /**\n     * An event triggered when the system is stopped\n     */\n    this.onStoppedObservable = new Observable();\n    this._particles = new Array();\n    this._stockParticles = new Array();\n    this._newPartsExcess = 0;\n    this._vertexBuffers = {};\n    this._scaledColorStep = new Color4(0, 0, 0, 0);\n    this._colorDiff = new Color4(0, 0, 0, 0);\n    this._scaledDirection = Vector3.Zero();\n    this._scaledGravity = Vector3.Zero();\n    this._currentRenderId = -1;\n    this._useInstancing = false;\n    this._started = false;\n    this._stopped = false;\n    this._actualFrame = 0;\n    /** @internal */\n    this._currentEmitRate1 = 0;\n    /** @internal */\n    this._currentEmitRate2 = 0;\n    /** @internal */\n    this._currentStartSize1 = 0;\n    /** @internal */\n    this._currentStartSize2 = 0;\n    /** Indicates that the update of particles is done in the animate function */\n    this.updateInAnimate = true;\n    this._rawTextureWidth = 256;\n    this._useRampGradients = false;\n    /**\n     * @internal\n     * If the particle systems emitter should be disposed when the particle system is disposed\n     */\n    this._disposeEmitterOnDispose = false;\n    /**\n     * Specifies if the particles are updated in emitter local space or world space\n     */\n    this.isLocal = false;\n    /** Indicates that the particle system is CPU based */\n    this.isGPU = false;\n    /** @internal */\n    this._onBeforeDrawParticlesObservable = null;\n    // start of sub system methods\n    /**\n     * \"Recycles\" one of the particle by copying it back to the \"stock\" of particles and removing it from the active list.\n     * Its lifetime will start back at 0.\n     * @param particle\n     */\n    this.recycleParticle = particle => {\n      // move particle from activeParticle list to stock particles\n      const lastParticle = this._particles.pop();\n      if (lastParticle !== particle) {\n        lastParticle.copyTo(particle);\n      }\n      this._stockParticles.push(lastParticle);\n    };\n    this._createParticle = () => {\n      let particle;\n      if (this._stockParticles.length !== 0) {\n        particle = this._stockParticles.pop();\n        particle._reset();\n      } else {\n        particle = new Particle(this);\n      }\n      // Attach emitters\n      if (this._subEmitters && this._subEmitters.length > 0) {\n        const subEmitters = this._subEmitters[Math.floor(Math.random() * this._subEmitters.length)];\n        particle._attachedSubEmitters = [];\n        subEmitters.forEach(subEmitter => {\n          if (subEmitter.type === SubEmitterType.ATTACHED) {\n            const newEmitter = subEmitter.clone();\n            particle._attachedSubEmitters.push(newEmitter);\n            newEmitter.particleSystem.start();\n          }\n        });\n      }\n      return particle;\n    };\n    this._emitFromParticle = particle => {\n      if (!this._subEmitters || this._subEmitters.length === 0) {\n        return;\n      }\n      const templateIndex = Math.floor(Math.random() * this._subEmitters.length);\n      this._subEmitters[templateIndex].forEach(subEmitter => {\n        if (subEmitter.type === SubEmitterType.END) {\n          const subSystem = subEmitter.clone();\n          particle._inheritParticleInfoToSubEmitter(subSystem);\n          subSystem.particleSystem._rootParticleSystem = this;\n          this.activeSubSystems.push(subSystem.particleSystem);\n          subSystem.particleSystem.start();\n        }\n      });\n    };\n    this._capacity = capacity;\n    this._epsilon = epsilon;\n    this._isAnimationSheetEnabled = isAnimationSheetEnabled;\n    if (!sceneOrEngine || sceneOrEngine.getClassName() === \"Scene\") {\n      this._scene = sceneOrEngine || EngineStore.LastCreatedScene;\n      this._engine = this._scene.getEngine();\n      this.uniqueId = this._scene.getUniqueId();\n      this._scene.particleSystems.push(this);\n    } else {\n      this._engine = sceneOrEngine;\n      this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100, this._engine.isNDCHalfZRange);\n    }\n    if (this._engine.getCaps().vertexArrayObject) {\n      this._vertexArrayObject = null;\n    }\n    // Setup the default processing configuration to the scene.\n    this._attachImageProcessingConfiguration(null);\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    this._customWrappers = {\n      0: new DrawWrapper(this._engine)\n    };\n    this._customWrappers[0].effect = customEffect;\n    this._drawWrappers = [];\n    this._useInstancing = this._engine.getCaps().instancedArrays;\n    this._createIndexBuffer();\n    this._createVertexBuffers();\n    // Default emitter type\n    this.particleEmitterType = new BoxParticleEmitter();\n    let noiseTextureData = null;\n    // Update\n    this.updateFunction = particles => {\n      var _a;\n      let noiseTextureSize = null;\n      if (this.noiseTexture) {\n        // We need to get texture data back to CPU\n        noiseTextureSize = this.noiseTexture.getSize();\n        (_a = this.noiseTexture.getContent()) === null || _a === void 0 ? void 0 : _a.then(data => {\n          noiseTextureData = data;\n        });\n      }\n      const sameParticleArray = particles === this._particles;\n      for (let index = 0; index < particles.length; index++) {\n        const particle = particles[index];\n        let scaledUpdateSpeed = this._scaledUpdateSpeed;\n        const previousAge = particle.age;\n        particle.age += scaledUpdateSpeed;\n        // Evaluate step to death\n        if (particle.age > particle.lifeTime) {\n          const diff = particle.age - previousAge;\n          const oldDiff = particle.lifeTime - previousAge;\n          scaledUpdateSpeed = oldDiff * scaledUpdateSpeed / diff;\n          particle.age = particle.lifeTime;\n        }\n        const ratio = particle.age / particle.lifeTime;\n        // Color\n        if (this._colorGradients && this._colorGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, this._colorGradients, (currentGradient, nextGradient, scale) => {\n            if (currentGradient !== particle._currentColorGradient) {\n              particle._currentColor1.copyFrom(particle._currentColor2);\n              nextGradient.getColorToRef(particle._currentColor2);\n              particle._currentColorGradient = currentGradient;\n            }\n            Color4.LerpToRef(particle._currentColor1, particle._currentColor2, scale, particle.color);\n          });\n        } else {\n          particle.colorStep.scaleToRef(scaledUpdateSpeed, this._scaledColorStep);\n          particle.color.addInPlace(this._scaledColorStep);\n          if (particle.color.a < 0) {\n            particle.color.a = 0;\n          }\n        }\n        // Angular speed\n        if (this._angularSpeedGradients && this._angularSpeedGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, this._angularSpeedGradients, (currentGradient, nextGradient, scale) => {\n            if (currentGradient !== particle._currentAngularSpeedGradient) {\n              particle._currentAngularSpeed1 = particle._currentAngularSpeed2;\n              particle._currentAngularSpeed2 = nextGradient.getFactor();\n              particle._currentAngularSpeedGradient = currentGradient;\n            }\n            particle.angularSpeed = Scalar.Lerp(particle._currentAngularSpeed1, particle._currentAngularSpeed2, scale);\n          });\n        }\n        particle.angle += particle.angularSpeed * scaledUpdateSpeed;\n        // Direction\n        let directionScale = scaledUpdateSpeed;\n        /// Velocity\n        if (this._velocityGradients && this._velocityGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, this._velocityGradients, (currentGradient, nextGradient, scale) => {\n            if (currentGradient !== particle._currentVelocityGradient) {\n              particle._currentVelocity1 = particle._currentVelocity2;\n              particle._currentVelocity2 = nextGradient.getFactor();\n              particle._currentVelocityGradient = currentGradient;\n            }\n            directionScale *= Scalar.Lerp(particle._currentVelocity1, particle._currentVelocity2, scale);\n          });\n        }\n        particle.direction.scaleToRef(directionScale, this._scaledDirection);\n        /// Limit velocity\n        if (this._limitVelocityGradients && this._limitVelocityGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, this._limitVelocityGradients, (currentGradient, nextGradient, scale) => {\n            if (currentGradient !== particle._currentLimitVelocityGradient) {\n              particle._currentLimitVelocity1 = particle._currentLimitVelocity2;\n              particle._currentLimitVelocity2 = nextGradient.getFactor();\n              particle._currentLimitVelocityGradient = currentGradient;\n            }\n            const limitVelocity = Scalar.Lerp(particle._currentLimitVelocity1, particle._currentLimitVelocity2, scale);\n            const currentVelocity = particle.direction.length();\n            if (currentVelocity > limitVelocity) {\n              particle.direction.scaleInPlace(this.limitVelocityDamping);\n            }\n          });\n        }\n        /// Drag\n        if (this._dragGradients && this._dragGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, this._dragGradients, (currentGradient, nextGradient, scale) => {\n            if (currentGradient !== particle._currentDragGradient) {\n              particle._currentDrag1 = particle._currentDrag2;\n              particle._currentDrag2 = nextGradient.getFactor();\n              particle._currentDragGradient = currentGradient;\n            }\n            const drag = Scalar.Lerp(particle._currentDrag1, particle._currentDrag2, scale);\n            this._scaledDirection.scaleInPlace(1.0 - drag);\n          });\n        }\n        if (this.isLocal && particle._localPosition) {\n          particle._localPosition.addInPlace(this._scaledDirection);\n          Vector3.TransformCoordinatesToRef(particle._localPosition, this._emitterWorldMatrix, particle.position);\n        } else {\n          particle.position.addInPlace(this._scaledDirection);\n        }\n        // Noise\n        if (noiseTextureData && noiseTextureSize && particle._randomNoiseCoordinates1) {\n          const fetchedColorR = this._fetchR(particle._randomNoiseCoordinates1.x, particle._randomNoiseCoordinates1.y, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);\n          const fetchedColorG = this._fetchR(particle._randomNoiseCoordinates1.z, particle._randomNoiseCoordinates2.x, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);\n          const fetchedColorB = this._fetchR(particle._randomNoiseCoordinates2.y, particle._randomNoiseCoordinates2.z, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);\n          const force = TmpVectors.Vector3[0];\n          const scaledForce = TmpVectors.Vector3[1];\n          force.copyFromFloats((2 * fetchedColorR - 1) * this.noiseStrength.x, (2 * fetchedColorG - 1) * this.noiseStrength.y, (2 * fetchedColorB - 1) * this.noiseStrength.z);\n          force.scaleToRef(scaledUpdateSpeed, scaledForce);\n          particle.direction.addInPlace(scaledForce);\n        }\n        // Gravity\n        this.gravity.scaleToRef(scaledUpdateSpeed, this._scaledGravity);\n        particle.direction.addInPlace(this._scaledGravity);\n        // Size\n        if (this._sizeGradients && this._sizeGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, this._sizeGradients, (currentGradient, nextGradient, scale) => {\n            if (currentGradient !== particle._currentSizeGradient) {\n              particle._currentSize1 = particle._currentSize2;\n              particle._currentSize2 = nextGradient.getFactor();\n              particle._currentSizeGradient = currentGradient;\n            }\n            particle.size = Scalar.Lerp(particle._currentSize1, particle._currentSize2, scale);\n          });\n        }\n        // Remap data\n        if (this._useRampGradients) {\n          if (this._colorRemapGradients && this._colorRemapGradients.length > 0) {\n            GradientHelper.GetCurrentGradient(ratio, this._colorRemapGradients, (currentGradient, nextGradient, scale) => {\n              const min = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);\n              const max = Scalar.Lerp(currentGradient.factor2, nextGradient.factor2, scale);\n              particle.remapData.x = min;\n              particle.remapData.y = max - min;\n            });\n          }\n          if (this._alphaRemapGradients && this._alphaRemapGradients.length > 0) {\n            GradientHelper.GetCurrentGradient(ratio, this._alphaRemapGradients, (currentGradient, nextGradient, scale) => {\n              const min = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);\n              const max = Scalar.Lerp(currentGradient.factor2, nextGradient.factor2, scale);\n              particle.remapData.z = min;\n              particle.remapData.w = max - min;\n            });\n          }\n        }\n        if (this._isAnimationSheetEnabled) {\n          particle.updateCellIndex();\n        }\n        // Update the position of the attached sub-emitters to match their attached particle\n        particle._inheritParticleInfoToSubEmitters();\n        if (particle.age >= particle.lifeTime) {\n          // Recycle by swapping with last particle\n          this._emitFromParticle(particle);\n          if (particle._attachedSubEmitters) {\n            particle._attachedSubEmitters.forEach(subEmitter => {\n              subEmitter.particleSystem.disposeOnStop = true;\n              subEmitter.particleSystem.stop();\n            });\n            particle._attachedSubEmitters = null;\n          }\n          this.recycleParticle(particle);\n          if (sameParticleArray) {\n            index--;\n          }\n          continue;\n        }\n      }\n    };\n  }\n  _addFactorGradient(factorGradients, gradient, factor, factor2) {\n    const newGradient = new FactorGradient(gradient, factor, factor2);\n    factorGradients.push(newGradient);\n    factorGradients.sort((a, b) => {\n      if (a.gradient < b.gradient) {\n        return -1;\n      } else if (a.gradient > b.gradient) {\n        return 1;\n      }\n      return 0;\n    });\n  }\n  _removeFactorGradient(factorGradients, gradient) {\n    if (!factorGradients) {\n      return;\n    }\n    let index = 0;\n    for (const factorGradient of factorGradients) {\n      if (factorGradient.gradient === gradient) {\n        factorGradients.splice(index, 1);\n        break;\n      }\n      index++;\n    }\n  }\n  /**\n   * Adds a new life time gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the life time factor to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n  addLifeTimeGradient(gradient, factor, factor2) {\n    if (!this._lifeTimeGradients) {\n      this._lifeTimeGradients = [];\n    }\n    this._addFactorGradient(this._lifeTimeGradients, gradient, factor, factor2);\n    return this;\n  }\n  /**\n   * Remove a specific life time gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeLifeTimeGradient(gradient) {\n    this._removeFactorGradient(this._lifeTimeGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new size gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the size factor to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n  addSizeGradient(gradient, factor, factor2) {\n    if (!this._sizeGradients) {\n      this._sizeGradients = [];\n    }\n    this._addFactorGradient(this._sizeGradients, gradient, factor, factor2);\n    return this;\n  }\n  /**\n   * Remove a specific size gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeSizeGradient(gradient) {\n    this._removeFactorGradient(this._sizeGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new color remap gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param min defines the color remap minimal range\n   * @param max defines the color remap maximal range\n   * @returns the current particle system\n   */\n  addColorRemapGradient(gradient, min, max) {\n    if (!this._colorRemapGradients) {\n      this._colorRemapGradients = [];\n    }\n    this._addFactorGradient(this._colorRemapGradients, gradient, min, max);\n    return this;\n  }\n  /**\n   * Remove a specific color remap gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeColorRemapGradient(gradient) {\n    this._removeFactorGradient(this._colorRemapGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new alpha remap gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param min defines the alpha remap minimal range\n   * @param max defines the alpha remap maximal range\n   * @returns the current particle system\n   */\n  addAlphaRemapGradient(gradient, min, max) {\n    if (!this._alphaRemapGradients) {\n      this._alphaRemapGradients = [];\n    }\n    this._addFactorGradient(this._alphaRemapGradients, gradient, min, max);\n    return this;\n  }\n  /**\n   * Remove a specific alpha remap gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeAlphaRemapGradient(gradient) {\n    this._removeFactorGradient(this._alphaRemapGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new angular speed gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the angular speed  to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n  addAngularSpeedGradient(gradient, factor, factor2) {\n    if (!this._angularSpeedGradients) {\n      this._angularSpeedGradients = [];\n    }\n    this._addFactorGradient(this._angularSpeedGradients, gradient, factor, factor2);\n    return this;\n  }\n  /**\n   * Remove a specific angular speed gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeAngularSpeedGradient(gradient) {\n    this._removeFactorGradient(this._angularSpeedGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new velocity gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the velocity to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n  addVelocityGradient(gradient, factor, factor2) {\n    if (!this._velocityGradients) {\n      this._velocityGradients = [];\n    }\n    this._addFactorGradient(this._velocityGradients, gradient, factor, factor2);\n    return this;\n  }\n  /**\n   * Remove a specific velocity gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeVelocityGradient(gradient) {\n    this._removeFactorGradient(this._velocityGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new limit velocity gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the limit velocity value to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n  addLimitVelocityGradient(gradient, factor, factor2) {\n    if (!this._limitVelocityGradients) {\n      this._limitVelocityGradients = [];\n    }\n    this._addFactorGradient(this._limitVelocityGradients, gradient, factor, factor2);\n    return this;\n  }\n  /**\n   * Remove a specific limit velocity gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeLimitVelocityGradient(gradient) {\n    this._removeFactorGradient(this._limitVelocityGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new drag gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the drag value to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n  addDragGradient(gradient, factor, factor2) {\n    if (!this._dragGradients) {\n      this._dragGradients = [];\n    }\n    this._addFactorGradient(this._dragGradients, gradient, factor, factor2);\n    return this;\n  }\n  /**\n   * Remove a specific drag gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeDragGradient(gradient) {\n    this._removeFactorGradient(this._dragGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new emit rate gradient (please note that this will only work if you set the targetStopDuration property)\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the emit rate value to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n  addEmitRateGradient(gradient, factor, factor2) {\n    if (!this._emitRateGradients) {\n      this._emitRateGradients = [];\n    }\n    this._addFactorGradient(this._emitRateGradients, gradient, factor, factor2);\n    return this;\n  }\n  /**\n   * Remove a specific emit rate gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeEmitRateGradient(gradient) {\n    this._removeFactorGradient(this._emitRateGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new start size gradient (please note that this will only work if you set the targetStopDuration property)\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the start size value to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n  addStartSizeGradient(gradient, factor, factor2) {\n    if (!this._startSizeGradients) {\n      this._startSizeGradients = [];\n    }\n    this._addFactorGradient(this._startSizeGradients, gradient, factor, factor2);\n    return this;\n  }\n  /**\n   * Remove a specific start size gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeStartSizeGradient(gradient) {\n    this._removeFactorGradient(this._startSizeGradients, gradient);\n    return this;\n  }\n  _createRampGradientTexture() {\n    if (!this._rampGradients || !this._rampGradients.length || this._rampGradientsTexture || !this._scene) {\n      return;\n    }\n    const data = new Uint8Array(this._rawTextureWidth * 4);\n    const tmpColor = TmpColors.Color3[0];\n    for (let x = 0; x < this._rawTextureWidth; x++) {\n      const ratio = x / this._rawTextureWidth;\n      GradientHelper.GetCurrentGradient(ratio, this._rampGradients, (currentGradient, nextGradient, scale) => {\n        Color3.LerpToRef(currentGradient.color, nextGradient.color, scale, tmpColor);\n        data[x * 4] = tmpColor.r * 255;\n        data[x * 4 + 1] = tmpColor.g * 255;\n        data[x * 4 + 2] = tmpColor.b * 255;\n        data[x * 4 + 3] = 255;\n      });\n    }\n    this._rampGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, 1);\n  }\n  /**\n   * Gets the current list of ramp gradients.\n   * You must use addRampGradient and removeRampGradient to update this list\n   * @returns the list of ramp gradients\n   */\n  getRampGradients() {\n    return this._rampGradients;\n  }\n  /** Force the system to rebuild all gradients that need to be resync */\n  forceRefreshGradients() {\n    this._syncRampGradientTexture();\n  }\n  _syncRampGradientTexture() {\n    if (!this._rampGradients) {\n      return;\n    }\n    this._rampGradients.sort((a, b) => {\n      if (a.gradient < b.gradient) {\n        return -1;\n      } else if (a.gradient > b.gradient) {\n        return 1;\n      }\n      return 0;\n    });\n    if (this._rampGradientsTexture) {\n      this._rampGradientsTexture.dispose();\n      this._rampGradientsTexture = null;\n    }\n    this._createRampGradientTexture();\n  }\n  /**\n   * Adds a new ramp gradient used to remap particle colors\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param color defines the color to affect to the specified gradient\n   * @returns the current particle system\n   */\n  addRampGradient(gradient, color) {\n    if (!this._rampGradients) {\n      this._rampGradients = [];\n    }\n    const rampGradient = new Color3Gradient(gradient, color);\n    this._rampGradients.push(rampGradient);\n    this._syncRampGradientTexture();\n    return this;\n  }\n  /**\n   * Remove a specific ramp gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeRampGradient(gradient) {\n    this._removeGradientAndTexture(gradient, this._rampGradients, this._rampGradientsTexture);\n    this._rampGradientsTexture = null;\n    if (this._rampGradients && this._rampGradients.length > 0) {\n      this._createRampGradientTexture();\n    }\n    return this;\n  }\n  /**\n   * Adds a new color gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param color1 defines the color to affect to the specified gradient\n   * @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from\n   * @returns this particle system\n   */\n  addColorGradient(gradient, color1, color2) {\n    if (!this._colorGradients) {\n      this._colorGradients = [];\n    }\n    const colorGradient = new ColorGradient(gradient, color1, color2);\n    this._colorGradients.push(colorGradient);\n    this._colorGradients.sort((a, b) => {\n      if (a.gradient < b.gradient) {\n        return -1;\n      } else if (a.gradient > b.gradient) {\n        return 1;\n      }\n      return 0;\n    });\n    return this;\n  }\n  /**\n   * Remove a specific color gradient\n   * @param gradient defines the gradient to remove\n   * @returns this particle system\n   */\n  removeColorGradient(gradient) {\n    if (!this._colorGradients) {\n      return this;\n    }\n    let index = 0;\n    for (const colorGradient of this._colorGradients) {\n      if (colorGradient.gradient === gradient) {\n        this._colorGradients.splice(index, 1);\n        break;\n      }\n      index++;\n    }\n    return this;\n  }\n  /**\n   * Resets the draw wrappers cache\n   */\n  resetDrawCache() {\n    for (const drawWrappers of this._drawWrappers) {\n      if (drawWrappers) {\n        for (const drawWrapper of drawWrappers) {\n          drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.dispose();\n        }\n      }\n    }\n    this._drawWrappers = [];\n  }\n  _fetchR(u, v, width, height, pixels) {\n    u = Math.abs(u) * 0.5 + 0.5;\n    v = Math.abs(v) * 0.5 + 0.5;\n    const wrappedU = u * width % width | 0;\n    const wrappedV = v * height % height | 0;\n    const position = (wrappedU + wrappedV * width) * 4;\n    return pixels[position] / 255;\n  }\n  _reset() {\n    this._resetEffect();\n  }\n  _resetEffect() {\n    if (this._vertexBuffer) {\n      this._vertexBuffer.dispose();\n      this._vertexBuffer = null;\n    }\n    if (this._spriteBuffer) {\n      this._spriteBuffer.dispose();\n      this._spriteBuffer = null;\n    }\n    if (this._vertexArrayObject) {\n      this._engine.releaseVertexArrayObject(this._vertexArrayObject);\n      this._vertexArrayObject = null;\n    }\n    this._createVertexBuffers();\n  }\n  _createVertexBuffers() {\n    this._vertexBufferSize = this._useInstancing ? 10 : 12;\n    if (this._isAnimationSheetEnabled) {\n      this._vertexBufferSize += 1;\n    }\n    if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {\n      this._vertexBufferSize += 3;\n    }\n    if (this._useRampGradients) {\n      this._vertexBufferSize += 4;\n    }\n    const engine = this._engine;\n    const vertexSize = this._vertexBufferSize * (this._useInstancing ? 1 : 4);\n    this._vertexData = new Float32Array(this._capacity * vertexSize);\n    this._vertexBuffer = new Buffer(engine, this._vertexData, true, vertexSize);\n    let dataOffset = 0;\n    const positions = this._vertexBuffer.createVertexBuffer(VertexBuffer.PositionKind, dataOffset, 3, this._vertexBufferSize, this._useInstancing);\n    this._vertexBuffers[VertexBuffer.PositionKind] = positions;\n    dataOffset += 3;\n    const colors = this._vertexBuffer.createVertexBuffer(VertexBuffer.ColorKind, dataOffset, 4, this._vertexBufferSize, this._useInstancing);\n    this._vertexBuffers[VertexBuffer.ColorKind] = colors;\n    dataOffset += 4;\n    const options = this._vertexBuffer.createVertexBuffer(\"angle\", dataOffset, 1, this._vertexBufferSize, this._useInstancing);\n    this._vertexBuffers[\"angle\"] = options;\n    dataOffset += 1;\n    const size = this._vertexBuffer.createVertexBuffer(\"size\", dataOffset, 2, this._vertexBufferSize, this._useInstancing);\n    this._vertexBuffers[\"size\"] = size;\n    dataOffset += 2;\n    if (this._isAnimationSheetEnabled) {\n      const cellIndexBuffer = this._vertexBuffer.createVertexBuffer(\"cellIndex\", dataOffset, 1, this._vertexBufferSize, this._useInstancing);\n      this._vertexBuffers[\"cellIndex\"] = cellIndexBuffer;\n      dataOffset += 1;\n    }\n    if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {\n      const directionBuffer = this._vertexBuffer.createVertexBuffer(\"direction\", dataOffset, 3, this._vertexBufferSize, this._useInstancing);\n      this._vertexBuffers[\"direction\"] = directionBuffer;\n      dataOffset += 3;\n    }\n    if (this._useRampGradients) {\n      const rampDataBuffer = this._vertexBuffer.createVertexBuffer(\"remapData\", dataOffset, 4, this._vertexBufferSize, this._useInstancing);\n      this._vertexBuffers[\"remapData\"] = rampDataBuffer;\n      dataOffset += 4;\n    }\n    let offsets;\n    if (this._useInstancing) {\n      const spriteData = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\n      this._spriteBuffer = new Buffer(engine, spriteData, false, 2);\n      offsets = this._spriteBuffer.createVertexBuffer(\"offset\", 0, 2);\n    } else {\n      offsets = this._vertexBuffer.createVertexBuffer(\"offset\", dataOffset, 2, this._vertexBufferSize, this._useInstancing);\n      dataOffset += 2;\n    }\n    this._vertexBuffers[\"offset\"] = offsets;\n    this.resetDrawCache();\n  }\n  _createIndexBuffer() {\n    if (this._useInstancing) {\n      this._linesIndexBufferUseInstancing = this._engine.createIndexBuffer(new Uint32Array([0, 1, 1, 3, 3, 2, 2, 0, 0, 3]));\n      return;\n    }\n    const indices = [];\n    const indicesWireframe = [];\n    let index = 0;\n    for (let count = 0; count < this._capacity; count++) {\n      indices.push(index);\n      indices.push(index + 1);\n      indices.push(index + 2);\n      indices.push(index);\n      indices.push(index + 2);\n      indices.push(index + 3);\n      indicesWireframe.push(index, index + 1, index + 1, index + 2, index + 2, index + 3, index + 3, index, index, index + 3);\n      index += 4;\n    }\n    this._indexBuffer = this._engine.createIndexBuffer(indices);\n    this._linesIndexBuffer = this._engine.createIndexBuffer(indicesWireframe);\n  }\n  /**\n   * Gets the maximum number of particles active at the same time.\n   * @returns The max number of active particles.\n   */\n  getCapacity() {\n    return this._capacity;\n  }\n  /**\n   * Gets whether there are still active particles in the system.\n   * @returns True if it is alive, otherwise false.\n   */\n  isAlive() {\n    return this._alive;\n  }\n  /**\n   * Gets if the system has been started. (Note: this will still be true after stop is called)\n   * @returns True if it has been started, otherwise false.\n   */\n  isStarted() {\n    return this._started;\n  }\n  _prepareSubEmitterInternalArray() {\n    this._subEmitters = new Array();\n    if (this.subEmitters) {\n      this.subEmitters.forEach(subEmitter => {\n        if (subEmitter instanceof ParticleSystem) {\n          this._subEmitters.push([new SubEmitter(subEmitter)]);\n        } else if (subEmitter instanceof SubEmitter) {\n          this._subEmitters.push([subEmitter]);\n        } else if (subEmitter instanceof Array) {\n          this._subEmitters.push(subEmitter);\n        }\n      });\n    }\n  }\n  /**\n   * Starts the particle system and begins to emit\n   * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)\n   */\n  start(delay = this.startDelay) {\n    var _a;\n    if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {\n      throw \"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set\";\n    }\n    if (delay) {\n      setTimeout(() => {\n        this.start(0);\n      }, delay);\n      return;\n    }\n    // Convert the subEmitters field to the constant type field _subEmitters\n    this._prepareSubEmitterInternalArray();\n    this._started = true;\n    this._stopped = false;\n    this._actualFrame = 0;\n    if (this._subEmitters && this._subEmitters.length != 0) {\n      this.activeSubSystems = new Array();\n    }\n    // Reset emit gradient so it acts the same on every start\n    if (this._emitRateGradients) {\n      if (this._emitRateGradients.length > 0) {\n        this._currentEmitRateGradient = this._emitRateGradients[0];\n        this._currentEmitRate1 = this._currentEmitRateGradient.getFactor();\n        this._currentEmitRate2 = this._currentEmitRate1;\n      }\n      if (this._emitRateGradients.length > 1) {\n        this._currentEmitRate2 = this._emitRateGradients[1].getFactor();\n      }\n    }\n    // Reset start size gradient so it acts the same on every start\n    if (this._startSizeGradients) {\n      if (this._startSizeGradients.length > 0) {\n        this._currentStartSizeGradient = this._startSizeGradients[0];\n        this._currentStartSize1 = this._currentStartSizeGradient.getFactor();\n        this._currentStartSize2 = this._currentStartSize1;\n      }\n      if (this._startSizeGradients.length > 1) {\n        this._currentStartSize2 = this._startSizeGradients[1].getFactor();\n      }\n    }\n    if (this.preWarmCycles) {\n      if (((_a = this.emitter) === null || _a === void 0 ? void 0 : _a.getClassName().indexOf(\"Mesh\")) !== -1) {\n        this.emitter.computeWorldMatrix(true);\n      }\n      const noiseTextureAsProcedural = this.noiseTexture;\n      if (noiseTextureAsProcedural && noiseTextureAsProcedural.onGeneratedObservable) {\n        noiseTextureAsProcedural.onGeneratedObservable.addOnce(() => {\n          setTimeout(() => {\n            for (let index = 0; index < this.preWarmCycles; index++) {\n              this.animate(true);\n              noiseTextureAsProcedural.render();\n            }\n          });\n        });\n      } else {\n        for (let index = 0; index < this.preWarmCycles; index++) {\n          this.animate(true);\n        }\n      }\n    }\n    // Animations\n    if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {\n      this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);\n    }\n  }\n  /**\n   * Stops the particle system.\n   * @param stopSubEmitters if true it will stop the current system and all created sub-Systems if false it will stop the current root system only, this param is used by the root particle system only. the default value is true.\n   */\n  stop(stopSubEmitters = true) {\n    if (this._stopped) {\n      return;\n    }\n    this.onStoppedObservable.notifyObservers(this);\n    this._stopped = true;\n    if (stopSubEmitters) {\n      this._stopSubEmitters();\n    }\n  }\n  // animation sheet\n  /**\n   * Remove all active particles\n   */\n  reset() {\n    this._stockParticles.length = 0;\n    this._particles.length = 0;\n  }\n  /**\n   * @internal (for internal use only)\n   */\n  _appendParticleVertex(index, particle, offsetX, offsetY) {\n    let offset = index * this._vertexBufferSize;\n    this._vertexData[offset++] = particle.position.x + this.worldOffset.x;\n    this._vertexData[offset++] = particle.position.y + this.worldOffset.y;\n    this._vertexData[offset++] = particle.position.z + this.worldOffset.z;\n    this._vertexData[offset++] = particle.color.r;\n    this._vertexData[offset++] = particle.color.g;\n    this._vertexData[offset++] = particle.color.b;\n    this._vertexData[offset++] = particle.color.a;\n    this._vertexData[offset++] = particle.angle;\n    this._vertexData[offset++] = particle.scale.x * particle.size;\n    this._vertexData[offset++] = particle.scale.y * particle.size;\n    if (this._isAnimationSheetEnabled) {\n      this._vertexData[offset++] = particle.cellIndex;\n    }\n    if (!this._isBillboardBased) {\n      if (particle._initialDirection) {\n        let initialDirection = particle._initialDirection;\n        if (this.isLocal) {\n          Vector3.TransformNormalToRef(initialDirection, this._emitterWorldMatrix, TmpVectors.Vector3[0]);\n          initialDirection = TmpVectors.Vector3[0];\n        }\n        if (initialDirection.x === 0 && initialDirection.z === 0) {\n          initialDirection.x = 0.001;\n        }\n        this._vertexData[offset++] = initialDirection.x;\n        this._vertexData[offset++] = initialDirection.y;\n        this._vertexData[offset++] = initialDirection.z;\n      } else {\n        let direction = particle.direction;\n        if (this.isLocal) {\n          Vector3.TransformNormalToRef(direction, this._emitterWorldMatrix, TmpVectors.Vector3[0]);\n          direction = TmpVectors.Vector3[0];\n        }\n        if (direction.x === 0 && direction.z === 0) {\n          direction.x = 0.001;\n        }\n        this._vertexData[offset++] = direction.x;\n        this._vertexData[offset++] = direction.y;\n        this._vertexData[offset++] = direction.z;\n      }\n    } else if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {\n      this._vertexData[offset++] = particle.direction.x;\n      this._vertexData[offset++] = particle.direction.y;\n      this._vertexData[offset++] = particle.direction.z;\n    }\n    if (this._useRampGradients && particle.remapData) {\n      this._vertexData[offset++] = particle.remapData.x;\n      this._vertexData[offset++] = particle.remapData.y;\n      this._vertexData[offset++] = particle.remapData.z;\n      this._vertexData[offset++] = particle.remapData.w;\n    }\n    if (!this._useInstancing) {\n      if (this._isAnimationSheetEnabled) {\n        if (offsetX === 0) {\n          offsetX = this._epsilon;\n        } else if (offsetX === 1) {\n          offsetX = 1 - this._epsilon;\n        }\n        if (offsetY === 0) {\n          offsetY = this._epsilon;\n        } else if (offsetY === 1) {\n          offsetY = 1 - this._epsilon;\n        }\n      }\n      this._vertexData[offset++] = offsetX;\n      this._vertexData[offset++] = offsetY;\n    }\n  }\n  _stopSubEmitters() {\n    if (!this.activeSubSystems) {\n      return;\n    }\n    this.activeSubSystems.forEach(subSystem => {\n      subSystem.stop(true);\n    });\n    this.activeSubSystems = new Array();\n  }\n  _removeFromRoot() {\n    if (!this._rootParticleSystem) {\n      return;\n    }\n    const index = this._rootParticleSystem.activeSubSystems.indexOf(this);\n    if (index !== -1) {\n      this._rootParticleSystem.activeSubSystems.splice(index, 1);\n    }\n    this._rootParticleSystem = null;\n  }\n  // End of sub system methods\n  _update(newParticles) {\n    // Update current\n    this._alive = this._particles.length > 0;\n    if (this.emitter.position) {\n      const emitterMesh = this.emitter;\n      this._emitterWorldMatrix = emitterMesh.getWorldMatrix();\n    } else {\n      const emitterPosition = this.emitter;\n      this._emitterWorldMatrix = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);\n    }\n    this._emitterWorldMatrix.invertToRef(this._emitterInverseWorldMatrix);\n    this.updateFunction(this._particles);\n    // Add new ones\n    let particle;\n    for (let index = 0; index < newParticles; index++) {\n      if (this._particles.length === this._capacity) {\n        break;\n      }\n      particle = this._createParticle();\n      this._particles.push(particle);\n      // Life time\n      if (this.targetStopDuration && this._lifeTimeGradients && this._lifeTimeGradients.length > 0) {\n        const ratio = Scalar.Clamp(this._actualFrame / this.targetStopDuration);\n        GradientHelper.GetCurrentGradient(ratio, this._lifeTimeGradients, (currentGradient, nextGradient) => {\n          const factorGradient1 = currentGradient;\n          const factorGradient2 = nextGradient;\n          const lifeTime1 = factorGradient1.getFactor();\n          const lifeTime2 = factorGradient2.getFactor();\n          const gradient = (ratio - factorGradient1.gradient) / (factorGradient2.gradient - factorGradient1.gradient);\n          particle.lifeTime = Scalar.Lerp(lifeTime1, lifeTime2, gradient);\n        });\n      } else {\n        particle.lifeTime = Scalar.RandomRange(this.minLifeTime, this.maxLifeTime);\n      }\n      // Emitter\n      const emitPower = Scalar.RandomRange(this.minEmitPower, this.maxEmitPower);\n      if (this.startPositionFunction) {\n        this.startPositionFunction(this._emitterWorldMatrix, particle.position, particle, this.isLocal);\n      } else {\n        this.particleEmitterType.startPositionFunction(this._emitterWorldMatrix, particle.position, particle, this.isLocal);\n      }\n      if (this.isLocal) {\n        if (!particle._localPosition) {\n          particle._localPosition = particle.position.clone();\n        } else {\n          particle._localPosition.copyFrom(particle.position);\n        }\n        Vector3.TransformCoordinatesToRef(particle._localPosition, this._emitterWorldMatrix, particle.position);\n      }\n      if (this.startDirectionFunction) {\n        this.startDirectionFunction(this._emitterWorldMatrix, particle.direction, particle, this.isLocal);\n      } else {\n        this.particleEmitterType.startDirectionFunction(this._emitterWorldMatrix, particle.direction, particle, this.isLocal, this._emitterInverseWorldMatrix);\n      }\n      if (emitPower === 0) {\n        if (!particle._initialDirection) {\n          particle._initialDirection = particle.direction.clone();\n        } else {\n          particle._initialDirection.copyFrom(particle.direction);\n        }\n      } else {\n        particle._initialDirection = null;\n      }\n      particle.direction.scaleInPlace(emitPower);\n      // Size\n      if (!this._sizeGradients || this._sizeGradients.length === 0) {\n        particle.size = Scalar.RandomRange(this.minSize, this.maxSize);\n      } else {\n        particle._currentSizeGradient = this._sizeGradients[0];\n        particle._currentSize1 = particle._currentSizeGradient.getFactor();\n        particle.size = particle._currentSize1;\n        if (this._sizeGradients.length > 1) {\n          particle._currentSize2 = this._sizeGradients[1].getFactor();\n        } else {\n          particle._currentSize2 = particle._currentSize1;\n        }\n      }\n      // Size and scale\n      particle.scale.copyFromFloats(Scalar.RandomRange(this.minScaleX, this.maxScaleX), Scalar.RandomRange(this.minScaleY, this.maxScaleY));\n      // Adjust scale by start size\n      if (this._startSizeGradients && this._startSizeGradients[0] && this.targetStopDuration) {\n        const ratio = this._actualFrame / this.targetStopDuration;\n        GradientHelper.GetCurrentGradient(ratio, this._startSizeGradients, (currentGradient, nextGradient, scale) => {\n          if (currentGradient !== this._currentStartSizeGradient) {\n            this._currentStartSize1 = this._currentStartSize2;\n            this._currentStartSize2 = nextGradient.getFactor();\n            this._currentStartSizeGradient = currentGradient;\n          }\n          const value = Scalar.Lerp(this._currentStartSize1, this._currentStartSize2, scale);\n          particle.scale.scaleInPlace(value);\n        });\n      }\n      // Angle\n      if (!this._angularSpeedGradients || this._angularSpeedGradients.length === 0) {\n        particle.angularSpeed = Scalar.RandomRange(this.minAngularSpeed, this.maxAngularSpeed);\n      } else {\n        particle._currentAngularSpeedGradient = this._angularSpeedGradients[0];\n        particle.angularSpeed = particle._currentAngularSpeedGradient.getFactor();\n        particle._currentAngularSpeed1 = particle.angularSpeed;\n        if (this._angularSpeedGradients.length > 1) {\n          particle._currentAngularSpeed2 = this._angularSpeedGradients[1].getFactor();\n        } else {\n          particle._currentAngularSpeed2 = particle._currentAngularSpeed1;\n        }\n      }\n      particle.angle = Scalar.RandomRange(this.minInitialRotation, this.maxInitialRotation);\n      // Velocity\n      if (this._velocityGradients && this._velocityGradients.length > 0) {\n        particle._currentVelocityGradient = this._velocityGradients[0];\n        particle._currentVelocity1 = particle._currentVelocityGradient.getFactor();\n        if (this._velocityGradients.length > 1) {\n          particle._currentVelocity2 = this._velocityGradients[1].getFactor();\n        } else {\n          particle._currentVelocity2 = particle._currentVelocity1;\n        }\n      }\n      // Limit velocity\n      if (this._limitVelocityGradients && this._limitVelocityGradients.length > 0) {\n        particle._currentLimitVelocityGradient = this._limitVelocityGradients[0];\n        particle._currentLimitVelocity1 = particle._currentLimitVelocityGradient.getFactor();\n        if (this._limitVelocityGradients.length > 1) {\n          particle._currentLimitVelocity2 = this._limitVelocityGradients[1].getFactor();\n        } else {\n          particle._currentLimitVelocity2 = particle._currentLimitVelocity1;\n        }\n      }\n      // Drag\n      if (this._dragGradients && this._dragGradients.length > 0) {\n        particle._currentDragGradient = this._dragGradients[0];\n        particle._currentDrag1 = particle._currentDragGradient.getFactor();\n        if (this._dragGradients.length > 1) {\n          particle._currentDrag2 = this._dragGradients[1].getFactor();\n        } else {\n          particle._currentDrag2 = particle._currentDrag1;\n        }\n      }\n      // Color\n      if (!this._colorGradients || this._colorGradients.length === 0) {\n        const step = Scalar.RandomRange(0, 1.0);\n        Color4.LerpToRef(this.color1, this.color2, step, particle.color);\n        this.colorDead.subtractToRef(particle.color, this._colorDiff);\n        this._colorDiff.scaleToRef(1.0 / particle.lifeTime, particle.colorStep);\n      } else {\n        particle._currentColorGradient = this._colorGradients[0];\n        particle._currentColorGradient.getColorToRef(particle.color);\n        particle._currentColor1.copyFrom(particle.color);\n        if (this._colorGradients.length > 1) {\n          this._colorGradients[1].getColorToRef(particle._currentColor2);\n        } else {\n          particle._currentColor2.copyFrom(particle.color);\n        }\n      }\n      // Sheet\n      if (this._isAnimationSheetEnabled) {\n        particle._initialStartSpriteCellID = this.startSpriteCellID;\n        particle._initialEndSpriteCellID = this.endSpriteCellID;\n        particle._initialSpriteCellLoop = this.spriteCellLoop;\n      }\n      // Inherited Velocity\n      particle.direction.addInPlace(this._inheritedVelocityOffset);\n      // Ramp\n      if (this._useRampGradients) {\n        particle.remapData = new Vector4(0, 1, 0, 1);\n      }\n      // Noise texture coordinates\n      if (this.noiseTexture) {\n        if (particle._randomNoiseCoordinates1) {\n          particle._randomNoiseCoordinates1.copyFromFloats(Math.random(), Math.random(), Math.random());\n          particle._randomNoiseCoordinates2.copyFromFloats(Math.random(), Math.random(), Math.random());\n        } else {\n          particle._randomNoiseCoordinates1 = new Vector3(Math.random(), Math.random(), Math.random());\n          particle._randomNoiseCoordinates2 = new Vector3(Math.random(), Math.random(), Math.random());\n        }\n      }\n      // Update the position of the attached sub-emitters to match their attached particle\n      particle._inheritParticleInfoToSubEmitters();\n    }\n  }\n  /**\n   * @internal\n   */\n  static _GetAttributeNamesOrOptions(isAnimationSheetEnabled = false, isBillboardBased = false, useRampGradients = false) {\n    const attributeNamesOrOptions = [VertexBuffer.PositionKind, VertexBuffer.ColorKind, \"angle\", \"offset\", \"size\"];\n    if (isAnimationSheetEnabled) {\n      attributeNamesOrOptions.push(\"cellIndex\");\n    }\n    if (!isBillboardBased) {\n      attributeNamesOrOptions.push(\"direction\");\n    }\n    if (useRampGradients) {\n      attributeNamesOrOptions.push(\"remapData\");\n    }\n    return attributeNamesOrOptions;\n  }\n  /**\n   * @internal\n   */\n  static _GetEffectCreationOptions(isAnimationSheetEnabled = false, useLogarithmicDepth = false) {\n    const effectCreationOption = [\"invView\", \"view\", \"projection\", \"textureMask\", \"translationPivot\", \"eyePosition\"];\n    addClipPlaneUniforms(effectCreationOption);\n    if (isAnimationSheetEnabled) {\n      effectCreationOption.push(\"particlesInfos\");\n    }\n    if (useLogarithmicDepth) {\n      effectCreationOption.push(\"logarithmicDepthConstant\");\n    }\n    return effectCreationOption;\n  }\n  /**\n   * Fill the defines array according to the current settings of the particle system\n   * @param defines Array to be updated\n   * @param blendMode blend mode to take into account when updating the array\n   */\n  fillDefines(defines, blendMode) {\n    if (this._scene) {\n      prepareStringDefinesForClipPlanes(this, this._scene, defines);\n    }\n    if (this._isAnimationSheetEnabled) {\n      defines.push(\"#define ANIMATESHEET\");\n    }\n    if (this.useLogarithmicDepth) {\n      defines.push(\"#define LOGARITHMICDEPTH\");\n    }\n    if (blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {\n      defines.push(\"#define BLENDMULTIPLYMODE\");\n    }\n    if (this._useRampGradients) {\n      defines.push(\"#define RAMPGRADIENT\");\n    }\n    if (this._isBillboardBased) {\n      defines.push(\"#define BILLBOARD\");\n      switch (this.billboardMode) {\n        case ParticleSystem.BILLBOARDMODE_Y:\n          defines.push(\"#define BILLBOARDY\");\n          break;\n        case ParticleSystem.BILLBOARDMODE_STRETCHED:\n        case ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL:\n          defines.push(\"#define BILLBOARDSTRETCHED\");\n          if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {\n            defines.push(\"#define BILLBOARDSTRETCHED_LOCAL\");\n          }\n          break;\n        case ParticleSystem.BILLBOARDMODE_ALL:\n          defines.push(\"#define BILLBOARDMODE_ALL\");\n          break;\n        default:\n          break;\n      }\n    }\n    if (this._imageProcessingConfiguration) {\n      this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);\n      defines.push(this._imageProcessingConfigurationDefines.toString());\n    }\n  }\n  /**\n   * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system\n   * @param uniforms Uniforms array to fill\n   * @param attributes Attributes array to fill\n   * @param samplers Samplers array to fill\n   */\n  fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers) {\n    attributes.push(...ParticleSystem._GetAttributeNamesOrOptions(this._isAnimationSheetEnabled, this._isBillboardBased && this.billboardMode !== ParticleSystem.BILLBOARDMODE_STRETCHED && this.billboardMode !== ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL, this._useRampGradients));\n    uniforms.push(...ParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled, this.useLogarithmicDepth));\n    samplers.push(\"diffuseSampler\", \"rampSampler\");\n    if (this._imageProcessingConfiguration) {\n      ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);\n      ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);\n    }\n  }\n  /**\n   * @internal\n   */\n  _getWrapper(blendMode) {\n    const customWrapper = this._getCustomDrawWrapper(blendMode);\n    if (customWrapper === null || customWrapper === void 0 ? void 0 : customWrapper.effect) {\n      return customWrapper;\n    }\n    const defines = [];\n    this.fillDefines(defines, blendMode);\n    // Effect\n    const currentRenderPassId = this._engine._features.supportRenderPasses ? this._engine.currentRenderPassId : 0;\n    let drawWrappers = this._drawWrappers[currentRenderPassId];\n    if (!drawWrappers) {\n      drawWrappers = this._drawWrappers[currentRenderPassId] = [];\n    }\n    let drawWrapper = drawWrappers[blendMode];\n    if (!drawWrapper) {\n      drawWrapper = new DrawWrapper(this._engine);\n      if (drawWrapper.drawContext) {\n        drawWrapper.drawContext.useInstancing = this._useInstancing;\n      }\n      drawWrappers[blendMode] = drawWrapper;\n    }\n    const join = defines.join(\"\\n\");\n    if (drawWrapper.defines !== join) {\n      const attributesNamesOrOptions = [];\n      const effectCreationOption = [];\n      const samplers = [];\n      this.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, samplers);\n      drawWrapper.setEffect(this._engine.createEffect(\"particles\", attributesNamesOrOptions, effectCreationOption, samplers, join), join);\n    }\n    return drawWrapper;\n  }\n  /**\n   * Animates the particle system for the current frame by emitting new particles and or animating the living ones.\n   * @param preWarmOnly will prevent the system from updating the vertex buffer (default is false)\n   */\n  animate(preWarmOnly = false) {\n    var _a;\n    if (!this._started) {\n      return;\n    }\n    if (!preWarmOnly && this._scene) {\n      // Check\n      if (!this.isReady()) {\n        return;\n      }\n      if (this._currentRenderId === this._scene.getFrameId()) {\n        return;\n      }\n      this._currentRenderId = this._scene.getFrameId();\n    }\n    this._scaledUpdateSpeed = this.updateSpeed * (preWarmOnly ? this.preWarmStepOffset : ((_a = this._scene) === null || _a === void 0 ? void 0 : _a.getAnimationRatio()) || 1);\n    // Determine the number of particles we need to create\n    let newParticles;\n    if (this.manualEmitCount > -1) {\n      newParticles = this.manualEmitCount;\n      this._newPartsExcess = 0;\n      this.manualEmitCount = 0;\n    } else {\n      let rate = this.emitRate;\n      if (this._emitRateGradients && this._emitRateGradients.length > 0 && this.targetStopDuration) {\n        const ratio = this._actualFrame / this.targetStopDuration;\n        GradientHelper.GetCurrentGradient(ratio, this._emitRateGradients, (currentGradient, nextGradient, scale) => {\n          if (currentGradient !== this._currentEmitRateGradient) {\n            this._currentEmitRate1 = this._currentEmitRate2;\n            this._currentEmitRate2 = nextGradient.getFactor();\n            this._currentEmitRateGradient = currentGradient;\n          }\n          rate = Scalar.Lerp(this._currentEmitRate1, this._currentEmitRate2, scale);\n        });\n      }\n      newParticles = rate * this._scaledUpdateSpeed >> 0;\n      this._newPartsExcess += rate * this._scaledUpdateSpeed - newParticles;\n    }\n    if (this._newPartsExcess > 1.0) {\n      newParticles += this._newPartsExcess >> 0;\n      this._newPartsExcess -= this._newPartsExcess >> 0;\n    }\n    this._alive = false;\n    if (!this._stopped) {\n      this._actualFrame += this._scaledUpdateSpeed;\n      if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {\n        this.stop();\n      }\n    } else {\n      newParticles = 0;\n    }\n    this._update(newParticles);\n    // Stopped?\n    if (this._stopped) {\n      if (!this._alive) {\n        this._started = false;\n        if (this.onAnimationEnd) {\n          this.onAnimationEnd();\n        }\n        if (this.disposeOnStop && this._scene) {\n          this._scene._toBeDisposed.push(this);\n        }\n      }\n    }\n    if (!preWarmOnly) {\n      // Update VBO\n      let offset = 0;\n      for (let index = 0; index < this._particles.length; index++) {\n        const particle = this._particles[index];\n        this._appendParticleVertices(offset, particle);\n        offset += this._useInstancing ? 1 : 4;\n      }\n      if (this._vertexBuffer) {\n        this._vertexBuffer.updateDirectly(this._vertexData, 0, this._particles.length);\n      }\n    }\n    if (this.manualEmitCount === 0 && this.disposeOnStop) {\n      this.stop();\n    }\n  }\n  _appendParticleVertices(offset, particle) {\n    this._appendParticleVertex(offset++, particle, 0, 0);\n    if (!this._useInstancing) {\n      this._appendParticleVertex(offset++, particle, 1, 0);\n      this._appendParticleVertex(offset++, particle, 1, 1);\n      this._appendParticleVertex(offset++, particle, 0, 1);\n    }\n  }\n  /**\n   * Rebuilds the particle system.\n   */\n  rebuild() {\n    var _a, _b;\n    if (this._engine.getCaps().vertexArrayObject) {\n      this._vertexArrayObject = null;\n    }\n    this._createIndexBuffer();\n    (_a = this._spriteBuffer) === null || _a === void 0 ? void 0 : _a._rebuild();\n    (_b = this._vertexBuffer) === null || _b === void 0 ? void 0 : _b._rebuild();\n    for (const key in this._vertexBuffers) {\n      this._vertexBuffers[key]._rebuild();\n    }\n    this.resetDrawCache();\n  }\n  /**\n   * Is this system ready to be used/rendered\n   * @returns true if the system is ready\n   */\n  isReady() {\n    if (!this.emitter || this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady() || !this.particleTexture || !this.particleTexture.isReady()) {\n      return false;\n    }\n    if (this.blendMode !== ParticleSystem.BLENDMODE_MULTIPLYADD) {\n      if (!this._getWrapper(this.blendMode).effect.isReady()) {\n        return false;\n      }\n    } else {\n      if (!this._getWrapper(ParticleSystem.BLENDMODE_MULTIPLY).effect.isReady()) {\n        return false;\n      }\n      if (!this._getWrapper(ParticleSystem.BLENDMODE_ADD).effect.isReady()) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _render(blendMode) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const drawWrapper = this._getWrapper(blendMode);\n    const effect = drawWrapper.effect;\n    const engine = this._engine;\n    // Render\n    engine.enableEffect(drawWrapper);\n    const viewMatrix = (_a = this.defaultViewMatrix) !== null && _a !== void 0 ? _a : this._scene.getViewMatrix();\n    effect.setTexture(\"diffuseSampler\", this.particleTexture);\n    effect.setMatrix(\"view\", viewMatrix);\n    effect.setMatrix(\"projection\", (_b = this.defaultProjectionMatrix) !== null && _b !== void 0 ? _b : this._scene.getProjectionMatrix());\n    if (this._isAnimationSheetEnabled && this.particleTexture) {\n      const baseSize = this.particleTexture.getBaseSize();\n      effect.setFloat3(\"particlesInfos\", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, this.spriteCellWidth / baseSize.width);\n    }\n    effect.setVector2(\"translationPivot\", this.translationPivot);\n    effect.setFloat4(\"textureMask\", this.textureMask.r, this.textureMask.g, this.textureMask.b, this.textureMask.a);\n    if (this._isBillboardBased && this._scene) {\n      const camera = this._scene.activeCamera;\n      effect.setVector3(\"eyePosition\", camera.globalPosition);\n    }\n    if (this._rampGradientsTexture) {\n      if (!this._rampGradients || !this._rampGradients.length) {\n        this._rampGradientsTexture.dispose();\n        this._rampGradientsTexture = null;\n      }\n      effect.setTexture(\"rampSampler\", this._rampGradientsTexture);\n    }\n    const defines = effect.defines;\n    if (this._scene) {\n      bindClipPlane(effect, this, this._scene);\n    }\n    if (defines.indexOf(\"#define BILLBOARDMODE_ALL\") >= 0) {\n      viewMatrix.invertToRef(TmpVectors.Matrix[0]);\n      effect.setMatrix(\"invView\", TmpVectors.Matrix[0]);\n    }\n    if (this._vertexArrayObject !== undefined) {\n      if ((_c = this._scene) === null || _c === void 0 ? void 0 : _c.forceWireframe) {\n        engine.bindBuffers(this._vertexBuffers, this._linesIndexBufferUseInstancing, effect);\n      } else {\n        if (!this._vertexArrayObject) {\n          this._vertexArrayObject = this._engine.recordVertexArrayObject(this._vertexBuffers, null, effect);\n        }\n        this._engine.bindVertexArrayObject(this._vertexArrayObject, ((_d = this._scene) === null || _d === void 0 ? void 0 : _d.forceWireframe) ? this._linesIndexBufferUseInstancing : this._indexBuffer);\n      }\n    } else {\n      if (!this._indexBuffer) {\n        // Use instancing mode\n        engine.bindBuffers(this._vertexBuffers, ((_e = this._scene) === null || _e === void 0 ? void 0 : _e.forceWireframe) ? this._linesIndexBufferUseInstancing : null, effect);\n      } else {\n        engine.bindBuffers(this._vertexBuffers, ((_f = this._scene) === null || _f === void 0 ? void 0 : _f.forceWireframe) ? this._linesIndexBuffer : this._indexBuffer, effect);\n      }\n    }\n    // Log. depth\n    if (this.useLogarithmicDepth && this._scene) {\n      MaterialHelper.BindLogDepth(defines, effect, this._scene);\n    }\n    // image processing\n    if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\n      this._imageProcessingConfiguration.bind(effect);\n    }\n    // Draw order\n    switch (blendMode) {\n      case ParticleSystem.BLENDMODE_ADD:\n        engine.setAlphaMode(1);\n        break;\n      case ParticleSystem.BLENDMODE_ONEONE:\n        engine.setAlphaMode(6);\n        break;\n      case ParticleSystem.BLENDMODE_STANDARD:\n        engine.setAlphaMode(2);\n        break;\n      case ParticleSystem.BLENDMODE_MULTIPLY:\n        engine.setAlphaMode(4);\n        break;\n    }\n    if (this._onBeforeDrawParticlesObservable) {\n      this._onBeforeDrawParticlesObservable.notifyObservers(effect);\n    }\n    if (this._useInstancing) {\n      if ((_g = this._scene) === null || _g === void 0 ? void 0 : _g.forceWireframe) {\n        engine.drawElementsType(6, 0, 10, this._particles.length);\n      } else {\n        engine.drawArraysType(7, 0, 4, this._particles.length);\n      }\n    } else {\n      if ((_h = this._scene) === null || _h === void 0 ? void 0 : _h.forceWireframe) {\n        engine.drawElementsType(1, 0, this._particles.length * 10);\n      } else {\n        engine.drawElementsType(0, 0, this._particles.length * 6);\n      }\n    }\n    return this._particles.length;\n  }\n  /**\n   * Renders the particle system in its current state.\n   * @returns the current number of particles\n   */\n  render() {\n    // Check\n    if (!this.isReady() || !this._particles.length) {\n      return 0;\n    }\n    const engine = this._engine;\n    if (engine.setState) {\n      engine.setState(false);\n      if (this.forceDepthWrite) {\n        engine.setDepthWrite(true);\n      }\n    }\n    let outparticles = 0;\n    if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLYADD) {\n      outparticles = this._render(ParticleSystem.BLENDMODE_MULTIPLY) + this._render(ParticleSystem.BLENDMODE_ADD);\n    } else {\n      outparticles = this._render(this.blendMode);\n    }\n    this._engine.unbindInstanceAttributes();\n    this._engine.setAlphaMode(0);\n    return outparticles;\n  }\n  /**\n   * Disposes the particle system and free the associated resources\n   * @param disposeTexture defines if the particle texture must be disposed as well (true by default)\n   */\n  dispose(disposeTexture = true) {\n    this.resetDrawCache();\n    if (this._vertexBuffer) {\n      this._vertexBuffer.dispose();\n      this._vertexBuffer = null;\n    }\n    if (this._spriteBuffer) {\n      this._spriteBuffer.dispose();\n      this._spriteBuffer = null;\n    }\n    if (this._indexBuffer) {\n      this._engine._releaseBuffer(this._indexBuffer);\n      this._indexBuffer = null;\n    }\n    if (this._linesIndexBuffer) {\n      this._engine._releaseBuffer(this._linesIndexBuffer);\n      this._linesIndexBuffer = null;\n    }\n    if (this._linesIndexBufferUseInstancing) {\n      this._engine._releaseBuffer(this._linesIndexBufferUseInstancing);\n      this._linesIndexBufferUseInstancing = null;\n    }\n    if (this._vertexArrayObject) {\n      this._engine.releaseVertexArrayObject(this._vertexArrayObject);\n      this._vertexArrayObject = null;\n    }\n    if (disposeTexture && this.particleTexture) {\n      this.particleTexture.dispose();\n      this.particleTexture = null;\n    }\n    if (disposeTexture && this.noiseTexture) {\n      this.noiseTexture.dispose();\n      this.noiseTexture = null;\n    }\n    if (this._rampGradientsTexture) {\n      this._rampGradientsTexture.dispose();\n      this._rampGradientsTexture = null;\n    }\n    this._removeFromRoot();\n    if (this.subEmitters && !this._subEmitters) {\n      this._prepareSubEmitterInternalArray();\n    }\n    if (this._subEmitters && this._subEmitters.length) {\n      for (let index = 0; index < this._subEmitters.length; index++) {\n        for (const subEmitter of this._subEmitters[index]) {\n          subEmitter.dispose();\n        }\n      }\n      this._subEmitters = [];\n      this.subEmitters = [];\n    }\n    if (this._disposeEmitterOnDispose && this.emitter && this.emitter.dispose) {\n      this.emitter.dispose(true);\n    }\n    if (this._onBeforeDrawParticlesObservable) {\n      this._onBeforeDrawParticlesObservable.clear();\n    }\n    // Remove from scene\n    if (this._scene) {\n      const index = this._scene.particleSystems.indexOf(this);\n      if (index > -1) {\n        this._scene.particleSystems.splice(index, 1);\n      }\n      this._scene._activeParticleSystems.dispose();\n    }\n    // Callback\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.onStoppedObservable.clear();\n    this.reset();\n  }\n  // Clone\n  /**\n   * Clones the particle system.\n   * @param name The name of the cloned object\n   * @param newEmitter The new emitter to use\n   * @param cloneTexture Also clone the textures if true\n   * @returns the cloned particle system\n   */\n  clone(name, newEmitter, cloneTexture = false) {\n    const custom = Object.assign({}, this._customWrappers);\n    let program = null;\n    const engine = this._engine;\n    if (engine.createEffectForParticles) {\n      if (this.customShader != null) {\n        program = this.customShader;\n        const defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n        const effect = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\n        if (!custom[0]) {\n          this.setCustomEffect(effect, 0);\n        } else {\n          custom[0].effect = effect;\n        }\n      }\n    }\n    const serialization = this.serialize(cloneTexture);\n    const result = ParticleSystem.Parse(serialization, this._scene || this._engine, this._rootUrl);\n    result.name = name;\n    result.customShader = program;\n    result._customWrappers = custom;\n    if (newEmitter === undefined) {\n      newEmitter = this.emitter;\n    }\n    if (this.noiseTexture) {\n      result.noiseTexture = this.noiseTexture.clone();\n    }\n    result.emitter = newEmitter;\n    if (!this.preventAutoStart) {\n      result.start();\n    }\n    return result;\n  }\n  /**\n   * Serializes the particle system to a JSON object\n   * @param serializeTexture defines if the texture must be serialized as well\n   * @returns the JSON object\n   */\n  serialize(serializeTexture = false) {\n    const serializationObject = {};\n    ParticleSystem._Serialize(serializationObject, this, serializeTexture);\n    serializationObject.textureMask = this.textureMask.asArray();\n    serializationObject.customShader = this.customShader;\n    serializationObject.preventAutoStart = this.preventAutoStart;\n    // SubEmitters\n    if (this.subEmitters) {\n      serializationObject.subEmitters = [];\n      if (!this._subEmitters) {\n        this._prepareSubEmitterInternalArray();\n      }\n      for (const subs of this._subEmitters) {\n        const cell = [];\n        for (const sub of subs) {\n          cell.push(sub.serialize(serializeTexture));\n        }\n        serializationObject.subEmitters.push(cell);\n      }\n    }\n    return serializationObject;\n  }\n  /**\n   * @internal\n   */\n  static _Serialize(serializationObject, particleSystem, serializeTexture) {\n    serializationObject.name = particleSystem.name;\n    serializationObject.id = particleSystem.id;\n    serializationObject.capacity = particleSystem.getCapacity();\n    serializationObject.disposeOnStop = particleSystem.disposeOnStop;\n    serializationObject.manualEmitCount = particleSystem.manualEmitCount;\n    // Emitter\n    if (particleSystem.emitter.position) {\n      const emitterMesh = particleSystem.emitter;\n      serializationObject.emitterId = emitterMesh.id;\n    } else {\n      const emitterPosition = particleSystem.emitter;\n      serializationObject.emitter = emitterPosition.asArray();\n    }\n    // Emitter\n    if (particleSystem.particleEmitterType) {\n      serializationObject.particleEmitterType = particleSystem.particleEmitterType.serialize();\n    }\n    if (particleSystem.particleTexture) {\n      if (serializeTexture) {\n        serializationObject.texture = particleSystem.particleTexture.serialize();\n      } else {\n        serializationObject.textureName = particleSystem.particleTexture.name;\n        serializationObject.invertY = !!particleSystem.particleTexture._invertY;\n      }\n    }\n    serializationObject.isLocal = particleSystem.isLocal;\n    // Animations\n    SerializationHelper.AppendSerializedAnimations(particleSystem, serializationObject);\n    serializationObject.beginAnimationOnStart = particleSystem.beginAnimationOnStart;\n    serializationObject.beginAnimationFrom = particleSystem.beginAnimationFrom;\n    serializationObject.beginAnimationTo = particleSystem.beginAnimationTo;\n    serializationObject.beginAnimationLoop = particleSystem.beginAnimationLoop;\n    // Particle system\n    serializationObject.startDelay = particleSystem.startDelay;\n    serializationObject.renderingGroupId = particleSystem.renderingGroupId;\n    serializationObject.isBillboardBased = particleSystem.isBillboardBased;\n    serializationObject.billboardMode = particleSystem.billboardMode;\n    serializationObject.minAngularSpeed = particleSystem.minAngularSpeed;\n    serializationObject.maxAngularSpeed = particleSystem.maxAngularSpeed;\n    serializationObject.minSize = particleSystem.minSize;\n    serializationObject.maxSize = particleSystem.maxSize;\n    serializationObject.minScaleX = particleSystem.minScaleX;\n    serializationObject.maxScaleX = particleSystem.maxScaleX;\n    serializationObject.minScaleY = particleSystem.minScaleY;\n    serializationObject.maxScaleY = particleSystem.maxScaleY;\n    serializationObject.minEmitPower = particleSystem.minEmitPower;\n    serializationObject.maxEmitPower = particleSystem.maxEmitPower;\n    serializationObject.minLifeTime = particleSystem.minLifeTime;\n    serializationObject.maxLifeTime = particleSystem.maxLifeTime;\n    serializationObject.emitRate = particleSystem.emitRate;\n    serializationObject.gravity = particleSystem.gravity.asArray();\n    serializationObject.noiseStrength = particleSystem.noiseStrength.asArray();\n    serializationObject.color1 = particleSystem.color1.asArray();\n    serializationObject.color2 = particleSystem.color2.asArray();\n    serializationObject.colorDead = particleSystem.colorDead.asArray();\n    serializationObject.updateSpeed = particleSystem.updateSpeed;\n    serializationObject.targetStopDuration = particleSystem.targetStopDuration;\n    serializationObject.blendMode = particleSystem.blendMode;\n    serializationObject.preWarmCycles = particleSystem.preWarmCycles;\n    serializationObject.preWarmStepOffset = particleSystem.preWarmStepOffset;\n    serializationObject.minInitialRotation = particleSystem.minInitialRotation;\n    serializationObject.maxInitialRotation = particleSystem.maxInitialRotation;\n    serializationObject.startSpriteCellID = particleSystem.startSpriteCellID;\n    serializationObject.spriteCellLoop = particleSystem.spriteCellLoop;\n    serializationObject.endSpriteCellID = particleSystem.endSpriteCellID;\n    serializationObject.spriteCellChangeSpeed = particleSystem.spriteCellChangeSpeed;\n    serializationObject.spriteCellWidth = particleSystem.spriteCellWidth;\n    serializationObject.spriteCellHeight = particleSystem.spriteCellHeight;\n    serializationObject.spriteRandomStartCell = particleSystem.spriteRandomStartCell;\n    serializationObject.isAnimationSheetEnabled = particleSystem.isAnimationSheetEnabled;\n    serializationObject.useLogarithmicDepth = particleSystem.useLogarithmicDepth;\n    const colorGradients = particleSystem.getColorGradients();\n    if (colorGradients) {\n      serializationObject.colorGradients = [];\n      for (const colorGradient of colorGradients) {\n        const serializedGradient = {\n          gradient: colorGradient.gradient,\n          color1: colorGradient.color1.asArray()\n        };\n        if (colorGradient.color2) {\n          serializedGradient.color2 = colorGradient.color2.asArray();\n        } else {\n          serializedGradient.color2 = colorGradient.color1.asArray();\n        }\n        serializationObject.colorGradients.push(serializedGradient);\n      }\n    }\n    const rampGradients = particleSystem.getRampGradients();\n    if (rampGradients) {\n      serializationObject.rampGradients = [];\n      for (const rampGradient of rampGradients) {\n        const serializedGradient = {\n          gradient: rampGradient.gradient,\n          color: rampGradient.color.asArray()\n        };\n        serializationObject.rampGradients.push(serializedGradient);\n      }\n      serializationObject.useRampGradients = particleSystem.useRampGradients;\n    }\n    const colorRemapGradients = particleSystem.getColorRemapGradients();\n    if (colorRemapGradients) {\n      serializationObject.colorRemapGradients = [];\n      for (const colorRemapGradient of colorRemapGradients) {\n        const serializedGradient = {\n          gradient: colorRemapGradient.gradient,\n          factor1: colorRemapGradient.factor1\n        };\n        if (colorRemapGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = colorRemapGradient.factor2;\n        } else {\n          serializedGradient.factor2 = colorRemapGradient.factor1;\n        }\n        serializationObject.colorRemapGradients.push(serializedGradient);\n      }\n    }\n    const alphaRemapGradients = particleSystem.getAlphaRemapGradients();\n    if (alphaRemapGradients) {\n      serializationObject.alphaRemapGradients = [];\n      for (const alphaRemapGradient of alphaRemapGradients) {\n        const serializedGradient = {\n          gradient: alphaRemapGradient.gradient,\n          factor1: alphaRemapGradient.factor1\n        };\n        if (alphaRemapGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = alphaRemapGradient.factor2;\n        } else {\n          serializedGradient.factor2 = alphaRemapGradient.factor1;\n        }\n        serializationObject.alphaRemapGradients.push(serializedGradient);\n      }\n    }\n    const sizeGradients = particleSystem.getSizeGradients();\n    if (sizeGradients) {\n      serializationObject.sizeGradients = [];\n      for (const sizeGradient of sizeGradients) {\n        const serializedGradient = {\n          gradient: sizeGradient.gradient,\n          factor1: sizeGradient.factor1\n        };\n        if (sizeGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = sizeGradient.factor2;\n        } else {\n          serializedGradient.factor2 = sizeGradient.factor1;\n        }\n        serializationObject.sizeGradients.push(serializedGradient);\n      }\n    }\n    const angularSpeedGradients = particleSystem.getAngularSpeedGradients();\n    if (angularSpeedGradients) {\n      serializationObject.angularSpeedGradients = [];\n      for (const angularSpeedGradient of angularSpeedGradients) {\n        const serializedGradient = {\n          gradient: angularSpeedGradient.gradient,\n          factor1: angularSpeedGradient.factor1\n        };\n        if (angularSpeedGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = angularSpeedGradient.factor2;\n        } else {\n          serializedGradient.factor2 = angularSpeedGradient.factor1;\n        }\n        serializationObject.angularSpeedGradients.push(serializedGradient);\n      }\n    }\n    const velocityGradients = particleSystem.getVelocityGradients();\n    if (velocityGradients) {\n      serializationObject.velocityGradients = [];\n      for (const velocityGradient of velocityGradients) {\n        const serializedGradient = {\n          gradient: velocityGradient.gradient,\n          factor1: velocityGradient.factor1\n        };\n        if (velocityGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = velocityGradient.factor2;\n        } else {\n          serializedGradient.factor2 = velocityGradient.factor1;\n        }\n        serializationObject.velocityGradients.push(serializedGradient);\n      }\n    }\n    const dragGradients = particleSystem.getDragGradients();\n    if (dragGradients) {\n      serializationObject.dragGradients = [];\n      for (const dragGradient of dragGradients) {\n        const serializedGradient = {\n          gradient: dragGradient.gradient,\n          factor1: dragGradient.factor1\n        };\n        if (dragGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = dragGradient.factor2;\n        } else {\n          serializedGradient.factor2 = dragGradient.factor1;\n        }\n        serializationObject.dragGradients.push(serializedGradient);\n      }\n    }\n    const emitRateGradients = particleSystem.getEmitRateGradients();\n    if (emitRateGradients) {\n      serializationObject.emitRateGradients = [];\n      for (const emitRateGradient of emitRateGradients) {\n        const serializedGradient = {\n          gradient: emitRateGradient.gradient,\n          factor1: emitRateGradient.factor1\n        };\n        if (emitRateGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = emitRateGradient.factor2;\n        } else {\n          serializedGradient.factor2 = emitRateGradient.factor1;\n        }\n        serializationObject.emitRateGradients.push(serializedGradient);\n      }\n    }\n    const startSizeGradients = particleSystem.getStartSizeGradients();\n    if (startSizeGradients) {\n      serializationObject.startSizeGradients = [];\n      for (const startSizeGradient of startSizeGradients) {\n        const serializedGradient = {\n          gradient: startSizeGradient.gradient,\n          factor1: startSizeGradient.factor1\n        };\n        if (startSizeGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = startSizeGradient.factor2;\n        } else {\n          serializedGradient.factor2 = startSizeGradient.factor1;\n        }\n        serializationObject.startSizeGradients.push(serializedGradient);\n      }\n    }\n    const lifeTimeGradients = particleSystem.getLifeTimeGradients();\n    if (lifeTimeGradients) {\n      serializationObject.lifeTimeGradients = [];\n      for (const lifeTimeGradient of lifeTimeGradients) {\n        const serializedGradient = {\n          gradient: lifeTimeGradient.gradient,\n          factor1: lifeTimeGradient.factor1\n        };\n        if (lifeTimeGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = lifeTimeGradient.factor2;\n        } else {\n          serializedGradient.factor2 = lifeTimeGradient.factor1;\n        }\n        serializationObject.lifeTimeGradients.push(serializedGradient);\n      }\n    }\n    const limitVelocityGradients = particleSystem.getLimitVelocityGradients();\n    if (limitVelocityGradients) {\n      serializationObject.limitVelocityGradients = [];\n      for (const limitVelocityGradient of limitVelocityGradients) {\n        const serializedGradient = {\n          gradient: limitVelocityGradient.gradient,\n          factor1: limitVelocityGradient.factor1\n        };\n        if (limitVelocityGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = limitVelocityGradient.factor2;\n        } else {\n          serializedGradient.factor2 = limitVelocityGradient.factor1;\n        }\n        serializationObject.limitVelocityGradients.push(serializedGradient);\n      }\n      serializationObject.limitVelocityDamping = particleSystem.limitVelocityDamping;\n    }\n    if (particleSystem.noiseTexture) {\n      serializationObject.noiseTexture = particleSystem.noiseTexture.serialize();\n    }\n  }\n  /**\n   * @internal\n   */\n  static _Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl) {\n    var _a, _b, _c;\n    let scene;\n    if (sceneOrEngine instanceof ThinEngine) {\n      scene = null;\n    } else {\n      scene = sceneOrEngine;\n    }\n    const internalClass = GetClass(\"BABYLON.Texture\");\n    if (internalClass && scene) {\n      // Texture\n      if (parsedParticleSystem.texture) {\n        particleSystem.particleTexture = internalClass.Parse(parsedParticleSystem.texture, scene, rootUrl);\n      } else if (parsedParticleSystem.textureName) {\n        particleSystem.particleTexture = new internalClass(rootUrl + parsedParticleSystem.textureName, scene, false, parsedParticleSystem.invertY !== undefined ? parsedParticleSystem.invertY : true);\n        particleSystem.particleTexture.name = parsedParticleSystem.textureName;\n      }\n    }\n    // Emitter\n    if (!parsedParticleSystem.emitterId && parsedParticleSystem.emitterId !== 0 && parsedParticleSystem.emitter === undefined) {\n      particleSystem.emitter = Vector3.Zero();\n    } else if (parsedParticleSystem.emitterId && scene) {\n      particleSystem.emitter = scene.getLastMeshById(parsedParticleSystem.emitterId);\n    } else {\n      particleSystem.emitter = Vector3.FromArray(parsedParticleSystem.emitter);\n    }\n    particleSystem.isLocal = !!parsedParticleSystem.isLocal;\n    // Misc.\n    if (parsedParticleSystem.renderingGroupId !== undefined) {\n      particleSystem.renderingGroupId = parsedParticleSystem.renderingGroupId;\n    }\n    if (parsedParticleSystem.isBillboardBased !== undefined) {\n      particleSystem.isBillboardBased = parsedParticleSystem.isBillboardBased;\n    }\n    if (parsedParticleSystem.billboardMode !== undefined) {\n      particleSystem.billboardMode = parsedParticleSystem.billboardMode;\n    }\n    if (parsedParticleSystem.useLogarithmicDepth !== undefined) {\n      particleSystem.useLogarithmicDepth = parsedParticleSystem.useLogarithmicDepth;\n    }\n    // Animations\n    if (parsedParticleSystem.animations) {\n      for (let animationIndex = 0; animationIndex < parsedParticleSystem.animations.length; animationIndex++) {\n        const parsedAnimation = parsedParticleSystem.animations[animationIndex];\n        const internalClass = GetClass(\"BABYLON.Animation\");\n        if (internalClass) {\n          particleSystem.animations.push(internalClass.Parse(parsedAnimation));\n        }\n      }\n      particleSystem.beginAnimationOnStart = parsedParticleSystem.beginAnimationOnStart;\n      particleSystem.beginAnimationFrom = parsedParticleSystem.beginAnimationFrom;\n      particleSystem.beginAnimationTo = parsedParticleSystem.beginAnimationTo;\n      particleSystem.beginAnimationLoop = parsedParticleSystem.beginAnimationLoop;\n    }\n    if (parsedParticleSystem.autoAnimate && scene) {\n      scene.beginAnimation(particleSystem, parsedParticleSystem.autoAnimateFrom, parsedParticleSystem.autoAnimateTo, parsedParticleSystem.autoAnimateLoop, parsedParticleSystem.autoAnimateSpeed || 1.0);\n    }\n    // Particle system\n    particleSystem.startDelay = parsedParticleSystem.startDelay | 0;\n    particleSystem.minAngularSpeed = parsedParticleSystem.minAngularSpeed;\n    particleSystem.maxAngularSpeed = parsedParticleSystem.maxAngularSpeed;\n    particleSystem.minSize = parsedParticleSystem.minSize;\n    particleSystem.maxSize = parsedParticleSystem.maxSize;\n    if (parsedParticleSystem.minScaleX) {\n      particleSystem.minScaleX = parsedParticleSystem.minScaleX;\n      particleSystem.maxScaleX = parsedParticleSystem.maxScaleX;\n      particleSystem.minScaleY = parsedParticleSystem.minScaleY;\n      particleSystem.maxScaleY = parsedParticleSystem.maxScaleY;\n    }\n    if (parsedParticleSystem.preWarmCycles !== undefined) {\n      particleSystem.preWarmCycles = parsedParticleSystem.preWarmCycles;\n      particleSystem.preWarmStepOffset = parsedParticleSystem.preWarmStepOffset;\n    }\n    if (parsedParticleSystem.minInitialRotation !== undefined) {\n      particleSystem.minInitialRotation = parsedParticleSystem.minInitialRotation;\n      particleSystem.maxInitialRotation = parsedParticleSystem.maxInitialRotation;\n    }\n    particleSystem.minLifeTime = parsedParticleSystem.minLifeTime;\n    particleSystem.maxLifeTime = parsedParticleSystem.maxLifeTime;\n    particleSystem.minEmitPower = parsedParticleSystem.minEmitPower;\n    particleSystem.maxEmitPower = parsedParticleSystem.maxEmitPower;\n    particleSystem.emitRate = parsedParticleSystem.emitRate;\n    particleSystem.gravity = Vector3.FromArray(parsedParticleSystem.gravity);\n    if (parsedParticleSystem.noiseStrength) {\n      particleSystem.noiseStrength = Vector3.FromArray(parsedParticleSystem.noiseStrength);\n    }\n    particleSystem.color1 = Color4.FromArray(parsedParticleSystem.color1);\n    particleSystem.color2 = Color4.FromArray(parsedParticleSystem.color2);\n    particleSystem.colorDead = Color4.FromArray(parsedParticleSystem.colorDead);\n    particleSystem.updateSpeed = parsedParticleSystem.updateSpeed;\n    particleSystem.targetStopDuration = parsedParticleSystem.targetStopDuration;\n    particleSystem.blendMode = parsedParticleSystem.blendMode;\n    if (parsedParticleSystem.colorGradients) {\n      for (const colorGradient of parsedParticleSystem.colorGradients) {\n        particleSystem.addColorGradient(colorGradient.gradient, Color4.FromArray(colorGradient.color1), colorGradient.color2 ? Color4.FromArray(colorGradient.color2) : undefined);\n      }\n    }\n    if (parsedParticleSystem.rampGradients) {\n      for (const rampGradient of parsedParticleSystem.rampGradients) {\n        particleSystem.addRampGradient(rampGradient.gradient, Color3.FromArray(rampGradient.color));\n      }\n      particleSystem.useRampGradients = parsedParticleSystem.useRampGradients;\n    }\n    if (parsedParticleSystem.colorRemapGradients) {\n      for (const colorRemapGradient of parsedParticleSystem.colorRemapGradients) {\n        particleSystem.addColorRemapGradient(colorRemapGradient.gradient, colorRemapGradient.factor1 !== undefined ? colorRemapGradient.factor1 : colorRemapGradient.factor, colorRemapGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.alphaRemapGradients) {\n      for (const alphaRemapGradient of parsedParticleSystem.alphaRemapGradients) {\n        particleSystem.addAlphaRemapGradient(alphaRemapGradient.gradient, alphaRemapGradient.factor1 !== undefined ? alphaRemapGradient.factor1 : alphaRemapGradient.factor, alphaRemapGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.sizeGradients) {\n      for (const sizeGradient of parsedParticleSystem.sizeGradients) {\n        particleSystem.addSizeGradient(sizeGradient.gradient, sizeGradient.factor1 !== undefined ? sizeGradient.factor1 : sizeGradient.factor, sizeGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.angularSpeedGradients) {\n      for (const angularSpeedGradient of parsedParticleSystem.angularSpeedGradients) {\n        particleSystem.addAngularSpeedGradient(angularSpeedGradient.gradient, angularSpeedGradient.factor1 !== undefined ? angularSpeedGradient.factor1 : angularSpeedGradient.factor, angularSpeedGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.velocityGradients) {\n      for (const velocityGradient of parsedParticleSystem.velocityGradients) {\n        particleSystem.addVelocityGradient(velocityGradient.gradient, velocityGradient.factor1 !== undefined ? velocityGradient.factor1 : velocityGradient.factor, velocityGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.dragGradients) {\n      for (const dragGradient of parsedParticleSystem.dragGradients) {\n        particleSystem.addDragGradient(dragGradient.gradient, dragGradient.factor1 !== undefined ? dragGradient.factor1 : dragGradient.factor, dragGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.emitRateGradients) {\n      for (const emitRateGradient of parsedParticleSystem.emitRateGradients) {\n        particleSystem.addEmitRateGradient(emitRateGradient.gradient, emitRateGradient.factor1 !== undefined ? emitRateGradient.factor1 : emitRateGradient.factor, emitRateGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.startSizeGradients) {\n      for (const startSizeGradient of parsedParticleSystem.startSizeGradients) {\n        particleSystem.addStartSizeGradient(startSizeGradient.gradient, startSizeGradient.factor1 !== undefined ? startSizeGradient.factor1 : startSizeGradient.factor, startSizeGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.lifeTimeGradients) {\n      for (const lifeTimeGradient of parsedParticleSystem.lifeTimeGradients) {\n        particleSystem.addLifeTimeGradient(lifeTimeGradient.gradient, lifeTimeGradient.factor1 !== undefined ? lifeTimeGradient.factor1 : lifeTimeGradient.factor, lifeTimeGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.limitVelocityGradients) {\n      for (const limitVelocityGradient of parsedParticleSystem.limitVelocityGradients) {\n        particleSystem.addLimitVelocityGradient(limitVelocityGradient.gradient, limitVelocityGradient.factor1 !== undefined ? limitVelocityGradient.factor1 : limitVelocityGradient.factor, limitVelocityGradient.factor2);\n      }\n      particleSystem.limitVelocityDamping = parsedParticleSystem.limitVelocityDamping;\n    }\n    if (parsedParticleSystem.noiseTexture && scene) {\n      const internalClass = GetClass(\"BABYLON.ProceduralTexture\");\n      particleSystem.noiseTexture = internalClass.Parse(parsedParticleSystem.noiseTexture, scene, rootUrl);\n    }\n    // Emitter\n    let emitterType;\n    if (parsedParticleSystem.particleEmitterType) {\n      switch (parsedParticleSystem.particleEmitterType.type) {\n        case \"SphereParticleEmitter\":\n          emitterType = new SphereParticleEmitter();\n          break;\n        case \"SphereDirectedParticleEmitter\":\n          emitterType = new SphereDirectedParticleEmitter();\n          break;\n        case \"ConeEmitter\":\n        case \"ConeParticleEmitter\":\n          emitterType = new ConeParticleEmitter();\n          break;\n        case \"CylinderParticleEmitter\":\n          emitterType = new CylinderParticleEmitter();\n          break;\n        case \"CylinderDirectedParticleEmitter\":\n          emitterType = new CylinderDirectedParticleEmitter();\n          break;\n        case \"HemisphericParticleEmitter\":\n          emitterType = new HemisphericParticleEmitter();\n          break;\n        case \"PointParticleEmitter\":\n          emitterType = new PointParticleEmitter();\n          break;\n        case \"MeshParticleEmitter\":\n          emitterType = new MeshParticleEmitter();\n          break;\n        case \"BoxEmitter\":\n        case \"BoxParticleEmitter\":\n        default:\n          emitterType = new BoxParticleEmitter();\n          break;\n      }\n      emitterType.parse(parsedParticleSystem.particleEmitterType, scene);\n    } else {\n      emitterType = new BoxParticleEmitter();\n      emitterType.parse(parsedParticleSystem, scene);\n    }\n    particleSystem.particleEmitterType = emitterType;\n    // Animation sheet\n    particleSystem.startSpriteCellID = parsedParticleSystem.startSpriteCellID;\n    particleSystem.endSpriteCellID = parsedParticleSystem.endSpriteCellID;\n    particleSystem.spriteCellLoop = (_a = parsedParticleSystem.spriteCellLoop) !== null && _a !== void 0 ? _a : true;\n    particleSystem.spriteCellWidth = parsedParticleSystem.spriteCellWidth;\n    particleSystem.spriteCellHeight = parsedParticleSystem.spriteCellHeight;\n    particleSystem.spriteCellChangeSpeed = parsedParticleSystem.spriteCellChangeSpeed;\n    particleSystem.spriteRandomStartCell = parsedParticleSystem.spriteRandomStartCell;\n    particleSystem.disposeOnStop = (_b = parsedParticleSystem.disposeOnStop) !== null && _b !== void 0 ? _b : false;\n    particleSystem.manualEmitCount = (_c = parsedParticleSystem.manualEmitCount) !== null && _c !== void 0 ? _c : -1;\n  }\n  /**\n   * Parses a JSON object to create a particle system.\n   * @param parsedParticleSystem The JSON object to parse\n   * @param sceneOrEngine The scene or the engine to create the particle system in\n   * @param rootUrl The root url to use to load external dependencies like texture\n   * @param doNotStart Ignore the preventAutoStart attribute and does not start\n   * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n   * @returns the Parsed particle system\n   */\n  static Parse(parsedParticleSystem, sceneOrEngine, rootUrl, doNotStart = false, capacity) {\n    const name = parsedParticleSystem.name;\n    let custom = null;\n    let program = null;\n    let engine;\n    let scene;\n    if (sceneOrEngine instanceof ThinEngine) {\n      engine = sceneOrEngine;\n    } else {\n      scene = sceneOrEngine;\n      engine = scene.getEngine();\n    }\n    if (parsedParticleSystem.customShader && engine.createEffectForParticles) {\n      program = parsedParticleSystem.customShader;\n      const defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n      custom = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\n    }\n    const particleSystem = new ParticleSystem(name, capacity || parsedParticleSystem.capacity, sceneOrEngine, custom, parsedParticleSystem.isAnimationSheetEnabled);\n    particleSystem.customShader = program;\n    particleSystem._rootUrl = rootUrl;\n    if (parsedParticleSystem.id) {\n      particleSystem.id = parsedParticleSystem.id;\n    }\n    // SubEmitters\n    if (parsedParticleSystem.subEmitters) {\n      particleSystem.subEmitters = [];\n      for (const cell of parsedParticleSystem.subEmitters) {\n        const cellArray = [];\n        for (const sub of cell) {\n          cellArray.push(SubEmitter.Parse(sub, sceneOrEngine, rootUrl));\n        }\n        particleSystem.subEmitters.push(cellArray);\n      }\n    }\n    ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);\n    if (parsedParticleSystem.textureMask) {\n      particleSystem.textureMask = Color4.FromArray(parsedParticleSystem.textureMask);\n    }\n    // Auto start\n    if (parsedParticleSystem.preventAutoStart) {\n      particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;\n    }\n    if (!doNotStart && !particleSystem.preventAutoStart) {\n      particleSystem.start();\n    }\n    return particleSystem;\n  }\n}\n/**\n * Billboard mode will only apply to Y axis\n */\nParticleSystem.BILLBOARDMODE_Y = 2;\n/**\n * Billboard mode will apply to all axes\n */\nParticleSystem.BILLBOARDMODE_ALL = 7;\n/**\n * Special billboard mode where the particle will be biilboard to the camera but rotated to align with direction\n */\nParticleSystem.BILLBOARDMODE_STRETCHED = 8;\n/**\n * Special billboard mode where the particle will be billboard to the camera but only around the axis of the direction of particle emission\n */\nParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL = 9;\nSubEmitter._ParseParticleSystem = ParticleSystem.Parse;","map":{"version":3,"names":["FactorGradient","ColorGradient","Color3Gradient","GradientHelper","Observable","Vector3","Matrix","TmpVectors","Vector4","Scalar","VertexBuffer","Buffer","ImageProcessingConfiguration","RawTexture","EngineStore","BoxParticleEmitter","HemisphericParticleEmitter","SphereParticleEmitter","SphereDirectedParticleEmitter","CylinderParticleEmitter","ConeParticleEmitter","PointParticleEmitter","MeshParticleEmitter","CylinderDirectedParticleEmitter","BaseParticleSystem","Particle","SubEmitter","SubEmitterType","SerializationHelper","GetClass","DrawWrapper","Color4","Color3","TmpColors","ThinEngine","MaterialHelper","addClipPlaneUniforms","prepareStringDefinesForClipPlanes","bindClipPlane","ParticleSystem","onDispose","callback","_onDisposeObserver","onDisposeObservable","remove","add","useRampGradients","_useRampGradients","value","_resetEffect","particles","_particles","getActiveCount","length","getClassName","isStopping","_stopped","isAlive","getCustomEffect","blendMode","_b","_a","_customWrappers","effect","_getCustomDrawWrapper","setCustomEffect","_engine","drawContext","useInstancing","_useInstancing","onBeforeDrawParticlesObservable","_onBeforeDrawParticlesObservable","vertexShaderName","vertexBuffers","_vertexBuffers","indexBuffer","_indexBuffer","constructor","name","capacity","sceneOrEngine","customEffect","isAnimationSheetEnabled","epsilon","_emitterInverseWorldMatrix","Identity","_inheritedVelocityOffset","onStoppedObservable","Array","_stockParticles","_newPartsExcess","_scaledColorStep","_colorDiff","_scaledDirection","Zero","_scaledGravity","_currentRenderId","_started","_actualFrame","_currentEmitRate1","_currentEmitRate2","_currentStartSize1","_currentStartSize2","updateInAnimate","_rawTextureWidth","_disposeEmitterOnDispose","isLocal","isGPU","recycleParticle","particle","lastParticle","pop","copyTo","push","_createParticle","_reset","_subEmitters","subEmitters","Math","floor","random","_attachedSubEmitters","forEach","subEmitter","type","ATTACHED","newEmitter","clone","particleSystem","start","_emitFromParticle","templateIndex","END","subSystem","_inheritParticleInfoToSubEmitter","_rootParticleSystem","activeSubSystems","_capacity","_epsilon","_isAnimationSheetEnabled","_scene","LastCreatedScene","getEngine","uniqueId","getUniqueId","particleSystems","defaultProjectionMatrix","PerspectiveFovLH","isNDCHalfZRange","getCaps","vertexArrayObject","_vertexArrayObject","_attachImageProcessingConfiguration","_drawWrappers","instancedArrays","_createIndexBuffer","_createVertexBuffers","particleEmitterType","noiseTextureData","updateFunction","noiseTextureSize","noiseTexture","getSize","getContent","then","data","sameParticleArray","index","scaledUpdateSpeed","_scaledUpdateSpeed","previousAge","age","lifeTime","diff","oldDiff","ratio","_colorGradients","GetCurrentGradient","currentGradient","nextGradient","scale","_currentColorGradient","_currentColor1","copyFrom","_currentColor2","getColorToRef","LerpToRef","color","colorStep","scaleToRef","addInPlace","a","_angularSpeedGradients","_currentAngularSpeedGradient","_currentAngularSpeed1","_currentAngularSpeed2","getFactor","angularSpeed","Lerp","angle","directionScale","_velocityGradients","_currentVelocityGradient","_currentVelocity1","_currentVelocity2","direction","_limitVelocityGradients","_currentLimitVelocityGradient","_currentLimitVelocity1","_currentLimitVelocity2","limitVelocity","currentVelocity","scaleInPlace","limitVelocityDamping","_dragGradients","_currentDragGradient","_currentDrag1","_currentDrag2","drag","_localPosition","TransformCoordinatesToRef","_emitterWorldMatrix","position","_randomNoiseCoordinates1","fetchedColorR","_fetchR","x","y","width","height","fetchedColorG","z","_randomNoiseCoordinates2","fetchedColorB","force","scaledForce","copyFromFloats","noiseStrength","gravity","_sizeGradients","_currentSizeGradient","_currentSize1","_currentSize2","size","_colorRemapGradients","min","factor1","max","factor2","remapData","_alphaRemapGradients","w","updateCellIndex","_inheritParticleInfoToSubEmitters","disposeOnStop","stop","_addFactorGradient","factorGradients","gradient","factor","newGradient","sort","b","_removeFactorGradient","factorGradient","splice","addLifeTimeGradient","_lifeTimeGradients","removeLifeTimeGradient","addSizeGradient","removeSizeGradient","addColorRemapGradient","removeColorRemapGradient","addAlphaRemapGradient","removeAlphaRemapGradient","addAngularSpeedGradient","removeAngularSpeedGradient","addVelocityGradient","removeVelocityGradient","addLimitVelocityGradient","removeLimitVelocityGradient","addDragGradient","removeDragGradient","addEmitRateGradient","_emitRateGradients","removeEmitRateGradient","addStartSizeGradient","_startSizeGradients","removeStartSizeGradient","_createRampGradientTexture","_rampGradients","_rampGradientsTexture","Uint8Array","tmpColor","r","g","CreateRGBATexture","getRampGradients","forceRefreshGradients","_syncRampGradientTexture","dispose","addRampGradient","rampGradient","removeRampGradient","_removeGradientAndTexture","addColorGradient","color1","color2","colorGradient","removeColorGradient","resetDrawCache","drawWrappers","drawWrapper","u","v","pixels","abs","wrappedU","wrappedV","_vertexBuffer","_spriteBuffer","releaseVertexArrayObject","_vertexBufferSize","_isBillboardBased","billboardMode","BILLBOARDMODE_STRETCHED","BILLBOARDMODE_STRETCHED_LOCAL","engine","vertexSize","_vertexData","Float32Array","dataOffset","positions","createVertexBuffer","PositionKind","colors","ColorKind","options","cellIndexBuffer","directionBuffer","rampDataBuffer","offsets","spriteData","_linesIndexBufferUseInstancing","createIndexBuffer","Uint32Array","indices","indicesWireframe","count","_linesIndexBuffer","getCapacity","_alive","isStarted","_prepareSubEmitterInternalArray","delay","startDelay","targetStopDuration","_hasTargetStopDurationDependantGradient","setTimeout","_currentEmitRateGradient","_currentStartSizeGradient","preWarmCycles","emitter","indexOf","computeWorldMatrix","noiseTextureAsProcedural","onGeneratedObservable","addOnce","animate","render","beginAnimationOnStart","animations","beginAnimation","beginAnimationFrom","beginAnimationTo","beginAnimationLoop","stopSubEmitters","notifyObservers","_stopSubEmitters","reset","_appendParticleVertex","offsetX","offsetY","offset","worldOffset","cellIndex","_initialDirection","initialDirection","TransformNormalToRef","_removeFromRoot","_update","newParticles","emitterMesh","getWorldMatrix","emitterPosition","Translation","invertToRef","Clamp","factorGradient1","factorGradient2","lifeTime1","lifeTime2","RandomRange","minLifeTime","maxLifeTime","emitPower","minEmitPower","maxEmitPower","startPositionFunction","startDirectionFunction","minSize","maxSize","minScaleX","maxScaleX","minScaleY","maxScaleY","minAngularSpeed","maxAngularSpeed","minInitialRotation","maxInitialRotation","step","colorDead","subtractToRef","_initialStartSpriteCellID","startSpriteCellID","_initialEndSpriteCellID","endSpriteCellID","_initialSpriteCellLoop","spriteCellLoop","_GetAttributeNamesOrOptions","isBillboardBased","attributeNamesOrOptions","_GetEffectCreationOptions","useLogarithmicDepth","effectCreationOption","fillDefines","defines","BLENDMODE_MULTIPLY","BILLBOARDMODE_Y","BILLBOARDMODE_ALL","_imageProcessingConfiguration","prepareDefines","_imageProcessingConfigurationDefines","toString","fillUniformsAttributesAndSamplerNames","uniforms","attributes","samplers","PrepareUniforms","PrepareSamplers","_getWrapper","customWrapper","currentRenderPassId","_features","supportRenderPasses","join","attributesNamesOrOptions","setEffect","createEffect","preWarmOnly","isReady","getFrameId","updateSpeed","preWarmStepOffset","getAnimationRatio","manualEmitCount","rate","emitRate","onAnimationEnd","_toBeDisposed","_appendParticleVertices","updateDirectly","rebuild","_rebuild","key","particleTexture","BLENDMODE_MULTIPLYADD","BLENDMODE_ADD","_render","enableEffect","viewMatrix","defaultViewMatrix","getViewMatrix","setTexture","setMatrix","getProjectionMatrix","baseSize","getBaseSize","setFloat3","spriteCellWidth","spriteCellHeight","setVector2","translationPivot","setFloat4","textureMask","camera","activeCamera","setVector3","globalPosition","undefined","_c","forceWireframe","bindBuffers","recordVertexArrayObject","bindVertexArrayObject","_d","_e","_f","BindLogDepth","applyByPostProcess","bind","setAlphaMode","BLENDMODE_ONEONE","BLENDMODE_STANDARD","_g","drawElementsType","drawArraysType","_h","setState","forceDepthWrite","setDepthWrite","outparticles","unbindInstanceAttributes","disposeTexture","_releaseBuffer","clear","_activeParticleSystems","cloneTexture","custom","Object","assign","program","createEffectForParticles","customShader","shaderOptions","shaderPath","fragmentElement","serialization","serialize","result","Parse","_rootUrl","preventAutoStart","serializeTexture","serializationObject","_Serialize","asArray","subs","cell","sub","id","emitterId","texture","textureName","invertY","_invertY","AppendSerializedAnimations","renderingGroupId","spriteCellChangeSpeed","spriteRandomStartCell","colorGradients","getColorGradients","serializedGradient","rampGradients","colorRemapGradients","getColorRemapGradients","colorRemapGradient","alphaRemapGradients","getAlphaRemapGradients","alphaRemapGradient","sizeGradients","getSizeGradients","sizeGradient","angularSpeedGradients","getAngularSpeedGradients","angularSpeedGradient","velocityGradients","getVelocityGradients","velocityGradient","dragGradients","getDragGradients","dragGradient","emitRateGradients","getEmitRateGradients","emitRateGradient","startSizeGradients","getStartSizeGradients","startSizeGradient","lifeTimeGradients","getLifeTimeGradients","lifeTimeGradient","limitVelocityGradients","getLimitVelocityGradients","limitVelocityGradient","_Parse","parsedParticleSystem","rootUrl","scene","internalClass","getLastMeshById","FromArray","animationIndex","parsedAnimation","autoAnimate","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","emitterType","parse","doNotStart","cellArray","_ParseParticleSystem"],"sources":["../../../../dev/core/src/Particles/particleSystem.ts"],"sourcesContent":["/* eslint-disable import/no-internal-modules */\r\nimport type { Immutable, Nullable } from \"../types\";\r\nimport { FactorGradient, ColorGradient, Color3Gradient, GradientHelper } from \"../Misc/gradients\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3, Matrix, TmpVectors, Vector4 } from \"../Maths/math.vector\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer\";\r\n\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { IDisposable } from \"../scene\";\r\nimport type { IParticleEmitterType } from \"../Particles/EmitterTypes/index\";\r\nimport {\r\n    BoxParticleEmitter,\r\n    HemisphericParticleEmitter,\r\n    SphereParticleEmitter,\r\n    SphereDirectedParticleEmitter,\r\n    CylinderParticleEmitter,\r\n    ConeParticleEmitter,\r\n    PointParticleEmitter,\r\n    MeshParticleEmitter,\r\n    CylinderDirectedParticleEmitter,\r\n} from \"../Particles/EmitterTypes/index\";\r\nimport type { IParticleSystem } from \"./IParticleSystem\";\r\nimport { BaseParticleSystem } from \"./baseParticleSystem\";\r\nimport { Particle } from \"./particle\";\r\nimport { SubEmitter, SubEmitterType } from \"./subEmitter\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { SerializationHelper } from \"../Misc/decorators\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\n\r\nimport \"../Shaders/particles.fragment\";\r\nimport \"../Shaders/particles.vertex\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { Color4, Color3, TmpColors } from \"../Maths/math.color\";\r\nimport type { ISize } from \"../Maths/math.size\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\n\r\nimport \"../Engines/Extensions/engine.alpha\";\r\nimport { addClipPlaneUniforms, prepareStringDefinesForClipPlanes, bindClipPlane } from \"../Materials/clipPlaneMaterialHelper\";\r\n\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { ProceduralTexture } from \"../Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n * This represents a particle system in Babylon.\r\n * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n * Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.\r\n * @example https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro\r\n */\r\nexport class ParticleSystem extends BaseParticleSystem implements IDisposable, IAnimatable, IParticleSystem {\r\n    /**\r\n     * Billboard mode will only apply to Y axis\r\n     */\r\n    public static readonly BILLBOARDMODE_Y = Constants.PARTICLES_BILLBOARDMODE_Y;\r\n    /**\r\n     * Billboard mode will apply to all axes\r\n     */\r\n    public static readonly BILLBOARDMODE_ALL = Constants.PARTICLES_BILLBOARDMODE_ALL;\r\n    /**\r\n     * Special billboard mode where the particle will be biilboard to the camera but rotated to align with direction\r\n     */\r\n    public static readonly BILLBOARDMODE_STRETCHED = Constants.PARTICLES_BILLBOARDMODE_STRETCHED;\r\n    /**\r\n     * Special billboard mode where the particle will be billboard to the camera but only around the axis of the direction of particle emission\r\n     */\r\n    public static readonly BILLBOARDMODE_STRETCHED_LOCAL = Constants.PARTICLES_BILLBOARDMODE_STRETCHED_LOCAL;\r\n\r\n    /**\r\n     * This function can be defined to provide custom update for active particles.\r\n     * This function will be called instead of regular update (age, position, color, etc.).\r\n     * Do not forget that this function will be called on every frame so try to keep it simple and fast :)\r\n     */\r\n    public updateFunction: (particles: Particle[]) => void;\r\n\r\n    private _emitterWorldMatrix: Matrix;\r\n    private _emitterInverseWorldMatrix: Matrix = Matrix.Identity();\r\n\r\n    /**\r\n     * This function can be defined to specify initial direction for every new particle.\r\n     * It by default use the emitterType defined function\r\n     */\r\n    public startDirectionFunction: (worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean) => void;\r\n    /**\r\n     * This function can be defined to specify initial position for every new particle.\r\n     * It by default use the emitterType defined function\r\n     */\r\n    public startPositionFunction: (worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean) => void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _inheritedVelocityOffset = new Vector3();\r\n    /**\r\n     * An event triggered when the system is disposed\r\n     */\r\n    public onDisposeObservable = new Observable<IParticleSystem>();\r\n    /**\r\n     * An event triggered when the system is stopped\r\n     */\r\n    public onStoppedObservable = new Observable<IParticleSystem>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<IParticleSystem>>;\r\n    /**\r\n     * Sets a callback that will be triggered when the system is disposed\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    private _particles = new Array<Particle>();\r\n    private _epsilon: number;\r\n    private _capacity: number;\r\n    private _stockParticles = new Array<Particle>();\r\n    private _newPartsExcess = 0;\r\n    private _vertexData: Float32Array;\r\n    private _vertexBuffer: Nullable<Buffer>;\r\n    private _vertexBuffers: { [key: string]: VertexBuffer } = {};\r\n    private _spriteBuffer: Nullable<Buffer>;\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _linesIndexBuffer: Nullable<DataBuffer>;\r\n    private _linesIndexBufferUseInstancing: Nullable<DataBuffer>;\r\n    private _drawWrappers: DrawWrapper[][]; // first index is render pass id, second index is blend mode\r\n    private _customWrappers: { [blendMode: number]: Nullable<DrawWrapper> };\r\n    private _scaledColorStep = new Color4(0, 0, 0, 0);\r\n    private _colorDiff = new Color4(0, 0, 0, 0);\r\n    private _scaledDirection = Vector3.Zero();\r\n    private _scaledGravity = Vector3.Zero();\r\n    private _currentRenderId = -1;\r\n    private _alive: boolean;\r\n    private _useInstancing = false;\r\n    private _vertexArrayObject: Nullable<WebGLVertexArrayObject>;\r\n\r\n    private _started = false;\r\n    private _stopped = false;\r\n    private _actualFrame = 0;\r\n    private _scaledUpdateSpeed: number;\r\n    private _vertexBufferSize: number;\r\n\r\n    /** @internal */\r\n    public _currentEmitRateGradient: Nullable<FactorGradient>;\r\n    /** @internal */\r\n    public _currentEmitRate1 = 0;\r\n    /** @internal */\r\n    public _currentEmitRate2 = 0;\r\n\r\n    /** @internal */\r\n    public _currentStartSizeGradient: Nullable<FactorGradient>;\r\n    /** @internal */\r\n    public _currentStartSize1 = 0;\r\n    /** @internal */\r\n    public _currentStartSize2 = 0;\r\n\r\n    /** Indicates that the update of particles is done in the animate function */\r\n    public readonly updateInAnimate = true;\r\n\r\n    private readonly _rawTextureWidth = 256;\r\n    private _rampGradientsTexture: Nullable<RawTexture>;\r\n    private _useRampGradients = false;\r\n\r\n    /** Gets or sets a matrix to use to compute projection */\r\n    public defaultProjectionMatrix: Matrix;\r\n\r\n    /** Gets or sets a matrix to use to compute view */\r\n    public defaultViewMatrix: Matrix;\r\n\r\n    /** Gets or sets a boolean indicating that ramp gradients must be used\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro#ramp-gradients\r\n     */\r\n    public get useRampGradients(): boolean {\r\n        return this._useRampGradients;\r\n    }\r\n\r\n    public set useRampGradients(value: boolean) {\r\n        if (this._useRampGradients === value) {\r\n            return;\r\n        }\r\n\r\n        this._useRampGradients = value;\r\n\r\n        this._resetEffect();\r\n    }\r\n\r\n    // Sub-emitters\r\n    /**\r\n     * The Sub-emitters templates that will be used to generate the sub particle system to be associated with the system, this property is used by the root particle system only.\r\n     * When a particle is spawned, an array will be chosen at random and all the emitters in that array will be attached to the particle.  (Default: [])\r\n     */\r\n    public subEmitters: Array<ParticleSystem | SubEmitter | Array<SubEmitter>>;\r\n    // the subEmitters field above converted to a constant type\r\n    private _subEmitters: Array<Array<SubEmitter>>;\r\n    /**\r\n     * @internal\r\n     * If the particle systems emitter should be disposed when the particle system is disposed\r\n     */\r\n    public _disposeEmitterOnDispose = false;\r\n    /**\r\n     * The current active Sub-systems, this property is used by the root particle system only.\r\n     */\r\n    public activeSubSystems: Array<ParticleSystem>;\r\n\r\n    /**\r\n     * Specifies if the particles are updated in emitter local space or world space\r\n     */\r\n    public isLocal = false;\r\n\r\n    /** Indicates that the particle system is CPU based */\r\n    public readonly isGPU = false;\r\n\r\n    private _rootParticleSystem: Nullable<ParticleSystem>;\r\n    //end of Sub-emitter\r\n\r\n    /**\r\n     * Gets the current list of active particles\r\n     */\r\n    public get particles(): Particle[] {\r\n        return this._particles;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of particles active at the same time.\r\n     * @returns The number of active particles.\r\n     */\r\n    public getActiveCount() {\r\n        return this._particles.length;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"ParticleSystem\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ParticleSystem\";\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the system is stopping\r\n     * @returns true if the system is currently stopping\r\n     */\r\n    public isStopping() {\r\n        return this._stopped && this.isAlive();\r\n    }\r\n\r\n    /**\r\n     * Gets the custom effect used to render the particles\r\n     * @param blendMode Blend mode for which the effect should be retrieved\r\n     * @returns The effect\r\n     */\r\n    public getCustomEffect(blendMode: number = 0): Nullable<Effect> {\r\n        return this._customWrappers[blendMode]?.effect ?? this._customWrappers[0]!.effect;\r\n    }\r\n\r\n    private _getCustomDrawWrapper(blendMode: number = 0): Nullable<DrawWrapper> {\r\n        return this._customWrappers[blendMode] ?? this._customWrappers[0];\r\n    }\r\n\r\n    /**\r\n     * Sets the custom effect used to render the particles\r\n     * @param effect The effect to set\r\n     * @param blendMode Blend mode for which the effect should be set\r\n     */\r\n    public setCustomEffect(effect: Nullable<Effect>, blendMode: number = 0) {\r\n        this._customWrappers[blendMode] = new DrawWrapper(this._engine);\r\n        this._customWrappers[blendMode]!.effect = effect;\r\n        if (this._customWrappers[blendMode]!.drawContext) {\r\n            this._customWrappers[blendMode]!.drawContext!.useInstancing = this._useInstancing;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    private _onBeforeDrawParticlesObservable: Nullable<Observable<Nullable<Effect>>> = null;\r\n\r\n    /**\r\n     * Observable that will be called just before the particles are drawn\r\n     */\r\n    public get onBeforeDrawParticlesObservable(): Observable<Nullable<Effect>> {\r\n        if (!this._onBeforeDrawParticlesObservable) {\r\n            this._onBeforeDrawParticlesObservable = new Observable<Nullable<Effect>>();\r\n        }\r\n\r\n        return this._onBeforeDrawParticlesObservable;\r\n    }\r\n\r\n    /**\r\n     * Gets the name of the particle vertex shader\r\n     */\r\n    public get vertexShaderName(): string {\r\n        return \"particles\";\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex buffers used by the particle system\r\n     */\r\n    public get vertexBuffers(): Immutable<{ [key: string]: VertexBuffer }> {\r\n        return this._vertexBuffers;\r\n    }\r\n\r\n    /**\r\n     * Gets the index buffer used by the particle system (or null if no index buffer is used (if _useInstancing=true))\r\n     */\r\n    public get indexBuffer(): Nullable<DataBuffer> {\r\n        return this._indexBuffer;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a particle system.\r\n     * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n     * @param name The name of the particle system\r\n     * @param capacity The max number of particles alive at the same time\r\n     * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene\r\n     * @param customEffect a custom effect used to change the way particles are rendered by default\r\n     * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture\r\n     * @param epsilon Offset used to render the particles\r\n     */\r\n    constructor(\r\n        name: string,\r\n        capacity: number,\r\n        sceneOrEngine: Scene | ThinEngine,\r\n        customEffect: Nullable<Effect> = null,\r\n        isAnimationSheetEnabled: boolean = false,\r\n        epsilon: number = 0.01\r\n    ) {\r\n        super(name);\r\n\r\n        this._capacity = capacity;\r\n\r\n        this._epsilon = epsilon;\r\n        this._isAnimationSheetEnabled = isAnimationSheetEnabled;\r\n\r\n        if (!sceneOrEngine || sceneOrEngine.getClassName() === \"Scene\") {\r\n            this._scene = (sceneOrEngine as Scene) || EngineStore.LastCreatedScene;\r\n            this._engine = this._scene.getEngine();\r\n            this.uniqueId = this._scene.getUniqueId();\r\n            this._scene.particleSystems.push(this);\r\n        } else {\r\n            this._engine = sceneOrEngine as ThinEngine;\r\n            this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100, this._engine.isNDCHalfZRange);\r\n        }\r\n\r\n        if (this._engine.getCaps().vertexArrayObject) {\r\n            this._vertexArrayObject = null;\r\n        }\r\n\r\n        // Setup the default processing configuration to the scene.\r\n        this._attachImageProcessingConfiguration(null);\r\n\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        this._customWrappers = { 0: new DrawWrapper(this._engine) };\r\n        this._customWrappers[0]!.effect = customEffect;\r\n\r\n        this._drawWrappers = [];\r\n        this._useInstancing = this._engine.getCaps().instancedArrays;\r\n\r\n        this._createIndexBuffer();\r\n        this._createVertexBuffers();\r\n\r\n        // Default emitter type\r\n        this.particleEmitterType = new BoxParticleEmitter();\r\n        let noiseTextureData: Nullable<Uint8Array> = null;\r\n\r\n        // Update\r\n        this.updateFunction = (particles: Particle[]): void => {\r\n            let noiseTextureSize: Nullable<ISize> = null;\r\n\r\n            if (this.noiseTexture) {\r\n                // We need to get texture data back to CPU\r\n                noiseTextureSize = this.noiseTexture.getSize();\r\n                this.noiseTexture.getContent()?.then((data) => {\r\n                    noiseTextureData = data as Uint8Array;\r\n                });\r\n            }\r\n\r\n            const sameParticleArray = particles === this._particles;\r\n\r\n            for (let index = 0; index < particles.length; index++) {\r\n                const particle = particles[index];\r\n\r\n                let scaledUpdateSpeed = this._scaledUpdateSpeed;\r\n                const previousAge = particle.age;\r\n                particle.age += scaledUpdateSpeed;\r\n\r\n                // Evaluate step to death\r\n                if (particle.age > particle.lifeTime) {\r\n                    const diff = particle.age - previousAge;\r\n                    const oldDiff = particle.lifeTime - previousAge;\r\n\r\n                    scaledUpdateSpeed = (oldDiff * scaledUpdateSpeed) / diff;\r\n\r\n                    particle.age = particle.lifeTime;\r\n                }\r\n\r\n                const ratio = particle.age / particle.lifeTime;\r\n\r\n                // Color\r\n                if (this._colorGradients && this._colorGradients.length > 0) {\r\n                    GradientHelper.GetCurrentGradient(ratio, this._colorGradients, (currentGradient, nextGradient, scale) => {\r\n                        if (currentGradient !== particle._currentColorGradient) {\r\n                            particle._currentColor1.copyFrom(particle._currentColor2);\r\n                            (<ColorGradient>nextGradient).getColorToRef(particle._currentColor2);\r\n                            particle._currentColorGradient = <ColorGradient>currentGradient;\r\n                        }\r\n                        Color4.LerpToRef(particle._currentColor1, particle._currentColor2, scale, particle.color);\r\n                    });\r\n                } else {\r\n                    particle.colorStep.scaleToRef(scaledUpdateSpeed, this._scaledColorStep);\r\n                    particle.color.addInPlace(this._scaledColorStep);\r\n\r\n                    if (particle.color.a < 0) {\r\n                        particle.color.a = 0;\r\n                    }\r\n                }\r\n\r\n                // Angular speed\r\n                if (this._angularSpeedGradients && this._angularSpeedGradients.length > 0) {\r\n                    GradientHelper.GetCurrentGradient(ratio, this._angularSpeedGradients, (currentGradient, nextGradient, scale) => {\r\n                        if (currentGradient !== particle._currentAngularSpeedGradient) {\r\n                            particle._currentAngularSpeed1 = particle._currentAngularSpeed2;\r\n                            particle._currentAngularSpeed2 = (<FactorGradient>nextGradient).getFactor();\r\n                            particle._currentAngularSpeedGradient = <FactorGradient>currentGradient;\r\n                        }\r\n                        particle.angularSpeed = Scalar.Lerp(particle._currentAngularSpeed1, particle._currentAngularSpeed2, scale);\r\n                    });\r\n                }\r\n                particle.angle += particle.angularSpeed * scaledUpdateSpeed;\r\n\r\n                // Direction\r\n                let directionScale = scaledUpdateSpeed;\r\n\r\n                /// Velocity\r\n                if (this._velocityGradients && this._velocityGradients.length > 0) {\r\n                    GradientHelper.GetCurrentGradient(ratio, this._velocityGradients, (currentGradient, nextGradient, scale) => {\r\n                        if (currentGradient !== particle._currentVelocityGradient) {\r\n                            particle._currentVelocity1 = particle._currentVelocity2;\r\n                            particle._currentVelocity2 = (<FactorGradient>nextGradient).getFactor();\r\n                            particle._currentVelocityGradient = <FactorGradient>currentGradient;\r\n                        }\r\n                        directionScale *= Scalar.Lerp(particle._currentVelocity1, particle._currentVelocity2, scale);\r\n                    });\r\n                }\r\n\r\n                particle.direction.scaleToRef(directionScale, this._scaledDirection);\r\n\r\n                /// Limit velocity\r\n                if (this._limitVelocityGradients && this._limitVelocityGradients.length > 0) {\r\n                    GradientHelper.GetCurrentGradient(ratio, this._limitVelocityGradients, (currentGradient, nextGradient, scale) => {\r\n                        if (currentGradient !== particle._currentLimitVelocityGradient) {\r\n                            particle._currentLimitVelocity1 = particle._currentLimitVelocity2;\r\n                            particle._currentLimitVelocity2 = (<FactorGradient>nextGradient).getFactor();\r\n                            particle._currentLimitVelocityGradient = <FactorGradient>currentGradient;\r\n                        }\r\n\r\n                        const limitVelocity = Scalar.Lerp(particle._currentLimitVelocity1, particle._currentLimitVelocity2, scale);\r\n                        const currentVelocity = particle.direction.length();\r\n\r\n                        if (currentVelocity > limitVelocity) {\r\n                            particle.direction.scaleInPlace(this.limitVelocityDamping);\r\n                        }\r\n                    });\r\n                }\r\n\r\n                /// Drag\r\n                if (this._dragGradients && this._dragGradients.length > 0) {\r\n                    GradientHelper.GetCurrentGradient(ratio, this._dragGradients, (currentGradient, nextGradient, scale) => {\r\n                        if (currentGradient !== particle._currentDragGradient) {\r\n                            particle._currentDrag1 = particle._currentDrag2;\r\n                            particle._currentDrag2 = (<FactorGradient>nextGradient).getFactor();\r\n                            particle._currentDragGradient = <FactorGradient>currentGradient;\r\n                        }\r\n\r\n                        const drag = Scalar.Lerp(particle._currentDrag1, particle._currentDrag2, scale);\r\n\r\n                        this._scaledDirection.scaleInPlace(1.0 - drag);\r\n                    });\r\n                }\r\n\r\n                if (this.isLocal && particle._localPosition) {\r\n                    particle._localPosition!.addInPlace(this._scaledDirection);\r\n                    Vector3.TransformCoordinatesToRef(particle._localPosition!, this._emitterWorldMatrix, particle.position);\r\n                } else {\r\n                    particle.position.addInPlace(this._scaledDirection);\r\n                }\r\n\r\n                // Noise\r\n                if (noiseTextureData && noiseTextureSize && particle._randomNoiseCoordinates1) {\r\n                    const fetchedColorR = this._fetchR(\r\n                        particle._randomNoiseCoordinates1.x,\r\n                        particle._randomNoiseCoordinates1.y,\r\n                        noiseTextureSize.width,\r\n                        noiseTextureSize.height,\r\n                        noiseTextureData\r\n                    );\r\n                    const fetchedColorG = this._fetchR(\r\n                        particle._randomNoiseCoordinates1.z,\r\n                        particle._randomNoiseCoordinates2.x,\r\n                        noiseTextureSize.width,\r\n                        noiseTextureSize.height,\r\n                        noiseTextureData\r\n                    );\r\n                    const fetchedColorB = this._fetchR(\r\n                        particle._randomNoiseCoordinates2.y,\r\n                        particle._randomNoiseCoordinates2.z,\r\n                        noiseTextureSize.width,\r\n                        noiseTextureSize.height,\r\n                        noiseTextureData\r\n                    );\r\n\r\n                    const force = TmpVectors.Vector3[0];\r\n                    const scaledForce = TmpVectors.Vector3[1];\r\n\r\n                    force.copyFromFloats(\r\n                        (2 * fetchedColorR - 1) * this.noiseStrength.x,\r\n                        (2 * fetchedColorG - 1) * this.noiseStrength.y,\r\n                        (2 * fetchedColorB - 1) * this.noiseStrength.z\r\n                    );\r\n\r\n                    force.scaleToRef(scaledUpdateSpeed, scaledForce);\r\n                    particle.direction.addInPlace(scaledForce);\r\n                }\r\n\r\n                // Gravity\r\n                this.gravity.scaleToRef(scaledUpdateSpeed, this._scaledGravity);\r\n                particle.direction.addInPlace(this._scaledGravity);\r\n\r\n                // Size\r\n                if (this._sizeGradients && this._sizeGradients.length > 0) {\r\n                    GradientHelper.GetCurrentGradient(ratio, this._sizeGradients, (currentGradient, nextGradient, scale) => {\r\n                        if (currentGradient !== particle._currentSizeGradient) {\r\n                            particle._currentSize1 = particle._currentSize2;\r\n                            particle._currentSize2 = (<FactorGradient>nextGradient).getFactor();\r\n                            particle._currentSizeGradient = <FactorGradient>currentGradient;\r\n                        }\r\n                        particle.size = Scalar.Lerp(particle._currentSize1, particle._currentSize2, scale);\r\n                    });\r\n                }\r\n\r\n                // Remap data\r\n                if (this._useRampGradients) {\r\n                    if (this._colorRemapGradients && this._colorRemapGradients.length > 0) {\r\n                        GradientHelper.GetCurrentGradient(ratio, this._colorRemapGradients, (currentGradient, nextGradient, scale) => {\r\n                            const min = Scalar.Lerp((<FactorGradient>currentGradient).factor1, (<FactorGradient>nextGradient).factor1, scale);\r\n                            const max = Scalar.Lerp((<FactorGradient>currentGradient).factor2!, (<FactorGradient>nextGradient).factor2!, scale);\r\n\r\n                            particle.remapData.x = min;\r\n                            particle.remapData.y = max - min;\r\n                        });\r\n                    }\r\n\r\n                    if (this._alphaRemapGradients && this._alphaRemapGradients.length > 0) {\r\n                        GradientHelper.GetCurrentGradient(ratio, this._alphaRemapGradients, (currentGradient, nextGradient, scale) => {\r\n                            const min = Scalar.Lerp((<FactorGradient>currentGradient).factor1, (<FactorGradient>nextGradient).factor1, scale);\r\n                            const max = Scalar.Lerp((<FactorGradient>currentGradient).factor2!, (<FactorGradient>nextGradient).factor2!, scale);\r\n\r\n                            particle.remapData.z = min;\r\n                            particle.remapData.w = max - min;\r\n                        });\r\n                    }\r\n                }\r\n\r\n                if (this._isAnimationSheetEnabled) {\r\n                    particle.updateCellIndex();\r\n                }\r\n\r\n                // Update the position of the attached sub-emitters to match their attached particle\r\n                particle._inheritParticleInfoToSubEmitters();\r\n\r\n                if (particle.age >= particle.lifeTime) {\r\n                    // Recycle by swapping with last particle\r\n                    this._emitFromParticle(particle);\r\n                    if (particle._attachedSubEmitters) {\r\n                        particle._attachedSubEmitters.forEach((subEmitter) => {\r\n                            subEmitter.particleSystem.disposeOnStop = true;\r\n                            subEmitter.particleSystem.stop();\r\n                        });\r\n                        particle._attachedSubEmitters = null;\r\n                    }\r\n                    this.recycleParticle(particle);\r\n                    if (sameParticleArray) {\r\n                        index--;\r\n                    }\r\n                    continue;\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    private _addFactorGradient(factorGradients: FactorGradient[], gradient: number, factor: number, factor2?: number) {\r\n        const newGradient = new FactorGradient(gradient, factor, factor2);\r\n        factorGradients.push(newGradient);\r\n\r\n        factorGradients.sort((a, b) => {\r\n            if (a.gradient < b.gradient) {\r\n                return -1;\r\n            } else if (a.gradient > b.gradient) {\r\n                return 1;\r\n            }\r\n\r\n            return 0;\r\n        });\r\n    }\r\n\r\n    private _removeFactorGradient(factorGradients: Nullable<FactorGradient[]>, gradient: number) {\r\n        if (!factorGradients) {\r\n            return;\r\n        }\r\n\r\n        let index = 0;\r\n        for (const factorGradient of factorGradients) {\r\n            if (factorGradient.gradient === gradient) {\r\n                factorGradients.splice(index, 1);\r\n                break;\r\n            }\r\n            index++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a new life time gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the life time factor to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addLifeTimeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._lifeTimeGradients) {\r\n            this._lifeTimeGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._lifeTimeGradients, gradient, factor, factor2);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific life time gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeLifeTimeGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._lifeTimeGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new size gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the size factor to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addSizeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._sizeGradients) {\r\n            this._sizeGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._sizeGradients, gradient, factor, factor2);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific size gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeSizeGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._sizeGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new color remap gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param min defines the color remap minimal range\r\n     * @param max defines the color remap maximal range\r\n     * @returns the current particle system\r\n     */\r\n    public addColorRemapGradient(gradient: number, min: number, max: number): IParticleSystem {\r\n        if (!this._colorRemapGradients) {\r\n            this._colorRemapGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._colorRemapGradients, gradient, min, max);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific color remap gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeColorRemapGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._colorRemapGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new alpha remap gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param min defines the alpha remap minimal range\r\n     * @param max defines the alpha remap maximal range\r\n     * @returns the current particle system\r\n     */\r\n    public addAlphaRemapGradient(gradient: number, min: number, max: number): IParticleSystem {\r\n        if (!this._alphaRemapGradients) {\r\n            this._alphaRemapGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._alphaRemapGradients, gradient, min, max);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific alpha remap gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeAlphaRemapGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._alphaRemapGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new angular speed gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the angular speed  to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addAngularSpeedGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._angularSpeedGradients) {\r\n            this._angularSpeedGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._angularSpeedGradients, gradient, factor, factor2);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific angular speed gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeAngularSpeedGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._angularSpeedGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new velocity gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the velocity to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addVelocityGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._velocityGradients) {\r\n            this._velocityGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._velocityGradients, gradient, factor, factor2);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific velocity gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeVelocityGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._velocityGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new limit velocity gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the limit velocity value to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addLimitVelocityGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._limitVelocityGradients) {\r\n            this._limitVelocityGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._limitVelocityGradients, gradient, factor, factor2);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific limit velocity gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeLimitVelocityGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._limitVelocityGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new drag gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the drag value to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addDragGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._dragGradients) {\r\n            this._dragGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._dragGradients, gradient, factor, factor2);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific drag gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeDragGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._dragGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new emit rate gradient (please note that this will only work if you set the targetStopDuration property)\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the emit rate value to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addEmitRateGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._emitRateGradients) {\r\n            this._emitRateGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._emitRateGradients, gradient, factor, factor2);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific emit rate gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeEmitRateGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._emitRateGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new start size gradient (please note that this will only work if you set the targetStopDuration property)\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the start size value to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addStartSizeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._startSizeGradients) {\r\n            this._startSizeGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._startSizeGradients, gradient, factor, factor2);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific start size gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeStartSizeGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._startSizeGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    private _createRampGradientTexture() {\r\n        if (!this._rampGradients || !this._rampGradients.length || this._rampGradientsTexture || !this._scene) {\r\n            return;\r\n        }\r\n\r\n        const data = new Uint8Array(this._rawTextureWidth * 4);\r\n        const tmpColor = TmpColors.Color3[0];\r\n\r\n        for (let x = 0; x < this._rawTextureWidth; x++) {\r\n            const ratio = x / this._rawTextureWidth;\r\n\r\n            GradientHelper.GetCurrentGradient(ratio, this._rampGradients, (currentGradient, nextGradient, scale) => {\r\n                Color3.LerpToRef((<Color3Gradient>currentGradient).color, (<Color3Gradient>nextGradient).color, scale, tmpColor);\r\n                data[x * 4] = tmpColor.r * 255;\r\n                data[x * 4 + 1] = tmpColor.g * 255;\r\n                data[x * 4 + 2] = tmpColor.b * 255;\r\n                data[x * 4 + 3] = 255;\r\n            });\r\n        }\r\n\r\n        this._rampGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE);\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of ramp gradients.\r\n     * You must use addRampGradient and removeRampGradient to update this list\r\n     * @returns the list of ramp gradients\r\n     */\r\n    public getRampGradients(): Nullable<Array<Color3Gradient>> {\r\n        return this._rampGradients;\r\n    }\r\n\r\n    /** Force the system to rebuild all gradients that need to be resync */\r\n    public forceRefreshGradients() {\r\n        this._syncRampGradientTexture();\r\n    }\r\n\r\n    private _syncRampGradientTexture() {\r\n        if (!this._rampGradients) {\r\n            return;\r\n        }\r\n\r\n        this._rampGradients.sort((a, b) => {\r\n            if (a.gradient < b.gradient) {\r\n                return -1;\r\n            } else if (a.gradient > b.gradient) {\r\n                return 1;\r\n            }\r\n\r\n            return 0;\r\n        });\r\n\r\n        if (this._rampGradientsTexture) {\r\n            this._rampGradientsTexture.dispose();\r\n            this._rampGradientsTexture = null;\r\n        }\r\n\r\n        this._createRampGradientTexture();\r\n    }\r\n\r\n    /**\r\n     * Adds a new ramp gradient used to remap particle colors\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param color defines the color to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addRampGradient(gradient: number, color: Color3): ParticleSystem {\r\n        if (!this._rampGradients) {\r\n            this._rampGradients = [];\r\n        }\r\n\r\n        const rampGradient = new Color3Gradient(gradient, color);\r\n        this._rampGradients.push(rampGradient);\r\n\r\n        this._syncRampGradientTexture();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific ramp gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeRampGradient(gradient: number): ParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._rampGradients, this._rampGradientsTexture);\r\n        this._rampGradientsTexture = null;\r\n\r\n        if (this._rampGradients && this._rampGradients.length > 0) {\r\n            this._createRampGradientTexture();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new color gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param color1 defines the color to affect to the specified gradient\r\n     * @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from\r\n     * @returns this particle system\r\n     */\r\n    public addColorGradient(gradient: number, color1: Color4, color2?: Color4): IParticleSystem {\r\n        if (!this._colorGradients) {\r\n            this._colorGradients = [];\r\n        }\r\n\r\n        const colorGradient = new ColorGradient(gradient, color1, color2);\r\n        this._colorGradients.push(colorGradient);\r\n\r\n        this._colorGradients.sort((a, b) => {\r\n            if (a.gradient < b.gradient) {\r\n                return -1;\r\n            } else if (a.gradient > b.gradient) {\r\n                return 1;\r\n            }\r\n\r\n            return 0;\r\n        });\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific color gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns this particle system\r\n     */\r\n    public removeColorGradient(gradient: number): IParticleSystem {\r\n        if (!this._colorGradients) {\r\n            return this;\r\n        }\r\n\r\n        let index = 0;\r\n        for (const colorGradient of this._colorGradients) {\r\n            if (colorGradient.gradient === gradient) {\r\n                this._colorGradients.splice(index, 1);\r\n                break;\r\n            }\r\n            index++;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache\r\n     */\r\n    public resetDrawCache(): void {\r\n        for (const drawWrappers of this._drawWrappers) {\r\n            if (drawWrappers) {\r\n                for (const drawWrapper of drawWrappers) {\r\n                    drawWrapper?.dispose();\r\n                }\r\n            }\r\n        }\r\n\r\n        this._drawWrappers = [];\r\n    }\r\n\r\n    private _fetchR(u: number, v: number, width: number, height: number, pixels: Uint8Array): number {\r\n        u = Math.abs(u) * 0.5 + 0.5;\r\n        v = Math.abs(v) * 0.5 + 0.5;\r\n\r\n        const wrappedU = (u * width) % width | 0;\r\n        const wrappedV = (v * height) % height | 0;\r\n\r\n        const position = (wrappedU + wrappedV * width) * 4;\r\n        return pixels[position] / 255;\r\n    }\r\n\r\n    protected _reset() {\r\n        this._resetEffect();\r\n    }\r\n\r\n    private _resetEffect() {\r\n        if (this._vertexBuffer) {\r\n            this._vertexBuffer.dispose();\r\n            this._vertexBuffer = null;\r\n        }\r\n\r\n        if (this._spriteBuffer) {\r\n            this._spriteBuffer.dispose();\r\n            this._spriteBuffer = null;\r\n        }\r\n\r\n        if (this._vertexArrayObject) {\r\n            this._engine.releaseVertexArrayObject(this._vertexArrayObject);\r\n            this._vertexArrayObject = null;\r\n        }\r\n\r\n        this._createVertexBuffers();\r\n    }\r\n\r\n    private _createVertexBuffers() {\r\n        this._vertexBufferSize = this._useInstancing ? 10 : 12;\r\n        if (this._isAnimationSheetEnabled) {\r\n            this._vertexBufferSize += 1;\r\n        }\r\n\r\n        if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {\r\n            this._vertexBufferSize += 3;\r\n        }\r\n\r\n        if (this._useRampGradients) {\r\n            this._vertexBufferSize += 4;\r\n        }\r\n\r\n        const engine = this._engine;\r\n        const vertexSize = this._vertexBufferSize * (this._useInstancing ? 1 : 4);\r\n        this._vertexData = new Float32Array(this._capacity * vertexSize);\r\n        this._vertexBuffer = new Buffer(engine, this._vertexData, true, vertexSize);\r\n\r\n        let dataOffset = 0;\r\n        const positions = this._vertexBuffer.createVertexBuffer(VertexBuffer.PositionKind, dataOffset, 3, this._vertexBufferSize, this._useInstancing);\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = positions;\r\n        dataOffset += 3;\r\n\r\n        const colors = this._vertexBuffer.createVertexBuffer(VertexBuffer.ColorKind, dataOffset, 4, this._vertexBufferSize, this._useInstancing);\r\n        this._vertexBuffers[VertexBuffer.ColorKind] = colors;\r\n        dataOffset += 4;\r\n\r\n        const options = this._vertexBuffer.createVertexBuffer(\"angle\", dataOffset, 1, this._vertexBufferSize, this._useInstancing);\r\n        this._vertexBuffers[\"angle\"] = options;\r\n        dataOffset += 1;\r\n\r\n        const size = this._vertexBuffer.createVertexBuffer(\"size\", dataOffset, 2, this._vertexBufferSize, this._useInstancing);\r\n        this._vertexBuffers[\"size\"] = size;\r\n        dataOffset += 2;\r\n\r\n        if (this._isAnimationSheetEnabled) {\r\n            const cellIndexBuffer = this._vertexBuffer.createVertexBuffer(\"cellIndex\", dataOffset, 1, this._vertexBufferSize, this._useInstancing);\r\n            this._vertexBuffers[\"cellIndex\"] = cellIndexBuffer;\r\n            dataOffset += 1;\r\n        }\r\n\r\n        if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {\r\n            const directionBuffer = this._vertexBuffer.createVertexBuffer(\"direction\", dataOffset, 3, this._vertexBufferSize, this._useInstancing);\r\n            this._vertexBuffers[\"direction\"] = directionBuffer;\r\n            dataOffset += 3;\r\n        }\r\n\r\n        if (this._useRampGradients) {\r\n            const rampDataBuffer = this._vertexBuffer.createVertexBuffer(\"remapData\", dataOffset, 4, this._vertexBufferSize, this._useInstancing);\r\n            this._vertexBuffers[\"remapData\"] = rampDataBuffer;\r\n            dataOffset += 4;\r\n        }\r\n\r\n        let offsets: VertexBuffer;\r\n        if (this._useInstancing) {\r\n            const spriteData = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\r\n            this._spriteBuffer = new Buffer(engine, spriteData, false, 2);\r\n            offsets = this._spriteBuffer.createVertexBuffer(\"offset\", 0, 2);\r\n        } else {\r\n            offsets = this._vertexBuffer.createVertexBuffer(\"offset\", dataOffset, 2, this._vertexBufferSize, this._useInstancing);\r\n            dataOffset += 2;\r\n        }\r\n        this._vertexBuffers[\"offset\"] = offsets;\r\n\r\n        this.resetDrawCache();\r\n    }\r\n\r\n    private _createIndexBuffer() {\r\n        if (this._useInstancing) {\r\n            this._linesIndexBufferUseInstancing = this._engine.createIndexBuffer(new Uint32Array([0, 1, 1, 3, 3, 2, 2, 0, 0, 3]));\r\n            return;\r\n        }\r\n        const indices = [];\r\n        const indicesWireframe = [];\r\n        let index = 0;\r\n        for (let count = 0; count < this._capacity; count++) {\r\n            indices.push(index);\r\n            indices.push(index + 1);\r\n            indices.push(index + 2);\r\n            indices.push(index);\r\n            indices.push(index + 2);\r\n            indices.push(index + 3);\r\n            indicesWireframe.push(index, index + 1, index + 1, index + 2, index + 2, index + 3, index + 3, index, index, index + 3);\r\n            index += 4;\r\n        }\r\n\r\n        this._indexBuffer = this._engine.createIndexBuffer(indices);\r\n        this._linesIndexBuffer = this._engine.createIndexBuffer(indicesWireframe);\r\n    }\r\n\r\n    /**\r\n     * Gets the maximum number of particles active at the same time.\r\n     * @returns The max number of active particles.\r\n     */\r\n    public getCapacity(): number {\r\n        return this._capacity;\r\n    }\r\n\r\n    /**\r\n     * Gets whether there are still active particles in the system.\r\n     * @returns True if it is alive, otherwise false.\r\n     */\r\n    public isAlive(): boolean {\r\n        return this._alive;\r\n    }\r\n\r\n    /**\r\n     * Gets if the system has been started. (Note: this will still be true after stop is called)\r\n     * @returns True if it has been started, otherwise false.\r\n     */\r\n    public isStarted(): boolean {\r\n        return this._started;\r\n    }\r\n\r\n    private _prepareSubEmitterInternalArray() {\r\n        this._subEmitters = new Array<Array<SubEmitter>>();\r\n        if (this.subEmitters) {\r\n            this.subEmitters.forEach((subEmitter) => {\r\n                if (subEmitter instanceof ParticleSystem) {\r\n                    this._subEmitters.push([new SubEmitter(subEmitter)]);\r\n                } else if (subEmitter instanceof SubEmitter) {\r\n                    this._subEmitters.push([subEmitter]);\r\n                } else if (subEmitter instanceof Array) {\r\n                    this._subEmitters.push(subEmitter);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts the particle system and begins to emit\r\n     * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)\r\n     */\r\n    public start(delay = this.startDelay): void {\r\n        if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {\r\n            throw \"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set\";\r\n        }\r\n        if (delay) {\r\n            setTimeout(() => {\r\n                this.start(0);\r\n            }, delay);\r\n            return;\r\n        }\r\n        // Convert the subEmitters field to the constant type field _subEmitters\r\n        this._prepareSubEmitterInternalArray();\r\n\r\n        this._started = true;\r\n        this._stopped = false;\r\n        this._actualFrame = 0;\r\n        if (this._subEmitters && this._subEmitters.length != 0) {\r\n            this.activeSubSystems = new Array<ParticleSystem>();\r\n        }\r\n\r\n        // Reset emit gradient so it acts the same on every start\r\n        if (this._emitRateGradients) {\r\n            if (this._emitRateGradients.length > 0) {\r\n                this._currentEmitRateGradient = this._emitRateGradients[0];\r\n                this._currentEmitRate1 = this._currentEmitRateGradient.getFactor();\r\n                this._currentEmitRate2 = this._currentEmitRate1;\r\n            }\r\n            if (this._emitRateGradients.length > 1) {\r\n                this._currentEmitRate2 = this._emitRateGradients[1].getFactor();\r\n            }\r\n        }\r\n        // Reset start size gradient so it acts the same on every start\r\n        if (this._startSizeGradients) {\r\n            if (this._startSizeGradients.length > 0) {\r\n                this._currentStartSizeGradient = this._startSizeGradients[0];\r\n                this._currentStartSize1 = this._currentStartSizeGradient.getFactor();\r\n                this._currentStartSize2 = this._currentStartSize1;\r\n            }\r\n            if (this._startSizeGradients.length > 1) {\r\n                this._currentStartSize2 = this._startSizeGradients[1].getFactor();\r\n            }\r\n        }\r\n\r\n        if (this.preWarmCycles) {\r\n            if (this.emitter?.getClassName().indexOf(\"Mesh\") !== -1) {\r\n                (this.emitter as any).computeWorldMatrix(true);\r\n            }\r\n\r\n            const noiseTextureAsProcedural = this.noiseTexture as ProceduralTexture;\r\n\r\n            if (noiseTextureAsProcedural && noiseTextureAsProcedural.onGeneratedObservable) {\r\n                noiseTextureAsProcedural.onGeneratedObservable.addOnce(() => {\r\n                    setTimeout(() => {\r\n                        for (let index = 0; index < this.preWarmCycles; index++) {\r\n                            this.animate(true);\r\n                            noiseTextureAsProcedural.render();\r\n                        }\r\n                    });\r\n                });\r\n            } else {\r\n                for (let index = 0; index < this.preWarmCycles; index++) {\r\n                    this.animate(true);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Animations\r\n        if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {\r\n            this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops the particle system.\r\n     * @param stopSubEmitters if true it will stop the current system and all created sub-Systems if false it will stop the current root system only, this param is used by the root particle system only. the default value is true.\r\n     */\r\n    public stop(stopSubEmitters = true): void {\r\n        if (this._stopped) {\r\n            return;\r\n        }\r\n\r\n        this.onStoppedObservable.notifyObservers(this);\r\n\r\n        this._stopped = true;\r\n\r\n        if (stopSubEmitters) {\r\n            this._stopSubEmitters();\r\n        }\r\n    }\r\n\r\n    // animation sheet\r\n\r\n    /**\r\n     * Remove all active particles\r\n     */\r\n    public reset(): void {\r\n        this._stockParticles.length = 0;\r\n        this._particles.length = 0;\r\n    }\r\n\r\n    /**\r\n     * @internal (for internal use only)\r\n     */\r\n    public _appendParticleVertex(index: number, particle: Particle, offsetX: number, offsetY: number): void {\r\n        let offset = index * this._vertexBufferSize;\r\n\r\n        this._vertexData[offset++] = particle.position.x + this.worldOffset.x;\r\n        this._vertexData[offset++] = particle.position.y + this.worldOffset.y;\r\n        this._vertexData[offset++] = particle.position.z + this.worldOffset.z;\r\n        this._vertexData[offset++] = particle.color.r;\r\n        this._vertexData[offset++] = particle.color.g;\r\n        this._vertexData[offset++] = particle.color.b;\r\n        this._vertexData[offset++] = particle.color.a;\r\n        this._vertexData[offset++] = particle.angle;\r\n\r\n        this._vertexData[offset++] = particle.scale.x * particle.size;\r\n        this._vertexData[offset++] = particle.scale.y * particle.size;\r\n\r\n        if (this._isAnimationSheetEnabled) {\r\n            this._vertexData[offset++] = particle.cellIndex;\r\n        }\r\n\r\n        if (!this._isBillboardBased) {\r\n            if (particle._initialDirection) {\r\n                let initialDirection = particle._initialDirection;\r\n                if (this.isLocal) {\r\n                    Vector3.TransformNormalToRef(initialDirection, this._emitterWorldMatrix, TmpVectors.Vector3[0]);\r\n                    initialDirection = TmpVectors.Vector3[0];\r\n                }\r\n                if (initialDirection.x === 0 && initialDirection.z === 0) {\r\n                    initialDirection.x = 0.001;\r\n                }\r\n\r\n                this._vertexData[offset++] = initialDirection.x;\r\n                this._vertexData[offset++] = initialDirection.y;\r\n                this._vertexData[offset++] = initialDirection.z;\r\n            } else {\r\n                let direction = particle.direction;\r\n                if (this.isLocal) {\r\n                    Vector3.TransformNormalToRef(direction, this._emitterWorldMatrix, TmpVectors.Vector3[0]);\r\n                    direction = TmpVectors.Vector3[0];\r\n                }\r\n\r\n                if (direction.x === 0 && direction.z === 0) {\r\n                    direction.x = 0.001;\r\n                }\r\n                this._vertexData[offset++] = direction.x;\r\n                this._vertexData[offset++] = direction.y;\r\n                this._vertexData[offset++] = direction.z;\r\n            }\r\n        } else if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {\r\n            this._vertexData[offset++] = particle.direction.x;\r\n            this._vertexData[offset++] = particle.direction.y;\r\n            this._vertexData[offset++] = particle.direction.z;\r\n        }\r\n\r\n        if (this._useRampGradients && particle.remapData) {\r\n            this._vertexData[offset++] = particle.remapData.x;\r\n            this._vertexData[offset++] = particle.remapData.y;\r\n            this._vertexData[offset++] = particle.remapData.z;\r\n            this._vertexData[offset++] = particle.remapData.w;\r\n        }\r\n\r\n        if (!this._useInstancing) {\r\n            if (this._isAnimationSheetEnabled) {\r\n                if (offsetX === 0) {\r\n                    offsetX = this._epsilon;\r\n                } else if (offsetX === 1) {\r\n                    offsetX = 1 - this._epsilon;\r\n                }\r\n\r\n                if (offsetY === 0) {\r\n                    offsetY = this._epsilon;\r\n                } else if (offsetY === 1) {\r\n                    offsetY = 1 - this._epsilon;\r\n                }\r\n            }\r\n\r\n            this._vertexData[offset++] = offsetX;\r\n            this._vertexData[offset++] = offsetY;\r\n        }\r\n    }\r\n\r\n    // start of sub system methods\r\n\r\n    /**\r\n     * \"Recycles\" one of the particle by copying it back to the \"stock\" of particles and removing it from the active list.\r\n     * Its lifetime will start back at 0.\r\n     * @param particle\r\n     */\r\n    public recycleParticle: (particle: Particle) => void = (particle) => {\r\n        // move particle from activeParticle list to stock particles\r\n        const lastParticle = <Particle>this._particles.pop();\r\n        if (lastParticle !== particle) {\r\n            lastParticle.copyTo(particle);\r\n        }\r\n        this._stockParticles.push(lastParticle);\r\n    };\r\n\r\n    private _stopSubEmitters(): void {\r\n        if (!this.activeSubSystems) {\r\n            return;\r\n        }\r\n        this.activeSubSystems.forEach((subSystem) => {\r\n            subSystem.stop(true);\r\n        });\r\n        this.activeSubSystems = new Array<ParticleSystem>();\r\n    }\r\n\r\n    private _createParticle: () => Particle = () => {\r\n        let particle: Particle;\r\n        if (this._stockParticles.length !== 0) {\r\n            particle = <Particle>this._stockParticles.pop();\r\n            particle._reset();\r\n        } else {\r\n            particle = new Particle(this);\r\n        }\r\n\r\n        // Attach emitters\r\n        if (this._subEmitters && this._subEmitters.length > 0) {\r\n            const subEmitters = this._subEmitters[Math.floor(Math.random() * this._subEmitters.length)];\r\n            particle._attachedSubEmitters = [];\r\n            subEmitters.forEach((subEmitter) => {\r\n                if (subEmitter.type === SubEmitterType.ATTACHED) {\r\n                    const newEmitter = subEmitter.clone();\r\n                    (<Array<SubEmitter>>particle._attachedSubEmitters).push(newEmitter);\r\n                    newEmitter.particleSystem.start();\r\n                }\r\n            });\r\n        }\r\n        return particle;\r\n    };\r\n\r\n    private _removeFromRoot(): void {\r\n        if (!this._rootParticleSystem) {\r\n            return;\r\n        }\r\n\r\n        const index = this._rootParticleSystem.activeSubSystems.indexOf(this);\r\n        if (index !== -1) {\r\n            this._rootParticleSystem.activeSubSystems.splice(index, 1);\r\n        }\r\n\r\n        this._rootParticleSystem = null;\r\n    }\r\n\r\n    private _emitFromParticle: (particle: Particle) => void = (particle) => {\r\n        if (!this._subEmitters || this._subEmitters.length === 0) {\r\n            return;\r\n        }\r\n        const templateIndex = Math.floor(Math.random() * this._subEmitters.length);\r\n\r\n        this._subEmitters[templateIndex].forEach((subEmitter) => {\r\n            if (subEmitter.type === SubEmitterType.END) {\r\n                const subSystem = subEmitter.clone();\r\n                particle._inheritParticleInfoToSubEmitter(subSystem);\r\n                subSystem.particleSystem._rootParticleSystem = this;\r\n                this.activeSubSystems.push(subSystem.particleSystem);\r\n                subSystem.particleSystem.start();\r\n            }\r\n        });\r\n    };\r\n\r\n    // End of sub system methods\r\n\r\n    private _update(newParticles: number): void {\r\n        // Update current\r\n        this._alive = this._particles.length > 0;\r\n\r\n        if ((<AbstractMesh>this.emitter).position) {\r\n            const emitterMesh = <AbstractMesh>this.emitter;\r\n            this._emitterWorldMatrix = emitterMesh.getWorldMatrix();\r\n        } else {\r\n            const emitterPosition = <Vector3>this.emitter;\r\n            this._emitterWorldMatrix = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);\r\n        }\r\n\r\n        this._emitterWorldMatrix.invertToRef(this._emitterInverseWorldMatrix);\r\n        this.updateFunction(this._particles);\r\n\r\n        // Add new ones\r\n        let particle: Particle;\r\n        for (let index = 0; index < newParticles; index++) {\r\n            if (this._particles.length === this._capacity) {\r\n                break;\r\n            }\r\n\r\n            particle = this._createParticle();\r\n\r\n            this._particles.push(particle);\r\n\r\n            // Life time\r\n            if (this.targetStopDuration && this._lifeTimeGradients && this._lifeTimeGradients.length > 0) {\r\n                const ratio = Scalar.Clamp(this._actualFrame / this.targetStopDuration);\r\n                GradientHelper.GetCurrentGradient(ratio, this._lifeTimeGradients, (currentGradient, nextGradient) => {\r\n                    const factorGradient1 = <FactorGradient>currentGradient;\r\n                    const factorGradient2 = <FactorGradient>nextGradient;\r\n                    const lifeTime1 = factorGradient1.getFactor();\r\n                    const lifeTime2 = factorGradient2.getFactor();\r\n                    const gradient = (ratio - factorGradient1.gradient) / (factorGradient2.gradient - factorGradient1.gradient);\r\n                    particle.lifeTime = Scalar.Lerp(lifeTime1, lifeTime2, gradient);\r\n                });\r\n            } else {\r\n                particle.lifeTime = Scalar.RandomRange(this.minLifeTime, this.maxLifeTime);\r\n            }\r\n\r\n            // Emitter\r\n            const emitPower = Scalar.RandomRange(this.minEmitPower, this.maxEmitPower);\r\n\r\n            if (this.startPositionFunction) {\r\n                this.startPositionFunction(this._emitterWorldMatrix, particle.position, particle, this.isLocal);\r\n            } else {\r\n                this.particleEmitterType.startPositionFunction(this._emitterWorldMatrix, particle.position, particle, this.isLocal);\r\n            }\r\n\r\n            if (this.isLocal) {\r\n                if (!particle._localPosition) {\r\n                    particle._localPosition = particle.position.clone();\r\n                } else {\r\n                    particle._localPosition.copyFrom(particle.position);\r\n                }\r\n                Vector3.TransformCoordinatesToRef(particle._localPosition!, this._emitterWorldMatrix, particle.position);\r\n            }\r\n\r\n            if (this.startDirectionFunction) {\r\n                this.startDirectionFunction(this._emitterWorldMatrix, particle.direction, particle, this.isLocal);\r\n            } else {\r\n                this.particleEmitterType.startDirectionFunction(this._emitterWorldMatrix, particle.direction, particle, this.isLocal, this._emitterInverseWorldMatrix);\r\n            }\r\n\r\n            if (emitPower === 0) {\r\n                if (!particle._initialDirection) {\r\n                    particle._initialDirection = particle.direction.clone();\r\n                } else {\r\n                    particle._initialDirection.copyFrom(particle.direction);\r\n                }\r\n            } else {\r\n                particle._initialDirection = null;\r\n            }\r\n\r\n            particle.direction.scaleInPlace(emitPower);\r\n\r\n            // Size\r\n            if (!this._sizeGradients || this._sizeGradients.length === 0) {\r\n                particle.size = Scalar.RandomRange(this.minSize, this.maxSize);\r\n            } else {\r\n                particle._currentSizeGradient = this._sizeGradients[0];\r\n                particle._currentSize1 = particle._currentSizeGradient.getFactor();\r\n                particle.size = particle._currentSize1;\r\n\r\n                if (this._sizeGradients.length > 1) {\r\n                    particle._currentSize2 = this._sizeGradients[1].getFactor();\r\n                } else {\r\n                    particle._currentSize2 = particle._currentSize1;\r\n                }\r\n            }\r\n            // Size and scale\r\n            particle.scale.copyFromFloats(Scalar.RandomRange(this.minScaleX, this.maxScaleX), Scalar.RandomRange(this.minScaleY, this.maxScaleY));\r\n\r\n            // Adjust scale by start size\r\n            if (this._startSizeGradients && this._startSizeGradients[0] && this.targetStopDuration) {\r\n                const ratio = this._actualFrame / this.targetStopDuration;\r\n                GradientHelper.GetCurrentGradient(ratio, this._startSizeGradients, (currentGradient, nextGradient, scale) => {\r\n                    if (currentGradient !== this._currentStartSizeGradient) {\r\n                        this._currentStartSize1 = this._currentStartSize2;\r\n                        this._currentStartSize2 = (<FactorGradient>nextGradient).getFactor();\r\n                        this._currentStartSizeGradient = <FactorGradient>currentGradient;\r\n                    }\r\n\r\n                    const value = Scalar.Lerp(this._currentStartSize1, this._currentStartSize2, scale);\r\n                    particle.scale.scaleInPlace(value);\r\n                });\r\n            }\r\n\r\n            // Angle\r\n            if (!this._angularSpeedGradients || this._angularSpeedGradients.length === 0) {\r\n                particle.angularSpeed = Scalar.RandomRange(this.minAngularSpeed, this.maxAngularSpeed);\r\n            } else {\r\n                particle._currentAngularSpeedGradient = this._angularSpeedGradients[0];\r\n                particle.angularSpeed = particle._currentAngularSpeedGradient.getFactor();\r\n                particle._currentAngularSpeed1 = particle.angularSpeed;\r\n\r\n                if (this._angularSpeedGradients.length > 1) {\r\n                    particle._currentAngularSpeed2 = this._angularSpeedGradients[1].getFactor();\r\n                } else {\r\n                    particle._currentAngularSpeed2 = particle._currentAngularSpeed1;\r\n                }\r\n            }\r\n            particle.angle = Scalar.RandomRange(this.minInitialRotation, this.maxInitialRotation);\r\n\r\n            // Velocity\r\n            if (this._velocityGradients && this._velocityGradients.length > 0) {\r\n                particle._currentVelocityGradient = this._velocityGradients[0];\r\n                particle._currentVelocity1 = particle._currentVelocityGradient.getFactor();\r\n\r\n                if (this._velocityGradients.length > 1) {\r\n                    particle._currentVelocity2 = this._velocityGradients[1].getFactor();\r\n                } else {\r\n                    particle._currentVelocity2 = particle._currentVelocity1;\r\n                }\r\n            }\r\n\r\n            // Limit velocity\r\n            if (this._limitVelocityGradients && this._limitVelocityGradients.length > 0) {\r\n                particle._currentLimitVelocityGradient = this._limitVelocityGradients[0];\r\n                particle._currentLimitVelocity1 = particle._currentLimitVelocityGradient.getFactor();\r\n\r\n                if (this._limitVelocityGradients.length > 1) {\r\n                    particle._currentLimitVelocity2 = this._limitVelocityGradients[1].getFactor();\r\n                } else {\r\n                    particle._currentLimitVelocity2 = particle._currentLimitVelocity1;\r\n                }\r\n            }\r\n\r\n            // Drag\r\n            if (this._dragGradients && this._dragGradients.length > 0) {\r\n                particle._currentDragGradient = this._dragGradients[0];\r\n                particle._currentDrag1 = particle._currentDragGradient.getFactor();\r\n\r\n                if (this._dragGradients.length > 1) {\r\n                    particle._currentDrag2 = this._dragGradients[1].getFactor();\r\n                } else {\r\n                    particle._currentDrag2 = particle._currentDrag1;\r\n                }\r\n            }\r\n\r\n            // Color\r\n            if (!this._colorGradients || this._colorGradients.length === 0) {\r\n                const step = Scalar.RandomRange(0, 1.0);\r\n\r\n                Color4.LerpToRef(this.color1, this.color2, step, particle.color);\r\n\r\n                this.colorDead.subtractToRef(particle.color, this._colorDiff);\r\n                this._colorDiff.scaleToRef(1.0 / particle.lifeTime, particle.colorStep);\r\n            } else {\r\n                particle._currentColorGradient = this._colorGradients[0];\r\n                particle._currentColorGradient.getColorToRef(particle.color);\r\n                particle._currentColor1.copyFrom(particle.color);\r\n\r\n                if (this._colorGradients.length > 1) {\r\n                    this._colorGradients[1].getColorToRef(particle._currentColor2);\r\n                } else {\r\n                    particle._currentColor2.copyFrom(particle.color);\r\n                }\r\n            }\r\n\r\n            // Sheet\r\n            if (this._isAnimationSheetEnabled) {\r\n                particle._initialStartSpriteCellID = this.startSpriteCellID;\r\n                particle._initialEndSpriteCellID = this.endSpriteCellID;\r\n                particle._initialSpriteCellLoop = this.spriteCellLoop;\r\n            }\r\n\r\n            // Inherited Velocity\r\n            particle.direction.addInPlace(this._inheritedVelocityOffset);\r\n\r\n            // Ramp\r\n            if (this._useRampGradients) {\r\n                particle.remapData = new Vector4(0, 1, 0, 1);\r\n            }\r\n\r\n            // Noise texture coordinates\r\n            if (this.noiseTexture) {\r\n                if (particle._randomNoiseCoordinates1) {\r\n                    particle._randomNoiseCoordinates1.copyFromFloats(Math.random(), Math.random(), Math.random());\r\n                    particle._randomNoiseCoordinates2.copyFromFloats(Math.random(), Math.random(), Math.random());\r\n                } else {\r\n                    particle._randomNoiseCoordinates1 = new Vector3(Math.random(), Math.random(), Math.random());\r\n                    particle._randomNoiseCoordinates2 = new Vector3(Math.random(), Math.random(), Math.random());\r\n                }\r\n            }\r\n\r\n            // Update the position of the attached sub-emitters to match their attached particle\r\n            particle._inheritParticleInfoToSubEmitters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _GetAttributeNamesOrOptions(isAnimationSheetEnabled = false, isBillboardBased = false, useRampGradients = false): string[] {\r\n        const attributeNamesOrOptions = [VertexBuffer.PositionKind, VertexBuffer.ColorKind, \"angle\", \"offset\", \"size\"];\r\n\r\n        if (isAnimationSheetEnabled) {\r\n            attributeNamesOrOptions.push(\"cellIndex\");\r\n        }\r\n\r\n        if (!isBillboardBased) {\r\n            attributeNamesOrOptions.push(\"direction\");\r\n        }\r\n\r\n        if (useRampGradients) {\r\n            attributeNamesOrOptions.push(\"remapData\");\r\n        }\r\n\r\n        return attributeNamesOrOptions;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _GetEffectCreationOptions(isAnimationSheetEnabled = false, useLogarithmicDepth = false): string[] {\r\n        const effectCreationOption = [\"invView\", \"view\", \"projection\", \"textureMask\", \"translationPivot\", \"eyePosition\"];\r\n\r\n        addClipPlaneUniforms(effectCreationOption);\r\n\r\n        if (isAnimationSheetEnabled) {\r\n            effectCreationOption.push(\"particlesInfos\");\r\n        }\r\n        if (useLogarithmicDepth) {\r\n            effectCreationOption.push(\"logarithmicDepthConstant\");\r\n        }\r\n\r\n        return effectCreationOption;\r\n    }\r\n\r\n    /**\r\n     * Fill the defines array according to the current settings of the particle system\r\n     * @param defines Array to be updated\r\n     * @param blendMode blend mode to take into account when updating the array\r\n     */\r\n    public fillDefines(defines: Array<string>, blendMode: number) {\r\n        if (this._scene) {\r\n            prepareStringDefinesForClipPlanes(this, this._scene, defines);\r\n        }\r\n\r\n        if (this._isAnimationSheetEnabled) {\r\n            defines.push(\"#define ANIMATESHEET\");\r\n        }\r\n\r\n        if (this.useLogarithmicDepth) {\r\n            defines.push(\"#define LOGARITHMICDEPTH\");\r\n        }\r\n\r\n        if (blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {\r\n            defines.push(\"#define BLENDMULTIPLYMODE\");\r\n        }\r\n\r\n        if (this._useRampGradients) {\r\n            defines.push(\"#define RAMPGRADIENT\");\r\n        }\r\n\r\n        if (this._isBillboardBased) {\r\n            defines.push(\"#define BILLBOARD\");\r\n\r\n            switch (this.billboardMode) {\r\n                case ParticleSystem.BILLBOARDMODE_Y:\r\n                    defines.push(\"#define BILLBOARDY\");\r\n                    break;\r\n                case ParticleSystem.BILLBOARDMODE_STRETCHED:\r\n                case ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL:\r\n                    defines.push(\"#define BILLBOARDSTRETCHED\");\r\n                    if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {\r\n                        defines.push(\"#define BILLBOARDSTRETCHED_LOCAL\");\r\n                    }\r\n                    break;\r\n                case ParticleSystem.BILLBOARDMODE_ALL:\r\n                    defines.push(\"#define BILLBOARDMODE_ALL\");\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);\r\n            defines.push(this._imageProcessingConfigurationDefines.toString());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system\r\n     * @param uniforms Uniforms array to fill\r\n     * @param attributes Attributes array to fill\r\n     * @param samplers Samplers array to fill\r\n     */\r\n    public fillUniformsAttributesAndSamplerNames(uniforms: Array<string>, attributes: Array<string>, samplers: Array<string>) {\r\n        attributes.push(\r\n            ...ParticleSystem._GetAttributeNamesOrOptions(\r\n                this._isAnimationSheetEnabled,\r\n                this._isBillboardBased && this.billboardMode !== ParticleSystem.BILLBOARDMODE_STRETCHED && this.billboardMode !== ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL,\r\n                this._useRampGradients\r\n            )\r\n        );\r\n\r\n        uniforms.push(...ParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled, this.useLogarithmicDepth));\r\n\r\n        samplers.push(\"diffuseSampler\", \"rampSampler\");\r\n\r\n        if (this._imageProcessingConfiguration) {\r\n            ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);\r\n            ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _getWrapper(blendMode: number): DrawWrapper {\r\n        const customWrapper = this._getCustomDrawWrapper(blendMode);\r\n\r\n        if (customWrapper?.effect) {\r\n            return customWrapper;\r\n        }\r\n\r\n        const defines: Array<string> = [];\r\n\r\n        this.fillDefines(defines, blendMode);\r\n\r\n        // Effect\r\n        const currentRenderPassId = this._engine._features.supportRenderPasses ? (this._engine as Engine).currentRenderPassId : Constants.RENDERPASS_MAIN;\r\n        let drawWrappers = this._drawWrappers[currentRenderPassId];\r\n        if (!drawWrappers) {\r\n            drawWrappers = this._drawWrappers[currentRenderPassId] = [];\r\n        }\r\n        let drawWrapper = drawWrappers[blendMode];\r\n        if (!drawWrapper) {\r\n            drawWrapper = new DrawWrapper(this._engine);\r\n            if (drawWrapper.drawContext) {\r\n                drawWrapper.drawContext.useInstancing = this._useInstancing;\r\n            }\r\n            drawWrappers[blendMode] = drawWrapper;\r\n        }\r\n\r\n        const join = defines.join(\"\\n\");\r\n        if (drawWrapper.defines !== join) {\r\n            const attributesNamesOrOptions: Array<string> = [];\r\n            const effectCreationOption: Array<string> = [];\r\n            const samplers: Array<string> = [];\r\n\r\n            this.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, samplers);\r\n\r\n            drawWrapper.setEffect(this._engine.createEffect(\"particles\", attributesNamesOrOptions, effectCreationOption, samplers, join), join);\r\n        }\r\n\r\n        return drawWrapper;\r\n    }\r\n\r\n    /**\r\n     * Animates the particle system for the current frame by emitting new particles and or animating the living ones.\r\n     * @param preWarmOnly will prevent the system from updating the vertex buffer (default is false)\r\n     */\r\n    public animate(preWarmOnly = false): void {\r\n        if (!this._started) {\r\n            return;\r\n        }\r\n\r\n        if (!preWarmOnly && this._scene) {\r\n            // Check\r\n            if (!this.isReady()) {\r\n                return;\r\n            }\r\n\r\n            if (this._currentRenderId === this._scene.getFrameId()) {\r\n                return;\r\n            }\r\n            this._currentRenderId = this._scene.getFrameId();\r\n        }\r\n\r\n        this._scaledUpdateSpeed = this.updateSpeed * (preWarmOnly ? this.preWarmStepOffset : this._scene?.getAnimationRatio() || 1);\r\n\r\n        // Determine the number of particles we need to create\r\n        let newParticles;\r\n\r\n        if (this.manualEmitCount > -1) {\r\n            newParticles = this.manualEmitCount;\r\n            this._newPartsExcess = 0;\r\n            this.manualEmitCount = 0;\r\n        } else {\r\n            let rate = this.emitRate;\r\n\r\n            if (this._emitRateGradients && this._emitRateGradients.length > 0 && this.targetStopDuration) {\r\n                const ratio = this._actualFrame / this.targetStopDuration;\r\n                GradientHelper.GetCurrentGradient(ratio, this._emitRateGradients, (currentGradient, nextGradient, scale) => {\r\n                    if (currentGradient !== this._currentEmitRateGradient) {\r\n                        this._currentEmitRate1 = this._currentEmitRate2;\r\n                        this._currentEmitRate2 = (<FactorGradient>nextGradient).getFactor();\r\n                        this._currentEmitRateGradient = <FactorGradient>currentGradient;\r\n                    }\r\n\r\n                    rate = Scalar.Lerp(this._currentEmitRate1, this._currentEmitRate2, scale);\r\n                });\r\n            }\r\n\r\n            newParticles = (rate * this._scaledUpdateSpeed) >> 0;\r\n            this._newPartsExcess += rate * this._scaledUpdateSpeed - newParticles;\r\n        }\r\n\r\n        if (this._newPartsExcess > 1.0) {\r\n            newParticles += this._newPartsExcess >> 0;\r\n            this._newPartsExcess -= this._newPartsExcess >> 0;\r\n        }\r\n\r\n        this._alive = false;\r\n\r\n        if (!this._stopped) {\r\n            this._actualFrame += this._scaledUpdateSpeed;\r\n\r\n            if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {\r\n                this.stop();\r\n            }\r\n        } else {\r\n            newParticles = 0;\r\n        }\r\n        this._update(newParticles);\r\n\r\n        // Stopped?\r\n        if (this._stopped) {\r\n            if (!this._alive) {\r\n                this._started = false;\r\n                if (this.onAnimationEnd) {\r\n                    this.onAnimationEnd();\r\n                }\r\n                if (this.disposeOnStop && this._scene) {\r\n                    this._scene._toBeDisposed.push(this);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!preWarmOnly) {\r\n            // Update VBO\r\n            let offset = 0;\r\n            for (let index = 0; index < this._particles.length; index++) {\r\n                const particle = this._particles[index];\r\n                this._appendParticleVertices(offset, particle);\r\n                offset += this._useInstancing ? 1 : 4;\r\n            }\r\n\r\n            if (this._vertexBuffer) {\r\n                this._vertexBuffer.updateDirectly(this._vertexData, 0, this._particles.length);\r\n            }\r\n        }\r\n\r\n        if (this.manualEmitCount === 0 && this.disposeOnStop) {\r\n            this.stop();\r\n        }\r\n    }\r\n\r\n    private _appendParticleVertices(offset: number, particle: Particle) {\r\n        this._appendParticleVertex(offset++, particle, 0, 0);\r\n        if (!this._useInstancing) {\r\n            this._appendParticleVertex(offset++, particle, 1, 0);\r\n            this._appendParticleVertex(offset++, particle, 1, 1);\r\n            this._appendParticleVertex(offset++, particle, 0, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the particle system.\r\n     */\r\n    public rebuild(): void {\r\n        if (this._engine.getCaps().vertexArrayObject) {\r\n            this._vertexArrayObject = null;\r\n        }\r\n\r\n        this._createIndexBuffer();\r\n\r\n        this._spriteBuffer?._rebuild();\r\n\r\n        this._vertexBuffer?._rebuild();\r\n\r\n        for (const key in this._vertexBuffers) {\r\n            this._vertexBuffers[key]._rebuild();\r\n        }\r\n\r\n        this.resetDrawCache();\r\n    }\r\n\r\n    /**\r\n     * Is this system ready to be used/rendered\r\n     * @returns true if the system is ready\r\n     */\r\n    public isReady(): boolean {\r\n        if (!this.emitter || (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady()) || !this.particleTexture || !this.particleTexture.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        if (this.blendMode !== ParticleSystem.BLENDMODE_MULTIPLYADD) {\r\n            if (!this._getWrapper(this.blendMode).effect!.isReady()) {\r\n                return false;\r\n            }\r\n        } else {\r\n            if (!this._getWrapper(ParticleSystem.BLENDMODE_MULTIPLY).effect!.isReady()) {\r\n                return false;\r\n            }\r\n            if (!this._getWrapper(ParticleSystem.BLENDMODE_ADD).effect!.isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _render(blendMode: number) {\r\n        const drawWrapper = this._getWrapper(blendMode);\r\n        const effect = drawWrapper.effect!;\r\n\r\n        const engine = this._engine;\r\n\r\n        // Render\r\n        engine.enableEffect(drawWrapper);\r\n\r\n        const viewMatrix = this.defaultViewMatrix ?? this._scene!.getViewMatrix();\r\n        effect.setTexture(\"diffuseSampler\", this.particleTexture);\r\n        effect.setMatrix(\"view\", viewMatrix);\r\n        effect.setMatrix(\"projection\", this.defaultProjectionMatrix ?? this._scene!.getProjectionMatrix());\r\n\r\n        if (this._isAnimationSheetEnabled && this.particleTexture) {\r\n            const baseSize = this.particleTexture.getBaseSize();\r\n            effect.setFloat3(\"particlesInfos\", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, this.spriteCellWidth / baseSize.width);\r\n        }\r\n\r\n        effect.setVector2(\"translationPivot\", this.translationPivot);\r\n        effect.setFloat4(\"textureMask\", this.textureMask.r, this.textureMask.g, this.textureMask.b, this.textureMask.a);\r\n\r\n        if (this._isBillboardBased && this._scene) {\r\n            const camera = this._scene.activeCamera!;\r\n            effect.setVector3(\"eyePosition\", camera.globalPosition);\r\n        }\r\n\r\n        if (this._rampGradientsTexture) {\r\n            if (!this._rampGradients || !this._rampGradients.length) {\r\n                this._rampGradientsTexture.dispose();\r\n                this._rampGradientsTexture = null;\r\n            }\r\n            effect.setTexture(\"rampSampler\", this._rampGradientsTexture);\r\n        }\r\n\r\n        const defines = effect.defines;\r\n\r\n        if (this._scene) {\r\n            bindClipPlane(effect, this, this._scene);\r\n        }\r\n\r\n        if (defines.indexOf(\"#define BILLBOARDMODE_ALL\") >= 0) {\r\n            viewMatrix.invertToRef(TmpVectors.Matrix[0]);\r\n            effect.setMatrix(\"invView\", TmpVectors.Matrix[0]);\r\n        }\r\n\r\n        if (this._vertexArrayObject !== undefined) {\r\n            if (this._scene?.forceWireframe) {\r\n                engine.bindBuffers(this._vertexBuffers, this._linesIndexBufferUseInstancing, effect);\r\n            } else {\r\n                if (!this._vertexArrayObject) {\r\n                    this._vertexArrayObject = this._engine.recordVertexArrayObject(this._vertexBuffers, null, effect);\r\n                }\r\n\r\n                this._engine.bindVertexArrayObject(this._vertexArrayObject, this._scene?.forceWireframe ? this._linesIndexBufferUseInstancing : this._indexBuffer);\r\n            }\r\n        } else {\r\n            if (!this._indexBuffer) {\r\n                // Use instancing mode\r\n                engine.bindBuffers(this._vertexBuffers, this._scene?.forceWireframe ? this._linesIndexBufferUseInstancing : null, effect);\r\n            } else {\r\n                engine.bindBuffers(this._vertexBuffers, this._scene?.forceWireframe ? this._linesIndexBuffer : this._indexBuffer, effect);\r\n            }\r\n        }\r\n\r\n        // Log. depth\r\n        if (this.useLogarithmicDepth && this._scene) {\r\n            MaterialHelper.BindLogDepth(defines, effect, this._scene);\r\n        }\r\n\r\n        // image processing\r\n        if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\r\n            this._imageProcessingConfiguration.bind(effect);\r\n        }\r\n\r\n        // Draw order\r\n        switch (blendMode) {\r\n            case ParticleSystem.BLENDMODE_ADD:\r\n                engine.setAlphaMode(Constants.ALPHA_ADD);\r\n                break;\r\n            case ParticleSystem.BLENDMODE_ONEONE:\r\n                engine.setAlphaMode(Constants.ALPHA_ONEONE);\r\n                break;\r\n            case ParticleSystem.BLENDMODE_STANDARD:\r\n                engine.setAlphaMode(Constants.ALPHA_COMBINE);\r\n                break;\r\n            case ParticleSystem.BLENDMODE_MULTIPLY:\r\n                engine.setAlphaMode(Constants.ALPHA_MULTIPLY);\r\n                break;\r\n        }\r\n\r\n        if (this._onBeforeDrawParticlesObservable) {\r\n            this._onBeforeDrawParticlesObservable.notifyObservers(effect);\r\n        }\r\n\r\n        if (this._useInstancing) {\r\n            if (this._scene?.forceWireframe) {\r\n                engine.drawElementsType(Constants.MATERIAL_LineStripDrawMode, 0, 10, this._particles.length);\r\n            } else {\r\n                engine.drawArraysType(Constants.MATERIAL_TriangleStripDrawMode, 0, 4, this._particles.length);\r\n            }\r\n        } else {\r\n            if (this._scene?.forceWireframe) {\r\n                engine.drawElementsType(Constants.MATERIAL_WireFrameFillMode, 0, this._particles.length * 10);\r\n            } else {\r\n                engine.drawElementsType(Constants.MATERIAL_TriangleFillMode, 0, this._particles.length * 6);\r\n            }\r\n        }\r\n\r\n        return this._particles.length;\r\n    }\r\n\r\n    /**\r\n     * Renders the particle system in its current state.\r\n     * @returns the current number of particles\r\n     */\r\n    public render(): number {\r\n        // Check\r\n        if (!this.isReady() || !this._particles.length) {\r\n            return 0;\r\n        }\r\n\r\n        const engine = this._engine as any;\r\n        if (engine.setState) {\r\n            engine.setState(false);\r\n\r\n            if (this.forceDepthWrite) {\r\n                engine.setDepthWrite(true);\r\n            }\r\n        }\r\n\r\n        let outparticles = 0;\r\n\r\n        if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLYADD) {\r\n            outparticles = this._render(ParticleSystem.BLENDMODE_MULTIPLY) + this._render(ParticleSystem.BLENDMODE_ADD);\r\n        } else {\r\n            outparticles = this._render(this.blendMode);\r\n        }\r\n\r\n        this._engine.unbindInstanceAttributes();\r\n        this._engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n\r\n        return outparticles;\r\n    }\r\n\r\n    /**\r\n     * Disposes the particle system and free the associated resources\r\n     * @param disposeTexture defines if the particle texture must be disposed as well (true by default)\r\n     */\r\n    public dispose(disposeTexture = true): void {\r\n        this.resetDrawCache();\r\n\r\n        if (this._vertexBuffer) {\r\n            this._vertexBuffer.dispose();\r\n            this._vertexBuffer = null;\r\n        }\r\n\r\n        if (this._spriteBuffer) {\r\n            this._spriteBuffer.dispose();\r\n            this._spriteBuffer = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._engine._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        if (this._linesIndexBuffer) {\r\n            this._engine._releaseBuffer(this._linesIndexBuffer);\r\n            this._linesIndexBuffer = null;\r\n        }\r\n\r\n        if (this._linesIndexBufferUseInstancing) {\r\n            this._engine._releaseBuffer(this._linesIndexBufferUseInstancing);\r\n            this._linesIndexBufferUseInstancing = null;\r\n        }\r\n\r\n        if (this._vertexArrayObject) {\r\n            this._engine.releaseVertexArrayObject(this._vertexArrayObject);\r\n            this._vertexArrayObject = null;\r\n        }\r\n\r\n        if (disposeTexture && this.particleTexture) {\r\n            this.particleTexture.dispose();\r\n            this.particleTexture = null;\r\n        }\r\n\r\n        if (disposeTexture && this.noiseTexture) {\r\n            this.noiseTexture.dispose();\r\n            this.noiseTexture = null;\r\n        }\r\n\r\n        if (this._rampGradientsTexture) {\r\n            this._rampGradientsTexture.dispose();\r\n            this._rampGradientsTexture = null;\r\n        }\r\n\r\n        this._removeFromRoot();\r\n\r\n        if (this.subEmitters && !this._subEmitters) {\r\n            this._prepareSubEmitterInternalArray();\r\n        }\r\n\r\n        if (this._subEmitters && this._subEmitters.length) {\r\n            for (let index = 0; index < this._subEmitters.length; index++) {\r\n                for (const subEmitter of this._subEmitters[index]) {\r\n                    subEmitter.dispose();\r\n                }\r\n            }\r\n\r\n            this._subEmitters = [];\r\n            this.subEmitters = [];\r\n        }\r\n\r\n        if (this._disposeEmitterOnDispose && this.emitter && (this.emitter as AbstractMesh).dispose) {\r\n            (<AbstractMesh>this.emitter).dispose(true);\r\n        }\r\n\r\n        if (this._onBeforeDrawParticlesObservable) {\r\n            this._onBeforeDrawParticlesObservable.clear();\r\n        }\r\n\r\n        // Remove from scene\r\n        if (this._scene) {\r\n            const index = this._scene.particleSystems.indexOf(this);\r\n            if (index > -1) {\r\n                this._scene.particleSystems.splice(index, 1);\r\n            }\r\n\r\n            this._scene._activeParticleSystems.dispose();\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n        this.onStoppedObservable.clear();\r\n\r\n        this.reset();\r\n    }\r\n\r\n    // Clone\r\n    /**\r\n     * Clones the particle system.\r\n     * @param name The name of the cloned object\r\n     * @param newEmitter The new emitter to use\r\n     * @param cloneTexture Also clone the textures if true\r\n     * @returns the cloned particle system\r\n     */\r\n    public clone(name: string, newEmitter: any, cloneTexture = false): ParticleSystem {\r\n        const custom = { ...this._customWrappers };\r\n        let program: any = null;\r\n        const engine = this._engine as Engine;\r\n        if (engine.createEffectForParticles) {\r\n            if (this.customShader != null) {\r\n                program = this.customShader;\r\n                const defines: string = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\r\n                const effect = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\r\n                if (!custom[0]) {\r\n                    this.setCustomEffect(effect, 0);\r\n                } else {\r\n                    custom[0].effect = effect;\r\n                }\r\n            }\r\n        }\r\n\r\n        const serialization = this.serialize(cloneTexture);\r\n        const result = ParticleSystem.Parse(serialization, this._scene || this._engine, this._rootUrl);\r\n        result.name = name;\r\n        result.customShader = program;\r\n        result._customWrappers = custom;\r\n\r\n        if (newEmitter === undefined) {\r\n            newEmitter = this.emitter;\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            result.noiseTexture = this.noiseTexture.clone();\r\n        }\r\n\r\n        result.emitter = newEmitter;\r\n        if (!this.preventAutoStart) {\r\n            result.start();\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object\r\n     * @param serializeTexture defines if the texture must be serialized as well\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(serializeTexture = false): any {\r\n        const serializationObject: any = {};\r\n\r\n        ParticleSystem._Serialize(serializationObject, this, serializeTexture);\r\n\r\n        serializationObject.textureMask = this.textureMask.asArray();\r\n        serializationObject.customShader = this.customShader;\r\n        serializationObject.preventAutoStart = this.preventAutoStart;\r\n\r\n        // SubEmitters\r\n        if (this.subEmitters) {\r\n            serializationObject.subEmitters = [];\r\n\r\n            if (!this._subEmitters) {\r\n                this._prepareSubEmitterInternalArray();\r\n            }\r\n\r\n            for (const subs of this._subEmitters) {\r\n                const cell = [];\r\n                for (const sub of subs) {\r\n                    cell.push(sub.serialize(serializeTexture));\r\n                }\r\n\r\n                serializationObject.subEmitters.push(cell);\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _Serialize(serializationObject: any, particleSystem: IParticleSystem, serializeTexture: boolean) {\r\n        serializationObject.name = particleSystem.name;\r\n        serializationObject.id = particleSystem.id;\r\n\r\n        serializationObject.capacity = particleSystem.getCapacity();\r\n\r\n        serializationObject.disposeOnStop = particleSystem.disposeOnStop;\r\n        serializationObject.manualEmitCount = particleSystem.manualEmitCount;\r\n\r\n        // Emitter\r\n        if ((<AbstractMesh>particleSystem.emitter).position) {\r\n            const emitterMesh = <AbstractMesh>particleSystem.emitter;\r\n            serializationObject.emitterId = emitterMesh.id;\r\n        } else {\r\n            const emitterPosition = <Vector3>particleSystem.emitter;\r\n            serializationObject.emitter = emitterPosition.asArray();\r\n        }\r\n\r\n        // Emitter\r\n        if (particleSystem.particleEmitterType) {\r\n            serializationObject.particleEmitterType = particleSystem.particleEmitterType.serialize();\r\n        }\r\n\r\n        if (particleSystem.particleTexture) {\r\n            if (serializeTexture) {\r\n                serializationObject.texture = particleSystem.particleTexture.serialize();\r\n            } else {\r\n                serializationObject.textureName = particleSystem.particleTexture.name;\r\n                serializationObject.invertY = !!(particleSystem.particleTexture as any)._invertY;\r\n            }\r\n        }\r\n\r\n        serializationObject.isLocal = particleSystem.isLocal;\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(particleSystem, serializationObject);\r\n        serializationObject.beginAnimationOnStart = particleSystem.beginAnimationOnStart;\r\n        serializationObject.beginAnimationFrom = particleSystem.beginAnimationFrom;\r\n        serializationObject.beginAnimationTo = particleSystem.beginAnimationTo;\r\n        serializationObject.beginAnimationLoop = particleSystem.beginAnimationLoop;\r\n\r\n        // Particle system\r\n        serializationObject.startDelay = particleSystem.startDelay;\r\n        serializationObject.renderingGroupId = particleSystem.renderingGroupId;\r\n        serializationObject.isBillboardBased = particleSystem.isBillboardBased;\r\n        serializationObject.billboardMode = particleSystem.billboardMode;\r\n        serializationObject.minAngularSpeed = particleSystem.minAngularSpeed;\r\n        serializationObject.maxAngularSpeed = particleSystem.maxAngularSpeed;\r\n        serializationObject.minSize = particleSystem.minSize;\r\n        serializationObject.maxSize = particleSystem.maxSize;\r\n        serializationObject.minScaleX = particleSystem.minScaleX;\r\n        serializationObject.maxScaleX = particleSystem.maxScaleX;\r\n        serializationObject.minScaleY = particleSystem.minScaleY;\r\n        serializationObject.maxScaleY = particleSystem.maxScaleY;\r\n        serializationObject.minEmitPower = particleSystem.minEmitPower;\r\n        serializationObject.maxEmitPower = particleSystem.maxEmitPower;\r\n        serializationObject.minLifeTime = particleSystem.minLifeTime;\r\n        serializationObject.maxLifeTime = particleSystem.maxLifeTime;\r\n        serializationObject.emitRate = particleSystem.emitRate;\r\n        serializationObject.gravity = particleSystem.gravity.asArray();\r\n        serializationObject.noiseStrength = particleSystem.noiseStrength.asArray();\r\n        serializationObject.color1 = particleSystem.color1.asArray();\r\n        serializationObject.color2 = particleSystem.color2.asArray();\r\n        serializationObject.colorDead = particleSystem.colorDead.asArray();\r\n        serializationObject.updateSpeed = particleSystem.updateSpeed;\r\n        serializationObject.targetStopDuration = particleSystem.targetStopDuration;\r\n        serializationObject.blendMode = particleSystem.blendMode;\r\n        serializationObject.preWarmCycles = particleSystem.preWarmCycles;\r\n        serializationObject.preWarmStepOffset = particleSystem.preWarmStepOffset;\r\n        serializationObject.minInitialRotation = particleSystem.minInitialRotation;\r\n        serializationObject.maxInitialRotation = particleSystem.maxInitialRotation;\r\n        serializationObject.startSpriteCellID = particleSystem.startSpriteCellID;\r\n        serializationObject.spriteCellLoop = particleSystem.spriteCellLoop;\r\n        serializationObject.endSpriteCellID = particleSystem.endSpriteCellID;\r\n        serializationObject.spriteCellChangeSpeed = particleSystem.spriteCellChangeSpeed;\r\n        serializationObject.spriteCellWidth = particleSystem.spriteCellWidth;\r\n        serializationObject.spriteCellHeight = particleSystem.spriteCellHeight;\r\n        serializationObject.spriteRandomStartCell = particleSystem.spriteRandomStartCell;\r\n        serializationObject.isAnimationSheetEnabled = particleSystem.isAnimationSheetEnabled;\r\n        serializationObject.useLogarithmicDepth = particleSystem.useLogarithmicDepth;\r\n\r\n        const colorGradients = particleSystem.getColorGradients();\r\n        if (colorGradients) {\r\n            serializationObject.colorGradients = [];\r\n            for (const colorGradient of colorGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: colorGradient.gradient,\r\n                    color1: colorGradient.color1.asArray(),\r\n                };\r\n\r\n                if (colorGradient.color2) {\r\n                    serializedGradient.color2 = colorGradient.color2.asArray();\r\n                } else {\r\n                    serializedGradient.color2 = colorGradient.color1.asArray();\r\n                }\r\n\r\n                serializationObject.colorGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const rampGradients = particleSystem.getRampGradients();\r\n        if (rampGradients) {\r\n            serializationObject.rampGradients = [];\r\n            for (const rampGradient of rampGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: rampGradient.gradient,\r\n                    color: rampGradient.color.asArray(),\r\n                };\r\n\r\n                serializationObject.rampGradients.push(serializedGradient);\r\n            }\r\n            serializationObject.useRampGradients = particleSystem.useRampGradients;\r\n        }\r\n\r\n        const colorRemapGradients = particleSystem.getColorRemapGradients();\r\n        if (colorRemapGradients) {\r\n            serializationObject.colorRemapGradients = [];\r\n            for (const colorRemapGradient of colorRemapGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: colorRemapGradient.gradient,\r\n                    factor1: colorRemapGradient.factor1,\r\n                };\r\n\r\n                if (colorRemapGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = colorRemapGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = colorRemapGradient.factor1;\r\n                }\r\n\r\n                serializationObject.colorRemapGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const alphaRemapGradients = particleSystem.getAlphaRemapGradients();\r\n        if (alphaRemapGradients) {\r\n            serializationObject.alphaRemapGradients = [];\r\n            for (const alphaRemapGradient of alphaRemapGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: alphaRemapGradient.gradient,\r\n                    factor1: alphaRemapGradient.factor1,\r\n                };\r\n\r\n                if (alphaRemapGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = alphaRemapGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = alphaRemapGradient.factor1;\r\n                }\r\n\r\n                serializationObject.alphaRemapGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const sizeGradients = particleSystem.getSizeGradients();\r\n        if (sizeGradients) {\r\n            serializationObject.sizeGradients = [];\r\n            for (const sizeGradient of sizeGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: sizeGradient.gradient,\r\n                    factor1: sizeGradient.factor1,\r\n                };\r\n\r\n                if (sizeGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = sizeGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = sizeGradient.factor1;\r\n                }\r\n\r\n                serializationObject.sizeGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const angularSpeedGradients = particleSystem.getAngularSpeedGradients();\r\n        if (angularSpeedGradients) {\r\n            serializationObject.angularSpeedGradients = [];\r\n            for (const angularSpeedGradient of angularSpeedGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: angularSpeedGradient.gradient,\r\n                    factor1: angularSpeedGradient.factor1,\r\n                };\r\n\r\n                if (angularSpeedGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = angularSpeedGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = angularSpeedGradient.factor1;\r\n                }\r\n\r\n                serializationObject.angularSpeedGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const velocityGradients = particleSystem.getVelocityGradients();\r\n        if (velocityGradients) {\r\n            serializationObject.velocityGradients = [];\r\n            for (const velocityGradient of velocityGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: velocityGradient.gradient,\r\n                    factor1: velocityGradient.factor1,\r\n                };\r\n\r\n                if (velocityGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = velocityGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = velocityGradient.factor1;\r\n                }\r\n\r\n                serializationObject.velocityGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const dragGradients = particleSystem.getDragGradients();\r\n        if (dragGradients) {\r\n            serializationObject.dragGradients = [];\r\n            for (const dragGradient of dragGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: dragGradient.gradient,\r\n                    factor1: dragGradient.factor1,\r\n                };\r\n\r\n                if (dragGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = dragGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = dragGradient.factor1;\r\n                }\r\n\r\n                serializationObject.dragGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const emitRateGradients = particleSystem.getEmitRateGradients();\r\n        if (emitRateGradients) {\r\n            serializationObject.emitRateGradients = [];\r\n            for (const emitRateGradient of emitRateGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: emitRateGradient.gradient,\r\n                    factor1: emitRateGradient.factor1,\r\n                };\r\n\r\n                if (emitRateGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = emitRateGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = emitRateGradient.factor1;\r\n                }\r\n\r\n                serializationObject.emitRateGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const startSizeGradients = particleSystem.getStartSizeGradients();\r\n        if (startSizeGradients) {\r\n            serializationObject.startSizeGradients = [];\r\n            for (const startSizeGradient of startSizeGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: startSizeGradient.gradient,\r\n                    factor1: startSizeGradient.factor1,\r\n                };\r\n\r\n                if (startSizeGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = startSizeGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = startSizeGradient.factor1;\r\n                }\r\n\r\n                serializationObject.startSizeGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const lifeTimeGradients = particleSystem.getLifeTimeGradients();\r\n        if (lifeTimeGradients) {\r\n            serializationObject.lifeTimeGradients = [];\r\n            for (const lifeTimeGradient of lifeTimeGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: lifeTimeGradient.gradient,\r\n                    factor1: lifeTimeGradient.factor1,\r\n                };\r\n\r\n                if (lifeTimeGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = lifeTimeGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = lifeTimeGradient.factor1;\r\n                }\r\n\r\n                serializationObject.lifeTimeGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const limitVelocityGradients = particleSystem.getLimitVelocityGradients();\r\n        if (limitVelocityGradients) {\r\n            serializationObject.limitVelocityGradients = [];\r\n            for (const limitVelocityGradient of limitVelocityGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: limitVelocityGradient.gradient,\r\n                    factor1: limitVelocityGradient.factor1,\r\n                };\r\n\r\n                if (limitVelocityGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = limitVelocityGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = limitVelocityGradient.factor1;\r\n                }\r\n\r\n                serializationObject.limitVelocityGradients.push(serializedGradient);\r\n            }\r\n\r\n            serializationObject.limitVelocityDamping = particleSystem.limitVelocityDamping;\r\n        }\r\n\r\n        if (particleSystem.noiseTexture) {\r\n            serializationObject.noiseTexture = particleSystem.noiseTexture.serialize();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _Parse(parsedParticleSystem: any, particleSystem: IParticleSystem, sceneOrEngine: Scene | ThinEngine, rootUrl: string) {\r\n        let scene: Nullable<Scene>;\r\n\r\n        if (sceneOrEngine instanceof ThinEngine) {\r\n            scene = null;\r\n        } else {\r\n            scene = sceneOrEngine as Scene;\r\n        }\r\n\r\n        const internalClass = GetClass(\"BABYLON.Texture\");\r\n        if (internalClass && scene) {\r\n            // Texture\r\n            if (parsedParticleSystem.texture) {\r\n                particleSystem.particleTexture = internalClass.Parse(parsedParticleSystem.texture, scene, rootUrl) as BaseTexture;\r\n            } else if (parsedParticleSystem.textureName) {\r\n                particleSystem.particleTexture = new internalClass(\r\n                    rootUrl + parsedParticleSystem.textureName,\r\n                    scene,\r\n                    false,\r\n                    parsedParticleSystem.invertY !== undefined ? parsedParticleSystem.invertY : true\r\n                );\r\n                particleSystem.particleTexture!.name = parsedParticleSystem.textureName;\r\n            }\r\n        }\r\n\r\n        // Emitter\r\n        if (!parsedParticleSystem.emitterId && parsedParticleSystem.emitterId !== 0 && parsedParticleSystem.emitter === undefined) {\r\n            particleSystem.emitter = Vector3.Zero();\r\n        } else if (parsedParticleSystem.emitterId && scene) {\r\n            particleSystem.emitter = scene.getLastMeshById(parsedParticleSystem.emitterId);\r\n        } else {\r\n            particleSystem.emitter = Vector3.FromArray(parsedParticleSystem.emitter);\r\n        }\r\n\r\n        particleSystem.isLocal = !!parsedParticleSystem.isLocal;\r\n\r\n        // Misc.\r\n        if (parsedParticleSystem.renderingGroupId !== undefined) {\r\n            particleSystem.renderingGroupId = parsedParticleSystem.renderingGroupId;\r\n        }\r\n\r\n        if (parsedParticleSystem.isBillboardBased !== undefined) {\r\n            particleSystem.isBillboardBased = parsedParticleSystem.isBillboardBased;\r\n        }\r\n\r\n        if (parsedParticleSystem.billboardMode !== undefined) {\r\n            particleSystem.billboardMode = parsedParticleSystem.billboardMode;\r\n        }\r\n\r\n        if (parsedParticleSystem.useLogarithmicDepth !== undefined) {\r\n            particleSystem.useLogarithmicDepth = parsedParticleSystem.useLogarithmicDepth;\r\n        }\r\n\r\n        // Animations\r\n        if (parsedParticleSystem.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedParticleSystem.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedParticleSystem.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    particleSystem.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n            particleSystem.beginAnimationOnStart = parsedParticleSystem.beginAnimationOnStart;\r\n            particleSystem.beginAnimationFrom = parsedParticleSystem.beginAnimationFrom;\r\n            particleSystem.beginAnimationTo = parsedParticleSystem.beginAnimationTo;\r\n            particleSystem.beginAnimationLoop = parsedParticleSystem.beginAnimationLoop;\r\n        }\r\n\r\n        if (parsedParticleSystem.autoAnimate && scene) {\r\n            scene.beginAnimation(\r\n                particleSystem,\r\n                parsedParticleSystem.autoAnimateFrom,\r\n                parsedParticleSystem.autoAnimateTo,\r\n                parsedParticleSystem.autoAnimateLoop,\r\n                parsedParticleSystem.autoAnimateSpeed || 1.0\r\n            );\r\n        }\r\n\r\n        // Particle system\r\n        particleSystem.startDelay = parsedParticleSystem.startDelay | 0;\r\n        particleSystem.minAngularSpeed = parsedParticleSystem.minAngularSpeed;\r\n        particleSystem.maxAngularSpeed = parsedParticleSystem.maxAngularSpeed;\r\n        particleSystem.minSize = parsedParticleSystem.minSize;\r\n        particleSystem.maxSize = parsedParticleSystem.maxSize;\r\n\r\n        if (parsedParticleSystem.minScaleX) {\r\n            particleSystem.minScaleX = parsedParticleSystem.minScaleX;\r\n            particleSystem.maxScaleX = parsedParticleSystem.maxScaleX;\r\n            particleSystem.minScaleY = parsedParticleSystem.minScaleY;\r\n            particleSystem.maxScaleY = parsedParticleSystem.maxScaleY;\r\n        }\r\n\r\n        if (parsedParticleSystem.preWarmCycles !== undefined) {\r\n            particleSystem.preWarmCycles = parsedParticleSystem.preWarmCycles;\r\n            particleSystem.preWarmStepOffset = parsedParticleSystem.preWarmStepOffset;\r\n        }\r\n\r\n        if (parsedParticleSystem.minInitialRotation !== undefined) {\r\n            particleSystem.minInitialRotation = parsedParticleSystem.minInitialRotation;\r\n            particleSystem.maxInitialRotation = parsedParticleSystem.maxInitialRotation;\r\n        }\r\n\r\n        particleSystem.minLifeTime = parsedParticleSystem.minLifeTime;\r\n        particleSystem.maxLifeTime = parsedParticleSystem.maxLifeTime;\r\n        particleSystem.minEmitPower = parsedParticleSystem.minEmitPower;\r\n        particleSystem.maxEmitPower = parsedParticleSystem.maxEmitPower;\r\n        particleSystem.emitRate = parsedParticleSystem.emitRate;\r\n        particleSystem.gravity = Vector3.FromArray(parsedParticleSystem.gravity);\r\n        if (parsedParticleSystem.noiseStrength) {\r\n            particleSystem.noiseStrength = Vector3.FromArray(parsedParticleSystem.noiseStrength);\r\n        }\r\n        particleSystem.color1 = Color4.FromArray(parsedParticleSystem.color1);\r\n        particleSystem.color2 = Color4.FromArray(parsedParticleSystem.color2);\r\n        particleSystem.colorDead = Color4.FromArray(parsedParticleSystem.colorDead);\r\n        particleSystem.updateSpeed = parsedParticleSystem.updateSpeed;\r\n        particleSystem.targetStopDuration = parsedParticleSystem.targetStopDuration;\r\n        particleSystem.blendMode = parsedParticleSystem.blendMode;\r\n\r\n        if (parsedParticleSystem.colorGradients) {\r\n            for (const colorGradient of parsedParticleSystem.colorGradients) {\r\n                particleSystem.addColorGradient(\r\n                    colorGradient.gradient,\r\n                    Color4.FromArray(colorGradient.color1),\r\n                    colorGradient.color2 ? Color4.FromArray(colorGradient.color2) : undefined\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.rampGradients) {\r\n            for (const rampGradient of parsedParticleSystem.rampGradients) {\r\n                particleSystem.addRampGradient(rampGradient.gradient, Color3.FromArray(rampGradient.color));\r\n            }\r\n            particleSystem.useRampGradients = parsedParticleSystem.useRampGradients;\r\n        }\r\n\r\n        if (parsedParticleSystem.colorRemapGradients) {\r\n            for (const colorRemapGradient of parsedParticleSystem.colorRemapGradients) {\r\n                particleSystem.addColorRemapGradient(\r\n                    colorRemapGradient.gradient,\r\n                    colorRemapGradient.factor1 !== undefined ? colorRemapGradient.factor1 : colorRemapGradient.factor,\r\n                    colorRemapGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.alphaRemapGradients) {\r\n            for (const alphaRemapGradient of parsedParticleSystem.alphaRemapGradients) {\r\n                particleSystem.addAlphaRemapGradient(\r\n                    alphaRemapGradient.gradient,\r\n                    alphaRemapGradient.factor1 !== undefined ? alphaRemapGradient.factor1 : alphaRemapGradient.factor,\r\n                    alphaRemapGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.sizeGradients) {\r\n            for (const sizeGradient of parsedParticleSystem.sizeGradients) {\r\n                particleSystem.addSizeGradient(sizeGradient.gradient, sizeGradient.factor1 !== undefined ? sizeGradient.factor1 : sizeGradient.factor, sizeGradient.factor2);\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.angularSpeedGradients) {\r\n            for (const angularSpeedGradient of parsedParticleSystem.angularSpeedGradients) {\r\n                particleSystem.addAngularSpeedGradient(\r\n                    angularSpeedGradient.gradient,\r\n                    angularSpeedGradient.factor1 !== undefined ? angularSpeedGradient.factor1 : angularSpeedGradient.factor,\r\n                    angularSpeedGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.velocityGradients) {\r\n            for (const velocityGradient of parsedParticleSystem.velocityGradients) {\r\n                particleSystem.addVelocityGradient(\r\n                    velocityGradient.gradient,\r\n                    velocityGradient.factor1 !== undefined ? velocityGradient.factor1 : velocityGradient.factor,\r\n                    velocityGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.dragGradients) {\r\n            for (const dragGradient of parsedParticleSystem.dragGradients) {\r\n                particleSystem.addDragGradient(dragGradient.gradient, dragGradient.factor1 !== undefined ? dragGradient.factor1 : dragGradient.factor, dragGradient.factor2);\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.emitRateGradients) {\r\n            for (const emitRateGradient of parsedParticleSystem.emitRateGradients) {\r\n                particleSystem.addEmitRateGradient(\r\n                    emitRateGradient.gradient,\r\n                    emitRateGradient.factor1 !== undefined ? emitRateGradient.factor1 : emitRateGradient.factor,\r\n                    emitRateGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.startSizeGradients) {\r\n            for (const startSizeGradient of parsedParticleSystem.startSizeGradients) {\r\n                particleSystem.addStartSizeGradient(\r\n                    startSizeGradient.gradient,\r\n                    startSizeGradient.factor1 !== undefined ? startSizeGradient.factor1 : startSizeGradient.factor,\r\n                    startSizeGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.lifeTimeGradients) {\r\n            for (const lifeTimeGradient of parsedParticleSystem.lifeTimeGradients) {\r\n                particleSystem.addLifeTimeGradient(\r\n                    lifeTimeGradient.gradient,\r\n                    lifeTimeGradient.factor1 !== undefined ? lifeTimeGradient.factor1 : lifeTimeGradient.factor,\r\n                    lifeTimeGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.limitVelocityGradients) {\r\n            for (const limitVelocityGradient of parsedParticleSystem.limitVelocityGradients) {\r\n                particleSystem.addLimitVelocityGradient(\r\n                    limitVelocityGradient.gradient,\r\n                    limitVelocityGradient.factor1 !== undefined ? limitVelocityGradient.factor1 : limitVelocityGradient.factor,\r\n                    limitVelocityGradient.factor2\r\n                );\r\n            }\r\n            particleSystem.limitVelocityDamping = parsedParticleSystem.limitVelocityDamping;\r\n        }\r\n\r\n        if (parsedParticleSystem.noiseTexture && scene) {\r\n            const internalClass = GetClass(\"BABYLON.ProceduralTexture\");\r\n            particleSystem.noiseTexture = internalClass.Parse(parsedParticleSystem.noiseTexture, scene, rootUrl);\r\n        }\r\n\r\n        // Emitter\r\n        let emitterType: IParticleEmitterType;\r\n        if (parsedParticleSystem.particleEmitterType) {\r\n            switch (parsedParticleSystem.particleEmitterType.type) {\r\n                case \"SphereParticleEmitter\":\r\n                    emitterType = new SphereParticleEmitter();\r\n                    break;\r\n                case \"SphereDirectedParticleEmitter\":\r\n                    emitterType = new SphereDirectedParticleEmitter();\r\n                    break;\r\n                case \"ConeEmitter\":\r\n                case \"ConeParticleEmitter\":\r\n                    emitterType = new ConeParticleEmitter();\r\n                    break;\r\n                case \"CylinderParticleEmitter\":\r\n                    emitterType = new CylinderParticleEmitter();\r\n                    break;\r\n                case \"CylinderDirectedParticleEmitter\":\r\n                    emitterType = new CylinderDirectedParticleEmitter();\r\n                    break;\r\n                case \"HemisphericParticleEmitter\":\r\n                    emitterType = new HemisphericParticleEmitter();\r\n                    break;\r\n                case \"PointParticleEmitter\":\r\n                    emitterType = new PointParticleEmitter();\r\n                    break;\r\n                case \"MeshParticleEmitter\":\r\n                    emitterType = new MeshParticleEmitter();\r\n                    break;\r\n                case \"BoxEmitter\":\r\n                case \"BoxParticleEmitter\":\r\n                default:\r\n                    emitterType = new BoxParticleEmitter();\r\n                    break;\r\n            }\r\n\r\n            emitterType.parse(parsedParticleSystem.particleEmitterType, scene);\r\n        } else {\r\n            emitterType = new BoxParticleEmitter();\r\n            emitterType.parse(parsedParticleSystem, scene);\r\n        }\r\n        particleSystem.particleEmitterType = emitterType;\r\n\r\n        // Animation sheet\r\n        particleSystem.startSpriteCellID = parsedParticleSystem.startSpriteCellID;\r\n        particleSystem.endSpriteCellID = parsedParticleSystem.endSpriteCellID;\r\n        particleSystem.spriteCellLoop = parsedParticleSystem.spriteCellLoop ?? true;\r\n        particleSystem.spriteCellWidth = parsedParticleSystem.spriteCellWidth;\r\n        particleSystem.spriteCellHeight = parsedParticleSystem.spriteCellHeight;\r\n        particleSystem.spriteCellChangeSpeed = parsedParticleSystem.spriteCellChangeSpeed;\r\n        particleSystem.spriteRandomStartCell = parsedParticleSystem.spriteRandomStartCell;\r\n\r\n        particleSystem.disposeOnStop = parsedParticleSystem.disposeOnStop ?? false;\r\n        particleSystem.manualEmitCount = parsedParticleSystem.manualEmitCount ?? -1;\r\n    }\r\n\r\n    /**\r\n     * Parses a JSON object to create a particle system.\r\n     * @param parsedParticleSystem The JSON object to parse\r\n     * @param sceneOrEngine The scene or the engine to create the particle system in\r\n     * @param rootUrl The root url to use to load external dependencies like texture\r\n     * @param doNotStart Ignore the preventAutoStart attribute and does not start\r\n     * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\r\n     * @returns the Parsed particle system\r\n     */\r\n    public static Parse(parsedParticleSystem: any, sceneOrEngine: Scene | ThinEngine, rootUrl: string, doNotStart = false, capacity?: number): ParticleSystem {\r\n        const name = parsedParticleSystem.name;\r\n        let custom: Nullable<Effect> = null;\r\n        let program: any = null;\r\n        let engine: ThinEngine;\r\n        let scene: Nullable<Scene>;\r\n\r\n        if (sceneOrEngine instanceof ThinEngine) {\r\n            engine = sceneOrEngine;\r\n        } else {\r\n            scene = sceneOrEngine as Scene;\r\n            engine = scene.getEngine();\r\n        }\r\n\r\n        if (parsedParticleSystem.customShader && (engine as any).createEffectForParticles) {\r\n            program = parsedParticleSystem.customShader;\r\n            const defines: string = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\r\n            custom = (engine as any).createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\r\n        }\r\n        const particleSystem = new ParticleSystem(name, capacity || parsedParticleSystem.capacity, sceneOrEngine, custom, parsedParticleSystem.isAnimationSheetEnabled);\r\n        particleSystem.customShader = program;\r\n        particleSystem._rootUrl = rootUrl;\r\n\r\n        if (parsedParticleSystem.id) {\r\n            particleSystem.id = parsedParticleSystem.id;\r\n        }\r\n\r\n        // SubEmitters\r\n        if (parsedParticleSystem.subEmitters) {\r\n            particleSystem.subEmitters = [];\r\n            for (const cell of parsedParticleSystem.subEmitters) {\r\n                const cellArray = [];\r\n                for (const sub of cell) {\r\n                    cellArray.push(SubEmitter.Parse(sub, sceneOrEngine, rootUrl));\r\n                }\r\n\r\n                particleSystem.subEmitters.push(cellArray);\r\n            }\r\n        }\r\n\r\n        ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);\r\n\r\n        if (parsedParticleSystem.textureMask) {\r\n            particleSystem.textureMask = Color4.FromArray(parsedParticleSystem.textureMask);\r\n        }\r\n\r\n        // Auto start\r\n        if (parsedParticleSystem.preventAutoStart) {\r\n            particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;\r\n        }\r\n\r\n        if (!doNotStart && !particleSystem.preventAutoStart) {\r\n            particleSystem.start();\r\n        }\r\n\r\n        return particleSystem;\r\n    }\r\n}\r\n\r\nSubEmitter._ParseParticleSystem = ParticleSystem.Parse;\r\n"],"mappings":";;;;AAEA,SAASA,cAAc,EAAEC,aAAa,EAAEC,cAAc,EAAEC,cAAc,QAAQ,sBAAoB;AAElG,SAASC,UAAU,QAAQ,uBAAqB;AAChD,SAASC,OAAO,EAAEC,MAAM,EAAEC,UAAU,EAAEC,OAAO,QAAQ,yBAAuB;AAC5E,SAASC,MAAM,QAAQ,yBAAuB;AAC9C,SAASC,YAAY,EAAEC,MAAM,QAAQ,sBAAoB;AAGzD,SAASC,4BAA4B,QAAQ,8CAA4C;AACzF,SAASC,UAAU,QAAQ,qCAAmC;AAC9D,SAASC,WAAW,QAAQ,2BAAyB;AAGrD,SACIC,kBAAkB,EAClBC,0BAA0B,EAC1BC,qBAAqB,EACrBC,6BAA6B,EAC7BC,uBAAuB,EACvBC,mBAAmB,EACnBC,oBAAoB,EACpBC,mBAAmB,EACnBC,+BAA+B,QAC5B,oCAAkC;AAEzC,SAASC,kBAAkB,QAAQ,yBAAuB;AAC1D,SAASC,QAAQ,QAAQ,eAAa;AACtC,SAASC,UAAU,EAAEC,cAAc,QAAQ,iBAAe;AAE1D,SAASC,mBAAmB,QAAQ,uBAAqB;AACzD,SAASC,QAAQ,QAAQ,sBAAoB;AAE7C,SAASC,WAAW,QAAQ,6BAA2B;AAEvD,OAAO,kCAAgC;AACvC,OAAO,gCAA8B;AAErC,SAASC,MAAM,EAAEC,MAAM,EAAEC,SAAS,QAAQ,wBAAsB;AAGhE,SAASC,UAAU,QAAQ,0BAAwB;AACnD,SAASC,cAAc,QAAQ,gCAA8B;AAE7D,OAAO,uCAAqC;AAC5C,SAASC,oBAAoB,EAAEC,iCAAiC,EAAEC,aAAa,QAAQ,yCAAuC;AAO9H;;;;;;AAMA,OAAM,MAAOC,cAAe,SAAQf,kBAAkB;EAqDlD;;;EAGA,IAAWgB,SAASA,CAACC,QAAoB;IACrC,IAAI,IAAI,CAACC,kBAAkB,EAAE;MACzB,IAAI,CAACC,mBAAmB,CAACC,MAAM,CAAC,IAAI,CAACF,kBAAkB,CAAC;;IAE5D,IAAI,CAACA,kBAAkB,GAAG,IAAI,CAACC,mBAAmB,CAACE,GAAG,CAACJ,QAAQ,CAAC;EACpE;EA0DA;;;EAGA,IAAWK,gBAAgBA,CAAA;IACvB,OAAO,IAAI,CAACC,iBAAiB;EACjC;EAEA,IAAWD,gBAAgBA,CAACE,KAAc;IACtC,IAAI,IAAI,CAACD,iBAAiB,KAAKC,KAAK,EAAE;MAClC;;IAGJ,IAAI,CAACD,iBAAiB,GAAGC,KAAK;IAE9B,IAAI,CAACC,YAAY,EAAE;EACvB;EA6BA;EAEA;;;EAGA,IAAWC,SAASA,CAAA;IAChB,OAAO,IAAI,CAACC,UAAU;EAC1B;EAEA;;;;EAIOC,cAAcA,CAAA;IACjB,OAAO,IAAI,CAACD,UAAU,CAACE,MAAM;EACjC;EAEA;;;;EAIOC,YAAYA,CAAA;IACf,OAAO,gBAAgB;EAC3B;EAEA;;;;EAIOC,UAAUA,CAAA;IACb,OAAO,IAAI,CAACC,QAAQ,IAAI,IAAI,CAACC,OAAO,EAAE;EAC1C;EAEA;;;;;EAKOC,eAAeA,CAACC,SAAA,GAAoB,CAAC;;IACxC,OAAO,CAAAC,EAAA,IAAAC,EAAA,OAAI,CAACC,eAAe,CAACH,SAAS,CAAC,cAAAE,EAAA,uBAAAA,EAAA,CAAEE,MAAM,cAAAH,EAAA,cAAAA,EAAA,GAAI,IAAI,CAACE,eAAe,CAAC,CAAC,CAAE,CAACC,MAAM;EACrF;EAEQC,qBAAqBA,CAACL,SAAA,GAAoB,CAAC;;IAC/C,OAAO,CAAAE,EAAA,OAAI,CAACC,eAAe,CAACH,SAAS,CAAC,cAAAE,EAAA,cAAAA,EAAA,GAAI,IAAI,CAACC,eAAe,CAAC,CAAC,CAAC;EACrE;EAEA;;;;;EAKOG,eAAeA,CAACF,MAAwB,EAAEJ,SAAA,GAAoB,CAAC;IAClE,IAAI,CAACG,eAAe,CAACH,SAAS,CAAC,GAAG,IAAI7B,WAAW,CAAC,IAAI,CAACoC,OAAO,CAAC;IAC/D,IAAI,CAACJ,eAAe,CAACH,SAAS,CAAE,CAACI,MAAM,GAAGA,MAAM;IAChD,IAAI,IAAI,CAACD,eAAe,CAACH,SAAS,CAAE,CAACQ,WAAW,EAAE;MAC9C,IAAI,CAACL,eAAe,CAACH,SAAS,CAAE,CAACQ,WAAY,CAACC,aAAa,GAAG,IAAI,CAACC,cAAc;;EAEzF;EAKA;;;EAGA,IAAWC,+BAA+BA,CAAA;IACtC,IAAI,CAAC,IAAI,CAACC,gCAAgC,EAAE;MACxC,IAAI,CAACA,gCAAgC,GAAG,IAAInE,UAAU,EAAoB;;IAG9E,OAAO,IAAI,CAACmE,gCAAgC;EAChD;EAEA;;;EAGA,IAAWC,gBAAgBA,CAAA;IACvB,OAAO,WAAW;EACtB;EAEA;;;EAGA,IAAWC,aAAaA,CAAA;IACpB,OAAO,IAAI,CAACC,cAAc;EAC9B;EAEA;;;EAGA,IAAWC,WAAWA,CAAA;IAClB,OAAO,IAAI,CAACC,YAAY;EAC5B;EAEA;;;;;;;;;;EAUAC,YACIC,IAAY,EACZC,QAAgB,EAChBC,aAAiC,EACjCC,YAAA,GAAiC,IAAI,EACrCC,uBAAA,GAAmC,KAAK,EACxCC,OAAA,GAAkB,IAAI;IAEtB,KAAK,CAACL,IAAI,CAAC;IAzPP,KAAAM,0BAA0B,GAAW9E,MAAM,CAAC+E,QAAQ,EAAE;IAa9D;;;IAGO,KAAAC,wBAAwB,GAAG,IAAIjF,OAAO,EAAE;IAC/C;;;IAGO,KAAAsC,mBAAmB,GAAG,IAAIvC,UAAU,EAAmB;IAC9D;;;IAGO,KAAAmF,mBAAmB,GAAG,IAAInF,UAAU,EAAmB;IAatD,KAAA+C,UAAU,GAAG,IAAIqC,KAAK,EAAY;IAGlC,KAAAC,eAAe,GAAG,IAAID,KAAK,EAAY;IACvC,KAAAE,eAAe,GAAG,CAAC;IAGnB,KAAAhB,cAAc,GAAoC,EAAE;IAOpD,KAAAiB,gBAAgB,GAAG,IAAI5D,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACzC,KAAA6D,UAAU,GAAG,IAAI7D,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACnC,KAAA8D,gBAAgB,GAAGxF,OAAO,CAACyF,IAAI,EAAE;IACjC,KAAAC,cAAc,GAAG1F,OAAO,CAACyF,IAAI,EAAE;IAC/B,KAAAE,gBAAgB,GAAG,CAAC,CAAC;IAErB,KAAA3B,cAAc,GAAG,KAAK;IAGtB,KAAA4B,QAAQ,GAAG,KAAK;IAChB,KAAAzC,QAAQ,GAAG,KAAK;IAChB,KAAA0C,YAAY,GAAG,CAAC;IAMxB;IACO,KAAAC,iBAAiB,GAAG,CAAC;IAC5B;IACO,KAAAC,iBAAiB,GAAG,CAAC;IAI5B;IACO,KAAAC,kBAAkB,GAAG,CAAC;IAC7B;IACO,KAAAC,kBAAkB,GAAG,CAAC;IAE7B;IACgB,KAAAC,eAAe,GAAG,IAAI;IAErB,KAAAC,gBAAgB,GAAG,GAAG;IAE/B,KAAAzD,iBAAiB,GAAG,KAAK;IAiCjC;;;;IAIO,KAAA0D,wBAAwB,GAAG,KAAK;IAMvC;;;IAGO,KAAAC,OAAO,GAAG,KAAK;IAEtB;IACgB,KAAAC,KAAK,GAAG,KAAK;IA8D7B;IACQ,KAAApC,gCAAgC,GAA2C,IAAI;IA8mCvF;IAEA;;;;;IAKO,KAAAqC,eAAe,GAAkCC,QAAQ,IAAI;MAChE;MACA,MAAMC,YAAY,GAAa,IAAI,CAAC3D,UAAU,CAAC4D,GAAG,EAAE;MACpD,IAAID,YAAY,KAAKD,QAAQ,EAAE;QAC3BC,YAAY,CAACE,MAAM,CAACH,QAAQ,CAAC;;MAEjC,IAAI,CAACpB,eAAe,CAACwB,IAAI,CAACH,YAAY,CAAC;IAC3C,CAAC;IAYO,KAAAI,eAAe,GAAmB,MAAK;MAC3C,IAAIL,QAAkB;MACtB,IAAI,IAAI,CAACpB,eAAe,CAACpC,MAAM,KAAK,CAAC,EAAE;QACnCwD,QAAQ,GAAa,IAAI,CAACpB,eAAe,CAACsB,GAAG,EAAE;QAC/CF,QAAQ,CAACM,MAAM,EAAE;OACpB,MAAM;QACHN,QAAQ,GAAG,IAAIpF,QAAQ,CAAC,IAAI,CAAC;;MAGjC;MACA,IAAI,IAAI,CAAC2F,YAAY,IAAI,IAAI,CAACA,YAAY,CAAC/D,MAAM,GAAG,CAAC,EAAE;QACnD,MAAMgE,WAAW,GAAG,IAAI,CAACD,YAAY,CAACE,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,EAAE,GAAG,IAAI,CAACJ,YAAY,CAAC/D,MAAM,CAAC,CAAC;QAC3FwD,QAAQ,CAACY,oBAAoB,GAAG,EAAE;QAClCJ,WAAW,CAACK,OAAO,CAAEC,UAAU,IAAI;UAC/B,IAAIA,UAAU,CAACC,IAAI,KAAKjG,cAAc,CAACkG,QAAQ,EAAE;YAC7C,MAAMC,UAAU,GAAGH,UAAU,CAACI,KAAK,EAAE;YACjBlB,QAAQ,CAACY,oBAAqB,CAACR,IAAI,CAACa,UAAU,CAAC;YACnEA,UAAU,CAACE,cAAc,CAACC,KAAK,EAAE;;QAEzC,CAAC,CAAC;;MAEN,OAAOpB,QAAQ;IACnB,CAAC;IAeO,KAAAqB,iBAAiB,GAAkCrB,QAAQ,IAAI;MACnE,IAAI,CAAC,IAAI,CAACO,YAAY,IAAI,IAAI,CAACA,YAAY,CAAC/D,MAAM,KAAK,CAAC,EAAE;QACtD;;MAEJ,MAAM8E,aAAa,GAAGb,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,EAAE,GAAG,IAAI,CAACJ,YAAY,CAAC/D,MAAM,CAAC;MAE1E,IAAI,CAAC+D,YAAY,CAACe,aAAa,CAAC,CAACT,OAAO,CAAEC,UAAU,IAAI;QACpD,IAAIA,UAAU,CAACC,IAAI,KAAKjG,cAAc,CAACyG,GAAG,EAAE;UACxC,MAAMC,SAAS,GAAGV,UAAU,CAACI,KAAK,EAAE;UACpClB,QAAQ,CAACyB,gCAAgC,CAACD,SAAS,CAAC;UACpDA,SAAS,CAACL,cAAc,CAACO,mBAAmB,GAAG,IAAI;UACnD,IAAI,CAACC,gBAAgB,CAACvB,IAAI,CAACoB,SAAS,CAACL,cAAc,CAAC;UACpDK,SAAS,CAACL,cAAc,CAACC,KAAK,EAAE;;MAExC,CAAC,CAAC;IACN,CAAC;IAtoCG,IAAI,CAACQ,SAAS,GAAG1D,QAAQ;IAEzB,IAAI,CAAC2D,QAAQ,GAAGvD,OAAO;IACvB,IAAI,CAACwD,wBAAwB,GAAGzD,uBAAuB;IAEvD,IAAI,CAACF,aAAa,IAAIA,aAAa,CAAC1B,YAAY,EAAE,KAAK,OAAO,EAAE;MAC5D,IAAI,CAACsF,MAAM,GAAI5D,aAAuB,IAAIlE,WAAW,CAAC+H,gBAAgB;MACtE,IAAI,CAAC3E,OAAO,GAAG,IAAI,CAAC0E,MAAM,CAACE,SAAS,EAAE;MACtC,IAAI,CAACC,QAAQ,GAAG,IAAI,CAACH,MAAM,CAACI,WAAW,EAAE;MACzC,IAAI,CAACJ,MAAM,CAACK,eAAe,CAAChC,IAAI,CAAC,IAAI,CAAC;KACzC,MAAM;MACH,IAAI,CAAC/C,OAAO,GAAGc,aAA2B;MAC1C,IAAI,CAACkE,uBAAuB,GAAG5I,MAAM,CAAC6I,gBAAgB,CAAC,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,CAACjF,OAAO,CAACkF,eAAe,CAAC;;IAG1G,IAAI,IAAI,CAAClF,OAAO,CAACmF,OAAO,EAAE,CAACC,iBAAiB,EAAE;MAC1C,IAAI,CAACC,kBAAkB,GAAG,IAAI;;IAGlC;IACA,IAAI,CAACC,mCAAmC,CAAC,IAAI,CAAC;IAE9C;IACA,IAAI,CAAC1F,eAAe,GAAG;MAAE,CAAC,EAAE,IAAIhC,WAAW,CAAC,IAAI,CAACoC,OAAO;IAAC,CAAE;IAC3D,IAAI,CAACJ,eAAe,CAAC,CAAC,CAAE,CAACC,MAAM,GAAGkB,YAAY;IAE9C,IAAI,CAACwE,aAAa,GAAG,EAAE;IACvB,IAAI,CAACpF,cAAc,GAAG,IAAI,CAACH,OAAO,CAACmF,OAAO,EAAE,CAACK,eAAe;IAE5D,IAAI,CAACC,kBAAkB,EAAE;IACzB,IAAI,CAACC,oBAAoB,EAAE;IAE3B;IACA,IAAI,CAACC,mBAAmB,GAAG,IAAI9I,kBAAkB,EAAE;IACnD,IAAI+I,gBAAgB,GAAyB,IAAI;IAEjD;IACA,IAAI,CAACC,cAAc,GAAI7G,SAAqB,IAAU;;MAClD,IAAI8G,gBAAgB,GAAoB,IAAI;MAE5C,IAAI,IAAI,CAACC,YAAY,EAAE;QACnB;QACAD,gBAAgB,GAAG,IAAI,CAACC,YAAY,CAACC,OAAO,EAAE;QAC9C,CAAArG,EAAA,OAAI,CAACoG,YAAY,CAACE,UAAU,EAAE,cAAAtG,EAAA,uBAAAA,EAAA,CAAEuG,IAAI,CAAEC,IAAI,IAAI;UAC1CP,gBAAgB,GAAGO,IAAkB;QACzC,CAAC,CAAC;;MAGN,MAAMC,iBAAiB,GAAGpH,SAAS,KAAK,IAAI,CAACC,UAAU;MAEvD,KAAK,IAAIoH,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGrH,SAAS,CAACG,MAAM,EAAEkH,KAAK,EAAE,EAAE;QACnD,MAAM1D,QAAQ,GAAG3D,SAAS,CAACqH,KAAK,CAAC;QAEjC,IAAIC,iBAAiB,GAAG,IAAI,CAACC,kBAAkB;QAC/C,MAAMC,WAAW,GAAG7D,QAAQ,CAAC8D,GAAG;QAChC9D,QAAQ,CAAC8D,GAAG,IAAIH,iBAAiB;QAEjC;QACA,IAAI3D,QAAQ,CAAC8D,GAAG,GAAG9D,QAAQ,CAAC+D,QAAQ,EAAE;UAClC,MAAMC,IAAI,GAAGhE,QAAQ,CAAC8D,GAAG,GAAGD,WAAW;UACvC,MAAMI,OAAO,GAAGjE,QAAQ,CAAC+D,QAAQ,GAAGF,WAAW;UAE/CF,iBAAiB,GAAIM,OAAO,GAAGN,iBAAiB,GAAIK,IAAI;UAExDhE,QAAQ,CAAC8D,GAAG,GAAG9D,QAAQ,CAAC+D,QAAQ;;QAGpC,MAAMG,KAAK,GAAGlE,QAAQ,CAAC8D,GAAG,GAAG9D,QAAQ,CAAC+D,QAAQ;QAE9C;QACA,IAAI,IAAI,CAACI,eAAe,IAAI,IAAI,CAACA,eAAe,CAAC3H,MAAM,GAAG,CAAC,EAAE;UACzDlD,cAAc,CAAC8K,kBAAkB,CAACF,KAAK,EAAE,IAAI,CAACC,eAAe,EAAE,CAACE,eAAe,EAAEC,YAAY,EAAEC,KAAK,KAAI;YACpG,IAAIF,eAAe,KAAKrE,QAAQ,CAACwE,qBAAqB,EAAE;cACpDxE,QAAQ,CAACyE,cAAc,CAACC,QAAQ,CAAC1E,QAAQ,CAAC2E,cAAc,CAAC;cACzCL,YAAa,CAACM,aAAa,CAAC5E,QAAQ,CAAC2E,cAAc,CAAC;cACpE3E,QAAQ,CAACwE,qBAAqB,GAAkBH,eAAe;;YAEnEnJ,MAAM,CAAC2J,SAAS,CAAC7E,QAAQ,CAACyE,cAAc,EAAEzE,QAAQ,CAAC2E,cAAc,EAAEJ,KAAK,EAAEvE,QAAQ,CAAC8E,KAAK,CAAC;UAC7F,CAAC,CAAC;SACL,MAAM;UACH9E,QAAQ,CAAC+E,SAAS,CAACC,UAAU,CAACrB,iBAAiB,EAAE,IAAI,CAAC7E,gBAAgB,CAAC;UACvEkB,QAAQ,CAAC8E,KAAK,CAACG,UAAU,CAAC,IAAI,CAACnG,gBAAgB,CAAC;UAEhD,IAAIkB,QAAQ,CAAC8E,KAAK,CAACI,CAAC,GAAG,CAAC,EAAE;YACtBlF,QAAQ,CAAC8E,KAAK,CAACI,CAAC,GAAG,CAAC;;;QAI5B;QACA,IAAI,IAAI,CAACC,sBAAsB,IAAI,IAAI,CAACA,sBAAsB,CAAC3I,MAAM,GAAG,CAAC,EAAE;UACvElD,cAAc,CAAC8K,kBAAkB,CAACF,KAAK,EAAE,IAAI,CAACiB,sBAAsB,EAAE,CAACd,eAAe,EAAEC,YAAY,EAAEC,KAAK,KAAI;YAC3G,IAAIF,eAAe,KAAKrE,QAAQ,CAACoF,4BAA4B,EAAE;cAC3DpF,QAAQ,CAACqF,qBAAqB,GAAGrF,QAAQ,CAACsF,qBAAqB;cAC/DtF,QAAQ,CAACsF,qBAAqB,GAAoBhB,YAAa,CAACiB,SAAS,EAAE;cAC3EvF,QAAQ,CAACoF,4BAA4B,GAAmBf,eAAe;;YAE3ErE,QAAQ,CAACwF,YAAY,GAAG5L,MAAM,CAAC6L,IAAI,CAACzF,QAAQ,CAACqF,qBAAqB,EAAErF,QAAQ,CAACsF,qBAAqB,EAAEf,KAAK,CAAC;UAC9G,CAAC,CAAC;;QAENvE,QAAQ,CAAC0F,KAAK,IAAI1F,QAAQ,CAACwF,YAAY,GAAG7B,iBAAiB;QAE3D;QACA,IAAIgC,cAAc,GAAGhC,iBAAiB;QAEtC;QACA,IAAI,IAAI,CAACiC,kBAAkB,IAAI,IAAI,CAACA,kBAAkB,CAACpJ,MAAM,GAAG,CAAC,EAAE;UAC/DlD,cAAc,CAAC8K,kBAAkB,CAACF,KAAK,EAAE,IAAI,CAAC0B,kBAAkB,EAAE,CAACvB,eAAe,EAAEC,YAAY,EAAEC,KAAK,KAAI;YACvG,IAAIF,eAAe,KAAKrE,QAAQ,CAAC6F,wBAAwB,EAAE;cACvD7F,QAAQ,CAAC8F,iBAAiB,GAAG9F,QAAQ,CAAC+F,iBAAiB;cACvD/F,QAAQ,CAAC+F,iBAAiB,GAAoBzB,YAAa,CAACiB,SAAS,EAAE;cACvEvF,QAAQ,CAAC6F,wBAAwB,GAAmBxB,eAAe;;YAEvEsB,cAAc,IAAI/L,MAAM,CAAC6L,IAAI,CAACzF,QAAQ,CAAC8F,iBAAiB,EAAE9F,QAAQ,CAAC+F,iBAAiB,EAAExB,KAAK,CAAC;UAChG,CAAC,CAAC;;QAGNvE,QAAQ,CAACgG,SAAS,CAAChB,UAAU,CAACW,cAAc,EAAE,IAAI,CAAC3G,gBAAgB,CAAC;QAEpE;QACA,IAAI,IAAI,CAACiH,uBAAuB,IAAI,IAAI,CAACA,uBAAuB,CAACzJ,MAAM,GAAG,CAAC,EAAE;UACzElD,cAAc,CAAC8K,kBAAkB,CAACF,KAAK,EAAE,IAAI,CAAC+B,uBAAuB,EAAE,CAAC5B,eAAe,EAAEC,YAAY,EAAEC,KAAK,KAAI;YAC5G,IAAIF,eAAe,KAAKrE,QAAQ,CAACkG,6BAA6B,EAAE;cAC5DlG,QAAQ,CAACmG,sBAAsB,GAAGnG,QAAQ,CAACoG,sBAAsB;cACjEpG,QAAQ,CAACoG,sBAAsB,GAAoB9B,YAAa,CAACiB,SAAS,EAAE;cAC5EvF,QAAQ,CAACkG,6BAA6B,GAAmB7B,eAAe;;YAG5E,MAAMgC,aAAa,GAAGzM,MAAM,CAAC6L,IAAI,CAACzF,QAAQ,CAACmG,sBAAsB,EAAEnG,QAAQ,CAACoG,sBAAsB,EAAE7B,KAAK,CAAC;YAC1G,MAAM+B,eAAe,GAAGtG,QAAQ,CAACgG,SAAS,CAACxJ,MAAM,EAAE;YAEnD,IAAI8J,eAAe,GAAGD,aAAa,EAAE;cACjCrG,QAAQ,CAACgG,SAAS,CAACO,YAAY,CAAC,IAAI,CAACC,oBAAoB,CAAC;;UAElE,CAAC,CAAC;;QAGN;QACA,IAAI,IAAI,CAACC,cAAc,IAAI,IAAI,CAACA,cAAc,CAACjK,MAAM,GAAG,CAAC,EAAE;UACvDlD,cAAc,CAAC8K,kBAAkB,CAACF,KAAK,EAAE,IAAI,CAACuC,cAAc,EAAE,CAACpC,eAAe,EAAEC,YAAY,EAAEC,KAAK,KAAI;YACnG,IAAIF,eAAe,KAAKrE,QAAQ,CAAC0G,oBAAoB,EAAE;cACnD1G,QAAQ,CAAC2G,aAAa,GAAG3G,QAAQ,CAAC4G,aAAa;cAC/C5G,QAAQ,CAAC4G,aAAa,GAAoBtC,YAAa,CAACiB,SAAS,EAAE;cACnEvF,QAAQ,CAAC0G,oBAAoB,GAAmBrC,eAAe;;YAGnE,MAAMwC,IAAI,GAAGjN,MAAM,CAAC6L,IAAI,CAACzF,QAAQ,CAAC2G,aAAa,EAAE3G,QAAQ,CAAC4G,aAAa,EAAErC,KAAK,CAAC;YAE/E,IAAI,CAACvF,gBAAgB,CAACuH,YAAY,CAAC,GAAG,GAAGM,IAAI,CAAC;UAClD,CAAC,CAAC;;QAGN,IAAI,IAAI,CAAChH,OAAO,IAAIG,QAAQ,CAAC8G,cAAc,EAAE;UACzC9G,QAAQ,CAAC8G,cAAe,CAAC7B,UAAU,CAAC,IAAI,CAACjG,gBAAgB,CAAC;UAC1DxF,OAAO,CAACuN,yBAAyB,CAAC/G,QAAQ,CAAC8G,cAAe,EAAE,IAAI,CAACE,mBAAmB,EAAEhH,QAAQ,CAACiH,QAAQ,CAAC;SAC3G,MAAM;UACHjH,QAAQ,CAACiH,QAAQ,CAAChC,UAAU,CAAC,IAAI,CAACjG,gBAAgB,CAAC;;QAGvD;QACA,IAAIiE,gBAAgB,IAAIE,gBAAgB,IAAInD,QAAQ,CAACkH,wBAAwB,EAAE;UAC3E,MAAMC,aAAa,GAAG,IAAI,CAACC,OAAO,CAC9BpH,QAAQ,CAACkH,wBAAwB,CAACG,CAAC,EACnCrH,QAAQ,CAACkH,wBAAwB,CAACI,CAAC,EACnCnE,gBAAgB,CAACoE,KAAK,EACtBpE,gBAAgB,CAACqE,MAAM,EACvBvE,gBAAgB,CACnB;UACD,MAAMwE,aAAa,GAAG,IAAI,CAACL,OAAO,CAC9BpH,QAAQ,CAACkH,wBAAwB,CAACQ,CAAC,EACnC1H,QAAQ,CAAC2H,wBAAwB,CAACN,CAAC,EACnClE,gBAAgB,CAACoE,KAAK,EACtBpE,gBAAgB,CAACqE,MAAM,EACvBvE,gBAAgB,CACnB;UACD,MAAM2E,aAAa,GAAG,IAAI,CAACR,OAAO,CAC9BpH,QAAQ,CAAC2H,wBAAwB,CAACL,CAAC,EACnCtH,QAAQ,CAAC2H,wBAAwB,CAACD,CAAC,EACnCvE,gBAAgB,CAACoE,KAAK,EACtBpE,gBAAgB,CAACqE,MAAM,EACvBvE,gBAAgB,CACnB;UAED,MAAM4E,KAAK,GAAGnO,UAAU,CAACF,OAAO,CAAC,CAAC,CAAC;UACnC,MAAMsO,WAAW,GAAGpO,UAAU,CAACF,OAAO,CAAC,CAAC,CAAC;UAEzCqO,KAAK,CAACE,cAAc,CAChB,CAAC,CAAC,GAAGZ,aAAa,GAAG,CAAC,IAAI,IAAI,CAACa,aAAa,CAACX,CAAC,EAC9C,CAAC,CAAC,GAAGI,aAAa,GAAG,CAAC,IAAI,IAAI,CAACO,aAAa,CAACV,CAAC,EAC9C,CAAC,CAAC,GAAGM,aAAa,GAAG,CAAC,IAAI,IAAI,CAACI,aAAa,CAACN,CAAC,CACjD;UAEDG,KAAK,CAAC7C,UAAU,CAACrB,iBAAiB,EAAEmE,WAAW,CAAC;UAChD9H,QAAQ,CAACgG,SAAS,CAACf,UAAU,CAAC6C,WAAW,CAAC;;QAG9C;QACA,IAAI,CAACG,OAAO,CAACjD,UAAU,CAACrB,iBAAiB,EAAE,IAAI,CAACzE,cAAc,CAAC;QAC/Dc,QAAQ,CAACgG,SAAS,CAACf,UAAU,CAAC,IAAI,CAAC/F,cAAc,CAAC;QAElD;QACA,IAAI,IAAI,CAACgJ,cAAc,IAAI,IAAI,CAACA,cAAc,CAAC1L,MAAM,GAAG,CAAC,EAAE;UACvDlD,cAAc,CAAC8K,kBAAkB,CAACF,KAAK,EAAE,IAAI,CAACgE,cAAc,EAAE,CAAC7D,eAAe,EAAEC,YAAY,EAAEC,KAAK,KAAI;YACnG,IAAIF,eAAe,KAAKrE,QAAQ,CAACmI,oBAAoB,EAAE;cACnDnI,QAAQ,CAACoI,aAAa,GAAGpI,QAAQ,CAACqI,aAAa;cAC/CrI,QAAQ,CAACqI,aAAa,GAAoB/D,YAAa,CAACiB,SAAS,EAAE;cACnEvF,QAAQ,CAACmI,oBAAoB,GAAmB9D,eAAe;;YAEnErE,QAAQ,CAACsI,IAAI,GAAG1O,MAAM,CAAC6L,IAAI,CAACzF,QAAQ,CAACoI,aAAa,EAAEpI,QAAQ,CAACqI,aAAa,EAAE9D,KAAK,CAAC;UACtF,CAAC,CAAC;;QAGN;QACA,IAAI,IAAI,CAACrI,iBAAiB,EAAE;UACxB,IAAI,IAAI,CAACqM,oBAAoB,IAAI,IAAI,CAACA,oBAAoB,CAAC/L,MAAM,GAAG,CAAC,EAAE;YACnElD,cAAc,CAAC8K,kBAAkB,CAACF,KAAK,EAAE,IAAI,CAACqE,oBAAoB,EAAE,CAAClE,eAAe,EAAEC,YAAY,EAAEC,KAAK,KAAI;cACzG,MAAMiE,GAAG,GAAG5O,MAAM,CAAC6L,IAAI,CAAkBpB,eAAgB,CAACoE,OAAO,EAAmBnE,YAAa,CAACmE,OAAO,EAAElE,KAAK,CAAC;cACjH,MAAMmE,GAAG,GAAG9O,MAAM,CAAC6L,IAAI,CAAkBpB,eAAgB,CAACsE,OAAQ,EAAmBrE,YAAa,CAACqE,OAAQ,EAAEpE,KAAK,CAAC;cAEnHvE,QAAQ,CAAC4I,SAAS,CAACvB,CAAC,GAAGmB,GAAG;cAC1BxI,QAAQ,CAAC4I,SAAS,CAACtB,CAAC,GAAGoB,GAAG,GAAGF,GAAG;YACpC,CAAC,CAAC;;UAGN,IAAI,IAAI,CAACK,oBAAoB,IAAI,IAAI,CAACA,oBAAoB,CAACrM,MAAM,GAAG,CAAC,EAAE;YACnElD,cAAc,CAAC8K,kBAAkB,CAACF,KAAK,EAAE,IAAI,CAAC2E,oBAAoB,EAAE,CAACxE,eAAe,EAAEC,YAAY,EAAEC,KAAK,KAAI;cACzG,MAAMiE,GAAG,GAAG5O,MAAM,CAAC6L,IAAI,CAAkBpB,eAAgB,CAACoE,OAAO,EAAmBnE,YAAa,CAACmE,OAAO,EAAElE,KAAK,CAAC;cACjH,MAAMmE,GAAG,GAAG9O,MAAM,CAAC6L,IAAI,CAAkBpB,eAAgB,CAACsE,OAAQ,EAAmBrE,YAAa,CAACqE,OAAQ,EAAEpE,KAAK,CAAC;cAEnHvE,QAAQ,CAAC4I,SAAS,CAAClB,CAAC,GAAGc,GAAG;cAC1BxI,QAAQ,CAAC4I,SAAS,CAACE,CAAC,GAAGJ,GAAG,GAAGF,GAAG;YACpC,CAAC,CAAC;;;QAIV,IAAI,IAAI,CAAC1G,wBAAwB,EAAE;UAC/B9B,QAAQ,CAAC+I,eAAe,EAAE;;QAG9B;QACA/I,QAAQ,CAACgJ,iCAAiC,EAAE;QAE5C,IAAIhJ,QAAQ,CAAC8D,GAAG,IAAI9D,QAAQ,CAAC+D,QAAQ,EAAE;UACnC;UACA,IAAI,CAAC1C,iBAAiB,CAACrB,QAAQ,CAAC;UAChC,IAAIA,QAAQ,CAACY,oBAAoB,EAAE;YAC/BZ,QAAQ,CAACY,oBAAoB,CAACC,OAAO,CAAEC,UAAU,IAAI;cACjDA,UAAU,CAACK,cAAc,CAAC8H,aAAa,GAAG,IAAI;cAC9CnI,UAAU,CAACK,cAAc,CAAC+H,IAAI,EAAE;YACpC,CAAC,CAAC;YACFlJ,QAAQ,CAACY,oBAAoB,GAAG,IAAI;;UAExC,IAAI,CAACb,eAAe,CAACC,QAAQ,CAAC;UAC9B,IAAIyD,iBAAiB,EAAE;YACnBC,KAAK,EAAE;;UAEX;;;IAGZ,CAAC;EACL;EAEQyF,kBAAkBA,CAACC,eAAiC,EAAEC,QAAgB,EAAEC,MAAc,EAAEX,OAAgB;IAC5G,MAAMY,WAAW,GAAG,IAAIpQ,cAAc,CAACkQ,QAAQ,EAAEC,MAAM,EAAEX,OAAO,CAAC;IACjES,eAAe,CAAChJ,IAAI,CAACmJ,WAAW,CAAC;IAEjCH,eAAe,CAACI,IAAI,CAAC,CAACtE,CAAC,EAAEuE,CAAC,KAAI;MAC1B,IAAIvE,CAAC,CAACmE,QAAQ,GAAGI,CAAC,CAACJ,QAAQ,EAAE;QACzB,OAAO,CAAC,CAAC;OACZ,MAAM,IAAInE,CAAC,CAACmE,QAAQ,GAAGI,CAAC,CAACJ,QAAQ,EAAE;QAChC,OAAO,CAAC;;MAGZ,OAAO,CAAC;IACZ,CAAC,CAAC;EACN;EAEQK,qBAAqBA,CAACN,eAA2C,EAAEC,QAAgB;IACvF,IAAI,CAACD,eAAe,EAAE;MAClB;;IAGJ,IAAI1F,KAAK,GAAG,CAAC;IACb,KAAK,MAAMiG,cAAc,IAAIP,eAAe,EAAE;MAC1C,IAAIO,cAAc,CAACN,QAAQ,KAAKA,QAAQ,EAAE;QACtCD,eAAe,CAACQ,MAAM,CAAClG,KAAK,EAAE,CAAC,CAAC;QAChC;;MAEJA,KAAK,EAAE;;EAEf;EAEA;;;;;;;EAOOmG,mBAAmBA,CAACR,QAAgB,EAAEC,MAAc,EAAEX,OAAgB;IACzE,IAAI,CAAC,IAAI,CAACmB,kBAAkB,EAAE;MAC1B,IAAI,CAACA,kBAAkB,GAAG,EAAE;;IAGhC,IAAI,CAACX,kBAAkB,CAAC,IAAI,CAACW,kBAAkB,EAAET,QAAQ,EAAEC,MAAM,EAAEX,OAAO,CAAC;IAE3E,OAAO,IAAI;EACf;EAEA;;;;;EAKOoB,sBAAsBA,CAACV,QAAgB;IAC1C,IAAI,CAACK,qBAAqB,CAAC,IAAI,CAACI,kBAAkB,EAAET,QAAQ,CAAC;IAE7D,OAAO,IAAI;EACf;EAEA;;;;;;;EAOOW,eAAeA,CAACX,QAAgB,EAAEC,MAAc,EAAEX,OAAgB;IACrE,IAAI,CAAC,IAAI,CAACT,cAAc,EAAE;MACtB,IAAI,CAACA,cAAc,GAAG,EAAE;;IAG5B,IAAI,CAACiB,kBAAkB,CAAC,IAAI,CAACjB,cAAc,EAAEmB,QAAQ,EAAEC,MAAM,EAAEX,OAAO,CAAC;IAEvE,OAAO,IAAI;EACf;EAEA;;;;;EAKOsB,kBAAkBA,CAACZ,QAAgB;IACtC,IAAI,CAACK,qBAAqB,CAAC,IAAI,CAACxB,cAAc,EAAEmB,QAAQ,CAAC;IAEzD,OAAO,IAAI;EACf;EAEA;;;;;;;EAOOa,qBAAqBA,CAACb,QAAgB,EAAEb,GAAW,EAAEE,GAAW;IACnE,IAAI,CAAC,IAAI,CAACH,oBAAoB,EAAE;MAC5B,IAAI,CAACA,oBAAoB,GAAG,EAAE;;IAGlC,IAAI,CAACY,kBAAkB,CAAC,IAAI,CAACZ,oBAAoB,EAAEc,QAAQ,EAAEb,GAAG,EAAEE,GAAG,CAAC;IAEtE,OAAO,IAAI;EACf;EAEA;;;;;EAKOyB,wBAAwBA,CAACd,QAAgB;IAC5C,IAAI,CAACK,qBAAqB,CAAC,IAAI,CAACnB,oBAAoB,EAAEc,QAAQ,CAAC;IAE/D,OAAO,IAAI;EACf;EAEA;;;;;;;EAOOe,qBAAqBA,CAACf,QAAgB,EAAEb,GAAW,EAAEE,GAAW;IACnE,IAAI,CAAC,IAAI,CAACG,oBAAoB,EAAE;MAC5B,IAAI,CAACA,oBAAoB,GAAG,EAAE;;IAGlC,IAAI,CAACM,kBAAkB,CAAC,IAAI,CAACN,oBAAoB,EAAEQ,QAAQ,EAAEb,GAAG,EAAEE,GAAG,CAAC;IAEtE,OAAO,IAAI;EACf;EAEA;;;;;EAKO2B,wBAAwBA,CAAChB,QAAgB;IAC5C,IAAI,CAACK,qBAAqB,CAAC,IAAI,CAACb,oBAAoB,EAAEQ,QAAQ,CAAC;IAE/D,OAAO,IAAI;EACf;EAEA;;;;;;;EAOOiB,uBAAuBA,CAACjB,QAAgB,EAAEC,MAAc,EAAEX,OAAgB;IAC7E,IAAI,CAAC,IAAI,CAACxD,sBAAsB,EAAE;MAC9B,IAAI,CAACA,sBAAsB,GAAG,EAAE;;IAGpC,IAAI,CAACgE,kBAAkB,CAAC,IAAI,CAAChE,sBAAsB,EAAEkE,QAAQ,EAAEC,MAAM,EAAEX,OAAO,CAAC;IAE/E,OAAO,IAAI;EACf;EAEA;;;;;EAKO4B,0BAA0BA,CAAClB,QAAgB;IAC9C,IAAI,CAACK,qBAAqB,CAAC,IAAI,CAACvE,sBAAsB,EAAEkE,QAAQ,CAAC;IAEjE,OAAO,IAAI;EACf;EAEA;;;;;;;EAOOmB,mBAAmBA,CAACnB,QAAgB,EAAEC,MAAc,EAAEX,OAAgB;IACzE,IAAI,CAAC,IAAI,CAAC/C,kBAAkB,EAAE;MAC1B,IAAI,CAACA,kBAAkB,GAAG,EAAE;;IAGhC,IAAI,CAACuD,kBAAkB,CAAC,IAAI,CAACvD,kBAAkB,EAAEyD,QAAQ,EAAEC,MAAM,EAAEX,OAAO,CAAC;IAE3E,OAAO,IAAI;EACf;EAEA;;;;;EAKO8B,sBAAsBA,CAACpB,QAAgB;IAC1C,IAAI,CAACK,qBAAqB,CAAC,IAAI,CAAC9D,kBAAkB,EAAEyD,QAAQ,CAAC;IAE7D,OAAO,IAAI;EACf;EAEA;;;;;;;EAOOqB,wBAAwBA,CAACrB,QAAgB,EAAEC,MAAc,EAAEX,OAAgB;IAC9E,IAAI,CAAC,IAAI,CAAC1C,uBAAuB,EAAE;MAC/B,IAAI,CAACA,uBAAuB,GAAG,EAAE;;IAGrC,IAAI,CAACkD,kBAAkB,CAAC,IAAI,CAAClD,uBAAuB,EAAEoD,QAAQ,EAAEC,MAAM,EAAEX,OAAO,CAAC;IAEhF,OAAO,IAAI;EACf;EAEA;;;;;EAKOgC,2BAA2BA,CAACtB,QAAgB;IAC/C,IAAI,CAACK,qBAAqB,CAAC,IAAI,CAACzD,uBAAuB,EAAEoD,QAAQ,CAAC;IAElE,OAAO,IAAI;EACf;EAEA;;;;;;;EAOOuB,eAAeA,CAACvB,QAAgB,EAAEC,MAAc,EAAEX,OAAgB;IACrE,IAAI,CAAC,IAAI,CAAClC,cAAc,EAAE;MACtB,IAAI,CAACA,cAAc,GAAG,EAAE;;IAG5B,IAAI,CAAC0C,kBAAkB,CAAC,IAAI,CAAC1C,cAAc,EAAE4C,QAAQ,EAAEC,MAAM,EAAEX,OAAO,CAAC;IAEvE,OAAO,IAAI;EACf;EAEA;;;;;EAKOkC,kBAAkBA,CAACxB,QAAgB;IACtC,IAAI,CAACK,qBAAqB,CAAC,IAAI,CAACjD,cAAc,EAAE4C,QAAQ,CAAC;IAEzD,OAAO,IAAI;EACf;EAEA;;;;;;;EAOOyB,mBAAmBA,CAACzB,QAAgB,EAAEC,MAAc,EAAEX,OAAgB;IACzE,IAAI,CAAC,IAAI,CAACoC,kBAAkB,EAAE;MAC1B,IAAI,CAACA,kBAAkB,GAAG,EAAE;;IAGhC,IAAI,CAAC5B,kBAAkB,CAAC,IAAI,CAAC4B,kBAAkB,EAAE1B,QAAQ,EAAEC,MAAM,EAAEX,OAAO,CAAC;IAC3E,OAAO,IAAI;EACf;EAEA;;;;;EAKOqC,sBAAsBA,CAAC3B,QAAgB;IAC1C,IAAI,CAACK,qBAAqB,CAAC,IAAI,CAACqB,kBAAkB,EAAE1B,QAAQ,CAAC;IAE7D,OAAO,IAAI;EACf;EAEA;;;;;;;EAOO4B,oBAAoBA,CAAC5B,QAAgB,EAAEC,MAAc,EAAEX,OAAgB;IAC1E,IAAI,CAAC,IAAI,CAACuC,mBAAmB,EAAE;MAC3B,IAAI,CAACA,mBAAmB,GAAG,EAAE;;IAGjC,IAAI,CAAC/B,kBAAkB,CAAC,IAAI,CAAC+B,mBAAmB,EAAE7B,QAAQ,EAAEC,MAAM,EAAEX,OAAO,CAAC;IAC5E,OAAO,IAAI;EACf;EAEA;;;;;EAKOwC,uBAAuBA,CAAC9B,QAAgB;IAC3C,IAAI,CAACK,qBAAqB,CAAC,IAAI,CAACwB,mBAAmB,EAAE7B,QAAQ,CAAC;IAE9D,OAAO,IAAI;EACf;EAEQ+B,0BAA0BA,CAAA;IAC9B,IAAI,CAAC,IAAI,CAACC,cAAc,IAAI,CAAC,IAAI,CAACA,cAAc,CAAC7O,MAAM,IAAI,IAAI,CAAC8O,qBAAqB,IAAI,CAAC,IAAI,CAACvJ,MAAM,EAAE;MACnG;;IAGJ,MAAMyB,IAAI,GAAG,IAAI+H,UAAU,CAAC,IAAI,CAAC5L,gBAAgB,GAAG,CAAC,CAAC;IACtD,MAAM6L,QAAQ,GAAGpQ,SAAS,CAACD,MAAM,CAAC,CAAC,CAAC;IAEpC,KAAK,IAAIkM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC1H,gBAAgB,EAAE0H,CAAC,EAAE,EAAE;MAC5C,MAAMnD,KAAK,GAAGmD,CAAC,GAAG,IAAI,CAAC1H,gBAAgB;MAEvCrG,cAAc,CAAC8K,kBAAkB,CAACF,KAAK,EAAE,IAAI,CAACmH,cAAc,EAAE,CAAChH,eAAe,EAAEC,YAAY,EAAEC,KAAK,KAAI;QACnGpJ,MAAM,CAAC0J,SAAS,CAAkBR,eAAgB,CAACS,KAAK,EAAmBR,YAAa,CAACQ,KAAK,EAAEP,KAAK,EAAEiH,QAAQ,CAAC;QAChHhI,IAAI,CAAC6D,CAAC,GAAG,CAAC,CAAC,GAAGmE,QAAQ,CAACC,CAAC,GAAG,GAAG;QAC9BjI,IAAI,CAAC6D,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGmE,QAAQ,CAACE,CAAC,GAAG,GAAG;QAClClI,IAAI,CAAC6D,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGmE,QAAQ,CAAC/B,CAAC,GAAG,GAAG;QAClCjG,IAAI,CAAC6D,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,GAAG;MACzB,CAAC,CAAC;;IAGN,IAAI,CAACiE,qBAAqB,GAAGtR,UAAU,CAAC2R,iBAAiB,CAACnI,IAAI,EAAE,IAAI,CAAC7D,gBAAgB,EAAE,CAAC,EAAE,IAAI,CAACoC,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE;EACzH;EAEA;;;;;EAKO6J,gBAAgBA,CAAA;IACnB,OAAO,IAAI,CAACP,cAAc;EAC9B;EAEA;EACOQ,qBAAqBA,CAAA;IACxB,IAAI,CAACC,wBAAwB,EAAE;EACnC;EAEQA,wBAAwBA,CAAA;IAC5B,IAAI,CAAC,IAAI,CAACT,cAAc,EAAE;MACtB;;IAGJ,IAAI,CAACA,cAAc,CAAC7B,IAAI,CAAC,CAACtE,CAAC,EAAEuE,CAAC,KAAI;MAC9B,IAAIvE,CAAC,CAACmE,QAAQ,GAAGI,CAAC,CAACJ,QAAQ,EAAE;QACzB,OAAO,CAAC,CAAC;OACZ,MAAM,IAAInE,CAAC,CAACmE,QAAQ,GAAGI,CAAC,CAACJ,QAAQ,EAAE;QAChC,OAAO,CAAC;;MAGZ,OAAO,CAAC;IACZ,CAAC,CAAC;IAEF,IAAI,IAAI,CAACiC,qBAAqB,EAAE;MAC5B,IAAI,CAACA,qBAAqB,CAACS,OAAO,EAAE;MACpC,IAAI,CAACT,qBAAqB,GAAG,IAAI;;IAGrC,IAAI,CAACF,0BAA0B,EAAE;EACrC;EAEA;;;;;;EAMOY,eAAeA,CAAC3C,QAAgB,EAAEvE,KAAa;IAClD,IAAI,CAAC,IAAI,CAACuG,cAAc,EAAE;MACtB,IAAI,CAACA,cAAc,GAAG,EAAE;;IAG5B,MAAMY,YAAY,GAAG,IAAI5S,cAAc,CAACgQ,QAAQ,EAAEvE,KAAK,CAAC;IACxD,IAAI,CAACuG,cAAc,CAACjL,IAAI,CAAC6L,YAAY,CAAC;IAEtC,IAAI,CAACH,wBAAwB,EAAE;IAE/B,OAAO,IAAI;EACf;EAEA;;;;;EAKOI,kBAAkBA,CAAC7C,QAAgB;IACtC,IAAI,CAAC8C,yBAAyB,CAAC9C,QAAQ,EAAE,IAAI,CAACgC,cAAc,EAAE,IAAI,CAACC,qBAAqB,CAAC;IACzF,IAAI,CAACA,qBAAqB,GAAG,IAAI;IAEjC,IAAI,IAAI,CAACD,cAAc,IAAI,IAAI,CAACA,cAAc,CAAC7O,MAAM,GAAG,CAAC,EAAE;MACvD,IAAI,CAAC4O,0BAA0B,EAAE;;IAGrC,OAAO,IAAI;EACf;EAEA;;;;;;;EAOOgB,gBAAgBA,CAAC/C,QAAgB,EAAEgD,MAAc,EAAEC,MAAe;IACrE,IAAI,CAAC,IAAI,CAACnI,eAAe,EAAE;MACvB,IAAI,CAACA,eAAe,GAAG,EAAE;;IAG7B,MAAMoI,aAAa,GAAG,IAAInT,aAAa,CAACiQ,QAAQ,EAAEgD,MAAM,EAAEC,MAAM,CAAC;IACjE,IAAI,CAACnI,eAAe,CAAC/D,IAAI,CAACmM,aAAa,CAAC;IAExC,IAAI,CAACpI,eAAe,CAACqF,IAAI,CAAC,CAACtE,CAAC,EAAEuE,CAAC,KAAI;MAC/B,IAAIvE,CAAC,CAACmE,QAAQ,GAAGI,CAAC,CAACJ,QAAQ,EAAE;QACzB,OAAO,CAAC,CAAC;OACZ,MAAM,IAAInE,CAAC,CAACmE,QAAQ,GAAGI,CAAC,CAACJ,QAAQ,EAAE;QAChC,OAAO,CAAC;;MAGZ,OAAO,CAAC;IACZ,CAAC,CAAC;IAEF,OAAO,IAAI;EACf;EAEA;;;;;EAKOmD,mBAAmBA,CAACnD,QAAgB;IACvC,IAAI,CAAC,IAAI,CAAClF,eAAe,EAAE;MACvB,OAAO,IAAI;;IAGf,IAAIT,KAAK,GAAG,CAAC;IACb,KAAK,MAAM6I,aAAa,IAAI,IAAI,CAACpI,eAAe,EAAE;MAC9C,IAAIoI,aAAa,CAAClD,QAAQ,KAAKA,QAAQ,EAAE;QACrC,IAAI,CAAClF,eAAe,CAACyF,MAAM,CAAClG,KAAK,EAAE,CAAC,CAAC;QACrC;;MAEJA,KAAK,EAAE;;IAGX,OAAO,IAAI;EACf;EAEA;;;EAGO+I,cAAcA,CAAA;IACjB,KAAK,MAAMC,YAAY,IAAI,IAAI,CAAC9J,aAAa,EAAE;MAC3C,IAAI8J,YAAY,EAAE;QACd,KAAK,MAAMC,WAAW,IAAID,YAAY,EAAE;UACpCC,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEZ,OAAO,EAAE;;;;IAKlC,IAAI,CAACnJ,aAAa,GAAG,EAAE;EAC3B;EAEQwE,OAAOA,CAACwF,CAAS,EAAEC,CAAS,EAAEtF,KAAa,EAAEC,MAAc,EAAEsF,MAAkB;IACnFF,CAAC,GAAGnM,IAAI,CAACsM,GAAG,CAACH,CAAC,CAAC,GAAG,GAAG,GAAG,GAAG;IAC3BC,CAAC,GAAGpM,IAAI,CAACsM,GAAG,CAACF,CAAC,CAAC,GAAG,GAAG,GAAG,GAAG;IAE3B,MAAMG,QAAQ,GAAIJ,CAAC,GAAGrF,KAAK,GAAIA,KAAK,GAAG,CAAC;IACxC,MAAM0F,QAAQ,GAAIJ,CAAC,GAAGrF,MAAM,GAAIA,MAAM,GAAG,CAAC;IAE1C,MAAMP,QAAQ,GAAG,CAAC+F,QAAQ,GAAGC,QAAQ,GAAG1F,KAAK,IAAI,CAAC;IAClD,OAAOuF,MAAM,CAAC7F,QAAQ,CAAC,GAAG,GAAG;EACjC;EAEU3G,MAAMA,CAAA;IACZ,IAAI,CAAClE,YAAY,EAAE;EACvB;EAEQA,YAAYA,CAAA;IAChB,IAAI,IAAI,CAAC8Q,aAAa,EAAE;MACpB,IAAI,CAACA,aAAa,CAACnB,OAAO,EAAE;MAC5B,IAAI,CAACmB,aAAa,GAAG,IAAI;;IAG7B,IAAI,IAAI,CAACC,aAAa,EAAE;MACpB,IAAI,CAACA,aAAa,CAACpB,OAAO,EAAE;MAC5B,IAAI,CAACoB,aAAa,GAAG,IAAI;;IAG7B,IAAI,IAAI,CAACzK,kBAAkB,EAAE;MACzB,IAAI,CAACrF,OAAO,CAAC+P,wBAAwB,CAAC,IAAI,CAAC1K,kBAAkB,CAAC;MAC9D,IAAI,CAACA,kBAAkB,GAAG,IAAI;;IAGlC,IAAI,CAACK,oBAAoB,EAAE;EAC/B;EAEQA,oBAAoBA,CAAA;IACxB,IAAI,CAACsK,iBAAiB,GAAG,IAAI,CAAC7P,cAAc,GAAG,EAAE,GAAG,EAAE;IACtD,IAAI,IAAI,CAACsE,wBAAwB,EAAE;MAC/B,IAAI,CAACuL,iBAAiB,IAAI,CAAC;;IAG/B,IAAI,CAAC,IAAI,CAACC,iBAAiB,IAAI,IAAI,CAACC,aAAa,KAAK7R,cAAc,CAAC8R,uBAAuB,IAAI,IAAI,CAACD,aAAa,KAAK7R,cAAc,CAAC+R,6BAA6B,EAAE;MACjK,IAAI,CAACJ,iBAAiB,IAAI,CAAC;;IAG/B,IAAI,IAAI,CAACnR,iBAAiB,EAAE;MACxB,IAAI,CAACmR,iBAAiB,IAAI,CAAC;;IAG/B,MAAMK,MAAM,GAAG,IAAI,CAACrQ,OAAO;IAC3B,MAAMsQ,UAAU,GAAG,IAAI,CAACN,iBAAiB,IAAI,IAAI,CAAC7P,cAAc,GAAG,CAAC,GAAG,CAAC,CAAC;IACzE,IAAI,CAACoQ,WAAW,GAAG,IAAIC,YAAY,CAAC,IAAI,CAACjM,SAAS,GAAG+L,UAAU,CAAC;IAChE,IAAI,CAACT,aAAa,GAAG,IAAIpT,MAAM,CAAC4T,MAAM,EAAE,IAAI,CAACE,WAAW,EAAE,IAAI,EAAED,UAAU,CAAC;IAE3E,IAAIG,UAAU,GAAG,CAAC;IAClB,MAAMC,SAAS,GAAG,IAAI,CAACb,aAAa,CAACc,kBAAkB,CAACnU,YAAY,CAACoU,YAAY,EAAEH,UAAU,EAAE,CAAC,EAAE,IAAI,CAACT,iBAAiB,EAAE,IAAI,CAAC7P,cAAc,CAAC;IAC9I,IAAI,CAACK,cAAc,CAAChE,YAAY,CAACoU,YAAY,CAAC,GAAGF,SAAS;IAC1DD,UAAU,IAAI,CAAC;IAEf,MAAMI,MAAM,GAAG,IAAI,CAAChB,aAAa,CAACc,kBAAkB,CAACnU,YAAY,CAACsU,SAAS,EAAEL,UAAU,EAAE,CAAC,EAAE,IAAI,CAACT,iBAAiB,EAAE,IAAI,CAAC7P,cAAc,CAAC;IACxI,IAAI,CAACK,cAAc,CAAChE,YAAY,CAACsU,SAAS,CAAC,GAAGD,MAAM;IACpDJ,UAAU,IAAI,CAAC;IAEf,MAAMM,OAAO,GAAG,IAAI,CAAClB,aAAa,CAACc,kBAAkB,CAAC,OAAO,EAAEF,UAAU,EAAE,CAAC,EAAE,IAAI,CAACT,iBAAiB,EAAE,IAAI,CAAC7P,cAAc,CAAC;IAC1H,IAAI,CAACK,cAAc,CAAC,OAAO,CAAC,GAAGuQ,OAAO;IACtCN,UAAU,IAAI,CAAC;IAEf,MAAMxF,IAAI,GAAG,IAAI,CAAC4E,aAAa,CAACc,kBAAkB,CAAC,MAAM,EAAEF,UAAU,EAAE,CAAC,EAAE,IAAI,CAACT,iBAAiB,EAAE,IAAI,CAAC7P,cAAc,CAAC;IACtH,IAAI,CAACK,cAAc,CAAC,MAAM,CAAC,GAAGyK,IAAI;IAClCwF,UAAU,IAAI,CAAC;IAEf,IAAI,IAAI,CAAChM,wBAAwB,EAAE;MAC/B,MAAMuM,eAAe,GAAG,IAAI,CAACnB,aAAa,CAACc,kBAAkB,CAAC,WAAW,EAAEF,UAAU,EAAE,CAAC,EAAE,IAAI,CAACT,iBAAiB,EAAE,IAAI,CAAC7P,cAAc,CAAC;MACtI,IAAI,CAACK,cAAc,CAAC,WAAW,CAAC,GAAGwQ,eAAe;MAClDP,UAAU,IAAI,CAAC;;IAGnB,IAAI,CAAC,IAAI,CAACR,iBAAiB,IAAI,IAAI,CAACC,aAAa,KAAK7R,cAAc,CAAC8R,uBAAuB,IAAI,IAAI,CAACD,aAAa,KAAK7R,cAAc,CAAC+R,6BAA6B,EAAE;MACjK,MAAMa,eAAe,GAAG,IAAI,CAACpB,aAAa,CAACc,kBAAkB,CAAC,WAAW,EAAEF,UAAU,EAAE,CAAC,EAAE,IAAI,CAACT,iBAAiB,EAAE,IAAI,CAAC7P,cAAc,CAAC;MACtI,IAAI,CAACK,cAAc,CAAC,WAAW,CAAC,GAAGyQ,eAAe;MAClDR,UAAU,IAAI,CAAC;;IAGnB,IAAI,IAAI,CAAC5R,iBAAiB,EAAE;MACxB,MAAMqS,cAAc,GAAG,IAAI,CAACrB,aAAa,CAACc,kBAAkB,CAAC,WAAW,EAAEF,UAAU,EAAE,CAAC,EAAE,IAAI,CAACT,iBAAiB,EAAE,IAAI,CAAC7P,cAAc,CAAC;MACrI,IAAI,CAACK,cAAc,CAAC,WAAW,CAAC,GAAG0Q,cAAc;MACjDT,UAAU,IAAI,CAAC;;IAGnB,IAAIU,OAAqB;IACzB,IAAI,IAAI,CAAChR,cAAc,EAAE;MACrB,MAAMiR,UAAU,GAAG,IAAIZ,YAAY,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;MAC7D,IAAI,CAACV,aAAa,GAAG,IAAIrT,MAAM,CAAC4T,MAAM,EAAEe,UAAU,EAAE,KAAK,EAAE,CAAC,CAAC;MAC7DD,OAAO,GAAG,IAAI,CAACrB,aAAa,CAACa,kBAAkB,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC;KAClE,MAAM;MACHQ,OAAO,GAAG,IAAI,CAACtB,aAAa,CAACc,kBAAkB,CAAC,QAAQ,EAAEF,UAAU,EAAE,CAAC,EAAE,IAAI,CAACT,iBAAiB,EAAE,IAAI,CAAC7P,cAAc,CAAC;MACrHsQ,UAAU,IAAI,CAAC;;IAEnB,IAAI,CAACjQ,cAAc,CAAC,QAAQ,CAAC,GAAG2Q,OAAO;IAEvC,IAAI,CAAC/B,cAAc,EAAE;EACzB;EAEQ3J,kBAAkBA,CAAA;IACtB,IAAI,IAAI,CAACtF,cAAc,EAAE;MACrB,IAAI,CAACkR,8BAA8B,GAAG,IAAI,CAACrR,OAAO,CAACsR,iBAAiB,CAAC,IAAIC,WAAW,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;MACrH;;IAEJ,MAAMC,OAAO,GAAG,EAAE;IAClB,MAAMC,gBAAgB,GAAG,EAAE;IAC3B,IAAIpL,KAAK,GAAG,CAAC;IACb,KAAK,IAAIqL,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,IAAI,CAACnN,SAAS,EAAEmN,KAAK,EAAE,EAAE;MACjDF,OAAO,CAACzO,IAAI,CAACsD,KAAK,CAAC;MACnBmL,OAAO,CAACzO,IAAI,CAACsD,KAAK,GAAG,CAAC,CAAC;MACvBmL,OAAO,CAACzO,IAAI,CAACsD,KAAK,GAAG,CAAC,CAAC;MACvBmL,OAAO,CAACzO,IAAI,CAACsD,KAAK,CAAC;MACnBmL,OAAO,CAACzO,IAAI,CAACsD,KAAK,GAAG,CAAC,CAAC;MACvBmL,OAAO,CAACzO,IAAI,CAACsD,KAAK,GAAG,CAAC,CAAC;MACvBoL,gBAAgB,CAAC1O,IAAI,CAACsD,KAAK,EAAEA,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,CAAC,EAAEA,KAAK,EAAEA,KAAK,EAAEA,KAAK,GAAG,CAAC,CAAC;MACvHA,KAAK,IAAI,CAAC;;IAGd,IAAI,CAAC3F,YAAY,GAAG,IAAI,CAACV,OAAO,CAACsR,iBAAiB,CAACE,OAAO,CAAC;IAC3D,IAAI,CAACG,iBAAiB,GAAG,IAAI,CAAC3R,OAAO,CAACsR,iBAAiB,CAACG,gBAAgB,CAAC;EAC7E;EAEA;;;;EAIOG,WAAWA,CAAA;IACd,OAAO,IAAI,CAACrN,SAAS;EACzB;EAEA;;;;EAIOhF,OAAOA,CAAA;IACV,OAAO,IAAI,CAACsS,MAAM;EACtB;EAEA;;;;EAIOC,SAASA,CAAA;IACZ,OAAO,IAAI,CAAC/P,QAAQ;EACxB;EAEQgQ,+BAA+BA,CAAA;IACnC,IAAI,CAAC7O,YAAY,GAAG,IAAI5B,KAAK,EAAqB;IAClD,IAAI,IAAI,CAAC6B,WAAW,EAAE;MAClB,IAAI,CAACA,WAAW,CAACK,OAAO,CAAEC,UAAU,IAAI;QACpC,IAAIA,UAAU,YAAYpF,cAAc,EAAE;UACtC,IAAI,CAAC6E,YAAY,CAACH,IAAI,CAAC,CAAC,IAAIvF,UAAU,CAACiG,UAAU,CAAC,CAAC,CAAC;SACvD,MAAM,IAAIA,UAAU,YAAYjG,UAAU,EAAE;UACzC,IAAI,CAAC0F,YAAY,CAACH,IAAI,CAAC,CAACU,UAAU,CAAC,CAAC;SACvC,MAAM,IAAIA,UAAU,YAAYnC,KAAK,EAAE;UACpC,IAAI,CAAC4B,YAAY,CAACH,IAAI,CAACU,UAAU,CAAC;;MAE1C,CAAC,CAAC;;EAEV;EAEA;;;;EAIOM,KAAKA,CAACiO,KAAK,GAAG,IAAI,CAACC,UAAU;;IAChC,IAAI,CAAC,IAAI,CAACC,kBAAkB,IAAI,IAAI,CAACC,uCAAuC,EAAE,EAAE;MAC5E,MAAM,6HAA6H;;IAEvI,IAAIH,KAAK,EAAE;MACPI,UAAU,CAAC,MAAK;QACZ,IAAI,CAACrO,KAAK,CAAC,CAAC,CAAC;MACjB,CAAC,EAAEiO,KAAK,CAAC;MACT;;IAEJ;IACA,IAAI,CAACD,+BAA+B,EAAE;IAEtC,IAAI,CAAChQ,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACzC,QAAQ,GAAG,KAAK;IACrB,IAAI,CAAC0C,YAAY,GAAG,CAAC;IACrB,IAAI,IAAI,CAACkB,YAAY,IAAI,IAAI,CAACA,YAAY,CAAC/D,MAAM,IAAI,CAAC,EAAE;MACpD,IAAI,CAACmF,gBAAgB,GAAG,IAAIhD,KAAK,EAAkB;;IAGvD;IACA,IAAI,IAAI,CAACoM,kBAAkB,EAAE;MACzB,IAAI,IAAI,CAACA,kBAAkB,CAACvO,MAAM,GAAG,CAAC,EAAE;QACpC,IAAI,CAACkT,wBAAwB,GAAG,IAAI,CAAC3E,kBAAkB,CAAC,CAAC,CAAC;QAC1D,IAAI,CAACzL,iBAAiB,GAAG,IAAI,CAACoQ,wBAAwB,CAACnK,SAAS,EAAE;QAClE,IAAI,CAAChG,iBAAiB,GAAG,IAAI,CAACD,iBAAiB;;MAEnD,IAAI,IAAI,CAACyL,kBAAkB,CAACvO,MAAM,GAAG,CAAC,EAAE;QACpC,IAAI,CAAC+C,iBAAiB,GAAG,IAAI,CAACwL,kBAAkB,CAAC,CAAC,CAAC,CAACxF,SAAS,EAAE;;;IAGvE;IACA,IAAI,IAAI,CAAC2F,mBAAmB,EAAE;MAC1B,IAAI,IAAI,CAACA,mBAAmB,CAAC1O,MAAM,GAAG,CAAC,EAAE;QACrC,IAAI,CAACmT,yBAAyB,GAAG,IAAI,CAACzE,mBAAmB,CAAC,CAAC,CAAC;QAC5D,IAAI,CAAC1L,kBAAkB,GAAG,IAAI,CAACmQ,yBAAyB,CAACpK,SAAS,EAAE;QACpE,IAAI,CAAC9F,kBAAkB,GAAG,IAAI,CAACD,kBAAkB;;MAErD,IAAI,IAAI,CAAC0L,mBAAmB,CAAC1O,MAAM,GAAG,CAAC,EAAE;QACrC,IAAI,CAACiD,kBAAkB,GAAG,IAAI,CAACyL,mBAAmB,CAAC,CAAC,CAAC,CAAC3F,SAAS,EAAE;;;IAIzE,IAAI,IAAI,CAACqK,aAAa,EAAE;MACpB,IAAI,EAAA5S,EAAA,OAAI,CAAC6S,OAAO,cAAA7S,EAAA,uBAAAA,EAAA,CAAEP,YAAY,GAAGqT,OAAO,CAAC,MAAM,CAAC,MAAK,CAAC,CAAC,EAAE;QACpD,IAAI,CAACD,OAAe,CAACE,kBAAkB,CAAC,IAAI,CAAC;;MAGlD,MAAMC,wBAAwB,GAAG,IAAI,CAAC5M,YAAiC;MAEvE,IAAI4M,wBAAwB,IAAIA,wBAAwB,CAACC,qBAAqB,EAAE;QAC5ED,wBAAwB,CAACC,qBAAqB,CAACC,OAAO,CAAC,MAAK;UACxDT,UAAU,CAAC,MAAK;YACZ,KAAK,IAAI/L,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,IAAI,CAACkM,aAAa,EAAElM,KAAK,EAAE,EAAE;cACrD,IAAI,CAACyM,OAAO,CAAC,IAAI,CAAC;cAClBH,wBAAwB,CAACI,MAAM,EAAE;;UAEzC,CAAC,CAAC;QACN,CAAC,CAAC;OACL,MAAM;QACH,KAAK,IAAI1M,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,IAAI,CAACkM,aAAa,EAAElM,KAAK,EAAE,EAAE;UACrD,IAAI,CAACyM,OAAO,CAAC,IAAI,CAAC;;;;IAK9B;IACA,IAAI,IAAI,CAACE,qBAAqB,IAAI,IAAI,CAACC,UAAU,IAAI,IAAI,CAACA,UAAU,CAAC9T,MAAM,GAAG,CAAC,IAAI,IAAI,CAACuF,MAAM,EAAE;MAC5F,IAAI,CAACA,MAAM,CAACwO,cAAc,CAAC,IAAI,EAAE,IAAI,CAACC,kBAAkB,EAAE,IAAI,CAACC,gBAAgB,EAAE,IAAI,CAACC,kBAAkB,CAAC;;EAEjH;EAEA;;;;EAIOxH,IAAIA,CAACyH,eAAe,GAAG,IAAI;IAC9B,IAAI,IAAI,CAAChU,QAAQ,EAAE;MACf;;IAGJ,IAAI,CAAC+B,mBAAmB,CAACkS,eAAe,CAAC,IAAI,CAAC;IAE9C,IAAI,CAACjU,QAAQ,GAAG,IAAI;IAEpB,IAAIgU,eAAe,EAAE;MACjB,IAAI,CAACE,gBAAgB,EAAE;;EAE/B;EAEA;EAEA;;;EAGOC,KAAKA,CAAA;IACR,IAAI,CAAClS,eAAe,CAACpC,MAAM,GAAG,CAAC;IAC/B,IAAI,CAACF,UAAU,CAACE,MAAM,GAAG,CAAC;EAC9B;EAEA;;;EAGOuU,qBAAqBA,CAACrN,KAAa,EAAE1D,QAAkB,EAAEgR,OAAe,EAAEC,OAAe;IAC5F,IAAIC,MAAM,GAAGxN,KAAK,GAAG,IAAI,CAAC2J,iBAAiB;IAE3C,IAAI,CAACO,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGlR,QAAQ,CAACiH,QAAQ,CAACI,CAAC,GAAG,IAAI,CAAC8J,WAAW,CAAC9J,CAAC;IACrE,IAAI,CAACuG,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGlR,QAAQ,CAACiH,QAAQ,CAACK,CAAC,GAAG,IAAI,CAAC6J,WAAW,CAAC7J,CAAC;IACrE,IAAI,CAACsG,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGlR,QAAQ,CAACiH,QAAQ,CAACS,CAAC,GAAG,IAAI,CAACyJ,WAAW,CAACzJ,CAAC;IACrE,IAAI,CAACkG,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGlR,QAAQ,CAAC8E,KAAK,CAAC2G,CAAC;IAC7C,IAAI,CAACmC,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGlR,QAAQ,CAAC8E,KAAK,CAAC4G,CAAC;IAC7C,IAAI,CAACkC,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGlR,QAAQ,CAAC8E,KAAK,CAAC2E,CAAC;IAC7C,IAAI,CAACmE,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGlR,QAAQ,CAAC8E,KAAK,CAACI,CAAC;IAC7C,IAAI,CAAC0I,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGlR,QAAQ,CAAC0F,KAAK;IAE3C,IAAI,CAACkI,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGlR,QAAQ,CAACuE,KAAK,CAAC8C,CAAC,GAAGrH,QAAQ,CAACsI,IAAI;IAC7D,IAAI,CAACsF,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGlR,QAAQ,CAACuE,KAAK,CAAC+C,CAAC,GAAGtH,QAAQ,CAACsI,IAAI;IAE7D,IAAI,IAAI,CAACxG,wBAAwB,EAAE;MAC/B,IAAI,CAAC8L,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGlR,QAAQ,CAACoR,SAAS;;IAGnD,IAAI,CAAC,IAAI,CAAC9D,iBAAiB,EAAE;MACzB,IAAItN,QAAQ,CAACqR,iBAAiB,EAAE;QAC5B,IAAIC,gBAAgB,GAAGtR,QAAQ,CAACqR,iBAAiB;QACjD,IAAI,IAAI,CAACxR,OAAO,EAAE;UACdrG,OAAO,CAAC+X,oBAAoB,CAACD,gBAAgB,EAAE,IAAI,CAACtK,mBAAmB,EAAEtN,UAAU,CAACF,OAAO,CAAC,CAAC,CAAC,CAAC;UAC/F8X,gBAAgB,GAAG5X,UAAU,CAACF,OAAO,CAAC,CAAC,CAAC;;QAE5C,IAAI8X,gBAAgB,CAACjK,CAAC,KAAK,CAAC,IAAIiK,gBAAgB,CAAC5J,CAAC,KAAK,CAAC,EAAE;UACtD4J,gBAAgB,CAACjK,CAAC,GAAG,KAAK;;QAG9B,IAAI,CAACuG,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGI,gBAAgB,CAACjK,CAAC;QAC/C,IAAI,CAACuG,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGI,gBAAgB,CAAChK,CAAC;QAC/C,IAAI,CAACsG,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGI,gBAAgB,CAAC5J,CAAC;OAClD,MAAM;QACH,IAAI1B,SAAS,GAAGhG,QAAQ,CAACgG,SAAS;QAClC,IAAI,IAAI,CAACnG,OAAO,EAAE;UACdrG,OAAO,CAAC+X,oBAAoB,CAACvL,SAAS,EAAE,IAAI,CAACgB,mBAAmB,EAAEtN,UAAU,CAACF,OAAO,CAAC,CAAC,CAAC,CAAC;UACxFwM,SAAS,GAAGtM,UAAU,CAACF,OAAO,CAAC,CAAC,CAAC;;QAGrC,IAAIwM,SAAS,CAACqB,CAAC,KAAK,CAAC,IAAIrB,SAAS,CAAC0B,CAAC,KAAK,CAAC,EAAE;UACxC1B,SAAS,CAACqB,CAAC,GAAG,KAAK;;QAEvB,IAAI,CAACuG,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGlL,SAAS,CAACqB,CAAC;QACxC,IAAI,CAACuG,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGlL,SAAS,CAACsB,CAAC;QACxC,IAAI,CAACsG,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGlL,SAAS,CAAC0B,CAAC;;KAE/C,MAAM,IAAI,IAAI,CAAC6F,aAAa,KAAK7R,cAAc,CAAC8R,uBAAuB,IAAI,IAAI,CAACD,aAAa,KAAK7R,cAAc,CAAC+R,6BAA6B,EAAE;MAC7I,IAAI,CAACG,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGlR,QAAQ,CAACgG,SAAS,CAACqB,CAAC;MACjD,IAAI,CAACuG,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGlR,QAAQ,CAACgG,SAAS,CAACsB,CAAC;MACjD,IAAI,CAACsG,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGlR,QAAQ,CAACgG,SAAS,CAAC0B,CAAC;;IAGrD,IAAI,IAAI,CAACxL,iBAAiB,IAAI8D,QAAQ,CAAC4I,SAAS,EAAE;MAC9C,IAAI,CAACgF,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGlR,QAAQ,CAAC4I,SAAS,CAACvB,CAAC;MACjD,IAAI,CAACuG,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGlR,QAAQ,CAAC4I,SAAS,CAACtB,CAAC;MACjD,IAAI,CAACsG,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGlR,QAAQ,CAAC4I,SAAS,CAAClB,CAAC;MACjD,IAAI,CAACkG,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGlR,QAAQ,CAAC4I,SAAS,CAACE,CAAC;;IAGrD,IAAI,CAAC,IAAI,CAACtL,cAAc,EAAE;MACtB,IAAI,IAAI,CAACsE,wBAAwB,EAAE;QAC/B,IAAIkP,OAAO,KAAK,CAAC,EAAE;UACfA,OAAO,GAAG,IAAI,CAACnP,QAAQ;SAC1B,MAAM,IAAImP,OAAO,KAAK,CAAC,EAAE;UACtBA,OAAO,GAAG,CAAC,GAAG,IAAI,CAACnP,QAAQ;;QAG/B,IAAIoP,OAAO,KAAK,CAAC,EAAE;UACfA,OAAO,GAAG,IAAI,CAACpP,QAAQ;SAC1B,MAAM,IAAIoP,OAAO,KAAK,CAAC,EAAE;UACtBA,OAAO,GAAG,CAAC,GAAG,IAAI,CAACpP,QAAQ;;;MAInC,IAAI,CAAC+L,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGF,OAAO;MACpC,IAAI,CAACpD,WAAW,CAACsD,MAAM,EAAE,CAAC,GAAGD,OAAO;;EAE5C;EAkBQJ,gBAAgBA,CAAA;IACpB,IAAI,CAAC,IAAI,CAAClP,gBAAgB,EAAE;MACxB;;IAEJ,IAAI,CAACA,gBAAgB,CAACd,OAAO,CAAEW,SAAS,IAAI;MACxCA,SAAS,CAAC0H,IAAI,CAAC,IAAI,CAAC;IACxB,CAAC,CAAC;IACF,IAAI,CAACvH,gBAAgB,GAAG,IAAIhD,KAAK,EAAkB;EACvD;EA0BQ6S,eAAeA,CAAA;IACnB,IAAI,CAAC,IAAI,CAAC9P,mBAAmB,EAAE;MAC3B;;IAGJ,MAAMgC,KAAK,GAAG,IAAI,CAAChC,mBAAmB,CAACC,gBAAgB,CAACmO,OAAO,CAAC,IAAI,CAAC;IACrE,IAAIpM,KAAK,KAAK,CAAC,CAAC,EAAE;MACd,IAAI,CAAChC,mBAAmB,CAACC,gBAAgB,CAACiI,MAAM,CAAClG,KAAK,EAAE,CAAC,CAAC;;IAG9D,IAAI,CAAChC,mBAAmB,GAAG,IAAI;EACnC;EAmBA;EAEQ+P,OAAOA,CAACC,YAAoB;IAChC;IACA,IAAI,CAACxC,MAAM,GAAG,IAAI,CAAC5S,UAAU,CAACE,MAAM,GAAG,CAAC;IAExC,IAAmB,IAAI,CAACqT,OAAQ,CAAC5I,QAAQ,EAAE;MACvC,MAAM0K,WAAW,GAAiB,IAAI,CAAC9B,OAAO;MAC9C,IAAI,CAAC7I,mBAAmB,GAAG2K,WAAW,CAACC,cAAc,EAAE;KAC1D,MAAM;MACH,MAAMC,eAAe,GAAY,IAAI,CAAChC,OAAO;MAC7C,IAAI,CAAC7I,mBAAmB,GAAGvN,MAAM,CAACqY,WAAW,CAACD,eAAe,CAACxK,CAAC,EAAEwK,eAAe,CAACvK,CAAC,EAAEuK,eAAe,CAACnK,CAAC,CAAC;;IAG1G,IAAI,CAACV,mBAAmB,CAAC+K,WAAW,CAAC,IAAI,CAACxT,0BAA0B,CAAC;IACrE,IAAI,CAAC2E,cAAc,CAAC,IAAI,CAAC5G,UAAU,CAAC;IAEpC;IACA,IAAI0D,QAAkB;IACtB,KAAK,IAAI0D,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGgO,YAAY,EAAEhO,KAAK,EAAE,EAAE;MAC/C,IAAI,IAAI,CAACpH,UAAU,CAACE,MAAM,KAAK,IAAI,CAACoF,SAAS,EAAE;QAC3C;;MAGJ5B,QAAQ,GAAG,IAAI,CAACK,eAAe,EAAE;MAEjC,IAAI,CAAC/D,UAAU,CAAC8D,IAAI,CAACJ,QAAQ,CAAC;MAE9B;MACA,IAAI,IAAI,CAACuP,kBAAkB,IAAI,IAAI,CAACzF,kBAAkB,IAAI,IAAI,CAACA,kBAAkB,CAACtN,MAAM,GAAG,CAAC,EAAE;QAC1F,MAAM0H,KAAK,GAAGtK,MAAM,CAACoY,KAAK,CAAC,IAAI,CAAC3S,YAAY,GAAG,IAAI,CAACkQ,kBAAkB,CAAC;QACvEjW,cAAc,CAAC8K,kBAAkB,CAACF,KAAK,EAAE,IAAI,CAAC4F,kBAAkB,EAAE,CAACzF,eAAe,EAAEC,YAAY,KAAI;UAChG,MAAM2N,eAAe,GAAmB5N,eAAe;UACvD,MAAM6N,eAAe,GAAmB5N,YAAY;UACpD,MAAM6N,SAAS,GAAGF,eAAe,CAAC1M,SAAS,EAAE;UAC7C,MAAM6M,SAAS,GAAGF,eAAe,CAAC3M,SAAS,EAAE;UAC7C,MAAM8D,QAAQ,GAAG,CAACnF,KAAK,GAAG+N,eAAe,CAAC5I,QAAQ,KAAK6I,eAAe,CAAC7I,QAAQ,GAAG4I,eAAe,CAAC5I,QAAQ,CAAC;UAC3GrJ,QAAQ,CAAC+D,QAAQ,GAAGnK,MAAM,CAAC6L,IAAI,CAAC0M,SAAS,EAAEC,SAAS,EAAE/I,QAAQ,CAAC;QACnE,CAAC,CAAC;OACL,MAAM;QACHrJ,QAAQ,CAAC+D,QAAQ,GAAGnK,MAAM,CAACyY,WAAW,CAAC,IAAI,CAACC,WAAW,EAAE,IAAI,CAACC,WAAW,CAAC;;MAG9E;MACA,MAAMC,SAAS,GAAG5Y,MAAM,CAACyY,WAAW,CAAC,IAAI,CAACI,YAAY,EAAE,IAAI,CAACC,YAAY,CAAC;MAE1E,IAAI,IAAI,CAACC,qBAAqB,EAAE;QAC5B,IAAI,CAACA,qBAAqB,CAAC,IAAI,CAAC3L,mBAAmB,EAAEhH,QAAQ,CAACiH,QAAQ,EAAEjH,QAAQ,EAAE,IAAI,CAACH,OAAO,CAAC;OAClG,MAAM;QACH,IAAI,CAACmD,mBAAmB,CAAC2P,qBAAqB,CAAC,IAAI,CAAC3L,mBAAmB,EAAEhH,QAAQ,CAACiH,QAAQ,EAAEjH,QAAQ,EAAE,IAAI,CAACH,OAAO,CAAC;;MAGvH,IAAI,IAAI,CAACA,OAAO,EAAE;QACd,IAAI,CAACG,QAAQ,CAAC8G,cAAc,EAAE;UAC1B9G,QAAQ,CAAC8G,cAAc,GAAG9G,QAAQ,CAACiH,QAAQ,CAAC/F,KAAK,EAAE;SACtD,MAAM;UACHlB,QAAQ,CAAC8G,cAAc,CAACpC,QAAQ,CAAC1E,QAAQ,CAACiH,QAAQ,CAAC;;QAEvDzN,OAAO,CAACuN,yBAAyB,CAAC/G,QAAQ,CAAC8G,cAAe,EAAE,IAAI,CAACE,mBAAmB,EAAEhH,QAAQ,CAACiH,QAAQ,CAAC;;MAG5G,IAAI,IAAI,CAAC2L,sBAAsB,EAAE;QAC7B,IAAI,CAACA,sBAAsB,CAAC,IAAI,CAAC5L,mBAAmB,EAAEhH,QAAQ,CAACgG,SAAS,EAAEhG,QAAQ,EAAE,IAAI,CAACH,OAAO,CAAC;OACpG,MAAM;QACH,IAAI,CAACmD,mBAAmB,CAAC4P,sBAAsB,CAAC,IAAI,CAAC5L,mBAAmB,EAAEhH,QAAQ,CAACgG,SAAS,EAAEhG,QAAQ,EAAE,IAAI,CAACH,OAAO,EAAE,IAAI,CAACtB,0BAA0B,CAAC;;MAG1J,IAAIiU,SAAS,KAAK,CAAC,EAAE;QACjB,IAAI,CAACxS,QAAQ,CAACqR,iBAAiB,EAAE;UAC7BrR,QAAQ,CAACqR,iBAAiB,GAAGrR,QAAQ,CAACgG,SAAS,CAAC9E,KAAK,EAAE;SAC1D,MAAM;UACHlB,QAAQ,CAACqR,iBAAiB,CAAC3M,QAAQ,CAAC1E,QAAQ,CAACgG,SAAS,CAAC;;OAE9D,MAAM;QACHhG,QAAQ,CAACqR,iBAAiB,GAAG,IAAI;;MAGrCrR,QAAQ,CAACgG,SAAS,CAACO,YAAY,CAACiM,SAAS,CAAC;MAE1C;MACA,IAAI,CAAC,IAAI,CAACtK,cAAc,IAAI,IAAI,CAACA,cAAc,CAAC1L,MAAM,KAAK,CAAC,EAAE;QAC1DwD,QAAQ,CAACsI,IAAI,GAAG1O,MAAM,CAACyY,WAAW,CAAC,IAAI,CAACQ,OAAO,EAAE,IAAI,CAACC,OAAO,CAAC;OACjE,MAAM;QACH9S,QAAQ,CAACmI,oBAAoB,GAAG,IAAI,CAACD,cAAc,CAAC,CAAC,CAAC;QACtDlI,QAAQ,CAACoI,aAAa,GAAGpI,QAAQ,CAACmI,oBAAoB,CAAC5C,SAAS,EAAE;QAClEvF,QAAQ,CAACsI,IAAI,GAAGtI,QAAQ,CAACoI,aAAa;QAEtC,IAAI,IAAI,CAACF,cAAc,CAAC1L,MAAM,GAAG,CAAC,EAAE;UAChCwD,QAAQ,CAACqI,aAAa,GAAG,IAAI,CAACH,cAAc,CAAC,CAAC,CAAC,CAAC3C,SAAS,EAAE;SAC9D,MAAM;UACHvF,QAAQ,CAACqI,aAAa,GAAGrI,QAAQ,CAACoI,aAAa;;;MAGvD;MACApI,QAAQ,CAACuE,KAAK,CAACwD,cAAc,CAACnO,MAAM,CAACyY,WAAW,CAAC,IAAI,CAACU,SAAS,EAAE,IAAI,CAACC,SAAS,CAAC,EAAEpZ,MAAM,CAACyY,WAAW,CAAC,IAAI,CAACY,SAAS,EAAE,IAAI,CAACC,SAAS,CAAC,CAAC;MAErI;MACA,IAAI,IAAI,CAAChI,mBAAmB,IAAI,IAAI,CAACA,mBAAmB,CAAC,CAAC,CAAC,IAAI,IAAI,CAACqE,kBAAkB,EAAE;QACpF,MAAMrL,KAAK,GAAG,IAAI,CAAC7E,YAAY,GAAG,IAAI,CAACkQ,kBAAkB;QACzDjW,cAAc,CAAC8K,kBAAkB,CAACF,KAAK,EAAE,IAAI,CAACgH,mBAAmB,EAAE,CAAC7G,eAAe,EAAEC,YAAY,EAAEC,KAAK,KAAI;UACxG,IAAIF,eAAe,KAAK,IAAI,CAACsL,yBAAyB,EAAE;YACpD,IAAI,CAACnQ,kBAAkB,GAAG,IAAI,CAACC,kBAAkB;YACjD,IAAI,CAACA,kBAAkB,GAAoB6E,YAAa,CAACiB,SAAS,EAAE;YACpE,IAAI,CAACoK,yBAAyB,GAAmBtL,eAAe;;UAGpE,MAAMlI,KAAK,GAAGvC,MAAM,CAAC6L,IAAI,CAAC,IAAI,CAACjG,kBAAkB,EAAE,IAAI,CAACC,kBAAkB,EAAE8E,KAAK,CAAC;UAClFvE,QAAQ,CAACuE,KAAK,CAACgC,YAAY,CAACpK,KAAK,CAAC;QACtC,CAAC,CAAC;;MAGN;MACA,IAAI,CAAC,IAAI,CAACgJ,sBAAsB,IAAI,IAAI,CAACA,sBAAsB,CAAC3I,MAAM,KAAK,CAAC,EAAE;QAC1EwD,QAAQ,CAACwF,YAAY,GAAG5L,MAAM,CAACyY,WAAW,CAAC,IAAI,CAACc,eAAe,EAAE,IAAI,CAACC,eAAe,CAAC;OACzF,MAAM;QACHpT,QAAQ,CAACoF,4BAA4B,GAAG,IAAI,CAACD,sBAAsB,CAAC,CAAC,CAAC;QACtEnF,QAAQ,CAACwF,YAAY,GAAGxF,QAAQ,CAACoF,4BAA4B,CAACG,SAAS,EAAE;QACzEvF,QAAQ,CAACqF,qBAAqB,GAAGrF,QAAQ,CAACwF,YAAY;QAEtD,IAAI,IAAI,CAACL,sBAAsB,CAAC3I,MAAM,GAAG,CAAC,EAAE;UACxCwD,QAAQ,CAACsF,qBAAqB,GAAG,IAAI,CAACH,sBAAsB,CAAC,CAAC,CAAC,CAACI,SAAS,EAAE;SAC9E,MAAM;UACHvF,QAAQ,CAACsF,qBAAqB,GAAGtF,QAAQ,CAACqF,qBAAqB;;;MAGvErF,QAAQ,CAAC0F,KAAK,GAAG9L,MAAM,CAACyY,WAAW,CAAC,IAAI,CAACgB,kBAAkB,EAAE,IAAI,CAACC,kBAAkB,CAAC;MAErF;MACA,IAAI,IAAI,CAAC1N,kBAAkB,IAAI,IAAI,CAACA,kBAAkB,CAACpJ,MAAM,GAAG,CAAC,EAAE;QAC/DwD,QAAQ,CAAC6F,wBAAwB,GAAG,IAAI,CAACD,kBAAkB,CAAC,CAAC,CAAC;QAC9D5F,QAAQ,CAAC8F,iBAAiB,GAAG9F,QAAQ,CAAC6F,wBAAwB,CAACN,SAAS,EAAE;QAE1E,IAAI,IAAI,CAACK,kBAAkB,CAACpJ,MAAM,GAAG,CAAC,EAAE;UACpCwD,QAAQ,CAAC+F,iBAAiB,GAAG,IAAI,CAACH,kBAAkB,CAAC,CAAC,CAAC,CAACL,SAAS,EAAE;SACtE,MAAM;UACHvF,QAAQ,CAAC+F,iBAAiB,GAAG/F,QAAQ,CAAC8F,iBAAiB;;;MAI/D;MACA,IAAI,IAAI,CAACG,uBAAuB,IAAI,IAAI,CAACA,uBAAuB,CAACzJ,MAAM,GAAG,CAAC,EAAE;QACzEwD,QAAQ,CAACkG,6BAA6B,GAAG,IAAI,CAACD,uBAAuB,CAAC,CAAC,CAAC;QACxEjG,QAAQ,CAACmG,sBAAsB,GAAGnG,QAAQ,CAACkG,6BAA6B,CAACX,SAAS,EAAE;QAEpF,IAAI,IAAI,CAACU,uBAAuB,CAACzJ,MAAM,GAAG,CAAC,EAAE;UACzCwD,QAAQ,CAACoG,sBAAsB,GAAG,IAAI,CAACH,uBAAuB,CAAC,CAAC,CAAC,CAACV,SAAS,EAAE;SAChF,MAAM;UACHvF,QAAQ,CAACoG,sBAAsB,GAAGpG,QAAQ,CAACmG,sBAAsB;;;MAIzE;MACA,IAAI,IAAI,CAACM,cAAc,IAAI,IAAI,CAACA,cAAc,CAACjK,MAAM,GAAG,CAAC,EAAE;QACvDwD,QAAQ,CAAC0G,oBAAoB,GAAG,IAAI,CAACD,cAAc,CAAC,CAAC,CAAC;QACtDzG,QAAQ,CAAC2G,aAAa,GAAG3G,QAAQ,CAAC0G,oBAAoB,CAACnB,SAAS,EAAE;QAElE,IAAI,IAAI,CAACkB,cAAc,CAACjK,MAAM,GAAG,CAAC,EAAE;UAChCwD,QAAQ,CAAC4G,aAAa,GAAG,IAAI,CAACH,cAAc,CAAC,CAAC,CAAC,CAAClB,SAAS,EAAE;SAC9D,MAAM;UACHvF,QAAQ,CAAC4G,aAAa,GAAG5G,QAAQ,CAAC2G,aAAa;;;MAIvD;MACA,IAAI,CAAC,IAAI,CAACxC,eAAe,IAAI,IAAI,CAACA,eAAe,CAAC3H,MAAM,KAAK,CAAC,EAAE;QAC5D,MAAM+W,IAAI,GAAG3Z,MAAM,CAACyY,WAAW,CAAC,CAAC,EAAE,GAAG,CAAC;QAEvCnX,MAAM,CAAC2J,SAAS,CAAC,IAAI,CAACwH,MAAM,EAAE,IAAI,CAACC,MAAM,EAAEiH,IAAI,EAAEvT,QAAQ,CAAC8E,KAAK,CAAC;QAEhE,IAAI,CAAC0O,SAAS,CAACC,aAAa,CAACzT,QAAQ,CAAC8E,KAAK,EAAE,IAAI,CAAC/F,UAAU,CAAC;QAC7D,IAAI,CAACA,UAAU,CAACiG,UAAU,CAAC,GAAG,GAAGhF,QAAQ,CAAC+D,QAAQ,EAAE/D,QAAQ,CAAC+E,SAAS,CAAC;OAC1E,MAAM;QACH/E,QAAQ,CAACwE,qBAAqB,GAAG,IAAI,CAACL,eAAe,CAAC,CAAC,CAAC;QACxDnE,QAAQ,CAACwE,qBAAqB,CAACI,aAAa,CAAC5E,QAAQ,CAAC8E,KAAK,CAAC;QAC5D9E,QAAQ,CAACyE,cAAc,CAACC,QAAQ,CAAC1E,QAAQ,CAAC8E,KAAK,CAAC;QAEhD,IAAI,IAAI,CAACX,eAAe,CAAC3H,MAAM,GAAG,CAAC,EAAE;UACjC,IAAI,CAAC2H,eAAe,CAAC,CAAC,CAAC,CAACS,aAAa,CAAC5E,QAAQ,CAAC2E,cAAc,CAAC;SACjE,MAAM;UACH3E,QAAQ,CAAC2E,cAAc,CAACD,QAAQ,CAAC1E,QAAQ,CAAC8E,KAAK,CAAC;;;MAIxD;MACA,IAAI,IAAI,CAAChD,wBAAwB,EAAE;QAC/B9B,QAAQ,CAAC0T,yBAAyB,GAAG,IAAI,CAACC,iBAAiB;QAC3D3T,QAAQ,CAAC4T,uBAAuB,GAAG,IAAI,CAACC,eAAe;QACvD7T,QAAQ,CAAC8T,sBAAsB,GAAG,IAAI,CAACC,cAAc;;MAGzD;MACA/T,QAAQ,CAACgG,SAAS,CAACf,UAAU,CAAC,IAAI,CAACxG,wBAAwB,CAAC;MAE5D;MACA,IAAI,IAAI,CAACvC,iBAAiB,EAAE;QACxB8D,QAAQ,CAAC4I,SAAS,GAAG,IAAIjP,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;;MAGhD;MACA,IAAI,IAAI,CAACyJ,YAAY,EAAE;QACnB,IAAIpD,QAAQ,CAACkH,wBAAwB,EAAE;UACnClH,QAAQ,CAACkH,wBAAwB,CAACa,cAAc,CAACtH,IAAI,CAACE,MAAM,EAAE,EAAEF,IAAI,CAACE,MAAM,EAAE,EAAEF,IAAI,CAACE,MAAM,EAAE,CAAC;UAC7FX,QAAQ,CAAC2H,wBAAwB,CAACI,cAAc,CAACtH,IAAI,CAACE,MAAM,EAAE,EAAEF,IAAI,CAACE,MAAM,EAAE,EAAEF,IAAI,CAACE,MAAM,EAAE,CAAC;SAChG,MAAM;UACHX,QAAQ,CAACkH,wBAAwB,GAAG,IAAI1N,OAAO,CAACiH,IAAI,CAACE,MAAM,EAAE,EAAEF,IAAI,CAACE,MAAM,EAAE,EAAEF,IAAI,CAACE,MAAM,EAAE,CAAC;UAC5FX,QAAQ,CAAC2H,wBAAwB,GAAG,IAAInO,OAAO,CAACiH,IAAI,CAACE,MAAM,EAAE,EAAEF,IAAI,CAACE,MAAM,EAAE,EAAEF,IAAI,CAACE,MAAM,EAAE,CAAC;;;MAIpG;MACAX,QAAQ,CAACgJ,iCAAiC,EAAE;;EAEpD;EAEA;;;EAGO,OAAOgL,2BAA2BA,CAAC3V,uBAAuB,GAAG,KAAK,EAAE4V,gBAAgB,GAAG,KAAK,EAAEhY,gBAAgB,GAAG,KAAK;IACzH,MAAMiY,uBAAuB,GAAG,CAACra,YAAY,CAACoU,YAAY,EAAEpU,YAAY,CAACsU,SAAS,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,CAAC;IAE9G,IAAI9P,uBAAuB,EAAE;MACzB6V,uBAAuB,CAAC9T,IAAI,CAAC,WAAW,CAAC;;IAG7C,IAAI,CAAC6T,gBAAgB,EAAE;MACnBC,uBAAuB,CAAC9T,IAAI,CAAC,WAAW,CAAC;;IAG7C,IAAInE,gBAAgB,EAAE;MAClBiY,uBAAuB,CAAC9T,IAAI,CAAC,WAAW,CAAC;;IAG7C,OAAO8T,uBAAuB;EAClC;EAEA;;;EAGO,OAAOC,yBAAyBA,CAAC9V,uBAAuB,GAAG,KAAK,EAAE+V,mBAAmB,GAAG,KAAK;IAChG,MAAMC,oBAAoB,GAAG,CAAC,SAAS,EAAE,MAAM,EAAE,YAAY,EAAE,aAAa,EAAE,kBAAkB,EAAE,aAAa,CAAC;IAEhH9Y,oBAAoB,CAAC8Y,oBAAoB,CAAC;IAE1C,IAAIhW,uBAAuB,EAAE;MACzBgW,oBAAoB,CAACjU,IAAI,CAAC,gBAAgB,CAAC;;IAE/C,IAAIgU,mBAAmB,EAAE;MACrBC,oBAAoB,CAACjU,IAAI,CAAC,0BAA0B,CAAC;;IAGzD,OAAOiU,oBAAoB;EAC/B;EAEA;;;;;EAKOC,WAAWA,CAACC,OAAsB,EAAEzX,SAAiB;IACxD,IAAI,IAAI,CAACiF,MAAM,EAAE;MACbvG,iCAAiC,CAAC,IAAI,EAAE,IAAI,CAACuG,MAAM,EAAEwS,OAAO,CAAC;;IAGjE,IAAI,IAAI,CAACzS,wBAAwB,EAAE;MAC/ByS,OAAO,CAACnU,IAAI,CAAC,sBAAsB,CAAC;;IAGxC,IAAI,IAAI,CAACgU,mBAAmB,EAAE;MAC1BG,OAAO,CAACnU,IAAI,CAAC,0BAA0B,CAAC;;IAG5C,IAAItD,SAAS,KAAKpB,cAAc,CAAC8Y,kBAAkB,EAAE;MACjDD,OAAO,CAACnU,IAAI,CAAC,2BAA2B,CAAC;;IAG7C,IAAI,IAAI,CAAClE,iBAAiB,EAAE;MACxBqY,OAAO,CAACnU,IAAI,CAAC,sBAAsB,CAAC;;IAGxC,IAAI,IAAI,CAACkN,iBAAiB,EAAE;MACxBiH,OAAO,CAACnU,IAAI,CAAC,mBAAmB,CAAC;MAEjC,QAAQ,IAAI,CAACmN,aAAa;QACtB,KAAK7R,cAAc,CAAC+Y,eAAe;UAC/BF,OAAO,CAACnU,IAAI,CAAC,oBAAoB,CAAC;UAClC;QACJ,KAAK1E,cAAc,CAAC8R,uBAAuB;QAC3C,KAAK9R,cAAc,CAAC+R,6BAA6B;UAC7C8G,OAAO,CAACnU,IAAI,CAAC,4BAA4B,CAAC;UAC1C,IAAI,IAAI,CAACmN,aAAa,KAAK7R,cAAc,CAAC+R,6BAA6B,EAAE;YACrE8G,OAAO,CAACnU,IAAI,CAAC,kCAAkC,CAAC;;UAEpD;QACJ,KAAK1E,cAAc,CAACgZ,iBAAiB;UACjCH,OAAO,CAACnU,IAAI,CAAC,2BAA2B,CAAC;UACzC;QACJ;UACI;;;IAIZ,IAAI,IAAI,CAACuU,6BAA6B,EAAE;MACpC,IAAI,CAACA,6BAA6B,CAACC,cAAc,CAAC,IAAI,CAACC,oCAAoC,CAAC;MAC5FN,OAAO,CAACnU,IAAI,CAAC,IAAI,CAACyU,oCAAoC,CAACC,QAAQ,EAAE,CAAC;;EAE1E;EAEA;;;;;;EAMOC,qCAAqCA,CAACC,QAAuB,EAAEC,UAAyB,EAAEC,QAAuB;IACpHD,UAAU,CAAC7U,IAAI,CACX,GAAG1E,cAAc,CAACsY,2BAA2B,CACzC,IAAI,CAAClS,wBAAwB,EAC7B,IAAI,CAACwL,iBAAiB,IAAI,IAAI,CAACC,aAAa,KAAK7R,cAAc,CAAC8R,uBAAuB,IAAI,IAAI,CAACD,aAAa,KAAK7R,cAAc,CAAC+R,6BAA6B,EAC9J,IAAI,CAACvR,iBAAiB,CACzB,CACJ;IAED8Y,QAAQ,CAAC5U,IAAI,CAAC,GAAG1E,cAAc,CAACyY,yBAAyB,CAAC,IAAI,CAACrS,wBAAwB,EAAE,IAAI,CAACsS,mBAAmB,CAAC,CAAC;IAEnHc,QAAQ,CAAC9U,IAAI,CAAC,gBAAgB,EAAE,aAAa,CAAC;IAE9C,IAAI,IAAI,CAACuU,6BAA6B,EAAE;MACpC5a,4BAA4B,CAACob,eAAe,CAACH,QAAQ,EAAE,IAAI,CAACH,oCAAoC,CAAC;MACjG9a,4BAA4B,CAACqb,eAAe,CAACF,QAAQ,EAAE,IAAI,CAACL,oCAAoC,CAAC;;EAEzG;EAEA;;;EAGQQ,WAAWA,CAACvY,SAAiB;IACjC,MAAMwY,aAAa,GAAG,IAAI,CAACnY,qBAAqB,CAACL,SAAS,CAAC;IAE3D,IAAIwY,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAEpY,MAAM,EAAE;MACvB,OAAOoY,aAAa;;IAGxB,MAAMf,OAAO,GAAkB,EAAE;IAEjC,IAAI,CAACD,WAAW,CAACC,OAAO,EAAEzX,SAAS,CAAC;IAEpC;IACA,MAAMyY,mBAAmB,GAAG,IAAI,CAAClY,OAAO,CAACmY,SAAS,CAACC,mBAAmB,GAAI,IAAI,CAACpY,OAAkB,CAACkY,mBAAmB,GAAG;IACxH,IAAI7I,YAAY,GAAG,IAAI,CAAC9J,aAAa,CAAC2S,mBAAmB,CAAC;IAC1D,IAAI,CAAC7I,YAAY,EAAE;MACfA,YAAY,GAAG,IAAI,CAAC9J,aAAa,CAAC2S,mBAAmB,CAAC,GAAG,EAAE;;IAE/D,IAAI5I,WAAW,GAAGD,YAAY,CAAC5P,SAAS,CAAC;IACzC,IAAI,CAAC6P,WAAW,EAAE;MACdA,WAAW,GAAG,IAAI1R,WAAW,CAAC,IAAI,CAACoC,OAAO,CAAC;MAC3C,IAAIsP,WAAW,CAACrP,WAAW,EAAE;QACzBqP,WAAW,CAACrP,WAAW,CAACC,aAAa,GAAG,IAAI,CAACC,cAAc;;MAE/DkP,YAAY,CAAC5P,SAAS,CAAC,GAAG6P,WAAW;;IAGzC,MAAM+I,IAAI,GAAGnB,OAAO,CAACmB,IAAI,CAAC,IAAI,CAAC;IAC/B,IAAI/I,WAAW,CAAC4H,OAAO,KAAKmB,IAAI,EAAE;MAC9B,MAAMC,wBAAwB,GAAkB,EAAE;MAClD,MAAMtB,oBAAoB,GAAkB,EAAE;MAC9C,MAAMa,QAAQ,GAAkB,EAAE;MAElC,IAAI,CAACH,qCAAqC,CAACV,oBAAoB,EAAEsB,wBAAwB,EAAET,QAAQ,CAAC;MAEpGvI,WAAW,CAACiJ,SAAS,CAAC,IAAI,CAACvY,OAAO,CAACwY,YAAY,CAAC,WAAW,EAAEF,wBAAwB,EAAEtB,oBAAoB,EAAEa,QAAQ,EAAEQ,IAAI,CAAC,EAAEA,IAAI,CAAC;;IAGvI,OAAO/I,WAAW;EACtB;EAEA;;;;EAIOwD,OAAOA,CAAC2F,WAAW,GAAG,KAAK;;IAC9B,IAAI,CAAC,IAAI,CAAC1W,QAAQ,EAAE;MAChB;;IAGJ,IAAI,CAAC0W,WAAW,IAAI,IAAI,CAAC/T,MAAM,EAAE;MAC7B;MACA,IAAI,CAAC,IAAI,CAACgU,OAAO,EAAE,EAAE;QACjB;;MAGJ,IAAI,IAAI,CAAC5W,gBAAgB,KAAK,IAAI,CAAC4C,MAAM,CAACiU,UAAU,EAAE,EAAE;QACpD;;MAEJ,IAAI,CAAC7W,gBAAgB,GAAG,IAAI,CAAC4C,MAAM,CAACiU,UAAU,EAAE;;IAGpD,IAAI,CAACpS,kBAAkB,GAAG,IAAI,CAACqS,WAAW,IAAIH,WAAW,GAAG,IAAI,CAACI,iBAAiB,GAAG,EAAAlZ,EAAA,OAAI,CAAC+E,MAAM,cAAA/E,EAAA,uBAAAA,EAAA,CAAEmZ,iBAAiB,EAAE,KAAI,CAAC,CAAC;IAE3H;IACA,IAAIzE,YAAY;IAEhB,IAAI,IAAI,CAAC0E,eAAe,GAAG,CAAC,CAAC,EAAE;MAC3B1E,YAAY,GAAG,IAAI,CAAC0E,eAAe;MACnC,IAAI,CAACvX,eAAe,GAAG,CAAC;MACxB,IAAI,CAACuX,eAAe,GAAG,CAAC;KAC3B,MAAM;MACH,IAAIC,IAAI,GAAG,IAAI,CAACC,QAAQ;MAExB,IAAI,IAAI,CAACvL,kBAAkB,IAAI,IAAI,CAACA,kBAAkB,CAACvO,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC+S,kBAAkB,EAAE;QAC1F,MAAMrL,KAAK,GAAG,IAAI,CAAC7E,YAAY,GAAG,IAAI,CAACkQ,kBAAkB;QACzDjW,cAAc,CAAC8K,kBAAkB,CAACF,KAAK,EAAE,IAAI,CAAC6G,kBAAkB,EAAE,CAAC1G,eAAe,EAAEC,YAAY,EAAEC,KAAK,KAAI;UACvG,IAAIF,eAAe,KAAK,IAAI,CAACqL,wBAAwB,EAAE;YACnD,IAAI,CAACpQ,iBAAiB,GAAG,IAAI,CAACC,iBAAiB;YAC/C,IAAI,CAACA,iBAAiB,GAAoB+E,YAAa,CAACiB,SAAS,EAAE;YACnE,IAAI,CAACmK,wBAAwB,GAAmBrL,eAAe;;UAGnEgS,IAAI,GAAGzc,MAAM,CAAC6L,IAAI,CAAC,IAAI,CAACnG,iBAAiB,EAAE,IAAI,CAACC,iBAAiB,EAAEgF,KAAK,CAAC;QAC7E,CAAC,CAAC;;MAGNmN,YAAY,GAAI2E,IAAI,GAAG,IAAI,CAACzS,kBAAkB,IAAK,CAAC;MACpD,IAAI,CAAC/E,eAAe,IAAIwX,IAAI,GAAG,IAAI,CAACzS,kBAAkB,GAAG8N,YAAY;;IAGzE,IAAI,IAAI,CAAC7S,eAAe,GAAG,GAAG,EAAE;MAC5B6S,YAAY,IAAI,IAAI,CAAC7S,eAAe,IAAI,CAAC;MACzC,IAAI,CAACA,eAAe,IAAI,IAAI,CAACA,eAAe,IAAI,CAAC;;IAGrD,IAAI,CAACqQ,MAAM,GAAG,KAAK;IAEnB,IAAI,CAAC,IAAI,CAACvS,QAAQ,EAAE;MAChB,IAAI,CAAC0C,YAAY,IAAI,IAAI,CAACuE,kBAAkB;MAE5C,IAAI,IAAI,CAAC2L,kBAAkB,IAAI,IAAI,CAAClQ,YAAY,IAAI,IAAI,CAACkQ,kBAAkB,EAAE;QACzE,IAAI,CAACrG,IAAI,EAAE;;KAElB,MAAM;MACHwI,YAAY,GAAG,CAAC;;IAEpB,IAAI,CAACD,OAAO,CAACC,YAAY,CAAC;IAE1B;IACA,IAAI,IAAI,CAAC/U,QAAQ,EAAE;MACf,IAAI,CAAC,IAAI,CAACuS,MAAM,EAAE;QACd,IAAI,CAAC9P,QAAQ,GAAG,KAAK;QACrB,IAAI,IAAI,CAACmX,cAAc,EAAE;UACrB,IAAI,CAACA,cAAc,EAAE;;QAEzB,IAAI,IAAI,CAACtN,aAAa,IAAI,IAAI,CAAClH,MAAM,EAAE;UACnC,IAAI,CAACA,MAAM,CAACyU,aAAa,CAACpW,IAAI,CAAC,IAAI,CAAC;;;;IAKhD,IAAI,CAAC0V,WAAW,EAAE;MACd;MACA,IAAI5E,MAAM,GAAG,CAAC;MACd,KAAK,IAAIxN,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,IAAI,CAACpH,UAAU,CAACE,MAAM,EAAEkH,KAAK,EAAE,EAAE;QACzD,MAAM1D,QAAQ,GAAG,IAAI,CAAC1D,UAAU,CAACoH,KAAK,CAAC;QACvC,IAAI,CAAC+S,uBAAuB,CAACvF,MAAM,EAAElR,QAAQ,CAAC;QAC9CkR,MAAM,IAAI,IAAI,CAAC1T,cAAc,GAAG,CAAC,GAAG,CAAC;;MAGzC,IAAI,IAAI,CAAC0P,aAAa,EAAE;QACpB,IAAI,CAACA,aAAa,CAACwJ,cAAc,CAAC,IAAI,CAAC9I,WAAW,EAAE,CAAC,EAAE,IAAI,CAACtR,UAAU,CAACE,MAAM,CAAC;;;IAItF,IAAI,IAAI,CAAC4Z,eAAe,KAAK,CAAC,IAAI,IAAI,CAACnN,aAAa,EAAE;MAClD,IAAI,CAACC,IAAI,EAAE;;EAEnB;EAEQuN,uBAAuBA,CAACvF,MAAc,EAAElR,QAAkB;IAC9D,IAAI,CAAC+Q,qBAAqB,CAACG,MAAM,EAAE,EAAElR,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC;IACpD,IAAI,CAAC,IAAI,CAACxC,cAAc,EAAE;MACtB,IAAI,CAACuT,qBAAqB,CAACG,MAAM,EAAE,EAAElR,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC;MACpD,IAAI,CAAC+Q,qBAAqB,CAACG,MAAM,EAAE,EAAElR,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC;MACpD,IAAI,CAAC+Q,qBAAqB,CAACG,MAAM,EAAE,EAAElR,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC;;EAE5D;EAEA;;;EAGO2W,OAAOA,CAAA;;IACV,IAAI,IAAI,CAACtZ,OAAO,CAACmF,OAAO,EAAE,CAACC,iBAAiB,EAAE;MAC1C,IAAI,CAACC,kBAAkB,GAAG,IAAI;;IAGlC,IAAI,CAACI,kBAAkB,EAAE;IAEzB,CAAA9F,EAAA,OAAI,CAACmQ,aAAa,cAAAnQ,EAAA,uBAAAA,EAAA,CAAE4Z,QAAQ,EAAE;IAE9B,CAAA7Z,EAAA,OAAI,CAACmQ,aAAa,cAAAnQ,EAAA,uBAAAA,EAAA,CAAE6Z,QAAQ,EAAE;IAE9B,KAAK,MAAMC,GAAG,IAAI,IAAI,CAAChZ,cAAc,EAAE;MACnC,IAAI,CAACA,cAAc,CAACgZ,GAAG,CAAC,CAACD,QAAQ,EAAE;;IAGvC,IAAI,CAACnK,cAAc,EAAE;EACzB;EAEA;;;;EAIOsJ,OAAOA,CAAA;IACV,IAAI,CAAC,IAAI,CAAClG,OAAO,IAAK,IAAI,CAAC8E,6BAA6B,IAAI,CAAC,IAAI,CAACA,6BAA6B,CAACoB,OAAO,EAAG,IAAI,CAAC,IAAI,CAACe,eAAe,IAAI,CAAC,IAAI,CAACA,eAAe,CAACf,OAAO,EAAE,EAAE;MACpK,OAAO,KAAK;;IAGhB,IAAI,IAAI,CAACjZ,SAAS,KAAKpB,cAAc,CAACqb,qBAAqB,EAAE;MACzD,IAAI,CAAC,IAAI,CAAC1B,WAAW,CAAC,IAAI,CAACvY,SAAS,CAAC,CAACI,MAAO,CAAC6Y,OAAO,EAAE,EAAE;QACrD,OAAO,KAAK;;KAEnB,MAAM;MACH,IAAI,CAAC,IAAI,CAACV,WAAW,CAAC3Z,cAAc,CAAC8Y,kBAAkB,CAAC,CAACtX,MAAO,CAAC6Y,OAAO,EAAE,EAAE;QACxE,OAAO,KAAK;;MAEhB,IAAI,CAAC,IAAI,CAACV,WAAW,CAAC3Z,cAAc,CAACsb,aAAa,CAAC,CAAC9Z,MAAO,CAAC6Y,OAAO,EAAE,EAAE;QACnE,OAAO,KAAK;;;IAIpB,OAAO,IAAI;EACf;EAEQkB,OAAOA,CAACna,SAAiB;;IAC7B,MAAM6P,WAAW,GAAG,IAAI,CAAC0I,WAAW,CAACvY,SAAS,CAAC;IAC/C,MAAMI,MAAM,GAAGyP,WAAW,CAACzP,MAAO;IAElC,MAAMwQ,MAAM,GAAG,IAAI,CAACrQ,OAAO;IAE3B;IACAqQ,MAAM,CAACwJ,YAAY,CAACvK,WAAW,CAAC;IAEhC,MAAMwK,UAAU,GAAG,CAAAna,EAAA,OAAI,CAACoa,iBAAiB,cAAApa,EAAA,cAAAA,EAAA,GAAI,IAAI,CAAC+E,MAAO,CAACsV,aAAa,EAAE;IACzEna,MAAM,CAACoa,UAAU,CAAC,gBAAgB,EAAE,IAAI,CAACR,eAAe,CAAC;IACzD5Z,MAAM,CAACqa,SAAS,CAAC,MAAM,EAAEJ,UAAU,CAAC;IACpCja,MAAM,CAACqa,SAAS,CAAC,YAAY,EAAE,CAAAxa,EAAA,OAAI,CAACsF,uBAAuB,cAAAtF,EAAA,cAAAA,EAAA,GAAI,IAAI,CAACgF,MAAO,CAACyV,mBAAmB,EAAE,CAAC;IAElG,IAAI,IAAI,CAAC1V,wBAAwB,IAAI,IAAI,CAACgV,eAAe,EAAE;MACvD,MAAMW,QAAQ,GAAG,IAAI,CAACX,eAAe,CAACY,WAAW,EAAE;MACnDxa,MAAM,CAACya,SAAS,CAAC,gBAAgB,EAAE,IAAI,CAACC,eAAe,GAAGH,QAAQ,CAAClQ,KAAK,EAAE,IAAI,CAACsQ,gBAAgB,GAAGJ,QAAQ,CAACjQ,MAAM,EAAE,IAAI,CAACoQ,eAAe,GAAGH,QAAQ,CAAClQ,KAAK,CAAC;;IAG7JrK,MAAM,CAAC4a,UAAU,CAAC,kBAAkB,EAAE,IAAI,CAACC,gBAAgB,CAAC;IAC5D7a,MAAM,CAAC8a,SAAS,CAAC,aAAa,EAAE,IAAI,CAACC,WAAW,CAACxM,CAAC,EAAE,IAAI,CAACwM,WAAW,CAACvM,CAAC,EAAE,IAAI,CAACuM,WAAW,CAACxO,CAAC,EAAE,IAAI,CAACwO,WAAW,CAAC/S,CAAC,CAAC;IAE/G,IAAI,IAAI,CAACoI,iBAAiB,IAAI,IAAI,CAACvL,MAAM,EAAE;MACvC,MAAMmW,MAAM,GAAG,IAAI,CAACnW,MAAM,CAACoW,YAAa;MACxCjb,MAAM,CAACkb,UAAU,CAAC,aAAa,EAAEF,MAAM,CAACG,cAAc,CAAC;;IAG3D,IAAI,IAAI,CAAC/M,qBAAqB,EAAE;MAC5B,IAAI,CAAC,IAAI,CAACD,cAAc,IAAI,CAAC,IAAI,CAACA,cAAc,CAAC7O,MAAM,EAAE;QACrD,IAAI,CAAC8O,qBAAqB,CAACS,OAAO,EAAE;QACpC,IAAI,CAACT,qBAAqB,GAAG,IAAI;;MAErCpO,MAAM,CAACoa,UAAU,CAAC,aAAa,EAAE,IAAI,CAAChM,qBAAqB,CAAC;;IAGhE,MAAMiJ,OAAO,GAAGrX,MAAM,CAACqX,OAAO;IAE9B,IAAI,IAAI,CAACxS,MAAM,EAAE;MACbtG,aAAa,CAACyB,MAAM,EAAE,IAAI,EAAE,IAAI,CAAC6E,MAAM,CAAC;;IAG5C,IAAIwS,OAAO,CAACzE,OAAO,CAAC,2BAA2B,CAAC,IAAI,CAAC,EAAE;MACnDqH,UAAU,CAACpF,WAAW,CAACrY,UAAU,CAACD,MAAM,CAAC,CAAC,CAAC,CAAC;MAC5CyD,MAAM,CAACqa,SAAS,CAAC,SAAS,EAAE7d,UAAU,CAACD,MAAM,CAAC,CAAC,CAAC,CAAC;;IAGrD,IAAI,IAAI,CAACiJ,kBAAkB,KAAK4V,SAAS,EAAE;MACvC,IAAI,CAAAC,EAAA,OAAI,CAACxW,MAAM,cAAAwW,EAAA,uBAAAA,EAAA,CAAEC,cAAc,EAAE;QAC7B9K,MAAM,CAAC+K,WAAW,CAAC,IAAI,CAAC5a,cAAc,EAAE,IAAI,CAAC6Q,8BAA8B,EAAExR,MAAM,CAAC;OACvF,MAAM;QACH,IAAI,CAAC,IAAI,CAACwF,kBAAkB,EAAE;UAC1B,IAAI,CAACA,kBAAkB,GAAG,IAAI,CAACrF,OAAO,CAACqb,uBAAuB,CAAC,IAAI,CAAC7a,cAAc,EAAE,IAAI,EAAEX,MAAM,CAAC;;QAGrG,IAAI,CAACG,OAAO,CAACsb,qBAAqB,CAAC,IAAI,CAACjW,kBAAkB,EAAE,EAAAkW,EAAA,OAAI,CAAC7W,MAAM,cAAA6W,EAAA,uBAAAA,EAAA,CAAEJ,cAAc,IAAG,IAAI,CAAC9J,8BAA8B,GAAG,IAAI,CAAC3Q,YAAY,CAAC;;KAEzJ,MAAM;MACH,IAAI,CAAC,IAAI,CAACA,YAAY,EAAE;QACpB;QACA2P,MAAM,CAAC+K,WAAW,CAAC,IAAI,CAAC5a,cAAc,EAAE,EAAAgb,EAAA,OAAI,CAAC9W,MAAM,cAAA8W,EAAA,uBAAAA,EAAA,CAAEL,cAAc,IAAG,IAAI,CAAC9J,8BAA8B,GAAG,IAAI,EAAExR,MAAM,CAAC;OAC5H,MAAM;QACHwQ,MAAM,CAAC+K,WAAW,CAAC,IAAI,CAAC5a,cAAc,EAAE,EAAAib,EAAA,OAAI,CAAC/W,MAAM,cAAA+W,EAAA,uBAAAA,EAAA,CAAEN,cAAc,IAAG,IAAI,CAACxJ,iBAAiB,GAAG,IAAI,CAACjR,YAAY,EAAEb,MAAM,CAAC;;;IAIjI;IACA,IAAI,IAAI,CAACkX,mBAAmB,IAAI,IAAI,CAACrS,MAAM,EAAE;MACzCzG,cAAc,CAACyd,YAAY,CAACxE,OAAO,EAAErX,MAAM,EAAE,IAAI,CAAC6E,MAAM,CAAC;;IAG7D;IACA,IAAI,IAAI,CAAC4S,6BAA6B,IAAI,CAAC,IAAI,CAACA,6BAA6B,CAACqE,kBAAkB,EAAE;MAC9F,IAAI,CAACrE,6BAA6B,CAACsE,IAAI,CAAC/b,MAAM,CAAC;;IAGnD;IACA,QAAQJ,SAAS;MACb,KAAKpB,cAAc,CAACsb,aAAa;QAC7BtJ,MAAM,CAACwL,YAAY,CAAC;QACpB;MACJ,KAAKxd,cAAc,CAACyd,gBAAgB;QAChCzL,MAAM,CAACwL,YAAY,CAAC;QACpB;MACJ,KAAKxd,cAAc,CAAC0d,kBAAkB;QAClC1L,MAAM,CAACwL,YAAY,CAAC;QACpB;MACJ,KAAKxd,cAAc,CAAC8Y,kBAAkB;QAClC9G,MAAM,CAACwL,YAAY,CAAC;QACpB;;IAGR,IAAI,IAAI,CAACxb,gCAAgC,EAAE;MACvC,IAAI,CAACA,gCAAgC,CAACkT,eAAe,CAAC1T,MAAM,CAAC;;IAGjE,IAAI,IAAI,CAACM,cAAc,EAAE;MACrB,IAAI,CAAA6b,EAAA,OAAI,CAACtX,MAAM,cAAAsX,EAAA,uBAAAA,EAAA,CAAEb,cAAc,EAAE;QAC7B9K,MAAM,CAAC4L,gBAAgB,CAAC,UAAU,KAAAhd,UAAA,CAAAE,MAAA;OACrC,MAAM;QACHkR,MAAM,CAAC6L,cAAc,CAAC,SAAS,IAAC,CAAAjd,UAAA,CAAAE,MAAA;;KAEvC,MAAM;MACH,IAAI,CAAAgd,EAAA,OAAI,CAACzX,MAAM,cAAAyX,EAAA,uBAAAA,EAAA,CAAEhB,cAAc,EAAE;QAC7B9K,MAAM,CAAC4L,gBAAgB,CAAC,UAAU,CAAAhd,UAAA,CAAAE,MAAA;OACrC,MAAM;QACHkR,MAAM,CAAC4L,gBAAgB,CAAC,UAAU,CAAAhd,UAAA,CAAAE,MAAA;;;IAI1C,OAAO,IAAI,CAACF,UAAU,CAACE,MAAM;EACjC;EAEA;;;;EAIO4T,MAAMA,CAAA;IACT;IACA,IAAI,CAAC,IAAI,CAAC2F,OAAO,EAAE,IAAI,CAAC,IAAI,CAACzZ,UAAU,CAACE,MAAM,EAAE;MAC5C,OAAO,CAAC;;IAGZ,MAAMkR,MAAM,GAAG,IAAI,CAACrQ,OAAc;IAClC,IAAIqQ,MAAM,CAAC+L,QAAQ,EAAE;MACjB/L,MAAM,CAAC+L,QAAQ,CAAC,KAAK,CAAC;MAEtB,IAAI,IAAI,CAACC,eAAe,EAAE;QACtBhM,MAAM,CAACiM,aAAa,CAAC,IAAI,CAAC;;;IAIlC,IAAIC,YAAY,GAAG,CAAC;IAEpB,IAAI,IAAI,CAAC9c,SAAS,KAAKpB,cAAc,CAACqb,qBAAqB,EAAE;MACzD6C,YAAY,GAAG,IAAI,CAAC3C,OAAO,CAACvb,cAAc,CAAC8Y,kBAAkB,CAAC,GAAG,IAAI,CAACyC,OAAO,CAACvb,cAAc,CAACsb,aAAa,CAAC;KAC9G,MAAM;MACH4C,YAAY,GAAG,IAAI,CAAC3C,OAAO,CAAC,IAAI,CAACna,SAAS,CAAC;;IAG/C,IAAI,CAACO,OAAO,CAACwc,wBAAwB,EAAE;IACvC,IAAI,CAACxc,OAAO,CAAC6b,YAAY,CAAC;IAE1B,OAAOU,YAAY;EACvB;EAEA;;;;EAIO7N,OAAOA,CAAC+N,cAAc,GAAG,IAAI;IAChC,IAAI,CAACrN,cAAc,EAAE;IAErB,IAAI,IAAI,CAACS,aAAa,EAAE;MACpB,IAAI,CAACA,aAAa,CAACnB,OAAO,EAAE;MAC5B,IAAI,CAACmB,aAAa,GAAG,IAAI;;IAG7B,IAAI,IAAI,CAACC,aAAa,EAAE;MACpB,IAAI,CAACA,aAAa,CAACpB,OAAO,EAAE;MAC5B,IAAI,CAACoB,aAAa,GAAG,IAAI;;IAG7B,IAAI,IAAI,CAACpP,YAAY,EAAE;MACnB,IAAI,CAACV,OAAO,CAAC0c,cAAc,CAAC,IAAI,CAAChc,YAAY,CAAC;MAC9C,IAAI,CAACA,YAAY,GAAG,IAAI;;IAG5B,IAAI,IAAI,CAACiR,iBAAiB,EAAE;MACxB,IAAI,CAAC3R,OAAO,CAAC0c,cAAc,CAAC,IAAI,CAAC/K,iBAAiB,CAAC;MACnD,IAAI,CAACA,iBAAiB,GAAG,IAAI;;IAGjC,IAAI,IAAI,CAACN,8BAA8B,EAAE;MACrC,IAAI,CAACrR,OAAO,CAAC0c,cAAc,CAAC,IAAI,CAACrL,8BAA8B,CAAC;MAChE,IAAI,CAACA,8BAA8B,GAAG,IAAI;;IAG9C,IAAI,IAAI,CAAChM,kBAAkB,EAAE;MACzB,IAAI,CAACrF,OAAO,CAAC+P,wBAAwB,CAAC,IAAI,CAAC1K,kBAAkB,CAAC;MAC9D,IAAI,CAACA,kBAAkB,GAAG,IAAI;;IAGlC,IAAIoX,cAAc,IAAI,IAAI,CAAChD,eAAe,EAAE;MACxC,IAAI,CAACA,eAAe,CAAC/K,OAAO,EAAE;MAC9B,IAAI,CAAC+K,eAAe,GAAG,IAAI;;IAG/B,IAAIgD,cAAc,IAAI,IAAI,CAAC1W,YAAY,EAAE;MACrC,IAAI,CAACA,YAAY,CAAC2I,OAAO,EAAE;MAC3B,IAAI,CAAC3I,YAAY,GAAG,IAAI;;IAG5B,IAAI,IAAI,CAACkI,qBAAqB,EAAE;MAC5B,IAAI,CAACA,qBAAqB,CAACS,OAAO,EAAE;MACpC,IAAI,CAACT,qBAAqB,GAAG,IAAI;;IAGrC,IAAI,CAACkG,eAAe,EAAE;IAEtB,IAAI,IAAI,CAAChR,WAAW,IAAI,CAAC,IAAI,CAACD,YAAY,EAAE;MACxC,IAAI,CAAC6O,+BAA+B,EAAE;;IAG1C,IAAI,IAAI,CAAC7O,YAAY,IAAI,IAAI,CAACA,YAAY,CAAC/D,MAAM,EAAE;MAC/C,KAAK,IAAIkH,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,IAAI,CAACnD,YAAY,CAAC/D,MAAM,EAAEkH,KAAK,EAAE,EAAE;QAC3D,KAAK,MAAM5C,UAAU,IAAI,IAAI,CAACP,YAAY,CAACmD,KAAK,CAAC,EAAE;UAC/C5C,UAAU,CAACiL,OAAO,EAAE;;;MAI5B,IAAI,CAACxL,YAAY,GAAG,EAAE;MACtB,IAAI,CAACC,WAAW,GAAG,EAAE;;IAGzB,IAAI,IAAI,CAACZ,wBAAwB,IAAI,IAAI,CAACiQ,OAAO,IAAK,IAAI,CAACA,OAAwB,CAAC9D,OAAO,EAAE;MAC1E,IAAI,CAAC8D,OAAQ,CAAC9D,OAAO,CAAC,IAAI,CAAC;;IAG9C,IAAI,IAAI,CAACrO,gCAAgC,EAAE;MACvC,IAAI,CAACA,gCAAgC,CAACsc,KAAK,EAAE;;IAGjD;IACA,IAAI,IAAI,CAACjY,MAAM,EAAE;MACb,MAAM2B,KAAK,GAAG,IAAI,CAAC3B,MAAM,CAACK,eAAe,CAAC0N,OAAO,CAAC,IAAI,CAAC;MACvD,IAAIpM,KAAK,GAAG,CAAC,CAAC,EAAE;QACZ,IAAI,CAAC3B,MAAM,CAACK,eAAe,CAACwH,MAAM,CAAClG,KAAK,EAAE,CAAC,CAAC;;MAGhD,IAAI,CAAC3B,MAAM,CAACkY,sBAAsB,CAAClO,OAAO,EAAE;;IAGhD;IACA,IAAI,CAACjQ,mBAAmB,CAAC8U,eAAe,CAAC,IAAI,CAAC;IAC9C,IAAI,CAAC9U,mBAAmB,CAACke,KAAK,EAAE;IAChC,IAAI,CAACtb,mBAAmB,CAACsb,KAAK,EAAE;IAEhC,IAAI,CAAClJ,KAAK,EAAE;EAChB;EAEA;EACA;;;;;;;EAOO5P,KAAKA,CAACjD,IAAY,EAAEgD,UAAe,EAAEiZ,YAAY,GAAG,KAAK;IAC5D,MAAMC,MAAM,GAAAC,MAAA,CAAAC,MAAA,KAAQ,IAAI,CAACpd,eAAe,CAAE;IAC1C,IAAIqd,OAAO,GAAQ,IAAI;IACvB,MAAM5M,MAAM,GAAG,IAAI,CAACrQ,OAAiB;IACrC,IAAIqQ,MAAM,CAAC6M,wBAAwB,EAAE;MACjC,IAAI,IAAI,CAACC,YAAY,IAAI,IAAI,EAAE;QAC3BF,OAAO,GAAG,IAAI,CAACE,YAAY;QAC3B,MAAMjG,OAAO,GAAW+F,OAAO,CAACG,aAAa,CAAClG,OAAO,CAAC/X,MAAM,GAAG,CAAC,GAAG8d,OAAO,CAACG,aAAa,CAAClG,OAAO,CAACmB,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE;QAChH,MAAMxY,MAAM,GAAGwQ,MAAM,CAAC6M,wBAAwB,CAACD,OAAO,CAACI,UAAU,CAACC,eAAe,EAAEL,OAAO,CAACG,aAAa,CAACzF,QAAQ,EAAEsF,OAAO,CAACG,aAAa,CAACvF,QAAQ,EAAEX,OAAO,CAAC;QAC3J,IAAI,CAAC4F,MAAM,CAAC,CAAC,CAAC,EAAE;UACZ,IAAI,CAAC/c,eAAe,CAACF,MAAM,EAAE,CAAC,CAAC;SAClC,MAAM;UACHid,MAAM,CAAC,CAAC,CAAC,CAACjd,MAAM,GAAGA,MAAM;;;;IAKrC,MAAM0d,aAAa,GAAG,IAAI,CAACC,SAAS,CAACX,YAAY,CAAC;IAClD,MAAMY,MAAM,GAAGpf,cAAc,CAACqf,KAAK,CAACH,aAAa,EAAE,IAAI,CAAC7Y,MAAM,IAAI,IAAI,CAAC1E,OAAO,EAAE,IAAI,CAAC2d,QAAQ,CAAC;IAC9FF,MAAM,CAAC7c,IAAI,GAAGA,IAAI;IAClB6c,MAAM,CAACN,YAAY,GAAGF,OAAO;IAC7BQ,MAAM,CAAC7d,eAAe,GAAGkd,MAAM;IAE/B,IAAIlZ,UAAU,KAAKqX,SAAS,EAAE;MAC1BrX,UAAU,GAAG,IAAI,CAAC4O,OAAO;;IAG7B,IAAI,IAAI,CAACzM,YAAY,EAAE;MACnB0X,MAAM,CAAC1X,YAAY,GAAG,IAAI,CAACA,YAAY,CAAClC,KAAK,EAAE;;IAGnD4Z,MAAM,CAACjL,OAAO,GAAG5O,UAAU;IAC3B,IAAI,CAAC,IAAI,CAACga,gBAAgB,EAAE;MACxBH,MAAM,CAAC1Z,KAAK,EAAE;;IAGlB,OAAO0Z,MAAM;EACjB;EAEA;;;;;EAKOD,SAASA,CAACK,gBAAgB,GAAG,KAAK;IACrC,MAAMC,mBAAmB,GAAQ,EAAE;IAEnCzf,cAAc,CAAC0f,UAAU,CAACD,mBAAmB,EAAE,IAAI,EAAED,gBAAgB,CAAC;IAEtEC,mBAAmB,CAAClD,WAAW,GAAG,IAAI,CAACA,WAAW,CAACoD,OAAO,EAAE;IAC5DF,mBAAmB,CAACX,YAAY,GAAG,IAAI,CAACA,YAAY;IACpDW,mBAAmB,CAACF,gBAAgB,GAAG,IAAI,CAACA,gBAAgB;IAE5D;IACA,IAAI,IAAI,CAACza,WAAW,EAAE;MAClB2a,mBAAmB,CAAC3a,WAAW,GAAG,EAAE;MAEpC,IAAI,CAAC,IAAI,CAACD,YAAY,EAAE;QACpB,IAAI,CAAC6O,+BAA+B,EAAE;;MAG1C,KAAK,MAAMkM,IAAI,IAAI,IAAI,CAAC/a,YAAY,EAAE;QAClC,MAAMgb,IAAI,GAAG,EAAE;QACf,KAAK,MAAMC,GAAG,IAAIF,IAAI,EAAE;UACpBC,IAAI,CAACnb,IAAI,CAACob,GAAG,CAACX,SAAS,CAACK,gBAAgB,CAAC,CAAC;;QAG9CC,mBAAmB,CAAC3a,WAAW,CAACJ,IAAI,CAACmb,IAAI,CAAC;;;IAIlD,OAAOJ,mBAAmB;EAC9B;EAEA;;;EAGO,OAAOC,UAAUA,CAACD,mBAAwB,EAAEha,cAA+B,EAAE+Z,gBAAyB;IACzGC,mBAAmB,CAACld,IAAI,GAAGkD,cAAc,CAAClD,IAAI;IAC9Ckd,mBAAmB,CAACM,EAAE,GAAGta,cAAc,CAACsa,EAAE;IAE1CN,mBAAmB,CAACjd,QAAQ,GAAGiD,cAAc,CAAC8N,WAAW,EAAE;IAE3DkM,mBAAmB,CAAClS,aAAa,GAAG9H,cAAc,CAAC8H,aAAa;IAChEkS,mBAAmB,CAAC/E,eAAe,GAAGjV,cAAc,CAACiV,eAAe;IAEpE;IACA,IAAmBjV,cAAc,CAAC0O,OAAQ,CAAC5I,QAAQ,EAAE;MACjD,MAAM0K,WAAW,GAAiBxQ,cAAc,CAAC0O,OAAO;MACxDsL,mBAAmB,CAACO,SAAS,GAAG/J,WAAW,CAAC8J,EAAE;KACjD,MAAM;MACH,MAAM5J,eAAe,GAAY1Q,cAAc,CAAC0O,OAAO;MACvDsL,mBAAmB,CAACtL,OAAO,GAAGgC,eAAe,CAACwJ,OAAO,EAAE;;IAG3D;IACA,IAAIla,cAAc,CAAC6B,mBAAmB,EAAE;MACpCmY,mBAAmB,CAACnY,mBAAmB,GAAG7B,cAAc,CAAC6B,mBAAmB,CAAC6X,SAAS,EAAE;;IAG5F,IAAI1Z,cAAc,CAAC2V,eAAe,EAAE;MAChC,IAAIoE,gBAAgB,EAAE;QAClBC,mBAAmB,CAACQ,OAAO,GAAGxa,cAAc,CAAC2V,eAAe,CAAC+D,SAAS,EAAE;OAC3E,MAAM;QACHM,mBAAmB,CAACS,WAAW,GAAGza,cAAc,CAAC2V,eAAe,CAAC7Y,IAAI;QACrEkd,mBAAmB,CAACU,OAAO,GAAG,CAAC,CAAE1a,cAAc,CAAC2V,eAAuB,CAACgF,QAAQ;;;IAIxFX,mBAAmB,CAACtb,OAAO,GAAGsB,cAAc,CAACtB,OAAO;IAEpD;IACA9E,mBAAmB,CAACghB,0BAA0B,CAAC5a,cAAc,EAAEga,mBAAmB,CAAC;IACnFA,mBAAmB,CAAC9K,qBAAqB,GAAGlP,cAAc,CAACkP,qBAAqB;IAChF8K,mBAAmB,CAAC3K,kBAAkB,GAAGrP,cAAc,CAACqP,kBAAkB;IAC1E2K,mBAAmB,CAAC1K,gBAAgB,GAAGtP,cAAc,CAACsP,gBAAgB;IACtE0K,mBAAmB,CAACzK,kBAAkB,GAAGvP,cAAc,CAACuP,kBAAkB;IAE1E;IACAyK,mBAAmB,CAAC7L,UAAU,GAAGnO,cAAc,CAACmO,UAAU;IAC1D6L,mBAAmB,CAACa,gBAAgB,GAAG7a,cAAc,CAAC6a,gBAAgB;IACtEb,mBAAmB,CAAClH,gBAAgB,GAAG9S,cAAc,CAAC8S,gBAAgB;IACtEkH,mBAAmB,CAAC5N,aAAa,GAAGpM,cAAc,CAACoM,aAAa;IAChE4N,mBAAmB,CAAChI,eAAe,GAAGhS,cAAc,CAACgS,eAAe;IACpEgI,mBAAmB,CAAC/H,eAAe,GAAGjS,cAAc,CAACiS,eAAe;IACpE+H,mBAAmB,CAACtI,OAAO,GAAG1R,cAAc,CAAC0R,OAAO;IACpDsI,mBAAmB,CAACrI,OAAO,GAAG3R,cAAc,CAAC2R,OAAO;IACpDqI,mBAAmB,CAACpI,SAAS,GAAG5R,cAAc,CAAC4R,SAAS;IACxDoI,mBAAmB,CAACnI,SAAS,GAAG7R,cAAc,CAAC6R,SAAS;IACxDmI,mBAAmB,CAAClI,SAAS,GAAG9R,cAAc,CAAC8R,SAAS;IACxDkI,mBAAmB,CAACjI,SAAS,GAAG/R,cAAc,CAAC+R,SAAS;IACxDiI,mBAAmB,CAAC1I,YAAY,GAAGtR,cAAc,CAACsR,YAAY;IAC9D0I,mBAAmB,CAACzI,YAAY,GAAGvR,cAAc,CAACuR,YAAY;IAC9DyI,mBAAmB,CAAC7I,WAAW,GAAGnR,cAAc,CAACmR,WAAW;IAC5D6I,mBAAmB,CAAC5I,WAAW,GAAGpR,cAAc,CAACoR,WAAW;IAC5D4I,mBAAmB,CAAC7E,QAAQ,GAAGnV,cAAc,CAACmV,QAAQ;IACtD6E,mBAAmB,CAAClT,OAAO,GAAG9G,cAAc,CAAC8G,OAAO,CAACoT,OAAO,EAAE;IAC9DF,mBAAmB,CAACnT,aAAa,GAAG7G,cAAc,CAAC6G,aAAa,CAACqT,OAAO,EAAE;IAC1EF,mBAAmB,CAAC9O,MAAM,GAAGlL,cAAc,CAACkL,MAAM,CAACgP,OAAO,EAAE;IAC5DF,mBAAmB,CAAC7O,MAAM,GAAGnL,cAAc,CAACmL,MAAM,CAAC+O,OAAO,EAAE;IAC5DF,mBAAmB,CAAC3H,SAAS,GAAGrS,cAAc,CAACqS,SAAS,CAAC6H,OAAO,EAAE;IAClEF,mBAAmB,CAAClF,WAAW,GAAG9U,cAAc,CAAC8U,WAAW;IAC5DkF,mBAAmB,CAAC5L,kBAAkB,GAAGpO,cAAc,CAACoO,kBAAkB;IAC1E4L,mBAAmB,CAACre,SAAS,GAAGqE,cAAc,CAACrE,SAAS;IACxDqe,mBAAmB,CAACvL,aAAa,GAAGzO,cAAc,CAACyO,aAAa;IAChEuL,mBAAmB,CAACjF,iBAAiB,GAAG/U,cAAc,CAAC+U,iBAAiB;IACxEiF,mBAAmB,CAAC9H,kBAAkB,GAAGlS,cAAc,CAACkS,kBAAkB;IAC1E8H,mBAAmB,CAAC7H,kBAAkB,GAAGnS,cAAc,CAACmS,kBAAkB;IAC1E6H,mBAAmB,CAACxH,iBAAiB,GAAGxS,cAAc,CAACwS,iBAAiB;IACxEwH,mBAAmB,CAACpH,cAAc,GAAG5S,cAAc,CAAC4S,cAAc;IAClEoH,mBAAmB,CAACtH,eAAe,GAAG1S,cAAc,CAAC0S,eAAe;IACpEsH,mBAAmB,CAACc,qBAAqB,GAAG9a,cAAc,CAAC8a,qBAAqB;IAChFd,mBAAmB,CAACvD,eAAe,GAAGzW,cAAc,CAACyW,eAAe;IACpEuD,mBAAmB,CAACtD,gBAAgB,GAAG1W,cAAc,CAAC0W,gBAAgB;IACtEsD,mBAAmB,CAACe,qBAAqB,GAAG/a,cAAc,CAAC+a,qBAAqB;IAChFf,mBAAmB,CAAC9c,uBAAuB,GAAG8C,cAAc,CAAC9C,uBAAuB;IACpF8c,mBAAmB,CAAC/G,mBAAmB,GAAGjT,cAAc,CAACiT,mBAAmB;IAE5E,MAAM+H,cAAc,GAAGhb,cAAc,CAACib,iBAAiB,EAAE;IACzD,IAAID,cAAc,EAAE;MAChBhB,mBAAmB,CAACgB,cAAc,GAAG,EAAE;MACvC,KAAK,MAAM5P,aAAa,IAAI4P,cAAc,EAAE;QACxC,MAAME,kBAAkB,GAAQ;UAC5BhT,QAAQ,EAAEkD,aAAa,CAAClD,QAAQ;UAChCgD,MAAM,EAAEE,aAAa,CAACF,MAAM,CAACgP,OAAO;SACvC;QAED,IAAI9O,aAAa,CAACD,MAAM,EAAE;UACtB+P,kBAAkB,CAAC/P,MAAM,GAAGC,aAAa,CAACD,MAAM,CAAC+O,OAAO,EAAE;SAC7D,MAAM;UACHgB,kBAAkB,CAAC/P,MAAM,GAAGC,aAAa,CAACF,MAAM,CAACgP,OAAO,EAAE;;QAG9DF,mBAAmB,CAACgB,cAAc,CAAC/b,IAAI,CAACic,kBAAkB,CAAC;;;IAInE,MAAMC,aAAa,GAAGnb,cAAc,CAACyK,gBAAgB,EAAE;IACvD,IAAI0Q,aAAa,EAAE;MACfnB,mBAAmB,CAACmB,aAAa,GAAG,EAAE;MACtC,KAAK,MAAMrQ,YAAY,IAAIqQ,aAAa,EAAE;QACtC,MAAMD,kBAAkB,GAAQ;UAC5BhT,QAAQ,EAAE4C,YAAY,CAAC5C,QAAQ;UAC/BvE,KAAK,EAAEmH,YAAY,CAACnH,KAAK,CAACuW,OAAO;SACpC;QAEDF,mBAAmB,CAACmB,aAAa,CAAClc,IAAI,CAACic,kBAAkB,CAAC;;MAE9DlB,mBAAmB,CAAClf,gBAAgB,GAAGkF,cAAc,CAAClF,gBAAgB;;IAG1E,MAAMsgB,mBAAmB,GAAGpb,cAAc,CAACqb,sBAAsB,EAAE;IACnE,IAAID,mBAAmB,EAAE;MACrBpB,mBAAmB,CAACoB,mBAAmB,GAAG,EAAE;MAC5C,KAAK,MAAME,kBAAkB,IAAIF,mBAAmB,EAAE;QAClD,MAAMF,kBAAkB,GAAQ;UAC5BhT,QAAQ,EAAEoT,kBAAkB,CAACpT,QAAQ;UACrCZ,OAAO,EAAEgU,kBAAkB,CAAChU;SAC/B;QAED,IAAIgU,kBAAkB,CAAC9T,OAAO,KAAK2P,SAAS,EAAE;UAC1C+D,kBAAkB,CAAC1T,OAAO,GAAG8T,kBAAkB,CAAC9T,OAAO;SAC1D,MAAM;UACH0T,kBAAkB,CAAC1T,OAAO,GAAG8T,kBAAkB,CAAChU,OAAO;;QAG3D0S,mBAAmB,CAACoB,mBAAmB,CAACnc,IAAI,CAACic,kBAAkB,CAAC;;;IAIxE,MAAMK,mBAAmB,GAAGvb,cAAc,CAACwb,sBAAsB,EAAE;IACnE,IAAID,mBAAmB,EAAE;MACrBvB,mBAAmB,CAACuB,mBAAmB,GAAG,EAAE;MAC5C,KAAK,MAAME,kBAAkB,IAAIF,mBAAmB,EAAE;QAClD,MAAML,kBAAkB,GAAQ;UAC5BhT,QAAQ,EAAEuT,kBAAkB,CAACvT,QAAQ;UACrCZ,OAAO,EAAEmU,kBAAkB,CAACnU;SAC/B;QAED,IAAImU,kBAAkB,CAACjU,OAAO,KAAK2P,SAAS,EAAE;UAC1C+D,kBAAkB,CAAC1T,OAAO,GAAGiU,kBAAkB,CAACjU,OAAO;SAC1D,MAAM;UACH0T,kBAAkB,CAAC1T,OAAO,GAAGiU,kBAAkB,CAACnU,OAAO;;QAG3D0S,mBAAmB,CAACuB,mBAAmB,CAACtc,IAAI,CAACic,kBAAkB,CAAC;;;IAIxE,MAAMQ,aAAa,GAAG1b,cAAc,CAAC2b,gBAAgB,EAAE;IACvD,IAAID,aAAa,EAAE;MACf1B,mBAAmB,CAAC0B,aAAa,GAAG,EAAE;MACtC,KAAK,MAAME,YAAY,IAAIF,aAAa,EAAE;QACtC,MAAMR,kBAAkB,GAAQ;UAC5BhT,QAAQ,EAAE0T,YAAY,CAAC1T,QAAQ;UAC/BZ,OAAO,EAAEsU,YAAY,CAACtU;SACzB;QAED,IAAIsU,YAAY,CAACpU,OAAO,KAAK2P,SAAS,EAAE;UACpC+D,kBAAkB,CAAC1T,OAAO,GAAGoU,YAAY,CAACpU,OAAO;SACpD,MAAM;UACH0T,kBAAkB,CAAC1T,OAAO,GAAGoU,YAAY,CAACtU,OAAO;;QAGrD0S,mBAAmB,CAAC0B,aAAa,CAACzc,IAAI,CAACic,kBAAkB,CAAC;;;IAIlE,MAAMW,qBAAqB,GAAG7b,cAAc,CAAC8b,wBAAwB,EAAE;IACvE,IAAID,qBAAqB,EAAE;MACvB7B,mBAAmB,CAAC6B,qBAAqB,GAAG,EAAE;MAC9C,KAAK,MAAME,oBAAoB,IAAIF,qBAAqB,EAAE;QACtD,MAAMX,kBAAkB,GAAQ;UAC5BhT,QAAQ,EAAE6T,oBAAoB,CAAC7T,QAAQ;UACvCZ,OAAO,EAAEyU,oBAAoB,CAACzU;SACjC;QAED,IAAIyU,oBAAoB,CAACvU,OAAO,KAAK2P,SAAS,EAAE;UAC5C+D,kBAAkB,CAAC1T,OAAO,GAAGuU,oBAAoB,CAACvU,OAAO;SAC5D,MAAM;UACH0T,kBAAkB,CAAC1T,OAAO,GAAGuU,oBAAoB,CAACzU,OAAO;;QAG7D0S,mBAAmB,CAAC6B,qBAAqB,CAAC5c,IAAI,CAACic,kBAAkB,CAAC;;;IAI1E,MAAMc,iBAAiB,GAAGhc,cAAc,CAACic,oBAAoB,EAAE;IAC/D,IAAID,iBAAiB,EAAE;MACnBhC,mBAAmB,CAACgC,iBAAiB,GAAG,EAAE;MAC1C,KAAK,MAAME,gBAAgB,IAAIF,iBAAiB,EAAE;QAC9C,MAAMd,kBAAkB,GAAQ;UAC5BhT,QAAQ,EAAEgU,gBAAgB,CAAChU,QAAQ;UACnCZ,OAAO,EAAE4U,gBAAgB,CAAC5U;SAC7B;QAED,IAAI4U,gBAAgB,CAAC1U,OAAO,KAAK2P,SAAS,EAAE;UACxC+D,kBAAkB,CAAC1T,OAAO,GAAG0U,gBAAgB,CAAC1U,OAAO;SACxD,MAAM;UACH0T,kBAAkB,CAAC1T,OAAO,GAAG0U,gBAAgB,CAAC5U,OAAO;;QAGzD0S,mBAAmB,CAACgC,iBAAiB,CAAC/c,IAAI,CAACic,kBAAkB,CAAC;;;IAItE,MAAMiB,aAAa,GAAGnc,cAAc,CAACoc,gBAAgB,EAAE;IACvD,IAAID,aAAa,EAAE;MACfnC,mBAAmB,CAACmC,aAAa,GAAG,EAAE;MACtC,KAAK,MAAME,YAAY,IAAIF,aAAa,EAAE;QACtC,MAAMjB,kBAAkB,GAAQ;UAC5BhT,QAAQ,EAAEmU,YAAY,CAACnU,QAAQ;UAC/BZ,OAAO,EAAE+U,YAAY,CAAC/U;SACzB;QAED,IAAI+U,YAAY,CAAC7U,OAAO,KAAK2P,SAAS,EAAE;UACpC+D,kBAAkB,CAAC1T,OAAO,GAAG6U,YAAY,CAAC7U,OAAO;SACpD,MAAM;UACH0T,kBAAkB,CAAC1T,OAAO,GAAG6U,YAAY,CAAC/U,OAAO;;QAGrD0S,mBAAmB,CAACmC,aAAa,CAACld,IAAI,CAACic,kBAAkB,CAAC;;;IAIlE,MAAMoB,iBAAiB,GAAGtc,cAAc,CAACuc,oBAAoB,EAAE;IAC/D,IAAID,iBAAiB,EAAE;MACnBtC,mBAAmB,CAACsC,iBAAiB,GAAG,EAAE;MAC1C,KAAK,MAAME,gBAAgB,IAAIF,iBAAiB,EAAE;QAC9C,MAAMpB,kBAAkB,GAAQ;UAC5BhT,QAAQ,EAAEsU,gBAAgB,CAACtU,QAAQ;UACnCZ,OAAO,EAAEkV,gBAAgB,CAAClV;SAC7B;QAED,IAAIkV,gBAAgB,CAAChV,OAAO,KAAK2P,SAAS,EAAE;UACxC+D,kBAAkB,CAAC1T,OAAO,GAAGgV,gBAAgB,CAAChV,OAAO;SACxD,MAAM;UACH0T,kBAAkB,CAAC1T,OAAO,GAAGgV,gBAAgB,CAAClV,OAAO;;QAGzD0S,mBAAmB,CAACsC,iBAAiB,CAACrd,IAAI,CAACic,kBAAkB,CAAC;;;IAItE,MAAMuB,kBAAkB,GAAGzc,cAAc,CAAC0c,qBAAqB,EAAE;IACjE,IAAID,kBAAkB,EAAE;MACpBzC,mBAAmB,CAACyC,kBAAkB,GAAG,EAAE;MAC3C,KAAK,MAAME,iBAAiB,IAAIF,kBAAkB,EAAE;QAChD,MAAMvB,kBAAkB,GAAQ;UAC5BhT,QAAQ,EAAEyU,iBAAiB,CAACzU,QAAQ;UACpCZ,OAAO,EAAEqV,iBAAiB,CAACrV;SAC9B;QAED,IAAIqV,iBAAiB,CAACnV,OAAO,KAAK2P,SAAS,EAAE;UACzC+D,kBAAkB,CAAC1T,OAAO,GAAGmV,iBAAiB,CAACnV,OAAO;SACzD,MAAM;UACH0T,kBAAkB,CAAC1T,OAAO,GAAGmV,iBAAiB,CAACrV,OAAO;;QAG1D0S,mBAAmB,CAACyC,kBAAkB,CAACxd,IAAI,CAACic,kBAAkB,CAAC;;;IAIvE,MAAM0B,iBAAiB,GAAG5c,cAAc,CAAC6c,oBAAoB,EAAE;IAC/D,IAAID,iBAAiB,EAAE;MACnB5C,mBAAmB,CAAC4C,iBAAiB,GAAG,EAAE;MAC1C,KAAK,MAAME,gBAAgB,IAAIF,iBAAiB,EAAE;QAC9C,MAAM1B,kBAAkB,GAAQ;UAC5BhT,QAAQ,EAAE4U,gBAAgB,CAAC5U,QAAQ;UACnCZ,OAAO,EAAEwV,gBAAgB,CAACxV;SAC7B;QAED,IAAIwV,gBAAgB,CAACtV,OAAO,KAAK2P,SAAS,EAAE;UACxC+D,kBAAkB,CAAC1T,OAAO,GAAGsV,gBAAgB,CAACtV,OAAO;SACxD,MAAM;UACH0T,kBAAkB,CAAC1T,OAAO,GAAGsV,gBAAgB,CAACxV,OAAO;;QAGzD0S,mBAAmB,CAAC4C,iBAAiB,CAAC3d,IAAI,CAACic,kBAAkB,CAAC;;;IAItE,MAAM6B,sBAAsB,GAAG/c,cAAc,CAACgd,yBAAyB,EAAE;IACzE,IAAID,sBAAsB,EAAE;MACxB/C,mBAAmB,CAAC+C,sBAAsB,GAAG,EAAE;MAC/C,KAAK,MAAME,qBAAqB,IAAIF,sBAAsB,EAAE;QACxD,MAAM7B,kBAAkB,GAAQ;UAC5BhT,QAAQ,EAAE+U,qBAAqB,CAAC/U,QAAQ;UACxCZ,OAAO,EAAE2V,qBAAqB,CAAC3V;SAClC;QAED,IAAI2V,qBAAqB,CAACzV,OAAO,KAAK2P,SAAS,EAAE;UAC7C+D,kBAAkB,CAAC1T,OAAO,GAAGyV,qBAAqB,CAACzV,OAAO;SAC7D,MAAM;UACH0T,kBAAkB,CAAC1T,OAAO,GAAGyV,qBAAqB,CAAC3V,OAAO;;QAG9D0S,mBAAmB,CAAC+C,sBAAsB,CAAC9d,IAAI,CAACic,kBAAkB,CAAC;;MAGvElB,mBAAmB,CAAC3U,oBAAoB,GAAGrF,cAAc,CAACqF,oBAAoB;;IAGlF,IAAIrF,cAAc,CAACiC,YAAY,EAAE;MAC7B+X,mBAAmB,CAAC/X,YAAY,GAAGjC,cAAc,CAACiC,YAAY,CAACyX,SAAS,EAAE;;EAElF;EAEA;;;EAGO,OAAOwD,MAAMA,CAACC,oBAAyB,EAAEnd,cAA+B,EAAEhD,aAAiC,EAAEogB,OAAe;;IAC/H,IAAIC,KAAsB;IAE1B,IAAIrgB,aAAa,YAAY9C,UAAU,EAAE;MACrCmjB,KAAK,GAAG,IAAI;KACf,MAAM;MACHA,KAAK,GAAGrgB,aAAsB;;IAGlC,MAAMsgB,aAAa,GAAGzjB,QAAQ,CAAC,iBAAiB,CAAC;IACjD,IAAIyjB,aAAa,IAAID,KAAK,EAAE;MACxB;MACA,IAAIF,oBAAoB,CAAC3C,OAAO,EAAE;QAC9Bxa,cAAc,CAAC2V,eAAe,GAAG2H,aAAa,CAAC1D,KAAK,CAACuD,oBAAoB,CAAC3C,OAAO,EAAE6C,KAAK,EAAED,OAAO,CAAgB;OACpH,MAAM,IAAID,oBAAoB,CAAC1C,WAAW,EAAE;QACzCza,cAAc,CAAC2V,eAAe,GAAG,IAAI2H,aAAa,CAC9CF,OAAO,GAAGD,oBAAoB,CAAC1C,WAAW,EAC1C4C,KAAK,EACL,KAAK,EACLF,oBAAoB,CAACzC,OAAO,KAAKvD,SAAS,GAAGgG,oBAAoB,CAACzC,OAAO,GAAG,IAAI,CACnF;QACD1a,cAAc,CAAC2V,eAAgB,CAAC7Y,IAAI,GAAGqgB,oBAAoB,CAAC1C,WAAW;;;IAI/E;IACA,IAAI,CAAC0C,oBAAoB,CAAC5C,SAAS,IAAI4C,oBAAoB,CAAC5C,SAAS,KAAK,CAAC,IAAI4C,oBAAoB,CAACzO,OAAO,KAAKyI,SAAS,EAAE;MACvHnX,cAAc,CAAC0O,OAAO,GAAGrW,OAAO,CAACyF,IAAI,EAAE;KAC1C,MAAM,IAAIqf,oBAAoB,CAAC5C,SAAS,IAAI8C,KAAK,EAAE;MAChDrd,cAAc,CAAC0O,OAAO,GAAG2O,KAAK,CAACE,eAAe,CAACJ,oBAAoB,CAAC5C,SAAS,CAAC;KACjF,MAAM;MACHva,cAAc,CAAC0O,OAAO,GAAGrW,OAAO,CAACmlB,SAAS,CAACL,oBAAoB,CAACzO,OAAO,CAAC;;IAG5E1O,cAAc,CAACtB,OAAO,GAAG,CAAC,CAACye,oBAAoB,CAACze,OAAO;IAEvD;IACA,IAAIye,oBAAoB,CAACtC,gBAAgB,KAAK1D,SAAS,EAAE;MACrDnX,cAAc,CAAC6a,gBAAgB,GAAGsC,oBAAoB,CAACtC,gBAAgB;;IAG3E,IAAIsC,oBAAoB,CAACrK,gBAAgB,KAAKqE,SAAS,EAAE;MACrDnX,cAAc,CAAC8S,gBAAgB,GAAGqK,oBAAoB,CAACrK,gBAAgB;;IAG3E,IAAIqK,oBAAoB,CAAC/Q,aAAa,KAAK+K,SAAS,EAAE;MAClDnX,cAAc,CAACoM,aAAa,GAAG+Q,oBAAoB,CAAC/Q,aAAa;;IAGrE,IAAI+Q,oBAAoB,CAAClK,mBAAmB,KAAKkE,SAAS,EAAE;MACxDnX,cAAc,CAACiT,mBAAmB,GAAGkK,oBAAoB,CAAClK,mBAAmB;;IAGjF;IACA,IAAIkK,oBAAoB,CAAChO,UAAU,EAAE;MACjC,KAAK,IAAIsO,cAAc,GAAG,CAAC,EAAEA,cAAc,GAAGN,oBAAoB,CAAChO,UAAU,CAAC9T,MAAM,EAAEoiB,cAAc,EAAE,EAAE;QACpG,MAAMC,eAAe,GAAGP,oBAAoB,CAAChO,UAAU,CAACsO,cAAc,CAAC;QACvE,MAAMH,aAAa,GAAGzjB,QAAQ,CAAC,mBAAmB,CAAC;QACnD,IAAIyjB,aAAa,EAAE;UACftd,cAAc,CAACmP,UAAU,CAAClQ,IAAI,CAACqe,aAAa,CAAC1D,KAAK,CAAC8D,eAAe,CAAC,CAAC;;;MAG5E1d,cAAc,CAACkP,qBAAqB,GAAGiO,oBAAoB,CAACjO,qBAAqB;MACjFlP,cAAc,CAACqP,kBAAkB,GAAG8N,oBAAoB,CAAC9N,kBAAkB;MAC3ErP,cAAc,CAACsP,gBAAgB,GAAG6N,oBAAoB,CAAC7N,gBAAgB;MACvEtP,cAAc,CAACuP,kBAAkB,GAAG4N,oBAAoB,CAAC5N,kBAAkB;;IAG/E,IAAI4N,oBAAoB,CAACQ,WAAW,IAAIN,KAAK,EAAE;MAC3CA,KAAK,CAACjO,cAAc,CAChBpP,cAAc,EACdmd,oBAAoB,CAACS,eAAe,EACpCT,oBAAoB,CAACU,aAAa,EAClCV,oBAAoB,CAACW,eAAe,EACpCX,oBAAoB,CAACY,gBAAgB,IAAI,GAAG,CAC/C;;IAGL;IACA/d,cAAc,CAACmO,UAAU,GAAGgP,oBAAoB,CAAChP,UAAU,GAAG,CAAC;IAC/DnO,cAAc,CAACgS,eAAe,GAAGmL,oBAAoB,CAACnL,eAAe;IACrEhS,cAAc,CAACiS,eAAe,GAAGkL,oBAAoB,CAAClL,eAAe;IACrEjS,cAAc,CAAC0R,OAAO,GAAGyL,oBAAoB,CAACzL,OAAO;IACrD1R,cAAc,CAAC2R,OAAO,GAAGwL,oBAAoB,CAACxL,OAAO;IAErD,IAAIwL,oBAAoB,CAACvL,SAAS,EAAE;MAChC5R,cAAc,CAAC4R,SAAS,GAAGuL,oBAAoB,CAACvL,SAAS;MACzD5R,cAAc,CAAC6R,SAAS,GAAGsL,oBAAoB,CAACtL,SAAS;MACzD7R,cAAc,CAAC8R,SAAS,GAAGqL,oBAAoB,CAACrL,SAAS;MACzD9R,cAAc,CAAC+R,SAAS,GAAGoL,oBAAoB,CAACpL,SAAS;;IAG7D,IAAIoL,oBAAoB,CAAC1O,aAAa,KAAK0I,SAAS,EAAE;MAClDnX,cAAc,CAACyO,aAAa,GAAG0O,oBAAoB,CAAC1O,aAAa;MACjEzO,cAAc,CAAC+U,iBAAiB,GAAGoI,oBAAoB,CAACpI,iBAAiB;;IAG7E,IAAIoI,oBAAoB,CAACjL,kBAAkB,KAAKiF,SAAS,EAAE;MACvDnX,cAAc,CAACkS,kBAAkB,GAAGiL,oBAAoB,CAACjL,kBAAkB;MAC3ElS,cAAc,CAACmS,kBAAkB,GAAGgL,oBAAoB,CAAChL,kBAAkB;;IAG/EnS,cAAc,CAACmR,WAAW,GAAGgM,oBAAoB,CAAChM,WAAW;IAC7DnR,cAAc,CAACoR,WAAW,GAAG+L,oBAAoB,CAAC/L,WAAW;IAC7DpR,cAAc,CAACsR,YAAY,GAAG6L,oBAAoB,CAAC7L,YAAY;IAC/DtR,cAAc,CAACuR,YAAY,GAAG4L,oBAAoB,CAAC5L,YAAY;IAC/DvR,cAAc,CAACmV,QAAQ,GAAGgI,oBAAoB,CAAChI,QAAQ;IACvDnV,cAAc,CAAC8G,OAAO,GAAGzO,OAAO,CAACmlB,SAAS,CAACL,oBAAoB,CAACrW,OAAO,CAAC;IACxE,IAAIqW,oBAAoB,CAACtW,aAAa,EAAE;MACpC7G,cAAc,CAAC6G,aAAa,GAAGxO,OAAO,CAACmlB,SAAS,CAACL,oBAAoB,CAACtW,aAAa,CAAC;;IAExF7G,cAAc,CAACkL,MAAM,GAAGnR,MAAM,CAACyjB,SAAS,CAACL,oBAAoB,CAACjS,MAAM,CAAC;IACrElL,cAAc,CAACmL,MAAM,GAAGpR,MAAM,CAACyjB,SAAS,CAACL,oBAAoB,CAAChS,MAAM,CAAC;IACrEnL,cAAc,CAACqS,SAAS,GAAGtY,MAAM,CAACyjB,SAAS,CAACL,oBAAoB,CAAC9K,SAAS,CAAC;IAC3ErS,cAAc,CAAC8U,WAAW,GAAGqI,oBAAoB,CAACrI,WAAW;IAC7D9U,cAAc,CAACoO,kBAAkB,GAAG+O,oBAAoB,CAAC/O,kBAAkB;IAC3EpO,cAAc,CAACrE,SAAS,GAAGwhB,oBAAoB,CAACxhB,SAAS;IAEzD,IAAIwhB,oBAAoB,CAACnC,cAAc,EAAE;MACrC,KAAK,MAAM5P,aAAa,IAAI+R,oBAAoB,CAACnC,cAAc,EAAE;QAC7Dhb,cAAc,CAACiL,gBAAgB,CAC3BG,aAAa,CAAClD,QAAQ,EACtBnO,MAAM,CAACyjB,SAAS,CAACpS,aAAa,CAACF,MAAM,CAAC,EACtCE,aAAa,CAACD,MAAM,GAAGpR,MAAM,CAACyjB,SAAS,CAACpS,aAAa,CAACD,MAAM,CAAC,GAAGgM,SAAS,CAC5E;;;IAIT,IAAIgG,oBAAoB,CAAChC,aAAa,EAAE;MACpC,KAAK,MAAMrQ,YAAY,IAAIqS,oBAAoB,CAAChC,aAAa,EAAE;QAC3Dnb,cAAc,CAAC6K,eAAe,CAACC,YAAY,CAAC5C,QAAQ,EAAElO,MAAM,CAACwjB,SAAS,CAAC1S,YAAY,CAACnH,KAAK,CAAC,CAAC;;MAE/F3D,cAAc,CAAClF,gBAAgB,GAAGqiB,oBAAoB,CAACriB,gBAAgB;;IAG3E,IAAIqiB,oBAAoB,CAAC/B,mBAAmB,EAAE;MAC1C,KAAK,MAAME,kBAAkB,IAAI6B,oBAAoB,CAAC/B,mBAAmB,EAAE;QACvEpb,cAAc,CAAC+I,qBAAqB,CAChCuS,kBAAkB,CAACpT,QAAQ,EAC3BoT,kBAAkB,CAAChU,OAAO,KAAK6P,SAAS,GAAGmE,kBAAkB,CAAChU,OAAO,GAAGgU,kBAAkB,CAACnT,MAAM,EACjGmT,kBAAkB,CAAC9T,OAAO,CAC7B;;;IAIT,IAAI2V,oBAAoB,CAAC5B,mBAAmB,EAAE;MAC1C,KAAK,MAAME,kBAAkB,IAAI0B,oBAAoB,CAAC5B,mBAAmB,EAAE;QACvEvb,cAAc,CAACiJ,qBAAqB,CAChCwS,kBAAkB,CAACvT,QAAQ,EAC3BuT,kBAAkB,CAACnU,OAAO,KAAK6P,SAAS,GAAGsE,kBAAkB,CAACnU,OAAO,GAAGmU,kBAAkB,CAACtT,MAAM,EACjGsT,kBAAkB,CAACjU,OAAO,CAC7B;;;IAIT,IAAI2V,oBAAoB,CAACzB,aAAa,EAAE;MACpC,KAAK,MAAME,YAAY,IAAIuB,oBAAoB,CAACzB,aAAa,EAAE;QAC3D1b,cAAc,CAAC6I,eAAe,CAAC+S,YAAY,CAAC1T,QAAQ,EAAE0T,YAAY,CAACtU,OAAO,KAAK6P,SAAS,GAAGyE,YAAY,CAACtU,OAAO,GAAGsU,YAAY,CAACzT,MAAM,EAAEyT,YAAY,CAACpU,OAAO,CAAC;;;IAIpK,IAAI2V,oBAAoB,CAACtB,qBAAqB,EAAE;MAC5C,KAAK,MAAME,oBAAoB,IAAIoB,oBAAoB,CAACtB,qBAAqB,EAAE;QAC3E7b,cAAc,CAACmJ,uBAAuB,CAClC4S,oBAAoB,CAAC7T,QAAQ,EAC7B6T,oBAAoB,CAACzU,OAAO,KAAK6P,SAAS,GAAG4E,oBAAoB,CAACzU,OAAO,GAAGyU,oBAAoB,CAAC5T,MAAM,EACvG4T,oBAAoB,CAACvU,OAAO,CAC/B;;;IAIT,IAAI2V,oBAAoB,CAACnB,iBAAiB,EAAE;MACxC,KAAK,MAAME,gBAAgB,IAAIiB,oBAAoB,CAACnB,iBAAiB,EAAE;QACnEhc,cAAc,CAACqJ,mBAAmB,CAC9B6S,gBAAgB,CAAChU,QAAQ,EACzBgU,gBAAgB,CAAC5U,OAAO,KAAK6P,SAAS,GAAG+E,gBAAgB,CAAC5U,OAAO,GAAG4U,gBAAgB,CAAC/T,MAAM,EAC3F+T,gBAAgB,CAAC1U,OAAO,CAC3B;;;IAIT,IAAI2V,oBAAoB,CAAChB,aAAa,EAAE;MACpC,KAAK,MAAME,YAAY,IAAIc,oBAAoB,CAAChB,aAAa,EAAE;QAC3Dnc,cAAc,CAACyJ,eAAe,CAAC4S,YAAY,CAACnU,QAAQ,EAAEmU,YAAY,CAAC/U,OAAO,KAAK6P,SAAS,GAAGkF,YAAY,CAAC/U,OAAO,GAAG+U,YAAY,CAAClU,MAAM,EAAEkU,YAAY,CAAC7U,OAAO,CAAC;;;IAIpK,IAAI2V,oBAAoB,CAACb,iBAAiB,EAAE;MACxC,KAAK,MAAME,gBAAgB,IAAIW,oBAAoB,CAACb,iBAAiB,EAAE;QACnEtc,cAAc,CAAC2J,mBAAmB,CAC9B6S,gBAAgB,CAACtU,QAAQ,EACzBsU,gBAAgB,CAAClV,OAAO,KAAK6P,SAAS,GAAGqF,gBAAgB,CAAClV,OAAO,GAAGkV,gBAAgB,CAACrU,MAAM,EAC3FqU,gBAAgB,CAAChV,OAAO,CAC3B;;;IAIT,IAAI2V,oBAAoB,CAACV,kBAAkB,EAAE;MACzC,KAAK,MAAME,iBAAiB,IAAIQ,oBAAoB,CAACV,kBAAkB,EAAE;QACrEzc,cAAc,CAAC8J,oBAAoB,CAC/B6S,iBAAiB,CAACzU,QAAQ,EAC1ByU,iBAAiB,CAACrV,OAAO,KAAK6P,SAAS,GAAGwF,iBAAiB,CAACrV,OAAO,GAAGqV,iBAAiB,CAACxU,MAAM,EAC9FwU,iBAAiB,CAACnV,OAAO,CAC5B;;;IAIT,IAAI2V,oBAAoB,CAACP,iBAAiB,EAAE;MACxC,KAAK,MAAME,gBAAgB,IAAIK,oBAAoB,CAACP,iBAAiB,EAAE;QACnE5c,cAAc,CAAC0I,mBAAmB,CAC9BoU,gBAAgB,CAAC5U,QAAQ,EACzB4U,gBAAgB,CAACxV,OAAO,KAAK6P,SAAS,GAAG2F,gBAAgB,CAACxV,OAAO,GAAGwV,gBAAgB,CAAC3U,MAAM,EAC3F2U,gBAAgB,CAACtV,OAAO,CAC3B;;;IAIT,IAAI2V,oBAAoB,CAACJ,sBAAsB,EAAE;MAC7C,KAAK,MAAME,qBAAqB,IAAIE,oBAAoB,CAACJ,sBAAsB,EAAE;QAC7E/c,cAAc,CAACuJ,wBAAwB,CACnC0T,qBAAqB,CAAC/U,QAAQ,EAC9B+U,qBAAqB,CAAC3V,OAAO,KAAK6P,SAAS,GAAG8F,qBAAqB,CAAC3V,OAAO,GAAG2V,qBAAqB,CAAC9U,MAAM,EAC1G8U,qBAAqB,CAACzV,OAAO,CAChC;;MAELxH,cAAc,CAACqF,oBAAoB,GAAG8X,oBAAoB,CAAC9X,oBAAoB;;IAGnF,IAAI8X,oBAAoB,CAAClb,YAAY,IAAIob,KAAK,EAAE;MAC5C,MAAMC,aAAa,GAAGzjB,QAAQ,CAAC,2BAA2B,CAAC;MAC3DmG,cAAc,CAACiC,YAAY,GAAGqb,aAAa,CAAC1D,KAAK,CAACuD,oBAAoB,CAAClb,YAAY,EAAEob,KAAK,EAAED,OAAO,CAAC;;IAGxG;IACA,IAAIY,WAAiC;IACrC,IAAIb,oBAAoB,CAACtb,mBAAmB,EAAE;MAC1C,QAAQsb,oBAAoB,CAACtb,mBAAmB,CAACjC,IAAI;QACjD,KAAK,uBAAuB;UACxBoe,WAAW,GAAG,IAAI/kB,qBAAqB,EAAE;UACzC;QACJ,KAAK,+BAA+B;UAChC+kB,WAAW,GAAG,IAAI9kB,6BAA6B,EAAE;UACjD;QACJ,KAAK,aAAa;QAClB,KAAK,qBAAqB;UACtB8kB,WAAW,GAAG,IAAI5kB,mBAAmB,EAAE;UACvC;QACJ,KAAK,yBAAyB;UAC1B4kB,WAAW,GAAG,IAAI7kB,uBAAuB,EAAE;UAC3C;QACJ,KAAK,iCAAiC;UAClC6kB,WAAW,GAAG,IAAIzkB,+BAA+B,EAAE;UACnD;QACJ,KAAK,4BAA4B;UAC7BykB,WAAW,GAAG,IAAIhlB,0BAA0B,EAAE;UAC9C;QACJ,KAAK,sBAAsB;UACvBglB,WAAW,GAAG,IAAI3kB,oBAAoB,EAAE;UACxC;QACJ,KAAK,qBAAqB;UACtB2kB,WAAW,GAAG,IAAI1kB,mBAAmB,EAAE;UACvC;QACJ,KAAK,YAAY;QACjB,KAAK,oBAAoB;QACzB;UACI0kB,WAAW,GAAG,IAAIjlB,kBAAkB,EAAE;UACtC;;MAGRilB,WAAW,CAACC,KAAK,CAACd,oBAAoB,CAACtb,mBAAmB,EAAEwb,KAAK,CAAC;KACrE,MAAM;MACHW,WAAW,GAAG,IAAIjlB,kBAAkB,EAAE;MACtCilB,WAAW,CAACC,KAAK,CAACd,oBAAoB,EAAEE,KAAK,CAAC;;IAElDrd,cAAc,CAAC6B,mBAAmB,GAAGmc,WAAW;IAEhD;IACAhe,cAAc,CAACwS,iBAAiB,GAAG2K,oBAAoB,CAAC3K,iBAAiB;IACzExS,cAAc,CAAC0S,eAAe,GAAGyK,oBAAoB,CAACzK,eAAe;IACrE1S,cAAc,CAAC4S,cAAc,GAAG,CAAA/W,EAAA,GAAAshB,oBAAoB,CAACvK,cAAc,cAAA/W,EAAA,cAAAA,EAAA,GAAI,IAAI;IAC3EmE,cAAc,CAACyW,eAAe,GAAG0G,oBAAoB,CAAC1G,eAAe;IACrEzW,cAAc,CAAC0W,gBAAgB,GAAGyG,oBAAoB,CAACzG,gBAAgB;IACvE1W,cAAc,CAAC8a,qBAAqB,GAAGqC,oBAAoB,CAACrC,qBAAqB;IACjF9a,cAAc,CAAC+a,qBAAqB,GAAGoC,oBAAoB,CAACpC,qBAAqB;IAEjF/a,cAAc,CAAC8H,aAAa,GAAG,CAAAlM,EAAA,GAAAuhB,oBAAoB,CAACrV,aAAa,cAAAlM,EAAA,cAAAA,EAAA,GAAI,KAAK;IAC1EoE,cAAc,CAACiV,eAAe,GAAG,CAAAmC,EAAA,GAAA+F,oBAAoB,CAAClI,eAAe,cAAAmC,EAAA,cAAAA,EAAA,GAAI,CAAC,CAAC;EAC/E;EAEA;;;;;;;;;EASO,OAAOwC,KAAKA,CAACuD,oBAAyB,EAAEngB,aAAiC,EAAEogB,OAAe,EAAEc,UAAU,GAAG,KAAK,EAAEnhB,QAAiB;IACpI,MAAMD,IAAI,GAAGqgB,oBAAoB,CAACrgB,IAAI;IACtC,IAAIkc,MAAM,GAAqB,IAAI;IACnC,IAAIG,OAAO,GAAQ,IAAI;IACvB,IAAI5M,MAAkB;IACtB,IAAI8Q,KAAsB;IAE1B,IAAIrgB,aAAa,YAAY9C,UAAU,EAAE;MACrCqS,MAAM,GAAGvP,aAAa;KACzB,MAAM;MACHqgB,KAAK,GAAGrgB,aAAsB;MAC9BuP,MAAM,GAAG8Q,KAAK,CAACvc,SAAS,EAAE;;IAG9B,IAAIqc,oBAAoB,CAAC9D,YAAY,IAAK9M,MAAc,CAAC6M,wBAAwB,EAAE;MAC/ED,OAAO,GAAGgE,oBAAoB,CAAC9D,YAAY;MAC3C,MAAMjG,OAAO,GAAW+F,OAAO,CAACG,aAAa,CAAClG,OAAO,CAAC/X,MAAM,GAAG,CAAC,GAAG8d,OAAO,CAACG,aAAa,CAAClG,OAAO,CAACmB,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE;MAChHyE,MAAM,GAAIzM,MAAc,CAAC6M,wBAAwB,CAACD,OAAO,CAACI,UAAU,CAACC,eAAe,EAAEL,OAAO,CAACG,aAAa,CAACzF,QAAQ,EAAEsF,OAAO,CAACG,aAAa,CAACvF,QAAQ,EAAEX,OAAO,CAAC;;IAElK,MAAMpT,cAAc,GAAG,IAAIzF,cAAc,CAACuC,IAAI,EAAEC,QAAQ,IAAIogB,oBAAoB,CAACpgB,QAAQ,EAAEC,aAAa,EAAEgc,MAAM,EAAEmE,oBAAoB,CAACjgB,uBAAuB,CAAC;IAC/J8C,cAAc,CAACqZ,YAAY,GAAGF,OAAO;IACrCnZ,cAAc,CAAC6Z,QAAQ,GAAGuD,OAAO;IAEjC,IAAID,oBAAoB,CAAC7C,EAAE,EAAE;MACzBta,cAAc,CAACsa,EAAE,GAAG6C,oBAAoB,CAAC7C,EAAE;;IAG/C;IACA,IAAI6C,oBAAoB,CAAC9d,WAAW,EAAE;MAClCW,cAAc,CAACX,WAAW,GAAG,EAAE;MAC/B,KAAK,MAAM+a,IAAI,IAAI+C,oBAAoB,CAAC9d,WAAW,EAAE;QACjD,MAAM8e,SAAS,GAAG,EAAE;QACpB,KAAK,MAAM9D,GAAG,IAAID,IAAI,EAAE;UACpB+D,SAAS,CAAClf,IAAI,CAACvF,UAAU,CAACkgB,KAAK,CAACS,GAAG,EAAErd,aAAa,EAAEogB,OAAO,CAAC,CAAC;;QAGjEpd,cAAc,CAACX,WAAW,CAACJ,IAAI,CAACkf,SAAS,CAAC;;;IAIlD5jB,cAAc,CAAC2iB,MAAM,CAACC,oBAAoB,EAAEnd,cAAc,EAAEhD,aAAa,EAAEogB,OAAO,CAAC;IAEnF,IAAID,oBAAoB,CAACrG,WAAW,EAAE;MAClC9W,cAAc,CAAC8W,WAAW,GAAG/c,MAAM,CAACyjB,SAAS,CAACL,oBAAoB,CAACrG,WAAW,CAAC;;IAGnF;IACA,IAAIqG,oBAAoB,CAACrD,gBAAgB,EAAE;MACvC9Z,cAAc,CAAC8Z,gBAAgB,GAAGqD,oBAAoB,CAACrD,gBAAgB;;IAG3E,IAAI,CAACoE,UAAU,IAAI,CAACle,cAAc,CAAC8Z,gBAAgB,EAAE;MACjD9Z,cAAc,CAACC,KAAK,EAAE;;IAG1B,OAAOD,cAAc;EACzB;;AA/4FA;;;AAGuBzF,cAAA,CAAA+Y,eAAe,GAAG;AACzC;;;AAGuB/Y,cAAA,CAAAgZ,iBAAiB,GAAG;AAC3C;;;AAGuBhZ,cAAA,CAAA8R,uBAAuB,GAAG;AACjD;;;AAGuB9R,cAAA,CAAA+R,6BAA6B,GAAG;AAm4F3D5S,UAAU,CAAC0kB,oBAAoB,GAAG7jB,cAAc,CAACqf,KAAK"},"metadata":{},"sourceType":"module","externalDependencies":[]}