{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Ray } from \"../Culling/ray.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { LensFlare } from \"./lensFlare.js\";\nimport \"../Shaders/lensFlare.fragment.js\";\nimport \"../Shaders/lensFlare.vertex.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\n/**\n * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.\n * It is usually composed of several `lensFlare`.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/lenseFlare\n */\nexport class LensFlareSystem {\n  /** Gets the scene */\n  get scene() {\n    return this._scene;\n  }\n  /**\n   * Instantiates a lens flare system.\n   * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.\n   * It is usually composed of several `lensFlare`.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/lenseFlare\n   * @param name Define the name of the lens flare system in the scene\n   * @param emitter Define the source (the emitter) of the lens flares (it can be a camera, a light or a mesh).\n   * @param scene Define the scene the lens flare system belongs to\n   */\n  constructor(\n  /**\n   * Define the name of the lens flare system\n   */\n  name, emitter, scene) {\n    this.name = name;\n    /**\n     * List of lens flares used in this system.\n     */\n    this.lensFlares = new Array();\n    /**\n     * Define a limit from the border the lens flare can be visible.\n     */\n    this.borderLimit = 300;\n    /**\n     * Define a viewport border we do not want to see the lens flare in.\n     */\n    this.viewportBorder = 0;\n    /**\n     * Restricts the rendering of the effect to only the camera rendering this layer mask.\n     */\n    this.layerMask = 0x0fffffff;\n    this._vertexBuffers = {};\n    this._isEnabled = true;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    LensFlareSystem._SceneComponentInitialization(this._scene);\n    this._emitter = emitter;\n    this.id = name;\n    scene.lensFlareSystems.push(this);\n    this.meshesSelectionPredicate = m => scene.activeCamera && m.material && m.isVisible && m.isEnabled() && m.isBlocker && (m.layerMask & scene.activeCamera.layerMask) != 0;\n    const engine = scene.getEngine();\n    // VBO\n    const vertices = [];\n    vertices.push(1, 1);\n    vertices.push(-1, 1);\n    vertices.push(-1, -1);\n    vertices.push(1, -1);\n    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);\n    // Indices\n    this._createIndexBuffer();\n  }\n  _createIndexBuffer() {\n    const indices = [];\n    indices.push(0);\n    indices.push(1);\n    indices.push(2);\n    indices.push(0);\n    indices.push(2);\n    indices.push(3);\n    this._indexBuffer = this._scene.getEngine().createIndexBuffer(indices);\n  }\n  /**\n   * Define if the lens flare system is enabled.\n   */\n  get isEnabled() {\n    return this._isEnabled;\n  }\n  set isEnabled(value) {\n    this._isEnabled = value;\n  }\n  /**\n   * Get the scene the effects belongs to.\n   * @returns the scene holding the lens flare system\n   */\n  getScene() {\n    return this._scene;\n  }\n  /**\n   * Get the emitter of the lens flare system.\n   * It defines the source of the lens flares (it can be a camera, a light or a mesh).\n   * @returns the emitter of the lens flare system\n   */\n  getEmitter() {\n    return this._emitter;\n  }\n  /**\n   * Set the emitter of the lens flare system.\n   * It defines the source of the lens flares (it can be a camera, a light or a mesh).\n   * @param newEmitter Define the new emitter of the system\n   */\n  setEmitter(newEmitter) {\n    this._emitter = newEmitter;\n  }\n  /**\n   * Get the lens flare system emitter position.\n   * The emitter defines the source of the lens flares (it can be a camera, a light or a mesh).\n   * @returns the position\n   */\n  getEmitterPosition() {\n    return this._emitter.getAbsolutePosition ? this._emitter.getAbsolutePosition() : this._emitter.position;\n  }\n  /**\n   * @internal\n   */\n  computeEffectivePosition(globalViewport) {\n    let position = this.getEmitterPosition();\n    position = Vector3.Project(position, Matrix.Identity(), this._scene.getTransformMatrix(), globalViewport);\n    this._positionX = position.x;\n    this._positionY = position.y;\n    position = Vector3.TransformCoordinates(this.getEmitterPosition(), this._scene.getViewMatrix());\n    if (this.viewportBorder > 0) {\n      globalViewport.x -= this.viewportBorder;\n      globalViewport.y -= this.viewportBorder;\n      globalViewport.width += this.viewportBorder * 2;\n      globalViewport.height += this.viewportBorder * 2;\n      position.x += this.viewportBorder;\n      position.y += this.viewportBorder;\n      this._positionX += this.viewportBorder;\n      this._positionY += this.viewportBorder;\n    }\n    const rhs = this._scene.useRightHandedSystem;\n    const okZ = position.z > 0 && !rhs || position.z < 0 && rhs;\n    if (okZ) {\n      if (this._positionX > globalViewport.x && this._positionX < globalViewport.x + globalViewport.width) {\n        if (this._positionY > globalViewport.y && this._positionY < globalViewport.y + globalViewport.height) {\n          return true;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  /** @internal */\n  _isVisible() {\n    if (!this._isEnabled || !this._scene.activeCamera) {\n      return false;\n    }\n    const emitterPosition = this.getEmitterPosition();\n    const direction = emitterPosition.subtract(this._scene.activeCamera.globalPosition);\n    const distance = direction.length();\n    direction.normalize();\n    const ray = new Ray(this._scene.activeCamera.globalPosition, direction);\n    const pickInfo = this._scene.pickWithRay(ray, this.meshesSelectionPredicate, true);\n    return !pickInfo || !pickInfo.hit || pickInfo.distance > distance;\n  }\n  /**\n   * @internal\n   */\n  render() {\n    if (!this._scene.activeCamera) {\n      return false;\n    }\n    const engine = this._scene.getEngine();\n    const viewport = this._scene.activeCamera.viewport;\n    const globalViewport = viewport.toGlobal(engine.getRenderWidth(true), engine.getRenderHeight(true));\n    // Position\n    if (!this.computeEffectivePosition(globalViewport)) {\n      return false;\n    }\n    // Visibility\n    if (!this._isVisible()) {\n      return false;\n    }\n    // Intensity\n    let awayX;\n    let awayY;\n    if (this._positionX < this.borderLimit + globalViewport.x) {\n      awayX = this.borderLimit + globalViewport.x - this._positionX;\n    } else if (this._positionX > globalViewport.x + globalViewport.width - this.borderLimit) {\n      awayX = this._positionX - globalViewport.x - globalViewport.width + this.borderLimit;\n    } else {\n      awayX = 0;\n    }\n    if (this._positionY < this.borderLimit + globalViewport.y) {\n      awayY = this.borderLimit + globalViewport.y - this._positionY;\n    } else if (this._positionY > globalViewport.y + globalViewport.height - this.borderLimit) {\n      awayY = this._positionY - globalViewport.y - globalViewport.height + this.borderLimit;\n    } else {\n      awayY = 0;\n    }\n    let away = awayX > awayY ? awayX : awayY;\n    away -= this.viewportBorder;\n    if (away > this.borderLimit) {\n      away = this.borderLimit;\n    }\n    let intensity = 1.0 - Scalar.Clamp(away / this.borderLimit, 0, 1);\n    if (intensity < 0) {\n      return false;\n    }\n    if (intensity > 1.0) {\n      intensity = 1.0;\n    }\n    if (this.viewportBorder > 0) {\n      globalViewport.x += this.viewportBorder;\n      globalViewport.y += this.viewportBorder;\n      globalViewport.width -= this.viewportBorder * 2;\n      globalViewport.height -= this.viewportBorder * 2;\n      this._positionX -= this.viewportBorder;\n      this._positionY -= this.viewportBorder;\n    }\n    // Position\n    const centerX = globalViewport.x + globalViewport.width / 2;\n    const centerY = globalViewport.y + globalViewport.height / 2;\n    const distX = centerX - this._positionX;\n    const distY = centerY - this._positionY;\n    // Effects\n    engine.setState(false);\n    engine.setDepthBuffer(false);\n    // Flares\n    for (let index = 0; index < this.lensFlares.length; index++) {\n      const flare = this.lensFlares[index];\n      if (!flare._drawWrapper.effect.isReady() || flare.texture && !flare.texture.isReady()) {\n        continue;\n      }\n      engine.enableEffect(flare._drawWrapper);\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, flare._drawWrapper.effect);\n      engine.setAlphaMode(flare.alphaMode);\n      const x = centerX - distX * flare.position;\n      const y = centerY - distY * flare.position;\n      const cw = flare.size;\n      const ch = flare.size * engine.getAspectRatio(this._scene.activeCamera, true);\n      const cx = 2 * (x / (globalViewport.width + globalViewport.x * 2)) - 1.0;\n      const cy = 1.0 - 2 * (y / (globalViewport.height + globalViewport.y * 2));\n      const viewportMatrix = Matrix.FromValues(cw / 2, 0, 0, 0, 0, ch / 2, 0, 0, 0, 0, 1, 0, cx, cy, 0, 1);\n      flare._drawWrapper.effect.setMatrix(\"viewportMatrix\", viewportMatrix);\n      // Texture\n      flare._drawWrapper.effect.setTexture(\"textureSampler\", flare.texture);\n      // Color\n      flare._drawWrapper.effect.setFloat4(\"color\", flare.color.r * intensity, flare.color.g * intensity, flare.color.b * intensity, 1.0);\n      // Draw order\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    }\n    engine.setDepthBuffer(true);\n    engine.setAlphaMode(0);\n    return true;\n  }\n  /**\n   * Rebuilds the lens flare system\n   */\n  rebuild() {\n    var _a;\n    this._createIndexBuffer();\n    for (const key in this._vertexBuffers) {\n      (_a = this._vertexBuffers[key]) === null || _a === void 0 ? void 0 : _a._rebuild();\n    }\n  }\n  /**\n   * Dispose and release the lens flare with its associated resources.\n   */\n  dispose() {\n    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n    if (this._indexBuffer) {\n      this._scene.getEngine()._releaseBuffer(this._indexBuffer);\n      this._indexBuffer = null;\n    }\n    while (this.lensFlares.length) {\n      this.lensFlares[0].dispose();\n    }\n    // Remove from scene\n    const index = this._scene.lensFlareSystems.indexOf(this);\n    this._scene.lensFlareSystems.splice(index, 1);\n  }\n  /**\n   * Parse a lens flare system from a JSON representation\n   * @param parsedLensFlareSystem Define the JSON to parse\n   * @param scene Define the scene the parsed system should be instantiated in\n   * @param rootUrl Define the rootUrl of the load sequence to easily find a load relative dependencies such as textures\n   * @returns the parsed system\n   */\n  static Parse(parsedLensFlareSystem, scene, rootUrl) {\n    const emitter = scene.getLastEntryById(parsedLensFlareSystem.emitterId);\n    const name = parsedLensFlareSystem.name || \"lensFlareSystem#\" + parsedLensFlareSystem.emitterId;\n    const lensFlareSystem = new LensFlareSystem(name, emitter, scene);\n    lensFlareSystem.id = parsedLensFlareSystem.id || name;\n    lensFlareSystem.borderLimit = parsedLensFlareSystem.borderLimit;\n    for (let index = 0; index < parsedLensFlareSystem.flares.length; index++) {\n      const parsedFlare = parsedLensFlareSystem.flares[index];\n      LensFlare.AddFlare(parsedFlare.size, parsedFlare.position, Color3.FromArray(parsedFlare.color), parsedFlare.textureName ? rootUrl + parsedFlare.textureName : \"\", lensFlareSystem);\n    }\n    return lensFlareSystem;\n  }\n  /**\n   * Serialize the current Lens Flare System into a JSON representation.\n   * @returns the serialized JSON\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.id = this.id;\n    serializationObject.name = this.name;\n    serializationObject.emitterId = this.getEmitter().id;\n    serializationObject.borderLimit = this.borderLimit;\n    serializationObject.flares = [];\n    for (let index = 0; index < this.lensFlares.length; index++) {\n      const flare = this.lensFlares[index];\n      serializationObject.flares.push({\n        size: flare.size,\n        position: flare.position,\n        color: flare.color.asArray(),\n        textureName: Tools.GetFilename(flare.texture ? flare.texture.name : \"\")\n      });\n    }\n    return serializationObject;\n  }\n}\n/**\n * @internal\n */\nLensFlareSystem._SceneComponentInitialization = _ => {\n  throw _WarnImport(\"LensFlareSystemSceneComponent\");\n};","map":{"version":3,"names":["Tools","Matrix","Vector3","Scalar","EngineStore","VertexBuffer","Ray","Material","LensFlare","_WarnImport","Color3","LensFlareSystem","scene","_scene","constructor","name","emitter","lensFlares","Array","borderLimit","viewportBorder","layerMask","_vertexBuffers","_isEnabled","LastCreatedScene","_SceneComponentInitialization","_emitter","id","lensFlareSystems","push","meshesSelectionPredicate","m","activeCamera","material","isVisible","isEnabled","isBlocker","engine","getEngine","vertices","PositionKind","_createIndexBuffer","indices","_indexBuffer","createIndexBuffer","value","getScene","getEmitter","setEmitter","newEmitter","getEmitterPosition","getAbsolutePosition","position","computeEffectivePosition","globalViewport","Project","Identity","getTransformMatrix","_positionX","x","_positionY","y","TransformCoordinates","getViewMatrix","width","height","rhs","useRightHandedSystem","okZ","z","_isVisible","emitterPosition","direction","subtract","globalPosition","distance","length","normalize","ray","pickInfo","pickWithRay","hit","render","viewport","toGlobal","getRenderWidth","getRenderHeight","awayX","awayY","away","intensity","Clamp","centerX","centerY","distX","distY","setState","setDepthBuffer","index","flare","_drawWrapper","effect","isReady","texture","enableEffect","bindBuffers","setAlphaMode","alphaMode","cw","size","ch","getAspectRatio","cx","cy","viewportMatrix","FromValues","setMatrix","setTexture","setFloat4","color","r","g","b","drawElementsType","TriangleFillMode","rebuild","key","_a","_rebuild","dispose","vertexBuffer","_releaseBuffer","indexOf","splice","Parse","parsedLensFlareSystem","rootUrl","getLastEntryById","emitterId","lensFlareSystem","flares","parsedFlare","AddFlare","FromArray","textureName","serialize","serializationObject","asArray","GetFilename","_"],"sources":["../../../../dev/core/src/LensFlares/lensFlareSystem.ts"],"sourcesContent":["import { Tools } from \"../Misc/tools\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Ray } from \"../Culling/ray\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { LensFlare } from \"./lensFlare\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/lensFlare.fragment\";\r\nimport \"../Shaders/lensFlare.vertex\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { Viewport } from \"../Maths/math.viewport\";\r\n\r\n/**\r\n * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.\r\n * It is usually composed of several `lensFlare`.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/lenseFlare\r\n */\r\nexport class LensFlareSystem {\r\n    /**\r\n     * List of lens flares used in this system.\r\n     */\r\n    public lensFlares = new Array<LensFlare>();\r\n\r\n    /**\r\n     * Define a limit from the border the lens flare can be visible.\r\n     */\r\n    public borderLimit = 300;\r\n\r\n    /**\r\n     * Define a viewport border we do not want to see the lens flare in.\r\n     */\r\n    public viewportBorder = 0;\r\n\r\n    /**\r\n     * Define a predicate which could limit the list of meshes able to occlude the effect.\r\n     */\r\n    public meshesSelectionPredicate: (mesh: AbstractMesh) => boolean;\r\n\r\n    /**\r\n     * Restricts the rendering of the effect to only the camera rendering this layer mask.\r\n     */\r\n    public layerMask: number = 0x0fffffff;\r\n\r\n    /** Gets the scene */\r\n    public get scene() {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Define the id of the lens flare system in the scene.\r\n     * (equal to name by default)\r\n     */\r\n    public id: string;\r\n\r\n    private _scene: Scene;\r\n    private _emitter: any;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _positionX: number;\r\n    private _positionY: number;\r\n    private _isEnabled = true;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"LensFlareSystemSceneComponent\");\r\n    };\r\n\r\n    /**\r\n     * Instantiates a lens flare system.\r\n     * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.\r\n     * It is usually composed of several `lensFlare`.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/lenseFlare\r\n     * @param name Define the name of the lens flare system in the scene\r\n     * @param emitter Define the source (the emitter) of the lens flares (it can be a camera, a light or a mesh).\r\n     * @param scene Define the scene the lens flare system belongs to\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define the name of the lens flare system\r\n         */\r\n        public name: string,\r\n        emitter: any,\r\n        scene: Scene\r\n    ) {\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        LensFlareSystem._SceneComponentInitialization(this._scene);\r\n\r\n        this._emitter = emitter;\r\n        this.id = name;\r\n        scene.lensFlareSystems.push(this);\r\n\r\n        this.meshesSelectionPredicate = (m) =>\r\n            <boolean>(scene.activeCamera && m.material && m.isVisible && m.isEnabled() && m.isBlocker && (m.layerMask & scene.activeCamera.layerMask) != 0);\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n\r\n        // Indices\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    private _createIndexBuffer(): void {\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = this._scene.getEngine().createIndexBuffer(indices);\r\n    }\r\n\r\n    /**\r\n     * Define if the lens flare system is enabled.\r\n     */\r\n    public get isEnabled(): boolean {\r\n        return this._isEnabled;\r\n    }\r\n\r\n    public set isEnabled(value: boolean) {\r\n        this._isEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Get the scene the effects belongs to.\r\n     * @returns the scene holding the lens flare system\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Get the emitter of the lens flare system.\r\n     * It defines the source of the lens flares (it can be a camera, a light or a mesh).\r\n     * @returns the emitter of the lens flare system\r\n     */\r\n    public getEmitter(): any {\r\n        return this._emitter;\r\n    }\r\n\r\n    /**\r\n     * Set the emitter of the lens flare system.\r\n     * It defines the source of the lens flares (it can be a camera, a light or a mesh).\r\n     * @param newEmitter Define the new emitter of the system\r\n     */\r\n    public setEmitter(newEmitter: any): void {\r\n        this._emitter = newEmitter;\r\n    }\r\n\r\n    /**\r\n     * Get the lens flare system emitter position.\r\n     * The emitter defines the source of the lens flares (it can be a camera, a light or a mesh).\r\n     * @returns the position\r\n     */\r\n    public getEmitterPosition(): Vector3 {\r\n        return this._emitter.getAbsolutePosition ? this._emitter.getAbsolutePosition() : this._emitter.position;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public computeEffectivePosition(globalViewport: Viewport): boolean {\r\n        let position = this.getEmitterPosition();\r\n\r\n        position = Vector3.Project(position, Matrix.Identity(), this._scene.getTransformMatrix(), globalViewport);\r\n\r\n        this._positionX = position.x;\r\n        this._positionY = position.y;\r\n\r\n        position = Vector3.TransformCoordinates(this.getEmitterPosition(), this._scene.getViewMatrix());\r\n\r\n        if (this.viewportBorder > 0) {\r\n            globalViewport.x -= this.viewportBorder;\r\n            globalViewport.y -= this.viewportBorder;\r\n            globalViewport.width += this.viewportBorder * 2;\r\n            globalViewport.height += this.viewportBorder * 2;\r\n            position.x += this.viewportBorder;\r\n            position.y += this.viewportBorder;\r\n            this._positionX += this.viewportBorder;\r\n            this._positionY += this.viewportBorder;\r\n        }\r\n\r\n        const rhs = this._scene.useRightHandedSystem;\r\n        const okZ = (position.z > 0 && !rhs) || (position.z < 0 && rhs);\r\n\r\n        if (okZ) {\r\n            if (this._positionX > globalViewport.x && this._positionX < globalViewport.x + globalViewport.width) {\r\n                if (this._positionY > globalViewport.y && this._positionY < globalViewport.y + globalViewport.height) {\r\n                    return true;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _isVisible(): boolean {\r\n        if (!this._isEnabled || !this._scene.activeCamera) {\r\n            return false;\r\n        }\r\n\r\n        const emitterPosition = this.getEmitterPosition();\r\n        const direction = emitterPosition.subtract(this._scene.activeCamera.globalPosition);\r\n        const distance = direction.length();\r\n        direction.normalize();\r\n\r\n        const ray = new Ray(this._scene.activeCamera.globalPosition, direction);\r\n        const pickInfo = this._scene.pickWithRay(ray, this.meshesSelectionPredicate, true);\r\n\r\n        return !pickInfo || !pickInfo.hit || pickInfo.distance > distance;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public render(): boolean {\r\n        if (!this._scene.activeCamera) {\r\n            return false;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n        const viewport = this._scene.activeCamera.viewport;\r\n        const globalViewport = viewport.toGlobal(engine.getRenderWidth(true), engine.getRenderHeight(true));\r\n\r\n        // Position\r\n        if (!this.computeEffectivePosition(globalViewport)) {\r\n            return false;\r\n        }\r\n\r\n        // Visibility\r\n        if (!this._isVisible()) {\r\n            return false;\r\n        }\r\n\r\n        // Intensity\r\n        let awayX;\r\n        let awayY;\r\n\r\n        if (this._positionX < this.borderLimit + globalViewport.x) {\r\n            awayX = this.borderLimit + globalViewport.x - this._positionX;\r\n        } else if (this._positionX > globalViewport.x + globalViewport.width - this.borderLimit) {\r\n            awayX = this._positionX - globalViewport.x - globalViewport.width + this.borderLimit;\r\n        } else {\r\n            awayX = 0;\r\n        }\r\n\r\n        if (this._positionY < this.borderLimit + globalViewport.y) {\r\n            awayY = this.borderLimit + globalViewport.y - this._positionY;\r\n        } else if (this._positionY > globalViewport.y + globalViewport.height - this.borderLimit) {\r\n            awayY = this._positionY - globalViewport.y - globalViewport.height + this.borderLimit;\r\n        } else {\r\n            awayY = 0;\r\n        }\r\n\r\n        let away = awayX > awayY ? awayX : awayY;\r\n\r\n        away -= this.viewportBorder;\r\n\r\n        if (away > this.borderLimit) {\r\n            away = this.borderLimit;\r\n        }\r\n\r\n        let intensity = 1.0 - Scalar.Clamp(away / this.borderLimit, 0, 1);\r\n        if (intensity < 0) {\r\n            return false;\r\n        }\r\n\r\n        if (intensity > 1.0) {\r\n            intensity = 1.0;\r\n        }\r\n\r\n        if (this.viewportBorder > 0) {\r\n            globalViewport.x += this.viewportBorder;\r\n            globalViewport.y += this.viewportBorder;\r\n            globalViewport.width -= this.viewportBorder * 2;\r\n            globalViewport.height -= this.viewportBorder * 2;\r\n            this._positionX -= this.viewportBorder;\r\n            this._positionY -= this.viewportBorder;\r\n        }\r\n\r\n        // Position\r\n        const centerX = globalViewport.x + globalViewport.width / 2;\r\n        const centerY = globalViewport.y + globalViewport.height / 2;\r\n        const distX = centerX - this._positionX;\r\n        const distY = centerY - this._positionY;\r\n\r\n        // Effects\r\n        engine.setState(false);\r\n        engine.setDepthBuffer(false);\r\n\r\n        // Flares\r\n        for (let index = 0; index < this.lensFlares.length; index++) {\r\n            const flare = this.lensFlares[index];\r\n\r\n            if (!flare._drawWrapper.effect!.isReady() || (flare.texture && !flare.texture.isReady())) {\r\n                continue;\r\n            }\r\n\r\n            engine.enableEffect(flare._drawWrapper);\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, flare._drawWrapper.effect!);\r\n\r\n            engine.setAlphaMode(flare.alphaMode);\r\n\r\n            const x = centerX - distX * flare.position;\r\n            const y = centerY - distY * flare.position;\r\n\r\n            const cw = flare.size;\r\n            const ch = flare.size * engine.getAspectRatio(this._scene.activeCamera, true);\r\n            const cx = 2 * (x / (globalViewport.width + globalViewport.x * 2)) - 1.0;\r\n            const cy = 1.0 - 2 * (y / (globalViewport.height + globalViewport.y * 2));\r\n\r\n            const viewportMatrix = Matrix.FromValues(cw / 2, 0, 0, 0, 0, ch / 2, 0, 0, 0, 0, 1, 0, cx, cy, 0, 1);\r\n\r\n            flare._drawWrapper.effect!.setMatrix(\"viewportMatrix\", viewportMatrix);\r\n\r\n            // Texture\r\n            flare._drawWrapper.effect!.setTexture(\"textureSampler\", flare.texture);\r\n\r\n            // Color\r\n            flare._drawWrapper.effect!.setFloat4(\"color\", flare.color.r * intensity, flare.color.g * intensity, flare.color.b * intensity, 1.0);\r\n\r\n            // Draw order\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n\r\n        engine.setDepthBuffer(true);\r\n        engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the lens flare system\r\n     */\r\n    public rebuild(): void {\r\n        this._createIndexBuffer();\r\n\r\n        for (const key in this._vertexBuffers) {\r\n            this._vertexBuffers[key]?._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose and release the lens flare with its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        while (this.lensFlares.length) {\r\n            this.lensFlares[0].dispose();\r\n        }\r\n\r\n        // Remove from scene\r\n        const index = this._scene.lensFlareSystems.indexOf(this);\r\n        this._scene.lensFlareSystems.splice(index, 1);\r\n    }\r\n\r\n    /**\r\n     * Parse a lens flare system from a JSON representation\r\n     * @param parsedLensFlareSystem Define the JSON to parse\r\n     * @param scene Define the scene the parsed system should be instantiated in\r\n     * @param rootUrl Define the rootUrl of the load sequence to easily find a load relative dependencies such as textures\r\n     * @returns the parsed system\r\n     */\r\n    public static Parse(parsedLensFlareSystem: any, scene: Scene, rootUrl: string): LensFlareSystem {\r\n        const emitter = scene.getLastEntryById(parsedLensFlareSystem.emitterId);\r\n\r\n        const name = parsedLensFlareSystem.name || \"lensFlareSystem#\" + parsedLensFlareSystem.emitterId;\r\n\r\n        const lensFlareSystem = new LensFlareSystem(name, emitter, scene);\r\n\r\n        lensFlareSystem.id = parsedLensFlareSystem.id || name;\r\n        lensFlareSystem.borderLimit = parsedLensFlareSystem.borderLimit;\r\n\r\n        for (let index = 0; index < parsedLensFlareSystem.flares.length; index++) {\r\n            const parsedFlare = parsedLensFlareSystem.flares[index];\r\n            LensFlare.AddFlare(\r\n                parsedFlare.size,\r\n                parsedFlare.position,\r\n                Color3.FromArray(parsedFlare.color),\r\n                parsedFlare.textureName ? rootUrl + parsedFlare.textureName : \"\",\r\n                lensFlareSystem\r\n            );\r\n        }\r\n\r\n        return lensFlareSystem;\r\n    }\r\n\r\n    /**\r\n     * Serialize the current Lens Flare System into a JSON representation.\r\n     * @returns the serialized JSON\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.id = this.id;\r\n        serializationObject.name = this.name;\r\n\r\n        serializationObject.emitterId = this.getEmitter().id;\r\n        serializationObject.borderLimit = this.borderLimit;\r\n\r\n        serializationObject.flares = [];\r\n        for (let index = 0; index < this.lensFlares.length; index++) {\r\n            const flare = this.lensFlares[index];\r\n\r\n            serializationObject.flares.push({\r\n                size: flare.size,\r\n                position: flare.position,\r\n                color: flare.color.asArray(),\r\n                textureName: Tools.GetFilename(flare.texture ? flare.texture.name : \"\"),\r\n            });\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}