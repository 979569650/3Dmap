{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { Bone } from \"./bone.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { Animation } from \"../Animations/animation.js\";\nimport { AnimationRange } from \"../Animations/animationRange.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { DeepCopier } from \"../Misc/deepCopier.js\";\n/**\n * Class used to handle skinning animations\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\n */\nexport class Skeleton {\n  /**\n   * Gets or sets a boolean indicating that bone matrices should be stored as a texture instead of using shader uniforms (default is true).\n   * Please note that this option is not available if the hardware does not support it\n   */\n  get useTextureToStoreBoneMatrices() {\n    return this._useTextureToStoreBoneMatrices;\n  }\n  set useTextureToStoreBoneMatrices(value) {\n    this._useTextureToStoreBoneMatrices = value;\n    this._markAsDirty();\n  }\n  /**\n   * Gets or sets the animation properties override\n   */\n  get animationPropertiesOverride() {\n    if (!this._animationPropertiesOverride) {\n      return this._scene.animationPropertiesOverride;\n    }\n    return this._animationPropertiesOverride;\n  }\n  set animationPropertiesOverride(value) {\n    this._animationPropertiesOverride = value;\n  }\n  /**\n   * Gets a boolean indicating that the skeleton effectively stores matrices into a texture\n   */\n  get isUsingTextureForMatrices() {\n    return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;\n  }\n  /**\n   * Gets the unique ID of this skeleton\n   */\n  get uniqueId() {\n    return this._uniqueId;\n  }\n  /**\n   * Creates a new skeleton\n   * @param name defines the skeleton name\n   * @param id defines the skeleton Id\n   * @param scene defines the hosting scene\n   */\n  constructor( /** defines the skeleton name */\n  name, /** defines the skeleton Id */\n  id, scene) {\n    this.name = name;\n    this.id = id;\n    /**\n     * Defines the list of child bones\n     */\n    this.bones = new Array();\n    /**\n     * Defines a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)\n     */\n    this.needInitialSkinMatrix = false;\n    this._isDirty = true;\n    this._meshesWithPoseMatrix = new Array();\n    this._identity = Matrix.Identity();\n    this._currentRenderId = -1;\n    this._ranges = {};\n    this._absoluteTransformIsDirty = true;\n    this._canUseTextureForBones = false;\n    this._uniqueId = 0;\n    /** @internal */\n    this._numBonesWithLinkedTransformNode = 0;\n    /** @internal */\n    this._hasWaitingData = null;\n    /** @internal */\n    this._parentContainer = null;\n    /**\n     * Specifies if the skeleton should be serialized\n     */\n    this.doNotSerialize = false;\n    this._useTextureToStoreBoneMatrices = true;\n    this._animationPropertiesOverride = null;\n    // Events\n    /**\n     * An observable triggered before computing the skeleton's matrices\n     */\n    this.onBeforeComputeObservable = new Observable();\n    this.bones = [];\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this._uniqueId = this._scene.getUniqueId();\n    this._scene.addSkeleton(this);\n    //make sure it will recalculate the matrix next time prepare is called.\n    this._isDirty = true;\n    const engineCaps = this._scene.getEngine().getCaps();\n    this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;\n  }\n  /**\n   * Gets the current object class name.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"Skeleton\";\n  }\n  /**\n   * Returns an array containing the root bones\n   * @returns an array containing the root bones\n   */\n  getChildren() {\n    return this.bones.filter(b => !b.getParent());\n  }\n  // Members\n  /**\n   * Gets the list of transform matrices to send to shaders (one matrix per bone)\n   * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\n   * @returns a Float32Array containing matrices data\n   */\n  getTransformMatrices(mesh) {\n    if (this.needInitialSkinMatrix) {\n      if (!mesh._bonesTransformMatrices) {\n        this.prepare();\n      }\n      return mesh._bonesTransformMatrices;\n    }\n    if (!this._transformMatrices || this._isDirty) {\n      this.prepare();\n    }\n    return this._transformMatrices;\n  }\n  /**\n   * Gets the list of transform matrices to send to shaders inside a texture (one matrix per bone)\n   * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\n   * @returns a raw texture containing the data\n   */\n  getTransformMatrixTexture(mesh) {\n    if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {\n      return mesh._transformMatrixTexture;\n    }\n    return this._transformMatrixTexture;\n  }\n  /**\n   * Gets the current hosting scene\n   * @returns a scene object\n   */\n  getScene() {\n    return this._scene;\n  }\n  // Methods\n  /**\n   * Gets a string representing the current skeleton data\n   * @param fullDetails defines a boolean indicating if we want a verbose version\n   * @returns a string representing the current skeleton data\n   */\n  toString(fullDetails) {\n    let ret = `Name: ${this.name}, nBones: ${this.bones.length}`;\n    ret += `, nAnimationRanges: ${this._ranges ? Object.keys(this._ranges).length : \"none\"}`;\n    if (fullDetails) {\n      ret += \", Ranges: {\";\n      let first = true;\n      for (const name in this._ranges) {\n        if (first) {\n          ret += \", \";\n          first = false;\n        }\n        ret += name;\n      }\n      ret += \"}\";\n    }\n    return ret;\n  }\n  /**\n   * Get bone's index searching by name\n   * @param name defines bone's name to search for\n   * @returns the indice of the bone. Returns -1 if not found\n   */\n  getBoneIndexByName(name) {\n    for (let boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {\n      if (this.bones[boneIndex].name === name) {\n        return boneIndex;\n      }\n    }\n    return -1;\n  }\n  /**\n   * Create a new animation range\n   * @param name defines the name of the range\n   * @param from defines the start key\n   * @param to defines the end key\n   */\n  createAnimationRange(name, from, to) {\n    // check name not already in use\n    if (!this._ranges[name]) {\n      this._ranges[name] = new AnimationRange(name, from, to);\n      for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n        if (this.bones[i].animations[0]) {\n          this.bones[i].animations[0].createRange(name, from, to);\n        }\n      }\n    }\n  }\n  /**\n   * Delete a specific animation range\n   * @param name defines the name of the range\n   * @param deleteFrames defines if frames must be removed as well\n   */\n  deleteAnimationRange(name, deleteFrames = true) {\n    for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n      if (this.bones[i].animations[0]) {\n        this.bones[i].animations[0].deleteRange(name, deleteFrames);\n      }\n    }\n    this._ranges[name] = null; // said much faster than 'delete this._range[name]'\n  }\n  /**\n   * Gets a specific animation range\n   * @param name defines the name of the range to look for\n   * @returns the requested animation range or null if not found\n   */\n  getAnimationRange(name) {\n    return this._ranges[name] || null;\n  }\n  /**\n   * Gets the list of all animation ranges defined on this skeleton\n   * @returns an array\n   */\n  getAnimationRanges() {\n    const animationRanges = [];\n    let name;\n    for (name in this._ranges) {\n      animationRanges.push(this._ranges[name]);\n    }\n    return animationRanges;\n  }\n  /**\n   * Copy animation range from a source skeleton.\n   * This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences\n   * @param source defines the source skeleton\n   * @param name defines the name of the range to copy\n   * @param rescaleAsRequired defines if rescaling must be applied if required\n   * @returns true if operation was successful\n   */\n  copyAnimationRange(source, name, rescaleAsRequired = false) {\n    if (this._ranges[name] || !source.getAnimationRange(name)) {\n      return false;\n    }\n    let ret = true;\n    const frameOffset = this._getHighestAnimationFrame() + 1;\n    // make a dictionary of source skeleton's bones, so exact same order or doubly nested loop is not required\n    const boneDict = {};\n    const sourceBones = source.bones;\n    let nBones;\n    let i;\n    for (i = 0, nBones = sourceBones.length; i < nBones; i++) {\n      boneDict[sourceBones[i].name] = sourceBones[i];\n    }\n    if (this.bones.length !== sourceBones.length) {\n      Logger.Warn(`copyAnimationRange: this rig has ${this.bones.length} bones, while source as ${sourceBones.length}`);\n      ret = false;\n    }\n    const skelDimensionsRatio = rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;\n    for (i = 0, nBones = this.bones.length; i < nBones; i++) {\n      const boneName = this.bones[i].name;\n      const sourceBone = boneDict[boneName];\n      if (sourceBone) {\n        ret = ret && this.bones[i].copyAnimationRange(sourceBone, name, frameOffset, rescaleAsRequired, skelDimensionsRatio);\n      } else {\n        Logger.Warn(\"copyAnimationRange: not same rig, missing source bone \" + boneName);\n        ret = false;\n      }\n    }\n    // do not call createAnimationRange(), since it also is done to bones, which was already done\n    const range = source.getAnimationRange(name);\n    if (range) {\n      this._ranges[name] = new AnimationRange(name, range.from + frameOffset, range.to + frameOffset);\n    }\n    return ret;\n  }\n  /**\n   * Forces the skeleton to go to rest pose\n   */\n  returnToRest() {\n    for (const bone of this.bones) {\n      if (bone._index !== -1) {\n        bone.returnToRest();\n      }\n    }\n  }\n  _getHighestAnimationFrame() {\n    let ret = 0;\n    for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n      if (this.bones[i].animations[0]) {\n        const highest = this.bones[i].animations[0].getHighestFrame();\n        if (ret < highest) {\n          ret = highest;\n        }\n      }\n    }\n    return ret;\n  }\n  /**\n   * Begin a specific animation range\n   * @param name defines the name of the range to start\n   * @param loop defines if looping must be turned on (false by default)\n   * @param speedRatio defines the speed ratio to apply (1 by default)\n   * @param onAnimationEnd defines a callback which will be called when animation will end\n   * @returns a new animatable\n   */\n  beginAnimation(name, loop, speedRatio, onAnimationEnd) {\n    const range = this.getAnimationRange(name);\n    if (!range) {\n      return null;\n    }\n    return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);\n  }\n  /**\n   * Convert the keyframes for a range of animation on a skeleton to be relative to a given reference frame.\n   * @param skeleton defines the Skeleton containing the animation range to convert\n   * @param referenceFrame defines the frame that keyframes in the range will be relative to\n   * @param range defines the name of the AnimationRange belonging to the Skeleton to convert\n   * @returns the original skeleton\n   */\n  static MakeAnimationAdditive(skeleton, referenceFrame = 0, range) {\n    const rangeValue = skeleton.getAnimationRange(range);\n    // We can't make a range additive if it doesn't exist\n    if (!rangeValue) {\n      return null;\n    }\n    // Find any current scene-level animatable belonging to the target that matches the range\n    const sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);\n    let rangeAnimatable = null;\n    for (let index = 0; index < sceneAnimatables.length; index++) {\n      const sceneAnimatable = sceneAnimatables[index];\n      if (sceneAnimatable.fromFrame === (rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.from) && sceneAnimatable.toFrame === (rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.to)) {\n        rangeAnimatable = sceneAnimatable;\n        break;\n      }\n    }\n    // Convert the animations belonging to the skeleton to additive keyframes\n    const animatables = skeleton.getAnimatables();\n    for (let index = 0; index < animatables.length; index++) {\n      const animatable = animatables[index];\n      const animations = animatable.animations;\n      if (!animations) {\n        continue;\n      }\n      for (let animIndex = 0; animIndex < animations.length; animIndex++) {\n        Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);\n      }\n    }\n    // Mark the scene-level animatable as additive\n    if (rangeAnimatable) {\n      rangeAnimatable.isAdditive = true;\n    }\n    return skeleton;\n  }\n  /** @internal */\n  _markAsDirty() {\n    this._isDirty = true;\n    this._absoluteTransformIsDirty = true;\n  }\n  /**\n   * @internal\n   */\n  _registerMeshWithPoseMatrix(mesh) {\n    this._meshesWithPoseMatrix.push(mesh);\n  }\n  /**\n   * @internal\n   */\n  _unregisterMeshWithPoseMatrix(mesh) {\n    const index = this._meshesWithPoseMatrix.indexOf(mesh);\n    if (index > -1) {\n      this._meshesWithPoseMatrix.splice(index, 1);\n    }\n  }\n  _computeTransformMatrices(targetMatrix, initialSkinMatrix) {\n    this.onBeforeComputeObservable.notifyObservers(this);\n    for (let index = 0; index < this.bones.length; index++) {\n      const bone = this.bones[index];\n      bone._childUpdateId++;\n      const parentBone = bone.getParent();\n      if (parentBone) {\n        bone.getLocalMatrix().multiplyToRef(parentBone.getFinalMatrix(), bone.getFinalMatrix());\n      } else {\n        if (initialSkinMatrix) {\n          bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getFinalMatrix());\n        } else {\n          bone.getFinalMatrix().copyFrom(bone.getLocalMatrix());\n        }\n      }\n      if (bone._index !== -1) {\n        const mappedIndex = bone._index === null ? index : bone._index;\n        bone.getAbsoluteInverseBindMatrix().multiplyToArray(bone.getFinalMatrix(), targetMatrix, mappedIndex * 16);\n      }\n    }\n    this._identity.copyToArray(targetMatrix, this.bones.length * 16);\n  }\n  /**\n   * Build all resources required to render a skeleton\n   * @param dontCheckFrameId defines a boolean indicating if prepare should be run without checking first the current frame id (default: false)\n   */\n  prepare(dontCheckFrameId = false) {\n    if (!dontCheckFrameId) {\n      const currentRenderId = this.getScene().getRenderId();\n      if (this._currentRenderId === currentRenderId) {\n        return;\n      }\n      this._currentRenderId = currentRenderId;\n    }\n    // Update the local matrix of bones with linked transform nodes.\n    if (this._numBonesWithLinkedTransformNode > 0) {\n      for (const bone of this.bones) {\n        if (bone._linkedTransformNode) {\n          const node = bone._linkedTransformNode;\n          bone.position = node.position;\n          if (node.rotationQuaternion) {\n            bone.rotationQuaternion = node.rotationQuaternion;\n          } else {\n            bone.rotation = node.rotation;\n          }\n          bone.scaling = node.scaling;\n        }\n      }\n    }\n    if (this.needInitialSkinMatrix) {\n      for (const mesh of this._meshesWithPoseMatrix) {\n        const poseMatrix = mesh.getPoseMatrix();\n        let needsUpdate = this._isDirty;\n        if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {\n          mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));\n          needsUpdate = true;\n        }\n        if (!needsUpdate) {\n          continue;\n        }\n        if (this._synchronizedWithMesh !== mesh) {\n          this._synchronizedWithMesh = mesh;\n          // Prepare bones\n          for (const bone of this.bones) {\n            if (!bone.getParent()) {\n              const matrix = bone.getBindMatrix();\n              matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);\n              bone._updateAbsoluteBindMatrices(TmpVectors.Matrix[1]);\n            }\n          }\n          if (this.isUsingTextureForMatrices) {\n            const textureWidth = (this.bones.length + 1) * 4;\n            if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {\n              if (mesh._transformMatrixTexture) {\n                mesh._transformMatrixTexture.dispose();\n              }\n              mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(mesh._bonesTransformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);\n            }\n          }\n        }\n        this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);\n        if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {\n          mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);\n        }\n      }\n    } else {\n      if (!this._isDirty) {\n        return;\n      }\n      if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {\n        this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));\n        if (this.isUsingTextureForMatrices) {\n          if (this._transformMatrixTexture) {\n            this._transformMatrixTexture.dispose();\n          }\n          this._transformMatrixTexture = RawTexture.CreateRGBATexture(this._transformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);\n        }\n      }\n      this._computeTransformMatrices(this._transformMatrices, null);\n      if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {\n        this._transformMatrixTexture.update(this._transformMatrices);\n      }\n    }\n    this._isDirty = false;\n  }\n  /**\n   * Gets the list of animatables currently running for this skeleton\n   * @returns an array of animatables\n   */\n  getAnimatables() {\n    if (!this._animatables || this._animatables.length !== this.bones.length) {\n      this._animatables = [];\n      for (let index = 0; index < this.bones.length; index++) {\n        this._animatables.push(this.bones[index]);\n      }\n    }\n    return this._animatables;\n  }\n  /**\n   * Clone the current skeleton\n   * @param name defines the name of the new skeleton\n   * @param id defines the id of the new skeleton\n   * @returns the new skeleton\n   */\n  clone(name, id) {\n    const result = new Skeleton(name, id || name, this._scene);\n    result.needInitialSkinMatrix = this.needInitialSkinMatrix;\n    for (let index = 0; index < this.bones.length; index++) {\n      const source = this.bones[index];\n      let parentBone = null;\n      const parent = source.getParent();\n      if (parent) {\n        const parentIndex = this.bones.indexOf(parent);\n        parentBone = result.bones[parentIndex];\n      }\n      const bone = new Bone(source.name, result, parentBone, source.getBindMatrix().clone(), source.getRestMatrix().clone());\n      bone._index = source._index;\n      if (source._linkedTransformNode) {\n        bone.linkTransformNode(source._linkedTransformNode);\n      }\n      DeepCopier.DeepCopy(source.animations, bone.animations);\n    }\n    if (this._ranges) {\n      result._ranges = {};\n      for (const rangeName in this._ranges) {\n        const range = this._ranges[rangeName];\n        if (range) {\n          result._ranges[rangeName] = range.clone();\n        }\n      }\n    }\n    this._isDirty = true;\n    result.prepare(true);\n    return result;\n  }\n  /**\n   * Enable animation blending for this skeleton\n   * @param blendingSpeed defines the blending speed to apply\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\n   */\n  enableBlending(blendingSpeed = 0.01) {\n    this.bones.forEach(bone => {\n      bone.animations.forEach(animation => {\n        animation.enableBlending = true;\n        animation.blendingSpeed = blendingSpeed;\n      });\n    });\n  }\n  /**\n   * Releases all resources associated with the current skeleton\n   */\n  dispose() {\n    this._meshesWithPoseMatrix.length = 0;\n    // Animations\n    this.getScene().stopAnimation(this);\n    // Remove from scene\n    this.getScene().removeSkeleton(this);\n    if (this._parentContainer) {\n      const index = this._parentContainer.skeletons.indexOf(this);\n      if (index > -1) {\n        this._parentContainer.skeletons.splice(index, 1);\n      }\n      this._parentContainer = null;\n    }\n    if (this._transformMatrixTexture) {\n      this._transformMatrixTexture.dispose();\n      this._transformMatrixTexture = null;\n    }\n  }\n  /**\n   * Serialize the skeleton in a JSON object\n   * @returns a JSON object\n   */\n  serialize() {\n    var _a;\n    const serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.id = this.id;\n    if (this.dimensionsAtRest) {\n      serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();\n    }\n    serializationObject.bones = [];\n    serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;\n    for (let index = 0; index < this.bones.length; index++) {\n      const bone = this.bones[index];\n      const parent = bone.getParent();\n      const serializedBone = {\n        parentBoneIndex: parent ? this.bones.indexOf(parent) : -1,\n        index: bone.getIndex(),\n        name: bone.name,\n        id: bone.id,\n        matrix: bone.getBindMatrix().toArray(),\n        rest: bone.getRestMatrix().toArray(),\n        linkedTransformNodeId: (_a = bone.getTransformNode()) === null || _a === void 0 ? void 0 : _a.id\n      };\n      serializationObject.bones.push(serializedBone);\n      if (bone.length) {\n        serializedBone.length = bone.length;\n      }\n      if (bone.metadata) {\n        serializedBone.metadata = bone.metadata;\n      }\n      if (bone.animations && bone.animations.length > 0) {\n        serializedBone.animation = bone.animations[0].serialize();\n      }\n      serializationObject.ranges = [];\n      for (const name in this._ranges) {\n        const source = this._ranges[name];\n        if (!source) {\n          continue;\n        }\n        const range = {};\n        range.name = name;\n        range.from = source.from;\n        range.to = source.to;\n        serializationObject.ranges.push(range);\n      }\n    }\n    return serializationObject;\n  }\n  /**\n   * Creates a new skeleton from serialized data\n   * @param parsedSkeleton defines the serialized data\n   * @param scene defines the hosting scene\n   * @returns a new skeleton\n   */\n  static Parse(parsedSkeleton, scene) {\n    const skeleton = new Skeleton(parsedSkeleton.name, parsedSkeleton.id, scene);\n    if (parsedSkeleton.dimensionsAtRest) {\n      skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);\n    }\n    skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;\n    let index;\n    for (index = 0; index < parsedSkeleton.bones.length; index++) {\n      const parsedBone = parsedSkeleton.bones[index];\n      const parsedBoneIndex = parsedSkeleton.bones[index].index;\n      let parentBone = null;\n      if (parsedBone.parentBoneIndex > -1) {\n        parentBone = skeleton.bones[parsedBone.parentBoneIndex];\n      }\n      const rest = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;\n      const bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);\n      if (parsedBone.id !== undefined && parsedBone.id !== null) {\n        bone.id = parsedBone.id;\n      }\n      if (parsedBone.length) {\n        bone.length = parsedBone.length;\n      }\n      if (parsedBone.metadata) {\n        bone.metadata = parsedBone.metadata;\n      }\n      if (parsedBone.animation) {\n        bone.animations.push(Animation.Parse(parsedBone.animation));\n      }\n      if (parsedBone.linkedTransformNodeId !== undefined && parsedBone.linkedTransformNodeId !== null) {\n        skeleton._hasWaitingData = true;\n        bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;\n      }\n    }\n    // placed after bones, so createAnimationRange can cascade down\n    if (parsedSkeleton.ranges) {\n      for (index = 0; index < parsedSkeleton.ranges.length; index++) {\n        const data = parsedSkeleton.ranges[index];\n        skeleton.createAnimationRange(data.name, data.from, data.to);\n      }\n    }\n    return skeleton;\n  }\n  /**\n   * Compute all node absolute matrices\n   * @param forceUpdate defines if computation must be done even if cache is up to date\n   */\n  computeAbsoluteMatrices(forceUpdate = false) {\n    if (this._absoluteTransformIsDirty || forceUpdate) {\n      this.bones[0].computeAbsoluteMatrices();\n      this._absoluteTransformIsDirty = false;\n    }\n  }\n  /**\n   * Compute all node absolute matrices\n   * @param forceUpdate defines if computation must be done even if cache is up to date\n   * @deprecated Please use computeAbsoluteMatrices instead\n   */\n  computeAbsoluteTransforms(forceUpdate = false) {\n    this.computeAbsoluteMatrices(forceUpdate);\n  }\n  /**\n   * Gets the root pose matrix\n   * @returns a matrix\n   */\n  getPoseMatrix() {\n    let poseMatrix = null;\n    if (this._meshesWithPoseMatrix.length > 0) {\n      poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();\n    }\n    return poseMatrix;\n  }\n  /**\n   * Sorts bones per internal index\n   */\n  sortBones() {\n    const bones = new Array();\n    const visited = new Array(this.bones.length);\n    for (let index = 0; index < this.bones.length; index++) {\n      this._sortBones(index, bones, visited);\n    }\n    this.bones = bones;\n  }\n  _sortBones(index, bones, visited) {\n    if (visited[index]) {\n      return;\n    }\n    visited[index] = true;\n    const bone = this.bones[index];\n    if (!bone) return;\n    if (bone._index === undefined) {\n      bone._index = index;\n    }\n    const parentBone = bone.getParent();\n    if (parentBone) {\n      this._sortBones(this.bones.indexOf(parentBone), bones, visited);\n    }\n    bones.push(bone);\n  }\n  /**\n   * Set the current local matrix as the restPose for all bones in the skeleton.\n   */\n  setCurrentPoseAsRest() {\n    this.bones.forEach(b => {\n      b.setCurrentPoseAsRest();\n    });\n  }\n}","map":{"version":3,"names":["Bone","Observable","Vector3","Matrix","TmpVectors","RawTexture","Animation","AnimationRange","EngineStore","Logger","DeepCopier","Skeleton","useTextureToStoreBoneMatrices","_useTextureToStoreBoneMatrices","value","_markAsDirty","animationPropertiesOverride","_animationPropertiesOverride","_scene","isUsingTextureForMatrices","_canUseTextureForBones","uniqueId","_uniqueId","constructor","name","id","scene","bones","Array","needInitialSkinMatrix","_isDirty","_meshesWithPoseMatrix","_identity","Identity","_currentRenderId","_ranges","_absoluteTransformIsDirty","_numBonesWithLinkedTransformNode","_hasWaitingData","_parentContainer","doNotSerialize","onBeforeComputeObservable","LastCreatedScene","getUniqueId","addSkeleton","engineCaps","getEngine","getCaps","textureFloat","maxVertexTextureImageUnits","getClassName","getChildren","filter","b","getParent","getTransformMatrices","mesh","_bonesTransformMatrices","prepare","_transformMatrices","getTransformMatrixTexture","_transformMatrixTexture","getScene","toString","fullDetails","ret","length","Object","keys","first","getBoneIndexByName","boneIndex","cache","createAnimationRange","from","to","i","nBones","animations","createRange","deleteAnimationRange","deleteFrames","deleteRange","getAnimationRange","getAnimationRanges","animationRanges","push","copyAnimationRange","source","rescaleAsRequired","frameOffset","_getHighestAnimationFrame","boneDict","sourceBones","Warn","skelDimensionsRatio","dimensionsAtRest","divide","boneName","sourceBone","range","returnToRest","bone","_index","highest","getHighestFrame","beginAnimation","loop","speedRatio","onAnimationEnd","MakeAnimationAdditive","skeleton","referenceFrame","rangeValue","sceneAnimatables","getAllAnimatablesByTarget","rangeAnimatable","index","sceneAnimatable","fromFrame","toFrame","animatables","getAnimatables","animatable","animIndex","isAdditive","_registerMeshWithPoseMatrix","_unregisterMeshWithPoseMatrix","indexOf","splice","_computeTransformMatrices","targetMatrix","initialSkinMatrix","notifyObservers","_childUpdateId","parentBone","getLocalMatrix","multiplyToRef","getFinalMatrix","copyFrom","mappedIndex","getAbsoluteInverseBindMatrix","multiplyToArray","copyToArray","dontCheckFrameId","currentRenderId","getRenderId","_linkedTransformNode","node","position","rotationQuaternion","rotation","scaling","poseMatrix","getPoseMatrix","needsUpdate","Float32Array","_synchronizedWithMesh","matrix","getBindMatrix","_updateAbsoluteBindMatrices","textureWidth","getSize","width","dispose","CreateRGBATexture","update","_animatables","clone","result","parent","parentIndex","getRestMatrix","linkTransformNode","DeepCopy","rangeName","enableBlending","blendingSpeed","forEach","animation","stopAnimation","removeSkeleton","skeletons","serialize","serializationObject","asArray","serializedBone","parentBoneIndex","getIndex","toArray","rest","linkedTransformNodeId","_a","getTransformNode","metadata","ranges","Parse","parsedSkeleton","FromArray","parsedBone","parsedBoneIndex","undefined","_waitingTransformNodeId","data","computeAbsoluteMatrices","forceUpdate","computeAbsoluteTransforms","sortBones","visited","_sortBones","setCurrentPoseAsRest"],"sources":["../../../../dev/core/src/Bones/skeleton.ts"],"sourcesContent":["import { Bone } from \"./bone\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport type { Animatable } from \"../Animations/animatable\";\r\nimport type { AnimationPropertiesOverride } from \"../Animations/animationPropertiesOverride\";\r\nimport { Animation } from \"../Animations/animation\";\r\nimport { AnimationRange } from \"../Animations/animationRange\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport type { IInspectable } from \"../Misc/iInspectable\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport type { AbstractScene } from \"../abstractScene\";\r\n\r\n/**\r\n * Class used to handle skinning animations\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\r\n */\r\nexport class Skeleton implements IAnimatable {\r\n    /**\r\n     * Defines the list of child bones\r\n     */\r\n    public bones = new Array<Bone>();\r\n    /**\r\n     * Defines an estimate of the dimension of the skeleton at rest\r\n     */\r\n    public dimensionsAtRest: Vector3;\r\n    /**\r\n     * Defines a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)\r\n     */\r\n    public needInitialSkinMatrix = false;\r\n\r\n    /**\r\n     * Gets the list of animations attached to this skeleton\r\n     */\r\n    public animations: Array<Animation>;\r\n\r\n    private _scene: Scene;\r\n    private _isDirty = true;\r\n    private _transformMatrices: Float32Array;\r\n    private _transformMatrixTexture: Nullable<RawTexture>;\r\n    private _meshesWithPoseMatrix = new Array<AbstractMesh>();\r\n    private _animatables: IAnimatable[];\r\n    private _identity = Matrix.Identity();\r\n    private _synchronizedWithMesh: AbstractMesh;\r\n    private _currentRenderId = -1;\r\n\r\n    private _ranges: { [name: string]: Nullable<AnimationRange> } = {};\r\n\r\n    private _absoluteTransformIsDirty = true;\r\n\r\n    private _canUseTextureForBones = false;\r\n    private _uniqueId = 0;\r\n\r\n    /** @internal */\r\n    public _numBonesWithLinkedTransformNode = 0;\r\n\r\n    /** @internal */\r\n    public _hasWaitingData: Nullable<boolean> = null;\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    /**\r\n     * Specifies if the skeleton should be serialized\r\n     */\r\n    public doNotSerialize = false;\r\n\r\n    private _useTextureToStoreBoneMatrices = true;\r\n    /**\r\n     * Gets or sets a boolean indicating that bone matrices should be stored as a texture instead of using shader uniforms (default is true).\r\n     * Please note that this option is not available if the hardware does not support it\r\n     */\r\n    public get useTextureToStoreBoneMatrices(): boolean {\r\n        return this._useTextureToStoreBoneMatrices;\r\n    }\r\n\r\n    public set useTextureToStoreBoneMatrices(value: boolean) {\r\n        this._useTextureToStoreBoneMatrices = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    private _animationPropertiesOverride: Nullable<AnimationPropertiesOverride> = null;\r\n\r\n    /**\r\n     * Gets or sets the animation properties override\r\n     */\r\n    public get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride> {\r\n        if (!this._animationPropertiesOverride) {\r\n            return this._scene.animationPropertiesOverride;\r\n        }\r\n        return this._animationPropertiesOverride;\r\n    }\r\n\r\n    public set animationPropertiesOverride(value: Nullable<AnimationPropertiesOverride>) {\r\n        this._animationPropertiesOverride = value;\r\n    }\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/toolsAndResources/inspector#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    // Events\r\n\r\n    /**\r\n     * An observable triggered before computing the skeleton's matrices\r\n     */\r\n    public onBeforeComputeObservable = new Observable<Skeleton>();\r\n\r\n    /**\r\n     * Gets a boolean indicating that the skeleton effectively stores matrices into a texture\r\n     */\r\n    public get isUsingTextureForMatrices() {\r\n        return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;\r\n    }\r\n\r\n    /**\r\n     * Gets the unique ID of this skeleton\r\n     */\r\n    public get uniqueId(): number {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Creates a new skeleton\r\n     * @param name defines the skeleton name\r\n     * @param id defines the skeleton Id\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(\r\n        /** defines the skeleton name */\r\n        public name: string,\r\n        /** defines the skeleton Id */\r\n        public id: string,\r\n        scene: Scene\r\n    ) {\r\n        this.bones = [];\r\n\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        this._uniqueId = this._scene.getUniqueId();\r\n\r\n        this._scene.addSkeleton(this);\r\n\r\n        //make sure it will recalculate the matrix next time prepare is called.\r\n        this._isDirty = true;\r\n\r\n        const engineCaps = this._scene.getEngine().getCaps();\r\n        this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Skeleton\";\r\n    }\r\n\r\n    /**\r\n     * Returns an array containing the root bones\r\n     * @returns an array containing the root bones\r\n     */\r\n    public getChildren(): Array<Bone> {\r\n        return this.bones.filter((b) => !b.getParent());\r\n    }\r\n\r\n    // Members\r\n    /**\r\n     * Gets the list of transform matrices to send to shaders (one matrix per bone)\r\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\r\n     * @returns a Float32Array containing matrices data\r\n     */\r\n    public getTransformMatrices(mesh: AbstractMesh): Float32Array {\r\n        if (this.needInitialSkinMatrix) {\r\n            if (!mesh._bonesTransformMatrices) {\r\n                this.prepare();\r\n            }\r\n\r\n            return mesh._bonesTransformMatrices!;\r\n        }\r\n\r\n        if (!this._transformMatrices || this._isDirty) {\r\n            this.prepare();\r\n        }\r\n\r\n        return this._transformMatrices;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of transform matrices to send to shaders inside a texture (one matrix per bone)\r\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\r\n     * @returns a raw texture containing the data\r\n     */\r\n    public getTransformMatrixTexture(mesh: AbstractMesh): Nullable<RawTexture> {\r\n        if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {\r\n            return mesh._transformMatrixTexture;\r\n        }\r\n\r\n        return this._transformMatrixTexture;\r\n    }\r\n\r\n    /**\r\n     * Gets the current hosting scene\r\n     * @returns a scene object\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Gets a string representing the current skeleton data\r\n     * @param fullDetails defines a boolean indicating if we want a verbose version\r\n     * @returns a string representing the current skeleton data\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = `Name: ${this.name}, nBones: ${this.bones.length}`;\r\n        ret += `, nAnimationRanges: ${this._ranges ? Object.keys(this._ranges).length : \"none\"}`;\r\n        if (fullDetails) {\r\n            ret += \", Ranges: {\";\r\n            let first = true;\r\n            for (const name in this._ranges) {\r\n                if (first) {\r\n                    ret += \", \";\r\n                    first = false;\r\n                }\r\n                ret += name;\r\n            }\r\n            ret += \"}\";\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Get bone's index searching by name\r\n     * @param name defines bone's name to search for\r\n     * @returns the indice of the bone. Returns -1 if not found\r\n     */\r\n    public getBoneIndexByName(name: string): number {\r\n        for (let boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {\r\n            if (this.bones[boneIndex].name === name) {\r\n                return boneIndex;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Create a new animation range\r\n     * @param name defines the name of the range\r\n     * @param from defines the start key\r\n     * @param to defines the end key\r\n     */\r\n    public createAnimationRange(name: string, from: number, to: number): void {\r\n        // check name not already in use\r\n        if (!this._ranges[name]) {\r\n            this._ranges[name] = new AnimationRange(name, from, to);\r\n            for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n                if (this.bones[i].animations[0]) {\r\n                    this.bones[i].animations[0].createRange(name, from, to);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete a specific animation range\r\n     * @param name defines the name of the range\r\n     * @param deleteFrames defines if frames must be removed as well\r\n     */\r\n    public deleteAnimationRange(name: string, deleteFrames = true): void {\r\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n            if (this.bones[i].animations[0]) {\r\n                this.bones[i].animations[0].deleteRange(name, deleteFrames);\r\n            }\r\n        }\r\n        this._ranges[name] = null; // said much faster than 'delete this._range[name]'\r\n    }\r\n\r\n    /**\r\n     * Gets a specific animation range\r\n     * @param name defines the name of the range to look for\r\n     * @returns the requested animation range or null if not found\r\n     */\r\n    public getAnimationRange(name: string): Nullable<AnimationRange> {\r\n        return this._ranges[name] || null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of all animation ranges defined on this skeleton\r\n     * @returns an array\r\n     */\r\n    public getAnimationRanges(): Nullable<AnimationRange>[] {\r\n        const animationRanges: Nullable<AnimationRange>[] = [];\r\n        let name: string;\r\n        for (name in this._ranges) {\r\n            animationRanges.push(this._ranges[name]);\r\n        }\r\n        return animationRanges;\r\n    }\r\n\r\n    /**\r\n     * Copy animation range from a source skeleton.\r\n     * This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences\r\n     * @param source defines the source skeleton\r\n     * @param name defines the name of the range to copy\r\n     * @param rescaleAsRequired defines if rescaling must be applied if required\r\n     * @returns true if operation was successful\r\n     */\r\n    public copyAnimationRange(source: Skeleton, name: string, rescaleAsRequired = false): boolean {\r\n        if (this._ranges[name] || !source.getAnimationRange(name)) {\r\n            return false;\r\n        }\r\n        let ret = true;\r\n        const frameOffset = this._getHighestAnimationFrame() + 1;\r\n\r\n        // make a dictionary of source skeleton's bones, so exact same order or doubly nested loop is not required\r\n        const boneDict: { [key: string]: Bone } = {};\r\n        const sourceBones = source.bones;\r\n        let nBones: number;\r\n        let i: number;\r\n        for (i = 0, nBones = sourceBones.length; i < nBones; i++) {\r\n            boneDict[sourceBones[i].name] = sourceBones[i];\r\n        }\r\n\r\n        if (this.bones.length !== sourceBones.length) {\r\n            Logger.Warn(`copyAnimationRange: this rig has ${this.bones.length} bones, while source as ${sourceBones.length}`);\r\n            ret = false;\r\n        }\r\n\r\n        const skelDimensionsRatio = rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;\r\n\r\n        for (i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n            const boneName = this.bones[i].name;\r\n            const sourceBone = boneDict[boneName];\r\n            if (sourceBone) {\r\n                ret = ret && this.bones[i].copyAnimationRange(sourceBone, name, frameOffset, rescaleAsRequired, skelDimensionsRatio);\r\n            } else {\r\n                Logger.Warn(\"copyAnimationRange: not same rig, missing source bone \" + boneName);\r\n                ret = false;\r\n            }\r\n        }\r\n        // do not call createAnimationRange(), since it also is done to bones, which was already done\r\n        const range = source.getAnimationRange(name);\r\n        if (range) {\r\n            this._ranges[name] = new AnimationRange(name, range.from + frameOffset, range.to + frameOffset);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Forces the skeleton to go to rest pose\r\n     */\r\n    public returnToRest(): void {\r\n        for (const bone of this.bones) {\r\n            if (bone._index !== -1) {\r\n                bone.returnToRest();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getHighestAnimationFrame(): number {\r\n        let ret = 0;\r\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n            if (this.bones[i].animations[0]) {\r\n                const highest = this.bones[i].animations[0].getHighestFrame();\r\n                if (ret < highest) {\r\n                    ret = highest;\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Begin a specific animation range\r\n     * @param name defines the name of the range to start\r\n     * @param loop defines if looping must be turned on (false by default)\r\n     * @param speedRatio defines the speed ratio to apply (1 by default)\r\n     * @param onAnimationEnd defines a callback which will be called when animation will end\r\n     * @returns a new animatable\r\n     */\r\n    public beginAnimation(name: string, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void): Nullable<Animatable> {\r\n        const range = this.getAnimationRange(name);\r\n\r\n        if (!range) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Convert the keyframes for a range of animation on a skeleton to be relative to a given reference frame.\r\n     * @param skeleton defines the Skeleton containing the animation range to convert\r\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to\r\n     * @param range defines the name of the AnimationRange belonging to the Skeleton to convert\r\n     * @returns the original skeleton\r\n     */\r\n    public static MakeAnimationAdditive(skeleton: Skeleton, referenceFrame = 0, range: string): Nullable<Skeleton> {\r\n        const rangeValue = skeleton.getAnimationRange(range);\r\n\r\n        // We can't make a range additive if it doesn't exist\r\n        if (!rangeValue) {\r\n            return null;\r\n        }\r\n\r\n        // Find any current scene-level animatable belonging to the target that matches the range\r\n        const sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);\r\n        let rangeAnimatable: Nullable<Animatable> = null;\r\n\r\n        for (let index = 0; index < sceneAnimatables.length; index++) {\r\n            const sceneAnimatable = sceneAnimatables[index];\r\n\r\n            if (sceneAnimatable.fromFrame === rangeValue?.from && sceneAnimatable.toFrame === rangeValue?.to) {\r\n                rangeAnimatable = sceneAnimatable;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Convert the animations belonging to the skeleton to additive keyframes\r\n        const animatables = skeleton.getAnimatables();\r\n\r\n        for (let index = 0; index < animatables.length; index++) {\r\n            const animatable = animatables[index];\r\n            const animations = animatable.animations;\r\n\r\n            if (!animations) {\r\n                continue;\r\n            }\r\n\r\n            for (let animIndex = 0; animIndex < animations.length; animIndex++) {\r\n                Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);\r\n            }\r\n        }\r\n\r\n        // Mark the scene-level animatable as additive\r\n        if (rangeAnimatable) {\r\n            rangeAnimatable.isAdditive = true;\r\n        }\r\n\r\n        return skeleton;\r\n    }\r\n\r\n    /** @internal */\r\n    public _markAsDirty(): void {\r\n        this._isDirty = true;\r\n        this._absoluteTransformIsDirty = true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _registerMeshWithPoseMatrix(mesh: AbstractMesh): void {\r\n        this._meshesWithPoseMatrix.push(mesh);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _unregisterMeshWithPoseMatrix(mesh: AbstractMesh): void {\r\n        const index = this._meshesWithPoseMatrix.indexOf(mesh);\r\n\r\n        if (index > -1) {\r\n            this._meshesWithPoseMatrix.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    private _computeTransformMatrices(targetMatrix: Float32Array, initialSkinMatrix: Nullable<Matrix>): void {\r\n        this.onBeforeComputeObservable.notifyObservers(this);\r\n\r\n        for (let index = 0; index < this.bones.length; index++) {\r\n            const bone = this.bones[index];\r\n            bone._childUpdateId++;\r\n            const parentBone = bone.getParent();\r\n\r\n            if (parentBone) {\r\n                bone.getLocalMatrix().multiplyToRef(parentBone.getFinalMatrix(), bone.getFinalMatrix());\r\n            } else {\r\n                if (initialSkinMatrix) {\r\n                    bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getFinalMatrix());\r\n                } else {\r\n                    bone.getFinalMatrix().copyFrom(bone.getLocalMatrix());\r\n                }\r\n            }\r\n\r\n            if (bone._index !== -1) {\r\n                const mappedIndex = bone._index === null ? index : bone._index;\r\n                bone.getAbsoluteInverseBindMatrix().multiplyToArray(bone.getFinalMatrix(), targetMatrix, mappedIndex * 16);\r\n            }\r\n        }\r\n\r\n        this._identity.copyToArray(targetMatrix, this.bones.length * 16);\r\n    }\r\n\r\n    /**\r\n     * Build all resources required to render a skeleton\r\n     * @param dontCheckFrameId defines a boolean indicating if prepare should be run without checking first the current frame id (default: false)\r\n     */\r\n    public prepare(dontCheckFrameId = false): void {\r\n        if (!dontCheckFrameId) {\r\n            const currentRenderId = this.getScene().getRenderId();\r\n            if (this._currentRenderId === currentRenderId) {\r\n                return;\r\n            }\r\n            this._currentRenderId = currentRenderId;\r\n        }\r\n\r\n        // Update the local matrix of bones with linked transform nodes.\r\n        if (this._numBonesWithLinkedTransformNode > 0) {\r\n            for (const bone of this.bones) {\r\n                if (bone._linkedTransformNode) {\r\n                    const node = bone._linkedTransformNode;\r\n                    bone.position = node.position;\r\n                    if (node.rotationQuaternion) {\r\n                        bone.rotationQuaternion = node.rotationQuaternion;\r\n                    } else {\r\n                        bone.rotation = node.rotation;\r\n                    }\r\n                    bone.scaling = node.scaling;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.needInitialSkinMatrix) {\r\n            for (const mesh of this._meshesWithPoseMatrix) {\r\n                const poseMatrix = mesh.getPoseMatrix();\r\n\r\n                let needsUpdate = this._isDirty;\r\n                if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {\r\n                    mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));\r\n                    needsUpdate = true;\r\n                }\r\n\r\n                if (!needsUpdate) {\r\n                    continue;\r\n                }\r\n\r\n                if (this._synchronizedWithMesh !== mesh) {\r\n                    this._synchronizedWithMesh = mesh;\r\n\r\n                    // Prepare bones\r\n                    for (const bone of this.bones) {\r\n                        if (!bone.getParent()) {\r\n                            const matrix = bone.getBindMatrix();\r\n                            matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);\r\n                            bone._updateAbsoluteBindMatrices(TmpVectors.Matrix[1]);\r\n                        }\r\n                    }\r\n\r\n                    if (this.isUsingTextureForMatrices) {\r\n                        const textureWidth = (this.bones.length + 1) * 4;\r\n                        if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {\r\n                            if (mesh._transformMatrixTexture) {\r\n                                mesh._transformMatrixTexture.dispose();\r\n                            }\r\n\r\n                            mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(\r\n                                mesh._bonesTransformMatrices,\r\n                                (this.bones.length + 1) * 4,\r\n                                1,\r\n                                this._scene,\r\n                                false,\r\n                                false,\r\n                                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                                Constants.TEXTURETYPE_FLOAT\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);\r\n\r\n                if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {\r\n                    mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);\r\n                }\r\n            }\r\n        } else {\r\n            if (!this._isDirty) {\r\n                return;\r\n            }\r\n\r\n            if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {\r\n                this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));\r\n\r\n                if (this.isUsingTextureForMatrices) {\r\n                    if (this._transformMatrixTexture) {\r\n                        this._transformMatrixTexture.dispose();\r\n                    }\r\n\r\n                    this._transformMatrixTexture = RawTexture.CreateRGBATexture(\r\n                        this._transformMatrices,\r\n                        (this.bones.length + 1) * 4,\r\n                        1,\r\n                        this._scene,\r\n                        false,\r\n                        false,\r\n                        Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                        Constants.TEXTURETYPE_FLOAT\r\n                    );\r\n                }\r\n            }\r\n\r\n            this._computeTransformMatrices(this._transformMatrices, null);\r\n\r\n            if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {\r\n                this._transformMatrixTexture.update(this._transformMatrices);\r\n            }\r\n        }\r\n\r\n        this._isDirty = false;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of animatables currently running for this skeleton\r\n     * @returns an array of animatables\r\n     */\r\n    public getAnimatables(): IAnimatable[] {\r\n        if (!this._animatables || this._animatables.length !== this.bones.length) {\r\n            this._animatables = [];\r\n\r\n            for (let index = 0; index < this.bones.length; index++) {\r\n                this._animatables.push(this.bones[index]);\r\n            }\r\n        }\r\n\r\n        return this._animatables;\r\n    }\r\n\r\n    /**\r\n     * Clone the current skeleton\r\n     * @param name defines the name of the new skeleton\r\n     * @param id defines the id of the new skeleton\r\n     * @returns the new skeleton\r\n     */\r\n    public clone(name: string, id?: string): Skeleton {\r\n        const result = new Skeleton(name, id || name, this._scene);\r\n\r\n        result.needInitialSkinMatrix = this.needInitialSkinMatrix;\r\n\r\n        for (let index = 0; index < this.bones.length; index++) {\r\n            const source = this.bones[index];\r\n            let parentBone = null;\r\n\r\n            const parent = source.getParent();\r\n            if (parent) {\r\n                const parentIndex = this.bones.indexOf(parent);\r\n                parentBone = result.bones[parentIndex];\r\n            }\r\n\r\n            const bone = new Bone(source.name, result, parentBone, source.getBindMatrix().clone(), source.getRestMatrix().clone());\r\n            bone._index = source._index;\r\n\r\n            if (source._linkedTransformNode) {\r\n                bone.linkTransformNode(source._linkedTransformNode);\r\n            }\r\n\r\n            DeepCopier.DeepCopy(source.animations, bone.animations);\r\n        }\r\n\r\n        if (this._ranges) {\r\n            result._ranges = {};\r\n            for (const rangeName in this._ranges) {\r\n                const range = this._ranges[rangeName];\r\n\r\n                if (range) {\r\n                    result._ranges[rangeName] = range.clone();\r\n                }\r\n            }\r\n        }\r\n\r\n        this._isDirty = true;\r\n\r\n        result.prepare(true);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Enable animation blending for this skeleton\r\n     * @param blendingSpeed defines the blending speed to apply\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\r\n     */\r\n    public enableBlending(blendingSpeed = 0.01) {\r\n        this.bones.forEach((bone) => {\r\n            bone.animations.forEach((animation: Animation) => {\r\n                animation.enableBlending = true;\r\n                animation.blendingSpeed = blendingSpeed;\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Releases all resources associated with the current skeleton\r\n     */\r\n    public dispose() {\r\n        this._meshesWithPoseMatrix.length = 0;\r\n\r\n        // Animations\r\n        this.getScene().stopAnimation(this);\r\n\r\n        // Remove from scene\r\n        this.getScene().removeSkeleton(this);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.skeletons.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.skeletons.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        if (this._transformMatrixTexture) {\r\n            this._transformMatrixTexture.dispose();\r\n            this._transformMatrixTexture = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serialize the skeleton in a JSON object\r\n     * @returns a JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.id = this.id;\r\n\r\n        if (this.dimensionsAtRest) {\r\n            serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();\r\n        }\r\n\r\n        serializationObject.bones = [];\r\n\r\n        serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;\r\n\r\n        for (let index = 0; index < this.bones.length; index++) {\r\n            const bone = this.bones[index];\r\n            const parent = bone.getParent();\r\n\r\n            const serializedBone: any = {\r\n                parentBoneIndex: parent ? this.bones.indexOf(parent) : -1,\r\n                index: bone.getIndex(),\r\n                name: bone.name,\r\n                id: bone.id,\r\n                matrix: bone.getBindMatrix().toArray(),\r\n                rest: bone.getRestMatrix().toArray(),\r\n                linkedTransformNodeId: bone.getTransformNode()?.id,\r\n            };\r\n\r\n            serializationObject.bones.push(serializedBone);\r\n\r\n            if (bone.length) {\r\n                serializedBone.length = bone.length;\r\n            }\r\n\r\n            if (bone.metadata) {\r\n                serializedBone.metadata = bone.metadata;\r\n            }\r\n\r\n            if (bone.animations && bone.animations.length > 0) {\r\n                serializedBone.animation = bone.animations[0].serialize();\r\n            }\r\n\r\n            serializationObject.ranges = [];\r\n            for (const name in this._ranges) {\r\n                const source = this._ranges[name];\r\n\r\n                if (!source) {\r\n                    continue;\r\n                }\r\n\r\n                const range: any = {};\r\n                range.name = name;\r\n                range.from = source.from;\r\n                range.to = source.to;\r\n                serializationObject.ranges.push(range);\r\n            }\r\n        }\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a new skeleton from serialized data\r\n     * @param parsedSkeleton defines the serialized data\r\n     * @param scene defines the hosting scene\r\n     * @returns a new skeleton\r\n     */\r\n    public static Parse(parsedSkeleton: any, scene: Scene): Skeleton {\r\n        const skeleton = new Skeleton(parsedSkeleton.name, parsedSkeleton.id, scene);\r\n        if (parsedSkeleton.dimensionsAtRest) {\r\n            skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);\r\n        }\r\n\r\n        skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;\r\n\r\n        let index: number;\r\n        for (index = 0; index < parsedSkeleton.bones.length; index++) {\r\n            const parsedBone = parsedSkeleton.bones[index];\r\n            const parsedBoneIndex = parsedSkeleton.bones[index].index;\r\n            let parentBone = null;\r\n            if (parsedBone.parentBoneIndex > -1) {\r\n                parentBone = skeleton.bones[parsedBone.parentBoneIndex];\r\n            }\r\n\r\n            const rest: Nullable<Matrix> = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;\r\n            const bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);\r\n\r\n            if (parsedBone.id !== undefined && parsedBone.id !== null) {\r\n                bone.id = parsedBone.id;\r\n            }\r\n\r\n            if (parsedBone.length) {\r\n                bone.length = parsedBone.length;\r\n            }\r\n\r\n            if (parsedBone.metadata) {\r\n                bone.metadata = parsedBone.metadata;\r\n            }\r\n\r\n            if (parsedBone.animation) {\r\n                bone.animations.push(Animation.Parse(parsedBone.animation));\r\n            }\r\n\r\n            if (parsedBone.linkedTransformNodeId !== undefined && parsedBone.linkedTransformNodeId !== null) {\r\n                skeleton._hasWaitingData = true;\r\n                bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;\r\n            }\r\n        }\r\n\r\n        // placed after bones, so createAnimationRange can cascade down\r\n        if (parsedSkeleton.ranges) {\r\n            for (index = 0; index < parsedSkeleton.ranges.length; index++) {\r\n                const data = parsedSkeleton.ranges[index];\r\n                skeleton.createAnimationRange(data.name, data.from, data.to);\r\n            }\r\n        }\r\n        return skeleton;\r\n    }\r\n\r\n    /**\r\n     * Compute all node absolute matrices\r\n     * @param forceUpdate defines if computation must be done even if cache is up to date\r\n     */\r\n    public computeAbsoluteMatrices(forceUpdate = false): void {\r\n        if (this._absoluteTransformIsDirty || forceUpdate) {\r\n            this.bones[0].computeAbsoluteMatrices();\r\n            this._absoluteTransformIsDirty = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compute all node absolute matrices\r\n     * @param forceUpdate defines if computation must be done even if cache is up to date\r\n     * @deprecated Please use computeAbsoluteMatrices instead\r\n     */\r\n    public computeAbsoluteTransforms(forceUpdate = false): void {\r\n        this.computeAbsoluteMatrices(forceUpdate);\r\n    }\r\n\r\n    /**\r\n     * Gets the root pose matrix\r\n     * @returns a matrix\r\n     */\r\n    public getPoseMatrix(): Nullable<Matrix> {\r\n        let poseMatrix: Nullable<Matrix> = null;\r\n\r\n        if (this._meshesWithPoseMatrix.length > 0) {\r\n            poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();\r\n        }\r\n\r\n        return poseMatrix;\r\n    }\r\n\r\n    /**\r\n     * Sorts bones per internal index\r\n     */\r\n    public sortBones(): void {\r\n        const bones = new Array<Bone>();\r\n        const visited = new Array<boolean>(this.bones.length);\r\n        for (let index = 0; index < this.bones.length; index++) {\r\n            this._sortBones(index, bones, visited);\r\n        }\r\n\r\n        this.bones = bones;\r\n    }\r\n\r\n    private _sortBones(index: number, bones: Bone[], visited: boolean[]): void {\r\n        if (visited[index]) {\r\n            return;\r\n        }\r\n\r\n        visited[index] = true;\r\n\r\n        const bone = this.bones[index];\r\n        if (!bone) return;\r\n\r\n        if (bone._index === undefined) {\r\n            bone._index = index;\r\n        }\r\n\r\n        const parentBone = bone.getParent();\r\n        if (parentBone) {\r\n            this._sortBones(this.bones.indexOf(parentBone), bones, visited);\r\n        }\r\n\r\n        bones.push(bone);\r\n    }\r\n\r\n    /**\r\n     * Set the current local matrix as the restPose for all bones in the skeleton.\r\n     */\r\n    public setCurrentPoseAsRest(): void {\r\n        this.bones.forEach((b) => {\r\n            b.setCurrentPoseAsRest();\r\n        });\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}