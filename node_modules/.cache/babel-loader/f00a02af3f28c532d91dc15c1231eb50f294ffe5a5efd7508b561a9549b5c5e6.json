{"ast":null,"code":"// Assumptions: absolute position of button mesh is inside the mesh\nimport { Vector3, TmpVectors } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { PointerEventTypes } from \"@babylonjs/core/Events/pointerEvents.js\";\nimport { Observable } from \"@babylonjs/core/Misc/observable.js\";\nimport { Button3D } from \"./button3D.js\";\n/**\n * Class used to create a touchable button in 3D\n */\nexport class TouchButton3D extends Button3D {\n  /**\n   * Creates a new touchable button\n   * @param name defines the control name\n   * @param collisionMesh mesh to track collisions with\n   */\n  constructor(name, collisionMesh) {\n    super(name);\n    this._isNearPressed = false;\n    this._interactionSurfaceHeight = 0;\n    this._isToggleButton = false;\n    this._toggleState = false;\n    this._toggleButtonCallback = () => {\n      this._onToggle(!this._toggleState);\n    };\n    /**\n     * An event triggered when the button is toggled. Only fired if 'isToggleButton' is true\n     */\n    this.onToggleObservable = new Observable();\n    this.collidableFrontDirection = Vector3.Zero();\n    if (collisionMesh) {\n      this.collisionMesh = collisionMesh;\n    }\n  }\n  /**\n   * Whether the current interaction is caused by near interaction or not\n   */\n  get isActiveNearInteraction() {\n    return this._isNearPressed;\n  }\n  /**\n   * Sets the front-facing direction of the button. Pass in Vector3.Zero to allow interactions from any direction\n   * @param frontWorldDir the forward direction of the button\n   */\n  set collidableFrontDirection(frontWorldDir) {\n    this._collidableFrontDirection = frontWorldDir.normalize();\n    if (this._collisionMesh) {\n      const invert = TmpVectors.Matrix[0];\n      invert.copyFrom(this._collisionMesh.getWorldMatrix());\n      invert.invert();\n      Vector3.TransformNormalToRef(this._collidableFrontDirection, invert, this._collidableFrontDirection);\n      this._collidableFrontDirection.normalize();\n    }\n  }\n  /**\n   * Returns the front-facing direction of the button, or Vector3.Zero if there is no 'front'\n   */\n  get collidableFrontDirection() {\n    if (this._collisionMesh) {\n      // Update the front direction to reflect any rotations of the collision mesh\n      const transformedDirection = TmpVectors.Vector3[0];\n      Vector3.TransformNormalToRef(this._collidableFrontDirection, this._collisionMesh.getWorldMatrix(), transformedDirection);\n      return transformedDirection.normalize();\n    }\n    return this._collidableFrontDirection;\n  }\n  /**\n   * Sets the mesh used for testing input collision\n   * @param collisionMesh the new collision mesh for the button\n   */\n  set collisionMesh(collisionMesh) {\n    var _a;\n    // Remove the GUI3DManager's data from the previous collision mesh's reserved data store, and reset interactability\n    if (this._collisionMesh) {\n      this._collisionMesh.isNearPickable = false;\n      if ((_a = this._collisionMesh.reservedDataStore) === null || _a === void 0 ? void 0 : _a.GUI3D) {\n        this._collisionMesh.reservedDataStore.GUI3D = {};\n      }\n      this._collisionMesh.getChildMeshes().forEach(mesh => {\n        var _a;\n        mesh.isNearPickable = false;\n        if ((_a = mesh.reservedDataStore) === null || _a === void 0 ? void 0 : _a.GUI3D) {\n          mesh.reservedDataStore.GUI3D = {};\n        }\n      });\n    }\n    this._collisionMesh = collisionMesh;\n    this._injectGUI3DReservedDataStore(this._collisionMesh).control = this;\n    this._collisionMesh.isNearPickable = true;\n    this._collisionMesh.getChildMeshes().forEach(mesh => {\n      this._injectGUI3DReservedDataStore(mesh).control = this;\n      mesh.isNearPickable = true;\n    });\n    this.collidableFrontDirection = collisionMesh.forward;\n  }\n  /**\n   * Setter for if this TouchButton3D should be treated as a toggle button\n   * @param value If this TouchHolographicButton should act like a toggle button\n   */\n  set isToggleButton(value) {\n    if (value === this._isToggleButton) {\n      return;\n    }\n    this._isToggleButton = value;\n    if (value) {\n      this.onPointerUpObservable.add(this._toggleButtonCallback);\n    } else {\n      this.onPointerUpObservable.removeCallback(this._toggleButtonCallback);\n      // Safety check, reset the button if it's toggled on but no longer a toggle button\n      if (this._toggleState) {\n        this._onToggle(false);\n      }\n    }\n  }\n  get isToggleButton() {\n    return this._isToggleButton;\n  }\n  /**\n   * A public entrypoint to set the toggle state of the TouchHolographicButton. Only works if 'isToggleButton' is true\n   * @param newState The new state to set the TouchHolographicButton's toggle state to\n   */\n  set isToggled(newState) {\n    if (this._isToggleButton && this._toggleState !== newState) {\n      this._onToggle(newState);\n    }\n  }\n  get isToggled() {\n    return this._toggleState;\n  }\n  _onToggle(newState) {\n    this._toggleState = newState;\n    this.onToggleObservable.notifyObservers(newState);\n  }\n  // Returns true if the collidable is in front of the button, or if the button has no front direction\n  _isInteractionInFrontOfButton(collidablePos) {\n    return this._getInteractionHeight(collidablePos, this._collisionMesh.getAbsolutePosition()) > 0;\n  }\n  /**\n   * Get the height of the touchPoint from the collidable part of the button\n   * @param touchPoint the point to compare to the button, in absolute position\n   * @returns the depth of the touch point into the front of the button\n   */\n  getPressDepth(touchPoint) {\n    if (!this._isNearPressed) {\n      return 0;\n    }\n    const interactionHeight = this._getInteractionHeight(touchPoint, this._collisionMesh.getAbsolutePosition());\n    return this._interactionSurfaceHeight - interactionHeight;\n  }\n  // Returns true if the collidable is in front of the button, or if the button has no front direction\n  _getInteractionHeight(interactionPos, basePos) {\n    const frontDir = this.collidableFrontDirection;\n    if (frontDir.length() === 0) {\n      // The button has no front, just return the distance to the base\n      return Vector3.Distance(interactionPos, basePos);\n    }\n    const d = Vector3.Dot(basePos, frontDir);\n    const abc = Vector3.Dot(interactionPos, frontDir);\n    return abc - d;\n  }\n  /**\n   * @internal\n   */\n  _generatePointerEventType(providedType, nearMeshPosition, activeInteractionCount) {\n    if (providedType === PointerEventTypes.POINTERDOWN || providedType === PointerEventTypes.POINTERMOVE) {\n      if (!this._isInteractionInFrontOfButton(nearMeshPosition)) {\n        // Near interaction mesh is behind the button, don't send a pointer down\n        return PointerEventTypes.POINTERMOVE;\n      } else {\n        this._isNearPressed = true;\n        this._interactionSurfaceHeight = this._getInteractionHeight(nearMeshPosition, this._collisionMesh.getAbsolutePosition());\n      }\n    }\n    if (providedType === PointerEventTypes.POINTERUP) {\n      if (activeInteractionCount == 0) {\n        // We get the release for the down we swallowed earlier, swallow as well\n        return PointerEventTypes.POINTERMOVE;\n      } else {\n        this._isNearPressed = false;\n      }\n    }\n    return providedType;\n  }\n  _getTypeName() {\n    return \"TouchButton3D\";\n  }\n  // Mesh association\n  _createNode(scene) {\n    return super._createNode(scene);\n  }\n  /**\n   * Releases all associated resources\n   */\n  dispose() {\n    super.dispose();\n    // Clean up toggle observables\n    this.onPointerUpObservable.removeCallback(this._toggleButtonCallback);\n    this.onToggleObservable.clear();\n    if (this._collisionMesh) {\n      this._collisionMesh.dispose();\n    }\n  }\n}","map":{"version":3,"names":["Vector3","TmpVectors","PointerEventTypes","Observable","Button3D","TouchButton3D","constructor","name","collisionMesh","_isNearPressed","_interactionSurfaceHeight","_isToggleButton","_toggleState","_toggleButtonCallback","_onToggle","onToggleObservable","collidableFrontDirection","Zero","isActiveNearInteraction","frontWorldDir","_collidableFrontDirection","normalize","_collisionMesh","invert","Matrix","copyFrom","getWorldMatrix","TransformNormalToRef","transformedDirection","isNearPickable","_a","reservedDataStore","GUI3D","getChildMeshes","forEach","mesh","_injectGUI3DReservedDataStore","control","forward","isToggleButton","value","onPointerUpObservable","add","removeCallback","isToggled","newState","notifyObservers","_isInteractionInFrontOfButton","collidablePos","_getInteractionHeight","getAbsolutePosition","getPressDepth","touchPoint","interactionHeight","interactionPos","basePos","frontDir","length","Distance","d","Dot","abc","_generatePointerEventType","providedType","nearMeshPosition","activeInteractionCount","POINTERDOWN","POINTERMOVE","POINTERUP","_getTypeName","_createNode","scene","dispose","clear"],"sources":["../../../../../dev/gui/src/3D/controls/touchButton3D.ts"],"sourcesContent":["// Assumptions: absolute position of button mesh is inside the mesh\r\n\r\nimport { Vector3, TmpVectors } from \"core/Maths/math.vector\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { PointerEventTypes } from \"core/Events/pointerEvents\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport { Observable } from \"core/Misc/observable\";\r\n\r\nimport { Button3D } from \"./button3D\";\r\n\r\n/**\r\n * Class used to create a touchable button in 3D\r\n */\r\nexport class TouchButton3D extends Button3D {\r\n    private _collisionMesh: Mesh;\r\n\r\n    // 'front' direction. If Vector3.Zero, there is no front and all directions of interaction are accepted\r\n    private _collidableFrontDirection: Vector3;\r\n    private _isNearPressed = false;\r\n    private _interactionSurfaceHeight = 0;\r\n\r\n    private _isToggleButton = false;\r\n    private _toggleState = false;\r\n    private _toggleButtonCallback = () => {\r\n        this._onToggle(!this._toggleState);\r\n    };\r\n\r\n    /**\r\n     * An event triggered when the button is toggled. Only fired if 'isToggleButton' is true\r\n     */\r\n    public onToggleObservable = new Observable<boolean>();\r\n\r\n    /**\r\n     * Creates a new touchable button\r\n     * @param name defines the control name\r\n     * @param collisionMesh mesh to track collisions with\r\n     */\r\n    constructor(name?: string, collisionMesh?: Mesh) {\r\n        super(name);\r\n\r\n        this.collidableFrontDirection = Vector3.Zero();\r\n\r\n        if (collisionMesh) {\r\n            this.collisionMesh = collisionMesh;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Whether the current interaction is caused by near interaction or not\r\n     */\r\n    public get isActiveNearInteraction() {\r\n        return this._isNearPressed;\r\n    }\r\n\r\n    /**\r\n     * Sets the front-facing direction of the button. Pass in Vector3.Zero to allow interactions from any direction\r\n     * @param frontWorldDir the forward direction of the button\r\n     */\r\n    public set collidableFrontDirection(frontWorldDir: Vector3) {\r\n        this._collidableFrontDirection = frontWorldDir.normalize();\r\n\r\n        if (this._collisionMesh) {\r\n            const invert = TmpVectors.Matrix[0];\r\n\r\n            invert.copyFrom(this._collisionMesh.getWorldMatrix());\r\n            invert.invert();\r\n            Vector3.TransformNormalToRef(this._collidableFrontDirection, invert, this._collidableFrontDirection);\r\n            this._collidableFrontDirection.normalize();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the front-facing direction of the button, or Vector3.Zero if there is no 'front'\r\n     */\r\n    public get collidableFrontDirection() {\r\n        if (this._collisionMesh) {\r\n            // Update the front direction to reflect any rotations of the collision mesh\r\n            const transformedDirection = TmpVectors.Vector3[0];\r\n            Vector3.TransformNormalToRef(this._collidableFrontDirection, this._collisionMesh.getWorldMatrix(), transformedDirection);\r\n\r\n            return transformedDirection.normalize();\r\n        }\r\n\r\n        return this._collidableFrontDirection;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh used for testing input collision\r\n     * @param collisionMesh the new collision mesh for the button\r\n     */\r\n    public set collisionMesh(collisionMesh: Mesh) {\r\n        // Remove the GUI3DManager's data from the previous collision mesh's reserved data store, and reset interactability\r\n        if (this._collisionMesh) {\r\n            this._collisionMesh.isNearPickable = false;\r\n            if (this._collisionMesh.reservedDataStore?.GUI3D) {\r\n                this._collisionMesh.reservedDataStore.GUI3D = {};\r\n            }\r\n\r\n            this._collisionMesh.getChildMeshes().forEach((mesh) => {\r\n                mesh.isNearPickable = false;\r\n                if (mesh.reservedDataStore?.GUI3D) {\r\n                    mesh.reservedDataStore.GUI3D = {};\r\n                }\r\n            });\r\n        }\r\n\r\n        this._collisionMesh = collisionMesh;\r\n        this._injectGUI3DReservedDataStore(this._collisionMesh).control = this;\r\n        this._collisionMesh.isNearPickable = true;\r\n\r\n        this._collisionMesh.getChildMeshes().forEach((mesh) => {\r\n            this._injectGUI3DReservedDataStore(mesh).control = this;\r\n            mesh.isNearPickable = true;\r\n        });\r\n        this.collidableFrontDirection = collisionMesh.forward;\r\n    }\r\n\r\n    /**\r\n     * Setter for if this TouchButton3D should be treated as a toggle button\r\n     * @param value If this TouchHolographicButton should act like a toggle button\r\n     */\r\n    public set isToggleButton(value: boolean) {\r\n        if (value === this._isToggleButton) {\r\n            return;\r\n        }\r\n\r\n        this._isToggleButton = value;\r\n\r\n        if (value) {\r\n            this.onPointerUpObservable.add(this._toggleButtonCallback);\r\n        } else {\r\n            this.onPointerUpObservable.removeCallback(this._toggleButtonCallback);\r\n\r\n            // Safety check, reset the button if it's toggled on but no longer a toggle button\r\n            if (this._toggleState) {\r\n                this._onToggle(false);\r\n            }\r\n        }\r\n    }\r\n    public get isToggleButton() {\r\n        return this._isToggleButton;\r\n    }\r\n\r\n    /**\r\n     * A public entrypoint to set the toggle state of the TouchHolographicButton. Only works if 'isToggleButton' is true\r\n     * @param newState The new state to set the TouchHolographicButton's toggle state to\r\n     */\r\n    public set isToggled(newState: boolean) {\r\n        if (this._isToggleButton && this._toggleState !== newState) {\r\n            this._onToggle(newState);\r\n        }\r\n    }\r\n    public get isToggled() {\r\n        return this._toggleState;\r\n    }\r\n\r\n    protected _onToggle(newState: boolean) {\r\n        this._toggleState = newState;\r\n        this.onToggleObservable.notifyObservers(newState);\r\n    }\r\n\r\n    // Returns true if the collidable is in front of the button, or if the button has no front direction\r\n    private _isInteractionInFrontOfButton(collidablePos: Vector3) {\r\n        return this._getInteractionHeight(collidablePos, this._collisionMesh.getAbsolutePosition()) > 0;\r\n    }\r\n\r\n    /**\r\n     * Get the height of the touchPoint from the collidable part of the button\r\n     * @param touchPoint the point to compare to the button, in absolute position\r\n     * @returns the depth of the touch point into the front of the button\r\n     */\r\n    public getPressDepth(touchPoint: Vector3) {\r\n        if (!this._isNearPressed) {\r\n            return 0;\r\n        }\r\n        const interactionHeight = this._getInteractionHeight(touchPoint, this._collisionMesh.getAbsolutePosition());\r\n        return this._interactionSurfaceHeight - interactionHeight;\r\n    }\r\n\r\n    // Returns true if the collidable is in front of the button, or if the button has no front direction\r\n    protected _getInteractionHeight(interactionPos: Vector3, basePos: Vector3) {\r\n        const frontDir = this.collidableFrontDirection;\r\n        if (frontDir.length() === 0) {\r\n            // The button has no front, just return the distance to the base\r\n            return Vector3.Distance(interactionPos, basePos);\r\n        }\r\n        const d = Vector3.Dot(basePos, frontDir);\r\n        const abc = Vector3.Dot(interactionPos, frontDir);\r\n\r\n        return abc - d;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _generatePointerEventType(providedType: number, nearMeshPosition: Vector3, activeInteractionCount: number): number {\r\n        if (providedType === PointerEventTypes.POINTERDOWN || providedType === PointerEventTypes.POINTERMOVE) {\r\n            if (!this._isInteractionInFrontOfButton(nearMeshPosition)) {\r\n                // Near interaction mesh is behind the button, don't send a pointer down\r\n                return PointerEventTypes.POINTERMOVE;\r\n            } else {\r\n                this._isNearPressed = true;\r\n                this._interactionSurfaceHeight = this._getInteractionHeight(nearMeshPosition, this._collisionMesh.getAbsolutePosition());\r\n            }\r\n        }\r\n        if (providedType === PointerEventTypes.POINTERUP) {\r\n            if (activeInteractionCount == 0) {\r\n                // We get the release for the down we swallowed earlier, swallow as well\r\n                return PointerEventTypes.POINTERMOVE;\r\n            } else {\r\n                this._isNearPressed = false;\r\n            }\r\n        }\r\n\r\n        return providedType;\r\n    }\r\n\r\n    protected _getTypeName(): string {\r\n        return \"TouchButton3D\";\r\n    }\r\n\r\n    // Mesh association\r\n    protected _createNode(scene: Scene): TransformNode {\r\n        return super._createNode(scene);\r\n    }\r\n\r\n    /**\r\n     * Releases all associated resources\r\n     */\r\n    public dispose() {\r\n        super.dispose();\r\n\r\n        // Clean up toggle observables\r\n        this.onPointerUpObservable.removeCallback(this._toggleButtonCallback);\r\n        this.onToggleObservable.clear();\r\n\r\n        if (this._collisionMesh) {\r\n            this._collisionMesh.dispose();\r\n        }\r\n    }\r\n}\r\n"],"mappings":"AAAA;AAEA,SAASA,OAAO,EAAEC,UAAU,QAAE;AAE9B,SAASC,iBAAiB,QAAE;AAI5B,SAASC,UAAU,QAAE;AAErB,SAASC,QAAQ,QAAQ,eAAa;AAEtC;;;AAGA,OAAM,MAAOC,aAAc,SAAQD,QAAQ;EAmBvC;;;;;EAKAE,YAAYC,IAAa,EAAEC,aAAoB;IAC3C,KAAK,CAACD,IAAI,CAAC;IApBP,KAAAE,cAAc,GAAG,KAAK;IACtB,KAAAC,yBAAyB,GAAG,CAAC;IAE7B,KAAAC,eAAe,GAAG,KAAK;IACvB,KAAAC,YAAY,GAAG,KAAK;IACpB,KAAAC,qBAAqB,GAAG,MAAK;MACjC,IAAI,CAACC,SAAS,CAAC,CAAC,IAAI,CAACF,YAAY,CAAC;IACtC,CAAC;IAED;;;IAGO,KAAAG,kBAAkB,GAAG,IAAIZ,UAAU,EAAW;IAUjD,IAAI,CAACa,wBAAwB,GAAGhB,OAAO,CAACiB,IAAI,EAAE;IAE9C,IAAIT,aAAa,EAAE;MACf,IAAI,CAACA,aAAa,GAAGA,aAAa;;EAE1C;EAEA;;;EAGA,IAAWU,uBAAuBA,CAAA;IAC9B,OAAO,IAAI,CAACT,cAAc;EAC9B;EAEA;;;;EAIA,IAAWO,wBAAwBA,CAACG,aAAsB;IACtD,IAAI,CAACC,yBAAyB,GAAGD,aAAa,CAACE,SAAS,EAAE;IAE1D,IAAI,IAAI,CAACC,cAAc,EAAE;MACrB,MAAMC,MAAM,GAAGtB,UAAU,CAACuB,MAAM,CAAC,CAAC,CAAC;MAEnCD,MAAM,CAACE,QAAQ,CAAC,IAAI,CAACH,cAAc,CAACI,cAAc,EAAE,CAAC;MACrDH,MAAM,CAACA,MAAM,EAAE;MACfvB,OAAO,CAAC2B,oBAAoB,CAAC,IAAI,CAACP,yBAAyB,EAAEG,MAAM,EAAE,IAAI,CAACH,yBAAyB,CAAC;MACpG,IAAI,CAACA,yBAAyB,CAACC,SAAS,EAAE;;EAElD;EAEA;;;EAGA,IAAWL,wBAAwBA,CAAA;IAC/B,IAAI,IAAI,CAACM,cAAc,EAAE;MACrB;MACA,MAAMM,oBAAoB,GAAG3B,UAAU,CAACD,OAAO,CAAC,CAAC,CAAC;MAClDA,OAAO,CAAC2B,oBAAoB,CAAC,IAAI,CAACP,yBAAyB,EAAE,IAAI,CAACE,cAAc,CAACI,cAAc,EAAE,EAAEE,oBAAoB,CAAC;MAExH,OAAOA,oBAAoB,CAACP,SAAS,EAAE;;IAG3C,OAAO,IAAI,CAACD,yBAAyB;EACzC;EAEA;;;;EAIA,IAAWZ,aAAaA,CAACA,aAAmB;;IACxC;IACA,IAAI,IAAI,CAACc,cAAc,EAAE;MACrB,IAAI,CAACA,cAAc,CAACO,cAAc,GAAG,KAAK;MAC1C,IAAI,CAAAC,EAAA,OAAI,CAACR,cAAc,CAACS,iBAAiB,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,KAAK,EAAE;QAC9C,IAAI,CAACV,cAAc,CAACS,iBAAiB,CAACC,KAAK,GAAG,EAAE;;MAGpD,IAAI,CAACV,cAAc,CAACW,cAAc,EAAE,CAACC,OAAO,CAAEC,IAAI,IAAI;;QAClDA,IAAI,CAACN,cAAc,GAAG,KAAK;QAC3B,IAAI,CAAAC,EAAA,GAAAK,IAAI,CAACJ,iBAAiB,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,KAAK,EAAE;UAC/BG,IAAI,CAACJ,iBAAiB,CAACC,KAAK,GAAG,EAAE;;MAEzC,CAAC,CAAC;;IAGN,IAAI,CAACV,cAAc,GAAGd,aAAa;IACnC,IAAI,CAAC4B,6BAA6B,CAAC,IAAI,CAACd,cAAc,CAAC,CAACe,OAAO,GAAG,IAAI;IACtE,IAAI,CAACf,cAAc,CAACO,cAAc,GAAG,IAAI;IAEzC,IAAI,CAACP,cAAc,CAACW,cAAc,EAAE,CAACC,OAAO,CAAEC,IAAI,IAAI;MAClD,IAAI,CAACC,6BAA6B,CAACD,IAAI,CAAC,CAACE,OAAO,GAAG,IAAI;MACvDF,IAAI,CAACN,cAAc,GAAG,IAAI;IAC9B,CAAC,CAAC;IACF,IAAI,CAACb,wBAAwB,GAAGR,aAAa,CAAC8B,OAAO;EACzD;EAEA;;;;EAIA,IAAWC,cAAcA,CAACC,KAAc;IACpC,IAAIA,KAAK,KAAK,IAAI,CAAC7B,eAAe,EAAE;MAChC;;IAGJ,IAAI,CAACA,eAAe,GAAG6B,KAAK;IAE5B,IAAIA,KAAK,EAAE;MACP,IAAI,CAACC,qBAAqB,CAACC,GAAG,CAAC,IAAI,CAAC7B,qBAAqB,CAAC;KAC7D,MAAM;MACH,IAAI,CAAC4B,qBAAqB,CAACE,cAAc,CAAC,IAAI,CAAC9B,qBAAqB,CAAC;MAErE;MACA,IAAI,IAAI,CAACD,YAAY,EAAE;QACnB,IAAI,CAACE,SAAS,CAAC,KAAK,CAAC;;;EAGjC;EACA,IAAWyB,cAAcA,CAAA;IACrB,OAAO,IAAI,CAAC5B,eAAe;EAC/B;EAEA;;;;EAIA,IAAWiC,SAASA,CAACC,QAAiB;IAClC,IAAI,IAAI,CAAClC,eAAe,IAAI,IAAI,CAACC,YAAY,KAAKiC,QAAQ,EAAE;MACxD,IAAI,CAAC/B,SAAS,CAAC+B,QAAQ,CAAC;;EAEhC;EACA,IAAWD,SAASA,CAAA;IAChB,OAAO,IAAI,CAAChC,YAAY;EAC5B;EAEUE,SAASA,CAAC+B,QAAiB;IACjC,IAAI,CAACjC,YAAY,GAAGiC,QAAQ;IAC5B,IAAI,CAAC9B,kBAAkB,CAAC+B,eAAe,CAACD,QAAQ,CAAC;EACrD;EAEA;EACQE,6BAA6BA,CAACC,aAAsB;IACxD,OAAO,IAAI,CAACC,qBAAqB,CAACD,aAAa,EAAE,IAAI,CAAC1B,cAAc,CAAC4B,mBAAmB,EAAE,CAAC,GAAG,CAAC;EACnG;EAEA;;;;;EAKOC,aAAaA,CAACC,UAAmB;IACpC,IAAI,CAAC,IAAI,CAAC3C,cAAc,EAAE;MACtB,OAAO,CAAC;;IAEZ,MAAM4C,iBAAiB,GAAG,IAAI,CAACJ,qBAAqB,CAACG,UAAU,EAAE,IAAI,CAAC9B,cAAc,CAAC4B,mBAAmB,EAAE,CAAC;IAC3G,OAAO,IAAI,CAACxC,yBAAyB,GAAG2C,iBAAiB;EAC7D;EAEA;EACUJ,qBAAqBA,CAACK,cAAuB,EAAEC,OAAgB;IACrE,MAAMC,QAAQ,GAAG,IAAI,CAACxC,wBAAwB;IAC9C,IAAIwC,QAAQ,CAACC,MAAM,EAAE,KAAK,CAAC,EAAE;MACzB;MACA,OAAOzD,OAAO,CAAC0D,QAAQ,CAACJ,cAAc,EAAEC,OAAO,CAAC;;IAEpD,MAAMI,CAAC,GAAG3D,OAAO,CAAC4D,GAAG,CAACL,OAAO,EAAEC,QAAQ,CAAC;IACxC,MAAMK,GAAG,GAAG7D,OAAO,CAAC4D,GAAG,CAACN,cAAc,EAAEE,QAAQ,CAAC;IAEjD,OAAOK,GAAG,GAAGF,CAAC;EAClB;EAEA;;;EAGOG,yBAAyBA,CAACC,YAAoB,EAAEC,gBAAyB,EAAEC,sBAA8B;IAC5G,IAAIF,YAAY,KAAK7D,iBAAiB,CAACgE,WAAW,IAAIH,YAAY,KAAK7D,iBAAiB,CAACiE,WAAW,EAAE;MAClG,IAAI,CAAC,IAAI,CAACpB,6BAA6B,CAACiB,gBAAgB,CAAC,EAAE;QACvD;QACA,OAAO9D,iBAAiB,CAACiE,WAAW;OACvC,MAAM;QACH,IAAI,CAAC1D,cAAc,GAAG,IAAI;QAC1B,IAAI,CAACC,yBAAyB,GAAG,IAAI,CAACuC,qBAAqB,CAACe,gBAAgB,EAAE,IAAI,CAAC1C,cAAc,CAAC4B,mBAAmB,EAAE,CAAC;;;IAGhI,IAAIa,YAAY,KAAK7D,iBAAiB,CAACkE,SAAS,EAAE;MAC9C,IAAIH,sBAAsB,IAAI,CAAC,EAAE;QAC7B;QACA,OAAO/D,iBAAiB,CAACiE,WAAW;OACvC,MAAM;QACH,IAAI,CAAC1D,cAAc,GAAG,KAAK;;;IAInC,OAAOsD,YAAY;EACvB;EAEUM,YAAYA,CAAA;IAClB,OAAO,eAAe;EAC1B;EAEA;EACUC,WAAWA,CAACC,KAAY;IAC9B,OAAO,KAAK,CAACD,WAAW,CAACC,KAAK,CAAC;EACnC;EAEA;;;EAGOC,OAAOA,CAAA;IACV,KAAK,CAACA,OAAO,EAAE;IAEf;IACA,IAAI,CAAC/B,qBAAqB,CAACE,cAAc,CAAC,IAAI,CAAC9B,qBAAqB,CAAC;IACrE,IAAI,CAACE,kBAAkB,CAAC0D,KAAK,EAAE;IAE/B,IAAI,IAAI,CAACnD,cAAc,EAAE;MACrB,IAAI,CAACA,cAAc,CAACkD,OAAO,EAAE;;EAErC"},"metadata":{},"sourceType":"module","externalDependencies":[]}