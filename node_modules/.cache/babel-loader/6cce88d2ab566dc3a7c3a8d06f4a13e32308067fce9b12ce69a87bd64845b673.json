{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { Vector3 } from \"../../../../Maths/math.vector.js\";\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator.js\";\n/**\n * Block used to instance geometry on every face of a geometry\n */\nexport class InstantiateOnFacesBlock extends NodeGeometryBlock {\n  /**\n   * Create a new InstantiateOnFacesBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    this._currentPosition = new Vector3();\n    this._vertex0 = new Vector3();\n    this._vertex1 = new Vector3();\n    this._vertex2 = new Vector3();\n    this._tempVector0 = new Vector3();\n    this._tempVector1 = new Vector3();\n    /**\n     * Gets or sets a boolean indicating that this block can evaluate context\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\n     */\n    this.evaluateContext = true;\n    this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\n    this.registerInput(\"instance\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\n    this.registerInput(\"count\", NodeGeometryBlockConnectionPointTypes.Int, true, 256);\n    this.registerInput(\"matrix\", NodeGeometryBlockConnectionPointTypes.Matrix, true);\n    this.registerInput(\"rotation\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());\n    this.registerInput(\"scaling\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.One());\n    this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\n    this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\n  }\n  /**\n   * Gets the current instance index in the current flow\n   * @returns the current index\n   */\n  getInstanceIndex() {\n    return this._currentLoopIndex;\n  }\n  /**\n   * Gets the current index in the current flow\n   * @returns the current index\n   */\n  getExecutionIndex() {\n    return 0;\n  }\n  /**\n   * Gets the current face index in the current flow\n   * @returns the current face index\n   */\n  getExecutionFaceIndex() {\n    return this._currentFaceIndex;\n  }\n  /**\n   * Gets the current loop index in the current flow\n   * @returns the current loop index\n   */\n  getExecutionLoopIndex() {\n    return this._currentLoopIndex;\n  }\n  /**\n   * Gets the value associated with a contextual positions\n   * @returns the value associated with the source\n   */\n  getOverridePositionsContextualValue() {\n    return this._currentPosition;\n  }\n  /**\n   * Gets the value associated with a contextual normals\n   * @returns the value associated with the source\n   */\n  getOverrideNormalsContextualValue() {\n    this._vertex1.subtractToRef(this._vertex0, this._tempVector0);\n    this._vertex2.subtractToRef(this._vertex1, this._tempVector1);\n    this._tempVector0.normalize();\n    this._tempVector1.normalize();\n    return Vector3.Cross(this._tempVector1, this._tempVector0);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"InstantiateOnFacesBlock\";\n  }\n  /**\n   * Gets the geometry input component\n   */\n  get geometry() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the instance input component\n   */\n  get instance() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the count input component\n   */\n  get count() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the matrix input component\n   */\n  get matrix() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the rotation input component\n   */\n  get rotation() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the scaling input component\n   */\n  get scaling() {\n    return this._inputs[5];\n  }\n  /**\n   * Gets the geometry output component\n   */\n  get output() {\n    return this._outputs[0];\n  }\n  _buildBlock(state) {\n    const func = state => {\n      state.pushExecutionContext(this);\n      state.pushInstancingContext(this);\n      this._vertexData = this.geometry.getConnectedValue(state);\n      state.pushGeometryContext(this._vertexData);\n      if (!this._vertexData || !this._vertexData.positions || !this._vertexData.indices || !this.instance.isConnected) {\n        state.restoreExecutionContext();\n        state.restoreInstancingContext();\n        state.restoreGeometryContext();\n        this.output._storedValue = null;\n        return;\n      }\n      // Processing\n      let instanceGeometry = null;\n      const instanceCount = this.count.getConnectedValue(state);\n      const faceCount = this._vertexData.indices.length / 3;\n      const instancePerFace = instanceCount / faceCount;\n      let accumulatedCount = 0;\n      const additionalVertexData = [];\n      let totalDone = 0;\n      this._currentLoopIndex = 0;\n      for (this._currentFaceIndex = 0; this._currentFaceIndex < faceCount; this._currentFaceIndex++) {\n        // Extract face vertices\n        this._vertex0.fromArray(this._vertexData.positions, this._vertexData.indices[this._currentFaceIndex * 3] * 3);\n        this._vertex1.fromArray(this._vertexData.positions, this._vertexData.indices[this._currentFaceIndex * 3 + 1] * 3);\n        this._vertex2.fromArray(this._vertexData.positions, this._vertexData.indices[this._currentFaceIndex * 3 + 2] * 3);\n        accumulatedCount += instancePerFace;\n        const countPerFace = (accumulatedCount | 0) - totalDone;\n        if (countPerFace < 1) {\n          continue;\n        }\n        for (let faceDispatchCount = 0; faceDispatchCount < countPerFace; faceDispatchCount++) {\n          if (totalDone >= instanceCount) {\n            break;\n          }\n          // Get random point on face\n          let x = Math.random();\n          let y = Math.random();\n          if (x > y) {\n            const temp = x;\n            x = y;\n            y = temp;\n          }\n          const s = x;\n          const t = y - x;\n          const u = 1 - s - t;\n          this._currentPosition.set(s * this._vertex0.x + t * this._vertex1.x + u * this._vertex2.x, s * this._vertex0.y + t * this._vertex1.y + u * this._vertex2.y, s * this._vertex0.z + t * this._vertex1.z + u * this._vertex2.z);\n          // Clone the instance\n          instanceGeometry = this.instance.getConnectedValue(state);\n          if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {\n            accumulatedCount -= instancePerFace;\n            continue;\n          }\n          const clone = instanceGeometry.clone();\n          if (this.matrix.isConnected) {\n            const transform = this.matrix.getConnectedValue(state);\n            state._instantiateWithPositionAndMatrix(clone, this._currentPosition, transform, additionalVertexData);\n          } else {\n            const scaling = state.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);\n            const rotation = this.rotation.getConnectedValue(state) || Vector3.ZeroReadOnly;\n            state._instantiate(clone, this._currentPosition, rotation, scaling, additionalVertexData);\n          }\n          totalDone++;\n          this._currentLoopIndex++;\n        }\n      }\n      // Merge\n      if (additionalVertexData.length) {\n        if (additionalVertexData.length === 1) {\n          this._vertexData = additionalVertexData[0];\n        } else {\n          // We do not merge the main one as user can use a merge node if wanted\n          const main = additionalVertexData.splice(0, 1)[0];\n          this._vertexData = main.merge(additionalVertexData, true, false, true, true);\n        }\n      }\n      state.restoreExecutionContext();\n      state.restoreInstancingContext();\n      state.restoreGeometryContext();\n      return this._vertexData;\n    };\n    // Storage\n    if (this.evaluateContext) {\n      this.output._storedFunction = func;\n    } else {\n      this.output._storedFunction = null;\n      this.output._storedValue = func(state);\n    }\n  }\n  _dumpPropertiesCode() {\n    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\n    return codeString;\n  }\n  /**\n   * Serializes this block in a JSON representation\n   * @returns the serialized block object\n   */\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.evaluateContext = this.evaluateContext;\n    return serializationObject;\n  }\n  _deserialize(serializationObject) {\n    super._deserialize(serializationObject);\n    if (serializationObject.evaluateContext !== undefined) {\n      this.evaluateContext = serializationObject.evaluateContext;\n    }\n  }\n}\n__decorate([editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    rebuild: true\n  }\n})], InstantiateOnFacesBlock.prototype, \"evaluateContext\", void 0);\nRegisterClass(\"BABYLON.InstantiateOnFacesBlock\", InstantiateOnFacesBlock);","map":{"version":3,"names":["NodeGeometryBlock","RegisterClass","NodeGeometryBlockConnectionPointTypes","Vector3","PropertyTypeForEdition","editableInPropertyPage","InstantiateOnFacesBlock","constructor","name","_currentPosition","_vertex0","_vertex1","_vertex2","_tempVector0","_tempVector1","evaluateContext","registerInput","Geometry","Int","Matrix","Zero","One","scaling","acceptedConnectionPointTypes","push","Float","registerOutput","getInstanceIndex","_currentLoopIndex","getExecutionIndex","getExecutionFaceIndex","_currentFaceIndex","getExecutionLoopIndex","getOverridePositionsContextualValue","getOverrideNormalsContextualValue","subtractToRef","normalize","Cross","getClassName","geometry","_inputs","instance","count","matrix","rotation","output","_outputs","_buildBlock","state","func","pushExecutionContext","pushInstancingContext","_vertexData","getConnectedValue","pushGeometryContext","positions","indices","isConnected","restoreExecutionContext","restoreInstancingContext","restoreGeometryContext","_storedValue","instanceGeometry","instanceCount","faceCount","length","instancePerFace","accumulatedCount","additionalVertexData","totalDone","fromArray","countPerFace","faceDispatchCount","x","Math","random","y","temp","s","t","u","set","z","clone","transform","_instantiateWithPositionAndMatrix","adaptInput","OneReadOnly","ZeroReadOnly","_instantiate","main","splice","merge","_storedFunction","_dumpPropertiesCode","codeString","_codeVariableName","serialize","serializationObject","_deserialize","undefined","__decorate","Boolean","notifiers","rebuild"],"sources":["../../../../../../../dev/core/src/Meshes/Node/Blocks/Instances/instantiateOnFacesBlock.ts"],"sourcesContent":["import { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport type { INodeGeometryExecutionContext } from \"../../Interfaces/nodeGeometryExecutionContext\";\r\nimport type { VertexData } from \"../../../mesh.vertexData\";\r\nimport { Vector3 } from \"../../../../Maths/math.vector\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport type { INodeGeometryInstancingContext } from \"../../Interfaces/nodeGeometryInstancingContext\";\r\n\r\n/**\r\n * Block used to instance geometry on every face of a geometry\r\n */\r\nexport class InstantiateOnFacesBlock extends NodeGeometryBlock implements INodeGeometryExecutionContext, INodeGeometryInstancingContext {\r\n    private _vertexData: VertexData;\r\n    private _currentFaceIndex: number;\r\n    private _currentLoopIndex: number;\r\n    private _currentPosition = new Vector3();\r\n    private _vertex0 = new Vector3();\r\n    private _vertex1 = new Vector3();\r\n    private _vertex2 = new Vector3();\r\n    private _tempVector0 = new Vector3();\r\n    private _tempVector1 = new Vector3();\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = true;\r\n\r\n    /**\r\n     * Create a new InstantiateOnFacesBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this.registerInput(\"instance\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\r\n        this.registerInput(\"count\", NodeGeometryBlockConnectionPointTypes.Int, true, 256);\r\n        this.registerInput(\"matrix\", NodeGeometryBlockConnectionPointTypes.Matrix, true);\r\n        this.registerInput(\"rotation\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());\r\n        this.registerInput(\"scaling\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.One());\r\n\r\n        this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current instance index in the current flow\r\n     * @returns the current index\r\n     */\r\n    public getInstanceIndex(): number {\r\n        return this._currentLoopIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current index in the current flow\r\n     * @returns the current index\r\n     */\r\n    public getExecutionIndex(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current face index in the current flow\r\n     * @returns the current face index\r\n     */\r\n    public getExecutionFaceIndex(): number {\r\n        return this._currentFaceIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current loop index in the current flow\r\n     * @returns the current loop index\r\n     */\r\n    public getExecutionLoopIndex(): number {\r\n        return this._currentLoopIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the value associated with a contextual positions\r\n     * @returns the value associated with the source\r\n     */\r\n    public getOverridePositionsContextualValue() {\r\n        return this._currentPosition;\r\n    }\r\n\r\n    /**\r\n     * Gets the value associated with a contextual normals\r\n     * @returns the value associated with the source\r\n     */\r\n    public getOverrideNormalsContextualValue() {\r\n        this._vertex1.subtractToRef(this._vertex0, this._tempVector0);\r\n        this._vertex2.subtractToRef(this._vertex1, this._tempVector1);\r\n        this._tempVector0.normalize();\r\n        this._tempVector1.normalize();\r\n        return Vector3.Cross(this._tempVector1, this._tempVector0);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"InstantiateOnFacesBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry input component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the instance input component\r\n     */\r\n    public get instance(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the count input component\r\n     */\r\n    public get count(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix input component\r\n     */\r\n    public get matrix(): NodeGeometryConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the rotation input component\r\n     */\r\n    public get rotation(): NodeGeometryConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the scaling input component\r\n     */\r\n    public get scaling(): NodeGeometryConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            state.pushExecutionContext(this);\r\n            state.pushInstancingContext(this);\r\n\r\n            this._vertexData = this.geometry.getConnectedValue(state);\r\n            state.pushGeometryContext(this._vertexData);\r\n\r\n            if (!this._vertexData || !this._vertexData.positions || !this._vertexData.indices || !this.instance.isConnected) {\r\n                state.restoreExecutionContext();\r\n                state.restoreInstancingContext();\r\n                state.restoreGeometryContext();\r\n                this.output._storedValue = null;\r\n                return;\r\n            }\r\n\r\n            // Processing\r\n            let instanceGeometry: Nullable<VertexData> = null;\r\n            const instanceCount = this.count.getConnectedValue(state);\r\n            const faceCount = this._vertexData.indices.length / 3;\r\n            const instancePerFace = instanceCount / faceCount;\r\n            let accumulatedCount = 0;\r\n            const additionalVertexData: VertexData[] = [];\r\n            let totalDone = 0;\r\n            this._currentLoopIndex = 0;\r\n\r\n            for (this._currentFaceIndex = 0; this._currentFaceIndex < faceCount; this._currentFaceIndex++) {\r\n                // Extract face vertices\r\n                this._vertex0.fromArray(this._vertexData.positions, this._vertexData.indices[this._currentFaceIndex * 3] * 3);\r\n                this._vertex1.fromArray(this._vertexData.positions, this._vertexData.indices[this._currentFaceIndex * 3 + 1] * 3);\r\n                this._vertex2.fromArray(this._vertexData.positions, this._vertexData.indices[this._currentFaceIndex * 3 + 2] * 3);\r\n\r\n                accumulatedCount += instancePerFace;\r\n                const countPerFace = (accumulatedCount | 0) - totalDone;\r\n\r\n                if (countPerFace < 1) {\r\n                    continue;\r\n                }\r\n\r\n                for (let faceDispatchCount = 0; faceDispatchCount < countPerFace; faceDispatchCount++) {\r\n                    if (totalDone >= instanceCount) {\r\n                        break;\r\n                    }\r\n\r\n                    // Get random point on face\r\n                    let x = Math.random();\r\n                    let y = Math.random();\r\n\r\n                    if (x > y) {\r\n                        const temp = x;\r\n                        x = y;\r\n                        y = temp;\r\n                    }\r\n                    const s = x;\r\n                    const t = y - x;\r\n                    const u = 1 - s - t;\r\n\r\n                    this._currentPosition.set(\r\n                        s * this._vertex0.x + t * this._vertex1.x + u * this._vertex2.x,\r\n                        s * this._vertex0.y + t * this._vertex1.y + u * this._vertex2.y,\r\n                        s * this._vertex0.z + t * this._vertex1.z + u * this._vertex2.z\r\n                    );\r\n\r\n                    // Clone the instance\r\n                    instanceGeometry = this.instance.getConnectedValue(state) as VertexData;\r\n\r\n                    if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {\r\n                        accumulatedCount -= instancePerFace;\r\n                        continue;\r\n                    }\r\n                    const clone = instanceGeometry!.clone();\r\n\r\n                    if (this.matrix.isConnected) {\r\n                        const transform = this.matrix.getConnectedValue(state);\r\n                        state._instantiateWithPositionAndMatrix(clone, this._currentPosition, transform, additionalVertexData);\r\n                    } else {\r\n                        const scaling = state.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);\r\n                        const rotation = this.rotation.getConnectedValue(state) || Vector3.ZeroReadOnly;\r\n                        state._instantiate(clone, this._currentPosition, rotation, scaling, additionalVertexData);\r\n                    }\r\n                    totalDone++;\r\n                    this._currentLoopIndex++;\r\n                }\r\n            }\r\n\r\n            // Merge\r\n            if (additionalVertexData.length) {\r\n                if (additionalVertexData.length === 1) {\r\n                    this._vertexData = additionalVertexData[0];\r\n                } else {\r\n                    // We do not merge the main one as user can use a merge node if wanted\r\n                    const main = additionalVertexData.splice(0, 1)[0];\r\n                    this._vertexData = main.merge(additionalVertexData, true, false, true, true);\r\n                }\r\n            }\r\n            state.restoreExecutionContext();\r\n            state.restoreInstancingContext();\r\n            state.restoreGeometryContext();\r\n            return this._vertexData;\r\n        };\r\n\r\n        // Storage\r\n        if (this.evaluateContext) {\r\n            this.output._storedFunction = func;\r\n        } else {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = func(state);\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        if (serializationObject.evaluateContext !== undefined) {\r\n            this.evaluateContext = serializationObject.evaluateContext;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.InstantiateOnFacesBlock\", InstantiateOnFacesBlock);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}