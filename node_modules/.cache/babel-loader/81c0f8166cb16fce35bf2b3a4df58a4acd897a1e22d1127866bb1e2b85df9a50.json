{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Quaternion } from \"../../Maths/math.vector.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Listen to mouse events to control the camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class FlyCameraMouseInput {\n  /**\n   * Listen to mouse events to control the camera.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n   */\n  constructor() {\n    /**\n     * Defines the buttons associated with the input to handle camera rotation.\n     */\n    this.buttons = [0, 1, 2];\n    /**\n     * Assign buttons for Yaw control.\n     */\n    this.buttonsYaw = [-1, 0, 1];\n    /**\n     * Assign buttons for Pitch control.\n     */\n    this.buttonsPitch = [-1, 0, 1];\n    /**\n     * Assign buttons for Roll control.\n     */\n    this.buttonsRoll = [2];\n    /**\n     * Detect if any button is being pressed while mouse is moved.\n     * -1 = Mouse locked.\n     * 0 = Left button.\n     * 1 = Middle Button.\n     * 2 = Right Button.\n     */\n    this.activeButton = -1;\n    /**\n     * Defines the pointer's angular sensibility, to control the camera rotation speed.\n     * Higher values reduce its sensitivity.\n     */\n    this.angularSensibility = 1000.0;\n    this._previousPosition = null;\n  }\n  /**\n   * Attach the mouse control to the HTML DOM element.\n   * @param noPreventDefault Defines whether events caught by the controls should call preventdefault().\n   */\n  attachControl(noPreventDefault) {\n    // eslint-disable-next-line prefer-rest-params\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    this._noPreventDefault = noPreventDefault;\n    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(p => {\n      this._pointerInput(p);\n    }, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\n    // Correct Roll by rate, if enabled.\n    this._rollObserver = this.camera.getScene().onBeforeRenderObservable.add(() => {\n      if (this.camera.rollCorrect) {\n        this.camera.restoreRoll(this.camera.rollCorrect);\n      }\n    });\n  }\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n  detachControl() {\n    if (this._observer) {\n      this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\n      this.camera.getScene().onBeforeRenderObservable.remove(this._rollObserver);\n      this._observer = null;\n      this._rollObserver = null;\n      this._previousPosition = null;\n      this._noPreventDefault = undefined;\n    }\n  }\n  /**\n   * Gets the class name of the current input.\n   * @returns the class name.\n   */\n  getClassName() {\n    return \"FlyCameraMouseInput\";\n  }\n  /**\n   * Get the friendly name associated with the input class.\n   * @returns the input's friendly name.\n   */\n  getSimpleName() {\n    return \"mouse\";\n  }\n  // Track mouse movement, when the pointer is not locked.\n  _pointerInput(p) {\n    const e = p.event;\n    const camera = this.camera;\n    const engine = camera.getEngine();\n    if (!this.touchEnabled && e.pointerType === \"touch\") {\n      return;\n    }\n    // Mouse is moved but an unknown mouse button is pressed.\n    if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(e.button) === -1) {\n      return;\n    }\n    const srcElement = e.target;\n    // Mouse down.\n    if (p.type === PointerEventTypes.POINTERDOWN) {\n      try {\n        srcElement === null || srcElement === void 0 ? void 0 : srcElement.setPointerCapture(e.pointerId);\n      } catch (e) {\n        // Nothing to do with the error. Execution continues.\n      }\n      this._previousPosition = {\n        x: e.clientX,\n        y: e.clientY\n      };\n      this.activeButton = e.button;\n      if (!this._noPreventDefault) {\n        e.preventDefault();\n        this._element.focus();\n      }\n      // This is required to move while pointer button is down\n      if (engine.isPointerLock) {\n        this._onMouseMove(p.event);\n      }\n    }\n    // Mouse up.\n    else if (p.type === PointerEventTypes.POINTERUP) {\n      try {\n        srcElement === null || srcElement === void 0 ? void 0 : srcElement.releasePointerCapture(e.pointerId);\n      } catch (e) {\n        // Nothing to do with the error. Execution continues.\n      }\n      this.activeButton = -1;\n      this._previousPosition = null;\n      if (!this._noPreventDefault) {\n        e.preventDefault();\n      }\n    }\n    // Mouse move.\n    else if (p.type === PointerEventTypes.POINTERMOVE) {\n      if (!this._previousPosition) {\n        if (engine.isPointerLock) {\n          this._onMouseMove(p.event);\n        }\n        return;\n      }\n      const offsetX = e.clientX - this._previousPosition.x;\n      const offsetY = e.clientY - this._previousPosition.y;\n      this._rotateCamera(offsetX, offsetY);\n      this._previousPosition = {\n        x: e.clientX,\n        y: e.clientY\n      };\n      if (!this._noPreventDefault) {\n        e.preventDefault();\n      }\n    }\n  }\n  // Track mouse movement, when pointer is locked.\n  _onMouseMove(e) {\n    const camera = this.camera;\n    const engine = camera.getEngine();\n    if (!engine.isPointerLock) {\n      return;\n    }\n    const offsetX = e.movementX;\n    const offsetY = e.movementY;\n    this._rotateCamera(offsetX, offsetY);\n    this._previousPosition = null;\n    if (!this._noPreventDefault) {\n      e.preventDefault();\n    }\n  }\n  /**\n   * Rotate camera by mouse offset.\n   * @param offsetX\n   * @param offsetY\n   */\n  _rotateCamera(offsetX, offsetY) {\n    const camera = this.camera;\n    const handednessMultiplier = camera._calculateHandednessMultiplier();\n    offsetX *= handednessMultiplier;\n    const x = offsetX / this.angularSensibility;\n    const y = offsetY / this.angularSensibility;\n    // Initialize to current rotation.\n    const currentRotation = Quaternion.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, camera.rotation.z);\n    let rotationChange;\n    // Pitch.\n    if (this.buttonsPitch.some(v => {\n      return v === this.activeButton;\n    })) {\n      // Apply change in Radians to vector Angle.\n      rotationChange = Quaternion.RotationAxis(Axis.X, y);\n      // Apply Pitch to quaternion.\n      currentRotation.multiplyInPlace(rotationChange);\n    }\n    // Yaw.\n    if (this.buttonsYaw.some(v => {\n      return v === this.activeButton;\n    })) {\n      // Apply change in Radians to vector Angle.\n      rotationChange = Quaternion.RotationAxis(Axis.Y, x);\n      // Apply Yaw to quaternion.\n      currentRotation.multiplyInPlace(rotationChange);\n      // Add Roll, if banked turning is enabled, within Roll limit.\n      const limit = camera.bankedTurnLimit + camera._trackRoll; // Defaults to 90° plus manual roll.\n      if (camera.bankedTurn && -limit < camera.rotation.z && camera.rotation.z < limit) {\n        const bankingDelta = camera.bankedTurnMultiplier * -x;\n        // Apply change in Radians to vector Angle.\n        rotationChange = Quaternion.RotationAxis(Axis.Z, bankingDelta);\n        // Apply Yaw to quaternion.\n        currentRotation.multiplyInPlace(rotationChange);\n      }\n    }\n    // Roll.\n    if (this.buttonsRoll.some(v => {\n      return v === this.activeButton;\n    })) {\n      // Apply change in Radians to vector Angle.\n      rotationChange = Quaternion.RotationAxis(Axis.Z, -x);\n      // Track Rolling.\n      camera._trackRoll -= x;\n      // Apply Pitch to quaternion.\n      currentRotation.multiplyInPlace(rotationChange);\n    }\n    // Apply rotationQuaternion to Euler camera.rotation.\n    currentRotation.toEulerAnglesToRef(camera.rotation);\n  }\n}\n__decorate([serialize()], FlyCameraMouseInput.prototype, \"buttons\", void 0);\n__decorate([serialize()], FlyCameraMouseInput.prototype, \"angularSensibility\", void 0);\nCameraInputTypes[\"FlyCameraMouseInput\"] = FlyCameraMouseInput;","map":{"version":3,"names":["serialize","CameraInputTypes","PointerEventTypes","Quaternion","Axis","Tools","FlyCameraMouseInput","constructor","buttons","buttonsYaw","buttonsPitch","buttonsRoll","activeButton","angularSensibility","_previousPosition","attachControl","noPreventDefault","BackCompatCameraNoPreventDefault","arguments","_noPreventDefault","_observer","camera","getScene","_inputManager","_addCameraPointerObserver","p","_pointerInput","POINTERDOWN","POINTERUP","POINTERMOVE","_rollObserver","onBeforeRenderObservable","add","rollCorrect","restoreRoll","detachControl","_removeCameraPointerObserver","remove","undefined","getClassName","getSimpleName","e","event","engine","getEngine","touchEnabled","pointerType","type","indexOf","button","srcElement","target","setPointerCapture","pointerId","x","clientX","y","clientY","preventDefault","_element","focus","isPointerLock","_onMouseMove","releasePointerCapture","offsetX","offsetY","_rotateCamera","movementX","movementY","handednessMultiplier","_calculateHandednessMultiplier","currentRotation","RotationYawPitchRoll","rotation","z","rotationChange","some","v","RotationAxis","X","multiplyInPlace","Y","limit","bankedTurnLimit","_trackRoll","bankedTurn","bankingDelta","bankedTurnMultiplier","Z","toEulerAnglesToRef","__decorate"],"sources":["../../../../../dev/core/src/Cameras/Inputs/flyCameraMouseInput.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FlyCamera } from \"../../Cameras/flyCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Quaternion } from \"../../Maths/math.vector\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Listen to mouse events to control the camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FlyCameraMouseInput implements ICameraInput<FlyCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FlyCamera;\r\n\r\n    /**\r\n     * Defines if touch is enabled. (Default is true.)\r\n     */\r\n    public touchEnabled: boolean;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera rotation.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Assign buttons for Yaw control.\r\n     */\r\n    public buttonsYaw: number[] = [-1, 0, 1];\r\n\r\n    /**\r\n     * Assign buttons for Pitch control.\r\n     */\r\n    public buttonsPitch: number[] = [-1, 0, 1];\r\n\r\n    /**\r\n     * Assign buttons for Roll control.\r\n     */\r\n    public buttonsRoll: number[] = [2];\r\n\r\n    /**\r\n     * Detect if any button is being pressed while mouse is moved.\r\n     * -1 = Mouse locked.\r\n     * 0 = Left button.\r\n     * 1 = Middle Button.\r\n     * 2 = Right Button.\r\n     */\r\n    public activeButton: number = -1;\r\n\r\n    /**\r\n     * Defines the pointer's angular sensibility, to control the camera rotation speed.\r\n     * Higher values reduce its sensitivity.\r\n     */\r\n    @serialize()\r\n    public angularSensibility = 1000.0;\r\n\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _rollObserver: Nullable<Observer<Scene>>;\r\n    private _previousPosition: Nullable<{ x: number; y: number }> = null;\r\n    private _noPreventDefault: boolean | undefined;\r\n    private _element: HTMLElement;\r\n\r\n    /**\r\n     * Listen to mouse events to control the camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     * Attach the mouse control to the HTML DOM element.\r\n     * @param noPreventDefault Defines whether events caught by the controls should call preventdefault().\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this._noPreventDefault = noPreventDefault;\r\n\r\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver((p: any) => {\r\n            this._pointerInput(p);\r\n        }, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        // Correct Roll by rate, if enabled.\r\n        this._rollObserver = this.camera.getScene().onBeforeRenderObservable.add(() => {\r\n            if (this.camera.rollCorrect) {\r\n                this.camera.restoreRoll(this.camera.rollCorrect);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n\r\n            this.camera.getScene().onBeforeRenderObservable.remove(this._rollObserver);\r\n\r\n            this._observer = null;\r\n            this._rollObserver = null;\r\n            this._previousPosition = null;\r\n            this._noPreventDefault = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name.\r\n     */\r\n    public getClassName(): string {\r\n        return \"FlyCameraMouseInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input's friendly name.\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mouse\";\r\n    }\r\n\r\n    // Track mouse movement, when the pointer is not locked.\r\n    private _pointerInput(p: any): void {\r\n        const e = <IPointerEvent>p.event;\r\n\r\n        const camera = this.camera;\r\n        const engine = camera.getEngine();\r\n\r\n        if (!this.touchEnabled && e.pointerType === \"touch\") {\r\n            return;\r\n        }\r\n\r\n        // Mouse is moved but an unknown mouse button is pressed.\r\n        if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(e.button) === -1) {\r\n            return;\r\n        }\r\n\r\n        const srcElement = <HTMLElement>e.target;\r\n\r\n        // Mouse down.\r\n        if (p.type === PointerEventTypes.POINTERDOWN) {\r\n            try {\r\n                srcElement?.setPointerCapture(e.pointerId);\r\n            } catch (e) {\r\n                // Nothing to do with the error. Execution continues.\r\n            }\r\n\r\n            this._previousPosition = {\r\n                x: e.clientX,\r\n                y: e.clientY,\r\n            };\r\n\r\n            this.activeButton = e.button;\r\n\r\n            if (!this._noPreventDefault) {\r\n                e.preventDefault();\r\n                this._element.focus();\r\n            }\r\n\r\n            // This is required to move while pointer button is down\r\n            if (engine.isPointerLock) {\r\n                this._onMouseMove(p.event);\r\n            }\r\n        }\r\n        // Mouse up.\r\n        else if (p.type === PointerEventTypes.POINTERUP) {\r\n            try {\r\n                srcElement?.releasePointerCapture(e.pointerId);\r\n            } catch (e) {\r\n                // Nothing to do with the error. Execution continues.\r\n            }\r\n\r\n            this.activeButton = -1;\r\n\r\n            this._previousPosition = null;\r\n            if (!this._noPreventDefault) {\r\n                e.preventDefault();\r\n            }\r\n        }\r\n        // Mouse move.\r\n        else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n            if (!this._previousPosition) {\r\n                if (engine.isPointerLock) {\r\n                    this._onMouseMove(p.event);\r\n                }\r\n\r\n                return;\r\n            }\r\n\r\n            const offsetX = e.clientX - this._previousPosition.x;\r\n            const offsetY = e.clientY - this._previousPosition.y;\r\n\r\n            this._rotateCamera(offsetX, offsetY);\r\n\r\n            this._previousPosition = {\r\n                x: e.clientX,\r\n                y: e.clientY,\r\n            };\r\n\r\n            if (!this._noPreventDefault) {\r\n                e.preventDefault();\r\n            }\r\n        }\r\n    }\r\n\r\n    // Track mouse movement, when pointer is locked.\r\n    private _onMouseMove(e: any): void {\r\n        const camera = this.camera;\r\n        const engine = camera.getEngine();\r\n\r\n        if (!engine.isPointerLock) {\r\n            return;\r\n        }\r\n\r\n        const offsetX = e.movementX;\r\n        const offsetY = e.movementY;\r\n\r\n        this._rotateCamera(offsetX, offsetY);\r\n\r\n        this._previousPosition = null;\r\n\r\n        if (!this._noPreventDefault) {\r\n            e.preventDefault();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rotate camera by mouse offset.\r\n     * @param offsetX\r\n     * @param offsetY\r\n     */\r\n    private _rotateCamera(offsetX: number, offsetY: number): void {\r\n        const camera = this.camera;\r\n        const handednessMultiplier = camera._calculateHandednessMultiplier();\r\n\r\n        offsetX *= handednessMultiplier;\r\n\r\n        const x = offsetX / this.angularSensibility;\r\n        const y = offsetY / this.angularSensibility;\r\n\r\n        // Initialize to current rotation.\r\n        const currentRotation = Quaternion.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, camera.rotation.z);\r\n        let rotationChange: Quaternion;\r\n\r\n        // Pitch.\r\n        if (\r\n            this.buttonsPitch.some((v) => {\r\n                return v === this.activeButton;\r\n            })\r\n        ) {\r\n            // Apply change in Radians to vector Angle.\r\n            rotationChange = Quaternion.RotationAxis(Axis.X, y);\r\n            // Apply Pitch to quaternion.\r\n            currentRotation.multiplyInPlace(rotationChange);\r\n        }\r\n\r\n        // Yaw.\r\n        if (\r\n            this.buttonsYaw.some((v) => {\r\n                return v === this.activeButton;\r\n            })\r\n        ) {\r\n            // Apply change in Radians to vector Angle.\r\n            rotationChange = Quaternion.RotationAxis(Axis.Y, x);\r\n            // Apply Yaw to quaternion.\r\n            currentRotation.multiplyInPlace(rotationChange);\r\n\r\n            // Add Roll, if banked turning is enabled, within Roll limit.\r\n            const limit = camera.bankedTurnLimit + camera._trackRoll; // Defaults to 90° plus manual roll.\r\n            if (camera.bankedTurn && -limit < camera.rotation.z && camera.rotation.z < limit) {\r\n                const bankingDelta = camera.bankedTurnMultiplier * -x;\r\n                // Apply change in Radians to vector Angle.\r\n                rotationChange = Quaternion.RotationAxis(Axis.Z, bankingDelta);\r\n                // Apply Yaw to quaternion.\r\n                currentRotation.multiplyInPlace(rotationChange);\r\n            }\r\n        }\r\n\r\n        // Roll.\r\n        if (\r\n            this.buttonsRoll.some((v) => {\r\n                return v === this.activeButton;\r\n            })\r\n        ) {\r\n            // Apply change in Radians to vector Angle.\r\n            rotationChange = Quaternion.RotationAxis(Axis.Z, -x);\r\n            // Track Rolling.\r\n            camera._trackRoll -= x;\r\n            // Apply Pitch to quaternion.\r\n            currentRotation.multiplyInPlace(rotationChange);\r\n        }\r\n\r\n        // Apply rotationQuaternion to Euler camera.rotation.\r\n        currentRotation.toEulerAnglesToRef(camera.rotation);\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FlyCameraMouseInput\"] = FlyCameraMouseInput;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}