{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { DataBuffer } from \"../Buffers/dataBuffer.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { CreateImageDataArrayBufferViews, GetEnvInfo, UploadEnvSpherical } from \"../Misc/environmentTextureTools.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { ThinEngine } from \"./thinEngine.js\";\nimport { EngineStore } from \"./engineStore.js\";\nimport { ShaderCodeInliner } from \"./Processors/shaderCodeInliner.js\";\nimport { WebGL2ShaderProcessor } from \"../Engines/WebGL/webGL2ShaderProcessors.js\";\nimport { NativeDataStream } from \"./Native/nativeDataStream.js\";\nimport { NativePipelineContext } from \"./Native/nativePipelineContext.js\";\nimport { NativeRenderTargetWrapper } from \"./Native/nativeRenderTargetWrapper.js\";\nimport { NativeHardwareTexture } from \"./Native/nativeHardwareTexture.js\";\nimport { getNativeAlphaMode, getNativeAttribType, getNativeSamplingMode, getNativeTextureFormat, getNativeStencilDepthFail, getNativeStencilDepthPass, getNativeStencilFunc, getNativeStencilOpFail, getNativeAddressMode } from \"./Native/nativeHelpers.js\";\nconst onNativeObjectInitialized = new Observable();\nif (typeof self !== \"undefined\" && !Object.prototype.hasOwnProperty.call(self, \"_native\")) {\n  let __native;\n  Object.defineProperty(self, \"_native\", {\n    get: () => __native,\n    set: value => {\n      __native = value;\n      if (__native) {\n        onNativeObjectInitialized.notifyObservers(__native);\n      }\n    }\n  });\n}\n/**\n * Returns _native only after it has been defined by BabylonNative.\n * @internal\n */\nexport function AcquireNativeObjectAsync() {\n  return new Promise(resolve => {\n    if (typeof _native === \"undefined\") {\n      onNativeObjectInitialized.addOnce(nativeObject => resolve(nativeObject));\n    } else {\n      resolve(_native);\n    }\n  });\n}\n/**\n * Registers a constructor on the _native object. See NativeXRFrame for an example.\n * @internal\n */\nexport async function RegisterNativeTypeAsync(typeName, constructor) {\n  (await AcquireNativeObjectAsync())[typeName] = constructor;\n}\n/**\n * Container for accessors for natively-stored mesh data buffers.\n */\nclass NativeDataBuffer extends DataBuffer {}\n/** @internal */\nclass CommandBufferEncoder {\n  constructor(_engine) {\n    this._engine = _engine;\n    this._pending = new Array();\n    this._isCommandBufferScopeActive = false;\n    this._commandStream = NativeEngine._createNativeDataStream();\n    this._engine.setCommandDataStream(this._commandStream);\n  }\n  beginCommandScope() {\n    if (this._isCommandBufferScopeActive) {\n      throw new Error(\"Command scope already active.\");\n    }\n    this._isCommandBufferScopeActive = true;\n  }\n  endCommandScope() {\n    if (!this._isCommandBufferScopeActive) {\n      throw new Error(\"Command scope is not active.\");\n    }\n    this._isCommandBufferScopeActive = false;\n    this._submit();\n  }\n  startEncodingCommand(command) {\n    this._commandStream.writeNativeData(command);\n  }\n  encodeCommandArgAsUInt32(commandArg) {\n    this._commandStream.writeUint32(commandArg);\n  }\n  encodeCommandArgAsUInt32s(commandArg) {\n    this._commandStream.writeUint32Array(commandArg);\n  }\n  encodeCommandArgAsInt32(commandArg) {\n    this._commandStream.writeInt32(commandArg);\n  }\n  encodeCommandArgAsInt32s(commandArg) {\n    this._commandStream.writeInt32Array(commandArg);\n  }\n  encodeCommandArgAsFloat32(commandArg) {\n    this._commandStream.writeFloat32(commandArg);\n  }\n  encodeCommandArgAsFloat32s(commandArg) {\n    this._commandStream.writeFloat32Array(commandArg);\n  }\n  encodeCommandArgAsNativeData(commandArg) {\n    this._commandStream.writeNativeData(commandArg);\n    this._pending.push(commandArg);\n  }\n  finishEncodingCommand() {\n    if (!this._isCommandBufferScopeActive) {\n      this._submit();\n    }\n  }\n  _submit() {\n    this._engine.submitCommands();\n    this._pending.length = 0;\n  }\n}\n/** @internal */\nexport class NativeEngine extends Engine {\n  setHardwareScalingLevel(level) {\n    super.setHardwareScalingLevel(level);\n    this._engine.setHardwareScalingLevel(level);\n  }\n  constructor(options = {}) {\n    super(null, false, undefined, options.adaptToDeviceRatio);\n    this._engine = new _native.Engine();\n    this._camera = _native.Camera ? new _native.Camera() : null;\n    this._commandBufferEncoder = new CommandBufferEncoder(this._engine);\n    this._boundBuffersVertexArray = null;\n    this._currentDepthTest = _native.Engine.DEPTH_TEST_LEQUAL;\n    this._stencilTest = false;\n    this._stencilMask = 255;\n    this._stencilFunc = 519;\n    this._stencilFuncRef = 0;\n    this._stencilFuncMask = 255;\n    this._stencilOpStencilFail = 7680;\n    this._stencilOpDepthFail = 7680;\n    this._stencilOpStencilDepthPass = 7681;\n    this._zOffset = 0;\n    this._zOffsetUnits = 0;\n    this._depthWrite = true;\n    if (_native.Engine.PROTOCOL_VERSION !== NativeEngine.PROTOCOL_VERSION) {\n      throw new Error(`Protocol version mismatch: ${_native.Engine.PROTOCOL_VERSION} (Native) !== ${NativeEngine.PROTOCOL_VERSION} (JS)`);\n    }\n    this._webGLVersion = 2;\n    this.disableUniformBuffers = true;\n    this._shaderPlatformName = \"NATIVE\";\n    // TODO: Initialize this more correctly based on the hardware capabilities.\n    // Init caps\n    this._caps = {\n      maxTexturesImageUnits: 16,\n      maxVertexTextureImageUnits: 16,\n      maxCombinedTexturesImageUnits: 32,\n      maxTextureSize: _native.Engine.CAPS_LIMITS_MAX_TEXTURE_SIZE,\n      maxCubemapTextureSize: 512,\n      maxRenderTextureSize: 512,\n      maxVertexAttribs: 16,\n      maxVaryingVectors: 16,\n      maxFragmentUniformVectors: 16,\n      maxVertexUniformVectors: 16,\n      standardDerivatives: true,\n      astc: null,\n      pvrtc: null,\n      etc1: null,\n      etc2: null,\n      bptc: null,\n      maxAnisotropy: 16,\n      uintIndices: true,\n      fragmentDepthSupported: false,\n      highPrecisionShaderSupported: true,\n      colorBufferFloat: false,\n      textureFloat: true,\n      textureFloatLinearFiltering: false,\n      textureFloatRender: true,\n      textureHalfFloat: true,\n      textureHalfFloatLinearFiltering: false,\n      textureHalfFloatRender: true,\n      textureLOD: true,\n      texelFetch: false,\n      drawBuffersExtension: false,\n      depthTextureExtension: false,\n      vertexArrayObject: true,\n      instancedArrays: true,\n      supportOcclusionQuery: false,\n      canUseTimestampForTimerQuery: false,\n      blendMinMax: false,\n      maxMSAASamples: 16,\n      canUseGLInstanceID: true,\n      canUseGLVertexID: true,\n      supportComputeShaders: false,\n      supportSRGBBuffers: true,\n      supportTransformFeedbacks: false,\n      textureMaxLevel: false,\n      texture2DArrayMaxLayerCount: _native.Engine.CAPS_LIMITS_MAX_TEXTURE_LAYERS,\n      disableMorphTargetTexture: false\n    };\n    this._features = {\n      forceBitmapOverHTMLImageElement: false,\n      supportRenderAndCopyToLodForFloatTextures: false,\n      supportDepthStencilTexture: false,\n      supportShadowSamplers: false,\n      uniformBufferHardCheckMatrix: false,\n      allowTexturePrefiltering: false,\n      trackUbosInFrame: false,\n      checkUbosContentBeforeUpload: false,\n      supportCSM: false,\n      basisNeedsPOT: false,\n      support3DTextures: false,\n      needTypeSuffixInShaderConstants: false,\n      supportMSAA: true,\n      supportSSAO2: false,\n      supportExtendedTextureFormats: false,\n      supportSwitchCaseInShader: false,\n      supportSyncTextureRead: false,\n      needsInvertingBitmap: true,\n      useUBOBindingCache: true,\n      needShaderCodeInlining: true,\n      needToAlwaysBindUniformBuffers: false,\n      supportRenderPasses: true,\n      supportSpriteInstancing: false,\n      forceVertexBufferStrideMultiple4Bytes: false,\n      _collectUbosUpdatedInFrame: false\n    };\n    Tools.Log(\"Babylon Native (v\" + Engine.Version + \") launched\");\n    Tools.LoadScript = function (scriptUrl, onSuccess, onError, scriptId) {\n      Tools.LoadFile(scriptUrl, data => {\n        Function(data).apply(null);\n        if (onSuccess) {\n          onSuccess();\n        }\n      }, undefined, undefined, false, (request, exception) => {\n        if (onError) {\n          onError(\"LoadScript Error\", exception);\n        }\n      });\n    };\n    // Wrappers\n    if (typeof URL === \"undefined\") {\n      window.URL = {\n        createObjectURL: function () {},\n        revokeObjectURL: function () {}\n      };\n    }\n    if (typeof Blob === \"undefined\") {\n      window.Blob = function (v) {\n        return v;\n      };\n    }\n    // polyfill for Chakra\n    if (!Array.prototype.flat) {\n      Object.defineProperty(Array.prototype, \"flat\", {\n        configurable: true,\n        value: function flat() {\n          const depth = isNaN(arguments[0]) ? 1 : Number(arguments[0]);\n          return depth ? Array.prototype.reduce.call(this, function (acc, cur) {\n            if (Array.isArray(cur)) {\n              acc.push.apply(acc, flat.call(cur, depth - 1));\n            } else {\n              acc.push(cur);\n            }\n            return acc;\n          }, []) : Array.prototype.slice.call(this);\n        },\n        writable: true\n      });\n    }\n    // Currently we do not fully configure the ThinEngine on construction of NativeEngine.\n    // Setup resolution scaling based on display settings.\n    const devicePixelRatio = window ? window.devicePixelRatio || 1.0 : 1.0;\n    this._hardwareScalingLevel = options.adaptToDeviceRatio ? 1.0 / devicePixelRatio : 1.0;\n    this._engine.setHardwareScalingLevel(this._hardwareScalingLevel);\n    this._lastDevicePixelRatio = devicePixelRatio;\n    this.resize();\n    const currentDepthFunction = this.getDepthFunction();\n    if (currentDepthFunction) {\n      this.setDepthFunction(currentDepthFunction);\n    }\n    // Shader processor\n    this._shaderProcessor = new WebGL2ShaderProcessor();\n    this.onNewSceneAddedObservable.add(scene => {\n      const originalRender = scene.render;\n      scene.render = (...args) => {\n        this._commandBufferEncoder.beginCommandScope();\n        originalRender.apply(scene, args);\n        this._commandBufferEncoder.endCommandScope();\n      };\n    });\n  }\n  dispose() {\n    super.dispose();\n    if (this._boundBuffersVertexArray) {\n      this._deleteVertexArray(this._boundBuffersVertexArray);\n    }\n    this._engine.dispose();\n  }\n  /** @internal */\n  static _createNativeDataStream() {\n    return new NativeDataStream();\n  }\n  /**\n   * Can be used to override the current requestAnimationFrame requester.\n   * @internal\n   */\n  _queueNewFrame(bindedRenderFunction, requester) {\n    // Use the provided requestAnimationFrame, unless the requester is the window. In that case, we will default to the Babylon Native version of requestAnimationFrame.\n    if (requester.requestAnimationFrame && requester !== window) {\n      requester.requestAnimationFrame(bindedRenderFunction);\n    } else {\n      this._engine.requestAnimationFrame(bindedRenderFunction);\n    }\n    return 0;\n  }\n  /**\n   * Override default engine behavior.\n   * @param framebuffer\n   */\n  _bindUnboundFramebuffer(framebuffer) {\n    if (this._currentFramebuffer !== framebuffer) {\n      if (this._currentFramebuffer) {\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_UNBINDFRAMEBUFFER);\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(this._currentFramebuffer);\n        this._commandBufferEncoder.finishEncodingCommand();\n      }\n      if (framebuffer) {\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_BINDFRAMEBUFFER);\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(framebuffer);\n        this._commandBufferEncoder.finishEncodingCommand();\n      }\n      this._currentFramebuffer = framebuffer;\n    }\n  }\n  /**\n   * Gets host document\n   * @returns the host document object\n   */\n  getHostDocument() {\n    return null;\n  }\n  clear(color, backBuffer, depth, stencil = false) {\n    if (this.useReverseDepthBuffer) {\n      throw new Error(\"reverse depth buffer is not currently implemented\");\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_CLEAR);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(backBuffer && color ? 1 : 0);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.r : 0);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.g : 0);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.b : 0);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.a : 1);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(depth ? 1 : 0);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(1);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(stencil ? 1 : 0);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(0);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  createIndexBuffer(indices, updateable, _label) {\n    const data = this._normalizeIndexData(indices);\n    const buffer = new NativeDataBuffer();\n    buffer.references = 1;\n    buffer.is32Bits = data.BYTES_PER_ELEMENT === 4;\n    if (data.byteLength) {\n      buffer.nativeIndexBuffer = this._engine.createIndexBuffer(data.buffer, data.byteOffset, data.byteLength, buffer.is32Bits, updateable !== null && updateable !== void 0 ? updateable : false);\n    }\n    return buffer;\n  }\n  createVertexBuffer(vertices, updateable, _label) {\n    const data = ArrayBuffer.isView(vertices) ? vertices : new Float32Array(vertices);\n    const buffer = new NativeDataBuffer();\n    buffer.references = 1;\n    if (data.byteLength) {\n      buffer.nativeVertexBuffer = this._engine.createVertexBuffer(data.buffer, data.byteOffset, data.byteLength, updateable !== null && updateable !== void 0 ? updateable : false);\n    }\n    return buffer;\n  }\n  _recordVertexArrayObject(vertexArray, vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {\n    if (indexBuffer) {\n      this._engine.recordIndexBuffer(vertexArray, indexBuffer.nativeIndexBuffer);\n    }\n    const attributes = effect.getAttributesNames();\n    for (let index = 0; index < attributes.length; index++) {\n      const location = effect.getAttributeLocation(index);\n      if (location >= 0) {\n        const kind = attributes[index];\n        let vertexBuffer = null;\n        if (overrideVertexBuffers) {\n          vertexBuffer = overrideVertexBuffers[kind];\n        }\n        if (!vertexBuffer) {\n          vertexBuffer = vertexBuffers[kind];\n        }\n        if (vertexBuffer) {\n          const buffer = vertexBuffer.getBuffer();\n          if (buffer && buffer.nativeVertexBuffer) {\n            this._engine.recordVertexBuffer(vertexArray, buffer.nativeVertexBuffer, location, vertexBuffer.byteOffset, vertexBuffer.byteStride, vertexBuffer.getSize(), getNativeAttribType(vertexBuffer.type), vertexBuffer.normalized, vertexBuffer.getInstanceDivisor());\n          }\n        }\n      }\n    }\n  }\n  bindBuffers(vertexBuffers, indexBuffer, effect) {\n    if (this._boundBuffersVertexArray) {\n      this._deleteVertexArray(this._boundBuffersVertexArray);\n    }\n    this._boundBuffersVertexArray = this._engine.createVertexArray();\n    this._recordVertexArrayObject(this._boundBuffersVertexArray, vertexBuffers, indexBuffer, effect);\n    this.bindVertexArrayObject(this._boundBuffersVertexArray);\n  }\n  recordVertexArrayObject(vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {\n    const vertexArray = this._engine.createVertexArray();\n    this._recordVertexArrayObject(vertexArray, vertexBuffers, indexBuffer, effect, overrideVertexBuffers);\n    return vertexArray;\n  }\n  _deleteVertexArray(vertexArray) {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEVERTEXARRAY);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(vertexArray);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  bindVertexArrayObject(vertexArray) {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_BINDVERTEXARRAY);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(vertexArray);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  releaseVertexArrayObject(vertexArray) {\n    this._deleteVertexArray(vertexArray);\n  }\n  getAttributes(pipelineContext, attributesNames) {\n    const nativePipelineContext = pipelineContext;\n    return this._engine.getAttributes(nativePipelineContext.nativeProgram, attributesNames);\n  }\n  /**\n   * Draw a list of indexed primitives\n   * @param fillMode defines the primitive to use\n   * @param indexStart defines the starting index\n   * @param indexCount defines the number of index to draw\n   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n   */\n  drawElementsType(fillMode, indexStart, indexCount, instancesCount) {\n    // Apply states\n    this._drawCalls.addCount(1, false);\n    if (instancesCount && _native.Engine.COMMAND_DRAWINDEXEDINSTANCED) {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAWINDEXEDINSTANCED);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(fillMode);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(indexStart);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(indexCount);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(instancesCount);\n    } else {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAWINDEXED);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(fillMode);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(indexStart);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(indexCount);\n    }\n    this._commandBufferEncoder.finishEncodingCommand();\n    // }\n  }\n  /**\n   * Draw a list of unindexed primitives\n   * @param fillMode defines the primitive to use\n   * @param verticesStart defines the index of first vertex to draw\n   * @param verticesCount defines the count of vertices to draw\n   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n   */\n  drawArraysType(fillMode, verticesStart, verticesCount, instancesCount) {\n    // Apply states\n    this._drawCalls.addCount(1, false);\n    if (instancesCount && _native.Engine.COMMAND_DRAWINSTANCED) {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAWINSTANCED);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(fillMode);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(verticesStart);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(verticesCount);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(instancesCount);\n    } else {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAW);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(fillMode);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(verticesStart);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(verticesCount);\n    }\n    this._commandBufferEncoder.finishEncodingCommand();\n    // }\n  }\n\n  createPipelineContext() {\n    return new NativePipelineContext(this);\n  }\n  createMaterialContext() {\n    return undefined;\n  }\n  createDrawContext() {\n    return undefined;\n  }\n  _preparePipelineContext(pipelineContext, vertexSourceCode, fragmentSourceCode, createAsRaw, _rawVertexSourceCode, _rawFragmentSourceCode, _rebuildRebind, defines) {\n    const nativePipelineContext = pipelineContext;\n    if (createAsRaw) {\n      nativePipelineContext.nativeProgram = this.createRawShaderProgram();\n    } else {\n      nativePipelineContext.nativeProgram = this.createShaderProgram(pipelineContext, vertexSourceCode, fragmentSourceCode, defines);\n    }\n  }\n  isAsync(pipelineContext) {\n    return !!(pipelineContext.isAsync && this._engine.createProgramAsync);\n  }\n  /**\n   * @internal\n   */\n  _executeWhenRenderingStateIsCompiled(pipelineContext, action) {\n    const nativePipelineContext = pipelineContext;\n    if (!this.isAsync(pipelineContext)) {\n      action();\n      return;\n    }\n    const oldHandler = nativePipelineContext.onCompiled;\n    if (oldHandler) {\n      nativePipelineContext.onCompiled = () => {\n        oldHandler();\n        action();\n      };\n    } else {\n      nativePipelineContext.onCompiled = action;\n    }\n  }\n  createRawShaderProgram() {\n    throw new Error(\"Not Supported\");\n  }\n  createShaderProgram(pipelineContext, vertexCode, fragmentCode, defines) {\n    const nativePipelineContext = pipelineContext;\n    if (nativePipelineContext.nativeProgram) {\n      throw new Error(\"Tried to create a second program in the same NativePipelineContext\");\n    }\n    this.onBeforeShaderCompilationObservable.notifyObservers(this);\n    const vertexInliner = new ShaderCodeInliner(vertexCode);\n    vertexInliner.processCode();\n    vertexCode = vertexInliner.code;\n    const fragmentInliner = new ShaderCodeInliner(fragmentCode);\n    fragmentInliner.processCode();\n    fragmentCode = fragmentInliner.code;\n    vertexCode = ThinEngine._ConcatenateShader(vertexCode, defines);\n    fragmentCode = ThinEngine._ConcatenateShader(fragmentCode, defines);\n    const onSuccess = () => {\n      var _a;\n      nativePipelineContext.isCompiled = true;\n      (_a = nativePipelineContext.onCompiled) === null || _a === void 0 ? void 0 : _a.call(nativePipelineContext);\n      this.onAfterShaderCompilationObservable.notifyObservers(this);\n    };\n    if (this.isAsync(pipelineContext)) {\n      return this._engine.createProgramAsync(vertexCode, fragmentCode, onSuccess, error => {\n        nativePipelineContext.compilationError = error;\n      });\n    } else {\n      try {\n        const program = nativePipelineContext.nativeProgram = this._engine.createProgram(vertexCode, fragmentCode);\n        onSuccess();\n        return program;\n      } catch (e) {\n        const message = e === null || e === void 0 ? void 0 : e.message;\n        throw new Error(\"SHADER ERROR\" + (typeof message === \"string\" ? \"\\n\" + message : \"\"));\n      }\n    }\n  }\n  /**\n   * Inline functions in shader code that are marked to be inlined\n   * @param code code to inline\n   * @returns inlined code\n   */\n  inlineShaderCode(code) {\n    const sci = new ShaderCodeInliner(code);\n    sci.debug = false;\n    sci.processCode();\n    return sci.code;\n  }\n  _setProgram(program) {\n    if (this._currentProgram !== program) {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETPROGRAM);\n      this._commandBufferEncoder.encodeCommandArgAsNativeData(program);\n      this._commandBufferEncoder.finishEncodingCommand();\n      this._currentProgram = program;\n    }\n  }\n  _deletePipelineContext(pipelineContext) {\n    const nativePipelineContext = pipelineContext;\n    if (nativePipelineContext && nativePipelineContext.nativeProgram) {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEPROGRAM);\n      this._commandBufferEncoder.encodeCommandArgAsNativeData(nativePipelineContext.nativeProgram);\n      this._commandBufferEncoder.finishEncodingCommand();\n    }\n  }\n  getUniforms(pipelineContext, uniformsNames) {\n    const nativePipelineContext = pipelineContext;\n    return this._engine.getUniforms(nativePipelineContext.nativeProgram, uniformsNames);\n  }\n  bindUniformBlock(pipelineContext, blockName, index) {\n    // TODO\n    throw new Error(\"Not Implemented\");\n  }\n  bindSamplers(effect) {\n    const nativePipelineContext = effect.getPipelineContext();\n    this._setProgram(nativePipelineContext.nativeProgram);\n    // TODO: share this with engine?\n    const samplers = effect.getSamplers();\n    for (let index = 0; index < samplers.length; index++) {\n      const uniform = effect.getUniform(samplers[index]);\n      if (uniform) {\n        this._boundUniforms[index] = uniform;\n      }\n    }\n    this._currentEffect = null;\n  }\n  getRenderWidth(useScreen = false) {\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.width;\n    }\n    return this._engine.getRenderWidth();\n  }\n  getRenderHeight(useScreen = false) {\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.height;\n    }\n    return this._engine.getRenderHeight();\n  }\n  setViewport(viewport, requiredWidth, requiredHeight) {\n    this._cachedViewport = viewport;\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETVIEWPORT);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(viewport.x);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(viewport.y);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(viewport.width);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(viewport.height);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  enableScissor(x, y, width, height) {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSCISSOR);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(x);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(y);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(width);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(height);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  disableScissor() {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSCISSOR);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(0);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(0);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(0);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(0);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  setState(culling, zOffset = 0, force, reverseSide = false, cullBackFaces, stencil, zOffsetUnits = 0) {\n    var _a, _b;\n    this._zOffset = zOffset;\n    this._zOffsetUnits = zOffsetUnits;\n    if (this._zOffset !== 0) {\n      Tools.Warn(\"zOffset is not supported in Native engine.\");\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSTATE);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(culling ? 1 : 0);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(zOffset);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(zOffsetUnits);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(((_b = (_a = this.cullBackFaces) !== null && _a !== void 0 ? _a : cullBackFaces) !== null && _b !== void 0 ? _b : true) ? 1 : 0);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(reverseSide ? 1 : 0);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  /**\n   * Gets the client rect of native canvas.  Needed for InputManager.\n   * @returns a client rectangle\n   */\n  getInputElementClientRect() {\n    const rect = {\n      bottom: this.getRenderHeight(),\n      height: this.getRenderHeight(),\n      left: 0,\n      right: this.getRenderWidth(),\n      top: 0,\n      width: this.getRenderWidth(),\n      x: 0,\n      y: 0,\n      toJSON: () => {}\n    };\n    return rect;\n  }\n  /**\n   * Set the z offset Factor to apply to current rendering\n   * @param value defines the offset to apply\n   */\n  setZOffset(value) {\n    if (value !== this._zOffset) {\n      this._zOffset = value;\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETZOFFSET);\n      this._commandBufferEncoder.encodeCommandArgAsFloat32(this.useReverseDepthBuffer ? -value : value);\n      this._commandBufferEncoder.finishEncodingCommand();\n    }\n  }\n  /**\n   * Gets the current value of the zOffset Factor\n   * @returns the current zOffset Factor state\n   */\n  getZOffset() {\n    return this._zOffset;\n  }\n  /**\n   * Set the z offset Units to apply to current rendering\n   * @param value defines the offset to apply\n   */\n  setZOffsetUnits(value) {\n    if (value !== this._zOffsetUnits) {\n      this._zOffsetUnits = value;\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETZOFFSETUNITS);\n      this._commandBufferEncoder.encodeCommandArgAsFloat32(this.useReverseDepthBuffer ? -value : value);\n      this._commandBufferEncoder.finishEncodingCommand();\n    }\n  }\n  /**\n   * Gets the current value of the zOffset Units\n   * @returns the current zOffset Units state\n   */\n  getZOffsetUnits() {\n    return this._zOffsetUnits;\n  }\n  /**\n   * Enable or disable depth buffering\n   * @param enable defines the state to set\n   */\n  setDepthBuffer(enable) {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETDEPTHTEST);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(enable ? this._currentDepthTest : _native.Engine.DEPTH_TEST_ALWAYS);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  /**\n   * Gets a boolean indicating if depth writing is enabled\n   * @returns the current depth writing state\n   */\n  getDepthWrite() {\n    return this._depthWrite;\n  }\n  getDepthFunction() {\n    switch (this._currentDepthTest) {\n      case _native.Engine.DEPTH_TEST_NEVER:\n        return 512;\n      case _native.Engine.DEPTH_TEST_ALWAYS:\n        return 519;\n      case _native.Engine.DEPTH_TEST_GREATER:\n        return 516;\n      case _native.Engine.DEPTH_TEST_GEQUAL:\n        return 518;\n      case _native.Engine.DEPTH_TEST_NOTEQUAL:\n        return 517;\n      case _native.Engine.DEPTH_TEST_EQUAL:\n        return 514;\n      case _native.Engine.DEPTH_TEST_LESS:\n        return 513;\n      case _native.Engine.DEPTH_TEST_LEQUAL:\n        return 515;\n    }\n    return null;\n  }\n  setDepthFunction(depthFunc) {\n    let nativeDepthFunc = 0;\n    switch (depthFunc) {\n      case 512:\n        nativeDepthFunc = _native.Engine.DEPTH_TEST_NEVER;\n        break;\n      case 519:\n        nativeDepthFunc = _native.Engine.DEPTH_TEST_ALWAYS;\n        break;\n      case 516:\n        nativeDepthFunc = _native.Engine.DEPTH_TEST_GREATER;\n        break;\n      case 518:\n        nativeDepthFunc = _native.Engine.DEPTH_TEST_GEQUAL;\n        break;\n      case 517:\n        nativeDepthFunc = _native.Engine.DEPTH_TEST_NOTEQUAL;\n        break;\n      case 514:\n        nativeDepthFunc = _native.Engine.DEPTH_TEST_EQUAL;\n        break;\n      case 513:\n        nativeDepthFunc = _native.Engine.DEPTH_TEST_LESS;\n        break;\n      case 515:\n        nativeDepthFunc = _native.Engine.DEPTH_TEST_LEQUAL;\n        break;\n    }\n    this._currentDepthTest = nativeDepthFunc;\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETDEPTHTEST);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(this._currentDepthTest);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  /**\n   * Enable or disable depth writing\n   * @param enable defines the state to set\n   */\n  setDepthWrite(enable) {\n    this._depthWrite = enable;\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETDEPTHWRITE);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(Number(enable));\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  /**\n   * Enable or disable color writing\n   * @param enable defines the state to set\n   */\n  setColorWrite(enable) {\n    this._colorWrite = enable;\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETCOLORWRITE);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(Number(enable));\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  /**\n   * Gets a boolean indicating if color writing is enabled\n   * @returns the current color writing state\n   */\n  getColorWrite() {\n    return this._colorWrite;\n  }\n  applyStencil() {\n    this._setStencil(this._stencilMask, getNativeStencilOpFail(this._stencilOpStencilFail), getNativeStencilDepthFail(this._stencilOpDepthFail), getNativeStencilDepthPass(this._stencilOpStencilDepthPass), getNativeStencilFunc(this._stencilFunc), this._stencilFuncRef);\n  }\n  _setStencil(mask, stencilOpFail, depthOpFail, depthOpPass, func, ref) {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSTENCIL);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(mask);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(stencilOpFail);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(depthOpFail);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(depthOpPass);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(func);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(ref);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  /**\n   * Enable or disable the stencil buffer\n   * @param enable defines if the stencil buffer must be enabled or disabled\n   */\n  setStencilBuffer(enable) {\n    this._stencilTest = enable;\n    if (enable) {\n      this.applyStencil();\n    } else {\n      this._setStencil(255, _native.Engine.STENCIL_OP_FAIL_S_KEEP, _native.Engine.STENCIL_OP_FAIL_Z_KEEP, _native.Engine.STENCIL_OP_PASS_Z_KEEP, _native.Engine.STENCIL_TEST_ALWAYS, 0);\n    }\n  }\n  /**\n   * Gets a boolean indicating if stencil buffer is enabled\n   * @returns the current stencil buffer state\n   */\n  getStencilBuffer() {\n    return this._stencilTest;\n  }\n  /**\n   * Gets the current stencil operation when stencil passes\n   * @returns a number defining stencil operation to use when stencil passes\n   */\n  getStencilOperationPass() {\n    return this._stencilOpStencilDepthPass;\n  }\n  /**\n   * Sets the stencil operation to use when stencil passes\n   * @param operation defines the stencil operation to use when stencil passes\n   */\n  setStencilOperationPass(operation) {\n    this._stencilOpStencilDepthPass = operation;\n    this.applyStencil();\n  }\n  /**\n   * Sets the current stencil mask\n   * @param mask defines the new stencil mask to use\n   */\n  setStencilMask(mask) {\n    this._stencilMask = mask;\n    this.applyStencil();\n  }\n  /**\n   * Sets the current stencil function\n   * @param stencilFunc defines the new stencil function to use\n   */\n  setStencilFunction(stencilFunc) {\n    this._stencilFunc = stencilFunc;\n    this.applyStencil();\n  }\n  /**\n   * Sets the current stencil reference\n   * @param reference defines the new stencil reference to use\n   */\n  setStencilFunctionReference(reference) {\n    this._stencilFuncRef = reference;\n    this.applyStencil();\n  }\n  /**\n   * Sets the current stencil mask\n   * @param mask defines the new stencil mask to use\n   */\n  setStencilFunctionMask(mask) {\n    this._stencilFuncMask = mask;\n  }\n  /**\n   * Sets the stencil operation to use when stencil fails\n   * @param operation defines the stencil operation to use when stencil fails\n   */\n  setStencilOperationFail(operation) {\n    this._stencilOpStencilFail = operation;\n    this.applyStencil();\n  }\n  /**\n   * Sets the stencil operation to use when depth fails\n   * @param operation defines the stencil operation to use when depth fails\n   */\n  setStencilOperationDepthFail(operation) {\n    this._stencilOpDepthFail = operation;\n    this.applyStencil();\n  }\n  /**\n   * Gets the current stencil mask\n   * @returns a number defining the new stencil mask to use\n   */\n  getStencilMask() {\n    return this._stencilMask;\n  }\n  /**\n   * Gets the current stencil function\n   * @returns a number defining the stencil function to use\n   */\n  getStencilFunction() {\n    return this._stencilFunc;\n  }\n  /**\n   * Gets the current stencil reference value\n   * @returns a number defining the stencil reference value to use\n   */\n  getStencilFunctionReference() {\n    return this._stencilFuncRef;\n  }\n  /**\n   * Gets the current stencil mask\n   * @returns a number defining the stencil mask to use\n   */\n  getStencilFunctionMask() {\n    return this._stencilFuncMask;\n  }\n  /**\n   * Gets the current stencil operation when stencil fails\n   * @returns a number defining stencil operation to use when stencil fails\n   */\n  getStencilOperationFail() {\n    return this._stencilOpStencilFail;\n  }\n  /**\n   * Gets the current stencil operation when depth fails\n   * @returns a number defining stencil operation to use when depth fails\n   */\n  getStencilOperationDepthFail() {\n    return this._stencilOpDepthFail;\n  }\n  /**\n   * Sets alpha constants used by some alpha blending modes\n   * @param r defines the red component\n   * @param g defines the green component\n   * @param b defines the blue component\n   * @param a defines the alpha component\n   */\n  setAlphaConstants(r, g, b, a) {\n    throw new Error(\"Setting alpha blend constant color not yet implemented.\");\n  }\n  /**\n   * Sets the current alpha mode\n   * @param mode defines the mode to use (one of the BABYLON.undefined)\n   * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering\n   */\n  setAlphaMode(mode, noDepthWriteChange = false) {\n    if (this._alphaMode === mode) {\n      return;\n    }\n    const nativeMode = getNativeAlphaMode(mode);\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETBLENDMODE);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(nativeMode);\n    this._commandBufferEncoder.finishEncodingCommand();\n    if (!noDepthWriteChange) {\n      this.setDepthWrite(mode === 0);\n    }\n    this._alphaMode = mode;\n  }\n  /**\n   * Gets the current alpha mode\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering\n   * @returns the current alpha mode\n   */\n  getAlphaMode() {\n    return this._alphaMode;\n  }\n  setInt(uniform, int) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINT);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsInt32(int);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setIntArray(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsInt32s(array);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setIntArray2(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY2);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsInt32s(array);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setIntArray3(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY3);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsInt32s(array);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setIntArray4(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY4);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsInt32s(array);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setFloatArray(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setFloatArray2(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY2);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setFloatArray3(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY3);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setFloatArray4(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY4);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setArray(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    return this.setFloatArray(uniform, new Float32Array(array));\n  }\n  setArray2(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    return this.setFloatArray2(uniform, new Float32Array(array));\n  }\n  setArray3(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    return this.setFloatArray3(uniform, new Float32Array(array));\n  }\n  setArray4(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    return this.setFloatArray4(uniform, new Float32Array(array));\n  }\n  setMatrices(uniform, matrices) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETMATRICES);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32s(matrices);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setMatrix3x3(uniform, matrix) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETMATRIX3X3);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32s(matrix);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setMatrix2x2(uniform, matrix) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETMATRIX2X2);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32s(matrix);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setFloat(uniform, value) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(value);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setFloat2(uniform, x, y) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT2);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(x);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(y);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setFloat3(uniform, x, y, z) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT3);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(x);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(y);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(z);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setFloat4(uniform, x, y, z, w) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT4);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(x);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(y);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(z);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(w);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setColor3(uniform, color3) {\n    if (!uniform) {\n      return false;\n    }\n    this.setFloat3(uniform, color3.r, color3.g, color3.b);\n    return true;\n  }\n  setColor4(uniform, color3, alpha) {\n    if (!uniform) {\n      return false;\n    }\n    this.setFloat4(uniform, color3.r, color3.g, color3.b, alpha);\n    return true;\n  }\n  wipeCaches(bruteForce) {\n    if (this.preventCacheWipeBetweenFrames) {\n      return;\n    }\n    this.resetTextureCache();\n    this._currentEffect = null;\n    if (bruteForce) {\n      this._currentProgram = null;\n      this._stencilStateComposer.reset();\n      this._depthCullingState.reset();\n      this._alphaState.reset();\n    }\n    this._cachedVertexBuffers = null;\n    this._cachedIndexBuffer = null;\n    this._cachedEffectForVertexBuffers = null;\n  }\n  _createTexture() {\n    return this._engine.createTexture();\n  }\n  _deleteTexture(texture) {\n    if (texture) {\n      this._engine.deleteTexture(texture);\n    }\n  }\n  /**\n   * Update the content of a dynamic texture\n   * @param texture defines the texture to update\n   * @param canvas defines the canvas containing the source\n   * @param invertY defines if data must be stored with Y axis inverted\n   * @param premulAlpha defines if alpha is stored as premultiplied\n   * @param format defines the format of the data\n   */\n  updateDynamicTexture(texture, canvas, invertY, premulAlpha = false, format) {\n    if (premulAlpha === void 0) {\n      premulAlpha = false;\n    }\n    if (!!texture && !!texture._hardwareTexture) {\n      const source = canvas.getCanvasTexture();\n      const destination = texture._hardwareTexture.underlyingResource;\n      this._engine.copyTexture(destination, source);\n      texture.isReady = true;\n    }\n  }\n  createDynamicTexture(width, height, generateMipMaps, samplingMode) {\n    // it's not possible to create 0x0 texture sized. Many bgfx methods assume texture size is at least 1x1(best case).\n    // Worst case is getting a crash/assert.\n    width = Math.max(width, 1);\n    height = Math.max(height, 1);\n    return this.createRawTexture(new Uint8Array(width * height * 4), width, height, 5, false, false, samplingMode);\n  }\n  createVideoElement(constraints) {\n    // create native object depending on stream. Only NativeCamera is supported for now.\n    if (this._camera) {\n      return this._camera.createVideo(constraints);\n    }\n    return null;\n  }\n  updateVideoTexture(texture, video, invertY) {\n    if (texture && texture._hardwareTexture && this._camera) {\n      const webGLTexture = texture._hardwareTexture.underlyingResource;\n      this._camera.updateVideoTexture(webGLTexture, video, invertY);\n    }\n  }\n  createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, compression = null, type = 0, creationFlags = 0, useSRGBBuffer = false) {\n    const texture = new InternalTexture(this, InternalTextureSource.Raw);\n    texture.format = format;\n    texture.generateMipMaps = generateMipMaps;\n    texture.samplingMode = samplingMode;\n    texture.invertY = invertY;\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = texture.baseWidth;\n    texture.height = texture.baseHeight;\n    texture._compression = compression;\n    texture.type = type;\n    texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !generateMipMaps);\n    this.updateRawTexture(texture, data, format, invertY, compression, type, texture._useSRGBBuffer);\n    if (texture._hardwareTexture) {\n      const webGLTexture = texture._hardwareTexture.underlyingResource;\n      const filter = getNativeSamplingMode(samplingMode);\n      this._setTextureSampling(webGLTexture, filter);\n    }\n    this._internalTexturesCache.push(texture);\n    return texture;\n  }\n  createRawTexture2DArray(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression = null, textureType = 0) {\n    const texture = new InternalTexture(this, InternalTextureSource.Raw2DArray);\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.baseDepth = depth;\n    texture.width = width;\n    texture.height = height;\n    texture.depth = depth;\n    texture.format = format;\n    texture.type = textureType;\n    texture.generateMipMaps = generateMipMaps;\n    texture.samplingMode = samplingMode;\n    texture.is2DArray = true;\n    if (texture._hardwareTexture) {\n      const nativeTexture = texture._hardwareTexture.underlyingResource;\n      this._engine.loadRawTexture2DArray(nativeTexture, data, width, height, depth, getNativeTextureFormat(format, textureType), generateMipMaps, invertY);\n      const filter = getNativeSamplingMode(samplingMode);\n      this._setTextureSampling(nativeTexture, filter);\n    }\n    texture.isReady = true;\n    this._internalTexturesCache.push(texture);\n    return texture;\n  }\n  updateRawTexture(texture, bufferView, format, invertY, compression = null, type = 0, useSRGBBuffer = false) {\n    if (!texture) {\n      return;\n    }\n    if (bufferView && texture._hardwareTexture) {\n      const underlyingResource = texture._hardwareTexture.underlyingResource;\n      this._engine.loadRawTexture(underlyingResource, bufferView, texture.width, texture.height, getNativeTextureFormat(format, type), texture.generateMipMaps, texture.invertY);\n    }\n    texture.isReady = true;\n  }\n  // TODO: Refactor to share more logic with babylon.engine.ts version.\n  /**\n   * Usually called from Texture.ts.\n   * Passed information to create a NativeTexture\n   * @param url defines a value which contains one of the following:\n   * * A conventional http URL, e.g. 'http://...' or 'file://...'\n   * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\n   * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\n   * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\n   * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\n   * @param scene needed for loading to the correct scene\n   * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\n   * @param onLoad optional callback to be called upon successful completion\n   * @param onError optional callback to be called upon failure\n   * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\n   * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\n   * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\n   * @param forcedExtension defines the extension to use to pick the right loader\n   * @param mimeType defines an optional mime type\n   * @param loaderOptions options to be passed to the loader\n   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n   * @returns a InternalTexture for assignment back into BABYLON.Texture\n   */\n  createTexture(url, noMipmap, invertY, scene, samplingMode = 3, onLoad = null, onError = null, buffer = null, fallback = null, format = null, forcedExtension = null, mimeType, loaderOptions, creationFlags, useSRGBBuffer = false) {\n    url = url || \"\";\n    const fromData = url.substr(0, 5) === \"data:\";\n    //const fromBlob = url.substr(0, 5) === \"blob:\";\n    const isBase64 = fromData && url.indexOf(\";base64,\") !== -1;\n    const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Url);\n    const originalUrl = url;\n    if (this._transformTextureUrl && !isBase64 && !fallback && !buffer) {\n      url = this._transformTextureUrl(url);\n    }\n    // establish the file extension, if possible\n    const lastDot = url.lastIndexOf(\".\");\n    const extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : \"\";\n    let loader = null;\n    for (const availableLoader of Engine._TextureLoaders) {\n      if (availableLoader.canLoad(extension)) {\n        loader = availableLoader;\n        break;\n      }\n    }\n    if (scene) {\n      scene.addPendingData(texture);\n    }\n    texture.url = url;\n    texture.generateMipMaps = !noMipmap;\n    texture.samplingMode = samplingMode;\n    texture.invertY = invertY;\n    texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, noMipmap);\n    if (!this.doNotHandleContextLost) {\n      // Keep a link to the buffer only if we plan to handle context lost\n      texture._buffer = buffer;\n    }\n    let onLoadObserver = null;\n    if (onLoad && !fallback) {\n      onLoadObserver = texture.onLoadedObservable.add(onLoad);\n    }\n    if (!fallback) {\n      this._internalTexturesCache.push(texture);\n    }\n    const onInternalError = (message, exception) => {\n      if (scene) {\n        scene.removePendingData(texture);\n      }\n      if (url === originalUrl) {\n        if (onLoadObserver) {\n          texture.onLoadedObservable.remove(onLoadObserver);\n        }\n        if (EngineStore.UseFallbackTexture) {\n          this.createTexture(EngineStore.FallbackTexture, noMipmap, texture.invertY, scene, samplingMode, null, onError, buffer, texture);\n        }\n        if (onError) {\n          onError((message || \"Unknown error\") + (EngineStore.UseFallbackTexture ? \" - Fallback texture was used\" : \"\"), exception);\n        }\n      } else {\n        // fall back to the original url if the transformed url fails to load\n        Logger.Warn(`Failed to load ${url}, falling back to ${originalUrl}`);\n        this.createTexture(originalUrl, noMipmap, texture.invertY, scene, samplingMode, onLoad, onError, buffer, texture, format, forcedExtension, mimeType, loaderOptions);\n      }\n    };\n    // processing for non-image formats\n    if (loader) {\n      throw new Error(\"Loading textures from IInternalTextureLoader not yet implemented.\");\n    } else {\n      const onload = data => {\n        if (!texture._hardwareTexture) {\n          if (scene) {\n            scene.removePendingData(texture);\n          }\n          return;\n        }\n        const underlyingResource = texture._hardwareTexture.underlyingResource;\n        this._engine.loadTexture(underlyingResource, data, !noMipmap, invertY, texture._useSRGBBuffer, () => {\n          texture.baseWidth = this._engine.getTextureWidth(underlyingResource);\n          texture.baseHeight = this._engine.getTextureHeight(underlyingResource);\n          texture.width = texture.baseWidth;\n          texture.height = texture.baseHeight;\n          texture.isReady = true;\n          const filter = getNativeSamplingMode(samplingMode);\n          this._setTextureSampling(underlyingResource, filter);\n          if (scene) {\n            scene.removePendingData(texture);\n          }\n          texture.onLoadedObservable.notifyObservers(texture);\n          texture.onLoadedObservable.clear();\n        }, () => {\n          throw new Error(\"Could not load a native texture.\");\n        });\n      };\n      if (fromData && buffer) {\n        if (buffer instanceof ArrayBuffer) {\n          onload(new Uint8Array(buffer));\n        } else if (ArrayBuffer.isView(buffer)) {\n          onload(buffer);\n        } else if (typeof buffer === \"string\") {\n          onload(new Uint8Array(Tools.DecodeBase64(buffer)));\n        } else {\n          throw new Error(\"Unsupported buffer type\");\n        }\n      } else {\n        if (isBase64) {\n          onload(new Uint8Array(Tools.DecodeBase64(url)));\n        } else {\n          this._loadFile(url, data => onload(new Uint8Array(data)), undefined, undefined, true, (request, exception) => {\n            onInternalError(\"Unable to load \" + (request ? request.responseURL : url, exception));\n          });\n        }\n      }\n    }\n    return texture;\n  }\n  /**\n   * Wraps an external native texture in a Babylon texture.\n   * @param texture defines the external texture\n   * @param hasMipMaps defines whether the external texture has mip maps\n   * @param samplingMode defines the sampling mode for the external texture (default: 3)\n   * @returns the babylon internal texture\n   */\n  wrapNativeTexture(texture, hasMipMaps = false, samplingMode = 3) {\n    const hardwareTexture = new NativeHardwareTexture(texture, this._engine);\n    const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);\n    internalTexture._hardwareTexture = hardwareTexture;\n    internalTexture.baseWidth = this._engine.getTextureWidth(texture);\n    internalTexture.baseHeight = this._engine.getTextureHeight(texture);\n    internalTexture.width = internalTexture.baseWidth;\n    internalTexture.height = internalTexture.baseHeight;\n    internalTexture.isReady = true;\n    internalTexture.useMipMaps = hasMipMaps;\n    this.updateTextureSamplingMode(samplingMode, internalTexture);\n    return internalTexture;\n  }\n  /**\n   * Wraps an external web gl texture in a Babylon texture.\n   * @returns the babylon internal texture\n   */\n  wrapWebGLTexture() {\n    throw new Error(\"wrapWebGLTexture is not supported, use wrapNativeTexture instead.\");\n  }\n  _createDepthStencilTexture(size, options, rtWrapper) {\n    var _a, _b;\n    // TODO: handle other options?\n    const generateStencil = options.generateStencil || false;\n    const samples = options.samples || 1;\n    const nativeRTWrapper = rtWrapper;\n    const texture = new InternalTexture(this, InternalTextureSource.DepthStencil);\n    const width = (_a = size.width) !== null && _a !== void 0 ? _a : size;\n    const height = (_b = size.height) !== null && _b !== void 0 ? _b : size;\n    const framebuffer = this._engine.createFrameBuffer(texture._hardwareTexture.underlyingResource, width, height, generateStencil, true, samples);\n    nativeRTWrapper._framebufferDepthStencil = framebuffer;\n    return texture;\n  }\n  /**\n   * @internal\n   */\n  _releaseFramebufferObjects(framebuffer) {\n    if (framebuffer) {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEFRAMEBUFFER);\n      this._commandBufferEncoder.encodeCommandArgAsNativeData(framebuffer);\n      this._commandBufferEncoder.finishEncodingCommand();\n    }\n  }\n  /**\n   * @internal Engine abstraction for loading and creating an image bitmap from a given source string.\n   * @param imageSource source to load the image from.\n   * @param options An object that sets options for the image's extraction.\n   * @returns ImageBitmap\n   */\n  _createImageBitmapFromSource(imageSource, options) {\n    const promise = new Promise((resolve, reject) => {\n      const image = this.createCanvasImage();\n      image.onload = () => {\n        try {\n          const imageBitmap = this._engine.createImageBitmap(image);\n          resolve(imageBitmap);\n        } catch (error) {\n          reject(`Error loading image ${image.src} with exception: ${error}`);\n        }\n      };\n      image.onerror = error => {\n        reject(`Error loading image ${image.src} with exception: ${error}`);\n      };\n      image.src = imageSource;\n    });\n    return promise;\n  }\n  /**\n   * Engine abstraction for createImageBitmap\n   * @param image source for image\n   * @param options An object that sets options for the image's extraction.\n   * @returns ImageBitmap\n   */\n  createImageBitmap(image, options) {\n    return new Promise((resolve, reject) => {\n      if (Array.isArray(image)) {\n        const arr = image;\n        if (arr.length) {\n          const image = this._engine.createImageBitmap(arr[0]);\n          if (image) {\n            resolve(image);\n            return;\n          }\n        }\n      }\n      reject(`Unsupported data for createImageBitmap.`);\n    });\n  }\n  /**\n   * Resize an image and returns the image data as an uint8array\n   * @param image image to resize\n   * @param bufferWidth destination buffer width\n   * @param bufferHeight destination buffer height\n   * @returns an uint8array containing RGBA values of bufferWidth * bufferHeight size\n   */\n  resizeImageBitmap(image, bufferWidth, bufferHeight) {\n    return this._engine.resizeImageBitmap(image, bufferWidth, bufferHeight);\n  }\n  /**\n   * Creates a cube texture\n   * @param rootUrl defines the url where the files to load is located\n   * @param scene defines the current scene\n   * @param files defines the list of files to load (1 per face)\n   * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\n   * @param onLoad defines an optional callback raised when the texture is loaded\n   * @param onError defines an optional callback raised if there is an issue to load the texture\n   * @param format defines the format of the data\n   * @param forcedExtension defines the extension to use to pick the right loader\n   * @param createPolynomials if a polynomial sphere should be created for the cube texture\n   * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\n   * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\n   * @param fallback defines texture to use while falling back when (compressed) texture file not found.\n   * @param loaderOptions options to be passed to the loader\n   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n   * @returns the cube texture as an InternalTexture\n   */\n  createCubeTexture(rootUrl, scene, files, noMipmap, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = false, lodScale = 0, lodOffset = 0, fallback = null, loaderOptions, useSRGBBuffer = false) {\n    const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);\n    texture.isCube = true;\n    texture.url = rootUrl;\n    texture.generateMipMaps = !noMipmap;\n    texture._lodGenerationScale = lodScale;\n    texture._lodGenerationOffset = lodOffset;\n    texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !!noMipmap);\n    if (!this._doNotHandleContextLost) {\n      texture._extension = forcedExtension;\n      texture._files = files;\n    }\n    const lastDot = rootUrl.lastIndexOf(\".\");\n    const extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrl.substring(lastDot).toLowerCase() : \"\";\n    // TODO: use texture loader to load env files?\n    if (extension === \".env\") {\n      const onloaddata = data => {\n        const info = GetEnvInfo(data);\n        texture.width = info.width;\n        texture.height = info.width;\n        UploadEnvSpherical(texture, info);\n        const specularInfo = info.specular;\n        if (!specularInfo) {\n          throw new Error(`Nothing else parsed so far`);\n        }\n        texture._lodGenerationScale = specularInfo.lodGenerationScale;\n        const imageData = CreateImageDataArrayBufferViews(data, info);\n        texture.format = 5;\n        texture.type = 0;\n        texture.generateMipMaps = true;\n        texture.getEngine().updateTextureSamplingMode(Texture.TRILINEAR_SAMPLINGMODE, texture);\n        texture._isRGBD = true;\n        texture.invertY = true;\n        this._engine.loadCubeTextureWithMips(texture._hardwareTexture.underlyingResource, imageData, false, texture._useSRGBBuffer, () => {\n          texture.isReady = true;\n          if (onLoad) {\n            onLoad();\n          }\n        }, () => {\n          throw new Error(\"Could not load a native cube texture.\");\n        });\n      };\n      if (files && files.length === 6) {\n        throw new Error(`Multi-file loading not allowed on env files.`);\n      } else {\n        const onInternalError = (request, exception) => {\n          if (onError && request) {\n            onError(request.status + \" \" + request.statusText, exception);\n          }\n        };\n        this._loadFile(rootUrl, data => onloaddata(new Uint8Array(data)), undefined, undefined, true, onInternalError);\n      }\n    } else {\n      if (!files || files.length !== 6) {\n        throw new Error(\"Cannot load cubemap because 6 files were not defined\");\n      }\n      // Reorder from [+X, +Y, +Z, -X, -Y, -Z] to [+X, -X, +Y, -Y, +Z, -Z].\n      const reorderedFiles = [files[0], files[3], files[1], files[4], files[2], files[5]];\n      Promise.all(reorderedFiles.map(file => Tools.LoadFileAsync(file).then(data => new Uint8Array(data)))).then(data => {\n        return new Promise((resolve, reject) => {\n          this._engine.loadCubeTexture(texture._hardwareTexture.underlyingResource, data, !noMipmap, true, texture._useSRGBBuffer, resolve, reject);\n        });\n      }).then(() => {\n        texture.isReady = true;\n        if (onLoad) {\n          onLoad();\n        }\n      }, error => {\n        if (onError) {\n          onError(`Failed to load cubemap: ${error.message}`, error);\n        }\n      });\n    }\n    this._internalTexturesCache.push(texture);\n    return texture;\n  }\n  /** @internal */\n  _createHardwareTexture() {\n    return new NativeHardwareTexture(this._createTexture(), this._engine);\n  }\n  /** @internal */\n  _createHardwareRenderTargetWrapper(isMulti, isCube, size) {\n    const rtWrapper = new NativeRenderTargetWrapper(isMulti, isCube, size, this);\n    this._renderTargetWrapperCache.push(rtWrapper);\n    return rtWrapper;\n  }\n  /** @internal */\n  _createInternalTexture(size, options, _delayGPUTextureCreation = true, source = InternalTextureSource.Unknown) {\n    var _a, _b, _c;\n    let generateMipMaps = false;\n    let type = 0;\n    let samplingMode = 3;\n    let format = 5;\n    let useSRGBBuffer = false;\n    let samples = 1;\n    let label;\n    if (options !== undefined && typeof options === \"object\") {\n      generateMipMaps = !!options.generateMipMaps;\n      type = options.type === undefined ? 0 : options.type;\n      samplingMode = options.samplingMode === undefined ? 3 : options.samplingMode;\n      format = options.format === undefined ? 5 : options.format;\n      useSRGBBuffer = options.useSRGBBuffer === undefined ? false : options.useSRGBBuffer;\n      samples = (_a = options.samples) !== null && _a !== void 0 ? _a : 1;\n      label = options.label;\n    } else {\n      generateMipMaps = !!options;\n    }\n    useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !generateMipMaps);\n    if (type === 1 && !this._caps.textureFloatLinearFiltering) {\n      // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\n      samplingMode = 1;\n    } else if (type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\n      // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\n      samplingMode = 1;\n    }\n    if (type === 1 && !this._caps.textureFloat) {\n      type = 0;\n      Logger.Warn(\"Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE\");\n    }\n    const texture = new InternalTexture(this, source);\n    const width = (_b = size.width) !== null && _b !== void 0 ? _b : size;\n    const height = (_c = size.height) !== null && _c !== void 0 ? _c : size;\n    const layers = size.layers || 0;\n    if (layers !== 0) {\n      throw new Error(\"Texture layers are not supported in Babylon Native\");\n    }\n    const nativeTexture = texture._hardwareTexture.underlyingResource;\n    const nativeTextureFormat = getNativeTextureFormat(format, type);\n    // REVIEW: We are always setting the renderTarget flag as we don't know whether the texture will be used as a render target.\n    this._engine.initializeTexture(nativeTexture, width, height, generateMipMaps, nativeTextureFormat, true, useSRGBBuffer, samples);\n    this._setTextureSampling(nativeTexture, getNativeSamplingMode(samplingMode));\n    texture._useSRGBBuffer = useSRGBBuffer;\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = width;\n    texture.height = height;\n    texture.depth = layers;\n    texture.isReady = true;\n    texture.samples = samples;\n    texture.generateMipMaps = generateMipMaps;\n    texture.samplingMode = samplingMode;\n    texture.type = type;\n    texture.format = format;\n    texture.label = label;\n    this._internalTexturesCache.push(texture);\n    return texture;\n  }\n  createRenderTargetTexture(size, options) {\n    var _a, _b, _c, _d;\n    const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size);\n    let generateDepthBuffer = true;\n    let generateStencilBuffer = false;\n    let noColorAttachment = false;\n    let colorAttachment = undefined;\n    let samples = 1;\n    if (options !== undefined && typeof options === \"object\") {\n      generateDepthBuffer = (_a = options.generateDepthBuffer) !== null && _a !== void 0 ? _a : true;\n      generateStencilBuffer = !!options.generateStencilBuffer;\n      noColorAttachment = !!options.noColorAttachment;\n      colorAttachment = options.colorAttachment;\n      samples = (_b = options.samples) !== null && _b !== void 0 ? _b : 1;\n    }\n    const texture = colorAttachment || (noColorAttachment ? null : this._createInternalTexture(size, options, true, InternalTextureSource.RenderTarget));\n    const width = (_c = size.width) !== null && _c !== void 0 ? _c : size;\n    const height = (_d = size.height) !== null && _d !== void 0 ? _d : size;\n    const framebuffer = this._engine.createFrameBuffer(texture ? texture._hardwareTexture.underlyingResource : null, width, height, generateStencilBuffer, generateDepthBuffer, samples);\n    rtWrapper._framebuffer = framebuffer;\n    rtWrapper._generateDepthBuffer = generateDepthBuffer;\n    rtWrapper._generateStencilBuffer = generateStencilBuffer;\n    rtWrapper._samples = samples;\n    rtWrapper.setTextures(texture);\n    return rtWrapper;\n  }\n  updateRenderTargetTextureSampleCount(rtWrapper, samples) {\n    Logger.Warn(\"Updating render target sample count is not currently supported\");\n    return rtWrapper.samples;\n  }\n  updateTextureSamplingMode(samplingMode, texture) {\n    if (texture._hardwareTexture) {\n      const filter = getNativeSamplingMode(samplingMode);\n      this._setTextureSampling(texture._hardwareTexture.underlyingResource, filter);\n    }\n    texture.samplingMode = samplingMode;\n  }\n  bindFramebuffer(texture, faceIndex, requiredWidth, requiredHeight, forceFullscreenViewport) {\n    const nativeRTWrapper = texture;\n    if (this._currentRenderTarget) {\n      this.unBindFramebuffer(this._currentRenderTarget);\n    }\n    this._currentRenderTarget = texture;\n    if (faceIndex) {\n      throw new Error(\"Cuboid frame buffers are not yet supported in NativeEngine.\");\n    }\n    if (requiredWidth || requiredHeight) {\n      throw new Error(\"Required width/height for frame buffers not yet supported in NativeEngine.\");\n    }\n    if (forceFullscreenViewport) {\n      //Not supported yet but don't stop rendering\n    }\n    if (nativeRTWrapper._framebufferDepthStencil) {\n      this._bindUnboundFramebuffer(nativeRTWrapper._framebufferDepthStencil);\n    } else {\n      this._bindUnboundFramebuffer(nativeRTWrapper._framebuffer);\n    }\n  }\n  unBindFramebuffer(texture, disableGenerateMipMaps = false, onBeforeUnbind) {\n    // NOTE: Disabling mipmap generation is not yet supported in NativeEngine.\n    this._currentRenderTarget = null;\n    if (onBeforeUnbind) {\n      onBeforeUnbind();\n    }\n    this._bindUnboundFramebuffer(null);\n  }\n  createDynamicVertexBuffer(data) {\n    return this.createVertexBuffer(data, true);\n  }\n  updateDynamicIndexBuffer(indexBuffer, indices, offset = 0) {\n    const buffer = indexBuffer;\n    const data = this._normalizeIndexData(indices);\n    buffer.is32Bits = data.BYTES_PER_ELEMENT === 4;\n    this._engine.updateDynamicIndexBuffer(buffer.nativeIndexBuffer, data.buffer, data.byteOffset, data.byteLength, offset);\n  }\n  updateDynamicVertexBuffer(vertexBuffer, verticies, byteOffset, byteLength) {\n    const buffer = vertexBuffer;\n    const data = ArrayBuffer.isView(verticies) ? verticies : new Float32Array(verticies);\n    this._engine.updateDynamicVertexBuffer(buffer.nativeVertexBuffer, data.buffer, data.byteOffset + (byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0), byteLength !== null && byteLength !== void 0 ? byteLength : data.byteLength);\n  }\n  // TODO: Refactor to share more logic with base Engine implementation.\n  _setTexture(channel, texture, isPartOfTextureArray = false, depthStencilTexture = false) {\n    const uniform = this._boundUniforms[channel];\n    if (!uniform) {\n      return false;\n    }\n    // Not ready?\n    if (!texture) {\n      if (this._boundTexturesCache[channel] != null) {\n        this._activeChannel = channel;\n        this._boundTexturesCache[channel] = null;\n      }\n      return false;\n    }\n    // Video\n    if (texture.video) {\n      this._activeChannel = channel;\n      texture.update();\n    } else if (texture.delayLoadState === 4) {\n      // Delay loading\n      texture.delayLoad();\n      return false;\n    }\n    let internalTexture;\n    if (depthStencilTexture) {\n      internalTexture = texture.depthStencilTexture;\n    } else if (texture.isReady()) {\n      internalTexture = texture.getInternalTexture();\n    } else if (texture.isCube) {\n      internalTexture = this.emptyCubeTexture;\n    } else if (texture.is3D) {\n      internalTexture = this.emptyTexture3D;\n    } else if (texture.is2DArray) {\n      internalTexture = this.emptyTexture2DArray;\n    } else {\n      internalTexture = this.emptyTexture;\n    }\n    this._activeChannel = channel;\n    if (!internalTexture || !internalTexture._hardwareTexture) {\n      return false;\n    }\n    this._setTextureWrapMode(internalTexture._hardwareTexture.underlyingResource, getNativeAddressMode(texture.wrapU), getNativeAddressMode(texture.wrapV), getNativeAddressMode(texture.wrapR));\n    this._updateAnisotropicLevel(texture);\n    this._setTextureCore(uniform, internalTexture._hardwareTexture.underlyingResource);\n    return true;\n  }\n  // filter is a NativeFilter.XXXX value.\n  _setTextureSampling(texture, filter) {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTURESAMPLING);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(texture);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(filter);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  // addressModes are NativeAddressMode.XXXX values.\n  _setTextureWrapMode(texture, addressModeU, addressModeV, addressModeW) {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTUREWRAPMODE);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(texture);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(addressModeU);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(addressModeV);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(addressModeW);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  _setTextureCore(uniform, texture) {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTURE);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(texture);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  // TODO: Share more of this logic with the base implementation.\n  // TODO: Rename to match naming in base implementation once refactoring allows different parameters.\n  _updateAnisotropicLevel(texture) {\n    const internalTexture = texture.getInternalTexture();\n    const value = texture.anisotropicFilteringLevel;\n    if (!internalTexture || !internalTexture._hardwareTexture) {\n      return;\n    }\n    if (internalTexture._cachedAnisotropicFilteringLevel !== value) {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTUREANISOTROPICLEVEL);\n      this._commandBufferEncoder.encodeCommandArgAsNativeData(internalTexture._hardwareTexture.underlyingResource);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(value);\n      this._commandBufferEncoder.finishEncodingCommand();\n      internalTexture._cachedAnisotropicFilteringLevel = value;\n    }\n  }\n  /**\n   * @internal\n   */\n  _bindTexture(channel, texture) {\n    const uniform = this._boundUniforms[channel];\n    if (!uniform) {\n      return;\n    }\n    if (texture && texture._hardwareTexture) {\n      const underlyingResource = texture._hardwareTexture.underlyingResource;\n      this._setTextureCore(uniform, underlyingResource);\n    }\n  }\n  _deleteBuffer(buffer) {\n    if (buffer.nativeIndexBuffer) {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEINDEXBUFFER);\n      this._commandBufferEncoder.encodeCommandArgAsNativeData(buffer.nativeIndexBuffer);\n      this._commandBufferEncoder.finishEncodingCommand();\n      delete buffer.nativeIndexBuffer;\n    }\n    if (buffer.nativeVertexBuffer) {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEVERTEXBUFFER);\n      this._commandBufferEncoder.encodeCommandArgAsNativeData(buffer.nativeVertexBuffer);\n      this._commandBufferEncoder.finishEncodingCommand();\n      delete buffer.nativeVertexBuffer;\n    }\n  }\n  /**\n   * Create a canvas\n   * @param width width\n   * @param height height\n   * @returns ICanvas interface\n   */\n  createCanvas(width, height) {\n    if (!_native.Canvas) {\n      throw new Error(\"Native Canvas plugin not available.\");\n    }\n    const canvas = new _native.Canvas();\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  }\n  /**\n   * Create an image to use with canvas\n   * @returns IImage interface\n   */\n  createCanvasImage() {\n    if (!_native.Canvas) {\n      throw new Error(\"Native Canvas plugin not available.\");\n    }\n    const image = new _native.Image();\n    return image;\n  }\n  /**\n   * Update a portion of an internal texture\n   * @param texture defines the texture to update\n   * @param imageData defines the data to store into the texture\n   * @param xOffset defines the x coordinates of the update rectangle\n   * @param yOffset defines the y coordinates of the update rectangle\n   * @param width defines the width of the update rectangle\n   * @param height defines the height of the update rectangle\n   * @param faceIndex defines the face index if texture is a cube (0 by default)\n   * @param lod defines the lod level to update (0 by default)\n   * @param generateMipMaps defines whether to generate mipmaps or not\n   */\n  updateTextureData(texture, imageData, xOffset, yOffset, width, height, faceIndex = 0, lod = 0, generateMipMaps = false) {\n    throw new Error(\"updateTextureData not implemented.\");\n  }\n  /**\n   * @internal\n   */\n  _uploadCompressedDataToTextureDirectly(texture, internalFormat, width, height, data, faceIndex = 0, lod = 0) {\n    throw new Error(\"_uploadCompressedDataToTextureDirectly not implemented.\");\n  }\n  /**\n   * @internal\n   */\n  _uploadDataToTextureDirectly(texture, imageData, faceIndex = 0, lod = 0) {\n    throw new Error(\"_uploadDataToTextureDirectly not implemented.\");\n  }\n  /**\n   * @internal\n   */\n  _uploadArrayBufferViewToTexture(texture, imageData, faceIndex = 0, lod = 0) {\n    throw new Error(\"_uploadArrayBufferViewToTexture not implemented.\");\n  }\n  /**\n   * @internal\n   */\n  _uploadImageToTexture(texture, image, faceIndex = 0, lod = 0) {\n    throw new Error(\"_uploadArrayBufferViewToTexture not implemented.\");\n  }\n  getFontOffset(font) {\n    // TODO\n    const result = {\n      ascent: 0,\n      height: 0,\n      descent: 0\n    };\n    return result;\n  }\n  _readTexturePixels(texture, width, height, faceIndex, level, buffer, _flushRenderer, _noDataConversion, x, y) {\n    var _a, _b, _c, _d;\n    if (faceIndex !== undefined && faceIndex !== -1) {\n      throw new Error(`Reading cubemap faces is not supported, but faceIndex is ${faceIndex}.`);\n    }\n    return this._engine.readTexture((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource, level !== null && level !== void 0 ? level : 0, x !== null && x !== void 0 ? x : 0, y !== null && y !== void 0 ? y : 0, width, height, (_b = buffer === null || buffer === void 0 ? void 0 : buffer.buffer) !== null && _b !== void 0 ? _b : null, (_c = buffer === null || buffer === void 0 ? void 0 : buffer.byteOffset) !== null && _c !== void 0 ? _c : 0, (_d = buffer === null || buffer === void 0 ? void 0 : buffer.byteLength) !== null && _d !== void 0 ? _d : 0).then(rawBuffer => {\n      if (!buffer) {\n        buffer = new Uint8Array(rawBuffer);\n      }\n      return buffer;\n    });\n  }\n}\n// This must match the protocol version in NativeEngine.cpp\nNativeEngine.PROTOCOL_VERSION = 8;","map":{"version":3,"names":["Engine","InternalTexture","InternalTextureSource","Texture","DataBuffer","Tools","Observable","CreateImageDataArrayBufferViews","GetEnvInfo","UploadEnvSpherical","Logger","ThinEngine","EngineStore","ShaderCodeInliner","WebGL2ShaderProcessor","NativeDataStream","NativePipelineContext","NativeRenderTargetWrapper","NativeHardwareTexture","getNativeAlphaMode","getNativeAttribType","getNativeSamplingMode","getNativeTextureFormat","getNativeStencilDepthFail","getNativeStencilDepthPass","getNativeStencilFunc","getNativeStencilOpFail","getNativeAddressMode","onNativeObjectInitialized","self","Object","prototype","hasOwnProperty","call","__native","defineProperty","get","set","value","notifyObservers","AcquireNativeObjectAsync","Promise","resolve","_native","addOnce","nativeObject","RegisterNativeTypeAsync","typeName","constructor","NativeDataBuffer","CommandBufferEncoder","_engine","_pending","Array","_isCommandBufferScopeActive","_commandStream","NativeEngine","_createNativeDataStream","setCommandDataStream","beginCommandScope","Error","endCommandScope","_submit","startEncodingCommand","command","writeNativeData","encodeCommandArgAsUInt32","commandArg","writeUint32","encodeCommandArgAsUInt32s","writeUint32Array","encodeCommandArgAsInt32","writeInt32","encodeCommandArgAsInt32s","writeInt32Array","encodeCommandArgAsFloat32","writeFloat32","encodeCommandArgAsFloat32s","writeFloat32Array","encodeCommandArgAsNativeData","push","finishEncodingCommand","submitCommands","length","setHardwareScalingLevel","level","options","undefined","adaptToDeviceRatio","_camera","Camera","_commandBufferEncoder","_boundBuffersVertexArray","_currentDepthTest","DEPTH_TEST_LEQUAL","_stencilTest","_stencilMask","_stencilFunc","_stencilFuncRef","_stencilFuncMask","_stencilOpStencilFail","_stencilOpDepthFail","_stencilOpStencilDepthPass","_zOffset","_zOffsetUnits","_depthWrite","PROTOCOL_VERSION","_webGLVersion","disableUniformBuffers","_shaderPlatformName","_caps","maxTexturesImageUnits","maxVertexTextureImageUnits","maxCombinedTexturesImageUnits","maxTextureSize","CAPS_LIMITS_MAX_TEXTURE_SIZE","maxCubemapTextureSize","maxRenderTextureSize","maxVertexAttribs","maxVaryingVectors","maxFragmentUniformVectors","maxVertexUniformVectors","standardDerivatives","astc","pvrtc","etc1","etc2","bptc","maxAnisotropy","uintIndices","fragmentDepthSupported","highPrecisionShaderSupported","colorBufferFloat","textureFloat","textureFloatLinearFiltering","textureFloatRender","textureHalfFloat","textureHalfFloatLinearFiltering","textureHalfFloatRender","textureLOD","texelFetch","drawBuffersExtension","depthTextureExtension","vertexArrayObject","instancedArrays","supportOcclusionQuery","canUseTimestampForTimerQuery","blendMinMax","maxMSAASamples","canUseGLInstanceID","canUseGLVertexID","supportComputeShaders","supportSRGBBuffers","supportTransformFeedbacks","textureMaxLevel","texture2DArrayMaxLayerCount","CAPS_LIMITS_MAX_TEXTURE_LAYERS","disableMorphTargetTexture","_features","forceBitmapOverHTMLImageElement","supportRenderAndCopyToLodForFloatTextures","supportDepthStencilTexture","supportShadowSamplers","uniformBufferHardCheckMatrix","allowTexturePrefiltering","trackUbosInFrame","checkUbosContentBeforeUpload","supportCSM","basisNeedsPOT","support3DTextures","needTypeSuffixInShaderConstants","supportMSAA","supportSSAO2","supportExtendedTextureFormats","supportSwitchCaseInShader","supportSyncTextureRead","needsInvertingBitmap","useUBOBindingCache","needShaderCodeInlining","needToAlwaysBindUniformBuffers","supportRenderPasses","supportSpriteInstancing","forceVertexBufferStrideMultiple4Bytes","_collectUbosUpdatedInFrame","Log","Version","LoadScript","scriptUrl","onSuccess","onError","scriptId","LoadFile","data","Function","apply","request","exception","URL","window","createObjectURL","revokeObjectURL","Blob","v","flat","configurable","depth","isNaN","arguments","Number","reduce","acc","cur","isArray","slice","writable","devicePixelRatio","_hardwareScalingLevel","_lastDevicePixelRatio","resize","currentDepthFunction","getDepthFunction","setDepthFunction","_shaderProcessor","onNewSceneAddedObservable","add","scene","originalRender","render","args","dispose","_deleteVertexArray","_queueNewFrame","bindedRenderFunction","requester","requestAnimationFrame","_bindUnboundFramebuffer","framebuffer","_currentFramebuffer","COMMAND_UNBINDFRAMEBUFFER","COMMAND_BINDFRAMEBUFFER","getHostDocument","clear","color","backBuffer","stencil","useReverseDepthBuffer","COMMAND_CLEAR","r","g","b","a","createIndexBuffer","indices","updateable","_label","_normalizeIndexData","buffer","references","is32Bits","BYTES_PER_ELEMENT","byteLength","nativeIndexBuffer","byteOffset","createVertexBuffer","vertices","ArrayBuffer","isView","Float32Array","nativeVertexBuffer","_recordVertexArrayObject","vertexArray","vertexBuffers","indexBuffer","effect","overrideVertexBuffers","recordIndexBuffer","attributes","getAttributesNames","index","location","getAttributeLocation","kind","vertexBuffer","getBuffer","recordVertexBuffer","byteStride","getSize","type","normalized","getInstanceDivisor","bindBuffers","createVertexArray","bindVertexArrayObject","recordVertexArrayObject","COMMAND_DELETEVERTEXARRAY","COMMAND_BINDVERTEXARRAY","releaseVertexArrayObject","getAttributes","pipelineContext","attributesNames","nativePipelineContext","nativeProgram","drawElementsType","fillMode","indexStart","indexCount","instancesCount","_drawCalls","addCount","COMMAND_DRAWINDEXEDINSTANCED","COMMAND_DRAWINDEXED","drawArraysType","verticesStart","verticesCount","COMMAND_DRAWINSTANCED","COMMAND_DRAW","createPipelineContext","createMaterialContext","createDrawContext","_preparePipelineContext","vertexSourceCode","fragmentSourceCode","createAsRaw","_rawVertexSourceCode","_rawFragmentSourceCode","_rebuildRebind","defines","createRawShaderProgram","createShaderProgram","isAsync","createProgramAsync","_executeWhenRenderingStateIsCompiled","action","oldHandler","onCompiled","vertexCode","fragmentCode","onBeforeShaderCompilationObservable","vertexInliner","processCode","code","fragmentInliner","_ConcatenateShader","isCompiled","_a","onAfterShaderCompilationObservable","error","compilationError","program","createProgram","e","message","inlineShaderCode","sci","debug","_setProgram","_currentProgram","COMMAND_SETPROGRAM","_deletePipelineContext","COMMAND_DELETEPROGRAM","getUniforms","uniformsNames","bindUniformBlock","blockName","bindSamplers","getPipelineContext","samplers","getSamplers","uniform","getUniform","_boundUniforms","_currentEffect","getRenderWidth","useScreen","_currentRenderTarget","width","getRenderHeight","height","setViewport","viewport","requiredWidth","requiredHeight","_cachedViewport","COMMAND_SETVIEWPORT","x","y","enableScissor","COMMAND_SETSCISSOR","disableScissor","setState","culling","zOffset","force","reverseSide","cullBackFaces","zOffsetUnits","Warn","COMMAND_SETSTATE","_b","getInputElementClientRect","rect","bottom","left","right","top","toJSON","setZOffset","COMMAND_SETZOFFSET","getZOffset","setZOffsetUnits","COMMAND_SETZOFFSETUNITS","getZOffsetUnits","setDepthBuffer","enable","COMMAND_SETDEPTHTEST","DEPTH_TEST_ALWAYS","getDepthWrite","DEPTH_TEST_NEVER","DEPTH_TEST_GREATER","DEPTH_TEST_GEQUAL","DEPTH_TEST_NOTEQUAL","DEPTH_TEST_EQUAL","DEPTH_TEST_LESS","depthFunc","nativeDepthFunc","setDepthWrite","COMMAND_SETDEPTHWRITE","setColorWrite","_colorWrite","COMMAND_SETCOLORWRITE","getColorWrite","applyStencil","_setStencil","mask","stencilOpFail","depthOpFail","depthOpPass","func","ref","COMMAND_SETSTENCIL","setStencilBuffer","STENCIL_OP_FAIL_S_KEEP","STENCIL_OP_FAIL_Z_KEEP","STENCIL_OP_PASS_Z_KEEP","STENCIL_TEST_ALWAYS","getStencilBuffer","getStencilOperationPass","setStencilOperationPass","operation","setStencilMask","setStencilFunction","stencilFunc","setStencilFunctionReference","reference","setStencilFunctionMask","setStencilOperationFail","setStencilOperationDepthFail","getStencilMask","getStencilFunction","getStencilFunctionReference","getStencilFunctionMask","getStencilOperationFail","getStencilOperationDepthFail","setAlphaConstants","setAlphaMode","mode","noDepthWriteChange","_alphaMode","nativeMode","COMMAND_SETBLENDMODE","getAlphaMode","setInt","int","COMMAND_SETINT","setIntArray","array","COMMAND_SETINTARRAY","setIntArray2","COMMAND_SETINTARRAY2","setIntArray3","COMMAND_SETINTARRAY3","setIntArray4","COMMAND_SETINTARRAY4","setFloatArray","COMMAND_SETFLOATARRAY","setFloatArray2","COMMAND_SETFLOATARRAY2","setFloatArray3","COMMAND_SETFLOATARRAY3","setFloatArray4","COMMAND_SETFLOATARRAY4","setArray","setArray2","setArray3","setArray4","setMatrices","matrices","COMMAND_SETMATRICES","setMatrix3x3","matrix","COMMAND_SETMATRIX3X3","setMatrix2x2","COMMAND_SETMATRIX2X2","setFloat","COMMAND_SETFLOAT","setFloat2","COMMAND_SETFLOAT2","setFloat3","z","COMMAND_SETFLOAT3","setFloat4","w","COMMAND_SETFLOAT4","setColor3","color3","setColor4","alpha","wipeCaches","bruteForce","preventCacheWipeBetweenFrames","resetTextureCache","_stencilStateComposer","reset","_depthCullingState","_alphaState","_cachedVertexBuffers","_cachedIndexBuffer","_cachedEffectForVertexBuffers","_createTexture","createTexture","_deleteTexture","texture","deleteTexture","updateDynamicTexture","canvas","invertY","premulAlpha","format","_hardwareTexture","source","getCanvasTexture","destination","underlyingResource","copyTexture","isReady","createDynamicTexture","generateMipMaps","samplingMode","Math","max","createRawTexture","Uint8Array","createVideoElement","constraints","createVideo","updateVideoTexture","video","webGLTexture","compression","creationFlags","useSRGBBuffer","Raw","baseWidth","baseHeight","_compression","_useSRGBBuffer","_getUseSRGBBuffer","updateRawTexture","filter","_setTextureSampling","_internalTexturesCache","createRawTexture2DArray","textureType","Raw2DArray","baseDepth","is2DArray","nativeTexture","loadRawTexture2DArray","bufferView","loadRawTexture","url","noMipmap","onLoad","fallback","forcedExtension","mimeType","loaderOptions","fromData","substr","isBase64","indexOf","Url","originalUrl","_transformTextureUrl","lastDot","lastIndexOf","extension","substring","toLowerCase","loader","availableLoader","_TextureLoaders","canLoad","addPendingData","doNotHandleContextLost","_buffer","onLoadObserver","onLoadedObservable","onInternalError","removePendingData","remove","UseFallbackTexture","FallbackTexture","onload","loadTexture","getTextureWidth","getTextureHeight","DecodeBase64","_loadFile","responseURL","wrapNativeTexture","hasMipMaps","hardwareTexture","internalTexture","Unknown","useMipMaps","updateTextureSamplingMode","wrapWebGLTexture","_createDepthStencilTexture","size","rtWrapper","generateStencil","samples","nativeRTWrapper","DepthStencil","createFrameBuffer","_framebufferDepthStencil","_releaseFramebufferObjects","COMMAND_DELETEFRAMEBUFFER","_createImageBitmapFromSource","imageSource","promise","reject","image","createCanvasImage","imageBitmap","createImageBitmap","src","onerror","arr","resizeImageBitmap","bufferWidth","bufferHeight","createCubeTexture","rootUrl","files","createPolynomials","lodScale","lodOffset","Cube","isCube","_lodGenerationScale","_lodGenerationOffset","_doNotHandleContextLost","_extension","_files","onloaddata","info","specularInfo","specular","lodGenerationScale","imageData","getEngine","TRILINEAR_SAMPLINGMODE","_isRGBD","loadCubeTextureWithMips","status","statusText","reorderedFiles","all","map","file","LoadFileAsync","then","loadCubeTexture","_createHardwareTexture","_createHardwareRenderTargetWrapper","isMulti","_renderTargetWrapperCache","_createInternalTexture","_delayGPUTextureCreation","label","_c","layers","nativeTextureFormat","initializeTexture","createRenderTargetTexture","generateDepthBuffer","generateStencilBuffer","noColorAttachment","colorAttachment","RenderTarget","_d","_framebuffer","_generateDepthBuffer","_generateStencilBuffer","_samples","setTextures","updateRenderTargetTextureSampleCount","bindFramebuffer","faceIndex","forceFullscreenViewport","unBindFramebuffer","disableGenerateMipMaps","onBeforeUnbind","createDynamicVertexBuffer","updateDynamicIndexBuffer","offset","updateDynamicVertexBuffer","verticies","_setTexture","channel","isPartOfTextureArray","depthStencilTexture","_boundTexturesCache","_activeChannel","update","delayLoadState","delayLoad","getInternalTexture","emptyCubeTexture","is3D","emptyTexture3D","emptyTexture2DArray","emptyTexture","_setTextureWrapMode","wrapU","wrapV","wrapR","_updateAnisotropicLevel","_setTextureCore","COMMAND_SETTEXTURESAMPLING","addressModeU","addressModeV","addressModeW","COMMAND_SETTEXTUREWRAPMODE","COMMAND_SETTEXTURE","anisotropicFilteringLevel","_cachedAnisotropicFilteringLevel","COMMAND_SETTEXTUREANISOTROPICLEVEL","_bindTexture","_deleteBuffer","COMMAND_DELETEINDEXBUFFER","COMMAND_DELETEVERTEXBUFFER","createCanvas","Canvas","Image","updateTextureData","xOffset","yOffset","lod","_uploadCompressedDataToTextureDirectly","internalFormat","_uploadDataToTextureDirectly","_uploadArrayBufferViewToTexture","_uploadImageToTexture","getFontOffset","font","result","ascent","descent","_readTexturePixels","_flushRenderer","_noDataConversion","readTexture","rawBuffer"],"sources":["../../../../dev/core/src/Engines/nativeEngine.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable, IndicesArray, DataArray } from \"../types\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport type { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport type { IInternalTextureLoader } from \"../Materials/Textures/internalTextureLoader\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { VideoTexture } from \"../Materials/Textures/videoTexture\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { EnvironmentTextureSpecularInfoV1 } from \"../Misc/environmentTextureTools\";\r\nimport { CreateImageDataArrayBufferViews, GetEnvInfo, UploadEnvSpherical } from \"../Misc/environmentTextureTools\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { RenderTargetCreationOptions, TextureSize, DepthTextureCreationOptions, InternalTextureCreationOptions } from \"../Materials/Textures/textureCreationOptions\";\r\nimport type { IPipelineContext } from \"./IPipelineContext\";\r\nimport type { IColor3Like, IColor4Like, IViewportLike } from \"../Maths/math.like\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Constants } from \"./constants\";\r\nimport type { ISceneLike } from \"./thinEngine\";\r\nimport { ThinEngine } from \"./thinEngine\";\r\nimport type { IWebRequest } from \"../Misc/interfaces/iWebRequest\";\r\nimport { EngineStore } from \"./engineStore\";\r\nimport { ShaderCodeInliner } from \"./Processors/shaderCodeInliner\";\r\nimport { WebGL2ShaderProcessor } from \"../Engines/WebGL/webGL2ShaderProcessors\";\r\nimport type { IMaterialContext } from \"./IMaterialContext\";\r\nimport type { IDrawContext } from \"./IDrawContext\";\r\nimport type { ICanvas, IImage } from \"./ICanvas\";\r\nimport type { IStencilState } from \"../States/IStencilState\";\r\nimport type { RenderTargetWrapper } from \"./renderTargetWrapper\";\r\nimport type { NativeData } from \"./Native/nativeDataStream\";\r\nimport { NativeDataStream } from \"./Native/nativeDataStream\";\r\nimport type { INative, INativeCamera, INativeEngine, NativeFramebuffer, NativeProgram, NativeTexture, NativeUniform, NativeVertexArrayObject } from \"./Native/nativeInterfaces\";\r\nimport { NativePipelineContext } from \"./Native/nativePipelineContext\";\r\nimport { NativeRenderTargetWrapper } from \"./Native/nativeRenderTargetWrapper\";\r\nimport { NativeHardwareTexture } from \"./Native/nativeHardwareTexture\";\r\nimport type { HardwareTextureWrapper } from \"../Materials/Textures/hardwareTextureWrapper\";\r\nimport {\r\n    getNativeAlphaMode,\r\n    getNativeAttribType,\r\n    getNativeSamplingMode,\r\n    getNativeTextureFormat,\r\n    getNativeStencilDepthFail,\r\n    getNativeStencilDepthPass,\r\n    getNativeStencilFunc,\r\n    getNativeStencilOpFail,\r\n    getNativeAddressMode,\r\n} from \"./Native/nativeHelpers\";\r\n\r\ndeclare const _native: INative;\r\n\r\nconst onNativeObjectInitialized = new Observable<INative>();\r\nif (typeof self !== \"undefined\" && !Object.prototype.hasOwnProperty.call(self, \"_native\")) {\r\n    let __native: INative;\r\n    Object.defineProperty(self, \"_native\", {\r\n        get: () => __native,\r\n        set: (value: INative) => {\r\n            __native = value;\r\n            if (__native) {\r\n                onNativeObjectInitialized.notifyObservers(__native);\r\n            }\r\n        },\r\n    });\r\n}\r\n\r\n/**\r\n * Returns _native only after it has been defined by BabylonNative.\r\n * @internal\r\n */\r\nexport function AcquireNativeObjectAsync(): Promise<INative> {\r\n    return new Promise((resolve) => {\r\n        if (typeof _native === \"undefined\") {\r\n            onNativeObjectInitialized.addOnce((nativeObject) => resolve(nativeObject));\r\n        } else {\r\n            resolve(_native);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Registers a constructor on the _native object. See NativeXRFrame for an example.\r\n * @internal\r\n */\r\nexport async function RegisterNativeTypeAsync<Type>(typeName: string, constructor: Type) {\r\n    ((await AcquireNativeObjectAsync()) as any)[typeName] = constructor;\r\n}\r\n\r\n/**\r\n * Container for accessors for natively-stored mesh data buffers.\r\n */\r\nclass NativeDataBuffer extends DataBuffer {\r\n    /**\r\n     * Accessor value used to identify/retrieve a natively-stored index buffer.\r\n     */\r\n    public nativeIndexBuffer?: NativeData;\r\n\r\n    /**\r\n     * Accessor value used to identify/retrieve a natively-stored vertex buffer.\r\n     */\r\n    public nativeVertexBuffer?: NativeData;\r\n}\r\n\r\n/**\r\n * Options to create the Native engine\r\n */\r\nexport interface NativeEngineOptions {\r\n    /**\r\n     * defines whether to adapt to the device's viewport characteristics (default: false)\r\n     */\r\n    adaptToDeviceRatio?: boolean;\r\n}\r\n\r\n/** @internal */\r\nclass CommandBufferEncoder {\r\n    private readonly _commandStream: NativeDataStream;\r\n    private readonly _pending = new Array<NativeData>();\r\n    private _isCommandBufferScopeActive = false;\r\n\r\n    public constructor(private readonly _engine: INativeEngine) {\r\n        this._commandStream = NativeEngine._createNativeDataStream();\r\n        this._engine.setCommandDataStream(this._commandStream);\r\n    }\r\n\r\n    public beginCommandScope() {\r\n        if (this._isCommandBufferScopeActive) {\r\n            throw new Error(\"Command scope already active.\");\r\n        }\r\n\r\n        this._isCommandBufferScopeActive = true;\r\n    }\r\n\r\n    public endCommandScope() {\r\n        if (!this._isCommandBufferScopeActive) {\r\n            throw new Error(\"Command scope is not active.\");\r\n        }\r\n\r\n        this._isCommandBufferScopeActive = false;\r\n        this._submit();\r\n    }\r\n\r\n    public startEncodingCommand(command: NativeData) {\r\n        this._commandStream.writeNativeData(command);\r\n    }\r\n\r\n    public encodeCommandArgAsUInt32(commandArg: number) {\r\n        this._commandStream.writeUint32(commandArg);\r\n    }\r\n\r\n    public encodeCommandArgAsUInt32s(commandArg: Uint32Array) {\r\n        this._commandStream.writeUint32Array(commandArg);\r\n    }\r\n\r\n    public encodeCommandArgAsInt32(commandArg: number) {\r\n        this._commandStream.writeInt32(commandArg);\r\n    }\r\n\r\n    public encodeCommandArgAsInt32s(commandArg: Int32Array) {\r\n        this._commandStream.writeInt32Array(commandArg);\r\n    }\r\n\r\n    public encodeCommandArgAsFloat32(commandArg: number) {\r\n        this._commandStream.writeFloat32(commandArg);\r\n    }\r\n\r\n    public encodeCommandArgAsFloat32s(commandArg: Float32Array) {\r\n        this._commandStream.writeFloat32Array(commandArg);\r\n    }\r\n\r\n    public encodeCommandArgAsNativeData(commandArg: NativeData) {\r\n        this._commandStream.writeNativeData(commandArg);\r\n        this._pending.push(commandArg);\r\n    }\r\n\r\n    public finishEncodingCommand() {\r\n        if (!this._isCommandBufferScopeActive) {\r\n            this._submit();\r\n        }\r\n    }\r\n\r\n    private _submit() {\r\n        this._engine.submitCommands();\r\n        this._pending.length = 0;\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class NativeEngine extends Engine {\r\n    // This must match the protocol version in NativeEngine.cpp\r\n    private static readonly PROTOCOL_VERSION = 8;\r\n\r\n    private readonly _engine: INativeEngine = new _native.Engine();\r\n    private readonly _camera: Nullable<INativeCamera> = _native.Camera ? new _native.Camera() : null;\r\n\r\n    private readonly _commandBufferEncoder = new CommandBufferEncoder(this._engine);\r\n\r\n    private _boundBuffersVertexArray: any = null;\r\n    private _currentDepthTest: number = _native.Engine.DEPTH_TEST_LEQUAL;\r\n    private _stencilTest = false;\r\n    private _stencilMask: number = 255;\r\n    private _stencilFunc: number = Constants.ALWAYS;\r\n    private _stencilFuncRef: number = 0;\r\n    private _stencilFuncMask: number = 255;\r\n    private _stencilOpStencilFail: number = Constants.KEEP;\r\n    private _stencilOpDepthFail: number = Constants.KEEP;\r\n    private _stencilOpStencilDepthPass: number = Constants.REPLACE;\r\n    private _zOffset: number = 0;\r\n    private _zOffsetUnits: number = 0;\r\n    private _depthWrite: boolean = true;\r\n\r\n    public setHardwareScalingLevel(level: number): void {\r\n        super.setHardwareScalingLevel(level);\r\n        this._engine.setHardwareScalingLevel(level);\r\n    }\r\n\r\n    public constructor(options: NativeEngineOptions = {}) {\r\n        super(null, false, undefined, options.adaptToDeviceRatio);\r\n\r\n        if (_native.Engine.PROTOCOL_VERSION !== NativeEngine.PROTOCOL_VERSION) {\r\n            throw new Error(`Protocol version mismatch: ${_native.Engine.PROTOCOL_VERSION} (Native) !== ${NativeEngine.PROTOCOL_VERSION} (JS)`);\r\n        }\r\n\r\n        this._webGLVersion = 2;\r\n        this.disableUniformBuffers = true;\r\n        this._shaderPlatformName = \"NATIVE\";\r\n\r\n        // TODO: Initialize this more correctly based on the hardware capabilities.\r\n        // Init caps\r\n\r\n        this._caps = {\r\n            maxTexturesImageUnits: 16,\r\n            maxVertexTextureImageUnits: 16,\r\n            maxCombinedTexturesImageUnits: 32,\r\n            maxTextureSize: _native.Engine.CAPS_LIMITS_MAX_TEXTURE_SIZE,\r\n            maxCubemapTextureSize: 512,\r\n            maxRenderTextureSize: 512,\r\n            maxVertexAttribs: 16,\r\n            maxVaryingVectors: 16,\r\n            maxFragmentUniformVectors: 16,\r\n            maxVertexUniformVectors: 16,\r\n            standardDerivatives: true,\r\n            astc: null,\r\n            pvrtc: null,\r\n            etc1: null,\r\n            etc2: null,\r\n            bptc: null,\r\n            maxAnisotropy: 16, // TODO: Retrieve this smartly. Currently set to D3D11 maximum allowable value.\r\n            uintIndices: true,\r\n            fragmentDepthSupported: false,\r\n            highPrecisionShaderSupported: true,\r\n            colorBufferFloat: false,\r\n            textureFloat: true,\r\n            textureFloatLinearFiltering: false,\r\n            textureFloatRender: true,\r\n            textureHalfFloat: true,\r\n            textureHalfFloatLinearFiltering: false,\r\n            textureHalfFloatRender: true,\r\n            textureLOD: true,\r\n            texelFetch: false,\r\n            drawBuffersExtension: false,\r\n            depthTextureExtension: false,\r\n            vertexArrayObject: true,\r\n            instancedArrays: true,\r\n            supportOcclusionQuery: false,\r\n            canUseTimestampForTimerQuery: false,\r\n            blendMinMax: false,\r\n            maxMSAASamples: 16,\r\n            canUseGLInstanceID: true,\r\n            canUseGLVertexID: true,\r\n            supportComputeShaders: false,\r\n            supportSRGBBuffers: true,\r\n            supportTransformFeedbacks: false,\r\n            textureMaxLevel: false,\r\n            texture2DArrayMaxLayerCount: _native.Engine.CAPS_LIMITS_MAX_TEXTURE_LAYERS,\r\n            disableMorphTargetTexture: false,\r\n        };\r\n\r\n        this._features = {\r\n            forceBitmapOverHTMLImageElement: false,\r\n            supportRenderAndCopyToLodForFloatTextures: false,\r\n            supportDepthStencilTexture: false,\r\n            supportShadowSamplers: false,\r\n            uniformBufferHardCheckMatrix: false,\r\n            allowTexturePrefiltering: false,\r\n            trackUbosInFrame: false,\r\n            checkUbosContentBeforeUpload: false,\r\n            supportCSM: false,\r\n            basisNeedsPOT: false,\r\n            support3DTextures: false,\r\n            needTypeSuffixInShaderConstants: false,\r\n            supportMSAA: true,\r\n            supportSSAO2: false,\r\n            supportExtendedTextureFormats: false,\r\n            supportSwitchCaseInShader: false,\r\n            supportSyncTextureRead: false,\r\n            needsInvertingBitmap: true,\r\n            useUBOBindingCache: true,\r\n            needShaderCodeInlining: true,\r\n            needToAlwaysBindUniformBuffers: false,\r\n            supportRenderPasses: true,\r\n            supportSpriteInstancing: false,\r\n            forceVertexBufferStrideMultiple4Bytes: false,\r\n            _collectUbosUpdatedInFrame: false,\r\n        };\r\n\r\n        Tools.Log(\"Babylon Native (v\" + Engine.Version + \") launched\");\r\n\r\n        Tools.LoadScript = function (scriptUrl, onSuccess, onError, scriptId) {\r\n            Tools.LoadFile(\r\n                scriptUrl,\r\n                (data) => {\r\n                    Function(data as string).apply(null);\r\n                    if (onSuccess) {\r\n                        onSuccess();\r\n                    }\r\n                },\r\n                undefined,\r\n                undefined,\r\n                false,\r\n                (request, exception) => {\r\n                    if (onError) {\r\n                        onError(\"LoadScript Error\", exception);\r\n                    }\r\n                }\r\n            );\r\n        };\r\n\r\n        // Wrappers\r\n        if (typeof URL === \"undefined\") {\r\n            (window.URL as any) = {\r\n                createObjectURL: function () {},\r\n                revokeObjectURL: function () {},\r\n            };\r\n        }\r\n\r\n        if (typeof Blob === \"undefined\") {\r\n            (window.Blob as any) = function (v: any) {\r\n                return v;\r\n            };\r\n        }\r\n\r\n        // polyfill for Chakra\r\n        if (!Array.prototype.flat) {\r\n            Object.defineProperty(Array.prototype, \"flat\", {\r\n                configurable: true,\r\n                value: function flat() {\r\n                    const depth = isNaN(arguments[0]) ? 1 : Number(arguments[0]);\r\n\r\n                    return depth\r\n                        ? Array.prototype.reduce.call(\r\n                              this,\r\n                              function (acc: any, cur: any) {\r\n                                  if (Array.isArray(cur)) {\r\n                                      acc.push.apply(acc, flat.call(cur, depth - 1));\r\n                                  } else {\r\n                                      acc.push(cur);\r\n                                  }\r\n                                  return acc;\r\n                              },\r\n                              []\r\n                          )\r\n                        : Array.prototype.slice.call(this);\r\n                },\r\n                writable: true,\r\n            });\r\n        }\r\n\r\n        // Currently we do not fully configure the ThinEngine on construction of NativeEngine.\r\n        // Setup resolution scaling based on display settings.\r\n        const devicePixelRatio = window ? window.devicePixelRatio || 1.0 : 1.0;\r\n        this._hardwareScalingLevel = options.adaptToDeviceRatio ? 1.0 / devicePixelRatio : 1.0;\r\n        this._engine.setHardwareScalingLevel(this._hardwareScalingLevel);\r\n        this._lastDevicePixelRatio = devicePixelRatio;\r\n        this.resize();\r\n\r\n        const currentDepthFunction = this.getDepthFunction();\r\n        if (currentDepthFunction) {\r\n            this.setDepthFunction(currentDepthFunction);\r\n        }\r\n\r\n        // Shader processor\r\n        this._shaderProcessor = new WebGL2ShaderProcessor();\r\n\r\n        this.onNewSceneAddedObservable.add((scene) => {\r\n            const originalRender = scene.render;\r\n            scene.render = (...args: Parameters<typeof originalRender>) => {\r\n                this._commandBufferEncoder.beginCommandScope();\r\n                originalRender.apply(scene, args);\r\n                this._commandBufferEncoder.endCommandScope();\r\n            };\r\n        });\r\n    }\r\n\r\n    public dispose(): void {\r\n        super.dispose();\r\n        if (this._boundBuffersVertexArray) {\r\n            this._deleteVertexArray(this._boundBuffersVertexArray);\r\n        }\r\n        this._engine.dispose();\r\n    }\r\n\r\n    /** @internal */\r\n    public static _createNativeDataStream(): NativeDataStream {\r\n        return new NativeDataStream();\r\n    }\r\n\r\n    /**\r\n     * Can be used to override the current requestAnimationFrame requester.\r\n     * @internal\r\n     */\r\n    protected _queueNewFrame(bindedRenderFunction: any, requester?: any): number {\r\n        // Use the provided requestAnimationFrame, unless the requester is the window. In that case, we will default to the Babylon Native version of requestAnimationFrame.\r\n        if (requester.requestAnimationFrame && requester !== window) {\r\n            requester.requestAnimationFrame(bindedRenderFunction);\r\n        } else {\r\n            this._engine.requestAnimationFrame(bindedRenderFunction);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Override default engine behavior.\r\n     * @param framebuffer\r\n     */\r\n    public _bindUnboundFramebuffer(framebuffer: Nullable<WebGLFramebuffer>) {\r\n        if (this._currentFramebuffer !== framebuffer) {\r\n            if (this._currentFramebuffer) {\r\n                this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_UNBINDFRAMEBUFFER);\r\n                this._commandBufferEncoder.encodeCommandArgAsNativeData(this._currentFramebuffer as NativeFramebuffer);\r\n                this._commandBufferEncoder.finishEncodingCommand();\r\n            }\r\n\r\n            if (framebuffer) {\r\n                this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_BINDFRAMEBUFFER);\r\n                this._commandBufferEncoder.encodeCommandArgAsNativeData(framebuffer as NativeFramebuffer);\r\n                this._commandBufferEncoder.finishEncodingCommand();\r\n            }\r\n\r\n            this._currentFramebuffer = framebuffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets host document\r\n     * @returns the host document object\r\n     */\r\n    public getHostDocument(): Nullable<Document> {\r\n        return null;\r\n    }\r\n\r\n    public clear(color: Nullable<IColor4Like>, backBuffer: boolean, depth: boolean, stencil: boolean = false): void {\r\n        if (this.useReverseDepthBuffer) {\r\n            throw new Error(\"reverse depth buffer is not currently implemented\");\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_CLEAR);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(backBuffer && color ? 1 : 0);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.r : 0);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.g : 0);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.b : 0);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.a : 1);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(depth ? 1 : 0);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(1);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(stencil ? 1 : 0);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(0);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    public createIndexBuffer(indices: IndicesArray, updateable?: boolean, _label?: string): NativeDataBuffer {\r\n        const data = this._normalizeIndexData(indices);\r\n        const buffer = new NativeDataBuffer();\r\n        buffer.references = 1;\r\n        buffer.is32Bits = data.BYTES_PER_ELEMENT === 4;\r\n        if (data.byteLength) {\r\n            buffer.nativeIndexBuffer = this._engine.createIndexBuffer(data.buffer, data.byteOffset, data.byteLength, buffer.is32Bits, updateable ?? false);\r\n        }\r\n        return buffer;\r\n    }\r\n\r\n    public createVertexBuffer(vertices: DataArray, updateable?: boolean, _label?: string): NativeDataBuffer {\r\n        const data = ArrayBuffer.isView(vertices) ? vertices : new Float32Array(vertices);\r\n        const buffer = new NativeDataBuffer();\r\n        buffer.references = 1;\r\n        if (data.byteLength) {\r\n            buffer.nativeVertexBuffer = this._engine.createVertexBuffer(data.buffer, data.byteOffset, data.byteLength, updateable ?? false);\r\n        }\r\n        return buffer;\r\n    }\r\n\r\n    protected _recordVertexArrayObject(\r\n        vertexArray: any,\r\n        vertexBuffers: { [key: string]: VertexBuffer },\r\n        indexBuffer: Nullable<NativeDataBuffer>,\r\n        effect: Effect,\r\n        overrideVertexBuffers?: { [kind: string]: Nullable<VertexBuffer> }\r\n    ): void {\r\n        if (indexBuffer) {\r\n            this._engine.recordIndexBuffer(vertexArray, indexBuffer.nativeIndexBuffer!);\r\n        }\r\n\r\n        const attributes = effect.getAttributesNames();\r\n        for (let index = 0; index < attributes.length; index++) {\r\n            const location = effect.getAttributeLocation(index);\r\n            if (location >= 0) {\r\n                const kind = attributes[index];\r\n                let vertexBuffer: Nullable<VertexBuffer> = null;\r\n\r\n                if (overrideVertexBuffers) {\r\n                    vertexBuffer = overrideVertexBuffers[kind];\r\n                }\r\n                if (!vertexBuffer) {\r\n                    vertexBuffer = vertexBuffers[kind];\r\n                }\r\n\r\n                if (vertexBuffer) {\r\n                    const buffer = vertexBuffer.getBuffer() as Nullable<NativeDataBuffer>;\r\n                    if (buffer && buffer.nativeVertexBuffer) {\r\n                        this._engine.recordVertexBuffer(\r\n                            vertexArray,\r\n                            buffer.nativeVertexBuffer!,\r\n                            location,\r\n                            vertexBuffer.byteOffset,\r\n                            vertexBuffer.byteStride,\r\n                            vertexBuffer.getSize(),\r\n                            getNativeAttribType(vertexBuffer.type),\r\n                            vertexBuffer.normalized,\r\n                            vertexBuffer.getInstanceDivisor()\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public bindBuffers(vertexBuffers: { [key: string]: VertexBuffer }, indexBuffer: Nullable<NativeDataBuffer>, effect: Effect): void {\r\n        if (this._boundBuffersVertexArray) {\r\n            this._deleteVertexArray(this._boundBuffersVertexArray);\r\n        }\r\n        this._boundBuffersVertexArray = this._engine.createVertexArray();\r\n        this._recordVertexArrayObject(this._boundBuffersVertexArray, vertexBuffers, indexBuffer, effect);\r\n        this.bindVertexArrayObject(this._boundBuffersVertexArray);\r\n    }\r\n\r\n    public recordVertexArrayObject(\r\n        vertexBuffers: { [key: string]: VertexBuffer },\r\n        indexBuffer: Nullable<NativeDataBuffer>,\r\n        effect: Effect,\r\n        overrideVertexBuffers?: { [kind: string]: Nullable<VertexBuffer> }\r\n    ): WebGLVertexArrayObject {\r\n        const vertexArray = this._engine.createVertexArray();\r\n        this._recordVertexArrayObject(vertexArray, vertexBuffers, indexBuffer, effect, overrideVertexBuffers);\r\n        return vertexArray;\r\n    }\r\n\r\n    private _deleteVertexArray(vertexArray: NativeVertexArrayObject) {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEVERTEXARRAY);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(vertexArray);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    public bindVertexArrayObject(vertexArray: WebGLVertexArrayObject): void {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_BINDVERTEXARRAY);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(vertexArray as NativeVertexArrayObject);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    public releaseVertexArrayObject(vertexArray: WebGLVertexArrayObject) {\r\n        this._deleteVertexArray(vertexArray as NativeVertexArrayObject);\r\n    }\r\n\r\n    public getAttributes(pipelineContext: IPipelineContext, attributesNames: string[]): number[] {\r\n        const nativePipelineContext = pipelineContext as NativePipelineContext;\r\n        return this._engine.getAttributes(nativePipelineContext.nativeProgram, attributesNames);\r\n    }\r\n\r\n    /**\r\n     * Draw a list of indexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param indexStart defines the starting index\r\n     * @param indexCount defines the number of index to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public drawElementsType(fillMode: number, indexStart: number, indexCount: number, instancesCount?: number): void {\r\n        // Apply states\r\n        this._drawCalls.addCount(1, false);\r\n\r\n        if (instancesCount && _native.Engine.COMMAND_DRAWINDEXEDINSTANCED) {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAWINDEXEDINSTANCED);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(fillMode);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(indexStart);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(indexCount);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(instancesCount);\r\n        } else {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAWINDEXED);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(fillMode);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(indexStart);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(indexCount);\r\n        }\r\n\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        // }\r\n    }\r\n\r\n    /**\r\n     * Draw a list of unindexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param verticesStart defines the index of first vertex to draw\r\n     * @param verticesCount defines the count of vertices to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public drawArraysType(fillMode: number, verticesStart: number, verticesCount: number, instancesCount?: number): void {\r\n        // Apply states\r\n        this._drawCalls.addCount(1, false);\r\n\r\n        if (instancesCount && _native.Engine.COMMAND_DRAWINSTANCED) {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAWINSTANCED);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(fillMode);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(verticesStart);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(verticesCount);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(instancesCount);\r\n        } else {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAW);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(fillMode);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(verticesStart);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(verticesCount);\r\n        }\r\n\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        // }\r\n    }\r\n\r\n    public createPipelineContext(): IPipelineContext {\r\n        return new NativePipelineContext(this);\r\n    }\r\n\r\n    public createMaterialContext(): IMaterialContext | undefined {\r\n        return undefined;\r\n    }\r\n\r\n    public createDrawContext(): IDrawContext | undefined {\r\n        return undefined;\r\n    }\r\n\r\n    public _preparePipelineContext(\r\n        pipelineContext: IPipelineContext,\r\n        vertexSourceCode: string,\r\n        fragmentSourceCode: string,\r\n        createAsRaw: boolean,\r\n        _rawVertexSourceCode: string,\r\n        _rawFragmentSourceCode: string,\r\n        _rebuildRebind: any,\r\n        defines: Nullable<string>\r\n    ) {\r\n        const nativePipelineContext = pipelineContext as NativePipelineContext;\r\n\r\n        if (createAsRaw) {\r\n            nativePipelineContext.nativeProgram = this.createRawShaderProgram();\r\n        } else {\r\n            nativePipelineContext.nativeProgram = this.createShaderProgram(pipelineContext, vertexSourceCode, fragmentSourceCode, defines);\r\n        }\r\n    }\r\n\r\n    public isAsync(pipelineContext: IPipelineContext): boolean {\r\n        return !!(pipelineContext.isAsync && this._engine.createProgramAsync);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _executeWhenRenderingStateIsCompiled(pipelineContext: IPipelineContext, action: () => void) {\r\n        const nativePipelineContext = pipelineContext as NativePipelineContext;\r\n\r\n        if (!this.isAsync(pipelineContext)) {\r\n            action();\r\n            return;\r\n        }\r\n\r\n        const oldHandler = nativePipelineContext.onCompiled;\r\n\r\n        if (oldHandler) {\r\n            nativePipelineContext.onCompiled = () => {\r\n                oldHandler!();\r\n                action();\r\n            };\r\n        } else {\r\n            nativePipelineContext.onCompiled = action;\r\n        }\r\n    }\r\n\r\n    public createRawShaderProgram(): WebGLProgram {\r\n        throw new Error(\"Not Supported\");\r\n    }\r\n\r\n    public createShaderProgram(pipelineContext: IPipelineContext, vertexCode: string, fragmentCode: string, defines: Nullable<string>): WebGLProgram {\r\n        const nativePipelineContext = pipelineContext as NativePipelineContext;\r\n\r\n        if (nativePipelineContext.nativeProgram) {\r\n            throw new Error(\"Tried to create a second program in the same NativePipelineContext\");\r\n        }\r\n\r\n        this.onBeforeShaderCompilationObservable.notifyObservers(this);\r\n\r\n        const vertexInliner = new ShaderCodeInliner(vertexCode);\r\n        vertexInliner.processCode();\r\n        vertexCode = vertexInliner.code;\r\n\r\n        const fragmentInliner = new ShaderCodeInliner(fragmentCode);\r\n        fragmentInliner.processCode();\r\n        fragmentCode = fragmentInliner.code;\r\n\r\n        vertexCode = ThinEngine._ConcatenateShader(vertexCode, defines);\r\n        fragmentCode = ThinEngine._ConcatenateShader(fragmentCode, defines);\r\n\r\n        const onSuccess = () => {\r\n            nativePipelineContext.isCompiled = true;\r\n            nativePipelineContext.onCompiled?.();\r\n            this.onAfterShaderCompilationObservable.notifyObservers(this);\r\n        };\r\n\r\n        if (this.isAsync(pipelineContext)) {\r\n            return this._engine.createProgramAsync(vertexCode, fragmentCode, onSuccess, (error: Error) => {\r\n                nativePipelineContext.compilationError = error;\r\n            }) as WebGLProgram;\r\n        } else {\r\n            try {\r\n                const program = (nativePipelineContext.nativeProgram = this._engine.createProgram(vertexCode, fragmentCode));\r\n                onSuccess();\r\n                return program as WebGLProgram;\r\n            } catch (e: any) {\r\n                const message = e?.message;\r\n                throw new Error(\"SHADER ERROR\" + (typeof message === \"string\" ? \"\\n\" + message : \"\"));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Inline functions in shader code that are marked to be inlined\r\n     * @param code code to inline\r\n     * @returns inlined code\r\n     */\r\n    public inlineShaderCode(code: string): string {\r\n        const sci = new ShaderCodeInliner(code);\r\n        sci.debug = false;\r\n        sci.processCode();\r\n        return sci.code;\r\n    }\r\n\r\n    protected _setProgram(program: WebGLProgram): void {\r\n        if (this._currentProgram !== program) {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETPROGRAM);\r\n            this._commandBufferEncoder.encodeCommandArgAsNativeData(program as NativeProgram);\r\n            this._commandBufferEncoder.finishEncodingCommand();\r\n            this._currentProgram = program;\r\n        }\r\n    }\r\n\r\n    public _deletePipelineContext(pipelineContext: IPipelineContext): void {\r\n        const nativePipelineContext = pipelineContext as NativePipelineContext;\r\n        if (nativePipelineContext && nativePipelineContext.nativeProgram) {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEPROGRAM);\r\n            this._commandBufferEncoder.encodeCommandArgAsNativeData(nativePipelineContext.nativeProgram);\r\n            this._commandBufferEncoder.finishEncodingCommand();\r\n        }\r\n    }\r\n\r\n    public getUniforms(pipelineContext: IPipelineContext, uniformsNames: string[]): WebGLUniformLocation[] {\r\n        const nativePipelineContext = pipelineContext as NativePipelineContext;\r\n        return this._engine.getUniforms(nativePipelineContext.nativeProgram, uniformsNames);\r\n    }\r\n\r\n    public bindUniformBlock(pipelineContext: IPipelineContext, blockName: string, index: number): void {\r\n        // TODO\r\n        throw new Error(\"Not Implemented\");\r\n    }\r\n\r\n    public bindSamplers(effect: Effect): void {\r\n        const nativePipelineContext = effect.getPipelineContext() as NativePipelineContext;\r\n        this._setProgram(nativePipelineContext.nativeProgram);\r\n\r\n        // TODO: share this with engine?\r\n        const samplers = effect.getSamplers();\r\n        for (let index = 0; index < samplers.length; index++) {\r\n            const uniform = effect.getUniform(samplers[index]);\r\n\r\n            if (uniform) {\r\n                this._boundUniforms[index] = uniform;\r\n            }\r\n        }\r\n        this._currentEffect = null;\r\n    }\r\n\r\n    public getRenderWidth(useScreen = false): number {\r\n        if (!useScreen && this._currentRenderTarget) {\r\n            return this._currentRenderTarget.width;\r\n        }\r\n\r\n        return this._engine.getRenderWidth();\r\n    }\r\n\r\n    public getRenderHeight(useScreen = false): number {\r\n        if (!useScreen && this._currentRenderTarget) {\r\n            return this._currentRenderTarget.height;\r\n        }\r\n\r\n        return this._engine.getRenderHeight();\r\n    }\r\n\r\n    public setViewport(viewport: IViewportLike, requiredWidth?: number, requiredHeight?: number): void {\r\n        this._cachedViewport = viewport;\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETVIEWPORT);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(viewport.x);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(viewport.y);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(viewport.width);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(viewport.height);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    public enableScissor(x: number, y: number, width: number, height: number): void {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSCISSOR);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(x);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(y);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(width);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(height);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    public disableScissor() {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSCISSOR);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(0);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(0);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(0);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(0);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    public setState(culling: boolean, zOffset: number = 0, force?: boolean, reverseSide = false, cullBackFaces?: boolean, stencil?: IStencilState, zOffsetUnits: number = 0): void {\r\n        this._zOffset = zOffset;\r\n        this._zOffsetUnits = zOffsetUnits;\r\n        if (this._zOffset !== 0) {\r\n            Tools.Warn(\"zOffset is not supported in Native engine.\");\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSTATE);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(culling ? 1 : 0);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(zOffset);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(zOffsetUnits);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(this.cullBackFaces ?? cullBackFaces ?? true ? 1 : 0);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(reverseSide ? 1 : 0);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    /**\r\n     * Gets the client rect of native canvas.  Needed for InputManager.\r\n     * @returns a client rectangle\r\n     */\r\n    public getInputElementClientRect(): Nullable<DOMRect> {\r\n        const rect = {\r\n            bottom: this.getRenderHeight(),\r\n            height: this.getRenderHeight(),\r\n            left: 0,\r\n            right: this.getRenderWidth(),\r\n            top: 0,\r\n            width: this.getRenderWidth(),\r\n            x: 0,\r\n            y: 0,\r\n            toJSON: () => {},\r\n        };\r\n        return rect;\r\n    }\r\n\r\n    /**\r\n     * Set the z offset Factor to apply to current rendering\r\n     * @param value defines the offset to apply\r\n     */\r\n    public setZOffset(value: number): void {\r\n        if (value !== this._zOffset) {\r\n            this._zOffset = value;\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETZOFFSET);\r\n            this._commandBufferEncoder.encodeCommandArgAsFloat32(this.useReverseDepthBuffer ? -value : value);\r\n            this._commandBufferEncoder.finishEncodingCommand();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current value of the zOffset Factor\r\n     * @returns the current zOffset Factor state\r\n     */\r\n    public getZOffset(): number {\r\n        return this._zOffset;\r\n    }\r\n\r\n    /**\r\n     * Set the z offset Units to apply to current rendering\r\n     * @param value defines the offset to apply\r\n     */\r\n    public setZOffsetUnits(value: number): void {\r\n        if (value !== this._zOffsetUnits) {\r\n            this._zOffsetUnits = value;\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETZOFFSETUNITS);\r\n            this._commandBufferEncoder.encodeCommandArgAsFloat32(this.useReverseDepthBuffer ? -value : value);\r\n            this._commandBufferEncoder.finishEncodingCommand();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current value of the zOffset Units\r\n     * @returns the current zOffset Units state\r\n     */\r\n    public getZOffsetUnits(): number {\r\n        return this._zOffsetUnits;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable depth buffering\r\n     * @param enable defines the state to set\r\n     */\r\n    public setDepthBuffer(enable: boolean): void {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETDEPTHTEST);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(enable ? this._currentDepthTest : _native.Engine.DEPTH_TEST_ALWAYS);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if depth writing is enabled\r\n     * @returns the current depth writing state\r\n     */\r\n    public getDepthWrite(): boolean {\r\n        return this._depthWrite;\r\n    }\r\n\r\n    public getDepthFunction(): Nullable<number> {\r\n        switch (this._currentDepthTest) {\r\n            case _native.Engine.DEPTH_TEST_NEVER:\r\n                return Constants.NEVER;\r\n            case _native.Engine.DEPTH_TEST_ALWAYS:\r\n                return Constants.ALWAYS;\r\n            case _native.Engine.DEPTH_TEST_GREATER:\r\n                return Constants.GREATER;\r\n            case _native.Engine.DEPTH_TEST_GEQUAL:\r\n                return Constants.GEQUAL;\r\n            case _native.Engine.DEPTH_TEST_NOTEQUAL:\r\n                return Constants.NOTEQUAL;\r\n            case _native.Engine.DEPTH_TEST_EQUAL:\r\n                return Constants.EQUAL;\r\n            case _native.Engine.DEPTH_TEST_LESS:\r\n                return Constants.LESS;\r\n            case _native.Engine.DEPTH_TEST_LEQUAL:\r\n                return Constants.LEQUAL;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public setDepthFunction(depthFunc: number) {\r\n        let nativeDepthFunc = 0;\r\n        switch (depthFunc) {\r\n            case Constants.NEVER:\r\n                nativeDepthFunc = _native.Engine.DEPTH_TEST_NEVER;\r\n                break;\r\n            case Constants.ALWAYS:\r\n                nativeDepthFunc = _native.Engine.DEPTH_TEST_ALWAYS;\r\n                break;\r\n            case Constants.GREATER:\r\n                nativeDepthFunc = _native.Engine.DEPTH_TEST_GREATER;\r\n                break;\r\n            case Constants.GEQUAL:\r\n                nativeDepthFunc = _native.Engine.DEPTH_TEST_GEQUAL;\r\n                break;\r\n            case Constants.NOTEQUAL:\r\n                nativeDepthFunc = _native.Engine.DEPTH_TEST_NOTEQUAL;\r\n                break;\r\n            case Constants.EQUAL:\r\n                nativeDepthFunc = _native.Engine.DEPTH_TEST_EQUAL;\r\n                break;\r\n            case Constants.LESS:\r\n                nativeDepthFunc = _native.Engine.DEPTH_TEST_LESS;\r\n                break;\r\n            case Constants.LEQUAL:\r\n                nativeDepthFunc = _native.Engine.DEPTH_TEST_LEQUAL;\r\n                break;\r\n        }\r\n\r\n        this._currentDepthTest = nativeDepthFunc;\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETDEPTHTEST);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(this._currentDepthTest);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    /**\r\n     * Enable or disable depth writing\r\n     * @param enable defines the state to set\r\n     */\r\n    public setDepthWrite(enable: boolean): void {\r\n        this._depthWrite = enable;\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETDEPTHWRITE);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(Number(enable));\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    /**\r\n     * Enable or disable color writing\r\n     * @param enable defines the state to set\r\n     */\r\n    public setColorWrite(enable: boolean): void {\r\n        this._colorWrite = enable;\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETCOLORWRITE);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(Number(enable));\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if color writing is enabled\r\n     * @returns the current color writing state\r\n     */\r\n    public getColorWrite(): boolean {\r\n        return this._colorWrite;\r\n    }\r\n\r\n    private applyStencil(): void {\r\n        this._setStencil(\r\n            this._stencilMask,\r\n            getNativeStencilOpFail(this._stencilOpStencilFail),\r\n            getNativeStencilDepthFail(this._stencilOpDepthFail),\r\n            getNativeStencilDepthPass(this._stencilOpStencilDepthPass),\r\n            getNativeStencilFunc(this._stencilFunc),\r\n            this._stencilFuncRef\r\n        );\r\n    }\r\n\r\n    private _setStencil(mask: number, stencilOpFail: number, depthOpFail: number, depthOpPass: number, func: number, ref: number) {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSTENCIL);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(mask);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(stencilOpFail);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(depthOpFail);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(depthOpPass);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(func);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(ref);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    /**\r\n     * Enable or disable the stencil buffer\r\n     * @param enable defines if the stencil buffer must be enabled or disabled\r\n     */\r\n    public setStencilBuffer(enable: boolean): void {\r\n        this._stencilTest = enable;\r\n        if (enable) {\r\n            this.applyStencil();\r\n        } else {\r\n            this._setStencil(\r\n                255,\r\n                _native.Engine.STENCIL_OP_FAIL_S_KEEP,\r\n                _native.Engine.STENCIL_OP_FAIL_Z_KEEP,\r\n                _native.Engine.STENCIL_OP_PASS_Z_KEEP,\r\n                _native.Engine.STENCIL_TEST_ALWAYS,\r\n                0\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if stencil buffer is enabled\r\n     * @returns the current stencil buffer state\r\n     */\r\n    public getStencilBuffer(): boolean {\r\n        return this._stencilTest;\r\n    }\r\n\r\n    /**\r\n     * Gets the current stencil operation when stencil passes\r\n     * @returns a number defining stencil operation to use when stencil passes\r\n     */\r\n    public getStencilOperationPass(): number {\r\n        return this._stencilOpStencilDepthPass;\r\n    }\r\n\r\n    /**\r\n     * Sets the stencil operation to use when stencil passes\r\n     * @param operation defines the stencil operation to use when stencil passes\r\n     */\r\n    public setStencilOperationPass(operation: number): void {\r\n        this._stencilOpStencilDepthPass = operation;\r\n        this.applyStencil();\r\n    }\r\n\r\n    /**\r\n     * Sets the current stencil mask\r\n     * @param mask defines the new stencil mask to use\r\n     */\r\n    public setStencilMask(mask: number): void {\r\n        this._stencilMask = mask;\r\n        this.applyStencil();\r\n    }\r\n\r\n    /**\r\n     * Sets the current stencil function\r\n     * @param stencilFunc defines the new stencil function to use\r\n     */\r\n    public setStencilFunction(stencilFunc: number) {\r\n        this._stencilFunc = stencilFunc;\r\n        this.applyStencil();\r\n    }\r\n\r\n    /**\r\n     * Sets the current stencil reference\r\n     * @param reference defines the new stencil reference to use\r\n     */\r\n    public setStencilFunctionReference(reference: number) {\r\n        this._stencilFuncRef = reference;\r\n        this.applyStencil();\r\n    }\r\n\r\n    /**\r\n     * Sets the current stencil mask\r\n     * @param mask defines the new stencil mask to use\r\n     */\r\n    public setStencilFunctionMask(mask: number) {\r\n        this._stencilFuncMask = mask;\r\n    }\r\n\r\n    /**\r\n     * Sets the stencil operation to use when stencil fails\r\n     * @param operation defines the stencil operation to use when stencil fails\r\n     */\r\n    public setStencilOperationFail(operation: number): void {\r\n        this._stencilOpStencilFail = operation;\r\n        this.applyStencil();\r\n    }\r\n\r\n    /**\r\n     * Sets the stencil operation to use when depth fails\r\n     * @param operation defines the stencil operation to use when depth fails\r\n     */\r\n    public setStencilOperationDepthFail(operation: number): void {\r\n        this._stencilOpDepthFail = operation;\r\n        this.applyStencil();\r\n    }\r\n\r\n    /**\r\n     * Gets the current stencil mask\r\n     * @returns a number defining the new stencil mask to use\r\n     */\r\n    public getStencilMask(): number {\r\n        return this._stencilMask;\r\n    }\r\n\r\n    /**\r\n     * Gets the current stencil function\r\n     * @returns a number defining the stencil function to use\r\n     */\r\n    public getStencilFunction(): number {\r\n        return this._stencilFunc;\r\n    }\r\n\r\n    /**\r\n     * Gets the current stencil reference value\r\n     * @returns a number defining the stencil reference value to use\r\n     */\r\n    public getStencilFunctionReference(): number {\r\n        return this._stencilFuncRef;\r\n    }\r\n\r\n    /**\r\n     * Gets the current stencil mask\r\n     * @returns a number defining the stencil mask to use\r\n     */\r\n    public getStencilFunctionMask(): number {\r\n        return this._stencilFuncMask;\r\n    }\r\n\r\n    /**\r\n     * Gets the current stencil operation when stencil fails\r\n     * @returns a number defining stencil operation to use when stencil fails\r\n     */\r\n    public getStencilOperationFail(): number {\r\n        return this._stencilOpStencilFail;\r\n    }\r\n\r\n    /**\r\n     * Gets the current stencil operation when depth fails\r\n     * @returns a number defining stencil operation to use when depth fails\r\n     */\r\n    public getStencilOperationDepthFail(): number {\r\n        return this._stencilOpDepthFail;\r\n    }\r\n\r\n    /**\r\n     * Sets alpha constants used by some alpha blending modes\r\n     * @param r defines the red component\r\n     * @param g defines the green component\r\n     * @param b defines the blue component\r\n     * @param a defines the alpha component\r\n     */\r\n    public setAlphaConstants(r: number, g: number, b: number, a: number) {\r\n        throw new Error(\"Setting alpha blend constant color not yet implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Sets the current alpha mode\r\n     * @param mode defines the mode to use (one of the BABYLON.Constants.ALPHA_XXX)\r\n     * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering\r\n     */\r\n    public setAlphaMode(mode: number, noDepthWriteChange: boolean = false): void {\r\n        if (this._alphaMode === mode) {\r\n            return;\r\n        }\r\n\r\n        const nativeMode = getNativeAlphaMode(mode);\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETBLENDMODE);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(nativeMode);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n\r\n        if (!noDepthWriteChange) {\r\n            this.setDepthWrite(mode === Constants.ALPHA_DISABLE);\r\n        }\r\n\r\n        this._alphaMode = mode;\r\n    }\r\n\r\n    /**\r\n     * Gets the current alpha mode\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering\r\n     * @returns the current alpha mode\r\n     */\r\n    public getAlphaMode(): number {\r\n        return this._alphaMode;\r\n    }\r\n\r\n    public setInt(uniform: WebGLUniformLocation, int: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINT);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsInt32(int);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setIntArray(uniform: WebGLUniformLocation, array: Int32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsInt32s(array);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setIntArray2(uniform: WebGLUniformLocation, array: Int32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY2);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsInt32s(array);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setIntArray3(uniform: WebGLUniformLocation, array: Int32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY3);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsInt32s(array);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setIntArray4(uniform: WebGLUniformLocation, array: Int32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY4);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsInt32s(array);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setFloatArray(uniform: WebGLUniformLocation, array: Float32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setFloatArray2(uniform: WebGLUniformLocation, array: Float32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY2);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setFloatArray3(uniform: WebGLUniformLocation, array: Float32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY3);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setFloatArray4(uniform: WebGLUniformLocation, array: Float32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY4);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setArray(uniform: WebGLUniformLocation, array: number[]): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        return this.setFloatArray(uniform, new Float32Array(array));\r\n    }\r\n\r\n    public setArray2(uniform: WebGLUniformLocation, array: number[]): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        return this.setFloatArray2(uniform, new Float32Array(array));\r\n    }\r\n\r\n    public setArray3(uniform: WebGLUniformLocation, array: number[]): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        return this.setFloatArray3(uniform, new Float32Array(array));\r\n    }\r\n\r\n    public setArray4(uniform: WebGLUniformLocation, array: number[]): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        return this.setFloatArray4(uniform, new Float32Array(array));\r\n    }\r\n\r\n    public setMatrices(uniform: WebGLUniformLocation, matrices: Float32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETMATRICES);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32s(matrices);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n\r\n        return true;\r\n    }\r\n\r\n    public setMatrix3x3(uniform: WebGLUniformLocation, matrix: Float32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETMATRIX3X3);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32s(matrix);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setMatrix2x2(uniform: WebGLUniformLocation, matrix: Float32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETMATRIX2X2);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32s(matrix);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setFloat(uniform: WebGLUniformLocation, value: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(value);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setFloat2(uniform: WebGLUniformLocation, x: number, y: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT2);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(x);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(y);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setFloat3(uniform: WebGLUniformLocation, x: number, y: number, z: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT3);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(x);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(y);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(z);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setFloat4(uniform: WebGLUniformLocation, x: number, y: number, z: number, w: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT4);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(x);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(y);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(z);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(w);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setColor3(uniform: WebGLUniformLocation, color3: IColor3Like): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this.setFloat3(uniform, color3.r, color3.g, color3.b);\r\n        return true;\r\n    }\r\n\r\n    public setColor4(uniform: WebGLUniformLocation, color3: IColor3Like, alpha: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this.setFloat4(uniform, color3.r, color3.g, color3.b, alpha);\r\n        return true;\r\n    }\r\n\r\n    public wipeCaches(bruteForce?: boolean): void {\r\n        if (this.preventCacheWipeBetweenFrames) {\r\n            return;\r\n        }\r\n        this.resetTextureCache();\r\n        this._currentEffect = null;\r\n\r\n        if (bruteForce) {\r\n            this._currentProgram = null;\r\n\r\n            this._stencilStateComposer.reset();\r\n            this._depthCullingState.reset();\r\n            this._alphaState.reset();\r\n        }\r\n\r\n        this._cachedVertexBuffers = null;\r\n        this._cachedIndexBuffer = null;\r\n        this._cachedEffectForVertexBuffers = null;\r\n    }\r\n\r\n    protected _createTexture(): WebGLTexture {\r\n        return this._engine.createTexture();\r\n    }\r\n\r\n    protected _deleteTexture(texture: Nullable<WebGLTexture>): void {\r\n        if (texture) {\r\n            this._engine.deleteTexture(texture as NativeTexture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the content of a dynamic texture\r\n     * @param texture defines the texture to update\r\n     * @param canvas defines the canvas containing the source\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param premulAlpha defines if alpha is stored as premultiplied\r\n     * @param format defines the format of the data\r\n     */\r\n    public updateDynamicTexture(texture: Nullable<InternalTexture>, canvas: any, invertY: boolean, premulAlpha: boolean = false, format?: number): void {\r\n        if (premulAlpha === void 0) {\r\n            premulAlpha = false;\r\n        }\r\n\r\n        if (!!texture && !!texture._hardwareTexture) {\r\n            const source = canvas.getCanvasTexture();\r\n            const destination = texture._hardwareTexture.underlyingResource;\r\n            this._engine.copyTexture(destination, source);\r\n            texture.isReady = true;\r\n        }\r\n    }\r\n\r\n    public createDynamicTexture(width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture {\r\n        // it's not possible to create 0x0 texture sized. Many bgfx methods assume texture size is at least 1x1(best case).\r\n        // Worst case is getting a crash/assert.\r\n        width = Math.max(width, 1);\r\n        height = Math.max(height, 1);\r\n        return this.createRawTexture(new Uint8Array(width * height * 4), width, height, Constants.TEXTUREFORMAT_RGBA, false, false, samplingMode);\r\n    }\r\n\r\n    public createVideoElement(constraints: MediaTrackConstraints): any {\r\n        // create native object depending on stream. Only NativeCamera is supported for now.\r\n        if (this._camera) {\r\n            return this._camera.createVideo(constraints);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public updateVideoTexture(texture: Nullable<InternalTexture>, video: HTMLVideoElement, invertY: boolean): void {\r\n        if (texture && texture._hardwareTexture && this._camera) {\r\n            const webGLTexture = texture._hardwareTexture.underlyingResource;\r\n            this._camera.updateVideoTexture(webGLTexture, video, invertY);\r\n        }\r\n    }\r\n\r\n    public createRawTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        format: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression: Nullable<string> = null,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        creationFlags: number = 0,\r\n        useSRGBBuffer: boolean = false\r\n    ): InternalTexture {\r\n        const texture = new InternalTexture(this, InternalTextureSource.Raw);\r\n\r\n        texture.format = format;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        texture.invertY = invertY;\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = texture.baseWidth;\r\n        texture.height = texture.baseHeight;\r\n        texture._compression = compression;\r\n        texture.type = type;\r\n        texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !generateMipMaps);\r\n\r\n        this.updateRawTexture(texture, data, format, invertY, compression, type, texture._useSRGBBuffer);\r\n\r\n        if (texture._hardwareTexture) {\r\n            const webGLTexture = texture._hardwareTexture.underlyingResource;\r\n            const filter = getNativeSamplingMode(samplingMode);\r\n            this._setTextureSampling(webGLTexture, filter);\r\n        }\r\n\r\n        this._internalTexturesCache.push(texture);\r\n        return texture;\r\n    }\r\n\r\n    public createRawTexture2DArray(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        format: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression: Nullable<string> = null,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ): InternalTexture {\r\n        const texture = new InternalTexture(this, InternalTextureSource.Raw2DArray);\r\n\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.baseDepth = depth;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.depth = depth;\r\n        texture.format = format;\r\n        texture.type = textureType;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        texture.is2DArray = true;\r\n\r\n        if (texture._hardwareTexture) {\r\n            const nativeTexture = texture._hardwareTexture.underlyingResource;\r\n            this._engine.loadRawTexture2DArray(nativeTexture, data, width, height, depth, getNativeTextureFormat(format, textureType), generateMipMaps, invertY);\r\n\r\n            const filter = getNativeSamplingMode(samplingMode);\r\n            this._setTextureSampling(nativeTexture, filter);\r\n        }\r\n\r\n        texture.isReady = true;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n        return texture;\r\n    }\r\n\r\n    public updateRawTexture(\r\n        texture: Nullable<InternalTexture>,\r\n        bufferView: Nullable<ArrayBufferView>,\r\n        format: number,\r\n        invertY: boolean,\r\n        compression: Nullable<string> = null,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        useSRGBBuffer: boolean = false\r\n    ): void {\r\n        if (!texture) {\r\n            return;\r\n        }\r\n\r\n        if (bufferView && texture._hardwareTexture) {\r\n            const underlyingResource = texture._hardwareTexture.underlyingResource;\r\n            this._engine.loadRawTexture(\r\n                underlyingResource,\r\n                bufferView,\r\n                texture.width,\r\n                texture.height,\r\n                getNativeTextureFormat(format, type),\r\n                texture.generateMipMaps,\r\n                texture.invertY\r\n            );\r\n        }\r\n\r\n        texture.isReady = true;\r\n    }\r\n\r\n    // TODO: Refactor to share more logic with babylon.engine.ts version.\r\n    /**\r\n     * Usually called from Texture.ts.\r\n     * Passed information to create a NativeTexture\r\n     * @param url defines a value which contains one of the following:\r\n     * * A conventional http URL, e.g. 'http://...' or 'file://...'\r\n     * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\r\n     * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\r\n     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\r\n     * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\r\n     * @param scene needed for loading to the correct scene\r\n     * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param onLoad optional callback to be called upon successful completion\r\n     * @param onError optional callback to be called upon failure\r\n     * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\r\n     * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\r\n     * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @param mimeType defines an optional mime type\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns a InternalTexture for assignment back into BABYLON.Texture\r\n     */\r\n    public createTexture(\r\n        url: Nullable<string>,\r\n        noMipmap: boolean,\r\n        invertY: boolean,\r\n        scene: Nullable<ISceneLike>,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<(texture: InternalTexture) => void> = null,\r\n        onError: Nullable<(message: string, exception: any) => void> = null,\r\n        buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null,\r\n        fallback: Nullable<InternalTexture> = null,\r\n        format: Nullable<number> = null,\r\n        forcedExtension: Nullable<string> = null,\r\n        mimeType?: string,\r\n        loaderOptions?: any,\r\n        creationFlags?: number,\r\n        useSRGBBuffer = false\r\n    ): InternalTexture {\r\n        url = url || \"\";\r\n        const fromData = url.substr(0, 5) === \"data:\";\r\n        //const fromBlob = url.substr(0, 5) === \"blob:\";\r\n        const isBase64 = fromData && url.indexOf(\";base64,\") !== -1;\r\n\r\n        const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Url);\r\n\r\n        const originalUrl = url;\r\n        if (this._transformTextureUrl && !isBase64 && !fallback && !buffer) {\r\n            url = this._transformTextureUrl(url);\r\n        }\r\n\r\n        // establish the file extension, if possible\r\n        const lastDot = url.lastIndexOf(\".\");\r\n        const extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : \"\";\r\n\r\n        let loader: Nullable<IInternalTextureLoader> = null;\r\n        for (const availableLoader of Engine._TextureLoaders) {\r\n            if (availableLoader.canLoad(extension)) {\r\n                loader = availableLoader;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (scene) {\r\n            scene.addPendingData(texture);\r\n        }\r\n        texture.url = url;\r\n        texture.generateMipMaps = !noMipmap;\r\n        texture.samplingMode = samplingMode;\r\n        texture.invertY = invertY;\r\n        texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, noMipmap);\r\n\r\n        if (!this.doNotHandleContextLost) {\r\n            // Keep a link to the buffer only if we plan to handle context lost\r\n            texture._buffer = buffer;\r\n        }\r\n\r\n        let onLoadObserver: Nullable<Observer<InternalTexture>> = null;\r\n        if (onLoad && !fallback) {\r\n            onLoadObserver = texture.onLoadedObservable.add(onLoad);\r\n        }\r\n\r\n        if (!fallback) {\r\n            this._internalTexturesCache.push(texture);\r\n        }\r\n\r\n        const onInternalError = (message?: string, exception?: any) => {\r\n            if (scene) {\r\n                scene.removePendingData(texture);\r\n            }\r\n\r\n            if (url === originalUrl) {\r\n                if (onLoadObserver) {\r\n                    texture.onLoadedObservable.remove(onLoadObserver);\r\n                }\r\n\r\n                if (EngineStore.UseFallbackTexture) {\r\n                    this.createTexture(EngineStore.FallbackTexture, noMipmap, texture.invertY, scene, samplingMode, null, onError, buffer, texture);\r\n                }\r\n\r\n                if (onError) {\r\n                    onError((message || \"Unknown error\") + (EngineStore.UseFallbackTexture ? \" - Fallback texture was used\" : \"\"), exception);\r\n                }\r\n            } else {\r\n                // fall back to the original url if the transformed url fails to load\r\n                Logger.Warn(`Failed to load ${url}, falling back to ${originalUrl}`);\r\n                this.createTexture(originalUrl, noMipmap, texture.invertY, scene, samplingMode, onLoad, onError, buffer, texture, format, forcedExtension, mimeType, loaderOptions);\r\n            }\r\n        };\r\n\r\n        // processing for non-image formats\r\n        if (loader) {\r\n            throw new Error(\"Loading textures from IInternalTextureLoader not yet implemented.\");\r\n        } else {\r\n            const onload = (data: ArrayBufferView) => {\r\n                if (!texture._hardwareTexture) {\r\n                    if (scene) {\r\n                        scene.removePendingData(texture);\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n                const underlyingResource = texture._hardwareTexture.underlyingResource;\r\n\r\n                this._engine.loadTexture(\r\n                    underlyingResource,\r\n                    data,\r\n                    !noMipmap,\r\n                    invertY,\r\n                    texture._useSRGBBuffer,\r\n                    () => {\r\n                        texture.baseWidth = this._engine.getTextureWidth(underlyingResource);\r\n                        texture.baseHeight = this._engine.getTextureHeight(underlyingResource);\r\n                        texture.width = texture.baseWidth;\r\n                        texture.height = texture.baseHeight;\r\n                        texture.isReady = true;\r\n\r\n                        const filter = getNativeSamplingMode(samplingMode);\r\n                        this._setTextureSampling(underlyingResource, filter);\r\n\r\n                        if (scene) {\r\n                            scene.removePendingData(texture);\r\n                        }\r\n\r\n                        texture.onLoadedObservable.notifyObservers(texture);\r\n                        texture.onLoadedObservable.clear();\r\n                    },\r\n                    () => {\r\n                        throw new Error(\"Could not load a native texture.\");\r\n                    }\r\n                );\r\n            };\r\n\r\n            if (fromData && buffer) {\r\n                if (buffer instanceof ArrayBuffer) {\r\n                    onload(new Uint8Array(buffer));\r\n                } else if (ArrayBuffer.isView(buffer)) {\r\n                    onload(buffer);\r\n                } else if (typeof buffer === \"string\") {\r\n                    onload(new Uint8Array(Tools.DecodeBase64(buffer)));\r\n                } else {\r\n                    throw new Error(\"Unsupported buffer type\");\r\n                }\r\n            } else {\r\n                if (isBase64) {\r\n                    onload(new Uint8Array(Tools.DecodeBase64(url)));\r\n                } else {\r\n                    this._loadFile(\r\n                        url,\r\n                        (data) => onload(new Uint8Array(data as ArrayBuffer)),\r\n                        undefined,\r\n                        undefined,\r\n                        true,\r\n                        (request?: IWebRequest, exception?: any) => {\r\n                            onInternalError(\"Unable to load \" + (request ? request.responseURL : url, exception));\r\n                        }\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Wraps an external native texture in a Babylon texture.\r\n     * @param texture defines the external texture\r\n     * @param hasMipMaps defines whether the external texture has mip maps\r\n     * @param samplingMode defines the sampling mode for the external texture (default: Constants.TEXTURE_TRILINEAR_SAMPLINGMODE)\r\n     * @returns the babylon internal texture\r\n     */\r\n    public wrapNativeTexture(texture: NativeTexture, hasMipMaps: boolean = false, samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE): InternalTexture {\r\n        const hardwareTexture = new NativeHardwareTexture(texture, this._engine);\r\n        const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);\r\n        internalTexture._hardwareTexture = hardwareTexture;\r\n        internalTexture.baseWidth = this._engine.getTextureWidth(texture);\r\n        internalTexture.baseHeight = this._engine.getTextureHeight(texture);\r\n        internalTexture.width = internalTexture.baseWidth;\r\n        internalTexture.height = internalTexture.baseHeight;\r\n        internalTexture.isReady = true;\r\n        internalTexture.useMipMaps = hasMipMaps;\r\n        this.updateTextureSamplingMode(samplingMode, internalTexture);\r\n        return internalTexture;\r\n    }\r\n\r\n    /**\r\n     * Wraps an external web gl texture in a Babylon texture.\r\n     * @returns the babylon internal texture\r\n     */\r\n    public wrapWebGLTexture(): InternalTexture {\r\n        throw new Error(\"wrapWebGLTexture is not supported, use wrapNativeTexture instead.\");\r\n    }\r\n\r\n    public _createDepthStencilTexture(size: TextureSize, options: DepthTextureCreationOptions, rtWrapper: RenderTargetWrapper): InternalTexture {\r\n        // TODO: handle other options?\r\n        const generateStencil = options.generateStencil || false;\r\n        const samples = options.samples || 1;\r\n\r\n        const nativeRTWrapper = rtWrapper as NativeRenderTargetWrapper;\r\n        const texture = new InternalTexture(this, InternalTextureSource.DepthStencil);\r\n\r\n        const width = (<{ width: number; height: number; layers?: number }>size).width ?? <number>size;\r\n        const height = (<{ width: number; height: number; layers?: number }>size).height ?? <number>size;\r\n\r\n        const framebuffer = this._engine.createFrameBuffer(texture._hardwareTexture!.underlyingResource, width, height, generateStencil, true, samples);\r\n        nativeRTWrapper._framebufferDepthStencil = framebuffer;\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _releaseFramebufferObjects(framebuffer: Nullable<NativeFramebuffer>): void {\r\n        if (framebuffer) {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEFRAMEBUFFER);\r\n            this._commandBufferEncoder.encodeCommandArgAsNativeData(framebuffer as NativeData);\r\n            this._commandBufferEncoder.finishEncodingCommand();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal Engine abstraction for loading and creating an image bitmap from a given source string.\r\n     * @param imageSource source to load the image from.\r\n     * @param options An object that sets options for the image's extraction.\r\n     * @returns ImageBitmap\r\n     */\r\n    public _createImageBitmapFromSource(imageSource: string, options?: ImageBitmapOptions): Promise<ImageBitmap> {\r\n        const promise = new Promise<ImageBitmap>((resolve, reject) => {\r\n            const image = this.createCanvasImage();\r\n            image.onload = () => {\r\n                try {\r\n                    const imageBitmap = this._engine.createImageBitmap(image);\r\n                    resolve(imageBitmap);\r\n                } catch (error) {\r\n                    reject(`Error loading image ${image.src} with exception: ${error}`);\r\n                }\r\n            };\r\n            image.onerror = (error) => {\r\n                reject(`Error loading image ${image.src} with exception: ${error}`);\r\n            };\r\n\r\n            image.src = imageSource;\r\n        });\r\n\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * Engine abstraction for createImageBitmap\r\n     * @param image source for image\r\n     * @param options An object that sets options for the image's extraction.\r\n     * @returns ImageBitmap\r\n     */\r\n    public createImageBitmap(image: ImageBitmapSource, options?: ImageBitmapOptions): Promise<ImageBitmap> {\r\n        return new Promise((resolve, reject) => {\r\n            if (Array.isArray(image)) {\r\n                const arr = <Array<ArrayBufferView>>image;\r\n                if (arr.length) {\r\n                    const image = this._engine.createImageBitmap(arr[0]);\r\n                    if (image) {\r\n                        resolve(image);\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            reject(`Unsupported data for createImageBitmap.`);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Resize an image and returns the image data as an uint8array\r\n     * @param image image to resize\r\n     * @param bufferWidth destination buffer width\r\n     * @param bufferHeight destination buffer height\r\n     * @returns an uint8array containing RGBA values of bufferWidth * bufferHeight size\r\n     */\r\n    public resizeImageBitmap(image: ImageBitmap, bufferWidth: number, bufferHeight: number): Uint8Array {\r\n        return this._engine.resizeImageBitmap(image, bufferWidth, bufferHeight);\r\n    }\r\n\r\n    /**\r\n     * Creates a cube texture\r\n     * @param rootUrl defines the url where the files to load is located\r\n     * @param scene defines the current scene\r\n     * @param files defines the list of files to load (1 per face)\r\n     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n     * @param onLoad defines an optional callback raised when the texture is loaded\r\n     * @param onError defines an optional callback raised if there is an issue to load the texture\r\n     * @param format defines the format of the data\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n     * @param fallback defines texture to use while falling back when (compressed) texture file not found.\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the cube texture as an InternalTexture\r\n     */\r\n    public createCubeTexture(\r\n        rootUrl: string,\r\n        scene: Nullable<Scene>,\r\n        files: Nullable<string[]>,\r\n        noMipmap?: boolean,\r\n        onLoad: Nullable<(data?: any) => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        format?: number,\r\n        forcedExtension: any = null,\r\n        createPolynomials = false,\r\n        lodScale: number = 0,\r\n        lodOffset: number = 0,\r\n        fallback: Nullable<InternalTexture> = null,\r\n        loaderOptions?: any,\r\n        useSRGBBuffer = false\r\n    ): InternalTexture {\r\n        const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);\r\n        texture.isCube = true;\r\n        texture.url = rootUrl;\r\n        texture.generateMipMaps = !noMipmap;\r\n        texture._lodGenerationScale = lodScale;\r\n        texture._lodGenerationOffset = lodOffset;\r\n        texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !!noMipmap);\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            texture._extension = forcedExtension;\r\n            texture._files = files;\r\n        }\r\n\r\n        const lastDot = rootUrl.lastIndexOf(\".\");\r\n        const extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrl.substring(lastDot).toLowerCase() : \"\";\r\n\r\n        // TODO: use texture loader to load env files?\r\n        if (extension === \".env\") {\r\n            const onloaddata = (data: ArrayBufferView) => {\r\n                const info = GetEnvInfo(data)!;\r\n                texture.width = info.width;\r\n                texture.height = info.width;\r\n\r\n                UploadEnvSpherical(texture, info);\r\n\r\n                const specularInfo = info.specular as EnvironmentTextureSpecularInfoV1;\r\n                if (!specularInfo) {\r\n                    throw new Error(`Nothing else parsed so far`);\r\n                }\r\n\r\n                texture._lodGenerationScale = specularInfo.lodGenerationScale;\r\n                const imageData = CreateImageDataArrayBufferViews(data, info);\r\n\r\n                texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n                texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n                texture.generateMipMaps = true;\r\n                texture.getEngine().updateTextureSamplingMode(Texture.TRILINEAR_SAMPLINGMODE, texture);\r\n                texture._isRGBD = true;\r\n                texture.invertY = true;\r\n\r\n                this._engine.loadCubeTextureWithMips(\r\n                    texture._hardwareTexture!.underlyingResource,\r\n                    imageData,\r\n                    false,\r\n                    texture._useSRGBBuffer,\r\n                    () => {\r\n                        texture.isReady = true;\r\n                        if (onLoad) {\r\n                            onLoad();\r\n                        }\r\n                    },\r\n                    () => {\r\n                        throw new Error(\"Could not load a native cube texture.\");\r\n                    }\r\n                );\r\n            };\r\n\r\n            if (files && files.length === 6) {\r\n                throw new Error(`Multi-file loading not allowed on env files.`);\r\n            } else {\r\n                const onInternalError = (request?: IWebRequest, exception?: any) => {\r\n                    if (onError && request) {\r\n                        onError(request.status + \" \" + request.statusText, exception);\r\n                    }\r\n                };\r\n\r\n                this._loadFile(rootUrl, (data) => onloaddata(new Uint8Array(data as ArrayBuffer)), undefined, undefined, true, onInternalError);\r\n            }\r\n        } else {\r\n            if (!files || files.length !== 6) {\r\n                throw new Error(\"Cannot load cubemap because 6 files were not defined\");\r\n            }\r\n\r\n            // Reorder from [+X, +Y, +Z, -X, -Y, -Z] to [+X, -X, +Y, -Y, +Z, -Z].\r\n            const reorderedFiles = [files[0], files[3], files[1], files[4], files[2], files[5]];\r\n            Promise.all(reorderedFiles.map((file) => Tools.LoadFileAsync(file).then((data) => new Uint8Array(data as ArrayBuffer))))\r\n                .then((data) => {\r\n                    return new Promise<void>((resolve, reject) => {\r\n                        this._engine.loadCubeTexture(texture._hardwareTexture!.underlyingResource, data, !noMipmap, true, texture._useSRGBBuffer, resolve, reject);\r\n                    });\r\n                })\r\n                .then(\r\n                    () => {\r\n                        texture.isReady = true;\r\n                        if (onLoad) {\r\n                            onLoad();\r\n                        }\r\n                    },\r\n                    (error) => {\r\n                        if (onError) {\r\n                            onError(`Failed to load cubemap: ${error.message}`, error);\r\n                        }\r\n                    }\r\n                );\r\n        }\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        return texture;\r\n    }\r\n\r\n    /** @internal */\r\n    public _createHardwareTexture(): HardwareTextureWrapper {\r\n        return new NativeHardwareTexture(this._createTexture() as NativeTexture, this._engine);\r\n    }\r\n\r\n    /** @internal */\r\n    public _createHardwareRenderTargetWrapper(isMulti: boolean, isCube: boolean, size: TextureSize): RenderTargetWrapper {\r\n        const rtWrapper = new NativeRenderTargetWrapper(isMulti, isCube, size, this);\r\n        this._renderTargetWrapperCache.push(rtWrapper);\r\n        return rtWrapper;\r\n    }\r\n\r\n    /** @internal */\r\n    public _createInternalTexture(\r\n        size: TextureSize,\r\n        options: boolean | InternalTextureCreationOptions,\r\n        _delayGPUTextureCreation = true,\r\n        source = InternalTextureSource.Unknown\r\n    ): InternalTexture {\r\n        let generateMipMaps = false;\r\n        let type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        let samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n        let format = Constants.TEXTUREFORMAT_RGBA;\r\n        let useSRGBBuffer = false;\r\n        let samples = 1;\r\n        let label: string | undefined;\r\n        if (options !== undefined && typeof options === \"object\") {\r\n            generateMipMaps = !!options.generateMipMaps;\r\n            type = options.type === undefined ? Constants.TEXTURETYPE_UNSIGNED_INT : options.type;\r\n            samplingMode = options.samplingMode === undefined ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : options.samplingMode;\r\n            format = options.format === undefined ? Constants.TEXTUREFORMAT_RGBA : options.format;\r\n            useSRGBBuffer = options.useSRGBBuffer === undefined ? false : options.useSRGBBuffer;\r\n            samples = options.samples ?? 1;\r\n            label = options.label;\r\n        } else {\r\n            generateMipMaps = !!options;\r\n        }\r\n\r\n        useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !generateMipMaps);\r\n\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n            // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n            // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\r\n            type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n            Logger.Warn(\"Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE\");\r\n        }\r\n\r\n        const texture = new InternalTexture(this, source);\r\n        const width = (<{ width: number; height: number; layers?: number }>size).width ?? <number>size;\r\n        const height = (<{ width: number; height: number; layers?: number }>size).height ?? <number>size;\r\n\r\n        const layers = (<{ width: number; height: number; layers?: number }>size).layers || 0;\r\n        if (layers !== 0) {\r\n            throw new Error(\"Texture layers are not supported in Babylon Native\");\r\n        }\r\n\r\n        const nativeTexture = texture._hardwareTexture!.underlyingResource;\r\n        const nativeTextureFormat = getNativeTextureFormat(format, type);\r\n        // REVIEW: We are always setting the renderTarget flag as we don't know whether the texture will be used as a render target.\r\n        this._engine.initializeTexture(nativeTexture, width, height, generateMipMaps, nativeTextureFormat, true, useSRGBBuffer, samples);\r\n        this._setTextureSampling(nativeTexture, getNativeSamplingMode(samplingMode));\r\n\r\n        texture._useSRGBBuffer = useSRGBBuffer;\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.depth = layers;\r\n        texture.isReady = true;\r\n        texture.samples = samples;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        texture.type = type;\r\n        texture.format = format;\r\n        texture.label = label;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        return texture;\r\n    }\r\n\r\n    public createRenderTargetTexture(size: number | { width: number; height: number }, options: boolean | RenderTargetCreationOptions): RenderTargetWrapper {\r\n        const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size) as NativeRenderTargetWrapper;\r\n\r\n        let generateDepthBuffer = true;\r\n        let generateStencilBuffer = false;\r\n        let noColorAttachment = false;\r\n        let colorAttachment: InternalTexture | undefined = undefined;\r\n        let samples = 1;\r\n        if (options !== undefined && typeof options === \"object\") {\r\n            generateDepthBuffer = options.generateDepthBuffer ?? true;\r\n            generateStencilBuffer = !!options.generateStencilBuffer;\r\n            noColorAttachment = !!options.noColorAttachment;\r\n            colorAttachment = options.colorAttachment;\r\n            samples = options.samples ?? 1;\r\n        }\r\n\r\n        const texture = colorAttachment || (noColorAttachment ? null : this._createInternalTexture(size, options, true, InternalTextureSource.RenderTarget));\r\n        const width = (<{ width: number; height: number; layers?: number }>size).width ?? <number>size;\r\n        const height = (<{ width: number; height: number; layers?: number }>size).height ?? <number>size;\r\n\r\n        const framebuffer = this._engine.createFrameBuffer(\r\n            texture ? texture._hardwareTexture!.underlyingResource : null,\r\n            width,\r\n            height,\r\n            generateStencilBuffer,\r\n            generateDepthBuffer,\r\n            samples\r\n        );\r\n\r\n        rtWrapper._framebuffer = framebuffer;\r\n        rtWrapper._generateDepthBuffer = generateDepthBuffer;\r\n        rtWrapper._generateStencilBuffer = generateStencilBuffer;\r\n        rtWrapper._samples = samples;\r\n\r\n        rtWrapper.setTextures(texture);\r\n\r\n        return rtWrapper;\r\n    }\r\n\r\n    public updateRenderTargetTextureSampleCount(rtWrapper: RenderTargetWrapper, samples: number): number {\r\n        Logger.Warn(\"Updating render target sample count is not currently supported\");\r\n        return rtWrapper.samples;\r\n    }\r\n\r\n    public updateTextureSamplingMode(samplingMode: number, texture: InternalTexture): void {\r\n        if (texture._hardwareTexture) {\r\n            const filter = getNativeSamplingMode(samplingMode);\r\n            this._setTextureSampling(texture._hardwareTexture.underlyingResource, filter);\r\n        }\r\n\r\n        texture.samplingMode = samplingMode;\r\n    }\r\n\r\n    public bindFramebuffer(texture: RenderTargetWrapper, faceIndex?: number, requiredWidth?: number, requiredHeight?: number, forceFullscreenViewport?: boolean): void {\r\n        const nativeRTWrapper = texture as NativeRenderTargetWrapper;\r\n\r\n        if (this._currentRenderTarget) {\r\n            this.unBindFramebuffer(this._currentRenderTarget);\r\n        }\r\n\r\n        this._currentRenderTarget = texture;\r\n\r\n        if (faceIndex) {\r\n            throw new Error(\"Cuboid frame buffers are not yet supported in NativeEngine.\");\r\n        }\r\n\r\n        if (requiredWidth || requiredHeight) {\r\n            throw new Error(\"Required width/height for frame buffers not yet supported in NativeEngine.\");\r\n        }\r\n\r\n        if (forceFullscreenViewport) {\r\n            //Not supported yet but don't stop rendering\r\n        }\r\n\r\n        if (nativeRTWrapper._framebufferDepthStencil) {\r\n            this._bindUnboundFramebuffer(nativeRTWrapper._framebufferDepthStencil);\r\n        } else {\r\n            this._bindUnboundFramebuffer(nativeRTWrapper._framebuffer);\r\n        }\r\n    }\r\n\r\n    public unBindFramebuffer(texture: RenderTargetWrapper, disableGenerateMipMaps = false, onBeforeUnbind?: () => void): void {\r\n        // NOTE: Disabling mipmap generation is not yet supported in NativeEngine.\r\n\r\n        this._currentRenderTarget = null;\r\n\r\n        if (onBeforeUnbind) {\r\n            onBeforeUnbind();\r\n        }\r\n\r\n        this._bindUnboundFramebuffer(null);\r\n    }\r\n\r\n    public createDynamicVertexBuffer(data: DataArray): DataBuffer {\r\n        return this.createVertexBuffer(data, true);\r\n    }\r\n\r\n    public updateDynamicIndexBuffer(indexBuffer: DataBuffer, indices: IndicesArray, offset: number = 0): void {\r\n        const buffer = indexBuffer as NativeDataBuffer;\r\n        const data = this._normalizeIndexData(indices);\r\n        buffer.is32Bits = data.BYTES_PER_ELEMENT === 4;\r\n        this._engine.updateDynamicIndexBuffer(buffer.nativeIndexBuffer!, data.buffer, data.byteOffset, data.byteLength, offset);\r\n    }\r\n\r\n    public updateDynamicVertexBuffer(vertexBuffer: DataBuffer, verticies: DataArray, byteOffset?: number, byteLength?: number): void {\r\n        const buffer = vertexBuffer as NativeDataBuffer;\r\n        const data = ArrayBuffer.isView(verticies) ? verticies : new Float32Array(verticies);\r\n        this._engine.updateDynamicVertexBuffer(buffer.nativeVertexBuffer!, data.buffer, data.byteOffset + (byteOffset ?? 0), byteLength ?? data.byteLength);\r\n    }\r\n\r\n    // TODO: Refactor to share more logic with base Engine implementation.\r\n    protected _setTexture(channel: number, texture: Nullable<BaseTexture>, isPartOfTextureArray = false, depthStencilTexture = false): boolean {\r\n        const uniform = this._boundUniforms[channel] as unknown as NativeUniform;\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        // Not ready?\r\n        if (!texture) {\r\n            if (this._boundTexturesCache[channel] != null) {\r\n                this._activeChannel = channel;\r\n                this._boundTexturesCache[channel] = null;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        // Video\r\n        if ((<VideoTexture>texture).video) {\r\n            this._activeChannel = channel;\r\n            (<VideoTexture>texture).update();\r\n        } else if (texture.delayLoadState === Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            // Delay loading\r\n            texture.delayLoad();\r\n            return false;\r\n        }\r\n\r\n        let internalTexture: InternalTexture;\r\n        if (depthStencilTexture) {\r\n            internalTexture = (<RenderTargetTexture>texture).depthStencilTexture!;\r\n        } else if (texture.isReady()) {\r\n            internalTexture = <InternalTexture>texture.getInternalTexture();\r\n        } else if (texture.isCube) {\r\n            internalTexture = this.emptyCubeTexture;\r\n        } else if (texture.is3D) {\r\n            internalTexture = this.emptyTexture3D;\r\n        } else if (texture.is2DArray) {\r\n            internalTexture = this.emptyTexture2DArray;\r\n        } else {\r\n            internalTexture = this.emptyTexture;\r\n        }\r\n\r\n        this._activeChannel = channel;\r\n\r\n        if (!internalTexture || !internalTexture._hardwareTexture) {\r\n            return false;\r\n        }\r\n\r\n        this._setTextureWrapMode(\r\n            internalTexture._hardwareTexture.underlyingResource,\r\n            getNativeAddressMode(texture.wrapU),\r\n            getNativeAddressMode(texture.wrapV),\r\n            getNativeAddressMode(texture.wrapR)\r\n        );\r\n        this._updateAnisotropicLevel(texture);\r\n\r\n        this._setTextureCore(uniform, internalTexture._hardwareTexture.underlyingResource);\r\n\r\n        return true;\r\n    }\r\n\r\n    // filter is a NativeFilter.XXXX value.\r\n    private _setTextureSampling(texture: NativeTexture, filter: number) {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTURESAMPLING);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(texture as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(filter);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    // addressModes are NativeAddressMode.XXXX values.\r\n    private _setTextureWrapMode(texture: NativeTexture, addressModeU: number, addressModeV: number, addressModeW: number) {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTUREWRAPMODE);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(texture as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(addressModeU);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(addressModeV);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(addressModeW);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    private _setTextureCore(uniform: NativeUniform, texture: NativeTexture) {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTURE);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(texture);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    // TODO: Share more of this logic with the base implementation.\r\n    // TODO: Rename to match naming in base implementation once refactoring allows different parameters.\r\n    private _updateAnisotropicLevel(texture: BaseTexture) {\r\n        const internalTexture = texture.getInternalTexture();\r\n        const value = texture.anisotropicFilteringLevel;\r\n\r\n        if (!internalTexture || !internalTexture._hardwareTexture) {\r\n            return;\r\n        }\r\n\r\n        if (internalTexture._cachedAnisotropicFilteringLevel !== value) {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTUREANISOTROPICLEVEL);\r\n            this._commandBufferEncoder.encodeCommandArgAsNativeData(internalTexture._hardwareTexture.underlyingResource);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(value);\r\n            this._commandBufferEncoder.finishEncodingCommand();\r\n            internalTexture._cachedAnisotropicFilteringLevel = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bindTexture(channel: number, texture: InternalTexture): void {\r\n        const uniform = this._boundUniforms[channel] as unknown as NativeUniform;\r\n        if (!uniform) {\r\n            return;\r\n        }\r\n        if (texture && texture._hardwareTexture) {\r\n            const underlyingResource = texture._hardwareTexture.underlyingResource;\r\n            this._setTextureCore(uniform, underlyingResource);\r\n        }\r\n    }\r\n\r\n    protected _deleteBuffer(buffer: NativeDataBuffer): void {\r\n        if (buffer.nativeIndexBuffer) {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEINDEXBUFFER);\r\n            this._commandBufferEncoder.encodeCommandArgAsNativeData(buffer.nativeIndexBuffer);\r\n            this._commandBufferEncoder.finishEncodingCommand();\r\n            delete buffer.nativeIndexBuffer;\r\n        }\r\n\r\n        if (buffer.nativeVertexBuffer) {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEVERTEXBUFFER);\r\n            this._commandBufferEncoder.encodeCommandArgAsNativeData(buffer.nativeVertexBuffer);\r\n            this._commandBufferEncoder.finishEncodingCommand();\r\n            delete buffer.nativeVertexBuffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a canvas\r\n     * @param width width\r\n     * @param height height\r\n     * @returns ICanvas interface\r\n     */\r\n    public createCanvas(width: number, height: number): ICanvas {\r\n        if (!_native.Canvas) {\r\n            throw new Error(\"Native Canvas plugin not available.\");\r\n        }\r\n        const canvas = new _native.Canvas();\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        return canvas;\r\n    }\r\n\r\n    /**\r\n     * Create an image to use with canvas\r\n     * @returns IImage interface\r\n     */\r\n    public createCanvasImage(): IImage {\r\n        if (!_native.Canvas) {\r\n            throw new Error(\"Native Canvas plugin not available.\");\r\n        }\r\n        const image = new _native.Image();\r\n        return image;\r\n    }\r\n\r\n    /**\r\n     * Update a portion of an internal texture\r\n     * @param texture defines the texture to update\r\n     * @param imageData defines the data to store into the texture\r\n     * @param xOffset defines the x coordinates of the update rectangle\r\n     * @param yOffset defines the y coordinates of the update rectangle\r\n     * @param width defines the width of the update rectangle\r\n     * @param height defines the height of the update rectangle\r\n     * @param faceIndex defines the face index if texture is a cube (0 by default)\r\n     * @param lod defines the lod level to update (0 by default)\r\n     * @param generateMipMaps defines whether to generate mipmaps or not\r\n     */\r\n    public updateTextureData(\r\n        texture: InternalTexture,\r\n        imageData: ArrayBufferView,\r\n        xOffset: number,\r\n        yOffset: number,\r\n        width: number,\r\n        height: number,\r\n        faceIndex: number = 0,\r\n        lod: number = 0,\r\n        generateMipMaps = false\r\n    ): void {\r\n        throw new Error(\"updateTextureData not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadCompressedDataToTextureDirectly(\r\n        texture: InternalTexture,\r\n        internalFormat: number,\r\n        width: number,\r\n        height: number,\r\n        data: ArrayBufferView,\r\n        faceIndex: number = 0,\r\n        lod: number = 0\r\n    ) {\r\n        throw new Error(\"_uploadCompressedDataToTextureDirectly not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadDataToTextureDirectly(texture: InternalTexture, imageData: ArrayBufferView, faceIndex: number = 0, lod: number = 0): void {\r\n        throw new Error(\"_uploadDataToTextureDirectly not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadArrayBufferViewToTexture(texture: InternalTexture, imageData: ArrayBufferView, faceIndex: number = 0, lod: number = 0): void {\r\n        throw new Error(\"_uploadArrayBufferViewToTexture not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadImageToTexture(texture: InternalTexture, image: HTMLImageElement, faceIndex: number = 0, lod: number = 0) {\r\n        throw new Error(\"_uploadArrayBufferViewToTexture not implemented.\");\r\n    }\r\n\r\n    public getFontOffset(font: string): { ascent: number; height: number; descent: number } {\r\n        // TODO\r\n        const result = { ascent: 0, height: 0, descent: 0 };\r\n        return result;\r\n    }\r\n\r\n    public _readTexturePixels(\r\n        texture: InternalTexture,\r\n        width: number,\r\n        height: number,\r\n        faceIndex?: number,\r\n        level?: number,\r\n        buffer?: Nullable<ArrayBufferView>,\r\n        _flushRenderer?: boolean,\r\n        _noDataConversion?: boolean,\r\n        x?: number,\r\n        y?: number\r\n    ): Promise<ArrayBufferView> {\r\n        if (faceIndex !== undefined && faceIndex !== -1) {\r\n            throw new Error(`Reading cubemap faces is not supported, but faceIndex is ${faceIndex}.`);\r\n        }\r\n\r\n        return this._engine\r\n            .readTexture(\r\n                texture._hardwareTexture?.underlyingResource,\r\n                level ?? 0,\r\n                x ?? 0,\r\n                y ?? 0,\r\n                width,\r\n                height,\r\n                buffer?.buffer ?? null,\r\n                buffer?.byteOffset ?? 0,\r\n                buffer?.byteLength ?? 0\r\n            )\r\n            .then((rawBuffer) => {\r\n                if (!buffer) {\r\n                    buffer = new Uint8Array(rawBuffer);\r\n                }\r\n\r\n                return buffer;\r\n            });\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}