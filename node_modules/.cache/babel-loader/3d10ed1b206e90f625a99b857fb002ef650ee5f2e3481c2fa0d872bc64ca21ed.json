{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../tslib.es6.js\";\nimport { serialize, serializeAsTexture, expandToProperty, serializeAsColor3 } from \"../../Misc/decorators.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { MaterialFlags } from \"../materialFlags.js\";\nimport { MaterialHelper } from \"../../Materials/materialHelper.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { TmpVectors } from \"../../Maths/math.vector.js\";\nimport { MaterialPluginBase } from \"../materialPluginBase.js\";\nimport { MaterialDefines } from \"../materialDefines.js\";\n/**\n * @internal\n */\nexport class MaterialSubSurfaceDefines extends MaterialDefines {\n  constructor() {\n    super(...arguments);\n    this.SUBSURFACE = false;\n    this.SS_REFRACTION = false;\n    this.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;\n    this.SS_TRANSLUCENCY = false;\n    this.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;\n    this.SS_SCATTERING = false;\n    this.SS_THICKNESSANDMASK_TEXTURE = false;\n    this.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;\n    this.SS_HAS_THICKNESS = false;\n    this.SS_REFRACTIONINTENSITY_TEXTURE = false;\n    this.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;\n    this.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\n    this.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;\n    this.SS_REFRACTIONMAP_3D = false;\n    this.SS_REFRACTIONMAP_OPPOSITEZ = false;\n    this.SS_LODINREFRACTIONALPHA = false;\n    this.SS_GAMMAREFRACTION = false;\n    this.SS_RGBDREFRACTION = false;\n    this.SS_LINEARSPECULARREFRACTION = false;\n    this.SS_LINKREFRACTIONTOTRANSPARENCY = false;\n    this.SS_ALBEDOFORREFRACTIONTINT = false;\n    this.SS_ALBEDOFORTRANSLUCENCYTINT = false;\n    this.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\n    this.SS_USE_THICKNESS_AS_DEPTH = false;\n    this.SS_MASK_FROM_THICKNESS_TEXTURE = false;\n    this.SS_USE_GLTF_TEXTURES = false;\n  }\n}\n/**\n * Plugin that implements the sub surface component of the PBR material\n */\nexport class PBRSubSurfaceConfiguration extends MaterialPluginBase {\n  /**\n   * Diffusion profile for subsurface scattering.\n   * Useful for better scattering in the skins or foliages.\n   */\n  get scatteringDiffusionProfile() {\n    if (!this._scene.subSurfaceConfiguration) {\n      return null;\n    }\n    return this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex];\n  }\n  set scatteringDiffusionProfile(c) {\n    if (!this._scene.enableSubSurfaceForPrePass()) {\n      // Not supported\n      return;\n    }\n    // addDiffusionProfile automatically checks for doubles\n    if (c) {\n      this._scatteringDiffusionProfileIndex = this._scene.subSurfaceConfiguration.addDiffusionProfile(c);\n    }\n  }\n  /**\n   * Index of refraction of the material's volume.\n   * https://en.wikipedia.org/wiki/List_of_refractive_indices\n   *\n   * This ONLY impacts refraction. If not provided or given a non-valid value,\n   * the volume will use the same IOR as the surface.\n   */\n  get volumeIndexOfRefraction() {\n    if (this._volumeIndexOfRefraction >= 1.0) {\n      return this._volumeIndexOfRefraction;\n    }\n    return this._indexOfRefraction;\n  }\n  set volumeIndexOfRefraction(value) {\n    if (value >= 1.0) {\n      this._volumeIndexOfRefraction = value;\n    } else {\n      this._volumeIndexOfRefraction = -1.0;\n    }\n  }\n  /** @internal */\n  _markAllSubMeshesAsTexturesDirty() {\n    this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled);\n    this._internalMarkAllSubMeshesAsTexturesDirty();\n  }\n  /** @internal */\n  _markScenePrePassDirty() {\n    this._internalMarkAllSubMeshesAsTexturesDirty();\n    this._internalMarkScenePrePassDirty();\n  }\n  constructor(material, addToPluginList = true) {\n    super(material, \"PBRSubSurface\", 130, new MaterialSubSurfaceDefines(), addToPluginList);\n    this._isRefractionEnabled = false;\n    /**\n     * Defines if the refraction is enabled in the material.\n     */\n    this.isRefractionEnabled = false;\n    this._isTranslucencyEnabled = false;\n    /**\n     * Defines if the translucency is enabled in the material.\n     */\n    this.isTranslucencyEnabled = false;\n    this._isScatteringEnabled = false;\n    /**\n     * Defines if the sub surface scattering is enabled in the material.\n     */\n    this.isScatteringEnabled = false;\n    this._scatteringDiffusionProfileIndex = 0;\n    /**\n     * Defines the refraction intensity of the material.\n     * The refraction when enabled replaces the Diffuse part of the material.\n     * The intensity helps transitioning between diffuse and refraction.\n     */\n    this.refractionIntensity = 1;\n    /**\n     * Defines the translucency intensity of the material.\n     * When translucency has been enabled, this defines how much of the \"translucency\"\n     * is added to the diffuse part of the material.\n     */\n    this.translucencyIntensity = 1;\n    /**\n     * When enabled, transparent surfaces will be tinted with the albedo colour (independent of thickness)\n     */\n    this.useAlbedoToTintRefraction = false;\n    /**\n     * When enabled, translucent surfaces will be tinted with the albedo colour (independent of thickness)\n     */\n    this.useAlbedoToTintTranslucency = false;\n    this._thicknessTexture = null;\n    /**\n     * Stores the average thickness of a mesh in a texture (The texture is holding the values linearly).\n     * The red (or green if useGltfStyleTextures=true) channel of the texture should contain the thickness remapped between 0 and 1.\n     * 0 would mean minimumThickness\n     * 1 would mean maximumThickness\n     * The other channels might be use as a mask to vary the different effects intensity.\n     */\n    this.thicknessTexture = null;\n    this._refractionTexture = null;\n    /**\n     * Defines the texture to use for refraction.\n     */\n    this.refractionTexture = null;\n    /** @internal */\n    this._indexOfRefraction = 1.5;\n    /**\n     * Index of refraction of the material base layer.\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\n     *\n     * This does not only impact refraction but also the Base F0 of Dielectric Materials.\n     *\n     * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))\n     */\n    this.indexOfRefraction = 1.5;\n    this._volumeIndexOfRefraction = -1.0;\n    this._invertRefractionY = false;\n    /**\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\n     */\n    this.invertRefractionY = false;\n    /** @internal */\n    this._linkRefractionWithTransparency = false;\n    /**\n     * This parameters will make the material used its opacity to control how much it is refracting against not.\n     * Materials half opaque for instance using refraction could benefit from this control.\n     */\n    this.linkRefractionWithTransparency = false;\n    /**\n     * Defines the minimum thickness stored in the thickness map.\n     * If no thickness map is defined, this value will be used to simulate thickness.\n     */\n    this.minimumThickness = 0;\n    /**\n     * Defines the maximum thickness stored in the thickness map.\n     */\n    this.maximumThickness = 1;\n    /**\n     * Defines that the thickness should be used as a measure of the depth volume.\n     */\n    this.useThicknessAsDepth = false;\n    /**\n     * Defines the volume tint of the material.\n     * This is used for both translucency and scattering.\n     */\n    this.tintColor = Color3.White();\n    /**\n     * Defines the distance at which the tint color should be found in the media.\n     * This is used for refraction only.\n     */\n    this.tintColorAtDistance = 1;\n    /**\n     * Defines how far each channel transmit through the media.\n     * It is defined as a color to simplify it selection.\n     */\n    this.diffusionDistance = Color3.White();\n    this._useMaskFromThicknessTexture = false;\n    /**\n     * Stores the intensity of the different subsurface effects in the thickness texture.\n     * Note that if refractionIntensityTexture and/or translucencyIntensityTexture is provided it takes precedence over thicknessTexture + useMaskFromThicknessTexture\n     * * the green (red if useGltfStyleTextures = true) channel is the refraction intensity.\n     * * the blue channel is the translucency intensity.\n     */\n    this.useMaskFromThicknessTexture = false;\n    this._refractionIntensityTexture = null;\n    /**\n     * Stores the intensity of the refraction. If provided, it takes precedence over thicknessTexture + useMaskFromThicknessTexture\n     * * the green (red if useGltfStyleTextures = true) channel is the refraction intensity.\n     */\n    this.refractionIntensityTexture = null;\n    this._translucencyIntensityTexture = null;\n    /**\n     * Stores the intensity of the translucency. If provided, it takes precedence over thicknessTexture + useMaskFromThicknessTexture\n     * * the blue channel is the translucency intensity.\n     */\n    this.translucencyIntensityTexture = null;\n    this._useGltfStyleTextures = false;\n    /**\n     * Use channels layout used by glTF:\n     * * thicknessTexture: the green (instead of red) channel is the thickness\n     * * thicknessTexture/refractionIntensityTexture: the red (instead of green) channel is the refraction intensity\n     * * thicknessTexture/translucencyIntensityTexture: no change, use the blue channel for the translucency intensity\n     */\n    this.useGltfStyleTextures = false;\n    this._scene = material.getScene();\n    this.registerForExtraEvents = true;\n    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];\n    this._internalMarkScenePrePassDirty = material._dirtyCallbacks[32];\n  }\n  isReadyForSubMesh(defines, scene) {\n    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\n      return true;\n    }\n    if (defines._areTexturesDirty) {\n      if (scene.texturesEnabled) {\n        if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n          if (!this._thicknessTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n        const refractionTexture = this._getRefractionTexture(scene);\n        if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n          if (!refractionTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n  prepareDefinesBeforeAttributes(defines, scene) {\n    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\n      defines.SUBSURFACE = false;\n      defines.SS_TRANSLUCENCY = false;\n      defines.SS_SCATTERING = false;\n      defines.SS_REFRACTION = false;\n      defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;\n      defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;\n      defines.SS_THICKNESSANDMASK_TEXTURE = false;\n      defines.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;\n      defines.SS_HAS_THICKNESS = false;\n      defines.SS_REFRACTIONINTENSITY_TEXTURE = false;\n      defines.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;\n      defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\n      defines.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;\n      defines.SS_REFRACTIONMAP_3D = false;\n      defines.SS_REFRACTIONMAP_OPPOSITEZ = false;\n      defines.SS_LODINREFRACTIONALPHA = false;\n      defines.SS_GAMMAREFRACTION = false;\n      defines.SS_RGBDREFRACTION = false;\n      defines.SS_LINEARSPECULARREFRACTION = false;\n      defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;\n      defines.SS_ALBEDOFORREFRACTIONTINT = false;\n      defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;\n      defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\n      defines.SS_USE_THICKNESS_AS_DEPTH = false;\n      defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;\n      defines.SS_USE_GLTF_TEXTURES = false;\n      return;\n    }\n    if (defines._areTexturesDirty) {\n      defines.SUBSURFACE = true;\n      defines.SS_TRANSLUCENCY = this._isTranslucencyEnabled;\n      defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;\n      defines.SS_SCATTERING = this._isScatteringEnabled;\n      defines.SS_THICKNESSANDMASK_TEXTURE = false;\n      defines.SS_REFRACTIONINTENSITY_TEXTURE = false;\n      defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\n      defines.SS_HAS_THICKNESS = false;\n      defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;\n      defines.SS_USE_GLTF_TEXTURES = false;\n      defines.SS_REFRACTION = false;\n      defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;\n      defines.SS_REFRACTIONMAP_3D = false;\n      defines.SS_GAMMAREFRACTION = false;\n      defines.SS_RGBDREFRACTION = false;\n      defines.SS_LINEARSPECULARREFRACTION = false;\n      defines.SS_REFRACTIONMAP_OPPOSITEZ = false;\n      defines.SS_LODINREFRACTIONALPHA = false;\n      defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;\n      defines.SS_ALBEDOFORREFRACTIONTINT = false;\n      defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;\n      defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\n      defines.SS_USE_THICKNESS_AS_DEPTH = false;\n      const refractionIntensityTextureIsThicknessTexture = !!this._thicknessTexture && !!this._refractionIntensityTexture && this._refractionIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture) && this._refractionIntensityTexture._texture === this._thicknessTexture._texture;\n      const translucencyIntensityTextureIsThicknessTexture = !!this._thicknessTexture && !!this._translucencyIntensityTexture && this._translucencyIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture) && this._translucencyIntensityTexture._texture === this._thicknessTexture._texture;\n      // if true, it means the refraction/translucency textures are the same than the thickness texture so there's no need to pass them to the shader, only thicknessTexture\n      const useOnlyThicknessTexture = (refractionIntensityTextureIsThicknessTexture || !this._refractionIntensityTexture) && (translucencyIntensityTextureIsThicknessTexture || !this._translucencyIntensityTexture);\n      if (defines._areTexturesDirty) {\n        if (scene.texturesEnabled) {\n          if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n            MaterialHelper.PrepareDefinesForMergedUV(this._thicknessTexture, defines, \"SS_THICKNESSANDMASK_TEXTURE\");\n          }\n          if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && !useOnlyThicknessTexture) {\n            MaterialHelper.PrepareDefinesForMergedUV(this._refractionIntensityTexture, defines, \"SS_REFRACTIONINTENSITY_TEXTURE\");\n          }\n          if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && !useOnlyThicknessTexture) {\n            MaterialHelper.PrepareDefinesForMergedUV(this._translucencyIntensityTexture, defines, \"SS_TRANSLUCENCYINTENSITY_TEXTURE\");\n          }\n        }\n      }\n      defines.SS_HAS_THICKNESS = this.maximumThickness - this.minimumThickness !== 0.0;\n      defines.SS_MASK_FROM_THICKNESS_TEXTURE = (this._useMaskFromThicknessTexture || !!this._refractionIntensityTexture || !!this._translucencyIntensityTexture) && useOnlyThicknessTexture;\n      defines.SS_USE_GLTF_TEXTURES = this._useGltfStyleTextures;\n      defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = (this._useMaskFromThicknessTexture || !!this._refractionIntensityTexture) && useOnlyThicknessTexture;\n      defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = (this._useMaskFromThicknessTexture || !!this._translucencyIntensityTexture) && useOnlyThicknessTexture;\n      if (this._isRefractionEnabled) {\n        if (scene.texturesEnabled) {\n          const refractionTexture = this._getRefractionTexture(scene);\n          if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n            defines.SS_REFRACTION = true;\n            defines.SS_REFRACTIONMAP_3D = refractionTexture.isCube;\n            defines.SS_GAMMAREFRACTION = refractionTexture.gammaSpace;\n            defines.SS_RGBDREFRACTION = refractionTexture.isRGBD;\n            defines.SS_LINEARSPECULARREFRACTION = refractionTexture.linearSpecularLOD;\n            defines.SS_REFRACTIONMAP_OPPOSITEZ = this._scene.useRightHandedSystem && refractionTexture.isCube ? !refractionTexture.invertZ : refractionTexture.invertZ;\n            defines.SS_LODINREFRACTIONALPHA = refractionTexture.lodLevelInAlpha;\n            defines.SS_LINKREFRACTIONTOTRANSPARENCY = this._linkRefractionWithTransparency;\n            defines.SS_ALBEDOFORREFRACTIONTINT = this.useAlbedoToTintRefraction;\n            defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = refractionTexture.isCube && refractionTexture.boundingBoxSize;\n            defines.SS_USE_THICKNESS_AS_DEPTH = this.useThicknessAsDepth;\n          }\n        }\n      }\n      if (this._isTranslucencyEnabled) {\n        defines.SS_ALBEDOFORTRANSLUCENCYTINT = this.useAlbedoToTintTranslucency;\n      }\n    }\n  }\n  /**\n   * Binds the material data (this function is called even if mustRebind() returns false)\n   * @param uniformBuffer defines the Uniform buffer to fill in.\n   * @param scene defines the scene the material belongs to.\n   * @param engine defines the engine the material belongs to.\n   * @param subMesh the submesh to bind data for\n   */\n  hardBindForSubMesh(uniformBuffer, scene, engine, subMesh) {\n    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\n      return;\n    }\n    subMesh.getRenderingMesh().getWorldMatrix().decompose(TmpVectors.Vector3[0]);\n    const thicknessScale = Math.max(Math.abs(TmpVectors.Vector3[0].x), Math.abs(TmpVectors.Vector3[0].y), Math.abs(TmpVectors.Vector3[0].z));\n    uniformBuffer.updateFloat2(\"vThicknessParam\", this.minimumThickness * thicknessScale, (this.maximumThickness - this.minimumThickness) * thicknessScale);\n  }\n  bindForSubMesh(uniformBuffer, scene, engine, subMesh) {\n    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\n      return;\n    }\n    const defines = subMesh.materialDefines;\n    const isFrozen = this._material.isFrozen;\n    const realTimeFiltering = this._material.realTimeFiltering;\n    const lodBasedMicrosurface = defines.LODBASEDMICROSFURACE;\n    const refractionTexture = this._getRefractionTexture(scene);\n    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\n      if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n        uniformBuffer.updateFloat2(\"vThicknessInfos\", this._thicknessTexture.coordinatesIndex, this._thicknessTexture.level);\n        MaterialHelper.BindTextureMatrix(this._thicknessTexture, uniformBuffer, \"thickness\");\n      }\n      if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {\n        uniformBuffer.updateFloat2(\"vRefractionIntensityInfos\", this._refractionIntensityTexture.coordinatesIndex, this._refractionIntensityTexture.level);\n        MaterialHelper.BindTextureMatrix(this._refractionIntensityTexture, uniformBuffer, \"refractionIntensity\");\n      }\n      if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {\n        uniformBuffer.updateFloat2(\"vTranslucencyIntensityInfos\", this._translucencyIntensityTexture.coordinatesIndex, this._translucencyIntensityTexture.level);\n        MaterialHelper.BindTextureMatrix(this._translucencyIntensityTexture, uniformBuffer, \"translucencyIntensity\");\n      }\n      if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n        uniformBuffer.updateMatrix(\"refractionMatrix\", refractionTexture.getRefractionTextureMatrix());\n        let depth = 1.0;\n        if (!refractionTexture.isCube) {\n          if (refractionTexture.depth) {\n            depth = refractionTexture.depth;\n          }\n        }\n        const width = refractionTexture.getSize().width;\n        const refractionIor = this.volumeIndexOfRefraction;\n        uniformBuffer.updateFloat4(\"vRefractionInfos\", refractionTexture.level, 1 / refractionIor, depth, this._invertRefractionY ? -1 : 1);\n        uniformBuffer.updateFloat4(\"vRefractionMicrosurfaceInfos\", width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset, 1.0 / this.indexOfRefraction);\n        if (realTimeFiltering) {\n          uniformBuffer.updateFloat2(\"vRefractionFilteringInfo\", width, Scalar.Log2(width));\n        }\n        if (refractionTexture.boundingBoxSize) {\n          const cubeTexture = refractionTexture;\n          uniformBuffer.updateVector3(\"vRefractionPosition\", cubeTexture.boundingBoxPosition);\n          uniformBuffer.updateVector3(\"vRefractionSize\", cubeTexture.boundingBoxSize);\n        }\n      }\n      if (this._isScatteringEnabled) {\n        uniformBuffer.updateFloat(\"scatteringDiffusionProfile\", this._scatteringDiffusionProfileIndex);\n      }\n      uniformBuffer.updateColor3(\"vDiffusionDistance\", this.diffusionDistance);\n      uniformBuffer.updateFloat4(\"vTintColor\", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(0.00001, this.tintColorAtDistance));\n      uniformBuffer.updateFloat3(\"vSubSurfaceIntensity\", this.refractionIntensity, this.translucencyIntensity, 0);\n    }\n    // Textures\n    if (scene.texturesEnabled) {\n      if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n        uniformBuffer.setTexture(\"thicknessSampler\", this._thicknessTexture);\n      }\n      if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {\n        uniformBuffer.setTexture(\"refractionIntensitySampler\", this._refractionIntensityTexture);\n      }\n      if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {\n        uniformBuffer.setTexture(\"translucencyIntensitySampler\", this._translucencyIntensityTexture);\n      }\n      if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n        if (lodBasedMicrosurface) {\n          uniformBuffer.setTexture(\"refractionSampler\", refractionTexture);\n        } else {\n          uniformBuffer.setTexture(\"refractionSampler\", refractionTexture._lodTextureMid || refractionTexture);\n          uniformBuffer.setTexture(\"refractionSamplerLow\", refractionTexture._lodTextureLow || refractionTexture);\n          uniformBuffer.setTexture(\"refractionSamplerHigh\", refractionTexture._lodTextureHigh || refractionTexture);\n        }\n      }\n    }\n  }\n  /**\n   * Returns the texture used for refraction or null if none is used.\n   * @param scene defines the scene the material belongs to.\n   * @returns - Refraction texture if present.  If no refraction texture and refraction\n   * is linked with transparency, returns environment texture.  Otherwise, returns null.\n   */\n  _getRefractionTexture(scene) {\n    if (this._refractionTexture) {\n      return this._refractionTexture;\n    }\n    if (this._isRefractionEnabled) {\n      return scene.environmentTexture;\n    }\n    return null;\n  }\n  /**\n   * Returns true if alpha blending should be disabled.\n   */\n  get disableAlphaBlending() {\n    return this._isRefractionEnabled && this._linkRefractionWithTransparency;\n  }\n  /**\n   * Fills the list of render target textures.\n   * @param renderTargets the list of render targets to update\n   */\n  fillRenderTargetTextures(renderTargets) {\n    if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\n      renderTargets.push(this._refractionTexture);\n    }\n  }\n  hasTexture(texture) {\n    if (this._thicknessTexture === texture) {\n      return true;\n    }\n    if (this._refractionTexture === texture) {\n      return true;\n    }\n    return false;\n  }\n  hasRenderTargetTextures() {\n    if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\n      return true;\n    }\n    return false;\n  }\n  getActiveTextures(activeTextures) {\n    if (this._thicknessTexture) {\n      activeTextures.push(this._thicknessTexture);\n    }\n    if (this._refractionTexture) {\n      activeTextures.push(this._refractionTexture);\n    }\n  }\n  getAnimatables(animatables) {\n    if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {\n      animatables.push(this._thicknessTexture);\n    }\n    if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {\n      animatables.push(this._refractionTexture);\n    }\n  }\n  dispose(forceDisposeTextures) {\n    if (forceDisposeTextures) {\n      if (this._thicknessTexture) {\n        this._thicknessTexture.dispose();\n      }\n      if (this._refractionTexture) {\n        this._refractionTexture.dispose();\n      }\n    }\n  }\n  getClassName() {\n    return \"PBRSubSurfaceConfiguration\";\n  }\n  addFallbacks(defines, fallbacks, currentRank) {\n    if (defines.SS_SCATTERING) {\n      fallbacks.addFallback(currentRank++, \"SS_SCATTERING\");\n    }\n    if (defines.SS_TRANSLUCENCY) {\n      fallbacks.addFallback(currentRank++, \"SS_TRANSLUCENCY\");\n    }\n    return currentRank;\n  }\n  getSamplers(samplers) {\n    samplers.push(\"thicknessSampler\", \"refractionIntensitySampler\", \"translucencyIntensitySampler\", \"refractionSampler\", \"refractionSamplerLow\", \"refractionSamplerHigh\");\n  }\n  getUniforms() {\n    return {\n      ubo: [{\n        name: \"vRefractionMicrosurfaceInfos\",\n        size: 4,\n        type: \"vec4\"\n      }, {\n        name: \"vRefractionFilteringInfo\",\n        size: 2,\n        type: \"vec2\"\n      }, {\n        name: \"vTranslucencyIntensityInfos\",\n        size: 2,\n        type: \"vec2\"\n      }, {\n        name: \"vRefractionInfos\",\n        size: 4,\n        type: \"vec4\"\n      }, {\n        name: \"refractionMatrix\",\n        size: 16,\n        type: \"mat4\"\n      }, {\n        name: \"vThicknessInfos\",\n        size: 2,\n        type: \"vec2\"\n      }, {\n        name: \"vRefractionIntensityInfos\",\n        size: 2,\n        type: \"vec2\"\n      }, {\n        name: \"thicknessMatrix\",\n        size: 16,\n        type: \"mat4\"\n      }, {\n        name: \"refractionIntensityMatrix\",\n        size: 16,\n        type: \"mat4\"\n      }, {\n        name: \"translucencyIntensityMatrix\",\n        size: 16,\n        type: \"mat4\"\n      }, {\n        name: \"vThicknessParam\",\n        size: 2,\n        type: \"vec2\"\n      }, {\n        name: \"vDiffusionDistance\",\n        size: 3,\n        type: \"vec3\"\n      }, {\n        name: \"vTintColor\",\n        size: 4,\n        type: \"vec4\"\n      }, {\n        name: \"vSubSurfaceIntensity\",\n        size: 3,\n        type: \"vec3\"\n      }, {\n        name: \"vRefractionPosition\",\n        size: 3,\n        type: \"vec3\"\n      }, {\n        name: \"vRefractionSize\",\n        size: 3,\n        type: \"vec3\"\n      }, {\n        name: \"scatteringDiffusionProfile\",\n        size: 1,\n        type: \"float\"\n      }]\n    };\n  }\n}\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"isRefractionEnabled\", void 0);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"isTranslucencyEnabled\", void 0);\n__decorate([serialize(), expandToProperty(\"_markScenePrePassDirty\")], PBRSubSurfaceConfiguration.prototype, \"isScatteringEnabled\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"_scatteringDiffusionProfileIndex\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"refractionIntensity\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"translucencyIntensity\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"useAlbedoToTintRefraction\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"useAlbedoToTintTranslucency\", void 0);\n__decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"thicknessTexture\", void 0);\n__decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"refractionTexture\", void 0);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"indexOfRefraction\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"_volumeIndexOfRefraction\", void 0);\n__decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"volumeIndexOfRefraction\", null);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"invertRefractionY\", void 0);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"linkRefractionWithTransparency\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"minimumThickness\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"maximumThickness\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"useThicknessAsDepth\", void 0);\n__decorate([serializeAsColor3()], PBRSubSurfaceConfiguration.prototype, \"tintColor\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"tintColorAtDistance\", void 0);\n__decorate([serializeAsColor3()], PBRSubSurfaceConfiguration.prototype, \"diffusionDistance\", void 0);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"useMaskFromThicknessTexture\", void 0);\n__decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"refractionIntensityTexture\", void 0);\n__decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"translucencyIntensityTexture\", void 0);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"useGltfStyleTextures\", void 0);","map":{"version":3,"names":["serialize","serializeAsTexture","expandToProperty","serializeAsColor3","Color3","MaterialFlags","MaterialHelper","Scalar","TmpVectors","MaterialPluginBase","MaterialDefines","MaterialSubSurfaceDefines","constructor","SUBSURFACE","SS_REFRACTION","SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE","SS_TRANSLUCENCY","SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE","SS_SCATTERING","SS_THICKNESSANDMASK_TEXTURE","SS_THICKNESSANDMASK_TEXTUREDIRECTUV","SS_HAS_THICKNESS","SS_REFRACTIONINTENSITY_TEXTURE","SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV","SS_TRANSLUCENCYINTENSITY_TEXTURE","SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV","SS_REFRACTIONMAP_3D","SS_REFRACTIONMAP_OPPOSITEZ","SS_LODINREFRACTIONALPHA","SS_GAMMAREFRACTION","SS_RGBDREFRACTION","SS_LINEARSPECULARREFRACTION","SS_LINKREFRACTIONTOTRANSPARENCY","SS_ALBEDOFORREFRACTIONTINT","SS_ALBEDOFORTRANSLUCENCYTINT","SS_USE_LOCAL_REFRACTIONMAP_CUBIC","SS_USE_THICKNESS_AS_DEPTH","SS_MASK_FROM_THICKNESS_TEXTURE","SS_USE_GLTF_TEXTURES","PBRSubSurfaceConfiguration","scatteringDiffusionProfile","_scene","subSurfaceConfiguration","ssDiffusionProfileColors","_scatteringDiffusionProfileIndex","c","enableSubSurfaceForPrePass","addDiffusionProfile","volumeIndexOfRefraction","_volumeIndexOfRefraction","_indexOfRefraction","value","_markAllSubMeshesAsTexturesDirty","_enable","_isRefractionEnabled","_isTranslucencyEnabled","_isScatteringEnabled","_internalMarkAllSubMeshesAsTexturesDirty","_markScenePrePassDirty","_internalMarkScenePrePassDirty","material","addToPluginList","isRefractionEnabled","isTranslucencyEnabled","isScatteringEnabled","refractionIntensity","translucencyIntensity","useAlbedoToTintRefraction","useAlbedoToTintTranslucency","_thicknessTexture","thicknessTexture","_refractionTexture","refractionTexture","indexOfRefraction","_invertRefractionY","invertRefractionY","_linkRefractionWithTransparency","linkRefractionWithTransparency","minimumThickness","maximumThickness","useThicknessAsDepth","tintColor","White","tintColorAtDistance","diffusionDistance","_useMaskFromThicknessTexture","useMaskFromThicknessTexture","_refractionIntensityTexture","refractionIntensityTexture","_translucencyIntensityTexture","translucencyIntensityTexture","_useGltfStyleTextures","useGltfStyleTextures","getScene","registerForExtraEvents","_dirtyCallbacks","isReadyForSubMesh","defines","scene","_areTexturesDirty","texturesEnabled","ThicknessTextureEnabled","isReadyOrNotBlocking","_getRefractionTexture","RefractionTextureEnabled","prepareDefinesBeforeAttributes","refractionIntensityTextureIsThicknessTexture","checkTransformsAreIdentical","_texture","translucencyIntensityTextureIsThicknessTexture","useOnlyThicknessTexture","PrepareDefinesForMergedUV","RefractionIntensityTextureEnabled","TranslucencyIntensityTextureEnabled","isCube","gammaSpace","isRGBD","linearSpecularLOD","useRightHandedSystem","invertZ","lodLevelInAlpha","boundingBoxSize","hardBindForSubMesh","uniformBuffer","engine","subMesh","getRenderingMesh","getWorldMatrix","decompose","Vector3","thicknessScale","Math","max","abs","x","y","z","updateFloat2","bindForSubMesh","materialDefines","isFrozen","_material","realTimeFiltering","lodBasedMicrosurface","LODBASEDMICROSFURACE","useUbo","isSync","coordinatesIndex","level","BindTextureMatrix","updateMatrix","getRefractionTextureMatrix","depth","width","getSize","refractionIor","updateFloat4","lodGenerationScale","lodGenerationOffset","Log2","cubeTexture","updateVector3","boundingBoxPosition","updateFloat","updateColor3","r","g","b","updateFloat3","setTexture","_lodTextureMid","_lodTextureLow","_lodTextureHigh","environmentTexture","disableAlphaBlending","fillRenderTargetTextures","renderTargets","isRenderTarget","push","hasTexture","texture","hasRenderTargetTextures","getActiveTextures","activeTextures","getAnimatables","animatables","animations","length","dispose","forceDisposeTextures","getClassName","addFallbacks","fallbacks","currentRank","addFallback","getSamplers","samplers","getUniforms","ubo","name","size","type","__decorate"],"sources":["../../../../../dev/core/src/Materials/PBR/pbrSubSurfaceConfiguration.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport { serialize, serializeAsTexture, expandToProperty, serializeAsColor3 } from \"../../Misc/decorators\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport type { SmartArray } from \"../../Misc/smartArray\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { MaterialFlags } from \"../materialFlags\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { MaterialHelper } from \"../../Materials/materialHelper\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { CubeTexture } from \"../Textures/cubeTexture\";\r\nimport { TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\n\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialSubSurfaceDefines extends MaterialDefines {\r\n    public SUBSURFACE = false;\r\n\r\n    public SS_REFRACTION = false;\r\n    public SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;\r\n    public SS_TRANSLUCENCY = false;\r\n    public SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;\r\n    public SS_SCATTERING = false;\r\n\r\n    public SS_THICKNESSANDMASK_TEXTURE = false;\r\n    public SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;\r\n    public SS_HAS_THICKNESS = false;\r\n    public SS_REFRACTIONINTENSITY_TEXTURE = false;\r\n    public SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;\r\n    public SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\r\n    public SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;\r\n\r\n    public SS_REFRACTIONMAP_3D = false;\r\n    public SS_REFRACTIONMAP_OPPOSITEZ = false;\r\n    public SS_LODINREFRACTIONALPHA = false;\r\n    public SS_GAMMAREFRACTION = false;\r\n    public SS_RGBDREFRACTION = false;\r\n    public SS_LINEARSPECULARREFRACTION = false;\r\n    public SS_LINKREFRACTIONTOTRANSPARENCY = false;\r\n    public SS_ALBEDOFORREFRACTIONTINT = false;\r\n    public SS_ALBEDOFORTRANSLUCENCYTINT = false;\r\n    public SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\r\n    public SS_USE_THICKNESS_AS_DEPTH = false;\r\n\r\n    public SS_MASK_FROM_THICKNESS_TEXTURE = false;\r\n    public SS_USE_GLTF_TEXTURES = false;\r\n}\r\n\r\n/**\r\n * Plugin that implements the sub surface component of the PBR material\r\n */\r\nexport class PBRSubSurfaceConfiguration extends MaterialPluginBase {\r\n    protected _material: PBRBaseMaterial;\r\n\r\n    private _isRefractionEnabled = false;\r\n    /**\r\n     * Defines if the refraction is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isRefractionEnabled = false;\r\n\r\n    private _isTranslucencyEnabled = false;\r\n    /**\r\n     * Defines if the translucency is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isTranslucencyEnabled = false;\r\n\r\n    private _isScatteringEnabled = false;\r\n    /**\r\n     * Defines if the sub surface scattering is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markScenePrePassDirty\")\r\n    public isScatteringEnabled = false;\r\n\r\n    @serialize()\r\n    private _scatteringDiffusionProfileIndex = 0;\r\n\r\n    /**\r\n     * Diffusion profile for subsurface scattering.\r\n     * Useful for better scattering in the skins or foliages.\r\n     */\r\n    public get scatteringDiffusionProfile(): Nullable<Color3> {\r\n        if (!this._scene.subSurfaceConfiguration) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex];\r\n    }\r\n\r\n    public set scatteringDiffusionProfile(c: Nullable<Color3>) {\r\n        if (!this._scene.enableSubSurfaceForPrePass()) {\r\n            // Not supported\r\n            return;\r\n        }\r\n\r\n        // addDiffusionProfile automatically checks for doubles\r\n        if (c) {\r\n            this._scatteringDiffusionProfileIndex = this._scene.subSurfaceConfiguration!.addDiffusionProfile(c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the refraction intensity of the material.\r\n     * The refraction when enabled replaces the Diffuse part of the material.\r\n     * The intensity helps transitioning between diffuse and refraction.\r\n     */\r\n    @serialize()\r\n    public refractionIntensity: number = 1;\r\n\r\n    /**\r\n     * Defines the translucency intensity of the material.\r\n     * When translucency has been enabled, this defines how much of the \"translucency\"\r\n     * is added to the diffuse part of the material.\r\n     */\r\n    @serialize()\r\n    public translucencyIntensity: number = 1;\r\n\r\n    /**\r\n     * When enabled, transparent surfaces will be tinted with the albedo colour (independent of thickness)\r\n     */\r\n    @serialize()\r\n    public useAlbedoToTintRefraction: boolean = false;\r\n\r\n    /**\r\n     * When enabled, translucent surfaces will be tinted with the albedo colour (independent of thickness)\r\n     */\r\n    @serialize()\r\n    public useAlbedoToTintTranslucency: boolean = false;\r\n\r\n    private _thicknessTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the average thickness of a mesh in a texture (The texture is holding the values linearly).\r\n     * The red (or green if useGltfStyleTextures=true) channel of the texture should contain the thickness remapped between 0 and 1.\r\n     * 0 would mean minimumThickness\r\n     * 1 would mean maximumThickness\r\n     * The other channels might be use as a mask to vary the different effects intensity.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public thicknessTexture: Nullable<BaseTexture> = null;\r\n\r\n    private _refractionTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Defines the texture to use for refraction.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public refractionTexture: Nullable<BaseTexture> = null;\r\n\r\n    /** @internal */\r\n    public _indexOfRefraction = 1.5;\r\n    /**\r\n     * Index of refraction of the material base layer.\r\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\r\n     *\r\n     * This does not only impact refraction but also the Base F0 of Dielectric Materials.\r\n     *\r\n     * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public indexOfRefraction = 1.5;\r\n\r\n    @serialize()\r\n    private _volumeIndexOfRefraction = -1.0;\r\n\r\n    /**\r\n     * Index of refraction of the material's volume.\r\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\r\n     *\r\n     * This ONLY impacts refraction. If not provided or given a non-valid value,\r\n     * the volume will use the same IOR as the surface.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public get volumeIndexOfRefraction(): number {\r\n        if (this._volumeIndexOfRefraction >= 1.0) {\r\n            return this._volumeIndexOfRefraction;\r\n        }\r\n        return this._indexOfRefraction;\r\n    }\r\n    public set volumeIndexOfRefraction(value: number) {\r\n        if (value >= 1.0) {\r\n            this._volumeIndexOfRefraction = value;\r\n        } else {\r\n            this._volumeIndexOfRefraction = -1.0;\r\n        }\r\n    }\r\n\r\n    private _invertRefractionY = false;\r\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertRefractionY = false;\r\n\r\n    /** @internal */\r\n    public _linkRefractionWithTransparency = false;\r\n    /**\r\n     * This parameters will make the material used its opacity to control how much it is refracting against not.\r\n     * Materials half opaque for instance using refraction could benefit from this control.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public linkRefractionWithTransparency = false;\r\n\r\n    /**\r\n     * Defines the minimum thickness stored in the thickness map.\r\n     * If no thickness map is defined, this value will be used to simulate thickness.\r\n     */\r\n    @serialize()\r\n    public minimumThickness: number = 0;\r\n\r\n    /**\r\n     * Defines the maximum thickness stored in the thickness map.\r\n     */\r\n    @serialize()\r\n    public maximumThickness: number = 1;\r\n\r\n    /**\r\n     * Defines that the thickness should be used as a measure of the depth volume.\r\n     */\r\n    @serialize()\r\n    public useThicknessAsDepth = false;\r\n\r\n    /**\r\n     * Defines the volume tint of the material.\r\n     * This is used for both translucency and scattering.\r\n     */\r\n    @serializeAsColor3()\r\n    public tintColor = Color3.White();\r\n\r\n    /**\r\n     * Defines the distance at which the tint color should be found in the media.\r\n     * This is used for refraction only.\r\n     */\r\n    @serialize()\r\n    public tintColorAtDistance = 1;\r\n\r\n    /**\r\n     * Defines how far each channel transmit through the media.\r\n     * It is defined as a color to simplify it selection.\r\n     */\r\n    @serializeAsColor3()\r\n    public diffusionDistance = Color3.White();\r\n\r\n    private _useMaskFromThicknessTexture = false;\r\n    /**\r\n     * Stores the intensity of the different subsurface effects in the thickness texture.\r\n     * Note that if refractionIntensityTexture and/or translucencyIntensityTexture is provided it takes precedence over thicknessTexture + useMaskFromThicknessTexture\r\n     * * the green (red if useGltfStyleTextures = true) channel is the refraction intensity.\r\n     * * the blue channel is the translucency intensity.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useMaskFromThicknessTexture: boolean = false;\r\n\r\n    private _refractionIntensityTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the intensity of the refraction. If provided, it takes precedence over thicknessTexture + useMaskFromThicknessTexture\r\n     * * the green (red if useGltfStyleTextures = true) channel is the refraction intensity.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public refractionIntensityTexture: Nullable<BaseTexture> = null;\r\n\r\n    private _translucencyIntensityTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the intensity of the translucency. If provided, it takes precedence over thicknessTexture + useMaskFromThicknessTexture\r\n     * * the blue channel is the translucency intensity.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public translucencyIntensityTexture: Nullable<BaseTexture> = null;\r\n\r\n    private _scene: Scene;\r\n    private _useGltfStyleTextures = false;\r\n    /**\r\n     * Use channels layout used by glTF:\r\n     * * thicknessTexture: the green (instead of red) channel is the thickness\r\n     * * thicknessTexture/refractionIntensityTexture: the red (instead of green) channel is the refraction intensity\r\n     * * thicknessTexture/translucencyIntensityTexture: no change, use the blue channel for the translucency intensity\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useGltfStyleTextures: boolean = false;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n    private _internalMarkScenePrePassDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n    /** @internal */\r\n    public _markScenePrePassDirty(): void {\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n        this._internalMarkScenePrePassDirty();\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial, addToPluginList = true) {\r\n        super(material, \"PBRSubSurface\", 130, new MaterialSubSurfaceDefines(), addToPluginList);\r\n\r\n        this._scene = material.getScene();\r\n        this.registerForExtraEvents = true;\r\n\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\r\n        this._internalMarkScenePrePassDirty = material._dirtyCallbacks[Constants.MATERIAL_PrePassDirtyFlag];\r\n    }\r\n\r\n    public isReadyForSubMesh(defines: MaterialSubSurfaceDefines, scene: Scene): boolean {\r\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\r\n            return true;\r\n        }\r\n\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                    if (!this._thicknessTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                const refractionTexture = this._getRefractionTexture(scene);\r\n                if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                    if (!refractionTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public prepareDefinesBeforeAttributes(defines: MaterialSubSurfaceDefines, scene: Scene): void {\r\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\r\n            defines.SUBSURFACE = false;\r\n            defines.SS_TRANSLUCENCY = false;\r\n            defines.SS_SCATTERING = false;\r\n            defines.SS_REFRACTION = false;\r\n            defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;\r\n            defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;\r\n            defines.SS_THICKNESSANDMASK_TEXTURE = false;\r\n            defines.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;\r\n            defines.SS_HAS_THICKNESS = false;\r\n            defines.SS_REFRACTIONINTENSITY_TEXTURE = false;\r\n            defines.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;\r\n            defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\r\n            defines.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;\r\n            defines.SS_REFRACTIONMAP_3D = false;\r\n            defines.SS_REFRACTIONMAP_OPPOSITEZ = false;\r\n            defines.SS_LODINREFRACTIONALPHA = false;\r\n            defines.SS_GAMMAREFRACTION = false;\r\n            defines.SS_RGBDREFRACTION = false;\r\n            defines.SS_LINEARSPECULARREFRACTION = false;\r\n            defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;\r\n            defines.SS_ALBEDOFORREFRACTIONTINT = false;\r\n            defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;\r\n            defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\r\n            defines.SS_USE_THICKNESS_AS_DEPTH = false;\r\n            defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;\r\n            defines.SS_USE_GLTF_TEXTURES = false;\r\n            return;\r\n        }\r\n\r\n        if (defines._areTexturesDirty) {\r\n            defines.SUBSURFACE = true;\r\n\r\n            defines.SS_TRANSLUCENCY = this._isTranslucencyEnabled;\r\n            defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;\r\n            defines.SS_SCATTERING = this._isScatteringEnabled;\r\n            defines.SS_THICKNESSANDMASK_TEXTURE = false;\r\n            defines.SS_REFRACTIONINTENSITY_TEXTURE = false;\r\n            defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\r\n            defines.SS_HAS_THICKNESS = false;\r\n            defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;\r\n            defines.SS_USE_GLTF_TEXTURES = false;\r\n            defines.SS_REFRACTION = false;\r\n            defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;\r\n            defines.SS_REFRACTIONMAP_3D = false;\r\n            defines.SS_GAMMAREFRACTION = false;\r\n            defines.SS_RGBDREFRACTION = false;\r\n            defines.SS_LINEARSPECULARREFRACTION = false;\r\n            defines.SS_REFRACTIONMAP_OPPOSITEZ = false;\r\n            defines.SS_LODINREFRACTIONALPHA = false;\r\n            defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;\r\n            defines.SS_ALBEDOFORREFRACTIONTINT = false;\r\n            defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;\r\n            defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\r\n            defines.SS_USE_THICKNESS_AS_DEPTH = false;\r\n\r\n            const refractionIntensityTextureIsThicknessTexture =\r\n                !!this._thicknessTexture &&\r\n                !!this._refractionIntensityTexture &&\r\n                this._refractionIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture) &&\r\n                this._refractionIntensityTexture._texture === this._thicknessTexture._texture;\r\n\r\n            const translucencyIntensityTextureIsThicknessTexture =\r\n                !!this._thicknessTexture &&\r\n                !!this._translucencyIntensityTexture &&\r\n                this._translucencyIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture) &&\r\n                this._translucencyIntensityTexture._texture === this._thicknessTexture._texture;\r\n\r\n            // if true, it means the refraction/translucency textures are the same than the thickness texture so there's no need to pass them to the shader, only thicknessTexture\r\n            const useOnlyThicknessTexture =\r\n                (refractionIntensityTextureIsThicknessTexture || !this._refractionIntensityTexture) &&\r\n                (translucencyIntensityTextureIsThicknessTexture || !this._translucencyIntensityTexture);\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (scene.texturesEnabled) {\r\n                    if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._thicknessTexture, defines, \"SS_THICKNESSANDMASK_TEXTURE\");\r\n                    }\r\n\r\n                    if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && !useOnlyThicknessTexture) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._refractionIntensityTexture, defines, \"SS_REFRACTIONINTENSITY_TEXTURE\");\r\n                    }\r\n\r\n                    if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && !useOnlyThicknessTexture) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._translucencyIntensityTexture, defines, \"SS_TRANSLUCENCYINTENSITY_TEXTURE\");\r\n                    }\r\n                }\r\n            }\r\n\r\n            defines.SS_HAS_THICKNESS = this.maximumThickness - this.minimumThickness !== 0.0;\r\n            defines.SS_MASK_FROM_THICKNESS_TEXTURE =\r\n                (this._useMaskFromThicknessTexture || !!this._refractionIntensityTexture || !!this._translucencyIntensityTexture) && useOnlyThicknessTexture;\r\n            defines.SS_USE_GLTF_TEXTURES = this._useGltfStyleTextures;\r\n            defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = (this._useMaskFromThicknessTexture || !!this._refractionIntensityTexture) && useOnlyThicknessTexture;\r\n            defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = (this._useMaskFromThicknessTexture || !!this._translucencyIntensityTexture) && useOnlyThicknessTexture;\r\n\r\n            if (this._isRefractionEnabled) {\r\n                if (scene.texturesEnabled) {\r\n                    const refractionTexture = this._getRefractionTexture(scene);\r\n                    if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                        defines.SS_REFRACTION = true;\r\n                        defines.SS_REFRACTIONMAP_3D = refractionTexture.isCube;\r\n                        defines.SS_GAMMAREFRACTION = refractionTexture.gammaSpace;\r\n                        defines.SS_RGBDREFRACTION = refractionTexture.isRGBD;\r\n                        defines.SS_LINEARSPECULARREFRACTION = refractionTexture.linearSpecularLOD;\r\n                        defines.SS_REFRACTIONMAP_OPPOSITEZ = this._scene.useRightHandedSystem && refractionTexture.isCube ? !refractionTexture.invertZ : refractionTexture.invertZ;\r\n                        defines.SS_LODINREFRACTIONALPHA = refractionTexture.lodLevelInAlpha;\r\n                        defines.SS_LINKREFRACTIONTOTRANSPARENCY = this._linkRefractionWithTransparency;\r\n                        defines.SS_ALBEDOFORREFRACTIONTINT = this.useAlbedoToTintRefraction;\r\n                        defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = refractionTexture.isCube && (<any>refractionTexture).boundingBoxSize;\r\n                        defines.SS_USE_THICKNESS_AS_DEPTH = this.useThicknessAsDepth;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this._isTranslucencyEnabled) {\r\n                defines.SS_ALBEDOFORTRANSLUCENCYTINT = this.useAlbedoToTintTranslucency;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the material data (this function is called even if mustRebind() returns false)\r\n     * @param uniformBuffer defines the Uniform buffer to fill in.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @param engine defines the engine the material belongs to.\r\n     * @param subMesh the submesh to bind data for\r\n     */\r\n    public hardBindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, subMesh: SubMesh): void {\r\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\r\n            return;\r\n        }\r\n\r\n        subMesh.getRenderingMesh().getWorldMatrix().decompose(TmpVectors.Vector3[0]);\r\n\r\n        const thicknessScale = Math.max(Math.abs(TmpVectors.Vector3[0].x), Math.abs(TmpVectors.Vector3[0].y), Math.abs(TmpVectors.Vector3[0].z));\r\n\r\n        uniformBuffer.updateFloat2(\"vThicknessParam\", this.minimumThickness * thicknessScale, (this.maximumThickness - this.minimumThickness) * thicknessScale);\r\n    }\r\n\r\n    public bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, subMesh: SubMesh): void {\r\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\r\n            return;\r\n        }\r\n\r\n        const defines = subMesh!.materialDefines as unknown as MaterialSubSurfaceDefines;\r\n\r\n        const isFrozen = this._material.isFrozen;\r\n        const realTimeFiltering = this._material.realTimeFiltering;\r\n        const lodBasedMicrosurface = defines.LODBASEDMICROSFURACE;\r\n\r\n        const refractionTexture = this._getRefractionTexture(scene);\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                uniformBuffer.updateFloat2(\"vThicknessInfos\", this._thicknessTexture.coordinatesIndex, this._thicknessTexture.level);\r\n                MaterialHelper.BindTextureMatrix(this._thicknessTexture, uniformBuffer, \"thickness\");\r\n            }\r\n\r\n            if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {\r\n                uniformBuffer.updateFloat2(\"vRefractionIntensityInfos\", this._refractionIntensityTexture.coordinatesIndex, this._refractionIntensityTexture.level);\r\n                MaterialHelper.BindTextureMatrix(this._refractionIntensityTexture, uniformBuffer, \"refractionIntensity\");\r\n            }\r\n\r\n            if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {\r\n                uniformBuffer.updateFloat2(\"vTranslucencyIntensityInfos\", this._translucencyIntensityTexture.coordinatesIndex, this._translucencyIntensityTexture.level);\r\n                MaterialHelper.BindTextureMatrix(this._translucencyIntensityTexture, uniformBuffer, \"translucencyIntensity\");\r\n            }\r\n\r\n            if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                uniformBuffer.updateMatrix(\"refractionMatrix\", refractionTexture.getRefractionTextureMatrix());\r\n\r\n                let depth = 1.0;\r\n                if (!refractionTexture.isCube) {\r\n                    if ((<any>refractionTexture).depth) {\r\n                        depth = (<any>refractionTexture).depth;\r\n                    }\r\n                }\r\n\r\n                const width = refractionTexture.getSize().width;\r\n                const refractionIor = this.volumeIndexOfRefraction;\r\n                uniformBuffer.updateFloat4(\"vRefractionInfos\", refractionTexture.level, 1 / refractionIor, depth, this._invertRefractionY ? -1 : 1);\r\n                uniformBuffer.updateFloat4(\r\n                    \"vRefractionMicrosurfaceInfos\",\r\n                    width,\r\n                    refractionTexture.lodGenerationScale,\r\n                    refractionTexture.lodGenerationOffset,\r\n                    1.0 / this.indexOfRefraction\r\n                );\r\n\r\n                if (realTimeFiltering) {\r\n                    uniformBuffer.updateFloat2(\"vRefractionFilteringInfo\", width, Scalar.Log2(width));\r\n                }\r\n\r\n                if ((<any>refractionTexture).boundingBoxSize) {\r\n                    const cubeTexture = <CubeTexture>refractionTexture;\r\n\r\n                    uniformBuffer.updateVector3(\"vRefractionPosition\", cubeTexture.boundingBoxPosition);\r\n                    uniformBuffer.updateVector3(\"vRefractionSize\", cubeTexture.boundingBoxSize);\r\n                }\r\n            }\r\n\r\n            if (this._isScatteringEnabled) {\r\n                uniformBuffer.updateFloat(\"scatteringDiffusionProfile\", this._scatteringDiffusionProfileIndex);\r\n            }\r\n            uniformBuffer.updateColor3(\"vDiffusionDistance\", this.diffusionDistance);\r\n\r\n            uniformBuffer.updateFloat4(\"vTintColor\", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(0.00001, this.tintColorAtDistance));\r\n\r\n            uniformBuffer.updateFloat3(\"vSubSurfaceIntensity\", this.refractionIntensity, this.translucencyIntensity, 0);\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                uniformBuffer.setTexture(\"thicknessSampler\", this._thicknessTexture);\r\n            }\r\n\r\n            if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {\r\n                uniformBuffer.setTexture(\"refractionIntensitySampler\", this._refractionIntensityTexture);\r\n            }\r\n\r\n            if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {\r\n                uniformBuffer.setTexture(\"translucencyIntensitySampler\", this._translucencyIntensityTexture);\r\n            }\r\n\r\n            if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                if (lodBasedMicrosurface) {\r\n                    uniformBuffer.setTexture(\"refractionSampler\", refractionTexture);\r\n                } else {\r\n                    uniformBuffer.setTexture(\"refractionSampler\", refractionTexture._lodTextureMid || refractionTexture);\r\n                    uniformBuffer.setTexture(\"refractionSamplerLow\", refractionTexture._lodTextureLow || refractionTexture);\r\n                    uniformBuffer.setTexture(\"refractionSamplerHigh\", refractionTexture._lodTextureHigh || refractionTexture);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the texture used for refraction or null if none is used.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @returns - Refraction texture if present.  If no refraction texture and refraction\r\n     * is linked with transparency, returns environment texture.  Otherwise, returns null.\r\n     */\r\n    private _getRefractionTexture(scene: Scene): Nullable<BaseTexture> {\r\n        if (this._refractionTexture) {\r\n            return this._refractionTexture;\r\n        }\r\n\r\n        if (this._isRefractionEnabled) {\r\n            return scene.environmentTexture;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns true if alpha blending should be disabled.\r\n     */\r\n    public get disableAlphaBlending(): boolean {\r\n        return this._isRefractionEnabled && this._linkRefractionWithTransparency;\r\n    }\r\n\r\n    /**\r\n     * Fills the list of render target textures.\r\n     * @param renderTargets the list of render targets to update\r\n     */\r\n    public fillRenderTargetTextures(renderTargets: SmartArray<RenderTargetTexture>): void {\r\n        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n            renderTargets.push(<RenderTargetTexture>this._refractionTexture);\r\n        }\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (this._thicknessTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._refractionTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public hasRenderTargetTextures(): boolean {\r\n        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._thicknessTexture) {\r\n            activeTextures.push(this._thicknessTexture);\r\n        }\r\n\r\n        if (this._refractionTexture) {\r\n            activeTextures.push(this._refractionTexture);\r\n        }\r\n    }\r\n\r\n    public getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {\r\n            animatables.push(this._thicknessTexture);\r\n        }\r\n\r\n        if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {\r\n            animatables.push(this._refractionTexture);\r\n        }\r\n    }\r\n\r\n    public dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            if (this._thicknessTexture) {\r\n                this._thicknessTexture.dispose();\r\n            }\r\n\r\n            if (this._refractionTexture) {\r\n                this._refractionTexture.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"PBRSubSurfaceConfiguration\";\r\n    }\r\n\r\n    public addFallbacks(defines: MaterialSubSurfaceDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        if (defines.SS_SCATTERING) {\r\n            fallbacks.addFallback(currentRank++, \"SS_SCATTERING\");\r\n        }\r\n        if (defines.SS_TRANSLUCENCY) {\r\n            fallbacks.addFallback(currentRank++, \"SS_TRANSLUCENCY\");\r\n        }\r\n        return currentRank;\r\n    }\r\n\r\n    public getSamplers(samplers: string[]): void {\r\n        samplers.push(\"thicknessSampler\", \"refractionIntensitySampler\", \"translucencyIntensitySampler\", \"refractionSampler\", \"refractionSamplerLow\", \"refractionSamplerHigh\");\r\n    }\r\n\r\n    public getUniforms(): { ubo?: Array<{ name: string; size: number; type: string }>; vertex?: string; fragment?: string } {\r\n        return {\r\n            ubo: [\r\n                { name: \"vRefractionMicrosurfaceInfos\", size: 4, type: \"vec4\" },\r\n                { name: \"vRefractionFilteringInfo\", size: 2, type: \"vec2\" },\r\n                { name: \"vTranslucencyIntensityInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"vRefractionInfos\", size: 4, type: \"vec4\" },\r\n                { name: \"refractionMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"vThicknessInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"vRefractionIntensityInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"thicknessMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"refractionIntensityMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"translucencyIntensityMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"vThicknessParam\", size: 2, type: \"vec2\" },\r\n                { name: \"vDiffusionDistance\", size: 3, type: \"vec3\" },\r\n                { name: \"vTintColor\", size: 4, type: \"vec4\" },\r\n                { name: \"vSubSurfaceIntensity\", size: 3, type: \"vec3\" },\r\n                { name: \"vRefractionPosition\", size: 3, type: \"vec3\" },\r\n                { name: \"vRefractionSize\", size: 3, type: \"vec3\" },\r\n                { name: \"scatteringDiffusionProfile\", size: 1, type: \"float\" },\r\n            ],\r\n        };\r\n    }\r\n}\r\n"],"mappings":";;AAGA,SAASA,SAAS,EAAEC,kBAAkB,EAAEC,gBAAgB,EAAEC,iBAAiB,QAAQ,0BAAwB;AAC3G,SAASC,MAAM,QAAQ,2BAAyB;AAIhD,SAASC,aAAa,QAAQ,qBAAmB;AAEjD,SAASC,cAAc,QAAQ,mCAAiC;AAEhE,SAASC,MAAM,QAAQ,4BAA0B;AAEjD,SAASC,UAAU,QAAQ,4BAA0B;AAErD,SAASC,kBAAkB,QAAQ,0BAAwB;AAE3D,SAASC,eAAe,QAAQ,uBAAqB;AAMrD;;;AAGA,OAAM,MAAOC,yBAA0B,SAAQD,eAAe;EAA9DE,YAAA;;IACW,KAAAC,UAAU,GAAG,KAAK;IAElB,KAAAC,aAAa,GAAG,KAAK;IACrB,KAAAC,wCAAwC,GAAG,KAAK;IAChD,KAAAC,eAAe,GAAG,KAAK;IACvB,KAAAC,0CAA0C,GAAG,KAAK;IAClD,KAAAC,aAAa,GAAG,KAAK;IAErB,KAAAC,2BAA2B,GAAG,KAAK;IACnC,KAAAC,mCAAmC,GAAG,CAAC;IACvC,KAAAC,gBAAgB,GAAG,KAAK;IACxB,KAAAC,8BAA8B,GAAG,KAAK;IACtC,KAAAC,sCAAsC,GAAG,CAAC;IAC1C,KAAAC,gCAAgC,GAAG,KAAK;IACxC,KAAAC,wCAAwC,GAAG,CAAC;IAE5C,KAAAC,mBAAmB,GAAG,KAAK;IAC3B,KAAAC,0BAA0B,GAAG,KAAK;IAClC,KAAAC,uBAAuB,GAAG,KAAK;IAC/B,KAAAC,kBAAkB,GAAG,KAAK;IAC1B,KAAAC,iBAAiB,GAAG,KAAK;IACzB,KAAAC,2BAA2B,GAAG,KAAK;IACnC,KAAAC,+BAA+B,GAAG,KAAK;IACvC,KAAAC,0BAA0B,GAAG,KAAK;IAClC,KAAAC,4BAA4B,GAAG,KAAK;IACpC,KAAAC,gCAAgC,GAAG,KAAK;IACxC,KAAAC,yBAAyB,GAAG,KAAK;IAEjC,KAAAC,8BAA8B,GAAG,KAAK;IACtC,KAAAC,oBAAoB,GAAG,KAAK;EACvC;;AAEA;;;AAGA,OAAM,MAAOC,0BAA2B,SAAQ9B,kBAAkB;EA8B9D;;;;EAIA,IAAW+B,0BAA0BA,CAAA;IACjC,IAAI,CAAC,IAAI,CAACC,MAAM,CAACC,uBAAuB,EAAE;MACtC,OAAO,IAAI;;IAGf,OAAO,IAAI,CAACD,MAAM,CAACC,uBAAuB,CAACC,wBAAwB,CAAC,IAAI,CAACC,gCAAgC,CAAC;EAC9G;EAEA,IAAWJ,0BAA0BA,CAACK,CAAmB;IACrD,IAAI,CAAC,IAAI,CAACJ,MAAM,CAACK,0BAA0B,EAAE,EAAE;MAC3C;MACA;;IAGJ;IACA,IAAID,CAAC,EAAE;MACH,IAAI,CAACD,gCAAgC,GAAG,IAAI,CAACH,MAAM,CAACC,uBAAwB,CAACK,mBAAmB,CAACF,CAAC,CAAC;;EAE3G;EAmEA;;;;;;;EAQA,IAAWG,uBAAuBA,CAAA;IAC9B,IAAI,IAAI,CAACC,wBAAwB,IAAI,GAAG,EAAE;MACtC,OAAO,IAAI,CAACA,wBAAwB;;IAExC,OAAO,IAAI,CAACC,kBAAkB;EAClC;EACA,IAAWF,uBAAuBA,CAACG,KAAa;IAC5C,IAAIA,KAAK,IAAI,GAAG,EAAE;MACd,IAAI,CAACF,wBAAwB,GAAGE,KAAK;KACxC,MAAM;MACH,IAAI,CAACF,wBAAwB,GAAG,CAAC,GAAG;;EAE5C;EAyGA;EACOG,gCAAgCA,CAAA;IACnC,IAAI,CAACC,OAAO,CAAC,IAAI,CAACC,oBAAoB,IAAI,IAAI,CAACC,sBAAsB,IAAI,IAAI,CAACC,oBAAoB,CAAC;IACnG,IAAI,CAACC,wCAAwC,EAAE;EACnD;EACA;EACOC,sBAAsBA,CAAA;IACzB,IAAI,CAACD,wCAAwC,EAAE;IAC/C,IAAI,CAACE,8BAA8B,EAAE;EACzC;EAEA/C,YAAYgD,QAAyB,EAAEC,eAAe,GAAG,IAAI;IACzD,KAAK,CAACD,QAAQ,EAAE,eAAe,EAAE,GAAG,EAAE,IAAIjD,yBAAyB,EAAE,EAAEkD,eAAe,CAAC;IA7PnF,KAAAP,oBAAoB,GAAG,KAAK;IACpC;;;IAKO,KAAAQ,mBAAmB,GAAG,KAAK;IAE1B,KAAAP,sBAAsB,GAAG,KAAK;IACtC;;;IAKO,KAAAQ,qBAAqB,GAAG,KAAK;IAE5B,KAAAP,oBAAoB,GAAG,KAAK;IACpC;;;IAKO,KAAAQ,mBAAmB,GAAG,KAAK;IAG1B,KAAApB,gCAAgC,GAAG,CAAC;IA0B5C;;;;;IAMO,KAAAqB,mBAAmB,GAAW,CAAC;IAEtC;;;;;IAMO,KAAAC,qBAAqB,GAAW,CAAC;IAExC;;;IAIO,KAAAC,yBAAyB,GAAY,KAAK;IAEjD;;;IAIO,KAAAC,2BAA2B,GAAY,KAAK;IAE3C,KAAAC,iBAAiB,GAA0B,IAAI;IACvD;;;;;;;IASO,KAAAC,gBAAgB,GAA0B,IAAI;IAE7C,KAAAC,kBAAkB,GAA0B,IAAI;IACxD;;;IAKO,KAAAC,iBAAiB,GAA0B,IAAI;IAEtD;IACO,KAAAtB,kBAAkB,GAAG,GAAG;IAC/B;;;;;;;;IAUO,KAAAuB,iBAAiB,GAAG,GAAG;IAGtB,KAAAxB,wBAAwB,GAAG,CAAC,GAAG;IAwB/B,KAAAyB,kBAAkB,GAAG,KAAK;IAClC;;;IAKO,KAAAC,iBAAiB,GAAG,KAAK;IAEhC;IACO,KAAAC,+BAA+B,GAAG,KAAK;IAC9C;;;;IAMO,KAAAC,8BAA8B,GAAG,KAAK;IAE7C;;;;IAKO,KAAAC,gBAAgB,GAAW,CAAC;IAEnC;;;IAIO,KAAAC,gBAAgB,GAAW,CAAC;IAEnC;;;IAIO,KAAAC,mBAAmB,GAAG,KAAK;IAElC;;;;IAKO,KAAAC,SAAS,GAAG7E,MAAM,CAAC8E,KAAK,EAAE;IAEjC;;;;IAKO,KAAAC,mBAAmB,GAAG,CAAC;IAE9B;;;;IAKO,KAAAC,iBAAiB,GAAGhF,MAAM,CAAC8E,KAAK,EAAE;IAEjC,KAAAG,4BAA4B,GAAG,KAAK;IAC5C;;;;;;IAQO,KAAAC,2BAA2B,GAAY,KAAK;IAE3C,KAAAC,2BAA2B,GAA0B,IAAI;IACjE;;;;IAMO,KAAAC,0BAA0B,GAA0B,IAAI;IAEvD,KAAAC,6BAA6B,GAA0B,IAAI;IACnE;;;;IAMO,KAAAC,4BAA4B,GAA0B,IAAI;IAGzD,KAAAC,qBAAqB,GAAG,KAAK;IACrC;;;;;;IAQO,KAAAC,oBAAoB,GAAY,KAAK;IAoBxC,IAAI,CAACnD,MAAM,GAAGmB,QAAQ,CAACiC,QAAQ,EAAE;IACjC,IAAI,CAACC,sBAAsB,GAAG,IAAI;IAElC,IAAI,CAACrC,wCAAwC,GAAGG,QAAQ,CAACmC,eAAe,CAAC;IACzE,IAAI,CAACpC,8BAA8B,GAAGC,QAAQ,CAACmC,eAAe,CAAC;EACnE;EAEOC,iBAAiBA,CAACC,OAAkC,EAAEC,KAAY;IACrE,IAAI,CAAC,IAAI,CAAC5C,oBAAoB,IAAI,CAAC,IAAI,CAACC,sBAAsB,IAAI,CAAC,IAAI,CAACC,oBAAoB,EAAE;MAC1F,OAAO,IAAI;;IAGf,IAAIyC,OAAO,CAACE,iBAAiB,EAAE;MAC3B,IAAID,KAAK,CAACE,eAAe,EAAE;QACvB,IAAI,IAAI,CAAC/B,iBAAiB,IAAIhE,aAAa,CAACgG,uBAAuB,EAAE;UACjE,IAAI,CAAC,IAAI,CAAChC,iBAAiB,CAACiC,oBAAoB,EAAE,EAAE;YAChD,OAAO,KAAK;;;QAIpB,MAAM9B,iBAAiB,GAAG,IAAI,CAAC+B,qBAAqB,CAACL,KAAK,CAAC;QAC3D,IAAI1B,iBAAiB,IAAInE,aAAa,CAACmG,wBAAwB,EAAE;UAC7D,IAAI,CAAChC,iBAAiB,CAAC8B,oBAAoB,EAAE,EAAE;YAC3C,OAAO,KAAK;;;;;IAM5B,OAAO,IAAI;EACf;EAEOG,8BAA8BA,CAACR,OAAkC,EAAEC,KAAY;IAClF,IAAI,CAAC,IAAI,CAAC5C,oBAAoB,IAAI,CAAC,IAAI,CAACC,sBAAsB,IAAI,CAAC,IAAI,CAACC,oBAAoB,EAAE;MAC1FyC,OAAO,CAACpF,UAAU,GAAG,KAAK;MAC1BoF,OAAO,CAACjF,eAAe,GAAG,KAAK;MAC/BiF,OAAO,CAAC/E,aAAa,GAAG,KAAK;MAC7B+E,OAAO,CAACnF,aAAa,GAAG,KAAK;MAC7BmF,OAAO,CAAClF,wCAAwC,GAAG,KAAK;MACxDkF,OAAO,CAAChF,0CAA0C,GAAG,KAAK;MAC1DgF,OAAO,CAAC9E,2BAA2B,GAAG,KAAK;MAC3C8E,OAAO,CAAC7E,mCAAmC,GAAG,CAAC;MAC/C6E,OAAO,CAAC5E,gBAAgB,GAAG,KAAK;MAChC4E,OAAO,CAAC3E,8BAA8B,GAAG,KAAK;MAC9C2E,OAAO,CAAC1E,sCAAsC,GAAG,CAAC;MAClD0E,OAAO,CAACzE,gCAAgC,GAAG,KAAK;MAChDyE,OAAO,CAACxE,wCAAwC,GAAG,CAAC;MACpDwE,OAAO,CAACvE,mBAAmB,GAAG,KAAK;MACnCuE,OAAO,CAACtE,0BAA0B,GAAG,KAAK;MAC1CsE,OAAO,CAACrE,uBAAuB,GAAG,KAAK;MACvCqE,OAAO,CAACpE,kBAAkB,GAAG,KAAK;MAClCoE,OAAO,CAACnE,iBAAiB,GAAG,KAAK;MACjCmE,OAAO,CAAClE,2BAA2B,GAAG,KAAK;MAC3CkE,OAAO,CAACjE,+BAA+B,GAAG,KAAK;MAC/CiE,OAAO,CAAChE,0BAA0B,GAAG,KAAK;MAC1CgE,OAAO,CAAC/D,4BAA4B,GAAG,KAAK;MAC5C+D,OAAO,CAAC9D,gCAAgC,GAAG,KAAK;MAChD8D,OAAO,CAAC7D,yBAAyB,GAAG,KAAK;MACzC6D,OAAO,CAAC5D,8BAA8B,GAAG,KAAK;MAC9C4D,OAAO,CAAC3D,oBAAoB,GAAG,KAAK;MACpC;;IAGJ,IAAI2D,OAAO,CAACE,iBAAiB,EAAE;MAC3BF,OAAO,CAACpF,UAAU,GAAG,IAAI;MAEzBoF,OAAO,CAACjF,eAAe,GAAG,IAAI,CAACuC,sBAAsB;MACrD0C,OAAO,CAAChF,0CAA0C,GAAG,KAAK;MAC1DgF,OAAO,CAAC/E,aAAa,GAAG,IAAI,CAACsC,oBAAoB;MACjDyC,OAAO,CAAC9E,2BAA2B,GAAG,KAAK;MAC3C8E,OAAO,CAAC3E,8BAA8B,GAAG,KAAK;MAC9C2E,OAAO,CAACzE,gCAAgC,GAAG,KAAK;MAChDyE,OAAO,CAAC5E,gBAAgB,GAAG,KAAK;MAChC4E,OAAO,CAAC5D,8BAA8B,GAAG,KAAK;MAC9C4D,OAAO,CAAC3D,oBAAoB,GAAG,KAAK;MACpC2D,OAAO,CAACnF,aAAa,GAAG,KAAK;MAC7BmF,OAAO,CAAClF,wCAAwC,GAAG,KAAK;MACxDkF,OAAO,CAACvE,mBAAmB,GAAG,KAAK;MACnCuE,OAAO,CAACpE,kBAAkB,GAAG,KAAK;MAClCoE,OAAO,CAACnE,iBAAiB,GAAG,KAAK;MACjCmE,OAAO,CAAClE,2BAA2B,GAAG,KAAK;MAC3CkE,OAAO,CAACtE,0BAA0B,GAAG,KAAK;MAC1CsE,OAAO,CAACrE,uBAAuB,GAAG,KAAK;MACvCqE,OAAO,CAACjE,+BAA+B,GAAG,KAAK;MAC/CiE,OAAO,CAAChE,0BAA0B,GAAG,KAAK;MAC1CgE,OAAO,CAAC/D,4BAA4B,GAAG,KAAK;MAC5C+D,OAAO,CAAC9D,gCAAgC,GAAG,KAAK;MAChD8D,OAAO,CAAC7D,yBAAyB,GAAG,KAAK;MAEzC,MAAMsE,4CAA4C,GAC9C,CAAC,CAAC,IAAI,CAACrC,iBAAiB,IACxB,CAAC,CAAC,IAAI,CAACkB,2BAA2B,IAClC,IAAI,CAACA,2BAA2B,CAACoB,2BAA2B,CAAC,IAAI,CAACtC,iBAAiB,CAAC,IACpF,IAAI,CAACkB,2BAA2B,CAACqB,QAAQ,KAAK,IAAI,CAACvC,iBAAiB,CAACuC,QAAQ;MAEjF,MAAMC,8CAA8C,GAChD,CAAC,CAAC,IAAI,CAACxC,iBAAiB,IACxB,CAAC,CAAC,IAAI,CAACoB,6BAA6B,IACpC,IAAI,CAACA,6BAA6B,CAACkB,2BAA2B,CAAC,IAAI,CAACtC,iBAAiB,CAAC,IACtF,IAAI,CAACoB,6BAA6B,CAACmB,QAAQ,KAAK,IAAI,CAACvC,iBAAiB,CAACuC,QAAQ;MAEnF;MACA,MAAME,uBAAuB,GACzB,CAACJ,4CAA4C,IAAI,CAAC,IAAI,CAACnB,2BAA2B,MACjFsB,8CAA8C,IAAI,CAAC,IAAI,CAACpB,6BAA6B,CAAC;MAE3F,IAAIQ,OAAO,CAACE,iBAAiB,EAAE;QAC3B,IAAID,KAAK,CAACE,eAAe,EAAE;UACvB,IAAI,IAAI,CAAC/B,iBAAiB,IAAIhE,aAAa,CAACgG,uBAAuB,EAAE;YACjE/F,cAAc,CAACyG,yBAAyB,CAAC,IAAI,CAAC1C,iBAAiB,EAAE4B,OAAO,EAAE,6BAA6B,CAAC;;UAG5G,IAAI,IAAI,CAACV,2BAA2B,IAAIlF,aAAa,CAAC2G,iCAAiC,IAAI,CAACF,uBAAuB,EAAE;YACjHxG,cAAc,CAACyG,yBAAyB,CAAC,IAAI,CAACxB,2BAA2B,EAAEU,OAAO,EAAE,gCAAgC,CAAC;;UAGzH,IAAI,IAAI,CAACR,6BAA6B,IAAIpF,aAAa,CAAC4G,mCAAmC,IAAI,CAACH,uBAAuB,EAAE;YACrHxG,cAAc,CAACyG,yBAAyB,CAAC,IAAI,CAACtB,6BAA6B,EAAEQ,OAAO,EAAE,kCAAkC,CAAC;;;;MAKrIA,OAAO,CAAC5E,gBAAgB,GAAG,IAAI,CAAC0D,gBAAgB,GAAG,IAAI,CAACD,gBAAgB,KAAK,GAAG;MAChFmB,OAAO,CAAC5D,8BAA8B,GAClC,CAAC,IAAI,CAACgD,4BAA4B,IAAI,CAAC,CAAC,IAAI,CAACE,2BAA2B,IAAI,CAAC,CAAC,IAAI,CAACE,6BAA6B,KAAKqB,uBAAuB;MAChJb,OAAO,CAAC3D,oBAAoB,GAAG,IAAI,CAACqD,qBAAqB;MACzDM,OAAO,CAAClF,wCAAwC,GAAG,CAAC,IAAI,CAACsE,4BAA4B,IAAI,CAAC,CAAC,IAAI,CAACE,2BAA2B,KAAKuB,uBAAuB;MACvJb,OAAO,CAAChF,0CAA0C,GAAG,CAAC,IAAI,CAACoE,4BAA4B,IAAI,CAAC,CAAC,IAAI,CAACI,6BAA6B,KAAKqB,uBAAuB;MAE3J,IAAI,IAAI,CAACxD,oBAAoB,EAAE;QAC3B,IAAI4C,KAAK,CAACE,eAAe,EAAE;UACvB,MAAM5B,iBAAiB,GAAG,IAAI,CAAC+B,qBAAqB,CAACL,KAAK,CAAC;UAC3D,IAAI1B,iBAAiB,IAAInE,aAAa,CAACmG,wBAAwB,EAAE;YAC7DP,OAAO,CAACnF,aAAa,GAAG,IAAI;YAC5BmF,OAAO,CAACvE,mBAAmB,GAAG8C,iBAAiB,CAAC0C,MAAM;YACtDjB,OAAO,CAACpE,kBAAkB,GAAG2C,iBAAiB,CAAC2C,UAAU;YACzDlB,OAAO,CAACnE,iBAAiB,GAAG0C,iBAAiB,CAAC4C,MAAM;YACpDnB,OAAO,CAAClE,2BAA2B,GAAGyC,iBAAiB,CAAC6C,iBAAiB;YACzEpB,OAAO,CAACtE,0BAA0B,GAAG,IAAI,CAACc,MAAM,CAAC6E,oBAAoB,IAAI9C,iBAAiB,CAAC0C,MAAM,GAAG,CAAC1C,iBAAiB,CAAC+C,OAAO,GAAG/C,iBAAiB,CAAC+C,OAAO;YAC1JtB,OAAO,CAACrE,uBAAuB,GAAG4C,iBAAiB,CAACgD,eAAe;YACnEvB,OAAO,CAACjE,+BAA+B,GAAG,IAAI,CAAC4C,+BAA+B;YAC9EqB,OAAO,CAAChE,0BAA0B,GAAG,IAAI,CAACkC,yBAAyB;YACnE8B,OAAO,CAAC9D,gCAAgC,GAAGqC,iBAAiB,CAAC0C,MAAM,IAAU1C,iBAAkB,CAACiD,eAAe;YAC/GxB,OAAO,CAAC7D,yBAAyB,GAAG,IAAI,CAAC4C,mBAAmB;;;;MAKxE,IAAI,IAAI,CAACzB,sBAAsB,EAAE;QAC7B0C,OAAO,CAAC/D,4BAA4B,GAAG,IAAI,CAACkC,2BAA2B;;;EAGnF;EAEA;;;;;;;EAOOsD,kBAAkBA,CAACC,aAA4B,EAAEzB,KAAY,EAAE0B,MAAc,EAAEC,OAAgB;IAClG,IAAI,CAAC,IAAI,CAACvE,oBAAoB,IAAI,CAAC,IAAI,CAACC,sBAAsB,IAAI,CAAC,IAAI,CAACC,oBAAoB,EAAE;MAC1F;;IAGJqE,OAAO,CAACC,gBAAgB,EAAE,CAACC,cAAc,EAAE,CAACC,SAAS,CAACxH,UAAU,CAACyH,OAAO,CAAC,CAAC,CAAC,CAAC;IAE5E,MAAMC,cAAc,GAAGC,IAAI,CAACC,GAAG,CAACD,IAAI,CAACE,GAAG,CAAC7H,UAAU,CAACyH,OAAO,CAAC,CAAC,CAAC,CAACK,CAAC,CAAC,EAAEH,IAAI,CAACE,GAAG,CAAC7H,UAAU,CAACyH,OAAO,CAAC,CAAC,CAAC,CAACM,CAAC,CAAC,EAAEJ,IAAI,CAACE,GAAG,CAAC7H,UAAU,CAACyH,OAAO,CAAC,CAAC,CAAC,CAACO,CAAC,CAAC,CAAC;IAExIb,aAAa,CAACc,YAAY,CAAC,iBAAiB,EAAE,IAAI,CAAC3D,gBAAgB,GAAGoD,cAAc,EAAE,CAAC,IAAI,CAACnD,gBAAgB,GAAG,IAAI,CAACD,gBAAgB,IAAIoD,cAAc,CAAC;EAC3J;EAEOQ,cAAcA,CAACf,aAA4B,EAAEzB,KAAY,EAAE0B,MAAc,EAAEC,OAAgB;IAC9F,IAAI,CAAC,IAAI,CAACvE,oBAAoB,IAAI,CAAC,IAAI,CAACC,sBAAsB,IAAI,CAAC,IAAI,CAACC,oBAAoB,EAAE;MAC1F;;IAGJ,MAAMyC,OAAO,GAAG4B,OAAQ,CAACc,eAAuD;IAEhF,MAAMC,QAAQ,GAAG,IAAI,CAACC,SAAS,CAACD,QAAQ;IACxC,MAAME,iBAAiB,GAAG,IAAI,CAACD,SAAS,CAACC,iBAAiB;IAC1D,MAAMC,oBAAoB,GAAG9C,OAAO,CAAC+C,oBAAoB;IAEzD,MAAMxE,iBAAiB,GAAG,IAAI,CAAC+B,qBAAqB,CAACL,KAAK,CAAC;IAE3D,IAAI,CAACyB,aAAa,CAACsB,MAAM,IAAI,CAACL,QAAQ,IAAI,CAACjB,aAAa,CAACuB,MAAM,EAAE;MAC7D,IAAI,IAAI,CAAC7E,iBAAiB,IAAIhE,aAAa,CAACgG,uBAAuB,EAAE;QACjEsB,aAAa,CAACc,YAAY,CAAC,iBAAiB,EAAE,IAAI,CAACpE,iBAAiB,CAAC8E,gBAAgB,EAAE,IAAI,CAAC9E,iBAAiB,CAAC+E,KAAK,CAAC;QACpH9I,cAAc,CAAC+I,iBAAiB,CAAC,IAAI,CAAChF,iBAAiB,EAAEsD,aAAa,EAAE,WAAW,CAAC;;MAGxF,IAAI,IAAI,CAACpC,2BAA2B,IAAIlF,aAAa,CAAC2G,iCAAiC,IAAIf,OAAO,CAAC3E,8BAA8B,EAAE;QAC/HqG,aAAa,CAACc,YAAY,CAAC,2BAA2B,EAAE,IAAI,CAAClD,2BAA2B,CAAC4D,gBAAgB,EAAE,IAAI,CAAC5D,2BAA2B,CAAC6D,KAAK,CAAC;QAClJ9I,cAAc,CAAC+I,iBAAiB,CAAC,IAAI,CAAC9D,2BAA2B,EAAEoC,aAAa,EAAE,qBAAqB,CAAC;;MAG5G,IAAI,IAAI,CAAClC,6BAA6B,IAAIpF,aAAa,CAAC4G,mCAAmC,IAAIhB,OAAO,CAACzE,gCAAgC,EAAE;QACrImG,aAAa,CAACc,YAAY,CAAC,6BAA6B,EAAE,IAAI,CAAChD,6BAA6B,CAAC0D,gBAAgB,EAAE,IAAI,CAAC1D,6BAA6B,CAAC2D,KAAK,CAAC;QACxJ9I,cAAc,CAAC+I,iBAAiB,CAAC,IAAI,CAAC5D,6BAA6B,EAAEkC,aAAa,EAAE,uBAAuB,CAAC;;MAGhH,IAAInD,iBAAiB,IAAInE,aAAa,CAACmG,wBAAwB,EAAE;QAC7DmB,aAAa,CAAC2B,YAAY,CAAC,kBAAkB,EAAE9E,iBAAiB,CAAC+E,0BAA0B,EAAE,CAAC;QAE9F,IAAIC,KAAK,GAAG,GAAG;QACf,IAAI,CAAChF,iBAAiB,CAAC0C,MAAM,EAAE;UAC3B,IAAU1C,iBAAkB,CAACgF,KAAK,EAAE;YAChCA,KAAK,GAAShF,iBAAkB,CAACgF,KAAK;;;QAI9C,MAAMC,KAAK,GAAGjF,iBAAiB,CAACkF,OAAO,EAAE,CAACD,KAAK;QAC/C,MAAME,aAAa,GAAG,IAAI,CAAC3G,uBAAuB;QAClD2E,aAAa,CAACiC,YAAY,CAAC,kBAAkB,EAAEpF,iBAAiB,CAAC4E,KAAK,EAAE,CAAC,GAAGO,aAAa,EAAEH,KAAK,EAAE,IAAI,CAAC9E,kBAAkB,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;QACnIiD,aAAa,CAACiC,YAAY,CACtB,8BAA8B,EAC9BH,KAAK,EACLjF,iBAAiB,CAACqF,kBAAkB,EACpCrF,iBAAiB,CAACsF,mBAAmB,EACrC,GAAG,GAAG,IAAI,CAACrF,iBAAiB,CAC/B;QAED,IAAIqE,iBAAiB,EAAE;UACnBnB,aAAa,CAACc,YAAY,CAAC,0BAA0B,EAAEgB,KAAK,EAAElJ,MAAM,CAACwJ,IAAI,CAACN,KAAK,CAAC,CAAC;;QAGrF,IAAUjF,iBAAkB,CAACiD,eAAe,EAAE;UAC1C,MAAMuC,WAAW,GAAgBxF,iBAAiB;UAElDmD,aAAa,CAACsC,aAAa,CAAC,qBAAqB,EAAED,WAAW,CAACE,mBAAmB,CAAC;UACnFvC,aAAa,CAACsC,aAAa,CAAC,iBAAiB,EAAED,WAAW,CAACvC,eAAe,CAAC;;;MAInF,IAAI,IAAI,CAACjE,oBAAoB,EAAE;QAC3BmE,aAAa,CAACwC,WAAW,CAAC,4BAA4B,EAAE,IAAI,CAACvH,gCAAgC,CAAC;;MAElG+E,aAAa,CAACyC,YAAY,CAAC,oBAAoB,EAAE,IAAI,CAAChF,iBAAiB,CAAC;MAExEuC,aAAa,CAACiC,YAAY,CAAC,YAAY,EAAE,IAAI,CAAC3E,SAAS,CAACoF,CAAC,EAAE,IAAI,CAACpF,SAAS,CAACqF,CAAC,EAAE,IAAI,CAACrF,SAAS,CAACsF,CAAC,EAAEpC,IAAI,CAACC,GAAG,CAAC,OAAO,EAAE,IAAI,CAACjD,mBAAmB,CAAC,CAAC;MAE3IwC,aAAa,CAAC6C,YAAY,CAAC,sBAAsB,EAAE,IAAI,CAACvG,mBAAmB,EAAE,IAAI,CAACC,qBAAqB,EAAE,CAAC,CAAC;;IAG/G;IACA,IAAIgC,KAAK,CAACE,eAAe,EAAE;MACvB,IAAI,IAAI,CAAC/B,iBAAiB,IAAIhE,aAAa,CAACgG,uBAAuB,EAAE;QACjEsB,aAAa,CAAC8C,UAAU,CAAC,kBAAkB,EAAE,IAAI,CAACpG,iBAAiB,CAAC;;MAGxE,IAAI,IAAI,CAACkB,2BAA2B,IAAIlF,aAAa,CAAC2G,iCAAiC,IAAIf,OAAO,CAAC3E,8BAA8B,EAAE;QAC/HqG,aAAa,CAAC8C,UAAU,CAAC,4BAA4B,EAAE,IAAI,CAAClF,2BAA2B,CAAC;;MAG5F,IAAI,IAAI,CAACE,6BAA6B,IAAIpF,aAAa,CAAC4G,mCAAmC,IAAIhB,OAAO,CAACzE,gCAAgC,EAAE;QACrImG,aAAa,CAAC8C,UAAU,CAAC,8BAA8B,EAAE,IAAI,CAAChF,6BAA6B,CAAC;;MAGhG,IAAIjB,iBAAiB,IAAInE,aAAa,CAACmG,wBAAwB,EAAE;QAC7D,IAAIuC,oBAAoB,EAAE;UACtBpB,aAAa,CAAC8C,UAAU,CAAC,mBAAmB,EAAEjG,iBAAiB,CAAC;SACnE,MAAM;UACHmD,aAAa,CAAC8C,UAAU,CAAC,mBAAmB,EAAEjG,iBAAiB,CAACkG,cAAc,IAAIlG,iBAAiB,CAAC;UACpGmD,aAAa,CAAC8C,UAAU,CAAC,sBAAsB,EAAEjG,iBAAiB,CAACmG,cAAc,IAAInG,iBAAiB,CAAC;UACvGmD,aAAa,CAAC8C,UAAU,CAAC,uBAAuB,EAAEjG,iBAAiB,CAACoG,eAAe,IAAIpG,iBAAiB,CAAC;;;;EAIzH;EAEA;;;;;;EAMQ+B,qBAAqBA,CAACL,KAAY;IACtC,IAAI,IAAI,CAAC3B,kBAAkB,EAAE;MACzB,OAAO,IAAI,CAACA,kBAAkB;;IAGlC,IAAI,IAAI,CAACjB,oBAAoB,EAAE;MAC3B,OAAO4C,KAAK,CAAC2E,kBAAkB;;IAGnC,OAAO,IAAI;EACf;EAEA;;;EAGA,IAAWC,oBAAoBA,CAAA;IAC3B,OAAO,IAAI,CAACxH,oBAAoB,IAAI,IAAI,CAACsB,+BAA+B;EAC5E;EAEA;;;;EAIOmG,wBAAwBA,CAACC,aAA8C;IAC1E,IAAI3K,aAAa,CAACmG,wBAAwB,IAAI,IAAI,CAACjC,kBAAkB,IAAI,IAAI,CAACA,kBAAkB,CAAC0G,cAAc,EAAE;MAC7GD,aAAa,CAACE,IAAI,CAAsB,IAAI,CAAC3G,kBAAkB,CAAC;;EAExE;EAEO4G,UAAUA,CAACC,OAAoB;IAClC,IAAI,IAAI,CAAC/G,iBAAiB,KAAK+G,OAAO,EAAE;MACpC,OAAO,IAAI;;IAGf,IAAI,IAAI,CAAC7G,kBAAkB,KAAK6G,OAAO,EAAE;MACrC,OAAO,IAAI;;IAGf,OAAO,KAAK;EAChB;EAEOC,uBAAuBA,CAAA;IAC1B,IAAIhL,aAAa,CAACmG,wBAAwB,IAAI,IAAI,CAACjC,kBAAkB,IAAI,IAAI,CAACA,kBAAkB,CAAC0G,cAAc,EAAE;MAC7G,OAAO,IAAI;;IAGf,OAAO,KAAK;EAChB;EAEOK,iBAAiBA,CAACC,cAA6B;IAClD,IAAI,IAAI,CAAClH,iBAAiB,EAAE;MACxBkH,cAAc,CAACL,IAAI,CAAC,IAAI,CAAC7G,iBAAiB,CAAC;;IAG/C,IAAI,IAAI,CAACE,kBAAkB,EAAE;MACzBgH,cAAc,CAACL,IAAI,CAAC,IAAI,CAAC3G,kBAAkB,CAAC;;EAEpD;EAEOiH,cAAcA,CAACC,WAA0B;IAC5C,IAAI,IAAI,CAACpH,iBAAiB,IAAI,IAAI,CAACA,iBAAiB,CAACqH,UAAU,IAAI,IAAI,CAACrH,iBAAiB,CAACqH,UAAU,CAACC,MAAM,GAAG,CAAC,EAAE;MAC7GF,WAAW,CAACP,IAAI,CAAC,IAAI,CAAC7G,iBAAiB,CAAC;;IAG5C,IAAI,IAAI,CAACE,kBAAkB,IAAI,IAAI,CAACA,kBAAkB,CAACmH,UAAU,IAAI,IAAI,CAACnH,kBAAkB,CAACmH,UAAU,CAACC,MAAM,GAAG,CAAC,EAAE;MAChHF,WAAW,CAACP,IAAI,CAAC,IAAI,CAAC3G,kBAAkB,CAAC;;EAEjD;EAEOqH,OAAOA,CAACC,oBAA8B;IACzC,IAAIA,oBAAoB,EAAE;MACtB,IAAI,IAAI,CAACxH,iBAAiB,EAAE;QACxB,IAAI,CAACA,iBAAiB,CAACuH,OAAO,EAAE;;MAGpC,IAAI,IAAI,CAACrH,kBAAkB,EAAE;QACzB,IAAI,CAACA,kBAAkB,CAACqH,OAAO,EAAE;;;EAG7C;EAEOE,YAAYA,CAAA;IACf,OAAO,4BAA4B;EACvC;EAEOC,YAAYA,CAAC9F,OAAkC,EAAE+F,SAA0B,EAAEC,WAAmB;IACnG,IAAIhG,OAAO,CAAC/E,aAAa,EAAE;MACvB8K,SAAS,CAACE,WAAW,CAACD,WAAW,EAAE,EAAE,eAAe,CAAC;;IAEzD,IAAIhG,OAAO,CAACjF,eAAe,EAAE;MACzBgL,SAAS,CAACE,WAAW,CAACD,WAAW,EAAE,EAAE,iBAAiB,CAAC;;IAE3D,OAAOA,WAAW;EACtB;EAEOE,WAAWA,CAACC,QAAkB;IACjCA,QAAQ,CAAClB,IAAI,CAAC,kBAAkB,EAAE,4BAA4B,EAAE,8BAA8B,EAAE,mBAAmB,EAAE,sBAAsB,EAAE,uBAAuB,CAAC;EACzK;EAEOmB,WAAWA,CAAA;IACd,OAAO;MACHC,GAAG,EAAE,CACD;QAAEC,IAAI,EAAE,8BAA8B;QAAEC,IAAI,EAAE,CAAC;QAAEC,IAAI,EAAE;MAAM,CAAE,EAC/D;QAAEF,IAAI,EAAE,0BAA0B;QAAEC,IAAI,EAAE,CAAC;QAAEC,IAAI,EAAE;MAAM,CAAE,EAC3D;QAAEF,IAAI,EAAE,6BAA6B;QAAEC,IAAI,EAAE,CAAC;QAAEC,IAAI,EAAE;MAAM,CAAE,EAC9D;QAAEF,IAAI,EAAE,kBAAkB;QAAEC,IAAI,EAAE,CAAC;QAAEC,IAAI,EAAE;MAAM,CAAE,EACnD;QAAEF,IAAI,EAAE,kBAAkB;QAAEC,IAAI,EAAE,EAAE;QAAEC,IAAI,EAAE;MAAM,CAAE,EACpD;QAAEF,IAAI,EAAE,iBAAiB;QAAEC,IAAI,EAAE,CAAC;QAAEC,IAAI,EAAE;MAAM,CAAE,EAClD;QAAEF,IAAI,EAAE,2BAA2B;QAAEC,IAAI,EAAE,CAAC;QAAEC,IAAI,EAAE;MAAM,CAAE,EAC5D;QAAEF,IAAI,EAAE,iBAAiB;QAAEC,IAAI,EAAE,EAAE;QAAEC,IAAI,EAAE;MAAM,CAAE,EACnD;QAAEF,IAAI,EAAE,2BAA2B;QAAEC,IAAI,EAAE,EAAE;QAAEC,IAAI,EAAE;MAAM,CAAE,EAC7D;QAAEF,IAAI,EAAE,6BAA6B;QAAEC,IAAI,EAAE,EAAE;QAAEC,IAAI,EAAE;MAAM,CAAE,EAC/D;QAAEF,IAAI,EAAE,iBAAiB;QAAEC,IAAI,EAAE,CAAC;QAAEC,IAAI,EAAE;MAAM,CAAE,EAClD;QAAEF,IAAI,EAAE,oBAAoB;QAAEC,IAAI,EAAE,CAAC;QAAEC,IAAI,EAAE;MAAM,CAAE,EACrD;QAAEF,IAAI,EAAE,YAAY;QAAEC,IAAI,EAAE,CAAC;QAAEC,IAAI,EAAE;MAAM,CAAE,EAC7C;QAAEF,IAAI,EAAE,sBAAsB;QAAEC,IAAI,EAAE,CAAC;QAAEC,IAAI,EAAE;MAAM,CAAE,EACvD;QAAEF,IAAI,EAAE,qBAAqB;QAAEC,IAAI,EAAE,CAAC;QAAEC,IAAI,EAAE;MAAM,CAAE,EACtD;QAAEF,IAAI,EAAE,iBAAiB;QAAEC,IAAI,EAAE,CAAC;QAAEC,IAAI,EAAE;MAAM,CAAE,EAClD;QAAEF,IAAI,EAAE,4BAA4B;QAAEC,IAAI,EAAE,CAAC;QAAEC,IAAI,EAAE;MAAO,CAAE;KAErE;EACL;;AAvoBOC,UAAA,EAFN1M,SAAS,EAAE,EACXE,gBAAgB,CAAC,kCAAkC,CAAC,C,sEAClB;AAQ5BwM,UAAA,EAFN1M,SAAS,EAAE,EACXE,gBAAgB,CAAC,kCAAkC,CAAC,C,wEAChB;AAQ9BwM,UAAA,EAFN1M,SAAS,EAAE,EACXE,gBAAgB,CAAC,wBAAwB,CAAC,C,sEACR;AAG3BwM,UAAA,EADP1M,SAAS,EAAE,C,mFACiC;AAgCtC0M,UAAA,EADN1M,SAAS,EAAE,C,sEAC2B;AAQhC0M,UAAA,EADN1M,SAAS,EAAE,C,wEAC6B;AAMlC0M,UAAA,EADN1M,SAAS,EAAE,C,4EACsC;AAM3C0M,UAAA,EADN1M,SAAS,EAAE,C,8EACwC;AAY7C0M,UAAA,EAFNzM,kBAAkB,EAAE,EACpBC,gBAAgB,CAAC,kCAAkC,CAAC,C,mEACC;AAQ/CwM,UAAA,EAFNzM,kBAAkB,EAAE,EACpBC,gBAAgB,CAAC,kCAAkC,CAAC,C,oEACE;AAchDwM,UAAA,EAFN1M,SAAS,EAAE,EACXE,gBAAgB,CAAC,kCAAkC,CAAC,C,oEACtB;AAGvBwM,UAAA,EADP1M,SAAS,EAAE,C,2EAC4B;AAUxC0M,UAAA,EADCxM,gBAAgB,CAAC,kCAAkC,CAAC,C,wEAMpD;AAeMwM,UAAA,EAFN1M,SAAS,EAAE,EACXE,gBAAgB,CAAC,kCAAkC,CAAC,C,oEACpB;AAU1BwM,UAAA,EAFN1M,SAAS,EAAE,EACXE,gBAAgB,CAAC,kCAAkC,CAAC,C,iFACP;AAOvCwM,UAAA,EADN1M,SAAS,EAAE,C,mEACwB;AAM7B0M,UAAA,EADN1M,SAAS,EAAE,C,mEACwB;AAM7B0M,UAAA,EADN1M,SAAS,EAAE,C,sEACuB;AAO5B0M,UAAA,EADNvM,iBAAiB,EAAE,C,4DACc;AAO3BuM,UAAA,EADN1M,SAAS,EAAE,C,sEACmB;AAOxB0M,UAAA,EADNvM,iBAAiB,EAAE,C,oEACsB;AAWnCuM,UAAA,EAFN1M,SAAS,EAAE,EACXE,gBAAgB,CAAC,kCAAkC,CAAC,C,8EACD;AAS7CwM,UAAA,EAFNzM,kBAAkB,EAAE,EACpBC,gBAAgB,CAAC,kCAAkC,CAAC,C,6EACW;AASzDwM,UAAA,EAFNzM,kBAAkB,EAAE,EACpBC,gBAAgB,CAAC,kCAAkC,CAAC,C,+EACa;AAY3DwM,UAAA,EAFN1M,SAAS,EAAE,EACXE,gBAAgB,CAAC,kCAAkC,CAAC,C,uEACR"},"metadata":{},"sourceType":"module","externalDependencies":[]}