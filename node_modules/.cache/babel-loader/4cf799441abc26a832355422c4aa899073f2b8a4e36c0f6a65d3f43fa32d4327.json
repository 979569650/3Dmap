{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\n\n/**\n * Wrapper around a render target (either single or multi textures)\n */\nexport class RenderTargetWrapper {\n  /**\n   * Gets the depth/stencil texture (if created by a createDepthStencilTexture() call)\n   */\n  get depthStencilTexture() {\n    return this._depthStencilTexture;\n  }\n  /**\n   * Indicates if the depth/stencil texture has a stencil aspect\n   */\n  get depthStencilTextureWithStencil() {\n    return this._depthStencilTextureWithStencil;\n  }\n  /**\n   * Defines if the render target wrapper is for a cube texture or if false a 2d texture\n   */\n  get isCube() {\n    return this._isCube;\n  }\n  /**\n   * Defines if the render target wrapper is for a single or multi target render wrapper\n   */\n  get isMulti() {\n    return this._isMulti;\n  }\n  /**\n   * Defines if the render target wrapper is for a single or an array of textures\n   */\n  get is2DArray() {\n    return this.layers > 0;\n  }\n  /**\n   * Gets the size of the render target wrapper (used for cubes, as width=height in this case)\n   */\n  get size() {\n    return this.width;\n  }\n  /**\n   * Gets the width of the render target wrapper\n   */\n  get width() {\n    return this._size.width || this._size;\n  }\n  /**\n   * Gets the height of the render target wrapper\n   */\n  get height() {\n    return this._size.height || this._size;\n  }\n  /**\n   * Gets the number of layers of the render target wrapper (only used if is2DArray is true and wrapper is not a multi render target)\n   */\n  get layers() {\n    return this._size.layers || 0;\n  }\n  /**\n   * Gets the render texture. If this is a multi render target, gets the first texture\n   */\n  get texture() {\n    var _a, _b;\n    return (_b = (_a = this._textures) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;\n  }\n  /**\n   * Gets the list of render textures. If we are not in a multi render target, the list will be null (use the texture getter instead)\n   */\n  get textures() {\n    return this._textures;\n  }\n  /**\n   * Gets the face indices that correspond to the list of render textures. If we are not in a multi render target, the list will be null\n   */\n  get faceIndices() {\n    return this._faceIndices;\n  }\n  /**\n   * Gets the layer indices that correspond to the list of render textures. If we are not in a multi render target, the list will be null\n   */\n  get layerIndices() {\n    return this._layerIndices;\n  }\n  /**\n   * Gets the sample count of the render target\n   */\n  get samples() {\n    return this._samples;\n  }\n  /**\n   * Sets the sample count of the render target\n   * @param value sample count\n   * @param initializeBuffers If set to true, the engine will make an initializing call to drawBuffers (only used when isMulti=true).\n   * @param force true to force calling the update sample count engine function even if the current sample count is equal to value\n   * @returns the sample count that has been set\n   */\n  setSamples(value, initializeBuffers = true, force = false) {\n    if (this.samples === value && !force) {\n      return value;\n    }\n    const result = this._isMulti ? this._engine.updateMultipleRenderTargetTextureSampleCount(this, value, initializeBuffers) : this._engine.updateRenderTargetTextureSampleCount(this, value);\n    this._samples = value;\n    return result;\n  }\n  /**\n   * Initializes the render target wrapper\n   * @param isMulti true if the wrapper is a multi render target\n   * @param isCube true if the wrapper should render to a cube texture\n   * @param size size of the render target (width/height/layers)\n   * @param engine engine used to create the render target\n   * @param label defines the label to use for the wrapper (for debugging purpose only)\n   */\n  constructor(isMulti, isCube, size, engine, label) {\n    this._textures = null;\n    this._faceIndices = null;\n    this._layerIndices = null;\n    /** @internal */\n    this._samples = 1;\n    /** @internal */\n    this._attachments = null;\n    /** @internal */\n    this._generateStencilBuffer = false;\n    /** @internal */\n    this._generateDepthBuffer = false;\n    /** @internal */\n    this._depthStencilTextureWithStencil = false;\n    this._isMulti = isMulti;\n    this._isCube = isCube;\n    this._size = size;\n    this._engine = engine;\n    this._depthStencilTexture = null;\n    this.label = label;\n  }\n  /**\n   * Sets the render target texture(s)\n   * @param textures texture(s) to set\n   */\n  setTextures(textures) {\n    if (Array.isArray(textures)) {\n      this._textures = textures;\n    } else if (textures) {\n      this._textures = [textures];\n    } else {\n      this._textures = null;\n    }\n  }\n  /**\n   * Set a texture in the textures array\n   * @param texture The texture to set\n   * @param index The index in the textures array to set\n   * @param disposePrevious If this function should dispose the previous texture\n   */\n  setTexture(texture, index = 0, disposePrevious = true) {\n    if (!this._textures) {\n      this._textures = [];\n    }\n    if (this._textures[index] === texture) {\n      return;\n    }\n    if (this._textures[index] && disposePrevious) {\n      this._textures[index].dispose();\n    }\n    this._textures[index] = texture;\n  }\n  /**\n   * Sets the layer and face indices of every render target texture bound to each color attachment\n   * @param layers The layers of each texture to be set\n   * @param faces The faces of each texture to be set\n   */\n  setLayerAndFaceIndices(layers, faces) {\n    this._layerIndices = layers;\n    this._faceIndices = faces;\n  }\n  /**\n   * Sets the layer and face indices of a texture in the textures array that should be bound to each color attachment\n   * @param index The index of the texture in the textures array to modify\n   * @param layer The layer of the texture to be set\n   * @param face The face of the texture to be set\n   */\n  setLayerAndFaceIndex(index = 0, layer, face) {\n    if (!this._layerIndices) {\n      this._layerIndices = [];\n    }\n    if (!this._faceIndices) {\n      this._faceIndices = [];\n    }\n    if (layer !== undefined && layer >= 0) {\n      this._layerIndices[index] = layer;\n    }\n    if (face !== undefined && face >= 0) {\n      this._faceIndices[index] = face;\n    }\n  }\n  /**\n   * Creates the depth/stencil texture\n   * @param comparisonFunction Comparison function to use for the texture\n   * @param bilinearFiltering true if bilinear filtering should be used when sampling the texture\n   * @param generateStencil true if the stencil aspect should also be created\n   * @param samples sample count to use when creating the texture\n   * @param format format of the depth texture\n   * @param label defines the label to use for the texture (for debugging purpose only)\n   * @returns the depth/stencil created texture\n   */\n  createDepthStencilTexture(comparisonFunction = 0, bilinearFiltering = true, generateStencil = false, samples = 1, format = 14, label) {\n    var _a;\n    (_a = this._depthStencilTexture) === null || _a === void 0 ? void 0 : _a.dispose();\n    this._depthStencilTextureWithStencil = generateStencil;\n    this._depthStencilTexture = this._engine.createDepthStencilTexture(this._size, {\n      bilinearFiltering,\n      comparisonFunction,\n      generateStencil,\n      isCube: this._isCube,\n      samples,\n      depthTextureFormat: format,\n      label\n    }, this);\n    return this._depthStencilTexture;\n  }\n  /**\n   * Shares the depth buffer of this render target with another render target.\n   * @internal\n   * @param renderTarget Destination renderTarget\n   */\n  _shareDepth(renderTarget) {\n    if (this._depthStencilTexture) {\n      if (renderTarget._depthStencilTexture) {\n        renderTarget._depthStencilTexture.dispose();\n      }\n      renderTarget._depthStencilTexture = this._depthStencilTexture;\n      this._depthStencilTexture.incrementReferences();\n    }\n  }\n  /**\n   * @internal\n   */\n  _swapAndDie(target) {\n    if (this.texture) {\n      this.texture._swapAndDie(target);\n    }\n    this._textures = null;\n    this.dispose(true);\n  }\n  _cloneRenderTargetWrapper() {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    let rtw = null;\n    if (this._isMulti) {\n      const textureArray = this.textures;\n      if (textureArray && textureArray.length > 0) {\n        let generateDepthTexture = false;\n        let textureCount = textureArray.length;\n        const lastTextureSource = textureArray[textureArray.length - 1]._source;\n        if (lastTextureSource === InternalTextureSource.Depth || lastTextureSource === InternalTextureSource.DepthStencil) {\n          generateDepthTexture = true;\n          textureCount--;\n        }\n        const samplingModes = [];\n        const types = [];\n        const formats = [];\n        const targetTypes = [];\n        const faceIndex = [];\n        const layerIndex = [];\n        const layerCounts = [];\n        const internalTexture2Index = {};\n        for (let i = 0; i < textureCount; ++i) {\n          const texture = textureArray[i];\n          samplingModes.push(texture.samplingMode);\n          types.push(texture.type);\n          formats.push(texture.format);\n          const index = internalTexture2Index[texture.uniqueId];\n          if (index !== undefined) {\n            targetTypes.push(-1);\n            layerCounts.push(0);\n          } else {\n            internalTexture2Index[texture.uniqueId] = i;\n            if (texture.is2DArray) {\n              targetTypes.push(35866);\n              layerCounts.push(texture.depth);\n            } else if (texture.isCube) {\n              targetTypes.push(34067);\n              layerCounts.push(0);\n            } /*else if (texture.isCubeArray) {\n                targetTypes.push(3735928559);\n                layerCounts.push(texture.depth);\n              }*/else if (texture.is3D) {\n              targetTypes.push(32879);\n              layerCounts.push(texture.depth);\n            } else {\n              targetTypes.push(3553);\n              layerCounts.push(0);\n            }\n          }\n          if (this._faceIndices) {\n            faceIndex.push((_a = this._faceIndices[i]) !== null && _a !== void 0 ? _a : 0);\n          }\n          if (this._layerIndices) {\n            layerIndex.push((_b = this._layerIndices[i]) !== null && _b !== void 0 ? _b : 0);\n          }\n        }\n        const optionsMRT = {\n          samplingModes,\n          generateMipMaps: textureArray[0].generateMipMaps,\n          generateDepthBuffer: this._generateDepthBuffer,\n          generateStencilBuffer: this._generateStencilBuffer,\n          generateDepthTexture,\n          types,\n          formats,\n          textureCount,\n          targetTypes,\n          faceIndex,\n          layerIndex,\n          layerCounts\n        };\n        const size = {\n          width: this.width,\n          height: this.height\n        };\n        rtw = this._engine.createMultipleRenderTarget(size, optionsMRT);\n        for (let i = 0; i < textureCount; ++i) {\n          if (targetTypes[i] !== -1) {\n            continue;\n          }\n          const index = internalTexture2Index[textureArray[i].uniqueId];\n          rtw.setTexture(rtw.textures[index], i);\n        }\n      }\n    } else {\n      const options = {};\n      options.generateDepthBuffer = this._generateDepthBuffer;\n      options.generateMipMaps = (_d = (_c = this.texture) === null || _c === void 0 ? void 0 : _c.generateMipMaps) !== null && _d !== void 0 ? _d : false;\n      options.generateStencilBuffer = this._generateStencilBuffer;\n      options.samplingMode = (_e = this.texture) === null || _e === void 0 ? void 0 : _e.samplingMode;\n      options.type = (_f = this.texture) === null || _f === void 0 ? void 0 : _f.type;\n      options.format = (_g = this.texture) === null || _g === void 0 ? void 0 : _g.format;\n      if (this.isCube) {\n        rtw = this._engine.createRenderTargetCubeTexture(this.width, options);\n      } else {\n        const size = {\n          width: this.width,\n          height: this.height,\n          layers: this.is2DArray ? (_h = this.texture) === null || _h === void 0 ? void 0 : _h.depth : undefined\n        };\n        rtw = this._engine.createRenderTargetTexture(size, options);\n      }\n      rtw.texture.isReady = true;\n    }\n    return rtw;\n  }\n  _swapRenderTargetWrapper(target) {\n    if (this._textures && target._textures) {\n      for (let i = 0; i < this._textures.length; ++i) {\n        this._textures[i]._swapAndDie(target._textures[i], false);\n        target._textures[i].isReady = true;\n      }\n    }\n    if (this._depthStencilTexture && target._depthStencilTexture) {\n      this._depthStencilTexture._swapAndDie(target._depthStencilTexture);\n      target._depthStencilTexture.isReady = true;\n    }\n    this._textures = null;\n    this._depthStencilTexture = null;\n  }\n  /** @internal */\n  _rebuild() {\n    const rtw = this._cloneRenderTargetWrapper();\n    if (!rtw) {\n      return;\n    }\n    if (this._depthStencilTexture) {\n      const samplingMode = this._depthStencilTexture.samplingMode;\n      const bilinear = samplingMode === 2 || samplingMode === 3 || samplingMode === 11;\n      rtw.createDepthStencilTexture(this._depthStencilTexture._comparisonFunction, bilinear, this._depthStencilTextureWithStencil, this._depthStencilTexture.samples);\n    }\n    if (this.samples > 1) {\n      rtw.setSamples(this.samples);\n    }\n    rtw._swapRenderTargetWrapper(this);\n    rtw.dispose();\n  }\n  /**\n   * Releases the internal render textures\n   */\n  releaseTextures() {\n    var _a, _b;\n    if (this._textures) {\n      for (let i = 0; (_b = i < ((_a = this._textures) === null || _a === void 0 ? void 0 : _a.length)) !== null && _b !== void 0 ? _b : 0; ++i) {\n        this._textures[i].dispose();\n      }\n    }\n    this._textures = null;\n  }\n  /**\n   * Disposes the whole render target wrapper\n   * @param disposeOnlyFramebuffers true if only the frame buffers should be released (used for the WebGL engine). If false, all the textures will also be released\n   */\n  dispose(disposeOnlyFramebuffers = false) {\n    var _a;\n    if (!disposeOnlyFramebuffers) {\n      (_a = this._depthStencilTexture) === null || _a === void 0 ? void 0 : _a.dispose();\n      this._depthStencilTexture = null;\n      this.releaseTextures();\n    }\n    this._engine._releaseRenderTargetWrapper(this);\n  }\n}","map":{"version":3,"names":["InternalTextureSource","RenderTargetWrapper","depthStencilTexture","_depthStencilTexture","depthStencilTextureWithStencil","_depthStencilTextureWithStencil","isCube","_isCube","isMulti","_isMulti","is2DArray","layers","size","width","_size","height","texture","_b","_a","_textures","textures","faceIndices","_faceIndices","layerIndices","_layerIndices","samples","_samples","setSamples","value","initializeBuffers","force","result","_engine","updateMultipleRenderTargetTextureSampleCount","updateRenderTargetTextureSampleCount","constructor","engine","label","_attachments","_generateStencilBuffer","_generateDepthBuffer","setTextures","Array","isArray","setTexture","index","disposePrevious","dispose","setLayerAndFaceIndices","faces","setLayerAndFaceIndex","layer","face","undefined","createDepthStencilTexture","comparisonFunction","bilinearFiltering","generateStencil","format","depthTextureFormat","_shareDepth","renderTarget","incrementReferences","_swapAndDie","target","_cloneRenderTargetWrapper","rtw","textureArray","length","generateDepthTexture","textureCount","lastTextureSource","_source","Depth","DepthStencil","samplingModes","types","formats","targetTypes","faceIndex","layerIndex","layerCounts","internalTexture2Index","i","push","samplingMode","type","uniqueId","depth","is3D","optionsMRT","generateMipMaps","generateDepthBuffer","generateStencilBuffer","createMultipleRenderTarget","options","_d","_c","_e","_f","_g","createRenderTargetCubeTexture","_h","createRenderTargetTexture","isReady","_swapRenderTargetWrapper","_rebuild","bilinear","_comparisonFunction","releaseTextures","disposeOnlyFramebuffers","_releaseRenderTargetWrapper"],"sources":["../../../../dev/core/src/Engines/renderTargetWrapper.ts"],"sourcesContent":["import type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport { InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport type { RenderTargetCreationOptions, TextureSize } from \"../Materials/Textures/textureCreationOptions\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Constants } from \"./constants\";\r\nimport type { ThinEngine } from \"./thinEngine\";\r\nimport type { IMultiRenderTargetOptions } from \"../Materials/Textures/multiRenderTarget\";\r\n\r\n/**\r\n * An interface enforcing the renderTarget accessor to used by render target textures.\r\n */\r\nexport interface IRenderTargetTexture {\r\n    /**\r\n     * Entry point to access the wrapper on a texture.\r\n     */\r\n    renderTarget: Nullable<RenderTargetWrapper>;\r\n}\r\n\r\n/**\r\n * Wrapper around a render target (either single or multi textures)\r\n */\r\nexport class RenderTargetWrapper {\r\n    protected _engine: ThinEngine;\r\n    private _size: TextureSize;\r\n    private _isCube: boolean;\r\n    private _isMulti: boolean;\r\n    private _textures: Nullable<InternalTexture[]> = null;\r\n    private _faceIndices: Nullable<number[]> = null;\r\n    private _layerIndices: Nullable<number[]> = null;\r\n    /** @internal */\r\n    public _samples = 1;\r\n\r\n    /** @internal */\r\n    public _attachments: Nullable<number[]> = null;\r\n    /** @internal */\r\n    public _generateStencilBuffer: boolean = false;\r\n    /** @internal */\r\n    public _generateDepthBuffer: boolean = false;\r\n\r\n    /** @internal */\r\n    public _depthStencilTexture: Nullable<InternalTexture>;\r\n    /** @internal */\r\n    public _depthStencilTextureWithStencil: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets the label of the render target wrapper (optional, for debugging purpose)\r\n     */\r\n    public label?: string;\r\n\r\n    /**\r\n     * Gets the depth/stencil texture (if created by a createDepthStencilTexture() call)\r\n     */\r\n    public get depthStencilTexture() {\r\n        return this._depthStencilTexture;\r\n    }\r\n\r\n    /**\r\n     * Indicates if the depth/stencil texture has a stencil aspect\r\n     */\r\n    public get depthStencilTextureWithStencil() {\r\n        return this._depthStencilTextureWithStencil;\r\n    }\r\n\r\n    /**\r\n     * Defines if the render target wrapper is for a cube texture or if false a 2d texture\r\n     */\r\n    public get isCube(): boolean {\r\n        return this._isCube;\r\n    }\r\n\r\n    /**\r\n     * Defines if the render target wrapper is for a single or multi target render wrapper\r\n     */\r\n    public get isMulti(): boolean {\r\n        return this._isMulti;\r\n    }\r\n\r\n    /**\r\n     * Defines if the render target wrapper is for a single or an array of textures\r\n     */\r\n    public get is2DArray(): boolean {\r\n        return this.layers > 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the size of the render target wrapper (used for cubes, as width=height in this case)\r\n     */\r\n    public get size(): number {\r\n        return this.width;\r\n    }\r\n\r\n    /**\r\n     * Gets the width of the render target wrapper\r\n     */\r\n    public get width(): number {\r\n        return (<{ width: number; height: number }>this._size).width || <number>this._size;\r\n    }\r\n\r\n    /**\r\n     * Gets the height of the render target wrapper\r\n     */\r\n    public get height(): number {\r\n        return (<{ width: number; height: number }>this._size).height || <number>this._size;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of layers of the render target wrapper (only used if is2DArray is true and wrapper is not a multi render target)\r\n     */\r\n    public get layers(): number {\r\n        return (<{ width: number; height: number; layers?: number }>this._size).layers || 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the render texture. If this is a multi render target, gets the first texture\r\n     */\r\n    public get texture(): Nullable<InternalTexture> {\r\n        return this._textures?.[0] ?? null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of render textures. If we are not in a multi render target, the list will be null (use the texture getter instead)\r\n     */\r\n    public get textures(): Nullable<InternalTexture[]> {\r\n        return this._textures;\r\n    }\r\n\r\n    /**\r\n     * Gets the face indices that correspond to the list of render textures. If we are not in a multi render target, the list will be null\r\n     */\r\n    public get faceIndices(): Nullable<number[]> {\r\n        return this._faceIndices;\r\n    }\r\n\r\n    /**\r\n     * Gets the layer indices that correspond to the list of render textures. If we are not in a multi render target, the list will be null\r\n     */\r\n    public get layerIndices(): Nullable<number[]> {\r\n        return this._layerIndices;\r\n    }\r\n\r\n    /**\r\n     * Gets the sample count of the render target\r\n     */\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    /**\r\n     * Sets the sample count of the render target\r\n     * @param value sample count\r\n     * @param initializeBuffers If set to true, the engine will make an initializing call to drawBuffers (only used when isMulti=true).\r\n     * @param force true to force calling the update sample count engine function even if the current sample count is equal to value\r\n     * @returns the sample count that has been set\r\n     */\r\n    public setSamples(value: number, initializeBuffers = true, force = false): number {\r\n        if (this.samples === value && !force) {\r\n            return value;\r\n        }\r\n\r\n        const result = this._isMulti\r\n            ? this._engine.updateMultipleRenderTargetTextureSampleCount(this, value, initializeBuffers)\r\n            : this._engine.updateRenderTargetTextureSampleCount(this, value);\r\n        this._samples = value;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Initializes the render target wrapper\r\n     * @param isMulti true if the wrapper is a multi render target\r\n     * @param isCube true if the wrapper should render to a cube texture\r\n     * @param size size of the render target (width/height/layers)\r\n     * @param engine engine used to create the render target\r\n     * @param label defines the label to use for the wrapper (for debugging purpose only)\r\n     */\r\n    constructor(isMulti: boolean, isCube: boolean, size: TextureSize, engine: ThinEngine, label?: string) {\r\n        this._isMulti = isMulti;\r\n        this._isCube = isCube;\r\n        this._size = size;\r\n        this._engine = engine;\r\n        this._depthStencilTexture = null;\r\n        this.label = label;\r\n    }\r\n\r\n    /**\r\n     * Sets the render target texture(s)\r\n     * @param textures texture(s) to set\r\n     */\r\n    public setTextures(textures: Nullable<InternalTexture> | Nullable<InternalTexture[]>): void {\r\n        if (Array.isArray(textures)) {\r\n            this._textures = textures;\r\n        } else if (textures) {\r\n            this._textures = [textures];\r\n        } else {\r\n            this._textures = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the textures array\r\n     * @param texture The texture to set\r\n     * @param index The index in the textures array to set\r\n     * @param disposePrevious If this function should dispose the previous texture\r\n     */\r\n    public setTexture(texture: InternalTexture, index: number = 0, disposePrevious: boolean = true): void {\r\n        if (!this._textures) {\r\n            this._textures = [];\r\n        }\r\n        if (this._textures[index] === texture) {\r\n            return;\r\n        }\r\n\r\n        if (this._textures[index] && disposePrevious) {\r\n            this._textures[index].dispose();\r\n        }\r\n\r\n        this._textures[index] = texture;\r\n    }\r\n\r\n    /**\r\n     * Sets the layer and face indices of every render target texture bound to each color attachment\r\n     * @param layers The layers of each texture to be set\r\n     * @param faces The faces of each texture to be set\r\n     */\r\n    public setLayerAndFaceIndices(layers: number[], faces: number[]) {\r\n        this._layerIndices = layers;\r\n        this._faceIndices = faces;\r\n    }\r\n\r\n    /**\r\n     * Sets the layer and face indices of a texture in the textures array that should be bound to each color attachment\r\n     * @param index The index of the texture in the textures array to modify\r\n     * @param layer The layer of the texture to be set\r\n     * @param face The face of the texture to be set\r\n     */\r\n    public setLayerAndFaceIndex(index: number = 0, layer?: number, face?: number): void {\r\n        if (!this._layerIndices) {\r\n            this._layerIndices = [];\r\n        }\r\n        if (!this._faceIndices) {\r\n            this._faceIndices = [];\r\n        }\r\n\r\n        if (layer !== undefined && layer >= 0) {\r\n            this._layerIndices[index] = layer;\r\n        }\r\n        if (face !== undefined && face >= 0) {\r\n            this._faceIndices[index] = face;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates the depth/stencil texture\r\n     * @param comparisonFunction Comparison function to use for the texture\r\n     * @param bilinearFiltering true if bilinear filtering should be used when sampling the texture\r\n     * @param generateStencil true if the stencil aspect should also be created\r\n     * @param samples sample count to use when creating the texture\r\n     * @param format format of the depth texture\r\n     * @param label defines the label to use for the texture (for debugging purpose only)\r\n     * @returns the depth/stencil created texture\r\n     */\r\n    public createDepthStencilTexture(\r\n        comparisonFunction: number = 0,\r\n        bilinearFiltering: boolean = true,\r\n        generateStencil: boolean = false,\r\n        samples: number = 1,\r\n        format: number = Constants.TEXTUREFORMAT_DEPTH32_FLOAT,\r\n        label?: string\r\n    ): InternalTexture {\r\n        this._depthStencilTexture?.dispose();\r\n\r\n        this._depthStencilTextureWithStencil = generateStencil;\r\n        this._depthStencilTexture = this._engine.createDepthStencilTexture(\r\n            this._size,\r\n            {\r\n                bilinearFiltering,\r\n                comparisonFunction,\r\n                generateStencil,\r\n                isCube: this._isCube,\r\n                samples,\r\n                depthTextureFormat: format,\r\n                label,\r\n            },\r\n            this\r\n        );\r\n\r\n        return this._depthStencilTexture;\r\n    }\r\n\r\n    /**\r\n     * Shares the depth buffer of this render target with another render target.\r\n     * @internal\r\n     * @param renderTarget Destination renderTarget\r\n     */\r\n    public _shareDepth(renderTarget: RenderTargetWrapper): void {\r\n        if (this._depthStencilTexture) {\r\n            if (renderTarget._depthStencilTexture) {\r\n                renderTarget._depthStencilTexture.dispose();\r\n            }\r\n\r\n            renderTarget._depthStencilTexture = this._depthStencilTexture;\r\n            this._depthStencilTexture.incrementReferences();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _swapAndDie(target: InternalTexture): void {\r\n        if (this.texture) {\r\n            this.texture._swapAndDie(target);\r\n        }\r\n        this._textures = null;\r\n        this.dispose(true);\r\n    }\r\n\r\n    protected _cloneRenderTargetWrapper(): Nullable<RenderTargetWrapper> {\r\n        let rtw: Nullable<RenderTargetWrapper> = null;\r\n\r\n        if (this._isMulti) {\r\n            const textureArray = this.textures;\r\n            if (textureArray && textureArray.length > 0) {\r\n                let generateDepthTexture = false;\r\n                let textureCount = textureArray.length;\r\n\r\n                const lastTextureSource = textureArray[textureArray.length - 1]._source;\r\n                if (lastTextureSource === InternalTextureSource.Depth || lastTextureSource === InternalTextureSource.DepthStencil) {\r\n                    generateDepthTexture = true;\r\n                    textureCount--;\r\n                }\r\n\r\n                const samplingModes: number[] = [];\r\n                const types: number[] = [];\r\n                const formats: number[] = [];\r\n                const targetTypes: number[] = [];\r\n                const faceIndex: number[] = [];\r\n                const layerIndex: number[] = [];\r\n                const layerCounts: number[] = [];\r\n                const internalTexture2Index: { [id: number]: number } = {};\r\n\r\n                for (let i = 0; i < textureCount; ++i) {\r\n                    const texture = textureArray[i];\r\n\r\n                    samplingModes.push(texture.samplingMode);\r\n                    types.push(texture.type);\r\n                    formats.push(texture.format);\r\n\r\n                    const index = internalTexture2Index[texture.uniqueId];\r\n                    if (index !== undefined) {\r\n                        targetTypes.push(-1);\r\n                        layerCounts.push(0);\r\n                    } else {\r\n                        internalTexture2Index[texture.uniqueId] = i;\r\n                        if (texture.is2DArray) {\r\n                            targetTypes.push(Constants.TEXTURE_2D_ARRAY);\r\n                            layerCounts.push(texture.depth);\r\n                        } else if (texture.isCube) {\r\n                            targetTypes.push(Constants.TEXTURE_CUBE_MAP);\r\n                            layerCounts.push(0);\r\n                        } /*else if (texture.isCubeArray) {\r\n                            targetTypes.push(Constants.TEXTURE_CUBE_MAP_ARRAY);\r\n                            layerCounts.push(texture.depth);\r\n                        }*/ else if (texture.is3D) {\r\n                            targetTypes.push(Constants.TEXTURE_3D);\r\n                            layerCounts.push(texture.depth);\r\n                        } else {\r\n                            targetTypes.push(Constants.TEXTURE_2D);\r\n                            layerCounts.push(0);\r\n                        }\r\n                    }\r\n\r\n                    if (this._faceIndices) {\r\n                        faceIndex.push(this._faceIndices[i] ?? 0);\r\n                    }\r\n                    if (this._layerIndices) {\r\n                        layerIndex.push(this._layerIndices[i] ?? 0);\r\n                    }\r\n                }\r\n\r\n                const optionsMRT: IMultiRenderTargetOptions = {\r\n                    samplingModes,\r\n                    generateMipMaps: textureArray[0].generateMipMaps,\r\n                    generateDepthBuffer: this._generateDepthBuffer,\r\n                    generateStencilBuffer: this._generateStencilBuffer,\r\n                    generateDepthTexture,\r\n                    types,\r\n                    formats,\r\n                    textureCount,\r\n                    targetTypes,\r\n                    faceIndex,\r\n                    layerIndex,\r\n                    layerCounts,\r\n                };\r\n                const size = {\r\n                    width: this.width,\r\n                    height: this.height,\r\n                };\r\n\r\n                rtw = this._engine.createMultipleRenderTarget(size, optionsMRT);\r\n\r\n                for (let i = 0; i < textureCount; ++i) {\r\n                    if (targetTypes[i] !== -1) {\r\n                        continue;\r\n                    }\r\n                    const index = internalTexture2Index[textureArray[i].uniqueId];\r\n                    rtw.setTexture(rtw.textures![index], i);\r\n                }\r\n            }\r\n        } else {\r\n            const options: RenderTargetCreationOptions = {};\r\n\r\n            options.generateDepthBuffer = this._generateDepthBuffer;\r\n            options.generateMipMaps = this.texture?.generateMipMaps ?? false;\r\n            options.generateStencilBuffer = this._generateStencilBuffer;\r\n            options.samplingMode = this.texture?.samplingMode;\r\n            options.type = this.texture?.type;\r\n            options.format = this.texture?.format;\r\n\r\n            if (this.isCube) {\r\n                rtw = this._engine.createRenderTargetCubeTexture(this.width, options);\r\n            } else {\r\n                const size = {\r\n                    width: this.width,\r\n                    height: this.height,\r\n                    layers: this.is2DArray ? this.texture?.depth : undefined,\r\n                };\r\n\r\n                rtw = this._engine.createRenderTargetTexture(size, options);\r\n            }\r\n            rtw.texture!.isReady = true;\r\n        }\r\n\r\n        return rtw;\r\n    }\r\n\r\n    protected _swapRenderTargetWrapper(target: RenderTargetWrapper): void {\r\n        if (this._textures && target._textures) {\r\n            for (let i = 0; i < this._textures.length; ++i) {\r\n                this._textures[i]._swapAndDie(target._textures[i], false);\r\n                target._textures[i].isReady = true;\r\n            }\r\n        }\r\n        if (this._depthStencilTexture && target._depthStencilTexture) {\r\n            this._depthStencilTexture._swapAndDie(target._depthStencilTexture);\r\n            target._depthStencilTexture.isReady = true;\r\n        }\r\n\r\n        this._textures = null;\r\n        this._depthStencilTexture = null;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        const rtw = this._cloneRenderTargetWrapper();\r\n        if (!rtw) {\r\n            return;\r\n        }\r\n\r\n        if (this._depthStencilTexture) {\r\n            const samplingMode = this._depthStencilTexture.samplingMode;\r\n            const bilinear =\r\n                samplingMode === Constants.TEXTURE_BILINEAR_SAMPLINGMODE ||\r\n                samplingMode === Constants.TEXTURE_TRILINEAR_SAMPLINGMODE ||\r\n                samplingMode === Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST;\r\n            rtw.createDepthStencilTexture(this._depthStencilTexture._comparisonFunction, bilinear, this._depthStencilTextureWithStencil, this._depthStencilTexture.samples);\r\n        }\r\n\r\n        if (this.samples > 1) {\r\n            rtw.setSamples(this.samples);\r\n        }\r\n\r\n        rtw._swapRenderTargetWrapper(this);\r\n        rtw.dispose();\r\n    }\r\n\r\n    /**\r\n     * Releases the internal render textures\r\n     */\r\n    public releaseTextures(): void {\r\n        if (this._textures) {\r\n            for (let i = 0; i < this._textures?.length ?? 0; ++i) {\r\n                this._textures[i].dispose();\r\n            }\r\n        }\r\n        this._textures = null;\r\n    }\r\n\r\n    /**\r\n     * Disposes the whole render target wrapper\r\n     * @param disposeOnlyFramebuffers true if only the frame buffers should be released (used for the WebGL engine). If false, all the textures will also be released\r\n     */\r\n    public dispose(disposeOnlyFramebuffers = false): void {\r\n        if (!disposeOnlyFramebuffers) {\r\n            this._depthStencilTexture?.dispose();\r\n            this._depthStencilTexture = null;\r\n            this.releaseTextures();\r\n        }\r\n\r\n        this._engine._releaseRenderTargetWrapper(this);\r\n    }\r\n}\r\n"],"mappings":";AACA,SAASA,qBAAqB,QAAQ,0CAAwC;;AAiB9E;;;AAGA,OAAM,MAAOC,mBAAmB;EA4B5B;;;EAGA,IAAWC,mBAAmBA,CAAA;IAC1B,OAAO,IAAI,CAACC,oBAAoB;EACpC;EAEA;;;EAGA,IAAWC,8BAA8BA,CAAA;IACrC,OAAO,IAAI,CAACC,+BAA+B;EAC/C;EAEA;;;EAGA,IAAWC,MAAMA,CAAA;IACb,OAAO,IAAI,CAACC,OAAO;EACvB;EAEA;;;EAGA,IAAWC,OAAOA,CAAA;IACd,OAAO,IAAI,CAACC,QAAQ;EACxB;EAEA;;;EAGA,IAAWC,SAASA,CAAA;IAChB,OAAO,IAAI,CAACC,MAAM,GAAG,CAAC;EAC1B;EAEA;;;EAGA,IAAWC,IAAIA,CAAA;IACX,OAAO,IAAI,CAACC,KAAK;EACrB;EAEA;;;EAGA,IAAWA,KAAKA,CAAA;IACZ,OAA2C,IAAI,CAACC,KAAM,CAACD,KAAK,IAAY,IAAI,CAACC,KAAK;EACtF;EAEA;;;EAGA,IAAWC,MAAMA,CAAA;IACb,OAA2C,IAAI,CAACD,KAAM,CAACC,MAAM,IAAY,IAAI,CAACD,KAAK;EACvF;EAEA;;;EAGA,IAAWH,MAAMA,CAAA;IACb,OAA4D,IAAI,CAACG,KAAM,CAACH,MAAM,IAAI,CAAC;EACvF;EAEA;;;EAGA,IAAWK,OAAOA,CAAA;;IACd,OAAO,CAAAC,EAAA,IAAAC,EAAA,OAAI,CAACC,SAAS,cAAAD,EAAA,uBAAAA,EAAA,CAAG,CAAC,CAAC,cAAAD,EAAA,cAAAA,EAAA,GAAI,IAAI;EACtC;EAEA;;;EAGA,IAAWG,QAAQA,CAAA;IACf,OAAO,IAAI,CAACD,SAAS;EACzB;EAEA;;;EAGA,IAAWE,WAAWA,CAAA;IAClB,OAAO,IAAI,CAACC,YAAY;EAC5B;EAEA;;;EAGA,IAAWC,YAAYA,CAAA;IACnB,OAAO,IAAI,CAACC,aAAa;EAC7B;EAEA;;;EAGA,IAAWC,OAAOA,CAAA;IACd,OAAO,IAAI,CAACC,QAAQ;EACxB;EAEA;;;;;;;EAOOC,UAAUA,CAACC,KAAa,EAAEC,iBAAiB,GAAG,IAAI,EAAEC,KAAK,GAAG,KAAK;IACpE,IAAI,IAAI,CAACL,OAAO,KAAKG,KAAK,IAAI,CAACE,KAAK,EAAE;MAClC,OAAOF,KAAK;;IAGhB,MAAMG,MAAM,GAAG,IAAI,CAACtB,QAAQ,GACtB,IAAI,CAACuB,OAAO,CAACC,4CAA4C,CAAC,IAAI,EAAEL,KAAK,EAAEC,iBAAiB,CAAC,GACzF,IAAI,CAACG,OAAO,CAACE,oCAAoC,CAAC,IAAI,EAAEN,KAAK,CAAC;IACpE,IAAI,CAACF,QAAQ,GAAGE,KAAK;IACrB,OAAOG,MAAM;EACjB;EAEA;;;;;;;;EAQAI,YAAY3B,OAAgB,EAAEF,MAAe,EAAEM,IAAiB,EAAEwB,MAAkB,EAAEC,KAAc;IApJ5F,KAAAlB,SAAS,GAAgC,IAAI;IAC7C,KAAAG,YAAY,GAAuB,IAAI;IACvC,KAAAE,aAAa,GAAuB,IAAI;IAChD;IACO,KAAAE,QAAQ,GAAG,CAAC;IAEnB;IACO,KAAAY,YAAY,GAAuB,IAAI;IAC9C;IACO,KAAAC,sBAAsB,GAAY,KAAK;IAC9C;IACO,KAAAC,oBAAoB,GAAY,KAAK;IAI5C;IACO,KAAAnC,+BAA+B,GAAY,KAAK;IAqInD,IAAI,CAACI,QAAQ,GAAGD,OAAO;IACvB,IAAI,CAACD,OAAO,GAAGD,MAAM;IACrB,IAAI,CAACQ,KAAK,GAAGF,IAAI;IACjB,IAAI,CAACoB,OAAO,GAAGI,MAAM;IACrB,IAAI,CAACjC,oBAAoB,GAAG,IAAI;IAChC,IAAI,CAACkC,KAAK,GAAGA,KAAK;EACtB;EAEA;;;;EAIOI,WAAWA,CAACrB,QAAiE;IAChF,IAAIsB,KAAK,CAACC,OAAO,CAACvB,QAAQ,CAAC,EAAE;MACzB,IAAI,CAACD,SAAS,GAAGC,QAAQ;KAC5B,MAAM,IAAIA,QAAQ,EAAE;MACjB,IAAI,CAACD,SAAS,GAAG,CAACC,QAAQ,CAAC;KAC9B,MAAM;MACH,IAAI,CAACD,SAAS,GAAG,IAAI;;EAE7B;EAEA;;;;;;EAMOyB,UAAUA,CAAC5B,OAAwB,EAAE6B,KAAA,GAAgB,CAAC,EAAEC,eAAA,GAA2B,IAAI;IAC1F,IAAI,CAAC,IAAI,CAAC3B,SAAS,EAAE;MACjB,IAAI,CAACA,SAAS,GAAG,EAAE;;IAEvB,IAAI,IAAI,CAACA,SAAS,CAAC0B,KAAK,CAAC,KAAK7B,OAAO,EAAE;MACnC;;IAGJ,IAAI,IAAI,CAACG,SAAS,CAAC0B,KAAK,CAAC,IAAIC,eAAe,EAAE;MAC1C,IAAI,CAAC3B,SAAS,CAAC0B,KAAK,CAAC,CAACE,OAAO,EAAE;;IAGnC,IAAI,CAAC5B,SAAS,CAAC0B,KAAK,CAAC,GAAG7B,OAAO;EACnC;EAEA;;;;;EAKOgC,sBAAsBA,CAACrC,MAAgB,EAAEsC,KAAe;IAC3D,IAAI,CAACzB,aAAa,GAAGb,MAAM;IAC3B,IAAI,CAACW,YAAY,GAAG2B,KAAK;EAC7B;EAEA;;;;;;EAMOC,oBAAoBA,CAACL,KAAA,GAAgB,CAAC,EAAEM,KAAc,EAAEC,IAAa;IACxE,IAAI,CAAC,IAAI,CAAC5B,aAAa,EAAE;MACrB,IAAI,CAACA,aAAa,GAAG,EAAE;;IAE3B,IAAI,CAAC,IAAI,CAACF,YAAY,EAAE;MACpB,IAAI,CAACA,YAAY,GAAG,EAAE;;IAG1B,IAAI6B,KAAK,KAAKE,SAAS,IAAIF,KAAK,IAAI,CAAC,EAAE;MACnC,IAAI,CAAC3B,aAAa,CAACqB,KAAK,CAAC,GAAGM,KAAK;;IAErC,IAAIC,IAAI,KAAKC,SAAS,IAAID,IAAI,IAAI,CAAC,EAAE;MACjC,IAAI,CAAC9B,YAAY,CAACuB,KAAK,CAAC,GAAGO,IAAI;;EAEvC;EAEA;;;;;;;;;;EAUOE,yBAAyBA,CAC5BC,kBAAA,GAA6B,CAAC,EAC9BC,iBAAA,GAA6B,IAAI,EACjCC,eAAA,GAA2B,KAAK,EAChChC,OAAA,GAAkB,CAAC,EACnBiC,MAAA,GAAiB,IAAArB,KAAS,EAAC;;IAG3B,CAAAnB,EAAA,OAAI,CAACf,oBAAoB,cAAAe,EAAA,uBAAAA,EAAA,CAAE6B,OAAO,EAAE;IAEpC,IAAI,CAAC1C,+BAA+B,GAAGoD,eAAe;IACtD,IAAI,CAACtD,oBAAoB,GAAG,IAAI,CAAC6B,OAAO,CAACsB,yBAAyB,CAC9D,IAAI,CAACxC,KAAK,EACV;MACI0C,iBAAiB;MACjBD,kBAAkB;MAClBE,eAAe;MACfnD,MAAM,EAAE,IAAI,CAACC,OAAO;MACpBkB,OAAO;MACPkC,kBAAkB,EAAED,MAAM;MAC1BrB;KACH,EACD,IAAI,CACP;IAED,OAAO,IAAI,CAAClC,oBAAoB;EACpC;EAEA;;;;;EAKOyD,WAAWA,CAACC,YAAiC;IAChD,IAAI,IAAI,CAAC1D,oBAAoB,EAAE;MAC3B,IAAI0D,YAAY,CAAC1D,oBAAoB,EAAE;QACnC0D,YAAY,CAAC1D,oBAAoB,CAAC4C,OAAO,EAAE;;MAG/Cc,YAAY,CAAC1D,oBAAoB,GAAG,IAAI,CAACA,oBAAoB;MAC7D,IAAI,CAACA,oBAAoB,CAAC2D,mBAAmB,EAAE;;EAEvD;EAEA;;;EAGOC,WAAWA,CAACC,MAAuB;IACtC,IAAI,IAAI,CAAChD,OAAO,EAAE;MACd,IAAI,CAACA,OAAO,CAAC+C,WAAW,CAACC,MAAM,CAAC;;IAEpC,IAAI,CAAC7C,SAAS,GAAG,IAAI;IACrB,IAAI,CAAC4B,OAAO,CAAC,IAAI,CAAC;EACtB;EAEUkB,yBAAyBA,CAAA;;IAC/B,IAAIC,GAAG,GAAkC,IAAI;IAE7C,IAAI,IAAI,CAACzD,QAAQ,EAAE;MACf,MAAM0D,YAAY,GAAG,IAAI,CAAC/C,QAAQ;MAClC,IAAI+C,YAAY,IAAIA,YAAY,CAACC,MAAM,GAAG,CAAC,EAAE;QACzC,IAAIC,oBAAoB,GAAG,KAAK;QAChC,IAAIC,YAAY,GAAGH,YAAY,CAACC,MAAM;QAEtC,MAAMG,iBAAiB,GAAGJ,YAAY,CAACA,YAAY,CAACC,MAAM,GAAG,CAAC,CAAC,CAACI,OAAO;QACvE,IAAID,iBAAiB,KAAKvE,qBAAqB,CAACyE,KAAK,IAAIF,iBAAiB,KAAKvE,qBAAqB,CAAC0E,YAAY,EAAE;UAC/GL,oBAAoB,GAAG,IAAI;UAC3BC,YAAY,EAAE;;QAGlB,MAAMK,aAAa,GAAa,EAAE;QAClC,MAAMC,KAAK,GAAa,EAAE;QAC1B,MAAMC,OAAO,GAAa,EAAE;QAC5B,MAAMC,WAAW,GAAa,EAAE;QAChC,MAAMC,SAAS,GAAa,EAAE;QAC9B,MAAMC,UAAU,GAAa,EAAE;QAC/B,MAAMC,WAAW,GAAa,EAAE;QAChC,MAAMC,qBAAqB,GAA6B,EAAE;QAE1D,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,YAAY,EAAE,EAAEa,CAAC,EAAE;UACnC,MAAMnE,OAAO,GAAGmD,YAAY,CAACgB,CAAC,CAAC;UAE/BR,aAAa,CAACS,IAAI,CAACpE,OAAO,CAACqE,YAAY,CAAC;UACxCT,KAAK,CAACQ,IAAI,CAACpE,OAAO,CAACsE,IAAI,CAAC;UACxBT,OAAO,CAACO,IAAI,CAACpE,OAAO,CAAC0C,MAAM,CAAC;UAE5B,MAAMb,KAAK,GAAGqC,qBAAqB,CAAClE,OAAO,CAACuE,QAAQ,CAAC;UACrD,IAAI1C,KAAK,KAAKQ,SAAS,EAAE;YACrByB,WAAW,CAACM,IAAI,CAAC,CAAC,CAAC,CAAC;YACpBH,WAAW,CAACG,IAAI,CAAC,CAAC,CAAC;WACtB,MAAM;YACHF,qBAAqB,CAAClE,OAAO,CAACuE,QAAQ,CAAC,GAAGJ,CAAC;YAC3C,IAAInE,OAAO,CAACN,SAAS,EAAE;cACnBoE,WAAW,CAACM,IAAI,CAAC;cACjBH,WAAW,CAACG,IAAI,CAACpE,OAAO,CAACwE,KAAK,CAAC;aAClC,MAAM,IAAIxE,OAAO,CAACV,MAAM,EAAE;cACvBwE,WAAW,CAACM,IAAI,CAAC;cACjBH,WAAW,CAACG,IAAI,CAAC,CAAC,CAAC;aACtB,CAAC;;;iBAAA,KAGO,IAAIpE,OAAO,CAACyE,IAAI,EAAE;cACvBX,WAAW,CAACM,IAAI,CAAC;cACjBH,WAAW,CAACG,IAAI,CAACpE,OAAO,CAACwE,KAAK,CAAC;aAClC,MAAM;cACHV,WAAW,CAACM,IAAI,CAAC;cACjBH,WAAW,CAACG,IAAI,CAAC,CAAC,CAAC;;;UAI3B,IAAI,IAAI,CAAC9D,YAAY,EAAE;YACnByD,SAAS,CAACK,IAAI,CAAC,CAAAlE,EAAA,OAAI,CAACI,YAAY,CAAC6D,CAAC,CAAC,cAAAjE,EAAA,cAAAA,EAAA,GAAI,CAAC,CAAC;;UAE7C,IAAI,IAAI,CAACM,aAAa,EAAE;YACpBwD,UAAU,CAACI,IAAI,CAAC,CAAAnE,EAAA,OAAI,CAACO,aAAa,CAAC2D,CAAC,CAAC,cAAAlE,EAAA,cAAAA,EAAA,GAAI,CAAC,CAAC;;;QAInD,MAAMyE,UAAU,GAA8B;UAC1Cf,aAAa;UACbgB,eAAe,EAAExB,YAAY,CAAC,CAAC,CAAC,CAACwB,eAAe;UAChDC,mBAAmB,EAAE,IAAI,CAACpD,oBAAoB;UAC9CqD,qBAAqB,EAAE,IAAI,CAACtD,sBAAsB;UAClD8B,oBAAoB;UACpBO,KAAK;UACLC,OAAO;UACPP,YAAY;UACZQ,WAAW;UACXC,SAAS;UACTC,UAAU;UACVC;SACH;QACD,MAAMrE,IAAI,GAAG;UACTC,KAAK,EAAE,IAAI,CAACA,KAAK;UACjBE,MAAM,EAAE,IAAI,CAACA;SAChB;QAEDmD,GAAG,GAAG,IAAI,CAAClC,OAAO,CAAC8D,0BAA0B,CAAClF,IAAI,EAAE8E,UAAU,CAAC;QAE/D,KAAK,IAAIP,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,YAAY,EAAE,EAAEa,CAAC,EAAE;UACnC,IAAIL,WAAW,CAACK,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;YACvB;;UAEJ,MAAMtC,KAAK,GAAGqC,qBAAqB,CAACf,YAAY,CAACgB,CAAC,CAAC,CAACI,QAAQ,CAAC;UAC7DrB,GAAG,CAACtB,UAAU,CAACsB,GAAG,CAAC9C,QAAS,CAACyB,KAAK,CAAC,EAAEsC,CAAC,CAAC;;;KAGlD,MAAM;MACH,MAAMY,OAAO,GAAgC,EAAE;MAE/CA,OAAO,CAACH,mBAAmB,GAAG,IAAI,CAACpD,oBAAoB;MACvDuD,OAAO,CAACJ,eAAe,GAAG,CAAAK,EAAA,IAAAC,EAAA,OAAI,CAACjF,OAAO,cAAAiF,EAAA,uBAAAA,EAAA,CAAEN,eAAe,cAAAK,EAAA,cAAAA,EAAA,GAAI,KAAK;MAChED,OAAO,CAACF,qBAAqB,GAAG,IAAI,CAACtD,sBAAsB;MAC3DwD,OAAO,CAACV,YAAY,GAAG,CAAAa,EAAA,OAAI,CAAClF,OAAO,cAAAkF,EAAA,uBAAAA,EAAA,CAAEb,YAAY;MACjDU,OAAO,CAACT,IAAI,GAAG,CAAAa,EAAA,OAAI,CAACnF,OAAO,cAAAmF,EAAA,uBAAAA,EAAA,CAAEb,IAAI;MACjCS,OAAO,CAACrC,MAAM,GAAG,CAAA0C,EAAA,OAAI,CAACpF,OAAO,cAAAoF,EAAA,uBAAAA,EAAA,CAAE1C,MAAM;MAErC,IAAI,IAAI,CAACpD,MAAM,EAAE;QACb4D,GAAG,GAAG,IAAI,CAAClC,OAAO,CAACqE,6BAA6B,CAAC,IAAI,CAACxF,KAAK,EAAEkF,OAAO,CAAC;OACxE,MAAM;QACH,MAAMnF,IAAI,GAAG;UACTC,KAAK,EAAE,IAAI,CAACA,KAAK;UACjBE,MAAM,EAAE,IAAI,CAACA,MAAM;UACnBJ,MAAM,EAAE,IAAI,CAACD,SAAS,GAAG,CAAA4F,EAAA,OAAI,CAACtF,OAAO,cAAAsF,EAAA,uBAAAA,EAAA,CAAEd,KAAK,GAAGnC;SAClD;QAEDa,GAAG,GAAG,IAAI,CAAClC,OAAO,CAACuE,yBAAyB,CAAC3F,IAAI,EAAEmF,OAAO,CAAC;;MAE/D7B,GAAG,CAAClD,OAAQ,CAACwF,OAAO,GAAG,IAAI;;IAG/B,OAAOtC,GAAG;EACd;EAEUuC,wBAAwBA,CAACzC,MAA2B;IAC1D,IAAI,IAAI,CAAC7C,SAAS,IAAI6C,MAAM,CAAC7C,SAAS,EAAE;MACpC,KAAK,IAAIgE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAChE,SAAS,CAACiD,MAAM,EAAE,EAAEe,CAAC,EAAE;QAC5C,IAAI,CAAChE,SAAS,CAACgE,CAAC,CAAC,CAACpB,WAAW,CAACC,MAAM,CAAC7C,SAAS,CAACgE,CAAC,CAAC,EAAE,KAAK,CAAC;QACzDnB,MAAM,CAAC7C,SAAS,CAACgE,CAAC,CAAC,CAACqB,OAAO,GAAG,IAAI;;;IAG1C,IAAI,IAAI,CAACrG,oBAAoB,IAAI6D,MAAM,CAAC7D,oBAAoB,EAAE;MAC1D,IAAI,CAACA,oBAAoB,CAAC4D,WAAW,CAACC,MAAM,CAAC7D,oBAAoB,CAAC;MAClE6D,MAAM,CAAC7D,oBAAoB,CAACqG,OAAO,GAAG,IAAI;;IAG9C,IAAI,CAACrF,SAAS,GAAG,IAAI;IACrB,IAAI,CAAChB,oBAAoB,GAAG,IAAI;EACpC;EAEA;EACOuG,QAAQA,CAAA;IACX,MAAMxC,GAAG,GAAG,IAAI,CAACD,yBAAyB,EAAE;IAC5C,IAAI,CAACC,GAAG,EAAE;MACN;;IAGJ,IAAI,IAAI,CAAC/D,oBAAoB,EAAE;MAC3B,MAAMkF,YAAY,GAAG,IAAI,CAAClF,oBAAoB,CAACkF,YAAY;MAC3D,MAAMsB,QAAQ,GACVtB,YAAY,KAAK,KACjBA,YAAY,KAAK,KACjBA,YAAY,KAAK;MACrBnB,GAAG,CAACZ,yBAAyB,CAAC,IAAI,CAACnD,oBAAoB,CAACyG,mBAAmB,EAAED,QAAQ,EAAE,IAAI,CAACtG,+BAA+B,EAAE,IAAI,CAACF,oBAAoB,CAACsB,OAAO,CAAC;;IAGnK,IAAI,IAAI,CAACA,OAAO,GAAG,CAAC,EAAE;MAClByC,GAAG,CAACvC,UAAU,CAAC,IAAI,CAACF,OAAO,CAAC;;IAGhCyC,GAAG,CAACuC,wBAAwB,CAAC,IAAI,CAAC;IAClCvC,GAAG,CAACnB,OAAO,EAAE;EACjB;EAEA;;;EAGO8D,eAAeA,CAAA;;IAClB,IAAI,IAAI,CAAC1F,SAAS,EAAE;MAChB,KAAK,IAAIgE,CAAC,GAAG,CAAC,EAAE,CAAAlE,EAAA,GAAAkE,CAAC,IAAG,CAAAjE,EAAA,OAAI,CAACC,SAAS,cAAAD,EAAA,uBAAAA,EAAA,CAAEkD,MAAM,eAAAnD,EAAA,cAAAA,EAAA,GAAI,CAAC,EAAE,EAAEkE,CAAC,EAAE;QAClD,IAAI,CAAChE,SAAS,CAACgE,CAAC,CAAC,CAACpC,OAAO,EAAE;;;IAGnC,IAAI,CAAC5B,SAAS,GAAG,IAAI;EACzB;EAEA;;;;EAIO4B,OAAOA,CAAC+D,uBAAuB,GAAG,KAAK;;IAC1C,IAAI,CAACA,uBAAuB,EAAE;MAC1B,CAAA5F,EAAA,OAAI,CAACf,oBAAoB,cAAAe,EAAA,uBAAAA,EAAA,CAAE6B,OAAO,EAAE;MACpC,IAAI,CAAC5C,oBAAoB,GAAG,IAAI;MAChC,IAAI,CAAC0G,eAAe,EAAE;;IAG1B,IAAI,CAAC7E,OAAO,CAAC+E,2BAA2B,CAAC,IAAI,CAAC;EAClD"},"metadata":{},"sourceType":"module","externalDependencies":[]}