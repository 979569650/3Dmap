{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Animation } from \"./animation.js\";\nimport { RuntimeAnimation } from \"./runtimeAnimation.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Scene } from \"../scene.js\";\nimport { Matrix, Quaternion, Vector3, TmpVectors } from \"../Maths/math.vector.js\";\nimport { PrecisionDate } from \"../Misc/precisionDate.js\";\nimport { Bone } from \"../Bones/bone.js\";\n/**\n * Class used to store an actual running animation\n */\nexport class Animatable {\n  /**\n   * Gets the root Animatable used to synchronize and normalize animations\n   */\n  get syncRoot() {\n    return this._syncRoot;\n  }\n  /**\n   * Gets the current frame of the first RuntimeAnimation\n   * Used to synchronize Animatables\n   */\n  get masterFrame() {\n    if (this._runtimeAnimations.length === 0) {\n      return 0;\n    }\n    return this._runtimeAnimations[0].currentFrame;\n  }\n  /**\n   * Gets or sets the animatable weight (-1.0 by default meaning not weighted)\n   */\n  get weight() {\n    return this._weight;\n  }\n  set weight(value) {\n    if (value === -1) {\n      // -1 is ok and means no weight\n      this._weight = -1;\n      return;\n    }\n    // Else weight must be in [0, 1] range\n    this._weight = Math.min(Math.max(value, 0), 1.0);\n  }\n  /**\n   * Gets or sets the speed ratio to apply to the animatable (1.0 by default)\n   */\n  get speedRatio() {\n    return this._speedRatio;\n  }\n  set speedRatio(value) {\n    for (let index = 0; index < this._runtimeAnimations.length; index++) {\n      const animation = this._runtimeAnimations[index];\n      animation._prepareForSpeedRatioChange(value);\n    }\n    this._speedRatio = value;\n    // Resync _manualJumpDelay in case goToFrame was called before speedRatio was set.\n    if (this._goToFrame !== null) {\n      this.goToFrame(this._goToFrame);\n    }\n  }\n  /**\n   * Gets the elapsed time since the animatable started in milliseconds\n   */\n  get elapsedTime() {\n    return this._localDelayOffset === null ? 0 : this._scene._animationTime - this._localDelayOffset;\n  }\n  /**\n   * Creates a new Animatable\n   * @param scene defines the hosting scene\n   * @param target defines the target object\n   * @param fromFrame defines the starting frame number (default is 0)\n   * @param toFrame defines the ending frame number (default is 100)\n   * @param loopAnimation defines if the animation must loop (default is false)\n   * @param speedRatio defines the factor to apply to animation speed (default is 1)\n   * @param onAnimationEnd defines a callback to call when animation ends if it is not looping\n   * @param animations defines a group of animation to add to the new Animatable\n   * @param onAnimationLoop defines a callback to call when animation loops\n   * @param isAdditive defines whether the animation should be evaluated additively\n   * @param playOrder defines the order in which this animatable should be processed in the list of active animatables (default: 0)\n   */\n  constructor(scene, /** defines the target object */\n  target, /** defines the starting frame number (default is 0) */\n  fromFrame = 0, /** defines the ending frame number (default is 100) */\n  toFrame = 100, /** defines if the animation must loop (default is false)  */\n  loopAnimation = false, speedRatio = 1.0, /** defines a callback to call when animation ends if it is not looping */\n  onAnimationEnd, animations, /** defines a callback to call when animation loops */\n  onAnimationLoop, /** defines whether the animation should be evaluated additively */\n  isAdditive = false, /** defines the order in which this animatable should be processed in the list of active animatables (default: 0) */\n  playOrder = 0) {\n    this.target = target;\n    this.fromFrame = fromFrame;\n    this.toFrame = toFrame;\n    this.loopAnimation = loopAnimation;\n    this.onAnimationEnd = onAnimationEnd;\n    this.onAnimationLoop = onAnimationLoop;\n    this.isAdditive = isAdditive;\n    this.playOrder = playOrder;\n    this._localDelayOffset = null;\n    this._pausedDelay = null;\n    this._manualJumpDelay = null;\n    /** @hidden */\n    this._runtimeAnimations = new Array();\n    this._paused = false;\n    this._speedRatio = 1;\n    this._weight = -1.0;\n    this._syncRoot = null;\n    this._frameToSyncFromJump = null;\n    this._goToFrame = null;\n    /**\n     * Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.\n     * This will only apply for non looping animation (default is true)\n     */\n    this.disposeOnEnd = true;\n    /**\n     * Gets a boolean indicating if the animation has started\n     */\n    this.animationStarted = false;\n    /**\n     * Observer raised when the animation ends\n     */\n    this.onAnimationEndObservable = new Observable();\n    /**\n     * Observer raised when the animation loops\n     */\n    this.onAnimationLoopObservable = new Observable();\n    this._scene = scene;\n    if (animations) {\n      this.appendAnimations(target, animations);\n    }\n    this._speedRatio = speedRatio;\n    scene._activeAnimatables.push(this);\n  }\n  // Methods\n  /**\n   * Synchronize and normalize current Animatable with a source Animatable\n   * This is useful when using animation weights and when animations are not of the same length\n   * @param root defines the root Animatable to synchronize with (null to stop synchronizing)\n   * @returns the current Animatable\n   */\n  syncWith(root) {\n    this._syncRoot = root;\n    if (root) {\n      // Make sure this animatable will animate after the root\n      const index = this._scene._activeAnimatables.indexOf(this);\n      if (index > -1) {\n        this._scene._activeAnimatables.splice(index, 1);\n        this._scene._activeAnimatables.push(this);\n      }\n    }\n    return this;\n  }\n  /**\n   * Gets the list of runtime animations\n   * @returns an array of RuntimeAnimation\n   */\n  getAnimations() {\n    return this._runtimeAnimations;\n  }\n  /**\n   * Adds more animations to the current animatable\n   * @param target defines the target of the animations\n   * @param animations defines the new animations to add\n   */\n  appendAnimations(target, animations) {\n    for (let index = 0; index < animations.length; index++) {\n      const animation = animations[index];\n      const newRuntimeAnimation = new RuntimeAnimation(target, animation, this._scene, this);\n      newRuntimeAnimation._onLoop = () => {\n        this.onAnimationLoopObservable.notifyObservers(this);\n        if (this.onAnimationLoop) {\n          this.onAnimationLoop();\n        }\n      };\n      this._runtimeAnimations.push(newRuntimeAnimation);\n    }\n  }\n  /**\n   * Gets the source animation for a specific property\n   * @param property defines the property to look for\n   * @returns null or the source animation for the given property\n   */\n  getAnimationByTargetProperty(property) {\n    const runtimeAnimations = this._runtimeAnimations;\n    for (let index = 0; index < runtimeAnimations.length; index++) {\n      if (runtimeAnimations[index].animation.targetProperty === property) {\n        return runtimeAnimations[index].animation;\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets the runtime animation for a specific property\n   * @param property defines the property to look for\n   * @returns null or the runtime animation for the given property\n   */\n  getRuntimeAnimationByTargetProperty(property) {\n    const runtimeAnimations = this._runtimeAnimations;\n    for (let index = 0; index < runtimeAnimations.length; index++) {\n      if (runtimeAnimations[index].animation.targetProperty === property) {\n        return runtimeAnimations[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Resets the animatable to its original state\n   */\n  reset() {\n    const runtimeAnimations = this._runtimeAnimations;\n    for (let index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].reset(true);\n    }\n    this._localDelayOffset = null;\n    this._pausedDelay = null;\n  }\n  /**\n   * Allows the animatable to blend with current running animations\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\n   * @param blendingSpeed defines the blending speed to use\n   */\n  enableBlending(blendingSpeed) {\n    const runtimeAnimations = this._runtimeAnimations;\n    for (let index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].animation.enableBlending = true;\n      runtimeAnimations[index].animation.blendingSpeed = blendingSpeed;\n    }\n  }\n  /**\n   * Disable animation blending\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\n   */\n  disableBlending() {\n    const runtimeAnimations = this._runtimeAnimations;\n    for (let index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].animation.enableBlending = false;\n    }\n  }\n  /**\n   * Jump directly to a given frame\n   * @param frame defines the frame to jump to\n   */\n  goToFrame(frame) {\n    var _a;\n    const runtimeAnimations = this._runtimeAnimations;\n    if (runtimeAnimations[0]) {\n      const fps = runtimeAnimations[0].animation.framePerSecond;\n      this._frameToSyncFromJump = (_a = this._frameToSyncFromJump) !== null && _a !== void 0 ? _a : runtimeAnimations[0].currentFrame;\n      const delay = this.speedRatio === 0 ? 0 : (frame - this._frameToSyncFromJump) / fps * 1000 / this.speedRatio;\n      this._manualJumpDelay = -delay;\n    }\n    for (let index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].goToFrame(frame);\n    }\n    this._goToFrame = frame;\n  }\n  /**\n   * Returns true if the animations for this animatable are paused\n   */\n  get paused() {\n    return this._paused;\n  }\n  /**\n   * Pause the animation\n   */\n  pause() {\n    if (this._paused) {\n      return;\n    }\n    this._paused = true;\n  }\n  /**\n   * Restart the animation\n   */\n  restart() {\n    this._paused = false;\n  }\n  _raiseOnAnimationEnd() {\n    if (this.onAnimationEnd) {\n      this.onAnimationEnd();\n    }\n    this.onAnimationEndObservable.notifyObservers(this);\n  }\n  /**\n   * Stop and delete the current animation\n   * @param animationName defines a string used to only stop some of the runtime animations instead of all\n   * @param targetMask a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\n   * @param useGlobalSplice if true, the animatables will be removed by the caller of this function (false by default)\n   */\n  stop(animationName, targetMask, useGlobalSplice = false) {\n    if (animationName || targetMask) {\n      const idx = this._scene._activeAnimatables.indexOf(this);\n      if (idx > -1) {\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = runtimeAnimations.length - 1; index >= 0; index--) {\n          const runtimeAnimation = runtimeAnimations[index];\n          if (animationName && runtimeAnimation.animation.name != animationName) {\n            continue;\n          }\n          if (targetMask && !targetMask(runtimeAnimation.target)) {\n            continue;\n          }\n          runtimeAnimation.dispose();\n          runtimeAnimations.splice(index, 1);\n        }\n        if (runtimeAnimations.length == 0) {\n          if (!useGlobalSplice) {\n            this._scene._activeAnimatables.splice(idx, 1);\n          }\n          this._raiseOnAnimationEnd();\n        }\n      }\n    } else {\n      const index = this._scene._activeAnimatables.indexOf(this);\n      if (index > -1) {\n        if (!useGlobalSplice) {\n          this._scene._activeAnimatables.splice(index, 1);\n        }\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n          runtimeAnimations[index].dispose();\n        }\n        this._runtimeAnimations.length = 0;\n        this._raiseOnAnimationEnd();\n      }\n    }\n  }\n  /**\n   * Wait asynchronously for the animation to end\n   * @returns a promise which will be fulfilled when the animation ends\n   */\n  waitAsync() {\n    return new Promise(resolve => {\n      this.onAnimationEndObservable.add(() => {\n        resolve(this);\n      }, undefined, undefined, this, true);\n    });\n  }\n  /**\n   * @internal\n   */\n  _animate(delay) {\n    if (this._paused) {\n      this.animationStarted = false;\n      if (this._pausedDelay === null) {\n        this._pausedDelay = delay;\n      }\n      return true;\n    }\n    if (this._localDelayOffset === null) {\n      this._localDelayOffset = delay;\n      this._pausedDelay = null;\n    } else if (this._pausedDelay !== null) {\n      this._localDelayOffset += delay - this._pausedDelay;\n      this._pausedDelay = null;\n    }\n    if (this._manualJumpDelay !== null) {\n      this._localDelayOffset += this._manualJumpDelay;\n      this._manualJumpDelay = null;\n      this._frameToSyncFromJump = null;\n    }\n    this._goToFrame = null;\n    if (this._weight === 0) {\n      // We consider that an animatable with a weight === 0 is \"actively\" paused\n      return true;\n    }\n    // Animating\n    let running = false;\n    const runtimeAnimations = this._runtimeAnimations;\n    let index;\n    for (index = 0; index < runtimeAnimations.length; index++) {\n      const animation = runtimeAnimations[index];\n      const isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);\n      running = running || isRunning;\n    }\n    this.animationStarted = running;\n    if (!running) {\n      if (this.disposeOnEnd) {\n        // Remove from active animatables\n        index = this._scene._activeAnimatables.indexOf(this);\n        this._scene._activeAnimatables.splice(index, 1);\n        // Dispose all runtime animations\n        for (index = 0; index < runtimeAnimations.length; index++) {\n          runtimeAnimations[index].dispose();\n        }\n      }\n      this._raiseOnAnimationEnd();\n      if (this.disposeOnEnd) {\n        this.onAnimationEnd = null;\n        this.onAnimationLoop = null;\n        this.onAnimationLoopObservable.clear();\n        this.onAnimationEndObservable.clear();\n      }\n    }\n    return running;\n  }\n}\nScene.prototype._animate = function () {\n  if (!this.animationsEnabled) {\n    return;\n  }\n  // Getting time\n  const now = PrecisionDate.Now;\n  if (!this._animationTimeLast) {\n    if (this._pendingData.length > 0) {\n      return;\n    }\n    this._animationTimeLast = now;\n  }\n  this.deltaTime = this.useConstantAnimationDeltaTime ? 16.0 : (now - this._animationTimeLast) * this.animationTimeScale;\n  this._animationTimeLast = now;\n  const animatables = this._activeAnimatables;\n  if (animatables.length === 0) {\n    return;\n  }\n  this._animationTime += this.deltaTime;\n  const animationTime = this._animationTime;\n  for (let index = 0; index < animatables.length; index++) {\n    const animatable = animatables[index];\n    if (!animatable._animate(animationTime) && animatable.disposeOnEnd) {\n      index--; // Array was updated\n    }\n  }\n  // Late animation bindings\n  this._processLateAnimationBindings();\n};\nScene.prototype.sortActiveAnimatables = function () {\n  this._activeAnimatables.sort((a, b) => {\n    return a.playOrder - b.playOrder;\n  });\n};\nScene.prototype.beginWeightedAnimation = function (target, from, to, weight = 1.0, loop, speedRatio = 1.0, onAnimationEnd, animatable, targetMask, onAnimationLoop, isAdditive = false) {\n  const returnedAnimatable = this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, false, targetMask, onAnimationLoop, isAdditive);\n  returnedAnimatable.weight = weight;\n  return returnedAnimatable;\n};\nScene.prototype.beginAnimation = function (target, from, to, loop, speedRatio = 1.0, onAnimationEnd, animatable, stopCurrent = true, targetMask, onAnimationLoop, isAdditive = false) {\n  if (from > to && speedRatio > 0) {\n    speedRatio *= -1;\n  }\n  if (stopCurrent) {\n    this.stopAnimation(target, undefined, targetMask);\n  }\n  if (!animatable) {\n    animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, undefined, onAnimationLoop, isAdditive);\n  }\n  const shouldRunTargetAnimations = targetMask ? targetMask(target) : true;\n  // Local animations\n  if (target.animations && shouldRunTargetAnimations) {\n    animatable.appendAnimations(target, target.animations);\n  }\n  // Children animations\n  if (target.getAnimatables) {\n    const animatables = target.getAnimatables();\n    for (let index = 0; index < animatables.length; index++) {\n      this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop);\n    }\n  }\n  animatable.reset();\n  return animatable;\n};\nScene.prototype.beginHierarchyAnimation = function (target, directDescendantsOnly, from, to, loop, speedRatio = 1.0, onAnimationEnd, animatable, stopCurrent = true, targetMask, onAnimationLoop, isAdditive = false) {\n  const children = target.getDescendants(directDescendantsOnly);\n  const result = [];\n  result.push(this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\n  for (const child of children) {\n    result.push(this.beginAnimation(child, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\n  }\n  return result;\n};\nScene.prototype.beginDirectAnimation = function (target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive = false) {\n  if (speedRatio === undefined) {\n    speedRatio = 1.0;\n  }\n  if (from > to && speedRatio > 0) {\n    speedRatio *= -1;\n  } else if (to > from && speedRatio < 0) {\n    const temp = to;\n    to = from;\n    from = temp;\n  }\n  const animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive);\n  return animatable;\n};\nScene.prototype.beginDirectHierarchyAnimation = function (target, directDescendantsOnly, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive = false) {\n  const children = target.getDescendants(directDescendantsOnly);\n  const result = [];\n  result.push(this.beginDirectAnimation(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\n  for (const child of children) {\n    result.push(this.beginDirectAnimation(child, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\n  }\n  return result;\n};\nScene.prototype.getAnimatableByTarget = function (target) {\n  for (let index = 0; index < this._activeAnimatables.length; index++) {\n    if (this._activeAnimatables[index].target === target) {\n      return this._activeAnimatables[index];\n    }\n  }\n  return null;\n};\nScene.prototype.getAllAnimatablesByTarget = function (target) {\n  const result = [];\n  for (let index = 0; index < this._activeAnimatables.length; index++) {\n    if (this._activeAnimatables[index].target === target) {\n      result.push(this._activeAnimatables[index]);\n    }\n  }\n  return result;\n};\n/**\n * Will stop the animation of the given target\n * @param target - the target\n * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\n * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\n */\nScene.prototype.stopAnimation = function (target, animationName, targetMask) {\n  const animatables = this.getAllAnimatablesByTarget(target);\n  for (const animatable of animatables) {\n    animatable.stop(animationName, targetMask);\n  }\n};\n/**\n * Stops and removes all animations that have been applied to the scene\n */\nScene.prototype.stopAllAnimations = function () {\n  if (this._activeAnimatables) {\n    for (let i = 0; i < this._activeAnimatables.length; i++) {\n      this._activeAnimatables[i].stop(undefined, undefined, true);\n    }\n    this._activeAnimatables.length = 0;\n  }\n  for (const group of this.animationGroups) {\n    group.stop();\n  }\n};\nScene.prototype._registerTargetForLateAnimationBinding = function (runtimeAnimation, originalValue) {\n  const target = runtimeAnimation.target;\n  this._registeredForLateAnimationBindings.pushNoDuplicate(target);\n  if (!target._lateAnimationHolders) {\n    target._lateAnimationHolders = {};\n  }\n  if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\n    target._lateAnimationHolders[runtimeAnimation.targetPath] = {\n      totalWeight: 0,\n      totalAdditiveWeight: 0,\n      animations: [],\n      additiveAnimations: [],\n      originalValue: originalValue\n    };\n  }\n  if (runtimeAnimation.isAdditive) {\n    target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\n    target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\n  } else {\n    target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\n    target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\n  }\n};\nScene.prototype._processLateAnimationBindingsForMatrices = function (holder) {\n  if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\n    return holder.originalValue;\n  }\n  let normalizer = 1.0;\n  const finalPosition = TmpVectors.Vector3[0];\n  const finalScaling = TmpVectors.Vector3[1];\n  const finalQuaternion = TmpVectors.Quaternion[0];\n  let startIndex = 0;\n  const originalAnimation = holder.animations[0];\n  const originalValue = holder.originalValue;\n  let scale = 1;\n  let skipOverride = false;\n  if (holder.totalWeight < 1.0) {\n    // We need to mix the original value in\n    scale = 1.0 - holder.totalWeight;\n    originalValue.decompose(finalScaling, finalQuaternion, finalPosition);\n  } else {\n    startIndex = 1;\n    // We need to normalize the weights\n    normalizer = holder.totalWeight;\n    scale = originalAnimation.weight / normalizer;\n    if (scale == 1) {\n      if (holder.totalAdditiveWeight) {\n        skipOverride = true;\n      } else {\n        return originalAnimation.currentValue;\n      }\n    }\n    originalAnimation.currentValue.decompose(finalScaling, finalQuaternion, finalPosition);\n  }\n  // Add up the override animations\n  if (!skipOverride) {\n    finalScaling.scaleInPlace(scale);\n    finalPosition.scaleInPlace(scale);\n    finalQuaternion.scaleInPlace(scale);\n    for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\n      const runtimeAnimation = holder.animations[animIndex];\n      if (runtimeAnimation.weight === 0) {\n        continue;\n      }\n      scale = runtimeAnimation.weight / normalizer;\n      const currentPosition = TmpVectors.Vector3[2];\n      const currentScaling = TmpVectors.Vector3[3];\n      const currentQuaternion = TmpVectors.Quaternion[1];\n      runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\n      currentScaling.scaleAndAddToRef(scale, finalScaling);\n      currentQuaternion.scaleAndAddToRef(Quaternion.Dot(finalQuaternion, currentQuaternion) > 0 ? scale : -scale, finalQuaternion);\n      currentPosition.scaleAndAddToRef(scale, finalPosition);\n    }\n    finalQuaternion.normalize();\n  }\n  // Add up the additive animations\n  for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\n    const runtimeAnimation = holder.additiveAnimations[animIndex];\n    if (runtimeAnimation.weight === 0) {\n      continue;\n    }\n    const currentPosition = TmpVectors.Vector3[2];\n    const currentScaling = TmpVectors.Vector3[3];\n    const currentQuaternion = TmpVectors.Quaternion[1];\n    runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\n    currentScaling.multiplyToRef(finalScaling, currentScaling);\n    Vector3.LerpToRef(finalScaling, currentScaling, runtimeAnimation.weight, finalScaling);\n    finalQuaternion.multiplyToRef(currentQuaternion, currentQuaternion);\n    Quaternion.SlerpToRef(finalQuaternion, currentQuaternion, runtimeAnimation.weight, finalQuaternion);\n    currentPosition.scaleAndAddToRef(runtimeAnimation.weight, finalPosition);\n  }\n  const workValue = originalAnimation ? originalAnimation._animationState.workValue : TmpVectors.Matrix[0].clone();\n  Matrix.ComposeToRef(finalScaling, finalQuaternion, finalPosition, workValue);\n  return workValue;\n};\nScene.prototype._processLateAnimationBindingsForQuaternions = function (holder, refQuaternion) {\n  if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\n    return refQuaternion;\n  }\n  const originalAnimation = holder.animations[0];\n  const originalValue = holder.originalValue;\n  let cumulativeQuaternion = refQuaternion;\n  if (holder.totalWeight === 0 && holder.totalAdditiveWeight > 0) {\n    cumulativeQuaternion.copyFrom(originalValue);\n  } else if (holder.animations.length === 1) {\n    Quaternion.SlerpToRef(originalValue, originalAnimation.currentValue, Math.min(1.0, holder.totalWeight), cumulativeQuaternion);\n    if (holder.totalAdditiveWeight === 0) {\n      return cumulativeQuaternion;\n    }\n  } else if (holder.animations.length > 1) {\n    // Add up the override animations\n    let normalizer = 1.0;\n    let quaternions;\n    let weights;\n    if (holder.totalWeight < 1.0) {\n      const scale = 1.0 - holder.totalWeight;\n      quaternions = [];\n      weights = [];\n      quaternions.push(originalValue);\n      weights.push(scale);\n    } else {\n      if (holder.animations.length === 2) {\n        // Slerp as soon as we can\n        Quaternion.SlerpToRef(holder.animations[0].currentValue, holder.animations[1].currentValue, holder.animations[1].weight / holder.totalWeight, refQuaternion);\n        if (holder.totalAdditiveWeight === 0) {\n          return refQuaternion;\n        }\n      }\n      quaternions = [];\n      weights = [];\n      normalizer = holder.totalWeight;\n    }\n    for (let animIndex = 0; animIndex < holder.animations.length; animIndex++) {\n      const runtimeAnimation = holder.animations[animIndex];\n      quaternions.push(runtimeAnimation.currentValue);\n      weights.push(runtimeAnimation.weight / normalizer);\n    }\n    // https://gamedev.stackexchange.com/questions/62354/method-for-interpolation-between-3-quaternions\n    let cumulativeAmount = 0;\n    for (let index = 0; index < quaternions.length;) {\n      if (!index) {\n        Quaternion.SlerpToRef(quaternions[index], quaternions[index + 1], weights[index + 1] / (weights[index] + weights[index + 1]), refQuaternion);\n        cumulativeQuaternion = refQuaternion;\n        cumulativeAmount = weights[index] + weights[index + 1];\n        index += 2;\n        continue;\n      }\n      cumulativeAmount += weights[index];\n      Quaternion.SlerpToRef(cumulativeQuaternion, quaternions[index], weights[index] / cumulativeAmount, cumulativeQuaternion);\n      index++;\n    }\n  }\n  // Add up the additive animations\n  for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\n    const runtimeAnimation = holder.additiveAnimations[animIndex];\n    if (runtimeAnimation.weight === 0) {\n      continue;\n    }\n    cumulativeQuaternion.multiplyToRef(runtimeAnimation.currentValue, TmpVectors.Quaternion[0]);\n    Quaternion.SlerpToRef(cumulativeQuaternion, TmpVectors.Quaternion[0], runtimeAnimation.weight, cumulativeQuaternion);\n  }\n  return cumulativeQuaternion;\n};\nScene.prototype._processLateAnimationBindings = function () {\n  if (!this._registeredForLateAnimationBindings.length) {\n    return;\n  }\n  for (let index = 0; index < this._registeredForLateAnimationBindings.length; index++) {\n    const target = this._registeredForLateAnimationBindings.data[index];\n    for (const path in target._lateAnimationHolders) {\n      const holder = target._lateAnimationHolders[path];\n      const originalAnimation = holder.animations[0];\n      const originalValue = holder.originalValue;\n      if (originalValue === undefined || originalValue === null) {\n        continue;\n      }\n      const matrixDecomposeMode = Animation.AllowMatrixDecomposeForInterpolation && originalValue.m; // ie. data is matrix\n      let finalValue = target[path];\n      if (matrixDecomposeMode) {\n        finalValue = this._processLateAnimationBindingsForMatrices(holder);\n      } else {\n        const quaternionMode = originalValue.w !== undefined;\n        if (quaternionMode) {\n          finalValue = this._processLateAnimationBindingsForQuaternions(holder, finalValue || Quaternion.Identity());\n        } else {\n          let startIndex = 0;\n          let normalizer = 1.0;\n          if (holder.totalWeight < 1.0) {\n            // We need to mix the original value in\n            if (originalAnimation && originalValue.scale) {\n              finalValue = originalValue.scale(1.0 - holder.totalWeight);\n            } else if (originalAnimation) {\n              finalValue = originalValue * (1.0 - holder.totalWeight);\n            } else if (originalValue.clone) {\n              finalValue = originalValue.clone();\n            } else {\n              finalValue = originalValue;\n            }\n          } else if (originalAnimation) {\n            // We need to normalize the weights\n            normalizer = holder.totalWeight;\n            const scale = originalAnimation.weight / normalizer;\n            if (scale !== 1) {\n              if (originalAnimation.currentValue.scale) {\n                finalValue = originalAnimation.currentValue.scale(scale);\n              } else {\n                finalValue = originalAnimation.currentValue * scale;\n              }\n            } else {\n              finalValue = originalAnimation.currentValue;\n            }\n            startIndex = 1;\n          }\n          // Add up the override animations\n          for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\n            const runtimeAnimation = holder.animations[animIndex];\n            const scale = runtimeAnimation.weight / normalizer;\n            if (!scale) {\n              continue;\n            } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\n              runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\n            } else {\n              finalValue += runtimeAnimation.currentValue * scale;\n            }\n          }\n          // Add up the additive animations\n          for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\n            const runtimeAnimation = holder.additiveAnimations[animIndex];\n            const scale = runtimeAnimation.weight;\n            if (!scale) {\n              continue;\n            } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\n              runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\n            } else {\n              finalValue += runtimeAnimation.currentValue * scale;\n            }\n          }\n        }\n      }\n      target[path] = finalValue;\n    }\n    target._lateAnimationHolders = {};\n  }\n  this._registeredForLateAnimationBindings.reset();\n};\nBone.prototype.copyAnimationRange = function (source, rangeName, frameOffset, rescaleAsRequired = false, skelDimensionsRatio = null) {\n  // all animation may be coming from a library skeleton, so may need to create animation\n  if (this.animations.length === 0) {\n    this.animations.push(new Animation(this.name, \"_matrix\", source.animations[0].framePerSecond, Animation.ANIMATIONTYPE_MATRIX, 0));\n    this.animations[0].setKeys([]);\n  }\n  // get animation info / verify there is such a range from the source bone\n  const sourceRange = source.animations[0].getRange(rangeName);\n  if (!sourceRange) {\n    return false;\n  }\n  const from = sourceRange.from;\n  const to = sourceRange.to;\n  const sourceKeys = source.animations[0].getKeys();\n  // rescaling prep\n  const sourceBoneLength = source.length;\n  const sourceParent = source.getParent();\n  const parent = this.getParent();\n  const parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;\n  const parentRatio = parentScalingReqd && parent && sourceParent ? parent.length / sourceParent.length : 1;\n  const dimensionsScalingReqd = rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);\n  const destKeys = this.animations[0].getKeys();\n  // loop vars declaration\n  let orig;\n  let origTranslation;\n  let mat;\n  for (let key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {\n    orig = sourceKeys[key];\n    if (orig.frame >= from && orig.frame <= to) {\n      if (rescaleAsRequired) {\n        mat = orig.value.clone();\n        // scale based on parent ratio, when bone has parent\n        if (parentScalingReqd) {\n          origTranslation = mat.getTranslation();\n          mat.setTranslation(origTranslation.scaleInPlace(parentRatio));\n          // scale based on skeleton dimension ratio when root bone, and value is passed\n        } else if (dimensionsScalingReqd && skelDimensionsRatio) {\n          origTranslation = mat.getTranslation();\n          mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio));\n          // use original when root bone, and no data for skelDimensionsRatio\n        } else {\n          mat = orig.value;\n        }\n      } else {\n        mat = orig.value;\n      }\n      destKeys.push({\n        frame: orig.frame + frameOffset,\n        value: mat\n      });\n    }\n  }\n  this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);\n  return true;\n};","map":{"version":3,"names":["Animation","RuntimeAnimation","Observable","Scene","Matrix","Quaternion","Vector3","TmpVectors","PrecisionDate","Bone","Animatable","syncRoot","_syncRoot","masterFrame","_runtimeAnimations","length","currentFrame","weight","_weight","value","Math","min","max","speedRatio","_speedRatio","index","animation","_prepareForSpeedRatioChange","_goToFrame","goToFrame","elapsedTime","_localDelayOffset","_scene","_animationTime","constructor","scene","target","fromFrame","toFrame","loopAnimation","onAnimationEnd","animations","onAnimationLoop","isAdditive","playOrder","_pausedDelay","_manualJumpDelay","Array","_paused","_frameToSyncFromJump","disposeOnEnd","animationStarted","onAnimationEndObservable","onAnimationLoopObservable","appendAnimations","_activeAnimatables","push","syncWith","root","indexOf","splice","getAnimations","newRuntimeAnimation","_onLoop","notifyObservers","getAnimationByTargetProperty","property","runtimeAnimations","targetProperty","getRuntimeAnimationByTargetProperty","reset","enableBlending","blendingSpeed","disableBlending","frame","fps","framePerSecond","_a","delay","paused","pause","restart","_raiseOnAnimationEnd","stop","animationName","targetMask","useGlobalSplice","idx","runtimeAnimation","name","dispose","waitAsync","Promise","resolve","add","undefined","_animate","running","isRunning","animate","clear","prototype","animationsEnabled","now","Now","_animationTimeLast","_pendingData","deltaTime","useConstantAnimationDeltaTime","animationTimeScale","animatables","animationTime","animatable","_processLateAnimationBindings","sortActiveAnimatables","sort","a","b","beginWeightedAnimation","from","to","loop","returnedAnimatable","beginAnimation","stopCurrent","stopAnimation","shouldRunTargetAnimations","getAnimatables","beginHierarchyAnimation","directDescendantsOnly","children","getDescendants","result","child","beginDirectAnimation","temp","beginDirectHierarchyAnimation","getAnimatableByTarget","getAllAnimatablesByTarget","stopAllAnimations","i","group","animationGroups","_registerTargetForLateAnimationBinding","originalValue","_registeredForLateAnimationBindings","pushNoDuplicate","_lateAnimationHolders","targetPath","totalWeight","totalAdditiveWeight","additiveAnimations","_processLateAnimationBindingsForMatrices","holder","normalizer","finalPosition","finalScaling","finalQuaternion","startIndex","originalAnimation","scale","skipOverride","decompose","currentValue","scaleInPlace","animIndex","currentPosition","currentScaling","currentQuaternion","scaleAndAddToRef","Dot","normalize","multiplyToRef","LerpToRef","SlerpToRef","workValue","_animationState","clone","ComposeToRef","_processLateAnimationBindingsForQuaternions","refQuaternion","cumulativeQuaternion","copyFrom","quaternions","weights","cumulativeAmount","data","path","matrixDecomposeMode","AllowMatrixDecomposeForInterpolation","m","finalValue","quaternionMode","w","Identity","copyAnimationRange","source","rangeName","frameOffset","rescaleAsRequired","skelDimensionsRatio","ANIMATIONTYPE_MATRIX","setKeys","sourceRange","getRange","sourceKeys","getKeys","sourceBoneLength","sourceParent","getParent","parent","parentScalingReqd","parentRatio","dimensionsScalingReqd","x","y","z","destKeys","orig","origTranslation","mat","key","nKeys","getTranslation","setTranslation","multiplyInPlace","createRange"],"sources":["../../../../dev/core/src/Animations/animatable.ts"],"sourcesContent":["import { Animation } from \"./animation\";\r\nimport { RuntimeAnimation } from \"./runtimeAnimation\";\r\n\r\nimport type { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix, Quaternion, Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport { PrecisionDate } from \"../Misc/precisionDate\";\r\nimport { Bone } from \"../Bones/bone\";\r\nimport type { Node } from \"../node\";\r\n\r\n/**\r\n * Class used to store an actual running animation\r\n */\r\nexport class Animatable {\r\n    private _localDelayOffset: Nullable<number> = null;\r\n    private _pausedDelay: Nullable<number> = null;\r\n    private _manualJumpDelay: Nullable<number> = null;\r\n    /** @hidden */\r\n    public _runtimeAnimations = new Array<RuntimeAnimation>();\r\n    private _paused = false;\r\n    private _scene: Scene;\r\n    private _speedRatio = 1;\r\n    private _weight = -1.0;\r\n    private _syncRoot: Nullable<Animatable> = null;\r\n    private _frameToSyncFromJump: Nullable<number> = null;\r\n    private _goToFrame: Nullable<number> = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.\r\n     * This will only apply for non looping animation (default is true)\r\n     */\r\n    public disposeOnEnd = true;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the animation has started\r\n     */\r\n    public animationStarted = false;\r\n\r\n    /**\r\n     * Observer raised when the animation ends\r\n     */\r\n    public onAnimationEndObservable = new Observable<Animatable>();\r\n\r\n    /**\r\n     * Observer raised when the animation loops\r\n     */\r\n    public onAnimationLoopObservable = new Observable<Animatable>();\r\n\r\n    /**\r\n     * Gets the root Animatable used to synchronize and normalize animations\r\n     */\r\n    public get syncRoot(): Nullable<Animatable> {\r\n        return this._syncRoot;\r\n    }\r\n\r\n    /**\r\n     * Gets the current frame of the first RuntimeAnimation\r\n     * Used to synchronize Animatables\r\n     */\r\n    public get masterFrame(): number {\r\n        if (this._runtimeAnimations.length === 0) {\r\n            return 0;\r\n        }\r\n\r\n        return this._runtimeAnimations[0].currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the animatable weight (-1.0 by default meaning not weighted)\r\n     */\r\n    public get weight(): number {\r\n        return this._weight;\r\n    }\r\n\r\n    public set weight(value: number) {\r\n        if (value === -1) {\r\n            // -1 is ok and means no weight\r\n            this._weight = -1;\r\n            return;\r\n        }\r\n\r\n        // Else weight must be in [0, 1] range\r\n        this._weight = Math.min(Math.max(value, 0), 1.0);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the speed ratio to apply to the animatable (1.0 by default)\r\n     */\r\n    public get speedRatio(): number {\r\n        return this._speedRatio;\r\n    }\r\n\r\n    public set speedRatio(value: number) {\r\n        for (let index = 0; index < this._runtimeAnimations.length; index++) {\r\n            const animation = this._runtimeAnimations[index];\r\n\r\n            animation._prepareForSpeedRatioChange(value);\r\n        }\r\n        this._speedRatio = value;\r\n\r\n        // Resync _manualJumpDelay in case goToFrame was called before speedRatio was set.\r\n        if (this._goToFrame !== null) {\r\n            this.goToFrame(this._goToFrame);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the elapsed time since the animatable started in milliseconds\r\n     */\r\n    public get elapsedTime(): number {\r\n        return this._localDelayOffset === null ? 0 : this._scene._animationTime - this._localDelayOffset;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Animatable\r\n     * @param scene defines the hosting scene\r\n     * @param target defines the target object\r\n     * @param fromFrame defines the starting frame number (default is 0)\r\n     * @param toFrame defines the ending frame number (default is 100)\r\n     * @param loopAnimation defines if the animation must loop (default is false)\r\n     * @param speedRatio defines the factor to apply to animation speed (default is 1)\r\n     * @param onAnimationEnd defines a callback to call when animation ends if it is not looping\r\n     * @param animations defines a group of animation to add to the new Animatable\r\n     * @param onAnimationLoop defines a callback to call when animation loops\r\n     * @param isAdditive defines whether the animation should be evaluated additively\r\n     * @param playOrder defines the order in which this animatable should be processed in the list of active animatables (default: 0)\r\n     */\r\n    constructor(\r\n        scene: Scene,\r\n        /** defines the target object */\r\n        public target: any,\r\n        /** defines the starting frame number (default is 0) */\r\n        public fromFrame: number = 0,\r\n        /** defines the ending frame number (default is 100) */\r\n        public toFrame: number = 100,\r\n        /** defines if the animation must loop (default is false)  */\r\n        public loopAnimation: boolean = false,\r\n        speedRatio: number = 1.0,\r\n        /** defines a callback to call when animation ends if it is not looping */\r\n        public onAnimationEnd?: Nullable<() => void>,\r\n        animations?: Animation[],\r\n        /** defines a callback to call when animation loops */\r\n        public onAnimationLoop?: Nullable<() => void>,\r\n        /** defines whether the animation should be evaluated additively */\r\n        public isAdditive: boolean = false,\r\n        /** defines the order in which this animatable should be processed in the list of active animatables (default: 0) */\r\n        public playOrder = 0\r\n    ) {\r\n        this._scene = scene;\r\n        if (animations) {\r\n            this.appendAnimations(target, animations);\r\n        }\r\n\r\n        this._speedRatio = speedRatio;\r\n        scene._activeAnimatables.push(this);\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Synchronize and normalize current Animatable with a source Animatable\r\n     * This is useful when using animation weights and when animations are not of the same length\r\n     * @param root defines the root Animatable to synchronize with (null to stop synchronizing)\r\n     * @returns the current Animatable\r\n     */\r\n    public syncWith(root: Nullable<Animatable>): Animatable {\r\n        this._syncRoot = root;\r\n\r\n        if (root) {\r\n            // Make sure this animatable will animate after the root\r\n            const index = this._scene._activeAnimatables.indexOf(this);\r\n            if (index > -1) {\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n                this._scene._activeAnimatables.push(this);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of runtime animations\r\n     * @returns an array of RuntimeAnimation\r\n     */\r\n    public getAnimations(): RuntimeAnimation[] {\r\n        return this._runtimeAnimations;\r\n    }\r\n\r\n    /**\r\n     * Adds more animations to the current animatable\r\n     * @param target defines the target of the animations\r\n     * @param animations defines the new animations to add\r\n     */\r\n    public appendAnimations(target: any, animations: Animation[]): void {\r\n        for (let index = 0; index < animations.length; index++) {\r\n            const animation = animations[index];\r\n\r\n            const newRuntimeAnimation = new RuntimeAnimation(target, animation, this._scene, this);\r\n            newRuntimeAnimation._onLoop = () => {\r\n                this.onAnimationLoopObservable.notifyObservers(this);\r\n                if (this.onAnimationLoop) {\r\n                    this.onAnimationLoop();\r\n                }\r\n            };\r\n\r\n            this._runtimeAnimations.push(newRuntimeAnimation);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the source animation for a specific property\r\n     * @param property defines the property to look for\r\n     * @returns null or the source animation for the given property\r\n     */\r\n    public getAnimationByTargetProperty(property: string): Nullable<Animation> {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            if (runtimeAnimations[index].animation.targetProperty === property) {\r\n                return runtimeAnimations[index].animation;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the runtime animation for a specific property\r\n     * @param property defines the property to look for\r\n     * @returns null or the runtime animation for the given property\r\n     */\r\n    public getRuntimeAnimationByTargetProperty(property: string): Nullable<RuntimeAnimation> {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            if (runtimeAnimations[index].animation.targetProperty === property) {\r\n                return runtimeAnimations[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Resets the animatable to its original state\r\n     */\r\n    public reset(): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].reset(true);\r\n        }\r\n\r\n        this._localDelayOffset = null;\r\n        this._pausedDelay = null;\r\n    }\r\n\r\n    /**\r\n     * Allows the animatable to blend with current running animations\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\r\n     * @param blendingSpeed defines the blending speed to use\r\n     */\r\n    public enableBlending(blendingSpeed: number): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].animation.enableBlending = true;\r\n            runtimeAnimations[index].animation.blendingSpeed = blendingSpeed;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable animation blending\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\r\n     */\r\n    public disableBlending(): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].animation.enableBlending = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Jump directly to a given frame\r\n     * @param frame defines the frame to jump to\r\n     */\r\n    public goToFrame(frame: number): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        if (runtimeAnimations[0]) {\r\n            const fps = runtimeAnimations[0].animation.framePerSecond;\r\n            this._frameToSyncFromJump = this._frameToSyncFromJump ?? runtimeAnimations[0].currentFrame;\r\n            const delay = this.speedRatio === 0 ? 0 : (((frame - this._frameToSyncFromJump) / fps) * 1000) / this.speedRatio;\r\n            this._manualJumpDelay = -delay;\r\n        }\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].goToFrame(frame);\r\n        }\r\n\r\n        this._goToFrame = frame;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the animations for this animatable are paused\r\n     */\r\n    public get paused() {\r\n        return this._paused;\r\n    }\r\n\r\n    /**\r\n     * Pause the animation\r\n     */\r\n    public pause(): void {\r\n        if (this._paused) {\r\n            return;\r\n        }\r\n        this._paused = true;\r\n    }\r\n\r\n    /**\r\n     * Restart the animation\r\n     */\r\n    public restart(): void {\r\n        this._paused = false;\r\n    }\r\n\r\n    private _raiseOnAnimationEnd() {\r\n        if (this.onAnimationEnd) {\r\n            this.onAnimationEnd();\r\n        }\r\n\r\n        this.onAnimationEndObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Stop and delete the current animation\r\n     * @param animationName defines a string used to only stop some of the runtime animations instead of all\r\n     * @param targetMask a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n     * @param useGlobalSplice if true, the animatables will be removed by the caller of this function (false by default)\r\n     */\r\n    public stop(animationName?: string, targetMask?: (target: any) => boolean, useGlobalSplice = false): void {\r\n        if (animationName || targetMask) {\r\n            const idx = this._scene._activeAnimatables.indexOf(this);\r\n\r\n            if (idx > -1) {\r\n                const runtimeAnimations = this._runtimeAnimations;\r\n\r\n                for (let index = runtimeAnimations.length - 1; index >= 0; index--) {\r\n                    const runtimeAnimation = runtimeAnimations[index];\r\n                    if (animationName && runtimeAnimation.animation.name != animationName) {\r\n                        continue;\r\n                    }\r\n                    if (targetMask && !targetMask(runtimeAnimation.target)) {\r\n                        continue;\r\n                    }\r\n\r\n                    runtimeAnimation.dispose();\r\n                    runtimeAnimations.splice(index, 1);\r\n                }\r\n\r\n                if (runtimeAnimations.length == 0) {\r\n                    if (!useGlobalSplice) {\r\n                        this._scene._activeAnimatables.splice(idx, 1);\r\n                    }\r\n                    this._raiseOnAnimationEnd();\r\n                }\r\n            }\r\n        } else {\r\n            const index = this._scene._activeAnimatables.indexOf(this);\r\n\r\n            if (index > -1) {\r\n                if (!useGlobalSplice) {\r\n                    this._scene._activeAnimatables.splice(index, 1);\r\n                }\r\n                const runtimeAnimations = this._runtimeAnimations;\r\n\r\n                for (let index = 0; index < runtimeAnimations.length; index++) {\r\n                    runtimeAnimations[index].dispose();\r\n                }\r\n\r\n                this._runtimeAnimations.length = 0;\r\n\r\n                this._raiseOnAnimationEnd();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Wait asynchronously for the animation to end\r\n     * @returns a promise which will be fulfilled when the animation ends\r\n     */\r\n    public waitAsync(): Promise<Animatable> {\r\n        return new Promise((resolve) => {\r\n            this.onAnimationEndObservable.add(\r\n                () => {\r\n                    resolve(this);\r\n                },\r\n                undefined,\r\n                undefined,\r\n                this,\r\n                true\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _animate(delay: number): boolean {\r\n        if (this._paused) {\r\n            this.animationStarted = false;\r\n            if (this._pausedDelay === null) {\r\n                this._pausedDelay = delay;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        if (this._localDelayOffset === null) {\r\n            this._localDelayOffset = delay;\r\n            this._pausedDelay = null;\r\n        } else if (this._pausedDelay !== null) {\r\n            this._localDelayOffset += delay - this._pausedDelay;\r\n            this._pausedDelay = null;\r\n        }\r\n\r\n        if (this._manualJumpDelay !== null) {\r\n            this._localDelayOffset += this._manualJumpDelay;\r\n            this._manualJumpDelay = null;\r\n            this._frameToSyncFromJump = null;\r\n        }\r\n\r\n        this._goToFrame = null;\r\n\r\n        if (this._weight === 0) {\r\n            // We consider that an animatable with a weight === 0 is \"actively\" paused\r\n            return true;\r\n        }\r\n\r\n        // Animating\r\n        let running = false;\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n        let index: number;\r\n\r\n        for (index = 0; index < runtimeAnimations.length; index++) {\r\n            const animation = runtimeAnimations[index];\r\n            const isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);\r\n            running = running || isRunning;\r\n        }\r\n\r\n        this.animationStarted = running;\r\n\r\n        if (!running) {\r\n            if (this.disposeOnEnd) {\r\n                // Remove from active animatables\r\n                index = this._scene._activeAnimatables.indexOf(this);\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n\r\n                // Dispose all runtime animations\r\n                for (index = 0; index < runtimeAnimations.length; index++) {\r\n                    runtimeAnimations[index].dispose();\r\n                }\r\n            }\r\n\r\n            this._raiseOnAnimationEnd();\r\n\r\n            if (this.disposeOnEnd) {\r\n                this.onAnimationEnd = null;\r\n                this.onAnimationLoop = null;\r\n                this.onAnimationLoopObservable.clear();\r\n                this.onAnimationEndObservable.clear();\r\n            }\r\n        }\r\n\r\n        return running;\r\n    }\r\n}\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @internal */\r\n        _registerTargetForLateAnimationBinding(runtimeAnimation: RuntimeAnimation, originalValue: any): void;\r\n\r\n        /** @internal */\r\n        _processLateAnimationBindingsForMatrices(holder: {\r\n            totalWeight: number;\r\n            totalAdditiveWeight: number;\r\n            animations: RuntimeAnimation[];\r\n            additiveAnimations: RuntimeAnimation[];\r\n            originalValue: Matrix;\r\n        }): any;\r\n\r\n        /** @internal */\r\n        _processLateAnimationBindingsForQuaternions(\r\n            holder: {\r\n                totalWeight: number;\r\n                totalAdditiveWeight: number;\r\n                animations: RuntimeAnimation[];\r\n                additiveAnimations: RuntimeAnimation[];\r\n                originalValue: Quaternion;\r\n            },\r\n            refQuaternion: Quaternion\r\n        ): Quaternion;\r\n\r\n        /** @internal */\r\n        _processLateAnimationBindings(): void;\r\n\r\n        /**\r\n         * Sort active animatables based on their playOrder property\r\n         */\r\n        sortActiveAnimatables(): void;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target\r\n         * @param target defines the target\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param weight defines the weight to apply to the animation (1.0 by default)\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param targetMask defines if the target should be animated if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the animatable object created for this animation\r\n         */\r\n        beginWeightedAnimation(\r\n            target: any,\r\n            from: number,\r\n            to: number,\r\n            weight: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            animatable?: Animatable,\r\n            targetMask?: (target: any) => boolean,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target\r\n         * @param target defines the target\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param stopCurrent defines if the current animations must be stopped first (true by default)\r\n         * @param targetMask defines if the target should be animate if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the animatable object created for this animation\r\n         */\r\n        beginAnimation(\r\n            target: any,\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            animatable?: Animatable,\r\n            stopCurrent?: boolean,\r\n            targetMask?: (target: any) => boolean,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target and its hierarchy\r\n         * @param target defines the target\r\n         * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param stopCurrent defines if the current animations must be stopped first (true by default)\r\n         * @param targetMask defines if the target should be animated if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of created animatables\r\n         */\r\n        beginHierarchyAnimation(\r\n            target: any,\r\n            directDescendantsOnly: boolean,\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            animatable?: Animatable,\r\n            stopCurrent?: boolean,\r\n            targetMask?: (target: any) => boolean,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable[];\r\n\r\n        /**\r\n         * Begin a new animation on a given node\r\n         * @param target defines the target where the animation will take place\r\n         * @param animations defines the list of animations to start\r\n         * @param from defines the initial value\r\n         * @param to defines the final value\r\n         * @param loop defines if you want animation to loop (off by default)\r\n         * @param speedRatio defines the speed ratio to apply to all animations\r\n         * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of created animatables\r\n         */\r\n        beginDirectAnimation(\r\n            target: any,\r\n            animations: Animation[],\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable;\r\n\r\n        /**\r\n         * Begin a new animation on a given node and its hierarchy\r\n         * @param target defines the root node where the animation will take place\r\n         * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.\r\n         * @param animations defines the list of animations to start\r\n         * @param from defines the initial value\r\n         * @param to defines the final value\r\n         * @param loop defines if you want animation to loop (off by default)\r\n         * @param speedRatio defines the speed ratio to apply to all animations\r\n         * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of animatables created for all nodes\r\n         */\r\n        beginDirectHierarchyAnimation(\r\n            target: Node,\r\n            directDescendantsOnly: boolean,\r\n            animations: Animation[],\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable[];\r\n\r\n        /**\r\n         * Gets the animatable associated with a specific target\r\n         * @param target defines the target of the animatable\r\n         * @returns the required animatable if found\r\n         */\r\n        getAnimatableByTarget(target: any): Nullable<Animatable>;\r\n\r\n        /**\r\n         * Gets all animatables associated with a given target\r\n         * @param target defines the target to look animatables for\r\n         * @returns an array of Animatables\r\n         */\r\n        getAllAnimatablesByTarget(target: any): Array<Animatable>;\r\n\r\n        /**\r\n         * Stops and removes all animations that have been applied to the scene\r\n         */\r\n        stopAllAnimations(): void;\r\n\r\n        /**\r\n         * Gets the current delta time used by animation engine\r\n         */\r\n        deltaTime: number;\r\n    }\r\n}\r\n\r\nScene.prototype._animate = function (): void {\r\n    if (!this.animationsEnabled) {\r\n        return;\r\n    }\r\n\r\n    // Getting time\r\n    const now = PrecisionDate.Now;\r\n    if (!this._animationTimeLast) {\r\n        if (this._pendingData.length > 0) {\r\n            return;\r\n        }\r\n        this._animationTimeLast = now;\r\n    }\r\n\r\n    this.deltaTime = this.useConstantAnimationDeltaTime ? 16.0 : (now - this._animationTimeLast) * this.animationTimeScale;\r\n    this._animationTimeLast = now;\r\n\r\n    const animatables = this._activeAnimatables;\r\n    if (animatables.length === 0) {\r\n        return;\r\n    }\r\n\r\n    this._animationTime += this.deltaTime;\r\n    const animationTime = this._animationTime;\r\n\r\n    for (let index = 0; index < animatables.length; index++) {\r\n        const animatable = animatables[index];\r\n\r\n        if (!animatable._animate(animationTime) && animatable.disposeOnEnd) {\r\n            index--; // Array was updated\r\n        }\r\n    }\r\n\r\n    // Late animation bindings\r\n    this._processLateAnimationBindings();\r\n};\r\n\r\nScene.prototype.sortActiveAnimatables = function (): void {\r\n    this._activeAnimatables.sort((a, b) => {\r\n        return a.playOrder - b.playOrder;\r\n    });\r\n};\r\n\r\nScene.prototype.beginWeightedAnimation = function (\r\n    target: any,\r\n    from: number,\r\n    to: number,\r\n    weight = 1.0,\r\n    loop?: boolean,\r\n    speedRatio: number = 1.0,\r\n    onAnimationEnd?: () => void,\r\n    animatable?: Animatable,\r\n    targetMask?: (target: any) => boolean,\r\n    onAnimationLoop?: () => void,\r\n    isAdditive = false\r\n): Animatable {\r\n    const returnedAnimatable = this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, false, targetMask, onAnimationLoop, isAdditive);\r\n    returnedAnimatable.weight = weight;\r\n\r\n    return returnedAnimatable;\r\n};\r\n\r\nScene.prototype.beginAnimation = function (\r\n    target: any,\r\n    from: number,\r\n    to: number,\r\n    loop?: boolean,\r\n    speedRatio: number = 1.0,\r\n    onAnimationEnd?: () => void,\r\n    animatable?: Animatable,\r\n    stopCurrent = true,\r\n    targetMask?: (target: any) => boolean,\r\n    onAnimationLoop?: () => void,\r\n    isAdditive = false\r\n): Animatable {\r\n    if (from > to && speedRatio > 0) {\r\n        speedRatio *= -1;\r\n    }\r\n\r\n    if (stopCurrent) {\r\n        this.stopAnimation(target, undefined, targetMask);\r\n    }\r\n\r\n    if (!animatable) {\r\n        animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, undefined, onAnimationLoop, isAdditive);\r\n    }\r\n\r\n    const shouldRunTargetAnimations = targetMask ? targetMask(target) : true;\r\n    // Local animations\r\n    if (target.animations && shouldRunTargetAnimations) {\r\n        animatable.appendAnimations(target, target.animations);\r\n    }\r\n\r\n    // Children animations\r\n    if (target.getAnimatables) {\r\n        const animatables = target.getAnimatables();\r\n        for (let index = 0; index < animatables.length; index++) {\r\n            this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop);\r\n        }\r\n    }\r\n\r\n    animatable.reset();\r\n\r\n    return animatable;\r\n};\r\n\r\nScene.prototype.beginHierarchyAnimation = function (\r\n    target: any,\r\n    directDescendantsOnly: boolean,\r\n    from: number,\r\n    to: number,\r\n    loop?: boolean,\r\n    speedRatio: number = 1.0,\r\n    onAnimationEnd?: () => void,\r\n    animatable?: Animatable,\r\n    stopCurrent = true,\r\n    targetMask?: (target: any) => boolean,\r\n    onAnimationLoop?: () => void,\r\n    isAdditive = false\r\n): Animatable[] {\r\n    const children = target.getDescendants(directDescendantsOnly);\r\n\r\n    const result = [];\r\n    result.push(this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\r\n    for (const child of children) {\r\n        result.push(this.beginAnimation(child, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.beginDirectAnimation = function (\r\n    target: any,\r\n    animations: Animation[],\r\n    from: number,\r\n    to: number,\r\n    loop?: boolean,\r\n    speedRatio?: number,\r\n    onAnimationEnd?: () => void,\r\n    onAnimationLoop?: () => void,\r\n    isAdditive = false\r\n): Animatable {\r\n    if (speedRatio === undefined) {\r\n        speedRatio = 1.0;\r\n    }\r\n\r\n    if (from > to && speedRatio > 0) {\r\n        speedRatio *= -1;\r\n    } else if (to > from && speedRatio < 0) {\r\n        const temp = to;\r\n        to = from;\r\n        from = temp;\r\n    }\r\n\r\n    const animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive);\r\n\r\n    return animatable;\r\n};\r\n\r\nScene.prototype.beginDirectHierarchyAnimation = function (\r\n    target: Node,\r\n    directDescendantsOnly: boolean,\r\n    animations: Animation[],\r\n    from: number,\r\n    to: number,\r\n    loop?: boolean,\r\n    speedRatio?: number,\r\n    onAnimationEnd?: () => void,\r\n    onAnimationLoop?: () => void,\r\n    isAdditive = false\r\n): Animatable[] {\r\n    const children = target.getDescendants(directDescendantsOnly);\r\n\r\n    const result = [];\r\n    result.push(this.beginDirectAnimation(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\r\n    for (const child of children) {\r\n        result.push(this.beginDirectAnimation(child, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.getAnimatableByTarget = function (target: any): Nullable<Animatable> {\r\n    for (let index = 0; index < this._activeAnimatables.length; index++) {\r\n        if (this._activeAnimatables[index].target === target) {\r\n            return this._activeAnimatables[index];\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\nScene.prototype.getAllAnimatablesByTarget = function (target: any): Array<Animatable> {\r\n    const result = [];\r\n    for (let index = 0; index < this._activeAnimatables.length; index++) {\r\n        if (this._activeAnimatables[index].target === target) {\r\n            result.push(this._activeAnimatables[index]);\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n/**\r\n * Will stop the animation of the given target\r\n * @param target - the target\r\n * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\r\n * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n */\r\nScene.prototype.stopAnimation = function (target: any, animationName?: string, targetMask?: (target: any) => boolean): void {\r\n    const animatables = this.getAllAnimatablesByTarget(target);\r\n\r\n    for (const animatable of animatables) {\r\n        animatable.stop(animationName, targetMask);\r\n    }\r\n};\r\n\r\n/**\r\n * Stops and removes all animations that have been applied to the scene\r\n */\r\nScene.prototype.stopAllAnimations = function (): void {\r\n    if (this._activeAnimatables) {\r\n        for (let i = 0; i < this._activeAnimatables.length; i++) {\r\n            this._activeAnimatables[i].stop(undefined, undefined, true);\r\n        }\r\n        this._activeAnimatables.length = 0;\r\n    }\r\n\r\n    for (const group of this.animationGroups) {\r\n        group.stop();\r\n    }\r\n};\r\n\r\nScene.prototype._registerTargetForLateAnimationBinding = function (runtimeAnimation: RuntimeAnimation, originalValue: any): void {\r\n    const target = runtimeAnimation.target;\r\n    this._registeredForLateAnimationBindings.pushNoDuplicate(target);\r\n\r\n    if (!target._lateAnimationHolders) {\r\n        target._lateAnimationHolders = {};\r\n    }\r\n\r\n    if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath] = {\r\n            totalWeight: 0,\r\n            totalAdditiveWeight: 0,\r\n            animations: [],\r\n            additiveAnimations: [],\r\n            originalValue: originalValue,\r\n        };\r\n    }\r\n\r\n    if (runtimeAnimation.isAdditive) {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\r\n    } else {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\r\n    }\r\n};\r\n\r\nScene.prototype._processLateAnimationBindingsForMatrices = function (holder: {\r\n    totalWeight: number;\r\n    totalAdditiveWeight: number;\r\n    animations: RuntimeAnimation[];\r\n    additiveAnimations: RuntimeAnimation[];\r\n    originalValue: Matrix;\r\n}): any {\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\r\n        return holder.originalValue;\r\n    }\r\n\r\n    let normalizer = 1.0;\r\n    const finalPosition = TmpVectors.Vector3[0];\r\n    const finalScaling = TmpVectors.Vector3[1];\r\n    const finalQuaternion = TmpVectors.Quaternion[0];\r\n    let startIndex = 0;\r\n    const originalAnimation = holder.animations[0];\r\n    const originalValue = holder.originalValue;\r\n\r\n    let scale = 1;\r\n    let skipOverride = false;\r\n    if (holder.totalWeight < 1.0) {\r\n        // We need to mix the original value in\r\n        scale = 1.0 - holder.totalWeight;\r\n        originalValue.decompose(finalScaling, finalQuaternion, finalPosition);\r\n    } else {\r\n        startIndex = 1;\r\n        // We need to normalize the weights\r\n        normalizer = holder.totalWeight;\r\n        scale = originalAnimation.weight / normalizer;\r\n        if (scale == 1) {\r\n            if (holder.totalAdditiveWeight) {\r\n                skipOverride = true;\r\n            } else {\r\n                return originalAnimation.currentValue;\r\n            }\r\n        }\r\n\r\n        originalAnimation.currentValue.decompose(finalScaling, finalQuaternion, finalPosition);\r\n    }\r\n\r\n    // Add up the override animations\r\n    if (!skipOverride) {\r\n        finalScaling.scaleInPlace(scale);\r\n        finalPosition.scaleInPlace(scale);\r\n        finalQuaternion.scaleInPlace(scale);\r\n\r\n        for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\r\n            const runtimeAnimation = holder.animations[animIndex];\r\n            if (runtimeAnimation.weight === 0) {\r\n                continue;\r\n            }\r\n\r\n            scale = runtimeAnimation.weight / normalizer;\r\n            const currentPosition = TmpVectors.Vector3[2];\r\n            const currentScaling = TmpVectors.Vector3[3];\r\n            const currentQuaternion = TmpVectors.Quaternion[1];\r\n\r\n            runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\r\n\r\n            currentScaling.scaleAndAddToRef(scale, finalScaling);\r\n            currentQuaternion.scaleAndAddToRef(Quaternion.Dot(finalQuaternion, currentQuaternion) > 0 ? scale : -scale, finalQuaternion);\r\n            currentPosition.scaleAndAddToRef(scale, finalPosition);\r\n        }\r\n\r\n        finalQuaternion.normalize();\r\n    }\r\n\r\n    // Add up the additive animations\r\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n        const runtimeAnimation = holder.additiveAnimations[animIndex];\r\n        if (runtimeAnimation.weight === 0) {\r\n            continue;\r\n        }\r\n\r\n        const currentPosition = TmpVectors.Vector3[2];\r\n        const currentScaling = TmpVectors.Vector3[3];\r\n        const currentQuaternion = TmpVectors.Quaternion[1];\r\n\r\n        runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\r\n        currentScaling.multiplyToRef(finalScaling, currentScaling);\r\n        Vector3.LerpToRef(finalScaling, currentScaling, runtimeAnimation.weight, finalScaling);\r\n        finalQuaternion.multiplyToRef(currentQuaternion, currentQuaternion);\r\n        Quaternion.SlerpToRef(finalQuaternion, currentQuaternion, runtimeAnimation.weight, finalQuaternion);\r\n        currentPosition.scaleAndAddToRef(runtimeAnimation.weight, finalPosition);\r\n    }\r\n\r\n    const workValue = originalAnimation ? originalAnimation._animationState.workValue : TmpVectors.Matrix[0].clone();\r\n    Matrix.ComposeToRef(finalScaling, finalQuaternion, finalPosition, workValue);\r\n    return workValue;\r\n};\r\n\r\nScene.prototype._processLateAnimationBindingsForQuaternions = function (\r\n    holder: {\r\n        totalWeight: number;\r\n        totalAdditiveWeight: number;\r\n        animations: RuntimeAnimation[];\r\n        additiveAnimations: RuntimeAnimation[];\r\n        originalValue: Quaternion;\r\n    },\r\n    refQuaternion: Quaternion\r\n): Quaternion {\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\r\n        return refQuaternion;\r\n    }\r\n\r\n    const originalAnimation = holder.animations[0];\r\n    const originalValue = holder.originalValue;\r\n    let cumulativeQuaternion = refQuaternion;\r\n\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight > 0) {\r\n        cumulativeQuaternion.copyFrom(originalValue);\r\n    } else if (holder.animations.length === 1) {\r\n        Quaternion.SlerpToRef(originalValue, originalAnimation.currentValue, Math.min(1.0, holder.totalWeight), cumulativeQuaternion);\r\n\r\n        if (holder.totalAdditiveWeight === 0) {\r\n            return cumulativeQuaternion;\r\n        }\r\n    } else if (holder.animations.length > 1) {\r\n        // Add up the override animations\r\n        let normalizer = 1.0;\r\n        let quaternions: Array<Quaternion>;\r\n        let weights: Array<number>;\r\n\r\n        if (holder.totalWeight < 1.0) {\r\n            const scale = 1.0 - holder.totalWeight;\r\n\r\n            quaternions = [];\r\n            weights = [];\r\n\r\n            quaternions.push(originalValue);\r\n            weights.push(scale);\r\n        } else {\r\n            if (holder.animations.length === 2) {\r\n                // Slerp as soon as we can\r\n                Quaternion.SlerpToRef(holder.animations[0].currentValue, holder.animations[1].currentValue, holder.animations[1].weight / holder.totalWeight, refQuaternion);\r\n\r\n                if (holder.totalAdditiveWeight === 0) {\r\n                    return refQuaternion;\r\n                }\r\n            }\r\n\r\n            quaternions = [];\r\n            weights = [];\r\n            normalizer = holder.totalWeight;\r\n        }\r\n\r\n        for (let animIndex = 0; animIndex < holder.animations.length; animIndex++) {\r\n            const runtimeAnimation = holder.animations[animIndex];\r\n            quaternions.push(runtimeAnimation.currentValue);\r\n            weights.push(runtimeAnimation.weight / normalizer);\r\n        }\r\n\r\n        // https://gamedev.stackexchange.com/questions/62354/method-for-interpolation-between-3-quaternions\r\n\r\n        let cumulativeAmount = 0;\r\n        for (let index = 0; index < quaternions.length; ) {\r\n            if (!index) {\r\n                Quaternion.SlerpToRef(quaternions[index], quaternions[index + 1], weights[index + 1] / (weights[index] + weights[index + 1]), refQuaternion);\r\n                cumulativeQuaternion = refQuaternion;\r\n                cumulativeAmount = weights[index] + weights[index + 1];\r\n                index += 2;\r\n                continue;\r\n            }\r\n            cumulativeAmount += weights[index];\r\n            Quaternion.SlerpToRef(cumulativeQuaternion, quaternions[index], weights[index] / cumulativeAmount, cumulativeQuaternion);\r\n            index++;\r\n        }\r\n    }\r\n\r\n    // Add up the additive animations\r\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n        const runtimeAnimation = holder.additiveAnimations[animIndex];\r\n        if (runtimeAnimation.weight === 0) {\r\n            continue;\r\n        }\r\n\r\n        cumulativeQuaternion.multiplyToRef(runtimeAnimation.currentValue, TmpVectors.Quaternion[0]);\r\n        Quaternion.SlerpToRef(cumulativeQuaternion, TmpVectors.Quaternion[0], runtimeAnimation.weight, cumulativeQuaternion);\r\n    }\r\n\r\n    return cumulativeQuaternion!;\r\n};\r\n\r\nScene.prototype._processLateAnimationBindings = function (): void {\r\n    if (!this._registeredForLateAnimationBindings.length) {\r\n        return;\r\n    }\r\n    for (let index = 0; index < this._registeredForLateAnimationBindings.length; index++) {\r\n        const target = this._registeredForLateAnimationBindings.data[index];\r\n\r\n        for (const path in target._lateAnimationHolders) {\r\n            const holder = target._lateAnimationHolders[path];\r\n            const originalAnimation: RuntimeAnimation = holder.animations[0];\r\n            const originalValue = holder.originalValue;\r\n            if (originalValue === undefined || originalValue === null) {\r\n                continue;\r\n            }\r\n            const matrixDecomposeMode = Animation.AllowMatrixDecomposeForInterpolation && originalValue.m; // ie. data is matrix\r\n\r\n            let finalValue: any = target[path];\r\n            if (matrixDecomposeMode) {\r\n                finalValue = this._processLateAnimationBindingsForMatrices(holder);\r\n            } else {\r\n                const quaternionMode = originalValue.w !== undefined;\r\n                if (quaternionMode) {\r\n                    finalValue = this._processLateAnimationBindingsForQuaternions(holder, finalValue || Quaternion.Identity());\r\n                } else {\r\n                    let startIndex = 0;\r\n                    let normalizer = 1.0;\r\n\r\n                    if (holder.totalWeight < 1.0) {\r\n                        // We need to mix the original value in\r\n                        if (originalAnimation && originalValue.scale) {\r\n                            finalValue = originalValue.scale(1.0 - holder.totalWeight);\r\n                        } else if (originalAnimation) {\r\n                            finalValue = originalValue * (1.0 - holder.totalWeight);\r\n                        } else if (originalValue.clone) {\r\n                            finalValue = originalValue.clone();\r\n                        } else {\r\n                            finalValue = originalValue;\r\n                        }\r\n                    } else if (originalAnimation) {\r\n                        // We need to normalize the weights\r\n                        normalizer = holder.totalWeight;\r\n                        const scale = originalAnimation.weight / normalizer;\r\n                        if (scale !== 1) {\r\n                            if (originalAnimation.currentValue.scale) {\r\n                                finalValue = originalAnimation.currentValue.scale(scale);\r\n                            } else {\r\n                                finalValue = originalAnimation.currentValue * scale;\r\n                            }\r\n                        } else {\r\n                            finalValue = originalAnimation.currentValue;\r\n                        }\r\n\r\n                        startIndex = 1;\r\n                    }\r\n\r\n                    // Add up the override animations\r\n                    for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\r\n                        const runtimeAnimation = holder.animations[animIndex];\r\n                        const scale = runtimeAnimation.weight / normalizer;\r\n\r\n                        if (!scale) {\r\n                            continue;\r\n                        } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\r\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\r\n                        } else {\r\n                            finalValue += runtimeAnimation.currentValue * scale;\r\n                        }\r\n                    }\r\n\r\n                    // Add up the additive animations\r\n                    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n                        const runtimeAnimation = holder.additiveAnimations[animIndex];\r\n                        const scale: number = runtimeAnimation.weight;\r\n\r\n                        if (!scale) {\r\n                            continue;\r\n                        } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\r\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\r\n                        } else {\r\n                            finalValue += runtimeAnimation.currentValue * scale;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            target[path] = finalValue;\r\n        }\r\n\r\n        target._lateAnimationHolders = {};\r\n    }\r\n    this._registeredForLateAnimationBindings.reset();\r\n};\r\n\r\ndeclare module \"../Bones/bone\" {\r\n    export interface Bone {\r\n        /**\r\n         * Copy an animation range from another bone\r\n         * @param source defines the source bone\r\n         * @param rangeName defines the range name to copy\r\n         * @param frameOffset defines the frame offset\r\n         * @param rescaleAsRequired defines if rescaling must be applied if required\r\n         * @param skelDimensionsRatio defines the scaling ratio\r\n         * @returns true if operation was successful\r\n         */\r\n        copyAnimationRange(source: Bone, rangeName: string, frameOffset: number, rescaleAsRequired: boolean, skelDimensionsRatio: Nullable<Vector3>): boolean;\r\n    }\r\n}\r\n\r\nBone.prototype.copyAnimationRange = function (\r\n    source: Bone,\r\n    rangeName: string,\r\n    frameOffset: number,\r\n    rescaleAsRequired = false,\r\n    skelDimensionsRatio: Nullable<Vector3> = null\r\n): boolean {\r\n    // all animation may be coming from a library skeleton, so may need to create animation\r\n    if (this.animations.length === 0) {\r\n        this.animations.push(new Animation(this.name, \"_matrix\", source.animations[0].framePerSecond, Animation.ANIMATIONTYPE_MATRIX, 0));\r\n        this.animations[0].setKeys([]);\r\n    }\r\n\r\n    // get animation info / verify there is such a range from the source bone\r\n    const sourceRange = source.animations[0].getRange(rangeName);\r\n    if (!sourceRange) {\r\n        return false;\r\n    }\r\n    const from = sourceRange.from;\r\n    const to = sourceRange.to;\r\n    const sourceKeys = source.animations[0].getKeys();\r\n\r\n    // rescaling prep\r\n    const sourceBoneLength = source.length;\r\n    const sourceParent = source.getParent();\r\n    const parent = this.getParent();\r\n    const parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;\r\n    const parentRatio = parentScalingReqd && parent && sourceParent ? parent.length / sourceParent.length : 1;\r\n\r\n    const dimensionsScalingReqd =\r\n        rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);\r\n\r\n    const destKeys = this.animations[0].getKeys();\r\n\r\n    // loop vars declaration\r\n    let orig: { frame: number; value: Matrix };\r\n    let origTranslation: Vector3;\r\n    let mat: Matrix;\r\n\r\n    for (let key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {\r\n        orig = sourceKeys[key];\r\n        if (orig.frame >= from && orig.frame <= to) {\r\n            if (rescaleAsRequired) {\r\n                mat = orig.value.clone();\r\n\r\n                // scale based on parent ratio, when bone has parent\r\n                if (parentScalingReqd) {\r\n                    origTranslation = mat.getTranslation();\r\n                    mat.setTranslation(origTranslation.scaleInPlace(parentRatio));\r\n\r\n                    // scale based on skeleton dimension ratio when root bone, and value is passed\r\n                } else if (dimensionsScalingReqd && skelDimensionsRatio) {\r\n                    origTranslation = mat.getTranslation();\r\n                    mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio));\r\n\r\n                    // use original when root bone, and no data for skelDimensionsRatio\r\n                } else {\r\n                    mat = orig.value;\r\n                }\r\n            } else {\r\n                mat = orig.value;\r\n            }\r\n            destKeys.push({ frame: orig.frame + frameOffset, value: mat });\r\n        }\r\n    }\r\n    this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);\r\n    return true;\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}