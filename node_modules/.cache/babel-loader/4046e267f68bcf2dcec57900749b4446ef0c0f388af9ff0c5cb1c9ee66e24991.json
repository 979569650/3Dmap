{"ast":null,"code":"import { Vector3, Quaternion, Matrix, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { BaseSixDofDragBehavior } from \"./baseSixDofDragBehavior.js\";\nimport { TransformNode } from \"../../Meshes/transformNode.js\";\nimport { Space } from \"../../Maths/math.axis.js\";\n/**\n * A behavior that when attached to a mesh will allow the mesh to be dragged around based on directions and origin of the pointer's ray\n */\nexport class SixDofDragBehavior extends BaseSixDofDragBehavior {\n  constructor() {\n    super(...arguments);\n    this._sceneRenderObserver = null;\n    this._targetPosition = new Vector3(0, 0, 0);\n    this._targetOrientation = new Quaternion();\n    this._targetScaling = new Vector3(1, 1, 1);\n    this._startingPosition = new Vector3(0, 0, 0);\n    this._startingOrientation = new Quaternion();\n    this._startingScaling = new Vector3(1, 1, 1);\n    /**\n     * Fires when position is updated\n     */\n    this.onPositionChangedObservable = new Observable();\n    /**\n     * The distance towards the target drag position to move each frame. This can be useful to avoid jitter. Set this to 1 for no delay. (Default: 0.2)\n     */\n    this.dragDeltaRatio = 0.2;\n    /**\n     * If the object should rotate to face the drag origin\n     */\n    this.rotateDraggedObject = true;\n    /**\n     * If `rotateDraggedObject` is set to `true`, this parameter determines if we are only rotating around the y axis (yaw)\n     */\n    this.rotateAroundYOnly = false;\n    /**\n     * Should the behavior rotate 1:1 with the motion controller, when one is used.\n     */\n    this.rotateWithMotionController = true;\n    /**\n     * Use this flag to update the target but not move the owner node towards the target\n     */\n    this.disableMovement = false;\n    /**\n     * Should the object rotate towards the camera when we start dragging it\n     */\n    this.faceCameraOnDragStart = false;\n  }\n  /**\n   *  The name of the behavior\n   */\n  get name() {\n    return \"SixDofDrag\";\n  }\n  /**\n   * Attaches the six DoF drag behavior\n   * @param ownerNode The mesh that will be dragged around once attached\n   */\n  attach(ownerNode) {\n    super.attach(ownerNode);\n    ownerNode.isNearGrabbable = true;\n    // Node that will save the owner's transform\n    this._virtualTransformNode = new TransformNode(\"virtual_sixDof\", BaseSixDofDragBehavior._virtualScene);\n    this._virtualTransformNode.rotationQuaternion = Quaternion.Identity();\n    // On every frame move towards target scaling to avoid jitter caused by vr controllers\n    this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(() => {\n      if (this.currentDraggingPointerIds.length === 1 && this._moving && !this.disableMovement) {\n        // 1 pointer only drags mesh\n        const oldParent = ownerNode.parent;\n        ownerNode.setParent(null);\n        ownerNode.position.addInPlace(this._targetPosition.subtract(ownerNode.position).scale(this.dragDeltaRatio));\n        this.onPositionChangedObservable.notifyObservers({\n          position: ownerNode.absolutePosition\n        });\n        // Only rotate the mesh if it's parent has uniform scaling\n        if (!oldParent || oldParent.scaling && !oldParent.scaling.isNonUniformWithinEpsilon(0.001)) {\n          Quaternion.SlerpToRef(ownerNode.rotationQuaternion, this._targetOrientation, this.dragDeltaRatio, ownerNode.rotationQuaternion);\n        }\n        ownerNode.setParent(oldParent);\n      }\n    });\n  }\n  _getPositionOffsetAround(transformationLocalOrigin, scaling, rotation) {\n    const translationMatrix = TmpVectors.Matrix[0]; // T\n    const translationMatrixInv = TmpVectors.Matrix[1]; // T'\n    const rotationMatrix = TmpVectors.Matrix[2]; // R\n    const scaleMatrix = TmpVectors.Matrix[3]; // S\n    const finalMatrix = TmpVectors.Matrix[4]; // T' x R x S x T\n    Matrix.TranslationToRef(transformationLocalOrigin.x, transformationLocalOrigin.y, transformationLocalOrigin.z, translationMatrix); // T\n    Matrix.TranslationToRef(-transformationLocalOrigin.x, -transformationLocalOrigin.y, -transformationLocalOrigin.z, translationMatrixInv); // T'\n    Matrix.FromQuaternionToRef(rotation, rotationMatrix); // R\n    Matrix.ScalingToRef(scaling, scaling, scaling, scaleMatrix);\n    translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix); // T' x R\n    finalMatrix.multiplyToRef(scaleMatrix, finalMatrix); // T' x R x S\n    finalMatrix.multiplyToRef(translationMatrix, finalMatrix); // T' x R x S x T\n    return finalMatrix.getTranslation();\n  }\n  _onePointerPositionUpdated(worldDeltaPosition, worldDeltaRotation) {\n    const pointerDelta = TmpVectors.Vector3[0];\n    pointerDelta.setAll(0);\n    if (this._dragging === this._dragType.DRAG) {\n      if (this.rotateDraggedObject) {\n        if (this.rotateAroundYOnly) {\n          // Convert change in rotation to only y axis rotation\n          Quaternion.RotationYawPitchRollToRef(worldDeltaRotation.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);\n        } else {\n          TmpVectors.Quaternion[0].copyFrom(worldDeltaRotation);\n        }\n        TmpVectors.Quaternion[0].multiplyToRef(this._startingOrientation, this._targetOrientation);\n      }\n    } else if (this._dragging === this._dragType.NEAR_DRAG || this._dragging === this._dragType.DRAG_WITH_CONTROLLER && this.rotateWithMotionController) {\n      worldDeltaRotation.multiplyToRef(this._startingOrientation, this._targetOrientation);\n    }\n    this._targetPosition.copyFrom(this._startingPosition).addInPlace(worldDeltaPosition);\n  }\n  _twoPointersPositionUpdated() {\n    const startingPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].startingPosition;\n    const startingPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].startingPosition;\n    const startingCenter = TmpVectors.Vector3[0];\n    startingPosition0.addToRef(startingPosition1, startingCenter);\n    startingCenter.scaleInPlace(0.5);\n    const startingVector = TmpVectors.Vector3[1];\n    startingPosition1.subtractToRef(startingPosition0, startingVector);\n    const currentPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].dragMesh.absolutePosition;\n    const currentPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].dragMesh.absolutePosition;\n    const currentCenter = TmpVectors.Vector3[2];\n    currentPosition0.addToRef(currentPosition1, currentCenter);\n    currentCenter.scaleInPlace(0.5);\n    const currentVector = TmpVectors.Vector3[3];\n    currentPosition1.subtractToRef(currentPosition0, currentVector);\n    const scaling = currentVector.length() / startingVector.length();\n    const translation = currentCenter.subtract(startingCenter);\n    const rotationQuaternion = Quaternion.FromEulerAngles(0, Vector3.GetAngleBetweenVectorsOnPlane(startingVector.normalize(), currentVector.normalize(), Vector3.UpReadOnly), 0);\n    const oldParent = this._ownerNode.parent;\n    this._ownerNode.setParent(null);\n    const positionOffset = this._getPositionOffsetAround(startingCenter.subtract(this._virtualTransformNode.getAbsolutePivotPoint()), scaling, rotationQuaternion);\n    this._virtualTransformNode.rotationQuaternion.multiplyToRef(rotationQuaternion, this._ownerNode.rotationQuaternion);\n    this._virtualTransformNode.scaling.scaleToRef(scaling, this._ownerNode.scaling);\n    this._virtualTransformNode.position.addToRef(translation.addInPlace(positionOffset), this._ownerNode.position);\n    this.onPositionChangedObservable.notifyObservers({\n      position: this._ownerNode.position\n    });\n    this._ownerNode.setParent(oldParent);\n  }\n  _targetDragStart() {\n    const pointerCount = this.currentDraggingPointerIds.length;\n    const oldParent = this._ownerNode.parent;\n    if (!this._ownerNode.rotationQuaternion) {\n      this._ownerNode.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._ownerNode.rotation.y, this._ownerNode.rotation.x, this._ownerNode.rotation.z);\n    }\n    const worldPivot = this._ownerNode.getAbsolutePivotPoint();\n    this._ownerNode.setParent(null);\n    if (pointerCount === 1) {\n      this._targetPosition.copyFrom(this._ownerNode.position);\n      this._targetOrientation.copyFrom(this._ownerNode.rotationQuaternion);\n      this._targetScaling.copyFrom(this._ownerNode.scaling);\n      if (this.faceCameraOnDragStart && this._scene.activeCamera) {\n        const toCamera = TmpVectors.Vector3[0];\n        this._scene.activeCamera.position.subtractToRef(worldPivot, toCamera);\n        toCamera.normalize();\n        const quat = TmpVectors.Quaternion[0];\n        if (this._scene.useRightHandedSystem) {\n          Quaternion.FromLookDirectionRHToRef(toCamera, new Vector3(0, 1, 0), quat);\n        } else {\n          Quaternion.FromLookDirectionLHToRef(toCamera, new Vector3(0, 1, 0), quat);\n        }\n        quat.normalize();\n        Quaternion.RotationYawPitchRollToRef(quat.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);\n        this._targetOrientation.copyFrom(TmpVectors.Quaternion[0]);\n      }\n      this._startingPosition.copyFrom(this._targetPosition);\n      this._startingOrientation.copyFrom(this._targetOrientation);\n      this._startingScaling.copyFrom(this._targetScaling);\n    } else if (pointerCount === 2) {\n      this._virtualTransformNode.setPivotPoint(new Vector3(0, 0, 0), Space.LOCAL);\n      this._virtualTransformNode.position.copyFrom(this._ownerNode.position);\n      this._virtualTransformNode.scaling.copyFrom(this._ownerNode.scaling);\n      this._virtualTransformNode.rotationQuaternion.copyFrom(this._ownerNode.rotationQuaternion);\n      this._virtualTransformNode.setPivotPoint(worldPivot, Space.WORLD);\n      this._resetVirtualMeshesPosition();\n    }\n    this._ownerNode.setParent(oldParent);\n  }\n  _targetDrag(worldDeltaPosition, worldDeltaRotation) {\n    if (this.currentDraggingPointerIds.length === 1) {\n      this._onePointerPositionUpdated(worldDeltaPosition, worldDeltaRotation);\n    } else if (this.currentDraggingPointerIds.length === 2) {\n      this._twoPointersPositionUpdated();\n    }\n  }\n  _targetDragEnd() {\n    if (this.currentDraggingPointerIds.length === 1) {\n      // We still have 1 active pointer, we must simulate a dragstart with a reseted position/orientation\n      this._resetVirtualMeshesPosition();\n      const previousFaceCameraFlag = this.faceCameraOnDragStart;\n      this.faceCameraOnDragStart = false;\n      this._targetDragStart();\n      this.faceCameraOnDragStart = previousFaceCameraFlag;\n    }\n  }\n  /**\n   *  Detaches the behavior from the mesh\n   */\n  detach() {\n    super.detach();\n    if (this._ownerNode) {\n      this._ownerNode.isNearGrabbable = false;\n      this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);\n    }\n    if (this._virtualTransformNode) {\n      this._virtualTransformNode.dispose();\n    }\n  }\n}","map":{"version":3,"names":["Vector3","Quaternion","Matrix","TmpVectors","Observable","BaseSixDofDragBehavior","TransformNode","Space","SixDofDragBehavior","constructor","_sceneRenderObserver","_targetPosition","_targetOrientation","_targetScaling","_startingPosition","_startingOrientation","_startingScaling","onPositionChangedObservable","dragDeltaRatio","rotateDraggedObject","rotateAroundYOnly","rotateWithMotionController","disableMovement","faceCameraOnDragStart","name","attach","ownerNode","isNearGrabbable","_virtualTransformNode","_virtualScene","rotationQuaternion","Identity","getScene","onBeforeRenderObservable","add","currentDraggingPointerIds","length","_moving","oldParent","parent","setParent","position","addInPlace","subtract","scale","notifyObservers","absolutePosition","scaling","isNonUniformWithinEpsilon","SlerpToRef","_getPositionOffsetAround","transformationLocalOrigin","rotation","translationMatrix","translationMatrixInv","rotationMatrix","scaleMatrix","finalMatrix","TranslationToRef","x","y","z","FromQuaternionToRef","ScalingToRef","multiplyToRef","getTranslation","_onePointerPositionUpdated","worldDeltaPosition","worldDeltaRotation","pointerDelta","setAll","_dragging","_dragType","DRAG","RotationYawPitchRollToRef","toEulerAngles","copyFrom","NEAR_DRAG","DRAG_WITH_CONTROLLER","_twoPointersPositionUpdated","startingPosition0","_virtualMeshesInfo","startingPosition","startingPosition1","startingCenter","addToRef","scaleInPlace","startingVector","subtractToRef","currentPosition0","dragMesh","currentPosition1","currentCenter","currentVector","translation","FromEulerAngles","GetAngleBetweenVectorsOnPlane","normalize","UpReadOnly","_ownerNode","positionOffset","getAbsolutePivotPoint","scaleToRef","_targetDragStart","pointerCount","RotationYawPitchRoll","worldPivot","_scene","activeCamera","toCamera","quat","useRightHandedSystem","FromLookDirectionRHToRef","FromLookDirectionLHToRef","setPivotPoint","LOCAL","WORLD","_resetVirtualMeshesPosition","_targetDrag","_targetDragEnd","previousFaceCameraFlag","detach","remove","dispose"],"sources":["../../../../../dev/core/src/Behaviors/Meshes/sixDofDragBehavior.ts"],"sourcesContent":["import type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Vector3, Quaternion, Matrix, TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { BaseSixDofDragBehavior } from \"./baseSixDofDragBehavior\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Space } from \"../../Maths/math.axis\";\r\n\r\n/**\r\n * A behavior that when attached to a mesh will allow the mesh to be dragged around based on directions and origin of the pointer's ray\r\n */\r\nexport class SixDofDragBehavior extends BaseSixDofDragBehavior {\r\n    private _sceneRenderObserver: Nullable<Observer<Scene>> = null;\r\n    private _virtualTransformNode: TransformNode;\r\n\r\n    protected _targetPosition = new Vector3(0, 0, 0);\r\n    protected _targetOrientation = new Quaternion();\r\n    protected _targetScaling = new Vector3(1, 1, 1);\r\n    protected _startingPosition = new Vector3(0, 0, 0);\r\n    protected _startingOrientation = new Quaternion();\r\n    protected _startingScaling = new Vector3(1, 1, 1);\r\n\r\n    /**\r\n     * Fires when position is updated\r\n     */\r\n    public onPositionChangedObservable = new Observable<{ position: Vector3 }>();\r\n\r\n    /**\r\n     * The distance towards the target drag position to move each frame. This can be useful to avoid jitter. Set this to 1 for no delay. (Default: 0.2)\r\n     */\r\n    public dragDeltaRatio = 0.2;\r\n\r\n    /**\r\n     * If the object should rotate to face the drag origin\r\n     */\r\n    public rotateDraggedObject = true;\r\n\r\n    /**\r\n     * If `rotateDraggedObject` is set to `true`, this parameter determines if we are only rotating around the y axis (yaw)\r\n     */\r\n    public rotateAroundYOnly = false;\r\n\r\n    /**\r\n     * Should the behavior rotate 1:1 with the motion controller, when one is used.\r\n     */\r\n    public rotateWithMotionController = true;\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"SixDofDrag\";\r\n    }\r\n\r\n    /**\r\n     * Use this flag to update the target but not move the owner node towards the target\r\n     */\r\n    public disableMovement: boolean = false;\r\n\r\n    /**\r\n     * Should the object rotate towards the camera when we start dragging it\r\n     */\r\n    public faceCameraOnDragStart = false;\r\n\r\n    /**\r\n     * Attaches the six DoF drag behavior\r\n     * @param ownerNode The mesh that will be dragged around once attached\r\n     */\r\n    public attach(ownerNode: Mesh): void {\r\n        super.attach(ownerNode);\r\n\r\n        ownerNode.isNearGrabbable = true;\r\n\r\n        // Node that will save the owner's transform\r\n        this._virtualTransformNode = new TransformNode(\"virtual_sixDof\", BaseSixDofDragBehavior._virtualScene);\r\n        this._virtualTransformNode.rotationQuaternion = Quaternion.Identity();\r\n\r\n        // On every frame move towards target scaling to avoid jitter caused by vr controllers\r\n        this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(() => {\r\n            if (this.currentDraggingPointerIds.length === 1 && this._moving && !this.disableMovement) {\r\n                // 1 pointer only drags mesh\r\n                const oldParent = ownerNode.parent;\r\n                ownerNode.setParent(null);\r\n                ownerNode.position.addInPlace(this._targetPosition.subtract(ownerNode.position).scale(this.dragDeltaRatio));\r\n\r\n                this.onPositionChangedObservable.notifyObservers({ position: ownerNode.absolutePosition });\r\n\r\n                // Only rotate the mesh if it's parent has uniform scaling\r\n                if (!oldParent || ((oldParent as Mesh).scaling && !(oldParent as Mesh).scaling.isNonUniformWithinEpsilon(0.001))) {\r\n                    Quaternion.SlerpToRef(ownerNode.rotationQuaternion!, this._targetOrientation, this.dragDeltaRatio, ownerNode.rotationQuaternion!);\r\n                }\r\n\r\n                ownerNode.setParent(oldParent);\r\n            }\r\n        });\r\n    }\r\n\r\n    private _getPositionOffsetAround(transformationLocalOrigin: Vector3, scaling: number, rotation: Quaternion): Vector3 {\r\n        const translationMatrix = TmpVectors.Matrix[0]; // T\r\n        const translationMatrixInv = TmpVectors.Matrix[1]; // T'\r\n        const rotationMatrix = TmpVectors.Matrix[2]; // R\r\n        const scaleMatrix = TmpVectors.Matrix[3]; // S\r\n        const finalMatrix = TmpVectors.Matrix[4]; // T' x R x S x T\r\n\r\n        Matrix.TranslationToRef(transformationLocalOrigin.x, transformationLocalOrigin.y, transformationLocalOrigin.z, translationMatrix); // T\r\n        Matrix.TranslationToRef(-transformationLocalOrigin.x, -transformationLocalOrigin.y, -transformationLocalOrigin.z, translationMatrixInv); // T'\r\n        Matrix.FromQuaternionToRef(rotation, rotationMatrix); // R\r\n        Matrix.ScalingToRef(scaling, scaling, scaling, scaleMatrix);\r\n        translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix); // T' x R\r\n        finalMatrix.multiplyToRef(scaleMatrix, finalMatrix); // T' x R x S\r\n        finalMatrix.multiplyToRef(translationMatrix, finalMatrix); // T' x R x S x T\r\n\r\n        return finalMatrix.getTranslation();\r\n    }\r\n\r\n    private _onePointerPositionUpdated(worldDeltaPosition: Vector3, worldDeltaRotation: Quaternion) {\r\n        const pointerDelta = TmpVectors.Vector3[0];\r\n        pointerDelta.setAll(0);\r\n\r\n        if (this._dragging === this._dragType.DRAG) {\r\n            if (this.rotateDraggedObject) {\r\n                if (this.rotateAroundYOnly) {\r\n                    // Convert change in rotation to only y axis rotation\r\n                    Quaternion.RotationYawPitchRollToRef(worldDeltaRotation.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);\r\n                } else {\r\n                    TmpVectors.Quaternion[0].copyFrom(worldDeltaRotation);\r\n                }\r\n                TmpVectors.Quaternion[0].multiplyToRef(this._startingOrientation, this._targetOrientation);\r\n            }\r\n        } else if (this._dragging === this._dragType.NEAR_DRAG || (this._dragging === this._dragType.DRAG_WITH_CONTROLLER && this.rotateWithMotionController)) {\r\n            worldDeltaRotation.multiplyToRef(this._startingOrientation, this._targetOrientation);\r\n        }\r\n\r\n        this._targetPosition.copyFrom(this._startingPosition).addInPlace(worldDeltaPosition);\r\n    }\r\n\r\n    private _twoPointersPositionUpdated() {\r\n        const startingPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].startingPosition;\r\n        const startingPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].startingPosition;\r\n        const startingCenter = TmpVectors.Vector3[0];\r\n        startingPosition0.addToRef(startingPosition1, startingCenter);\r\n        startingCenter.scaleInPlace(0.5);\r\n        const startingVector = TmpVectors.Vector3[1];\r\n        startingPosition1.subtractToRef(startingPosition0, startingVector);\r\n\r\n        const currentPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].dragMesh.absolutePosition;\r\n        const currentPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].dragMesh.absolutePosition;\r\n        const currentCenter = TmpVectors.Vector3[2];\r\n        currentPosition0.addToRef(currentPosition1, currentCenter);\r\n        currentCenter.scaleInPlace(0.5);\r\n        const currentVector = TmpVectors.Vector3[3];\r\n        currentPosition1.subtractToRef(currentPosition0, currentVector);\r\n\r\n        const scaling = currentVector.length() / startingVector.length();\r\n        const translation = currentCenter.subtract(startingCenter);\r\n        const rotationQuaternion = Quaternion.FromEulerAngles(\r\n            0,\r\n            Vector3.GetAngleBetweenVectorsOnPlane(startingVector.normalize(), currentVector.normalize(), Vector3.UpReadOnly),\r\n            0\r\n        );\r\n\r\n        const oldParent = this._ownerNode.parent;\r\n        this._ownerNode.setParent(null);\r\n\r\n        const positionOffset = this._getPositionOffsetAround(startingCenter.subtract(this._virtualTransformNode.getAbsolutePivotPoint()), scaling, rotationQuaternion);\r\n        this._virtualTransformNode.rotationQuaternion!.multiplyToRef(rotationQuaternion, this._ownerNode.rotationQuaternion!);\r\n        this._virtualTransformNode.scaling.scaleToRef(scaling, this._ownerNode.scaling);\r\n        this._virtualTransformNode.position.addToRef(translation.addInPlace(positionOffset), this._ownerNode.position);\r\n        this.onPositionChangedObservable.notifyObservers({ position: this._ownerNode.position });\r\n\r\n        this._ownerNode.setParent(oldParent);\r\n    }\r\n\r\n    protected _targetDragStart() {\r\n        const pointerCount = this.currentDraggingPointerIds.length;\r\n        const oldParent = this._ownerNode.parent;\r\n\r\n        if (!this._ownerNode.rotationQuaternion) {\r\n            this._ownerNode.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._ownerNode.rotation.y, this._ownerNode.rotation.x, this._ownerNode.rotation.z);\r\n        }\r\n        const worldPivot = this._ownerNode.getAbsolutePivotPoint();\r\n        this._ownerNode.setParent(null);\r\n\r\n        if (pointerCount === 1) {\r\n            this._targetPosition.copyFrom(this._ownerNode.position);\r\n            this._targetOrientation.copyFrom(this._ownerNode.rotationQuaternion);\r\n            this._targetScaling.copyFrom(this._ownerNode.scaling);\r\n\r\n            if (this.faceCameraOnDragStart && this._scene.activeCamera) {\r\n                const toCamera = TmpVectors.Vector3[0];\r\n                this._scene.activeCamera.position.subtractToRef(worldPivot, toCamera);\r\n                toCamera.normalize();\r\n                const quat = TmpVectors.Quaternion[0];\r\n                if (this._scene.useRightHandedSystem) {\r\n                    Quaternion.FromLookDirectionRHToRef(toCamera, new Vector3(0, 1, 0), quat);\r\n                } else {\r\n                    Quaternion.FromLookDirectionLHToRef(toCamera, new Vector3(0, 1, 0), quat);\r\n                }\r\n                quat.normalize();\r\n                Quaternion.RotationYawPitchRollToRef(quat.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);\r\n                this._targetOrientation.copyFrom(TmpVectors.Quaternion[0]);\r\n            }\r\n            this._startingPosition.copyFrom(this._targetPosition);\r\n            this._startingOrientation.copyFrom(this._targetOrientation);\r\n            this._startingScaling.copyFrom(this._targetScaling);\r\n        } else if (pointerCount === 2) {\r\n            this._virtualTransformNode.setPivotPoint(new Vector3(0, 0, 0), Space.LOCAL);\r\n            this._virtualTransformNode.position.copyFrom(this._ownerNode.position);\r\n            this._virtualTransformNode.scaling.copyFrom(this._ownerNode.scaling);\r\n            this._virtualTransformNode.rotationQuaternion!.copyFrom(this._ownerNode.rotationQuaternion);\r\n            this._virtualTransformNode.setPivotPoint(worldPivot, Space.WORLD);\r\n            this._resetVirtualMeshesPosition();\r\n        }\r\n\r\n        this._ownerNode.setParent(oldParent);\r\n    }\r\n\r\n    protected _targetDrag(worldDeltaPosition: Vector3, worldDeltaRotation: Quaternion) {\r\n        if (this.currentDraggingPointerIds.length === 1) {\r\n            this._onePointerPositionUpdated(worldDeltaPosition, worldDeltaRotation);\r\n        } else if (this.currentDraggingPointerIds.length === 2) {\r\n            this._twoPointersPositionUpdated();\r\n        }\r\n    }\r\n\r\n    protected _targetDragEnd() {\r\n        if (this.currentDraggingPointerIds.length === 1) {\r\n            // We still have 1 active pointer, we must simulate a dragstart with a reseted position/orientation\r\n            this._resetVirtualMeshesPosition();\r\n            const previousFaceCameraFlag = this.faceCameraOnDragStart;\r\n            this.faceCameraOnDragStart = false;\r\n            this._targetDragStart();\r\n            this.faceCameraOnDragStart = previousFaceCameraFlag;\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    public detach(): void {\r\n        super.detach();\r\n\r\n        if (this._ownerNode) {\r\n            (this._ownerNode as Mesh).isNearGrabbable = false;\r\n            this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);\r\n        }\r\n\r\n        if (this._virtualTransformNode) {\r\n            this._virtualTransformNode.dispose();\r\n        }\r\n    }\r\n}\r\n"],"mappings":"AAGA,SAASA,OAAO,EAAEC,UAAU,EAAEC,MAAM,EAAEC,UAAU,QAAQ,4BAA0B;AAElF,SAASC,UAAU,QAAQ,0BAAwB;AACnD,SAASC,sBAAsB,QAAQ,6BAA2B;AAClE,SAASC,aAAa,QAAQ,+BAA6B;AAC3D,SAASC,KAAK,QAAQ,0BAAwB;AAE9C;;;AAGA,OAAM,MAAOC,kBAAmB,SAAQH,sBAAsB;EAA9DI,YAAA;;IACY,KAAAC,oBAAoB,GAA8B,IAAI;IAGpD,KAAAC,eAAe,GAAG,IAAIX,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACtC,KAAAY,kBAAkB,GAAG,IAAIX,UAAU,EAAE;IACrC,KAAAY,cAAc,GAAG,IAAIb,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACrC,KAAAc,iBAAiB,GAAG,IAAId,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACxC,KAAAe,oBAAoB,GAAG,IAAId,UAAU,EAAE;IACvC,KAAAe,gBAAgB,GAAG,IAAIhB,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAEjD;;;IAGO,KAAAiB,2BAA2B,GAAG,IAAIb,UAAU,EAAyB;IAE5E;;;IAGO,KAAAc,cAAc,GAAG,GAAG;IAE3B;;;IAGO,KAAAC,mBAAmB,GAAG,IAAI;IAEjC;;;IAGO,KAAAC,iBAAiB,GAAG,KAAK;IAEhC;;;IAGO,KAAAC,0BAA0B,GAAG,IAAI;IASxC;;;IAGO,KAAAC,eAAe,GAAY,KAAK;IAEvC;;;IAGO,KAAAC,qBAAqB,GAAG,KAAK;EA6LxC;EA5MI;;;EAGA,IAAWC,IAAIA,CAAA;IACX,OAAO,YAAY;EACvB;EAYA;;;;EAIOC,MAAMA,CAACC,SAAe;IACzB,KAAK,CAACD,MAAM,CAACC,SAAS,CAAC;IAEvBA,SAAS,CAACC,eAAe,GAAG,IAAI;IAEhC;IACA,IAAI,CAACC,qBAAqB,GAAG,IAAItB,aAAa,CAAC,gBAAgB,EAAED,sBAAsB,CAACwB,aAAa,CAAC;IACtG,IAAI,CAACD,qBAAqB,CAACE,kBAAkB,GAAG7B,UAAU,CAAC8B,QAAQ,EAAE;IAErE;IACA,IAAI,CAACrB,oBAAoB,GAAGgB,SAAS,CAACM,QAAQ,EAAE,CAACC,wBAAwB,CAACC,GAAG,CAAC,MAAK;MAC/E,IAAI,IAAI,CAACC,yBAAyB,CAACC,MAAM,KAAK,CAAC,IAAI,IAAI,CAACC,OAAO,IAAI,CAAC,IAAI,CAACf,eAAe,EAAE;QACtF;QACA,MAAMgB,SAAS,GAAGZ,SAAS,CAACa,MAAM;QAClCb,SAAS,CAACc,SAAS,CAAC,IAAI,CAAC;QACzBd,SAAS,CAACe,QAAQ,CAACC,UAAU,CAAC,IAAI,CAAC/B,eAAe,CAACgC,QAAQ,CAACjB,SAAS,CAACe,QAAQ,CAAC,CAACG,KAAK,CAAC,IAAI,CAAC1B,cAAc,CAAC,CAAC;QAE3G,IAAI,CAACD,2BAA2B,CAAC4B,eAAe,CAAC;UAAEJ,QAAQ,EAAEf,SAAS,CAACoB;QAAgB,CAAE,CAAC;QAE1F;QACA,IAAI,CAACR,SAAS,IAAMA,SAAkB,CAACS,OAAO,IAAI,CAAET,SAAkB,CAACS,OAAO,CAACC,yBAAyB,CAAC,KAAK,CAAE,EAAE;UAC9G/C,UAAU,CAACgD,UAAU,CAACvB,SAAS,CAACI,kBAAmB,EAAE,IAAI,CAAClB,kBAAkB,EAAE,IAAI,CAACM,cAAc,EAAEQ,SAAS,CAACI,kBAAmB,CAAC;;QAGrIJ,SAAS,CAACc,SAAS,CAACF,SAAS,CAAC;;IAEtC,CAAC,CAAC;EACN;EAEQY,wBAAwBA,CAACC,yBAAkC,EAAEJ,OAAe,EAAEK,QAAoB;IACtG,MAAMC,iBAAiB,GAAGlD,UAAU,CAACD,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IAChD,MAAMoD,oBAAoB,GAAGnD,UAAU,CAACD,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IACnD,MAAMqD,cAAc,GAAGpD,UAAU,CAACD,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IAC7C,MAAMsD,WAAW,GAAGrD,UAAU,CAACD,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IAC1C,MAAMuD,WAAW,GAAGtD,UAAU,CAACD,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IAE1CA,MAAM,CAACwD,gBAAgB,CAACP,yBAAyB,CAACQ,CAAC,EAAER,yBAAyB,CAACS,CAAC,EAAET,yBAAyB,CAACU,CAAC,EAAER,iBAAiB,CAAC,CAAC,CAAC;IACnInD,MAAM,CAACwD,gBAAgB,CAAC,CAACP,yBAAyB,CAACQ,CAAC,EAAE,CAACR,yBAAyB,CAACS,CAAC,EAAE,CAACT,yBAAyB,CAACU,CAAC,EAAEP,oBAAoB,CAAC,CAAC,CAAC;IACzIpD,MAAM,CAAC4D,mBAAmB,CAACV,QAAQ,EAAEG,cAAc,CAAC,CAAC,CAAC;IACtDrD,MAAM,CAAC6D,YAAY,CAAChB,OAAO,EAAEA,OAAO,EAAEA,OAAO,EAAES,WAAW,CAAC;IAC3DF,oBAAoB,CAACU,aAAa,CAACT,cAAc,EAAEE,WAAW,CAAC,CAAC,CAAC;IACjEA,WAAW,CAACO,aAAa,CAACR,WAAW,EAAEC,WAAW,CAAC,CAAC,CAAC;IACrDA,WAAW,CAACO,aAAa,CAACX,iBAAiB,EAAEI,WAAW,CAAC,CAAC,CAAC;IAE3D,OAAOA,WAAW,CAACQ,cAAc,EAAE;EACvC;EAEQC,0BAA0BA,CAACC,kBAA2B,EAAEC,kBAA8B;IAC1F,MAAMC,YAAY,GAAGlE,UAAU,CAACH,OAAO,CAAC,CAAC,CAAC;IAC1CqE,YAAY,CAACC,MAAM,CAAC,CAAC,CAAC;IAEtB,IAAI,IAAI,CAACC,SAAS,KAAK,IAAI,CAACC,SAAS,CAACC,IAAI,EAAE;MACxC,IAAI,IAAI,CAACtD,mBAAmB,EAAE;QAC1B,IAAI,IAAI,CAACC,iBAAiB,EAAE;UACxB;UACAnB,UAAU,CAACyE,yBAAyB,CAACN,kBAAkB,CAACO,aAAa,EAAE,CAACf,CAAC,EAAE,CAAC,EAAE,CAAC,EAAEzD,UAAU,CAACF,UAAU,CAAC,CAAC,CAAC,CAAC;SAC7G,MAAM;UACHE,UAAU,CAACF,UAAU,CAAC,CAAC,CAAC,CAAC2E,QAAQ,CAACR,kBAAkB,CAAC;;QAEzDjE,UAAU,CAACF,UAAU,CAAC,CAAC,CAAC,CAAC+D,aAAa,CAAC,IAAI,CAACjD,oBAAoB,EAAE,IAAI,CAACH,kBAAkB,CAAC;;KAEjG,MAAM,IAAI,IAAI,CAAC2D,SAAS,KAAK,IAAI,CAACC,SAAS,CAACK,SAAS,IAAK,IAAI,CAACN,SAAS,KAAK,IAAI,CAACC,SAAS,CAACM,oBAAoB,IAAI,IAAI,CAACzD,0BAA2B,EAAE;MACnJ+C,kBAAkB,CAACJ,aAAa,CAAC,IAAI,CAACjD,oBAAoB,EAAE,IAAI,CAACH,kBAAkB,CAAC;;IAGxF,IAAI,CAACD,eAAe,CAACiE,QAAQ,CAAC,IAAI,CAAC9D,iBAAiB,CAAC,CAAC4B,UAAU,CAACyB,kBAAkB,CAAC;EACxF;EAEQY,2BAA2BA,CAAA;IAC/B,MAAMC,iBAAiB,GAAG,IAAI,CAACC,kBAAkB,CAAC,IAAI,CAAC9C,yBAAyB,CAAC,CAAC,CAAC,CAAC,CAAC+C,gBAAgB;IACrG,MAAMC,iBAAiB,GAAG,IAAI,CAACF,kBAAkB,CAAC,IAAI,CAAC9C,yBAAyB,CAAC,CAAC,CAAC,CAAC,CAAC+C,gBAAgB;IACrG,MAAME,cAAc,GAAGjF,UAAU,CAACH,OAAO,CAAC,CAAC,CAAC;IAC5CgF,iBAAiB,CAACK,QAAQ,CAACF,iBAAiB,EAAEC,cAAc,CAAC;IAC7DA,cAAc,CAACE,YAAY,CAAC,GAAG,CAAC;IAChC,MAAMC,cAAc,GAAGpF,UAAU,CAACH,OAAO,CAAC,CAAC,CAAC;IAC5CmF,iBAAiB,CAACK,aAAa,CAACR,iBAAiB,EAAEO,cAAc,CAAC;IAElE,MAAME,gBAAgB,GAAG,IAAI,CAACR,kBAAkB,CAAC,IAAI,CAAC9C,yBAAyB,CAAC,CAAC,CAAC,CAAC,CAACuD,QAAQ,CAAC5C,gBAAgB;IAC7G,MAAM6C,gBAAgB,GAAG,IAAI,CAACV,kBAAkB,CAAC,IAAI,CAAC9C,yBAAyB,CAAC,CAAC,CAAC,CAAC,CAACuD,QAAQ,CAAC5C,gBAAgB;IAC7G,MAAM8C,aAAa,GAAGzF,UAAU,CAACH,OAAO,CAAC,CAAC,CAAC;IAC3CyF,gBAAgB,CAACJ,QAAQ,CAACM,gBAAgB,EAAEC,aAAa,CAAC;IAC1DA,aAAa,CAACN,YAAY,CAAC,GAAG,CAAC;IAC/B,MAAMO,aAAa,GAAG1F,UAAU,CAACH,OAAO,CAAC,CAAC,CAAC;IAC3C2F,gBAAgB,CAACH,aAAa,CAACC,gBAAgB,EAAEI,aAAa,CAAC;IAE/D,MAAM9C,OAAO,GAAG8C,aAAa,CAACzD,MAAM,EAAE,GAAGmD,cAAc,CAACnD,MAAM,EAAE;IAChE,MAAM0D,WAAW,GAAGF,aAAa,CAACjD,QAAQ,CAACyC,cAAc,CAAC;IAC1D,MAAMtD,kBAAkB,GAAG7B,UAAU,CAAC8F,eAAe,CACjD,CAAC,EACD/F,OAAO,CAACgG,6BAA6B,CAACT,cAAc,CAACU,SAAS,EAAE,EAAEJ,aAAa,CAACI,SAAS,EAAE,EAAEjG,OAAO,CAACkG,UAAU,CAAC,EAChH,CAAC,CACJ;IAED,MAAM5D,SAAS,GAAG,IAAI,CAAC6D,UAAU,CAAC5D,MAAM;IACxC,IAAI,CAAC4D,UAAU,CAAC3D,SAAS,CAAC,IAAI,CAAC;IAE/B,MAAM4D,cAAc,GAAG,IAAI,CAAClD,wBAAwB,CAACkC,cAAc,CAACzC,QAAQ,CAAC,IAAI,CAACf,qBAAqB,CAACyE,qBAAqB,EAAE,CAAC,EAAEtD,OAAO,EAAEjB,kBAAkB,CAAC;IAC9J,IAAI,CAACF,qBAAqB,CAACE,kBAAmB,CAACkC,aAAa,CAAClC,kBAAkB,EAAE,IAAI,CAACqE,UAAU,CAACrE,kBAAmB,CAAC;IACrH,IAAI,CAACF,qBAAqB,CAACmB,OAAO,CAACuD,UAAU,CAACvD,OAAO,EAAE,IAAI,CAACoD,UAAU,CAACpD,OAAO,CAAC;IAC/E,IAAI,CAACnB,qBAAqB,CAACa,QAAQ,CAAC4C,QAAQ,CAACS,WAAW,CAACpD,UAAU,CAAC0D,cAAc,CAAC,EAAE,IAAI,CAACD,UAAU,CAAC1D,QAAQ,CAAC;IAC9G,IAAI,CAACxB,2BAA2B,CAAC4B,eAAe,CAAC;MAAEJ,QAAQ,EAAE,IAAI,CAAC0D,UAAU,CAAC1D;IAAQ,CAAE,CAAC;IAExF,IAAI,CAAC0D,UAAU,CAAC3D,SAAS,CAACF,SAAS,CAAC;EACxC;EAEUiE,gBAAgBA,CAAA;IACtB,MAAMC,YAAY,GAAG,IAAI,CAACrE,yBAAyB,CAACC,MAAM;IAC1D,MAAME,SAAS,GAAG,IAAI,CAAC6D,UAAU,CAAC5D,MAAM;IAExC,IAAI,CAAC,IAAI,CAAC4D,UAAU,CAACrE,kBAAkB,EAAE;MACrC,IAAI,CAACqE,UAAU,CAACrE,kBAAkB,GAAG7B,UAAU,CAACwG,oBAAoB,CAAC,IAAI,CAACN,UAAU,CAAC/C,QAAQ,CAACQ,CAAC,EAAE,IAAI,CAACuC,UAAU,CAAC/C,QAAQ,CAACO,CAAC,EAAE,IAAI,CAACwC,UAAU,CAAC/C,QAAQ,CAACS,CAAC,CAAC;;IAE5J,MAAM6C,UAAU,GAAG,IAAI,CAACP,UAAU,CAACE,qBAAqB,EAAE;IAC1D,IAAI,CAACF,UAAU,CAAC3D,SAAS,CAAC,IAAI,CAAC;IAE/B,IAAIgE,YAAY,KAAK,CAAC,EAAE;MACpB,IAAI,CAAC7F,eAAe,CAACiE,QAAQ,CAAC,IAAI,CAACuB,UAAU,CAAC1D,QAAQ,CAAC;MACvD,IAAI,CAAC7B,kBAAkB,CAACgE,QAAQ,CAAC,IAAI,CAACuB,UAAU,CAACrE,kBAAkB,CAAC;MACpE,IAAI,CAACjB,cAAc,CAAC+D,QAAQ,CAAC,IAAI,CAACuB,UAAU,CAACpD,OAAO,CAAC;MAErD,IAAI,IAAI,CAACxB,qBAAqB,IAAI,IAAI,CAACoF,MAAM,CAACC,YAAY,EAAE;QACxD,MAAMC,QAAQ,GAAG1G,UAAU,CAACH,OAAO,CAAC,CAAC,CAAC;QACtC,IAAI,CAAC2G,MAAM,CAACC,YAAY,CAACnE,QAAQ,CAAC+C,aAAa,CAACkB,UAAU,EAAEG,QAAQ,CAAC;QACrEA,QAAQ,CAACZ,SAAS,EAAE;QACpB,MAAMa,IAAI,GAAG3G,UAAU,CAACF,UAAU,CAAC,CAAC,CAAC;QACrC,IAAI,IAAI,CAAC0G,MAAM,CAACI,oBAAoB,EAAE;UAClC9G,UAAU,CAAC+G,wBAAwB,CAACH,QAAQ,EAAE,IAAI7G,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE8G,IAAI,CAAC;SAC5E,MAAM;UACH7G,UAAU,CAACgH,wBAAwB,CAACJ,QAAQ,EAAE,IAAI7G,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE8G,IAAI,CAAC;;QAE7EA,IAAI,CAACb,SAAS,EAAE;QAChBhG,UAAU,CAACyE,yBAAyB,CAACoC,IAAI,CAACnC,aAAa,EAAE,CAACf,CAAC,EAAE,CAAC,EAAE,CAAC,EAAEzD,UAAU,CAACF,UAAU,CAAC,CAAC,CAAC,CAAC;QAC5F,IAAI,CAACW,kBAAkB,CAACgE,QAAQ,CAACzE,UAAU,CAACF,UAAU,CAAC,CAAC,CAAC,CAAC;;MAE9D,IAAI,CAACa,iBAAiB,CAAC8D,QAAQ,CAAC,IAAI,CAACjE,eAAe,CAAC;MACrD,IAAI,CAACI,oBAAoB,CAAC6D,QAAQ,CAAC,IAAI,CAAChE,kBAAkB,CAAC;MAC3D,IAAI,CAACI,gBAAgB,CAAC4D,QAAQ,CAAC,IAAI,CAAC/D,cAAc,CAAC;KACtD,MAAM,IAAI2F,YAAY,KAAK,CAAC,EAAE;MAC3B,IAAI,CAAC5E,qBAAqB,CAACsF,aAAa,CAAC,IAAIlH,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAEO,KAAK,CAAC4G,KAAK,CAAC;MAC3E,IAAI,CAACvF,qBAAqB,CAACa,QAAQ,CAACmC,QAAQ,CAAC,IAAI,CAACuB,UAAU,CAAC1D,QAAQ,CAAC;MACtE,IAAI,CAACb,qBAAqB,CAACmB,OAAO,CAAC6B,QAAQ,CAAC,IAAI,CAACuB,UAAU,CAACpD,OAAO,CAAC;MACpE,IAAI,CAACnB,qBAAqB,CAACE,kBAAmB,CAAC8C,QAAQ,CAAC,IAAI,CAACuB,UAAU,CAACrE,kBAAkB,CAAC;MAC3F,IAAI,CAACF,qBAAqB,CAACsF,aAAa,CAACR,UAAU,EAAEnG,KAAK,CAAC6G,KAAK,CAAC;MACjE,IAAI,CAACC,2BAA2B,EAAE;;IAGtC,IAAI,CAAClB,UAAU,CAAC3D,SAAS,CAACF,SAAS,CAAC;EACxC;EAEUgF,WAAWA,CAACnD,kBAA2B,EAAEC,kBAA8B;IAC7E,IAAI,IAAI,CAACjC,yBAAyB,CAACC,MAAM,KAAK,CAAC,EAAE;MAC7C,IAAI,CAAC8B,0BAA0B,CAACC,kBAAkB,EAAEC,kBAAkB,CAAC;KAC1E,MAAM,IAAI,IAAI,CAACjC,yBAAyB,CAACC,MAAM,KAAK,CAAC,EAAE;MACpD,IAAI,CAAC2C,2BAA2B,EAAE;;EAE1C;EAEUwC,cAAcA,CAAA;IACpB,IAAI,IAAI,CAACpF,yBAAyB,CAACC,MAAM,KAAK,CAAC,EAAE;MAC7C;MACA,IAAI,CAACiF,2BAA2B,EAAE;MAClC,MAAMG,sBAAsB,GAAG,IAAI,CAACjG,qBAAqB;MACzD,IAAI,CAACA,qBAAqB,GAAG,KAAK;MAClC,IAAI,CAACgF,gBAAgB,EAAE;MACvB,IAAI,CAAChF,qBAAqB,GAAGiG,sBAAsB;;EAE3D;EAEA;;;EAGOC,MAAMA,CAAA;IACT,KAAK,CAACA,MAAM,EAAE;IAEd,IAAI,IAAI,CAACtB,UAAU,EAAE;MAChB,IAAI,CAACA,UAAmB,CAACxE,eAAe,GAAG,KAAK;MACjD,IAAI,CAACwE,UAAU,CAACnE,QAAQ,EAAE,CAACC,wBAAwB,CAACyF,MAAM,CAAC,IAAI,CAAChH,oBAAoB,CAAC;;IAGzF,IAAI,IAAI,CAACkB,qBAAqB,EAAE;MAC5B,IAAI,CAACA,qBAAqB,CAAC+F,OAAO,EAAE;;EAE5C"},"metadata":{},"sourceType":"module","externalDependencies":[]}