{"ast":null,"code":"import { Vector3, Quaternion, Matrix } from \"../Maths/math.vector.js\";\nimport { Space } from \"../Maths/math.axis.js\";\nimport { Logger } from \"../Misc/logger.js\";\n/**\n * Class used to apply inverse kinematics to bones\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons#boneikcontroller\n */\nexport class BoneIKController {\n  /**\n   * Gets or sets maximum allowed angle\n   */\n  get maxAngle() {\n    return this._maxAngle;\n  }\n  set maxAngle(value) {\n    this._setMaxAngle(value);\n  }\n  /**\n   * Creates a new BoneIKController\n   * @param mesh defines the TransformNode to control\n   * @param bone defines the bone to control. The bone needs to have a parent bone. It also needs to have a length greater than 0 or a children we can use to infer its length.\n   * @param options defines options to set up the controller\n   * @param options.targetMesh\n   * @param options.poleTargetMesh\n   * @param options.poleTargetBone\n   * @param options.poleTargetLocalOffset\n   * @param options.poleAngle\n   * @param options.bendAxis\n   * @param options.maxAngle\n   * @param options.slerpAmount\n   */\n  constructor(mesh, bone, options) {\n    /**\n     * Gets or sets the target position\n     */\n    this.targetPosition = Vector3.Zero();\n    /**\n     * Gets or sets the pole target position\n     */\n    this.poleTargetPosition = Vector3.Zero();\n    /**\n     * Gets or sets the pole target local offset\n     */\n    this.poleTargetLocalOffset = Vector3.Zero();\n    /**\n     * Gets or sets the pole angle\n     */\n    this.poleAngle = 0;\n    /**\n     * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)\n     */\n    this.slerpAmount = 1;\n    this._bone1Quat = Quaternion.Identity();\n    this._bone1Mat = Matrix.Identity();\n    this._bone2Ang = Math.PI;\n    this._maxAngle = Math.PI;\n    this._rightHandedSystem = false;\n    this._bendAxis = Vector3.Right();\n    this._slerping = false;\n    this._adjustRoll = 0;\n    this._notEnoughInformation = false;\n    this._bone2 = bone;\n    const bone1 = bone.getParent();\n    if (!bone1) {\n      this._notEnoughInformation = true;\n      Logger.Error(\"BoneIKController: bone must have a parent for IK to work.\");\n      return;\n    }\n    this._bone1 = bone1;\n    if (this._bone2.children.length === 0 && !this._bone2.length) {\n      this._notEnoughInformation = true;\n      Logger.Error(\"BoneIKController: bone must not be a leaf or it should have a length for IK to work.\");\n      return;\n    }\n    this.mesh = mesh;\n    bone.getSkeleton().computeAbsoluteMatrices();\n    const bonePos = bone.getPosition();\n    if (bone.getAbsoluteMatrix().determinant() > 0) {\n      this._rightHandedSystem = true;\n      this._bendAxis.x = 0;\n      this._bendAxis.y = 0;\n      this._bendAxis.z = -1;\n      if (bonePos.x > bonePos.y && bonePos.x > bonePos.z) {\n        this._adjustRoll = Math.PI * 0.5;\n        this._bendAxis.z = 1;\n      }\n    }\n    if (this._bone1.length && this._bone2.length) {\n      const boneScale1 = this._bone1.getScale();\n      const boneScale2 = this._bone2.getScale();\n      this._bone1Length = this._bone1.length * boneScale1.y * this.mesh.scaling.y;\n      this._bone2Length = this._bone2.length * boneScale2.y * this.mesh.scaling.y;\n    } else if (this._bone2.children[0]) {\n      mesh.computeWorldMatrix(true);\n      const pos1 = this._bone2.children[0].getAbsolutePosition(mesh);\n      const pos2 = this._bone2.getAbsolutePosition(mesh);\n      const pos3 = this._bone1.getAbsolutePosition(mesh);\n      this._bone2Length = Vector3.Distance(pos1, pos2);\n      this._bone1Length = Vector3.Distance(pos2, pos3);\n    } else {\n      mesh.computeWorldMatrix(true);\n      const boneScale2 = this._bone2.getScale();\n      this._bone2Length = this._bone2.length * boneScale2.y * this.mesh.scaling.y;\n      const pos2 = this._bone2.getAbsolutePosition(mesh);\n      const pos3 = this._bone1.getAbsolutePosition(mesh);\n      this._bone1Length = Vector3.Distance(pos2, pos3);\n    }\n    this._bone1.getRotationMatrixToRef(Space.WORLD, mesh, this._bone1Mat);\n    this.maxAngle = Math.PI;\n    if (options) {\n      if (options.targetMesh) {\n        this.targetMesh = options.targetMesh;\n        this.targetMesh.computeWorldMatrix(true);\n      }\n      if (options.poleTargetMesh) {\n        this.poleTargetMesh = options.poleTargetMesh;\n        this.poleTargetMesh.computeWorldMatrix(true);\n      } else if (options.poleTargetBone) {\n        this.poleTargetBone = options.poleTargetBone;\n      } else if (this._bone1.getParent()) {\n        this.poleTargetBone = this._bone1.getParent();\n      }\n      if (options.poleTargetLocalOffset) {\n        this.poleTargetLocalOffset.copyFrom(options.poleTargetLocalOffset);\n      }\n      if (options.poleAngle) {\n        this.poleAngle = options.poleAngle;\n      }\n      if (options.bendAxis) {\n        this._bendAxis.copyFrom(options.bendAxis);\n      }\n      if (options.maxAngle) {\n        this.maxAngle = options.maxAngle;\n      }\n      if (options.slerpAmount) {\n        this.slerpAmount = options.slerpAmount;\n      }\n    }\n  }\n  _setMaxAngle(ang) {\n    if (ang < 0) {\n      ang = 0;\n    }\n    if (ang > Math.PI || ang == undefined) {\n      ang = Math.PI;\n    }\n    this._maxAngle = ang;\n    const a = this._bone1Length;\n    const b = this._bone2Length;\n    this._maxReach = Math.sqrt(a * a + b * b - 2 * a * b * Math.cos(ang));\n  }\n  /**\n   * Force the controller to update the bones\n   */\n  update() {\n    if (this._notEnoughInformation) {\n      return;\n    }\n    const target = this.targetPosition;\n    const poleTarget = this.poleTargetPosition;\n    const mat1 = BoneIKController._TmpMats[0];\n    const mat2 = BoneIKController._TmpMats[1];\n    if (this.targetMesh) {\n      target.copyFrom(this.targetMesh.getAbsolutePosition());\n    }\n    if (this.poleTargetBone) {\n      this.poleTargetBone.getAbsolutePositionFromLocalToRef(this.poleTargetLocalOffset, this.mesh, poleTarget);\n    } else if (this.poleTargetMesh) {\n      Vector3.TransformCoordinatesToRef(this.poleTargetLocalOffset, this.poleTargetMesh.getWorldMatrix(), poleTarget);\n    }\n    const bonePos = BoneIKController._TmpVecs[0];\n    const zaxis = BoneIKController._TmpVecs[1];\n    const xaxis = BoneIKController._TmpVecs[2];\n    const yaxis = BoneIKController._TmpVecs[3];\n    const upAxis = BoneIKController._TmpVecs[4];\n    const tmpQuat = BoneIKController._TmpQuat;\n    this._bone1.getAbsolutePositionToRef(this.mesh, bonePos);\n    poleTarget.subtractToRef(bonePos, upAxis);\n    if (upAxis.x == 0 && upAxis.y == 0 && upAxis.z == 0) {\n      upAxis.y = 1;\n    } else {\n      upAxis.normalize();\n    }\n    target.subtractToRef(bonePos, yaxis);\n    yaxis.normalize();\n    Vector3.CrossToRef(yaxis, upAxis, zaxis);\n    zaxis.normalize();\n    Vector3.CrossToRef(yaxis, zaxis, xaxis);\n    xaxis.normalize();\n    Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, mat1);\n    const a = this._bone1Length;\n    const b = this._bone2Length;\n    let c = Vector3.Distance(bonePos, target);\n    if (this._maxReach > 0) {\n      c = Math.min(this._maxReach, c);\n    }\n    let acosa = (b * b + c * c - a * a) / (2 * b * c);\n    let acosb = (c * c + a * a - b * b) / (2 * c * a);\n    if (acosa > 1) {\n      acosa = 1;\n    }\n    if (acosb > 1) {\n      acosb = 1;\n    }\n    if (acosa < -1) {\n      acosa = -1;\n    }\n    if (acosb < -1) {\n      acosb = -1;\n    }\n    const angA = Math.acos(acosa);\n    const angB = Math.acos(acosb);\n    let angC = -angA - angB;\n    if (this._rightHandedSystem) {\n      Matrix.RotationYawPitchRollToRef(0, 0, this._adjustRoll, mat2);\n      mat2.multiplyToRef(mat1, mat1);\n      Matrix.RotationAxisToRef(this._bendAxis, angB, mat2);\n      mat2.multiplyToRef(mat1, mat1);\n    } else {\n      const _tmpVec = BoneIKController._TmpVecs[5];\n      _tmpVec.copyFrom(this._bendAxis);\n      _tmpVec.x *= -1;\n      Matrix.RotationAxisToRef(_tmpVec, -angB, mat2);\n      mat2.multiplyToRef(mat1, mat1);\n    }\n    if (this.poleAngle) {\n      Matrix.RotationAxisToRef(yaxis, this.poleAngle, mat2);\n      mat1.multiplyToRef(mat2, mat1);\n    }\n    if (this._bone1) {\n      if (this.slerpAmount < 1) {\n        if (!this._slerping) {\n          Quaternion.FromRotationMatrixToRef(this._bone1Mat, this._bone1Quat);\n        }\n        Quaternion.FromRotationMatrixToRef(mat1, tmpQuat);\n        Quaternion.SlerpToRef(this._bone1Quat, tmpQuat, this.slerpAmount, this._bone1Quat);\n        angC = this._bone2Ang * (1.0 - this.slerpAmount) + angC * this.slerpAmount;\n        this._bone1.setRotationQuaternion(this._bone1Quat, Space.WORLD, this.mesh);\n        this._slerping = true;\n      } else {\n        this._bone1.setRotationMatrix(mat1, Space.WORLD, this.mesh);\n        this._bone1Mat.copyFrom(mat1);\n        this._slerping = false;\n      }\n      this._updateLinkedTransformRotation(this._bone1);\n    }\n    this._bone2.setAxisAngle(this._bendAxis, angC, Space.LOCAL);\n    this._updateLinkedTransformRotation(this._bone2);\n    this._bone2Ang = angC;\n  }\n  _updateLinkedTransformRotation(bone) {\n    if (bone._linkedTransformNode) {\n      if (!bone._linkedTransformNode.rotationQuaternion) {\n        bone._linkedTransformNode.rotationQuaternion = new Quaternion();\n      }\n      bone.getRotationQuaternionToRef(Space.LOCAL, null, bone._linkedTransformNode.rotationQuaternion);\n    }\n  }\n}\nBoneIKController._TmpVecs = [Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero()];\nBoneIKController._TmpQuat = Quaternion.Identity();\nBoneIKController._TmpMats = [Matrix.Identity(), Matrix.Identity()];","map":{"version":3,"names":["Vector3","Quaternion","Matrix","Space","Logger","BoneIKController","maxAngle","_maxAngle","value","_setMaxAngle","constructor","mesh","bone","options","targetPosition","Zero","poleTargetPosition","poleTargetLocalOffset","poleAngle","slerpAmount","_bone1Quat","Identity","_bone1Mat","_bone2Ang","Math","PI","_rightHandedSystem","_bendAxis","Right","_slerping","_adjustRoll","_notEnoughInformation","_bone2","bone1","getParent","Error","_bone1","children","length","getSkeleton","computeAbsoluteMatrices","bonePos","getPosition","getAbsoluteMatrix","determinant","x","y","z","boneScale1","getScale","boneScale2","_bone1Length","scaling","_bone2Length","computeWorldMatrix","pos1","getAbsolutePosition","pos2","pos3","Distance","getRotationMatrixToRef","WORLD","targetMesh","poleTargetMesh","poleTargetBone","copyFrom","bendAxis","ang","undefined","a","b","_maxReach","sqrt","cos","update","target","poleTarget","mat1","_TmpMats","mat2","getAbsolutePositionFromLocalToRef","TransformCoordinatesToRef","getWorldMatrix","_TmpVecs","zaxis","xaxis","yaxis","upAxis","tmpQuat","_TmpQuat","getAbsolutePositionToRef","subtractToRef","normalize","CrossToRef","FromXYZAxesToRef","c","min","acosa","acosb","angA","acos","angB","angC","RotationYawPitchRollToRef","multiplyToRef","RotationAxisToRef","_tmpVec","FromRotationMatrixToRef","SlerpToRef","setRotationQuaternion","setRotationMatrix","_updateLinkedTransformRotation","setAxisAngle","LOCAL","_linkedTransformNode","rotationQuaternion","getRotationQuaternionToRef"],"sources":["../../../../dev/core/src/Bones/boneIKController.ts"],"sourcesContent":["import type { Bone } from \"./bone\";\r\nimport { Vector3, Quaternion, Matrix } from \"../Maths/math.vector\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Space } from \"../Maths/math.axis\";\r\nimport { Logger } from \"../Misc/logger\";\r\n\r\n/**\r\n * Class used to apply inverse kinematics to bones\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons#boneikcontroller\r\n */\r\nexport class BoneIKController {\r\n    private static _TmpVecs: Vector3[] = [Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero()];\r\n    private static _TmpQuat = Quaternion.Identity();\r\n    private static _TmpMats: Matrix[] = [Matrix.Identity(), Matrix.Identity()];\r\n\r\n    /**\r\n     * Gets or sets the target TransformNode\r\n     * Name kept as mesh for back compatibility\r\n     */\r\n    public targetMesh: TransformNode;\r\n\r\n    /** Gets or sets the mesh used as pole */\r\n    public poleTargetMesh: TransformNode;\r\n\r\n    /**\r\n     * Gets or sets the bone used as pole\r\n     */\r\n    public poleTargetBone: Nullable<Bone>;\r\n\r\n    /**\r\n     * Gets or sets the target position\r\n     */\r\n    public targetPosition = Vector3.Zero();\r\n\r\n    /**\r\n     * Gets or sets the pole target position\r\n     */\r\n    public poleTargetPosition = Vector3.Zero();\r\n\r\n    /**\r\n     * Gets or sets the pole target local offset\r\n     */\r\n    public poleTargetLocalOffset = Vector3.Zero();\r\n\r\n    /**\r\n     * Gets or sets the pole angle\r\n     */\r\n    public poleAngle = 0;\r\n\r\n    /**\r\n     * Gets or sets the TransformNode associated with the controller\r\n     * Name kept as mesh for back compatibility\r\n     */\r\n    public mesh: TransformNode;\r\n\r\n    /**\r\n     * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)\r\n     */\r\n    public slerpAmount = 1;\r\n\r\n    private _bone1Quat = Quaternion.Identity();\r\n    private _bone1Mat = Matrix.Identity();\r\n    private _bone2Ang = Math.PI;\r\n\r\n    private _bone1: Bone;\r\n    private _bone2: Bone;\r\n    private _bone1Length: number;\r\n    private _bone2Length: number;\r\n    private _maxAngle = Math.PI;\r\n    private _maxReach: number;\r\n\r\n    private _rightHandedSystem = false;\r\n\r\n    private _bendAxis = Vector3.Right();\r\n    private _slerping = false;\r\n\r\n    private _adjustRoll = 0;\r\n\r\n    private _notEnoughInformation = false;\r\n\r\n    /**\r\n     * Gets or sets maximum allowed angle\r\n     */\r\n    public get maxAngle(): number {\r\n        return this._maxAngle;\r\n    }\r\n\r\n    public set maxAngle(value: number) {\r\n        this._setMaxAngle(value);\r\n    }\r\n\r\n    /**\r\n     * Creates a new BoneIKController\r\n     * @param mesh defines the TransformNode to control\r\n     * @param bone defines the bone to control. The bone needs to have a parent bone. It also needs to have a length greater than 0 or a children we can use to infer its length.\r\n     * @param options defines options to set up the controller\r\n     * @param options.targetMesh\r\n     * @param options.poleTargetMesh\r\n     * @param options.poleTargetBone\r\n     * @param options.poleTargetLocalOffset\r\n     * @param options.poleAngle\r\n     * @param options.bendAxis\r\n     * @param options.maxAngle\r\n     * @param options.slerpAmount\r\n     */\r\n    constructor(\r\n        mesh: TransformNode,\r\n        bone: Bone,\r\n        options?: {\r\n            targetMesh?: TransformNode;\r\n            poleTargetMesh?: TransformNode;\r\n            poleTargetBone?: Bone;\r\n            poleTargetLocalOffset?: Vector3;\r\n            poleAngle?: number;\r\n            bendAxis?: Vector3;\r\n            maxAngle?: number;\r\n            slerpAmount?: number;\r\n        }\r\n    ) {\r\n        this._bone2 = bone;\r\n        const bone1 = bone.getParent();\r\n\r\n        if (!bone1) {\r\n            this._notEnoughInformation = true;\r\n            Logger.Error(\"BoneIKController: bone must have a parent for IK to work.\");\r\n            return;\r\n        }\r\n        this._bone1 = bone1;\r\n\r\n        if (this._bone2.children.length === 0 && !this._bone2.length) {\r\n            this._notEnoughInformation = true;\r\n            Logger.Error(\"BoneIKController: bone must not be a leaf or it should have a length for IK to work.\");\r\n            return;\r\n        }\r\n\r\n        this.mesh = mesh;\r\n\r\n        bone.getSkeleton().computeAbsoluteMatrices();\r\n\r\n        const bonePos = bone.getPosition();\r\n\r\n        if (bone.getAbsoluteMatrix().determinant() > 0) {\r\n            this._rightHandedSystem = true;\r\n            this._bendAxis.x = 0;\r\n            this._bendAxis.y = 0;\r\n            this._bendAxis.z = -1;\r\n\r\n            if (bonePos.x > bonePos.y && bonePos.x > bonePos.z) {\r\n                this._adjustRoll = Math.PI * 0.5;\r\n                this._bendAxis.z = 1;\r\n            }\r\n        }\r\n\r\n        if (this._bone1.length && this._bone2.length) {\r\n            const boneScale1 = this._bone1.getScale();\r\n            const boneScale2 = this._bone2.getScale();\r\n\r\n            this._bone1Length = this._bone1.length * boneScale1.y * this.mesh.scaling.y;\r\n            this._bone2Length = this._bone2.length * boneScale2.y * this.mesh.scaling.y;\r\n        } else if (this._bone2.children[0]) {\r\n            mesh.computeWorldMatrix(true);\r\n\r\n            const pos1 = this._bone2.children[0].getAbsolutePosition(mesh);\r\n            const pos2 = this._bone2.getAbsolutePosition(mesh);\r\n            const pos3 = this._bone1.getAbsolutePosition(mesh);\r\n\r\n            this._bone2Length = Vector3.Distance(pos1, pos2);\r\n            this._bone1Length = Vector3.Distance(pos2, pos3);\r\n        } else {\r\n            mesh.computeWorldMatrix(true);\r\n\r\n            const boneScale2 = this._bone2.getScale();\r\n            this._bone2Length = this._bone2.length * boneScale2.y * this.mesh.scaling.y;\r\n\r\n            const pos2 = this._bone2.getAbsolutePosition(mesh);\r\n            const pos3 = this._bone1.getAbsolutePosition(mesh);\r\n\r\n            this._bone1Length = Vector3.Distance(pos2, pos3);\r\n        }\r\n\r\n        this._bone1.getRotationMatrixToRef(Space.WORLD, mesh, this._bone1Mat);\r\n        this.maxAngle = Math.PI;\r\n\r\n        if (options) {\r\n            if (options.targetMesh) {\r\n                this.targetMesh = options.targetMesh;\r\n                this.targetMesh.computeWorldMatrix(true);\r\n            }\r\n\r\n            if (options.poleTargetMesh) {\r\n                this.poleTargetMesh = options.poleTargetMesh;\r\n                this.poleTargetMesh.computeWorldMatrix(true);\r\n            } else if (options.poleTargetBone) {\r\n                this.poleTargetBone = options.poleTargetBone;\r\n            } else if (this._bone1.getParent()) {\r\n                this.poleTargetBone = this._bone1.getParent();\r\n            }\r\n\r\n            if (options.poleTargetLocalOffset) {\r\n                this.poleTargetLocalOffset.copyFrom(options.poleTargetLocalOffset);\r\n            }\r\n\r\n            if (options.poleAngle) {\r\n                this.poleAngle = options.poleAngle;\r\n            }\r\n\r\n            if (options.bendAxis) {\r\n                this._bendAxis.copyFrom(options.bendAxis);\r\n            }\r\n\r\n            if (options.maxAngle) {\r\n                this.maxAngle = options.maxAngle;\r\n            }\r\n\r\n            if (options.slerpAmount) {\r\n                this.slerpAmount = options.slerpAmount;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setMaxAngle(ang: number): void {\r\n        if (ang < 0) {\r\n            ang = 0;\r\n        }\r\n\r\n        if (ang > Math.PI || ang == undefined) {\r\n            ang = Math.PI;\r\n        }\r\n\r\n        this._maxAngle = ang;\r\n\r\n        const a = this._bone1Length;\r\n        const b = this._bone2Length;\r\n\r\n        this._maxReach = Math.sqrt(a * a + b * b - 2 * a * b * Math.cos(ang));\r\n    }\r\n\r\n    /**\r\n     * Force the controller to update the bones\r\n     */\r\n    public update(): void {\r\n        if (this._notEnoughInformation) {\r\n            return;\r\n        }\r\n\r\n        const target = this.targetPosition;\r\n        const poleTarget = this.poleTargetPosition;\r\n\r\n        const mat1 = BoneIKController._TmpMats[0];\r\n        const mat2 = BoneIKController._TmpMats[1];\r\n\r\n        if (this.targetMesh) {\r\n            target.copyFrom(this.targetMesh.getAbsolutePosition());\r\n        }\r\n\r\n        if (this.poleTargetBone) {\r\n            this.poleTargetBone.getAbsolutePositionFromLocalToRef(this.poleTargetLocalOffset, this.mesh, poleTarget);\r\n        } else if (this.poleTargetMesh) {\r\n            Vector3.TransformCoordinatesToRef(this.poleTargetLocalOffset, this.poleTargetMesh.getWorldMatrix(), poleTarget);\r\n        }\r\n\r\n        const bonePos = BoneIKController._TmpVecs[0];\r\n        const zaxis = BoneIKController._TmpVecs[1];\r\n        const xaxis = BoneIKController._TmpVecs[2];\r\n        const yaxis = BoneIKController._TmpVecs[3];\r\n        const upAxis = BoneIKController._TmpVecs[4];\r\n\r\n        const tmpQuat = BoneIKController._TmpQuat;\r\n\r\n        this._bone1.getAbsolutePositionToRef(this.mesh, bonePos);\r\n\r\n        poleTarget.subtractToRef(bonePos, upAxis);\r\n\r\n        if (upAxis.x == 0 && upAxis.y == 0 && upAxis.z == 0) {\r\n            upAxis.y = 1;\r\n        } else {\r\n            upAxis.normalize();\r\n        }\r\n\r\n        target.subtractToRef(bonePos, yaxis);\r\n        yaxis.normalize();\r\n\r\n        Vector3.CrossToRef(yaxis, upAxis, zaxis);\r\n        zaxis.normalize();\r\n\r\n        Vector3.CrossToRef(yaxis, zaxis, xaxis);\r\n        xaxis.normalize();\r\n\r\n        Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, mat1);\r\n\r\n        const a = this._bone1Length;\r\n        const b = this._bone2Length;\r\n\r\n        let c = Vector3.Distance(bonePos, target);\r\n\r\n        if (this._maxReach > 0) {\r\n            c = Math.min(this._maxReach, c);\r\n        }\r\n\r\n        let acosa = (b * b + c * c - a * a) / (2 * b * c);\r\n        let acosb = (c * c + a * a - b * b) / (2 * c * a);\r\n\r\n        if (acosa > 1) {\r\n            acosa = 1;\r\n        }\r\n\r\n        if (acosb > 1) {\r\n            acosb = 1;\r\n        }\r\n\r\n        if (acosa < -1) {\r\n            acosa = -1;\r\n        }\r\n\r\n        if (acosb < -1) {\r\n            acosb = -1;\r\n        }\r\n\r\n        const angA = Math.acos(acosa);\r\n        const angB = Math.acos(acosb);\r\n\r\n        let angC = -angA - angB;\r\n\r\n        if (this._rightHandedSystem) {\r\n            Matrix.RotationYawPitchRollToRef(0, 0, this._adjustRoll, mat2);\r\n            mat2.multiplyToRef(mat1, mat1);\r\n\r\n            Matrix.RotationAxisToRef(this._bendAxis, angB, mat2);\r\n            mat2.multiplyToRef(mat1, mat1);\r\n        } else {\r\n            const _tmpVec = BoneIKController._TmpVecs[5];\r\n\r\n            _tmpVec.copyFrom(this._bendAxis);\r\n            _tmpVec.x *= -1;\r\n\r\n            Matrix.RotationAxisToRef(_tmpVec, -angB, mat2);\r\n            mat2.multiplyToRef(mat1, mat1);\r\n        }\r\n\r\n        if (this.poleAngle) {\r\n            Matrix.RotationAxisToRef(yaxis, this.poleAngle, mat2);\r\n            mat1.multiplyToRef(mat2, mat1);\r\n        }\r\n\r\n        if (this._bone1) {\r\n            if (this.slerpAmount < 1) {\r\n                if (!this._slerping) {\r\n                    Quaternion.FromRotationMatrixToRef(this._bone1Mat, this._bone1Quat);\r\n                }\r\n                Quaternion.FromRotationMatrixToRef(mat1, tmpQuat);\r\n                Quaternion.SlerpToRef(this._bone1Quat, tmpQuat, this.slerpAmount, this._bone1Quat);\r\n                angC = this._bone2Ang * (1.0 - this.slerpAmount) + angC * this.slerpAmount;\r\n\r\n                this._bone1.setRotationQuaternion(this._bone1Quat, Space.WORLD, this.mesh);\r\n                this._slerping = true;\r\n            } else {\r\n                this._bone1.setRotationMatrix(mat1, Space.WORLD, this.mesh);\r\n                this._bone1Mat.copyFrom(mat1);\r\n                this._slerping = false;\r\n            }\r\n            this._updateLinkedTransformRotation(this._bone1);\r\n        }\r\n\r\n        this._bone2.setAxisAngle(this._bendAxis, angC, Space.LOCAL);\r\n        this._updateLinkedTransformRotation(this._bone2);\r\n        this._bone2Ang = angC;\r\n    }\r\n\r\n    private _updateLinkedTransformRotation(bone: Bone): void {\r\n        if (bone._linkedTransformNode) {\r\n            if (!bone._linkedTransformNode.rotationQuaternion) {\r\n                bone._linkedTransformNode.rotationQuaternion = new Quaternion();\r\n            }\r\n            bone.getRotationQuaternionToRef(Space.LOCAL, null, bone._linkedTransformNode.rotationQuaternion);\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}