{"ast":null,"code":"import { Scene } from \"../scene.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { PointerInfo, PointerEventTypes } from \"../Events/pointerEvents.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { HemisphericLight } from \"../Lights/hemisphericLight.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\n/**\n * Renders a layer on top of an existing scene\n */\nexport class UtilityLayerRenderer {\n  /**\n   * Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)\n   * @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned\n   * @returns the camera that is used when rendering the utility layer\n   */\n  getRenderCamera(getRigParentIfPossible) {\n    if (this._renderCamera) {\n      return this._renderCamera;\n    } else {\n      let activeCam;\n      if (this.originalScene.activeCameras && this.originalScene.activeCameras.length > 1) {\n        activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];\n      } else {\n        activeCam = this.originalScene.activeCamera;\n      }\n      if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {\n        return activeCam.rigParent;\n      }\n      return activeCam;\n    }\n  }\n  /**\n   * Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)\n   * @param cam the camera that should be used when rendering the utility layer\n   */\n  setRenderCamera(cam) {\n    this._renderCamera = cam;\n  }\n  /**\n   * @internal\n   * Light which used by gizmos to get light shading\n   */\n  _getSharedGizmoLight() {\n    if (!this._sharedGizmoLight) {\n      this._sharedGizmoLight = new HemisphericLight(\"shared gizmo light\", new Vector3(0, 1, 0), this.utilityLayerScene);\n      this._sharedGizmoLight.intensity = 2;\n      this._sharedGizmoLight.groundColor = Color3.Gray();\n    }\n    return this._sharedGizmoLight;\n  }\n  /**\n   * A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)\n   */\n  static get DefaultUtilityLayer() {\n    if (UtilityLayerRenderer._DefaultUtilityLayer == null) {\n      return UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene(EngineStore.LastCreatedScene);\n    }\n    return UtilityLayerRenderer._DefaultUtilityLayer;\n  }\n  /**\n   * Creates an utility layer, and set it as a default utility layer\n   * @param scene associated scene\n   * @internal\n   */\n  static _CreateDefaultUtilityLayerFromScene(scene) {\n    UtilityLayerRenderer._DefaultUtilityLayer = new UtilityLayerRenderer(scene);\n    UtilityLayerRenderer._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\n      UtilityLayerRenderer._DefaultUtilityLayer = null;\n    });\n    return UtilityLayerRenderer._DefaultUtilityLayer;\n  }\n  /**\n   * A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)\n   */\n  static get DefaultKeepDepthUtilityLayer() {\n    if (UtilityLayerRenderer._DefaultKeepDepthUtilityLayer == null) {\n      UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = new UtilityLayerRenderer(EngineStore.LastCreatedScene);\n      UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\n      UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\n        UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;\n      });\n    }\n    return UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;\n  }\n  /**\n   * Instantiates a UtilityLayerRenderer\n   * @param originalScene the original scene that will be rendered on top of\n   * @param handleEvents boolean indicating if the utility layer should handle events\n   */\n  constructor( /** the original scene that will be rendered on top of */\n  originalScene, handleEvents = true) {\n    this.originalScene = originalScene;\n    this._pointerCaptures = {};\n    this._lastPointerEvents = {};\n    this._sharedGizmoLight = null;\n    this._renderCamera = null;\n    /**\n     * If the picking should be done on the utility layer prior to the actual scene (Default: true)\n     */\n    this.pickUtilitySceneFirst = true;\n    /**\n     *  If the utility layer should automatically be rendered on top of existing scene\n     */\n    this.shouldRender = true;\n    /**\n     * If set to true, only pointer down onPointerObservable events will be blocked when picking is occluded by original scene\n     */\n    this.onlyCheckPointerDownEvents = true;\n    /**\n     * If set to false, only pointerUp, pointerDown and pointerMove will be sent to the utilityLayerScene (false by default)\n     */\n    this.processAllEvents = false;\n    /**\n     * Set to false to disable picking\n     */\n    this.pickingEnabled = true;\n    /**\n     * Observable raised when the pointer moves from the utility layer scene to the main scene\n     */\n    this.onPointerOutObservable = new Observable();\n    // Create scene which will be rendered in the foreground and remove it from being referenced by engine to avoid interfering with existing app\n    this.utilityLayerScene = new Scene(originalScene.getEngine(), {\n      virtual: true\n    });\n    this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;\n    this.utilityLayerScene._allowPostProcessClearColor = false;\n    // Deactivate post processes\n    this.utilityLayerScene.postProcessesEnabled = false;\n    // Detach controls on utility scene, events will be fired by logic below to handle picking priority\n    this.utilityLayerScene.detachControl();\n    if (handleEvents) {\n      this._originalPointerObserver = originalScene.onPrePointerObservable.add(prePointerInfo => {\n        if (!this.utilityLayerScene.activeCamera) {\n          return;\n        }\n        if (!this.pickingEnabled) {\n          return;\n        }\n        if (!this.processAllEvents) {\n          if (prePointerInfo.type !== PointerEventTypes.POINTERMOVE && prePointerInfo.type !== PointerEventTypes.POINTERUP && prePointerInfo.type !== PointerEventTypes.POINTERDOWN && prePointerInfo.type !== PointerEventTypes.POINTERDOUBLETAP) {\n            return;\n          }\n        }\n        this.utilityLayerScene.pointerX = originalScene.pointerX;\n        this.utilityLayerScene.pointerY = originalScene.pointerY;\n        const pointerEvent = prePointerInfo.event;\n        if (originalScene.isPointerCaptured(pointerEvent.pointerId)) {\n          this._pointerCaptures[pointerEvent.pointerId] = false;\n          return;\n        }\n        const getNearPickDataForScene = scene => {\n          let scenePick = null;\n          if (prePointerInfo.nearInteractionPickingInfo) {\n            if (prePointerInfo.nearInteractionPickingInfo.pickedMesh.getScene() == scene) {\n              scenePick = prePointerInfo.nearInteractionPickingInfo;\n            } else {\n              scenePick = new PickingInfo();\n            }\n          } else if (scene !== this.utilityLayerScene && prePointerInfo.originalPickingInfo) {\n            scenePick = prePointerInfo.originalPickingInfo;\n          } else {\n            let previousActiveCamera = null;\n            // If a camera is set for rendering with this layer\n            // it will also be used for the ray computation\n            // To preserve back compat and because scene.pick always use activeCamera\n            // it's substituted temporarily and a new scenePick is forced.\n            // otherwise, the ray with previously active camera is always used.\n            // It's set back to previous activeCamera after operation.\n            if (this._renderCamera) {\n              previousActiveCamera = scene._activeCamera;\n              scene._activeCamera = this._renderCamera;\n              prePointerInfo.ray = null;\n            }\n            scenePick = prePointerInfo.ray ? scene.pickWithRay(prePointerInfo.ray) : scene.pick(originalScene.pointerX, originalScene.pointerY);\n            if (previousActiveCamera) {\n              scene._activeCamera = previousActiveCamera;\n            }\n          }\n          return scenePick;\n        };\n        const utilityScenePick = getNearPickDataForScene(this.utilityLayerScene);\n        if (!prePointerInfo.ray && utilityScenePick) {\n          prePointerInfo.ray = utilityScenePick.ray;\n        }\n        // always fire the prepointer observable\n        this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo);\n        // allow every non pointer down event to flow to the utility layer\n        if (this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {\n          if (!prePointerInfo.skipOnPointerObservable) {\n            this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);\n          }\n          if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\n            this._pointerCaptures[pointerEvent.pointerId] = false;\n          }\n          return;\n        }\n        if (this.utilityLayerScene.autoClearDepthAndStencil || this.pickUtilitySceneFirst) {\n          // If this layer is an overlay, check if this layer was hit and if so, skip pointer events for the main scene\n          if (utilityScenePick && utilityScenePick.hit) {\n            if (!prePointerInfo.skipOnPointerObservable) {\n              this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);\n            }\n            prePointerInfo.skipOnPointerObservable = true;\n          }\n        } else {\n          const originalScenePick = getNearPickDataForScene(originalScene);\n          const pointerEvent = prePointerInfo.event;\n          // If the layer can be occluded by the original scene, only fire pointer events to the first layer that hit they ray\n          if (originalScenePick && utilityScenePick) {\n            // No pick in utility scene\n            if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {\n              if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\n                // We touched an utility mesh present in the main scene\n                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\n                prePointerInfo.skipOnPointerObservable = true;\n              } else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {\n                this._pointerCaptures[pointerEvent.pointerId] = true;\n              } else if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\n                if (this._lastPointerEvents[pointerEvent.pointerId]) {\n                  // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\n                  this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\n                  delete this._lastPointerEvents[pointerEvent.pointerId];\n                }\n                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\n              }\n            } else if (!this._pointerCaptures[pointerEvent.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {\n              // We pick something in utility scene or the pick in utility is closer than the one in main scene\n              this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\n              // If a previous utility layer set this, do not unset this\n              if (!prePointerInfo.skipOnPointerObservable) {\n                prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;\n              }\n            } else if (!this._pointerCaptures[pointerEvent.pointerId] && utilityScenePick.distance >= originalScenePick.distance) {\n              // We have a pick in both scenes but main is closer than utility\n              // We touched an utility mesh present in the main scene\n              if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\n                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\n                prePointerInfo.skipOnPointerObservable = true;\n              } else {\n                if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\n                  if (this._lastPointerEvents[pointerEvent.pointerId]) {\n                    // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\n                    this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\n                    delete this._lastPointerEvents[pointerEvent.pointerId];\n                  }\n                }\n                this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\n              }\n            }\n            if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\n              this._pointerCaptures[pointerEvent.pointerId] = false;\n            }\n          }\n        }\n      });\n      // As a newly added utility layer will be rendered over the screen last, it's pointer events should be processed first\n      if (this._originalPointerObserver) {\n        originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);\n      }\n    }\n    // Render directly on top of existing scene without clearing\n    this.utilityLayerScene.autoClear = false;\n    this._afterRenderObserver = this.originalScene.onAfterRenderCameraObservable.add(camera => {\n      // Only render when the render camera finishes rendering\n      if (this.shouldRender && camera == this.getRenderCamera()) {\n        this.render();\n      }\n    });\n    this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(() => {\n      this.dispose();\n    });\n    this._updateCamera();\n  }\n  _notifyObservers(prePointerInfo, pickInfo, pointerEvent) {\n    if (!prePointerInfo.skipOnPointerObservable) {\n      this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo), prePointerInfo.type);\n      this._lastPointerEvents[pointerEvent.pointerId] = true;\n    }\n  }\n  /**\n   * Renders the utility layers scene on top of the original scene\n   */\n  render() {\n    this._updateCamera();\n    if (this.utilityLayerScene.activeCamera) {\n      // Set the camera's scene to utility layers scene\n      const oldScene = this.utilityLayerScene.activeCamera.getScene();\n      const camera = this.utilityLayerScene.activeCamera;\n      camera._scene = this.utilityLayerScene;\n      if (camera.leftCamera) {\n        camera.leftCamera._scene = this.utilityLayerScene;\n      }\n      if (camera.rightCamera) {\n        camera.rightCamera._scene = this.utilityLayerScene;\n      }\n      this.utilityLayerScene.render(false);\n      // Reset camera's scene back to original\n      camera._scene = oldScene;\n      if (camera.leftCamera) {\n        camera.leftCamera._scene = oldScene;\n      }\n      if (camera.rightCamera) {\n        camera.rightCamera._scene = oldScene;\n      }\n    }\n  }\n  /**\n   * Disposes of the renderer\n   */\n  dispose() {\n    this.onPointerOutObservable.clear();\n    if (this._afterRenderObserver) {\n      this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);\n    }\n    if (this._sceneDisposeObserver) {\n      this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);\n    }\n    if (this._originalPointerObserver) {\n      this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);\n    }\n    this.utilityLayerScene.dispose();\n  }\n  _updateCamera() {\n    this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();\n    this.utilityLayerScene.activeCamera = this.getRenderCamera();\n  }\n}\n/** @internal */\nUtilityLayerRenderer._DefaultUtilityLayer = null;\n/** @internal */\nUtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;","map":{"version":3,"names":["Scene","Observable","PointerInfo","PointerEventTypes","PickingInfo","EngineStore","HemisphericLight","Vector3","Color3","UtilityLayerRenderer","getRenderCamera","getRigParentIfPossible","_renderCamera","activeCam","originalScene","activeCameras","length","activeCamera","isRigCamera","rigParent","setRenderCamera","cam","_getSharedGizmoLight","_sharedGizmoLight","utilityLayerScene","intensity","groundColor","Gray","DefaultUtilityLayer","_DefaultUtilityLayer","_CreateDefaultUtilityLayerFromScene","LastCreatedScene","scene","onDisposeObservable","addOnce","DefaultKeepDepthUtilityLayer","_DefaultKeepDepthUtilityLayer","autoClearDepthAndStencil","constructor","handleEvents","_pointerCaptures","_lastPointerEvents","pickUtilitySceneFirst","shouldRender","onlyCheckPointerDownEvents","processAllEvents","pickingEnabled","onPointerOutObservable","getEngine","virtual","useRightHandedSystem","_allowPostProcessClearColor","postProcessesEnabled","detachControl","_originalPointerObserver","onPrePointerObservable","add","prePointerInfo","type","POINTERMOVE","POINTERUP","POINTERDOWN","POINTERDOUBLETAP","pointerX","pointerY","pointerEvent","event","isPointerCaptured","pointerId","getNearPickDataForScene","scenePick","nearInteractionPickingInfo","pickedMesh","getScene","originalPickingInfo","previousActiveCamera","_activeCamera","ray","pickWithRay","pick","utilityScenePick","notifyObservers","skipOnPointerObservable","onPointerObservable","hit","originalScenePick","distance","mainSceneTrackerPredicate","_notifyObservers","makeObserverTopPriority","autoClear","_afterRenderObserver","onAfterRenderCameraObservable","camera","render","_sceneDisposeObserver","dispose","_updateCamera","pickInfo","oldScene","_scene","leftCamera","rightCamera","clear","onAfterCameraRenderObservable","remove","cameraToUseForPointers"],"sources":["../../../../dev/core/src/Rendering/utilityLayerRenderer.ts"],"sourcesContent":["import type { IDisposable } from \"../scene\";\r\nimport { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { PointerInfoPre } from \"../Events/pointerEvents\";\r\nimport { PointerInfo, PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { HemisphericLight } from \"../Lights/hemisphericLight\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { IPointerEvent } from \"../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Renders a layer on top of an existing scene\r\n */\r\nexport class UtilityLayerRenderer implements IDisposable {\r\n    private _pointerCaptures: { [pointerId: number]: boolean } = {};\r\n    private _lastPointerEvents: { [pointerId: number]: boolean } = {};\r\n    /** @internal */\r\n    public static _DefaultUtilityLayer: Nullable<UtilityLayerRenderer> = null;\r\n    /** @internal */\r\n    public static _DefaultKeepDepthUtilityLayer: Nullable<UtilityLayerRenderer> = null;\r\n    private _sharedGizmoLight: Nullable<HemisphericLight> = null;\r\n\r\n    private _renderCamera: Nullable<Camera> = null;\r\n\r\n    /**\r\n     * Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)\r\n     * @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned\r\n     * @returns the camera that is used when rendering the utility layer\r\n     */\r\n    public getRenderCamera(getRigParentIfPossible?: boolean) {\r\n        if (this._renderCamera) {\r\n            return this._renderCamera;\r\n        } else {\r\n            let activeCam: Camera;\r\n            if (this.originalScene.activeCameras && this.originalScene.activeCameras.length > 1) {\r\n                activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];\r\n            } else {\r\n                activeCam = <Camera>this.originalScene.activeCamera!;\r\n            }\r\n\r\n            if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {\r\n                return activeCam.rigParent!;\r\n            }\r\n            return activeCam;\r\n        }\r\n    }\r\n    /**\r\n     * Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)\r\n     * @param cam the camera that should be used when rendering the utility layer\r\n     */\r\n    public setRenderCamera(cam: Nullable<Camera>) {\r\n        this._renderCamera = cam;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Light which used by gizmos to get light shading\r\n     */\r\n    public _getSharedGizmoLight(): HemisphericLight {\r\n        if (!this._sharedGizmoLight) {\r\n            this._sharedGizmoLight = new HemisphericLight(\"shared gizmo light\", new Vector3(0, 1, 0), this.utilityLayerScene);\r\n            this._sharedGizmoLight.intensity = 2;\r\n            this._sharedGizmoLight.groundColor = Color3.Gray();\r\n        }\r\n        return this._sharedGizmoLight;\r\n    }\r\n\r\n    /**\r\n     * If the picking should be done on the utility layer prior to the actual scene (Default: true)\r\n     */\r\n    public pickUtilitySceneFirst = true;\r\n    /**\r\n     * A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)\r\n     */\r\n    public static get DefaultUtilityLayer(): UtilityLayerRenderer {\r\n        if (UtilityLayerRenderer._DefaultUtilityLayer == null) {\r\n            return UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene(EngineStore.LastCreatedScene!);\r\n        }\r\n\r\n        return UtilityLayerRenderer._DefaultUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * Creates an utility layer, and set it as a default utility layer\r\n     * @param scene associated scene\r\n     * @internal\r\n     */\r\n    public static _CreateDefaultUtilityLayerFromScene(scene: Scene): UtilityLayerRenderer {\r\n        UtilityLayerRenderer._DefaultUtilityLayer = new UtilityLayerRenderer(scene);\r\n        UtilityLayerRenderer._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\r\n            UtilityLayerRenderer._DefaultUtilityLayer = null;\r\n        });\r\n\r\n        return UtilityLayerRenderer._DefaultUtilityLayer;\r\n    }\r\n    /**\r\n     * A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)\r\n     */\r\n    public static get DefaultKeepDepthUtilityLayer(): UtilityLayerRenderer {\r\n        if (UtilityLayerRenderer._DefaultKeepDepthUtilityLayer == null) {\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = new UtilityLayerRenderer(EngineStore.LastCreatedScene!);\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\r\n                UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;\r\n            });\r\n        }\r\n        return UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * The scene that is rendered on top of the original scene\r\n     */\r\n    public utilityLayerScene: Scene;\r\n\r\n    /**\r\n     *  If the utility layer should automatically be rendered on top of existing scene\r\n     */\r\n    public shouldRender: boolean = true;\r\n    /**\r\n     * If set to true, only pointer down onPointerObservable events will be blocked when picking is occluded by original scene\r\n     */\r\n    public onlyCheckPointerDownEvents = true;\r\n\r\n    /**\r\n     * If set to false, only pointerUp, pointerDown and pointerMove will be sent to the utilityLayerScene (false by default)\r\n     */\r\n    public processAllEvents = false;\r\n\r\n    /**\r\n     * Set to false to disable picking\r\n     */\r\n    public pickingEnabled = true;\r\n\r\n    /**\r\n     * Observable raised when the pointer moves from the utility layer scene to the main scene\r\n     */\r\n    public onPointerOutObservable = new Observable<number>();\r\n\r\n    /** Gets or sets a predicate that will be used to indicate utility meshes present in the main scene */\r\n    public mainSceneTrackerPredicate: (mesh: Nullable<AbstractMesh>) => boolean;\r\n\r\n    private _afterRenderObserver: Nullable<Observer<Camera>>;\r\n    private _sceneDisposeObserver: Nullable<Observer<Scene>>;\r\n    private _originalPointerObserver: Nullable<Observer<PointerInfoPre>>;\r\n    /**\r\n     * Instantiates a UtilityLayerRenderer\r\n     * @param originalScene the original scene that will be rendered on top of\r\n     * @param handleEvents boolean indicating if the utility layer should handle events\r\n     */\r\n    constructor(\r\n        /** the original scene that will be rendered on top of */\r\n        public originalScene: Scene,\r\n        handleEvents: boolean = true\r\n    ) {\r\n        // Create scene which will be rendered in the foreground and remove it from being referenced by engine to avoid interfering with existing app\r\n        this.utilityLayerScene = new Scene(originalScene.getEngine(), { virtual: true });\r\n        this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;\r\n        this.utilityLayerScene._allowPostProcessClearColor = false;\r\n\r\n        // Deactivate post processes\r\n        this.utilityLayerScene.postProcessesEnabled = false;\r\n\r\n        // Detach controls on utility scene, events will be fired by logic below to handle picking priority\r\n        this.utilityLayerScene.detachControl();\r\n\r\n        if (handleEvents) {\r\n            this._originalPointerObserver = originalScene.onPrePointerObservable.add((prePointerInfo) => {\r\n                if (!this.utilityLayerScene.activeCamera) {\r\n                    return;\r\n                }\r\n                if (!this.pickingEnabled) {\r\n                    return;\r\n                }\r\n\r\n                if (!this.processAllEvents) {\r\n                    if (\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERMOVE &&\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERUP &&\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERDOWN &&\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERDOUBLETAP\r\n                    ) {\r\n                        return;\r\n                    }\r\n                }\r\n                this.utilityLayerScene.pointerX = originalScene.pointerX;\r\n                this.utilityLayerScene.pointerY = originalScene.pointerY;\r\n                const pointerEvent = <IPointerEvent>prePointerInfo.event;\r\n                if (originalScene!.isPointerCaptured(pointerEvent.pointerId)) {\r\n                    this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                    return;\r\n                }\r\n\r\n                const getNearPickDataForScene = (scene: Scene) => {\r\n                    let scenePick = null;\r\n\r\n                    if (prePointerInfo.nearInteractionPickingInfo) {\r\n                        if (prePointerInfo.nearInteractionPickingInfo.pickedMesh!.getScene() == scene) {\r\n                            scenePick = prePointerInfo.nearInteractionPickingInfo;\r\n                        } else {\r\n                            scenePick = new PickingInfo();\r\n                        }\r\n                    } else if (scene !== this.utilityLayerScene && prePointerInfo.originalPickingInfo) {\r\n                        scenePick = prePointerInfo.originalPickingInfo;\r\n                    } else {\r\n                        let previousActiveCamera: Nullable<Camera> = null;\r\n                        // If a camera is set for rendering with this layer\r\n                        // it will also be used for the ray computation\r\n                        // To preserve back compat and because scene.pick always use activeCamera\r\n                        // it's substituted temporarily and a new scenePick is forced.\r\n                        // otherwise, the ray with previously active camera is always used.\r\n                        // It's set back to previous activeCamera after operation.\r\n                        if (this._renderCamera) {\r\n                            previousActiveCamera = scene._activeCamera;\r\n                            scene._activeCamera = this._renderCamera;\r\n                            prePointerInfo.ray = null;\r\n                        }\r\n                        scenePick = prePointerInfo.ray ? scene.pickWithRay(prePointerInfo.ray) : scene.pick(originalScene.pointerX, originalScene.pointerY);\r\n                        if (previousActiveCamera) {\r\n                            scene._activeCamera = previousActiveCamera;\r\n                        }\r\n                    }\r\n\r\n                    return scenePick;\r\n                };\r\n\r\n                const utilityScenePick = getNearPickDataForScene(this.utilityLayerScene);\r\n\r\n                if (!prePointerInfo.ray && utilityScenePick) {\r\n                    prePointerInfo.ray = utilityScenePick.ray;\r\n                }\r\n\r\n                // always fire the prepointer observable\r\n                this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo);\r\n\r\n                // allow every non pointer down event to flow to the utility layer\r\n                if (this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {\r\n                    if (!prePointerInfo.skipOnPointerObservable) {\r\n                        this.utilityLayerScene.onPointerObservable.notifyObservers(\r\n                            new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick),\r\n                            prePointerInfo.type\r\n                        );\r\n                    }\r\n                    if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\r\n                        this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                if (this.utilityLayerScene.autoClearDepthAndStencil || this.pickUtilitySceneFirst) {\r\n                    // If this layer is an overlay, check if this layer was hit and if so, skip pointer events for the main scene\r\n                    if (utilityScenePick && utilityScenePick.hit) {\r\n                        if (!prePointerInfo.skipOnPointerObservable) {\r\n                            this.utilityLayerScene.onPointerObservable.notifyObservers(\r\n                                new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick),\r\n                                prePointerInfo.type\r\n                            );\r\n                        }\r\n                        prePointerInfo.skipOnPointerObservable = true;\r\n                    }\r\n                } else {\r\n                    const originalScenePick = getNearPickDataForScene(originalScene);\r\n                    const pointerEvent = <IPointerEvent>prePointerInfo.event;\r\n\r\n                    // If the layer can be occluded by the original scene, only fire pointer events to the first layer that hit they ray\r\n                    if (originalScenePick && utilityScenePick) {\r\n                        // No pick in utility scene\r\n                        if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {\r\n                            if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\r\n                                // We touched an utility mesh present in the main scene\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                                prePointerInfo.skipOnPointerObservable = true;\r\n                            } else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                                this._pointerCaptures[pointerEvent.pointerId] = true;\r\n                            } else if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                                if (this._lastPointerEvents[pointerEvent.pointerId]) {\r\n                                    // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\r\n                                    this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\r\n                                    delete this._lastPointerEvents[pointerEvent.pointerId];\r\n                                }\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                            }\r\n                        } else if (!this._pointerCaptures[pointerEvent.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {\r\n                            // We pick something in utility scene or the pick in utility is closer than the one in main scene\r\n                            this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\r\n                            // If a previous utility layer set this, do not unset this\r\n                            if (!prePointerInfo.skipOnPointerObservable) {\r\n                                prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;\r\n                            }\r\n                        } else if (!this._pointerCaptures[pointerEvent.pointerId] && utilityScenePick.distance >= originalScenePick.distance) {\r\n                            // We have a pick in both scenes but main is closer than utility\r\n\r\n                            // We touched an utility mesh present in the main scene\r\n                            if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                                prePointerInfo.skipOnPointerObservable = true;\r\n                            } else {\r\n                                if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                                    if (this._lastPointerEvents[pointerEvent.pointerId]) {\r\n                                        // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\r\n                                        this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\r\n                                        delete this._lastPointerEvents[pointerEvent.pointerId];\r\n                                    }\r\n                                }\r\n                                this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\r\n                            }\r\n                        }\r\n\r\n                        if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\r\n                            this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n\r\n            // As a newly added utility layer will be rendered over the screen last, it's pointer events should be processed first\r\n            if (this._originalPointerObserver) {\r\n                originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);\r\n            }\r\n        }\r\n\r\n        // Render directly on top of existing scene without clearing\r\n        this.utilityLayerScene.autoClear = false;\r\n\r\n        this._afterRenderObserver = this.originalScene.onAfterRenderCameraObservable.add((camera) => {\r\n            // Only render when the render camera finishes rendering\r\n            if (this.shouldRender && camera == this.getRenderCamera()) {\r\n                this.render();\r\n            }\r\n        });\r\n\r\n        this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(() => {\r\n            this.dispose();\r\n        });\r\n\r\n        this._updateCamera();\r\n    }\r\n\r\n    private _notifyObservers(prePointerInfo: PointerInfoPre, pickInfo: PickingInfo, pointerEvent: IPointerEvent) {\r\n        if (!prePointerInfo.skipOnPointerObservable) {\r\n            this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo), prePointerInfo.type);\r\n            this._lastPointerEvents[pointerEvent.pointerId] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders the utility layers scene on top of the original scene\r\n     */\r\n    public render() {\r\n        this._updateCamera();\r\n        if (this.utilityLayerScene.activeCamera) {\r\n            // Set the camera's scene to utility layers scene\r\n            const oldScene = this.utilityLayerScene.activeCamera.getScene();\r\n            const camera = this.utilityLayerScene.activeCamera;\r\n            camera._scene = this.utilityLayerScene;\r\n            if (camera.leftCamera) {\r\n                camera.leftCamera._scene = this.utilityLayerScene;\r\n            }\r\n            if (camera.rightCamera) {\r\n                camera.rightCamera._scene = this.utilityLayerScene;\r\n            }\r\n\r\n            this.utilityLayerScene.render(false);\r\n\r\n            // Reset camera's scene back to original\r\n            camera._scene = oldScene;\r\n            if (camera.leftCamera) {\r\n                camera.leftCamera._scene = oldScene;\r\n            }\r\n            if (camera.rightCamera) {\r\n                camera.rightCamera._scene = oldScene;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the renderer\r\n     */\r\n    public dispose() {\r\n        this.onPointerOutObservable.clear();\r\n\r\n        if (this._afterRenderObserver) {\r\n            this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);\r\n        }\r\n        if (this._sceneDisposeObserver) {\r\n            this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);\r\n        }\r\n        if (this._originalPointerObserver) {\r\n            this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);\r\n        }\r\n        this.utilityLayerScene.dispose();\r\n    }\r\n\r\n    private _updateCamera() {\r\n        this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();\r\n        this.utilityLayerScene.activeCamera = this.getRenderCamera();\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}