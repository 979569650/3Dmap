{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { CreateBox } from \"../Meshes/Builders/boxBuilder.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { Matrix, Quaternion, TmpVectors, Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { PhysicsImpostor } from \"../Physics/v1/physicsImpostor.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder.js\";\nimport { CreateCapsule } from \"../Meshes/Builders/capsuleBuilder.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\nimport { MeshBuilder } from \"../Meshes/meshBuilder.js\";\nimport { AxesViewer } from \"./axesViewer.js\";\nimport { TransformNode } from \"../Meshes/transformNode.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\n/**\n * Used to show the physics impostor around the specific mesh\n */\nexport class PhysicsViewer {\n  /**\n   * Creates a new PhysicsViewer\n   * @param scene defines the hosting scene\n   */\n  constructor(scene) {\n    /** @internal */\n    this._impostors = [];\n    /** @internal */\n    this._meshes = [];\n    /** @internal */\n    this._bodies = [];\n    /** @internal */\n    this._inertiaBodies = [];\n    /** @internal */\n    this._constraints = [];\n    /** @internal */\n    this._bodyMeshes = [];\n    /** @internal */\n    this._inertiaMeshes = [];\n    /** @internal */\n    this._constraintMeshes = [];\n    /** @internal */\n    this._numMeshes = 0;\n    /** @internal */\n    this._numBodies = 0;\n    /** @internal */\n    this._numInertiaBodies = 0;\n    /** @internal */\n    this._numConstraints = 0;\n    this._debugMeshMeshes = new Array();\n    this._constraintAxesSize = 0.4;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    if (!this._scene) {\n      return;\n    }\n    const physicEngine = this._scene.getPhysicsEngine();\n    if (physicEngine) {\n      this._physicsEnginePlugin = physicEngine.getPhysicsPlugin();\n    }\n    this._utilityLayer = new UtilityLayerRenderer(this._scene, false);\n    this._utilityLayer.pickUtilitySceneFirst = false;\n    this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = true;\n  }\n  /**\n   * Updates the debug meshes of the physics engine.\n   *\n   * This code is useful for synchronizing the debug meshes of the physics engine with the physics impostor and mesh.\n   * It checks if the impostor is disposed and if the plugin version is 1, then it syncs the mesh with the impostor.\n   * This ensures that the debug meshes are up to date with the physics engine.\n   */\n  _updateDebugMeshes() {\n    const plugin = this._physicsEnginePlugin;\n    if ((plugin === null || plugin === void 0 ? void 0 : plugin.getPluginVersion()) === 1) {\n      this._updateDebugMeshesV1();\n    } else {\n      this._updateDebugMeshesV2();\n    }\n  }\n  /**\n   * Updates the debug meshes of the physics engine.\n   *\n   * This method is useful for synchronizing the debug meshes with the physics impostors.\n   * It iterates through the impostors and meshes, and if the plugin version is 1, it syncs the mesh with the impostor.\n   * This ensures that the debug meshes accurately reflect the physics impostors, which is important for debugging the physics engine.\n   */\n  _updateDebugMeshesV1() {\n    const plugin = this._physicsEnginePlugin;\n    for (let i = 0; i < this._numMeshes; i++) {\n      const impostor = this._impostors[i];\n      if (!impostor) {\n        continue;\n      }\n      if (impostor.isDisposed) {\n        this.hideImpostor(this._impostors[i--]);\n      } else {\n        if (impostor.type === PhysicsImpostor.MeshImpostor) {\n          continue;\n        }\n        const mesh = this._meshes[i];\n        if (mesh && plugin) {\n          plugin.syncMeshWithImpostor(mesh, impostor);\n        }\n      }\n    }\n  }\n  /**\n   * Updates the debug meshes of the physics engine for V2 plugin.\n   *\n   * This method is useful for synchronizing the debug meshes of the physics engine with the current state of the bodies.\n   * It iterates through the bodies array and updates the debug meshes with the current transform of each body.\n   * This ensures that the debug meshes accurately reflect the current state of the physics engine.\n   */\n  _updateDebugMeshesV2() {\n    const plugin = this._physicsEnginePlugin;\n    for (let i = 0; i < this._numBodies; i++) {\n      const body = this._bodies[i];\n      const transform = this._bodyMeshes[i];\n      if (body && transform) {\n        plugin.syncTransform(body, transform);\n      }\n    }\n  }\n  _updateInertiaMeshes() {\n    for (let i = 0; i < this._numInertiaBodies; i++) {\n      const body = this._inertiaBodies[i];\n      const mesh = this._inertiaMeshes[i];\n      if (body && mesh) {\n        this._updateDebugInertia(body, mesh);\n      }\n    }\n  }\n  _updateDebugInertia(body, inertiaMesh) {\n    var _a;\n    const inertiaMatrixRef = Matrix.Identity();\n    const transformMatrixRef = Matrix.Identity();\n    const finalMatrixRef = Matrix.Identity();\n    if (body._pluginDataInstances.length) {\n      const inertiaAsMesh = inertiaMesh;\n      const inertiaMeshMatrixData = inertiaAsMesh._thinInstanceDataStorage.matrixData;\n      const bodyTransformMatrixData = body.transformNode._thinInstanceDataStorage.matrixData;\n      for (let i = 0; i < body._pluginDataInstances.length; i++) {\n        const props = body.getMassProperties(i);\n        this._getMeshDebugInertiaMatrixToRef(props, inertiaMatrixRef);\n        Matrix.FromArrayToRef(bodyTransformMatrixData, i * 16, transformMatrixRef);\n        inertiaMatrixRef.multiplyToRef(transformMatrixRef, finalMatrixRef);\n        finalMatrixRef.copyToArray(inertiaMeshMatrixData, i * 16);\n      }\n      inertiaAsMesh.thinInstanceBufferUpdated(\"matrix\");\n    } else {\n      const props = body.getMassProperties();\n      this._getMeshDebugInertiaMatrixToRef(props, inertiaMatrixRef);\n      (_a = body.transformNode.rotationQuaternion) === null || _a === void 0 ? void 0 : _a.toRotationMatrix(transformMatrixRef);\n      transformMatrixRef.setTranslation(body.transformNode.position);\n      if (body.transformNode.parent) {\n        const parentTransform = body.transformNode.parent.computeWorldMatrix(true);\n        transformMatrixRef.multiplyToRef(parentTransform, transformMatrixRef);\n      }\n      inertiaMatrixRef.multiplyToRef(transformMatrixRef, inertiaMatrixRef);\n      inertiaMatrixRef.decomposeToTransformNode(inertiaMesh);\n    }\n  }\n  _updateDebugConstraints() {\n    for (let i = 0; i < this._numConstraints; i++) {\n      const constraint = this._constraints[i];\n      const mesh = this._constraintMeshes[i];\n      if (constraint && mesh) {\n        this._updateDebugConstraint(constraint, mesh);\n      }\n    }\n  }\n  /**\n   * Given a scaling vector, make all of its components\n   * 1, preserving the sign\n   * @param scaling\n   */\n  _makeScalingUnitInPlace(scaling) {\n    if (Math.abs(scaling.x - 1) > Epsilon) {\n      scaling.x = 1 * Math.sign(scaling.x);\n    }\n    if (Math.abs(scaling.y - 1) > Epsilon) {\n      scaling.y = 1 * Math.sign(scaling.y);\n    }\n    if (Math.abs(scaling.z - 1) > Epsilon) {\n      scaling.z = 1 * Math.sign(scaling.z);\n    }\n  }\n  _updateDebugConstraint(constraint, parentingMesh) {\n    if (!constraint._initOptions) {\n      return;\n    }\n    // Get constraint pivot and axes\n    const {\n      pivotA,\n      pivotB,\n      axisA,\n      axisB,\n      perpAxisA,\n      perpAxisB\n    } = constraint._initOptions;\n    if (!pivotA || !pivotB || !axisA || !axisB || !perpAxisA || !perpAxisB) {\n      return;\n    }\n    parentingMesh.getDescendants(true).forEach(parentConstraintMesh => {\n      // Get the parent transform\n      const parentCoordSystemNode = parentConstraintMesh.getDescendants(true)[0];\n      const childCoordSystemNode = parentConstraintMesh.getDescendants(true)[1];\n      const {\n        parentBody,\n        parentBodyIndex\n      } = parentCoordSystemNode.metadata;\n      const {\n        childBody,\n        childBodyIndex\n      } = childCoordSystemNode.metadata;\n      const parentTransform = this._getTransformFromBodyToRef(parentBody, TmpVectors.Matrix[0], parentBodyIndex);\n      const childTransform = this._getTransformFromBodyToRef(childBody, TmpVectors.Matrix[1], childBodyIndex);\n      parentTransform.decomposeToTransformNode(parentCoordSystemNode);\n      this._makeScalingUnitInPlace(parentCoordSystemNode.scaling);\n      childTransform.decomposeToTransformNode(childCoordSystemNode);\n      this._makeScalingUnitInPlace(childCoordSystemNode.scaling);\n      // Create a transform node and set its matrix\n      const parentTransformNode = parentCoordSystemNode.getDescendants(true)[0];\n      parentTransformNode.position.copyFrom(pivotA);\n      const childTransformNode = childCoordSystemNode.getDescendants(true)[0];\n      childTransformNode.position.copyFrom(pivotB);\n      // Get the transform to align the XYZ axes to the constraint axes\n      Quaternion.FromRotationMatrixToRef(Matrix.FromXYZAxesToRef(axisA, perpAxisA, Vector3.CrossToRef(axisA, perpAxisA, TmpVectors.Vector3[0]), TmpVectors.Matrix[0]), parentTransformNode.rotationQuaternion);\n      Quaternion.FromRotationMatrixToRef(Matrix.FromXYZAxesToRef(axisB, perpAxisB, Vector3.CrossToRef(axisB, perpAxisB, TmpVectors.Vector3[1]), TmpVectors.Matrix[1]), childTransformNode.rotationQuaternion);\n    });\n  }\n  /**\n   * Renders a specified physic impostor\n   * @param impostor defines the impostor to render\n   * @param targetMesh defines the mesh represented by the impostor\n   * @returns the new debug mesh used to render the impostor\n   */\n  showImpostor(impostor, targetMesh) {\n    if (!this._scene) {\n      return null;\n    }\n    for (let i = 0; i < this._numMeshes; i++) {\n      if (this._impostors[i] == impostor) {\n        return null;\n      }\n    }\n    const debugMesh = this._getDebugMesh(impostor, targetMesh);\n    if (debugMesh) {\n      this._impostors[this._numMeshes] = impostor;\n      this._meshes[this._numMeshes] = debugMesh;\n      if (this._numMeshes === 0) {\n        this._renderFunction = () => this._updateDebugMeshes();\n        this._scene.registerBeforeRender(this._renderFunction);\n      }\n      this._numMeshes++;\n    }\n    return debugMesh;\n  }\n  /**\n   * Shows a debug mesh for a given physics body.\n   * @param body The physics body to show.\n   * @returns The debug mesh, or null if the body is already shown.\n   *\n   * This function is useful for visualizing the physics body in the scene.\n   * It creates a debug mesh for the given body and adds it to the scene.\n   * It also registers a before render function to update the debug mesh position and rotation.\n   */\n  showBody(body) {\n    if (!this._scene) {\n      return null;\n    }\n    for (let i = 0; i < this._numBodies; i++) {\n      if (this._bodies[i] == body) {\n        return null;\n      }\n    }\n    const debugMesh = this._getDebugBodyMesh(body);\n    if (debugMesh) {\n      this._bodies[this._numBodies] = body;\n      this._bodyMeshes[this._numBodies] = debugMesh;\n      if (this._numBodies === 0) {\n        this._renderFunction = () => this._updateDebugMeshes();\n        this._scene.registerBeforeRender(this._renderFunction);\n      }\n      this._numBodies++;\n    }\n    return debugMesh;\n  }\n  /**\n   * Shows a debug box corresponding to the inertia of a given body\n   * @param body\n   */\n  showInertia(body) {\n    if (!this._scene) {\n      return null;\n    }\n    for (let i = 0; i < this._numInertiaBodies; i++) {\n      if (this._inertiaBodies[i] == body) {\n        return null;\n      }\n    }\n    const debugMesh = this._getDebugInertiaMesh(body);\n    if (debugMesh) {\n      this._inertiaBodies[this._numInertiaBodies] = body;\n      this._inertiaMeshes[this._numInertiaBodies] = debugMesh;\n      if (this._numInertiaBodies === 0) {\n        this._inertiaRenderFunction = () => this._updateInertiaMeshes();\n        this._scene.registerBeforeRender(this._inertiaRenderFunction);\n      }\n      this._numInertiaBodies++;\n    }\n    return debugMesh;\n  }\n  /**\n   * Shows a debug mesh for a given physics constraint.\n   * @param constraint the physics constraint to show\n   * @returns the debug mesh, or null if the constraint is already shown\n   */\n  showConstraint(constraint) {\n    if (!this._scene) {\n      return null;\n    }\n    for (let i = 0; i < this._numConstraints; i++) {\n      if (this._constraints[i] == constraint) {\n        return null;\n      }\n    }\n    const debugMesh = this._getDebugConstraintMesh(constraint);\n    if (debugMesh) {\n      this._constraints[this._numConstraints] = constraint;\n      this._constraintMeshes[this._numConstraints] = debugMesh;\n      if (this._numConstraints === 0) {\n        this._constraintRenderFunction = () => this._updateDebugConstraints();\n        this._scene.registerBeforeRender(this._constraintRenderFunction);\n      }\n      this._numConstraints++;\n    }\n    return debugMesh;\n  }\n  /**\n   * Hides an impostor from the scene.\n   * @param impostor - The impostor to hide.\n   *\n   * This method is useful for hiding an impostor from the scene. It removes the\n   * impostor from the utility layer scene, disposes the mesh, and removes the\n   * impostor from the list of impostors. If the impostor is the last one in the\n   * list, it also unregisters the render function.\n   */\n  hideImpostor(impostor) {\n    if (!impostor || !this._scene || !this._utilityLayer) {\n      return;\n    }\n    let removed = false;\n    const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n    for (let i = 0; i < this._numMeshes; i++) {\n      if (this._impostors[i] == impostor) {\n        const mesh = this._meshes[i];\n        if (!mesh) {\n          continue;\n        }\n        utilityLayerScene.removeMesh(mesh);\n        mesh.dispose();\n        const index = this._debugMeshMeshes.indexOf(mesh);\n        if (index > -1) {\n          this._debugMeshMeshes.splice(index, 1);\n        }\n        this._numMeshes--;\n        if (this._numMeshes > 0) {\n          this._meshes[i] = this._meshes[this._numMeshes];\n          this._impostors[i] = this._impostors[this._numMeshes];\n          this._meshes[this._numMeshes] = null;\n          this._impostors[this._numMeshes] = null;\n        } else {\n          this._meshes[0] = null;\n          this._impostors[0] = null;\n        }\n        removed = true;\n        break;\n      }\n    }\n    if (removed && this._numMeshes === 0) {\n      this._scene.unregisterBeforeRender(this._renderFunction);\n    }\n  }\n  /**\n   * Hides a body from the physics engine.\n   * @param body - The body to hide.\n   *\n   * This function is useful for hiding a body from the physics engine.\n   * It removes the body from the utility layer scene and disposes the mesh associated with it.\n   * It also unregisters the render function if the number of bodies is 0.\n   * This is useful for hiding a body from the physics engine without deleting it.\n   */\n  hideBody(body) {\n    if (!body || !this._scene || !this._utilityLayer) {\n      return;\n    }\n    let removed = false;\n    const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n    for (let i = 0; i < this._numBodies; i++) {\n      if (this._bodies[i] === body) {\n        const mesh = this._bodyMeshes[i];\n        if (!mesh) {\n          continue;\n        }\n        utilityLayerScene.removeMesh(mesh);\n        mesh.dispose();\n        this._numBodies--;\n        if (this._numBodies > 0) {\n          this._bodyMeshes[i] = this._bodyMeshes[this._numBodies];\n          this._bodies[i] = this._bodies[this._numBodies];\n          this._bodyMeshes[this._numBodies] = null;\n          this._bodies[this._numBodies] = null;\n        } else {\n          this._bodyMeshes[0] = null;\n          this._bodies[0] = null;\n        }\n        removed = true;\n        break;\n      }\n    }\n    if (removed && this._numBodies === 0) {\n      this._scene.unregisterBeforeRender(this._renderFunction);\n    }\n  }\n  hideInertia(body) {\n    if (!body || !this._scene || !this._utilityLayer) {\n      return;\n    }\n    let removed = false;\n    const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n    for (let i = 0; i < this._numInertiaBodies; i++) {\n      if (this._inertiaBodies[i] === body) {\n        const mesh = this._inertiaMeshes[i];\n        if (!mesh) {\n          continue;\n        }\n        utilityLayerScene.removeMesh(mesh);\n        mesh.dispose();\n        this._inertiaBodies.splice(i, 1);\n        this._inertiaMeshes.splice(i, 1);\n        this._numInertiaBodies--;\n        removed = true;\n        break;\n      }\n    }\n    if (removed && this._numInertiaBodies === 0) {\n      this._scene.unregisterBeforeRender(this._inertiaRenderFunction);\n    }\n  }\n  /**\n   * Hide a physics constraint from the viewer utility layer\n   * @param constraint the constraint to hide\n   */\n  hideConstraint(constraint) {\n    if (!constraint || !this._scene || !this._utilityLayer) {\n      return;\n    }\n    let removed = false;\n    const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n    for (let i = 0; i < this._numConstraints; i++) {\n      if (this._constraints[i] === constraint) {\n        const mesh = this._constraintMeshes[i];\n        if (!mesh) {\n          continue;\n        }\n        utilityLayerScene.removeMesh(mesh);\n        mesh.dispose();\n        this._constraints.splice(i, 1);\n        this._constraintMeshes.splice(i, 1);\n        this._numConstraints--;\n        if (this._numConstraints > 0) {\n          this._constraints[i] = this._constraints[this._numConstraints];\n          this._constraintMeshes[i] = this._constraintMeshes[this._numConstraints];\n          this._constraints[this._numConstraints] = null;\n          this._constraintMeshes[this._numConstraints] = null;\n        } else {\n          this._constraints[0] = null;\n          this._constraintMeshes[0] = null;\n        }\n        removed = true;\n        break;\n      }\n    }\n    if (removed && this._numConstraints === 0) {\n      this._scene.unregisterBeforeRender(this._constraintRenderFunction);\n    }\n  }\n  _getDebugMaterial(scene) {\n    if (!this._debugMaterial) {\n      this._debugMaterial = new StandardMaterial(\"\", scene);\n      this._debugMaterial.wireframe = true;\n      this._debugMaterial.emissiveColor = Color3.White();\n      this._debugMaterial.disableLighting = true;\n    }\n    return this._debugMaterial;\n  }\n  _getDebugInertiaMaterial(scene) {\n    if (!this._debugInertiaMaterial) {\n      this._debugInertiaMaterial = new StandardMaterial(\"\", scene);\n      this._debugInertiaMaterial.disableLighting = true;\n      this._debugInertiaMaterial.alpha = 0.0;\n    }\n    return this._debugInertiaMaterial;\n  }\n  _getDebugBoxMesh(scene) {\n    if (!this._debugBoxMesh) {\n      this._debugBoxMesh = CreateBox(\"physicsBodyBoxViewMesh\", {\n        size: 1\n      }, scene);\n      this._debugBoxMesh.rotationQuaternion = Quaternion.Identity();\n      this._debugBoxMesh.material = this._getDebugMaterial(scene);\n      this._debugBoxMesh.setEnabled(false);\n    }\n    return this._debugBoxMesh.createInstance(\"physicsBodyBoxViewInstance\");\n  }\n  _getDebugSphereMesh(scene) {\n    if (!this._debugSphereMesh) {\n      this._debugSphereMesh = CreateSphere(\"physicsBodySphereViewMesh\", {\n        diameter: 1\n      }, scene);\n      this._debugSphereMesh.rotationQuaternion = Quaternion.Identity();\n      this._debugSphereMesh.material = this._getDebugMaterial(scene);\n      this._debugSphereMesh.setEnabled(false);\n    }\n    return this._debugSphereMesh.createInstance(\"physicsBodySphereViewInstance\");\n  }\n  _getDebugCapsuleMesh(scene) {\n    if (!this._debugCapsuleMesh) {\n      this._debugCapsuleMesh = CreateCapsule(\"physicsBodyCapsuleViewMesh\", {\n        height: 1\n      }, scene);\n      this._debugCapsuleMesh.rotationQuaternion = Quaternion.Identity();\n      this._debugCapsuleMesh.material = this._getDebugMaterial(scene);\n      this._debugCapsuleMesh.setEnabled(false);\n    }\n    return this._debugCapsuleMesh.createInstance(\"physicsBodyCapsuleViewInstance\");\n  }\n  _getDebugCylinderMesh(scene) {\n    if (!this._debugCylinderMesh) {\n      this._debugCylinderMesh = CreateCylinder(\"physicsBodyCylinderViewMesh\", {\n        diameterTop: 1,\n        diameterBottom: 1,\n        height: 1\n      }, scene);\n      this._debugCylinderMesh.rotationQuaternion = Quaternion.Identity();\n      this._debugCylinderMesh.material = this._getDebugMaterial(scene);\n      this._debugCylinderMesh.setEnabled(false);\n    }\n    return this._debugCylinderMesh.createInstance(\"physicsBodyCylinderViewInstance\");\n  }\n  _getDebugMeshMesh(mesh, scene) {\n    const wireframeOver = new Mesh(mesh.name, scene, null, mesh);\n    wireframeOver.setParent(mesh);\n    wireframeOver.position = Vector3.Zero();\n    wireframeOver.material = this._getDebugMaterial(scene);\n    this._debugMeshMeshes.push(wireframeOver);\n    return wireframeOver;\n  }\n  _getDebugMesh(impostor, targetMesh) {\n    if (!this._utilityLayer) {\n      return null;\n    }\n    // Only create child impostor debug meshes when evaluating the parent\n    if (targetMesh && targetMesh.parent && targetMesh.parent.physicsImpostor) {\n      return null;\n    }\n    let mesh = null;\n    const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n    if (!impostor.physicsBody) {\n      Logger.Warn(\"Unable to get physicsBody of impostor. It might be initialized later by its parent's impostor.\");\n      return null;\n    }\n    switch (impostor.type) {\n      case PhysicsImpostor.BoxImpostor:\n        mesh = this._getDebugBoxMesh(utilityLayerScene);\n        impostor.getBoxSizeToRef(mesh.scaling);\n        break;\n      case PhysicsImpostor.SphereImpostor:\n        {\n          mesh = this._getDebugSphereMesh(utilityLayerScene);\n          const radius = impostor.getRadius();\n          mesh.scaling.x = radius * 2;\n          mesh.scaling.y = radius * 2;\n          mesh.scaling.z = radius * 2;\n          break;\n        }\n      case PhysicsImpostor.CapsuleImpostor:\n        {\n          mesh = this._getDebugCapsuleMesh(utilityLayerScene);\n          const bi = impostor.object.getBoundingInfo();\n          mesh.scaling.x = (bi.boundingBox.maximum.x - bi.boundingBox.minimum.x) * 2 * impostor.object.scaling.x;\n          mesh.scaling.y = (bi.boundingBox.maximum.y - bi.boundingBox.minimum.y) * impostor.object.scaling.y;\n          mesh.scaling.z = (bi.boundingBox.maximum.z - bi.boundingBox.minimum.z) * 2 * impostor.object.scaling.z;\n          break;\n        }\n      case PhysicsImpostor.MeshImpostor:\n        if (targetMesh) {\n          mesh = this._getDebugMeshMesh(targetMesh, utilityLayerScene);\n        }\n        break;\n      case PhysicsImpostor.NoImpostor:\n        if (targetMesh) {\n          // Handle compound impostors\n          const childMeshes = targetMesh.getChildMeshes().filter(c => {\n            return c.physicsImpostor ? 1 : 0;\n          });\n          childMeshes.forEach(m => {\n            if (m.physicsImpostor && m.getClassName() === \"Mesh\") {\n              const boundingInfo = m.getBoundingInfo();\n              const min = boundingInfo.boundingBox.minimum;\n              const max = boundingInfo.boundingBox.maximum;\n              switch (m.physicsImpostor.type) {\n                case PhysicsImpostor.BoxImpostor:\n                  mesh = this._getDebugBoxMesh(utilityLayerScene);\n                  mesh.position.copyFrom(min);\n                  mesh.position.addInPlace(max);\n                  mesh.position.scaleInPlace(0.5);\n                  break;\n                case PhysicsImpostor.SphereImpostor:\n                  mesh = this._getDebugSphereMesh(utilityLayerScene);\n                  break;\n                case PhysicsImpostor.CylinderImpostor:\n                  mesh = this._getDebugCylinderMesh(utilityLayerScene);\n                  break;\n                default:\n                  mesh = null;\n                  break;\n              }\n              if (mesh) {\n                mesh.scaling.x = max.x - min.x;\n                mesh.scaling.y = max.y - min.y;\n                mesh.scaling.z = max.z - min.z;\n                mesh.parent = m;\n              }\n            }\n          });\n        } else {\n          Logger.Warn(\"No target mesh parameter provided for NoImpostor. Skipping.\");\n        }\n        mesh = null;\n        break;\n      case PhysicsImpostor.CylinderImpostor:\n        {\n          mesh = this._getDebugCylinderMesh(utilityLayerScene);\n          const bi = impostor.object.getBoundingInfo();\n          mesh.scaling.x = (bi.boundingBox.maximum.x - bi.boundingBox.minimum.x) * impostor.object.scaling.x;\n          mesh.scaling.y = (bi.boundingBox.maximum.y - bi.boundingBox.minimum.y) * impostor.object.scaling.y;\n          mesh.scaling.z = (bi.boundingBox.maximum.z - bi.boundingBox.minimum.z) * impostor.object.scaling.z;\n          break;\n        }\n    }\n    return mesh;\n  }\n  /**\n   * Creates a debug mesh for a given physics body\n   * @param body The physics body to create the debug mesh for\n   * @returns The created debug mesh or null if the utility layer is not available\n   *\n   * This code is useful for creating a debug mesh for a given physics body.\n   * It creates a Mesh object with a VertexData object containing the positions and indices\n   * of the geometry of the body. The mesh is then assigned a debug material from the utility layer scene.\n   * This allows for visualizing the physics body in the scene.\n   */\n  _getDebugBodyMesh(body) {\n    if (!this._utilityLayer) {\n      return null;\n    }\n    const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n    const mesh = new Mesh(\"custom\", utilityLayerScene);\n    const vertexData = new VertexData();\n    const geometry = body.getGeometry();\n    vertexData.positions = geometry.positions;\n    vertexData.indices = geometry.indices;\n    vertexData.applyToMesh(mesh);\n    if (body._pluginDataInstances) {\n      const instanceBuffer = new Float32Array(body._pluginDataInstances.length * 16);\n      mesh.thinInstanceSetBuffer(\"matrix\", instanceBuffer, 16);\n    }\n    mesh.material = this._getDebugMaterial(utilityLayerScene);\n    return mesh;\n  }\n  _getMeshDebugInertiaMatrixToRef(massProps, matrix) {\n    var _a, _b, _c;\n    const orientation = (_a = massProps.inertiaOrientation) !== null && _a !== void 0 ? _a : Quaternion.Identity();\n    const inertiaLocal = (_b = massProps.inertia) !== null && _b !== void 0 ? _b : Vector3.Zero();\n    const center = (_c = massProps.centerOfMass) !== null && _c !== void 0 ? _c : Vector3.Zero();\n    const betaSqrd = (inertiaLocal.x - inertiaLocal.y + inertiaLocal.z) * 6;\n    const beta = Math.sqrt(Math.max(betaSqrd, 0)); // Safety check for zeroed elements!\n    const gammaSqrd = inertiaLocal.x * 12 - betaSqrd;\n    const gamma = Math.sqrt(Math.max(gammaSqrd, 0)); // Safety check for zeroed elements!\n    const alphaSqrd = inertiaLocal.z * 12 - betaSqrd;\n    const alpha = Math.sqrt(Math.max(alphaSqrd, 0)); // Safety check for zeroed elements!\n    const extents = TmpVectors.Vector3[0];\n    extents.set(alpha, beta, gamma);\n    const scaling = Matrix.ScalingToRef(extents.x, extents.y, extents.z, TmpVectors.Matrix[0]);\n    const rotation = orientation.toRotationMatrix(TmpVectors.Matrix[1]);\n    const translation = Matrix.TranslationToRef(center.x, center.y, center.z, TmpVectors.Matrix[2]);\n    scaling.multiplyToRef(rotation, matrix);\n    matrix.multiplyToRef(translation, matrix);\n    return matrix;\n  }\n  _getDebugInertiaMesh(body) {\n    if (!this._utilityLayer) {\n      return null;\n    }\n    const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n    // The base inertia mesh is going to be a 1x1 cube that's scaled and rotated according to the inertia\n    const inertiaBoxMesh = MeshBuilder.CreateBox(\"custom\", {\n      size: 1\n    }, utilityLayerScene);\n    const matrixRef = Matrix.Identity();\n    if (body._pluginDataInstances.length) {\n      const instanceBuffer = new Float32Array(body._pluginDataInstances.length * 16);\n      for (let i = 0; i < body._pluginDataInstances.length; ++i) {\n        const props = body.getMassProperties(i);\n        this._getMeshDebugInertiaMatrixToRef(props, matrixRef);\n        matrixRef.copyToArray(instanceBuffer, i * 16);\n      }\n      inertiaBoxMesh.thinInstanceSetBuffer(\"matrix\", instanceBuffer, 16);\n    } else {\n      const props = body.getMassProperties();\n      this._getMeshDebugInertiaMatrixToRef(props, matrixRef);\n      matrixRef.decomposeToTransformNode(inertiaBoxMesh);\n    }\n    inertiaBoxMesh.enableEdgesRendering();\n    inertiaBoxMesh.edgesWidth = 2.0;\n    inertiaBoxMesh.edgesColor = new Color4(1, 0, 1, 1);\n    inertiaBoxMesh.material = this._getDebugInertiaMaterial(utilityLayerScene);\n    return inertiaBoxMesh;\n  }\n  _getTransformFromBodyToRef(body, matrix, instanceIndex) {\n    const tnode = body.transformNode;\n    if (instanceIndex && instanceIndex >= 0) {\n      return Matrix.FromArrayToRef(tnode._thinInstanceDataStorage.matrixData, instanceIndex, matrix);\n    } else {\n      return matrix.copyFrom(tnode.getWorldMatrix());\n    }\n  }\n  _getDebugConstraintMesh(constraint) {\n    if (!this._utilityLayer) {\n      return null;\n    }\n    const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n    if (!constraint._initOptions) {\n      return null;\n    }\n    // Get constraint pivot and axes\n    const {\n      pivotA,\n      pivotB,\n      axisA,\n      axisB,\n      perpAxisA,\n      perpAxisB\n    } = constraint._initOptions;\n    if (!pivotA || !pivotB || !axisA || !axisB || !perpAxisA || !perpAxisB) {\n      return null;\n    }\n    // Create a mesh to parent all the constraint debug meshes to\n    const parentingMesh = new Mesh(\"parentingDebugConstraint\", utilityLayerScene);\n    // First, get a reference to all physic bodies that are using this constraint\n    const bodiesUsingConstraint = constraint.getBodiesUsingConstraint();\n    for (const bodyPairInfo of bodiesUsingConstraint) {\n      // Create a mesh to keep the pair of constraint axes\n      const parentOfPair = new TransformNode(\"parentOfPair\", utilityLayerScene);\n      parentOfPair.parent = parentingMesh;\n      const {\n        parentBody,\n        parentBodyIndex,\n        childBody,\n        childBodyIndex\n      } = bodyPairInfo;\n      // Get the parent transform\n      const parentTransform = this._getTransformFromBodyToRef(parentBody, TmpVectors.Matrix[0], parentBodyIndex);\n      const childTransform = this._getTransformFromBodyToRef(childBody, TmpVectors.Matrix[1], childBodyIndex);\n      const parentCoordSystemNode = new TransformNode(\"parentCoordSystem\", utilityLayerScene);\n      // parentCoordSystemNode.parent = parentingMesh;\n      parentCoordSystemNode.parent = parentOfPair;\n      // Save parent and index here to be able to get the transform on update\n      parentCoordSystemNode.metadata = {\n        parentBody,\n        parentBodyIndex\n      };\n      parentTransform.decomposeToTransformNode(parentCoordSystemNode);\n      const childCoordSystemNode = new TransformNode(\"childCoordSystem\", utilityLayerScene);\n      // childCoordSystemNode.parent = parentingMesh;\n      childCoordSystemNode.parent = parentOfPair;\n      // Save child and index here to be able to get the transform on update\n      childCoordSystemNode.metadata = {\n        childBody,\n        childBodyIndex\n      };\n      childTransform.decomposeToTransformNode(childCoordSystemNode);\n      // Get the transform to align the XYZ axes to the constraint axes\n      const rotTransformParent = Quaternion.FromRotationMatrix(Matrix.FromXYZAxesToRef(axisA, perpAxisA, axisA.cross(perpAxisA), TmpVectors.Matrix[0]));\n      const rotTransformChild = Quaternion.FromRotationMatrix(Matrix.FromXYZAxesToRef(axisB, perpAxisB, axisB.cross(perpAxisB), TmpVectors.Matrix[0]));\n      const translateTransformParent = pivotA;\n      const translateTransformChild = pivotB;\n      // Create a transform node and set its matrix\n      const parentTransformNode = new TransformNode(\"constraint_parent\", utilityLayerScene);\n      parentTransformNode.position.copyFrom(translateTransformParent);\n      parentTransformNode.rotationQuaternion = rotTransformParent;\n      parentTransformNode.parent = parentCoordSystemNode;\n      const childTransformNode = new TransformNode(\"constraint_child\", utilityLayerScene);\n      childTransformNode.parent = childCoordSystemNode;\n      childTransformNode.position.copyFrom(translateTransformChild);\n      childTransformNode.rotationQuaternion = rotTransformChild;\n      // Create axes for the constraint\n      const parentAxes = new AxesViewer(utilityLayerScene, this._constraintAxesSize);\n      parentAxes.xAxis.parent = parentTransformNode;\n      parentAxes.yAxis.parent = parentTransformNode;\n      parentAxes.zAxis.parent = parentTransformNode;\n      const childAxes = new AxesViewer(utilityLayerScene, this._constraintAxesSize);\n      childAxes.xAxis.parent = childTransformNode;\n      childAxes.yAxis.parent = childTransformNode;\n      childAxes.zAxis.parent = childTransformNode;\n    }\n    return parentingMesh;\n  }\n  /**\n   * Clean up physics debug display\n   */\n  dispose() {\n    // impostors\n    for (let index = this._numMeshes - 1; index >= 0; index--) {\n      this.hideImpostor(this._impostors[0]);\n    }\n    // bodies\n    for (let index = this._numBodies - 1; index >= 0; index--) {\n      this.hideBody(this._bodies[0]);\n    }\n    // inertia\n    for (let index = this._numInertiaBodies - 1; index >= 0; index--) {\n      this.hideInertia(this._inertiaBodies[0]);\n    }\n    if (this._debugBoxMesh) {\n      this._debugBoxMesh.dispose();\n    }\n    if (this._debugSphereMesh) {\n      this._debugSphereMesh.dispose();\n    }\n    if (this._debugCylinderMesh) {\n      this._debugCylinderMesh.dispose();\n    }\n    if (this._debugMaterial) {\n      this._debugMaterial.dispose();\n    }\n    this._impostors.length = 0;\n    this._scene = null;\n    this._physicsEnginePlugin = null;\n    if (this._utilityLayer) {\n      this._utilityLayer.dispose();\n      this._utilityLayer = null;\n    }\n  }\n}","map":{"version":3,"names":["Mesh","CreateBox","CreateSphere","Matrix","Quaternion","TmpVectors","Vector3","Color3","Color4","EngineStore","StandardMaterial","PhysicsImpostor","UtilityLayerRenderer","CreateCylinder","CreateCapsule","Logger","VertexData","MeshBuilder","AxesViewer","TransformNode","Epsilon","PhysicsViewer","constructor","scene","_impostors","_meshes","_bodies","_inertiaBodies","_constraints","_bodyMeshes","_inertiaMeshes","_constraintMeshes","_numMeshes","_numBodies","_numInertiaBodies","_numConstraints","_debugMeshMeshes","Array","_constraintAxesSize","_scene","LastCreatedScene","physicEngine","getPhysicsEngine","_physicsEnginePlugin","getPhysicsPlugin","_utilityLayer","pickUtilitySceneFirst","utilityLayerScene","autoClearDepthAndStencil","_updateDebugMeshes","plugin","getPluginVersion","_updateDebugMeshesV1","_updateDebugMeshesV2","i","impostor","isDisposed","hideImpostor","type","MeshImpostor","mesh","syncMeshWithImpostor","body","transform","syncTransform","_updateInertiaMeshes","_updateDebugInertia","inertiaMesh","inertiaMatrixRef","Identity","transformMatrixRef","finalMatrixRef","_pluginDataInstances","length","inertiaAsMesh","inertiaMeshMatrixData","_thinInstanceDataStorage","matrixData","bodyTransformMatrixData","transformNode","props","getMassProperties","_getMeshDebugInertiaMatrixToRef","FromArrayToRef","multiplyToRef","copyToArray","thinInstanceBufferUpdated","_a","rotationQuaternion","toRotationMatrix","setTranslation","position","parent","parentTransform","computeWorldMatrix","decomposeToTransformNode","_updateDebugConstraints","constraint","_updateDebugConstraint","_makeScalingUnitInPlace","scaling","Math","abs","x","sign","y","z","parentingMesh","_initOptions","pivotA","pivotB","axisA","axisB","perpAxisA","perpAxisB","getDescendants","forEach","parentConstraintMesh","parentCoordSystemNode","childCoordSystemNode","parentBody","parentBodyIndex","metadata","childBody","childBodyIndex","_getTransformFromBodyToRef","childTransform","parentTransformNode","copyFrom","childTransformNode","FromRotationMatrixToRef","FromXYZAxesToRef","CrossToRef","showImpostor","targetMesh","debugMesh","_getDebugMesh","_renderFunction","registerBeforeRender","showBody","_getDebugBodyMesh","showInertia","_getDebugInertiaMesh","_inertiaRenderFunction","showConstraint","_getDebugConstraintMesh","_constraintRenderFunction","removed","removeMesh","dispose","index","indexOf","splice","unregisterBeforeRender","hideBody","hideInertia","hideConstraint","_getDebugMaterial","_debugMaterial","wireframe","emissiveColor","White","disableLighting","_getDebugInertiaMaterial","_debugInertiaMaterial","alpha","_getDebugBoxMesh","_debugBoxMesh","size","material","setEnabled","createInstance","_getDebugSphereMesh","_debugSphereMesh","diameter","_getDebugCapsuleMesh","_debugCapsuleMesh","height","_getDebugCylinderMesh","_debugCylinderMesh","diameterTop","diameterBottom","_getDebugMeshMesh","wireframeOver","name","setParent","Zero","push","physicsImpostor","physicsBody","Warn","BoxImpostor","getBoxSizeToRef","SphereImpostor","radius","getRadius","CapsuleImpostor","bi","object","getBoundingInfo","boundingBox","maximum","minimum","NoImpostor","childMeshes","getChildMeshes","filter","c","m","getClassName","boundingInfo","min","max","addInPlace","scaleInPlace","CylinderImpostor","vertexData","geometry","getGeometry","positions","indices","applyToMesh","instanceBuffer","Float32Array","thinInstanceSetBuffer","massProps","matrix","orientation","inertiaOrientation","inertiaLocal","_b","inertia","center","_c","centerOfMass","betaSqrd","beta","sqrt","gammaSqrd","gamma","alphaSqrd","extents","set","ScalingToRef","rotation","translation","TranslationToRef","inertiaBoxMesh","matrixRef","enableEdgesRendering","edgesWidth","edgesColor","instanceIndex","tnode","getWorldMatrix","bodiesUsingConstraint","getBodiesUsingConstraint","bodyPairInfo","parentOfPair","rotTransformParent","FromRotationMatrix","cross","rotTransformChild","translateTransformParent","translateTransformChild","parentAxes","xAxis","yAxis","zAxis","childAxes"],"sources":["../../../../dev/core/src/Debug/physicsViewer.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { CreateBox } from \"../Meshes/Builders/boxBuilder\";\r\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder\";\r\nimport { Matrix, Quaternion, TmpVectors, Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport type { IPhysicsEnginePlugin as IPhysicsEnginePluginV1 } from \"../Physics/v1/IPhysicsEnginePlugin\";\r\nimport type { IPhysicsEnginePluginV2, PhysicsMassProperties } from \"../Physics/v2/IPhysicsEnginePlugin\";\r\nimport { PhysicsImpostor } from \"../Physics/v1/physicsImpostor\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder\";\r\nimport type { ICreateCapsuleOptions } from \"../Meshes/Builders/capsuleBuilder\";\r\nimport { CreateCapsule } from \"../Meshes/Builders/capsuleBuilder\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { PhysicsBody } from \"../Physics/v2/physicsBody\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport { MeshBuilder } from \"../Meshes/meshBuilder\";\r\nimport type { PhysicsConstraint } from \"../Physics/v2/physicsConstraint\";\r\nimport { AxesViewer } from \"./axesViewer\";\r\nimport { TransformNode } from \"../Meshes/transformNode\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\n\r\n/**\r\n * Used to show the physics impostor around the specific mesh\r\n */\r\nexport class PhysicsViewer {\r\n    /** @internal */\r\n    protected _impostors: Array<Nullable<PhysicsImpostor>> = [];\r\n    /** @internal */\r\n    protected _meshes: Array<Nullable<AbstractMesh>> = [];\r\n    /** @internal */\r\n    protected _bodies: Array<Nullable<PhysicsBody>> = [];\r\n    /** @internal */\r\n    protected _inertiaBodies: Array<Nullable<PhysicsBody>> = [];\r\n    /** @internal */\r\n    protected _constraints: Array<Nullable<PhysicsConstraint>> = [];\r\n    /** @internal */\r\n    protected _bodyMeshes: Array<Nullable<AbstractMesh>> = [];\r\n    /** @internal */\r\n    protected _inertiaMeshes: Array<Nullable<AbstractMesh>> = [];\r\n    /** @internal */\r\n    protected _constraintMeshes: Array<Nullable<AbstractMesh>> = [];\r\n    /** @internal */\r\n    protected _scene: Nullable<Scene>;\r\n    /** @internal */\r\n    protected _numMeshes = 0;\r\n    /** @internal */\r\n    protected _numBodies = 0;\r\n    /** @internal */\r\n    protected _numInertiaBodies = 0;\r\n    /** @internal */\r\n    protected _numConstraints = 0;\r\n    /** @internal */\r\n    protected _physicsEnginePlugin: IPhysicsEnginePluginV1 | IPhysicsEnginePluginV2 | null;\r\n    private _renderFunction: () => void;\r\n    private _inertiaRenderFunction: () => void;\r\n    private _constraintRenderFunction: () => void;\r\n    private _utilityLayer: Nullable<UtilityLayerRenderer>;\r\n\r\n    private _debugBoxMesh: Mesh;\r\n    private _debugSphereMesh: Mesh;\r\n    private _debugCapsuleMesh: Mesh;\r\n    private _debugCylinderMesh: Mesh;\r\n    private _debugMaterial: StandardMaterial;\r\n    private _debugInertiaMaterial: StandardMaterial;\r\n    private _debugMeshMeshes = new Array<Mesh>();\r\n\r\n    private _constraintAxesSize = 0.4;\r\n\r\n    /**\r\n     * Creates a new PhysicsViewer\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(scene?: Scene) {\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        if (!this._scene) {\r\n            return;\r\n        }\r\n        const physicEngine = this._scene.getPhysicsEngine();\r\n\r\n        if (physicEngine) {\r\n            this._physicsEnginePlugin = physicEngine.getPhysicsPlugin();\r\n        }\r\n\r\n        this._utilityLayer = new UtilityLayerRenderer(this._scene, false);\r\n        this._utilityLayer.pickUtilitySceneFirst = false;\r\n        this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = true;\r\n    }\r\n\r\n    /**\r\n     * Updates the debug meshes of the physics engine.\r\n     *\r\n     * This code is useful for synchronizing the debug meshes of the physics engine with the physics impostor and mesh.\r\n     * It checks if the impostor is disposed and if the plugin version is 1, then it syncs the mesh with the impostor.\r\n     * This ensures that the debug meshes are up to date with the physics engine.\r\n     */\r\n    protected _updateDebugMeshes(): void {\r\n        const plugin = this._physicsEnginePlugin;\r\n\r\n        if (plugin?.getPluginVersion() === 1) {\r\n            this._updateDebugMeshesV1();\r\n        } else {\r\n            this._updateDebugMeshesV2();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the debug meshes of the physics engine.\r\n     *\r\n     * This method is useful for synchronizing the debug meshes with the physics impostors.\r\n     * It iterates through the impostors and meshes, and if the plugin version is 1, it syncs the mesh with the impostor.\r\n     * This ensures that the debug meshes accurately reflect the physics impostors, which is important for debugging the physics engine.\r\n     */\r\n    protected _updateDebugMeshesV1(): void {\r\n        const plugin = this._physicsEnginePlugin as IPhysicsEnginePluginV1;\r\n        for (let i = 0; i < this._numMeshes; i++) {\r\n            const impostor = this._impostors[i];\r\n\r\n            if (!impostor) {\r\n                continue;\r\n            }\r\n\r\n            if (impostor.isDisposed) {\r\n                this.hideImpostor(this._impostors[i--]);\r\n            } else {\r\n                if (impostor.type === PhysicsImpostor.MeshImpostor) {\r\n                    continue;\r\n                }\r\n                const mesh = this._meshes[i];\r\n\r\n                if (mesh && plugin) {\r\n                    plugin.syncMeshWithImpostor(mesh, impostor);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the debug meshes of the physics engine for V2 plugin.\r\n     *\r\n     * This method is useful for synchronizing the debug meshes of the physics engine with the current state of the bodies.\r\n     * It iterates through the bodies array and updates the debug meshes with the current transform of each body.\r\n     * This ensures that the debug meshes accurately reflect the current state of the physics engine.\r\n     */\r\n    protected _updateDebugMeshesV2(): void {\r\n        const plugin = this._physicsEnginePlugin as IPhysicsEnginePluginV2;\r\n        for (let i = 0; i < this._numBodies; i++) {\r\n            const body = this._bodies[i];\r\n            const transform = this._bodyMeshes[i];\r\n            if (body && transform) {\r\n                plugin.syncTransform(body, transform);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _updateInertiaMeshes(): void {\r\n        for (let i = 0; i < this._numInertiaBodies; i++) {\r\n            const body = this._inertiaBodies[i];\r\n            const mesh = this._inertiaMeshes[i];\r\n            if (body && mesh) {\r\n                this._updateDebugInertia(body, mesh);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _updateDebugInertia(body: PhysicsBody, inertiaMesh: AbstractMesh): void {\r\n        const inertiaMatrixRef = Matrix.Identity();\r\n        const transformMatrixRef = Matrix.Identity();\r\n        const finalMatrixRef = Matrix.Identity();\r\n        if (body._pluginDataInstances.length) {\r\n            const inertiaAsMesh = inertiaMesh as Mesh;\r\n            const inertiaMeshMatrixData = inertiaAsMesh._thinInstanceDataStorage.matrixData!;\r\n            const bodyTransformMatrixData = (body.transformNode as Mesh)._thinInstanceDataStorage.matrixData!;\r\n            for (let i = 0; i < body._pluginDataInstances.length; i++) {\r\n                const props = body.getMassProperties(i);\r\n                this._getMeshDebugInertiaMatrixToRef(props, inertiaMatrixRef);\r\n                Matrix.FromArrayToRef(bodyTransformMatrixData, i * 16, transformMatrixRef);\r\n                inertiaMatrixRef.multiplyToRef(transformMatrixRef, finalMatrixRef);\r\n                finalMatrixRef.copyToArray(inertiaMeshMatrixData, i * 16);\r\n            }\r\n            inertiaAsMesh.thinInstanceBufferUpdated(\"matrix\");\r\n        } else {\r\n            const props = body.getMassProperties();\r\n            this._getMeshDebugInertiaMatrixToRef(props, inertiaMatrixRef);\r\n            body.transformNode.rotationQuaternion?.toRotationMatrix(transformMatrixRef);\r\n            transformMatrixRef.setTranslation(body.transformNode.position);\r\n            if (body.transformNode.parent) {\r\n                const parentTransform = body.transformNode.parent.computeWorldMatrix(true);\r\n                transformMatrixRef.multiplyToRef(parentTransform, transformMatrixRef);\r\n            }\r\n            inertiaMatrixRef.multiplyToRef(transformMatrixRef, inertiaMatrixRef);\r\n            inertiaMatrixRef.decomposeToTransformNode(inertiaMesh);\r\n        }\r\n    }\r\n\r\n    protected _updateDebugConstraints() {\r\n        for (let i = 0; i < this._numConstraints; i++) {\r\n            const constraint = this._constraints[i];\r\n            const mesh = this._constraintMeshes[i];\r\n            if (constraint && mesh) {\r\n                this._updateDebugConstraint(constraint, mesh);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a scaling vector, make all of its components\r\n     * 1, preserving the sign\r\n     * @param scaling\r\n     */\r\n    protected _makeScalingUnitInPlace(scaling: Vector3) {\r\n        if (Math.abs(scaling.x - 1) > Epsilon) {\r\n            scaling.x = 1 * Math.sign(scaling.x);\r\n        }\r\n        if (Math.abs(scaling.y - 1) > Epsilon) {\r\n            scaling.y = 1 * Math.sign(scaling.y);\r\n        }\r\n        if (Math.abs(scaling.z - 1) > Epsilon) {\r\n            scaling.z = 1 * Math.sign(scaling.z);\r\n        }\r\n    }\r\n\r\n    protected _updateDebugConstraint(constraint: PhysicsConstraint, parentingMesh: AbstractMesh) {\r\n        if (!constraint._initOptions) {\r\n            return;\r\n        }\r\n\r\n        // Get constraint pivot and axes\r\n        const { pivotA, pivotB, axisA, axisB, perpAxisA, perpAxisB } = constraint._initOptions;\r\n\r\n        if (!pivotA || !pivotB || !axisA || !axisB || !perpAxisA || !perpAxisB) {\r\n            return;\r\n        }\r\n\r\n        parentingMesh.getDescendants(true).forEach((parentConstraintMesh) => {\r\n            // Get the parent transform\r\n            const parentCoordSystemNode = parentConstraintMesh.getDescendants(true)[0] as TransformNode;\r\n            const childCoordSystemNode = parentConstraintMesh.getDescendants(true)[1] as TransformNode;\r\n\r\n            const { parentBody, parentBodyIndex } = parentCoordSystemNode.metadata;\r\n            const { childBody, childBodyIndex } = childCoordSystemNode.metadata;\r\n\r\n            const parentTransform = this._getTransformFromBodyToRef(parentBody, TmpVectors.Matrix[0], parentBodyIndex);\r\n            const childTransform = this._getTransformFromBodyToRef(childBody, TmpVectors.Matrix[1], childBodyIndex);\r\n\r\n            parentTransform.decomposeToTransformNode(parentCoordSystemNode);\r\n            this._makeScalingUnitInPlace(parentCoordSystemNode.scaling);\r\n\r\n            childTransform.decomposeToTransformNode(childCoordSystemNode);\r\n            this._makeScalingUnitInPlace(childCoordSystemNode.scaling);\r\n\r\n            // Create a transform node and set its matrix\r\n            const parentTransformNode = parentCoordSystemNode.getDescendants(true)[0] as TransformNode;\r\n            parentTransformNode.position.copyFrom(pivotA);\r\n\r\n            const childTransformNode = childCoordSystemNode.getDescendants(true)[0] as TransformNode;\r\n            childTransformNode.position.copyFrom(pivotB);\r\n\r\n            // Get the transform to align the XYZ axes to the constraint axes\r\n            Quaternion.FromRotationMatrixToRef(\r\n                Matrix.FromXYZAxesToRef(axisA, perpAxisA, Vector3.CrossToRef(axisA, perpAxisA, TmpVectors.Vector3[0]), TmpVectors.Matrix[0]),\r\n                parentTransformNode.rotationQuaternion!\r\n            );\r\n            Quaternion.FromRotationMatrixToRef(\r\n                Matrix.FromXYZAxesToRef(axisB, perpAxisB, Vector3.CrossToRef(axisB, perpAxisB, TmpVectors.Vector3[1]), TmpVectors.Matrix[1]),\r\n                childTransformNode.rotationQuaternion!\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Renders a specified physic impostor\r\n     * @param impostor defines the impostor to render\r\n     * @param targetMesh defines the mesh represented by the impostor\r\n     * @returns the new debug mesh used to render the impostor\r\n     */\r\n    public showImpostor(impostor: PhysicsImpostor, targetMesh?: Mesh): Nullable<AbstractMesh> {\r\n        if (!this._scene) {\r\n            return null;\r\n        }\r\n\r\n        for (let i = 0; i < this._numMeshes; i++) {\r\n            if (this._impostors[i] == impostor) {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        const debugMesh = this._getDebugMesh(impostor, targetMesh);\r\n\r\n        if (debugMesh) {\r\n            this._impostors[this._numMeshes] = impostor;\r\n            this._meshes[this._numMeshes] = debugMesh;\r\n\r\n            if (this._numMeshes === 0) {\r\n                this._renderFunction = () => this._updateDebugMeshes();\r\n                this._scene.registerBeforeRender(this._renderFunction);\r\n            }\r\n\r\n            this._numMeshes++;\r\n        }\r\n\r\n        return debugMesh;\r\n    }\r\n\r\n    /**\r\n     * Shows a debug mesh for a given physics body.\r\n     * @param body The physics body to show.\r\n     * @returns The debug mesh, or null if the body is already shown.\r\n     *\r\n     * This function is useful for visualizing the physics body in the scene.\r\n     * It creates a debug mesh for the given body and adds it to the scene.\r\n     * It also registers a before render function to update the debug mesh position and rotation.\r\n     */\r\n    public showBody(body: PhysicsBody): Nullable<AbstractMesh> {\r\n        if (!this._scene) {\r\n            return null;\r\n        }\r\n\r\n        for (let i = 0; i < this._numBodies; i++) {\r\n            if (this._bodies[i] == body) {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        const debugMesh = this._getDebugBodyMesh(body);\r\n\r\n        if (debugMesh) {\r\n            this._bodies[this._numBodies] = body;\r\n            this._bodyMeshes[this._numBodies] = debugMesh;\r\n\r\n            if (this._numBodies === 0) {\r\n                this._renderFunction = () => this._updateDebugMeshes();\r\n                this._scene.registerBeforeRender(this._renderFunction);\r\n            }\r\n\r\n            this._numBodies++;\r\n        }\r\n\r\n        return debugMesh;\r\n    }\r\n\r\n    /**\r\n     * Shows a debug box corresponding to the inertia of a given body\r\n     * @param body\r\n     */\r\n    public showInertia(body: PhysicsBody): Nullable<AbstractMesh> {\r\n        if (!this._scene) {\r\n            return null;\r\n        }\r\n\r\n        for (let i = 0; i < this._numInertiaBodies; i++) {\r\n            if (this._inertiaBodies[i] == body) {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        const debugMesh = this._getDebugInertiaMesh(body);\r\n        if (debugMesh) {\r\n            this._inertiaBodies[this._numInertiaBodies] = body;\r\n            this._inertiaMeshes[this._numInertiaBodies] = debugMesh;\r\n\r\n            if (this._numInertiaBodies === 0) {\r\n                this._inertiaRenderFunction = () => this._updateInertiaMeshes();\r\n                this._scene.registerBeforeRender(this._inertiaRenderFunction);\r\n            }\r\n\r\n            this._numInertiaBodies++;\r\n        }\r\n\r\n        return debugMesh;\r\n    }\r\n\r\n    /**\r\n     * Shows a debug mesh for a given physics constraint.\r\n     * @param constraint the physics constraint to show\r\n     * @returns the debug mesh, or null if the constraint is already shown\r\n     */\r\n    public showConstraint(constraint: PhysicsConstraint): Nullable<AbstractMesh> {\r\n        if (!this._scene) {\r\n            return null;\r\n        }\r\n\r\n        for (let i = 0; i < this._numConstraints; i++) {\r\n            if (this._constraints[i] == constraint) {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        const debugMesh = this._getDebugConstraintMesh(constraint);\r\n        if (debugMesh) {\r\n            this._constraints[this._numConstraints] = constraint;\r\n            this._constraintMeshes[this._numConstraints] = debugMesh;\r\n\r\n            if (this._numConstraints === 0) {\r\n                this._constraintRenderFunction = () => this._updateDebugConstraints();\r\n                this._scene.registerBeforeRender(this._constraintRenderFunction);\r\n            }\r\n\r\n            this._numConstraints++;\r\n        }\r\n\r\n        return debugMesh;\r\n    }\r\n\r\n    /**\r\n     * Hides an impostor from the scene.\r\n     * @param impostor - The impostor to hide.\r\n     *\r\n     * This method is useful for hiding an impostor from the scene. It removes the\r\n     * impostor from the utility layer scene, disposes the mesh, and removes the\r\n     * impostor from the list of impostors. If the impostor is the last one in the\r\n     * list, it also unregisters the render function.\r\n     */\r\n    public hideImpostor(impostor: Nullable<PhysicsImpostor>) {\r\n        if (!impostor || !this._scene || !this._utilityLayer) {\r\n            return;\r\n        }\r\n\r\n        let removed = false;\r\n        const utilityLayerScene = this._utilityLayer.utilityLayerScene;\r\n\r\n        for (let i = 0; i < this._numMeshes; i++) {\r\n            if (this._impostors[i] == impostor) {\r\n                const mesh = this._meshes[i];\r\n\r\n                if (!mesh) {\r\n                    continue;\r\n                }\r\n\r\n                utilityLayerScene.removeMesh(mesh);\r\n                mesh.dispose();\r\n\r\n                const index = this._debugMeshMeshes.indexOf(mesh as Mesh);\r\n                if (index > -1) {\r\n                    this._debugMeshMeshes.splice(index, 1);\r\n                }\r\n\r\n                this._numMeshes--;\r\n                if (this._numMeshes > 0) {\r\n                    this._meshes[i] = this._meshes[this._numMeshes];\r\n                    this._impostors[i] = this._impostors[this._numMeshes];\r\n                    this._meshes[this._numMeshes] = null;\r\n                    this._impostors[this._numMeshes] = null;\r\n                } else {\r\n                    this._meshes[0] = null;\r\n                    this._impostors[0] = null;\r\n                }\r\n                removed = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (removed && this._numMeshes === 0) {\r\n            this._scene.unregisterBeforeRender(this._renderFunction);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Hides a body from the physics engine.\r\n     * @param body - The body to hide.\r\n     *\r\n     * This function is useful for hiding a body from the physics engine.\r\n     * It removes the body from the utility layer scene and disposes the mesh associated with it.\r\n     * It also unregisters the render function if the number of bodies is 0.\r\n     * This is useful for hiding a body from the physics engine without deleting it.\r\n     */\r\n    public hideBody(body: Nullable<PhysicsBody>) {\r\n        if (!body || !this._scene || !this._utilityLayer) {\r\n            return;\r\n        }\r\n\r\n        let removed = false;\r\n        const utilityLayerScene = this._utilityLayer.utilityLayerScene;\r\n\r\n        for (let i = 0; i < this._numBodies; i++) {\r\n            if (this._bodies[i] === body) {\r\n                const mesh = this._bodyMeshes[i];\r\n\r\n                if (!mesh) {\r\n                    continue;\r\n                }\r\n\r\n                utilityLayerScene.removeMesh(mesh);\r\n                mesh.dispose();\r\n\r\n                this._numBodies--;\r\n                if (this._numBodies > 0) {\r\n                    this._bodyMeshes[i] = this._bodyMeshes[this._numBodies];\r\n                    this._bodies[i] = this._bodies[this._numBodies];\r\n                    this._bodyMeshes[this._numBodies] = null;\r\n                    this._bodies[this._numBodies] = null;\r\n                } else {\r\n                    this._bodyMeshes[0] = null;\r\n                    this._bodies[0] = null;\r\n                }\r\n                removed = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (removed && this._numBodies === 0) {\r\n            this._scene.unregisterBeforeRender(this._renderFunction);\r\n        }\r\n    }\r\n\r\n    public hideInertia(body: Nullable<PhysicsBody>) {\r\n        if (!body || !this._scene || !this._utilityLayer) {\r\n            return;\r\n        }\r\n        let removed = false;\r\n        const utilityLayerScene = this._utilityLayer.utilityLayerScene;\r\n\r\n        for (let i = 0; i < this._numInertiaBodies; i++) {\r\n            if (this._inertiaBodies[i] === body) {\r\n                const mesh = this._inertiaMeshes[i];\r\n\r\n                if (!mesh) {\r\n                    continue;\r\n                }\r\n\r\n                utilityLayerScene.removeMesh(mesh);\r\n                mesh.dispose();\r\n\r\n                this._inertiaBodies.splice(i, 1);\r\n                this._inertiaMeshes.splice(i, 1);\r\n\r\n                this._numInertiaBodies--;\r\n\r\n                removed = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (removed && this._numInertiaBodies === 0) {\r\n            this._scene.unregisterBeforeRender(this._inertiaRenderFunction);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Hide a physics constraint from the viewer utility layer\r\n     * @param constraint the constraint to hide\r\n     */\r\n    public hideConstraint(constraint: Nullable<PhysicsConstraint>) {\r\n        if (!constraint || !this._scene || !this._utilityLayer) {\r\n            return;\r\n        }\r\n        let removed = false;\r\n        const utilityLayerScene = this._utilityLayer.utilityLayerScene;\r\n\r\n        for (let i = 0; i < this._numConstraints; i++) {\r\n            if (this._constraints[i] === constraint) {\r\n                const mesh = this._constraintMeshes[i];\r\n\r\n                if (!mesh) {\r\n                    continue;\r\n                }\r\n\r\n                utilityLayerScene.removeMesh(mesh);\r\n                mesh.dispose();\r\n\r\n                this._constraints.splice(i, 1);\r\n                this._constraintMeshes.splice(i, 1);\r\n\r\n                this._numConstraints--;\r\n\r\n                if (this._numConstraints > 0) {\r\n                    this._constraints[i] = this._constraints[this._numConstraints];\r\n                    this._constraintMeshes[i] = this._constraintMeshes[this._numConstraints];\r\n                    this._constraints[this._numConstraints] = null;\r\n                    this._constraintMeshes[this._numConstraints] = null;\r\n                } else {\r\n                    this._constraints[0] = null;\r\n                    this._constraintMeshes[0] = null;\r\n                }\r\n\r\n                removed = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (removed && this._numConstraints === 0) {\r\n            this._scene.unregisterBeforeRender(this._constraintRenderFunction);\r\n        }\r\n    }\r\n\r\n    private _getDebugMaterial(scene: Scene): Material {\r\n        if (!this._debugMaterial) {\r\n            this._debugMaterial = new StandardMaterial(\"\", scene);\r\n            this._debugMaterial.wireframe = true;\r\n            this._debugMaterial.emissiveColor = Color3.White();\r\n            this._debugMaterial.disableLighting = true;\r\n        }\r\n\r\n        return this._debugMaterial;\r\n    }\r\n\r\n    private _getDebugInertiaMaterial(scene: Scene): Material {\r\n        if (!this._debugInertiaMaterial) {\r\n            this._debugInertiaMaterial = new StandardMaterial(\"\", scene);\r\n            this._debugInertiaMaterial.disableLighting = true;\r\n            this._debugInertiaMaterial.alpha = 0.0;\r\n        }\r\n\r\n        return this._debugInertiaMaterial;\r\n    }\r\n\r\n    private _getDebugBoxMesh(scene: Scene): AbstractMesh {\r\n        if (!this._debugBoxMesh) {\r\n            this._debugBoxMesh = CreateBox(\"physicsBodyBoxViewMesh\", { size: 1 }, scene);\r\n            this._debugBoxMesh.rotationQuaternion = Quaternion.Identity();\r\n            this._debugBoxMesh.material = this._getDebugMaterial(scene);\r\n            this._debugBoxMesh.setEnabled(false);\r\n        }\r\n\r\n        return this._debugBoxMesh.createInstance(\"physicsBodyBoxViewInstance\");\r\n    }\r\n\r\n    private _getDebugSphereMesh(scene: Scene): AbstractMesh {\r\n        if (!this._debugSphereMesh) {\r\n            this._debugSphereMesh = CreateSphere(\"physicsBodySphereViewMesh\", { diameter: 1 }, scene);\r\n            this._debugSphereMesh.rotationQuaternion = Quaternion.Identity();\r\n            this._debugSphereMesh.material = this._getDebugMaterial(scene);\r\n            this._debugSphereMesh.setEnabled(false);\r\n        }\r\n\r\n        return this._debugSphereMesh.createInstance(\"physicsBodySphereViewInstance\");\r\n    }\r\n\r\n    private _getDebugCapsuleMesh(scene: Scene): AbstractMesh {\r\n        if (!this._debugCapsuleMesh) {\r\n            this._debugCapsuleMesh = CreateCapsule(\"physicsBodyCapsuleViewMesh\", { height: 1 } as ICreateCapsuleOptions, scene);\r\n            this._debugCapsuleMesh.rotationQuaternion = Quaternion.Identity();\r\n            this._debugCapsuleMesh.material = this._getDebugMaterial(scene);\r\n            this._debugCapsuleMesh.setEnabled(false);\r\n        }\r\n\r\n        return this._debugCapsuleMesh.createInstance(\"physicsBodyCapsuleViewInstance\");\r\n    }\r\n\r\n    private _getDebugCylinderMesh(scene: Scene): AbstractMesh {\r\n        if (!this._debugCylinderMesh) {\r\n            this._debugCylinderMesh = CreateCylinder(\"physicsBodyCylinderViewMesh\", { diameterTop: 1, diameterBottom: 1, height: 1 }, scene);\r\n            this._debugCylinderMesh.rotationQuaternion = Quaternion.Identity();\r\n            this._debugCylinderMesh.material = this._getDebugMaterial(scene);\r\n            this._debugCylinderMesh.setEnabled(false);\r\n        }\r\n\r\n        return this._debugCylinderMesh.createInstance(\"physicsBodyCylinderViewInstance\");\r\n    }\r\n\r\n    private _getDebugMeshMesh(mesh: Mesh, scene: Scene): AbstractMesh {\r\n        const wireframeOver = new Mesh(mesh.name, scene, null, mesh);\r\n        wireframeOver.setParent(mesh);\r\n        wireframeOver.position = Vector3.Zero();\r\n        wireframeOver.material = this._getDebugMaterial(scene);\r\n\r\n        this._debugMeshMeshes.push(wireframeOver);\r\n\r\n        return wireframeOver;\r\n    }\r\n\r\n    private _getDebugMesh(impostor: PhysicsImpostor, targetMesh?: Mesh): Nullable<AbstractMesh> {\r\n        if (!this._utilityLayer) {\r\n            return null;\r\n        }\r\n\r\n        // Only create child impostor debug meshes when evaluating the parent\r\n        if (targetMesh && targetMesh.parent && (targetMesh.parent as Mesh).physicsImpostor) {\r\n            return null;\r\n        }\r\n\r\n        let mesh: Nullable<AbstractMesh> = null;\r\n        const utilityLayerScene = this._utilityLayer.utilityLayerScene;\r\n        if (!impostor.physicsBody) {\r\n            Logger.Warn(\"Unable to get physicsBody of impostor. It might be initialized later by its parent's impostor.\");\r\n            return null;\r\n        }\r\n        switch (impostor.type) {\r\n            case PhysicsImpostor.BoxImpostor:\r\n                mesh = this._getDebugBoxMesh(utilityLayerScene);\r\n                impostor.getBoxSizeToRef(mesh.scaling);\r\n                break;\r\n            case PhysicsImpostor.SphereImpostor: {\r\n                mesh = this._getDebugSphereMesh(utilityLayerScene);\r\n                const radius = impostor.getRadius();\r\n                mesh.scaling.x = radius * 2;\r\n                mesh.scaling.y = radius * 2;\r\n                mesh.scaling.z = radius * 2;\r\n                break;\r\n            }\r\n            case PhysicsImpostor.CapsuleImpostor: {\r\n                mesh = this._getDebugCapsuleMesh(utilityLayerScene);\r\n                const bi = impostor.object.getBoundingInfo();\r\n                mesh.scaling.x = (bi.boundingBox.maximum.x - bi.boundingBox.minimum.x) * 2 * impostor.object.scaling.x;\r\n                mesh.scaling.y = (bi.boundingBox.maximum.y - bi.boundingBox.minimum.y) * impostor.object.scaling.y;\r\n                mesh.scaling.z = (bi.boundingBox.maximum.z - bi.boundingBox.minimum.z) * 2 * impostor.object.scaling.z;\r\n                break;\r\n            }\r\n            case PhysicsImpostor.MeshImpostor:\r\n                if (targetMesh) {\r\n                    mesh = this._getDebugMeshMesh(targetMesh, utilityLayerScene);\r\n                }\r\n                break;\r\n            case PhysicsImpostor.NoImpostor:\r\n                if (targetMesh) {\r\n                    // Handle compound impostors\r\n                    const childMeshes = targetMesh.getChildMeshes().filter((c) => {\r\n                        return c.physicsImpostor ? 1 : 0;\r\n                    });\r\n                    childMeshes.forEach((m) => {\r\n                        if (m.physicsImpostor && m.getClassName() === \"Mesh\") {\r\n                            const boundingInfo = m.getBoundingInfo();\r\n                            const min = boundingInfo.boundingBox.minimum;\r\n                            const max = boundingInfo.boundingBox.maximum;\r\n                            switch (m.physicsImpostor.type) {\r\n                                case PhysicsImpostor.BoxImpostor:\r\n                                    mesh = this._getDebugBoxMesh(utilityLayerScene);\r\n                                    mesh.position.copyFrom(min);\r\n                                    mesh.position.addInPlace(max);\r\n                                    mesh.position.scaleInPlace(0.5);\r\n                                    break;\r\n                                case PhysicsImpostor.SphereImpostor:\r\n                                    mesh = this._getDebugSphereMesh(utilityLayerScene);\r\n                                    break;\r\n                                case PhysicsImpostor.CylinderImpostor:\r\n                                    mesh = this._getDebugCylinderMesh(utilityLayerScene);\r\n                                    break;\r\n                                default:\r\n                                    mesh = null;\r\n                                    break;\r\n                            }\r\n                            if (mesh) {\r\n                                mesh.scaling.x = max.x - min.x;\r\n                                mesh.scaling.y = max.y - min.y;\r\n                                mesh.scaling.z = max.z - min.z;\r\n                                mesh.parent = m;\r\n                            }\r\n                        }\r\n                    });\r\n                } else {\r\n                    Logger.Warn(\"No target mesh parameter provided for NoImpostor. Skipping.\");\r\n                }\r\n                mesh = null;\r\n                break;\r\n            case PhysicsImpostor.CylinderImpostor: {\r\n                mesh = this._getDebugCylinderMesh(utilityLayerScene);\r\n                const bi = impostor.object.getBoundingInfo();\r\n                mesh.scaling.x = (bi.boundingBox.maximum.x - bi.boundingBox.minimum.x) * impostor.object.scaling.x;\r\n                mesh.scaling.y = (bi.boundingBox.maximum.y - bi.boundingBox.minimum.y) * impostor.object.scaling.y;\r\n                mesh.scaling.z = (bi.boundingBox.maximum.z - bi.boundingBox.minimum.z) * impostor.object.scaling.z;\r\n                break;\r\n            }\r\n        }\r\n        return mesh;\r\n    }\r\n\r\n    /**\r\n     * Creates a debug mesh for a given physics body\r\n     * @param body The physics body to create the debug mesh for\r\n     * @returns The created debug mesh or null if the utility layer is not available\r\n     *\r\n     * This code is useful for creating a debug mesh for a given physics body.\r\n     * It creates a Mesh object with a VertexData object containing the positions and indices\r\n     * of the geometry of the body. The mesh is then assigned a debug material from the utility layer scene.\r\n     * This allows for visualizing the physics body in the scene.\r\n     */\r\n    private _getDebugBodyMesh(body: PhysicsBody): Nullable<AbstractMesh> {\r\n        if (!this._utilityLayer) {\r\n            return null;\r\n        }\r\n\r\n        const utilityLayerScene = this._utilityLayer.utilityLayerScene;\r\n\r\n        const mesh = new Mesh(\"custom\", utilityLayerScene);\r\n        const vertexData = new VertexData();\r\n        const geometry = body.getGeometry() as any;\r\n        vertexData.positions = geometry.positions;\r\n        vertexData.indices = geometry.indices;\r\n        vertexData.applyToMesh(mesh);\r\n        if (body._pluginDataInstances) {\r\n            const instanceBuffer = new Float32Array(body._pluginDataInstances.length * 16);\r\n            mesh.thinInstanceSetBuffer(\"matrix\", instanceBuffer, 16);\r\n        }\r\n        mesh.material = this._getDebugMaterial(utilityLayerScene);\r\n        return mesh;\r\n    }\r\n\r\n    private _getMeshDebugInertiaMatrixToRef(massProps: PhysicsMassProperties, matrix: Matrix) {\r\n        const orientation = massProps.inertiaOrientation ?? Quaternion.Identity();\r\n        const inertiaLocal = massProps.inertia ?? Vector3.Zero();\r\n        const center = massProps.centerOfMass ?? Vector3.Zero();\r\n\r\n        const betaSqrd = (inertiaLocal.x - inertiaLocal.y + inertiaLocal.z) * 6;\r\n        const beta = Math.sqrt(Math.max(betaSqrd, 0)); // Safety check for zeroed elements!\r\n\r\n        const gammaSqrd = inertiaLocal.x * 12 - betaSqrd;\r\n        const gamma = Math.sqrt(Math.max(gammaSqrd, 0)); // Safety check for zeroed elements!\r\n\r\n        const alphaSqrd = inertiaLocal.z * 12 - betaSqrd;\r\n        const alpha = Math.sqrt(Math.max(alphaSqrd, 0)); // Safety check for zeroed elements!\r\n\r\n        const extents = TmpVectors.Vector3[0];\r\n        extents.set(alpha, beta, gamma);\r\n\r\n        const scaling = Matrix.ScalingToRef(extents.x, extents.y, extents.z, TmpVectors.Matrix[0]);\r\n        const rotation = orientation.toRotationMatrix(TmpVectors.Matrix[1]);\r\n        const translation = Matrix.TranslationToRef(center.x, center.y, center.z, TmpVectors.Matrix[2]);\r\n\r\n        scaling.multiplyToRef(rotation, matrix);\r\n        matrix.multiplyToRef(translation, matrix);\r\n\r\n        return matrix;\r\n    }\r\n\r\n    private _getDebugInertiaMesh(body: PhysicsBody): Nullable<AbstractMesh> {\r\n        if (!this._utilityLayer) {\r\n            return null;\r\n        }\r\n        const utilityLayerScene = this._utilityLayer.utilityLayerScene;\r\n\r\n        // The base inertia mesh is going to be a 1x1 cube that's scaled and rotated according to the inertia\r\n        const inertiaBoxMesh = MeshBuilder.CreateBox(\"custom\", { size: 1 }, utilityLayerScene);\r\n        const matrixRef = Matrix.Identity();\r\n        if (body._pluginDataInstances.length) {\r\n            const instanceBuffer = new Float32Array(body._pluginDataInstances.length * 16);\r\n            for (let i = 0; i < body._pluginDataInstances.length; ++i) {\r\n                const props = body.getMassProperties(i);\r\n                this._getMeshDebugInertiaMatrixToRef(props, matrixRef);\r\n                matrixRef.copyToArray(instanceBuffer, i * 16);\r\n            }\r\n            inertiaBoxMesh.thinInstanceSetBuffer(\"matrix\", instanceBuffer, 16);\r\n        } else {\r\n            const props = body.getMassProperties();\r\n            this._getMeshDebugInertiaMatrixToRef(props, matrixRef);\r\n            matrixRef.decomposeToTransformNode(inertiaBoxMesh);\r\n        }\r\n        inertiaBoxMesh.enableEdgesRendering();\r\n        inertiaBoxMesh.edgesWidth = 2.0;\r\n        inertiaBoxMesh.edgesColor = new Color4(1, 0, 1, 1);\r\n        inertiaBoxMesh.material = this._getDebugInertiaMaterial(utilityLayerScene);\r\n\r\n        return inertiaBoxMesh;\r\n    }\r\n\r\n    private _getTransformFromBodyToRef(body: PhysicsBody, matrix: Matrix, instanceIndex?: number) {\r\n        const tnode = body.transformNode;\r\n        if (instanceIndex && instanceIndex >= 0) {\r\n            return Matrix.FromArrayToRef((tnode as Mesh)._thinInstanceDataStorage.matrixData!, instanceIndex, matrix);\r\n        } else {\r\n            return matrix.copyFrom(tnode.getWorldMatrix());\r\n        }\r\n    }\r\n\r\n    private _getDebugConstraintMesh(constraint: PhysicsConstraint): Nullable<AbstractMesh> {\r\n        if (!this._utilityLayer) {\r\n            return null;\r\n        }\r\n        const utilityLayerScene = this._utilityLayer.utilityLayerScene;\r\n\r\n        if (!constraint._initOptions) {\r\n            return null;\r\n        }\r\n\r\n        // Get constraint pivot and axes\r\n        const { pivotA, pivotB, axisA, axisB, perpAxisA, perpAxisB } = constraint._initOptions;\r\n\r\n        if (!pivotA || !pivotB || !axisA || !axisB || !perpAxisA || !perpAxisB) {\r\n            return null;\r\n        }\r\n\r\n        // Create a mesh to parent all the constraint debug meshes to\r\n        const parentingMesh = new Mesh(\"parentingDebugConstraint\", utilityLayerScene);\r\n\r\n        // First, get a reference to all physic bodies that are using this constraint\r\n        const bodiesUsingConstraint = constraint.getBodiesUsingConstraint();\r\n\r\n        for (const bodyPairInfo of bodiesUsingConstraint) {\r\n            // Create a mesh to keep the pair of constraint axes\r\n            const parentOfPair = new TransformNode(\"parentOfPair\", utilityLayerScene);\r\n            parentOfPair.parent = parentingMesh;\r\n\r\n            const { parentBody, parentBodyIndex, childBody, childBodyIndex } = bodyPairInfo;\r\n            // Get the parent transform\r\n\r\n            const parentTransform = this._getTransformFromBodyToRef(parentBody, TmpVectors.Matrix[0], parentBodyIndex);\r\n            const childTransform = this._getTransformFromBodyToRef(childBody, TmpVectors.Matrix[1], childBodyIndex);\r\n\r\n            const parentCoordSystemNode = new TransformNode(\"parentCoordSystem\", utilityLayerScene);\r\n            // parentCoordSystemNode.parent = parentingMesh;\r\n            parentCoordSystemNode.parent = parentOfPair;\r\n            // Save parent and index here to be able to get the transform on update\r\n            parentCoordSystemNode.metadata = { parentBody, parentBodyIndex };\r\n            parentTransform.decomposeToTransformNode(parentCoordSystemNode);\r\n\r\n            const childCoordSystemNode = new TransformNode(\"childCoordSystem\", utilityLayerScene);\r\n            // childCoordSystemNode.parent = parentingMesh;\r\n            childCoordSystemNode.parent = parentOfPair;\r\n            // Save child and index here to be able to get the transform on update\r\n            childCoordSystemNode.metadata = { childBody, childBodyIndex };\r\n            childTransform.decomposeToTransformNode(childCoordSystemNode);\r\n\r\n            // Get the transform to align the XYZ axes to the constraint axes\r\n            const rotTransformParent = Quaternion.FromRotationMatrix(Matrix.FromXYZAxesToRef(axisA, perpAxisA, axisA.cross(perpAxisA), TmpVectors.Matrix[0]));\r\n            const rotTransformChild = Quaternion.FromRotationMatrix(Matrix.FromXYZAxesToRef(axisB, perpAxisB, axisB.cross(perpAxisB), TmpVectors.Matrix[0]));\r\n\r\n            const translateTransformParent = pivotA;\r\n            const translateTransformChild = pivotB;\r\n\r\n            // Create a transform node and set its matrix\r\n            const parentTransformNode = new TransformNode(\"constraint_parent\", utilityLayerScene);\r\n            parentTransformNode.position.copyFrom(translateTransformParent);\r\n            parentTransformNode.rotationQuaternion = rotTransformParent;\r\n            parentTransformNode.parent = parentCoordSystemNode;\r\n\r\n            const childTransformNode = new TransformNode(\"constraint_child\", utilityLayerScene);\r\n            childTransformNode.parent = childCoordSystemNode;\r\n            childTransformNode.position.copyFrom(translateTransformChild);\r\n            childTransformNode.rotationQuaternion = rotTransformChild;\r\n\r\n            // Create axes for the constraint\r\n            const parentAxes = new AxesViewer(utilityLayerScene, this._constraintAxesSize);\r\n            parentAxes.xAxis.parent = parentTransformNode;\r\n            parentAxes.yAxis.parent = parentTransformNode;\r\n            parentAxes.zAxis.parent = parentTransformNode;\r\n\r\n            const childAxes = new AxesViewer(utilityLayerScene, this._constraintAxesSize);\r\n            childAxes.xAxis.parent = childTransformNode;\r\n            childAxes.yAxis.parent = childTransformNode;\r\n            childAxes.zAxis.parent = childTransformNode;\r\n        }\r\n\r\n        return parentingMesh;\r\n    }\r\n\r\n    /**\r\n     * Clean up physics debug display\r\n     */\r\n    public dispose() {\r\n        // impostors\r\n        for (let index = this._numMeshes - 1; index >= 0; index--) {\r\n            this.hideImpostor(this._impostors[0]);\r\n        }\r\n        // bodies\r\n        for (let index = this._numBodies - 1; index >= 0; index--) {\r\n            this.hideBody(this._bodies[0]);\r\n        }\r\n        // inertia\r\n        for (let index = this._numInertiaBodies - 1; index >= 0; index--) {\r\n            this.hideInertia(this._inertiaBodies[0]);\r\n        }\r\n\r\n        if (this._debugBoxMesh) {\r\n            this._debugBoxMesh.dispose();\r\n        }\r\n        if (this._debugSphereMesh) {\r\n            this._debugSphereMesh.dispose();\r\n        }\r\n        if (this._debugCylinderMesh) {\r\n            this._debugCylinderMesh.dispose();\r\n        }\r\n        if (this._debugMaterial) {\r\n            this._debugMaterial.dispose();\r\n        }\r\n\r\n        this._impostors.length = 0;\r\n        this._scene = null;\r\n        this._physicsEnginePlugin = null;\r\n\r\n        if (this._utilityLayer) {\r\n            this._utilityLayer.dispose();\r\n            this._utilityLayer = null;\r\n        }\r\n    }\r\n}\r\n"],"mappings":";;;;AAGA,SAASA,IAAI,QAAQ,mBAAiB;AACtC,SAASC,SAAS,QAAQ,kCAAgC;AAC1D,SAASC,YAAY,QAAQ,qCAAmC;AAChE,SAASC,MAAM,EAAEC,UAAU,EAAEC,UAAU,EAAEC,OAAO,QAAQ,yBAAuB;AAC/E,SAASC,MAAM,EAAEC,MAAM,QAAQ,wBAAsB;AAErD,SAASC,WAAW,QAAQ,2BAAyB;AACrD,SAASC,gBAAgB,QAAQ,kCAAgC;AAGjE,SAASC,eAAe,QAAQ,kCAAgC;AAChE,SAASC,oBAAoB,QAAQ,sCAAoC;AACzE,SAASC,cAAc,QAAQ,uCAAqC;AAEpE,SAASC,aAAa,QAAQ,sCAAoC;AAClE,SAASC,MAAM,QAAQ,mBAAiB;AAExC,SAASC,UAAU,QAAQ,8BAA4B;AACvD,SAASC,WAAW,QAAQ,0BAAwB;AAEpD,SAASC,UAAU,QAAQ,iBAAe;AAC1C,SAASC,aAAa,QAAQ,4BAA0B;AACxD,SAASC,OAAO,QAAQ,4BAA0B;AAElD;;;AAGA,OAAM,MAAOC,aAAa;EA4CtB;;;;EAIAC,YAAYC,KAAa;IA/CzB;IACU,KAAAC,UAAU,GAAqC,EAAE;IAC3D;IACU,KAAAC,OAAO,GAAkC,EAAE;IACrD;IACU,KAAAC,OAAO,GAAiC,EAAE;IACpD;IACU,KAAAC,cAAc,GAAiC,EAAE;IAC3D;IACU,KAAAC,YAAY,GAAuC,EAAE;IAC/D;IACU,KAAAC,WAAW,GAAkC,EAAE;IACzD;IACU,KAAAC,cAAc,GAAkC,EAAE;IAC5D;IACU,KAAAC,iBAAiB,GAAkC,EAAE;IAG/D;IACU,KAAAC,UAAU,GAAG,CAAC;IACxB;IACU,KAAAC,UAAU,GAAG,CAAC;IACxB;IACU,KAAAC,iBAAiB,GAAG,CAAC;IAC/B;IACU,KAAAC,eAAe,GAAG,CAAC;IAcrB,KAAAC,gBAAgB,GAAG,IAAIC,KAAK,EAAQ;IAEpC,KAAAC,mBAAmB,GAAG,GAAG;IAO7B,IAAI,CAACC,MAAM,GAAGhB,KAAK,IAAId,WAAW,CAAC+B,gBAAgB;IACnD,IAAI,CAAC,IAAI,CAACD,MAAM,EAAE;MACd;;IAEJ,MAAME,YAAY,GAAG,IAAI,CAACF,MAAM,CAACG,gBAAgB,EAAE;IAEnD,IAAID,YAAY,EAAE;MACd,IAAI,CAACE,oBAAoB,GAAGF,YAAY,CAACG,gBAAgB,EAAE;;IAG/D,IAAI,CAACC,aAAa,GAAG,IAAIjC,oBAAoB,CAAC,IAAI,CAAC2B,MAAM,EAAE,KAAK,CAAC;IACjE,IAAI,CAACM,aAAa,CAACC,qBAAqB,GAAG,KAAK;IAChD,IAAI,CAACD,aAAa,CAACE,iBAAiB,CAACC,wBAAwB,GAAG,IAAI;EACxE;EAEA;;;;;;;EAOUC,kBAAkBA,CAAA;IACxB,MAAMC,MAAM,GAAG,IAAI,CAACP,oBAAoB;IAExC,IAAI,CAAAO,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEC,gBAAgB,EAAE,MAAK,CAAC,EAAE;MAClC,IAAI,CAACC,oBAAoB,EAAE;KAC9B,MAAM;MACH,IAAI,CAACC,oBAAoB,EAAE;;EAEnC;EAEA;;;;;;;EAOUD,oBAAoBA,CAAA;IAC1B,MAAMF,MAAM,GAAG,IAAI,CAACP,oBAA8C;IAClE,KAAK,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACtB,UAAU,EAAEsB,CAAC,EAAE,EAAE;MACtC,MAAMC,QAAQ,GAAG,IAAI,CAAC/B,UAAU,CAAC8B,CAAC,CAAC;MAEnC,IAAI,CAACC,QAAQ,EAAE;QACX;;MAGJ,IAAIA,QAAQ,CAACC,UAAU,EAAE;QACrB,IAAI,CAACC,YAAY,CAAC,IAAI,CAACjC,UAAU,CAAC8B,CAAC,EAAE,CAAC,CAAC;OAC1C,MAAM;QACH,IAAIC,QAAQ,CAACG,IAAI,KAAK/C,eAAe,CAACgD,YAAY,EAAE;UAChD;;QAEJ,MAAMC,IAAI,GAAG,IAAI,CAACnC,OAAO,CAAC6B,CAAC,CAAC;QAE5B,IAAIM,IAAI,IAAIV,MAAM,EAAE;UAChBA,MAAM,CAACW,oBAAoB,CAACD,IAAI,EAAEL,QAAQ,CAAC;;;;EAI3D;EAEA;;;;;;;EAOUF,oBAAoBA,CAAA;IAC1B,MAAMH,MAAM,GAAG,IAAI,CAACP,oBAA8C;IAClE,KAAK,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACrB,UAAU,EAAEqB,CAAC,EAAE,EAAE;MACtC,MAAMQ,IAAI,GAAG,IAAI,CAACpC,OAAO,CAAC4B,CAAC,CAAC;MAC5B,MAAMS,SAAS,GAAG,IAAI,CAAClC,WAAW,CAACyB,CAAC,CAAC;MACrC,IAAIQ,IAAI,IAAIC,SAAS,EAAE;QACnBb,MAAM,CAACc,aAAa,CAACF,IAAI,EAAEC,SAAS,CAAC;;;EAGjD;EAEUE,oBAAoBA,CAAA;IAC1B,KAAK,IAAIX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACpB,iBAAiB,EAAEoB,CAAC,EAAE,EAAE;MAC7C,MAAMQ,IAAI,GAAG,IAAI,CAACnC,cAAc,CAAC2B,CAAC,CAAC;MACnC,MAAMM,IAAI,GAAG,IAAI,CAAC9B,cAAc,CAACwB,CAAC,CAAC;MACnC,IAAIQ,IAAI,IAAIF,IAAI,EAAE;QACd,IAAI,CAACM,mBAAmB,CAACJ,IAAI,EAAEF,IAAI,CAAC;;;EAGhD;EAEUM,mBAAmBA,CAACJ,IAAiB,EAAEK,WAAyB;;IACtE,MAAMC,gBAAgB,GAAGjE,MAAM,CAACkE,QAAQ,EAAE;IAC1C,MAAMC,kBAAkB,GAAGnE,MAAM,CAACkE,QAAQ,EAAE;IAC5C,MAAME,cAAc,GAAGpE,MAAM,CAACkE,QAAQ,EAAE;IACxC,IAAIP,IAAI,CAACU,oBAAoB,CAACC,MAAM,EAAE;MAClC,MAAMC,aAAa,GAAGP,WAAmB;MACzC,MAAMQ,qBAAqB,GAAGD,aAAa,CAACE,wBAAwB,CAACC,UAAW;MAChF,MAAMC,uBAAuB,GAAIhB,IAAI,CAACiB,aAAsB,CAACH,wBAAwB,CAACC,UAAW;MACjG,KAAK,IAAIvB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGQ,IAAI,CAACU,oBAAoB,CAACC,MAAM,EAAEnB,CAAC,EAAE,EAAE;QACvD,MAAM0B,KAAK,GAAGlB,IAAI,CAACmB,iBAAiB,CAAC3B,CAAC,CAAC;QACvC,IAAI,CAAC4B,+BAA+B,CAACF,KAAK,EAAEZ,gBAAgB,CAAC;QAC7DjE,MAAM,CAACgF,cAAc,CAACL,uBAAuB,EAAExB,CAAC,GAAG,EAAE,EAAEgB,kBAAkB,CAAC;QAC1EF,gBAAgB,CAACgB,aAAa,CAACd,kBAAkB,EAAEC,cAAc,CAAC;QAClEA,cAAc,CAACc,WAAW,CAACV,qBAAqB,EAAErB,CAAC,GAAG,EAAE,CAAC;;MAE7DoB,aAAa,CAACY,yBAAyB,CAAC,QAAQ,CAAC;KACpD,MAAM;MACH,MAAMN,KAAK,GAAGlB,IAAI,CAACmB,iBAAiB,EAAE;MACtC,IAAI,CAACC,+BAA+B,CAACF,KAAK,EAAEZ,gBAAgB,CAAC;MAC7D,CAAAmB,EAAA,GAAAzB,IAAI,CAACiB,aAAa,CAACS,kBAAkB,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,gBAAgB,CAACnB,kBAAkB,CAAC;MAC3EA,kBAAkB,CAACoB,cAAc,CAAC5B,IAAI,CAACiB,aAAa,CAACY,QAAQ,CAAC;MAC9D,IAAI7B,IAAI,CAACiB,aAAa,CAACa,MAAM,EAAE;QAC3B,MAAMC,eAAe,GAAG/B,IAAI,CAACiB,aAAa,CAACa,MAAM,CAACE,kBAAkB,CAAC,IAAI,CAAC;QAC1ExB,kBAAkB,CAACc,aAAa,CAACS,eAAe,EAAEvB,kBAAkB,CAAC;;MAEzEF,gBAAgB,CAACgB,aAAa,CAACd,kBAAkB,EAAEF,gBAAgB,CAAC;MACpEA,gBAAgB,CAAC2B,wBAAwB,CAAC5B,WAAW,CAAC;;EAE9D;EAEU6B,uBAAuBA,CAAA;IAC7B,KAAK,IAAI1C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACnB,eAAe,EAAEmB,CAAC,EAAE,EAAE;MAC3C,MAAM2C,UAAU,GAAG,IAAI,CAACrE,YAAY,CAAC0B,CAAC,CAAC;MACvC,MAAMM,IAAI,GAAG,IAAI,CAAC7B,iBAAiB,CAACuB,CAAC,CAAC;MACtC,IAAI2C,UAAU,IAAIrC,IAAI,EAAE;QACpB,IAAI,CAACsC,sBAAsB,CAACD,UAAU,EAAErC,IAAI,CAAC;;;EAGzD;EAEA;;;;;EAKUuC,uBAAuBA,CAACC,OAAgB;IAC9C,IAAIC,IAAI,CAACC,GAAG,CAACF,OAAO,CAACG,CAAC,GAAG,CAAC,CAAC,GAAGnF,OAAO,EAAE;MACnCgF,OAAO,CAACG,CAAC,GAAG,CAAC,GAAGF,IAAI,CAACG,IAAI,CAACJ,OAAO,CAACG,CAAC,CAAC;;IAExC,IAAIF,IAAI,CAACC,GAAG,CAACF,OAAO,CAACK,CAAC,GAAG,CAAC,CAAC,GAAGrF,OAAO,EAAE;MACnCgF,OAAO,CAACK,CAAC,GAAG,CAAC,GAAGJ,IAAI,CAACG,IAAI,CAACJ,OAAO,CAACK,CAAC,CAAC;;IAExC,IAAIJ,IAAI,CAACC,GAAG,CAACF,OAAO,CAACM,CAAC,GAAG,CAAC,CAAC,GAAGtF,OAAO,EAAE;MACnCgF,OAAO,CAACM,CAAC,GAAG,CAAC,GAAGL,IAAI,CAACG,IAAI,CAACJ,OAAO,CAACM,CAAC,CAAC;;EAE5C;EAEUR,sBAAsBA,CAACD,UAA6B,EAAEU,aAA2B;IACvF,IAAI,CAACV,UAAU,CAACW,YAAY,EAAE;MAC1B;;IAGJ;IACA,MAAM;MAAEC,MAAM;MAAEC,MAAM;MAAEC,KAAK;MAAEC,KAAK;MAAEC,SAAS;MAAEC;IAAS,CAAE,GAAGjB,UAAU,CAACW,YAAY;IAEtF,IAAI,CAACC,MAAM,IAAI,CAACC,MAAM,IAAI,CAACC,KAAK,IAAI,CAACC,KAAK,IAAI,CAACC,SAAS,IAAI,CAACC,SAAS,EAAE;MACpE;;IAGJP,aAAa,CAACQ,cAAc,CAAC,IAAI,CAAC,CAACC,OAAO,CAAEC,oBAAoB,IAAI;MAChE;MACA,MAAMC,qBAAqB,GAAGD,oBAAoB,CAACF,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,CAAkB;MAC3F,MAAMI,oBAAoB,GAAGF,oBAAoB,CAACF,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,CAAkB;MAE1F,MAAM;QAAEK,UAAU;QAAEC;MAAe,CAAE,GAAGH,qBAAqB,CAACI,QAAQ;MACtE,MAAM;QAAEC,SAAS;QAAEC;MAAc,CAAE,GAAGL,oBAAoB,CAACG,QAAQ;MAEnE,MAAM7B,eAAe,GAAG,IAAI,CAACgC,0BAA0B,CAACL,UAAU,EAAEnH,UAAU,CAACF,MAAM,CAAC,CAAC,CAAC,EAAEsH,eAAe,CAAC;MAC1G,MAAMK,cAAc,GAAG,IAAI,CAACD,0BAA0B,CAACF,SAAS,EAAEtH,UAAU,CAACF,MAAM,CAAC,CAAC,CAAC,EAAEyH,cAAc,CAAC;MAEvG/B,eAAe,CAACE,wBAAwB,CAACuB,qBAAqB,CAAC;MAC/D,IAAI,CAACnB,uBAAuB,CAACmB,qBAAqB,CAAClB,OAAO,CAAC;MAE3D0B,cAAc,CAAC/B,wBAAwB,CAACwB,oBAAoB,CAAC;MAC7D,IAAI,CAACpB,uBAAuB,CAACoB,oBAAoB,CAACnB,OAAO,CAAC;MAE1D;MACA,MAAM2B,mBAAmB,GAAGT,qBAAqB,CAACH,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,CAAkB;MAC1FY,mBAAmB,CAACpC,QAAQ,CAACqC,QAAQ,CAACnB,MAAM,CAAC;MAE7C,MAAMoB,kBAAkB,GAAGV,oBAAoB,CAACJ,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,CAAkB;MACxFc,kBAAkB,CAACtC,QAAQ,CAACqC,QAAQ,CAAClB,MAAM,CAAC;MAE5C;MACA1G,UAAU,CAAC8H,uBAAuB,CAC9B/H,MAAM,CAACgI,gBAAgB,CAACpB,KAAK,EAAEE,SAAS,EAAE3G,OAAO,CAAC8H,UAAU,CAACrB,KAAK,EAAEE,SAAS,EAAE5G,UAAU,CAACC,OAAO,CAAC,CAAC,CAAC,CAAC,EAAED,UAAU,CAACF,MAAM,CAAC,CAAC,CAAC,CAAC,EAC5H4H,mBAAmB,CAACvC,kBAAmB,CAC1C;MACDpF,UAAU,CAAC8H,uBAAuB,CAC9B/H,MAAM,CAACgI,gBAAgB,CAACnB,KAAK,EAAEE,SAAS,EAAE5G,OAAO,CAAC8H,UAAU,CAACpB,KAAK,EAAEE,SAAS,EAAE7G,UAAU,CAACC,OAAO,CAAC,CAAC,CAAC,CAAC,EAAED,UAAU,CAACF,MAAM,CAAC,CAAC,CAAC,CAAC,EAC5H8H,kBAAkB,CAACzC,kBAAmB,CACzC;IACL,CAAC,CAAC;EACN;EAEA;;;;;;EAMO6C,YAAYA,CAAC9E,QAAyB,EAAE+E,UAAiB;IAC5D,IAAI,CAAC,IAAI,CAAC/F,MAAM,EAAE;MACd,OAAO,IAAI;;IAGf,KAAK,IAAIe,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACtB,UAAU,EAAEsB,CAAC,EAAE,EAAE;MACtC,IAAI,IAAI,CAAC9B,UAAU,CAAC8B,CAAC,CAAC,IAAIC,QAAQ,EAAE;QAChC,OAAO,IAAI;;;IAInB,MAAMgF,SAAS,GAAG,IAAI,CAACC,aAAa,CAACjF,QAAQ,EAAE+E,UAAU,CAAC;IAE1D,IAAIC,SAAS,EAAE;MACX,IAAI,CAAC/G,UAAU,CAAC,IAAI,CAACQ,UAAU,CAAC,GAAGuB,QAAQ;MAC3C,IAAI,CAAC9B,OAAO,CAAC,IAAI,CAACO,UAAU,CAAC,GAAGuG,SAAS;MAEzC,IAAI,IAAI,CAACvG,UAAU,KAAK,CAAC,EAAE;QACvB,IAAI,CAACyG,eAAe,GAAG,MAAM,IAAI,CAACxF,kBAAkB,EAAE;QACtD,IAAI,CAACV,MAAM,CAACmG,oBAAoB,CAAC,IAAI,CAACD,eAAe,CAAC;;MAG1D,IAAI,CAACzG,UAAU,EAAE;;IAGrB,OAAOuG,SAAS;EACpB;EAEA;;;;;;;;;EASOI,QAAQA,CAAC7E,IAAiB;IAC7B,IAAI,CAAC,IAAI,CAACvB,MAAM,EAAE;MACd,OAAO,IAAI;;IAGf,KAAK,IAAIe,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACrB,UAAU,EAAEqB,CAAC,EAAE,EAAE;MACtC,IAAI,IAAI,CAAC5B,OAAO,CAAC4B,CAAC,CAAC,IAAIQ,IAAI,EAAE;QACzB,OAAO,IAAI;;;IAInB,MAAMyE,SAAS,GAAG,IAAI,CAACK,iBAAiB,CAAC9E,IAAI,CAAC;IAE9C,IAAIyE,SAAS,EAAE;MACX,IAAI,CAAC7G,OAAO,CAAC,IAAI,CAACO,UAAU,CAAC,GAAG6B,IAAI;MACpC,IAAI,CAACjC,WAAW,CAAC,IAAI,CAACI,UAAU,CAAC,GAAGsG,SAAS;MAE7C,IAAI,IAAI,CAACtG,UAAU,KAAK,CAAC,EAAE;QACvB,IAAI,CAACwG,eAAe,GAAG,MAAM,IAAI,CAACxF,kBAAkB,EAAE;QACtD,IAAI,CAACV,MAAM,CAACmG,oBAAoB,CAAC,IAAI,CAACD,eAAe,CAAC;;MAG1D,IAAI,CAACxG,UAAU,EAAE;;IAGrB,OAAOsG,SAAS;EACpB;EAEA;;;;EAIOM,WAAWA,CAAC/E,IAAiB;IAChC,IAAI,CAAC,IAAI,CAACvB,MAAM,EAAE;MACd,OAAO,IAAI;;IAGf,KAAK,IAAIe,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACpB,iBAAiB,EAAEoB,CAAC,EAAE,EAAE;MAC7C,IAAI,IAAI,CAAC3B,cAAc,CAAC2B,CAAC,CAAC,IAAIQ,IAAI,EAAE;QAChC,OAAO,IAAI;;;IAInB,MAAMyE,SAAS,GAAG,IAAI,CAACO,oBAAoB,CAAChF,IAAI,CAAC;IACjD,IAAIyE,SAAS,EAAE;MACX,IAAI,CAAC5G,cAAc,CAAC,IAAI,CAACO,iBAAiB,CAAC,GAAG4B,IAAI;MAClD,IAAI,CAAChC,cAAc,CAAC,IAAI,CAACI,iBAAiB,CAAC,GAAGqG,SAAS;MAEvD,IAAI,IAAI,CAACrG,iBAAiB,KAAK,CAAC,EAAE;QAC9B,IAAI,CAAC6G,sBAAsB,GAAG,MAAM,IAAI,CAAC9E,oBAAoB,EAAE;QAC/D,IAAI,CAAC1B,MAAM,CAACmG,oBAAoB,CAAC,IAAI,CAACK,sBAAsB,CAAC;;MAGjE,IAAI,CAAC7G,iBAAiB,EAAE;;IAG5B,OAAOqG,SAAS;EACpB;EAEA;;;;;EAKOS,cAAcA,CAAC/C,UAA6B;IAC/C,IAAI,CAAC,IAAI,CAAC1D,MAAM,EAAE;MACd,OAAO,IAAI;;IAGf,KAAK,IAAIe,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACnB,eAAe,EAAEmB,CAAC,EAAE,EAAE;MAC3C,IAAI,IAAI,CAAC1B,YAAY,CAAC0B,CAAC,CAAC,IAAI2C,UAAU,EAAE;QACpC,OAAO,IAAI;;;IAInB,MAAMsC,SAAS,GAAG,IAAI,CAACU,uBAAuB,CAAChD,UAAU,CAAC;IAC1D,IAAIsC,SAAS,EAAE;MACX,IAAI,CAAC3G,YAAY,CAAC,IAAI,CAACO,eAAe,CAAC,GAAG8D,UAAU;MACpD,IAAI,CAAClE,iBAAiB,CAAC,IAAI,CAACI,eAAe,CAAC,GAAGoG,SAAS;MAExD,IAAI,IAAI,CAACpG,eAAe,KAAK,CAAC,EAAE;QAC5B,IAAI,CAAC+G,yBAAyB,GAAG,MAAM,IAAI,CAAClD,uBAAuB,EAAE;QACrE,IAAI,CAACzD,MAAM,CAACmG,oBAAoB,CAAC,IAAI,CAACQ,yBAAyB,CAAC;;MAGpE,IAAI,CAAC/G,eAAe,EAAE;;IAG1B,OAAOoG,SAAS;EACpB;EAEA;;;;;;;;;EASO9E,YAAYA,CAACF,QAAmC;IACnD,IAAI,CAACA,QAAQ,IAAI,CAAC,IAAI,CAAChB,MAAM,IAAI,CAAC,IAAI,CAACM,aAAa,EAAE;MAClD;;IAGJ,IAAIsG,OAAO,GAAG,KAAK;IACnB,MAAMpG,iBAAiB,GAAG,IAAI,CAACF,aAAa,CAACE,iBAAiB;IAE9D,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACtB,UAAU,EAAEsB,CAAC,EAAE,EAAE;MACtC,IAAI,IAAI,CAAC9B,UAAU,CAAC8B,CAAC,CAAC,IAAIC,QAAQ,EAAE;QAChC,MAAMK,IAAI,GAAG,IAAI,CAACnC,OAAO,CAAC6B,CAAC,CAAC;QAE5B,IAAI,CAACM,IAAI,EAAE;UACP;;QAGJb,iBAAiB,CAACqG,UAAU,CAACxF,IAAI,CAAC;QAClCA,IAAI,CAACyF,OAAO,EAAE;QAEd,MAAMC,KAAK,GAAG,IAAI,CAAClH,gBAAgB,CAACmH,OAAO,CAAC3F,IAAY,CAAC;QACzD,IAAI0F,KAAK,GAAG,CAAC,CAAC,EAAE;UACZ,IAAI,CAAClH,gBAAgB,CAACoH,MAAM,CAACF,KAAK,EAAE,CAAC,CAAC;;QAG1C,IAAI,CAACtH,UAAU,EAAE;QACjB,IAAI,IAAI,CAACA,UAAU,GAAG,CAAC,EAAE;UACrB,IAAI,CAACP,OAAO,CAAC6B,CAAC,CAAC,GAAG,IAAI,CAAC7B,OAAO,CAAC,IAAI,CAACO,UAAU,CAAC;UAC/C,IAAI,CAACR,UAAU,CAAC8B,CAAC,CAAC,GAAG,IAAI,CAAC9B,UAAU,CAAC,IAAI,CAACQ,UAAU,CAAC;UACrD,IAAI,CAACP,OAAO,CAAC,IAAI,CAACO,UAAU,CAAC,GAAG,IAAI;UACpC,IAAI,CAACR,UAAU,CAAC,IAAI,CAACQ,UAAU,CAAC,GAAG,IAAI;SAC1C,MAAM;UACH,IAAI,CAACP,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI;UACtB,IAAI,CAACD,UAAU,CAAC,CAAC,CAAC,GAAG,IAAI;;QAE7B2H,OAAO,GAAG,IAAI;QACd;;;IAIR,IAAIA,OAAO,IAAI,IAAI,CAACnH,UAAU,KAAK,CAAC,EAAE;MAClC,IAAI,CAACO,MAAM,CAACkH,sBAAsB,CAAC,IAAI,CAAChB,eAAe,CAAC;;EAEhE;EAEA;;;;;;;;;EASOiB,QAAQA,CAAC5F,IAA2B;IACvC,IAAI,CAACA,IAAI,IAAI,CAAC,IAAI,CAACvB,MAAM,IAAI,CAAC,IAAI,CAACM,aAAa,EAAE;MAC9C;;IAGJ,IAAIsG,OAAO,GAAG,KAAK;IACnB,MAAMpG,iBAAiB,GAAG,IAAI,CAACF,aAAa,CAACE,iBAAiB;IAE9D,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACrB,UAAU,EAAEqB,CAAC,EAAE,EAAE;MACtC,IAAI,IAAI,CAAC5B,OAAO,CAAC4B,CAAC,CAAC,KAAKQ,IAAI,EAAE;QAC1B,MAAMF,IAAI,GAAG,IAAI,CAAC/B,WAAW,CAACyB,CAAC,CAAC;QAEhC,IAAI,CAACM,IAAI,EAAE;UACP;;QAGJb,iBAAiB,CAACqG,UAAU,CAACxF,IAAI,CAAC;QAClCA,IAAI,CAACyF,OAAO,EAAE;QAEd,IAAI,CAACpH,UAAU,EAAE;QACjB,IAAI,IAAI,CAACA,UAAU,GAAG,CAAC,EAAE;UACrB,IAAI,CAACJ,WAAW,CAACyB,CAAC,CAAC,GAAG,IAAI,CAACzB,WAAW,CAAC,IAAI,CAACI,UAAU,CAAC;UACvD,IAAI,CAACP,OAAO,CAAC4B,CAAC,CAAC,GAAG,IAAI,CAAC5B,OAAO,CAAC,IAAI,CAACO,UAAU,CAAC;UAC/C,IAAI,CAACJ,WAAW,CAAC,IAAI,CAACI,UAAU,CAAC,GAAG,IAAI;UACxC,IAAI,CAACP,OAAO,CAAC,IAAI,CAACO,UAAU,CAAC,GAAG,IAAI;SACvC,MAAM;UACH,IAAI,CAACJ,WAAW,CAAC,CAAC,CAAC,GAAG,IAAI;UAC1B,IAAI,CAACH,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI;;QAE1ByH,OAAO,GAAG,IAAI;QACd;;;IAIR,IAAIA,OAAO,IAAI,IAAI,CAAClH,UAAU,KAAK,CAAC,EAAE;MAClC,IAAI,CAACM,MAAM,CAACkH,sBAAsB,CAAC,IAAI,CAAChB,eAAe,CAAC;;EAEhE;EAEOkB,WAAWA,CAAC7F,IAA2B;IAC1C,IAAI,CAACA,IAAI,IAAI,CAAC,IAAI,CAACvB,MAAM,IAAI,CAAC,IAAI,CAACM,aAAa,EAAE;MAC9C;;IAEJ,IAAIsG,OAAO,GAAG,KAAK;IACnB,MAAMpG,iBAAiB,GAAG,IAAI,CAACF,aAAa,CAACE,iBAAiB;IAE9D,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACpB,iBAAiB,EAAEoB,CAAC,EAAE,EAAE;MAC7C,IAAI,IAAI,CAAC3B,cAAc,CAAC2B,CAAC,CAAC,KAAKQ,IAAI,EAAE;QACjC,MAAMF,IAAI,GAAG,IAAI,CAAC9B,cAAc,CAACwB,CAAC,CAAC;QAEnC,IAAI,CAACM,IAAI,EAAE;UACP;;QAGJb,iBAAiB,CAACqG,UAAU,CAACxF,IAAI,CAAC;QAClCA,IAAI,CAACyF,OAAO,EAAE;QAEd,IAAI,CAAC1H,cAAc,CAAC6H,MAAM,CAAClG,CAAC,EAAE,CAAC,CAAC;QAChC,IAAI,CAACxB,cAAc,CAAC0H,MAAM,CAAClG,CAAC,EAAE,CAAC,CAAC;QAEhC,IAAI,CAACpB,iBAAiB,EAAE;QAExBiH,OAAO,GAAG,IAAI;QACd;;;IAIR,IAAIA,OAAO,IAAI,IAAI,CAACjH,iBAAiB,KAAK,CAAC,EAAE;MACzC,IAAI,CAACK,MAAM,CAACkH,sBAAsB,CAAC,IAAI,CAACV,sBAAsB,CAAC;;EAEvE;EAEA;;;;EAIOa,cAAcA,CAAC3D,UAAuC;IACzD,IAAI,CAACA,UAAU,IAAI,CAAC,IAAI,CAAC1D,MAAM,IAAI,CAAC,IAAI,CAACM,aAAa,EAAE;MACpD;;IAEJ,IAAIsG,OAAO,GAAG,KAAK;IACnB,MAAMpG,iBAAiB,GAAG,IAAI,CAACF,aAAa,CAACE,iBAAiB;IAE9D,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACnB,eAAe,EAAEmB,CAAC,EAAE,EAAE;MAC3C,IAAI,IAAI,CAAC1B,YAAY,CAAC0B,CAAC,CAAC,KAAK2C,UAAU,EAAE;QACrC,MAAMrC,IAAI,GAAG,IAAI,CAAC7B,iBAAiB,CAACuB,CAAC,CAAC;QAEtC,IAAI,CAACM,IAAI,EAAE;UACP;;QAGJb,iBAAiB,CAACqG,UAAU,CAACxF,IAAI,CAAC;QAClCA,IAAI,CAACyF,OAAO,EAAE;QAEd,IAAI,CAACzH,YAAY,CAAC4H,MAAM,CAAClG,CAAC,EAAE,CAAC,CAAC;QAC9B,IAAI,CAACvB,iBAAiB,CAACyH,MAAM,CAAClG,CAAC,EAAE,CAAC,CAAC;QAEnC,IAAI,CAACnB,eAAe,EAAE;QAEtB,IAAI,IAAI,CAACA,eAAe,GAAG,CAAC,EAAE;UAC1B,IAAI,CAACP,YAAY,CAAC0B,CAAC,CAAC,GAAG,IAAI,CAAC1B,YAAY,CAAC,IAAI,CAACO,eAAe,CAAC;UAC9D,IAAI,CAACJ,iBAAiB,CAACuB,CAAC,CAAC,GAAG,IAAI,CAACvB,iBAAiB,CAAC,IAAI,CAACI,eAAe,CAAC;UACxE,IAAI,CAACP,YAAY,CAAC,IAAI,CAACO,eAAe,CAAC,GAAG,IAAI;UAC9C,IAAI,CAACJ,iBAAiB,CAAC,IAAI,CAACI,eAAe,CAAC,GAAG,IAAI;SACtD,MAAM;UACH,IAAI,CAACP,YAAY,CAAC,CAAC,CAAC,GAAG,IAAI;UAC3B,IAAI,CAACG,iBAAiB,CAAC,CAAC,CAAC,GAAG,IAAI;;QAGpCoH,OAAO,GAAG,IAAI;QACd;;;IAIR,IAAIA,OAAO,IAAI,IAAI,CAAChH,eAAe,KAAK,CAAC,EAAE;MACvC,IAAI,CAACI,MAAM,CAACkH,sBAAsB,CAAC,IAAI,CAACP,yBAAyB,CAAC;;EAE1E;EAEQW,iBAAiBA,CAACtI,KAAY;IAClC,IAAI,CAAC,IAAI,CAACuI,cAAc,EAAE;MACtB,IAAI,CAACA,cAAc,GAAG,IAAIpJ,gBAAgB,CAAC,EAAE,EAAEa,KAAK,CAAC;MACrD,IAAI,CAACuI,cAAc,CAACC,SAAS,GAAG,IAAI;MACpC,IAAI,CAACD,cAAc,CAACE,aAAa,GAAGzJ,MAAM,CAAC0J,KAAK,EAAE;MAClD,IAAI,CAACH,cAAc,CAACI,eAAe,GAAG,IAAI;;IAG9C,OAAO,IAAI,CAACJ,cAAc;EAC9B;EAEQK,wBAAwBA,CAAC5I,KAAY;IACzC,IAAI,CAAC,IAAI,CAAC6I,qBAAqB,EAAE;MAC7B,IAAI,CAACA,qBAAqB,GAAG,IAAI1J,gBAAgB,CAAC,EAAE,EAAEa,KAAK,CAAC;MAC5D,IAAI,CAAC6I,qBAAqB,CAACF,eAAe,GAAG,IAAI;MACjD,IAAI,CAACE,qBAAqB,CAACC,KAAK,GAAG,GAAG;;IAG1C,OAAO,IAAI,CAACD,qBAAqB;EACrC;EAEQE,gBAAgBA,CAAC/I,KAAY;IACjC,IAAI,CAAC,IAAI,CAACgJ,aAAa,EAAE;MACrB,IAAI,CAACA,aAAa,GAAGtK,SAAS,CAAC,wBAAwB,EAAE;QAAEuK,IAAI,EAAE;MAAC,CAAE,EAAEjJ,KAAK,CAAC;MAC5E,IAAI,CAACgJ,aAAa,CAAC/E,kBAAkB,GAAGpF,UAAU,CAACiE,QAAQ,EAAE;MAC7D,IAAI,CAACkG,aAAa,CAACE,QAAQ,GAAG,IAAI,CAACZ,iBAAiB,CAACtI,KAAK,CAAC;MAC3D,IAAI,CAACgJ,aAAa,CAACG,UAAU,CAAC,KAAK,CAAC;;IAGxC,OAAO,IAAI,CAACH,aAAa,CAACI,cAAc,CAAC,4BAA4B,CAAC;EAC1E;EAEQC,mBAAmBA,CAACrJ,KAAY;IACpC,IAAI,CAAC,IAAI,CAACsJ,gBAAgB,EAAE;MACxB,IAAI,CAACA,gBAAgB,GAAG3K,YAAY,CAAC,2BAA2B,EAAE;QAAE4K,QAAQ,EAAE;MAAC,CAAE,EAAEvJ,KAAK,CAAC;MACzF,IAAI,CAACsJ,gBAAgB,CAACrF,kBAAkB,GAAGpF,UAAU,CAACiE,QAAQ,EAAE;MAChE,IAAI,CAACwG,gBAAgB,CAACJ,QAAQ,GAAG,IAAI,CAACZ,iBAAiB,CAACtI,KAAK,CAAC;MAC9D,IAAI,CAACsJ,gBAAgB,CAACH,UAAU,CAAC,KAAK,CAAC;;IAG3C,OAAO,IAAI,CAACG,gBAAgB,CAACF,cAAc,CAAC,+BAA+B,CAAC;EAChF;EAEQI,oBAAoBA,CAACxJ,KAAY;IACrC,IAAI,CAAC,IAAI,CAACyJ,iBAAiB,EAAE;MACzB,IAAI,CAACA,iBAAiB,GAAGlK,aAAa,CAAC,4BAA4B,EAAE;QAAEmK,MAAM,EAAE;MAAC,CAA2B,EAAE1J,KAAK,CAAC;MACnH,IAAI,CAACyJ,iBAAiB,CAACxF,kBAAkB,GAAGpF,UAAU,CAACiE,QAAQ,EAAE;MACjE,IAAI,CAAC2G,iBAAiB,CAACP,QAAQ,GAAG,IAAI,CAACZ,iBAAiB,CAACtI,KAAK,CAAC;MAC/D,IAAI,CAACyJ,iBAAiB,CAACN,UAAU,CAAC,KAAK,CAAC;;IAG5C,OAAO,IAAI,CAACM,iBAAiB,CAACL,cAAc,CAAC,gCAAgC,CAAC;EAClF;EAEQO,qBAAqBA,CAAC3J,KAAY;IACtC,IAAI,CAAC,IAAI,CAAC4J,kBAAkB,EAAE;MAC1B,IAAI,CAACA,kBAAkB,GAAGtK,cAAc,CAAC,6BAA6B,EAAE;QAAEuK,WAAW,EAAE,CAAC;QAAEC,cAAc,EAAE,CAAC;QAAEJ,MAAM,EAAE;MAAC,CAAE,EAAE1J,KAAK,CAAC;MAChI,IAAI,CAAC4J,kBAAkB,CAAC3F,kBAAkB,GAAGpF,UAAU,CAACiE,QAAQ,EAAE;MAClE,IAAI,CAAC8G,kBAAkB,CAACV,QAAQ,GAAG,IAAI,CAACZ,iBAAiB,CAACtI,KAAK,CAAC;MAChE,IAAI,CAAC4J,kBAAkB,CAACT,UAAU,CAAC,KAAK,CAAC;;IAG7C,OAAO,IAAI,CAACS,kBAAkB,CAACR,cAAc,CAAC,iCAAiC,CAAC;EACpF;EAEQW,iBAAiBA,CAAC1H,IAAU,EAAErC,KAAY;IAC9C,MAAMgK,aAAa,GAAG,IAAIvL,IAAI,CAAC4D,IAAI,CAAC4H,IAAI,EAAEjK,KAAK,EAAE,IAAI,EAAEqC,IAAI,CAAC;IAC5D2H,aAAa,CAACE,SAAS,CAAC7H,IAAI,CAAC;IAC7B2H,aAAa,CAAC5F,QAAQ,GAAGrF,OAAO,CAACoL,IAAI,EAAE;IACvCH,aAAa,CAACd,QAAQ,GAAG,IAAI,CAACZ,iBAAiB,CAACtI,KAAK,CAAC;IAEtD,IAAI,CAACa,gBAAgB,CAACuJ,IAAI,CAACJ,aAAa,CAAC;IAEzC,OAAOA,aAAa;EACxB;EAEQ/C,aAAaA,CAACjF,QAAyB,EAAE+E,UAAiB;IAC9D,IAAI,CAAC,IAAI,CAACzF,aAAa,EAAE;MACrB,OAAO,IAAI;;IAGf;IACA,IAAIyF,UAAU,IAAIA,UAAU,CAAC1C,MAAM,IAAK0C,UAAU,CAAC1C,MAAe,CAACgG,eAAe,EAAE;MAChF,OAAO,IAAI;;IAGf,IAAIhI,IAAI,GAA2B,IAAI;IACvC,MAAMb,iBAAiB,GAAG,IAAI,CAACF,aAAa,CAACE,iBAAiB;IAC9D,IAAI,CAACQ,QAAQ,CAACsI,WAAW,EAAE;MACvB9K,MAAM,CAAC+K,IAAI,CAAC,gGAAgG,CAAC;MAC7G,OAAO,IAAI;;IAEf,QAAQvI,QAAQ,CAACG,IAAI;MACjB,KAAK/C,eAAe,CAACoL,WAAW;QAC5BnI,IAAI,GAAG,IAAI,CAAC0G,gBAAgB,CAACvH,iBAAiB,CAAC;QAC/CQ,QAAQ,CAACyI,eAAe,CAACpI,IAAI,CAACwC,OAAO,CAAC;QACtC;MACJ,KAAKzF,eAAe,CAACsL,cAAc;QAAE;UACjCrI,IAAI,GAAG,IAAI,CAACgH,mBAAmB,CAAC7H,iBAAiB,CAAC;UAClD,MAAMmJ,MAAM,GAAG3I,QAAQ,CAAC4I,SAAS,EAAE;UACnCvI,IAAI,CAACwC,OAAO,CAACG,CAAC,GAAG2F,MAAM,GAAG,CAAC;UAC3BtI,IAAI,CAACwC,OAAO,CAACK,CAAC,GAAGyF,MAAM,GAAG,CAAC;UAC3BtI,IAAI,CAACwC,OAAO,CAACM,CAAC,GAAGwF,MAAM,GAAG,CAAC;UAC3B;;MAEJ,KAAKvL,eAAe,CAACyL,eAAe;QAAE;UAClCxI,IAAI,GAAG,IAAI,CAACmH,oBAAoB,CAAChI,iBAAiB,CAAC;UACnD,MAAMsJ,EAAE,GAAG9I,QAAQ,CAAC+I,MAAM,CAACC,eAAe,EAAE;UAC5C3I,IAAI,CAACwC,OAAO,CAACG,CAAC,GAAG,CAAC8F,EAAE,CAACG,WAAW,CAACC,OAAO,CAAClG,CAAC,GAAG8F,EAAE,CAACG,WAAW,CAACE,OAAO,CAACnG,CAAC,IAAI,CAAC,GAAGhD,QAAQ,CAAC+I,MAAM,CAAClG,OAAO,CAACG,CAAC;UACtG3C,IAAI,CAACwC,OAAO,CAACK,CAAC,GAAG,CAAC4F,EAAE,CAACG,WAAW,CAACC,OAAO,CAAChG,CAAC,GAAG4F,EAAE,CAACG,WAAW,CAACE,OAAO,CAACjG,CAAC,IAAIlD,QAAQ,CAAC+I,MAAM,CAAClG,OAAO,CAACK,CAAC;UAClG7C,IAAI,CAACwC,OAAO,CAACM,CAAC,GAAG,CAAC2F,EAAE,CAACG,WAAW,CAACC,OAAO,CAAC/F,CAAC,GAAG2F,EAAE,CAACG,WAAW,CAACE,OAAO,CAAChG,CAAC,IAAI,CAAC,GAAGnD,QAAQ,CAAC+I,MAAM,CAAClG,OAAO,CAACM,CAAC;UACtG;;MAEJ,KAAK/F,eAAe,CAACgD,YAAY;QAC7B,IAAI2E,UAAU,EAAE;UACZ1E,IAAI,GAAG,IAAI,CAAC0H,iBAAiB,CAAChD,UAAU,EAAEvF,iBAAiB,CAAC;;QAEhE;MACJ,KAAKpC,eAAe,CAACgM,UAAU;QAC3B,IAAIrE,UAAU,EAAE;UACZ;UACA,MAAMsE,WAAW,GAAGtE,UAAU,CAACuE,cAAc,EAAE,CAACC,MAAM,CAAEC,CAAC,IAAI;YACzD,OAAOA,CAAC,CAACnB,eAAe,GAAG,CAAC,GAAG,CAAC;UACpC,CAAC,CAAC;UACFgB,WAAW,CAACxF,OAAO,CAAE4F,CAAC,IAAI;YACtB,IAAIA,CAAC,CAACpB,eAAe,IAAIoB,CAAC,CAACC,YAAY,EAAE,KAAK,MAAM,EAAE;cAClD,MAAMC,YAAY,GAAGF,CAAC,CAACT,eAAe,EAAE;cACxC,MAAMY,GAAG,GAAGD,YAAY,CAACV,WAAW,CAACE,OAAO;cAC5C,MAAMU,GAAG,GAAGF,YAAY,CAACV,WAAW,CAACC,OAAO;cAC5C,QAAQO,CAAC,CAACpB,eAAe,CAAClI,IAAI;gBAC1B,KAAK/C,eAAe,CAACoL,WAAW;kBAC5BnI,IAAI,GAAG,IAAI,CAAC0G,gBAAgB,CAACvH,iBAAiB,CAAC;kBAC/Ca,IAAI,CAAC+B,QAAQ,CAACqC,QAAQ,CAACmF,GAAG,CAAC;kBAC3BvJ,IAAI,CAAC+B,QAAQ,CAAC0H,UAAU,CAACD,GAAG,CAAC;kBAC7BxJ,IAAI,CAAC+B,QAAQ,CAAC2H,YAAY,CAAC,GAAG,CAAC;kBAC/B;gBACJ,KAAK3M,eAAe,CAACsL,cAAc;kBAC/BrI,IAAI,GAAG,IAAI,CAACgH,mBAAmB,CAAC7H,iBAAiB,CAAC;kBAClD;gBACJ,KAAKpC,eAAe,CAAC4M,gBAAgB;kBACjC3J,IAAI,GAAG,IAAI,CAACsH,qBAAqB,CAACnI,iBAAiB,CAAC;kBACpD;gBACJ;kBACIa,IAAI,GAAG,IAAI;kBACX;;cAER,IAAIA,IAAI,EAAE;gBACNA,IAAI,CAACwC,OAAO,CAACG,CAAC,GAAG6G,GAAG,CAAC7G,CAAC,GAAG4G,GAAG,CAAC5G,CAAC;gBAC9B3C,IAAI,CAACwC,OAAO,CAACK,CAAC,GAAG2G,GAAG,CAAC3G,CAAC,GAAG0G,GAAG,CAAC1G,CAAC;gBAC9B7C,IAAI,CAACwC,OAAO,CAACM,CAAC,GAAG0G,GAAG,CAAC1G,CAAC,GAAGyG,GAAG,CAACzG,CAAC;gBAC9B9C,IAAI,CAACgC,MAAM,GAAGoH,CAAC;;;UAG3B,CAAC,CAAC;SACL,MAAM;UACHjM,MAAM,CAAC+K,IAAI,CAAC,6DAA6D,CAAC;;QAE9ElI,IAAI,GAAG,IAAI;QACX;MACJ,KAAKjD,eAAe,CAAC4M,gBAAgB;QAAE;UACnC3J,IAAI,GAAG,IAAI,CAACsH,qBAAqB,CAACnI,iBAAiB,CAAC;UACpD,MAAMsJ,EAAE,GAAG9I,QAAQ,CAAC+I,MAAM,CAACC,eAAe,EAAE;UAC5C3I,IAAI,CAACwC,OAAO,CAACG,CAAC,GAAG,CAAC8F,EAAE,CAACG,WAAW,CAACC,OAAO,CAAClG,CAAC,GAAG8F,EAAE,CAACG,WAAW,CAACE,OAAO,CAACnG,CAAC,IAAIhD,QAAQ,CAAC+I,MAAM,CAAClG,OAAO,CAACG,CAAC;UAClG3C,IAAI,CAACwC,OAAO,CAACK,CAAC,GAAG,CAAC4F,EAAE,CAACG,WAAW,CAACC,OAAO,CAAChG,CAAC,GAAG4F,EAAE,CAACG,WAAW,CAACE,OAAO,CAACjG,CAAC,IAAIlD,QAAQ,CAAC+I,MAAM,CAAClG,OAAO,CAACK,CAAC;UAClG7C,IAAI,CAACwC,OAAO,CAACM,CAAC,GAAG,CAAC2F,EAAE,CAACG,WAAW,CAACC,OAAO,CAAC/F,CAAC,GAAG2F,EAAE,CAACG,WAAW,CAACE,OAAO,CAAChG,CAAC,IAAInD,QAAQ,CAAC+I,MAAM,CAAClG,OAAO,CAACM,CAAC;UAClG;;;IAGR,OAAO9C,IAAI;EACf;EAEA;;;;;;;;;;EAUQgF,iBAAiBA,CAAC9E,IAAiB;IACvC,IAAI,CAAC,IAAI,CAACjB,aAAa,EAAE;MACrB,OAAO,IAAI;;IAGf,MAAME,iBAAiB,GAAG,IAAI,CAACF,aAAa,CAACE,iBAAiB;IAE9D,MAAMa,IAAI,GAAG,IAAI5D,IAAI,CAAC,QAAQ,EAAE+C,iBAAiB,CAAC;IAClD,MAAMyK,UAAU,GAAG,IAAIxM,UAAU,EAAE;IACnC,MAAMyM,QAAQ,GAAG3J,IAAI,CAAC4J,WAAW,EAAS;IAC1CF,UAAU,CAACG,SAAS,GAAGF,QAAQ,CAACE,SAAS;IACzCH,UAAU,CAACI,OAAO,GAAGH,QAAQ,CAACG,OAAO;IACrCJ,UAAU,CAACK,WAAW,CAACjK,IAAI,CAAC;IAC5B,IAAIE,IAAI,CAACU,oBAAoB,EAAE;MAC3B,MAAMsJ,cAAc,GAAG,IAAIC,YAAY,CAACjK,IAAI,CAACU,oBAAoB,CAACC,MAAM,GAAG,EAAE,CAAC;MAC9Eb,IAAI,CAACoK,qBAAqB,CAAC,QAAQ,EAAEF,cAAc,EAAE,EAAE,CAAC;;IAE5DlK,IAAI,CAAC6G,QAAQ,GAAG,IAAI,CAACZ,iBAAiB,CAAC9G,iBAAiB,CAAC;IACzD,OAAOa,IAAI;EACf;EAEQsB,+BAA+BA,CAAC+I,SAAgC,EAAEC,MAAc;;IACpF,MAAMC,WAAW,GAAG,CAAA5I,EAAA,GAAA0I,SAAS,CAACG,kBAAkB,cAAA7I,EAAA,cAAAA,EAAA,GAAInF,UAAU,CAACiE,QAAQ,EAAE;IACzE,MAAMgK,YAAY,GAAG,CAAAC,EAAA,GAAAL,SAAS,CAACM,OAAO,cAAAD,EAAA,cAAAA,EAAA,GAAIhO,OAAO,CAACoL,IAAI,EAAE;IACxD,MAAM8C,MAAM,GAAG,CAAAC,EAAA,GAAAR,SAAS,CAACS,YAAY,cAAAD,EAAA,cAAAA,EAAA,GAAInO,OAAO,CAACoL,IAAI,EAAE;IAEvD,MAAMiD,QAAQ,GAAG,CAACN,YAAY,CAAC9H,CAAC,GAAG8H,YAAY,CAAC5H,CAAC,GAAG4H,YAAY,CAAC3H,CAAC,IAAI,CAAC;IACvE,MAAMkI,IAAI,GAAGvI,IAAI,CAACwI,IAAI,CAACxI,IAAI,CAAC+G,GAAG,CAACuB,QAAQ,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IAE/C,MAAMG,SAAS,GAAGT,YAAY,CAAC9H,CAAC,GAAG,EAAE,GAAGoI,QAAQ;IAChD,MAAMI,KAAK,GAAG1I,IAAI,CAACwI,IAAI,CAACxI,IAAI,CAAC+G,GAAG,CAAC0B,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IAEjD,MAAME,SAAS,GAAGX,YAAY,CAAC3H,CAAC,GAAG,EAAE,GAAGiI,QAAQ;IAChD,MAAMtE,KAAK,GAAGhE,IAAI,CAACwI,IAAI,CAACxI,IAAI,CAAC+G,GAAG,CAAC4B,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IAEjD,MAAMC,OAAO,GAAG5O,UAAU,CAACC,OAAO,CAAC,CAAC,CAAC;IACrC2O,OAAO,CAACC,GAAG,CAAC7E,KAAK,EAAEuE,IAAI,EAAEG,KAAK,CAAC;IAE/B,MAAM3I,OAAO,GAAGjG,MAAM,CAACgP,YAAY,CAACF,OAAO,CAAC1I,CAAC,EAAE0I,OAAO,CAACxI,CAAC,EAAEwI,OAAO,CAACvI,CAAC,EAAErG,UAAU,CAACF,MAAM,CAAC,CAAC,CAAC,CAAC;IAC1F,MAAMiP,QAAQ,GAAGjB,WAAW,CAAC1I,gBAAgB,CAACpF,UAAU,CAACF,MAAM,CAAC,CAAC,CAAC,CAAC;IACnE,MAAMkP,WAAW,GAAGlP,MAAM,CAACmP,gBAAgB,CAACd,MAAM,CAACjI,CAAC,EAAEiI,MAAM,CAAC/H,CAAC,EAAE+H,MAAM,CAAC9H,CAAC,EAAErG,UAAU,CAACF,MAAM,CAAC,CAAC,CAAC,CAAC;IAE/FiG,OAAO,CAAChB,aAAa,CAACgK,QAAQ,EAAElB,MAAM,CAAC;IACvCA,MAAM,CAAC9I,aAAa,CAACiK,WAAW,EAAEnB,MAAM,CAAC;IAEzC,OAAOA,MAAM;EACjB;EAEQpF,oBAAoBA,CAAChF,IAAiB;IAC1C,IAAI,CAAC,IAAI,CAACjB,aAAa,EAAE;MACrB,OAAO,IAAI;;IAEf,MAAME,iBAAiB,GAAG,IAAI,CAACF,aAAa,CAACE,iBAAiB;IAE9D;IACA,MAAMwM,cAAc,GAAGtO,WAAW,CAAChB,SAAS,CAAC,QAAQ,EAAE;MAAEuK,IAAI,EAAE;IAAC,CAAE,EAAEzH,iBAAiB,CAAC;IACtF,MAAMyM,SAAS,GAAGrP,MAAM,CAACkE,QAAQ,EAAE;IACnC,IAAIP,IAAI,CAACU,oBAAoB,CAACC,MAAM,EAAE;MAClC,MAAMqJ,cAAc,GAAG,IAAIC,YAAY,CAACjK,IAAI,CAACU,oBAAoB,CAACC,MAAM,GAAG,EAAE,CAAC;MAC9E,KAAK,IAAInB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGQ,IAAI,CAACU,oBAAoB,CAACC,MAAM,EAAE,EAAEnB,CAAC,EAAE;QACvD,MAAM0B,KAAK,GAAGlB,IAAI,CAACmB,iBAAiB,CAAC3B,CAAC,CAAC;QACvC,IAAI,CAAC4B,+BAA+B,CAACF,KAAK,EAAEwK,SAAS,CAAC;QACtDA,SAAS,CAACnK,WAAW,CAACyI,cAAc,EAAExK,CAAC,GAAG,EAAE,CAAC;;MAEjDiM,cAAc,CAACvB,qBAAqB,CAAC,QAAQ,EAAEF,cAAc,EAAE,EAAE,CAAC;KACrE,MAAM;MACH,MAAM9I,KAAK,GAAGlB,IAAI,CAACmB,iBAAiB,EAAE;MACtC,IAAI,CAACC,+BAA+B,CAACF,KAAK,EAAEwK,SAAS,CAAC;MACtDA,SAAS,CAACzJ,wBAAwB,CAACwJ,cAAc,CAAC;;IAEtDA,cAAc,CAACE,oBAAoB,EAAE;IACrCF,cAAc,CAACG,UAAU,GAAG,GAAG;IAC/BH,cAAc,CAACI,UAAU,GAAG,IAAInP,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAClD+O,cAAc,CAAC9E,QAAQ,GAAG,IAAI,CAACN,wBAAwB,CAACpH,iBAAiB,CAAC;IAE1E,OAAOwM,cAAc;EACzB;EAEQ1H,0BAA0BA,CAAC/D,IAAiB,EAAEoK,MAAc,EAAE0B,aAAsB;IACxF,MAAMC,KAAK,GAAG/L,IAAI,CAACiB,aAAa;IAChC,IAAI6K,aAAa,IAAIA,aAAa,IAAI,CAAC,EAAE;MACrC,OAAOzP,MAAM,CAACgF,cAAc,CAAE0K,KAAc,CAACjL,wBAAwB,CAACC,UAAW,EAAE+K,aAAa,EAAE1B,MAAM,CAAC;KAC5G,MAAM;MACH,OAAOA,MAAM,CAAClG,QAAQ,CAAC6H,KAAK,CAACC,cAAc,EAAE,CAAC;;EAEtD;EAEQ7G,uBAAuBA,CAAChD,UAA6B;IACzD,IAAI,CAAC,IAAI,CAACpD,aAAa,EAAE;MACrB,OAAO,IAAI;;IAEf,MAAME,iBAAiB,GAAG,IAAI,CAACF,aAAa,CAACE,iBAAiB;IAE9D,IAAI,CAACkD,UAAU,CAACW,YAAY,EAAE;MAC1B,OAAO,IAAI;;IAGf;IACA,MAAM;MAAEC,MAAM;MAAEC,MAAM;MAAEC,KAAK;MAAEC,KAAK;MAAEC,SAAS;MAAEC;IAAS,CAAE,GAAGjB,UAAU,CAACW,YAAY;IAEtF,IAAI,CAACC,MAAM,IAAI,CAACC,MAAM,IAAI,CAACC,KAAK,IAAI,CAACC,KAAK,IAAI,CAACC,SAAS,IAAI,CAACC,SAAS,EAAE;MACpE,OAAO,IAAI;;IAGf;IACA,MAAMP,aAAa,GAAG,IAAI3G,IAAI,CAAC,0BAA0B,EAAE+C,iBAAiB,CAAC;IAE7E;IACA,MAAMgN,qBAAqB,GAAG9J,UAAU,CAAC+J,wBAAwB,EAAE;IAEnE,KAAK,MAAMC,YAAY,IAAIF,qBAAqB,EAAE;MAC9C;MACA,MAAMG,YAAY,GAAG,IAAI/O,aAAa,CAAC,cAAc,EAAE4B,iBAAiB,CAAC;MACzEmN,YAAY,CAACtK,MAAM,GAAGe,aAAa;MAEnC,MAAM;QAAEa,UAAU;QAAEC,eAAe;QAAEE,SAAS;QAAEC;MAAc,CAAE,GAAGqI,YAAY;MAC/E;MAEA,MAAMpK,eAAe,GAAG,IAAI,CAACgC,0BAA0B,CAACL,UAAU,EAAEnH,UAAU,CAACF,MAAM,CAAC,CAAC,CAAC,EAAEsH,eAAe,CAAC;MAC1G,MAAMK,cAAc,GAAG,IAAI,CAACD,0BAA0B,CAACF,SAAS,EAAEtH,UAAU,CAACF,MAAM,CAAC,CAAC,CAAC,EAAEyH,cAAc,CAAC;MAEvG,MAAMN,qBAAqB,GAAG,IAAInG,aAAa,CAAC,mBAAmB,EAAE4B,iBAAiB,CAAC;MACvF;MACAuE,qBAAqB,CAAC1B,MAAM,GAAGsK,YAAY;MAC3C;MACA5I,qBAAqB,CAACI,QAAQ,GAAG;QAAEF,UAAU;QAAEC;MAAe,CAAE;MAChE5B,eAAe,CAACE,wBAAwB,CAACuB,qBAAqB,CAAC;MAE/D,MAAMC,oBAAoB,GAAG,IAAIpG,aAAa,CAAC,kBAAkB,EAAE4B,iBAAiB,CAAC;MACrF;MACAwE,oBAAoB,CAAC3B,MAAM,GAAGsK,YAAY;MAC1C;MACA3I,oBAAoB,CAACG,QAAQ,GAAG;QAAEC,SAAS;QAAEC;MAAc,CAAE;MAC7DE,cAAc,CAAC/B,wBAAwB,CAACwB,oBAAoB,CAAC;MAE7D;MACA,MAAM4I,kBAAkB,GAAG/P,UAAU,CAACgQ,kBAAkB,CAACjQ,MAAM,CAACgI,gBAAgB,CAACpB,KAAK,EAAEE,SAAS,EAAEF,KAAK,CAACsJ,KAAK,CAACpJ,SAAS,CAAC,EAAE5G,UAAU,CAACF,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;MACjJ,MAAMmQ,iBAAiB,GAAGlQ,UAAU,CAACgQ,kBAAkB,CAACjQ,MAAM,CAACgI,gBAAgB,CAACnB,KAAK,EAAEE,SAAS,EAAEF,KAAK,CAACqJ,KAAK,CAACnJ,SAAS,CAAC,EAAE7G,UAAU,CAACF,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;MAEhJ,MAAMoQ,wBAAwB,GAAG1J,MAAM;MACvC,MAAM2J,uBAAuB,GAAG1J,MAAM;MAEtC;MACA,MAAMiB,mBAAmB,GAAG,IAAI5G,aAAa,CAAC,mBAAmB,EAAE4B,iBAAiB,CAAC;MACrFgF,mBAAmB,CAACpC,QAAQ,CAACqC,QAAQ,CAACuI,wBAAwB,CAAC;MAC/DxI,mBAAmB,CAACvC,kBAAkB,GAAG2K,kBAAkB;MAC3DpI,mBAAmB,CAACnC,MAAM,GAAG0B,qBAAqB;MAElD,MAAMW,kBAAkB,GAAG,IAAI9G,aAAa,CAAC,kBAAkB,EAAE4B,iBAAiB,CAAC;MACnFkF,kBAAkB,CAACrC,MAAM,GAAG2B,oBAAoB;MAChDU,kBAAkB,CAACtC,QAAQ,CAACqC,QAAQ,CAACwI,uBAAuB,CAAC;MAC7DvI,kBAAkB,CAACzC,kBAAkB,GAAG8K,iBAAiB;MAEzD;MACA,MAAMG,UAAU,GAAG,IAAIvP,UAAU,CAAC6B,iBAAiB,EAAE,IAAI,CAACT,mBAAmB,CAAC;MAC9EmO,UAAU,CAACC,KAAK,CAAC9K,MAAM,GAAGmC,mBAAmB;MAC7C0I,UAAU,CAACE,KAAK,CAAC/K,MAAM,GAAGmC,mBAAmB;MAC7C0I,UAAU,CAACG,KAAK,CAAChL,MAAM,GAAGmC,mBAAmB;MAE7C,MAAM8I,SAAS,GAAG,IAAI3P,UAAU,CAAC6B,iBAAiB,EAAE,IAAI,CAACT,mBAAmB,CAAC;MAC7EuO,SAAS,CAACH,KAAK,CAAC9K,MAAM,GAAGqC,kBAAkB;MAC3C4I,SAAS,CAACF,KAAK,CAAC/K,MAAM,GAAGqC,kBAAkB;MAC3C4I,SAAS,CAACD,KAAK,CAAChL,MAAM,GAAGqC,kBAAkB;;IAG/C,OAAOtB,aAAa;EACxB;EAEA;;;EAGO0C,OAAOA,CAAA;IACV;IACA,KAAK,IAAIC,KAAK,GAAG,IAAI,CAACtH,UAAU,GAAG,CAAC,EAAEsH,KAAK,IAAI,CAAC,EAAEA,KAAK,EAAE,EAAE;MACvD,IAAI,CAAC7F,YAAY,CAAC,IAAI,CAACjC,UAAU,CAAC,CAAC,CAAC,CAAC;;IAEzC;IACA,KAAK,IAAI8H,KAAK,GAAG,IAAI,CAACrH,UAAU,GAAG,CAAC,EAAEqH,KAAK,IAAI,CAAC,EAAEA,KAAK,EAAE,EAAE;MACvD,IAAI,CAACI,QAAQ,CAAC,IAAI,CAAChI,OAAO,CAAC,CAAC,CAAC,CAAC;;IAElC;IACA,KAAK,IAAI4H,KAAK,GAAG,IAAI,CAACpH,iBAAiB,GAAG,CAAC,EAAEoH,KAAK,IAAI,CAAC,EAAEA,KAAK,EAAE,EAAE;MAC9D,IAAI,CAACK,WAAW,CAAC,IAAI,CAAChI,cAAc,CAAC,CAAC,CAAC,CAAC;;IAG5C,IAAI,IAAI,CAAC4I,aAAa,EAAE;MACpB,IAAI,CAACA,aAAa,CAAClB,OAAO,EAAE;;IAEhC,IAAI,IAAI,CAACwB,gBAAgB,EAAE;MACvB,IAAI,CAACA,gBAAgB,CAACxB,OAAO,EAAE;;IAEnC,IAAI,IAAI,CAAC8B,kBAAkB,EAAE;MACzB,IAAI,CAACA,kBAAkB,CAAC9B,OAAO,EAAE;;IAErC,IAAI,IAAI,CAACS,cAAc,EAAE;MACrB,IAAI,CAACA,cAAc,CAACT,OAAO,EAAE;;IAGjC,IAAI,CAAC7H,UAAU,CAACiD,MAAM,GAAG,CAAC;IAC1B,IAAI,CAAClC,MAAM,GAAG,IAAI;IAClB,IAAI,CAACI,oBAAoB,GAAG,IAAI;IAEhC,IAAI,IAAI,CAACE,aAAa,EAAE;MACpB,IAAI,CAACA,aAAa,CAACwG,OAAO,EAAE;MAC5B,IAAI,CAACxG,aAAa,GAAG,IAAI;;EAEjC"},"metadata":{},"sourceType":"module","externalDependencies":[]}