{"ast":null,"code":"import { Size } from \"../../Maths/math.size.js\";\n/**\n * Base class of all the textures in babylon.\n * It groups all the common properties required to work with Thin Engine.\n */\nexport class ThinTexture {\n  /**\n   * | Value | Type               | Description |\n   * | ----- | ------------------ | ----------- |\n   * | 0     | CLAMP_ADDRESSMODE  |             |\n   * | 1     | WRAP_ADDRESSMODE   |             |\n   * | 2     | MIRROR_ADDRESSMODE |             |\n   */\n  get wrapU() {\n    return this._wrapU;\n  }\n  set wrapU(value) {\n    this._wrapU = value;\n  }\n  /**\n   * | Value | Type               | Description |\n   * | ----- | ------------------ | ----------- |\n   * | 0     | CLAMP_ADDRESSMODE  |             |\n   * | 1     | WRAP_ADDRESSMODE   |             |\n   * | 2     | MIRROR_ADDRESSMODE |             |\n   */\n  get wrapV() {\n    return this._wrapV;\n  }\n  set wrapV(value) {\n    this._wrapV = value;\n  }\n  /**\n   * How a texture is mapped.\n   * Unused in thin texture mode.\n   */\n  get coordinatesMode() {\n    return 0;\n  }\n  /**\n   * Define if the texture is a cube texture or if false a 2d texture.\n   */\n  get isCube() {\n    if (!this._texture) {\n      return false;\n    }\n    return this._texture.isCube;\n  }\n  set isCube(value) {\n    if (!this._texture) {\n      return;\n    }\n    this._texture.isCube = value;\n  }\n  /**\n   * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\n   */\n  get is3D() {\n    if (!this._texture) {\n      return false;\n    }\n    return this._texture.is3D;\n  }\n  set is3D(value) {\n    if (!this._texture) {\n      return;\n    }\n    this._texture.is3D = value;\n  }\n  /**\n   * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\n   */\n  get is2DArray() {\n    if (!this._texture) {\n      return false;\n    }\n    return this._texture.is2DArray;\n  }\n  set is2DArray(value) {\n    if (!this._texture) {\n      return;\n    }\n    this._texture.is2DArray = value;\n  }\n  /**\n   * Get the class name of the texture.\n   * @returns \"ThinTexture\"\n   */\n  getClassName() {\n    return \"ThinTexture\";\n  }\n  static _IsRenderTargetWrapper(texture) {\n    return (texture === null || texture === void 0 ? void 0 : texture._shareDepth) !== undefined;\n  }\n  /**\n   * Instantiates a new ThinTexture.\n   * Base class of all the textures in babylon.\n   * This can be used as an internal texture wrapper in ThinEngine to benefit from the cache\n   * @param internalTexture Define the internalTexture to wrap. You can also pass a RenderTargetWrapper, in which case the texture will be the render target's texture\n   */\n  constructor(internalTexture) {\n    this._wrapU = 1;\n    this._wrapV = 1;\n    /**\n     * | Value | Type               | Description |\n     * | ----- | ------------------ | ----------- |\n     * | 0     | CLAMP_ADDRESSMODE  |             |\n     * | 1     | WRAP_ADDRESSMODE   |             |\n     * | 2     | MIRROR_ADDRESSMODE |             |\n     */\n    this.wrapR = 1;\n    /**\n     * With compliant hardware and browser (supporting anisotropic filtering)\n     * this defines the level of anisotropic filtering in the texture.\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\n     */\n    this.anisotropicFilteringLevel = 4;\n    /**\n     * Define the current state of the loading sequence when in delayed load mode.\n     */\n    this.delayLoadState = 0;\n    /** @internal */\n    this._texture = null;\n    this._engine = null;\n    this._cachedSize = Size.Zero();\n    this._cachedBaseSize = Size.Zero();\n    /** @internal */\n    this._initialSamplingMode = 2;\n    this._texture = ThinTexture._IsRenderTargetWrapper(internalTexture) ? internalTexture.texture : internalTexture;\n    if (this._texture) {\n      this._engine = this._texture.getEngine();\n    }\n  }\n  /**\n   * Get if the texture is ready to be used (downloaded, converted, mip mapped...).\n   * @returns true if fully ready\n   */\n  isReady() {\n    if (this.delayLoadState === 4) {\n      this.delayLoad();\n      return false;\n    }\n    if (this._texture) {\n      return this._texture.isReady;\n    }\n    return false;\n  }\n  /**\n   * Triggers the load sequence in delayed load mode.\n   */\n  delayLoad() {}\n  /**\n   * Get the underlying lower level texture from Babylon.\n   * @returns the internal texture\n   */\n  getInternalTexture() {\n    return this._texture;\n  }\n  /**\n   * Get the size of the texture.\n   * @returns the texture size.\n   */\n  getSize() {\n    if (this._texture) {\n      if (this._texture.width) {\n        this._cachedSize.width = this._texture.width;\n        this._cachedSize.height = this._texture.height;\n        return this._cachedSize;\n      }\n      if (this._texture._size) {\n        this._cachedSize.width = this._texture._size;\n        this._cachedSize.height = this._texture._size;\n        return this._cachedSize;\n      }\n    }\n    return this._cachedSize;\n  }\n  /**\n   * Get the base size of the texture.\n   * It can be different from the size if the texture has been resized for POT for instance\n   * @returns the base size\n   */\n  getBaseSize() {\n    if (!this.isReady() || !this._texture) {\n      this._cachedBaseSize.width = 0;\n      this._cachedBaseSize.height = 0;\n      return this._cachedBaseSize;\n    }\n    if (this._texture._size) {\n      this._cachedBaseSize.width = this._texture._size;\n      this._cachedBaseSize.height = this._texture._size;\n      return this._cachedBaseSize;\n    }\n    this._cachedBaseSize.width = this._texture.baseWidth;\n    this._cachedBaseSize.height = this._texture.baseHeight;\n    return this._cachedBaseSize;\n  }\n  /**\n   * Get the current sampling mode associated with the texture.\n   */\n  get samplingMode() {\n    if (!this._texture) {\n      return this._initialSamplingMode;\n    }\n    return this._texture.samplingMode;\n  }\n  /**\n   * Update the sampling mode of the texture.\n   * Default is Trilinear mode.\n   *\n   * | Value | Type               | Description |\n   * | ----- | ------------------ | ----------- |\n   * | 1     | NEAREST_SAMPLINGMODE or NEAREST_NEAREST_MIPLINEAR  | Nearest is: mag = nearest, min = nearest, mip = linear |\n   * | 2     | BILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPNEAREST | Bilinear is: mag = linear, min = linear, mip = nearest |\n   * | 3     | TRILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPLINEAR | Trilinear is: mag = linear, min = linear, mip = linear |\n   * | 4     | NEAREST_NEAREST_MIPNEAREST |             |\n   * | 5    | NEAREST_LINEAR_MIPNEAREST |             |\n   * | 6    | NEAREST_LINEAR_MIPLINEAR |             |\n   * | 7    | NEAREST_LINEAR |             |\n   * | 8    | NEAREST_NEAREST |             |\n   * | 9   | LINEAR_NEAREST_MIPNEAREST |             |\n   * | 10   | LINEAR_NEAREST_MIPLINEAR |             |\n   * | 11   | LINEAR_LINEAR |             |\n   * | 12   | LINEAR_NEAREST |             |\n   *\n   *    > _mag_: magnification filter (close to the viewer)\n   *    > _min_: minification filter (far from the viewer)\n   *    > _mip_: filter used between mip map levels\n   *@param samplingMode Define the new sampling mode of the texture\n   */\n  updateSamplingMode(samplingMode) {\n    if (this._texture && this._engine) {\n      this._engine.updateTextureSamplingMode(samplingMode, this._texture);\n    }\n  }\n  /**\n   * Release and destroy the underlying lower level texture aka internalTexture.\n   */\n  releaseInternalTexture() {\n    if (this._texture) {\n      this._texture.dispose();\n      this._texture = null;\n    }\n  }\n  /**\n   * Dispose the texture and release its associated resources.\n   */\n  dispose() {\n    if (this._texture) {\n      this.releaseInternalTexture();\n      this._engine = null;\n    }\n  }\n}","map":{"version":3,"names":["Size","ThinTexture","wrapU","_wrapU","value","wrapV","_wrapV","coordinatesMode","isCube","_texture","is3D","is2DArray","getClassName","_IsRenderTargetWrapper","texture","_shareDepth","undefined","constructor","internalTexture","wrapR","anisotropicFilteringLevel","delayLoadState","_engine","_cachedSize","Zero","_cachedBaseSize","_initialSamplingMode","getEngine","isReady","delayLoad","getInternalTexture","getSize","width","height","_size","getBaseSize","baseWidth","baseHeight","samplingMode","updateSamplingMode","updateTextureSamplingMode","releaseInternalTexture","dispose"],"sources":["../../../../../dev/core/src/Materials/Textures/thinTexture.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\nimport type { ISize } from \"../../Maths/math.size\";\r\nimport { Size } from \"../../Maths/math.size\";\r\n\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport type { RenderTargetWrapper } from \"core/Engines/renderTargetWrapper\";\r\n\r\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties required to work with Thin Engine.\r\n */\r\nexport class ThinTexture {\r\n    protected _wrapU = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    public get wrapU() {\r\n        return this._wrapU;\r\n    }\r\n\r\n    public set wrapU(value: number) {\r\n        this._wrapU = value;\r\n    }\r\n\r\n    protected _wrapV = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    public get wrapV() {\r\n        return this._wrapV;\r\n    }\r\n\r\n    public set wrapV(value: number) {\r\n        this._wrapV = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    public wrapR = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n    /**\r\n     * With compliant hardware and browser (supporting anisotropic filtering)\r\n     * this defines the level of anisotropic filtering in the texture.\r\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n     */\r\n    public anisotropicFilteringLevel = 4;\r\n\r\n    /**\r\n     * Define the current state of the loading sequence when in delayed load mode.\r\n     */\r\n    public delayLoadState = Constants.DELAYLOADSTATE_NONE;\r\n\r\n    /**\r\n     * How a texture is mapped.\r\n     * Unused in thin texture mode.\r\n     */\r\n    public get coordinatesMode(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a cube texture or if false a 2d texture.\r\n     */\r\n    public get isCube(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.isCube;\r\n    }\r\n\r\n    protected set isCube(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.isCube = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    public get is3D(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is3D;\r\n    }\r\n\r\n    protected set is3D(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is3D = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    public get is2DArray(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is2DArray;\r\n    }\r\n\r\n    protected set is2DArray(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is2DArray = value;\r\n    }\r\n\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"ThinTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"ThinTexture\";\r\n    }\r\n\r\n    /** @internal */\r\n    public _texture: Nullable<InternalTexture> = null;\r\n\r\n    protected _engine: Nullable<ThinEngine> = null;\r\n\r\n    private _cachedSize: ISize = Size.Zero();\r\n    private _cachedBaseSize: ISize = Size.Zero();\r\n\r\n    private static _IsRenderTargetWrapper(texture: Nullable<InternalTexture> | Nullable<RenderTargetWrapper>): texture is RenderTargetWrapper {\r\n        return (texture as RenderTargetWrapper)?._shareDepth !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new ThinTexture.\r\n     * Base class of all the textures in babylon.\r\n     * This can be used as an internal texture wrapper in ThinEngine to benefit from the cache\r\n     * @param internalTexture Define the internalTexture to wrap. You can also pass a RenderTargetWrapper, in which case the texture will be the render target's texture\r\n     */\r\n    constructor(internalTexture: Nullable<InternalTexture | RenderTargetWrapper>) {\r\n        this._texture = ThinTexture._IsRenderTargetWrapper(internalTexture) ? internalTexture.texture : internalTexture;\r\n        if (this._texture) {\r\n            this._engine = this._texture.getEngine();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get if the texture is ready to be used (downloaded, converted, mip mapped...).\r\n     * @returns true if fully ready\r\n     */\r\n    public isReady(): boolean {\r\n        if (this.delayLoadState === Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            this.delayLoad();\r\n            return false;\r\n        }\r\n\r\n        if (this._texture) {\r\n            return this._texture.isReady;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Triggers the load sequence in delayed load mode.\r\n     */\r\n    public delayLoad(): void {}\r\n\r\n    /**\r\n     * Get the underlying lower level texture from Babylon.\r\n     * @returns the internal texture\r\n     */\r\n    public getInternalTexture(): Nullable<InternalTexture> {\r\n        return this._texture;\r\n    }\r\n\r\n    /**\r\n     * Get the size of the texture.\r\n     * @returns the texture size.\r\n     */\r\n    public getSize(): ISize {\r\n        if (this._texture) {\r\n            if (this._texture.width) {\r\n                this._cachedSize.width = this._texture.width;\r\n                this._cachedSize.height = this._texture.height;\r\n                return this._cachedSize;\r\n            }\r\n\r\n            if (this._texture._size) {\r\n                this._cachedSize.width = this._texture._size;\r\n                this._cachedSize.height = this._texture._size;\r\n                return this._cachedSize;\r\n            }\r\n        }\r\n\r\n        return this._cachedSize;\r\n    }\r\n\r\n    /**\r\n     * Get the base size of the texture.\r\n     * It can be different from the size if the texture has been resized for POT for instance\r\n     * @returns the base size\r\n     */\r\n    public getBaseSize(): ISize {\r\n        if (!this.isReady() || !this._texture) {\r\n            this._cachedBaseSize.width = 0;\r\n            this._cachedBaseSize.height = 0;\r\n            return this._cachedBaseSize;\r\n        }\r\n\r\n        if (this._texture._size) {\r\n            this._cachedBaseSize.width = this._texture._size;\r\n            this._cachedBaseSize.height = this._texture._size;\r\n            return this._cachedBaseSize;\r\n        }\r\n\r\n        this._cachedBaseSize.width = this._texture.baseWidth;\r\n        this._cachedBaseSize.height = this._texture.baseHeight;\r\n        return this._cachedBaseSize;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _initialSamplingMode = Constants.TEXTURE_BILINEAR_SAMPLINGMODE;\r\n\r\n    /**\r\n     * Get the current sampling mode associated with the texture.\r\n     */\r\n    public get samplingMode(): number {\r\n        if (!this._texture) {\r\n            return this._initialSamplingMode;\r\n        }\r\n\r\n        return this._texture.samplingMode;\r\n    }\r\n\r\n    /**\r\n     * Update the sampling mode of the texture.\r\n     * Default is Trilinear mode.\r\n     *\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 1     | NEAREST_SAMPLINGMODE or NEAREST_NEAREST_MIPLINEAR  | Nearest is: mag = nearest, min = nearest, mip = linear |\r\n     * | 2     | BILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPNEAREST | Bilinear is: mag = linear, min = linear, mip = nearest |\r\n     * | 3     | TRILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPLINEAR | Trilinear is: mag = linear, min = linear, mip = linear |\r\n     * | 4     | NEAREST_NEAREST_MIPNEAREST |             |\r\n     * | 5    | NEAREST_LINEAR_MIPNEAREST |             |\r\n     * | 6    | NEAREST_LINEAR_MIPLINEAR |             |\r\n     * | 7    | NEAREST_LINEAR |             |\r\n     * | 8    | NEAREST_NEAREST |             |\r\n     * | 9   | LINEAR_NEAREST_MIPNEAREST |             |\r\n     * | 10   | LINEAR_NEAREST_MIPLINEAR |             |\r\n     * | 11   | LINEAR_LINEAR |             |\r\n     * | 12   | LINEAR_NEAREST |             |\r\n     *\r\n     *    > _mag_: magnification filter (close to the viewer)\r\n     *    > _min_: minification filter (far from the viewer)\r\n     *    > _mip_: filter used between mip map levels\r\n     *@param samplingMode Define the new sampling mode of the texture\r\n     */\r\n    public updateSamplingMode(samplingMode: number): void {\r\n        if (this._texture && this._engine) {\r\n            this._engine.updateTextureSamplingMode(samplingMode, this._texture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release and destroy the underlying lower level texture aka internalTexture.\r\n     */\r\n    public releaseInternalTexture(): void {\r\n        if (this._texture) {\r\n            this._texture.dispose();\r\n            this._texture = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._texture) {\r\n            this.releaseInternalTexture();\r\n            this._engine = null;\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}