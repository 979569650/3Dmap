{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../tslib.es6.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { serialize, expandToProperty, serializeAsVector2, serializeAsTexture } from \"../../Misc/decorators.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { Vector2 } from \"../../Maths/math.vector.js\";\nimport { MaterialFlags } from \"../../Materials/materialFlags.js\";\nimport { MaterialHelper } from \"../../Materials/materialHelper.js\";\nimport { MaterialPluginBase } from \"../materialPluginBase.js\";\nimport { MaterialDefines } from \"../materialDefines.js\";\n/**\n * @internal\n */\nexport class MaterialAnisotropicDefines extends MaterialDefines {\n  constructor() {\n    super(...arguments);\n    this.ANISOTROPIC = false;\n    this.ANISOTROPIC_TEXTURE = false;\n    this.ANISOTROPIC_TEXTUREDIRECTUV = 0;\n    this.ANISOTROPIC_LEGACY = false;\n    this.MAINUV1 = false;\n  }\n}\n/**\n * Plugin that implements the anisotropic component of the PBR material\n */\nexport class PBRAnisotropicConfiguration extends MaterialPluginBase {\n  /**\n   * Sets the anisotropy direction as an angle.\n   */\n  set angle(value) {\n    this.direction.x = Math.cos(value);\n    this.direction.y = Math.sin(value);\n  }\n  /**\n   * Gets the anisotropy angle value in radians.\n   * @returns the anisotropy angle value in radians.\n   */\n  get angle() {\n    return Math.atan2(this.direction.y, this.direction.x);\n  }\n  /** @internal */\n  _markAllSubMeshesAsTexturesDirty() {\n    this._enable(this._isEnabled);\n    this._internalMarkAllSubMeshesAsTexturesDirty();\n  }\n  /** @internal */\n  _markAllSubMeshesAsMiscDirty() {\n    this._enable(this._isEnabled);\n    this._internalMarkAllSubMeshesAsMiscDirty();\n  }\n  constructor(material, addToPluginList = true) {\n    super(material, \"PBRAnisotropic\", 110, new MaterialAnisotropicDefines(), addToPluginList);\n    this._isEnabled = false;\n    /**\n     * Defines if the anisotropy is enabled in the material.\n     */\n    this.isEnabled = false;\n    /**\n     * Defines the anisotropy strength (between 0 and 1) it defaults to 1.\n     */\n    this.intensity = 1;\n    /**\n     * Defines if the effect is along the tangents, bitangents or in between.\n     * By default, the effect is \"stretching\" the highlights along the tangents.\n     */\n    this.direction = new Vector2(1, 0);\n    this._texture = null;\n    /**\n     * Stores the anisotropy values in a texture.\n     * rg is direction (like normal from -1 to 1)\n     * b is a intensity\n     */\n    this.texture = null;\n    this._legacy = false;\n    /**\n     * Defines if the anisotropy is in legacy mode for backwards compatibility before 6.4.0.\n     */\n    this.legacy = false;\n    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];\n    this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[16];\n  }\n  isReadyForSubMesh(defines, scene) {\n    if (!this._isEnabled) {\n      return true;\n    }\n    if (defines._areTexturesDirty) {\n      if (scene.texturesEnabled) {\n        if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n          if (!this._texture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n  prepareDefinesBeforeAttributes(defines, scene, mesh) {\n    if (this._isEnabled) {\n      defines.ANISOTROPIC = this._isEnabled;\n      if (this._isEnabled && !mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n        defines._needUVs = true;\n        defines.MAINUV1 = true;\n      }\n      if (defines._areTexturesDirty) {\n        if (scene.texturesEnabled) {\n          if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n            MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"ANISOTROPIC_TEXTURE\");\n          } else {\n            defines.ANISOTROPIC_TEXTURE = false;\n          }\n        }\n      }\n      if (defines._areMiscDirty) {\n        defines.ANISOTROPIC_LEGACY = this._legacy;\n      }\n    } else {\n      defines.ANISOTROPIC = false;\n      defines.ANISOTROPIC_TEXTURE = false;\n      defines.ANISOTROPIC_TEXTUREDIRECTUV = 0;\n      defines.ANISOTROPIC_LEGACY = false;\n    }\n  }\n  bindForSubMesh(uniformBuffer, scene) {\n    if (!this._isEnabled) {\n      return;\n    }\n    const isFrozen = this._material.isFrozen;\n    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\n      if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n        uniformBuffer.updateFloat2(\"vAnisotropyInfos\", this._texture.coordinatesIndex, this._texture.level);\n        MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"anisotropy\");\n      }\n      // Anisotropy\n      uniformBuffer.updateFloat3(\"vAnisotropy\", this.direction.x, this.direction.y, this.intensity);\n    }\n    // Textures\n    if (scene.texturesEnabled) {\n      if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n        uniformBuffer.setTexture(\"anisotropySampler\", this._texture);\n      }\n    }\n  }\n  hasTexture(texture) {\n    if (this._texture === texture) {\n      return true;\n    }\n    return false;\n  }\n  getActiveTextures(activeTextures) {\n    if (this._texture) {\n      activeTextures.push(this._texture);\n    }\n  }\n  getAnimatables(animatables) {\n    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\n      animatables.push(this._texture);\n    }\n  }\n  dispose(forceDisposeTextures) {\n    if (forceDisposeTextures) {\n      if (this._texture) {\n        this._texture.dispose();\n      }\n    }\n  }\n  getClassName() {\n    return \"PBRAnisotropicConfiguration\";\n  }\n  addFallbacks(defines, fallbacks, currentRank) {\n    if (defines.ANISOTROPIC) {\n      fallbacks.addFallback(currentRank++, \"ANISOTROPIC\");\n    }\n    return currentRank;\n  }\n  getSamplers(samplers) {\n    samplers.push(\"anisotropySampler\");\n  }\n  getUniforms() {\n    return {\n      ubo: [{\n        name: \"vAnisotropy\",\n        size: 3,\n        type: \"vec3\"\n      }, {\n        name: \"vAnisotropyInfos\",\n        size: 2,\n        type: \"vec2\"\n      }, {\n        name: \"anisotropyMatrix\",\n        size: 16,\n        type: \"mat4\"\n      }]\n    };\n  }\n  /**\n   * Parses a anisotropy Configuration from a serialized object.\n   * @param source - Serialized object.\n   * @param scene Defines the scene we are parsing for\n   * @param rootUrl Defines the rootUrl to load from\n   */\n  parse(source, scene, rootUrl) {\n    super.parse(source, scene, rootUrl);\n    // Backward compatibility\n    if (source.legacy === undefined) {\n      this.legacy = true;\n    }\n  }\n}\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRAnisotropicConfiguration.prototype, \"isEnabled\", void 0);\n__decorate([serialize()], PBRAnisotropicConfiguration.prototype, \"intensity\", void 0);\n__decorate([serializeAsVector2()], PBRAnisotropicConfiguration.prototype, \"direction\", void 0);\n__decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRAnisotropicConfiguration.prototype, \"texture\", void 0);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsMiscDirty\")], PBRAnisotropicConfiguration.prototype, \"legacy\", void 0);","map":{"version":3,"names":["serialize","expandToProperty","serializeAsVector2","serializeAsTexture","VertexBuffer","Vector2","MaterialFlags","MaterialHelper","MaterialPluginBase","MaterialDefines","MaterialAnisotropicDefines","constructor","ANISOTROPIC","ANISOTROPIC_TEXTURE","ANISOTROPIC_TEXTUREDIRECTUV","ANISOTROPIC_LEGACY","MAINUV1","PBRAnisotropicConfiguration","angle","value","direction","x","Math","cos","y","sin","atan2","_markAllSubMeshesAsTexturesDirty","_enable","_isEnabled","_internalMarkAllSubMeshesAsTexturesDirty","_markAllSubMeshesAsMiscDirty","_internalMarkAllSubMeshesAsMiscDirty","material","addToPluginList","isEnabled","intensity","_texture","texture","_legacy","legacy","_dirtyCallbacks","isReadyForSubMesh","defines","scene","_areTexturesDirty","texturesEnabled","AnisotropicTextureEnabled","isReadyOrNotBlocking","prepareDefinesBeforeAttributes","mesh","isVerticesDataPresent","TangentKind","_needUVs","PrepareDefinesForMergedUV","_areMiscDirty","bindForSubMesh","uniformBuffer","isFrozen","_material","useUbo","isSync","updateFloat2","coordinatesIndex","level","BindTextureMatrix","updateFloat3","setTexture","hasTexture","getActiveTextures","activeTextures","push","getAnimatables","animatables","animations","length","dispose","forceDisposeTextures","getClassName","addFallbacks","fallbacks","currentRank","addFallback","getSamplers","samplers","getUniforms","ubo","name","size","type","parse","source","rootUrl","undefined","__decorate"],"sources":["../../../../../dev/core/src/Materials/PBR/pbrAnisotropicConfiguration.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { serialize, expandToProperty, serializeAsVector2, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { Vector2 } from \"../../Maths/math.vector\";\r\nimport { MaterialFlags } from \"../../Materials/materialFlags\";\r\nimport { MaterialHelper } from \"../../Materials/materialHelper\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\n\r\nimport type { Scene } from \"../../scene\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialAnisotropicDefines extends MaterialDefines {\r\n    public ANISOTROPIC = false;\r\n    public ANISOTROPIC_TEXTURE = false;\r\n    public ANISOTROPIC_TEXTUREDIRECTUV = 0;\r\n    public ANISOTROPIC_LEGACY = false;\r\n    public MAINUV1 = false;\r\n}\r\n\r\n/**\r\n * Plugin that implements the anisotropic component of the PBR material\r\n */\r\nexport class PBRAnisotropicConfiguration extends MaterialPluginBase {\r\n    private _isEnabled = false;\r\n    /**\r\n     * Defines if the anisotropy is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isEnabled = false;\r\n\r\n    /**\r\n     * Defines the anisotropy strength (between 0 and 1) it defaults to 1.\r\n     */\r\n    @serialize()\r\n    public intensity: number = 1;\r\n\r\n    /**\r\n     * Defines if the effect is along the tangents, bitangents or in between.\r\n     * By default, the effect is \"stretching\" the highlights along the tangents.\r\n     */\r\n    @serializeAsVector2()\r\n    public direction = new Vector2(1, 0);\r\n\r\n    /**\r\n     * Sets the anisotropy direction as an angle.\r\n     */\r\n    public set angle(value: number) {\r\n        this.direction.x = Math.cos(value);\r\n        this.direction.y = Math.sin(value);\r\n    }\r\n\r\n    /**\r\n     * Gets the anisotropy angle value in radians.\r\n     * @returns the anisotropy angle value in radians.\r\n     */\r\n    public get angle(): number {\r\n        return Math.atan2(this.direction.y, this.direction.x);\r\n    }\r\n\r\n    private _texture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the anisotropy values in a texture.\r\n     * rg is direction (like normal from -1 to 1)\r\n     * b is a intensity\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public texture: Nullable<BaseTexture> = null;\r\n\r\n    private _legacy = false;\r\n    /**\r\n     * Defines if the anisotropy is in legacy mode for backwards compatibility before 6.4.0.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public legacy: boolean = false;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._enable(this._isEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsMiscDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsMiscDirty(): void {\r\n        this._enable(this._isEnabled);\r\n        this._internalMarkAllSubMeshesAsMiscDirty();\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial, addToPluginList = true) {\r\n        super(material, \"PBRAnisotropic\", 110, new MaterialAnisotropicDefines(), addToPluginList);\r\n\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\r\n        this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[Constants.MATERIAL_MiscDirtyFlag];\r\n    }\r\n\r\n    public isReadyForSubMesh(defines: MaterialAnisotropicDefines, scene: Scene): boolean {\r\n        if (!this._isEnabled) {\r\n            return true;\r\n        }\r\n\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                    if (!this._texture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public prepareDefinesBeforeAttributes(defines: MaterialAnisotropicDefines, scene: Scene, mesh: AbstractMesh): void {\r\n        if (this._isEnabled) {\r\n            defines.ANISOTROPIC = this._isEnabled;\r\n            if (this._isEnabled && !mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n                defines._needUVs = true;\r\n                defines.MAINUV1 = true;\r\n            }\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (scene.texturesEnabled) {\r\n                    if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"ANISOTROPIC_TEXTURE\");\r\n                    } else {\r\n                        defines.ANISOTROPIC_TEXTURE = false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (defines._areMiscDirty) {\r\n                defines.ANISOTROPIC_LEGACY = this._legacy;\r\n            }\r\n        } else {\r\n            defines.ANISOTROPIC = false;\r\n            defines.ANISOTROPIC_TEXTURE = false;\r\n            defines.ANISOTROPIC_TEXTUREDIRECTUV = 0;\r\n            defines.ANISOTROPIC_LEGACY = false;\r\n        }\r\n    }\r\n\r\n    public bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene): void {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n\r\n        const isFrozen = this._material.isFrozen;\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                uniformBuffer.updateFloat2(\"vAnisotropyInfos\", this._texture.coordinatesIndex, this._texture.level);\r\n                MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"anisotropy\");\r\n            }\r\n\r\n            // Anisotropy\r\n            uniformBuffer.updateFloat3(\"vAnisotropy\", this.direction.x, this.direction.y, this.intensity);\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                uniformBuffer.setTexture(\"anisotropySampler\", this._texture);\r\n            }\r\n        }\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (this._texture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._texture) {\r\n            activeTextures.push(this._texture);\r\n        }\r\n    }\r\n\r\n    public getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\r\n            animatables.push(this._texture);\r\n        }\r\n    }\r\n\r\n    public dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            if (this._texture) {\r\n                this._texture.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"PBRAnisotropicConfiguration\";\r\n    }\r\n\r\n    public addFallbacks(defines: MaterialAnisotropicDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        if (defines.ANISOTROPIC) {\r\n            fallbacks.addFallback(currentRank++, \"ANISOTROPIC\");\r\n        }\r\n        return currentRank;\r\n    }\r\n\r\n    public getSamplers(samplers: string[]): void {\r\n        samplers.push(\"anisotropySampler\");\r\n    }\r\n\r\n    public getUniforms(): { ubo?: Array<{ name: string; size: number; type: string }>; vertex?: string; fragment?: string } {\r\n        return {\r\n            ubo: [\r\n                { name: \"vAnisotropy\", size: 3, type: \"vec3\" },\r\n                { name: \"vAnisotropyInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"anisotropyMatrix\", size: 16, type: \"mat4\" },\r\n            ],\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Parses a anisotropy Configuration from a serialized object.\r\n     * @param source - Serialized object.\r\n     * @param scene Defines the scene we are parsing for\r\n     * @param rootUrl Defines the rootUrl to load from\r\n     */\r\n    public parse(source: any, scene: Scene, rootUrl: string): void {\r\n        super.parse(source, scene, rootUrl);\r\n\r\n        // Backward compatibility\r\n        if (source.legacy === undefined) {\r\n            this.legacy = true;\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}