{"ast":null,"code":"import { WebXRFeatureName } from \"../../XR/webXRFeaturesManager.js\";\nimport { WebXRHandJoint } from \"../../XR/features/WebXRHandTracking.js\";\nimport { Quaternion, TmpVectors, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Zones around the hand\n */\nexport var HandConstraintZone;\n(function (HandConstraintZone) {\n  /**\n   * Above finger tips\n   */\n  HandConstraintZone[HandConstraintZone[\"ABOVE_FINGER_TIPS\"] = 0] = \"ABOVE_FINGER_TIPS\";\n  /**\n   * Next to the thumb\n   */\n  HandConstraintZone[HandConstraintZone[\"RADIAL_SIDE\"] = 1] = \"RADIAL_SIDE\";\n  /**\n   * Next to the pinky finger\n   */\n  HandConstraintZone[HandConstraintZone[\"ULNAR_SIDE\"] = 2] = \"ULNAR_SIDE\";\n  /**\n   * Below the wrist\n   */\n  HandConstraintZone[HandConstraintZone[\"BELOW_WRIST\"] = 3] = \"BELOW_WRIST\";\n})(HandConstraintZone || (HandConstraintZone = {}));\n/**\n * Orientations for the hand zones and for the attached node\n */\nexport var HandConstraintOrientation;\n(function (HandConstraintOrientation) {\n  /**\n   * Orientation is towards the camera\n   */\n  HandConstraintOrientation[HandConstraintOrientation[\"LOOK_AT_CAMERA\"] = 0] = \"LOOK_AT_CAMERA\";\n  /**\n   * Orientation is determined by the rotation of the palm\n   */\n  HandConstraintOrientation[HandConstraintOrientation[\"HAND_ROTATION\"] = 1] = \"HAND_ROTATION\";\n})(HandConstraintOrientation || (HandConstraintOrientation = {}));\n/**\n * Orientations for the hand zones and for the attached node\n */\nexport var HandConstraintVisibility;\n(function (HandConstraintVisibility) {\n  /**\n   * Constraint is always visible\n   */\n  HandConstraintVisibility[HandConstraintVisibility[\"ALWAYS_VISIBLE\"] = 0] = \"ALWAYS_VISIBLE\";\n  /**\n   * Constraint is only visible when the palm is up\n   */\n  HandConstraintVisibility[HandConstraintVisibility[\"PALM_UP\"] = 1] = \"PALM_UP\";\n  /**\n   * Constraint is only visible when the user is looking at the constraint.\n   * Uses XR Eye Tracking if enabled/available, otherwise uses camera direction\n   */\n  HandConstraintVisibility[HandConstraintVisibility[\"GAZE_FOCUS\"] = 2] = \"GAZE_FOCUS\";\n  /**\n   * Constraint is only visible when the palm is up and the user is looking at it\n   */\n  HandConstraintVisibility[HandConstraintVisibility[\"PALM_AND_GAZE\"] = 3] = \"PALM_AND_GAZE\";\n})(HandConstraintVisibility || (HandConstraintVisibility = {}));\n/**\n * Hand constraint behavior that makes the attached `TransformNode` follow hands in XR experiences.\n * @since 5.0.0\n */\nexport class HandConstraintBehavior {\n  /**\n   * Builds a hand constraint behavior\n   */\n  constructor() {\n    this._sceneRenderObserver = null;\n    this._zoneAxis = {};\n    /**\n     * Sets the HandConstraintVisibility level for the hand constraint\n     */\n    this.handConstraintVisibility = HandConstraintVisibility.PALM_AND_GAZE;\n    /**\n     * A number from 0.0 to 1.0, marking how restricted the direction the palm faces is for the attached node to be enabled.\n     * A 1 means the palm must be directly facing the user before the node is enabled, a 0 means it is always enabled.\n     * Used with HandConstraintVisibility.PALM_UP\n     */\n    this.palmUpStrictness = 0.95;\n    /**\n     * The radius in meters around the center of the hand that the user must gaze inside for the attached node to be enabled and appear.\n     * Used with HandConstraintVisibility.GAZE_FOCUS\n     */\n    this.gazeProximityRadius = 0.15;\n    /**\n     * Offset distance from the hand in meters\n     */\n    this.targetOffset = 0.1;\n    /**\n     * Where to place the node regarding the center of the hand.\n     */\n    this.targetZone = HandConstraintZone.ULNAR_SIDE;\n    /**\n     * Orientation mode of the 4 zones around the hand\n     */\n    this.zoneOrientationMode = HandConstraintOrientation.HAND_ROTATION;\n    /**\n     * Orientation mode of the node attached to this behavior\n     */\n    this.nodeOrientationMode = HandConstraintOrientation.HAND_ROTATION;\n    /**\n     * Set the hand this behavior should follow. If set to \"none\", it will follow any visible hand (prioritising the left one).\n     */\n    this.handedness = \"none\";\n    /**\n     * Rate of interpolation of position and rotation of the attached node.\n     * Higher values will give a slower interpolation.\n     */\n    this.lerpTime = 100;\n    // For a right hand\n    this._zoneAxis[HandConstraintZone.ABOVE_FINGER_TIPS] = new Vector3(0, 1, 0);\n    this._zoneAxis[HandConstraintZone.RADIAL_SIDE] = new Vector3(-1, 0, 0);\n    this._zoneAxis[HandConstraintZone.ULNAR_SIDE] = new Vector3(1, 0, 0);\n    this._zoneAxis[HandConstraintZone.BELOW_WRIST] = new Vector3(0, -1, 0);\n  }\n  /** gets or sets behavior's name */\n  get name() {\n    return \"HandConstraint\";\n  }\n  /** Enable the behavior */\n  enable() {\n    this._node.setEnabled(true);\n  }\n  /** Disable the behavior */\n  disable() {\n    this._node.setEnabled(false);\n  }\n  _getHandPose() {\n    if (!this._handTracking) {\n      return null;\n    }\n    // Retrieve any available hand, starting by the left\n    let hand;\n    if (this.handedness === \"none\") {\n      hand = this._handTracking.getHandByHandedness(\"left\") || this._handTracking.getHandByHandedness(\"right\");\n    } else {\n      hand = this._handTracking.getHandByHandedness(this.handedness);\n    }\n    if (hand) {\n      const pinkyMetacarpal = hand.getJointMesh(WebXRHandJoint.PINKY_FINGER_METACARPAL);\n      const middleMetacarpal = hand.getJointMesh(WebXRHandJoint.MIDDLE_FINGER_METACARPAL);\n      const wrist = hand.getJointMesh(WebXRHandJoint.WRIST);\n      if (wrist && middleMetacarpal && pinkyMetacarpal) {\n        const handPose = {\n          position: middleMetacarpal.absolutePosition,\n          quaternion: new Quaternion(),\n          id: hand.xrController.uniqueId\n        };\n        // palm forward\n        const up = TmpVectors.Vector3[0];\n        const forward = TmpVectors.Vector3[1];\n        const left = TmpVectors.Vector3[2];\n        up.copyFrom(middleMetacarpal.absolutePosition).subtractInPlace(wrist.absolutePosition).normalize();\n        forward.copyFrom(pinkyMetacarpal.absolutePosition).subtractInPlace(middleMetacarpal.absolutePosition).normalize();\n        // Create vectors for a rotation quaternion, where forward points out from the palm\n        Vector3.CrossToRef(up, forward, forward);\n        Vector3.CrossToRef(forward, up, left);\n        Quaternion.FromLookDirectionLHToRef(forward, up, handPose.quaternion);\n        return handPose;\n      }\n    }\n    return null;\n  }\n  /**\n   * Initializes the hand constraint behavior\n   */\n  init() {}\n  /**\n   * Attaches the hand constraint to a `TransformNode`\n   * @param node defines the node to attach the behavior to\n   */\n  attach(node) {\n    this._node = node;\n    this._scene = node.getScene();\n    if (!this._node.rotationQuaternion) {\n      this._node.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._node.rotation.y, this._node.rotation.x, this._node.rotation.z);\n    }\n    let lastTick = Date.now();\n    this._sceneRenderObserver = this._scene.onBeforeRenderObservable.add(() => {\n      const pose = this._getHandPose();\n      this._node.reservedDataStore = this._node.reservedDataStore || {};\n      this._node.reservedDataStore.nearInteraction = this._node.reservedDataStore.nearInteraction || {};\n      this._node.reservedDataStore.nearInteraction.excludedControllerId = null;\n      if (pose) {\n        const zoneOffset = TmpVectors.Vector3[0];\n        const camera = this._scene.activeCamera;\n        zoneOffset.copyFrom(this._zoneAxis[this.targetZone]);\n        const cameraLookAtQuaternion = TmpVectors.Quaternion[0];\n        if (camera && (this.zoneOrientationMode === HandConstraintOrientation.LOOK_AT_CAMERA || this.nodeOrientationMode === HandConstraintOrientation.LOOK_AT_CAMERA)) {\n          const toCamera = TmpVectors.Vector3[1];\n          toCamera.copyFrom(camera.position).subtractInPlace(pose.position).normalize();\n          if (this._scene.useRightHandedSystem) {\n            Quaternion.FromLookDirectionRHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);\n          } else {\n            Quaternion.FromLookDirectionLHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);\n          }\n        }\n        if (this.zoneOrientationMode === HandConstraintOrientation.HAND_ROTATION) {\n          pose.quaternion.toRotationMatrix(TmpVectors.Matrix[0]);\n        } else {\n          cameraLookAtQuaternion.toRotationMatrix(TmpVectors.Matrix[0]);\n        }\n        Vector3.TransformNormalToRef(zoneOffset, TmpVectors.Matrix[0], zoneOffset);\n        zoneOffset.scaleInPlace(this.targetOffset);\n        const targetPosition = TmpVectors.Vector3[2];\n        const targetRotation = TmpVectors.Quaternion[1];\n        targetPosition.copyFrom(pose.position).addInPlace(zoneOffset);\n        if (this.nodeOrientationMode === HandConstraintOrientation.HAND_ROTATION) {\n          targetRotation.copyFrom(pose.quaternion);\n        } else {\n          targetRotation.copyFrom(cameraLookAtQuaternion);\n        }\n        const elapsed = Date.now() - lastTick;\n        Vector3.SmoothToRef(this._node.position, targetPosition, elapsed, this.lerpTime, this._node.position);\n        Quaternion.SmoothToRef(this._node.rotationQuaternion, targetRotation, elapsed, this.lerpTime, this._node.rotationQuaternion);\n        this._node.reservedDataStore.nearInteraction.excludedControllerId = pose.id;\n      }\n      this._setVisibility(pose);\n      lastTick = Date.now();\n    });\n  }\n  _setVisibility(pose) {\n    let palmVisible = true;\n    let gazeVisible = true;\n    const camera = this._scene.activeCamera;\n    if (camera) {\n      const cameraForward = camera.getForwardRay();\n      if (this.handConstraintVisibility === HandConstraintVisibility.GAZE_FOCUS || this.handConstraintVisibility === HandConstraintVisibility.PALM_AND_GAZE) {\n        gazeVisible = false;\n        let gaze;\n        if (this._eyeTracking) {\n          gaze = this._eyeTracking.getEyeGaze();\n        }\n        gaze = gaze || cameraForward;\n        const gazeToBehavior = TmpVectors.Vector3[0];\n        if (pose) {\n          pose.position.subtractToRef(gaze.origin, gazeToBehavior);\n        } else {\n          this._node.getAbsolutePosition().subtractToRef(gaze.origin, gazeToBehavior);\n        }\n        const projectedDistance = Vector3.Dot(gazeToBehavior, gaze.direction);\n        const projectedSquared = projectedDistance * projectedDistance;\n        if (projectedDistance > 0) {\n          const radiusSquared = gazeToBehavior.lengthSquared() - projectedSquared;\n          if (radiusSquared < this.gazeProximityRadius * this.gazeProximityRadius) {\n            gazeVisible = true;\n          }\n        }\n      }\n      if (this.handConstraintVisibility === HandConstraintVisibility.PALM_UP || this.handConstraintVisibility === HandConstraintVisibility.PALM_AND_GAZE) {\n        palmVisible = false;\n        if (pose) {\n          const palmDirection = TmpVectors.Vector3[0];\n          Vector3.LeftHandedForwardReadOnly.rotateByQuaternionToRef(pose.quaternion, palmDirection);\n          if (Vector3.Dot(palmDirection, cameraForward.direction) > this.palmUpStrictness * 2 - 1) {\n            palmVisible = true;\n          }\n        }\n      }\n    }\n    this._node.setEnabled(palmVisible && gazeVisible);\n  }\n  /**\n   * Detaches the behavior from the `TransformNode`\n   */\n  detach() {\n    this._scene.onBeforeRenderObservable.remove(this._sceneRenderObserver);\n  }\n  /**\n   * Links the behavior to the XR experience in which to retrieve hand transform information.\n   * @param xr xr experience\n   */\n  linkToXRExperience(xr) {\n    const featuresManager = xr.featuresManager ? xr.featuresManager : xr;\n    if (!featuresManager) {\n      Tools.Error(\"XR features manager must be available or provided directly for the Hand Menu to work\");\n    } else {\n      try {\n        this._eyeTracking = featuresManager.getEnabledFeature(WebXRFeatureName.EYE_TRACKING);\n      } catch (_a) {}\n      try {\n        this._handTracking = featuresManager.getEnabledFeature(WebXRFeatureName.HAND_TRACKING);\n      } catch (_b) {\n        Tools.Error(\"Hand tracking must be enabled for the Hand Menu to work\");\n      }\n    }\n  }\n}","map":{"version":3,"names":["WebXRFeatureName","WebXRHandJoint","Quaternion","TmpVectors","Vector3","Tools","HandConstraintZone","HandConstraintOrientation","HandConstraintVisibility","HandConstraintBehavior","constructor","_sceneRenderObserver","_zoneAxis","handConstraintVisibility","PALM_AND_GAZE","palmUpStrictness","gazeProximityRadius","targetOffset","targetZone","ULNAR_SIDE","zoneOrientationMode","HAND_ROTATION","nodeOrientationMode","handedness","lerpTime","ABOVE_FINGER_TIPS","RADIAL_SIDE","BELOW_WRIST","name","enable","_node","setEnabled","disable","_getHandPose","_handTracking","hand","getHandByHandedness","pinkyMetacarpal","getJointMesh","PINKY_FINGER_METACARPAL","middleMetacarpal","MIDDLE_FINGER_METACARPAL","wrist","WRIST","handPose","position","absolutePosition","quaternion","id","xrController","uniqueId","up","forward","left","copyFrom","subtractInPlace","normalize","CrossToRef","FromLookDirectionLHToRef","init","attach","node","_scene","getScene","rotationQuaternion","RotationYawPitchRoll","rotation","y","x","z","lastTick","Date","now","onBeforeRenderObservable","add","pose","reservedDataStore","nearInteraction","excludedControllerId","zoneOffset","camera","activeCamera","cameraLookAtQuaternion","LOOK_AT_CAMERA","toCamera","useRightHandedSystem","FromLookDirectionRHToRef","UpReadOnly","toRotationMatrix","Matrix","TransformNormalToRef","scaleInPlace","targetPosition","targetRotation","addInPlace","elapsed","SmoothToRef","_setVisibility","palmVisible","gazeVisible","cameraForward","getForwardRay","GAZE_FOCUS","gaze","_eyeTracking","getEyeGaze","gazeToBehavior","subtractToRef","origin","getAbsolutePosition","projectedDistance","Dot","direction","projectedSquared","radiusSquared","lengthSquared","PALM_UP","palmDirection","LeftHandedForwardReadOnly","rotateByQuaternionToRef","detach","remove","linkToXRExperience","xr","featuresManager","Error","getEnabledFeature","EYE_TRACKING","_a","HAND_TRACKING","_b"],"sources":["../../../../../dev/core/src/Behaviors/Meshes/handConstraintBehavior.ts"],"sourcesContent":["import type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { WebXRFeatureName } from \"../../XR/webXRFeaturesManager\";\r\nimport type { WebXRFeaturesManager } from \"../../XR/webXRFeaturesManager\";\r\nimport type { WebXREyeTracking } from \"../../XR/features/WebXREyeTracking\";\r\nimport type { WebXRHandTracking } from \"../../XR/features/WebXRHandTracking\";\r\nimport { WebXRHandJoint } from \"../../XR/features/WebXRHandTracking\";\r\nimport type { WebXRExperienceHelper } from \"../../XR/webXRExperienceHelper\";\r\nimport type { Behavior } from \"../behavior\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Quaternion, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Ray } from \"../../Culling/ray\";\r\nimport { Tools } from \"core/Misc/tools\";\r\n\r\n/**\r\n * Zones around the hand\r\n */\r\nexport enum HandConstraintZone {\r\n    /**\r\n     * Above finger tips\r\n     */\r\n    ABOVE_FINGER_TIPS,\r\n    /**\r\n     * Next to the thumb\r\n     */\r\n    RADIAL_SIDE,\r\n    /**\r\n     * Next to the pinky finger\r\n     */\r\n    ULNAR_SIDE,\r\n    /**\r\n     * Below the wrist\r\n     */\r\n    BELOW_WRIST,\r\n}\r\n\r\n/**\r\n * Orientations for the hand zones and for the attached node\r\n */\r\nexport enum HandConstraintOrientation {\r\n    /**\r\n     * Orientation is towards the camera\r\n     */\r\n    LOOK_AT_CAMERA,\r\n    /**\r\n     * Orientation is determined by the rotation of the palm\r\n     */\r\n    HAND_ROTATION,\r\n}\r\n\r\n/**\r\n * Orientations for the hand zones and for the attached node\r\n */\r\nexport enum HandConstraintVisibility {\r\n    /**\r\n     * Constraint is always visible\r\n     */\r\n    ALWAYS_VISIBLE,\r\n    /**\r\n     * Constraint is only visible when the palm is up\r\n     */\r\n    PALM_UP,\r\n    /**\r\n     * Constraint is only visible when the user is looking at the constraint.\r\n     * Uses XR Eye Tracking if enabled/available, otherwise uses camera direction\r\n     */\r\n    GAZE_FOCUS,\r\n    /**\r\n     * Constraint is only visible when the palm is up and the user is looking at it\r\n     */\r\n    PALM_AND_GAZE,\r\n}\r\n\r\ntype HandPoseInfo = {\r\n    position: Vector3;\r\n    quaternion: Quaternion;\r\n    id: string;\r\n};\r\n\r\n/**\r\n * Hand constraint behavior that makes the attached `TransformNode` follow hands in XR experiences.\r\n * @since 5.0.0\r\n */\r\nexport class HandConstraintBehavior implements Behavior<TransformNode> {\r\n    private _scene: Scene;\r\n    private _node: TransformNode;\r\n    private _eyeTracking: Nullable<WebXREyeTracking>;\r\n    private _handTracking: Nullable<WebXRHandTracking>;\r\n    private _sceneRenderObserver: Nullable<Observer<Scene>> = null;\r\n    private _zoneAxis: { [id: number]: Vector3 } = {};\r\n\r\n    /**\r\n     * Sets the HandConstraintVisibility level for the hand constraint\r\n     */\r\n    public handConstraintVisibility: HandConstraintVisibility = HandConstraintVisibility.PALM_AND_GAZE;\r\n\r\n    /**\r\n     * A number from 0.0 to 1.0, marking how restricted the direction the palm faces is for the attached node to be enabled.\r\n     * A 1 means the palm must be directly facing the user before the node is enabled, a 0 means it is always enabled.\r\n     * Used with HandConstraintVisibility.PALM_UP\r\n     */\r\n    public palmUpStrictness: number = 0.95;\r\n\r\n    /**\r\n     * The radius in meters around the center of the hand that the user must gaze inside for the attached node to be enabled and appear.\r\n     * Used with HandConstraintVisibility.GAZE_FOCUS\r\n     */\r\n    public gazeProximityRadius: number = 0.15;\r\n\r\n    /**\r\n     * Offset distance from the hand in meters\r\n     */\r\n    public targetOffset: number = 0.1;\r\n\r\n    /**\r\n     * Where to place the node regarding the center of the hand.\r\n     */\r\n    public targetZone: HandConstraintZone = HandConstraintZone.ULNAR_SIDE;\r\n\r\n    /**\r\n     * Orientation mode of the 4 zones around the hand\r\n     */\r\n    public zoneOrientationMode: HandConstraintOrientation = HandConstraintOrientation.HAND_ROTATION;\r\n    /**\r\n     * Orientation mode of the node attached to this behavior\r\n     */\r\n    public nodeOrientationMode: HandConstraintOrientation = HandConstraintOrientation.HAND_ROTATION;\r\n\r\n    /**\r\n     * Set the hand this behavior should follow. If set to \"none\", it will follow any visible hand (prioritising the left one).\r\n     */\r\n    public handedness: XRHandedness = \"none\";\r\n\r\n    /**\r\n     * Rate of interpolation of position and rotation of the attached node.\r\n     * Higher values will give a slower interpolation.\r\n     */\r\n    public lerpTime = 100;\r\n\r\n    /**\r\n     * Builds a hand constraint behavior\r\n     */\r\n    constructor() {\r\n        // For a right hand\r\n        this._zoneAxis[HandConstraintZone.ABOVE_FINGER_TIPS] = new Vector3(0, 1, 0);\r\n        this._zoneAxis[HandConstraintZone.RADIAL_SIDE] = new Vector3(-1, 0, 0);\r\n        this._zoneAxis[HandConstraintZone.ULNAR_SIDE] = new Vector3(1, 0, 0);\r\n        this._zoneAxis[HandConstraintZone.BELOW_WRIST] = new Vector3(0, -1, 0);\r\n    }\r\n\r\n    /** gets or sets behavior's name */\r\n    public get name() {\r\n        return \"HandConstraint\";\r\n    }\r\n\r\n    /** Enable the behavior */\r\n    public enable() {\r\n        this._node.setEnabled(true);\r\n    }\r\n\r\n    /** Disable the behavior */\r\n    public disable() {\r\n        this._node.setEnabled(false);\r\n    }\r\n\r\n    private _getHandPose(): Nullable<HandPoseInfo> {\r\n        if (!this._handTracking) {\r\n            return null;\r\n        }\r\n\r\n        // Retrieve any available hand, starting by the left\r\n        let hand;\r\n        if (this.handedness === \"none\") {\r\n            hand = this._handTracking.getHandByHandedness(\"left\") || this._handTracking.getHandByHandedness(\"right\");\r\n        } else {\r\n            hand = this._handTracking.getHandByHandedness(this.handedness);\r\n        }\r\n\r\n        if (hand) {\r\n            const pinkyMetacarpal = hand.getJointMesh(WebXRHandJoint.PINKY_FINGER_METACARPAL);\r\n            const middleMetacarpal = hand.getJointMesh(WebXRHandJoint.MIDDLE_FINGER_METACARPAL);\r\n            const wrist = hand.getJointMesh(WebXRHandJoint.WRIST);\r\n\r\n            if (wrist && middleMetacarpal && pinkyMetacarpal) {\r\n                const handPose: HandPoseInfo = { position: middleMetacarpal.absolutePosition, quaternion: new Quaternion(), id: hand.xrController.uniqueId };\r\n\r\n                // palm forward\r\n                const up = TmpVectors.Vector3[0];\r\n                const forward = TmpVectors.Vector3[1];\r\n                const left = TmpVectors.Vector3[2];\r\n                up.copyFrom(middleMetacarpal.absolutePosition).subtractInPlace(wrist.absolutePosition).normalize();\r\n                forward.copyFrom(pinkyMetacarpal.absolutePosition).subtractInPlace(middleMetacarpal.absolutePosition).normalize();\r\n\r\n                // Create vectors for a rotation quaternion, where forward points out from the palm\r\n                Vector3.CrossToRef(up, forward, forward);\r\n                Vector3.CrossToRef(forward, up, left);\r\n\r\n                Quaternion.FromLookDirectionLHToRef(forward, up, handPose.quaternion);\r\n\r\n                return handPose;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Initializes the hand constraint behavior\r\n     */\r\n    public init() {}\r\n\r\n    /**\r\n     * Attaches the hand constraint to a `TransformNode`\r\n     * @param node defines the node to attach the behavior to\r\n     */\r\n    public attach(node: TransformNode): void {\r\n        this._node = node;\r\n        this._scene = node.getScene();\r\n\r\n        if (!this._node.rotationQuaternion) {\r\n            this._node.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._node.rotation.y, this._node.rotation.x, this._node.rotation.z);\r\n        }\r\n\r\n        let lastTick = Date.now();\r\n        this._sceneRenderObserver = this._scene.onBeforeRenderObservable.add(() => {\r\n            const pose = this._getHandPose();\r\n\r\n            this._node.reservedDataStore = this._node.reservedDataStore || {};\r\n            this._node.reservedDataStore.nearInteraction = this._node.reservedDataStore.nearInteraction || {};\r\n            this._node.reservedDataStore.nearInteraction.excludedControllerId = null;\r\n\r\n            if (pose) {\r\n                const zoneOffset = TmpVectors.Vector3[0];\r\n                const camera = this._scene.activeCamera;\r\n\r\n                zoneOffset.copyFrom(this._zoneAxis[this.targetZone]);\r\n\r\n                const cameraLookAtQuaternion = TmpVectors.Quaternion[0];\r\n                if (camera && (this.zoneOrientationMode === HandConstraintOrientation.LOOK_AT_CAMERA || this.nodeOrientationMode === HandConstraintOrientation.LOOK_AT_CAMERA)) {\r\n                    const toCamera = TmpVectors.Vector3[1];\r\n                    toCamera.copyFrom(camera.position).subtractInPlace(pose.position).normalize();\r\n                    if (this._scene.useRightHandedSystem) {\r\n                        Quaternion.FromLookDirectionRHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);\r\n                    } else {\r\n                        Quaternion.FromLookDirectionLHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);\r\n                    }\r\n                }\r\n\r\n                if (this.zoneOrientationMode === HandConstraintOrientation.HAND_ROTATION) {\r\n                    pose.quaternion.toRotationMatrix(TmpVectors.Matrix[0]);\r\n                } else {\r\n                    cameraLookAtQuaternion.toRotationMatrix(TmpVectors.Matrix[0]);\r\n                }\r\n\r\n                Vector3.TransformNormalToRef(zoneOffset, TmpVectors.Matrix[0], zoneOffset);\r\n                zoneOffset.scaleInPlace(this.targetOffset);\r\n\r\n                const targetPosition = TmpVectors.Vector3[2];\r\n                const targetRotation = TmpVectors.Quaternion[1];\r\n                targetPosition.copyFrom(pose.position).addInPlace(zoneOffset);\r\n\r\n                if (this.nodeOrientationMode === HandConstraintOrientation.HAND_ROTATION) {\r\n                    targetRotation.copyFrom(pose.quaternion);\r\n                } else {\r\n                    targetRotation.copyFrom(cameraLookAtQuaternion);\r\n                }\r\n\r\n                const elapsed = Date.now() - lastTick;\r\n\r\n                Vector3.SmoothToRef(this._node.position, targetPosition, elapsed, this.lerpTime, this._node.position);\r\n                Quaternion.SmoothToRef(this._node.rotationQuaternion!, targetRotation, elapsed, this.lerpTime, this._node.rotationQuaternion!);\r\n\r\n                this._node.reservedDataStore.nearInteraction.excludedControllerId = pose.id;\r\n            }\r\n\r\n            this._setVisibility(pose);\r\n\r\n            lastTick = Date.now();\r\n        });\r\n    }\r\n\r\n    private _setVisibility(pose: Nullable<HandPoseInfo>) {\r\n        let palmVisible = true;\r\n        let gazeVisible = true;\r\n        const camera = this._scene.activeCamera;\r\n\r\n        if (camera) {\r\n            const cameraForward = camera.getForwardRay();\r\n\r\n            if (this.handConstraintVisibility === HandConstraintVisibility.GAZE_FOCUS || this.handConstraintVisibility === HandConstraintVisibility.PALM_AND_GAZE) {\r\n                gazeVisible = false;\r\n                let gaze: Ray | undefined;\r\n                if (this._eyeTracking) {\r\n                    gaze = this._eyeTracking.getEyeGaze()!;\r\n                }\r\n\r\n                gaze = gaze || cameraForward;\r\n\r\n                const gazeToBehavior = TmpVectors.Vector3[0];\r\n                if (pose) {\r\n                    pose.position.subtractToRef(gaze.origin, gazeToBehavior);\r\n                } else {\r\n                    this._node.getAbsolutePosition().subtractToRef(gaze.origin, gazeToBehavior);\r\n                }\r\n\r\n                const projectedDistance = Vector3.Dot(gazeToBehavior, gaze.direction);\r\n                const projectedSquared = projectedDistance * projectedDistance;\r\n\r\n                if (projectedDistance > 0) {\r\n                    const radiusSquared = gazeToBehavior.lengthSquared() - projectedSquared;\r\n                    if (radiusSquared < this.gazeProximityRadius * this.gazeProximityRadius) {\r\n                        gazeVisible = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this.handConstraintVisibility === HandConstraintVisibility.PALM_UP || this.handConstraintVisibility === HandConstraintVisibility.PALM_AND_GAZE) {\r\n                palmVisible = false;\r\n\r\n                if (pose) {\r\n                    const palmDirection = TmpVectors.Vector3[0];\r\n                    Vector3.LeftHandedForwardReadOnly.rotateByQuaternionToRef(pose.quaternion, palmDirection);\r\n\r\n                    if (Vector3.Dot(palmDirection, cameraForward.direction) > this.palmUpStrictness * 2 - 1) {\r\n                        palmVisible = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this._node.setEnabled(palmVisible && gazeVisible);\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from the `TransformNode`\r\n     */\r\n    public detach(): void {\r\n        this._scene.onBeforeRenderObservable.remove(this._sceneRenderObserver);\r\n    }\r\n\r\n    /**\r\n     * Links the behavior to the XR experience in which to retrieve hand transform information.\r\n     * @param xr xr experience\r\n     */\r\n    public linkToXRExperience(xr: WebXRExperienceHelper | WebXRFeaturesManager) {\r\n        const featuresManager: WebXRFeaturesManager = (xr as WebXRExperienceHelper).featuresManager ? (xr as WebXRExperienceHelper).featuresManager : (xr as WebXRFeaturesManager);\r\n        if (!featuresManager) {\r\n            Tools.Error(\"XR features manager must be available or provided directly for the Hand Menu to work\");\r\n        } else {\r\n            try {\r\n                this._eyeTracking = featuresManager.getEnabledFeature(WebXRFeatureName.EYE_TRACKING) as WebXREyeTracking;\r\n            } catch {}\r\n\r\n            try {\r\n                this._handTracking = featuresManager.getEnabledFeature(WebXRFeatureName.HAND_TRACKING) as WebXRHandTracking;\r\n            } catch {\r\n                Tools.Error(\"Hand tracking must be enabled for the Hand Menu to work\");\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"mappings":"AAEA,SAASA,gBAAgB,QAAQ,kCAAgC;AAIjE,SAASC,cAAc,QAAQ,wCAAsC;AAKrE,SAASC,UAAU,EAAEC,UAAU,EAAEC,OAAO,QAAQ,4BAA0B;AAE1E,SAASC,KAAK,QAAE;AAEhB;;;AAGA,WAAYC,kBAiBX;AAjBD,WAAYA,kBAAkB;EAC1B;;;EAGAA,kBAAA,CAAAA,kBAAA,gDAAiB;EACjB;;;EAGAA,kBAAA,CAAAA,kBAAA,oCAAW;EACX;;;EAGAA,kBAAA,CAAAA,kBAAA,kCAAU;EACV;;;EAGAA,kBAAA,CAAAA,kBAAA,oCAAW;AACf,CAAC,EAjBWA,kBAAkB,KAAlBA,kBAAkB;AAmB9B;;;AAGA,WAAYC,yBASX;AATD,WAAYA,yBAAyB;EACjC;;;EAGAA,yBAAA,CAAAA,yBAAA,0CAAc;EACd;;;EAGAA,yBAAA,CAAAA,yBAAA,wCAAa;AACjB,CAAC,EATWA,yBAAyB,KAAzBA,yBAAyB;AAWrC;;;AAGA,WAAYC,wBAkBX;AAlBD,WAAYA,wBAAwB;EAChC;;;EAGAA,wBAAA,CAAAA,wBAAA,0CAAc;EACd;;;EAGAA,wBAAA,CAAAA,wBAAA,4BAAO;EACP;;;;EAIAA,wBAAA,CAAAA,wBAAA,kCAAU;EACV;;;EAGAA,wBAAA,CAAAA,wBAAA,wCAAa;AACjB,CAAC,EAlBWA,wBAAwB,KAAxBA,wBAAwB;AA0BpC;;;;AAIA,OAAM,MAAOC,sBAAsB;EAwD/B;;;EAGAC,YAAA;IAtDQ,KAAAC,oBAAoB,GAA8B,IAAI;IACtD,KAAAC,SAAS,GAA8B,EAAE;IAEjD;;;IAGO,KAAAC,wBAAwB,GAA6BL,wBAAwB,CAACM,aAAa;IAElG;;;;;IAKO,KAAAC,gBAAgB,GAAW,IAAI;IAEtC;;;;IAIO,KAAAC,mBAAmB,GAAW,IAAI;IAEzC;;;IAGO,KAAAC,YAAY,GAAW,GAAG;IAEjC;;;IAGO,KAAAC,UAAU,GAAuBZ,kBAAkB,CAACa,UAAU;IAErE;;;IAGO,KAAAC,mBAAmB,GAA8Bb,yBAAyB,CAACc,aAAa;IAC/F;;;IAGO,KAAAC,mBAAmB,GAA8Bf,yBAAyB,CAACc,aAAa;IAE/F;;;IAGO,KAAAE,UAAU,GAAiB,MAAM;IAExC;;;;IAIO,KAAAC,QAAQ,GAAG,GAAG;IAMjB;IACA,IAAI,CAACZ,SAAS,CAACN,kBAAkB,CAACmB,iBAAiB,CAAC,GAAG,IAAIrB,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAC3E,IAAI,CAACQ,SAAS,CAACN,kBAAkB,CAACoB,WAAW,CAAC,GAAG,IAAItB,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACtE,IAAI,CAACQ,SAAS,CAACN,kBAAkB,CAACa,UAAU,CAAC,GAAG,IAAIf,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACpE,IAAI,CAACQ,SAAS,CAACN,kBAAkB,CAACqB,WAAW,CAAC,GAAG,IAAIvB,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;EAC1E;EAEA;EACA,IAAWwB,IAAIA,CAAA;IACX,OAAO,gBAAgB;EAC3B;EAEA;EACOC,MAAMA,CAAA;IACT,IAAI,CAACC,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC;EAC/B;EAEA;EACOC,OAAOA,CAAA;IACV,IAAI,CAACF,KAAK,CAACC,UAAU,CAAC,KAAK,CAAC;EAChC;EAEQE,YAAYA,CAAA;IAChB,IAAI,CAAC,IAAI,CAACC,aAAa,EAAE;MACrB,OAAO,IAAI;;IAGf;IACA,IAAIC,IAAI;IACR,IAAI,IAAI,CAACZ,UAAU,KAAK,MAAM,EAAE;MAC5BY,IAAI,GAAG,IAAI,CAACD,aAAa,CAACE,mBAAmB,CAAC,MAAM,CAAC,IAAI,IAAI,CAACF,aAAa,CAACE,mBAAmB,CAAC,OAAO,CAAC;KAC3G,MAAM;MACHD,IAAI,GAAG,IAAI,CAACD,aAAa,CAACE,mBAAmB,CAAC,IAAI,CAACb,UAAU,CAAC;;IAGlE,IAAIY,IAAI,EAAE;MACN,MAAME,eAAe,GAAGF,IAAI,CAACG,YAAY,CAACrC,cAAc,CAACsC,uBAAuB,CAAC;MACjF,MAAMC,gBAAgB,GAAGL,IAAI,CAACG,YAAY,CAACrC,cAAc,CAACwC,wBAAwB,CAAC;MACnF,MAAMC,KAAK,GAAGP,IAAI,CAACG,YAAY,CAACrC,cAAc,CAAC0C,KAAK,CAAC;MAErD,IAAID,KAAK,IAAIF,gBAAgB,IAAIH,eAAe,EAAE;QAC9C,MAAMO,QAAQ,GAAiB;UAAEC,QAAQ,EAAEL,gBAAgB,CAACM,gBAAgB;UAAEC,UAAU,EAAE,IAAI7C,UAAU,EAAE;UAAE8C,EAAE,EAAEb,IAAI,CAACc,YAAY,CAACC;QAAQ,CAAE;QAE5I;QACA,MAAMC,EAAE,GAAGhD,UAAU,CAACC,OAAO,CAAC,CAAC,CAAC;QAChC,MAAMgD,OAAO,GAAGjD,UAAU,CAACC,OAAO,CAAC,CAAC,CAAC;QACrC,MAAMiD,IAAI,GAAGlD,UAAU,CAACC,OAAO,CAAC,CAAC,CAAC;QAClC+C,EAAE,CAACG,QAAQ,CAACd,gBAAgB,CAACM,gBAAgB,CAAC,CAACS,eAAe,CAACb,KAAK,CAACI,gBAAgB,CAAC,CAACU,SAAS,EAAE;QAClGJ,OAAO,CAACE,QAAQ,CAACjB,eAAe,CAACS,gBAAgB,CAAC,CAACS,eAAe,CAACf,gBAAgB,CAACM,gBAAgB,CAAC,CAACU,SAAS,EAAE;QAEjH;QACApD,OAAO,CAACqD,UAAU,CAACN,EAAE,EAAEC,OAAO,EAAEA,OAAO,CAAC;QACxChD,OAAO,CAACqD,UAAU,CAACL,OAAO,EAAED,EAAE,EAAEE,IAAI,CAAC;QAErCnD,UAAU,CAACwD,wBAAwB,CAACN,OAAO,EAAED,EAAE,EAAEP,QAAQ,CAACG,UAAU,CAAC;QAErE,OAAOH,QAAQ;;;IAIvB,OAAO,IAAI;EACf;EAEA;;;EAGOe,IAAIA,CAAA,GAAI;EAEf;;;;EAIOC,MAAMA,CAACC,IAAmB;IAC7B,IAAI,CAAC/B,KAAK,GAAG+B,IAAI;IACjB,IAAI,CAACC,MAAM,GAAGD,IAAI,CAACE,QAAQ,EAAE;IAE7B,IAAI,CAAC,IAAI,CAACjC,KAAK,CAACkC,kBAAkB,EAAE;MAChC,IAAI,CAAClC,KAAK,CAACkC,kBAAkB,GAAG9D,UAAU,CAAC+D,oBAAoB,CAAC,IAAI,CAACnC,KAAK,CAACoC,QAAQ,CAACC,CAAC,EAAE,IAAI,CAACrC,KAAK,CAACoC,QAAQ,CAACE,CAAC,EAAE,IAAI,CAACtC,KAAK,CAACoC,QAAQ,CAACG,CAAC,CAAC;;IAGxI,IAAIC,QAAQ,GAAGC,IAAI,CAACC,GAAG,EAAE;IACzB,IAAI,CAAC7D,oBAAoB,GAAG,IAAI,CAACmD,MAAM,CAACW,wBAAwB,CAACC,GAAG,CAAC,MAAK;MACtE,MAAMC,IAAI,GAAG,IAAI,CAAC1C,YAAY,EAAE;MAEhC,IAAI,CAACH,KAAK,CAAC8C,iBAAiB,GAAG,IAAI,CAAC9C,KAAK,CAAC8C,iBAAiB,IAAI,EAAE;MACjE,IAAI,CAAC9C,KAAK,CAAC8C,iBAAiB,CAACC,eAAe,GAAG,IAAI,CAAC/C,KAAK,CAAC8C,iBAAiB,CAACC,eAAe,IAAI,EAAE;MACjG,IAAI,CAAC/C,KAAK,CAAC8C,iBAAiB,CAACC,eAAe,CAACC,oBAAoB,GAAG,IAAI;MAExE,IAAIH,IAAI,EAAE;QACN,MAAMI,UAAU,GAAG5E,UAAU,CAACC,OAAO,CAAC,CAAC,CAAC;QACxC,MAAM4E,MAAM,GAAG,IAAI,CAAClB,MAAM,CAACmB,YAAY;QAEvCF,UAAU,CAACzB,QAAQ,CAAC,IAAI,CAAC1C,SAAS,CAAC,IAAI,CAACM,UAAU,CAAC,CAAC;QAEpD,MAAMgE,sBAAsB,GAAG/E,UAAU,CAACD,UAAU,CAAC,CAAC,CAAC;QACvD,IAAI8E,MAAM,KAAK,IAAI,CAAC5D,mBAAmB,KAAKb,yBAAyB,CAAC4E,cAAc,IAAI,IAAI,CAAC7D,mBAAmB,KAAKf,yBAAyB,CAAC4E,cAAc,CAAC,EAAE;UAC5J,MAAMC,QAAQ,GAAGjF,UAAU,CAACC,OAAO,CAAC,CAAC,CAAC;UACtCgF,QAAQ,CAAC9B,QAAQ,CAAC0B,MAAM,CAACnC,QAAQ,CAAC,CAACU,eAAe,CAACoB,IAAI,CAAC9B,QAAQ,CAAC,CAACW,SAAS,EAAE;UAC7E,IAAI,IAAI,CAACM,MAAM,CAACuB,oBAAoB,EAAE;YAClCnF,UAAU,CAACoF,wBAAwB,CAACF,QAAQ,EAAEhF,OAAO,CAACmF,UAAU,EAAEL,sBAAsB,CAAC;WAC5F,MAAM;YACHhF,UAAU,CAACwD,wBAAwB,CAAC0B,QAAQ,EAAEhF,OAAO,CAACmF,UAAU,EAAEL,sBAAsB,CAAC;;;QAIjG,IAAI,IAAI,CAAC9D,mBAAmB,KAAKb,yBAAyB,CAACc,aAAa,EAAE;UACtEsD,IAAI,CAAC5B,UAAU,CAACyC,gBAAgB,CAACrF,UAAU,CAACsF,MAAM,CAAC,CAAC,CAAC,CAAC;SACzD,MAAM;UACHP,sBAAsB,CAACM,gBAAgB,CAACrF,UAAU,CAACsF,MAAM,CAAC,CAAC,CAAC,CAAC;;QAGjErF,OAAO,CAACsF,oBAAoB,CAACX,UAAU,EAAE5E,UAAU,CAACsF,MAAM,CAAC,CAAC,CAAC,EAAEV,UAAU,CAAC;QAC1EA,UAAU,CAACY,YAAY,CAAC,IAAI,CAAC1E,YAAY,CAAC;QAE1C,MAAM2E,cAAc,GAAGzF,UAAU,CAACC,OAAO,CAAC,CAAC,CAAC;QAC5C,MAAMyF,cAAc,GAAG1F,UAAU,CAACD,UAAU,CAAC,CAAC,CAAC;QAC/C0F,cAAc,CAACtC,QAAQ,CAACqB,IAAI,CAAC9B,QAAQ,CAAC,CAACiD,UAAU,CAACf,UAAU,CAAC;QAE7D,IAAI,IAAI,CAACzD,mBAAmB,KAAKf,yBAAyB,CAACc,aAAa,EAAE;UACtEwE,cAAc,CAACvC,QAAQ,CAACqB,IAAI,CAAC5B,UAAU,CAAC;SAC3C,MAAM;UACH8C,cAAc,CAACvC,QAAQ,CAAC4B,sBAAsB,CAAC;;QAGnD,MAAMa,OAAO,GAAGxB,IAAI,CAACC,GAAG,EAAE,GAAGF,QAAQ;QAErClE,OAAO,CAAC4F,WAAW,CAAC,IAAI,CAAClE,KAAK,CAACe,QAAQ,EAAE+C,cAAc,EAAEG,OAAO,EAAE,IAAI,CAACvE,QAAQ,EAAE,IAAI,CAACM,KAAK,CAACe,QAAQ,CAAC;QACrG3C,UAAU,CAAC8F,WAAW,CAAC,IAAI,CAAClE,KAAK,CAACkC,kBAAmB,EAAE6B,cAAc,EAAEE,OAAO,EAAE,IAAI,CAACvE,QAAQ,EAAE,IAAI,CAACM,KAAK,CAACkC,kBAAmB,CAAC;QAE9H,IAAI,CAAClC,KAAK,CAAC8C,iBAAiB,CAACC,eAAe,CAACC,oBAAoB,GAAGH,IAAI,CAAC3B,EAAE;;MAG/E,IAAI,CAACiD,cAAc,CAACtB,IAAI,CAAC;MAEzBL,QAAQ,GAAGC,IAAI,CAACC,GAAG,EAAE;IACzB,CAAC,CAAC;EACN;EAEQyB,cAAcA,CAACtB,IAA4B;IAC/C,IAAIuB,WAAW,GAAG,IAAI;IACtB,IAAIC,WAAW,GAAG,IAAI;IACtB,MAAMnB,MAAM,GAAG,IAAI,CAAClB,MAAM,CAACmB,YAAY;IAEvC,IAAID,MAAM,EAAE;MACR,MAAMoB,aAAa,GAAGpB,MAAM,CAACqB,aAAa,EAAE;MAE5C,IAAI,IAAI,CAACxF,wBAAwB,KAAKL,wBAAwB,CAAC8F,UAAU,IAAI,IAAI,CAACzF,wBAAwB,KAAKL,wBAAwB,CAACM,aAAa,EAAE;QACnJqF,WAAW,GAAG,KAAK;QACnB,IAAII,IAAqB;QACzB,IAAI,IAAI,CAACC,YAAY,EAAE;UACnBD,IAAI,GAAG,IAAI,CAACC,YAAY,CAACC,UAAU,EAAG;;QAG1CF,IAAI,GAAGA,IAAI,IAAIH,aAAa;QAE5B,MAAMM,cAAc,GAAGvG,UAAU,CAACC,OAAO,CAAC,CAAC,CAAC;QAC5C,IAAIuE,IAAI,EAAE;UACNA,IAAI,CAAC9B,QAAQ,CAAC8D,aAAa,CAACJ,IAAI,CAACK,MAAM,EAAEF,cAAc,CAAC;SAC3D,MAAM;UACH,IAAI,CAAC5E,KAAK,CAAC+E,mBAAmB,EAAE,CAACF,aAAa,CAACJ,IAAI,CAACK,MAAM,EAAEF,cAAc,CAAC;;QAG/E,MAAMI,iBAAiB,GAAG1G,OAAO,CAAC2G,GAAG,CAACL,cAAc,EAAEH,IAAI,CAACS,SAAS,CAAC;QACrE,MAAMC,gBAAgB,GAAGH,iBAAiB,GAAGA,iBAAiB;QAE9D,IAAIA,iBAAiB,GAAG,CAAC,EAAE;UACvB,MAAMI,aAAa,GAAGR,cAAc,CAACS,aAAa,EAAE,GAAGF,gBAAgB;UACvE,IAAIC,aAAa,GAAG,IAAI,CAAClG,mBAAmB,GAAG,IAAI,CAACA,mBAAmB,EAAE;YACrEmF,WAAW,GAAG,IAAI;;;;MAK9B,IAAI,IAAI,CAACtF,wBAAwB,KAAKL,wBAAwB,CAAC4G,OAAO,IAAI,IAAI,CAACvG,wBAAwB,KAAKL,wBAAwB,CAACM,aAAa,EAAE;QAChJoF,WAAW,GAAG,KAAK;QAEnB,IAAIvB,IAAI,EAAE;UACN,MAAM0C,aAAa,GAAGlH,UAAU,CAACC,OAAO,CAAC,CAAC,CAAC;UAC3CA,OAAO,CAACkH,yBAAyB,CAACC,uBAAuB,CAAC5C,IAAI,CAAC5B,UAAU,EAAEsE,aAAa,CAAC;UAEzF,IAAIjH,OAAO,CAAC2G,GAAG,CAACM,aAAa,EAAEjB,aAAa,CAACY,SAAS,CAAC,GAAG,IAAI,CAACjG,gBAAgB,GAAG,CAAC,GAAG,CAAC,EAAE;YACrFmF,WAAW,GAAG,IAAI;;;;;IAMlC,IAAI,CAACpE,KAAK,CAACC,UAAU,CAACmE,WAAW,IAAIC,WAAW,CAAC;EACrD;EAEA;;;EAGOqB,MAAMA,CAAA;IACT,IAAI,CAAC1D,MAAM,CAACW,wBAAwB,CAACgD,MAAM,CAAC,IAAI,CAAC9G,oBAAoB,CAAC;EAC1E;EAEA;;;;EAIO+G,kBAAkBA,CAACC,EAAgD;IACtE,MAAMC,eAAe,GAA0BD,EAA4B,CAACC,eAAe,GAAID,EAA4B,CAACC,eAAe,GAAID,EAA2B;IAC1K,IAAI,CAACC,eAAe,EAAE;MAClBvH,KAAK,CAACwH,KAAK,CAAC,sFAAsF,CAAC;KACtG,MAAM;MACH,IAAI;QACA,IAAI,CAACrB,YAAY,GAAGoB,eAAe,CAACE,iBAAiB,CAAC9H,gBAAgB,CAAC+H,YAAY,CAAqB;OAC3G,CAAC,OAAAC,EAAA,EAAM;MAER,IAAI;QACA,IAAI,CAAC9F,aAAa,GAAG0F,eAAe,CAACE,iBAAiB,CAAC9H,gBAAgB,CAACiI,aAAa,CAAsB;OAC9G,CAAC,OAAAC,EAAA,EAAM;QACJ7H,KAAK,CAACwH,KAAK,CAAC,yDAAyD,CAAC;;;EAGlF"},"metadata":{},"sourceType":"module","externalDependencies":[]}