{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { Logger } from \"../Misc/logger.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { DataBuffer } from \"../Buffers/dataBuffer.js\";\nimport { PerformanceConfigurator } from \"./performanceConfigurator.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport { RenderTargetWrapper } from \"./renderTargetWrapper.js\";\n/**\n * Options to create the null engine\n */\nexport class NullEngineOptions {\n  constructor() {\n    /**\n     * Render width (Default: 512)\n     */\n    this.renderWidth = 512;\n    /**\n     * Render height (Default: 256)\n     */\n    this.renderHeight = 256;\n    /**\n     * Texture size (Default: 512)\n     */\n    this.textureSize = 512;\n    /**\n     * If delta time between frames should be constant\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n     */\n    this.deterministicLockstep = false;\n    /**\n     * Maximum about of steps between frames (Default: 4)\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n     */\n    this.lockstepMaxSteps = 4;\n  }\n}\n/**\n * The null engine class provides support for headless version of babylon.js.\n * This can be used in server side scenario or for testing purposes\n */\nexport class NullEngine extends Engine {\n  /**\n   * Gets a boolean indicating that the engine is running in deterministic lock step mode\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n   * @returns true if engine is in deterministic lock step mode\n   */\n  isDeterministicLockStep() {\n    return this._options.deterministicLockstep;\n  }\n  /**\n   * Gets the max steps when engine is running in deterministic lock step\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n   * @returns the max steps\n   */\n  getLockstepMaxSteps() {\n    return this._options.lockstepMaxSteps;\n  }\n  /**\n   * Gets the current hardware scaling level.\n   * By default the hardware scaling level is computed from the window device ratio.\n   * if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.\n   * @returns a number indicating the current hardware scaling level\n   */\n  getHardwareScalingLevel() {\n    return 1.0;\n  }\n  constructor(options = new NullEngineOptions()) {\n    super(null);\n    Engine.Instances.push(this);\n    if (options.deterministicLockstep === undefined) {\n      options.deterministicLockstep = false;\n    }\n    if (options.lockstepMaxSteps === undefined) {\n      options.lockstepMaxSteps = 4;\n    }\n    this._options = options;\n    PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix);\n    // Init caps\n    // We consider we are on a webgl1 capable device\n    this._caps = {\n      maxTexturesImageUnits: 16,\n      maxVertexTextureImageUnits: 16,\n      maxCombinedTexturesImageUnits: 32,\n      maxTextureSize: 512,\n      maxCubemapTextureSize: 512,\n      maxRenderTextureSize: 512,\n      maxVertexAttribs: 16,\n      maxVaryingVectors: 16,\n      maxFragmentUniformVectors: 16,\n      maxVertexUniformVectors: 16,\n      standardDerivatives: false,\n      astc: null,\n      pvrtc: null,\n      etc1: null,\n      etc2: null,\n      bptc: null,\n      maxAnisotropy: 0,\n      uintIndices: false,\n      fragmentDepthSupported: false,\n      highPrecisionShaderSupported: true,\n      colorBufferFloat: false,\n      textureFloat: false,\n      textureFloatLinearFiltering: false,\n      textureFloatRender: false,\n      textureHalfFloat: false,\n      textureHalfFloatLinearFiltering: false,\n      textureHalfFloatRender: false,\n      textureLOD: false,\n      texelFetch: false,\n      drawBuffersExtension: false,\n      depthTextureExtension: false,\n      vertexArrayObject: false,\n      instancedArrays: false,\n      supportOcclusionQuery: false,\n      canUseTimestampForTimerQuery: false,\n      maxMSAASamples: 1,\n      blendMinMax: false,\n      canUseGLInstanceID: false,\n      canUseGLVertexID: false,\n      supportComputeShaders: false,\n      supportSRGBBuffers: false,\n      supportTransformFeedbacks: false,\n      textureMaxLevel: false,\n      texture2DArrayMaxLayerCount: 128,\n      disableMorphTargetTexture: false\n    };\n    this._features = {\n      forceBitmapOverHTMLImageElement: false,\n      supportRenderAndCopyToLodForFloatTextures: false,\n      supportDepthStencilTexture: false,\n      supportShadowSamplers: false,\n      uniformBufferHardCheckMatrix: false,\n      allowTexturePrefiltering: false,\n      trackUbosInFrame: false,\n      checkUbosContentBeforeUpload: false,\n      supportCSM: false,\n      basisNeedsPOT: false,\n      support3DTextures: false,\n      needTypeSuffixInShaderConstants: false,\n      supportMSAA: false,\n      supportSSAO2: false,\n      supportExtendedTextureFormats: false,\n      supportSwitchCaseInShader: false,\n      supportSyncTextureRead: false,\n      needsInvertingBitmap: false,\n      useUBOBindingCache: false,\n      needShaderCodeInlining: false,\n      needToAlwaysBindUniformBuffers: false,\n      supportRenderPasses: true,\n      supportSpriteInstancing: false,\n      forceVertexBufferStrideMultiple4Bytes: false,\n      _collectUbosUpdatedInFrame: false\n    };\n    Logger.Log(`Babylon.js v${Engine.Version} - Null engine`);\n    // Wrappers\n    const theCurrentGlobal = typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : window;\n    if (typeof URL === \"undefined\") {\n      theCurrentGlobal.URL = {\n        createObjectURL: function () {},\n        revokeObjectURL: function () {}\n      };\n    }\n    if (typeof Blob === \"undefined\") {\n      theCurrentGlobal.Blob = function () {};\n    }\n  }\n  /**\n   * Creates a vertex buffer\n   * @param vertices the data for the vertex buffer\n   * @returns the new WebGL static buffer\n   */\n  createVertexBuffer(vertices) {\n    const buffer = new DataBuffer();\n    buffer.references = 1;\n    return buffer;\n  }\n  /**\n   * Creates a new index buffer\n   * @param indices defines the content of the index buffer\n   * @returns a new webGL buffer\n   */\n  createIndexBuffer(indices) {\n    const buffer = new DataBuffer();\n    buffer.references = 1;\n    return buffer;\n  }\n  /**\n   * Clear the current render buffer or the current render target (if any is set up)\n   * @param color defines the color to use\n   * @param backBuffer defines if the back buffer must be cleared\n   * @param depth defines if the depth buffer must be cleared\n   * @param stencil defines if the stencil buffer must be cleared\n   */\n  clear(color, backBuffer, depth, stencil = false) {}\n  /**\n   * Gets the current render width\n   * @param useScreen defines if screen size must be used (or the current render target if any)\n   * @returns a number defining the current render width\n   */\n  getRenderWidth(useScreen = false) {\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.width;\n    }\n    return this._options.renderWidth;\n  }\n  /**\n   * Gets the current render height\n   * @param useScreen defines if screen size must be used (or the current render target if any)\n   * @returns a number defining the current render height\n   */\n  getRenderHeight(useScreen = false) {\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.height;\n    }\n    return this._options.renderHeight;\n  }\n  /**\n   * Set the WebGL's viewport\n   * @param viewport defines the viewport element to be used\n   * @param requiredWidth defines the width required for rendering. If not provided the rendering canvas' width is used\n   * @param requiredHeight defines the height required for rendering. If not provided the rendering canvas' height is used\n   */\n  setViewport(viewport, requiredWidth, requiredHeight) {\n    this._cachedViewport = viewport;\n  }\n  createShaderProgram(pipelineContext, vertexCode, fragmentCode, defines, context) {\n    return {\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      __SPECTOR_rebuildProgram: null\n    };\n  }\n  /**\n   * Gets the list of webGL uniform locations associated with a specific program based on a list of uniform names\n   * @param pipelineContext defines the pipeline context to use\n   * @param uniformsNames defines the list of uniform names\n   * @returns an array of webGL uniform locations\n   */\n  getUniforms(pipelineContext, uniformsNames) {\n    return [];\n  }\n  /**\n   * Gets the lsit of active attributes for a given webGL program\n   * @param pipelineContext defines the pipeline context to use\n   * @param attributesNames defines the list of attribute names to get\n   * @returns an array of indices indicating the offset of each attribute\n   */\n  getAttributes(pipelineContext, attributesNames) {\n    return [];\n  }\n  /**\n   * Binds an effect to the webGL context\n   * @param effect defines the effect to bind\n   */\n  bindSamplers(effect) {\n    this._currentEffect = null;\n  }\n  /**\n   * Activates an effect, making it the current one (ie. the one used for rendering)\n   * @param effect defines the effect to activate\n   */\n  enableEffect(effect) {\n    effect = effect !== null && DrawWrapper.IsWrapper(effect) ? effect.effect : effect; // get only the effect, we don't need a Wrapper in the WebGL engine\n    this._currentEffect = effect;\n    if (!effect) {\n      return;\n    }\n    if (effect.onBind) {\n      effect.onBind(effect);\n    }\n    if (effect._onBindObservable) {\n      effect._onBindObservable.notifyObservers(effect);\n    }\n  }\n  /**\n   * Set various states to the webGL context\n   * @param culling defines culling state: true to enable culling, false to disable it\n   * @param zOffset defines the value to apply to zOffset (0 by default)\n   * @param force defines if states must be applied even if cache is up to date\n   * @param reverseSide defines if culling must be reversed (CCW if false, CW if true)\n   * @param cullBackFaces true to cull back faces, false to cull front faces (if culling is enabled)\n   * @param stencil stencil states to set\n   * @param zOffsetUnits defines the value to apply to zOffsetUnits (0 by default)\n   */\n  setState(culling, zOffset = 0, force, reverseSide = false, cullBackFaces, stencil, zOffsetUnits = 0) {}\n  /**\n   * Set the value of an uniform to an array of int32\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of int32 to store\n   * @returns true if value was set\n   */\n  setIntArray(uniform, array) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to an array of int32 (stored as vec2)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of int32 to store\n   * @returns true if value was set\n   */\n  setIntArray2(uniform, array) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to an array of int32 (stored as vec3)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of int32 to store\n   * @returns true if value was set\n   */\n  setIntArray3(uniform, array) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to an array of int32 (stored as vec4)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of int32 to store\n   * @returns true if value was set\n   */\n  setIntArray4(uniform, array) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to an array of float32\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of float32 to store\n   * @returns true if value was set\n   */\n  setFloatArray(uniform, array) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to an array of float32 (stored as vec2)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of float32 to store\n   * @returns true if value was set\n   */\n  setFloatArray2(uniform, array) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to an array of float32 (stored as vec3)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of float32 to store\n   * @returns true if value was set\n   */\n  setFloatArray3(uniform, array) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to an array of float32 (stored as vec4)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of float32 to store\n   * @returns true if value was set\n   */\n  setFloatArray4(uniform, array) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to an array of number\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of number to store\n   * @returns true if value was set\n   */\n  setArray(uniform, array) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to an array of number (stored as vec2)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of number to store\n   * @returns true if value was set\n   */\n  setArray2(uniform, array) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to an array of number (stored as vec3)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of number to store\n   * @returns true if value was set\n   */\n  setArray3(uniform, array) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to an array of number (stored as vec4)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of number to store\n   * @returns true if value was set\n   */\n  setArray4(uniform, array) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to an array of float32 (stored as matrices)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param matrices defines the array of float32 to store\n   * @returns true if value was set\n   */\n  setMatrices(uniform, matrices) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to a matrix (3x3)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param matrix defines the Float32Array representing the 3x3 matrix to store\n   * @returns true if value was set\n   */\n  setMatrix3x3(uniform, matrix) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to a matrix (2x2)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param matrix defines the Float32Array representing the 2x2 matrix to store\n   * @returns true if value was set\n   */\n  setMatrix2x2(uniform, matrix) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to a number (float)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param value defines the float number to store\n   * @returns true if value was set\n   */\n  setFloat(uniform, value) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to a vec2\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param x defines the 1st component of the value\n   * @param y defines the 2nd component of the value\n   * @returns true if value was set\n   */\n  setFloat2(uniform, x, y) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to a vec3\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param x defines the 1st component of the value\n   * @param y defines the 2nd component of the value\n   * @param z defines the 3rd component of the value\n   * @returns true if value was set\n   */\n  setFloat3(uniform, x, y, z) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to a boolean\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param bool defines the boolean to store\n   * @returns true if value was set\n   */\n  setBool(uniform, bool) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to a vec4\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param x defines the 1st component of the value\n   * @param y defines the 2nd component of the value\n   * @param z defines the 3rd component of the value\n   * @param w defines the 4th component of the value\n   * @returns true if value was set\n   */\n  setFloat4(uniform, x, y, z, w) {\n    return true;\n  }\n  /**\n   * Sets the current alpha mode\n   * @param mode defines the mode to use (one of the Engine.ALPHA_XXX)\n   * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering\n   */\n  setAlphaMode(mode, noDepthWriteChange = false) {\n    if (this._alphaMode === mode) {\n      return;\n    }\n    this.alphaState.alphaBlend = mode !== 0;\n    if (!noDepthWriteChange) {\n      this.setDepthWrite(mode === 0);\n    }\n    this._alphaMode = mode;\n  }\n  /**\n   * Bind webGl buffers directly to the webGL context\n   * @param vertexBuffers defines the vertex buffer to bind\n   * @param indexBuffer defines the index buffer to bind\n   * @param effect defines the effect associated with the vertex buffer\n   */\n  bindBuffers(vertexBuffers, indexBuffer, effect) {}\n  /**\n   * Force the entire cache to be cleared\n   * You should not have to use this function unless your engine needs to share the webGL context with another engine\n   * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)\n   */\n  wipeCaches(bruteForce) {\n    if (this.preventCacheWipeBetweenFrames) {\n      return;\n    }\n    this.resetTextureCache();\n    this._currentEffect = null;\n    if (bruteForce) {\n      this._currentProgram = null;\n      this._stencilStateComposer.reset();\n      this.depthCullingState.reset();\n      this.alphaState.reset();\n    }\n    this._cachedVertexBuffers = null;\n    this._cachedIndexBuffer = null;\n    this._cachedEffectForVertexBuffers = null;\n  }\n  /**\n   * Send a draw order\n   * @param useTriangles defines if triangles must be used to draw (else wireframe will be used)\n   * @param indexStart defines the starting index\n   * @param indexCount defines the number of index to draw\n   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n   */\n  draw(useTriangles, indexStart, indexCount, instancesCount) {}\n  /**\n   * Draw a list of indexed primitives\n   * @param fillMode defines the primitive to use\n   * @param indexStart defines the starting index\n   * @param indexCount defines the number of index to draw\n   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n   */\n  drawElementsType(fillMode, indexStart, indexCount, instancesCount) {}\n  /**\n   * Draw a list of unindexed primitives\n   * @param fillMode defines the primitive to use\n   * @param verticesStart defines the index of first vertex to draw\n   * @param verticesCount defines the count of vertices to draw\n   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n   */\n  drawArraysType(fillMode, verticesStart, verticesCount, instancesCount) {}\n  /** @internal */\n  _createTexture() {\n    return {};\n  }\n  /**\n   * @internal\n   */\n  _releaseTexture(texture) {}\n  /**\n   * Usually called from Texture.ts.\n   * Passed information to create a WebGLTexture\n   * @param urlArg defines a value which contains one of the following:\n   * * A conventional http URL, e.g. 'http://...' or 'file://...'\n   * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\n   * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\n   * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\n   * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\n   * @param scene needed for loading to the correct scene\n   * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\n   * @param onLoad optional callback to be called upon successful completion\n   * @param onError optional callback to be called upon failure\n   * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\n   * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\n   * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\n   * @param forcedExtension defines the extension to use to pick the right loader\n   * @param mimeType defines an optional mime type\n   * @returns a InternalTexture for assignment back into BABYLON.Texture\n   */\n  createTexture(urlArg, noMipmap, invertY, scene, samplingMode = 3, onLoad = null, onError = null, buffer = null, fallback = null, format = null, forcedExtension = null, mimeType) {\n    const texture = new InternalTexture(this, InternalTextureSource.Url);\n    const url = String(urlArg);\n    texture.url = url;\n    texture.generateMipMaps = !noMipmap;\n    texture.samplingMode = samplingMode;\n    texture.invertY = invertY;\n    texture.baseWidth = this._options.textureSize;\n    texture.baseHeight = this._options.textureSize;\n    texture.width = this._options.textureSize;\n    texture.height = this._options.textureSize;\n    if (format) {\n      texture.format = format;\n    }\n    texture.isReady = true;\n    if (onLoad) {\n      setTimeout(() => {\n        onLoad(texture);\n      });\n    }\n    this._internalTexturesCache.push(texture);\n    return texture;\n  }\n  /**\n   * @internal\n   */\n  _createHardwareRenderTargetWrapper(isMulti, isCube, size) {\n    const rtWrapper = new RenderTargetWrapper(isMulti, isCube, size, this);\n    this._renderTargetWrapperCache.push(rtWrapper);\n    return rtWrapper;\n  }\n  /**\n   * Creates a new render target wrapper\n   * @param size defines the size of the texture\n   * @param options defines the options used to create the texture\n   * @returns a new render target wrapper\n   */\n  createRenderTargetTexture(size, options) {\n    const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size);\n    const fullOptions = {};\n    if (options !== undefined && typeof options === \"object\") {\n      fullOptions.generateMipMaps = options.generateMipMaps;\n      fullOptions.generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n      fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && options.generateStencilBuffer;\n      fullOptions.type = options.type === undefined ? 0 : options.type;\n      fullOptions.samplingMode = options.samplingMode === undefined ? 3 : options.samplingMode;\n    } else {\n      fullOptions.generateMipMaps = options;\n      fullOptions.generateDepthBuffer = true;\n      fullOptions.generateStencilBuffer = false;\n      fullOptions.type = 0;\n      fullOptions.samplingMode = 3;\n    }\n    const texture = new InternalTexture(this, InternalTextureSource.RenderTarget);\n    const width = size.width || size;\n    const height = size.height || size;\n    rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;\n    rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = width;\n    texture.height = height;\n    texture.isReady = true;\n    texture.samples = 1;\n    texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;\n    texture.samplingMode = fullOptions.samplingMode;\n    texture.type = fullOptions.type;\n    this._internalTexturesCache.push(texture);\n    return rtWrapper;\n  }\n  /**\n   * Creates a new render target wrapper\n   * @param size defines the size of the texture\n   * @param options defines the options used to create the texture\n   * @returns a new render target wrapper\n   */\n  createRenderTargetCubeTexture(size, options) {\n    const rtWrapper = this._createHardwareRenderTargetWrapper(false, true, size);\n    const fullOptions = Object.assign({\n      generateMipMaps: true,\n      generateDepthBuffer: true,\n      generateStencilBuffer: false,\n      type: 0,\n      samplingMode: 3,\n      format: 5\n    }, options);\n    fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && fullOptions.generateStencilBuffer;\n    if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {\n      // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\n      fullOptions.samplingMode = 1;\n    } else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\n      // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\n      fullOptions.samplingMode = 1;\n    }\n    rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;\n    rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;\n    const texture = new InternalTexture(this, InternalTextureSource.RenderTarget);\n    texture.baseWidth = size;\n    texture.baseHeight = size;\n    texture.width = size;\n    texture.height = size;\n    texture.isReady = true;\n    texture.isCube = true;\n    texture.samples = 1;\n    texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;\n    texture.samplingMode = fullOptions.samplingMode;\n    texture.type = fullOptions.type;\n    this._internalTexturesCache.push(texture);\n    return rtWrapper;\n  }\n  /**\n   * Update the sampling mode of a given texture\n   * @param samplingMode defines the required sampling mode\n   * @param texture defines the texture to update\n   */\n  updateTextureSamplingMode(samplingMode, texture) {\n    texture.samplingMode = samplingMode;\n  }\n  /**\n   * Creates a raw texture\n   * @param data defines the data to store in the texture\n   * @param width defines the width of the texture\n   * @param height defines the height of the texture\n   * @param format defines the format of the data\n   * @param generateMipMaps defines if the engine should generate the mip levels\n   * @param invertY defines if data must be stored with Y axis inverted\n   * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\n   * @param compression defines the compression used (null by default)\n   * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\n   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n   * @returns the raw texture inside an InternalTexture\n   */\n  createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, compression = null, type = 0, creationFlags = 0, useSRGBBuffer = false) {\n    const texture = new InternalTexture(this, InternalTextureSource.Raw);\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = width;\n    texture.height = height;\n    texture.format = format;\n    texture.generateMipMaps = generateMipMaps;\n    texture.samplingMode = samplingMode;\n    texture.invertY = invertY;\n    texture._compression = compression;\n    texture.type = type;\n    texture._useSRGBBuffer = useSRGBBuffer;\n    if (!this._doNotHandleContextLost) {\n      texture._bufferView = data;\n    }\n    return texture;\n  }\n  /**\n   * Update a raw texture\n   * @param texture defines the texture to update\n   * @param data defines the data to store in the texture\n   * @param format defines the format of the data\n   * @param invertY defines if data must be stored with Y axis inverted\n   * @param compression defines the compression used (null by default)\n   * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\n   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n   */\n  updateRawTexture(texture, data, format, invertY, compression = null, type = 0, useSRGBBuffer = false) {\n    if (texture) {\n      texture._bufferView = data;\n      texture.format = format;\n      texture.invertY = invertY;\n      texture._compression = compression;\n      texture.type = type;\n      texture._useSRGBBuffer = useSRGBBuffer;\n    }\n  }\n  /**\n   * Binds the frame buffer to the specified texture.\n   * @param rtWrapper The render target wrapper to render to\n   * @param faceIndex The face of the texture to render to in case of cube texture\n   * @param requiredWidth The width of the target to render to\n   * @param requiredHeight The height of the target to render to\n   * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true\n   */\n  bindFramebuffer(rtWrapper, faceIndex, requiredWidth, requiredHeight, forceFullscreenViewport) {\n    if (this._currentRenderTarget) {\n      this.unBindFramebuffer(this._currentRenderTarget);\n    }\n    this._currentRenderTarget = rtWrapper;\n    this._currentFramebuffer = null;\n    if (this._cachedViewport && !forceFullscreenViewport) {\n      this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);\n    }\n  }\n  /**\n   * Unbind the current render target texture from the webGL context\n   * @param rtWrapper defines the render target wrapper to unbind\n   * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\n   * @param onBeforeUnbind defines a function which will be called before the effective unbind\n   */\n  unBindFramebuffer(rtWrapper, disableGenerateMipMaps = false, onBeforeUnbind) {\n    this._currentRenderTarget = null;\n    if (onBeforeUnbind) {\n      onBeforeUnbind();\n    }\n    this._currentFramebuffer = null;\n  }\n  /**\n   * Creates a dynamic vertex buffer\n   * @param vertices the data for the dynamic vertex buffer\n   * @returns the new WebGL dynamic buffer\n   */\n  createDynamicVertexBuffer(vertices) {\n    const buffer = new DataBuffer();\n    buffer.references = 1;\n    buffer.capacity = 1;\n    return buffer;\n  }\n  /**\n   * Update the content of a dynamic texture\n   * @param texture defines the texture to update\n   * @param canvas defines the canvas containing the source\n   * @param invertY defines if data must be stored with Y axis inverted\n   * @param premulAlpha defines if alpha is stored as premultiplied\n   * @param format defines the format of the data\n   */\n  updateDynamicTexture(texture, canvas, invertY, premulAlpha = false, format) {}\n  /**\n   * Gets a boolean indicating if all created effects are ready\n   * @returns true if all effects are ready\n   */\n  areAllEffectsReady() {\n    return true;\n  }\n  /**\n   * @internal\n   * Get the current error code of the webGL context\n   * @returns the error code\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getError\n   */\n  getError() {\n    return 0;\n  }\n  /** @internal */\n  _getUnpackAlignement() {\n    return 1;\n  }\n  /**\n   * @internal\n   */\n  _unpackFlipY(value) {}\n  /**\n   * Update a dynamic index buffer\n   * @param indexBuffer defines the target index buffer\n   * @param indices defines the data to update\n   * @param offset defines the offset in the target index buffer where update should start\n   */\n  updateDynamicIndexBuffer(indexBuffer, indices, offset = 0) {}\n  /**\n   * Updates a dynamic vertex buffer.\n   * @param vertexBuffer the vertex buffer to update\n   * @param vertices the data used to update the vertex buffer\n   * @param byteOffset the byte offset of the data (optional)\n   * @param byteLength the byte length of the data (optional)\n   */\n  updateDynamicVertexBuffer(vertexBuffer, vertices, byteOffset, byteLength) {}\n  /**\n   * @internal\n   */\n  _bindTextureDirectly(target, texture) {\n    if (this._boundTexturesCache[this._activeChannel] !== texture) {\n      this._boundTexturesCache[this._activeChannel] = texture;\n      return true;\n    }\n    return false;\n  }\n  /**\n   * @internal\n   */\n  _bindTexture(channel, texture) {\n    if (channel < 0) {\n      return;\n    }\n    this._bindTextureDirectly(0, texture);\n  }\n  _deleteBuffer(buffer) {}\n  /**\n   * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled\n   */\n  releaseEffects() {}\n  displayLoadingUI() {}\n  hideLoadingUI() {}\n  set loadingUIText(_) {}\n  /**\n   * @internal\n   */\n  _uploadCompressedDataToTextureDirectly(texture, internalFormat, width, height, data, faceIndex = 0, lod = 0) {}\n  /**\n   * @internal\n   */\n  _uploadDataToTextureDirectly(texture, imageData, faceIndex = 0, lod = 0) {}\n  /**\n   * @internal\n   */\n  _uploadArrayBufferViewToTexture(texture, imageData, faceIndex = 0, lod = 0) {}\n  /**\n   * @internal\n   */\n  _uploadImageToTexture(texture, image, faceIndex = 0, lod = 0) {}\n}","map":{"version":3,"names":["Logger","Engine","InternalTexture","InternalTextureSource","DataBuffer","PerformanceConfigurator","DrawWrapper","RenderTargetWrapper","NullEngineOptions","constructor","renderWidth","renderHeight","textureSize","deterministicLockstep","lockstepMaxSteps","NullEngine","isDeterministicLockStep","_options","getLockstepMaxSteps","getHardwareScalingLevel","options","Instances","push","undefined","SetMatrixPrecision","useHighPrecisionMatrix","_caps","maxTexturesImageUnits","maxVertexTextureImageUnits","maxCombinedTexturesImageUnits","maxTextureSize","maxCubemapTextureSize","maxRenderTextureSize","maxVertexAttribs","maxVaryingVectors","maxFragmentUniformVectors","maxVertexUniformVectors","standardDerivatives","astc","pvrtc","etc1","etc2","bptc","maxAnisotropy","uintIndices","fragmentDepthSupported","highPrecisionShaderSupported","colorBufferFloat","textureFloat","textureFloatLinearFiltering","textureFloatRender","textureHalfFloat","textureHalfFloatLinearFiltering","textureHalfFloatRender","textureLOD","texelFetch","drawBuffersExtension","depthTextureExtension","vertexArrayObject","instancedArrays","supportOcclusionQuery","canUseTimestampForTimerQuery","maxMSAASamples","blendMinMax","canUseGLInstanceID","canUseGLVertexID","supportComputeShaders","supportSRGBBuffers","supportTransformFeedbacks","textureMaxLevel","texture2DArrayMaxLayerCount","disableMorphTargetTexture","_features","forceBitmapOverHTMLImageElement","supportRenderAndCopyToLodForFloatTextures","supportDepthStencilTexture","supportShadowSamplers","uniformBufferHardCheckMatrix","allowTexturePrefiltering","trackUbosInFrame","checkUbosContentBeforeUpload","supportCSM","basisNeedsPOT","support3DTextures","needTypeSuffixInShaderConstants","supportMSAA","supportSSAO2","supportExtendedTextureFormats","supportSwitchCaseInShader","supportSyncTextureRead","needsInvertingBitmap","useUBOBindingCache","needShaderCodeInlining","needToAlwaysBindUniformBuffers","supportRenderPasses","supportSpriteInstancing","forceVertexBufferStrideMultiple4Bytes","_collectUbosUpdatedInFrame","Log","Version","theCurrentGlobal","self","global","window","URL","createObjectURL","revokeObjectURL","Blob","createVertexBuffer","vertices","buffer","references","createIndexBuffer","indices","clear","color","backBuffer","depth","stencil","getRenderWidth","useScreen","_currentRenderTarget","width","getRenderHeight","height","setViewport","viewport","requiredWidth","requiredHeight","_cachedViewport","createShaderProgram","pipelineContext","vertexCode","fragmentCode","defines","context","__SPECTOR_rebuildProgram","getUniforms","uniformsNames","getAttributes","attributesNames","bindSamplers","effect","_currentEffect","enableEffect","IsWrapper","onBind","_onBindObservable","notifyObservers","setState","culling","zOffset","force","reverseSide","cullBackFaces","zOffsetUnits","setIntArray","uniform","array","setIntArray2","setIntArray3","setIntArray4","setFloatArray","setFloatArray2","setFloatArray3","setFloatArray4","setArray","setArray2","setArray3","setArray4","setMatrices","matrices","setMatrix3x3","matrix","setMatrix2x2","setFloat","value","setFloat2","x","y","setFloat3","z","setBool","bool","setFloat4","w","setAlphaMode","mode","noDepthWriteChange","_alphaMode","alphaState","alphaBlend","setDepthWrite","bindBuffers","vertexBuffers","indexBuffer","wipeCaches","bruteForce","preventCacheWipeBetweenFrames","resetTextureCache","_currentProgram","_stencilStateComposer","reset","depthCullingState","_cachedVertexBuffers","_cachedIndexBuffer","_cachedEffectForVertexBuffers","draw","useTriangles","indexStart","indexCount","instancesCount","drawElementsType","fillMode","drawArraysType","verticesStart","verticesCount","_createTexture","_releaseTexture","texture","createTexture","urlArg","noMipmap","invertY","scene","samplingMode","onLoad","onError","fallback","format","forcedExtension","mimeType","Url","url","String","generateMipMaps","baseWidth","baseHeight","isReady","setTimeout","_internalTexturesCache","_createHardwareRenderTargetWrapper","isMulti","isCube","size","rtWrapper","_renderTargetWrapperCache","createRenderTargetTexture","fullOptions","generateDepthBuffer","generateStencilBuffer","type","RenderTarget","_generateDepthBuffer","_generateStencilBuffer","samples","createRenderTargetCubeTexture","Object","assign","updateTextureSamplingMode","createRawTexture","data","compression","creationFlags","useSRGBBuffer","Raw","_compression","_useSRGBBuffer","_doNotHandleContextLost","_bufferView","updateRawTexture","bindFramebuffer","faceIndex","forceFullscreenViewport","unBindFramebuffer","_currentFramebuffer","disableGenerateMipMaps","onBeforeUnbind","createDynamicVertexBuffer","capacity","updateDynamicTexture","canvas","premulAlpha","areAllEffectsReady","getError","_getUnpackAlignement","_unpackFlipY","updateDynamicIndexBuffer","offset","updateDynamicVertexBuffer","vertexBuffer","byteOffset","byteLength","_bindTextureDirectly","target","_boundTexturesCache","_activeChannel","_bindTexture","channel","_deleteBuffer","releaseEffects","displayLoadingUI","hideLoadingUI","loadingUIText","_","_uploadCompressedDataToTextureDirectly","internalFormat","lod","_uploadDataToTextureDirectly","imageData","_uploadArrayBufferViewToTexture","_uploadImageToTexture","image"],"sources":["../../../../dev/core/src/Engines/nullEngine.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport type { RenderTargetCreationOptions } from \"../Materials/Textures/textureCreationOptions\";\r\nimport type { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Constants } from \"./constants\";\r\nimport type { IPipelineContext } from \"./IPipelineContext\";\r\nimport { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { IColor4Like, IViewportLike } from \"../Maths/math.like\";\r\nimport type { ISceneLike } from \"./thinEngine\";\r\nimport { PerformanceConfigurator } from \"./performanceConfigurator\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport { RenderTargetWrapper } from \"./renderTargetWrapper\";\r\nimport type { IStencilState } from \"../States/IStencilState\";\r\n\r\ndeclare const global: any;\r\n\r\n/**\r\n * Options to create the null engine\r\n */\r\nexport class NullEngineOptions {\r\n    /**\r\n     * Render width (Default: 512)\r\n     */\r\n    public renderWidth = 512;\r\n    /**\r\n     * Render height (Default: 256)\r\n     */\r\n    public renderHeight = 256;\r\n\r\n    /**\r\n     * Texture size (Default: 512)\r\n     */\r\n    public textureSize = 512;\r\n\r\n    /**\r\n     * If delta time between frames should be constant\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\r\n     */\r\n    public deterministicLockstep = false;\r\n\r\n    /**\r\n     * Maximum about of steps between frames (Default: 4)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\r\n     */\r\n    public lockstepMaxSteps = 4;\r\n\r\n    /**\r\n     * Make the matrix computations to be performed in 64 bits instead of 32 bits. False by default\r\n     */\r\n    useHighPrecisionMatrix?: boolean;\r\n}\r\n\r\n/**\r\n * The null engine class provides support for headless version of babylon.js.\r\n * This can be used in server side scenario or for testing purposes\r\n */\r\nexport class NullEngine extends Engine {\r\n    private _options: NullEngineOptions;\r\n\r\n    /**\r\n     * Gets a boolean indicating that the engine is running in deterministic lock step mode\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\r\n     * @returns true if engine is in deterministic lock step mode\r\n     */\r\n    public isDeterministicLockStep(): boolean {\r\n        return this._options.deterministicLockstep;\r\n    }\r\n\r\n    /**\r\n     * Gets the max steps when engine is running in deterministic lock step\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\r\n     * @returns the max steps\r\n     */\r\n    public getLockstepMaxSteps(): number {\r\n        return this._options.lockstepMaxSteps;\r\n    }\r\n\r\n    /**\r\n     * Gets the current hardware scaling level.\r\n     * By default the hardware scaling level is computed from the window device ratio.\r\n     * if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.\r\n     * @returns a number indicating the current hardware scaling level\r\n     */\r\n    public getHardwareScalingLevel(): number {\r\n        return 1.0;\r\n    }\r\n\r\n    public constructor(options: NullEngineOptions = new NullEngineOptions()) {\r\n        super(null);\r\n\r\n        Engine.Instances.push(this);\r\n\r\n        if (options.deterministicLockstep === undefined) {\r\n            options.deterministicLockstep = false;\r\n        }\r\n\r\n        if (options.lockstepMaxSteps === undefined) {\r\n            options.lockstepMaxSteps = 4;\r\n        }\r\n\r\n        this._options = options;\r\n\r\n        PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix);\r\n\r\n        // Init caps\r\n        // We consider we are on a webgl1 capable device\r\n\r\n        this._caps = {\r\n            maxTexturesImageUnits: 16,\r\n            maxVertexTextureImageUnits: 16,\r\n            maxCombinedTexturesImageUnits: 32,\r\n            maxTextureSize: 512,\r\n            maxCubemapTextureSize: 512,\r\n            maxRenderTextureSize: 512,\r\n            maxVertexAttribs: 16,\r\n            maxVaryingVectors: 16,\r\n            maxFragmentUniformVectors: 16,\r\n            maxVertexUniformVectors: 16,\r\n            standardDerivatives: false,\r\n            astc: null,\r\n            pvrtc: null,\r\n            etc1: null,\r\n            etc2: null,\r\n            bptc: null,\r\n            maxAnisotropy: 0,\r\n            uintIndices: false,\r\n            fragmentDepthSupported: false,\r\n            highPrecisionShaderSupported: true,\r\n            colorBufferFloat: false,\r\n            textureFloat: false,\r\n            textureFloatLinearFiltering: false,\r\n            textureFloatRender: false,\r\n            textureHalfFloat: false,\r\n            textureHalfFloatLinearFiltering: false,\r\n            textureHalfFloatRender: false,\r\n            textureLOD: false,\r\n            texelFetch: false,\r\n            drawBuffersExtension: false,\r\n            depthTextureExtension: false,\r\n            vertexArrayObject: false,\r\n            instancedArrays: false,\r\n            supportOcclusionQuery: false,\r\n            canUseTimestampForTimerQuery: false,\r\n            maxMSAASamples: 1,\r\n            blendMinMax: false,\r\n            canUseGLInstanceID: false,\r\n            canUseGLVertexID: false,\r\n            supportComputeShaders: false,\r\n            supportSRGBBuffers: false,\r\n            supportTransformFeedbacks: false,\r\n            textureMaxLevel: false,\r\n            texture2DArrayMaxLayerCount: 128,\r\n            disableMorphTargetTexture: false,\r\n        };\r\n\r\n        this._features = {\r\n            forceBitmapOverHTMLImageElement: false,\r\n            supportRenderAndCopyToLodForFloatTextures: false,\r\n            supportDepthStencilTexture: false,\r\n            supportShadowSamplers: false,\r\n            uniformBufferHardCheckMatrix: false,\r\n            allowTexturePrefiltering: false,\r\n            trackUbosInFrame: false,\r\n            checkUbosContentBeforeUpload: false,\r\n            supportCSM: false,\r\n            basisNeedsPOT: false,\r\n            support3DTextures: false,\r\n            needTypeSuffixInShaderConstants: false,\r\n            supportMSAA: false,\r\n            supportSSAO2: false,\r\n            supportExtendedTextureFormats: false,\r\n            supportSwitchCaseInShader: false,\r\n            supportSyncTextureRead: false,\r\n            needsInvertingBitmap: false,\r\n            useUBOBindingCache: false,\r\n            needShaderCodeInlining: false,\r\n            needToAlwaysBindUniformBuffers: false,\r\n            supportRenderPasses: true,\r\n            supportSpriteInstancing: false,\r\n            forceVertexBufferStrideMultiple4Bytes: false,\r\n            _collectUbosUpdatedInFrame: false,\r\n        };\r\n\r\n        Logger.Log(`Babylon.js v${Engine.Version} - Null engine`);\r\n\r\n        // Wrappers\r\n        const theCurrentGlobal = typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : window;\r\n        if (typeof URL === \"undefined\") {\r\n            theCurrentGlobal.URL = {\r\n                createObjectURL: function () {},\r\n                revokeObjectURL: function () {},\r\n            };\r\n        }\r\n        if (typeof Blob === \"undefined\") {\r\n            theCurrentGlobal.Blob = function () {};\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a vertex buffer\r\n     * @param vertices the data for the vertex buffer\r\n     * @returns the new WebGL static buffer\r\n     */\r\n    public createVertexBuffer(vertices: FloatArray): DataBuffer {\r\n        const buffer = new DataBuffer();\r\n        buffer.references = 1;\r\n        return buffer;\r\n    }\r\n\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the content of the index buffer\r\n     * @returns a new webGL buffer\r\n     */\r\n    public createIndexBuffer(indices: IndicesArray): DataBuffer {\r\n        const buffer = new DataBuffer();\r\n        buffer.references = 1;\r\n        return buffer;\r\n    }\r\n\r\n    /**\r\n     * Clear the current render buffer or the current render target (if any is set up)\r\n     * @param color defines the color to use\r\n     * @param backBuffer defines if the back buffer must be cleared\r\n     * @param depth defines if the depth buffer must be cleared\r\n     * @param stencil defines if the stencil buffer must be cleared\r\n     */\r\n    public clear(color: IColor4Like, backBuffer: boolean, depth: boolean, stencil: boolean = false): void {}\r\n\r\n    /**\r\n     * Gets the current render width\r\n     * @param useScreen defines if screen size must be used (or the current render target if any)\r\n     * @returns a number defining the current render width\r\n     */\r\n    public getRenderWidth(useScreen = false): number {\r\n        if (!useScreen && this._currentRenderTarget) {\r\n            return this._currentRenderTarget.width;\r\n        }\r\n\r\n        return this._options.renderWidth;\r\n    }\r\n\r\n    /**\r\n     * Gets the current render height\r\n     * @param useScreen defines if screen size must be used (or the current render target if any)\r\n     * @returns a number defining the current render height\r\n     */\r\n    public getRenderHeight(useScreen = false): number {\r\n        if (!useScreen && this._currentRenderTarget) {\r\n            return this._currentRenderTarget.height;\r\n        }\r\n\r\n        return this._options.renderHeight;\r\n    }\r\n\r\n    /**\r\n     * Set the WebGL's viewport\r\n     * @param viewport defines the viewport element to be used\r\n     * @param requiredWidth defines the width required for rendering. If not provided the rendering canvas' width is used\r\n     * @param requiredHeight defines the height required for rendering. If not provided the rendering canvas' height is used\r\n     */\r\n    public setViewport(viewport: IViewportLike, requiredWidth?: number, requiredHeight?: number): void {\r\n        this._cachedViewport = viewport;\r\n    }\r\n\r\n    public createShaderProgram(pipelineContext: IPipelineContext, vertexCode: string, fragmentCode: string, defines: string, context?: WebGLRenderingContext): WebGLProgram {\r\n        return {\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            __SPECTOR_rebuildProgram: null,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the list of webGL uniform locations associated with a specific program based on a list of uniform names\r\n     * @param pipelineContext defines the pipeline context to use\r\n     * @param uniformsNames defines the list of uniform names\r\n     * @returns an array of webGL uniform locations\r\n     */\r\n    public getUniforms(pipelineContext: IPipelineContext, uniformsNames: string[]): Nullable<WebGLUniformLocation>[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Gets the lsit of active attributes for a given webGL program\r\n     * @param pipelineContext defines the pipeline context to use\r\n     * @param attributesNames defines the list of attribute names to get\r\n     * @returns an array of indices indicating the offset of each attribute\r\n     */\r\n    public getAttributes(pipelineContext: IPipelineContext, attributesNames: string[]): number[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Binds an effect to the webGL context\r\n     * @param effect defines the effect to bind\r\n     */\r\n    public bindSamplers(effect: Effect): void {\r\n        this._currentEffect = null;\r\n    }\r\n\r\n    /**\r\n     * Activates an effect, making it the current one (ie. the one used for rendering)\r\n     * @param effect defines the effect to activate\r\n     */\r\n    public enableEffect(effect: Nullable<Effect | DrawWrapper>): void {\r\n        effect = effect !== null && DrawWrapper.IsWrapper(effect) ? effect.effect : effect; // get only the effect, we don't need a Wrapper in the WebGL engine\r\n\r\n        this._currentEffect = effect as Nullable<Effect>;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        if (effect.onBind) {\r\n            effect.onBind(effect);\r\n        }\r\n        if (effect._onBindObservable) {\r\n            effect._onBindObservable.notifyObservers(effect);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set various states to the webGL context\r\n     * @param culling defines culling state: true to enable culling, false to disable it\r\n     * @param zOffset defines the value to apply to zOffset (0 by default)\r\n     * @param force defines if states must be applied even if cache is up to date\r\n     * @param reverseSide defines if culling must be reversed (CCW if false, CW if true)\r\n     * @param cullBackFaces true to cull back faces, false to cull front faces (if culling is enabled)\r\n     * @param stencil stencil states to set\r\n     * @param zOffsetUnits defines the value to apply to zOffsetUnits (0 by default)\r\n     */\r\n    public setState(\r\n        culling: boolean,\r\n        zOffset: number = 0,\r\n        force?: boolean,\r\n        reverseSide = false,\r\n        cullBackFaces?: boolean,\r\n        stencil?: IStencilState,\r\n        zOffsetUnits: number = 0\r\n    ): void {}\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of int32\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of int32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setIntArray(uniform: WebGLUniformLocation, array: Int32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of int32 (stored as vec2)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of int32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setIntArray2(uniform: WebGLUniformLocation, array: Int32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of int32 (stored as vec3)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of int32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setIntArray3(uniform: WebGLUniformLocation, array: Int32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of int32 (stored as vec4)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of int32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setIntArray4(uniform: WebGLUniformLocation, array: Int32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of float32\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of float32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setFloatArray(uniform: WebGLUniformLocation, array: Float32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of float32 (stored as vec2)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of float32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setFloatArray2(uniform: WebGLUniformLocation, array: Float32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of float32 (stored as vec3)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of float32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setFloatArray3(uniform: WebGLUniformLocation, array: Float32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of float32 (stored as vec4)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of float32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setFloatArray4(uniform: WebGLUniformLocation, array: Float32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of number\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of number to store\r\n     * @returns true if value was set\r\n     */\r\n    public setArray(uniform: WebGLUniformLocation, array: number[]): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of number (stored as vec2)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of number to store\r\n     * @returns true if value was set\r\n     */\r\n    public setArray2(uniform: WebGLUniformLocation, array: number[]): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of number (stored as vec3)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of number to store\r\n     * @returns true if value was set\r\n     */\r\n    public setArray3(uniform: WebGLUniformLocation, array: number[]): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of number (stored as vec4)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of number to store\r\n     * @returns true if value was set\r\n     */\r\n    public setArray4(uniform: WebGLUniformLocation, array: number[]): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of float32 (stored as matrices)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param matrices defines the array of float32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setMatrices(uniform: WebGLUniformLocation, matrices: Float32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a matrix (3x3)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param matrix defines the Float32Array representing the 3x3 matrix to store\r\n     * @returns true if value was set\r\n     */\r\n    public setMatrix3x3(uniform: WebGLUniformLocation, matrix: Float32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a matrix (2x2)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param matrix defines the Float32Array representing the 2x2 matrix to store\r\n     * @returns true if value was set\r\n     */\r\n    public setMatrix2x2(uniform: WebGLUniformLocation, matrix: Float32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a number (float)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param value defines the float number to store\r\n     * @returns true if value was set\r\n     */\r\n    public setFloat(uniform: WebGLUniformLocation, value: number): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a vec2\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param x defines the 1st component of the value\r\n     * @param y defines the 2nd component of the value\r\n     * @returns true if value was set\r\n     */\r\n    public setFloat2(uniform: WebGLUniformLocation, x: number, y: number): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a vec3\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param x defines the 1st component of the value\r\n     * @param y defines the 2nd component of the value\r\n     * @param z defines the 3rd component of the value\r\n     * @returns true if value was set\r\n     */\r\n    public setFloat3(uniform: WebGLUniformLocation, x: number, y: number, z: number): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a boolean\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param bool defines the boolean to store\r\n     * @returns true if value was set\r\n     */\r\n    public setBool(uniform: WebGLUniformLocation, bool: number): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a vec4\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param x defines the 1st component of the value\r\n     * @param y defines the 2nd component of the value\r\n     * @param z defines the 3rd component of the value\r\n     * @param w defines the 4th component of the value\r\n     * @returns true if value was set\r\n     */\r\n    public setFloat4(uniform: WebGLUniformLocation, x: number, y: number, z: number, w: number): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Sets the current alpha mode\r\n     * @param mode defines the mode to use (one of the Engine.ALPHA_XXX)\r\n     * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering\r\n     */\r\n    public setAlphaMode(mode: number, noDepthWriteChange: boolean = false): void {\r\n        if (this._alphaMode === mode) {\r\n            return;\r\n        }\r\n\r\n        this.alphaState.alphaBlend = mode !== Constants.ALPHA_DISABLE;\r\n\r\n        if (!noDepthWriteChange) {\r\n            this.setDepthWrite(mode === Constants.ALPHA_DISABLE);\r\n        }\r\n        this._alphaMode = mode;\r\n    }\r\n\r\n    /**\r\n     * Bind webGl buffers directly to the webGL context\r\n     * @param vertexBuffers defines the vertex buffer to bind\r\n     * @param indexBuffer defines the index buffer to bind\r\n     * @param effect defines the effect associated with the vertex buffer\r\n     */\r\n    public bindBuffers(vertexBuffers: { [key: string]: VertexBuffer }, indexBuffer: DataBuffer, effect: Effect): void {}\r\n\r\n    /**\r\n     * Force the entire cache to be cleared\r\n     * You should not have to use this function unless your engine needs to share the webGL context with another engine\r\n     * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)\r\n     */\r\n    public wipeCaches(bruteForce?: boolean): void {\r\n        if (this.preventCacheWipeBetweenFrames) {\r\n            return;\r\n        }\r\n        this.resetTextureCache();\r\n        this._currentEffect = null;\r\n\r\n        if (bruteForce) {\r\n            this._currentProgram = null;\r\n\r\n            this._stencilStateComposer.reset();\r\n            this.depthCullingState.reset();\r\n            this.alphaState.reset();\r\n        }\r\n\r\n        this._cachedVertexBuffers = null;\r\n        this._cachedIndexBuffer = null;\r\n        this._cachedEffectForVertexBuffers = null;\r\n    }\r\n\r\n    /**\r\n     * Send a draw order\r\n     * @param useTriangles defines if triangles must be used to draw (else wireframe will be used)\r\n     * @param indexStart defines the starting index\r\n     * @param indexCount defines the number of index to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public draw(useTriangles: boolean, indexStart: number, indexCount: number, instancesCount?: number): void {}\r\n\r\n    /**\r\n     * Draw a list of indexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param indexStart defines the starting index\r\n     * @param indexCount defines the number of index to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public drawElementsType(fillMode: number, indexStart: number, indexCount: number, instancesCount?: number): void {}\r\n\r\n    /**\r\n     * Draw a list of unindexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param verticesStart defines the index of first vertex to draw\r\n     * @param verticesCount defines the count of vertices to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public drawArraysType(fillMode: number, verticesStart: number, verticesCount: number, instancesCount?: number): void {}\r\n\r\n    /** @internal */\r\n    protected _createTexture(): WebGLTexture {\r\n        return {};\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _releaseTexture(texture: InternalTexture): void {}\r\n\r\n    /**\r\n     * Usually called from Texture.ts.\r\n     * Passed information to create a WebGLTexture\r\n     * @param urlArg defines a value which contains one of the following:\r\n     * * A conventional http URL, e.g. 'http://...' or 'file://...'\r\n     * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\r\n     * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\r\n     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\r\n     * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\r\n     * @param scene needed for loading to the correct scene\r\n     * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param onLoad optional callback to be called upon successful completion\r\n     * @param onError optional callback to be called upon failure\r\n     * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\r\n     * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\r\n     * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @param mimeType defines an optional mime type\r\n     * @returns a InternalTexture for assignment back into BABYLON.Texture\r\n     */\r\n    public createTexture(\r\n        urlArg: Nullable<string>,\r\n        noMipmap: boolean,\r\n        invertY: boolean,\r\n        scene: Nullable<ISceneLike>,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<(texture: InternalTexture) => void> = null,\r\n        onError: Nullable<(message: string, exception: any) => void> = null,\r\n        buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null,\r\n        fallback: Nullable<InternalTexture> = null,\r\n        format: Nullable<number> = null,\r\n        forcedExtension: Nullable<string> = null,\r\n        mimeType?: string\r\n    ): InternalTexture {\r\n        const texture = new InternalTexture(this, InternalTextureSource.Url);\r\n        const url = String(urlArg);\r\n\r\n        texture.url = url;\r\n        texture.generateMipMaps = !noMipmap;\r\n        texture.samplingMode = samplingMode;\r\n        texture.invertY = invertY;\r\n        texture.baseWidth = this._options.textureSize;\r\n        texture.baseHeight = this._options.textureSize;\r\n        texture.width = this._options.textureSize;\r\n        texture.height = this._options.textureSize;\r\n        if (format) {\r\n            texture.format = format;\r\n        }\r\n\r\n        texture.isReady = true;\r\n\r\n        if (onLoad) {\r\n            setTimeout(() => {\r\n                onLoad(texture);\r\n            });\r\n        }\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _createHardwareRenderTargetWrapper(isMulti: boolean, isCube: boolean, size: number | { width: number; height: number; layers?: number }): RenderTargetWrapper {\r\n        const rtWrapper = new RenderTargetWrapper(isMulti, isCube, size, this);\r\n        this._renderTargetWrapperCache.push(rtWrapper);\r\n        return rtWrapper;\r\n    }\r\n\r\n    /**\r\n     * Creates a new render target wrapper\r\n     * @param size defines the size of the texture\r\n     * @param options defines the options used to create the texture\r\n     * @returns a new render target wrapper\r\n     */\r\n    public createRenderTargetTexture(size: any, options: boolean | RenderTargetCreationOptions): RenderTargetWrapper {\r\n        const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size);\r\n\r\n        const fullOptions: RenderTargetCreationOptions = {};\r\n\r\n        if (options !== undefined && typeof options === \"object\") {\r\n            fullOptions.generateMipMaps = options.generateMipMaps;\r\n            fullOptions.generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\r\n            fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && options.generateStencilBuffer;\r\n            fullOptions.type = options.type === undefined ? Constants.TEXTURETYPE_UNSIGNED_INT : options.type;\r\n            fullOptions.samplingMode = options.samplingMode === undefined ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : options.samplingMode;\r\n        } else {\r\n            fullOptions.generateMipMaps = <boolean>options;\r\n            fullOptions.generateDepthBuffer = true;\r\n            fullOptions.generateStencilBuffer = false;\r\n            fullOptions.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n            fullOptions.samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n        }\r\n        const texture = new InternalTexture(this, InternalTextureSource.RenderTarget);\r\n\r\n        const width = size.width || size;\r\n        const height = size.height || size;\r\n\r\n        rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;\r\n        rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;\r\n\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.isReady = true;\r\n        texture.samples = 1;\r\n        texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;\r\n        texture.samplingMode = fullOptions.samplingMode;\r\n        texture.type = fullOptions.type;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        return rtWrapper;\r\n    }\r\n\r\n    /**\r\n     * Creates a new render target wrapper\r\n     * @param size defines the size of the texture\r\n     * @param options defines the options used to create the texture\r\n     * @returns a new render target wrapper\r\n     */\r\n    public createRenderTargetCubeTexture(size: number, options?: RenderTargetCreationOptions): RenderTargetWrapper {\r\n        const rtWrapper = this._createHardwareRenderTargetWrapper(false, true, size);\r\n\r\n        const fullOptions = {\r\n            generateMipMaps: true,\r\n            generateDepthBuffer: true,\r\n            generateStencilBuffer: false,\r\n            type: Constants.TEXTURETYPE_UNSIGNED_INT,\r\n            samplingMode: Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n            format: Constants.TEXTUREFORMAT_RGBA,\r\n            ...options,\r\n        };\r\n        fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && fullOptions.generateStencilBuffer;\r\n\r\n        if (fullOptions.type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n            // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            fullOptions.samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        } else if (fullOptions.type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n            // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            fullOptions.samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n\r\n        rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;\r\n        rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;\r\n\r\n        const texture = new InternalTexture(this, InternalTextureSource.RenderTarget);\r\n        texture.baseWidth = size;\r\n        texture.baseHeight = size;\r\n        texture.width = size;\r\n        texture.height = size;\r\n        texture.isReady = true;\r\n        texture.isCube = true;\r\n        texture.samples = 1;\r\n        texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;\r\n        texture.samplingMode = fullOptions.samplingMode;\r\n        texture.type = fullOptions.type;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        return rtWrapper;\r\n    }\r\n\r\n    /**\r\n     * Update the sampling mode of a given texture\r\n     * @param samplingMode defines the required sampling mode\r\n     * @param texture defines the texture to update\r\n     */\r\n    public updateTextureSamplingMode(samplingMode: number, texture: InternalTexture): void {\r\n        texture.samplingMode = samplingMode;\r\n    }\r\n\r\n    /**\r\n     * Creates a raw texture\r\n     * @param data defines the data to store in the texture\r\n     * @param width defines the width of the texture\r\n     * @param height defines the height of the texture\r\n     * @param format defines the format of the data\r\n     * @param generateMipMaps defines if the engine should generate the mip levels\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n     * @param compression defines the compression used (null by default)\r\n     * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the raw texture inside an InternalTexture\r\n     */\r\n    public createRawTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        format: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression: Nullable<string> = null,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        creationFlags = 0,\r\n        useSRGBBuffer = false\r\n    ): InternalTexture {\r\n        const texture = new InternalTexture(this, InternalTextureSource.Raw);\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.format = format;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n        texture.type = type;\r\n        texture._useSRGBBuffer = useSRGBBuffer;\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            texture._bufferView = data;\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Update a raw texture\r\n     * @param texture defines the texture to update\r\n     * @param data defines the data to store in the texture\r\n     * @param format defines the format of the data\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param compression defines the compression used (null by default)\r\n     * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     */\r\n    public updateRawTexture(\r\n        texture: Nullable<InternalTexture>,\r\n        data: Nullable<ArrayBufferView>,\r\n        format: number,\r\n        invertY: boolean,\r\n        compression: Nullable<string> = null,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        useSRGBBuffer: boolean = false\r\n    ): void {\r\n        if (texture) {\r\n            texture._bufferView = data;\r\n            texture.format = format;\r\n            texture.invertY = invertY;\r\n            texture._compression = compression;\r\n            texture.type = type;\r\n            texture._useSRGBBuffer = useSRGBBuffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the frame buffer to the specified texture.\r\n     * @param rtWrapper The render target wrapper to render to\r\n     * @param faceIndex The face of the texture to render to in case of cube texture\r\n     * @param requiredWidth The width of the target to render to\r\n     * @param requiredHeight The height of the target to render to\r\n     * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true\r\n     */\r\n    public bindFramebuffer(rtWrapper: RenderTargetWrapper, faceIndex?: number, requiredWidth?: number, requiredHeight?: number, forceFullscreenViewport?: boolean): void {\r\n        if (this._currentRenderTarget) {\r\n            this.unBindFramebuffer(this._currentRenderTarget);\r\n        }\r\n        this._currentRenderTarget = rtWrapper;\r\n        this._currentFramebuffer = null;\r\n        if (this._cachedViewport && !forceFullscreenViewport) {\r\n            this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unbind the current render target texture from the webGL context\r\n     * @param rtWrapper defines the render target wrapper to unbind\r\n     * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\r\n     * @param onBeforeUnbind defines a function which will be called before the effective unbind\r\n     */\r\n    public unBindFramebuffer(rtWrapper: RenderTargetWrapper, disableGenerateMipMaps = false, onBeforeUnbind?: () => void): void {\r\n        this._currentRenderTarget = null;\r\n\r\n        if (onBeforeUnbind) {\r\n            onBeforeUnbind();\r\n        }\r\n        this._currentFramebuffer = null;\r\n    }\r\n\r\n    /**\r\n     * Creates a dynamic vertex buffer\r\n     * @param vertices the data for the dynamic vertex buffer\r\n     * @returns the new WebGL dynamic buffer\r\n     */\r\n    public createDynamicVertexBuffer(vertices: FloatArray): DataBuffer {\r\n        const buffer = new DataBuffer();\r\n        buffer.references = 1;\r\n        buffer.capacity = 1;\r\n        return buffer;\r\n    }\r\n\r\n    /**\r\n     * Update the content of a dynamic texture\r\n     * @param texture defines the texture to update\r\n     * @param canvas defines the canvas containing the source\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param premulAlpha defines if alpha is stored as premultiplied\r\n     * @param format defines the format of the data\r\n     */\r\n    public updateDynamicTexture(texture: Nullable<InternalTexture>, canvas: HTMLCanvasElement, invertY: boolean, premulAlpha: boolean = false, format?: number): void {}\r\n\r\n    /**\r\n     * Gets a boolean indicating if all created effects are ready\r\n     * @returns true if all effects are ready\r\n     */\r\n    public areAllEffectsReady(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Get the current error code of the webGL context\r\n     * @returns the error code\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getError\r\n     */\r\n    public getError(): number {\r\n        return 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public _getUnpackAlignement(): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _unpackFlipY(value: boolean) {}\r\n\r\n    /**\r\n     * Update a dynamic index buffer\r\n     * @param indexBuffer defines the target index buffer\r\n     * @param indices defines the data to update\r\n     * @param offset defines the offset in the target index buffer where update should start\r\n     */\r\n    public updateDynamicIndexBuffer(indexBuffer: WebGLBuffer, indices: IndicesArray, offset: number = 0): void {}\r\n\r\n    /**\r\n     * Updates a dynamic vertex buffer.\r\n     * @param vertexBuffer the vertex buffer to update\r\n     * @param vertices the data used to update the vertex buffer\r\n     * @param byteOffset the byte offset of the data (optional)\r\n     * @param byteLength the byte length of the data (optional)\r\n     */\r\n    public updateDynamicVertexBuffer(vertexBuffer: WebGLBuffer, vertices: FloatArray, byteOffset?: number, byteLength?: number): void {}\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bindTextureDirectly(target: number, texture: InternalTexture): boolean {\r\n        if (this._boundTexturesCache[this._activeChannel] !== texture) {\r\n            this._boundTexturesCache[this._activeChannel] = texture;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bindTexture(channel: number, texture: InternalTexture): void {\r\n        if (channel < 0) {\r\n            return;\r\n        }\r\n\r\n        this._bindTextureDirectly(0, texture);\r\n    }\r\n\r\n    protected _deleteBuffer(buffer: WebGLBuffer): void {}\r\n\r\n    /**\r\n     * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled\r\n     */\r\n    public releaseEffects() {}\r\n\r\n    public displayLoadingUI(): void {}\r\n\r\n    public hideLoadingUI(): void {}\r\n\r\n    public set loadingUIText(_: string) {}\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadCompressedDataToTextureDirectly(\r\n        texture: InternalTexture,\r\n        internalFormat: number,\r\n        width: number,\r\n        height: number,\r\n        data: ArrayBufferView,\r\n        faceIndex: number = 0,\r\n        lod: number = 0\r\n    ) {}\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadDataToTextureDirectly(texture: InternalTexture, imageData: ArrayBufferView, faceIndex: number = 0, lod: number = 0): void {}\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadArrayBufferViewToTexture(texture: InternalTexture, imageData: ArrayBufferView, faceIndex: number = 0, lod: number = 0): void {}\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadImageToTexture(texture: InternalTexture, image: HTMLImageElement, faceIndex: number = 0, lod: number = 0) {}\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}