{"ast":null,"code":"import { Vector3, Quaternion, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Space } from \"../../Maths/math.axis.js\";\n/**\n * PhysicsBody is useful for creating a physics body that can be used in a physics engine. It allows\n * the user to set the mass and velocity of the body, which can then be used to calculate the\n * motion of the body in the physics engine.\n */\nexport class PhysicsBody {\n  /**\n   * Constructs a new physics body for the given node.\n   * @param transformNode - The Transform Node to construct the physics body for. For better performance, it is advised that this node does not have a parent.\n   * @param motionType - The motion type of the physics body. The options are:\n   *  - PhysicsMotionType.STATIC - Static bodies are not moving and unaffected by forces or collisions. They are good for level boundaries or terrain.\n   *  - PhysicsMotionType.DYNAMIC - Dynamic bodies are fully simulated. They can move and collide with other objects.\n   *  - PhysicsMotionType.ANIMATED - They behave like dynamic bodies, but they won't be affected by other bodies, but still push other bodies out of the way.\n   * @param startsAsleep - Whether the physics body should start in a sleeping state (not a guarantee). Defaults to false.\n   * @param scene - The scene containing the physics engine.\n   *\n   * This code is useful for creating a physics body for a given Transform Node in a scene.\n   * It checks the version of the physics engine and the physics plugin, and initializes the body accordingly.\n   * It also sets the node's rotation quaternion if it is not already set. Finally, it adds the body to the physics engine.\n   */\n  constructor(transformNode, motionType, startsAsleep, scene) {\n    /**\n     * V2 Physics plugin private data for single Transform\n     */\n    this._pluginData = undefined;\n    /**\n     * V2 Physics plugin private data for instances\n     */\n    this._pluginDataInstances = [];\n    /**\n     * If the collision callback is enabled\n     */\n    this._collisionCBEnabled = false;\n    /**\n     * If the collision ended callback is enabled\n     */\n    this._collisionEndedCBEnabled = false;\n    /**\n     * Disable pre-step that consists in updating Physics Body from Transform Node Translation/Orientation.\n     * True by default for maximum performance.\n     */\n    this.disablePreStep = true;\n    this._isDisposed = false;\n    if (!scene) {\n      return;\n    }\n    const physicsEngine = scene.getPhysicsEngine();\n    if (!physicsEngine) {\n      throw new Error(\"No Physics Engine available.\");\n    }\n    this._physicsEngine = physicsEngine;\n    if (physicsEngine.getPluginVersion() != 2) {\n      throw new Error(\"Plugin version is incorrect. Expected version 2.\");\n    }\n    const physicsPlugin = physicsEngine.getPhysicsPlugin();\n    if (!physicsPlugin) {\n      throw new Error(\"No Physics Plugin available.\");\n    }\n    this._physicsPlugin = physicsPlugin;\n    if (!transformNode.rotationQuaternion) {\n      transformNode.rotationQuaternion = Quaternion.FromEulerAngles(transformNode.rotation.x, transformNode.rotation.y, transformNode.rotation.z);\n    }\n    this.startAsleep = startsAsleep;\n    // instances?\n    const m = transformNode;\n    if (m.hasThinInstances) {\n      this._physicsPlugin.initBodyInstances(this, motionType, m);\n    } else {\n      // single instance\n      if (transformNode.parent) {\n        // Force computation of world matrix so that the parent transforms are correctly reflected in absolutePosition/absoluteRotationQuaternion.\n        transformNode.computeWorldMatrix(true);\n      }\n      this._physicsPlugin.initBody(this, motionType, transformNode.absolutePosition, transformNode.absoluteRotationQuaternion);\n    }\n    this.transformNode = transformNode;\n    transformNode.physicsBody = this;\n    physicsEngine.addBody(this);\n    this._nodeDisposeObserver = transformNode.onDisposeObservable.add(() => {\n      this.dispose();\n    });\n  }\n  /**\n   * Returns the string \"PhysicsBody\".\n   * @returns \"PhysicsBody\"\n   */\n  getClassName() {\n    return \"PhysicsBody\";\n  }\n  /**\n   * Clone the PhysicsBody to a new body and assign it to the transformNode parameter\n   * @param transformNode transformNode that will be used for the cloned PhysicsBody\n   * @returns the newly cloned PhysicsBody\n   */\n  clone(transformNode) {\n    const clonedBody = new PhysicsBody(transformNode, this.getMotionType(), this.startAsleep, this.transformNode.getScene());\n    clonedBody.shape = this.shape;\n    clonedBody.setMassProperties(this.getMassProperties());\n    clonedBody.setLinearDamping(this.getLinearDamping());\n    clonedBody.setAngularDamping(this.getAngularDamping());\n    return clonedBody;\n  }\n  /**\n   * If a physics body is connected to an instanced node, update the number physic instances to match the number of node instances.\n   */\n  updateBodyInstances() {\n    const m = this.transformNode;\n    if (m.hasThinInstances) {\n      this._physicsPlugin.updateBodyInstances(this, m);\n    }\n  }\n  /**\n   * This returns the number of internal instances of the physics body\n   */\n  get numInstances() {\n    return this._pluginDataInstances.length;\n  }\n  /**\n   * Sets the shape of the physics body.\n   * @param shape - The shape of the physics body.\n   *\n   * This method is useful for setting the shape of the physics body, which is necessary for the physics engine to accurately simulate the body's behavior.\n   * The shape is used to calculate the body's mass, inertia, and other properties.\n   */\n  set shape(shape) {\n    this._physicsPlugin.setShape(this, shape);\n  }\n  /**\n   * Retrieves the physics shape associated with this object.\n   *\n   * @returns The physics shape associated with this object, or `undefined` if no\n   * shape is associated.\n   *\n   * This method is useful for retrieving the physics shape associated with this object,\n   * which can be used to apply physical forces to the object or to detect collisions.\n   */\n  get shape() {\n    return this._physicsPlugin.getShape(this);\n  }\n  /**\n   * Sets the event mask for the physics engine.\n   *\n   * @param eventMask - A bitmask that determines which events will be sent to the physics engine.\n   *\n   * This method is useful for setting the event mask for the physics engine, which determines which events\n   * will be sent to the physics engine. This allows the user to control which events the physics engine will respond to.\n   */\n  setEventMask(eventMask, instanceIndex) {\n    this._physicsPlugin.setEventMask(this, eventMask, instanceIndex);\n  }\n  /**\n   * Gets the event mask of the physics engine.\n   *\n   * @returns The event mask of the physics engine.\n   *\n   * This method is useful for getting the event mask of the physics engine,\n   * which is used to determine which events the engine will respond to.\n   * This is important for ensuring that the engine is responding to the correct events and not\n   * wasting resources on unnecessary events.\n   */\n  getEventMask(instanceIndex) {\n    return this._physicsPlugin.getEventMask(this, instanceIndex);\n  }\n  /**\n   * Sets the motion type of the physics body. Can be STATIC, DYNAMIC, or ANIMATED.\n   */\n  setMotionType(motionType, instanceIndex) {\n    this._physicsPlugin.setMotionType(this, motionType, instanceIndex);\n  }\n  /**\n   * Gets the motion type of the physics body. Can be STATIC, DYNAMIC, or ANIMATED.\n   */\n  getMotionType(instanceIndex) {\n    return this._physicsPlugin.getMotionType(this, instanceIndex);\n  }\n  /**\n   * Computes the mass properties of the physics object, based on the set of physics shapes this body uses.\n   * This method is useful for computing the initial mass properties of a physics object, such as its mass,\n   * inertia, and center of mass; these values are important for accurately simulating the physics of the\n   * object in the physics engine, and computing values based on the shape will provide you with reasonable\n   * intial values, which you can then customize.\n   */\n  computeMassProperties(instanceIndex) {\n    return this._physicsPlugin.computeMassProperties(this, instanceIndex);\n  }\n  /**\n   * Sets the mass properties of the physics object.\n   *\n   * @param massProps - The mass properties to set.\n   * @param instanceIndex - The index of the instance to set the mass properties for. If not defined, the mass properties will be set for all instances.\n   *\n   * This method is useful for setting the mass properties of a physics object, such as its mass,\n   * inertia, and center of mass. This is important for accurately simulating the physics of the object in the physics engine.\n   */\n  setMassProperties(massProps, instanceIndex) {\n    this._physicsPlugin.setMassProperties(this, massProps, instanceIndex);\n  }\n  /**\n   * Retrieves the mass properties of the object.\n   *\n   * @returns The mass properties of the object.\n   *\n   * This method is useful for physics simulations, as it allows the user to\n   * retrieve the mass properties of the object, such as its mass, center of mass,\n   * and moment of inertia. This information is necessary for accurate physics\n   * simulations.\n   */\n  getMassProperties(instanceIndex) {\n    return this._physicsPlugin.getMassProperties(this, instanceIndex);\n  }\n  /**\n   * Sets the linear damping of the physics body.\n   *\n   * @param damping - The linear damping value.\n   *\n   * This method is useful for controlling the linear damping of the physics body,\n   * which is the rate at which the body's velocity decreases over time. This is useful for simulating\n   * the effects of air resistance or other forms of friction.\n   */\n  setLinearDamping(damping, instanceIndex) {\n    this._physicsPlugin.setLinearDamping(this, damping, instanceIndex);\n  }\n  /**\n   * Gets the linear damping of the physics body.\n   * @returns The linear damping of the physics body.\n   *\n   * This method is useful for retrieving the linear damping of the physics body, which is the amount of\n   * resistance the body has to linear motion. This is useful for simulating realistic physics behavior\n   * in a game.\n   */\n  getLinearDamping(instanceIndex) {\n    return this._physicsPlugin.getLinearDamping(this, instanceIndex);\n  }\n  /**\n   * Sets the angular damping of the physics body.\n   * @param damping The angular damping of the body.\n   *\n   * This method is useful for controlling the angular velocity of a physics body.\n   * By setting the damping, the body's angular velocity will be reduced over time, simulating the effect of friction.\n   * This can be used to create realistic physical behavior in a physics engine.\n   */\n  setAngularDamping(damping, instanceIndex) {\n    this._physicsPlugin.setAngularDamping(this, damping, instanceIndex);\n  }\n  /**\n   * Gets the angular damping of the physics body.\n   *\n   * @returns The angular damping of the physics body.\n   *\n   * This method is useful for getting the angular damping of the physics body,\n   * which is the rate of reduction of the angular velocity over time.\n   * This is important for simulating realistic physics behavior in a game.\n   */\n  getAngularDamping(instanceIndex) {\n    return this._physicsPlugin.getAngularDamping(this, instanceIndex);\n  }\n  /**\n   * Sets the linear velocity of the physics object.\n   * @param linVel - The linear velocity to set.\n   *\n   * This method is useful for setting the linear velocity of a physics object,\n   * which is necessary for simulating realistic physics in a game engine.\n   * By setting the linear velocity, the physics object will move in the direction and speed specified by the vector.\n   * This allows for realistic physics simulations, such as simulating the motion of a ball rolling down a hill.\n   */\n  setLinearVelocity(linVel, instanceIndex) {\n    this._physicsPlugin.setLinearVelocity(this, linVel, instanceIndex);\n  }\n  /**\n   * Gets the linear velocity of the physics body and stores it in the given vector3.\n   * @param linVel - The vector3 to store the linear velocity in.\n   *\n   * This method is useful for getting the linear velocity of a physics body in a physics engine.\n   * This can be used to determine the speed and direction of the body, which can be used to calculate the motion of the body.\n   */\n  getLinearVelocityToRef(linVel, instanceIndex) {\n    return this._physicsPlugin.getLinearVelocityToRef(this, linVel, instanceIndex);\n  }\n  /**\n   * Gets the linear velocity of the physics body as a new vector3.\n   * @returns The linear velocity of the physics body.\n   *\n   * This method is useful for getting the linear velocity of a physics body in a physics engine.\n   * This can be used to determine the speed and direction of the body, which can be used to calculate the motion of the body.\n   */\n  getLinearVelocity(instanceIndex) {\n    const ref = new Vector3();\n    this.getLinearVelocityToRef(ref, instanceIndex);\n    return ref;\n  }\n  /**\n   * Sets the angular velocity of the physics object.\n   * @param angVel - The angular velocity to set.\n   *\n   * This method is useful for setting the angular velocity of a physics object, which is necessary for\n   * simulating realistic physics behavior. The angular velocity is used to determine the rate of rotation of the object,\n   * which is important for simulating realistic motion.\n   */\n  setAngularVelocity(angVel, instanceIndex) {\n    this._physicsPlugin.setAngularVelocity(this, angVel, instanceIndex);\n  }\n  /**\n   * Gets the angular velocity of the physics body and stores it in the given vector3.\n   * @param angVel - The vector3 to store the angular velocity in.\n   *\n   * This method is useful for getting the angular velocity of a physics body, which can be used to determine the body's\n   * rotational speed. This information can be used to create realistic physics simulations.\n   */\n  getAngularVelocityToRef(angVel, instanceIndex) {\n    return this._physicsPlugin.getAngularVelocityToRef(this, angVel, instanceIndex);\n  }\n  /**\n   * Gets the angular velocity of the physics body as a new vector3.\n   * @returns The angular velocity of the physics body.\n   *\n   * This method is useful for getting the angular velocity of a physics body, which can be used to determine the body's\n   * rotational speed. This information can be used to create realistic physics simulations.\n   */\n  getAngularVelocity(instanceIndex) {\n    const ref = new Vector3();\n    this.getAngularVelocityToRef(ref, instanceIndex);\n    return ref;\n  }\n  /**\n   * Applies an impulse to the physics object.\n   *\n   * @param impulse The impulse vector.\n   * @param location The location of the impulse.\n   * @param instanceIndex For a instanced body, the instance to where the impulse should be applied. If not specified, the impulse is applied to all instances.\n   *\n   * This method is useful for applying an impulse to a physics object, which can be used to simulate physical forces such as gravity,\n   * collisions, and explosions. This can be used to create realistic physics simulations in a game or other application.\n   */\n  applyImpulse(impulse, location, instanceIndex) {\n    this._physicsPlugin.applyImpulse(this, impulse, location, instanceIndex);\n  }\n  /**\n   * Applies a force to the physics object.\n   *\n   * @param force The force vector.\n   * @param location The location of the force.\n   * @param instanceIndex For a instanced body, the instance to where the force should be applied. If not specified, the force is applied to all instances.\n   *\n   * This method is useful for applying a force to a physics object, which can be used to simulate physical forces such as gravity,\n   * collisions, and explosions. This can be used to create realistic physics simulations in a game or other application.\n   */\n  applyForce(force, location, instanceIndex) {\n    this._physicsPlugin.applyForce(this, force, location, instanceIndex);\n  }\n  /**\n   * Retrieves the geometry of the body from the physics plugin.\n   *\n   * @returns The geometry of the body.\n   *\n   * This method is useful for retrieving the geometry of the body from the physics plugin, which can be used for various physics calculations.\n   */\n  getGeometry() {\n    return this._physicsPlugin.getBodyGeometry(this);\n  }\n  /**\n   * Returns an observable that will be notified for when a collision starts or continues for this PhysicsBody\n   * @returns Observable\n   */\n  getCollisionObservable() {\n    return this._physicsPlugin.getCollisionObservable(this);\n  }\n  /**\n   * Returns an observable that will be notified when the body has finished colliding with another body\n   * @returns\n   */\n  getCollisionEndedObservable() {\n    return this._physicsPlugin.getCollisionEndedObservable(this);\n  }\n  /**\n   * Enable or disable collision callback for this PhysicsBody.\n   * @param enabled true if PhysicsBody's collision will rise a collision event and notifies the observable\n   */\n  setCollisionCallbackEnabled(enabled) {\n    this._collisionCBEnabled = enabled;\n    this._physicsPlugin.setCollisionCallbackEnabled(this, enabled);\n  }\n  setCollisionEndedCallbackEnabled(enabled) {\n    this._collisionEndedCBEnabled = enabled;\n    this._physicsPlugin.setCollisionEndedCallbackEnabled(this, enabled);\n  }\n  /*\n   * Get the center of the object in world space.\n   * @param instanceIndex - If this body is instanced, the index of the instance to get the center for.\n   * @returns geometric center of the associated mesh\n   */\n  getObjectCenterWorld(instanceIndex) {\n    const ref = new Vector3();\n    return this.getObjectCenterWorldToRef(ref, instanceIndex);\n  }\n  /*\n   * Get the center of the object in world space.\n   * @param ref - The vector3 to store the result in.\n   * @param instanceIndex - If this body is instanced, the index of the instance to get the center for.\n   * @returns geometric center of the associated mesh\n   */\n  getObjectCenterWorldToRef(ref, instanceIndex) {\n    var _a;\n    if (((_a = this._pluginDataInstances) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n      const index = instanceIndex || 0;\n      const matrixData = this.transformNode._thinInstanceDataStorage.matrixData;\n      if (matrixData) {\n        ref.set(matrixData[index * 16 + 12], matrixData[index * 16 + 13], matrixData[index * 16 + 14]);\n      }\n    } else {\n      ref.copyFrom(this.transformNode.position);\n    }\n    return ref;\n  }\n  /**\n   * Adds a constraint to the physics engine.\n   *\n   * @param childBody - The body to which the constraint will be applied.\n   * @param constraint - The constraint to be applied.\n   * @param instanceIndex - If this body is instanced, the index of the instance to which the constraint will be applied. If not specified, no constraint will be applied.\n   * @param childInstanceIndex - If the child body is instanced, the index of the instance to which the constraint will be applied. If not specified, no constraint will be applied.\n   *\n   */\n  addConstraint(childBody, constraint, instanceIndex, childInstanceIndex) {\n    this._physicsPlugin.addConstraint(this, childBody, constraint, instanceIndex, childInstanceIndex);\n  }\n  /**\n   * Sync with a bone\n   * @param bone The bone that the impostor will be synced to.\n   * @param boneMesh The mesh that the bone is influencing.\n   * @param jointPivot The pivot of the joint / bone in local space.\n   * @param distToJoint Optional distance from the impostor to the joint.\n   * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.\n   * @param boneAxis Optional vector3 axis the bone is aligned with\n   */\n  syncWithBone(bone, boneMesh, jointPivot, distToJoint, adjustRotation, boneAxis) {\n    const mesh = this.transformNode;\n    if (mesh.rotationQuaternion) {\n      if (adjustRotation) {\n        const tempQuat = TmpVectors.Quaternion[0];\n        bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, tempQuat);\n        tempQuat.multiplyToRef(adjustRotation, mesh.rotationQuaternion);\n      } else {\n        bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, mesh.rotationQuaternion);\n      }\n    }\n    const pos = TmpVectors.Vector3[0];\n    const boneDir = TmpVectors.Vector3[1];\n    if (!boneAxis) {\n      boneAxis = TmpVectors.Vector3[2];\n      boneAxis.x = 0;\n      boneAxis.y = 1;\n      boneAxis.z = 0;\n    }\n    bone.getDirectionToRef(boneAxis, boneMesh, boneDir);\n    bone.getAbsolutePositionToRef(boneMesh, pos);\n    if ((distToJoint === undefined || distToJoint === null) && jointPivot) {\n      distToJoint = jointPivot.length();\n    }\n    if (distToJoint !== undefined && distToJoint !== null) {\n      pos.x += boneDir.x * distToJoint;\n      pos.y += boneDir.y * distToJoint;\n      pos.z += boneDir.z * distToJoint;\n    }\n    mesh.setAbsolutePosition(pos);\n  }\n  /**\n   * Executes a callback on the body or all of the instances of a body\n   * @param callback the callback to execute\n   */\n  iterateOverAllInstances(callback) {\n    var _a;\n    if (((_a = this._pluginDataInstances) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n      for (let i = 0; i < this._pluginDataInstances.length; i++) {\n        callback(this, i);\n      }\n    } else {\n      callback(this, undefined);\n    }\n  }\n  /**\n   * Sets the gravity factor of the physics body\n   * @param factor the gravity factor to set\n   * @param instanceIndex the instance of the body to set, if undefined all instances will be set\n   */\n  setGravityFactor(factor, instanceIndex) {\n    this._physicsPlugin.setGravityFactor(this, factor, instanceIndex);\n  }\n  /**\n   * Gets the gravity factor of the physics body\n   * @param instanceIndex the instance of the body to get, if undefined the value of first instance will be returned\n   * @returns the gravity factor\n   */\n  getGravityFactor(instanceIndex) {\n    return this._physicsPlugin.getGravityFactor(this, instanceIndex);\n  }\n  /**\n   * Set the target transformation (position and rotation) of the body, such that the body will set its velocity to reach that target\n   * @param position The target position\n   * @param rotation The target rotation\n   * @param instanceIndex The index of the instance in an instanced body\n   */\n  setTargetTransform(position, rotation, instanceIndex) {\n    this._physicsPlugin.setTargetTransform(this, position, rotation, instanceIndex);\n  }\n  /**\n   * Disposes the body from the physics engine.\n   *\n   * This method is useful for cleaning up the physics engine when a body is no longer needed. Disposing the body will free up resources and prevent memory leaks.\n   */\n  dispose() {\n    if (this._isDisposed) {\n      return;\n    }\n    // Disable collisions CB so it doesn't fire when the body is disposed\n    if (this._collisionCBEnabled) {\n      this.setCollisionCallbackEnabled(false);\n    }\n    if (this._collisionEndedCBEnabled) {\n      this.setCollisionEndedCallbackEnabled(false);\n    }\n    if (this._nodeDisposeObserver) {\n      this.transformNode.onDisposeObservable.remove(this._nodeDisposeObserver);\n      this._nodeDisposeObserver = null;\n    }\n    this._physicsEngine.removeBody(this);\n    this._physicsPlugin.removeBody(this);\n    this._physicsPlugin.disposeBody(this);\n    this.transformNode.physicsBody = null;\n    this._pluginData = null;\n    this._pluginDataInstances.length = 0;\n    this._isDisposed = true;\n  }\n}","map":{"version":3,"names":["Vector3","Quaternion","TmpVectors","Space","PhysicsBody","constructor","transformNode","motionType","startsAsleep","scene","_pluginData","undefined","_pluginDataInstances","_collisionCBEnabled","_collisionEndedCBEnabled","disablePreStep","_isDisposed","physicsEngine","getPhysicsEngine","Error","_physicsEngine","getPluginVersion","physicsPlugin","getPhysicsPlugin","_physicsPlugin","rotationQuaternion","FromEulerAngles","rotation","x","y","z","startAsleep","m","hasThinInstances","initBodyInstances","parent","computeWorldMatrix","initBody","absolutePosition","absoluteRotationQuaternion","physicsBody","addBody","_nodeDisposeObserver","onDisposeObservable","add","dispose","getClassName","clone","clonedBody","getMotionType","getScene","shape","setMassProperties","getMassProperties","setLinearDamping","getLinearDamping","setAngularDamping","getAngularDamping","updateBodyInstances","numInstances","length","setShape","getShape","setEventMask","eventMask","instanceIndex","getEventMask","setMotionType","computeMassProperties","massProps","damping","setLinearVelocity","linVel","getLinearVelocityToRef","getLinearVelocity","ref","setAngularVelocity","angVel","getAngularVelocityToRef","getAngularVelocity","applyImpulse","impulse","location","applyForce","force","getGeometry","getBodyGeometry","getCollisionObservable","getCollisionEndedObservable","setCollisionCallbackEnabled","enabled","setCollisionEndedCallbackEnabled","getObjectCenterWorld","getObjectCenterWorldToRef","_a","index","matrixData","_thinInstanceDataStorage","set","copyFrom","position","addConstraint","childBody","constraint","childInstanceIndex","syncWithBone","bone","boneMesh","jointPivot","distToJoint","adjustRotation","boneAxis","mesh","tempQuat","getRotationQuaternionToRef","WORLD","multiplyToRef","pos","boneDir","getDirectionToRef","getAbsolutePositionToRef","setAbsolutePosition","iterateOverAllInstances","callback","i","setGravityFactor","factor","getGravityFactor","setTargetTransform","remove","removeBody","disposeBody"],"sources":["../../../../../dev/core/src/Physics/v2/physicsBody.ts"],"sourcesContent":["import type { IBasePhysicsCollisionEvent, IPhysicsCollisionEvent, IPhysicsEnginePluginV2, PhysicsMassProperties, PhysicsMotionType } from \"./IPhysicsEnginePlugin\";\r\nimport type { PhysicsShape } from \"./physicsShape\";\r\nimport { Vector3, Quaternion, TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { PhysicsEngine } from \"./physicsEngine\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { PhysicsConstraint } from \"./physicsConstraint\";\r\nimport type { Bone } from \"core/Bones/bone\";\r\nimport { Space } from \"core/Maths/math.axis\";\r\nimport type { Observable, Observer } from \"../../Misc/observable\";\r\nimport type { Node } from \"../../node\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\n\r\n/**\r\n * PhysicsBody is useful for creating a physics body that can be used in a physics engine. It allows\r\n * the user to set the mass and velocity of the body, which can then be used to calculate the\r\n * motion of the body in the physics engine.\r\n */\r\nexport class PhysicsBody {\r\n    /**\r\n     * V2 Physics plugin private data for single Transform\r\n     */\r\n    public _pluginData: any = undefined;\r\n    /**\r\n     * V2 Physics plugin private data for instances\r\n     */\r\n    public _pluginDataInstances: Array<any> = [];\r\n    /**\r\n     * The V2 plugin used to create and manage this Physics Body\r\n     */\r\n    private _physicsPlugin: IPhysicsEnginePluginV2;\r\n    /**\r\n     * The engine used to create and manage this Physics Body\r\n     */\r\n    private _physicsEngine: PhysicsEngine;\r\n    /**\r\n     * If the collision callback is enabled\r\n     */\r\n    private _collisionCBEnabled: boolean = false;\r\n    /**\r\n     * If the collision ended callback is enabled\r\n     */\r\n    private _collisionEndedCBEnabled: boolean = false;\r\n    /**\r\n     * The transform node associated with this Physics Body\r\n     */\r\n    transformNode: TransformNode;\r\n    /**\r\n     * Disable pre-step that consists in updating Physics Body from Transform Node Translation/Orientation.\r\n     * True by default for maximum performance.\r\n     */\r\n    disablePreStep: boolean = true;\r\n\r\n    /**\r\n     * Physics engine will try to make this body sleeping and not active\r\n     */\r\n    public startAsleep: boolean;\r\n\r\n    private _nodeDisposeObserver: Nullable<Observer<Node>>;\r\n\r\n    private _isDisposed = false;\r\n\r\n    /**\r\n     * Constructs a new physics body for the given node.\r\n     * @param transformNode - The Transform Node to construct the physics body for. For better performance, it is advised that this node does not have a parent.\r\n     * @param motionType - The motion type of the physics body. The options are:\r\n     *  - PhysicsMotionType.STATIC - Static bodies are not moving and unaffected by forces or collisions. They are good for level boundaries or terrain.\r\n     *  - PhysicsMotionType.DYNAMIC - Dynamic bodies are fully simulated. They can move and collide with other objects.\r\n     *  - PhysicsMotionType.ANIMATED - They behave like dynamic bodies, but they won't be affected by other bodies, but still push other bodies out of the way.\r\n     * @param startsAsleep - Whether the physics body should start in a sleeping state (not a guarantee). Defaults to false.\r\n     * @param scene - The scene containing the physics engine.\r\n     *\r\n     * This code is useful for creating a physics body for a given Transform Node in a scene.\r\n     * It checks the version of the physics engine and the physics plugin, and initializes the body accordingly.\r\n     * It also sets the node's rotation quaternion if it is not already set. Finally, it adds the body to the physics engine.\r\n     */\r\n    constructor(transformNode: TransformNode, motionType: PhysicsMotionType, startsAsleep: boolean, scene: Scene) {\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        const physicsEngine = scene.getPhysicsEngine() as PhysicsEngine;\r\n        if (!physicsEngine) {\r\n            throw new Error(\"No Physics Engine available.\");\r\n        }\r\n        this._physicsEngine = physicsEngine;\r\n        if (physicsEngine.getPluginVersion() != 2) {\r\n            throw new Error(\"Plugin version is incorrect. Expected version 2.\");\r\n        }\r\n        const physicsPlugin = physicsEngine.getPhysicsPlugin();\r\n        if (!physicsPlugin) {\r\n            throw new Error(\"No Physics Plugin available.\");\r\n        }\r\n\r\n        this._physicsPlugin = physicsPlugin as IPhysicsEnginePluginV2;\r\n        if (!transformNode.rotationQuaternion) {\r\n            transformNode.rotationQuaternion = Quaternion.FromEulerAngles(transformNode.rotation.x, transformNode.rotation.y, transformNode.rotation.z);\r\n        }\r\n\r\n        this.startAsleep = startsAsleep;\r\n\r\n        // instances?\r\n        const m = transformNode as Mesh;\r\n        if (m.hasThinInstances) {\r\n            this._physicsPlugin.initBodyInstances(this, motionType, m);\r\n        } else {\r\n            // single instance\r\n            if (transformNode.parent) {\r\n                // Force computation of world matrix so that the parent transforms are correctly reflected in absolutePosition/absoluteRotationQuaternion.\r\n                transformNode.computeWorldMatrix(true);\r\n            }\r\n            this._physicsPlugin.initBody(this, motionType, transformNode.absolutePosition, transformNode.absoluteRotationQuaternion);\r\n        }\r\n        this.transformNode = transformNode;\r\n        transformNode.physicsBody = this;\r\n        physicsEngine.addBody(this);\r\n\r\n        this._nodeDisposeObserver = transformNode.onDisposeObservable.add(() => {\r\n            this.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"PhysicsBody\".\r\n     * @returns \"PhysicsBody\"\r\n     */\r\n    public getClassName() {\r\n        return \"PhysicsBody\";\r\n    }\r\n\r\n    /**\r\n     * Clone the PhysicsBody to a new body and assign it to the transformNode parameter\r\n     * @param transformNode transformNode that will be used for the cloned PhysicsBody\r\n     * @returns the newly cloned PhysicsBody\r\n     */\r\n    public clone(transformNode: TransformNode): PhysicsBody {\r\n        const clonedBody = new PhysicsBody(transformNode, this.getMotionType(), this.startAsleep, this.transformNode.getScene());\r\n        clonedBody.shape = this.shape;\r\n        clonedBody.setMassProperties(this.getMassProperties());\r\n        clonedBody.setLinearDamping(this.getLinearDamping());\r\n        clonedBody.setAngularDamping(this.getAngularDamping());\r\n        return clonedBody;\r\n    }\r\n\r\n    /**\r\n     * If a physics body is connected to an instanced node, update the number physic instances to match the number of node instances.\r\n     */\r\n    public updateBodyInstances() {\r\n        const m = this.transformNode as Mesh;\r\n        if (m.hasThinInstances) {\r\n            this._physicsPlugin.updateBodyInstances(this, m);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This returns the number of internal instances of the physics body\r\n     */\r\n    public get numInstances(): number {\r\n        return this._pluginDataInstances.length;\r\n    }\r\n\r\n    /**\r\n     * Sets the shape of the physics body.\r\n     * @param shape - The shape of the physics body.\r\n     *\r\n     * This method is useful for setting the shape of the physics body, which is necessary for the physics engine to accurately simulate the body's behavior.\r\n     * The shape is used to calculate the body's mass, inertia, and other properties.\r\n     */\r\n    public set shape(shape: Nullable<PhysicsShape>) {\r\n        this._physicsPlugin.setShape(this, shape);\r\n    }\r\n\r\n    /**\r\n     * Retrieves the physics shape associated with this object.\r\n     *\r\n     * @returns The physics shape associated with this object, or `undefined` if no\r\n     * shape is associated.\r\n     *\r\n     * This method is useful for retrieving the physics shape associated with this object,\r\n     * which can be used to apply physical forces to the object or to detect collisions.\r\n     */\r\n    public get shape(): Nullable<PhysicsShape> {\r\n        return this._physicsPlugin.getShape(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the event mask for the physics engine.\r\n     *\r\n     * @param eventMask - A bitmask that determines which events will be sent to the physics engine.\r\n     *\r\n     * This method is useful for setting the event mask for the physics engine, which determines which events\r\n     * will be sent to the physics engine. This allows the user to control which events the physics engine will respond to.\r\n     */\r\n    public setEventMask(eventMask: number, instanceIndex?: number) {\r\n        this._physicsPlugin.setEventMask(this, eventMask, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Gets the event mask of the physics engine.\r\n     *\r\n     * @returns The event mask of the physics engine.\r\n     *\r\n     * This method is useful for getting the event mask of the physics engine,\r\n     * which is used to determine which events the engine will respond to.\r\n     * This is important for ensuring that the engine is responding to the correct events and not\r\n     * wasting resources on unnecessary events.\r\n     */\r\n    public getEventMask(instanceIndex?: number): number {\r\n        return this._physicsPlugin.getEventMask(this, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Sets the motion type of the physics body. Can be STATIC, DYNAMIC, or ANIMATED.\r\n     */\r\n    public setMotionType(motionType: PhysicsMotionType, instanceIndex?: number) {\r\n        this._physicsPlugin.setMotionType(this, motionType, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Gets the motion type of the physics body. Can be STATIC, DYNAMIC, or ANIMATED.\r\n     */\r\n    public getMotionType(instanceIndex?: number): PhysicsMotionType {\r\n        return this._physicsPlugin.getMotionType(this, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Computes the mass properties of the physics object, based on the set of physics shapes this body uses.\r\n     * This method is useful for computing the initial mass properties of a physics object, such as its mass,\r\n     * inertia, and center of mass; these values are important for accurately simulating the physics of the\r\n     * object in the physics engine, and computing values based on the shape will provide you with reasonable\r\n     * intial values, which you can then customize.\r\n     */\r\n    public computeMassProperties(instanceIndex?: number): PhysicsMassProperties {\r\n        return this._physicsPlugin.computeMassProperties(this, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Sets the mass properties of the physics object.\r\n     *\r\n     * @param massProps - The mass properties to set.\r\n     * @param instanceIndex - The index of the instance to set the mass properties for. If not defined, the mass properties will be set for all instances.\r\n     *\r\n     * This method is useful for setting the mass properties of a physics object, such as its mass,\r\n     * inertia, and center of mass. This is important for accurately simulating the physics of the object in the physics engine.\r\n     */\r\n    public setMassProperties(massProps: PhysicsMassProperties, instanceIndex?: number): void {\r\n        this._physicsPlugin.setMassProperties(this, massProps, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Retrieves the mass properties of the object.\r\n     *\r\n     * @returns The mass properties of the object.\r\n     *\r\n     * This method is useful for physics simulations, as it allows the user to\r\n     * retrieve the mass properties of the object, such as its mass, center of mass,\r\n     * and moment of inertia. This information is necessary for accurate physics\r\n     * simulations.\r\n     */\r\n    public getMassProperties(instanceIndex?: number): PhysicsMassProperties {\r\n        return this._physicsPlugin.getMassProperties(this, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Sets the linear damping of the physics body.\r\n     *\r\n     * @param damping - The linear damping value.\r\n     *\r\n     * This method is useful for controlling the linear damping of the physics body,\r\n     * which is the rate at which the body's velocity decreases over time. This is useful for simulating\r\n     * the effects of air resistance or other forms of friction.\r\n     */\r\n    public setLinearDamping(damping: number, instanceIndex?: number) {\r\n        this._physicsPlugin.setLinearDamping(this, damping, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Gets the linear damping of the physics body.\r\n     * @returns The linear damping of the physics body.\r\n     *\r\n     * This method is useful for retrieving the linear damping of the physics body, which is the amount of\r\n     * resistance the body has to linear motion. This is useful for simulating realistic physics behavior\r\n     * in a game.\r\n     */\r\n    public getLinearDamping(instanceIndex?: number): number {\r\n        return this._physicsPlugin.getLinearDamping(this, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Sets the angular damping of the physics body.\r\n     * @param damping The angular damping of the body.\r\n     *\r\n     * This method is useful for controlling the angular velocity of a physics body.\r\n     * By setting the damping, the body's angular velocity will be reduced over time, simulating the effect of friction.\r\n     * This can be used to create realistic physical behavior in a physics engine.\r\n     */\r\n    public setAngularDamping(damping: number, instanceIndex?: number) {\r\n        this._physicsPlugin.setAngularDamping(this, damping, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Gets the angular damping of the physics body.\r\n     *\r\n     * @returns The angular damping of the physics body.\r\n     *\r\n     * This method is useful for getting the angular damping of the physics body,\r\n     * which is the rate of reduction of the angular velocity over time.\r\n     * This is important for simulating realistic physics behavior in a game.\r\n     */\r\n    public getAngularDamping(instanceIndex?: number): number {\r\n        return this._physicsPlugin.getAngularDamping(this, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Sets the linear velocity of the physics object.\r\n     * @param linVel - The linear velocity to set.\r\n     *\r\n     * This method is useful for setting the linear velocity of a physics object,\r\n     * which is necessary for simulating realistic physics in a game engine.\r\n     * By setting the linear velocity, the physics object will move in the direction and speed specified by the vector.\r\n     * This allows for realistic physics simulations, such as simulating the motion of a ball rolling down a hill.\r\n     */\r\n    public setLinearVelocity(linVel: Vector3, instanceIndex?: number): void {\r\n        this._physicsPlugin.setLinearVelocity(this, linVel, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Gets the linear velocity of the physics body and stores it in the given vector3.\r\n     * @param linVel - The vector3 to store the linear velocity in.\r\n     *\r\n     * This method is useful for getting the linear velocity of a physics body in a physics engine.\r\n     * This can be used to determine the speed and direction of the body, which can be used to calculate the motion of the body.\r\n     */\r\n    public getLinearVelocityToRef(linVel: Vector3, instanceIndex?: number): void {\r\n        return this._physicsPlugin.getLinearVelocityToRef(this, linVel, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Gets the linear velocity of the physics body as a new vector3.\r\n     * @returns The linear velocity of the physics body.\r\n     *\r\n     * This method is useful for getting the linear velocity of a physics body in a physics engine.\r\n     * This can be used to determine the speed and direction of the body, which can be used to calculate the motion of the body.\r\n     */\r\n    public getLinearVelocity(instanceIndex?: number): Vector3 {\r\n        const ref = new Vector3();\r\n        this.getLinearVelocityToRef(ref, instanceIndex);\r\n        return ref;\r\n    }\r\n\r\n    /**\r\n     * Sets the angular velocity of the physics object.\r\n     * @param angVel - The angular velocity to set.\r\n     *\r\n     * This method is useful for setting the angular velocity of a physics object, which is necessary for\r\n     * simulating realistic physics behavior. The angular velocity is used to determine the rate of rotation of the object,\r\n     * which is important for simulating realistic motion.\r\n     */\r\n    public setAngularVelocity(angVel: Vector3, instanceIndex?: number): void {\r\n        this._physicsPlugin.setAngularVelocity(this, angVel, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Gets the angular velocity of the physics body and stores it in the given vector3.\r\n     * @param angVel - The vector3 to store the angular velocity in.\r\n     *\r\n     * This method is useful for getting the angular velocity of a physics body, which can be used to determine the body's\r\n     * rotational speed. This information can be used to create realistic physics simulations.\r\n     */\r\n    public getAngularVelocityToRef(angVel: Vector3, instanceIndex?: number): void {\r\n        return this._physicsPlugin.getAngularVelocityToRef(this, angVel, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Gets the angular velocity of the physics body as a new vector3.\r\n     * @returns The angular velocity of the physics body.\r\n     *\r\n     * This method is useful for getting the angular velocity of a physics body, which can be used to determine the body's\r\n     * rotational speed. This information can be used to create realistic physics simulations.\r\n     */\r\n    public getAngularVelocity(instanceIndex?: number): Vector3 {\r\n        const ref = new Vector3();\r\n        this.getAngularVelocityToRef(ref, instanceIndex);\r\n        return ref;\r\n    }\r\n\r\n    /**\r\n     * Applies an impulse to the physics object.\r\n     *\r\n     * @param impulse The impulse vector.\r\n     * @param location The location of the impulse.\r\n     * @param instanceIndex For a instanced body, the instance to where the impulse should be applied. If not specified, the impulse is applied to all instances.\r\n     *\r\n     * This method is useful for applying an impulse to a physics object, which can be used to simulate physical forces such as gravity,\r\n     * collisions, and explosions. This can be used to create realistic physics simulations in a game or other application.\r\n     */\r\n    public applyImpulse(impulse: Vector3, location: Vector3, instanceIndex?: number): void {\r\n        this._physicsPlugin.applyImpulse(this, impulse, location, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Applies a force to the physics object.\r\n     *\r\n     * @param force The force vector.\r\n     * @param location The location of the force.\r\n     * @param instanceIndex For a instanced body, the instance to where the force should be applied. If not specified, the force is applied to all instances.\r\n     *\r\n     * This method is useful for applying a force to a physics object, which can be used to simulate physical forces such as gravity,\r\n     * collisions, and explosions. This can be used to create realistic physics simulations in a game or other application.\r\n     */\r\n    public applyForce(force: Vector3, location: Vector3, instanceIndex?: number): void {\r\n        this._physicsPlugin.applyForce(this, force, location, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Retrieves the geometry of the body from the physics plugin.\r\n     *\r\n     * @returns The geometry of the body.\r\n     *\r\n     * This method is useful for retrieving the geometry of the body from the physics plugin, which can be used for various physics calculations.\r\n     */\r\n    public getGeometry(): {} {\r\n        return this._physicsPlugin.getBodyGeometry(this);\r\n    }\r\n\r\n    /**\r\n     * Returns an observable that will be notified for when a collision starts or continues for this PhysicsBody\r\n     * @returns Observable\r\n     */\r\n    public getCollisionObservable(): Observable<IPhysicsCollisionEvent> {\r\n        return this._physicsPlugin.getCollisionObservable(this);\r\n    }\r\n\r\n    /**\r\n     * Returns an observable that will be notified when the body has finished colliding with another body\r\n     * @returns\r\n     */\r\n    public getCollisionEndedObservable(): Observable<IBasePhysicsCollisionEvent> {\r\n        return this._physicsPlugin.getCollisionEndedObservable(this);\r\n    }\r\n\r\n    /**\r\n     * Enable or disable collision callback for this PhysicsBody.\r\n     * @param enabled true if PhysicsBody's collision will rise a collision event and notifies the observable\r\n     */\r\n    public setCollisionCallbackEnabled(enabled: boolean): void {\r\n        this._collisionCBEnabled = enabled;\r\n        this._physicsPlugin.setCollisionCallbackEnabled(this, enabled);\r\n    }\r\n\r\n    public setCollisionEndedCallbackEnabled(enabled: boolean): void {\r\n        this._collisionEndedCBEnabled = enabled;\r\n        this._physicsPlugin.setCollisionEndedCallbackEnabled(this, enabled);\r\n    }\r\n\r\n    /*\r\n     * Get the center of the object in world space.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the center for.\r\n     * @returns geometric center of the associated mesh\r\n     */\r\n    public getObjectCenterWorld(instanceIndex?: number): Vector3 {\r\n        const ref = new Vector3();\r\n        return this.getObjectCenterWorldToRef(ref, instanceIndex);\r\n    }\r\n\r\n    /*\r\n     * Get the center of the object in world space.\r\n     * @param ref - The vector3 to store the result in.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the center for.\r\n     * @returns geometric center of the associated mesh\r\n     */\r\n    public getObjectCenterWorldToRef(ref: Vector3, instanceIndex?: number): Vector3 {\r\n        if (this._pluginDataInstances?.length > 0) {\r\n            const index = instanceIndex || 0;\r\n            const matrixData = (this.transformNode as Mesh)._thinInstanceDataStorage.matrixData;\r\n            if (matrixData) {\r\n                ref.set(matrixData[index * 16 + 12], matrixData[index * 16 + 13], matrixData[index * 16 + 14]);\r\n            }\r\n        } else {\r\n            ref.copyFrom(this.transformNode.position);\r\n        }\r\n        return ref;\r\n    }\r\n\r\n    /**\r\n     * Adds a constraint to the physics engine.\r\n     *\r\n     * @param childBody - The body to which the constraint will be applied.\r\n     * @param constraint - The constraint to be applied.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to which the constraint will be applied. If not specified, no constraint will be applied.\r\n     * @param childInstanceIndex - If the child body is instanced, the index of the instance to which the constraint will be applied. If not specified, no constraint will be applied.\r\n     *\r\n     */\r\n    public addConstraint(childBody: PhysicsBody, constraint: PhysicsConstraint, instanceIndex?: number, childInstanceIndex?: number): void {\r\n        this._physicsPlugin.addConstraint(this, childBody, constraint, instanceIndex, childInstanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Sync with a bone\r\n     * @param bone The bone that the impostor will be synced to.\r\n     * @param boneMesh The mesh that the bone is influencing.\r\n     * @param jointPivot The pivot of the joint / bone in local space.\r\n     * @param distToJoint Optional distance from the impostor to the joint.\r\n     * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.\r\n     * @param boneAxis Optional vector3 axis the bone is aligned with\r\n     */\r\n    public syncWithBone(bone: Bone, boneMesh: AbstractMesh, jointPivot: Vector3, distToJoint?: number, adjustRotation?: Quaternion, boneAxis?: Vector3) {\r\n        const mesh = this.transformNode;\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            if (adjustRotation) {\r\n                const tempQuat = TmpVectors.Quaternion[0];\r\n                bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, tempQuat);\r\n                tempQuat.multiplyToRef(adjustRotation, mesh.rotationQuaternion);\r\n            } else {\r\n                bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, mesh.rotationQuaternion);\r\n            }\r\n        }\r\n\r\n        const pos = TmpVectors.Vector3[0];\r\n        const boneDir = TmpVectors.Vector3[1];\r\n\r\n        if (!boneAxis) {\r\n            boneAxis = TmpVectors.Vector3[2];\r\n            boneAxis.x = 0;\r\n            boneAxis.y = 1;\r\n            boneAxis.z = 0;\r\n        }\r\n\r\n        bone.getDirectionToRef(boneAxis, boneMesh, boneDir);\r\n        bone.getAbsolutePositionToRef(boneMesh, pos);\r\n\r\n        if ((distToJoint === undefined || distToJoint === null) && jointPivot) {\r\n            distToJoint = jointPivot.length();\r\n        }\r\n\r\n        if (distToJoint !== undefined && distToJoint !== null) {\r\n            pos.x += boneDir.x * distToJoint;\r\n            pos.y += boneDir.y * distToJoint;\r\n            pos.z += boneDir.z * distToJoint;\r\n        }\r\n\r\n        mesh.setAbsolutePosition(pos);\r\n    }\r\n\r\n    /**\r\n     * Executes a callback on the body or all of the instances of a body\r\n     * @param callback the callback to execute\r\n     */\r\n    public iterateOverAllInstances(callback: (body: PhysicsBody, instanceIndex?: number) => void) {\r\n        if (this._pluginDataInstances?.length > 0) {\r\n            for (let i = 0; i < this._pluginDataInstances.length; i++) {\r\n                callback(this, i);\r\n            }\r\n        } else {\r\n            callback(this, undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the gravity factor of the physics body\r\n     * @param factor the gravity factor to set\r\n     * @param instanceIndex the instance of the body to set, if undefined all instances will be set\r\n     */\r\n    public setGravityFactor(factor: number, instanceIndex?: number) {\r\n        this._physicsPlugin.setGravityFactor(this, factor, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Gets the gravity factor of the physics body\r\n     * @param instanceIndex the instance of the body to get, if undefined the value of first instance will be returned\r\n     * @returns the gravity factor\r\n     */\r\n    public getGravityFactor(instanceIndex?: number): number {\r\n        return this._physicsPlugin.getGravityFactor(this, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Set the target transformation (position and rotation) of the body, such that the body will set its velocity to reach that target\r\n     * @param position The target position\r\n     * @param rotation The target rotation\r\n     * @param instanceIndex The index of the instance in an instanced body\r\n     */\r\n    public setTargetTransform(position: Vector3, rotation: Quaternion, instanceIndex?: number) {\r\n        this._physicsPlugin.setTargetTransform(this, position, rotation, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Disposes the body from the physics engine.\r\n     *\r\n     * This method is useful for cleaning up the physics engine when a body is no longer needed. Disposing the body will free up resources and prevent memory leaks.\r\n     */\r\n    public dispose() {\r\n        if (this._isDisposed) {\r\n            return;\r\n        }\r\n        // Disable collisions CB so it doesn't fire when the body is disposed\r\n        if (this._collisionCBEnabled) {\r\n            this.setCollisionCallbackEnabled(false);\r\n        }\r\n        if (this._collisionEndedCBEnabled) {\r\n            this.setCollisionEndedCallbackEnabled(false);\r\n        }\r\n        if (this._nodeDisposeObserver) {\r\n            this.transformNode.onDisposeObservable.remove(this._nodeDisposeObserver);\r\n            this._nodeDisposeObserver = null;\r\n        }\r\n        this._physicsEngine.removeBody(this);\r\n        this._physicsPlugin.removeBody(this);\r\n        this._physicsPlugin.disposeBody(this);\r\n        this.transformNode.physicsBody = null;\r\n        this._pluginData = null;\r\n        this._pluginDataInstances.length = 0;\r\n        this._isDisposed = true;\r\n    }\r\n}\r\n"],"mappings":"AAEA,SAASA,OAAO,EAAEC,UAAU,EAAEC,UAAU,QAAQ,4BAA0B;AAM1E,SAASC,KAAK,QAAE;AAOhB;;;;;AAKA,OAAM,MAAOC,WAAW;EA4CpB;;;;;;;;;;;;;;EAcAC,YAAYC,aAA4B,EAAEC,UAA6B,EAAEC,YAAqB,EAAEC,KAAY;IAzD5G;;;IAGO,KAAAC,WAAW,GAAQC,SAAS;IACnC;;;IAGO,KAAAC,oBAAoB,GAAe,EAAE;IAS5C;;;IAGQ,KAAAC,mBAAmB,GAAY,KAAK;IAC5C;;;IAGQ,KAAAC,wBAAwB,GAAY,KAAK;IAKjD;;;;IAIA,KAAAC,cAAc,GAAY,IAAI;IAStB,KAAAC,WAAW,GAAG,KAAK;IAiBvB,IAAI,CAACP,KAAK,EAAE;MACR;;IAEJ,MAAMQ,aAAa,GAAGR,KAAK,CAACS,gBAAgB,EAAmB;IAC/D,IAAI,CAACD,aAAa,EAAE;MAChB,MAAM,IAAIE,KAAK,CAAC,8BAA8B,CAAC;;IAEnD,IAAI,CAACC,cAAc,GAAGH,aAAa;IACnC,IAAIA,aAAa,CAACI,gBAAgB,EAAE,IAAI,CAAC,EAAE;MACvC,MAAM,IAAIF,KAAK,CAAC,kDAAkD,CAAC;;IAEvE,MAAMG,aAAa,GAAGL,aAAa,CAACM,gBAAgB,EAAE;IACtD,IAAI,CAACD,aAAa,EAAE;MAChB,MAAM,IAAIH,KAAK,CAAC,8BAA8B,CAAC;;IAGnD,IAAI,CAACK,cAAc,GAAGF,aAAuC;IAC7D,IAAI,CAAChB,aAAa,CAACmB,kBAAkB,EAAE;MACnCnB,aAAa,CAACmB,kBAAkB,GAAGxB,UAAU,CAACyB,eAAe,CAACpB,aAAa,CAACqB,QAAQ,CAACC,CAAC,EAAEtB,aAAa,CAACqB,QAAQ,CAACE,CAAC,EAAEvB,aAAa,CAACqB,QAAQ,CAACG,CAAC,CAAC;;IAG/I,IAAI,CAACC,WAAW,GAAGvB,YAAY;IAE/B;IACA,MAAMwB,CAAC,GAAG1B,aAAqB;IAC/B,IAAI0B,CAAC,CAACC,gBAAgB,EAAE;MACpB,IAAI,CAACT,cAAc,CAACU,iBAAiB,CAAC,IAAI,EAAE3B,UAAU,EAAEyB,CAAC,CAAC;KAC7D,MAAM;MACH;MACA,IAAI1B,aAAa,CAAC6B,MAAM,EAAE;QACtB;QACA7B,aAAa,CAAC8B,kBAAkB,CAAC,IAAI,CAAC;;MAE1C,IAAI,CAACZ,cAAc,CAACa,QAAQ,CAAC,IAAI,EAAE9B,UAAU,EAAED,aAAa,CAACgC,gBAAgB,EAAEhC,aAAa,CAACiC,0BAA0B,CAAC;;IAE5H,IAAI,CAACjC,aAAa,GAAGA,aAAa;IAClCA,aAAa,CAACkC,WAAW,GAAG,IAAI;IAChCvB,aAAa,CAACwB,OAAO,CAAC,IAAI,CAAC;IAE3B,IAAI,CAACC,oBAAoB,GAAGpC,aAAa,CAACqC,mBAAmB,CAACC,GAAG,CAAC,MAAK;MACnE,IAAI,CAACC,OAAO,EAAE;IAClB,CAAC,CAAC;EACN;EAEA;;;;EAIOC,YAAYA,CAAA;IACf,OAAO,aAAa;EACxB;EAEA;;;;;EAKOC,KAAKA,CAACzC,aAA4B;IACrC,MAAM0C,UAAU,GAAG,IAAI5C,WAAW,CAACE,aAAa,EAAE,IAAI,CAAC2C,aAAa,EAAE,EAAE,IAAI,CAAClB,WAAW,EAAE,IAAI,CAACzB,aAAa,CAAC4C,QAAQ,EAAE,CAAC;IACxHF,UAAU,CAACG,KAAK,GAAG,IAAI,CAACA,KAAK;IAC7BH,UAAU,CAACI,iBAAiB,CAAC,IAAI,CAACC,iBAAiB,EAAE,CAAC;IACtDL,UAAU,CAACM,gBAAgB,CAAC,IAAI,CAACC,gBAAgB,EAAE,CAAC;IACpDP,UAAU,CAACQ,iBAAiB,CAAC,IAAI,CAACC,iBAAiB,EAAE,CAAC;IACtD,OAAOT,UAAU;EACrB;EAEA;;;EAGOU,mBAAmBA,CAAA;IACtB,MAAM1B,CAAC,GAAG,IAAI,CAAC1B,aAAqB;IACpC,IAAI0B,CAAC,CAACC,gBAAgB,EAAE;MACpB,IAAI,CAACT,cAAc,CAACkC,mBAAmB,CAAC,IAAI,EAAE1B,CAAC,CAAC;;EAExD;EAEA;;;EAGA,IAAW2B,YAAYA,CAAA;IACnB,OAAO,IAAI,CAAC/C,oBAAoB,CAACgD,MAAM;EAC3C;EAEA;;;;;;;EAOA,IAAWT,KAAKA,CAACA,KAA6B;IAC1C,IAAI,CAAC3B,cAAc,CAACqC,QAAQ,CAAC,IAAI,EAAEV,KAAK,CAAC;EAC7C;EAEA;;;;;;;;;EASA,IAAWA,KAAKA,CAAA;IACZ,OAAO,IAAI,CAAC3B,cAAc,CAACsC,QAAQ,CAAC,IAAI,CAAC;EAC7C;EAEA;;;;;;;;EAQOC,YAAYA,CAACC,SAAiB,EAAEC,aAAsB;IACzD,IAAI,CAACzC,cAAc,CAACuC,YAAY,CAAC,IAAI,EAAEC,SAAS,EAAEC,aAAa,CAAC;EACpE;EAEA;;;;;;;;;;EAUOC,YAAYA,CAACD,aAAsB;IACtC,OAAO,IAAI,CAACzC,cAAc,CAAC0C,YAAY,CAAC,IAAI,EAAED,aAAa,CAAC;EAChE;EAEA;;;EAGOE,aAAaA,CAAC5D,UAA6B,EAAE0D,aAAsB;IACtE,IAAI,CAACzC,cAAc,CAAC2C,aAAa,CAAC,IAAI,EAAE5D,UAAU,EAAE0D,aAAa,CAAC;EACtE;EAEA;;;EAGOhB,aAAaA,CAACgB,aAAsB;IACvC,OAAO,IAAI,CAACzC,cAAc,CAACyB,aAAa,CAAC,IAAI,EAAEgB,aAAa,CAAC;EACjE;EAEA;;;;;;;EAOOG,qBAAqBA,CAACH,aAAsB;IAC/C,OAAO,IAAI,CAACzC,cAAc,CAAC4C,qBAAqB,CAAC,IAAI,EAAEH,aAAa,CAAC;EACzE;EAEA;;;;;;;;;EASOb,iBAAiBA,CAACiB,SAAgC,EAAEJ,aAAsB;IAC7E,IAAI,CAACzC,cAAc,CAAC4B,iBAAiB,CAAC,IAAI,EAAEiB,SAAS,EAAEJ,aAAa,CAAC;EACzE;EAEA;;;;;;;;;;EAUOZ,iBAAiBA,CAACY,aAAsB;IAC3C,OAAO,IAAI,CAACzC,cAAc,CAAC6B,iBAAiB,CAAC,IAAI,EAAEY,aAAa,CAAC;EACrE;EAEA;;;;;;;;;EASOX,gBAAgBA,CAACgB,OAAe,EAAEL,aAAsB;IAC3D,IAAI,CAACzC,cAAc,CAAC8B,gBAAgB,CAAC,IAAI,EAAEgB,OAAO,EAAEL,aAAa,CAAC;EACtE;EAEA;;;;;;;;EAQOV,gBAAgBA,CAACU,aAAsB;IAC1C,OAAO,IAAI,CAACzC,cAAc,CAAC+B,gBAAgB,CAAC,IAAI,EAAEU,aAAa,CAAC;EACpE;EAEA;;;;;;;;EAQOT,iBAAiBA,CAACc,OAAe,EAAEL,aAAsB;IAC5D,IAAI,CAACzC,cAAc,CAACgC,iBAAiB,CAAC,IAAI,EAAEc,OAAO,EAAEL,aAAa,CAAC;EACvE;EAEA;;;;;;;;;EASOR,iBAAiBA,CAACQ,aAAsB;IAC3C,OAAO,IAAI,CAACzC,cAAc,CAACiC,iBAAiB,CAAC,IAAI,EAAEQ,aAAa,CAAC;EACrE;EAEA;;;;;;;;;EASOM,iBAAiBA,CAACC,MAAe,EAAEP,aAAsB;IAC5D,IAAI,CAACzC,cAAc,CAAC+C,iBAAiB,CAAC,IAAI,EAAEC,MAAM,EAAEP,aAAa,CAAC;EACtE;EAEA;;;;;;;EAOOQ,sBAAsBA,CAACD,MAAe,EAAEP,aAAsB;IACjE,OAAO,IAAI,CAACzC,cAAc,CAACiD,sBAAsB,CAAC,IAAI,EAAED,MAAM,EAAEP,aAAa,CAAC;EAClF;EAEA;;;;;;;EAOOS,iBAAiBA,CAACT,aAAsB;IAC3C,MAAMU,GAAG,GAAG,IAAI3E,OAAO,EAAE;IACzB,IAAI,CAACyE,sBAAsB,CAACE,GAAG,EAAEV,aAAa,CAAC;IAC/C,OAAOU,GAAG;EACd;EAEA;;;;;;;;EAQOC,kBAAkBA,CAACC,MAAe,EAAEZ,aAAsB;IAC7D,IAAI,CAACzC,cAAc,CAACoD,kBAAkB,CAAC,IAAI,EAAEC,MAAM,EAAEZ,aAAa,CAAC;EACvE;EAEA;;;;;;;EAOOa,uBAAuBA,CAACD,MAAe,EAAEZ,aAAsB;IAClE,OAAO,IAAI,CAACzC,cAAc,CAACsD,uBAAuB,CAAC,IAAI,EAAED,MAAM,EAAEZ,aAAa,CAAC;EACnF;EAEA;;;;;;;EAOOc,kBAAkBA,CAACd,aAAsB;IAC5C,MAAMU,GAAG,GAAG,IAAI3E,OAAO,EAAE;IACzB,IAAI,CAAC8E,uBAAuB,CAACH,GAAG,EAAEV,aAAa,CAAC;IAChD,OAAOU,GAAG;EACd;EAEA;;;;;;;;;;EAUOK,YAAYA,CAACC,OAAgB,EAAEC,QAAiB,EAAEjB,aAAsB;IAC3E,IAAI,CAACzC,cAAc,CAACwD,YAAY,CAAC,IAAI,EAAEC,OAAO,EAAEC,QAAQ,EAAEjB,aAAa,CAAC;EAC5E;EAEA;;;;;;;;;;EAUOkB,UAAUA,CAACC,KAAc,EAAEF,QAAiB,EAAEjB,aAAsB;IACvE,IAAI,CAACzC,cAAc,CAAC2D,UAAU,CAAC,IAAI,EAAEC,KAAK,EAAEF,QAAQ,EAAEjB,aAAa,CAAC;EACxE;EAEA;;;;;;;EAOOoB,WAAWA,CAAA;IACd,OAAO,IAAI,CAAC7D,cAAc,CAAC8D,eAAe,CAAC,IAAI,CAAC;EACpD;EAEA;;;;EAIOC,sBAAsBA,CAAA;IACzB,OAAO,IAAI,CAAC/D,cAAc,CAAC+D,sBAAsB,CAAC,IAAI,CAAC;EAC3D;EAEA;;;;EAIOC,2BAA2BA,CAAA;IAC9B,OAAO,IAAI,CAAChE,cAAc,CAACgE,2BAA2B,CAAC,IAAI,CAAC;EAChE;EAEA;;;;EAIOC,2BAA2BA,CAACC,OAAgB;IAC/C,IAAI,CAAC7E,mBAAmB,GAAG6E,OAAO;IAClC,IAAI,CAAClE,cAAc,CAACiE,2BAA2B,CAAC,IAAI,EAAEC,OAAO,CAAC;EAClE;EAEOC,gCAAgCA,CAACD,OAAgB;IACpD,IAAI,CAAC5E,wBAAwB,GAAG4E,OAAO;IACvC,IAAI,CAAClE,cAAc,CAACmE,gCAAgC,CAAC,IAAI,EAAED,OAAO,CAAC;EACvE;EAEA;;;;;EAKOE,oBAAoBA,CAAC3B,aAAsB;IAC9C,MAAMU,GAAG,GAAG,IAAI3E,OAAO,EAAE;IACzB,OAAO,IAAI,CAAC6F,yBAAyB,CAAClB,GAAG,EAAEV,aAAa,CAAC;EAC7D;EAEA;;;;;;EAMO4B,yBAAyBA,CAAClB,GAAY,EAAEV,aAAsB;;IACjE,IAAI,EAAA6B,EAAA,OAAI,CAAClF,oBAAoB,cAAAkF,EAAA,uBAAAA,EAAA,CAAElC,MAAM,IAAG,CAAC,EAAE;MACvC,MAAMmC,KAAK,GAAG9B,aAAa,IAAI,CAAC;MAChC,MAAM+B,UAAU,GAAI,IAAI,CAAC1F,aAAsB,CAAC2F,wBAAwB,CAACD,UAAU;MACnF,IAAIA,UAAU,EAAE;QACZrB,GAAG,CAACuB,GAAG,CAACF,UAAU,CAACD,KAAK,GAAG,EAAE,GAAG,EAAE,CAAC,EAAEC,UAAU,CAACD,KAAK,GAAG,EAAE,GAAG,EAAE,CAAC,EAAEC,UAAU,CAACD,KAAK,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;;KAErG,MAAM;MACHpB,GAAG,CAACwB,QAAQ,CAAC,IAAI,CAAC7F,aAAa,CAAC8F,QAAQ,CAAC;;IAE7C,OAAOzB,GAAG;EACd;EAEA;;;;;;;;;EASO0B,aAAaA,CAACC,SAAsB,EAAEC,UAA6B,EAAEtC,aAAsB,EAAEuC,kBAA2B;IAC3H,IAAI,CAAChF,cAAc,CAAC6E,aAAa,CAAC,IAAI,EAAEC,SAAS,EAAEC,UAAU,EAAEtC,aAAa,EAAEuC,kBAAkB,CAAC;EACrG;EAEA;;;;;;;;;EASOC,YAAYA,CAACC,IAAU,EAAEC,QAAsB,EAAEC,UAAmB,EAAEC,WAAoB,EAAEC,cAA2B,EAAEC,QAAkB;IAC9I,MAAMC,IAAI,GAAG,IAAI,CAAC1G,aAAa;IAE/B,IAAI0G,IAAI,CAACvF,kBAAkB,EAAE;MACzB,IAAIqF,cAAc,EAAE;QAChB,MAAMG,QAAQ,GAAG/G,UAAU,CAACD,UAAU,CAAC,CAAC,CAAC;QACzCyG,IAAI,CAACQ,0BAA0B,CAAC/G,KAAK,CAACgH,KAAK,EAAER,QAAQ,EAAEM,QAAQ,CAAC;QAChEA,QAAQ,CAACG,aAAa,CAACN,cAAc,EAAEE,IAAI,CAACvF,kBAAkB,CAAC;OAClE,MAAM;QACHiF,IAAI,CAACQ,0BAA0B,CAAC/G,KAAK,CAACgH,KAAK,EAAER,QAAQ,EAAEK,IAAI,CAACvF,kBAAkB,CAAC;;;IAIvF,MAAM4F,GAAG,GAAGnH,UAAU,CAACF,OAAO,CAAC,CAAC,CAAC;IACjC,MAAMsH,OAAO,GAAGpH,UAAU,CAACF,OAAO,CAAC,CAAC,CAAC;IAErC,IAAI,CAAC+G,QAAQ,EAAE;MACXA,QAAQ,GAAG7G,UAAU,CAACF,OAAO,CAAC,CAAC,CAAC;MAChC+G,QAAQ,CAACnF,CAAC,GAAG,CAAC;MACdmF,QAAQ,CAAClF,CAAC,GAAG,CAAC;MACdkF,QAAQ,CAACjF,CAAC,GAAG,CAAC;;IAGlB4E,IAAI,CAACa,iBAAiB,CAACR,QAAQ,EAAEJ,QAAQ,EAAEW,OAAO,CAAC;IACnDZ,IAAI,CAACc,wBAAwB,CAACb,QAAQ,EAAEU,GAAG,CAAC;IAE5C,IAAI,CAACR,WAAW,KAAKlG,SAAS,IAAIkG,WAAW,KAAK,IAAI,KAAKD,UAAU,EAAE;MACnEC,WAAW,GAAGD,UAAU,CAAChD,MAAM,EAAE;;IAGrC,IAAIiD,WAAW,KAAKlG,SAAS,IAAIkG,WAAW,KAAK,IAAI,EAAE;MACnDQ,GAAG,CAACzF,CAAC,IAAI0F,OAAO,CAAC1F,CAAC,GAAGiF,WAAW;MAChCQ,GAAG,CAACxF,CAAC,IAAIyF,OAAO,CAACzF,CAAC,GAAGgF,WAAW;MAChCQ,GAAG,CAACvF,CAAC,IAAIwF,OAAO,CAACxF,CAAC,GAAG+E,WAAW;;IAGpCG,IAAI,CAACS,mBAAmB,CAACJ,GAAG,CAAC;EACjC;EAEA;;;;EAIOK,uBAAuBA,CAACC,QAA6D;;IACxF,IAAI,EAAA7B,EAAA,OAAI,CAAClF,oBAAoB,cAAAkF,EAAA,uBAAAA,EAAA,CAAElC,MAAM,IAAG,CAAC,EAAE;MACvC,KAAK,IAAIgE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAChH,oBAAoB,CAACgD,MAAM,EAAEgE,CAAC,EAAE,EAAE;QACvDD,QAAQ,CAAC,IAAI,EAAEC,CAAC,CAAC;;KAExB,MAAM;MACHD,QAAQ,CAAC,IAAI,EAAEhH,SAAS,CAAC;;EAEjC;EAEA;;;;;EAKOkH,gBAAgBA,CAACC,MAAc,EAAE7D,aAAsB;IAC1D,IAAI,CAACzC,cAAc,CAACqG,gBAAgB,CAAC,IAAI,EAAEC,MAAM,EAAE7D,aAAa,CAAC;EACrE;EAEA;;;;;EAKO8D,gBAAgBA,CAAC9D,aAAsB;IAC1C,OAAO,IAAI,CAACzC,cAAc,CAACuG,gBAAgB,CAAC,IAAI,EAAE9D,aAAa,CAAC;EACpE;EAEA;;;;;;EAMO+D,kBAAkBA,CAAC5B,QAAiB,EAAEzE,QAAoB,EAAEsC,aAAsB;IACrF,IAAI,CAACzC,cAAc,CAACwG,kBAAkB,CAAC,IAAI,EAAE5B,QAAQ,EAAEzE,QAAQ,EAAEsC,aAAa,CAAC;EACnF;EAEA;;;;;EAKOpB,OAAOA,CAAA;IACV,IAAI,IAAI,CAAC7B,WAAW,EAAE;MAClB;;IAEJ;IACA,IAAI,IAAI,CAACH,mBAAmB,EAAE;MAC1B,IAAI,CAAC4E,2BAA2B,CAAC,KAAK,CAAC;;IAE3C,IAAI,IAAI,CAAC3E,wBAAwB,EAAE;MAC/B,IAAI,CAAC6E,gCAAgC,CAAC,KAAK,CAAC;;IAEhD,IAAI,IAAI,CAACjD,oBAAoB,EAAE;MAC3B,IAAI,CAACpC,aAAa,CAACqC,mBAAmB,CAACsF,MAAM,CAAC,IAAI,CAACvF,oBAAoB,CAAC;MACxE,IAAI,CAACA,oBAAoB,GAAG,IAAI;;IAEpC,IAAI,CAACtB,cAAc,CAAC8G,UAAU,CAAC,IAAI,CAAC;IACpC,IAAI,CAAC1G,cAAc,CAAC0G,UAAU,CAAC,IAAI,CAAC;IACpC,IAAI,CAAC1G,cAAc,CAAC2G,WAAW,CAAC,IAAI,CAAC;IACrC,IAAI,CAAC7H,aAAa,CAACkC,WAAW,GAAG,IAAI;IACrC,IAAI,CAAC9B,WAAW,GAAG,IAAI;IACvB,IAAI,CAACE,oBAAoB,CAACgD,MAAM,GAAG,CAAC;IACpC,IAAI,CAAC5C,WAAW,GAAG,IAAI;EAC3B"},"metadata":{},"sourceType":"module","externalDependencies":[]}