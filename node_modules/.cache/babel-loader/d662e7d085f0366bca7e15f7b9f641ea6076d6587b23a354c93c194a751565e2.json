{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext.js\";\nimport * as WebGPUConstants from \"./webgpuConstants.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor.js\";\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage.js\";\n/** @internal */\nexport class WebGPUShaderProcessorGLSL extends WebGPUShaderProcessor {\n  constructor() {\n    super(...arguments);\n    this._missingVaryings = [];\n    this._textureArrayProcessing = [];\n    this._vertexIsGLES3 = false;\n    this._fragmentIsGLES3 = false;\n    this.shaderLanguage = ShaderLanguage.GLSL;\n    this.parseGLES3 = true;\n  }\n  _getArraySize(name, type, preProcessors) {\n    let length = 0;\n    const startArray = name.indexOf(\"[\");\n    const endArray = name.indexOf(\"]\");\n    if (startArray > 0 && endArray > 0) {\n      const lengthInString = name.substring(startArray + 1, endArray);\n      length = +lengthInString;\n      if (isNaN(length)) {\n        length = +preProcessors[lengthInString.trim()];\n      }\n      name = name.substr(0, startArray);\n    }\n    return [name, type, length];\n  }\n  initializeShaders(processingContext) {\n    this._webgpuProcessingContext = processingContext;\n    this._missingVaryings.length = 0;\n    this._textureArrayProcessing.length = 0;\n    this.attributeKeywordName = undefined;\n    this.varyingVertexKeywordName = undefined;\n    this.varyingFragmentKeywordName = undefined;\n  }\n  preProcessShaderCode(code, isFragment) {\n    const ubDeclaration = `// Internals UBO\\nuniform ${WebGPUShaderProcessor.InternalsUBOName} {\\nfloat yFactor_;\\nfloat textureOutputHeight_;\\n};\\n`;\n    const alreadyInjected = code.indexOf(\"// Internals UBO\") !== -1;\n    if (isFragment) {\n      this._fragmentIsGLES3 = code.indexOf(\"#version 3\") !== -1;\n      if (this._fragmentIsGLES3) {\n        this.varyingFragmentKeywordName = \"in\";\n      }\n      return alreadyInjected ? code : ubDeclaration + \"##INJECTCODE##\\n\" + code;\n    }\n    this._vertexIsGLES3 = code.indexOf(\"#version 3\") !== -1;\n    if (this._vertexIsGLES3) {\n      this.attributeKeywordName = \"in\";\n      this.varyingVertexKeywordName = \"out\";\n    }\n    return alreadyInjected ? code : ubDeclaration + code;\n  }\n  varyingCheck(varying, isFragment) {\n    const outRegex = /(flat\\s)?\\s*\\bout\\b/;\n    const inRegex = /(flat\\s)?\\s*\\bin\\b/;\n    const varyingRegex = /(flat\\s)?\\s*\\bvarying\\b/;\n    const regex = isFragment && this._fragmentIsGLES3 ? inRegex : !isFragment && this._vertexIsGLES3 ? outRegex : varyingRegex;\n    return regex.test(varying);\n  }\n  varyingProcessor(varying, isFragment, preProcessors) {\n    var _a;\n    this._preProcessors = preProcessors;\n    const outRegex = /\\s*(flat)?\\s*out\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\n    const inRegex = /\\s*(flat)?\\s*in\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\n    const varyingRegex = /\\s*(flat)?\\s*varying\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\n    const regex = isFragment && this._fragmentIsGLES3 ? inRegex : !isFragment && this._vertexIsGLES3 ? outRegex : varyingRegex;\n    const match = regex.exec(varying);\n    if (match !== null) {\n      const interpolationQualifier = (_a = match[1]) !== null && _a !== void 0 ? _a : \"\";\n      const varyingType = match[2];\n      const name = match[3];\n      let location;\n      if (isFragment) {\n        location = this._webgpuProcessingContext.availableVaryings[name];\n        this._missingVaryings[location] = \"\";\n        if (location === undefined) {\n          Logger.Warn(`Invalid fragment shader: The varying named \"${name}\" is not declared in the vertex shader! This declaration will be ignored.`);\n        }\n      } else {\n        location = this._webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name, varyingType, preProcessors)[2]);\n        this._webgpuProcessingContext.availableVaryings[name] = location;\n        this._missingVaryings[location] = `layout(location = ${location}) ${interpolationQualifier} in ${varyingType} ${name};`;\n      }\n      varying = varying.replace(match[0], location === undefined ? \"\" : `layout(location = ${location}) ${interpolationQualifier} ${isFragment ? \"in\" : \"out\"} ${varyingType} ${name};`);\n    }\n    return varying;\n  }\n  attributeProcessor(attribute, preProcessors) {\n    this._preProcessors = preProcessors;\n    const inRegex = /\\s*in\\s+(\\S+)\\s+(\\S+)\\s*;/gm;\n    const attribRegex = /\\s*attribute\\s+(\\S+)\\s+(\\S+)\\s*;/gm;\n    const regex = this._vertexIsGLES3 ? inRegex : attribRegex;\n    const match = regex.exec(attribute);\n    if (match !== null) {\n      const attributeType = match[1];\n      const name = match[2];\n      const location = this._webgpuProcessingContext.getAttributeNextLocation(attributeType, this._getArraySize(name, attributeType, preProcessors)[2]);\n      this._webgpuProcessingContext.availableAttributes[name] = location;\n      this._webgpuProcessingContext.orderedAttributes[location] = name;\n      const numComponents = this.vertexBufferKindToNumberOfComponents[name];\n      if (numComponents !== undefined) {\n        // Special case for an int/ivecX vertex buffer that is used as a float/vecX attribute in the shader.\n        const newType = numComponents < 0 ? numComponents === -1 ? \"int\" : \"ivec\" + -numComponents : numComponents === 1 ? \"uint\" : \"uvec\" + numComponents;\n        const newName = `_int_${name}_`;\n        attribute = attribute.replace(match[0], `layout(location = ${location}) in ${newType} ${newName}; ${attributeType} ${name} = ${attributeType}(${newName});`);\n      } else {\n        attribute = attribute.replace(match[0], `layout(location = ${location}) in ${attributeType} ${name};`);\n      }\n    }\n    return attribute;\n  }\n  uniformProcessor(uniform, isFragment, preProcessors) {\n    var _a;\n    this._preProcessors = preProcessors;\n    const uniformRegex = /\\s*uniform\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\n    const match = uniformRegex.exec(uniform);\n    if (match !== null) {\n      let uniformType = match[1];\n      let name = match[2];\n      if (uniformType.indexOf(\"sampler\") === 0 || uniformType.indexOf(\"sampler\") === 1) {\n        let arraySize = 0; // 0 means the texture is not declared as an array\n        [name, uniformType, arraySize] = this._getArraySize(name, uniformType, preProcessors);\n        let textureInfo = this._webgpuProcessingContext.availableTextures[name];\n        if (!textureInfo) {\n          textureInfo = {\n            autoBindSampler: true,\n            isTextureArray: arraySize > 0,\n            isStorageTexture: false,\n            textures: [],\n            sampleType: WebGPUConstants.TextureSampleType.Float\n          };\n          for (let i = 0; i < (arraySize || 1); ++i) {\n            textureInfo.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding());\n          }\n        }\n        const samplerType = (_a = WebGPUShaderProcessor._SamplerTypeByWebGLSamplerType[uniformType]) !== null && _a !== void 0 ? _a : \"sampler\";\n        const isComparisonSampler = !!WebGPUShaderProcessor._IsComparisonSamplerByWebGPUSamplerType[samplerType];\n        const samplerBindingType = isComparisonSampler ? WebGPUConstants.SamplerBindingType.Comparison : WebGPUConstants.SamplerBindingType.Filtering;\n        const samplerName = name + WebGPUShaderProcessor.AutoSamplerSuffix;\n        let samplerInfo = this._webgpuProcessingContext.availableSamplers[samplerName];\n        if (!samplerInfo) {\n          samplerInfo = {\n            binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),\n            type: samplerBindingType\n          };\n        }\n        const componentType = uniformType.charAt(0) === \"u\" ? \"u\" : uniformType.charAt(0) === \"i\" ? \"i\" : \"\";\n        if (componentType) {\n          uniformType = uniformType.substr(1);\n        }\n        const sampleType = isComparisonSampler ? WebGPUConstants.TextureSampleType.Depth : componentType === \"u\" ? WebGPUConstants.TextureSampleType.Uint : componentType === \"i\" ? WebGPUConstants.TextureSampleType.Sint : WebGPUConstants.TextureSampleType.Float;\n        textureInfo.sampleType = sampleType;\n        const isTextureArray = arraySize > 0;\n        const samplerGroupIndex = samplerInfo.binding.groupIndex;\n        const samplerBindingIndex = samplerInfo.binding.bindingIndex;\n        const samplerFunction = WebGPUShaderProcessor._SamplerFunctionByWebGLSamplerType[uniformType];\n        const textureType = WebGPUShaderProcessor._TextureTypeByWebGLSamplerType[uniformType];\n        const textureDimension = WebGPUShaderProcessor._GpuTextureViewDimensionByWebGPUTextureType[textureType];\n        // Manage textures and samplers.\n        if (!isTextureArray) {\n          arraySize = 1;\n          uniform = `layout(set = ${samplerGroupIndex}, binding = ${samplerBindingIndex}) uniform ${samplerType} ${samplerName};\n                        layout(set = ${textureInfo.textures[0].groupIndex}, binding = ${textureInfo.textures[0].bindingIndex}) uniform ${componentType}${textureType} ${name}Texture;\n                        #define ${name} ${componentType}${samplerFunction}(${name}Texture, ${samplerName})`;\n        } else {\n          const layouts = [];\n          layouts.push(`layout(set = ${samplerGroupIndex}, binding = ${samplerBindingIndex}) uniform ${componentType}${samplerType} ${samplerName};`);\n          uniform = `\\n`;\n          for (let i = 0; i < arraySize; ++i) {\n            const textureSetIndex = textureInfo.textures[i].groupIndex;\n            const textureBindingIndex = textureInfo.textures[i].bindingIndex;\n            layouts.push(`layout(set = ${textureSetIndex}, binding = ${textureBindingIndex}) uniform ${textureType} ${name}Texture${i};`);\n            uniform += `${i > 0 ? \"\\n\" : \"\"}#define ${name}${i} ${componentType}${samplerFunction}(${name}Texture${i}, ${samplerName})`;\n          }\n          uniform = layouts.join(\"\\n\") + uniform;\n          this._textureArrayProcessing.push(name);\n        }\n        this._webgpuProcessingContext.availableTextures[name] = textureInfo;\n        this._webgpuProcessingContext.availableSamplers[samplerName] = samplerInfo;\n        this._addSamplerBindingDescription(samplerName, samplerInfo, !isFragment);\n        for (let i = 0; i < arraySize; ++i) {\n          this._addTextureBindingDescription(name, textureInfo, i, textureDimension, null, !isFragment);\n        }\n      } else {\n        this._addUniformToLeftOverUBO(name, uniformType, preProcessors);\n        uniform = \"\";\n      }\n    }\n    return uniform;\n  }\n  uniformBufferProcessor(uniformBuffer, isFragment) {\n    const uboRegex = /uniform\\s+(\\w+)/gm;\n    const match = uboRegex.exec(uniformBuffer);\n    if (match !== null) {\n      const name = match[1];\n      let uniformBufferInfo = this._webgpuProcessingContext.availableBuffers[name];\n      if (!uniformBufferInfo) {\n        const knownUBO = WebGPUShaderProcessingContext.KnownUBOs[name];\n        let binding;\n        if (knownUBO && knownUBO.binding.groupIndex !== -1) {\n          binding = knownUBO.binding;\n        } else {\n          binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\n        }\n        uniformBufferInfo = {\n          binding\n        };\n        this._webgpuProcessingContext.availableBuffers[name] = uniformBufferInfo;\n      }\n      this._addBufferBindingDescription(name, uniformBufferInfo, WebGPUConstants.BufferBindingType.Uniform, !isFragment);\n      uniformBuffer = uniformBuffer.replace(\"uniform\", `layout(set = ${uniformBufferInfo.binding.groupIndex}, binding = ${uniformBufferInfo.binding.bindingIndex}) uniform`);\n    }\n    return uniformBuffer;\n  }\n  postProcessor(code, defines, isFragment, processingContext, engine) {\n    const hasDrawBuffersExtension = code.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1;\n    // Remove extensions\n    const regex = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;\n    code = code.replace(regex, \"\");\n    // Replace instructions\n    code = code.replace(/texture2D\\s*\\(/g, \"texture(\");\n    if (isFragment) {\n      const hasFragCoord = code.indexOf(\"gl_FragCoord\") >= 0;\n      const fragCoordCode = `\n                glFragCoord_ = gl_FragCoord;\n                if (yFactor_ == 1.) {\n                    glFragCoord_.y = textureOutputHeight_ - glFragCoord_.y;\n                }\n            `;\n      const injectCode = hasFragCoord ? \"vec4 glFragCoord_;\\n\" : \"\";\n      const hasOutput = code.search(/layout *\\(location *= *0\\) *out/g) !== -1;\n      code = code.replace(/texture2DLodEXT\\s*\\(/g, \"textureLod(\");\n      code = code.replace(/textureCubeLodEXT\\s*\\(/g, \"textureLod(\");\n      code = code.replace(/textureCube\\s*\\(/g, \"texture(\");\n      code = code.replace(/gl_FragDepthEXT/g, \"gl_FragDepth\");\n      code = code.replace(/gl_FragColor/g, \"glFragColor\");\n      code = code.replace(/gl_FragData/g, \"glFragData\");\n      code = code.replace(/gl_FragCoord/g, \"glFragCoord_\");\n      if (!this._fragmentIsGLES3) {\n        code = code.replace(/void\\s+?main\\s*\\(/g, (hasDrawBuffersExtension || hasOutput ? \"\" : \"layout(location = 0) out vec4 glFragColor;\\n\") + \"void main(\");\n      } else {\n        const match = /^\\s*out\\s+\\S+\\s+\\S+\\s*;/gm.exec(code);\n        if (match !== null) {\n          code = code.substring(0, match.index) + \"layout(location = 0) \" + code.substring(match.index);\n        }\n      }\n      code = code.replace(/dFdy/g, \"(-yFactor_)*dFdy\"); // will also handle dFdyCoarse and dFdyFine\n      code = code.replace(\"##INJECTCODE##\", injectCode);\n      if (hasFragCoord) {\n        code = this._injectStartingAndEndingCode(code, \"void main\", fragCoordCode);\n      }\n    } else {\n      code = code.replace(/gl_InstanceID/g, \"gl_InstanceIndex\");\n      code = code.replace(/gl_VertexID/g, \"gl_VertexIndex\");\n      const hasMultiviewExtension = defines.indexOf(\"#define MULTIVIEW\") !== -1;\n      if (hasMultiviewExtension) {\n        return \"#extension GL_OVR_multiview2 : require\\nlayout (num_views = 2) in;\\n\" + code;\n      }\n    }\n    // Flip Y + convert z range from [-1,1] to [0,1]\n    if (!isFragment) {\n      const lastClosingCurly = code.lastIndexOf(\"}\");\n      code = code.substring(0, lastClosingCurly);\n      code += \"gl_Position.y *= yFactor_;\\n\";\n      if (!engine.isNDCHalfZRange) {\n        code += \"gl_Position.z = (gl_Position.z + gl_Position.w) / 2.0;\\n\";\n      }\n      code += \"}\";\n    }\n    return code;\n  }\n  _applyTextureArrayProcessing(code, name) {\n    // Replaces the occurrences of name[XX] by nameXX\n    const regex = new RegExp(name + \"\\\\s*\\\\[(.+)?\\\\]\", \"gm\");\n    let match = regex.exec(code);\n    while (match !== null) {\n      const index = match[1];\n      let iindex = +index;\n      if (this._preProcessors && isNaN(iindex)) {\n        iindex = +this._preProcessors[index.trim()];\n      }\n      code = code.replace(match[0], name + iindex);\n      match = regex.exec(code);\n    }\n    return code;\n  }\n  _generateLeftOverUBOCode(name, uniformBufferDescription) {\n    let ubo = `layout(set = ${uniformBufferDescription.binding.groupIndex}, binding = ${uniformBufferDescription.binding.bindingIndex}) uniform ${name} {\\n    `;\n    for (const leftOverUniform of this._webgpuProcessingContext.leftOverUniforms) {\n      if (leftOverUniform.length > 0) {\n        ubo += `    ${leftOverUniform.type} ${leftOverUniform.name}[${leftOverUniform.length}];\\n`;\n      } else {\n        ubo += `    ${leftOverUniform.type} ${leftOverUniform.name};\\n`;\n      }\n    }\n    ubo += \"};\\n\\n\";\n    return ubo;\n  }\n  finalizeShaders(vertexCode, fragmentCode) {\n    // make replacements for texture names in the texture array case\n    for (let i = 0; i < this._textureArrayProcessing.length; ++i) {\n      const name = this._textureArrayProcessing[i];\n      vertexCode = this._applyTextureArrayProcessing(vertexCode, name);\n      fragmentCode = this._applyTextureArrayProcessing(fragmentCode, name);\n    }\n    // inject the missing varying in the fragment shader\n    for (let i = 0; i < this._missingVaryings.length; ++i) {\n      const decl = this._missingVaryings[i];\n      if (decl && decl.length > 0) {\n        fragmentCode = decl + \"\\n\" + fragmentCode;\n      }\n    }\n    // Builds the leftover UBOs.\n    const leftOverUBO = this._buildLeftOverUBO();\n    vertexCode = leftOverUBO + vertexCode;\n    fragmentCode = leftOverUBO + fragmentCode;\n    this._collectBindingNames();\n    this._preCreateBindGroupEntries();\n    this._preProcessors = null;\n    this.vertexBufferKindToNumberOfComponents = {};\n    return {\n      vertexCode,\n      fragmentCode\n    };\n  }\n}","map":{"version":3,"names":["WebGPUShaderProcessingContext","WebGPUConstants","Logger","WebGPUShaderProcessor","ShaderLanguage","WebGPUShaderProcessorGLSL","constructor","_missingVaryings","_textureArrayProcessing","_vertexIsGLES3","_fragmentIsGLES3","shaderLanguage","GLSL","parseGLES3","_getArraySize","name","type","preProcessors","length","startArray","indexOf","endArray","lengthInString","substring","isNaN","trim","substr","initializeShaders","processingContext","_webgpuProcessingContext","attributeKeywordName","undefined","varyingVertexKeywordName","varyingFragmentKeywordName","preProcessShaderCode","code","isFragment","ubDeclaration","InternalsUBOName","alreadyInjected","varyingCheck","varying","outRegex","inRegex","varyingRegex","regex","test","varyingProcessor","_preProcessors","match","exec","interpolationQualifier","_a","varyingType","location","availableVaryings","Warn","getVaryingNextLocation","replace","attributeProcessor","attribute","attribRegex","attributeType","getAttributeNextLocation","availableAttributes","orderedAttributes","numComponents","vertexBufferKindToNumberOfComponents","newType","newName","uniformProcessor","uniform","uniformRegex","uniformType","arraySize","textureInfo","availableTextures","autoBindSampler","isTextureArray","isStorageTexture","textures","sampleType","TextureSampleType","Float","i","push","getNextFreeUBOBinding","samplerType","_SamplerTypeByWebGLSamplerType","isComparisonSampler","_IsComparisonSamplerByWebGPUSamplerType","samplerBindingType","SamplerBindingType","Comparison","Filtering","samplerName","AutoSamplerSuffix","samplerInfo","availableSamplers","binding","componentType","charAt","Depth","Uint","Sint","samplerGroupIndex","groupIndex","samplerBindingIndex","bindingIndex","samplerFunction","_SamplerFunctionByWebGLSamplerType","textureType","_TextureTypeByWebGLSamplerType","textureDimension","_GpuTextureViewDimensionByWebGPUTextureType","layouts","textureSetIndex","textureBindingIndex","join","_addSamplerBindingDescription","_addTextureBindingDescription","_addUniformToLeftOverUBO","uniformBufferProcessor","uniformBuffer","uboRegex","uniformBufferInfo","availableBuffers","knownUBO","KnownUBOs","_addBufferBindingDescription","BufferBindingType","Uniform","postProcessor","defines","engine","hasDrawBuffersExtension","search","hasFragCoord","fragCoordCode","injectCode","hasOutput","index","_injectStartingAndEndingCode","hasMultiviewExtension","lastClosingCurly","lastIndexOf","isNDCHalfZRange","_applyTextureArrayProcessing","RegExp","iindex","_generateLeftOverUBOCode","uniformBufferDescription","ubo","leftOverUniform","leftOverUniforms","finalizeShaders","vertexCode","fragmentCode","decl","leftOverUBO","_buildLeftOverUBO","_collectBindingNames","_preCreateBindGroupEntries"],"sources":["../../../../../dev/core/src/Engines/WebGPU/webgpuShaderProcessorsGLSL.ts"],"sourcesContent":["/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ShaderProcessingContext } from \"../Processors/shaderProcessingOptions\";\r\nimport type { WebGPUBufferDescription } from \"./webgpuShaderProcessingContext\";\r\nimport { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { ThinEngine } from \"../thinEngine\";\r\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor\";\r\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\n\r\n/** @internal */\r\nexport class WebGPUShaderProcessorGLSL extends WebGPUShaderProcessor {\r\n    protected _missingVaryings: Array<string> = [];\r\n    protected _textureArrayProcessing: Array<string> = [];\r\n    protected _preProcessors: { [key: string]: string };\r\n    protected _vertexIsGLES3: boolean = false;\r\n    protected _fragmentIsGLES3: boolean = false;\r\n\r\n    public shaderLanguage = ShaderLanguage.GLSL;\r\n    public parseGLES3 = true;\r\n    public attributeKeywordName: string | undefined;\r\n    public varyingVertexKeywordName: string | undefined;\r\n    public varyingFragmentKeywordName: string | undefined;\r\n\r\n    protected _getArraySize(name: string, type: string, preProcessors: { [key: string]: string }): [string, string, number] {\r\n        let length = 0;\r\n        const startArray = name.indexOf(\"[\");\r\n        const endArray = name.indexOf(\"]\");\r\n        if (startArray > 0 && endArray > 0) {\r\n            const lengthInString = name.substring(startArray + 1, endArray);\r\n            length = +lengthInString;\r\n            if (isNaN(length)) {\r\n                length = +preProcessors[lengthInString.trim()];\r\n            }\r\n            name = name.substr(0, startArray);\r\n        }\r\n        return [name, type, length];\r\n    }\r\n\r\n    public initializeShaders(processingContext: Nullable<ShaderProcessingContext>): void {\r\n        this._webgpuProcessingContext = processingContext as WebGPUShaderProcessingContext;\r\n\r\n        this._missingVaryings.length = 0;\r\n        this._textureArrayProcessing.length = 0;\r\n        this.attributeKeywordName = undefined;\r\n        this.varyingVertexKeywordName = undefined;\r\n        this.varyingFragmentKeywordName = undefined;\r\n    }\r\n\r\n    public preProcessShaderCode(code: string, isFragment: boolean): string {\r\n        const ubDeclaration = `// Internals UBO\\nuniform ${WebGPUShaderProcessor.InternalsUBOName} {\\nfloat yFactor_;\\nfloat textureOutputHeight_;\\n};\\n`;\r\n        const alreadyInjected = code.indexOf(\"// Internals UBO\") !== -1;\r\n\r\n        if (isFragment) {\r\n            this._fragmentIsGLES3 = code.indexOf(\"#version 3\") !== -1;\r\n            if (this._fragmentIsGLES3) {\r\n                this.varyingFragmentKeywordName = \"in\";\r\n            }\r\n            return alreadyInjected ? code : ubDeclaration + \"##INJECTCODE##\\n\" + code;\r\n        }\r\n\r\n        this._vertexIsGLES3 = code.indexOf(\"#version 3\") !== -1;\r\n        if (this._vertexIsGLES3) {\r\n            this.attributeKeywordName = \"in\";\r\n            this.varyingVertexKeywordName = \"out\";\r\n        }\r\n        return alreadyInjected ? code : ubDeclaration + code;\r\n    }\r\n\r\n    public varyingCheck(varying: string, isFragment: boolean) {\r\n        const outRegex = /(flat\\s)?\\s*\\bout\\b/;\r\n        const inRegex = /(flat\\s)?\\s*\\bin\\b/;\r\n        const varyingRegex = /(flat\\s)?\\s*\\bvarying\\b/;\r\n\r\n        const regex = isFragment && this._fragmentIsGLES3 ? inRegex : !isFragment && this._vertexIsGLES3 ? outRegex : varyingRegex;\r\n\r\n        return regex.test(varying);\r\n    }\r\n\r\n    public varyingProcessor(varying: string, isFragment: boolean, preProcessors: { [key: string]: string }) {\r\n        this._preProcessors = preProcessors;\r\n\r\n        const outRegex = /\\s*(flat)?\\s*out\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\r\n        const inRegex = /\\s*(flat)?\\s*in\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\r\n        const varyingRegex = /\\s*(flat)?\\s*varying\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\r\n\r\n        const regex = isFragment && this._fragmentIsGLES3 ? inRegex : !isFragment && this._vertexIsGLES3 ? outRegex : varyingRegex;\r\n        const match = regex.exec(varying);\r\n        if (match !== null) {\r\n            const interpolationQualifier = match[1] ?? \"\";\r\n            const varyingType = match[2];\r\n            const name = match[3];\r\n            let location: number;\r\n            if (isFragment) {\r\n                location = this._webgpuProcessingContext.availableVaryings[name];\r\n                this._missingVaryings[location] = \"\";\r\n                if (location === undefined) {\r\n                    Logger.Warn(`Invalid fragment shader: The varying named \"${name}\" is not declared in the vertex shader! This declaration will be ignored.`);\r\n                }\r\n            } else {\r\n                location = this._webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name, varyingType, preProcessors)[2]);\r\n                this._webgpuProcessingContext.availableVaryings[name] = location;\r\n                this._missingVaryings[location] = `layout(location = ${location}) ${interpolationQualifier} in ${varyingType} ${name};`;\r\n            }\r\n\r\n            varying = varying.replace(\r\n                match[0],\r\n                location === undefined ? \"\" : `layout(location = ${location}) ${interpolationQualifier} ${isFragment ? \"in\" : \"out\"} ${varyingType} ${name};`\r\n            );\r\n        }\r\n        return varying;\r\n    }\r\n\r\n    public attributeProcessor(attribute: string, preProcessors: { [key: string]: string }) {\r\n        this._preProcessors = preProcessors;\r\n\r\n        const inRegex = /\\s*in\\s+(\\S+)\\s+(\\S+)\\s*;/gm;\r\n        const attribRegex = /\\s*attribute\\s+(\\S+)\\s+(\\S+)\\s*;/gm;\r\n\r\n        const regex = this._vertexIsGLES3 ? inRegex : attribRegex;\r\n        const match = regex.exec(attribute);\r\n        if (match !== null) {\r\n            const attributeType = match[1];\r\n            const name = match[2];\r\n            const location = this._webgpuProcessingContext.getAttributeNextLocation(attributeType, this._getArraySize(name, attributeType, preProcessors)[2]);\r\n\r\n            this._webgpuProcessingContext.availableAttributes[name] = location;\r\n            this._webgpuProcessingContext.orderedAttributes[location] = name;\r\n\r\n            const numComponents = this.vertexBufferKindToNumberOfComponents[name];\r\n            if (numComponents !== undefined) {\r\n                // Special case for an int/ivecX vertex buffer that is used as a float/vecX attribute in the shader.\r\n                const newType = numComponents < 0 ? (numComponents === -1 ? \"int\" : \"ivec\" + -numComponents) : numComponents === 1 ? \"uint\" : \"uvec\" + numComponents;\r\n                const newName = `_int_${name}_`;\r\n\r\n                attribute = attribute.replace(match[0], `layout(location = ${location}) in ${newType} ${newName}; ${attributeType} ${name} = ${attributeType}(${newName});`);\r\n            } else {\r\n                attribute = attribute.replace(match[0], `layout(location = ${location}) in ${attributeType} ${name};`);\r\n            }\r\n        }\r\n        return attribute;\r\n    }\r\n\r\n    public uniformProcessor(uniform: string, isFragment: boolean, preProcessors: { [key: string]: string }): string {\r\n        this._preProcessors = preProcessors;\r\n\r\n        const uniformRegex = /\\s*uniform\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\r\n\r\n        const match = uniformRegex.exec(uniform);\r\n        if (match !== null) {\r\n            let uniformType = match[1];\r\n            let name = match[2];\r\n\r\n            if (uniformType.indexOf(\"sampler\") === 0 || uniformType.indexOf(\"sampler\") === 1) {\r\n                let arraySize = 0; // 0 means the texture is not declared as an array\r\n\r\n                [name, uniformType, arraySize] = this._getArraySize(name, uniformType, preProcessors);\r\n\r\n                let textureInfo = this._webgpuProcessingContext.availableTextures[name];\r\n                if (!textureInfo) {\r\n                    textureInfo = {\r\n                        autoBindSampler: true,\r\n                        isTextureArray: arraySize > 0,\r\n                        isStorageTexture: false,\r\n                        textures: [],\r\n                        sampleType: WebGPUConstants.TextureSampleType.Float,\r\n                    };\r\n                    for (let i = 0; i < (arraySize || 1); ++i) {\r\n                        textureInfo.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding());\r\n                    }\r\n                }\r\n\r\n                const samplerType = WebGPUShaderProcessor._SamplerTypeByWebGLSamplerType[uniformType] ?? \"sampler\";\r\n                const isComparisonSampler = !!WebGPUShaderProcessor._IsComparisonSamplerByWebGPUSamplerType[samplerType];\r\n                const samplerBindingType = isComparisonSampler ? WebGPUConstants.SamplerBindingType.Comparison : WebGPUConstants.SamplerBindingType.Filtering;\r\n                const samplerName = name + WebGPUShaderProcessor.AutoSamplerSuffix;\r\n\r\n                let samplerInfo = this._webgpuProcessingContext.availableSamplers[samplerName];\r\n                if (!samplerInfo) {\r\n                    samplerInfo = {\r\n                        binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),\r\n                        type: samplerBindingType,\r\n                    };\r\n                }\r\n\r\n                const componentType = uniformType.charAt(0) === \"u\" ? \"u\" : uniformType.charAt(0) === \"i\" ? \"i\" : \"\";\r\n\r\n                if (componentType) {\r\n                    uniformType = uniformType.substr(1);\r\n                }\r\n\r\n                const sampleType = isComparisonSampler\r\n                    ? WebGPUConstants.TextureSampleType.Depth\r\n                    : componentType === \"u\"\r\n                    ? WebGPUConstants.TextureSampleType.Uint\r\n                    : componentType === \"i\"\r\n                    ? WebGPUConstants.TextureSampleType.Sint\r\n                    : WebGPUConstants.TextureSampleType.Float;\r\n\r\n                textureInfo.sampleType = sampleType;\r\n\r\n                const isTextureArray = arraySize > 0;\r\n                const samplerGroupIndex = samplerInfo.binding.groupIndex;\r\n                const samplerBindingIndex = samplerInfo.binding.bindingIndex;\r\n                const samplerFunction = WebGPUShaderProcessor._SamplerFunctionByWebGLSamplerType[uniformType];\r\n                const textureType = WebGPUShaderProcessor._TextureTypeByWebGLSamplerType[uniformType];\r\n                const textureDimension = WebGPUShaderProcessor._GpuTextureViewDimensionByWebGPUTextureType[textureType];\r\n\r\n                // Manage textures and samplers.\r\n                if (!isTextureArray) {\r\n                    arraySize = 1;\r\n                    uniform = `layout(set = ${samplerGroupIndex}, binding = ${samplerBindingIndex}) uniform ${samplerType} ${samplerName};\r\n                        layout(set = ${textureInfo.textures[0].groupIndex}, binding = ${textureInfo.textures[0].bindingIndex}) uniform ${componentType}${textureType} ${name}Texture;\r\n                        #define ${name} ${componentType}${samplerFunction}(${name}Texture, ${samplerName})`;\r\n                } else {\r\n                    const layouts = [];\r\n                    layouts.push(`layout(set = ${samplerGroupIndex}, binding = ${samplerBindingIndex}) uniform ${componentType}${samplerType} ${samplerName};`);\r\n                    uniform = `\\n`;\r\n                    for (let i = 0; i < arraySize; ++i) {\r\n                        const textureSetIndex = textureInfo.textures[i].groupIndex;\r\n                        const textureBindingIndex = textureInfo.textures[i].bindingIndex;\r\n\r\n                        layouts.push(`layout(set = ${textureSetIndex}, binding = ${textureBindingIndex}) uniform ${textureType} ${name}Texture${i};`);\r\n\r\n                        uniform += `${i > 0 ? \"\\n\" : \"\"}#define ${name}${i} ${componentType}${samplerFunction}(${name}Texture${i}, ${samplerName})`;\r\n                    }\r\n                    uniform = layouts.join(\"\\n\") + uniform;\r\n                    this._textureArrayProcessing.push(name);\r\n                }\r\n\r\n                this._webgpuProcessingContext.availableTextures[name] = textureInfo;\r\n                this._webgpuProcessingContext.availableSamplers[samplerName] = samplerInfo;\r\n\r\n                this._addSamplerBindingDescription(samplerName, samplerInfo, !isFragment);\r\n\r\n                for (let i = 0; i < arraySize; ++i) {\r\n                    this._addTextureBindingDescription(name, textureInfo, i, textureDimension, null, !isFragment);\r\n                }\r\n            } else {\r\n                this._addUniformToLeftOverUBO(name, uniformType, preProcessors);\r\n                uniform = \"\";\r\n            }\r\n        }\r\n        return uniform;\r\n    }\r\n\r\n    public uniformBufferProcessor(uniformBuffer: string, isFragment: boolean): string {\r\n        const uboRegex = /uniform\\s+(\\w+)/gm;\r\n\r\n        const match = uboRegex.exec(uniformBuffer);\r\n        if (match !== null) {\r\n            const name = match[1];\r\n\r\n            let uniformBufferInfo = this._webgpuProcessingContext.availableBuffers[name];\r\n            if (!uniformBufferInfo) {\r\n                const knownUBO = WebGPUShaderProcessingContext.KnownUBOs[name];\r\n\r\n                let binding;\r\n                if (knownUBO && knownUBO.binding.groupIndex !== -1) {\r\n                    binding = knownUBO.binding;\r\n                } else {\r\n                    binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\r\n                }\r\n\r\n                uniformBufferInfo = { binding };\r\n                this._webgpuProcessingContext.availableBuffers[name] = uniformBufferInfo;\r\n            }\r\n\r\n            this._addBufferBindingDescription(name, uniformBufferInfo, WebGPUConstants.BufferBindingType.Uniform, !isFragment);\r\n\r\n            uniformBuffer = uniformBuffer.replace(\"uniform\", `layout(set = ${uniformBufferInfo.binding.groupIndex}, binding = ${uniformBufferInfo.binding.bindingIndex}) uniform`);\r\n        }\r\n        return uniformBuffer;\r\n    }\r\n\r\n    public postProcessor(code: string, defines: string[], isFragment: boolean, processingContext: Nullable<ShaderProcessingContext>, engine: ThinEngine) {\r\n        const hasDrawBuffersExtension = code.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1;\r\n\r\n        // Remove extensions\r\n        const regex = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;\r\n        code = code.replace(regex, \"\");\r\n\r\n        // Replace instructions\r\n        code = code.replace(/texture2D\\s*\\(/g, \"texture(\");\r\n        if (isFragment) {\r\n            const hasFragCoord = code.indexOf(\"gl_FragCoord\") >= 0;\r\n            const fragCoordCode = `\r\n                glFragCoord_ = gl_FragCoord;\r\n                if (yFactor_ == 1.) {\r\n                    glFragCoord_.y = textureOutputHeight_ - glFragCoord_.y;\r\n                }\r\n            `;\r\n\r\n            const injectCode = hasFragCoord ? \"vec4 glFragCoord_;\\n\" : \"\";\r\n            const hasOutput = code.search(/layout *\\(location *= *0\\) *out/g) !== -1;\r\n\r\n            code = code.replace(/texture2DLodEXT\\s*\\(/g, \"textureLod(\");\r\n            code = code.replace(/textureCubeLodEXT\\s*\\(/g, \"textureLod(\");\r\n            code = code.replace(/textureCube\\s*\\(/g, \"texture(\");\r\n            code = code.replace(/gl_FragDepthEXT/g, \"gl_FragDepth\");\r\n            code = code.replace(/gl_FragColor/g, \"glFragColor\");\r\n            code = code.replace(/gl_FragData/g, \"glFragData\");\r\n            code = code.replace(/gl_FragCoord/g, \"glFragCoord_\");\r\n            if (!this._fragmentIsGLES3) {\r\n                code = code.replace(/void\\s+?main\\s*\\(/g, (hasDrawBuffersExtension || hasOutput ? \"\" : \"layout(location = 0) out vec4 glFragColor;\\n\") + \"void main(\");\r\n            } else {\r\n                const match = /^\\s*out\\s+\\S+\\s+\\S+\\s*;/gm.exec(code);\r\n                if (match !== null) {\r\n                    code = code.substring(0, match.index) + \"layout(location = 0) \" + code.substring(match.index);\r\n                }\r\n            }\r\n            code = code.replace(/dFdy/g, \"(-yFactor_)*dFdy\"); // will also handle dFdyCoarse and dFdyFine\r\n            code = code.replace(\"##INJECTCODE##\", injectCode);\r\n\r\n            if (hasFragCoord) {\r\n                code = this._injectStartingAndEndingCode(code, \"void main\", fragCoordCode);\r\n            }\r\n        } else {\r\n            code = code.replace(/gl_InstanceID/g, \"gl_InstanceIndex\");\r\n            code = code.replace(/gl_VertexID/g, \"gl_VertexIndex\");\r\n            const hasMultiviewExtension = defines.indexOf(\"#define MULTIVIEW\") !== -1;\r\n            if (hasMultiviewExtension) {\r\n                return \"#extension GL_OVR_multiview2 : require\\nlayout (num_views = 2) in;\\n\" + code;\r\n            }\r\n        }\r\n\r\n        // Flip Y + convert z range from [-1,1] to [0,1]\r\n        if (!isFragment) {\r\n            const lastClosingCurly = code.lastIndexOf(\"}\");\r\n            code = code.substring(0, lastClosingCurly);\r\n            code += \"gl_Position.y *= yFactor_;\\n\";\r\n            if (!engine.isNDCHalfZRange) {\r\n                code += \"gl_Position.z = (gl_Position.z + gl_Position.w) / 2.0;\\n\";\r\n            }\r\n            code += \"}\";\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    private _applyTextureArrayProcessing(code: string, name: string): string {\r\n        // Replaces the occurrences of name[XX] by nameXX\r\n        const regex = new RegExp(name + \"\\\\s*\\\\[(.+)?\\\\]\", \"gm\");\r\n        let match = regex.exec(code);\r\n\r\n        while (match !== null) {\r\n            const index = match[1];\r\n            let iindex = +index;\r\n            if (this._preProcessors && isNaN(iindex)) {\r\n                iindex = +this._preProcessors[index.trim()];\r\n            }\r\n            code = code.replace(match[0], name + iindex);\r\n            match = regex.exec(code);\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _generateLeftOverUBOCode(name: string, uniformBufferDescription: WebGPUBufferDescription): string {\r\n        let ubo = `layout(set = ${uniformBufferDescription.binding.groupIndex}, binding = ${uniformBufferDescription.binding.bindingIndex}) uniform ${name} {\\n    `;\r\n        for (const leftOverUniform of this._webgpuProcessingContext.leftOverUniforms) {\r\n            if (leftOverUniform.length > 0) {\r\n                ubo += `    ${leftOverUniform.type} ${leftOverUniform.name}[${leftOverUniform.length}];\\n`;\r\n            } else {\r\n                ubo += `    ${leftOverUniform.type} ${leftOverUniform.name};\\n`;\r\n            }\r\n        }\r\n        ubo += \"};\\n\\n\";\r\n\r\n        return ubo;\r\n    }\r\n\r\n    public finalizeShaders(vertexCode: string, fragmentCode: string): { vertexCode: string; fragmentCode: string } {\r\n        // make replacements for texture names in the texture array case\r\n        for (let i = 0; i < this._textureArrayProcessing.length; ++i) {\r\n            const name = this._textureArrayProcessing[i];\r\n            vertexCode = this._applyTextureArrayProcessing(vertexCode, name);\r\n            fragmentCode = this._applyTextureArrayProcessing(fragmentCode, name);\r\n        }\r\n\r\n        // inject the missing varying in the fragment shader\r\n        for (let i = 0; i < this._missingVaryings.length; ++i) {\r\n            const decl = this._missingVaryings[i];\r\n            if (decl && decl.length > 0) {\r\n                fragmentCode = decl + \"\\n\" + fragmentCode;\r\n            }\r\n        }\r\n\r\n        // Builds the leftover UBOs.\r\n        const leftOverUBO = this._buildLeftOverUBO();\r\n\r\n        vertexCode = leftOverUBO + vertexCode;\r\n        fragmentCode = leftOverUBO + fragmentCode;\r\n\r\n        this._collectBindingNames();\r\n        this._preCreateBindGroupEntries();\r\n\r\n        this._preProcessors = null as any;\r\n        this.vertexBufferKindToNumberOfComponents = {};\r\n\r\n        return { vertexCode, fragmentCode };\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}