{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { ThinEngine } from \"../thinEngine.js\";\nThinEngine.prototype.restoreSingleAttachment = function () {\n  const gl = this._gl;\n  this.bindAttachments([gl.BACK]);\n};\nThinEngine.prototype.restoreSingleAttachmentForRenderTarget = function () {\n  const gl = this._gl;\n  this.bindAttachments([gl.COLOR_ATTACHMENT0]);\n};\nThinEngine.prototype.buildTextureLayout = function (textureStatus) {\n  const gl = this._gl;\n  const result = [];\n  for (let i = 0; i < textureStatus.length; i++) {\n    if (textureStatus[i]) {\n      result.push(gl[\"COLOR_ATTACHMENT\" + i]);\n    } else {\n      result.push(gl.NONE);\n    }\n  }\n  return result;\n};\nThinEngine.prototype.bindAttachments = function (attachments) {\n  const gl = this._gl;\n  gl.drawBuffers(attachments);\n};\nThinEngine.prototype.unBindMultiColorAttachmentFramebuffer = function (rtWrapper, disableGenerateMipMaps = false, onBeforeUnbind) {\n  this._currentRenderTarget = null;\n  // If MSAA, we need to bitblt back to main texture\n  const gl = this._gl;\n  const attachments = rtWrapper._attachments;\n  const count = attachments.length;\n  if (rtWrapper._MSAAFramebuffer) {\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, rtWrapper._MSAAFramebuffer);\n    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, rtWrapper._framebuffer);\n    for (let i = 0; i < count; i++) {\n      const texture = rtWrapper.textures[i];\n      for (let j = 0; j < count; j++) {\n        attachments[j] = gl.NONE;\n      }\n      attachments[i] = gl[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\n      gl.readBuffer(attachments[i]);\n      gl.drawBuffers(attachments);\n      gl.blitFramebuffer(0, 0, texture.width, texture.height, 0, 0, texture.width, texture.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);\n    }\n    for (let i = 0; i < count; i++) {\n      attachments[i] = gl[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\n    }\n    gl.drawBuffers(attachments);\n  }\n  for (let i = 0; i < count; i++) {\n    const texture = rtWrapper.textures[i];\n    if ((texture === null || texture === void 0 ? void 0 : texture.generateMipMaps) && !disableGenerateMipMaps && !texture.isCube) {\n      this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);\n      gl.generateMipmap(gl.TEXTURE_2D);\n      this._bindTextureDirectly(gl.TEXTURE_2D, null);\n    }\n  }\n  if (onBeforeUnbind) {\n    if (rtWrapper._MSAAFramebuffer) {\n      // Bind the correct framebuffer\n      this._bindUnboundFramebuffer(rtWrapper._framebuffer);\n    }\n    onBeforeUnbind();\n  }\n  this._bindUnboundFramebuffer(null);\n};\nThinEngine.prototype.createMultipleRenderTarget = function (size, options, initializeBuffers = true) {\n  var _a;\n  let generateMipMaps = false;\n  let generateDepthBuffer = true;\n  let generateStencilBuffer = false;\n  let generateDepthTexture = false;\n  let depthTextureFormat = 15;\n  let textureCount = 1;\n  const defaultType = 0;\n  const defaultSamplingMode = 3;\n  const defaultUseSRGBBuffer = false;\n  const defaultFormat = 5;\n  const defaultTarget = 3553;\n  let types = new Array();\n  let samplingModes = new Array();\n  let useSRGBBuffers = new Array();\n  let formats = new Array();\n  let targets = new Array();\n  let faceIndex = new Array();\n  let layerIndex = new Array();\n  let layers = new Array();\n  const rtWrapper = this._createHardwareRenderTargetWrapper(true, false, size);\n  if (options !== undefined) {\n    generateMipMaps = options.generateMipMaps === undefined ? false : options.generateMipMaps;\n    generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n    generateStencilBuffer = options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\n    generateDepthTexture = options.generateDepthTexture === undefined ? false : options.generateDepthTexture;\n    textureCount = options.textureCount || 1;\n    if (options.types) {\n      types = options.types;\n    }\n    if (options.samplingModes) {\n      samplingModes = options.samplingModes;\n    }\n    if (options.useSRGBBuffers) {\n      useSRGBBuffers = options.useSRGBBuffers;\n    }\n    if (options.formats) {\n      formats = options.formats;\n    }\n    if (options.targetTypes) {\n      targets = options.targetTypes;\n    }\n    if (options.faceIndex) {\n      faceIndex = options.faceIndex;\n    }\n    if (options.layerIndex) {\n      layerIndex = options.layerIndex;\n    }\n    if (options.layerCounts) {\n      layers = options.layerCounts;\n    }\n    if (this.webGLVersion > 1 && (options.depthTextureFormat === 13 || options.depthTextureFormat === 17 || options.depthTextureFormat === 16 || options.depthTextureFormat === 14 || options.depthTextureFormat === 18)) {\n      depthTextureFormat = options.depthTextureFormat;\n    }\n  }\n  const gl = this._gl;\n  // Create the framebuffer\n  const framebuffer = gl.createFramebuffer();\n  this._bindUnboundFramebuffer(framebuffer);\n  const width = size.width || size;\n  const height = size.height || size;\n  const textures = [];\n  const attachments = [];\n  const useStencilTexture = this.webGLVersion > 1 && generateDepthTexture && (options.depthTextureFormat === 13 || options.depthTextureFormat === 17 || options.depthTextureFormat === 18);\n  const depthStencilBuffer = this._setupFramebufferDepthAttachments(!useStencilTexture && generateStencilBuffer, !generateDepthTexture && generateDepthBuffer, width, height);\n  rtWrapper._framebuffer = framebuffer;\n  rtWrapper._depthStencilBuffer = depthStencilBuffer;\n  rtWrapper._generateDepthBuffer = !generateDepthTexture && generateDepthBuffer;\n  rtWrapper._generateStencilBuffer = !useStencilTexture && generateStencilBuffer;\n  rtWrapper._attachments = attachments;\n  for (let i = 0; i < textureCount; i++) {\n    let samplingMode = samplingModes[i] || defaultSamplingMode;\n    let type = types[i] || defaultType;\n    let useSRGBBuffer = useSRGBBuffers[i] || defaultUseSRGBBuffer;\n    const format = formats[i] || defaultFormat;\n    const target = targets[i] || defaultTarget;\n    const layerCount = (_a = layers[i]) !== null && _a !== void 0 ? _a : 1;\n    if (type === 1 && !this._caps.textureFloatLinearFiltering) {\n      // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\n      samplingMode = 1;\n    } else if (type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\n      // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\n      samplingMode = 1;\n    }\n    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\n    if (type === 1 && !this._caps.textureFloat) {\n      type = 0;\n      Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\n    }\n    useSRGBBuffer = useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU);\n    const isWebGL2 = this.webGLVersion > 1;\n    const attachment = gl[isWebGL2 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\n    attachments.push(attachment);\n    if (target === -1) {\n      continue;\n    }\n    const texture = new InternalTexture(this, InternalTextureSource.MultiRenderTarget);\n    textures[i] = texture;\n    gl.activeTexture(gl[\"TEXTURE\" + i]);\n    gl.bindTexture(target, texture._hardwareTexture.underlyingResource);\n    gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, filters.mag);\n    gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, filters.min);\n    gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    const internalSizedFormat = this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);\n    const internalFormat = this._getInternalFormat(format);\n    const webGLTextureType = this._getWebGLTextureType(type);\n    if (isWebGL2 && (target === 35866 || target === 32879)) {\n      if (target === 35866) {\n        texture.is2DArray = true;\n      } else {\n        texture.is3D = true;\n      }\n      texture.baseDepth = texture.depth = layerCount;\n      gl.texImage3D(target, 0, internalSizedFormat, width, height, layerCount, 0, internalFormat, webGLTextureType, null);\n    } else if (target === 34067) {\n      // We have to generate all faces to complete the framebuffer\n      for (let i = 0; i < 6; i++) {\n        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, internalSizedFormat, width, height, 0, internalFormat, webGLTextureType, null);\n      }\n      texture.isCube = true;\n    } else {\n      gl.texImage2D(gl.TEXTURE_2D, 0, internalSizedFormat, width, height, 0, internalFormat, webGLTextureType, null);\n    }\n    if (generateMipMaps) {\n      gl.generateMipmap(target);\n    }\n    // Unbind\n    this._bindTextureDirectly(target, null);\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = width;\n    texture.height = height;\n    texture.isReady = true;\n    texture.samples = 1;\n    texture.generateMipMaps = generateMipMaps;\n    texture.samplingMode = samplingMode;\n    texture.type = type;\n    texture._useSRGBBuffer = useSRGBBuffer;\n    texture.format = format;\n    this._internalTexturesCache.push(texture);\n  }\n  if (generateDepthTexture && this._caps.depthTextureExtension) {\n    // Depth texture\n    const depthTexture = new InternalTexture(this, InternalTextureSource.Depth);\n    let depthTextureType = 5;\n    let glDepthTextureInternalFormat = gl.DEPTH_COMPONENT16;\n    let glDepthTextureFormat = gl.DEPTH_COMPONENT;\n    let glDepthTextureType = gl.UNSIGNED_SHORT;\n    let glDepthTextureAttachment = gl.DEPTH_ATTACHMENT;\n    if (this.webGLVersion < 2) {\n      glDepthTextureInternalFormat = gl.DEPTH_COMPONENT;\n    } else {\n      if (depthTextureFormat === 14) {\n        depthTextureType = 1;\n        glDepthTextureType = gl.FLOAT;\n        glDepthTextureInternalFormat = gl.DEPTH_COMPONENT32F;\n      } else if (depthTextureFormat === 18) {\n        depthTextureType = 0;\n        glDepthTextureType = gl.FLOAT_32_UNSIGNED_INT_24_8_REV;\n        glDepthTextureInternalFormat = gl.DEPTH32F_STENCIL8;\n        glDepthTextureFormat = gl.DEPTH_STENCIL;\n        glDepthTextureAttachment = gl.DEPTH_STENCIL_ATTACHMENT;\n      } else if (depthTextureFormat === 16) {\n        depthTextureType = 0;\n        glDepthTextureType = gl.UNSIGNED_INT;\n        glDepthTextureInternalFormat = gl.DEPTH_COMPONENT24;\n        glDepthTextureAttachment = gl.DEPTH_ATTACHMENT;\n      } else if (depthTextureFormat === 13 || depthTextureFormat === 17) {\n        depthTextureType = 12;\n        glDepthTextureType = gl.UNSIGNED_INT_24_8;\n        glDepthTextureInternalFormat = gl.DEPTH24_STENCIL8;\n        glDepthTextureFormat = gl.DEPTH_STENCIL;\n        glDepthTextureAttachment = gl.DEPTH_STENCIL_ATTACHMENT;\n      }\n    }\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, depthTexture._hardwareTexture.underlyingResource);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, glDepthTextureInternalFormat, width, height, 0, glDepthTextureFormat, glDepthTextureType, null);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, glDepthTextureAttachment, gl.TEXTURE_2D, depthTexture._hardwareTexture.underlyingResource, 0);\n    depthTexture.baseWidth = width;\n    depthTexture.baseHeight = height;\n    depthTexture.width = width;\n    depthTexture.height = height;\n    depthTexture.isReady = true;\n    depthTexture.samples = 1;\n    depthTexture.generateMipMaps = generateMipMaps;\n    depthTexture.samplingMode = 1;\n    depthTexture.format = depthTextureFormat;\n    depthTexture.type = depthTextureType;\n    textures[textureCount] = depthTexture;\n    this._internalTexturesCache.push(depthTexture);\n  }\n  rtWrapper.setTextures(textures);\n  if (initializeBuffers) {\n    gl.drawBuffers(attachments);\n  }\n  this._bindUnboundFramebuffer(null);\n  rtWrapper.setLayerAndFaceIndices(layerIndex, faceIndex);\n  this.resetTextureCache();\n  return rtWrapper;\n};\nThinEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function (rtWrapper, samples, initializeBuffers = true) {\n  if (this.webGLVersion < 2 || !rtWrapper || !rtWrapper.texture) {\n    return 1;\n  }\n  if (rtWrapper.samples === samples) {\n    return samples;\n  }\n  const count = rtWrapper._attachments.length;\n  if (count === 0) {\n    return 1;\n  }\n  const gl = this._gl;\n  samples = Math.min(samples, this.getCaps().maxMSAASamples);\n  // Dispose previous render buffers\n  const useDepthStencil = !!rtWrapper._depthStencilBuffer;\n  if (useDepthStencil) {\n    gl.deleteRenderbuffer(rtWrapper._depthStencilBuffer);\n    rtWrapper._depthStencilBuffer = null;\n  }\n  if (rtWrapper._MSAAFramebuffer) {\n    gl.deleteFramebuffer(rtWrapper._MSAAFramebuffer);\n    rtWrapper._MSAAFramebuffer = null;\n  }\n  if (samples > 1 && typeof gl.renderbufferStorageMultisample === \"function\") {\n    const framebuffer = gl.createFramebuffer();\n    if (!framebuffer) {\n      throw new Error(\"Unable to create multi sampled framebuffer\");\n    }\n    rtWrapper._MSAAFramebuffer = framebuffer;\n    this._bindUnboundFramebuffer(framebuffer);\n    const attachments = [];\n    for (let i = 0; i < count; i++) {\n      const texture = rtWrapper.textures[i];\n      const hardwareTexture = texture._hardwareTexture;\n      hardwareTexture.releaseMSAARenderBuffers();\n    }\n    for (let i = 0; i < count; i++) {\n      const texture = rtWrapper.textures[i];\n      const hardwareTexture = texture._hardwareTexture;\n      const attachment = gl[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\n      const colorRenderbuffer = this._createRenderBuffer(texture.width, texture.height, samples, -1 /* not used */, this._getRGBAMultiSampleBufferFormat(texture.type, texture.format), attachment);\n      if (!colorRenderbuffer) {\n        throw new Error(\"Unable to create multi sampled framebuffer\");\n      }\n      hardwareTexture.addMSAARenderBuffer(colorRenderbuffer);\n      texture.samples = samples;\n      attachments.push(attachment);\n    }\n    if (initializeBuffers) {\n      gl.drawBuffers(attachments);\n    }\n  } else {\n    this._bindUnboundFramebuffer(rtWrapper._framebuffer);\n  }\n  if (useDepthStencil) {\n    rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(rtWrapper._generateStencilBuffer, rtWrapper._generateDepthBuffer, rtWrapper.texture.width, rtWrapper.texture.height, samples);\n  }\n  this._bindUnboundFramebuffer(null);\n  return samples;\n};","map":{"version":3,"names":["InternalTexture","InternalTextureSource","Logger","ThinEngine","prototype","restoreSingleAttachment","gl","_gl","bindAttachments","BACK","restoreSingleAttachmentForRenderTarget","COLOR_ATTACHMENT0","buildTextureLayout","textureStatus","result","i","length","push","NONE","attachments","drawBuffers","unBindMultiColorAttachmentFramebuffer","rtWrapper","disableGenerateMipMaps","onBeforeUnbind","_currentRenderTarget","_attachments","count","_MSAAFramebuffer","bindFramebuffer","READ_FRAMEBUFFER","DRAW_FRAMEBUFFER","_framebuffer","texture","textures","j","webGLVersion","readBuffer","blitFramebuffer","width","height","COLOR_BUFFER_BIT","NEAREST","generateMipMaps","isCube","_bindTextureDirectly","TEXTURE_2D","generateMipmap","_bindUnboundFramebuffer","createMultipleRenderTarget","size","options","initializeBuffers","generateDepthBuffer","generateStencilBuffer","generateDepthTexture","depthTextureFormat","textureCount","defaultType","defaultSamplingMode","defaultUseSRGBBuffer","defaultFormat","defaultTarget","types","Array","samplingModes","useSRGBBuffers","formats","targets","faceIndex","layerIndex","layers","_createHardwareRenderTargetWrapper","undefined","targetTypes","layerCounts","framebuffer","createFramebuffer","useStencilTexture","depthStencilBuffer","_setupFramebufferDepthAttachments","_depthStencilBuffer","_generateDepthBuffer","_generateStencilBuffer","samplingMode","type","useSRGBBuffer","format","target","layerCount","_a","_caps","textureFloatLinearFiltering","textureHalfFloatLinearFiltering","filters","_getSamplingParameters","textureFloat","Warn","supportSRGBBuffers","isWebGPU","isWebGL2","attachment","MultiRenderTarget","activeTexture","bindTexture","_hardwareTexture","underlyingResource","texParameteri","TEXTURE_MAG_FILTER","mag","TEXTURE_MIN_FILTER","min","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","internalSizedFormat","_getRGBABufferInternalSizedFormat","internalFormat","_getInternalFormat","webGLTextureType","_getWebGLTextureType","is2DArray","is3D","baseDepth","depth","texImage3D","texImage2D","TEXTURE_CUBE_MAP_POSITIVE_X","baseWidth","baseHeight","isReady","samples","_useSRGBBuffer","_internalTexturesCache","depthTextureExtension","depthTexture","Depth","depthTextureType","glDepthTextureInternalFormat","DEPTH_COMPONENT16","glDepthTextureFormat","DEPTH_COMPONENT","glDepthTextureType","UNSIGNED_SHORT","glDepthTextureAttachment","DEPTH_ATTACHMENT","FLOAT","DEPTH_COMPONENT32F","FLOAT_32_UNSIGNED_INT_24_8_REV","DEPTH32F_STENCIL8","DEPTH_STENCIL","DEPTH_STENCIL_ATTACHMENT","UNSIGNED_INT","DEPTH_COMPONENT24","UNSIGNED_INT_24_8","DEPTH24_STENCIL8","TEXTURE0","framebufferTexture2D","FRAMEBUFFER","setTextures","setLayerAndFaceIndices","resetTextureCache","updateMultipleRenderTargetTextureSampleCount","Math","getCaps","maxMSAASamples","useDepthStencil","deleteRenderbuffer","deleteFramebuffer","renderbufferStorageMultisample","Error","hardwareTexture","releaseMSAARenderBuffers","colorRenderbuffer","_createRenderBuffer","_getRGBAMultiSampleBufferFormat","addMSAARenderBuffer"],"sources":["../../../../../dev/core/src/Engines/Extensions/engine.multiRender.ts"],"sourcesContent":["import { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport type { IMultiRenderTargetOptions } from \"../../Materials/Textures/multiRenderTarget\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../constants\";\r\nimport { ThinEngine } from \"../thinEngine\";\r\nimport type { RenderTargetWrapper } from \"../renderTargetWrapper\";\r\nimport type { WebGLRenderTargetWrapper } from \"../WebGL/webGLRenderTargetWrapper\";\r\nimport type { WebGLHardwareTexture } from \"../WebGL/webGLHardwareTexture\";\r\nimport type { TextureSize } from \"../../Materials/Textures/textureCreationOptions\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Unbind a list of render target textures from the webGL context\r\n         * This is used only when drawBuffer extension or webGL2 are active\r\n         * @param rtWrapper defines the render target wrapper to unbind\r\n         * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\r\n         * @param onBeforeUnbind defines a function which will be called before the effective unbind\r\n         */\r\n        unBindMultiColorAttachmentFramebuffer(rtWrapper: RenderTargetWrapper, disableGenerateMipMaps: boolean, onBeforeUnbind?: () => void): void;\r\n\r\n        /**\r\n         * Create a multi render target texture\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#multiple-render-target\r\n         * @param size defines the size of the texture\r\n         * @param options defines the creation options\r\n         * @param initializeBuffers if set to true, the engine will make an initializing call of drawBuffers\r\n         * @returns a new render target wrapper ready to render textures\r\n         */\r\n        createMultipleRenderTarget(size: TextureSize, options: IMultiRenderTargetOptions, initializeBuffers?: boolean): RenderTargetWrapper;\r\n\r\n        /**\r\n         * Update the sample count for a given multiple render target texture\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#multisample-render-targets\r\n         * @param rtWrapper defines the render target wrapper to update\r\n         * @param samples defines the sample count to set\r\n         * @param initializeBuffers if set to true, the engine will make an initializing call of drawBuffers\r\n         * @returns the effective sample count (could be 0 if multisample render targets are not supported)\r\n         */\r\n        updateMultipleRenderTargetTextureSampleCount(rtWrapper: Nullable<RenderTargetWrapper>, samples: number, initializeBuffers?: boolean): number;\r\n\r\n        /**\r\n         * Select a subsets of attachments to draw to.\r\n         * @param attachments gl attachments\r\n         */\r\n        bindAttachments(attachments: number[]): void;\r\n\r\n        /**\r\n         * Creates a layout object to draw/clear on specific textures in a MRT\r\n         * @param textureStatus textureStatus[i] indicates if the i-th is active\r\n         * @returns A layout to be fed to the engine, calling `bindAttachments`.\r\n         */\r\n        buildTextureLayout(textureStatus: boolean[]): number[];\r\n\r\n        /**\r\n         * Restores the webgl state to only draw on the main color attachment\r\n         * when the frame buffer associated is the canvas frame buffer\r\n         */\r\n        restoreSingleAttachment(): void;\r\n\r\n        /**\r\n         * Restores the webgl state to only draw on the main color attachment\r\n         * when the frame buffer associated is not the canvas frame buffer\r\n         */\r\n        restoreSingleAttachmentForRenderTarget(): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.restoreSingleAttachment = function (): void {\r\n    const gl = this._gl;\r\n\r\n    this.bindAttachments([gl.BACK]);\r\n};\r\n\r\nThinEngine.prototype.restoreSingleAttachmentForRenderTarget = function (): void {\r\n    const gl = this._gl;\r\n\r\n    this.bindAttachments([gl.COLOR_ATTACHMENT0]);\r\n};\r\n\r\nThinEngine.prototype.buildTextureLayout = function (textureStatus: boolean[]): number[] {\r\n    const gl = this._gl;\r\n\r\n    const result = [];\r\n\r\n    for (let i = 0; i < textureStatus.length; i++) {\r\n        if (textureStatus[i]) {\r\n            result.push((<any>gl)[\"COLOR_ATTACHMENT\" + i]);\r\n        } else {\r\n            result.push(gl.NONE);\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nThinEngine.prototype.bindAttachments = function (attachments: number[]): void {\r\n    const gl = this._gl;\r\n\r\n    gl.drawBuffers(attachments);\r\n};\r\n\r\nThinEngine.prototype.unBindMultiColorAttachmentFramebuffer = function (\r\n    rtWrapper: WebGLRenderTargetWrapper,\r\n    disableGenerateMipMaps: boolean = false,\r\n    onBeforeUnbind?: () => void\r\n): void {\r\n    this._currentRenderTarget = null;\r\n\r\n    // If MSAA, we need to bitblt back to main texture\r\n    const gl = this._gl;\r\n\r\n    const attachments = rtWrapper._attachments!;\r\n    const count = attachments.length;\r\n\r\n    if (rtWrapper._MSAAFramebuffer) {\r\n        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, rtWrapper._MSAAFramebuffer);\r\n        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, rtWrapper._framebuffer);\r\n\r\n        for (let i = 0; i < count; i++) {\r\n            const texture = rtWrapper.textures![i];\r\n\r\n            for (let j = 0; j < count; j++) {\r\n                attachments[j] = gl.NONE;\r\n            }\r\n\r\n            attachments[i] = (<any>gl)[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\r\n            gl.readBuffer(attachments[i]);\r\n            gl.drawBuffers(attachments);\r\n            gl.blitFramebuffer(0, 0, texture.width, texture.height, 0, 0, texture.width, texture.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);\r\n        }\r\n\r\n        for (let i = 0; i < count; i++) {\r\n            attachments[i] = (<any>gl)[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\r\n        }\r\n\r\n        gl.drawBuffers(attachments);\r\n    }\r\n\r\n    for (let i = 0; i < count; i++) {\r\n        const texture = rtWrapper.textures![i];\r\n        if (texture?.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\r\n            this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n            this._bindTextureDirectly(gl.TEXTURE_2D, null);\r\n        }\r\n    }\r\n\r\n    if (onBeforeUnbind) {\r\n        if (rtWrapper._MSAAFramebuffer) {\r\n            // Bind the correct framebuffer\r\n            this._bindUnboundFramebuffer(rtWrapper._framebuffer);\r\n        }\r\n        onBeforeUnbind();\r\n    }\r\n\r\n    this._bindUnboundFramebuffer(null);\r\n};\r\n\r\nThinEngine.prototype.createMultipleRenderTarget = function (size: TextureSize, options: IMultiRenderTargetOptions, initializeBuffers: boolean = true): RenderTargetWrapper {\r\n    let generateMipMaps = false;\r\n    let generateDepthBuffer = true;\r\n    let generateStencilBuffer = false;\r\n    let generateDepthTexture = false;\r\n    let depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH16;\r\n    let textureCount = 1;\r\n\r\n    const defaultType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n    const defaultSamplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n    const defaultUseSRGBBuffer = false;\r\n    const defaultFormat = Constants.TEXTUREFORMAT_RGBA;\r\n    const defaultTarget = Constants.TEXTURE_2D;\r\n\r\n    let types = new Array<number>();\r\n    let samplingModes = new Array<number>();\r\n    let useSRGBBuffers = new Array<boolean>();\r\n    let formats = new Array<number>();\r\n    let targets = new Array<number>();\r\n    let faceIndex = new Array<number>();\r\n    let layerIndex = new Array<number>();\r\n    let layers = new Array<number>();\r\n\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(true, false, size) as WebGLRenderTargetWrapper;\r\n\r\n    if (options !== undefined) {\r\n        generateMipMaps = options.generateMipMaps === undefined ? false : options.generateMipMaps;\r\n        generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\r\n        generateStencilBuffer = options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\r\n        generateDepthTexture = options.generateDepthTexture === undefined ? false : options.generateDepthTexture;\r\n        textureCount = options.textureCount || 1;\r\n\r\n        if (options.types) {\r\n            types = options.types;\r\n        }\r\n        if (options.samplingModes) {\r\n            samplingModes = options.samplingModes;\r\n        }\r\n        if (options.useSRGBBuffers) {\r\n            useSRGBBuffers = options.useSRGBBuffers;\r\n        }\r\n        if (options.formats) {\r\n            formats = options.formats;\r\n        }\r\n        if (options.targetTypes) {\r\n            targets = options.targetTypes;\r\n        }\r\n        if (options.faceIndex) {\r\n            faceIndex = options.faceIndex;\r\n        }\r\n        if (options.layerIndex) {\r\n            layerIndex = options.layerIndex;\r\n        }\r\n        if (options.layerCounts) {\r\n            layers = options.layerCounts;\r\n        }\r\n        if (\r\n            this.webGLVersion > 1 &&\r\n            (options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 ||\r\n                options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8 ||\r\n                options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24 ||\r\n                options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32_FLOAT ||\r\n                options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8)\r\n        ) {\r\n            depthTextureFormat = options.depthTextureFormat;\r\n        }\r\n    }\r\n    const gl = this._gl;\r\n    // Create the framebuffer\r\n    const framebuffer = gl.createFramebuffer();\r\n    this._bindUnboundFramebuffer(framebuffer);\r\n\r\n    const width = (<{ width: number; height: number }>size).width || <number>size;\r\n    const height = (<{ width: number; height: number }>size).height || <number>size;\r\n\r\n    const textures: InternalTexture[] = [];\r\n    const attachments: number[] = [];\r\n\r\n    const useStencilTexture =\r\n        this.webGLVersion > 1 &&\r\n        generateDepthTexture &&\r\n        (options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 ||\r\n            options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8 ||\r\n            options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8);\r\n    const depthStencilBuffer = this._setupFramebufferDepthAttachments(!useStencilTexture && generateStencilBuffer, !generateDepthTexture && generateDepthBuffer, width, height);\r\n\r\n    rtWrapper._framebuffer = framebuffer;\r\n    rtWrapper._depthStencilBuffer = depthStencilBuffer;\r\n    rtWrapper._generateDepthBuffer = !generateDepthTexture && generateDepthBuffer;\r\n    rtWrapper._generateStencilBuffer = !useStencilTexture && generateStencilBuffer;\r\n    rtWrapper._attachments = attachments;\r\n\r\n    for (let i = 0; i < textureCount; i++) {\r\n        let samplingMode = samplingModes[i] || defaultSamplingMode;\r\n        let type = types[i] || defaultType;\r\n        let useSRGBBuffer = useSRGBBuffers[i] || defaultUseSRGBBuffer;\r\n        const format = formats[i] || defaultFormat;\r\n\r\n        const target = targets[i] || defaultTarget;\r\n        const layerCount = layers[i] ?? 1;\r\n\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n            // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n            // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n\r\n        const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\r\n            type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n            Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\r\n        }\r\n\r\n        useSRGBBuffer = useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU);\r\n\r\n        const isWebGL2 = this.webGLVersion > 1;\r\n        const attachment = (<any>gl)[isWebGL2 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\r\n\r\n        attachments.push(attachment);\r\n\r\n        if (target === -1) {\r\n            continue;\r\n        }\r\n\r\n        const texture = new InternalTexture(this, InternalTextureSource.MultiRenderTarget);\r\n        textures[i] = texture;\r\n\r\n        gl.activeTexture((<any>gl)[\"TEXTURE\" + i]);\r\n        gl.bindTexture(target, texture._hardwareTexture!.underlyingResource);\r\n\r\n        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, filters.mag);\r\n        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, filters.min);\r\n        gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n        const internalSizedFormat = this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);\r\n        const internalFormat = this._getInternalFormat(format);\r\n        const webGLTextureType = this._getWebGLTextureType(type);\r\n\r\n        if (isWebGL2 && (target === Constants.TEXTURE_2D_ARRAY || target === Constants.TEXTURE_3D)) {\r\n            if (target === Constants.TEXTURE_2D_ARRAY) {\r\n                texture.is2DArray = true;\r\n            } else {\r\n                texture.is3D = true;\r\n            }\r\n\r\n            texture.baseDepth = texture.depth = layerCount;\r\n\r\n            gl.texImage3D(target, 0, internalSizedFormat, width, height, layerCount, 0, internalFormat, webGLTextureType, null);\r\n        } else if (target === Constants.TEXTURE_CUBE_MAP) {\r\n            // We have to generate all faces to complete the framebuffer\r\n            for (let i = 0; i < 6; i++) {\r\n                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, internalSizedFormat, width, height, 0, internalFormat, webGLTextureType, null);\r\n            }\r\n            texture.isCube = true;\r\n        } else {\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, internalSizedFormat, width, height, 0, internalFormat, webGLTextureType, null);\r\n        }\r\n\r\n        if (generateMipMaps) {\r\n            gl.generateMipmap(target);\r\n        }\r\n\r\n        // Unbind\r\n        this._bindTextureDirectly(target, null);\r\n\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.isReady = true;\r\n        texture.samples = 1;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        texture.type = type;\r\n        texture._useSRGBBuffer = useSRGBBuffer;\r\n        texture.format = format;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n    }\r\n\r\n    if (generateDepthTexture && this._caps.depthTextureExtension) {\r\n        // Depth texture\r\n        const depthTexture = new InternalTexture(this, InternalTextureSource.Depth);\r\n\r\n        let depthTextureType = Constants.TEXTURETYPE_UNSIGNED_SHORT;\r\n        let glDepthTextureInternalFormat: GLenum = gl.DEPTH_COMPONENT16;\r\n        let glDepthTextureFormat: GLenum = gl.DEPTH_COMPONENT;\r\n        let glDepthTextureType: GLenum = gl.UNSIGNED_SHORT;\r\n        let glDepthTextureAttachment: GLenum = gl.DEPTH_ATTACHMENT;\r\n        if (this.webGLVersion < 2) {\r\n            glDepthTextureInternalFormat = gl.DEPTH_COMPONENT;\r\n        } else {\r\n            if (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32_FLOAT) {\r\n                depthTextureType = Constants.TEXTURETYPE_FLOAT;\r\n                glDepthTextureType = gl.FLOAT;\r\n                glDepthTextureInternalFormat = gl.DEPTH_COMPONENT32F;\r\n            } else if (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8) {\r\n                depthTextureType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n                glDepthTextureType = gl.FLOAT_32_UNSIGNED_INT_24_8_REV;\r\n                glDepthTextureInternalFormat = gl.DEPTH32F_STENCIL8;\r\n                glDepthTextureFormat = gl.DEPTH_STENCIL;\r\n                glDepthTextureAttachment = gl.DEPTH_STENCIL_ATTACHMENT;\r\n            } else if (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24) {\r\n                depthTextureType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n                glDepthTextureType = gl.UNSIGNED_INT;\r\n                glDepthTextureInternalFormat = gl.DEPTH_COMPONENT24;\r\n                glDepthTextureAttachment = gl.DEPTH_ATTACHMENT;\r\n            } else if (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 || depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8) {\r\n                depthTextureType = Constants.TEXTURETYPE_UNSIGNED_INT_24_8;\r\n                glDepthTextureType = gl.UNSIGNED_INT_24_8;\r\n                glDepthTextureInternalFormat = gl.DEPTH24_STENCIL8;\r\n                glDepthTextureFormat = gl.DEPTH_STENCIL;\r\n                glDepthTextureAttachment = gl.DEPTH_STENCIL_ATTACHMENT;\r\n            }\r\n        }\r\n\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, depthTexture._hardwareTexture!.underlyingResource);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, glDepthTextureInternalFormat, width, height, 0, glDepthTextureFormat, glDepthTextureType, null);\r\n\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, glDepthTextureAttachment, gl.TEXTURE_2D, depthTexture._hardwareTexture!.underlyingResource, 0);\r\n\r\n        depthTexture.baseWidth = width;\r\n        depthTexture.baseHeight = height;\r\n        depthTexture.width = width;\r\n        depthTexture.height = height;\r\n        depthTexture.isReady = true;\r\n        depthTexture.samples = 1;\r\n        depthTexture.generateMipMaps = generateMipMaps;\r\n        depthTexture.samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        depthTexture.format = depthTextureFormat;\r\n        depthTexture.type = depthTextureType;\r\n\r\n        textures[textureCount] = depthTexture;\r\n        this._internalTexturesCache.push(depthTexture);\r\n    }\r\n    rtWrapper.setTextures(textures);\r\n    if (initializeBuffers) {\r\n        gl.drawBuffers(attachments);\r\n    }\r\n\r\n    this._bindUnboundFramebuffer(null);\r\n\r\n    rtWrapper.setLayerAndFaceIndices(layerIndex, faceIndex);\r\n\r\n    this.resetTextureCache();\r\n\r\n    return rtWrapper;\r\n};\r\n\r\nThinEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function (\r\n    rtWrapper: Nullable<WebGLRenderTargetWrapper>,\r\n    samples: number,\r\n    initializeBuffers: boolean = true\r\n): number {\r\n    if (this.webGLVersion < 2 || !rtWrapper || !rtWrapper.texture) {\r\n        return 1;\r\n    }\r\n\r\n    if (rtWrapper.samples === samples) {\r\n        return samples;\r\n    }\r\n\r\n    const count = rtWrapper._attachments!.length;\r\n\r\n    if (count === 0) {\r\n        return 1;\r\n    }\r\n\r\n    const gl = this._gl;\r\n\r\n    samples = Math.min(samples, this.getCaps().maxMSAASamples);\r\n\r\n    // Dispose previous render buffers\r\n    const useDepthStencil = !!rtWrapper._depthStencilBuffer;\r\n    if (useDepthStencil) {\r\n        gl.deleteRenderbuffer(rtWrapper._depthStencilBuffer);\r\n        rtWrapper._depthStencilBuffer = null;\r\n    }\r\n\r\n    if (rtWrapper._MSAAFramebuffer) {\r\n        gl.deleteFramebuffer(rtWrapper._MSAAFramebuffer);\r\n        rtWrapper._MSAAFramebuffer = null;\r\n    }\r\n\r\n    if (samples > 1 && typeof gl.renderbufferStorageMultisample === \"function\") {\r\n        const framebuffer = gl.createFramebuffer();\r\n\r\n        if (!framebuffer) {\r\n            throw new Error(\"Unable to create multi sampled framebuffer\");\r\n        }\r\n\r\n        rtWrapper._MSAAFramebuffer = framebuffer;\r\n        this._bindUnboundFramebuffer(framebuffer);\r\n\r\n        const attachments = [];\r\n\r\n        for (let i = 0; i < count; i++) {\r\n            const texture = rtWrapper.textures![i];\r\n            const hardwareTexture = texture._hardwareTexture as WebGLHardwareTexture;\r\n\r\n            hardwareTexture.releaseMSAARenderBuffers();\r\n        }\r\n\r\n        for (let i = 0; i < count; i++) {\r\n            const texture = rtWrapper.textures![i];\r\n            const hardwareTexture = texture._hardwareTexture as WebGLHardwareTexture;\r\n            const attachment = (<any>gl)[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\r\n\r\n            const colorRenderbuffer = this._createRenderBuffer(\r\n                texture.width,\r\n                texture.height,\r\n                samples,\r\n                -1 /* not used */,\r\n                this._getRGBAMultiSampleBufferFormat(texture.type, texture.format),\r\n                attachment\r\n            );\r\n\r\n            if (!colorRenderbuffer) {\r\n                throw new Error(\"Unable to create multi sampled framebuffer\");\r\n            }\r\n\r\n            hardwareTexture.addMSAARenderBuffer(colorRenderbuffer);\r\n            texture.samples = samples;\r\n\r\n            attachments.push(attachment);\r\n        }\r\n        if (initializeBuffers) {\r\n            gl.drawBuffers(attachments);\r\n        }\r\n    } else {\r\n        this._bindUnboundFramebuffer(rtWrapper._framebuffer);\r\n    }\r\n\r\n    if (useDepthStencil) {\r\n        rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(\r\n            rtWrapper._generateStencilBuffer,\r\n            rtWrapper._generateDepthBuffer,\r\n            rtWrapper.texture.width,\r\n            rtWrapper.texture.height,\r\n            samples\r\n        );\r\n    }\r\n\r\n    this._bindUnboundFramebuffer(null);\r\n\r\n    return samples;\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}