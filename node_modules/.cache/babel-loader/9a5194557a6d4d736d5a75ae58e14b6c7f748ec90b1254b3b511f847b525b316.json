{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../tslib.es6.js\";\nimport { SerializationHelper, serialize } from \"../Misc/decorators.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { ComputeBindingType } from \"../Engines/Extensions/engine.computeShader.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { UniqueIdGenerator } from \"../Misc/uniqueIdGenerator.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { TextureSampler } from \"../Materials/Textures/textureSampler.js\";\n/**\n * The ComputeShader object lets you execute a compute shader on your GPU (if supported by the engine)\n */\nexport class ComputeShader {\n  /**\n   * The options used to create the shader\n   */\n  get options() {\n    return this._options;\n  }\n  /**\n   * The shaderPath used to create the shader\n   */\n  get shaderPath() {\n    return this._shaderPath;\n  }\n  /**\n   * Instantiates a new compute shader.\n   * @param name Defines the name of the compute shader in the scene\n   * @param engine Defines the engine the compute shader belongs to\n   * @param shaderPath Defines  the route to the shader code in one of three ways:\n   *  * object: \\{ compute: \"custom\" \\}, used with ShaderStore.ShadersStoreWGSL[\"customComputeShader\"]\n   *  * object: \\{ computeElement: \"HTMLElementId\" \\}, used with shader code in script tags\n   *  * object: \\{ computeSource: \"compute shader code string\" \\}, where the string contains the shader code\n   *  * string: try first to find the code in ShaderStore.ShadersStoreWGSL[shaderPath + \"ComputeShader\"]. If not, assumes it is a file with name shaderPath.compute.fx in index.html folder.\n   * @param options Define the options used to create the shader\n   */\n  constructor(name, engine, shaderPath, options = {}) {\n    this._bindings = {};\n    this._samplers = {};\n    this._contextIsDirty = false;\n    /**\n     * Callback triggered when the shader is compiled\n     */\n    this.onCompiled = null;\n    /**\n     * Callback triggered when an error occurs\n     */\n    this.onError = null;\n    this.name = name;\n    this._engine = engine;\n    this.uniqueId = UniqueIdGenerator.UniqueId;\n    if (!this._engine.getCaps().supportComputeShaders) {\n      Logger.Error(\"This engine does not support compute shaders!\");\n      return;\n    }\n    if (!options.bindingsMapping) {\n      Logger.Error(\"You must provide the binding mappings as browsers don't support reflection for wgsl shaders yet!\");\n      return;\n    }\n    this._context = engine.createComputeContext();\n    this._shaderPath = shaderPath;\n    this._options = Object.assign({\n      bindingsMapping: {},\n      defines: []\n    }, options);\n  }\n  /**\n   * Gets the current class name of the material e.g. \"ComputeShader\"\n   * Mainly use in serialization.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ComputeShader\";\n  }\n  /**\n   * Binds a texture to the shader\n   * @param name Binding name of the texture\n   * @param texture Texture to bind\n   * @param bindSampler Bind the sampler corresponding to the texture (default: true). The sampler will be bound just before the binding index of the texture\n   */\n  setTexture(name, texture, bindSampler = true) {\n    const current = this._bindings[name];\n    this._bindings[name] = {\n      type: bindSampler ? ComputeBindingType.Texture : ComputeBindingType.TextureWithoutSampler,\n      object: texture,\n      indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries\n    };\n    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== texture || current.type !== this._bindings[name].type);\n  }\n  /**\n   * Binds a storage texture to the shader\n   * @param name Binding name of the texture\n   * @param texture Texture to bind\n   */\n  setStorageTexture(name, texture) {\n    const current = this._bindings[name];\n    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== texture);\n    this._bindings[name] = {\n      type: ComputeBindingType.StorageTexture,\n      object: texture,\n      indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries\n    };\n  }\n  /**\n   * Binds an external texture to the shader\n   * @param name Binding name of the texture\n   * @param texture Texture to bind\n   */\n  setExternalTexture(name, texture) {\n    const current = this._bindings[name];\n    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== texture);\n    this._bindings[name] = {\n      type: ComputeBindingType.ExternalTexture,\n      object: texture,\n      indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries\n    };\n  }\n  /**\n   * Binds a video texture to the shader (by binding the external texture attached to this video)\n   * @param name Binding name of the texture\n   * @param texture Texture to bind\n   * @returns true if the video texture was successfully bound, else false. false will be returned if the current engine does not support external textures\n   */\n  setVideoTexture(name, texture) {\n    if (texture.externalTexture) {\n      this.setExternalTexture(name, texture.externalTexture);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Binds a uniform buffer to the shader\n   * @param name Binding name of the buffer\n   * @param buffer Buffer to bind\n   */\n  setUniformBuffer(name, buffer) {\n    const current = this._bindings[name];\n    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== buffer);\n    this._bindings[name] = {\n      type: ComputeBindingType.UniformBuffer,\n      object: buffer,\n      indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries\n    };\n  }\n  /**\n   * Binds a storage buffer to the shader\n   * @param name Binding name of the buffer\n   * @param buffer Buffer to bind\n   */\n  setStorageBuffer(name, buffer) {\n    const current = this._bindings[name];\n    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== buffer);\n    this._bindings[name] = {\n      type: ComputeBindingType.StorageBuffer,\n      object: buffer,\n      indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries\n    };\n  }\n  /**\n   * Binds a texture sampler to the shader\n   * @param name Binding name of the sampler\n   * @param sampler Sampler to bind\n   */\n  setTextureSampler(name, sampler) {\n    const current = this._bindings[name];\n    this._contextIsDirty || (this._contextIsDirty = !current || !sampler.compareSampler(current.object));\n    this._bindings[name] = {\n      type: ComputeBindingType.Sampler,\n      object: sampler,\n      indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries\n    };\n  }\n  /**\n   * Specifies that the compute shader is ready to be executed (the compute effect and all the resources are ready)\n   * @returns true if the compute shader is ready to be executed\n   */\n  isReady() {\n    let effect = this._effect;\n    for (const key in this._bindings) {\n      const binding = this._bindings[key],\n        type = binding.type,\n        object = binding.object;\n      switch (type) {\n        case ComputeBindingType.Texture:\n        case ComputeBindingType.TextureWithoutSampler:\n        case ComputeBindingType.StorageTexture:\n          {\n            const texture = object;\n            if (!texture.isReady()) {\n              return false;\n            }\n            break;\n          }\n        case ComputeBindingType.ExternalTexture:\n          {\n            const texture = object;\n            if (!texture.isReady()) {\n              return false;\n            }\n            break;\n          }\n      }\n    }\n    const defines = [];\n    const shaderName = this._shaderPath;\n    if (this._options.defines) {\n      for (let index = 0; index < this._options.defines.length; index++) {\n        defines.push(this._options.defines[index]);\n      }\n    }\n    const join = defines.join(\"\\n\");\n    if (this._cachedDefines !== join) {\n      this._cachedDefines = join;\n      effect = this._engine.createComputeEffect(shaderName, {\n        defines: join,\n        entryPoint: this._options.entryPoint,\n        onCompiled: this.onCompiled,\n        onError: this.onError\n      });\n      this._effect = effect;\n    }\n    if (!effect.isReady()) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Dispatches (executes) the compute shader\n   * @param x Number of workgroups to execute on the X dimension\n   * @param y Number of workgroups to execute on the Y dimension (default: 1)\n   * @param z Number of workgroups to execute on the Z dimension (default: 1)\n   * @returns True if the dispatch could be done, else false (meaning either the compute effect or at least one of the bound resources was not ready)\n   */\n  dispatch(x, y, z) {\n    var _a;\n    if (!this.isReady()) {\n      return false;\n    }\n    // If the sampling parameters of a texture bound to the shader have changed, we must clear the compute context so that it is recreated with the updated values\n    // Also, if the actual (gpu) buffer used by a uniform buffer has changed, we must clear the compute context so that it is recreated with the updated value\n    for (const key in this._bindings) {\n      const binding = this._bindings[key];\n      if (!this._options.bindingsMapping[key]) {\n        throw new Error(\"ComputeShader ('\" + this.name + \"'): No binding mapping has been provided for the property '\" + key + \"'\");\n      }\n      switch (binding.type) {\n        case ComputeBindingType.Texture:\n          {\n            const sampler = this._samplers[key];\n            const texture = binding.object;\n            if (!sampler || !texture._texture || !sampler.compareSampler(texture._texture)) {\n              this._samplers[key] = new TextureSampler().setParameters(texture.wrapU, texture.wrapV, texture.wrapR, texture.anisotropicFilteringLevel, texture._texture.samplingMode, (_a = texture._texture) === null || _a === void 0 ? void 0 : _a._comparisonFunction);\n              this._contextIsDirty = true;\n            }\n            break;\n          }\n        case ComputeBindingType.ExternalTexture:\n          {\n            // we must recreate the bind groups each time if there's an external texture, because device.importExternalTexture must be called each frame\n            this._contextIsDirty = true;\n            break;\n          }\n        case ComputeBindingType.UniformBuffer:\n          {\n            const ubo = binding.object;\n            if (ubo.getBuffer() !== binding.buffer) {\n              binding.buffer = ubo.getBuffer();\n              this._contextIsDirty = true;\n            }\n            break;\n          }\n      }\n    }\n    if (this._contextIsDirty) {\n      this._contextIsDirty = false;\n      this._context.clear();\n    }\n    this._engine.computeDispatch(this._effect, this._context, this._bindings, x, y, z, this._options.bindingsMapping);\n    return true;\n  }\n  /**\n   * Waits for the compute shader to be ready and executes it\n   * @param x Number of workgroups to execute on the X dimension\n   * @param y Number of workgroups to execute on the Y dimension (default: 1)\n   * @param z Number of workgroups to execute on the Z dimension (default: 1)\n   * @param delay Delay between the retries while the shader is not ready (in milliseconds - 10 by default)\n   * @returns A promise that is resolved once the shader has been sent to the GPU. Note that it does not mean that the shader execution itself is finished!\n   */\n  dispatchWhenReady(x, y, z, delay = 10) {\n    return new Promise(resolve => {\n      const check = () => {\n        if (!this.dispatch(x, y, z)) {\n          setTimeout(check, delay);\n        } else {\n          resolve();\n        }\n      };\n      check();\n    });\n  }\n  /**\n   * Serializes this compute shader in a JSON representation\n   * @returns the serialized compute shader object\n   */\n  serialize() {\n    const serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.options = this._options;\n    serializationObject.shaderPath = this._shaderPath;\n    serializationObject.bindings = {};\n    serializationObject.textures = {};\n    for (const key in this._bindings) {\n      const binding = this._bindings[key];\n      const object = binding.object;\n      switch (binding.type) {\n        case ComputeBindingType.Texture:\n        case ComputeBindingType.TextureWithoutSampler:\n        case ComputeBindingType.StorageTexture:\n          {\n            const serializedData = object.serialize();\n            if (serializedData) {\n              serializationObject.textures[key] = serializedData;\n              serializationObject.bindings[key] = {\n                type: binding.type\n              };\n            }\n            break;\n          }\n        case ComputeBindingType.UniformBuffer:\n          {\n            break;\n          }\n      }\n    }\n    return serializationObject;\n  }\n  /**\n   * Creates a compute shader from parsed compute shader data\n   * @param source defines the JSON representation of the compute shader\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a new compute shader\n   */\n  static Parse(source, scene, rootUrl) {\n    const compute = SerializationHelper.Parse(() => new ComputeShader(source.name, scene.getEngine(), source.shaderPath, source.options), source, scene, rootUrl);\n    for (const key in source.textures) {\n      const binding = source.bindings[key];\n      const texture = Texture.Parse(source.textures[key], scene, rootUrl);\n      if (binding.type === ComputeBindingType.Texture) {\n        compute.setTexture(key, texture);\n      } else if (binding.type === ComputeBindingType.TextureWithoutSampler) {\n        compute.setTexture(key, texture, false);\n      } else {\n        compute.setStorageTexture(key, texture);\n      }\n    }\n    return compute;\n  }\n}\n__decorate([serialize()], ComputeShader.prototype, \"name\", void 0);\nRegisterClass(\"BABYLON.ComputeShader\", ComputeShader);","map":{"version":3,"names":["SerializationHelper","serialize","RegisterClass","ComputeBindingType","Texture","UniqueIdGenerator","Logger","TextureSampler","ComputeShader","options","_options","shaderPath","_shaderPath","constructor","name","engine","_bindings","_samplers","_contextIsDirty","onCompiled","onError","_engine","uniqueId","UniqueId","getCaps","supportComputeShaders","Error","bindingsMapping","_context","createComputeContext","Object","assign","defines","getClassName","setTexture","texture","bindSampler","current","type","TextureWithoutSampler","object","indexInGroupEntries","setStorageTexture","StorageTexture","setExternalTexture","ExternalTexture","setVideoTexture","externalTexture","setUniformBuffer","buffer","UniformBuffer","setStorageBuffer","StorageBuffer","setTextureSampler","sampler","compareSampler","Sampler","isReady","effect","_effect","key","binding","shaderName","index","length","push","join","_cachedDefines","createComputeEffect","entryPoint","dispatch","x","y","z","_texture","setParameters","wrapU","wrapV","wrapR","anisotropicFilteringLevel","samplingMode","_a","_comparisonFunction","ubo","getBuffer","clear","computeDispatch","dispatchWhenReady","delay","Promise","resolve","check","setTimeout","serializationObject","Serialize","bindings","textures","serializedData","Parse","source","scene","rootUrl","compute","getEngine","__decorate"],"sources":["../../../../dev/core/src/Compute/computeShader.ts"],"sourcesContent":["import type { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport { SerializationHelper, serialize } from \"../Misc/decorators\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { ComputeEffect, IComputeEffectCreationOptions } from \"./computeEffect\";\r\nimport type { ComputeBindingMapping } from \"../Engines/Extensions/engine.computeShader\";\r\nimport { ComputeBindingType } from \"../Engines/Extensions/engine.computeShader\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { UniqueIdGenerator } from \"../Misc/uniqueIdGenerator\";\r\nimport type { IComputeContext } from \"./IComputeContext\";\r\nimport type { StorageBuffer } from \"../Buffers/storageBuffer\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { TextureSampler } from \"../Materials/Textures/textureSampler\";\r\nimport type { DataBuffer } from \"core/Buffers/dataBuffer\";\r\nimport type { ExternalTexture } from \"core/Materials/Textures/externalTexture\";\r\nimport type { VideoTexture } from \"core/Materials/Textures/videoTexture\";\r\n\r\n/**\r\n * Defines the options associated with the creation of a compute shader.\r\n */\r\nexport interface IComputeShaderOptions {\r\n    /**\r\n     * list of bindings mapping (key is property name, value is binding location)\r\n     * Must be provided because browsers don't support reflection for wgsl shaders yet (so there's no way to query the binding/group from a variable name)\r\n     * TODO: remove this when browsers support reflection for wgsl shaders\r\n     */\r\n    bindingsMapping: ComputeBindingMapping;\r\n\r\n    /**\r\n     * The list of defines used in the shader\r\n     */\r\n    defines?: string[];\r\n\r\n    /**\r\n     * The name of the entry point in the shader source (default: \"main\")\r\n     */\r\n    entryPoint?: string;\r\n\r\n    /**\r\n     * If provided, will be called with the shader code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<(code: string) => string>;\r\n}\r\n\r\ntype ComputeBindingListInternal = { [key: string]: { type: ComputeBindingType; object: any; indexInGroupEntries?: number; buffer?: Nullable<DataBuffer> } };\r\n\r\n/**\r\n * The ComputeShader object lets you execute a compute shader on your GPU (if supported by the engine)\r\n */\r\nexport class ComputeShader {\r\n    private _engine: ThinEngine;\r\n    private _shaderPath: any;\r\n    private _options: IComputeShaderOptions;\r\n    private _effect: ComputeEffect;\r\n    private _cachedDefines: string;\r\n    private _bindings: ComputeBindingListInternal = {};\r\n    private _samplers: { [key: string]: TextureSampler } = {};\r\n    private _context: IComputeContext;\r\n    private _contextIsDirty = false;\r\n\r\n    /**\r\n     * Gets the unique id of the compute shader\r\n     */\r\n    public readonly uniqueId: number;\r\n\r\n    /**\r\n     * The name of the shader\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * The options used to create the shader\r\n     */\r\n    public get options() {\r\n        return this._options;\r\n    }\r\n\r\n    /**\r\n     * The shaderPath used to create the shader\r\n     */\r\n    public get shaderPath() {\r\n        return this._shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Callback triggered when the shader is compiled\r\n     */\r\n    public onCompiled: Nullable<(effect: ComputeEffect) => void> = null;\r\n\r\n    /**\r\n     * Callback triggered when an error occurs\r\n     */\r\n    public onError: Nullable<(effect: ComputeEffect, errors: string) => void> = null;\r\n\r\n    /**\r\n     * Instantiates a new compute shader.\r\n     * @param name Defines the name of the compute shader in the scene\r\n     * @param engine Defines the engine the compute shader belongs to\r\n     * @param shaderPath Defines  the route to the shader code in one of three ways:\r\n     *  * object: \\{ compute: \"custom\" \\}, used with ShaderStore.ShadersStoreWGSL[\"customComputeShader\"]\r\n     *  * object: \\{ computeElement: \"HTMLElementId\" \\}, used with shader code in script tags\r\n     *  * object: \\{ computeSource: \"compute shader code string\" \\}, where the string contains the shader code\r\n     *  * string: try first to find the code in ShaderStore.ShadersStoreWGSL[shaderPath + \"ComputeShader\"]. If not, assumes it is a file with name shaderPath.compute.fx in index.html folder.\r\n     * @param options Define the options used to create the shader\r\n     */\r\n    constructor(name: string, engine: ThinEngine, shaderPath: any, options: Partial<IComputeShaderOptions> = {}) {\r\n        this.name = name;\r\n        this._engine = engine;\r\n        this.uniqueId = UniqueIdGenerator.UniqueId;\r\n\r\n        if (!this._engine.getCaps().supportComputeShaders) {\r\n            Logger.Error(\"This engine does not support compute shaders!\");\r\n            return;\r\n        }\r\n        if (!options.bindingsMapping) {\r\n            Logger.Error(\"You must provide the binding mappings as browsers don't support reflection for wgsl shaders yet!\");\r\n            return;\r\n        }\r\n\r\n        this._context = engine.createComputeContext()!;\r\n        this._shaderPath = shaderPath;\r\n        this._options = {\r\n            bindingsMapping: {},\r\n            defines: [],\r\n            ...options,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"ComputeShader\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ComputeShader\";\r\n    }\r\n\r\n    /**\r\n     * Binds a texture to the shader\r\n     * @param name Binding name of the texture\r\n     * @param texture Texture to bind\r\n     * @param bindSampler Bind the sampler corresponding to the texture (default: true). The sampler will be bound just before the binding index of the texture\r\n     */\r\n    public setTexture(name: string, texture: BaseTexture, bindSampler = true): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._bindings[name] = {\r\n            type: bindSampler ? ComputeBindingType.Texture : ComputeBindingType.TextureWithoutSampler,\r\n            object: texture,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n\r\n        this._contextIsDirty ||= !current || current.object !== texture || current.type !== this._bindings[name].type;\r\n    }\r\n\r\n    /**\r\n     * Binds a storage texture to the shader\r\n     * @param name Binding name of the texture\r\n     * @param texture Texture to bind\r\n     */\r\n    public setStorageTexture(name: string, texture: BaseTexture): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || current.object !== texture;\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.StorageTexture,\r\n            object: texture,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds an external texture to the shader\r\n     * @param name Binding name of the texture\r\n     * @param texture Texture to bind\r\n     */\r\n    public setExternalTexture(name: string, texture: ExternalTexture): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || current.object !== texture;\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.ExternalTexture,\r\n            object: texture,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds a video texture to the shader (by binding the external texture attached to this video)\r\n     * @param name Binding name of the texture\r\n     * @param texture Texture to bind\r\n     * @returns true if the video texture was successfully bound, else false. false will be returned if the current engine does not support external textures\r\n     */\r\n    public setVideoTexture(name: string, texture: VideoTexture) {\r\n        if (texture.externalTexture) {\r\n            this.setExternalTexture(name, texture.externalTexture);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Binds a uniform buffer to the shader\r\n     * @param name Binding name of the buffer\r\n     * @param buffer Buffer to bind\r\n     */\r\n    public setUniformBuffer(name: string, buffer: UniformBuffer): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || current.object !== buffer;\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.UniformBuffer,\r\n            object: buffer,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds a storage buffer to the shader\r\n     * @param name Binding name of the buffer\r\n     * @param buffer Buffer to bind\r\n     */\r\n    public setStorageBuffer(name: string, buffer: StorageBuffer): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || current.object !== buffer;\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.StorageBuffer,\r\n            object: buffer,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds a texture sampler to the shader\r\n     * @param name Binding name of the sampler\r\n     * @param sampler Sampler to bind\r\n     */\r\n    public setTextureSampler(name: string, sampler: TextureSampler): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || !sampler.compareSampler(current.object);\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.Sampler,\r\n            object: sampler,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Specifies that the compute shader is ready to be executed (the compute effect and all the resources are ready)\r\n     * @returns true if the compute shader is ready to be executed\r\n     */\r\n    public isReady(): boolean {\r\n        let effect = this._effect;\r\n\r\n        for (const key in this._bindings) {\r\n            const binding = this._bindings[key],\r\n                type = binding.type,\r\n                object = binding.object;\r\n\r\n            switch (type) {\r\n                case ComputeBindingType.Texture:\r\n                case ComputeBindingType.TextureWithoutSampler:\r\n                case ComputeBindingType.StorageTexture: {\r\n                    const texture = object as BaseTexture;\r\n                    if (!texture.isReady()) {\r\n                        return false;\r\n                    }\r\n                    break;\r\n                }\r\n                case ComputeBindingType.ExternalTexture: {\r\n                    const texture = object as ExternalTexture;\r\n                    if (!texture.isReady()) {\r\n                        return false;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        const defines = [];\r\n\r\n        const shaderName = this._shaderPath;\r\n\r\n        if (this._options.defines) {\r\n            for (let index = 0; index < this._options.defines.length; index++) {\r\n                defines.push(this._options.defines[index]);\r\n            }\r\n        }\r\n\r\n        const join = defines.join(\"\\n\");\r\n\r\n        if (this._cachedDefines !== join) {\r\n            this._cachedDefines = join;\r\n\r\n            effect = this._engine.createComputeEffect(shaderName, <IComputeEffectCreationOptions>{\r\n                defines: join,\r\n                entryPoint: this._options.entryPoint,\r\n                onCompiled: this.onCompiled,\r\n                onError: this.onError,\r\n            });\r\n\r\n            this._effect = effect;\r\n        }\r\n\r\n        if (!effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispatches (executes) the compute shader\r\n     * @param x Number of workgroups to execute on the X dimension\r\n     * @param y Number of workgroups to execute on the Y dimension (default: 1)\r\n     * @param z Number of workgroups to execute on the Z dimension (default: 1)\r\n     * @returns True if the dispatch could be done, else false (meaning either the compute effect or at least one of the bound resources was not ready)\r\n     */\r\n    public dispatch(x: number, y?: number, z?: number): boolean {\r\n        if (!this.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        // If the sampling parameters of a texture bound to the shader have changed, we must clear the compute context so that it is recreated with the updated values\r\n        // Also, if the actual (gpu) buffer used by a uniform buffer has changed, we must clear the compute context so that it is recreated with the updated value\r\n        for (const key in this._bindings) {\r\n            const binding = this._bindings[key];\r\n\r\n            if (!this._options.bindingsMapping[key]) {\r\n                throw new Error(\"ComputeShader ('\" + this.name + \"'): No binding mapping has been provided for the property '\" + key + \"'\");\r\n            }\r\n\r\n            switch (binding.type) {\r\n                case ComputeBindingType.Texture: {\r\n                    const sampler = this._samplers[key];\r\n                    const texture = binding.object as BaseTexture;\r\n\r\n                    if (!sampler || !texture._texture || !sampler.compareSampler(texture._texture)) {\r\n                        this._samplers[key] = new TextureSampler().setParameters(\r\n                            texture.wrapU,\r\n                            texture.wrapV,\r\n                            texture.wrapR,\r\n                            texture.anisotropicFilteringLevel,\r\n                            texture._texture!.samplingMode,\r\n                            texture._texture?._comparisonFunction\r\n                        );\r\n                        this._contextIsDirty = true;\r\n                    }\r\n                    break;\r\n                }\r\n                case ComputeBindingType.ExternalTexture: {\r\n                    // we must recreate the bind groups each time if there's an external texture, because device.importExternalTexture must be called each frame\r\n                    this._contextIsDirty = true;\r\n                    break;\r\n                }\r\n                case ComputeBindingType.UniformBuffer: {\r\n                    const ubo = binding.object as UniformBuffer;\r\n                    if (ubo.getBuffer() !== binding.buffer) {\r\n                        binding.buffer = ubo.getBuffer();\r\n                        this._contextIsDirty = true;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._contextIsDirty) {\r\n            this._contextIsDirty = false;\r\n            this._context.clear();\r\n        }\r\n\r\n        this._engine.computeDispatch(this._effect, this._context, this._bindings, x, y, z, this._options.bindingsMapping);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Waits for the compute shader to be ready and executes it\r\n     * @param x Number of workgroups to execute on the X dimension\r\n     * @param y Number of workgroups to execute on the Y dimension (default: 1)\r\n     * @param z Number of workgroups to execute on the Z dimension (default: 1)\r\n     * @param delay Delay between the retries while the shader is not ready (in milliseconds - 10 by default)\r\n     * @returns A promise that is resolved once the shader has been sent to the GPU. Note that it does not mean that the shader execution itself is finished!\r\n     */\r\n    public dispatchWhenReady(x: number, y?: number, z?: number, delay = 10): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            const check = () => {\r\n                if (!this.dispatch(x, y, z)) {\r\n                    setTimeout(check, delay);\r\n                } else {\r\n                    resolve();\r\n                }\r\n            };\r\n\r\n            check();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Serializes this compute shader in a JSON representation\r\n     * @returns the serialized compute shader object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        serializationObject.options = this._options;\r\n        serializationObject.shaderPath = this._shaderPath;\r\n        serializationObject.bindings = {};\r\n        serializationObject.textures = {};\r\n\r\n        for (const key in this._bindings) {\r\n            const binding = this._bindings[key];\r\n            const object = binding.object;\r\n\r\n            switch (binding.type) {\r\n                case ComputeBindingType.Texture:\r\n                case ComputeBindingType.TextureWithoutSampler:\r\n                case ComputeBindingType.StorageTexture: {\r\n                    const serializedData = (object as BaseTexture).serialize();\r\n                    if (serializedData) {\r\n                        serializationObject.textures[key] = serializedData;\r\n                        serializationObject.bindings[key] = {\r\n                            type: binding.type,\r\n                        };\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                case ComputeBindingType.UniformBuffer: {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a compute shader from parsed compute shader data\r\n     * @param source defines the JSON representation of the compute shader\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new compute shader\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): ComputeShader {\r\n        const compute = SerializationHelper.Parse(() => new ComputeShader(source.name, scene.getEngine(), source.shaderPath, source.options), source, scene, rootUrl);\r\n\r\n        for (const key in source.textures) {\r\n            const binding = source.bindings[key];\r\n            const texture = <Texture>Texture.Parse(source.textures[key], scene, rootUrl);\r\n\r\n            if (binding.type === ComputeBindingType.Texture) {\r\n                compute.setTexture(key, texture);\r\n            } else if (binding.type === ComputeBindingType.TextureWithoutSampler) {\r\n                compute.setTexture(key, texture, false);\r\n            } else {\r\n                compute.setStorageTexture(key, texture);\r\n            }\r\n        }\r\n\r\n        return compute;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ComputeShader\", ComputeShader);\r\n"],"mappings":";;AAIA,SAASA,mBAAmB,EAAEC,SAAS,QAAQ,uBAAqB;AACpE,SAASC,aAAa,QAAQ,sBAAoB;AAGlD,SAASC,kBAAkB,QAAQ,+CAA6C;AAEhF,SAASC,OAAO,QAAQ,kCAAgC;AACxD,SAASC,iBAAiB,QAAQ,8BAA4B;AAG9D,SAASC,MAAM,QAAQ,mBAAiB;AACxC,SAASC,cAAc,QAAQ,yCAAuC;AAkCtE;;;AAGA,OAAM,MAAOC,aAAa;EAsBtB;;;EAGA,IAAWC,OAAOA,CAAA;IACd,OAAO,IAAI,CAACC,QAAQ;EACxB;EAEA;;;EAGA,IAAWC,UAAUA,CAAA;IACjB,OAAO,IAAI,CAACC,WAAW;EAC3B;EAYA;;;;;;;;;;;EAWAC,YAAYC,IAAY,EAAEC,MAAkB,EAAEJ,UAAe,EAAEF,OAAA,GAA0C,EAAE;IAnDnG,KAAAO,SAAS,GAA+B,EAAE;IAC1C,KAAAC,SAAS,GAAsC,EAAE;IAEjD,KAAAC,eAAe,GAAG,KAAK;IA2B/B;;;IAGO,KAAAC,UAAU,GAA8C,IAAI;IAEnE;;;IAGO,KAAAC,OAAO,GAA8D,IAAI;IAc5E,IAAI,CAACN,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACO,OAAO,GAAGN,MAAM;IACrB,IAAI,CAACO,QAAQ,GAAGjB,iBAAiB,CAACkB,QAAQ;IAE1C,IAAI,CAAC,IAAI,CAACF,OAAO,CAACG,OAAO,EAAE,CAACC,qBAAqB,EAAE;MAC/CnB,MAAM,CAACoB,KAAK,CAAC,+CAA+C,CAAC;MAC7D;;IAEJ,IAAI,CAACjB,OAAO,CAACkB,eAAe,EAAE;MAC1BrB,MAAM,CAACoB,KAAK,CAAC,kGAAkG,CAAC;MAChH;;IAGJ,IAAI,CAACE,QAAQ,GAAGb,MAAM,CAACc,oBAAoB,EAAG;IAC9C,IAAI,CAACjB,WAAW,GAAGD,UAAU;IAC7B,IAAI,CAACD,QAAQ,GAAAoB,MAAA,CAAAC,MAAA;MACTJ,eAAe,EAAE,EAAE;MACnBK,OAAO,EAAE;IAAE,GACRvB,OAAO,CACb;EACL;EAEA;;;;;EAKOwB,YAAYA,CAAA;IACf,OAAO,eAAe;EAC1B;EAEA;;;;;;EAMOC,UAAUA,CAACpB,IAAY,EAAEqB,OAAoB,EAAEC,WAAW,GAAG,IAAI;IACpE,MAAMC,OAAO,GAAG,IAAI,CAACrB,SAAS,CAACF,IAAI,CAAC;IAEpC,IAAI,CAACE,SAAS,CAACF,IAAI,CAAC,GAAG;MACnBwB,IAAI,EAAEF,WAAW,GAAGjC,kBAAkB,CAACC,OAAO,GAAGD,kBAAkB,CAACoC,qBAAqB;MACzFC,MAAM,EAAEL,OAAO;MACfM,mBAAmB,EAAEJ,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEI;KACjC;IAED,IAAI,CAACvB,eAAe,KAApB,IAAI,CAACA,eAAe,GAAK,CAACmB,OAAO,IAAIA,OAAO,CAACG,MAAM,KAAKL,OAAO,IAAIE,OAAO,CAACC,IAAI,KAAK,IAAI,CAACtB,SAAS,CAACF,IAAI,CAAC,CAACwB,IAAI;EACjH;EAEA;;;;;EAKOI,iBAAiBA,CAAC5B,IAAY,EAAEqB,OAAoB;IACvD,MAAME,OAAO,GAAG,IAAI,CAACrB,SAAS,CAACF,IAAI,CAAC;IAEpC,IAAI,CAACI,eAAe,KAApB,IAAI,CAACA,eAAe,GAAK,CAACmB,OAAO,IAAIA,OAAO,CAACG,MAAM,KAAKL,OAAO;IAE/D,IAAI,CAACnB,SAAS,CAACF,IAAI,CAAC,GAAG;MACnBwB,IAAI,EAAEnC,kBAAkB,CAACwC,cAAc;MACvCH,MAAM,EAAEL,OAAO;MACfM,mBAAmB,EAAEJ,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEI;KACjC;EACL;EAEA;;;;;EAKOG,kBAAkBA,CAAC9B,IAAY,EAAEqB,OAAwB;IAC5D,MAAME,OAAO,GAAG,IAAI,CAACrB,SAAS,CAACF,IAAI,CAAC;IAEpC,IAAI,CAACI,eAAe,KAApB,IAAI,CAACA,eAAe,GAAK,CAACmB,OAAO,IAAIA,OAAO,CAACG,MAAM,KAAKL,OAAO;IAE/D,IAAI,CAACnB,SAAS,CAACF,IAAI,CAAC,GAAG;MACnBwB,IAAI,EAAEnC,kBAAkB,CAAC0C,eAAe;MACxCL,MAAM,EAAEL,OAAO;MACfM,mBAAmB,EAAEJ,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEI;KACjC;EACL;EAEA;;;;;;EAMOK,eAAeA,CAAChC,IAAY,EAAEqB,OAAqB;IACtD,IAAIA,OAAO,CAACY,eAAe,EAAE;MACzB,IAAI,CAACH,kBAAkB,CAAC9B,IAAI,EAAEqB,OAAO,CAACY,eAAe,CAAC;MACtD,OAAO,IAAI;;IAGf,OAAO,KAAK;EAChB;EAEA;;;;;EAKOC,gBAAgBA,CAAClC,IAAY,EAAEmC,MAAqB;IACvD,MAAMZ,OAAO,GAAG,IAAI,CAACrB,SAAS,CAACF,IAAI,CAAC;IAEpC,IAAI,CAACI,eAAe,KAApB,IAAI,CAACA,eAAe,GAAK,CAACmB,OAAO,IAAIA,OAAO,CAACG,MAAM,KAAKS,MAAM;IAE9D,IAAI,CAACjC,SAAS,CAACF,IAAI,CAAC,GAAG;MACnBwB,IAAI,EAAEnC,kBAAkB,CAAC+C,aAAa;MACtCV,MAAM,EAAES,MAAM;MACdR,mBAAmB,EAAEJ,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEI;KACjC;EACL;EAEA;;;;;EAKOU,gBAAgBA,CAACrC,IAAY,EAAEmC,MAAqB;IACvD,MAAMZ,OAAO,GAAG,IAAI,CAACrB,SAAS,CAACF,IAAI,CAAC;IAEpC,IAAI,CAACI,eAAe,KAApB,IAAI,CAACA,eAAe,GAAK,CAACmB,OAAO,IAAIA,OAAO,CAACG,MAAM,KAAKS,MAAM;IAE9D,IAAI,CAACjC,SAAS,CAACF,IAAI,CAAC,GAAG;MACnBwB,IAAI,EAAEnC,kBAAkB,CAACiD,aAAa;MACtCZ,MAAM,EAAES,MAAM;MACdR,mBAAmB,EAAEJ,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEI;KACjC;EACL;EAEA;;;;;EAKOY,iBAAiBA,CAACvC,IAAY,EAAEwC,OAAuB;IAC1D,MAAMjB,OAAO,GAAG,IAAI,CAACrB,SAAS,CAACF,IAAI,CAAC;IAEpC,IAAI,CAACI,eAAe,KAApB,IAAI,CAACA,eAAe,GAAK,CAACmB,OAAO,IAAI,CAACiB,OAAO,CAACC,cAAc,CAAClB,OAAO,CAACG,MAAM,CAAC;IAE5E,IAAI,CAACxB,SAAS,CAACF,IAAI,CAAC,GAAG;MACnBwB,IAAI,EAAEnC,kBAAkB,CAACqD,OAAO;MAChChB,MAAM,EAAEc,OAAO;MACfb,mBAAmB,EAAEJ,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEI;KACjC;EACL;EAEA;;;;EAIOgB,OAAOA,CAAA;IACV,IAAIC,MAAM,GAAG,IAAI,CAACC,OAAO;IAEzB,KAAK,MAAMC,GAAG,IAAI,IAAI,CAAC5C,SAAS,EAAE;MAC9B,MAAM6C,OAAO,GAAG,IAAI,CAAC7C,SAAS,CAAC4C,GAAG,CAAC;QAC/BtB,IAAI,GAAGuB,OAAO,CAACvB,IAAI;QACnBE,MAAM,GAAGqB,OAAO,CAACrB,MAAM;MAE3B,QAAQF,IAAI;QACR,KAAKnC,kBAAkB,CAACC,OAAO;QAC/B,KAAKD,kBAAkB,CAACoC,qBAAqB;QAC7C,KAAKpC,kBAAkB,CAACwC,cAAc;UAAE;YACpC,MAAMR,OAAO,GAAGK,MAAqB;YACrC,IAAI,CAACL,OAAO,CAACsB,OAAO,EAAE,EAAE;cACpB,OAAO,KAAK;;YAEhB;;QAEJ,KAAKtD,kBAAkB,CAAC0C,eAAe;UAAE;YACrC,MAAMV,OAAO,GAAGK,MAAyB;YACzC,IAAI,CAACL,OAAO,CAACsB,OAAO,EAAE,EAAE;cACpB,OAAO,KAAK;;YAEhB;;;;IAKZ,MAAMzB,OAAO,GAAG,EAAE;IAElB,MAAM8B,UAAU,GAAG,IAAI,CAAClD,WAAW;IAEnC,IAAI,IAAI,CAACF,QAAQ,CAACsB,OAAO,EAAE;MACvB,KAAK,IAAI+B,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,IAAI,CAACrD,QAAQ,CAACsB,OAAO,CAACgC,MAAM,EAAED,KAAK,EAAE,EAAE;QAC/D/B,OAAO,CAACiC,IAAI,CAAC,IAAI,CAACvD,QAAQ,CAACsB,OAAO,CAAC+B,KAAK,CAAC,CAAC;;;IAIlD,MAAMG,IAAI,GAAGlC,OAAO,CAACkC,IAAI,CAAC,IAAI,CAAC;IAE/B,IAAI,IAAI,CAACC,cAAc,KAAKD,IAAI,EAAE;MAC9B,IAAI,CAACC,cAAc,GAAGD,IAAI;MAE1BR,MAAM,GAAG,IAAI,CAACrC,OAAO,CAAC+C,mBAAmB,CAACN,UAAU,EAAiC;QACjF9B,OAAO,EAAEkC,IAAI;QACbG,UAAU,EAAE,IAAI,CAAC3D,QAAQ,CAAC2D,UAAU;QACpClD,UAAU,EAAE,IAAI,CAACA,UAAU;QAC3BC,OAAO,EAAE,IAAI,CAACA;OACjB,CAAC;MAEF,IAAI,CAACuC,OAAO,GAAGD,MAAM;;IAGzB,IAAI,CAACA,MAAM,CAACD,OAAO,EAAE,EAAE;MACnB,OAAO,KAAK;;IAGhB,OAAO,IAAI;EACf;EAEA;;;;;;;EAOOa,QAAQA,CAACC,CAAS,EAAEC,CAAU,EAAEC,CAAU;;IAC7C,IAAI,CAAC,IAAI,CAAChB,OAAO,EAAE,EAAE;MACjB,OAAO,KAAK;;IAGhB;IACA;IACA,KAAK,MAAMG,GAAG,IAAI,IAAI,CAAC5C,SAAS,EAAE;MAC9B,MAAM6C,OAAO,GAAG,IAAI,CAAC7C,SAAS,CAAC4C,GAAG,CAAC;MAEnC,IAAI,CAAC,IAAI,CAAClD,QAAQ,CAACiB,eAAe,CAACiC,GAAG,CAAC,EAAE;QACrC,MAAM,IAAIlC,KAAK,CAAC,kBAAkB,GAAG,IAAI,CAACZ,IAAI,GAAG,6DAA6D,GAAG8C,GAAG,GAAG,GAAG,CAAC;;MAG/H,QAAQC,OAAO,CAACvB,IAAI;QAChB,KAAKnC,kBAAkB,CAACC,OAAO;UAAE;YAC7B,MAAMkD,OAAO,GAAG,IAAI,CAACrC,SAAS,CAAC2C,GAAG,CAAC;YACnC,MAAMzB,OAAO,GAAG0B,OAAO,CAACrB,MAAqB;YAE7C,IAAI,CAACc,OAAO,IAAI,CAACnB,OAAO,CAACuC,QAAQ,IAAI,CAACpB,OAAO,CAACC,cAAc,CAACpB,OAAO,CAACuC,QAAQ,CAAC,EAAE;cAC5E,IAAI,CAACzD,SAAS,CAAC2C,GAAG,CAAC,GAAG,IAAIrD,cAAc,EAAE,CAACoE,aAAa,CACpDxC,OAAO,CAACyC,KAAK,EACbzC,OAAO,CAAC0C,KAAK,EACb1C,OAAO,CAAC2C,KAAK,EACb3C,OAAO,CAAC4C,yBAAyB,EACjC5C,OAAO,CAACuC,QAAS,CAACM,YAAY,EAC9B,CAAAC,EAAA,GAAA9C,OAAO,CAACuC,QAAQ,cAAAO,EAAA,uBAAAA,EAAA,CAAEC,mBAAmB,CACxC;cACD,IAAI,CAAChE,eAAe,GAAG,IAAI;;YAE/B;;QAEJ,KAAKf,kBAAkB,CAAC0C,eAAe;UAAE;YACrC;YACA,IAAI,CAAC3B,eAAe,GAAG,IAAI;YAC3B;;QAEJ,KAAKf,kBAAkB,CAAC+C,aAAa;UAAE;YACnC,MAAMiC,GAAG,GAAGtB,OAAO,CAACrB,MAAuB;YAC3C,IAAI2C,GAAG,CAACC,SAAS,EAAE,KAAKvB,OAAO,CAACZ,MAAM,EAAE;cACpCY,OAAO,CAACZ,MAAM,GAAGkC,GAAG,CAACC,SAAS,EAAE;cAChC,IAAI,CAAClE,eAAe,GAAG,IAAI;;YAE/B;;;;IAKZ,IAAI,IAAI,CAACA,eAAe,EAAE;MACtB,IAAI,CAACA,eAAe,GAAG,KAAK;MAC5B,IAAI,CAACU,QAAQ,CAACyD,KAAK,EAAE;;IAGzB,IAAI,CAAChE,OAAO,CAACiE,eAAe,CAAC,IAAI,CAAC3B,OAAO,EAAE,IAAI,CAAC/B,QAAQ,EAAE,IAAI,CAACZ,SAAS,EAAEuD,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE,IAAI,CAAC/D,QAAQ,CAACiB,eAAe,CAAC;IAEjH,OAAO,IAAI;EACf;EAEA;;;;;;;;EAQO4D,iBAAiBA,CAAChB,CAAS,EAAEC,CAAU,EAAEC,CAAU,EAAEe,KAAK,GAAG,EAAE;IAClE,OAAO,IAAIC,OAAO,CAAEC,OAAO,IAAI;MAC3B,MAAMC,KAAK,GAAGA,CAAA,KAAK;QACf,IAAI,CAAC,IAAI,CAACrB,QAAQ,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,EAAE;UACzBmB,UAAU,CAACD,KAAK,EAAEH,KAAK,CAAC;SAC3B,MAAM;UACHE,OAAO,EAAE;;MAEjB,CAAC;MAEDC,KAAK,EAAE;IACX,CAAC,CAAC;EACN;EAEA;;;;EAIO1F,SAASA,CAAA;IACZ,MAAM4F,mBAAmB,GAAG7F,mBAAmB,CAAC8F,SAAS,CAAC,IAAI,CAAC;IAE/DD,mBAAmB,CAACpF,OAAO,GAAG,IAAI,CAACC,QAAQ;IAC3CmF,mBAAmB,CAAClF,UAAU,GAAG,IAAI,CAACC,WAAW;IACjDiF,mBAAmB,CAACE,QAAQ,GAAG,EAAE;IACjCF,mBAAmB,CAACG,QAAQ,GAAG,EAAE;IAEjC,KAAK,MAAMpC,GAAG,IAAI,IAAI,CAAC5C,SAAS,EAAE;MAC9B,MAAM6C,OAAO,GAAG,IAAI,CAAC7C,SAAS,CAAC4C,GAAG,CAAC;MACnC,MAAMpB,MAAM,GAAGqB,OAAO,CAACrB,MAAM;MAE7B,QAAQqB,OAAO,CAACvB,IAAI;QAChB,KAAKnC,kBAAkB,CAACC,OAAO;QAC/B,KAAKD,kBAAkB,CAACoC,qBAAqB;QAC7C,KAAKpC,kBAAkB,CAACwC,cAAc;UAAE;YACpC,MAAMsD,cAAc,GAAIzD,MAAsB,CAACvC,SAAS,EAAE;YAC1D,IAAIgG,cAAc,EAAE;cAChBJ,mBAAmB,CAACG,QAAQ,CAACpC,GAAG,CAAC,GAAGqC,cAAc;cAClDJ,mBAAmB,CAACE,QAAQ,CAACnC,GAAG,CAAC,GAAG;gBAChCtB,IAAI,EAAEuB,OAAO,CAACvB;eACjB;;YAEL;;QAGJ,KAAKnC,kBAAkB,CAAC+C,aAAa;UAAE;YACnC;;;;IAKZ,OAAO2C,mBAAmB;EAC9B;EAEA;;;;;;;EAOO,OAAOK,KAAKA,CAACC,MAAW,EAAEC,KAAY,EAAEC,OAAe;IAC1D,MAAMC,OAAO,GAAGtG,mBAAmB,CAACkG,KAAK,CAAC,MAAM,IAAI1F,aAAa,CAAC2F,MAAM,CAACrF,IAAI,EAAEsF,KAAK,CAACG,SAAS,EAAE,EAAEJ,MAAM,CAACxF,UAAU,EAAEwF,MAAM,CAAC1F,OAAO,CAAC,EAAE0F,MAAM,EAAEC,KAAK,EAAEC,OAAO,CAAC;IAE7J,KAAK,MAAMzC,GAAG,IAAIuC,MAAM,CAACH,QAAQ,EAAE;MAC/B,MAAMnC,OAAO,GAAGsC,MAAM,CAACJ,QAAQ,CAACnC,GAAG,CAAC;MACpC,MAAMzB,OAAO,GAAY/B,OAAO,CAAC8F,KAAK,CAACC,MAAM,CAACH,QAAQ,CAACpC,GAAG,CAAC,EAAEwC,KAAK,EAAEC,OAAO,CAAC;MAE5E,IAAIxC,OAAO,CAACvB,IAAI,KAAKnC,kBAAkB,CAACC,OAAO,EAAE;QAC7CkG,OAAO,CAACpE,UAAU,CAAC0B,GAAG,EAAEzB,OAAO,CAAC;OACnC,MAAM,IAAI0B,OAAO,CAACvB,IAAI,KAAKnC,kBAAkB,CAACoC,qBAAqB,EAAE;QAClE+D,OAAO,CAACpE,UAAU,CAAC0B,GAAG,EAAEzB,OAAO,EAAE,KAAK,CAAC;OAC1C,MAAM;QACHmE,OAAO,CAAC5D,iBAAiB,CAACkB,GAAG,EAAEzB,OAAO,CAAC;;;IAI/C,OAAOmE,OAAO;EAClB;;AAjZOE,UAAA,EADNvG,SAAS,EAAE,C,0CACQ;AAoZxBC,aAAa,CAAC,uBAAuB,EAAEM,aAAa,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}