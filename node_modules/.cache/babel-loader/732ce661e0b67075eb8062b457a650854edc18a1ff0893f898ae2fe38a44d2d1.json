{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { WebXRControllerComponent } from \"../motionController/webXRControllerComponent.js\";\nimport { Vector3, Quaternion } from \"../../Maths/math.vector.js\";\nimport { Ray } from \"../../Culling/ray.js\";\nimport { DynamicTexture } from \"../../Materials/Textures/dynamicTexture.js\";\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder.js\";\nimport { SineEase, EasingFunction } from \"../../Animations/easing.js\";\nimport { Animation } from \"../../Animations/animation.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { StandardMaterial } from \"../../Materials/standardMaterial.js\";\nimport { CreateGround } from \"../../Meshes/Builders/groundBuilder.js\";\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder.js\";\nimport { Curve3 } from \"../../Maths/math.path.js\";\nimport { CreateLines } from \"../../Meshes/Builders/linesBuilder.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Color3, Color4 } from \"../../Maths/math.color.js\";\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { setAndStartTimer } from \"../../Misc/timer.js\";\n/**\n * This is a teleportation feature to be used with WebXR-enabled motion controllers.\n * When enabled and attached, the feature will allow a user to move around and rotate in the scene using\n * the input of the attached controllers.\n */\nexport class WebXRMotionControllerTeleportation extends WebXRAbstractFeature {\n  /**\n   * Is rotation enabled when moving forward?\n   * Disabling this feature will prevent the user from deciding the direction when teleporting\n   */\n  get rotationEnabled() {\n    return this._rotationEnabled;\n  }\n  /**\n   * Sets whether rotation is enabled or not\n   * @param enabled is rotation enabled when teleportation is shown\n   */\n  set rotationEnabled(enabled) {\n    this._rotationEnabled = enabled;\n    if (this._options.teleportationTargetMesh) {\n      const children = this._options.teleportationTargetMesh.getChildMeshes(false, node => node.name === \"rotationCone\");\n      if (children[0]) {\n        children[0].setEnabled(enabled);\n      }\n    }\n  }\n  /**\n   * Exposes the currently set teleportation target mesh.\n   */\n  get teleportationTargetMesh() {\n    return this._options.teleportationTargetMesh || null;\n  }\n  /**\n   * constructs a new teleportation system\n   * @param _xrSessionManager an instance of WebXRSessionManager\n   * @param _options configuration object for this feature\n   */\n  constructor(_xrSessionManager, _options) {\n    super(_xrSessionManager);\n    this._options = _options;\n    this._controllers = {};\n    this._snappedToPoint = false;\n    this._cachedColor4White = new Color4(1, 1, 1, 1);\n    this._tmpRay = new Ray(new Vector3(), new Vector3());\n    this._tmpVector = new Vector3();\n    this._tmpQuaternion = new Quaternion();\n    /**\n     * Skip the next teleportation. This can be controlled by the user to prevent the user from teleportation\n     * to sections that are not yet \"unlocked\", but should still show the teleportation mesh.\n     */\n    this.skipNextTeleportation = false;\n    /**\n     * Is movement backwards enabled\n     */\n    this.backwardsMovementEnabled = true;\n    /**\n     * Distance to travel when moving backwards\n     */\n    this.backwardsTeleportationDistance = 0.7;\n    /**\n     * The distance from the user to the inspection point in the direction of the controller\n     * A higher number will allow the user to move further\n     * defaults to 5 (meters, in xr units)\n     */\n    this.parabolicCheckRadius = 5;\n    /**\n     * Should the module support parabolic ray on top of direct ray\n     * If enabled, the user will be able to point \"at the sky\" and move according to predefined radius distance\n     * Very helpful when moving between floors / different heights\n     */\n    this.parabolicRayEnabled = true;\n    /**\n     * The second type of ray - straight line.\n     * Should it be enabled or should the parabolic line be the only one.\n     */\n    this.straightRayEnabled = true;\n    /**\n     * How much rotation should be applied when rotating right and left\n     */\n    this.rotationAngle = Math.PI / 8;\n    /**\n     * This observable will notify when the target mesh position was updated.\n     * The picking info it provides contains the point to which the target mesh will move ()\n     */\n    this.onTargetMeshPositionUpdatedObservable = new Observable();\n    /**\n     * Is teleportation enabled. Can be used to allow rotation only.\n     */\n    this.teleportationEnabled = true;\n    this._rotationEnabled = true;\n    this._attachController = xrController => {\n      if (this._controllers[xrController.uniqueId] || this._options.forceHandedness && xrController.inputSource.handedness !== this._options.forceHandedness) {\n        // already attached\n        return;\n      }\n      this._controllers[xrController.uniqueId] = {\n        xrController,\n        teleportationState: {\n          forward: false,\n          backwards: false,\n          rotating: false,\n          currentRotation: 0,\n          baseRotation: 0,\n          blocked: false\n        }\n      };\n      const controllerData = this._controllers[xrController.uniqueId];\n      // motion controller only available to gamepad-enabled input sources.\n      if (controllerData.xrController.inputSource.targetRayMode === \"tracked-pointer\" && controllerData.xrController.inputSource.gamepad) {\n        // motion controller support\n        const initMotionController = () => {\n          if (xrController.motionController) {\n            const movementController = xrController.motionController.getComponentOfType(WebXRControllerComponent.THUMBSTICK_TYPE) || xrController.motionController.getComponentOfType(WebXRControllerComponent.TOUCHPAD_TYPE);\n            if (!movementController || this._options.useMainComponentOnly) {\n              // use trigger to move on long press\n              const mainComponent = xrController.motionController.getMainComponent();\n              if (!mainComponent) {\n                return;\n              }\n              controllerData.teleportationComponent = mainComponent;\n              controllerData.onButtonChangedObserver = mainComponent.onButtonStateChangedObservable.add(() => {\n                if (!this.teleportationEnabled) {\n                  return;\n                }\n                // did \"pressed\" changed?\n                if (mainComponent.changes.pressed) {\n                  if (mainComponent.changes.pressed.current) {\n                    // simulate \"forward\" thumbstick push\n                    controllerData.teleportationState.forward = true;\n                    this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\n                    controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\n                    controllerData.teleportationState.currentRotation = 0;\n                    const timeToSelect = this._options.timeToTeleport || 3000;\n                    setAndStartTimer({\n                      timeout: timeToSelect,\n                      contextObservable: this._xrSessionManager.onXRFrameObservable,\n                      breakCondition: () => !mainComponent.pressed,\n                      onEnded: () => {\n                        if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\n                          this._teleportForward(xrController.uniqueId);\n                        }\n                      }\n                    });\n                  } else {\n                    controllerData.teleportationState.forward = false;\n                    this._currentTeleportationControllerId = \"\";\n                  }\n                }\n              });\n            } else {\n              controllerData.teleportationComponent = movementController;\n              // use thumbstick (or touchpad if thumbstick not available)\n              controllerData.onAxisChangedObserver = movementController.onAxisValueChangedObservable.add(axesData => {\n                if (axesData.y <= 0.7 && controllerData.teleportationState.backwards) {\n                  controllerData.teleportationState.backwards = false;\n                }\n                if (axesData.y > 0.7 && !controllerData.teleportationState.forward && this.backwardsMovementEnabled && !this.snapPointsOnly) {\n                  // teleport backwards\n                  // General gist: Go Back N units, cast a ray towards the floor. If collided, move.\n                  if (!controllerData.teleportationState.backwards) {\n                    controllerData.teleportationState.backwards = true;\n                    // teleport backwards ONCE\n                    this._tmpQuaternion.copyFrom(this._options.xrInput.xrCamera.rotationQuaternion);\n                    this._tmpQuaternion.toEulerAnglesToRef(this._tmpVector);\n                    // get only the y rotation\n                    this._tmpVector.x = 0;\n                    this._tmpVector.z = 0;\n                    // get the quaternion\n                    Quaternion.FromEulerVectorToRef(this._tmpVector, this._tmpQuaternion);\n                    this._tmpVector.set(0, 0, this.backwardsTeleportationDistance * (this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0));\n                    this._tmpVector.rotateByQuaternionToRef(this._tmpQuaternion, this._tmpVector);\n                    this._tmpVector.addInPlace(this._options.xrInput.xrCamera.position);\n                    this._tmpRay.origin.copyFrom(this._tmpVector);\n                    // This will prevent the user from \"falling\" to a lower platform!\n                    // TODO - should this be a flag? 'allow falling to lower platforms'?\n                    this._tmpRay.length = this._options.xrInput.xrCamera.realWorldHeight + 0.1;\n                    // Right handed system had here \"1\" instead of -1. This is unneeded.\n                    this._tmpRay.direction.set(0, -1, 0);\n                    const pick = this._xrSessionManager.scene.pickWithRay(this._tmpRay, o => {\n                      return this._floorMeshes.indexOf(o) !== -1;\n                    });\n                    // pick must exist, but stay safe\n                    if (pick && pick.pickedPoint) {\n                      // Teleport the users feet to where they targeted. Ignore the Y axis.\n                      // If the \"falling to lower platforms\" feature is implemented the Y axis should be set here as well\n                      this._options.xrInput.xrCamera.position.x = pick.pickedPoint.x;\n                      this._options.xrInput.xrCamera.position.z = pick.pickedPoint.z;\n                    }\n                  }\n                }\n                if (axesData.y < -0.7 && !this._currentTeleportationControllerId && !controllerData.teleportationState.rotating && this.teleportationEnabled) {\n                  controllerData.teleportationState.forward = true;\n                  this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\n                  controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\n                }\n                if (axesData.x) {\n                  if (!controllerData.teleportationState.forward) {\n                    if (!controllerData.teleportationState.rotating && Math.abs(axesData.x) > 0.7) {\n                      // rotate in the right direction positive is right\n                      controllerData.teleportationState.rotating = true;\n                      const rotation = this.rotationAngle * (axesData.x > 0 ? 1 : -1) * (this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);\n                      Quaternion.FromEulerAngles(0, rotation, 0).multiplyToRef(this._options.xrInput.xrCamera.rotationQuaternion, this._options.xrInput.xrCamera.rotationQuaternion);\n                    }\n                  } else {\n                    if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId) {\n                      // set the rotation of the forward movement\n                      if (this.rotationEnabled) {\n                        setTimeout(() => {\n                          controllerData.teleportationState.currentRotation = Math.atan2(axesData.x, axesData.y * (this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1));\n                        });\n                      } else {\n                        controllerData.teleportationState.currentRotation = 0;\n                      }\n                    }\n                  }\n                } else {\n                  controllerData.teleportationState.rotating = false;\n                }\n                if (axesData.x === 0 && axesData.y === 0) {\n                  if (controllerData.teleportationState.blocked) {\n                    controllerData.teleportationState.blocked = false;\n                    this._setTargetMeshVisibility(false);\n                  }\n                  if (controllerData.teleportationState.forward) {\n                    this._teleportForward(xrController.uniqueId);\n                  }\n                }\n              });\n            }\n          }\n        };\n        if (xrController.motionController) {\n          initMotionController();\n        } else {\n          xrController.onMotionControllerInitObservable.addOnce(() => {\n            initMotionController();\n          });\n        }\n      } else {\n        this._xrSessionManager.scene.onPointerObservable.add(pointerInfo => {\n          if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\n            controllerData.teleportationState.forward = true;\n            this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\n            controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\n            controllerData.teleportationState.currentRotation = 0;\n            const timeToSelect = this._options.timeToTeleport || 3000;\n            setAndStartTimer({\n              timeout: timeToSelect,\n              contextObservable: this._xrSessionManager.onXRFrameObservable,\n              onEnded: () => {\n                if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\n                  this._teleportForward(xrController.uniqueId);\n                }\n              }\n            });\n          } else if (pointerInfo.type === PointerEventTypes.POINTERUP) {\n            controllerData.teleportationState.forward = false;\n            this._currentTeleportationControllerId = \"\";\n          }\n        });\n      }\n    };\n    // create default mesh if not provided\n    if (!this._options.teleportationTargetMesh) {\n      this._createDefaultTargetMesh();\n    }\n    this._floorMeshes = this._options.floorMeshes || [];\n    this._snapToPositions = this._options.snapPositions || [];\n    this._blockedRayColor = this._options.blockedRayColor || new Color4(1, 0, 0, 0.75);\n    this._setTargetMeshVisibility(false);\n  }\n  /**\n   * Get the snapPointsOnly flag\n   */\n  get snapPointsOnly() {\n    return !!this._options.snapPointsOnly;\n  }\n  /**\n   * Sets the snapPointsOnly flag\n   * @param snapToPoints should teleportation be exclusively to snap points\n   */\n  set snapPointsOnly(snapToPoints) {\n    this._options.snapPointsOnly = snapToPoints;\n  }\n  /**\n   * Add a new mesh to the floor meshes array\n   * @param mesh the mesh to use as floor mesh\n   */\n  addFloorMesh(mesh) {\n    this._floorMeshes.push(mesh);\n  }\n  /**\n   * Add a mesh to the list of meshes blocking the teleportation ray\n   * @param mesh The mesh to add to the teleportation-blocking meshes\n   */\n  addBlockerMesh(mesh) {\n    this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];\n    this._options.pickBlockerMeshes.push(mesh);\n  }\n  /**\n   * Add a new snap-to point to fix teleportation to this position\n   * @param newSnapPoint The new Snap-To point\n   */\n  addSnapPoint(newSnapPoint) {\n    this._snapToPositions.push(newSnapPoint);\n  }\n  attach() {\n    if (!super.attach()) {\n      return false;\n    }\n    // Safety reset\n    this._currentTeleportationControllerId = \"\";\n    this._options.xrInput.controllers.forEach(this._attachController);\n    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\n    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, controller => {\n      // REMOVE the controller\n      this._detachController(controller.uniqueId);\n    });\n    return true;\n  }\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    Object.keys(this._controllers).forEach(controllerId => {\n      this._detachController(controllerId);\n    });\n    this._setTargetMeshVisibility(false);\n    this._currentTeleportationControllerId = \"\";\n    this._controllers = {};\n    return true;\n  }\n  dispose() {\n    super.dispose();\n    this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.dispose(false, true);\n  }\n  /**\n   * Remove a mesh from the floor meshes array\n   * @param mesh the mesh to remove\n   */\n  removeFloorMesh(mesh) {\n    const index = this._floorMeshes.indexOf(mesh);\n    if (index !== -1) {\n      this._floorMeshes.splice(index, 1);\n    }\n  }\n  /**\n   * Remove a mesh from the blocker meshes array\n   * @param mesh the mesh to remove\n   */\n  removeBlockerMesh(mesh) {\n    this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];\n    const index = this._options.pickBlockerMeshes.indexOf(mesh);\n    if (index !== -1) {\n      this._options.pickBlockerMeshes.splice(index, 1);\n    }\n  }\n  /**\n   * Remove a mesh from the floor meshes array using its name\n   * @param name the mesh name to remove\n   */\n  removeFloorMeshByName(name) {\n    const mesh = this._xrSessionManager.scene.getMeshByName(name);\n    if (mesh) {\n      this.removeFloorMesh(mesh);\n    }\n  }\n  /**\n   * This function will iterate through the array, searching for this point or equal to it. It will then remove it from the snap-to array\n   * @param snapPointToRemove the point (or a clone of it) to be removed from the array\n   * @returns was the point found and removed or not\n   */\n  removeSnapPoint(snapPointToRemove) {\n    // check if the object is in the array\n    let index = this._snapToPositions.indexOf(snapPointToRemove);\n    // if not found as an object, compare to the points\n    if (index === -1) {\n      for (let i = 0; i < this._snapToPositions.length; ++i) {\n        // equals? index is i, break the loop\n        if (this._snapToPositions[i].equals(snapPointToRemove)) {\n          index = i;\n          break;\n        }\n      }\n    }\n    // index is not -1? remove the object\n    if (index !== -1) {\n      this._snapToPositions.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * This function sets a selection feature that will be disabled when\n   * the forward ray is shown and will be reattached when hidden.\n   * This is used to remove the selection rays when moving.\n   * @param selectionFeature the feature to disable when forward movement is enabled\n   */\n  setSelectionFeature(selectionFeature) {\n    this._selectionFeature = selectionFeature;\n  }\n  _onXRFrame(_xrFrame) {\n    const frame = this._xrSessionManager.currentFrame;\n    const scene = this._xrSessionManager.scene;\n    if (!this.attach || !frame) {\n      return;\n    }\n    // render target if needed\n    const targetMesh = this._options.teleportationTargetMesh;\n    if (this._currentTeleportationControllerId) {\n      if (!targetMesh) {\n        return;\n      }\n      targetMesh.rotationQuaternion = targetMesh.rotationQuaternion || new Quaternion();\n      const controllerData = this._controllers[this._currentTeleportationControllerId];\n      if (controllerData && controllerData.teleportationState.forward) {\n        // set the rotation\n        Quaternion.RotationYawPitchRollToRef(controllerData.teleportationState.currentRotation + controllerData.teleportationState.baseRotation, 0, 0, targetMesh.rotationQuaternion);\n        // set the ray and position\n        let hitPossible = false;\n        controllerData.xrController.getWorldPointerRayToRef(this._tmpRay);\n        if (this.straightRayEnabled) {\n          // first check if direct ray possible\n          // pick grounds that are LOWER only. upper will use parabolic path\n          const pick = scene.pickWithRay(this._tmpRay, o => {\n            // check for mesh-blockers\n            if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {\n              return true;\n            }\n            const index = this._floorMeshes.indexOf(o);\n            if (index === -1) {\n              return false;\n            }\n            return this._floorMeshes[index].absolutePosition.y < this._options.xrInput.xrCamera.globalPosition.y;\n          });\n          if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {\n            controllerData.teleportationState.blocked = true;\n            this._setTargetMeshVisibility(false);\n            this._showParabolicPath(pick);\n            return;\n          } else if (pick && pick.pickedPoint) {\n            controllerData.teleportationState.blocked = false;\n            hitPossible = true;\n            this._setTargetMeshPosition(pick);\n            this._setTargetMeshVisibility(true);\n            this._showParabolicPath(pick);\n          }\n        }\n        // straight ray is still the main ray, but disabling the straight line will force parabolic line.\n        if (this.parabolicRayEnabled && !hitPossible) {\n          // radius compensation according to pointer rotation around X\n          const xRotation = controllerData.xrController.pointer.rotationQuaternion.toEulerAngles().x;\n          const compensation = 1 + (Math.PI / 2 - Math.abs(xRotation));\n          // check parabolic ray\n          const radius = this.parabolicCheckRadius * compensation;\n          this._tmpRay.origin.addToRef(this._tmpRay.direction.scale(radius * 2), this._tmpVector);\n          this._tmpVector.y = this._tmpRay.origin.y;\n          this._tmpRay.origin.addInPlace(this._tmpRay.direction.scale(radius));\n          this._tmpVector.subtractToRef(this._tmpRay.origin, this._tmpRay.direction);\n          this._tmpRay.direction.normalize();\n          const pick = scene.pickWithRay(this._tmpRay, o => {\n            // check for mesh-blockers\n            if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {\n              return true;\n            }\n            return this._floorMeshes.indexOf(o) !== -1;\n          });\n          if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {\n            controllerData.teleportationState.blocked = true;\n            this._setTargetMeshVisibility(false);\n            this._showParabolicPath(pick);\n            return;\n          } else if (pick && pick.pickedPoint) {\n            controllerData.teleportationState.blocked = false;\n            hitPossible = true;\n            this._setTargetMeshPosition(pick);\n            this._setTargetMeshVisibility(true);\n            this._showParabolicPath(pick);\n          }\n        }\n        // if needed, set visible:\n        this._setTargetMeshVisibility(hitPossible);\n      } else {\n        this._setTargetMeshVisibility(false);\n      }\n    } else {\n      this._disposeBezierCurve();\n      this._setTargetMeshVisibility(false);\n    }\n  }\n  _createDefaultTargetMesh() {\n    // set defaults\n    this._options.defaultTargetMeshOptions = this._options.defaultTargetMeshOptions || {};\n    const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._xrSessionManager.scene;\n    const teleportationTarget = CreateGround(\"teleportationTarget\", {\n      width: 2,\n      height: 2,\n      subdivisions: 2\n    }, sceneToRenderTo);\n    teleportationTarget.isPickable = false;\n    if (this._options.defaultTargetMeshOptions.teleportationCircleMaterial) {\n      teleportationTarget.material = this._options.defaultTargetMeshOptions.teleportationCircleMaterial;\n    } else {\n      const length = 512;\n      const dynamicTexture = new DynamicTexture(\"teleportationPlaneDynamicTexture\", length, sceneToRenderTo, true);\n      dynamicTexture.hasAlpha = true;\n      const context = dynamicTexture.getContext();\n      const centerX = length / 2;\n      const centerY = length / 2;\n      const radius = 200;\n      context.beginPath();\n      context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\n      context.fillStyle = this._options.defaultTargetMeshOptions.teleportationFillColor || \"#444444\";\n      context.fill();\n      context.lineWidth = 10;\n      context.strokeStyle = this._options.defaultTargetMeshOptions.teleportationBorderColor || \"#FFFFFF\";\n      context.stroke();\n      context.closePath();\n      dynamicTexture.update();\n      const teleportationCircleMaterial = new StandardMaterial(\"teleportationPlaneMaterial\", sceneToRenderTo);\n      teleportationCircleMaterial.diffuseTexture = dynamicTexture;\n      teleportationTarget.material = teleportationCircleMaterial;\n    }\n    const torus = CreateTorus(\"torusTeleportation\", {\n      diameter: 0.75,\n      thickness: 0.1,\n      tessellation: 20\n    }, sceneToRenderTo);\n    torus.isPickable = false;\n    torus.parent = teleportationTarget;\n    if (!this._options.defaultTargetMeshOptions.disableAnimation) {\n      const animationInnerCircle = new Animation(\"animationInnerCircle\", \"position.y\", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);\n      const keys = [];\n      keys.push({\n        frame: 0,\n        value: 0\n      });\n      keys.push({\n        frame: 30,\n        value: 0.4\n      });\n      keys.push({\n        frame: 60,\n        value: 0\n      });\n      animationInnerCircle.setKeys(keys);\n      const easingFunction = new SineEase();\n      easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\n      animationInnerCircle.setEasingFunction(easingFunction);\n      torus.animations = [];\n      torus.animations.push(animationInnerCircle);\n      sceneToRenderTo.beginAnimation(torus, 0, 60, true);\n    }\n    const cone = CreateCylinder(\"rotationCone\", {\n      diameterTop: 0,\n      tessellation: 4\n    }, sceneToRenderTo);\n    cone.isPickable = false;\n    cone.scaling.set(0.5, 0.12, 0.2);\n    cone.rotate(Axis.X, Math.PI / 2);\n    cone.position.z = 0.6;\n    cone.parent = torus;\n    if (this._options.defaultTargetMeshOptions.torusArrowMaterial) {\n      torus.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\n      cone.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\n    } else {\n      const torusConeMaterial = new StandardMaterial(\"torusConsMat\", sceneToRenderTo);\n      torusConeMaterial.disableLighting = !!this._options.defaultTargetMeshOptions.disableLighting;\n      if (torusConeMaterial.disableLighting) {\n        torusConeMaterial.emissiveColor = new Color3(0.3, 0.3, 1.0);\n      } else {\n        torusConeMaterial.diffuseColor = new Color3(0.3, 0.3, 1.0);\n      }\n      torusConeMaterial.alpha = 0.9;\n      torus.material = torusConeMaterial;\n      cone.material = torusConeMaterial;\n      this._teleportationRingMaterial = torusConeMaterial;\n    }\n    if (this._options.renderingGroupId !== undefined) {\n      teleportationTarget.renderingGroupId = this._options.renderingGroupId;\n      torus.renderingGroupId = this._options.renderingGroupId;\n      cone.renderingGroupId = this._options.renderingGroupId;\n    }\n    this._options.teleportationTargetMesh = teleportationTarget;\n    // hide the teleportation target mesh right after creating it.\n    this._setTargetMeshVisibility(false);\n  }\n  _detachController(xrControllerUniqueId) {\n    const controllerData = this._controllers[xrControllerUniqueId];\n    if (!controllerData) {\n      return;\n    }\n    if (controllerData.teleportationComponent) {\n      if (controllerData.onAxisChangedObserver) {\n        controllerData.teleportationComponent.onAxisValueChangedObservable.remove(controllerData.onAxisChangedObserver);\n      }\n      if (controllerData.onButtonChangedObserver) {\n        controllerData.teleportationComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\n      }\n    }\n    // remove from the map\n    delete this._controllers[xrControllerUniqueId];\n  }\n  _findClosestSnapPointWithRadius(realPosition, radius = this._options.snapToPositionRadius || 0.8) {\n    let closestPoint = null;\n    let closestDistance = Number.MAX_VALUE;\n    if (this._snapToPositions.length) {\n      const radiusSquared = radius * radius;\n      this._snapToPositions.forEach(position => {\n        const dist = Vector3.DistanceSquared(position, realPosition);\n        if (dist <= radiusSquared && dist < closestDistance) {\n          closestDistance = dist;\n          closestPoint = position;\n        }\n      });\n    }\n    return closestPoint;\n  }\n  _setTargetMeshPosition(pickInfo) {\n    const newPosition = pickInfo.pickedPoint;\n    if (!this._options.teleportationTargetMesh || !newPosition) {\n      return;\n    }\n    const snapPosition = this._findClosestSnapPointWithRadius(newPosition);\n    this._snappedToPoint = !!snapPosition;\n    if (this.snapPointsOnly && !this._snappedToPoint && this._teleportationRingMaterial) {\n      this._teleportationRingMaterial.diffuseColor.set(1.0, 0.3, 0.3);\n    } else if (this.snapPointsOnly && this._snappedToPoint && this._teleportationRingMaterial) {\n      this._teleportationRingMaterial.diffuseColor.set(0.3, 0.3, 1.0);\n    }\n    this._options.teleportationTargetMesh.position.copyFrom(snapPosition || newPosition);\n    this._options.teleportationTargetMesh.position.y += 0.01;\n    this.onTargetMeshPositionUpdatedObservable.notifyObservers(pickInfo);\n  }\n  _setTargetMeshVisibility(visible, force) {\n    if (!this._options.teleportationTargetMesh) {\n      return;\n    }\n    if (this._options.teleportationTargetMesh.isVisible === visible && !force) {\n      return;\n    }\n    this._options.teleportationTargetMesh.isVisible = visible;\n    this._options.teleportationTargetMesh.getChildren(undefined, false).forEach(m => {\n      m.isVisible = visible;\n    });\n    if (!visible) {\n      if (this._quadraticBezierCurve) {\n        this._quadraticBezierCurve.dispose();\n        this._quadraticBezierCurve = null;\n      }\n      if (this._selectionFeature) {\n        this._selectionFeature.attach();\n      }\n    } else {\n      if (this._selectionFeature) {\n        this._selectionFeature.detach();\n      }\n    }\n  }\n  _disposeBezierCurve() {\n    if (this._quadraticBezierCurve) {\n      this._quadraticBezierCurve.dispose();\n      this._quadraticBezierCurve = null;\n    }\n  }\n  _showParabolicPath(pickInfo) {\n    if (!pickInfo.pickedPoint || !this._currentTeleportationControllerId) {\n      return;\n    }\n    const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._xrSessionManager.scene;\n    const controllerData = this._controllers[this._currentTeleportationControllerId];\n    const quadraticBezierVectors = Curve3.CreateQuadraticBezier(controllerData.xrController.pointer.absolutePosition, pickInfo.ray.origin, pickInfo.pickedPoint, 25);\n    const color = controllerData.teleportationState.blocked ? this._blockedRayColor : undefined;\n    const colorsArray = new Array(26).fill(color || this._cachedColor4White);\n    if (!this._options.generateRayPathMesh) {\n      this._quadraticBezierCurve = CreateLines(\"teleportation path line\", {\n        points: quadraticBezierVectors.getPoints(),\n        instance: this._quadraticBezierCurve,\n        updatable: true,\n        colors: colorsArray\n      }, sceneToRenderTo);\n    } else {\n      this._quadraticBezierCurve = this._options.generateRayPathMesh(quadraticBezierVectors.getPoints(), pickInfo);\n    }\n    this._quadraticBezierCurve.isPickable = false;\n    if (this._options.renderingGroupId !== undefined) {\n      this._quadraticBezierCurve.renderingGroupId = this._options.renderingGroupId;\n    }\n  }\n  _teleportForward(controllerId) {\n    const controllerData = this._controllers[controllerId];\n    if (!controllerData || !controllerData.teleportationState.forward || !this.teleportationEnabled) {\n      return;\n    }\n    controllerData.teleportationState.forward = false;\n    this._currentTeleportationControllerId = \"\";\n    if (this.snapPointsOnly && !this._snappedToPoint) {\n      return;\n    }\n    if (this.skipNextTeleportation) {\n      this.skipNextTeleportation = false;\n      return;\n    }\n    // do the movement forward here\n    if (this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.isVisible) {\n      const height = this._options.xrInput.xrCamera.realWorldHeight;\n      this._options.xrInput.xrCamera.onBeforeCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\n      this._options.xrInput.xrCamera.position.copyFrom(this._options.teleportationTargetMesh.position);\n      this._options.xrInput.xrCamera.position.y += height;\n      Quaternion.FromEulerAngles(0, controllerData.teleportationState.currentRotation - (this._xrSessionManager.scene.useRightHandedSystem ? Math.PI : 0), 0).multiplyToRef(this._options.xrInput.xrCamera.rotationQuaternion, this._options.xrInput.xrCamera.rotationQuaternion);\n      this._options.xrInput.xrCamera.onAfterCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\n    }\n  }\n}\n/**\n * The module's name\n */\nWebXRMotionControllerTeleportation.Name = WebXRFeatureName.TELEPORTATION;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the webxr specs version\n */\nWebXRMotionControllerTeleportation.Version = 1;\nWebXRFeaturesManager.AddWebXRFeature(WebXRMotionControllerTeleportation.Name, (xrSessionManager, options) => {\n  return () => new WebXRMotionControllerTeleportation(xrSessionManager, options);\n}, WebXRMotionControllerTeleportation.Version, true);","map":{"version":3,"names":["WebXRFeaturesManager","WebXRFeatureName","Observable","WebXRControllerComponent","Vector3","Quaternion","Ray","DynamicTexture","CreateCylinder","SineEase","EasingFunction","Animation","Axis","StandardMaterial","CreateGround","CreateTorus","Curve3","CreateLines","WebXRAbstractFeature","Color3","Color4","UtilityLayerRenderer","PointerEventTypes","setAndStartTimer","WebXRMotionControllerTeleportation","rotationEnabled","_rotationEnabled","enabled","_options","teleportationTargetMesh","children","getChildMeshes","node","name","setEnabled","constructor","_xrSessionManager","_controllers","_snappedToPoint","_cachedColor4White","_tmpRay","_tmpVector","_tmpQuaternion","skipNextTeleportation","backwardsMovementEnabled","backwardsTeleportationDistance","parabolicCheckRadius","parabolicRayEnabled","straightRayEnabled","rotationAngle","Math","PI","onTargetMeshPositionUpdatedObservable","teleportationEnabled","_attachController","xrController","uniqueId","forceHandedness","inputSource","handedness","teleportationState","forward","backwards","rotating","currentRotation","baseRotation","blocked","controllerData","targetRayMode","gamepad","initMotionController","motionController","movementController","getComponentOfType","THUMBSTICK_TYPE","TOUCHPAD_TYPE","useMainComponentOnly","mainComponent","getMainComponent","teleportationComponent","onButtonChangedObserver","onButtonStateChangedObservable","add","changes","pressed","current","_currentTeleportationControllerId","xrInput","xrCamera","rotationQuaternion","toEulerAngles","y","timeToSelect","timeToTeleport","timeout","contextObservable","onXRFrameObservable","breakCondition","onEnded","_teleportForward","onAxisChangedObserver","onAxisValueChangedObservable","axesData","snapPointsOnly","copyFrom","toEulerAnglesToRef","x","z","FromEulerVectorToRef","set","scene","useRightHandedSystem","rotateByQuaternionToRef","addInPlace","position","origin","length","realWorldHeight","direction","pick","pickWithRay","o","_floorMeshes","indexOf","pickedPoint","abs","rotation","FromEulerAngles","multiplyToRef","setTimeout","atan2","_setTargetMeshVisibility","onMotionControllerInitObservable","addOnce","onPointerObservable","pointerInfo","type","POINTERDOWN","POINTERUP","_createDefaultTargetMesh","floorMeshes","_snapToPositions","snapPositions","_blockedRayColor","blockedRayColor","snapToPoints","addFloorMesh","mesh","push","addBlockerMesh","pickBlockerMeshes","addSnapPoint","newSnapPoint","attach","controllers","forEach","_addNewAttachObserver","onControllerAddedObservable","onControllerRemovedObservable","controller","_detachController","detach","Object","keys","controllerId","dispose","removeFloorMesh","index","splice","removeBlockerMesh","removeFloorMeshByName","getMeshByName","removeSnapPoint","snapPointToRemove","i","equals","setSelectionFeature","selectionFeature","_selectionFeature","_onXRFrame","_xrFrame","frame","currentFrame","targetMesh","RotationYawPitchRollToRef","hitPossible","getWorldPointerRayToRef","absolutePosition","globalPosition","pickedMesh","_showParabolicPath","_setTargetMeshPosition","xRotation","pointer","compensation","radius","addToRef","scale","subtractToRef","normalize","_disposeBezierCurve","defaultTargetMeshOptions","sceneToRenderTo","useUtilityLayer","customUtilityLayerScene","DefaultUtilityLayer","utilityLayerScene","teleportationTarget","width","height","subdivisions","isPickable","teleportationCircleMaterial","material","dynamicTexture","hasAlpha","context","getContext","centerX","centerY","beginPath","arc","fillStyle","teleportationFillColor","fill","lineWidth","strokeStyle","teleportationBorderColor","stroke","closePath","update","diffuseTexture","torus","diameter","thickness","tessellation","parent","disableAnimation","animationInnerCircle","ANIMATIONTYPE_FLOAT","ANIMATIONLOOPMODE_CYCLE","value","setKeys","easingFunction","setEasingMode","EASINGMODE_EASEINOUT","setEasingFunction","animations","beginAnimation","cone","diameterTop","scaling","rotate","X","torusArrowMaterial","torusConeMaterial","disableLighting","emissiveColor","diffuseColor","alpha","_teleportationRingMaterial","renderingGroupId","undefined","xrControllerUniqueId","remove","_findClosestSnapPointWithRadius","realPosition","snapToPositionRadius","closestPoint","closestDistance","Number","MAX_VALUE","radiusSquared","dist","DistanceSquared","pickInfo","newPosition","snapPosition","notifyObservers","visible","force","isVisible","getChildren","m","_quadraticBezierCurve","quadraticBezierVectors","CreateQuadraticBezier","ray","color","colorsArray","Array","generateRayPathMesh","points","getPoints","instance","updatable","colors","onBeforeCameraTeleport","onAfterCameraTeleport","Name","TELEPORTATION","Version","AddWebXRFeature","xrSessionManager","options"],"sources":["../../../../../dev/core/src/XR/features/WebXRControllerTeleportation.ts"],"sourcesContent":["import type { IWebXRFeature } from \"../webXRFeaturesManager\";\r\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport type { IWebXRMotionControllerAxesValue } from \"../motionController/webXRControllerComponent\";\r\nimport { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Vector3, Quaternion } from \"../../Maths/math.vector\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport type { Material } from \"../../Materials/material\";\r\nimport { DynamicTexture } from \"../../Materials/Textures/dynamicTexture\";\r\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder\";\r\nimport { SineEase, EasingFunction } from \"../../Animations/easing\";\r\nimport { Animation } from \"../../Animations/animation\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { CreateGround } from \"../../Meshes/Builders/groundBuilder\";\r\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder\";\r\nimport type { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { Curve3 } from \"../../Maths/math.path\";\r\nimport { CreateLines } from \"../../Meshes/Builders/linesBuilder\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Color3, Color4 } from \"../../Maths/math.color\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { setAndStartTimer } from \"../../Misc/timer\";\r\nimport type { LinesMesh } from \"../../Meshes/linesMesh\";\r\n\r\n/**\r\n * The options container for the teleportation module\r\n */\r\nexport interface IWebXRTeleportationOptions {\r\n    /**\r\n     * if provided, this scene will be used to render meshes.\r\n     */\r\n    customUtilityLayerScene?: Scene;\r\n    /**\r\n     * Values to configure the default target mesh\r\n     */\r\n    defaultTargetMeshOptions?: {\r\n        /**\r\n         * Fill color of the teleportation area\r\n         */\r\n        teleportationFillColor?: string;\r\n        /**\r\n         * Border color for the teleportation area\r\n         */\r\n        teleportationBorderColor?: string;\r\n        /**\r\n         * Disable the mesh's animation sequence\r\n         */\r\n        disableAnimation?: boolean;\r\n        /**\r\n         * Disable lighting on the material or the ring and arrow\r\n         */\r\n        disableLighting?: boolean;\r\n        /**\r\n         * Override the default material of the torus and arrow\r\n         */\r\n        torusArrowMaterial?: Material;\r\n        /**\r\n         * Override the default material of the Landing Zone\r\n         */\r\n        teleportationCircleMaterial?: Material;\r\n    };\r\n    /**\r\n     * A list of meshes to use as floor meshes.\r\n     * Meshes can be added and removed after initializing the feature using the\r\n     * addFloorMesh and removeFloorMesh functions\r\n     * If empty, rotation will still work\r\n     */\r\n    floorMeshes?: AbstractMesh[];\r\n    /**\r\n     *  use this rendering group id for the meshes (optional)\r\n     */\r\n    renderingGroupId?: number;\r\n    /**\r\n     * Should teleportation move only to snap points\r\n     */\r\n    snapPointsOnly?: boolean;\r\n    /**\r\n     * An array of points to which the teleportation will snap to.\r\n     * If the teleportation ray is in the proximity of one of those points, it will be corrected to this point.\r\n     */\r\n    snapPositions?: Vector3[];\r\n    /**\r\n     * How close should the teleportation ray be in order to snap to position.\r\n     * Default to 0.8 units (meters)\r\n     */\r\n    snapToPositionRadius?: number;\r\n    /**\r\n     * Provide your own teleportation mesh instead of babylon's wonderful doughnut.\r\n     * If you want to support rotation, make sure your mesh has a direction indicator.\r\n     *\r\n     * When left untouched, the default mesh will be initialized.\r\n     */\r\n    teleportationTargetMesh?: AbstractMesh;\r\n    /**\r\n     * If main component is used (no thumbstick), how long should the \"long press\" take before teleport\r\n     */\r\n    timeToTeleport?: number;\r\n    /**\r\n     * Disable using the thumbstick and use the main component (usually trigger) on long press.\r\n     * This will be automatically true if the controller doesn't have a thumbstick or touchpad.\r\n     */\r\n    useMainComponentOnly?: boolean;\r\n    /**\r\n     * Should meshes created here be added to a utility layer or the main scene\r\n     */\r\n    useUtilityLayer?: boolean;\r\n    /**\r\n     * Babylon XR Input class for controller\r\n     */\r\n    xrInput: WebXRInput;\r\n\r\n    /**\r\n     * Meshes that the teleportation ray cannot go through\r\n     */\r\n    pickBlockerMeshes?: AbstractMesh[];\r\n\r\n    /**\r\n     * Color of the teleportation ray when it is blocked by a mesh in the pickBlockerMeshes array\r\n     * Defaults to red.\r\n     */\r\n    blockedRayColor?: Color4;\r\n\r\n    /**\r\n     * Should teleport work only on a specific hand?\r\n     */\r\n    forceHandedness?: XRHandedness;\r\n\r\n    /**\r\n     * If provided, this function will be used to generate the ray mesh instead of the lines mesh being used per default\r\n     */\r\n    generateRayPathMesh?: (points: Vector3[], pickingInfo: PickingInfo) => AbstractMesh;\r\n}\r\n\r\n/**\r\n * This is a teleportation feature to be used with WebXR-enabled motion controllers.\r\n * When enabled and attached, the feature will allow a user to move around and rotate in the scene using\r\n * the input of the attached controllers.\r\n */\r\nexport class WebXRMotionControllerTeleportation extends WebXRAbstractFeature {\r\n    private _controllers: {\r\n        [controllerUniqueId: string]: {\r\n            xrController: WebXRInputSource;\r\n            teleportationComponent?: WebXRControllerComponent;\r\n            teleportationState: {\r\n                forward: boolean;\r\n                backwards: boolean;\r\n                currentRotation: number;\r\n                baseRotation: number;\r\n                rotating: boolean;\r\n                blocked: boolean;\r\n            };\r\n            onAxisChangedObserver?: Nullable<Observer<IWebXRMotionControllerAxesValue>>;\r\n            onButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n        };\r\n    } = {};\r\n    private _currentTeleportationControllerId: string;\r\n    private _floorMeshes: AbstractMesh[];\r\n    private _quadraticBezierCurve: Nullable<AbstractMesh>;\r\n    private _selectionFeature: Nullable<IWebXRFeature>;\r\n    private _snapToPositions: Vector3[];\r\n    private _snappedToPoint: boolean = false;\r\n    private _teleportationRingMaterial?: StandardMaterial;\r\n    private _blockedRayColor: Color4;\r\n    private _cachedColor4White = new Color4(1, 1, 1, 1);\r\n    private _tmpRay = new Ray(new Vector3(), new Vector3());\r\n    private _tmpVector = new Vector3();\r\n    private _tmpQuaternion = new Quaternion();\r\n\r\n    /**\r\n     * Skip the next teleportation. This can be controlled by the user to prevent the user from teleportation\r\n     * to sections that are not yet \"unlocked\", but should still show the teleportation mesh.\r\n     */\r\n    public skipNextTeleportation = false;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.TELEPORTATION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the webxr specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Is movement backwards enabled\r\n     */\r\n    public backwardsMovementEnabled = true;\r\n    /**\r\n     * Distance to travel when moving backwards\r\n     */\r\n    public backwardsTeleportationDistance: number = 0.7;\r\n    /**\r\n     * The distance from the user to the inspection point in the direction of the controller\r\n     * A higher number will allow the user to move further\r\n     * defaults to 5 (meters, in xr units)\r\n     */\r\n    public parabolicCheckRadius: number = 5;\r\n    /**\r\n     * Should the module support parabolic ray on top of direct ray\r\n     * If enabled, the user will be able to point \"at the sky\" and move according to predefined radius distance\r\n     * Very helpful when moving between floors / different heights\r\n     */\r\n    public parabolicRayEnabled: boolean = true;\r\n\r\n    /**\r\n     * The second type of ray - straight line.\r\n     * Should it be enabled or should the parabolic line be the only one.\r\n     */\r\n    public straightRayEnabled: boolean = true;\r\n    /**\r\n     * How much rotation should be applied when rotating right and left\r\n     */\r\n    public rotationAngle: number = Math.PI / 8;\r\n\r\n    /**\r\n     * This observable will notify when the target mesh position was updated.\r\n     * The picking info it provides contains the point to which the target mesh will move ()\r\n     */\r\n    public onTargetMeshPositionUpdatedObservable: Observable<PickingInfo> = new Observable();\r\n\r\n    /**\r\n     * Is teleportation enabled. Can be used to allow rotation only.\r\n     */\r\n    public teleportationEnabled: boolean = true;\r\n\r\n    private _rotationEnabled: boolean = true;\r\n\r\n    /**\r\n     * Is rotation enabled when moving forward?\r\n     * Disabling this feature will prevent the user from deciding the direction when teleporting\r\n     */\r\n    public get rotationEnabled(): boolean {\r\n        return this._rotationEnabled;\r\n    }\r\n\r\n    /**\r\n     * Sets whether rotation is enabled or not\r\n     * @param enabled is rotation enabled when teleportation is shown\r\n     */\r\n    public set rotationEnabled(enabled: boolean) {\r\n        this._rotationEnabled = enabled;\r\n\r\n        if (this._options.teleportationTargetMesh) {\r\n            const children = this._options.teleportationTargetMesh.getChildMeshes(false, (node) => node.name === \"rotationCone\");\r\n            if (children[0]) {\r\n                children[0].setEnabled(enabled);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Exposes the currently set teleportation target mesh.\r\n     */\r\n    public get teleportationTargetMesh(): Nullable<AbstractMesh> {\r\n        return this._options.teleportationTargetMesh || null;\r\n    }\r\n\r\n    /**\r\n     * constructs a new teleportation system\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param _options configuration object for this feature\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private _options: IWebXRTeleportationOptions) {\r\n        super(_xrSessionManager);\r\n        // create default mesh if not provided\r\n        if (!this._options.teleportationTargetMesh) {\r\n            this._createDefaultTargetMesh();\r\n        }\r\n\r\n        this._floorMeshes = this._options.floorMeshes || [];\r\n        this._snapToPositions = this._options.snapPositions || [];\r\n        this._blockedRayColor = this._options.blockedRayColor || new Color4(1, 0, 0, 0.75);\r\n\r\n        this._setTargetMeshVisibility(false);\r\n    }\r\n\r\n    /**\r\n     * Get the snapPointsOnly flag\r\n     */\r\n    public get snapPointsOnly(): boolean {\r\n        return !!this._options.snapPointsOnly;\r\n    }\r\n\r\n    /**\r\n     * Sets the snapPointsOnly flag\r\n     * @param snapToPoints should teleportation be exclusively to snap points\r\n     */\r\n    public set snapPointsOnly(snapToPoints: boolean) {\r\n        this._options.snapPointsOnly = snapToPoints;\r\n    }\r\n\r\n    /**\r\n     * Add a new mesh to the floor meshes array\r\n     * @param mesh the mesh to use as floor mesh\r\n     */\r\n    public addFloorMesh(mesh: AbstractMesh) {\r\n        this._floorMeshes.push(mesh);\r\n    }\r\n\r\n    /**\r\n     * Add a mesh to the list of meshes blocking the teleportation ray\r\n     * @param mesh The mesh to add to the teleportation-blocking meshes\r\n     */\r\n    public addBlockerMesh(mesh: AbstractMesh) {\r\n        this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];\r\n        this._options.pickBlockerMeshes.push(mesh);\r\n    }\r\n\r\n    /**\r\n     * Add a new snap-to point to fix teleportation to this position\r\n     * @param newSnapPoint The new Snap-To point\r\n     */\r\n    public addSnapPoint(newSnapPoint: Vector3) {\r\n        this._snapToPositions.push(newSnapPoint);\r\n    }\r\n\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        // Safety reset\r\n        this._currentTeleportationControllerId = \"\";\r\n\r\n        this._options.xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        this._setTargetMeshVisibility(false);\r\n        this._currentTeleportationControllerId = \"\";\r\n        this._controllers = {};\r\n\r\n        return true;\r\n    }\r\n\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.dispose(false, true);\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the floor meshes array\r\n     * @param mesh the mesh to remove\r\n     */\r\n    public removeFloorMesh(mesh: AbstractMesh) {\r\n        const index = this._floorMeshes.indexOf(mesh);\r\n        if (index !== -1) {\r\n            this._floorMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the blocker meshes array\r\n     * @param mesh the mesh to remove\r\n     */\r\n    public removeBlockerMesh(mesh: AbstractMesh) {\r\n        this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];\r\n        const index = this._options.pickBlockerMeshes.indexOf(mesh);\r\n        if (index !== -1) {\r\n            this._options.pickBlockerMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the floor meshes array using its name\r\n     * @param name the mesh name to remove\r\n     */\r\n    public removeFloorMeshByName(name: string) {\r\n        const mesh = this._xrSessionManager.scene.getMeshByName(name);\r\n        if (mesh) {\r\n            this.removeFloorMesh(mesh);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function will iterate through the array, searching for this point or equal to it. It will then remove it from the snap-to array\r\n     * @param snapPointToRemove the point (or a clone of it) to be removed from the array\r\n     * @returns was the point found and removed or not\r\n     */\r\n    public removeSnapPoint(snapPointToRemove: Vector3): boolean {\r\n        // check if the object is in the array\r\n        let index = this._snapToPositions.indexOf(snapPointToRemove);\r\n        // if not found as an object, compare to the points\r\n        if (index === -1) {\r\n            for (let i = 0; i < this._snapToPositions.length; ++i) {\r\n                // equals? index is i, break the loop\r\n                if (this._snapToPositions[i].equals(snapPointToRemove)) {\r\n                    index = i;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // index is not -1? remove the object\r\n        if (index !== -1) {\r\n            this._snapToPositions.splice(index, 1);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * This function sets a selection feature that will be disabled when\r\n     * the forward ray is shown and will be reattached when hidden.\r\n     * This is used to remove the selection rays when moving.\r\n     * @param selectionFeature the feature to disable when forward movement is enabled\r\n     */\r\n    public setSelectionFeature(selectionFeature: Nullable<IWebXRFeature>) {\r\n        this._selectionFeature = selectionFeature;\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        const frame = this._xrSessionManager.currentFrame;\r\n        const scene = this._xrSessionManager.scene;\r\n        if (!this.attach || !frame) {\r\n            return;\r\n        }\r\n\r\n        // render target if needed\r\n        const targetMesh = this._options.teleportationTargetMesh;\r\n        if (this._currentTeleportationControllerId) {\r\n            if (!targetMesh) {\r\n                return;\r\n            }\r\n            targetMesh.rotationQuaternion = targetMesh.rotationQuaternion || new Quaternion();\r\n            const controllerData = this._controllers[this._currentTeleportationControllerId];\r\n            if (controllerData && controllerData.teleportationState.forward) {\r\n                // set the rotation\r\n                Quaternion.RotationYawPitchRollToRef(\r\n                    controllerData.teleportationState.currentRotation + controllerData.teleportationState.baseRotation,\r\n                    0,\r\n                    0,\r\n                    targetMesh.rotationQuaternion\r\n                );\r\n                // set the ray and position\r\n\r\n                let hitPossible = false;\r\n                controllerData.xrController.getWorldPointerRayToRef(this._tmpRay);\r\n                if (this.straightRayEnabled) {\r\n                    // first check if direct ray possible\r\n                    // pick grounds that are LOWER only. upper will use parabolic path\r\n                    const pick = scene.pickWithRay(this._tmpRay, (o) => {\r\n                        // check for mesh-blockers\r\n                        if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {\r\n                            return true;\r\n                        }\r\n                        const index = this._floorMeshes.indexOf(o);\r\n                        if (index === -1) {\r\n                            return false;\r\n                        }\r\n                        return this._floorMeshes[index].absolutePosition.y < this._options.xrInput.xrCamera.globalPosition.y;\r\n                    });\r\n                    if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {\r\n                        controllerData.teleportationState.blocked = true;\r\n                        this._setTargetMeshVisibility(false);\r\n                        this._showParabolicPath(pick);\r\n                        return;\r\n                    } else if (pick && pick.pickedPoint) {\r\n                        controllerData.teleportationState.blocked = false;\r\n                        hitPossible = true;\r\n                        this._setTargetMeshPosition(pick);\r\n                        this._setTargetMeshVisibility(true);\r\n                        this._showParabolicPath(pick);\r\n                    }\r\n                }\r\n                // straight ray is still the main ray, but disabling the straight line will force parabolic line.\r\n                if (this.parabolicRayEnabled && !hitPossible) {\r\n                    // radius compensation according to pointer rotation around X\r\n                    const xRotation = controllerData.xrController.pointer.rotationQuaternion!.toEulerAngles().x;\r\n                    const compensation = 1 + (Math.PI / 2 - Math.abs(xRotation));\r\n                    // check parabolic ray\r\n                    const radius = this.parabolicCheckRadius * compensation;\r\n                    this._tmpRay.origin.addToRef(this._tmpRay.direction.scale(radius * 2), this._tmpVector);\r\n                    this._tmpVector.y = this._tmpRay.origin.y;\r\n                    this._tmpRay.origin.addInPlace(this._tmpRay.direction.scale(radius));\r\n                    this._tmpVector.subtractToRef(this._tmpRay.origin, this._tmpRay.direction);\r\n                    this._tmpRay.direction.normalize();\r\n\r\n                    const pick = scene.pickWithRay(this._tmpRay, (o) => {\r\n                        // check for mesh-blockers\r\n                        if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {\r\n                            return true;\r\n                        }\r\n                        return this._floorMeshes.indexOf(o) !== -1;\r\n                    });\r\n                    if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {\r\n                        controllerData.teleportationState.blocked = true;\r\n                        this._setTargetMeshVisibility(false);\r\n                        this._showParabolicPath(pick);\r\n                        return;\r\n                    } else if (pick && pick.pickedPoint) {\r\n                        controllerData.teleportationState.blocked = false;\r\n                        hitPossible = true;\r\n                        this._setTargetMeshPosition(pick);\r\n                        this._setTargetMeshVisibility(true);\r\n                        this._showParabolicPath(pick);\r\n                    }\r\n                }\r\n\r\n                // if needed, set visible:\r\n                this._setTargetMeshVisibility(hitPossible);\r\n            } else {\r\n                this._setTargetMeshVisibility(false);\r\n            }\r\n        } else {\r\n            this._disposeBezierCurve();\r\n            this._setTargetMeshVisibility(false);\r\n        }\r\n    }\r\n\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId] || (this._options.forceHandedness && xrController.inputSource.handedness !== this._options.forceHandedness)) {\r\n            // already attached\r\n            return;\r\n        }\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            teleportationState: {\r\n                forward: false,\r\n                backwards: false,\r\n                rotating: false,\r\n                currentRotation: 0,\r\n                baseRotation: 0,\r\n                blocked: false,\r\n            },\r\n        };\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        // motion controller only available to gamepad-enabled input sources.\r\n        if (controllerData.xrController.inputSource.targetRayMode === \"tracked-pointer\" && controllerData.xrController.inputSource.gamepad) {\r\n            // motion controller support\r\n            const initMotionController = () => {\r\n                if (xrController.motionController) {\r\n                    const movementController =\r\n                        xrController.motionController.getComponentOfType(WebXRControllerComponent.THUMBSTICK_TYPE) ||\r\n                        xrController.motionController.getComponentOfType(WebXRControllerComponent.TOUCHPAD_TYPE);\r\n                    if (!movementController || this._options.useMainComponentOnly) {\r\n                        // use trigger to move on long press\r\n                        const mainComponent = xrController.motionController.getMainComponent();\r\n                        if (!mainComponent) {\r\n                            return;\r\n                        }\r\n                        controllerData.teleportationComponent = mainComponent;\r\n                        controllerData.onButtonChangedObserver = mainComponent.onButtonStateChangedObservable.add(() => {\r\n                            if (!this.teleportationEnabled) {\r\n                                return;\r\n                            }\r\n                            // did \"pressed\" changed?\r\n                            if (mainComponent.changes.pressed) {\r\n                                if (mainComponent.changes.pressed.current) {\r\n                                    // simulate \"forward\" thumbstick push\r\n                                    controllerData.teleportationState.forward = true;\r\n                                    this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\r\n                                    controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\r\n                                    controllerData.teleportationState.currentRotation = 0;\r\n                                    const timeToSelect = this._options.timeToTeleport || 3000;\r\n                                    setAndStartTimer({\r\n                                        timeout: timeToSelect,\r\n                                        contextObservable: this._xrSessionManager.onXRFrameObservable,\r\n                                        breakCondition: () => !mainComponent.pressed,\r\n                                        onEnded: () => {\r\n                                            if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\r\n                                                this._teleportForward(xrController.uniqueId);\r\n                                            }\r\n                                        },\r\n                                    });\r\n                                } else {\r\n                                    controllerData.teleportationState.forward = false;\r\n                                    this._currentTeleportationControllerId = \"\";\r\n                                }\r\n                            }\r\n                        });\r\n                    } else {\r\n                        controllerData.teleportationComponent = movementController;\r\n                        // use thumbstick (or touchpad if thumbstick not available)\r\n                        controllerData.onAxisChangedObserver = movementController.onAxisValueChangedObservable.add((axesData) => {\r\n                            if (axesData.y <= 0.7 && controllerData.teleportationState.backwards) {\r\n                                controllerData.teleportationState.backwards = false;\r\n                            }\r\n                            if (axesData.y > 0.7 && !controllerData.teleportationState.forward && this.backwardsMovementEnabled && !this.snapPointsOnly) {\r\n                                // teleport backwards\r\n\r\n                                // General gist: Go Back N units, cast a ray towards the floor. If collided, move.\r\n                                if (!controllerData.teleportationState.backwards) {\r\n                                    controllerData.teleportationState.backwards = true;\r\n                                    // teleport backwards ONCE\r\n                                    this._tmpQuaternion.copyFrom(this._options.xrInput.xrCamera.rotationQuaternion!);\r\n                                    this._tmpQuaternion.toEulerAnglesToRef(this._tmpVector);\r\n                                    // get only the y rotation\r\n                                    this._tmpVector.x = 0;\r\n                                    this._tmpVector.z = 0;\r\n                                    // get the quaternion\r\n                                    Quaternion.FromEulerVectorToRef(this._tmpVector, this._tmpQuaternion);\r\n                                    this._tmpVector.set(0, 0, this.backwardsTeleportationDistance * (this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0));\r\n                                    this._tmpVector.rotateByQuaternionToRef(this._tmpQuaternion, this._tmpVector);\r\n                                    this._tmpVector.addInPlace(this._options.xrInput.xrCamera.position);\r\n                                    this._tmpRay.origin.copyFrom(this._tmpVector);\r\n                                    // This will prevent the user from \"falling\" to a lower platform!\r\n                                    // TODO - should this be a flag? 'allow falling to lower platforms'?\r\n                                    this._tmpRay.length = this._options.xrInput.xrCamera.realWorldHeight + 0.1;\r\n                                    // Right handed system had here \"1\" instead of -1. This is unneeded.\r\n                                    this._tmpRay.direction.set(0, -1, 0);\r\n                                    const pick = this._xrSessionManager.scene.pickWithRay(this._tmpRay, (o) => {\r\n                                        return this._floorMeshes.indexOf(o) !== -1;\r\n                                    });\r\n\r\n                                    // pick must exist, but stay safe\r\n                                    if (pick && pick.pickedPoint) {\r\n                                        // Teleport the users feet to where they targeted. Ignore the Y axis.\r\n                                        // If the \"falling to lower platforms\" feature is implemented the Y axis should be set here as well\r\n                                        this._options.xrInput.xrCamera.position.x = pick.pickedPoint.x;\r\n                                        this._options.xrInput.xrCamera.position.z = pick.pickedPoint.z;\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (axesData.y < -0.7 && !this._currentTeleportationControllerId && !controllerData.teleportationState.rotating && this.teleportationEnabled) {\r\n                                controllerData.teleportationState.forward = true;\r\n                                this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\r\n                                controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\r\n                            }\r\n                            if (axesData.x) {\r\n                                if (!controllerData.teleportationState.forward) {\r\n                                    if (!controllerData.teleportationState.rotating && Math.abs(axesData.x) > 0.7) {\r\n                                        // rotate in the right direction positive is right\r\n                                        controllerData.teleportationState.rotating = true;\r\n                                        const rotation = this.rotationAngle * (axesData.x > 0 ? 1 : -1) * (this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);\r\n                                        Quaternion.FromEulerAngles(0, rotation, 0).multiplyToRef(\r\n                                            this._options.xrInput.xrCamera.rotationQuaternion,\r\n                                            this._options.xrInput.xrCamera.rotationQuaternion\r\n                                        );\r\n                                    }\r\n                                } else {\r\n                                    if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId) {\r\n                                        // set the rotation of the forward movement\r\n                                        if (this.rotationEnabled) {\r\n                                            setTimeout(() => {\r\n                                                controllerData.teleportationState.currentRotation = Math.atan2(\r\n                                                    axesData.x,\r\n                                                    axesData.y * (this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1)\r\n                                                );\r\n                                            });\r\n                                        } else {\r\n                                            controllerData.teleportationState.currentRotation = 0;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                controllerData.teleportationState.rotating = false;\r\n                            }\r\n\r\n                            if (axesData.x === 0 && axesData.y === 0) {\r\n                                if (controllerData.teleportationState.blocked) {\r\n                                    controllerData.teleportationState.blocked = false;\r\n                                    this._setTargetMeshVisibility(false);\r\n                                }\r\n                                if (controllerData.teleportationState.forward) {\r\n                                    this._teleportForward(xrController.uniqueId);\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n            if (xrController.motionController) {\r\n                initMotionController();\r\n            } else {\r\n                xrController.onMotionControllerInitObservable.addOnce(() => {\r\n                    initMotionController();\r\n                });\r\n            }\r\n        } else {\r\n            this._xrSessionManager.scene.onPointerObservable.add((pointerInfo) => {\r\n                if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                    controllerData.teleportationState.forward = true;\r\n                    this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\r\n                    controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\r\n                    controllerData.teleportationState.currentRotation = 0;\r\n                    const timeToSelect = this._options.timeToTeleport || 3000;\r\n                    setAndStartTimer({\r\n                        timeout: timeToSelect,\r\n                        contextObservable: this._xrSessionManager.onXRFrameObservable,\r\n                        onEnded: () => {\r\n                            if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\r\n                                this._teleportForward(xrController.uniqueId);\r\n                            }\r\n                        },\r\n                    });\r\n                } else if (pointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                    controllerData.teleportationState.forward = false;\r\n                    this._currentTeleportationControllerId = \"\";\r\n                }\r\n            });\r\n        }\r\n    };\r\n\r\n    private _createDefaultTargetMesh() {\r\n        // set defaults\r\n        this._options.defaultTargetMeshOptions = this._options.defaultTargetMeshOptions || {};\r\n        const sceneToRenderTo = this._options.useUtilityLayer\r\n            ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene\r\n            : this._xrSessionManager.scene;\r\n        const teleportationTarget = CreateGround(\"teleportationTarget\", { width: 2, height: 2, subdivisions: 2 }, sceneToRenderTo);\r\n        teleportationTarget.isPickable = false;\r\n\r\n        if (this._options.defaultTargetMeshOptions.teleportationCircleMaterial) {\r\n            teleportationTarget.material = this._options.defaultTargetMeshOptions.teleportationCircleMaterial;\r\n        } else {\r\n            const length = 512;\r\n            const dynamicTexture = new DynamicTexture(\"teleportationPlaneDynamicTexture\", length, sceneToRenderTo, true);\r\n            dynamicTexture.hasAlpha = true;\r\n            const context = dynamicTexture.getContext();\r\n            const centerX = length / 2;\r\n            const centerY = length / 2;\r\n            const radius = 200;\r\n            context.beginPath();\r\n            context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\r\n            context.fillStyle = this._options.defaultTargetMeshOptions.teleportationFillColor || \"#444444\";\r\n            context.fill();\r\n            context.lineWidth = 10;\r\n            context.strokeStyle = this._options.defaultTargetMeshOptions.teleportationBorderColor || \"#FFFFFF\";\r\n            context.stroke();\r\n            context.closePath();\r\n            dynamicTexture.update();\r\n            const teleportationCircleMaterial = new StandardMaterial(\"teleportationPlaneMaterial\", sceneToRenderTo);\r\n            teleportationCircleMaterial.diffuseTexture = dynamicTexture;\r\n            teleportationTarget.material = teleportationCircleMaterial;\r\n        }\r\n\r\n        const torus = CreateTorus(\r\n            \"torusTeleportation\",\r\n            {\r\n                diameter: 0.75,\r\n                thickness: 0.1,\r\n                tessellation: 20,\r\n            },\r\n            sceneToRenderTo\r\n        );\r\n        torus.isPickable = false;\r\n        torus.parent = teleportationTarget;\r\n        if (!this._options.defaultTargetMeshOptions.disableAnimation) {\r\n            const animationInnerCircle = new Animation(\"animationInnerCircle\", \"position.y\", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);\r\n            const keys = [];\r\n            keys.push({\r\n                frame: 0,\r\n                value: 0,\r\n            });\r\n            keys.push({\r\n                frame: 30,\r\n                value: 0.4,\r\n            });\r\n            keys.push({\r\n                frame: 60,\r\n                value: 0,\r\n            });\r\n            animationInnerCircle.setKeys(keys);\r\n            const easingFunction = new SineEase();\r\n            easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\r\n            animationInnerCircle.setEasingFunction(easingFunction);\r\n            torus.animations = [];\r\n            torus.animations.push(animationInnerCircle);\r\n            sceneToRenderTo.beginAnimation(torus, 0, 60, true);\r\n        }\r\n\r\n        const cone = CreateCylinder(\"rotationCone\", { diameterTop: 0, tessellation: 4 }, sceneToRenderTo);\r\n        cone.isPickable = false;\r\n        cone.scaling.set(0.5, 0.12, 0.2);\r\n\r\n        cone.rotate(Axis.X, Math.PI / 2);\r\n\r\n        cone.position.z = 0.6;\r\n        cone.parent = torus;\r\n\r\n        if (this._options.defaultTargetMeshOptions.torusArrowMaterial) {\r\n            torus.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\r\n            cone.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\r\n        } else {\r\n            const torusConeMaterial = new StandardMaterial(\"torusConsMat\", sceneToRenderTo);\r\n            torusConeMaterial.disableLighting = !!this._options.defaultTargetMeshOptions.disableLighting;\r\n            if (torusConeMaterial.disableLighting) {\r\n                torusConeMaterial.emissiveColor = new Color3(0.3, 0.3, 1.0);\r\n            } else {\r\n                torusConeMaterial.diffuseColor = new Color3(0.3, 0.3, 1.0);\r\n            }\r\n            torusConeMaterial.alpha = 0.9;\r\n            torus.material = torusConeMaterial;\r\n            cone.material = torusConeMaterial;\r\n            this._teleportationRingMaterial = torusConeMaterial;\r\n        }\r\n\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            teleportationTarget.renderingGroupId = this._options.renderingGroupId;\r\n            torus.renderingGroupId = this._options.renderingGroupId;\r\n            cone.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n\r\n        this._options.teleportationTargetMesh = teleportationTarget;\r\n        // hide the teleportation target mesh right after creating it.\r\n        this._setTargetMeshVisibility(false);\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.teleportationComponent) {\r\n            if (controllerData.onAxisChangedObserver) {\r\n                controllerData.teleportationComponent.onAxisValueChangedObservable.remove(controllerData.onAxisChangedObserver);\r\n            }\r\n            if (controllerData.onButtonChangedObserver) {\r\n                controllerData.teleportationComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\r\n            }\r\n        }\r\n        // remove from the map\r\n        delete this._controllers[xrControllerUniqueId];\r\n    }\r\n\r\n    private _findClosestSnapPointWithRadius(realPosition: Vector3, radius: number = this._options.snapToPositionRadius || 0.8) {\r\n        let closestPoint: Nullable<Vector3> = null;\r\n        let closestDistance = Number.MAX_VALUE;\r\n        if (this._snapToPositions.length) {\r\n            const radiusSquared = radius * radius;\r\n            this._snapToPositions.forEach((position) => {\r\n                const dist = Vector3.DistanceSquared(position, realPosition);\r\n                if (dist <= radiusSquared && dist < closestDistance) {\r\n                    closestDistance = dist;\r\n                    closestPoint = position;\r\n                }\r\n            });\r\n        }\r\n        return closestPoint;\r\n    }\r\n\r\n    private _setTargetMeshPosition(pickInfo: PickingInfo) {\r\n        const newPosition = pickInfo.pickedPoint;\r\n        if (!this._options.teleportationTargetMesh || !newPosition) {\r\n            return;\r\n        }\r\n        const snapPosition = this._findClosestSnapPointWithRadius(newPosition);\r\n        this._snappedToPoint = !!snapPosition;\r\n        if (this.snapPointsOnly && !this._snappedToPoint && this._teleportationRingMaterial) {\r\n            this._teleportationRingMaterial.diffuseColor.set(1.0, 0.3, 0.3);\r\n        } else if (this.snapPointsOnly && this._snappedToPoint && this._teleportationRingMaterial) {\r\n            this._teleportationRingMaterial.diffuseColor.set(0.3, 0.3, 1.0);\r\n        }\r\n        this._options.teleportationTargetMesh.position.copyFrom(snapPosition || newPosition);\r\n        this._options.teleportationTargetMesh.position.y += 0.01;\r\n        this.onTargetMeshPositionUpdatedObservable.notifyObservers(pickInfo);\r\n    }\r\n\r\n    private _setTargetMeshVisibility(visible: boolean, force?: boolean) {\r\n        if (!this._options.teleportationTargetMesh) {\r\n            return;\r\n        }\r\n        if (this._options.teleportationTargetMesh.isVisible === visible && !force) {\r\n            return;\r\n        }\r\n        this._options.teleportationTargetMesh.isVisible = visible;\r\n        this._options.teleportationTargetMesh.getChildren(undefined, false).forEach((m) => {\r\n            (<any>m).isVisible = visible;\r\n        });\r\n\r\n        if (!visible) {\r\n            if (this._quadraticBezierCurve) {\r\n                this._quadraticBezierCurve.dispose();\r\n                this._quadraticBezierCurve = null;\r\n            }\r\n            if (this._selectionFeature) {\r\n                this._selectionFeature.attach();\r\n            }\r\n        } else {\r\n            if (this._selectionFeature) {\r\n                this._selectionFeature.detach();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _disposeBezierCurve() {\r\n        if (this._quadraticBezierCurve) {\r\n            this._quadraticBezierCurve.dispose();\r\n            this._quadraticBezierCurve = null;\r\n        }\r\n    }\r\n\r\n    private _showParabolicPath(pickInfo: PickingInfo) {\r\n        if (!pickInfo.pickedPoint || !this._currentTeleportationControllerId) {\r\n            return;\r\n        }\r\n\r\n        const sceneToRenderTo = this._options.useUtilityLayer\r\n            ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene\r\n            : this._xrSessionManager.scene;\r\n\r\n        const controllerData = this._controllers[this._currentTeleportationControllerId];\r\n\r\n        const quadraticBezierVectors = Curve3.CreateQuadraticBezier(controllerData.xrController.pointer.absolutePosition, pickInfo.ray!.origin, pickInfo.pickedPoint, 25);\r\n        const color = controllerData.teleportationState.blocked ? this._blockedRayColor : undefined;\r\n        const colorsArray = new Array(26).fill(color || this._cachedColor4White);\r\n        if (!this._options.generateRayPathMesh) {\r\n            this._quadraticBezierCurve = CreateLines(\r\n                \"teleportation path line\",\r\n                { points: quadraticBezierVectors.getPoints(), instance: this._quadraticBezierCurve as LinesMesh, updatable: true, colors: colorsArray },\r\n                sceneToRenderTo\r\n            );\r\n        } else {\r\n            this._quadraticBezierCurve = this._options.generateRayPathMesh(quadraticBezierVectors.getPoints(), pickInfo);\r\n        }\r\n        this._quadraticBezierCurve.isPickable = false;\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            this._quadraticBezierCurve.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n    }\r\n\r\n    private _teleportForward(controllerId: string) {\r\n        const controllerData = this._controllers[controllerId];\r\n        if (!controllerData || !controllerData.teleportationState.forward || !this.teleportationEnabled) {\r\n            return;\r\n        }\r\n        controllerData.teleportationState.forward = false;\r\n        this._currentTeleportationControllerId = \"\";\r\n        if (this.snapPointsOnly && !this._snappedToPoint) {\r\n            return;\r\n        }\r\n\r\n        if (this.skipNextTeleportation) {\r\n            this.skipNextTeleportation = false;\r\n            return;\r\n        }\r\n        // do the movement forward here\r\n        if (this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.isVisible) {\r\n            const height = this._options.xrInput.xrCamera.realWorldHeight;\r\n            this._options.xrInput.xrCamera.onBeforeCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\r\n            this._options.xrInput.xrCamera.position.copyFrom(this._options.teleportationTargetMesh.position);\r\n            this._options.xrInput.xrCamera.position.y += height;\r\n            Quaternion.FromEulerAngles(0, controllerData.teleportationState.currentRotation - (this._xrSessionManager.scene.useRightHandedSystem ? Math.PI : 0), 0).multiplyToRef(\r\n                this._options.xrInput.xrCamera.rotationQuaternion,\r\n                this._options.xrInput.xrCamera.rotationQuaternion\r\n            );\r\n            this._options.xrInput.xrCamera.onAfterCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\r\n        }\r\n    }\r\n}\r\n\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRMotionControllerTeleportation.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRMotionControllerTeleportation(xrSessionManager, options);\r\n    },\r\n    WebXRMotionControllerTeleportation.Version,\r\n    true\r\n);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}