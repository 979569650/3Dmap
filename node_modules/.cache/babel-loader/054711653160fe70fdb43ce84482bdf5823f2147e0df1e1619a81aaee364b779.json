{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Plane } from \"../../Maths/math.plane.js\";\nimport { Vector3, Matrix, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Epsilon } from \"../../Maths/math.constants.js\";\nimport { EventConstants } from \"../../Events/deviceInputEvents.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Firefox uses a different scheme to report scroll distances to other\n * browsers. Rather than use complicated methods to calculate the exact\n * multiple we need to apply, let's just cheat and use a constant.\n * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\n * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\n */\nconst ffMultiplier = 40;\n/**\n * Manage the mouse wheel inputs to control an arc rotate camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class ArcRotateCameraMouseWheelInput {\n  constructor() {\n    /**\n     * Gets or Set the mouse wheel precision or how fast is the camera zooming.\n     */\n    this.wheelPrecision = 3.0;\n    /**\n     * Gets or Set the boolean value that controls whether or not the mouse wheel\n     * zooms to the location of the mouse pointer or not.  The default is false.\n     */\n    this.zoomToMouseLocation = false;\n    /**\n     * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.\n     * It defines the percentage of current camera.radius to use as delta when wheel is used.\n     */\n    this.wheelDeltaPercentage = 0;\n    /**\n     * If set, this function will be used to set the radius delta that will be added to the current camera radius\n     */\n    this.customComputeDeltaFromMouseWheel = null;\n    this._viewOffset = new Vector3(0, 0, 0);\n    this._globalOffset = new Vector3(0, 0, 0);\n    this._inertialPanning = Vector3.Zero();\n  }\n  _computeDeltaFromMouseWheelLegacyEvent(mouseWheelDelta, radius) {\n    let delta = 0;\n    const wheelDelta = mouseWheelDelta * 0.01 * this.wheelDeltaPercentage * radius;\n    if (mouseWheelDelta > 0) {\n      delta = wheelDelta / (1.0 + this.wheelDeltaPercentage);\n    } else {\n      delta = wheelDelta * (1.0 + this.wheelDeltaPercentage);\n    }\n    return delta;\n  }\n  /**\n   * Attach the input controls to a specific dom element to get the input from.\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n   */\n  attachControl(noPreventDefault) {\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    this._wheel = p => {\n      //sanity check - this should be a PointerWheel event.\n      if (p.type !== PointerEventTypes.POINTERWHEEL) {\n        return;\n      }\n      const event = p.event;\n      let delta = 0;\n      const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? ffMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\n      const wheelDelta = -(event.deltaY * platformScale);\n      if (this.customComputeDeltaFromMouseWheel) {\n        delta = this.customComputeDeltaFromMouseWheel(wheelDelta, this, event);\n      } else {\n        if (this.wheelDeltaPercentage) {\n          delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, this.camera.radius);\n          // If zooming in, estimate the target radius and use that to compute the delta for inertia\n          // this will stop multiple scroll events zooming in from adding too much inertia\n          if (delta > 0) {\n            let estimatedTargetRadius = this.camera.radius;\n            let targetInertia = this.camera.inertialRadiusOffset + delta;\n            for (let i = 0; i < 20 && Math.abs(targetInertia) > 0.001; i++) {\n              estimatedTargetRadius -= targetInertia;\n              targetInertia *= this.camera.inertia;\n            }\n            estimatedTargetRadius = Scalar.Clamp(estimatedTargetRadius, 0, Number.MAX_VALUE);\n            delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, estimatedTargetRadius);\n          }\n        } else {\n          delta = wheelDelta / (this.wheelPrecision * 40);\n        }\n      }\n      if (delta) {\n        if (this.zoomToMouseLocation) {\n          // If we are zooming to the mouse location, then we need to get the hit plane at the start of the zoom gesture if it doesn't exist\n          // The hit plane is normally calculated after the first motion and each time there's motion so if we don't do this first,\n          // the first zoom will be to the center of the screen\n          if (!this._hitPlane) {\n            this._updateHitPlane();\n          }\n          this._zoomToMouse(delta);\n        } else {\n          this.camera.inertialRadiusOffset += delta;\n        }\n      }\n      if (event.preventDefault) {\n        if (!noPreventDefault) {\n          event.preventDefault();\n        }\n      }\n    };\n    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);\n    if (this.zoomToMouseLocation) {\n      this._inertialPanning.setAll(0);\n    }\n  }\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n  detachControl() {\n    if (this._observer) {\n      this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\n      this._observer = null;\n      this._wheel = null;\n    }\n  }\n  /**\n   * Update the current camera state depending on the inputs that have been used this frame.\n   * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\n   */\n  checkInputs() {\n    if (!this.zoomToMouseLocation) {\n      return;\n    }\n    const camera = this.camera;\n    const motion = 0.0 + camera.inertialAlphaOffset + camera.inertialBetaOffset + camera.inertialRadiusOffset;\n    if (motion) {\n      // if zooming is still happening as a result of inertia, then we also need to update\n      // the hit plane.\n      this._updateHitPlane();\n      // Note we cannot  use arcRotateCamera.inertialPlanning here because arcRotateCamera panning\n      // uses a different panningInertia which could cause this panning to get out of sync with\n      // the zooming, and for this to work they must be exactly in sync.\n      camera.target.addInPlace(this._inertialPanning);\n      this._inertialPanning.scaleInPlace(camera.inertia);\n      this._zeroIfClose(this._inertialPanning);\n    }\n  }\n  /**\n   * Gets the class name of the current input.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ArcRotateCameraMouseWheelInput\";\n  }\n  /**\n   * Get the friendly name associated with the input class.\n   * @returns the input friendly name\n   */\n  getSimpleName() {\n    return \"mousewheel\";\n  }\n  _updateHitPlane() {\n    const camera = this.camera;\n    const direction = camera.target.subtract(camera.position);\n    this._hitPlane = Plane.FromPositionAndNormal(camera.target, direction);\n  }\n  // Get position on the hit plane\n  _getPosition() {\n    var _a;\n    const camera = this.camera;\n    const scene = camera.getScene();\n    // since the _hitPlane is always updated to be orthogonal to the camera position vector\n    // we don't have to worry about this ray shooting off to infinity. This ray creates\n    // a vector defining where we want to zoom to.\n    const ray = scene.createPickingRay(scene.pointerX, scene.pointerY, Matrix.Identity(), camera, false);\n    // Since the camera is the origin of the picking ray, we need to offset it by the camera's offset manually\n    // Because the offset is in view space, we need to convert it to world space first\n    if (camera.targetScreenOffset.x !== 0 || camera.targetScreenOffset.y !== 0) {\n      this._viewOffset.set(camera.targetScreenOffset.x, camera.targetScreenOffset.y, 0);\n      camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\n      this._globalOffset = Vector3.TransformNormal(this._viewOffset, camera._cameraTransformMatrix);\n      ray.origin.addInPlace(this._globalOffset);\n    }\n    let distance = 0;\n    if (this._hitPlane) {\n      distance = (_a = ray.intersectsPlane(this._hitPlane)) !== null && _a !== void 0 ? _a : 0;\n    }\n    // not using this ray again, so modifying its vectors here is fine\n    return ray.origin.addInPlace(ray.direction.scaleInPlace(distance));\n  }\n  _zoomToMouse(delta) {\n    var _a, _b;\n    const camera = this.camera;\n    const inertiaComp = 1 - camera.inertia;\n    if (camera.lowerRadiusLimit) {\n      const lowerLimit = (_a = camera.lowerRadiusLimit) !== null && _a !== void 0 ? _a : 0;\n      if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp < lowerLimit) {\n        delta = (camera.radius - lowerLimit) * inertiaComp - camera.inertialRadiusOffset;\n      }\n    }\n    if (camera.upperRadiusLimit) {\n      const upperLimit = (_b = camera.upperRadiusLimit) !== null && _b !== void 0 ? _b : 0;\n      if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp > upperLimit) {\n        delta = (camera.radius - upperLimit) * inertiaComp - camera.inertialRadiusOffset;\n      }\n    }\n    const zoomDistance = delta / inertiaComp;\n    const ratio = zoomDistance / camera.radius;\n    const vec = this._getPosition();\n    // Now this vector tells us how much we also need to pan the camera\n    // so the targeted mouse location becomes the center of zooming.\n    const directionToZoomLocation = TmpVectors.Vector3[6];\n    vec.subtractToRef(camera.target, directionToZoomLocation);\n    directionToZoomLocation.scaleInPlace(ratio);\n    directionToZoomLocation.scaleInPlace(inertiaComp);\n    this._inertialPanning.addInPlace(directionToZoomLocation);\n    camera.inertialRadiusOffset += delta;\n  }\n  // Sets x y or z of passed in vector to zero if less than Epsilon.\n  _zeroIfClose(vec) {\n    if (Math.abs(vec.x) < Epsilon) {\n      vec.x = 0;\n    }\n    if (Math.abs(vec.y) < Epsilon) {\n      vec.y = 0;\n    }\n    if (Math.abs(vec.z) < Epsilon) {\n      vec.z = 0;\n    }\n  }\n}\n__decorate([serialize()], ArcRotateCameraMouseWheelInput.prototype, \"wheelPrecision\", void 0);\n__decorate([serialize()], ArcRotateCameraMouseWheelInput.prototype, \"zoomToMouseLocation\", void 0);\n__decorate([serialize()], ArcRotateCameraMouseWheelInput.prototype, \"wheelDeltaPercentage\", void 0);\nCameraInputTypes[\"ArcRotateCameraMouseWheelInput\"] = ArcRotateCameraMouseWheelInput;","map":{"version":3,"names":["serialize","CameraInputTypes","PointerEventTypes","Plane","Vector3","Matrix","TmpVectors","Epsilon","EventConstants","Scalar","Tools","ffMultiplier","ArcRotateCameraMouseWheelInput","constructor","wheelPrecision","zoomToMouseLocation","wheelDeltaPercentage","customComputeDeltaFromMouseWheel","_viewOffset","_globalOffset","_inertialPanning","Zero","_computeDeltaFromMouseWheelLegacyEvent","mouseWheelDelta","radius","delta","wheelDelta","attachControl","noPreventDefault","BackCompatCameraNoPreventDefault","arguments","_wheel","p","type","POINTERWHEEL","event","platformScale","deltaMode","DOM_DELTA_LINE","deltaY","camera","estimatedTargetRadius","targetInertia","inertialRadiusOffset","i","Math","abs","inertia","Clamp","Number","MAX_VALUE","_hitPlane","_updateHitPlane","_zoomToMouse","preventDefault","_observer","getScene","_inputManager","_addCameraPointerObserver","setAll","detachControl","_removeCameraPointerObserver","checkInputs","motion","inertialAlphaOffset","inertialBetaOffset","target","addInPlace","scaleInPlace","_zeroIfClose","getClassName","getSimpleName","direction","subtract","position","FromPositionAndNormal","_getPosition","scene","ray","createPickingRay","pointerX","pointerY","Identity","targetScreenOffset","x","y","set","getViewMatrix","invertToRef","_cameraTransformMatrix","TransformNormal","origin","distance","_a","intersectsPlane","inertiaComp","lowerRadiusLimit","lowerLimit","upperRadiusLimit","upperLimit","_b","zoomDistance","ratio","vec","directionToZoomLocation","subtractToRef","z","__decorate"],"sources":["../../../../../dev/core/src/Cameras/Inputs/arcRotateCameraMouseWheelInput.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Plane } from \"../../Maths/math.plane\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\nimport type { IWheelEvent } from \"../../Events/deviceInputEvents\";\r\nimport { EventConstants } from \"../../Events/deviceInputEvents\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Firefox uses a different scheme to report scroll distances to other\r\n * browsers. Rather than use complicated methods to calculate the exact\r\n * multiple we need to apply, let's just cheat and use a constant.\r\n * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\r\n * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n */\r\nconst ffMultiplier = 40;\r\n\r\n/**\r\n * Manage the mouse wheel inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraMouseWheelInput implements ICameraInput<ArcRotateCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Gets or Set the mouse wheel precision or how fast is the camera zooming.\r\n     */\r\n    @serialize()\r\n    public wheelPrecision = 3.0;\r\n\r\n    /**\r\n     * Gets or Set the boolean value that controls whether or not the mouse wheel\r\n     * zooms to the location of the mouse pointer or not.  The default is false.\r\n     */\r\n    @serialize()\r\n    public zoomToMouseLocation = false;\r\n\r\n    /**\r\n     * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when wheel is used.\r\n     */\r\n    @serialize()\r\n    public wheelDeltaPercentage = 0;\r\n\r\n    /**\r\n     * If set, this function will be used to set the radius delta that will be added to the current camera radius\r\n     */\r\n    public customComputeDeltaFromMouseWheel: Nullable<(wheelDelta: number, input: ArcRotateCameraMouseWheelInput, event: IWheelEvent) => number> = null;\r\n\r\n    private _wheel: Nullable<(p: PointerInfo, s: EventState) => void>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _hitPlane: Nullable<Plane>;\r\n    private _viewOffset: Vector3 = new Vector3(0, 0, 0);\r\n    private _globalOffset: Vector3 = new Vector3(0, 0, 0);\r\n\r\n    protected _computeDeltaFromMouseWheelLegacyEvent(mouseWheelDelta: number, radius: number) {\r\n        let delta = 0;\r\n        const wheelDelta = mouseWheelDelta * 0.01 * this.wheelDeltaPercentage * radius;\r\n        if (mouseWheelDelta > 0) {\r\n            delta = wheelDelta / (1.0 + this.wheelDeltaPercentage);\r\n        } else {\r\n            delta = wheelDelta * (1.0 + this.wheelDeltaPercentage);\r\n        }\r\n        return delta;\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this._wheel = (p) => {\r\n            //sanity check - this should be a PointerWheel event.\r\n            if (p.type !== PointerEventTypes.POINTERWHEEL) {\r\n                return;\r\n            }\r\n            const event = <IWheelEvent>p.event;\r\n            let delta = 0;\r\n            const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? ffMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\r\n\r\n            const wheelDelta = -(event.deltaY * platformScale);\r\n\r\n            if (this.customComputeDeltaFromMouseWheel) {\r\n                delta = this.customComputeDeltaFromMouseWheel(wheelDelta, this, event);\r\n            } else {\r\n                if (this.wheelDeltaPercentage) {\r\n                    delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, this.camera.radius);\r\n\r\n                    // If zooming in, estimate the target radius and use that to compute the delta for inertia\r\n                    // this will stop multiple scroll events zooming in from adding too much inertia\r\n                    if (delta > 0) {\r\n                        let estimatedTargetRadius = this.camera.radius;\r\n                        let targetInertia = this.camera.inertialRadiusOffset + delta;\r\n                        for (let i = 0; i < 20 && Math.abs(targetInertia) > 0.001; i++) {\r\n                            estimatedTargetRadius -= targetInertia;\r\n                            targetInertia *= this.camera.inertia;\r\n                        }\r\n                        estimatedTargetRadius = Scalar.Clamp(estimatedTargetRadius, 0, Number.MAX_VALUE);\r\n                        delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, estimatedTargetRadius);\r\n                    }\r\n                } else {\r\n                    delta = wheelDelta / (this.wheelPrecision * 40);\r\n                }\r\n            }\r\n\r\n            if (delta) {\r\n                if (this.zoomToMouseLocation) {\r\n                    // If we are zooming to the mouse location, then we need to get the hit plane at the start of the zoom gesture if it doesn't exist\r\n                    // The hit plane is normally calculated after the first motion and each time there's motion so if we don't do this first,\r\n                    // the first zoom will be to the center of the screen\r\n                    if (!this._hitPlane) {\r\n                        this._updateHitPlane();\r\n                    }\r\n\r\n                    this._zoomToMouse(delta);\r\n                } else {\r\n                    this.camera.inertialRadiusOffset += delta;\r\n                }\r\n            }\r\n\r\n            if (event.preventDefault) {\r\n                if (!noPreventDefault) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);\r\n\r\n        if (this.zoomToMouseLocation) {\r\n            this._inertialPanning.setAll(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n            this._wheel = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (!this.zoomToMouseLocation) {\r\n            return;\r\n        }\r\n\r\n        const camera = this.camera;\r\n        const motion = 0.0 + camera.inertialAlphaOffset + camera.inertialBetaOffset + camera.inertialRadiusOffset;\r\n        if (motion) {\r\n            // if zooming is still happening as a result of inertia, then we also need to update\r\n            // the hit plane.\r\n            this._updateHitPlane();\r\n\r\n            // Note we cannot  use arcRotateCamera.inertialPlanning here because arcRotateCamera panning\r\n            // uses a different panningInertia which could cause this panning to get out of sync with\r\n            // the zooming, and for this to work they must be exactly in sync.\r\n            camera.target.addInPlace(this._inertialPanning);\r\n            this._inertialPanning.scaleInPlace(camera.inertia);\r\n            this._zeroIfClose(this._inertialPanning);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mousewheel\";\r\n    }\r\n\r\n    private _updateHitPlane() {\r\n        const camera = this.camera;\r\n        const direction = camera.target.subtract(camera.position);\r\n        this._hitPlane = Plane.FromPositionAndNormal(camera.target, direction);\r\n    }\r\n\r\n    // Get position on the hit plane\r\n    private _getPosition(): Vector3 {\r\n        const camera = this.camera;\r\n        const scene = camera.getScene();\r\n\r\n        // since the _hitPlane is always updated to be orthogonal to the camera position vector\r\n        // we don't have to worry about this ray shooting off to infinity. This ray creates\r\n        // a vector defining where we want to zoom to.\r\n        const ray = scene.createPickingRay(scene.pointerX, scene.pointerY, Matrix.Identity(), camera, false);\r\n        // Since the camera is the origin of the picking ray, we need to offset it by the camera's offset manually\r\n        // Because the offset is in view space, we need to convert it to world space first\r\n        if (camera.targetScreenOffset.x !== 0 || camera.targetScreenOffset.y !== 0) {\r\n            this._viewOffset.set(camera.targetScreenOffset.x, camera.targetScreenOffset.y, 0);\r\n            camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\r\n            this._globalOffset = Vector3.TransformNormal(this._viewOffset, camera._cameraTransformMatrix);\r\n            ray.origin.addInPlace(this._globalOffset);\r\n        }\r\n\r\n        let distance = 0;\r\n        if (this._hitPlane) {\r\n            distance = ray.intersectsPlane(this._hitPlane) ?? 0;\r\n        }\r\n\r\n        // not using this ray again, so modifying its vectors here is fine\r\n        return ray.origin.addInPlace(ray.direction.scaleInPlace(distance));\r\n    }\r\n\r\n    private _inertialPanning: Vector3 = Vector3.Zero();\r\n\r\n    private _zoomToMouse(delta: number) {\r\n        const camera = this.camera;\r\n        const inertiaComp = 1 - camera.inertia;\r\n        if (camera.lowerRadiusLimit) {\r\n            const lowerLimit = camera.lowerRadiusLimit ?? 0;\r\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp < lowerLimit) {\r\n                delta = (camera.radius - lowerLimit) * inertiaComp - camera.inertialRadiusOffset;\r\n            }\r\n        }\r\n        if (camera.upperRadiusLimit) {\r\n            const upperLimit = camera.upperRadiusLimit ?? 0;\r\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp > upperLimit) {\r\n                delta = (camera.radius - upperLimit) * inertiaComp - camera.inertialRadiusOffset;\r\n            }\r\n        }\r\n\r\n        const zoomDistance = delta / inertiaComp;\r\n        const ratio = zoomDistance / camera.radius;\r\n        const vec = this._getPosition();\r\n\r\n        // Now this vector tells us how much we also need to pan the camera\r\n        // so the targeted mouse location becomes the center of zooming.\r\n\r\n        const directionToZoomLocation = TmpVectors.Vector3[6];\r\n        vec.subtractToRef(camera.target, directionToZoomLocation);\r\n        directionToZoomLocation.scaleInPlace(ratio);\r\n        directionToZoomLocation.scaleInPlace(inertiaComp);\r\n        this._inertialPanning.addInPlace(directionToZoomLocation);\r\n\r\n        camera.inertialRadiusOffset += delta;\r\n    }\r\n\r\n    // Sets x y or z of passed in vector to zero if less than Epsilon.\r\n    private _zeroIfClose(vec: Vector3) {\r\n        if (Math.abs(vec.x) < Epsilon) {\r\n            vec.x = 0;\r\n        }\r\n        if (Math.abs(vec.y) < Epsilon) {\r\n            vec.y = 0;\r\n        }\r\n        if (Math.abs(vec.z) < Epsilon) {\r\n            vec.z = 0;\r\n        }\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"ArcRotateCameraMouseWheelInput\"] = ArcRotateCameraMouseWheelInput;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}