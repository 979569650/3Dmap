{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"@babylonjs/core/tslib.es6.js\";\nimport { Observable } from \"@babylonjs/core/Misc/observable.js\";\nimport { Control } from \"./control.js\";\nimport { InputText } from \"./inputText.js\";\nimport { Rectangle } from \"./rectangle.js\";\nimport { Button } from \"./button.js\";\nimport { Grid } from \"./grid.js\";\nimport { TextBlock } from \"../controls/textBlock.js\";\nimport { RegisterClass } from \"@babylonjs/core/Misc/typeStore.js\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { serialize } from \"@babylonjs/core/Misc/decorators.js\";\nimport { EngineStore } from \"@babylonjs/core/Engines/engineStore.js\";\n/** Class used to create color pickers */\nexport class ColorPicker extends Control {\n  /** Gets or sets the color of the color picker */\n  get value() {\n    return this._value;\n  }\n  set value(value) {\n    if (this._value.equals(value)) {\n      return;\n    }\n    this._value.copyFrom(value);\n    this._value.toHSVToRef(this._tmpColor);\n    this._h = this._tmpColor.r;\n    this._s = Math.max(this._tmpColor.g, 0.00001);\n    this._v = Math.max(this._tmpColor.b, 0.00001);\n    this._markAsDirty();\n    if (this._value.r <= ColorPicker._Epsilon) {\n      this._value.r = 0;\n    }\n    if (this._value.g <= ColorPicker._Epsilon) {\n      this._value.g = 0;\n    }\n    if (this._value.b <= ColorPicker._Epsilon) {\n      this._value.b = 0;\n    }\n    if (this._value.r >= 1.0 - ColorPicker._Epsilon) {\n      this._value.r = 1.0;\n    }\n    if (this._value.g >= 1.0 - ColorPicker._Epsilon) {\n      this._value.g = 1.0;\n    }\n    if (this._value.b >= 1.0 - ColorPicker._Epsilon) {\n      this._value.b = 1.0;\n    }\n    this.onValueChangedObservable.notifyObservers(this._value);\n  }\n  /**\n   * Gets or sets control width\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#position-and-size\n   */\n  get width() {\n    return this._width.toString(this._host);\n  }\n  set width(value) {\n    if (this._width.toString(this._host) === value) {\n      return;\n    }\n    if (this._width.fromString(value)) {\n      if (this._width.getValue(this._host) === 0) {\n        value = \"1px\";\n        this._width.fromString(value);\n      }\n      this._height.fromString(value);\n      this._markAsDirty();\n    }\n  }\n  /**\n   * Gets or sets control height\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#position-and-size\n   */\n  get height() {\n    return this._height.toString(this._host);\n  }\n  /** Gets or sets control height */\n  set height(value) {\n    if (this._height.toString(this._host) === value) {\n      return;\n    }\n    if (this._height.fromString(value)) {\n      if (this._height.getValue(this._host) === 0) {\n        value = \"1px\";\n        this._height.fromString(value);\n      }\n      this._width.fromString(value);\n      this._markAsDirty();\n    }\n  }\n  /** Gets or sets control size */\n  get size() {\n    return this.width;\n  }\n  set size(value) {\n    this.width = value;\n  }\n  /**\n   * Creates a new ColorPicker\n   * @param name defines the control name\n   */\n  constructor(name) {\n    super(name);\n    this.name = name;\n    this._value = Color3.Red();\n    this._tmpColor = new Color3();\n    this._pointerStartedOnSquare = false;\n    this._pointerStartedOnWheel = false;\n    this._squareLeft = 0;\n    this._squareTop = 0;\n    this._squareSize = 0;\n    this._h = 360;\n    this._s = 1;\n    this._v = 1;\n    this._lastPointerDownId = -1;\n    /**\n     * Observable raised when the value changes\n     */\n    this.onValueChangedObservable = new Observable();\n    // Events\n    this._pointerIsDown = false;\n    this.value = new Color3(0.88, 0.1, 0.1);\n    this.size = \"200px\";\n    this.isPointerBlocker = true;\n  }\n  _getTypeName() {\n    return \"ColorPicker\";\n  }\n  /**\n   * @internal\n   */\n  _preMeasure(parentMeasure) {\n    if (parentMeasure.width < parentMeasure.height) {\n      this._currentMeasure.height = parentMeasure.width;\n    } else {\n      this._currentMeasure.width = parentMeasure.height;\n    }\n  }\n  _updateSquareProps() {\n    const radius = Math.min(this._currentMeasure.width, this._currentMeasure.height) * 0.5;\n    const wheelThickness = radius * 0.2;\n    const innerDiameter = (radius - wheelThickness) * 2;\n    const squareSize = innerDiameter / Math.sqrt(2);\n    const offset = radius - squareSize * 0.5;\n    this._squareLeft = this._currentMeasure.left + offset;\n    this._squareTop = this._currentMeasure.top + offset;\n    this._squareSize = squareSize;\n  }\n  _drawGradientSquare(hueValue, left, top, width, height, context) {\n    const lgh = context.createLinearGradient(left, top, width + left, top);\n    lgh.addColorStop(0, \"#fff\");\n    lgh.addColorStop(1, \"hsl(\" + hueValue + \", 100%, 50%)\");\n    context.fillStyle = lgh;\n    context.fillRect(left, top, width, height);\n    const lgv = context.createLinearGradient(left, top, left, height + top);\n    lgv.addColorStop(0, \"rgba(0,0,0,0)\");\n    lgv.addColorStop(1, \"#000\");\n    context.fillStyle = lgv;\n    context.fillRect(left, top, width, height);\n  }\n  _drawCircle(centerX, centerY, radius, context) {\n    context.beginPath();\n    context.arc(centerX, centerY, radius + 1, 0, 2 * Math.PI, false);\n    context.lineWidth = 3;\n    context.strokeStyle = \"#333333\";\n    context.stroke();\n    context.beginPath();\n    context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\n    context.lineWidth = 3;\n    context.strokeStyle = \"#ffffff\";\n    context.stroke();\n  }\n  _createColorWheelCanvas(radius, thickness) {\n    // Shoudl abstract platform instead of using LastCreatedEngine\n    const engine = EngineStore.LastCreatedEngine;\n    if (!engine) {\n      throw new Error(\"Invalid engine. Unable to create a canvas.\");\n    }\n    const canvas = engine.createCanvas(radius * 2, radius * 2);\n    const context = canvas.getContext(\"2d\");\n    const image = context.getImageData(0, 0, radius * 2, radius * 2);\n    const data = image.data;\n    const color = this._tmpColor;\n    const maxDistSq = radius * radius;\n    const innerRadius = radius - thickness;\n    const minDistSq = innerRadius * innerRadius;\n    for (let x = -radius; x < radius; x++) {\n      for (let y = -radius; y < radius; y++) {\n        const distSq = x * x + y * y;\n        if (distSq > maxDistSq || distSq < minDistSq) {\n          continue;\n        }\n        const dist = Math.sqrt(distSq);\n        const ang = Math.atan2(y, x);\n        Color3.HSVtoRGBToRef(ang * 180 / Math.PI + 180, dist / radius, 1, color);\n        const index = (x + radius + (y + radius) * 2 * radius) * 4;\n        data[index] = color.r * 255;\n        data[index + 1] = color.g * 255;\n        data[index + 2] = color.b * 255;\n        let alphaRatio = (dist - innerRadius) / (radius - innerRadius);\n        //apply less alpha to bigger color pickers\n        let alphaAmount = 0.2;\n        const maxAlpha = 0.2;\n        const minAlpha = 0.04;\n        const lowerRadius = 50;\n        const upperRadius = 150;\n        if (radius < lowerRadius) {\n          alphaAmount = maxAlpha;\n        } else if (radius > upperRadius) {\n          alphaAmount = minAlpha;\n        } else {\n          alphaAmount = (minAlpha - maxAlpha) * (radius - lowerRadius) / (upperRadius - lowerRadius) + maxAlpha;\n        }\n        alphaRatio = (dist - innerRadius) / (radius - innerRadius);\n        if (alphaRatio < alphaAmount) {\n          data[index + 3] = 255 * (alphaRatio / alphaAmount);\n        } else if (alphaRatio > 1 - alphaAmount) {\n          data[index + 3] = 255 * (1.0 - (alphaRatio - (1 - alphaAmount)) / alphaAmount);\n        } else {\n          data[index + 3] = 255;\n        }\n      }\n    }\n    context.putImageData(image, 0, 0);\n    return canvas;\n  }\n  /**\n   * @internal\n   */\n  _draw(context) {\n    context.save();\n    this._applyStates(context);\n    const radius = Math.min(this._currentMeasure.width, this._currentMeasure.height) * 0.5;\n    const wheelThickness = radius * 0.2;\n    const left = this._currentMeasure.left;\n    const top = this._currentMeasure.top;\n    if (!this._colorWheelCanvas || this._colorWheelCanvas.width != radius * 2) {\n      this._colorWheelCanvas = this._createColorWheelCanvas(radius, wheelThickness);\n    }\n    this._updateSquareProps();\n    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\n      context.shadowColor = this.shadowColor;\n      context.shadowBlur = this.shadowBlur;\n      context.shadowOffsetX = this.shadowOffsetX;\n      context.shadowOffsetY = this.shadowOffsetY;\n      context.fillRect(this._squareLeft, this._squareTop, this._squareSize, this._squareSize);\n    }\n    context.drawImage(this._colorWheelCanvas, left, top);\n    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\n      context.shadowBlur = 0;\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n    }\n    this._drawGradientSquare(this._h, this._squareLeft, this._squareTop, this._squareSize, this._squareSize, context);\n    let cx = this._squareLeft + this._squareSize * this._s;\n    let cy = this._squareTop + this._squareSize * (1 - this._v);\n    this._drawCircle(cx, cy, radius * 0.04, context);\n    const dist = radius - wheelThickness * 0.5;\n    cx = left + radius + Math.cos((this._h - 180) * Math.PI / 180) * dist;\n    cy = top + radius + Math.sin((this._h - 180) * Math.PI / 180) * dist;\n    this._drawCircle(cx, cy, wheelThickness * 0.35, context);\n    context.restore();\n  }\n  _updateValueFromPointer(x, y) {\n    if (this._pointerStartedOnWheel) {\n      const radius = Math.min(this._currentMeasure.width, this._currentMeasure.height) * 0.5;\n      const centerX = radius + this._currentMeasure.left;\n      const centerY = radius + this._currentMeasure.top;\n      this._h = Math.atan2(y - centerY, x - centerX) * 180 / Math.PI + 180;\n    } else if (this._pointerStartedOnSquare) {\n      this._updateSquareProps();\n      this._s = (x - this._squareLeft) / this._squareSize;\n      this._v = 1 - (y - this._squareTop) / this._squareSize;\n      this._s = Math.min(this._s, 1);\n      this._s = Math.max(this._s, ColorPicker._Epsilon);\n      this._v = Math.min(this._v, 1);\n      this._v = Math.max(this._v, ColorPicker._Epsilon);\n    }\n    Color3.HSVtoRGBToRef(this._h, this._s, this._v, this._tmpColor);\n    this.value = this._tmpColor;\n  }\n  _isPointOnSquare(x, y) {\n    this._updateSquareProps();\n    const left = this._squareLeft;\n    const top = this._squareTop;\n    const size = this._squareSize;\n    if (x >= left && x <= left + size && y >= top && y <= top + size) {\n      return true;\n    }\n    return false;\n  }\n  _isPointOnWheel(x, y) {\n    const radius = Math.min(this._currentMeasure.width, this._currentMeasure.height) * 0.5;\n    const centerX = radius + this._currentMeasure.left;\n    const centerY = radius + this._currentMeasure.top;\n    const wheelThickness = radius * 0.2;\n    const innerRadius = radius - wheelThickness;\n    const radiusSq = radius * radius;\n    const innerRadiusSq = innerRadius * innerRadius;\n    const dx = x - centerX;\n    const dy = y - centerY;\n    const distSq = dx * dx + dy * dy;\n    if (distSq <= radiusSq && distSq >= innerRadiusSq) {\n      return true;\n    }\n    return false;\n  }\n  _onPointerDown(target, coordinates, pointerId, buttonIndex, pi) {\n    if (!super._onPointerDown(target, coordinates, pointerId, buttonIndex, pi)) {\n      return false;\n    }\n    if (this.isReadOnly) {\n      return true;\n    }\n    this._pointerIsDown = true;\n    this._pointerStartedOnSquare = false;\n    this._pointerStartedOnWheel = false;\n    // Invert transform\n    this._invertTransformMatrix.transformCoordinates(coordinates.x, coordinates.y, this._transformedPosition);\n    const x = this._transformedPosition.x;\n    const y = this._transformedPosition.y;\n    if (this._isPointOnSquare(x, y)) {\n      this._pointerStartedOnSquare = true;\n    } else if (this._isPointOnWheel(x, y)) {\n      this._pointerStartedOnWheel = true;\n    }\n    this._updateValueFromPointer(x, y);\n    this._host._capturingControl[pointerId] = this;\n    this._lastPointerDownId = pointerId;\n    return true;\n  }\n  _onPointerMove(target, coordinates, pointerId, pi) {\n    // Only listen to pointer move events coming from the last pointer to click on the element (To support dual vr controller interaction)\n    if (pointerId != this._lastPointerDownId) {\n      return;\n    }\n    if (!this.isReadOnly) {\n      // Invert transform\n      this._invertTransformMatrix.transformCoordinates(coordinates.x, coordinates.y, this._transformedPosition);\n      const x = this._transformedPosition.x;\n      const y = this._transformedPosition.y;\n      if (this._pointerIsDown) {\n        this._updateValueFromPointer(x, y);\n      }\n    }\n    super._onPointerMove(target, coordinates, pointerId, pi);\n  }\n  _onPointerUp(target, coordinates, pointerId, buttonIndex, notifyClick, pi) {\n    this._pointerIsDown = false;\n    delete this._host._capturingControl[pointerId];\n    super._onPointerUp(target, coordinates, pointerId, buttonIndex, notifyClick, pi);\n  }\n  _onCanvasBlur() {\n    this._forcePointerUp();\n    super._onCanvasBlur();\n  }\n  /**\n   * This function expands the color picker by creating a color picker dialog with manual\n   * color value input and the ability to save colors into an array to be used later in\n   * subsequent launches of the dialogue.\n   * @param advancedTexture defines the AdvancedDynamicTexture the dialog is assigned to\n   * @param options defines size for dialog and options for saved colors. Also accepts last color picked as hex string and saved colors array as hex strings.\n   * @param options.pickerWidth\n   * @param options.pickerHeight\n   * @param options.headerHeight\n   * @param options.lastColor\n   * @param options.swatchLimit\n   * @param options.numSwatchesPerLine\n   * @param options.savedColors\n   * @returns picked color as a hex string and the saved colors array as hex strings.\n   */\n  static ShowPickerDialogAsync(advancedTexture, options) {\n    return new Promise(resolve => {\n      // Default options\n      options.pickerWidth = options.pickerWidth || \"640px\";\n      options.pickerHeight = options.pickerHeight || \"400px\";\n      options.headerHeight = options.headerHeight || \"35px\";\n      options.lastColor = options.lastColor || \"#000000\";\n      options.swatchLimit = options.swatchLimit || 20;\n      options.numSwatchesPerLine = options.numSwatchesPerLine || 10;\n      // Window size settings\n      const drawerMaxRows = options.swatchLimit / options.numSwatchesPerLine;\n      const rawSwatchSize = parseFloat(options.pickerWidth) / options.numSwatchesPerLine;\n      const gutterSize = Math.floor(rawSwatchSize * 0.25);\n      const colGutters = gutterSize * (options.numSwatchesPerLine + 1);\n      const swatchSize = Math.floor((parseFloat(options.pickerWidth) - colGutters) / options.numSwatchesPerLine);\n      const drawerMaxSize = swatchSize * drawerMaxRows + gutterSize * (drawerMaxRows + 1);\n      const containerSize = (parseInt(options.pickerHeight) + drawerMaxSize + Math.floor(swatchSize * 0.25)).toString() + \"px\";\n      // Button Colors\n      const buttonColor = \"#c0c0c0\";\n      const buttonBackgroundColor = \"#535353\";\n      const buttonBackgroundHoverColor = \"#414141\";\n      const buttonBackgroundClickColor = \"515151\";\n      const buttonDisabledColor = \"#555555\";\n      const buttonDisabledBackgroundColor = \"#454545\";\n      const currentSwatchesOutlineColor = \"#404040\";\n      const luminanceLimitColor = Color3.FromHexString(\"#dddddd\");\n      const luminanceLimit = luminanceLimitColor.r + luminanceLimitColor.g + luminanceLimitColor.b;\n      const iconColorDark = \"#aaaaaa\";\n      const iconColorLight = \"#ffffff\";\n      // Button settings\n      let buttonFontSize;\n      let butEdit;\n      // Input Text Colors\n      const inputFieldLabels = [\"R\", \"G\", \"B\"];\n      const inputTextBackgroundColor = \"#454545\";\n      const inputTextColor = \"#f0f0f0\";\n      // This int is used for naming swatches and serves as the index for calling them from the list\n      let swatchNumber;\n      // Menu Panel options. We need to know if the swatchDrawer exists so we can create it if needed.\n      let swatchDrawer;\n      let editSwatchMode = false;\n      // Color InputText fields that will be updated upon value change\n      let butSave;\n      let lastVal;\n      let activeField;\n      // Dialog menu container which will contain both the main dialogue window and the swatch drawer which opens once a color is saved.\n      const dialogContainer = new Grid();\n      dialogContainer.name = \"Dialog Container\";\n      dialogContainer.width = options.pickerWidth;\n      if (options.savedColors) {\n        dialogContainer.height = containerSize;\n        const topRow = parseInt(options.pickerHeight) / parseInt(containerSize);\n        dialogContainer.addRowDefinition(topRow, false);\n        dialogContainer.addRowDefinition(1.0 - topRow, false);\n      } else {\n        dialogContainer.height = options.pickerHeight;\n        dialogContainer.addRowDefinition(1.0, false);\n      }\n      advancedTexture.addControl(dialogContainer);\n      // Swatch drawer which contains all saved color buttons\n      if (options.savedColors) {\n        swatchDrawer = new Grid();\n        swatchDrawer.name = \"Swatch Drawer\";\n        swatchDrawer.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\n        swatchDrawer.background = buttonBackgroundColor;\n        swatchDrawer.width = options.pickerWidth;\n        const initialRows = options.savedColors.length / options.numSwatchesPerLine;\n        let gutterCount;\n        if (initialRows == 0) {\n          gutterCount = 0;\n        } else {\n          gutterCount = initialRows + 1;\n        }\n        swatchDrawer.height = (swatchSize * initialRows + gutterCount * gutterSize).toString() + \"px\";\n        swatchDrawer.top = Math.floor(swatchSize * 0.25).toString() + \"px\";\n        for (let i = 0; i < Math.ceil(options.savedColors.length / options.numSwatchesPerLine) * 2 + 1; i++) {\n          if (i % 2 != 0) {\n            swatchDrawer.addRowDefinition(swatchSize, true);\n          } else {\n            swatchDrawer.addRowDefinition(gutterSize, true);\n          }\n        }\n        for (let i = 0; i < options.numSwatchesPerLine * 2 + 1; i++) {\n          if (i % 2 != 0) {\n            swatchDrawer.addColumnDefinition(swatchSize, true);\n          } else {\n            swatchDrawer.addColumnDefinition(gutterSize, true);\n          }\n        }\n        dialogContainer.addControl(swatchDrawer, 1, 0);\n      }\n      // Picker container\n      const pickerPanel = new Grid();\n      pickerPanel.name = \"Picker Panel\";\n      pickerPanel.height = options.pickerHeight;\n      const panelHead = parseInt(options.headerHeight) / parseInt(options.pickerHeight);\n      const pickerPanelRows = [panelHead, 1.0 - panelHead];\n      pickerPanel.addRowDefinition(pickerPanelRows[0], false);\n      pickerPanel.addRowDefinition(pickerPanelRows[1], false);\n      dialogContainer.addControl(pickerPanel, 0, 0);\n      // Picker container header\n      const header = new Rectangle();\n      header.name = \"Dialogue Header Bar\";\n      header.background = \"#cccccc\";\n      header.thickness = 0;\n      pickerPanel.addControl(header, 0, 0);\n      // Header close button\n      const closeButton = Button.CreateSimpleButton(\"closeButton\", \"a\");\n      closeButton.fontFamily = \"coreglyphs\";\n      const headerColor3 = Color3.FromHexString(header.background);\n      const closeIconColor = new Color3(1.0 - headerColor3.r, 1.0 - headerColor3.g, 1.0 - headerColor3.b);\n      closeButton.color = closeIconColor.toHexString();\n      closeButton.fontSize = Math.floor(parseInt(options.headerHeight) * 0.6);\n      closeButton.textBlock.textVerticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\n      closeButton.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_RIGHT;\n      closeButton.height = closeButton.width = options.headerHeight;\n      closeButton.background = header.background;\n      closeButton.thickness = 0;\n      closeButton.pointerDownAnimation = () => {};\n      closeButton.pointerUpAnimation = () => {\n        closeButton.background = header.background;\n      };\n      closeButton.pointerEnterAnimation = () => {\n        closeButton.color = header.background;\n        closeButton.background = \"red\";\n      };\n      closeButton.pointerOutAnimation = () => {\n        closeButton.color = closeIconColor.toHexString();\n        closeButton.background = header.background;\n      };\n      closeButton.onPointerClickObservable.add(() => {\n        closePicker(currentSwatch.background);\n      });\n      pickerPanel.addControl(closeButton, 0, 0);\n      // Dialog container body\n      const dialogBody = new Grid();\n      dialogBody.name = \"Dialogue Body\";\n      dialogBody.background = buttonBackgroundColor;\n      const dialogBodyCols = [0.4375, 0.5625];\n      dialogBody.addRowDefinition(1.0, false);\n      dialogBody.addColumnDefinition(dialogBodyCols[0], false);\n      dialogBody.addColumnDefinition(dialogBodyCols[1], false);\n      pickerPanel.addControl(dialogBody, 1, 0);\n      // Picker grid\n      const pickerGrid = new Grid();\n      pickerGrid.name = \"Picker Grid\";\n      pickerGrid.addRowDefinition(0.85, false);\n      pickerGrid.addRowDefinition(0.15, false);\n      dialogBody.addControl(pickerGrid, 0, 0);\n      //  Picker control\n      const picker = new ColorPicker();\n      picker.name = \"GUI Color Picker\";\n      if (options.pickerHeight < options.pickerWidth) {\n        picker.width = 0.89;\n      } else {\n        picker.height = 0.89;\n      }\n      picker.value = Color3.FromHexString(options.lastColor);\n      picker.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\n      picker.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\n      picker.onPointerDownObservable.add(() => {\n        activeField = picker.name;\n        lastVal = \"\";\n        editSwatches(false);\n      });\n      picker.onValueChangedObservable.add(function (value) {\n        // value is a color3\n        if (activeField == picker.name) {\n          updateValues(value, picker.name);\n        }\n      });\n      pickerGrid.addControl(picker, 0, 0);\n      // Picker body right quarant\n      const pickerBodyRight = new Grid();\n      pickerBodyRight.name = \"Dialogue Right Half\";\n      pickerBodyRight.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\n      const pickerBodyRightRows = [0.514, 0.486];\n      pickerBodyRight.addRowDefinition(pickerBodyRightRows[0], false);\n      pickerBodyRight.addRowDefinition(pickerBodyRightRows[1], false);\n      dialogBody.addControl(pickerBodyRight, 1, 1);\n      // Picker container swatches and buttons\n      const pickerSwatchesButtons = new Grid();\n      pickerSwatchesButtons.name = \"Swatches and Buttons\";\n      const pickerButtonsCol = [0.417, 0.583];\n      pickerSwatchesButtons.addRowDefinition(1.0, false);\n      pickerSwatchesButtons.addColumnDefinition(pickerButtonsCol[0], false);\n      pickerSwatchesButtons.addColumnDefinition(pickerButtonsCol[1], false);\n      pickerBodyRight.addControl(pickerSwatchesButtons, 0, 0);\n      // Picker Swatches quadrant\n      const pickerSwatches = new Grid();\n      pickerSwatches.name = \"New and Current Swatches\";\n      const pickeSwatchesRows = [0.04, 0.16, 0.64, 0.16];\n      pickerSwatches.addRowDefinition(pickeSwatchesRows[0], false);\n      pickerSwatches.addRowDefinition(pickeSwatchesRows[1], false);\n      pickerSwatches.addRowDefinition(pickeSwatchesRows[2], false);\n      pickerSwatches.addRowDefinition(pickeSwatchesRows[3], false);\n      pickerSwatchesButtons.addControl(pickerSwatches, 0, 0);\n      // Active swatches\n      const activeSwatches = new Grid();\n      activeSwatches.name = \"Active Swatches\";\n      activeSwatches.width = 0.67;\n      activeSwatches.addRowDefinition(0.5, false);\n      activeSwatches.addRowDefinition(0.5, false);\n      pickerSwatches.addControl(activeSwatches, 2, 0);\n      const labelWidth = Math.floor(parseInt(options.pickerWidth) * dialogBodyCols[1] * pickerButtonsCol[0] * 0.11);\n      const labelHeight = Math.floor(parseInt(options.pickerHeight) * pickerPanelRows[1] * pickerBodyRightRows[0] * pickeSwatchesRows[1] * 0.5);\n      let labelTextSize;\n      if (options.pickerWidth > options.pickerHeight) {\n        labelTextSize = labelHeight;\n      } else {\n        labelTextSize = labelWidth;\n      }\n      // New color swatch and previous color button\n      const newText = new TextBlock();\n      newText.text = \"new\";\n      newText.name = \"New Color Label\";\n      newText.color = buttonColor;\n      newText.fontSize = labelTextSize;\n      pickerSwatches.addControl(newText, 1, 0);\n      const newSwatch = new Rectangle();\n      newSwatch.name = \"New Color Swatch\";\n      newSwatch.background = options.lastColor;\n      newSwatch.thickness = 0;\n      activeSwatches.addControl(newSwatch, 0, 0);\n      const currentSwatch = Button.CreateSimpleButton(\"currentSwatch\", \"\");\n      currentSwatch.background = options.lastColor;\n      currentSwatch.thickness = 0;\n      currentSwatch.onPointerClickObservable.add(() => {\n        const revertColor = Color3.FromHexString(currentSwatch.background);\n        updateValues(revertColor, currentSwatch.name);\n        editSwatches(false);\n      });\n      currentSwatch.pointerDownAnimation = () => {};\n      currentSwatch.pointerUpAnimation = () => {};\n      currentSwatch.pointerEnterAnimation = () => {};\n      currentSwatch.pointerOutAnimation = () => {};\n      activeSwatches.addControl(currentSwatch, 1, 0);\n      const swatchOutline = new Rectangle();\n      swatchOutline.name = \"Swatch Outline\";\n      swatchOutline.width = 0.67;\n      swatchOutline.thickness = 2;\n      swatchOutline.color = currentSwatchesOutlineColor;\n      swatchOutline.isHitTestVisible = false;\n      pickerSwatches.addControl(swatchOutline, 2, 0);\n      const currentText = new TextBlock();\n      currentText.name = \"Current Color Label\";\n      currentText.text = \"current\";\n      currentText.color = buttonColor;\n      currentText.fontSize = labelTextSize;\n      pickerSwatches.addControl(currentText, 3, 0);\n      // Buttons grid\n      const buttonGrid = new Grid();\n      buttonGrid.name = \"Button Grid\";\n      buttonGrid.height = 0.8;\n      const buttonGridRows = 1 / 3;\n      buttonGrid.addRowDefinition(buttonGridRows, false);\n      buttonGrid.addRowDefinition(buttonGridRows, false);\n      buttonGrid.addRowDefinition(buttonGridRows, false);\n      pickerSwatchesButtons.addControl(buttonGrid, 0, 1);\n      // Determine pixel width and height for all buttons from overall panel dimensions\n      const buttonWidth = Math.floor(parseInt(options.pickerWidth) * dialogBodyCols[1] * pickerButtonsCol[1] * 0.67).toString() + \"px\";\n      const buttonHeight = Math.floor(parseInt(options.pickerHeight) * pickerPanelRows[1] * pickerBodyRightRows[0] * (parseFloat(buttonGrid.height.toString()) / 100) * buttonGridRows * 0.7).toString() + \"px\";\n      // Determine button type size\n      if (parseFloat(buttonWidth) > parseFloat(buttonHeight)) {\n        buttonFontSize = Math.floor(parseFloat(buttonHeight) * 0.45);\n      } else {\n        buttonFontSize = Math.floor(parseFloat(buttonWidth) * 0.11);\n      }\n      // Panel Buttons\n      const butOK = Button.CreateSimpleButton(\"butOK\", \"OK\");\n      butOK.width = buttonWidth;\n      butOK.height = buttonHeight;\n      butOK.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\n      butOK.thickness = 2;\n      butOK.color = buttonColor;\n      butOK.fontSize = buttonFontSize;\n      butOK.background = buttonBackgroundColor;\n      butOK.onPointerEnterObservable.add(() => {\n        butOK.background = buttonBackgroundHoverColor;\n      });\n      butOK.onPointerOutObservable.add(() => {\n        butOK.background = buttonBackgroundColor;\n      });\n      butOK.pointerDownAnimation = () => {\n        butOK.background = buttonBackgroundClickColor;\n      };\n      butOK.pointerUpAnimation = () => {\n        butOK.background = buttonBackgroundHoverColor;\n      };\n      butOK.onPointerClickObservable.add(() => {\n        editSwatches(false);\n        closePicker(newSwatch.background);\n      });\n      buttonGrid.addControl(butOK, 0, 0);\n      const butCancel = Button.CreateSimpleButton(\"butCancel\", \"Cancel\");\n      butCancel.width = buttonWidth;\n      butCancel.height = buttonHeight;\n      butCancel.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\n      butCancel.thickness = 2;\n      butCancel.color = buttonColor;\n      butCancel.fontSize = buttonFontSize;\n      butCancel.background = buttonBackgroundColor;\n      butCancel.onPointerEnterObservable.add(() => {\n        butCancel.background = buttonBackgroundHoverColor;\n      });\n      butCancel.onPointerOutObservable.add(() => {\n        butCancel.background = buttonBackgroundColor;\n      });\n      butCancel.pointerDownAnimation = () => {\n        butCancel.background = buttonBackgroundClickColor;\n      };\n      butCancel.pointerUpAnimation = () => {\n        butCancel.background = buttonBackgroundHoverColor;\n      };\n      butCancel.onPointerClickObservable.add(() => {\n        editSwatches(false);\n        closePicker(currentSwatch.background);\n      });\n      buttonGrid.addControl(butCancel, 1, 0);\n      if (options.savedColors) {\n        butSave = Button.CreateSimpleButton(\"butSave\", \"Save\");\n        butSave.width = buttonWidth;\n        butSave.height = buttonHeight;\n        butSave.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\n        butSave.thickness = 2;\n        butSave.fontSize = buttonFontSize;\n        if (options.savedColors.length < options.swatchLimit) {\n          butSave.color = buttonColor;\n          butSave.background = buttonBackgroundColor;\n        } else {\n          disableButton(butSave, true);\n        }\n        butSave.onPointerEnterObservable.add(() => {\n          if (options.savedColors) {\n            if (options.savedColors.length < options.swatchLimit) {\n              butSave.background = buttonBackgroundHoverColor;\n            }\n          }\n        });\n        butSave.onPointerOutObservable.add(() => {\n          if (options.savedColors) {\n            if (options.savedColors.length < options.swatchLimit) {\n              butSave.background = buttonBackgroundColor;\n            }\n          }\n        });\n        butSave.pointerDownAnimation = () => {\n          if (options.savedColors) {\n            if (options.savedColors.length < options.swatchLimit) {\n              butSave.background = buttonBackgroundClickColor;\n            }\n          }\n        };\n        butSave.pointerUpAnimation = () => {\n          if (options.savedColors) {\n            if (options.savedColors.length < options.swatchLimit) {\n              butSave.background = buttonBackgroundHoverColor;\n            }\n          }\n        };\n        butSave.onPointerClickObservable.add(() => {\n          if (options.savedColors) {\n            if (options.savedColors.length == 0) {\n              setEditButtonVisibility(true);\n            }\n            if (options.savedColors.length < options.swatchLimit) {\n              updateSwatches(newSwatch.background, butSave);\n            }\n            editSwatches(false);\n          }\n        });\n        if (options.savedColors.length > 0) {\n          setEditButtonVisibility(true);\n        }\n        buttonGrid.addControl(butSave, 2, 0);\n      }\n      // Picker color values input\n      const pickerColorValues = new Grid();\n      pickerColorValues.name = \"Dialog Lower Right\";\n      pickerColorValues.addRowDefinition(0.02, false);\n      pickerColorValues.addRowDefinition(0.63, false);\n      pickerColorValues.addRowDefinition(0.21, false);\n      pickerColorValues.addRowDefinition(0.14, false);\n      pickerBodyRight.addControl(pickerColorValues, 1, 0);\n      // RGB values text boxes\n      const currentColor = Color3.FromHexString(options.lastColor);\n      const rgbValuesQuadrant = new Grid();\n      rgbValuesQuadrant.name = \"RGB Values\";\n      rgbValuesQuadrant.width = 0.82;\n      rgbValuesQuadrant.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\n      rgbValuesQuadrant.addRowDefinition(1 / 3, false);\n      rgbValuesQuadrant.addRowDefinition(1 / 3, false);\n      rgbValuesQuadrant.addRowDefinition(1 / 3, false);\n      rgbValuesQuadrant.addColumnDefinition(0.1, false);\n      rgbValuesQuadrant.addColumnDefinition(0.2, false);\n      rgbValuesQuadrant.addColumnDefinition(0.7, false);\n      pickerColorValues.addControl(rgbValuesQuadrant, 1, 0);\n      for (let i = 0; i < inputFieldLabels.length; i++) {\n        const labelText = new TextBlock();\n        labelText.text = inputFieldLabels[i];\n        labelText.color = buttonColor;\n        labelText.fontSize = buttonFontSize;\n        rgbValuesQuadrant.addControl(labelText, i, 0);\n      }\n      // Input fields for RGB values\n      const rValInt = new InputText();\n      rValInt.width = 0.83;\n      rValInt.height = 0.72;\n      rValInt.name = \"rIntField\";\n      rValInt.fontSize = buttonFontSize;\n      rValInt.text = (currentColor.r * 255).toString();\n      rValInt.color = inputTextColor;\n      rValInt.background = inputTextBackgroundColor;\n      rValInt.onFocusObservable.add(() => {\n        activeField = rValInt.name;\n        lastVal = rValInt.text;\n        editSwatches(false);\n      });\n      rValInt.onBlurObservable.add(() => {\n        if (rValInt.text == \"\") {\n          rValInt.text = \"0\";\n        }\n        updateInt(rValInt, \"r\");\n        if (activeField == rValInt.name) {\n          activeField = \"\";\n        }\n      });\n      rValInt.onTextChangedObservable.add(() => {\n        if (activeField == rValInt.name) {\n          updateInt(rValInt, \"r\");\n        }\n      });\n      rgbValuesQuadrant.addControl(rValInt, 0, 1);\n      const gValInt = new InputText();\n      gValInt.width = 0.83;\n      gValInt.height = 0.72;\n      gValInt.name = \"gIntField\";\n      gValInt.fontSize = buttonFontSize;\n      gValInt.text = (currentColor.g * 255).toString();\n      gValInt.color = inputTextColor;\n      gValInt.background = inputTextBackgroundColor;\n      gValInt.onFocusObservable.add(() => {\n        activeField = gValInt.name;\n        lastVal = gValInt.text;\n        editSwatches(false);\n      });\n      gValInt.onBlurObservable.add(() => {\n        if (gValInt.text == \"\") {\n          gValInt.text = \"0\";\n        }\n        updateInt(gValInt, \"g\");\n        if (activeField == gValInt.name) {\n          activeField = \"\";\n        }\n      });\n      gValInt.onTextChangedObservable.add(() => {\n        if (activeField == gValInt.name) {\n          updateInt(gValInt, \"g\");\n        }\n      });\n      rgbValuesQuadrant.addControl(gValInt, 1, 1);\n      const bValInt = new InputText();\n      bValInt.width = 0.83;\n      bValInt.height = 0.72;\n      bValInt.name = \"bIntField\";\n      bValInt.fontSize = buttonFontSize;\n      bValInt.text = (currentColor.b * 255).toString();\n      bValInt.color = inputTextColor;\n      bValInt.background = inputTextBackgroundColor;\n      bValInt.onFocusObservable.add(() => {\n        activeField = bValInt.name;\n        lastVal = bValInt.text;\n        editSwatches(false);\n      });\n      bValInt.onBlurObservable.add(() => {\n        if (bValInt.text == \"\") {\n          bValInt.text = \"0\";\n        }\n        updateInt(bValInt, \"b\");\n        if (activeField == bValInt.name) {\n          activeField = \"\";\n        }\n      });\n      bValInt.onTextChangedObservable.add(() => {\n        if (activeField == bValInt.name) {\n          updateInt(bValInt, \"b\");\n        }\n      });\n      rgbValuesQuadrant.addControl(bValInt, 2, 1);\n      const rValDec = new InputText();\n      rValDec.width = 0.95;\n      rValDec.height = 0.72;\n      rValDec.name = \"rDecField\";\n      rValDec.fontSize = buttonFontSize;\n      rValDec.text = currentColor.r.toString();\n      rValDec.color = inputTextColor;\n      rValDec.background = inputTextBackgroundColor;\n      rValDec.onFocusObservable.add(() => {\n        activeField = rValDec.name;\n        lastVal = rValDec.text;\n        editSwatches(false);\n      });\n      rValDec.onBlurObservable.add(() => {\n        if (parseFloat(rValDec.text) == 0 || rValDec.text == \"\") {\n          rValDec.text = \"0\";\n          updateFloat(rValDec, \"r\");\n        }\n        if (activeField == rValDec.name) {\n          activeField = \"\";\n        }\n      });\n      rValDec.onTextChangedObservable.add(() => {\n        if (activeField == rValDec.name) {\n          updateFloat(rValDec, \"r\");\n        }\n      });\n      rgbValuesQuadrant.addControl(rValDec, 0, 2);\n      const gValDec = new InputText();\n      gValDec.width = 0.95;\n      gValDec.height = 0.72;\n      gValDec.name = \"gDecField\";\n      gValDec.fontSize = buttonFontSize;\n      gValDec.text = currentColor.g.toString();\n      gValDec.color = inputTextColor;\n      gValDec.background = inputTextBackgroundColor;\n      gValDec.onFocusObservable.add(() => {\n        activeField = gValDec.name;\n        lastVal = gValDec.text;\n        editSwatches(false);\n      });\n      gValDec.onBlurObservable.add(() => {\n        if (parseFloat(gValDec.text) == 0 || gValDec.text == \"\") {\n          gValDec.text = \"0\";\n          updateFloat(gValDec, \"g\");\n        }\n        if (activeField == gValDec.name) {\n          activeField = \"\";\n        }\n      });\n      gValDec.onTextChangedObservable.add(() => {\n        if (activeField == gValDec.name) {\n          updateFloat(gValDec, \"g\");\n        }\n      });\n      rgbValuesQuadrant.addControl(gValDec, 1, 2);\n      const bValDec = new InputText();\n      bValDec.width = 0.95;\n      bValDec.height = 0.72;\n      bValDec.name = \"bDecField\";\n      bValDec.fontSize = buttonFontSize;\n      bValDec.text = currentColor.b.toString();\n      bValDec.color = inputTextColor;\n      bValDec.background = inputTextBackgroundColor;\n      bValDec.onFocusObservable.add(() => {\n        activeField = bValDec.name;\n        lastVal = bValDec.text;\n        editSwatches(false);\n      });\n      bValDec.onBlurObservable.add(() => {\n        if (parseFloat(bValDec.text) == 0 || bValDec.text == \"\") {\n          bValDec.text = \"0\";\n          updateFloat(bValDec, \"b\");\n        }\n        if (activeField == bValDec.name) {\n          activeField = \"\";\n        }\n      });\n      bValDec.onTextChangedObservable.add(() => {\n        if (activeField == bValDec.name) {\n          updateFloat(bValDec, \"b\");\n        }\n      });\n      rgbValuesQuadrant.addControl(bValDec, 2, 2);\n      // Hex value input\n      const hexValueQuadrant = new Grid();\n      hexValueQuadrant.name = \"Hex Value\";\n      hexValueQuadrant.width = 0.82;\n      hexValueQuadrant.addRowDefinition(1.0, false);\n      hexValueQuadrant.addColumnDefinition(0.1, false);\n      hexValueQuadrant.addColumnDefinition(0.9, false);\n      pickerColorValues.addControl(hexValueQuadrant, 2, 0);\n      const labelText = new TextBlock();\n      labelText.text = \"#\";\n      labelText.color = buttonColor;\n      labelText.fontSize = buttonFontSize;\n      hexValueQuadrant.addControl(labelText, 0, 0);\n      const hexVal = new InputText();\n      hexVal.width = 0.96;\n      hexVal.height = 0.72;\n      hexVal.name = \"hexField\";\n      hexVal.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\n      hexVal.fontSize = buttonFontSize;\n      const minusPound = options.lastColor.split(\"#\");\n      hexVal.text = minusPound[1];\n      hexVal.color = inputTextColor;\n      hexVal.background = inputTextBackgroundColor;\n      hexVal.onFocusObservable.add(() => {\n        activeField = hexVal.name;\n        lastVal = hexVal.text;\n        editSwatches(false);\n      });\n      hexVal.onBlurObservable.add(() => {\n        if (hexVal.text.length == 3) {\n          const val = hexVal.text.split(\"\");\n          hexVal.text = val[0] + val[0] + val[1] + val[1] + val[2] + val[2];\n        }\n        if (hexVal.text == \"\") {\n          hexVal.text = \"000000\";\n          updateValues(Color3.FromHexString(hexVal.text), \"b\");\n        }\n        if (activeField == hexVal.name) {\n          activeField = \"\";\n        }\n      });\n      hexVal.onTextChangedObservable.add(() => {\n        let newHexValue = hexVal.text;\n        const checkHex = /[^0-9A-F]/i.test(newHexValue);\n        if ((hexVal.text.length > 6 || checkHex) && activeField == hexVal.name) {\n          hexVal.text = lastVal;\n        } else {\n          if (hexVal.text.length < 6) {\n            const leadingZero = 6 - hexVal.text.length;\n            for (let i = 0; i < leadingZero; i++) {\n              newHexValue = \"0\" + newHexValue;\n            }\n          }\n          if (hexVal.text.length == 3) {\n            const val = hexVal.text.split(\"\");\n            newHexValue = val[0] + val[0] + val[1] + val[1] + val[2] + val[2];\n          }\n          newHexValue = \"#\" + newHexValue;\n          if (activeField == hexVal.name) {\n            lastVal = hexVal.text;\n            updateValues(Color3.FromHexString(newHexValue), hexVal.name);\n          }\n        }\n      });\n      hexValueQuadrant.addControl(hexVal, 0, 1);\n      if (options.savedColors && options.savedColors.length > 0) {\n        updateSwatches(\"\", butSave);\n      }\n      /**\n       * Will update all values for InputText and ColorPicker controls based on the BABYLON.Color3 passed to this function.\n       * Each InputText control and the ColorPicker control will be tested to see if they are the activeField and if they\n       * are will receive no update. This is to prevent the input from the user being overwritten.\n       * @param value\n       * @param inputField\n       */\n      function updateValues(value, inputField) {\n        activeField = inputField;\n        const pickedColor = value.toHexString();\n        newSwatch.background = pickedColor;\n        if (rValInt.name != activeField) {\n          rValInt.text = Math.floor(value.r * 255).toString();\n        }\n        if (gValInt.name != activeField) {\n          gValInt.text = Math.floor(value.g * 255).toString();\n        }\n        if (bValInt.name != activeField) {\n          bValInt.text = Math.floor(value.b * 255).toString();\n        }\n        if (rValDec.name != activeField) {\n          rValDec.text = value.r.toString();\n        }\n        if (gValDec.name != activeField) {\n          gValDec.text = value.g.toString();\n        }\n        if (bValDec.name != activeField) {\n          bValDec.text = value.b.toString();\n        }\n        if (hexVal.name != activeField) {\n          const minusPound = pickedColor.split(\"#\");\n          hexVal.text = minusPound[1];\n        }\n        if (picker.name != activeField) {\n          picker.value = value;\n        }\n      }\n      // When the user enters an integer for R, G, or B we check to make sure it is a valid number and replace if not.\n      function updateInt(field, channel) {\n        let newValue = field.text;\n        const checkVal = /[^0-9]/g.test(newValue);\n        if (checkVal) {\n          field.text = lastVal;\n          return;\n        } else {\n          if (newValue != \"\") {\n            if (Math.floor(parseInt(newValue)) < 0) {\n              newValue = \"0\";\n            } else if (Math.floor(parseInt(newValue)) > 255) {\n              newValue = \"255\";\n            } else if (isNaN(parseInt(newValue))) {\n              newValue = \"0\";\n            }\n          }\n          if (activeField == field.name) {\n            lastVal = newValue;\n          }\n        }\n        if (newValue != \"\") {\n          newValue = parseInt(newValue).toString();\n          field.text = newValue;\n          const newSwatchRGB = Color3.FromHexString(newSwatch.background);\n          if (activeField == field.name) {\n            if (channel == \"r\") {\n              updateValues(new Color3(parseInt(newValue) / 255, newSwatchRGB.g, newSwatchRGB.b), field.name);\n            } else if (channel == \"g\") {\n              updateValues(new Color3(newSwatchRGB.r, parseInt(newValue) / 255, newSwatchRGB.b), field.name);\n            } else {\n              updateValues(new Color3(newSwatchRGB.r, newSwatchRGB.g, parseInt(newValue) / 255), field.name);\n            }\n          }\n        }\n      }\n      // When the user enters a float for R, G, or B we check to make sure it is a valid number and replace if not.\n      function updateFloat(field, channel) {\n        let newValue = field.text;\n        const checkVal = /[^0-9.]/g.test(newValue);\n        if (checkVal) {\n          field.text = lastVal;\n          return;\n        } else {\n          if (newValue != \"\" && newValue != \".\" && parseFloat(newValue) != 0) {\n            if (parseFloat(newValue) < 0.0) {\n              newValue = \"0.0\";\n            } else if (parseFloat(newValue) > 1.0) {\n              newValue = \"1.0\";\n            } else if (isNaN(parseFloat(newValue))) {\n              newValue = \"0.0\";\n            }\n          }\n          if (activeField == field.name) {\n            lastVal = newValue;\n          }\n        }\n        if (newValue != \"\" && newValue != \".\" && parseFloat(newValue) != 0) {\n          newValue = parseFloat(newValue).toString();\n          field.text = newValue;\n        } else {\n          newValue = \"0.0\";\n        }\n        const newSwatchRGB = Color3.FromHexString(newSwatch.background);\n        if (activeField == field.name) {\n          if (channel == \"r\") {\n            updateValues(new Color3(parseFloat(newValue), newSwatchRGB.g, newSwatchRGB.b), field.name);\n          } else if (channel == \"g\") {\n            updateValues(new Color3(newSwatchRGB.r, parseFloat(newValue), newSwatchRGB.b), field.name);\n          } else {\n            updateValues(new Color3(newSwatchRGB.r, newSwatchRGB.g, parseFloat(newValue)), field.name);\n          }\n        }\n      }\n      // Removes the current index from the savedColors array. Drawer can then be regenerated.\n      function deleteSwatch(index) {\n        if (options.savedColors) {\n          options.savedColors.splice(index, 1);\n        }\n        if (options.savedColors && options.savedColors.length == 0) {\n          setEditButtonVisibility(false);\n          editSwatchMode = false;\n        }\n      }\n      // Creates and styles an individual swatch when updateSwatches is called.\n      function createSwatch() {\n        if (options.savedColors && options.savedColors[swatchNumber]) {\n          let icon;\n          if (editSwatchMode) {\n            icon = \"b\";\n          } else {\n            icon = \"\";\n          }\n          const swatch = Button.CreateSimpleButton(\"Swatch_\" + swatchNumber, icon);\n          swatch.fontFamily = \"coreglyphs\";\n          const swatchColor = Color3.FromHexString(options.savedColors[swatchNumber]);\n          const swatchLuminence = swatchColor.r + swatchColor.g + swatchColor.b;\n          // Set color of outline and textBlock based on luminance of the color swatch so feedback always visible\n          if (swatchLuminence > luminanceLimit) {\n            swatch.color = iconColorDark;\n          } else {\n            swatch.color = iconColorLight;\n          }\n          swatch.fontSize = Math.floor(swatchSize * 0.7);\n          swatch.textBlock.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\n          swatch.height = swatch.width = swatchSize.toString() + \"px\";\n          swatch.background = options.savedColors[swatchNumber];\n          swatch.thickness = 2;\n          const metadata = swatchNumber;\n          swatch.pointerDownAnimation = () => {\n            swatch.thickness = 4;\n          };\n          swatch.pointerUpAnimation = () => {\n            swatch.thickness = 3;\n          };\n          swatch.pointerEnterAnimation = () => {\n            swatch.thickness = 3;\n          };\n          swatch.pointerOutAnimation = () => {\n            swatch.thickness = 2;\n          };\n          swatch.onPointerClickObservable.add(() => {\n            if (!editSwatchMode) {\n              if (options.savedColors) {\n                updateValues(Color3.FromHexString(options.savedColors[metadata]), swatch.name);\n              }\n            } else {\n              deleteSwatch(metadata);\n              updateSwatches(\"\", butSave);\n            }\n          });\n          return swatch;\n        } else {\n          return null;\n        }\n      }\n      // Mode switch to render button text and close symbols on swatch controls\n      function editSwatches(mode) {\n        if (mode !== undefined) {\n          editSwatchMode = mode;\n        }\n        let thisButton;\n        if (editSwatchMode) {\n          for (let i = 0; i < swatchDrawer.children.length; i++) {\n            thisButton = swatchDrawer.children[i];\n            thisButton.textBlock.text = \"b\";\n          }\n          if (butEdit !== undefined) {\n            butEdit.textBlock.text = \"Done\";\n          }\n        } else {\n          for (let i = 0; i < swatchDrawer.children.length; i++) {\n            thisButton = swatchDrawer.children[i];\n            thisButton.textBlock.text = \"\";\n          }\n          if (butEdit !== undefined) {\n            butEdit.textBlock.text = \"Edit\";\n          }\n        }\n      }\n      /**\n       * When Save Color button is pressed this function will first create a swatch drawer if one is not already\n       * made. Then all controls are removed from the drawer and we step through the savedColors array and\n       * creates one swatch per color. It will also set the height of the drawer control based on how many\n       * saved colors there are and how many can be stored per row.\n       * @param color\n       * @param button\n       */\n      function updateSwatches(color, button) {\n        if (options.savedColors) {\n          if (color != \"\") {\n            options.savedColors.push(color);\n          }\n          swatchNumber = 0;\n          swatchDrawer.clearControls();\n          const rowCount = Math.ceil(options.savedColors.length / options.numSwatchesPerLine);\n          let gutterCount;\n          if (rowCount == 0) {\n            gutterCount = 0;\n          } else {\n            gutterCount = rowCount + 1;\n          }\n          if (swatchDrawer.rowCount != rowCount + gutterCount) {\n            const currentRows = swatchDrawer.rowCount;\n            for (let i = 0; i < currentRows; i++) {\n              swatchDrawer.removeRowDefinition(0);\n            }\n            for (let i = 0; i < rowCount + gutterCount; i++) {\n              if (i % 2) {\n                swatchDrawer.addRowDefinition(swatchSize, true);\n              } else {\n                swatchDrawer.addRowDefinition(gutterSize, true);\n              }\n            }\n          }\n          swatchDrawer.height = (swatchSize * rowCount + gutterCount * gutterSize).toString() + \"px\";\n          for (let y = 1, thisRow = 1; y < rowCount + gutterCount; y += 2, thisRow++) {\n            // Determine number of buttons to create per row based on the button limit per row and number of saved colors\n            let totalButtonsThisRow;\n            if (options.savedColors.length > thisRow * options.numSwatchesPerLine) {\n              totalButtonsThisRow = options.numSwatchesPerLine;\n            } else {\n              totalButtonsThisRow = options.savedColors.length - (thisRow - 1) * options.numSwatchesPerLine;\n            }\n            const buttonIterations = Math.min(Math.max(totalButtonsThisRow, 0), options.numSwatchesPerLine);\n            for (let x = 0, w = 1; x < buttonIterations; x++) {\n              if (x > options.numSwatchesPerLine) {\n                continue;\n              }\n              const swatch = createSwatch();\n              if (swatch != null) {\n                swatchDrawer.addControl(swatch, y, w);\n                w += 2;\n                swatchNumber++;\n              } else {\n                continue;\n              }\n            }\n          }\n          if (options.savedColors.length >= options.swatchLimit) {\n            disableButton(button, true);\n          } else {\n            disableButton(button, false);\n          }\n        }\n      }\n      // Shows or hides edit swatches button depending on if there are saved swatches\n      function setEditButtonVisibility(enableButton) {\n        if (enableButton) {\n          butEdit = Button.CreateSimpleButton(\"butEdit\", \"Edit\");\n          butEdit.width = buttonWidth;\n          butEdit.height = buttonHeight;\n          butEdit.left = Math.floor(parseInt(buttonWidth) * 0.1).toString() + \"px\";\n          butEdit.top = (parseFloat(butEdit.left) * -1).toString() + \"px\";\n          butEdit.verticalAlignment = Control.VERTICAL_ALIGNMENT_BOTTOM;\n          butEdit.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\n          butEdit.thickness = 2;\n          butEdit.color = buttonColor;\n          butEdit.fontSize = buttonFontSize;\n          butEdit.background = buttonBackgroundColor;\n          butEdit.onPointerEnterObservable.add(() => {\n            butEdit.background = buttonBackgroundHoverColor;\n          });\n          butEdit.onPointerOutObservable.add(() => {\n            butEdit.background = buttonBackgroundColor;\n          });\n          butEdit.pointerDownAnimation = () => {\n            butEdit.background = buttonBackgroundClickColor;\n          };\n          butEdit.pointerUpAnimation = () => {\n            butEdit.background = buttonBackgroundHoverColor;\n          };\n          butEdit.onPointerClickObservable.add(() => {\n            if (editSwatchMode) {\n              editSwatchMode = false;\n            } else {\n              editSwatchMode = true;\n            }\n            editSwatches();\n          });\n          pickerGrid.addControl(butEdit, 1, 0);\n        } else {\n          pickerGrid.removeControl(butEdit);\n        }\n      }\n      // Called when the user hits the limit of saved colors in the drawer.\n      function disableButton(button, disabled) {\n        if (disabled) {\n          button.color = buttonDisabledColor;\n          button.background = buttonDisabledBackgroundColor;\n        } else {\n          button.color = buttonColor;\n          button.background = buttonBackgroundColor;\n        }\n      }\n      // Passes last chosen color back to scene and kills dialog by removing from AdvancedDynamicTexture\n      function closePicker(color) {\n        if (options.savedColors && options.savedColors.length > 0) {\n          resolve({\n            savedColors: options.savedColors,\n            pickedColor: color\n          });\n        } else {\n          resolve({\n            pickedColor: color\n          });\n        }\n        advancedTexture.removeControl(dialogContainer);\n      }\n    });\n  }\n}\nColorPicker._Epsilon = 0.000001;\n__decorate([serialize()], ColorPicker.prototype, \"value\", null);\n__decorate([serialize()], ColorPicker.prototype, \"width\", null);\n__decorate([serialize()], ColorPicker.prototype, \"height\", null);\n__decorate([serialize()], ColorPicker.prototype, \"size\", null);\nRegisterClass(\"BABYLON.GUI.ColorPicker\", ColorPicker);","map":{"version":3,"names":["Observable","Control","InputText","Rectangle","Button","Grid","TextBlock","RegisterClass","Color3","serialize","EngineStore","ColorPicker","value","_value","equals","copyFrom","toHSVToRef","_tmpColor","_h","r","_s","Math","max","g","_v","b","_markAsDirty","_Epsilon","onValueChangedObservable","notifyObservers","width","_width","toString","_host","fromString","getValue","_height","height","size","constructor","name","Red","_pointerStartedOnSquare","_pointerStartedOnWheel","_squareLeft","_squareTop","_squareSize","_lastPointerDownId","_pointerIsDown","isPointerBlocker","_getTypeName","_preMeasure","parentMeasure","_currentMeasure","_updateSquareProps","radius","min","wheelThickness","innerDiameter","squareSize","sqrt","offset","left","top","_drawGradientSquare","hueValue","context","lgh","createLinearGradient","addColorStop","fillStyle","fillRect","lgv","_drawCircle","centerX","centerY","beginPath","arc","PI","lineWidth","strokeStyle","stroke","_createColorWheelCanvas","thickness","engine","LastCreatedEngine","Error","canvas","createCanvas","getContext","image","getImageData","data","color","maxDistSq","innerRadius","minDistSq","x","y","distSq","dist","ang","atan2","HSVtoRGBToRef","index","alphaRatio","alphaAmount","maxAlpha","minAlpha","lowerRadius","upperRadius","putImageData","_draw","save","_applyStates","_colorWheelCanvas","shadowBlur","shadowOffsetX","shadowOffsetY","shadowColor","drawImage","cx","cy","cos","sin","restore","_updateValueFromPointer","_isPointOnSquare","_isPointOnWheel","radiusSq","innerRadiusSq","dx","dy","_onPointerDown","target","coordinates","pointerId","buttonIndex","pi","isReadOnly","_invertTransformMatrix","transformCoordinates","_transformedPosition","_capturingControl","_onPointerMove","_onPointerUp","notifyClick","_onCanvasBlur","_forcePointerUp","ShowPickerDialogAsync","advancedTexture","options","Promise","resolve","pickerWidth","pickerHeight","headerHeight","lastColor","swatchLimit","numSwatchesPerLine","drawerMaxRows","rawSwatchSize","parseFloat","gutterSize","floor","colGutters","swatchSize","drawerMaxSize","containerSize","parseInt","buttonColor","buttonBackgroundColor","buttonBackgroundHoverColor","buttonBackgroundClickColor","buttonDisabledColor","buttonDisabledBackgroundColor","currentSwatchesOutlineColor","luminanceLimitColor","FromHexString","luminanceLimit","iconColorDark","iconColorLight","buttonFontSize","butEdit","inputFieldLabels","inputTextBackgroundColor","inputTextColor","swatchNumber","swatchDrawer","editSwatchMode","butSave","lastVal","activeField","dialogContainer","savedColors","topRow","addRowDefinition","addControl","verticalAlignment","VERTICAL_ALIGNMENT_TOP","background","initialRows","length","gutterCount","i","ceil","addColumnDefinition","pickerPanel","panelHead","pickerPanelRows","header","closeButton","CreateSimpleButton","fontFamily","headerColor3","closeIconColor","toHexString","fontSize","textBlock","textVerticalAlignment","VERTICAL_ALIGNMENT_CENTER","horizontalAlignment","HORIZONTAL_ALIGNMENT_RIGHT","pointerDownAnimation","pointerUpAnimation","pointerEnterAnimation","pointerOutAnimation","onPointerClickObservable","add","closePicker","currentSwatch","dialogBody","dialogBodyCols","pickerGrid","picker","HORIZONTAL_ALIGNMENT_CENTER","onPointerDownObservable","editSwatches","updateValues","pickerBodyRight","HORIZONTAL_ALIGNMENT_LEFT","pickerBodyRightRows","pickerSwatchesButtons","pickerButtonsCol","pickerSwatches","pickeSwatchesRows","activeSwatches","labelWidth","labelHeight","labelTextSize","newText","text","newSwatch","revertColor","swatchOutline","isHitTestVisible","currentText","buttonGrid","buttonGridRows","buttonWidth","buttonHeight","butOK","onPointerEnterObservable","onPointerOutObservable","butCancel","disableButton","setEditButtonVisibility","updateSwatches","pickerColorValues","currentColor","rgbValuesQuadrant","labelText","rValInt","onFocusObservable","onBlurObservable","updateInt","onTextChangedObservable","gValInt","bValInt","rValDec","updateFloat","gValDec","bValDec","hexValueQuadrant","hexVal","minusPound","split","val","newHexValue","checkHex","test","leadingZero","inputField","pickedColor","field","channel","newValue","checkVal","isNaN","newSwatchRGB","deleteSwatch","splice","createSwatch","icon","swatch","swatchColor","swatchLuminence","metadata","mode","undefined","thisButton","children","button","push","clearControls","rowCount","currentRows","removeRowDefinition","thisRow","totalButtonsThisRow","buttonIterations","w","enableButton","VERTICAL_ALIGNMENT_BOTTOM","removeControl","disabled","__decorate"],"sources":["../../../../../dev/gui/src/2D/controls/colorpicker.ts"],"sourcesContent":["import { Observable } from \"core/Misc/observable\";\r\nimport type { Vector2 } from \"core/Maths/math.vector\";\r\n\r\nimport { Control } from \"./control\";\r\nimport type { Measure } from \"../measure\";\r\nimport { InputText } from \"./inputText\";\r\nimport { Rectangle } from \"./rectangle\";\r\nimport { Button } from \"./button\";\r\nimport { Grid } from \"./grid\";\r\nimport type { AdvancedDynamicTexture } from \"../advancedDynamicTexture\";\r\nimport { TextBlock } from \"../controls/textBlock\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { PointerInfoBase } from \"core/Events/pointerEvents\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport type { ICanvas, ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\nimport { EngineStore } from \"core/Engines/engineStore\";\r\n\r\n/** Class used to create color pickers */\r\nexport class ColorPicker extends Control {\r\n    private static _Epsilon = 0.000001;\r\n    private _colorWheelCanvas: ICanvas;\r\n\r\n    private _value: Color3 = Color3.Red();\r\n    private _tmpColor = new Color3();\r\n\r\n    private _pointerStartedOnSquare = false;\r\n    private _pointerStartedOnWheel = false;\r\n\r\n    private _squareLeft = 0;\r\n    private _squareTop = 0;\r\n    private _squareSize = 0;\r\n\r\n    private _h = 360;\r\n    private _s = 1;\r\n    private _v = 1;\r\n\r\n    private _lastPointerDownId = -1;\r\n\r\n    /**\r\n     * Observable raised when the value changes\r\n     */\r\n    public onValueChangedObservable = new Observable<Color3>();\r\n\r\n    /** Gets or sets the color of the color picker */\r\n    @serialize()\r\n    public get value(): Color3 {\r\n        return this._value;\r\n    }\r\n\r\n    public set value(value: Color3) {\r\n        if (this._value.equals(value)) {\r\n            return;\r\n        }\r\n\r\n        this._value.copyFrom(value);\r\n\r\n        this._value.toHSVToRef(this._tmpColor);\r\n\r\n        this._h = this._tmpColor.r;\r\n        this._s = Math.max(this._tmpColor.g, 0.00001);\r\n        this._v = Math.max(this._tmpColor.b, 0.00001);\r\n\r\n        this._markAsDirty();\r\n\r\n        if (this._value.r <= ColorPicker._Epsilon) {\r\n            this._value.r = 0;\r\n        }\r\n\r\n        if (this._value.g <= ColorPicker._Epsilon) {\r\n            this._value.g = 0;\r\n        }\r\n\r\n        if (this._value.b <= ColorPicker._Epsilon) {\r\n            this._value.b = 0;\r\n        }\r\n\r\n        if (this._value.r >= 1.0 - ColorPicker._Epsilon) {\r\n            this._value.r = 1.0;\r\n        }\r\n\r\n        if (this._value.g >= 1.0 - ColorPicker._Epsilon) {\r\n            this._value.g = 1.0;\r\n        }\r\n\r\n        if (this._value.b >= 1.0 - ColorPicker._Epsilon) {\r\n            this._value.b = 1.0;\r\n        }\r\n\r\n        this.onValueChangedObservable.notifyObservers(this._value);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets control width\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#position-and-size\r\n     */\r\n    @serialize()\r\n    public get width(): string | number {\r\n        return this._width.toString(this._host);\r\n    }\r\n\r\n    public set width(value: string | number) {\r\n        if (this._width.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._width.fromString(value)) {\r\n            if (this._width.getValue(this._host) === 0) {\r\n                value = \"1px\";\r\n                this._width.fromString(value);\r\n            }\r\n            this._height.fromString(value);\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets control height\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#position-and-size\r\n     */\r\n    @serialize()\r\n    public get height(): string | number {\r\n        return this._height.toString(this._host);\r\n    }\r\n\r\n    /** Gets or sets control height */\r\n    public set height(value: string | number) {\r\n        if (this._height.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._height.fromString(value)) {\r\n            if (this._height.getValue(this._host) === 0) {\r\n                value = \"1px\";\r\n                this._height.fromString(value);\r\n            }\r\n            this._width.fromString(value);\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /** Gets or sets control size */\r\n    @serialize()\r\n    public get size(): string | number {\r\n        return this.width;\r\n    }\r\n\r\n    public set size(value: string | number) {\r\n        this.width = value;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ColorPicker\r\n     * @param name defines the control name\r\n     */\r\n    constructor(public name?: string) {\r\n        super(name);\r\n        this.value = new Color3(0.88, 0.1, 0.1);\r\n        this.size = \"200px\";\r\n        this.isPointerBlocker = true;\r\n    }\r\n\r\n    protected _getTypeName(): string {\r\n        return \"ColorPicker\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _preMeasure(parentMeasure: Measure): void {\r\n        if (parentMeasure.width < parentMeasure.height) {\r\n            this._currentMeasure.height = parentMeasure.width;\r\n        } else {\r\n            this._currentMeasure.width = parentMeasure.height;\r\n        }\r\n    }\r\n\r\n    private _updateSquareProps(): void {\r\n        const radius = Math.min(this._currentMeasure.width, this._currentMeasure.height) * 0.5;\r\n        const wheelThickness = radius * 0.2;\r\n        const innerDiameter = (radius - wheelThickness) * 2;\r\n        const squareSize = innerDiameter / Math.sqrt(2);\r\n        const offset = radius - squareSize * 0.5;\r\n\r\n        this._squareLeft = this._currentMeasure.left + offset;\r\n        this._squareTop = this._currentMeasure.top + offset;\r\n        this._squareSize = squareSize;\r\n    }\r\n\r\n    private _drawGradientSquare(hueValue: number, left: number, top: number, width: number, height: number, context: ICanvasRenderingContext) {\r\n        const lgh = context.createLinearGradient(left, top, width + left, top);\r\n        lgh.addColorStop(0, \"#fff\");\r\n        lgh.addColorStop(1, \"hsl(\" + hueValue + \", 100%, 50%)\");\r\n\r\n        context.fillStyle = lgh;\r\n        context.fillRect(left, top, width, height);\r\n\r\n        const lgv = context.createLinearGradient(left, top, left, height + top);\r\n        lgv.addColorStop(0, \"rgba(0,0,0,0)\");\r\n        lgv.addColorStop(1, \"#000\");\r\n\r\n        context.fillStyle = lgv;\r\n        context.fillRect(left, top, width, height);\r\n    }\r\n\r\n    private _drawCircle(centerX: number, centerY: number, radius: number, context: ICanvasRenderingContext) {\r\n        context.beginPath();\r\n        context.arc(centerX, centerY, radius + 1, 0, 2 * Math.PI, false);\r\n        context.lineWidth = 3;\r\n        context.strokeStyle = \"#333333\";\r\n        context.stroke();\r\n        context.beginPath();\r\n        context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\r\n        context.lineWidth = 3;\r\n        context.strokeStyle = \"#ffffff\";\r\n        context.stroke();\r\n    }\r\n\r\n    private _createColorWheelCanvas(radius: number, thickness: number): ICanvas {\r\n        // Shoudl abstract platform instead of using LastCreatedEngine\r\n        const engine = EngineStore.LastCreatedEngine;\r\n        if (!engine) {\r\n            throw new Error(\"Invalid engine. Unable to create a canvas.\");\r\n        }\r\n        const canvas = engine.createCanvas(radius * 2, radius * 2);\r\n        const context = canvas.getContext(\"2d\");\r\n        const image = context.getImageData(0, 0, radius * 2, radius * 2);\r\n        const data = image.data;\r\n\r\n        const color = this._tmpColor;\r\n        const maxDistSq = radius * radius;\r\n        const innerRadius = radius - thickness;\r\n        const minDistSq = innerRadius * innerRadius;\r\n\r\n        for (let x = -radius; x < radius; x++) {\r\n            for (let y = -radius; y < radius; y++) {\r\n                const distSq = x * x + y * y;\r\n\r\n                if (distSq > maxDistSq || distSq < minDistSq) {\r\n                    continue;\r\n                }\r\n\r\n                const dist = Math.sqrt(distSq);\r\n                const ang = Math.atan2(y, x);\r\n\r\n                Color3.HSVtoRGBToRef((ang * 180) / Math.PI + 180, dist / radius, 1, color);\r\n\r\n                const index = (x + radius + (y + radius) * 2 * radius) * 4;\r\n\r\n                data[index] = color.r * 255;\r\n                data[index + 1] = color.g * 255;\r\n                data[index + 2] = color.b * 255;\r\n                let alphaRatio = (dist - innerRadius) / (radius - innerRadius);\r\n\r\n                //apply less alpha to bigger color pickers\r\n                let alphaAmount = 0.2;\r\n                const maxAlpha = 0.2;\r\n                const minAlpha = 0.04;\r\n                const lowerRadius = 50;\r\n                const upperRadius = 150;\r\n\r\n                if (radius < lowerRadius) {\r\n                    alphaAmount = maxAlpha;\r\n                } else if (radius > upperRadius) {\r\n                    alphaAmount = minAlpha;\r\n                } else {\r\n                    alphaAmount = ((minAlpha - maxAlpha) * (radius - lowerRadius)) / (upperRadius - lowerRadius) + maxAlpha;\r\n                }\r\n\r\n                alphaRatio = (dist - innerRadius) / (radius - innerRadius);\r\n\r\n                if (alphaRatio < alphaAmount) {\r\n                    data[index + 3] = 255 * (alphaRatio / alphaAmount);\r\n                } else if (alphaRatio > 1 - alphaAmount) {\r\n                    data[index + 3] = 255 * (1.0 - (alphaRatio - (1 - alphaAmount)) / alphaAmount);\r\n                } else {\r\n                    data[index + 3] = 255;\r\n                }\r\n            }\r\n        }\r\n\r\n        context.putImageData(image, 0, 0);\r\n\r\n        return canvas;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _draw(context: ICanvasRenderingContext): void {\r\n        context.save();\r\n\r\n        this._applyStates(context);\r\n\r\n        const radius = Math.min(this._currentMeasure.width, this._currentMeasure.height) * 0.5;\r\n        const wheelThickness = radius * 0.2;\r\n        const left = this._currentMeasure.left;\r\n        const top = this._currentMeasure.top;\r\n\r\n        if (!this._colorWheelCanvas || this._colorWheelCanvas.width != radius * 2) {\r\n            this._colorWheelCanvas = this._createColorWheelCanvas(radius, wheelThickness);\r\n        }\r\n\r\n        this._updateSquareProps();\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowColor = this.shadowColor;\r\n            context.shadowBlur = this.shadowBlur;\r\n            context.shadowOffsetX = this.shadowOffsetX;\r\n            context.shadowOffsetY = this.shadowOffsetY;\r\n\r\n            context.fillRect(this._squareLeft, this._squareTop, this._squareSize, this._squareSize);\r\n        }\r\n\r\n        context.drawImage(this._colorWheelCanvas, left, top);\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowBlur = 0;\r\n            context.shadowOffsetX = 0;\r\n            context.shadowOffsetY = 0;\r\n        }\r\n\r\n        this._drawGradientSquare(this._h, this._squareLeft, this._squareTop, this._squareSize, this._squareSize, context);\r\n\r\n        let cx = this._squareLeft + this._squareSize * this._s;\r\n        let cy = this._squareTop + this._squareSize * (1 - this._v);\r\n\r\n        this._drawCircle(cx, cy, radius * 0.04, context);\r\n\r\n        const dist = radius - wheelThickness * 0.5;\r\n        cx = left + radius + Math.cos(((this._h - 180) * Math.PI) / 180) * dist;\r\n        cy = top + radius + Math.sin(((this._h - 180) * Math.PI) / 180) * dist;\r\n        this._drawCircle(cx, cy, wheelThickness * 0.35, context);\r\n\r\n        context.restore();\r\n    }\r\n\r\n    // Events\r\n    private _pointerIsDown = false;\r\n\r\n    private _updateValueFromPointer(x: number, y: number): void {\r\n        if (this._pointerStartedOnWheel) {\r\n            const radius = Math.min(this._currentMeasure.width, this._currentMeasure.height) * 0.5;\r\n            const centerX = radius + this._currentMeasure.left;\r\n            const centerY = radius + this._currentMeasure.top;\r\n            this._h = (Math.atan2(y - centerY, x - centerX) * 180) / Math.PI + 180;\r\n        } else if (this._pointerStartedOnSquare) {\r\n            this._updateSquareProps();\r\n            this._s = (x - this._squareLeft) / this._squareSize;\r\n            this._v = 1 - (y - this._squareTop) / this._squareSize;\r\n            this._s = Math.min(this._s, 1);\r\n            this._s = Math.max(this._s, ColorPicker._Epsilon);\r\n            this._v = Math.min(this._v, 1);\r\n            this._v = Math.max(this._v, ColorPicker._Epsilon);\r\n        }\r\n\r\n        Color3.HSVtoRGBToRef(this._h, this._s, this._v, this._tmpColor);\r\n\r\n        this.value = this._tmpColor;\r\n    }\r\n\r\n    private _isPointOnSquare(x: number, y: number): boolean {\r\n        this._updateSquareProps();\r\n\r\n        const left = this._squareLeft;\r\n        const top = this._squareTop;\r\n        const size = this._squareSize;\r\n\r\n        if (x >= left && x <= left + size && y >= top && y <= top + size) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private _isPointOnWheel(x: number, y: number): boolean {\r\n        const radius = Math.min(this._currentMeasure.width, this._currentMeasure.height) * 0.5;\r\n        const centerX = radius + this._currentMeasure.left;\r\n        const centerY = radius + this._currentMeasure.top;\r\n        const wheelThickness = radius * 0.2;\r\n        const innerRadius = radius - wheelThickness;\r\n        const radiusSq = radius * radius;\r\n        const innerRadiusSq = innerRadius * innerRadius;\r\n\r\n        const dx = x - centerX;\r\n        const dy = y - centerY;\r\n\r\n        const distSq = dx * dx + dy * dy;\r\n\r\n        if (distSq <= radiusSq && distSq >= innerRadiusSq) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public _onPointerDown(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, pi: PointerInfoBase): boolean {\r\n        if (!super._onPointerDown(target, coordinates, pointerId, buttonIndex, pi)) {\r\n            return false;\r\n        }\r\n\r\n        if (this.isReadOnly) {\r\n            return true;\r\n        }\r\n\r\n        this._pointerIsDown = true;\r\n\r\n        this._pointerStartedOnSquare = false;\r\n        this._pointerStartedOnWheel = false;\r\n\r\n        // Invert transform\r\n        this._invertTransformMatrix.transformCoordinates(coordinates.x, coordinates.y, this._transformedPosition);\r\n\r\n        const x = this._transformedPosition.x;\r\n        const y = this._transformedPosition.y;\r\n\r\n        if (this._isPointOnSquare(x, y)) {\r\n            this._pointerStartedOnSquare = true;\r\n        } else if (this._isPointOnWheel(x, y)) {\r\n            this._pointerStartedOnWheel = true;\r\n        }\r\n\r\n        this._updateValueFromPointer(x, y);\r\n        this._host._capturingControl[pointerId] = this;\r\n        this._lastPointerDownId = pointerId;\r\n        return true;\r\n    }\r\n\r\n    public _onPointerMove(target: Control, coordinates: Vector2, pointerId: number, pi: PointerInfoBase): void {\r\n        // Only listen to pointer move events coming from the last pointer to click on the element (To support dual vr controller interaction)\r\n        if (pointerId != this._lastPointerDownId) {\r\n            return;\r\n        }\r\n\r\n        if (!this.isReadOnly) {\r\n            // Invert transform\r\n            this._invertTransformMatrix.transformCoordinates(coordinates.x, coordinates.y, this._transformedPosition);\r\n\r\n            const x = this._transformedPosition.x;\r\n            const y = this._transformedPosition.y;\r\n\r\n            if (this._pointerIsDown) {\r\n                this._updateValueFromPointer(x, y);\r\n            }\r\n        }\r\n\r\n        super._onPointerMove(target, coordinates, pointerId, pi);\r\n    }\r\n\r\n    public _onPointerUp(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, notifyClick: boolean, pi: PointerInfoBase): void {\r\n        this._pointerIsDown = false;\r\n\r\n        delete this._host._capturingControl[pointerId];\r\n        super._onPointerUp(target, coordinates, pointerId, buttonIndex, notifyClick, pi);\r\n    }\r\n\r\n    public _onCanvasBlur() {\r\n        this._forcePointerUp();\r\n        super._onCanvasBlur();\r\n    }\r\n\r\n    /**\r\n     * This function expands the color picker by creating a color picker dialog with manual\r\n     * color value input and the ability to save colors into an array to be used later in\r\n     * subsequent launches of the dialogue.\r\n     * @param advancedTexture defines the AdvancedDynamicTexture the dialog is assigned to\r\n     * @param options defines size for dialog and options for saved colors. Also accepts last color picked as hex string and saved colors array as hex strings.\r\n     * @param options.pickerWidth\r\n     * @param options.pickerHeight\r\n     * @param options.headerHeight\r\n     * @param options.lastColor\r\n     * @param options.swatchLimit\r\n     * @param options.numSwatchesPerLine\r\n     * @param options.savedColors\r\n     * @returns picked color as a hex string and the saved colors array as hex strings.\r\n     */\r\n    public static ShowPickerDialogAsync(\r\n        advancedTexture: AdvancedDynamicTexture,\r\n        options: {\r\n            pickerWidth?: string;\r\n            pickerHeight?: string;\r\n            headerHeight?: string;\r\n            lastColor?: string;\r\n            swatchLimit?: number;\r\n            numSwatchesPerLine?: number;\r\n            savedColors?: Array<string>;\r\n        }\r\n    ): Promise<{\r\n        savedColors?: string[];\r\n        pickedColor: string;\r\n    }> {\r\n        return new Promise((resolve) => {\r\n            // Default options\r\n            options.pickerWidth = options.pickerWidth || \"640px\";\r\n            options.pickerHeight = options.pickerHeight || \"400px\";\r\n            options.headerHeight = options.headerHeight || \"35px\";\r\n            options.lastColor = options.lastColor || \"#000000\";\r\n            options.swatchLimit = options.swatchLimit || 20;\r\n            options.numSwatchesPerLine = options.numSwatchesPerLine || 10;\r\n\r\n            // Window size settings\r\n            const drawerMaxRows: number = options.swatchLimit / options.numSwatchesPerLine;\r\n            const rawSwatchSize: number = parseFloat(<string>options.pickerWidth) / options.numSwatchesPerLine;\r\n            const gutterSize: number = Math.floor(rawSwatchSize * 0.25);\r\n            const colGutters: number = gutterSize * (options.numSwatchesPerLine + 1);\r\n            const swatchSize: number = Math.floor((parseFloat(<string>options.pickerWidth) - colGutters) / options.numSwatchesPerLine);\r\n            const drawerMaxSize: number = swatchSize * drawerMaxRows + gutterSize * (drawerMaxRows + 1);\r\n            const containerSize: string = (parseInt(options.pickerHeight) + drawerMaxSize + Math.floor(swatchSize * 0.25)).toString() + \"px\";\r\n\r\n            // Button Colors\r\n            const buttonColor: string = \"#c0c0c0\";\r\n            const buttonBackgroundColor: string = \"#535353\";\r\n            const buttonBackgroundHoverColor: string = \"#414141\";\r\n            const buttonBackgroundClickColor: string = \"515151\";\r\n            const buttonDisabledColor: string = \"#555555\";\r\n            const buttonDisabledBackgroundColor: string = \"#454545\";\r\n            const currentSwatchesOutlineColor: string = \"#404040\";\r\n            const luminanceLimitColor: Color3 = Color3.FromHexString(\"#dddddd\");\r\n            const luminanceLimit: number = luminanceLimitColor.r + luminanceLimitColor.g + luminanceLimitColor.b;\r\n            const iconColorDark: string = \"#aaaaaa\";\r\n            const iconColorLight: string = \"#ffffff\";\r\n\r\n            // Button settings\r\n            let buttonFontSize: number;\r\n            let butEdit: Button;\r\n\r\n            // Input Text Colors\r\n            const inputFieldLabels: string[] = [\"R\", \"G\", \"B\"];\r\n            const inputTextBackgroundColor: string = \"#454545\";\r\n            const inputTextColor: string = \"#f0f0f0\";\r\n\r\n            // This int is used for naming swatches and serves as the index for calling them from the list\r\n            let swatchNumber: number;\r\n\r\n            // Menu Panel options. We need to know if the swatchDrawer exists so we can create it if needed.\r\n            let swatchDrawer: Grid;\r\n            let editSwatchMode: boolean = false;\r\n\r\n            // Color InputText fields that will be updated upon value change\r\n            let butSave: Button;\r\n            let lastVal: string;\r\n            let activeField: string;\r\n\r\n            // Dialog menu container which will contain both the main dialogue window and the swatch drawer which opens once a color is saved.\r\n            const dialogContainer: Grid = new Grid();\r\n            dialogContainer.name = \"Dialog Container\";\r\n            dialogContainer.width = options.pickerWidth;\r\n            if (options.savedColors) {\r\n                dialogContainer.height = containerSize;\r\n                const topRow: number = parseInt(options.pickerHeight) / parseInt(containerSize);\r\n                dialogContainer.addRowDefinition(topRow, false);\r\n                dialogContainer.addRowDefinition(1.0 - topRow, false);\r\n            } else {\r\n                dialogContainer.height = options.pickerHeight;\r\n                dialogContainer.addRowDefinition(1.0, false);\r\n            }\r\n            advancedTexture.addControl(dialogContainer);\r\n\r\n            // Swatch drawer which contains all saved color buttons\r\n            if (options.savedColors) {\r\n                swatchDrawer = new Grid();\r\n                swatchDrawer.name = \"Swatch Drawer\";\r\n                swatchDrawer.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n                swatchDrawer.background = buttonBackgroundColor;\r\n                swatchDrawer.width = options.pickerWidth!;\r\n                const initialRows: number = options.savedColors.length / options.numSwatchesPerLine;\r\n                let gutterCount: number;\r\n                if (initialRows == 0) {\r\n                    gutterCount = 0;\r\n                } else {\r\n                    gutterCount = initialRows + 1;\r\n                }\r\n                swatchDrawer.height = (swatchSize * initialRows + gutterCount * gutterSize).toString() + \"px\";\r\n                swatchDrawer.top = Math.floor(swatchSize * 0.25).toString() + \"px\";\r\n                for (let i = 0; i < Math.ceil(options.savedColors.length / options.numSwatchesPerLine) * 2 + 1; i++) {\r\n                    if (i % 2 != 0) {\r\n                        swatchDrawer.addRowDefinition(swatchSize, true);\r\n                    } else {\r\n                        swatchDrawer.addRowDefinition(gutterSize, true);\r\n                    }\r\n                }\r\n                for (let i = 0; i < options.numSwatchesPerLine! * 2 + 1; i++) {\r\n                    if (i % 2 != 0) {\r\n                        swatchDrawer.addColumnDefinition(swatchSize, true);\r\n                    } else {\r\n                        swatchDrawer.addColumnDefinition(gutterSize, true);\r\n                    }\r\n                }\r\n                dialogContainer.addControl(swatchDrawer, 1, 0);\r\n            }\r\n\r\n            // Picker container\r\n            const pickerPanel: Grid = new Grid();\r\n            pickerPanel.name = \"Picker Panel\";\r\n            pickerPanel.height = options.pickerHeight;\r\n            const panelHead: number = parseInt(options.headerHeight) / parseInt(options.pickerHeight);\r\n            const pickerPanelRows: number[] = [panelHead, 1.0 - panelHead];\r\n            pickerPanel.addRowDefinition(pickerPanelRows[0], false);\r\n            pickerPanel.addRowDefinition(pickerPanelRows[1], false);\r\n            dialogContainer.addControl(pickerPanel, 0, 0);\r\n\r\n            // Picker container header\r\n            const header: Rectangle = new Rectangle();\r\n            header.name = \"Dialogue Header Bar\";\r\n            header.background = \"#cccccc\";\r\n            header.thickness = 0;\r\n            pickerPanel.addControl(header, 0, 0);\r\n\r\n            // Header close button\r\n            const closeButton: Button = Button.CreateSimpleButton(\"closeButton\", \"a\");\r\n            closeButton.fontFamily = \"coreglyphs\";\r\n            const headerColor3: Color3 = Color3.FromHexString(header.background);\r\n            const closeIconColor = new Color3(1.0 - headerColor3.r, 1.0 - headerColor3.g, 1.0 - headerColor3.b);\r\n            closeButton.color = closeIconColor.toHexString();\r\n            closeButton.fontSize = Math.floor(parseInt(options.headerHeight!) * 0.6);\r\n            closeButton.textBlock!.textVerticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n            closeButton.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_RIGHT;\r\n            closeButton.height = closeButton.width = options.headerHeight;\r\n            closeButton.background = header.background;\r\n            closeButton.thickness = 0;\r\n            closeButton.pointerDownAnimation = () => {};\r\n            closeButton.pointerUpAnimation = () => {\r\n                closeButton.background = header.background;\r\n            };\r\n            closeButton.pointerEnterAnimation = () => {\r\n                closeButton.color = header.background;\r\n                closeButton.background = \"red\";\r\n            };\r\n            closeButton.pointerOutAnimation = () => {\r\n                closeButton.color = closeIconColor.toHexString();\r\n                closeButton.background = header.background;\r\n            };\r\n            closeButton.onPointerClickObservable.add(() => {\r\n                closePicker(currentSwatch.background);\r\n            });\r\n            pickerPanel.addControl(closeButton, 0, 0);\r\n\r\n            // Dialog container body\r\n            const dialogBody: Grid = new Grid();\r\n            dialogBody.name = \"Dialogue Body\";\r\n            dialogBody.background = buttonBackgroundColor;\r\n            const dialogBodyCols: number[] = [0.4375, 0.5625];\r\n            dialogBody.addRowDefinition(1.0, false);\r\n            dialogBody.addColumnDefinition(dialogBodyCols[0], false);\r\n            dialogBody.addColumnDefinition(dialogBodyCols[1], false);\r\n            pickerPanel.addControl(dialogBody, 1, 0);\r\n\r\n            // Picker grid\r\n            const pickerGrid: Grid = new Grid();\r\n            pickerGrid.name = \"Picker Grid\";\r\n            pickerGrid.addRowDefinition(0.85, false);\r\n            pickerGrid.addRowDefinition(0.15, false);\r\n            dialogBody.addControl(pickerGrid, 0, 0);\r\n\r\n            //  Picker control\r\n            const picker = new ColorPicker();\r\n            picker.name = \"GUI Color Picker\";\r\n            if (options.pickerHeight < options.pickerWidth) {\r\n                picker.width = 0.89;\r\n            } else {\r\n                picker.height = 0.89;\r\n            }\r\n            picker.value = Color3.FromHexString(options.lastColor);\r\n            picker.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n            picker.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n            picker.onPointerDownObservable.add(() => {\r\n                activeField = picker.name!;\r\n                lastVal = \"\";\r\n                editSwatches(false);\r\n            });\r\n            picker.onValueChangedObservable.add(function (value) {\r\n                // value is a color3\r\n                if (activeField == picker.name) {\r\n                    updateValues(value, picker.name);\r\n                }\r\n            });\r\n            pickerGrid.addControl(picker, 0, 0);\r\n\r\n            // Picker body right quarant\r\n            const pickerBodyRight: Grid = new Grid();\r\n            pickerBodyRight.name = \"Dialogue Right Half\";\r\n            pickerBodyRight.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n            const pickerBodyRightRows: number[] = [0.514, 0.486];\r\n            pickerBodyRight.addRowDefinition(pickerBodyRightRows[0], false);\r\n            pickerBodyRight.addRowDefinition(pickerBodyRightRows[1], false);\r\n            dialogBody.addControl(pickerBodyRight, 1, 1);\r\n\r\n            // Picker container swatches and buttons\r\n            const pickerSwatchesButtons: Grid = new Grid();\r\n            pickerSwatchesButtons.name = \"Swatches and Buttons\";\r\n            const pickerButtonsCol: number[] = [0.417, 0.583];\r\n            pickerSwatchesButtons.addRowDefinition(1.0, false);\r\n            pickerSwatchesButtons.addColumnDefinition(pickerButtonsCol[0], false);\r\n            pickerSwatchesButtons.addColumnDefinition(pickerButtonsCol[1], false);\r\n            pickerBodyRight.addControl(pickerSwatchesButtons, 0, 0);\r\n\r\n            // Picker Swatches quadrant\r\n            const pickerSwatches: Grid = new Grid();\r\n            pickerSwatches.name = \"New and Current Swatches\";\r\n            const pickeSwatchesRows: number[] = [0.04, 0.16, 0.64, 0.16];\r\n            pickerSwatches.addRowDefinition(pickeSwatchesRows[0], false);\r\n            pickerSwatches.addRowDefinition(pickeSwatchesRows[1], false);\r\n            pickerSwatches.addRowDefinition(pickeSwatchesRows[2], false);\r\n            pickerSwatches.addRowDefinition(pickeSwatchesRows[3], false);\r\n            pickerSwatchesButtons.addControl(pickerSwatches, 0, 0);\r\n\r\n            // Active swatches\r\n            const activeSwatches: Grid = new Grid();\r\n            activeSwatches.name = \"Active Swatches\";\r\n            activeSwatches.width = 0.67;\r\n            activeSwatches.addRowDefinition(0.5, false);\r\n            activeSwatches.addRowDefinition(0.5, false);\r\n            pickerSwatches.addControl(activeSwatches, 2, 0);\r\n\r\n            const labelWidth: number = Math.floor(parseInt(options.pickerWidth) * dialogBodyCols[1] * pickerButtonsCol[0] * 0.11);\r\n            const labelHeight: number = Math.floor(parseInt(options.pickerHeight) * pickerPanelRows[1] * pickerBodyRightRows[0] * pickeSwatchesRows[1] * 0.5);\r\n\r\n            let labelTextSize: number;\r\n            if (options.pickerWidth > options.pickerHeight) {\r\n                labelTextSize = labelHeight;\r\n            } else {\r\n                labelTextSize = labelWidth;\r\n            }\r\n            // New color swatch and previous color button\r\n            const newText: TextBlock = new TextBlock();\r\n            newText.text = \"new\";\r\n            newText.name = \"New Color Label\";\r\n            newText.color = buttonColor;\r\n            newText.fontSize = labelTextSize;\r\n            pickerSwatches.addControl(newText, 1, 0);\r\n\r\n            const newSwatch = new Rectangle();\r\n            newSwatch.name = \"New Color Swatch\";\r\n            newSwatch.background = options.lastColor;\r\n            newSwatch.thickness = 0;\r\n            activeSwatches.addControl(newSwatch, 0, 0);\r\n\r\n            const currentSwatch: Button = Button.CreateSimpleButton(\"currentSwatch\", \"\");\r\n            currentSwatch.background = options.lastColor;\r\n            currentSwatch.thickness = 0;\r\n            currentSwatch.onPointerClickObservable.add(() => {\r\n                const revertColor = Color3.FromHexString(currentSwatch.background);\r\n                updateValues(revertColor, currentSwatch.name!);\r\n                editSwatches(false);\r\n            });\r\n            currentSwatch.pointerDownAnimation = () => {};\r\n            currentSwatch.pointerUpAnimation = () => {};\r\n            currentSwatch.pointerEnterAnimation = () => {};\r\n            currentSwatch.pointerOutAnimation = () => {};\r\n            activeSwatches.addControl(currentSwatch, 1, 0);\r\n\r\n            const swatchOutline: Rectangle = new Rectangle();\r\n            swatchOutline.name = \"Swatch Outline\";\r\n            swatchOutline.width = 0.67;\r\n            swatchOutline.thickness = 2;\r\n            swatchOutline.color = currentSwatchesOutlineColor;\r\n            swatchOutline.isHitTestVisible = false;\r\n            pickerSwatches.addControl(swatchOutline, 2, 0);\r\n\r\n            const currentText: TextBlock = new TextBlock();\r\n            currentText.name = \"Current Color Label\";\r\n            currentText.text = \"current\";\r\n            currentText.color = buttonColor;\r\n            currentText.fontSize = labelTextSize;\r\n            pickerSwatches.addControl(currentText, 3, 0);\r\n\r\n            // Buttons grid\r\n            const buttonGrid: Grid = new Grid();\r\n            buttonGrid.name = \"Button Grid\";\r\n            buttonGrid.height = 0.8;\r\n            const buttonGridRows: number = 1 / 3;\r\n            buttonGrid.addRowDefinition(buttonGridRows, false);\r\n            buttonGrid.addRowDefinition(buttonGridRows, false);\r\n            buttonGrid.addRowDefinition(buttonGridRows, false);\r\n            pickerSwatchesButtons.addControl(buttonGrid, 0, 1);\r\n\r\n            // Determine pixel width and height for all buttons from overall panel dimensions\r\n            const buttonWidth = Math.floor(parseInt(options.pickerWidth) * dialogBodyCols[1] * pickerButtonsCol[1] * 0.67).toString() + \"px\";\r\n            const buttonHeight =\r\n                Math.floor(\r\n                    parseInt(options.pickerHeight) * pickerPanelRows[1] * pickerBodyRightRows[0] * (parseFloat(buttonGrid.height.toString()) / 100) * buttonGridRows * 0.7\r\n                ).toString() + \"px\";\r\n\r\n            // Determine button type size\r\n            if (parseFloat(buttonWidth) > parseFloat(buttonHeight)) {\r\n                buttonFontSize = Math.floor(parseFloat(buttonHeight) * 0.45);\r\n            } else {\r\n                buttonFontSize = Math.floor(parseFloat(buttonWidth) * 0.11);\r\n            }\r\n\r\n            // Panel Buttons\r\n            const butOK: Button = Button.CreateSimpleButton(\"butOK\", \"OK\");\r\n            butOK.width = buttonWidth;\r\n            butOK.height = buttonHeight;\r\n            butOK.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n            butOK.thickness = 2;\r\n            butOK.color = buttonColor;\r\n            butOK.fontSize = buttonFontSize;\r\n            butOK.background = buttonBackgroundColor;\r\n            butOK.onPointerEnterObservable.add(() => {\r\n                butOK.background = buttonBackgroundHoverColor;\r\n            });\r\n            butOK.onPointerOutObservable.add(() => {\r\n                butOK.background = buttonBackgroundColor;\r\n            });\r\n            butOK.pointerDownAnimation = () => {\r\n                butOK.background = buttonBackgroundClickColor;\r\n            };\r\n            butOK.pointerUpAnimation = () => {\r\n                butOK.background = buttonBackgroundHoverColor;\r\n            };\r\n            butOK.onPointerClickObservable.add(() => {\r\n                editSwatches(false);\r\n                closePicker(newSwatch.background);\r\n            });\r\n            buttonGrid.addControl(butOK, 0, 0);\r\n\r\n            const butCancel: Button = Button.CreateSimpleButton(\"butCancel\", \"Cancel\");\r\n            butCancel.width = buttonWidth;\r\n            butCancel.height = buttonHeight;\r\n            butCancel.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n            butCancel.thickness = 2;\r\n            butCancel.color = buttonColor;\r\n            butCancel.fontSize = buttonFontSize;\r\n            butCancel.background = buttonBackgroundColor;\r\n            butCancel.onPointerEnterObservable.add(() => {\r\n                butCancel.background = buttonBackgroundHoverColor;\r\n            });\r\n            butCancel.onPointerOutObservable.add(() => {\r\n                butCancel.background = buttonBackgroundColor;\r\n            });\r\n            butCancel.pointerDownAnimation = () => {\r\n                butCancel.background = buttonBackgroundClickColor;\r\n            };\r\n            butCancel.pointerUpAnimation = () => {\r\n                butCancel.background = buttonBackgroundHoverColor;\r\n            };\r\n            butCancel.onPointerClickObservable.add(() => {\r\n                editSwatches(false);\r\n                closePicker(currentSwatch.background);\r\n            });\r\n            buttonGrid.addControl(butCancel, 1, 0);\r\n\r\n            if (options.savedColors) {\r\n                butSave = Button.CreateSimpleButton(\"butSave\", \"Save\");\r\n                butSave.width = buttonWidth;\r\n                butSave.height = buttonHeight;\r\n                butSave.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n                butSave.thickness = 2;\r\n                butSave.fontSize = buttonFontSize;\r\n                if (options.savedColors.length < options.swatchLimit!) {\r\n                    butSave.color = buttonColor;\r\n                    butSave.background = buttonBackgroundColor;\r\n                } else {\r\n                    disableButton(butSave, true);\r\n                }\r\n                butSave.onPointerEnterObservable.add(() => {\r\n                    if (options.savedColors) {\r\n                        if (options.savedColors.length < options.swatchLimit!) {\r\n                            butSave.background = buttonBackgroundHoverColor;\r\n                        }\r\n                    }\r\n                });\r\n                butSave.onPointerOutObservable.add(() => {\r\n                    if (options.savedColors) {\r\n                        if (options.savedColors.length < options.swatchLimit!) {\r\n                            butSave.background = buttonBackgroundColor;\r\n                        }\r\n                    }\r\n                });\r\n                butSave.pointerDownAnimation = () => {\r\n                    if (options.savedColors) {\r\n                        if (options.savedColors.length < options.swatchLimit!) {\r\n                            butSave.background = buttonBackgroundClickColor;\r\n                        }\r\n                    }\r\n                };\r\n                butSave.pointerUpAnimation = () => {\r\n                    if (options.savedColors) {\r\n                        if (options.savedColors.length < options.swatchLimit!) {\r\n                            butSave.background = buttonBackgroundHoverColor;\r\n                        }\r\n                    }\r\n                };\r\n                butSave.onPointerClickObservable.add(() => {\r\n                    if (options.savedColors) {\r\n                        if (options.savedColors.length == 0) {\r\n                            setEditButtonVisibility(true);\r\n                        }\r\n                        if (options.savedColors.length < options.swatchLimit!) {\r\n                            updateSwatches(newSwatch.background, butSave);\r\n                        }\r\n                        editSwatches(false);\r\n                    }\r\n                });\r\n                if (options.savedColors.length > 0) {\r\n                    setEditButtonVisibility(true);\r\n                }\r\n                buttonGrid.addControl(butSave, 2, 0);\r\n            }\r\n\r\n            // Picker color values input\r\n            const pickerColorValues: Grid = new Grid();\r\n            pickerColorValues.name = \"Dialog Lower Right\";\r\n            pickerColorValues.addRowDefinition(0.02, false);\r\n            pickerColorValues.addRowDefinition(0.63, false);\r\n            pickerColorValues.addRowDefinition(0.21, false);\r\n            pickerColorValues.addRowDefinition(0.14, false);\r\n            pickerBodyRight.addControl(pickerColorValues, 1, 0);\r\n\r\n            // RGB values text boxes\r\n            const currentColor = Color3.FromHexString(options.lastColor);\r\n            const rgbValuesQuadrant: Grid = new Grid();\r\n            rgbValuesQuadrant.name = \"RGB Values\";\r\n            rgbValuesQuadrant.width = 0.82;\r\n            rgbValuesQuadrant.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n            rgbValuesQuadrant.addRowDefinition(1 / 3, false);\r\n            rgbValuesQuadrant.addRowDefinition(1 / 3, false);\r\n            rgbValuesQuadrant.addRowDefinition(1 / 3, false);\r\n            rgbValuesQuadrant.addColumnDefinition(0.1, false);\r\n            rgbValuesQuadrant.addColumnDefinition(0.2, false);\r\n            rgbValuesQuadrant.addColumnDefinition(0.7, false);\r\n            pickerColorValues.addControl(rgbValuesQuadrant, 1, 0);\r\n\r\n            for (let i = 0; i < inputFieldLabels.length; i++) {\r\n                const labelText: TextBlock = new TextBlock();\r\n                labelText.text = inputFieldLabels[i];\r\n                labelText.color = buttonColor;\r\n                labelText.fontSize = buttonFontSize;\r\n                rgbValuesQuadrant.addControl(labelText, i, 0);\r\n            }\r\n\r\n            // Input fields for RGB values\r\n            const rValInt = new InputText();\r\n            rValInt.width = 0.83;\r\n            rValInt.height = 0.72;\r\n            rValInt.name = \"rIntField\";\r\n            rValInt.fontSize = buttonFontSize;\r\n            rValInt.text = (currentColor.r * 255).toString();\r\n            rValInt.color = inputTextColor;\r\n            rValInt.background = inputTextBackgroundColor;\r\n            rValInt.onFocusObservable.add(() => {\r\n                activeField = rValInt.name!;\r\n                lastVal = rValInt.text;\r\n                editSwatches(false);\r\n            });\r\n            rValInt.onBlurObservable.add(() => {\r\n                if (rValInt.text == \"\") {\r\n                    rValInt.text = \"0\";\r\n                }\r\n                updateInt(rValInt, \"r\");\r\n                if (activeField == rValInt.name) {\r\n                    activeField = \"\";\r\n                }\r\n            });\r\n            rValInt.onTextChangedObservable.add(() => {\r\n                if (activeField == rValInt.name) {\r\n                    updateInt(rValInt, \"r\");\r\n                }\r\n            });\r\n            rgbValuesQuadrant.addControl(rValInt, 0, 1);\r\n\r\n            const gValInt = new InputText();\r\n            gValInt.width = 0.83;\r\n            gValInt.height = 0.72;\r\n            gValInt.name = \"gIntField\";\r\n            gValInt.fontSize = buttonFontSize;\r\n            gValInt.text = (currentColor.g * 255).toString();\r\n            gValInt.color = inputTextColor;\r\n            gValInt.background = inputTextBackgroundColor;\r\n            gValInt.onFocusObservable.add(() => {\r\n                activeField = gValInt.name!;\r\n                lastVal = gValInt.text;\r\n                editSwatches(false);\r\n            });\r\n            gValInt.onBlurObservable.add(() => {\r\n                if (gValInt.text == \"\") {\r\n                    gValInt.text = \"0\";\r\n                }\r\n                updateInt(gValInt, \"g\");\r\n                if (activeField == gValInt.name) {\r\n                    activeField = \"\";\r\n                }\r\n            });\r\n            gValInt.onTextChangedObservable.add(() => {\r\n                if (activeField == gValInt.name) {\r\n                    updateInt(gValInt, \"g\");\r\n                }\r\n            });\r\n            rgbValuesQuadrant.addControl(gValInt, 1, 1);\r\n\r\n            const bValInt = new InputText();\r\n            bValInt.width = 0.83;\r\n            bValInt.height = 0.72;\r\n            bValInt.name = \"bIntField\";\r\n            bValInt.fontSize = buttonFontSize;\r\n            bValInt.text = (currentColor.b * 255).toString();\r\n            bValInt.color = inputTextColor;\r\n            bValInt.background = inputTextBackgroundColor;\r\n            bValInt.onFocusObservable.add(() => {\r\n                activeField = bValInt.name!;\r\n                lastVal = bValInt.text;\r\n                editSwatches(false);\r\n            });\r\n            bValInt.onBlurObservable.add(() => {\r\n                if (bValInt.text == \"\") {\r\n                    bValInt.text = \"0\";\r\n                }\r\n                updateInt(bValInt, \"b\");\r\n                if (activeField == bValInt.name) {\r\n                    activeField = \"\";\r\n                }\r\n            });\r\n            bValInt.onTextChangedObservable.add(() => {\r\n                if (activeField == bValInt.name) {\r\n                    updateInt(bValInt, \"b\");\r\n                }\r\n            });\r\n            rgbValuesQuadrant.addControl(bValInt, 2, 1);\r\n\r\n            const rValDec = new InputText();\r\n            rValDec.width = 0.95;\r\n            rValDec.height = 0.72;\r\n            rValDec.name = \"rDecField\";\r\n            rValDec.fontSize = buttonFontSize;\r\n            rValDec.text = currentColor.r.toString();\r\n            rValDec.color = inputTextColor;\r\n            rValDec.background = inputTextBackgroundColor;\r\n            rValDec.onFocusObservable.add(() => {\r\n                activeField = rValDec.name!;\r\n                lastVal = rValDec.text;\r\n                editSwatches(false);\r\n            });\r\n            rValDec.onBlurObservable.add(() => {\r\n                if (parseFloat(rValDec.text) == 0 || rValDec.text == \"\") {\r\n                    rValDec.text = \"0\";\r\n                    updateFloat(rValDec, \"r\");\r\n                }\r\n                if (activeField == rValDec.name) {\r\n                    activeField = \"\";\r\n                }\r\n            });\r\n            rValDec.onTextChangedObservable.add(() => {\r\n                if (activeField == rValDec.name) {\r\n                    updateFloat(rValDec, \"r\");\r\n                }\r\n            });\r\n            rgbValuesQuadrant.addControl(rValDec, 0, 2);\r\n\r\n            const gValDec = new InputText();\r\n            gValDec.width = 0.95;\r\n            gValDec.height = 0.72;\r\n            gValDec.name = \"gDecField\";\r\n            gValDec.fontSize = buttonFontSize;\r\n            gValDec.text = currentColor.g.toString();\r\n            gValDec.color = inputTextColor;\r\n            gValDec.background = inputTextBackgroundColor;\r\n            gValDec.onFocusObservable.add(() => {\r\n                activeField = gValDec.name!;\r\n                lastVal = gValDec.text;\r\n                editSwatches(false);\r\n            });\r\n            gValDec.onBlurObservable.add(() => {\r\n                if (parseFloat(gValDec.text) == 0 || gValDec.text == \"\") {\r\n                    gValDec.text = \"0\";\r\n                    updateFloat(gValDec, \"g\");\r\n                }\r\n                if (activeField == gValDec.name) {\r\n                    activeField = \"\";\r\n                }\r\n            });\r\n            gValDec.onTextChangedObservable.add(() => {\r\n                if (activeField == gValDec.name) {\r\n                    updateFloat(gValDec, \"g\");\r\n                }\r\n            });\r\n            rgbValuesQuadrant.addControl(gValDec, 1, 2);\r\n\r\n            const bValDec = new InputText();\r\n            bValDec.width = 0.95;\r\n            bValDec.height = 0.72;\r\n            bValDec.name = \"bDecField\";\r\n            bValDec.fontSize = buttonFontSize;\r\n            bValDec.text = currentColor.b.toString();\r\n            bValDec.color = inputTextColor;\r\n            bValDec.background = inputTextBackgroundColor;\r\n            bValDec.onFocusObservable.add(() => {\r\n                activeField = bValDec.name!;\r\n                lastVal = bValDec.text;\r\n                editSwatches(false);\r\n            });\r\n            bValDec.onBlurObservable.add(() => {\r\n                if (parseFloat(bValDec.text) == 0 || bValDec.text == \"\") {\r\n                    bValDec.text = \"0\";\r\n                    updateFloat(bValDec, \"b\");\r\n                }\r\n                if (activeField == bValDec.name) {\r\n                    activeField = \"\";\r\n                }\r\n            });\r\n            bValDec.onTextChangedObservable.add(() => {\r\n                if (activeField == bValDec.name) {\r\n                    updateFloat(bValDec, \"b\");\r\n                }\r\n            });\r\n            rgbValuesQuadrant.addControl(bValDec, 2, 2);\r\n\r\n            // Hex value input\r\n            const hexValueQuadrant: Grid = new Grid();\r\n            hexValueQuadrant.name = \"Hex Value\";\r\n            hexValueQuadrant.width = 0.82;\r\n            hexValueQuadrant.addRowDefinition(1.0, false);\r\n            hexValueQuadrant.addColumnDefinition(0.1, false);\r\n            hexValueQuadrant.addColumnDefinition(0.9, false);\r\n            pickerColorValues.addControl(hexValueQuadrant, 2, 0);\r\n\r\n            const labelText: TextBlock = new TextBlock();\r\n            labelText.text = \"#\";\r\n            labelText.color = buttonColor;\r\n            labelText.fontSize = buttonFontSize;\r\n            hexValueQuadrant.addControl(labelText, 0, 0);\r\n\r\n            const hexVal = new InputText();\r\n            hexVal.width = 0.96;\r\n            hexVal.height = 0.72;\r\n            hexVal.name = \"hexField\";\r\n            hexVal.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n            hexVal.fontSize = buttonFontSize;\r\n            const minusPound = options.lastColor.split(\"#\");\r\n            hexVal.text = minusPound[1];\r\n            hexVal.color = inputTextColor;\r\n            hexVal.background = inputTextBackgroundColor;\r\n            hexVal.onFocusObservable.add(() => {\r\n                activeField = hexVal.name!;\r\n                lastVal = hexVal.text;\r\n                editSwatches(false);\r\n            });\r\n            hexVal.onBlurObservable.add(() => {\r\n                if (hexVal.text.length == 3) {\r\n                    const val = hexVal.text.split(\"\");\r\n                    hexVal.text = val[0] + val[0] + val[1] + val[1] + val[2] + val[2];\r\n                }\r\n                if (hexVal.text == \"\") {\r\n                    hexVal.text = \"000000\";\r\n                    updateValues(Color3.FromHexString(hexVal.text), \"b\");\r\n                }\r\n                if (activeField == hexVal.name) {\r\n                    activeField = \"\";\r\n                }\r\n            });\r\n            hexVal.onTextChangedObservable.add(() => {\r\n                let newHexValue: string = hexVal.text;\r\n                const checkHex: boolean = /[^0-9A-F]/i.test(newHexValue);\r\n                if ((hexVal.text.length > 6 || checkHex) && activeField == hexVal.name) {\r\n                    hexVal.text = lastVal;\r\n                } else {\r\n                    if (hexVal.text.length < 6) {\r\n                        const leadingZero: number = 6 - hexVal.text.length;\r\n                        for (let i = 0; i < leadingZero; i++) {\r\n                            newHexValue = \"0\" + newHexValue;\r\n                        }\r\n                    }\r\n                    if (hexVal.text.length == 3) {\r\n                        const val: string[] = hexVal.text.split(\"\");\r\n                        newHexValue = val[0] + val[0] + val[1] + val[1] + val[2] + val[2];\r\n                    }\r\n                    newHexValue = \"#\" + newHexValue;\r\n                    if (activeField == hexVal.name) {\r\n                        lastVal = hexVal.text;\r\n                        updateValues(Color3.FromHexString(newHexValue), hexVal.name);\r\n                    }\r\n                }\r\n            });\r\n            hexValueQuadrant.addControl(hexVal, 0, 1);\r\n\r\n            if (options.savedColors && options.savedColors.length > 0) {\r\n                updateSwatches(\"\", butSave!);\r\n            }\r\n\r\n            /**\r\n             * Will update all values for InputText and ColorPicker controls based on the BABYLON.Color3 passed to this function.\r\n             * Each InputText control and the ColorPicker control will be tested to see if they are the activeField and if they\r\n             * are will receive no update. This is to prevent the input from the user being overwritten.\r\n             * @param value\r\n             * @param inputField\r\n             */\r\n            function updateValues(value: Color3, inputField: string) {\r\n                activeField = inputField;\r\n                const pickedColor: string = value.toHexString();\r\n                newSwatch.background = pickedColor;\r\n                if (rValInt.name != activeField) {\r\n                    rValInt.text = Math.floor(value.r * 255).toString();\r\n                }\r\n                if (gValInt.name != activeField) {\r\n                    gValInt.text = Math.floor(value.g * 255).toString();\r\n                }\r\n                if (bValInt.name != activeField) {\r\n                    bValInt.text = Math.floor(value.b * 255).toString();\r\n                }\r\n                if (rValDec.name != activeField) {\r\n                    rValDec.text = value.r.toString();\r\n                }\r\n                if (gValDec.name != activeField) {\r\n                    gValDec.text = value.g.toString();\r\n                }\r\n                if (bValDec.name != activeField) {\r\n                    bValDec.text = value.b.toString();\r\n                }\r\n                if (hexVal.name != activeField) {\r\n                    const minusPound: string[] = pickedColor.split(\"#\");\r\n                    hexVal.text = minusPound[1];\r\n                }\r\n                if (picker.name != activeField) {\r\n                    picker.value = value;\r\n                }\r\n            }\r\n\r\n            // When the user enters an integer for R, G, or B we check to make sure it is a valid number and replace if not.\r\n            function updateInt(field: InputText, channel: string) {\r\n                let newValue: string = field.text;\r\n                const checkVal: boolean = /[^0-9]/g.test(newValue);\r\n                if (checkVal) {\r\n                    field.text = lastVal;\r\n                    return;\r\n                } else {\r\n                    if (newValue != \"\") {\r\n                        if (Math.floor(parseInt(newValue)) < 0) {\r\n                            newValue = \"0\";\r\n                        } else if (Math.floor(parseInt(newValue)) > 255) {\r\n                            newValue = \"255\";\r\n                        } else if (isNaN(parseInt(newValue))) {\r\n                            newValue = \"0\";\r\n                        }\r\n                    }\r\n                    if (activeField == field.name) {\r\n                        lastVal = newValue;\r\n                    }\r\n                }\r\n                if (newValue != \"\") {\r\n                    newValue = parseInt(newValue).toString();\r\n                    field.text = newValue;\r\n                    const newSwatchRGB: Color3 = Color3.FromHexString(newSwatch.background);\r\n                    if (activeField == field.name) {\r\n                        if (channel == \"r\") {\r\n                            updateValues(new Color3(parseInt(newValue) / 255, newSwatchRGB.g, newSwatchRGB.b), field.name);\r\n                        } else if (channel == \"g\") {\r\n                            updateValues(new Color3(newSwatchRGB.r, parseInt(newValue) / 255, newSwatchRGB.b), field.name);\r\n                        } else {\r\n                            updateValues(new Color3(newSwatchRGB.r, newSwatchRGB.g, parseInt(newValue) / 255), field.name);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // When the user enters a float for R, G, or B we check to make sure it is a valid number and replace if not.\r\n            function updateFloat(field: InputText, channel: string) {\r\n                let newValue: string = field.text;\r\n                const checkVal: boolean = /[^0-9.]/g.test(newValue);\r\n                if (checkVal) {\r\n                    field.text = lastVal;\r\n                    return;\r\n                } else {\r\n                    if (newValue != \"\" && newValue != \".\" && parseFloat(newValue) != 0) {\r\n                        if (parseFloat(newValue) < 0.0) {\r\n                            newValue = \"0.0\";\r\n                        } else if (parseFloat(newValue) > 1.0) {\r\n                            newValue = \"1.0\";\r\n                        } else if (isNaN(parseFloat(newValue))) {\r\n                            newValue = \"0.0\";\r\n                        }\r\n                    }\r\n                    if (activeField == field.name) {\r\n                        lastVal = newValue;\r\n                    }\r\n                }\r\n                if (newValue != \"\" && newValue != \".\" && parseFloat(newValue) != 0) {\r\n                    newValue = parseFloat(newValue).toString();\r\n                    field.text = newValue;\r\n                } else {\r\n                    newValue = \"0.0\";\r\n                }\r\n                const newSwatchRGB = Color3.FromHexString(newSwatch.background);\r\n                if (activeField == field.name) {\r\n                    if (channel == \"r\") {\r\n                        updateValues(new Color3(parseFloat(newValue), newSwatchRGB.g, newSwatchRGB.b), field.name);\r\n                    } else if (channel == \"g\") {\r\n                        updateValues(new Color3(newSwatchRGB.r, parseFloat(newValue), newSwatchRGB.b), field.name);\r\n                    } else {\r\n                        updateValues(new Color3(newSwatchRGB.r, newSwatchRGB.g, parseFloat(newValue)), field.name);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Removes the current index from the savedColors array. Drawer can then be regenerated.\r\n            function deleteSwatch(index: number) {\r\n                if (options.savedColors) {\r\n                    options.savedColors.splice(index, 1);\r\n                }\r\n                if (options.savedColors && options.savedColors.length == 0) {\r\n                    setEditButtonVisibility(false);\r\n                    editSwatchMode = false;\r\n                }\r\n            }\r\n\r\n            // Creates and styles an individual swatch when updateSwatches is called.\r\n            function createSwatch() {\r\n                if (options.savedColors && options.savedColors[swatchNumber]) {\r\n                    let icon: string;\r\n                    if (editSwatchMode) {\r\n                        icon = \"b\";\r\n                    } else {\r\n                        icon = \"\";\r\n                    }\r\n                    const swatch: Button = Button.CreateSimpleButton(\"Swatch_\" + swatchNumber, icon);\r\n                    swatch.fontFamily = \"coreglyphs\";\r\n                    const swatchColor: Color3 = Color3.FromHexString(options.savedColors[swatchNumber]);\r\n                    const swatchLuminence: number = swatchColor.r + swatchColor.g + swatchColor.b;\r\n\r\n                    // Set color of outline and textBlock based on luminance of the color swatch so feedback always visible\r\n                    if (swatchLuminence > luminanceLimit) {\r\n                        swatch.color = iconColorDark;\r\n                    } else {\r\n                        swatch.color = iconColorLight;\r\n                    }\r\n                    swatch.fontSize = Math.floor(swatchSize * 0.7);\r\n                    swatch.textBlock!.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n                    swatch.height = swatch.width = swatchSize.toString() + \"px\";\r\n                    swatch.background = options.savedColors[swatchNumber];\r\n                    swatch.thickness = 2;\r\n                    const metadata = swatchNumber;\r\n                    swatch.pointerDownAnimation = () => {\r\n                        swatch.thickness = 4;\r\n                    };\r\n                    swatch.pointerUpAnimation = () => {\r\n                        swatch.thickness = 3;\r\n                    };\r\n                    swatch.pointerEnterAnimation = () => {\r\n                        swatch.thickness = 3;\r\n                    };\r\n                    swatch.pointerOutAnimation = () => {\r\n                        swatch.thickness = 2;\r\n                    };\r\n                    swatch.onPointerClickObservable.add(() => {\r\n                        if (!editSwatchMode) {\r\n                            if (options.savedColors) {\r\n                                updateValues(Color3.FromHexString(options.savedColors[metadata]), swatch.name!);\r\n                            }\r\n                        } else {\r\n                            deleteSwatch(metadata);\r\n                            updateSwatches(\"\", butSave);\r\n                        }\r\n                    });\r\n                    return swatch;\r\n                } else {\r\n                    return null;\r\n                }\r\n            }\r\n\r\n            // Mode switch to render button text and close symbols on swatch controls\r\n            function editSwatches(mode?: boolean) {\r\n                if (mode !== undefined) {\r\n                    editSwatchMode = mode;\r\n                }\r\n                let thisButton: Button;\r\n                if (editSwatchMode) {\r\n                    for (let i = 0; i < swatchDrawer.children.length; i++) {\r\n                        thisButton = swatchDrawer.children[i] as Button;\r\n                        thisButton.textBlock!.text = \"b\";\r\n                    }\r\n                    if (butEdit !== undefined) {\r\n                        butEdit.textBlock!.text = \"Done\";\r\n                    }\r\n                } else {\r\n                    for (let i = 0; i < swatchDrawer.children.length; i++) {\r\n                        thisButton = swatchDrawer.children[i] as Button;\r\n                        thisButton.textBlock!.text = \"\";\r\n                    }\r\n                    if (butEdit !== undefined) {\r\n                        butEdit.textBlock!.text = \"Edit\";\r\n                    }\r\n                }\r\n            }\r\n\r\n            /**\r\n             * When Save Color button is pressed this function will first create a swatch drawer if one is not already\r\n             * made. Then all controls are removed from the drawer and we step through the savedColors array and\r\n             * creates one swatch per color. It will also set the height of the drawer control based on how many\r\n             * saved colors there are and how many can be stored per row.\r\n             * @param color\r\n             * @param button\r\n             */\r\n            function updateSwatches(color: string, button: Button) {\r\n                if (options.savedColors) {\r\n                    if (color != \"\") {\r\n                        options.savedColors.push(color);\r\n                    }\r\n                    swatchNumber = 0;\r\n                    swatchDrawer.clearControls();\r\n                    const rowCount: number = Math.ceil(options.savedColors.length / options.numSwatchesPerLine!);\r\n                    let gutterCount: number;\r\n                    if (rowCount == 0) {\r\n                        gutterCount = 0;\r\n                    } else {\r\n                        gutterCount = rowCount + 1;\r\n                    }\r\n                    if (swatchDrawer.rowCount != rowCount + gutterCount) {\r\n                        const currentRows: number = swatchDrawer.rowCount;\r\n                        for (let i = 0; i < currentRows; i++) {\r\n                            swatchDrawer.removeRowDefinition(0);\r\n                        }\r\n                        for (let i = 0; i < rowCount + gutterCount; i++) {\r\n                            if (i % 2) {\r\n                                swatchDrawer.addRowDefinition(swatchSize, true);\r\n                            } else {\r\n                                swatchDrawer.addRowDefinition(gutterSize, true);\r\n                            }\r\n                        }\r\n                    }\r\n                    swatchDrawer.height = (swatchSize * rowCount + gutterCount * gutterSize).toString() + \"px\";\r\n\r\n                    for (let y = 1, thisRow = 1; y < rowCount + gutterCount; y += 2, thisRow++) {\r\n                        // Determine number of buttons to create per row based on the button limit per row and number of saved colors\r\n                        let totalButtonsThisRow: number;\r\n                        if (options.savedColors.length > thisRow * options.numSwatchesPerLine!) {\r\n                            totalButtonsThisRow = options.numSwatchesPerLine!;\r\n                        } else {\r\n                            totalButtonsThisRow = options.savedColors.length - (thisRow - 1) * options.numSwatchesPerLine!;\r\n                        }\r\n                        const buttonIterations: number = Math.min(Math.max(totalButtonsThisRow, 0), options.numSwatchesPerLine!);\r\n                        for (let x = 0, w = 1; x < buttonIterations; x++) {\r\n                            if (x > options.numSwatchesPerLine!) {\r\n                                continue;\r\n                            }\r\n                            const swatch: Button | null = createSwatch();\r\n                            if (swatch != null) {\r\n                                swatchDrawer.addControl(swatch, y, w);\r\n                                w += 2;\r\n                                swatchNumber++;\r\n                            } else {\r\n                                continue;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (options.savedColors.length >= options.swatchLimit!) {\r\n                        disableButton(button, true);\r\n                    } else {\r\n                        disableButton(button, false);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Shows or hides edit swatches button depending on if there are saved swatches\r\n            function setEditButtonVisibility(enableButton: boolean) {\r\n                if (enableButton) {\r\n                    butEdit = Button.CreateSimpleButton(\"butEdit\", \"Edit\");\r\n                    butEdit.width = buttonWidth;\r\n                    butEdit.height = buttonHeight;\r\n                    butEdit.left = Math.floor(parseInt(buttonWidth) * 0.1).toString() + \"px\";\r\n                    butEdit.top = (parseFloat(butEdit.left) * -1).toString() + \"px\";\r\n                    butEdit.verticalAlignment = Control.VERTICAL_ALIGNMENT_BOTTOM;\r\n                    butEdit.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n                    butEdit.thickness = 2;\r\n                    butEdit.color = buttonColor;\r\n                    butEdit.fontSize = buttonFontSize;\r\n                    butEdit.background = buttonBackgroundColor;\r\n                    butEdit.onPointerEnterObservable.add(() => {\r\n                        butEdit.background = buttonBackgroundHoverColor;\r\n                    });\r\n                    butEdit.onPointerOutObservable.add(() => {\r\n                        butEdit.background = buttonBackgroundColor;\r\n                    });\r\n                    butEdit.pointerDownAnimation = () => {\r\n                        butEdit.background = buttonBackgroundClickColor;\r\n                    };\r\n                    butEdit.pointerUpAnimation = () => {\r\n                        butEdit.background = buttonBackgroundHoverColor;\r\n                    };\r\n                    butEdit.onPointerClickObservable.add(() => {\r\n                        if (editSwatchMode) {\r\n                            editSwatchMode = false;\r\n                        } else {\r\n                            editSwatchMode = true;\r\n                        }\r\n                        editSwatches();\r\n                    });\r\n                    pickerGrid.addControl(butEdit, 1, 0);\r\n                } else {\r\n                    pickerGrid.removeControl(butEdit);\r\n                }\r\n            }\r\n\r\n            // Called when the user hits the limit of saved colors in the drawer.\r\n            function disableButton(button: Button, disabled: boolean) {\r\n                if (disabled) {\r\n                    button.color = buttonDisabledColor;\r\n                    button.background = buttonDisabledBackgroundColor;\r\n                } else {\r\n                    button.color = buttonColor;\r\n                    button.background = buttonBackgroundColor;\r\n                }\r\n            }\r\n\r\n            // Passes last chosen color back to scene and kills dialog by removing from AdvancedDynamicTexture\r\n            function closePicker(color: string) {\r\n                if (options.savedColors && options.savedColors.length > 0) {\r\n                    resolve({\r\n                        savedColors: options.savedColors,\r\n                        pickedColor: color,\r\n                    });\r\n                } else {\r\n                    resolve({\r\n                        pickedColor: color,\r\n                    });\r\n                }\r\n                advancedTexture.removeControl(dialogContainer);\r\n            }\r\n        });\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.ColorPicker\", ColorPicker);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}