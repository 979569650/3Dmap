{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../tslib.es6.js\";\nimport { serialize, SerializationHelper, serializeAsColor3, expandToProperty } from \"../Misc/decorators.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3, TmpColors } from \"../Maths/math.color.js\";\nimport { Node } from \"../node.js\";\nimport { UniformBuffer } from \"../Materials/uniformBuffer.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\nimport { LightConstants } from \"./lightConstants.js\";\n/**\n * Base class of all the lights in Babylon. It groups all the generic information about lights.\n * Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.\n * All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.\n */\nexport class Light extends Node {\n  /**\n   * Defines how far from the source the light is impacting in scene units.\n   * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\n   */\n  get range() {\n    return this._range;\n  }\n  /**\n   * Defines how far from the source the light is impacting in scene units.\n   * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\n   */\n  set range(value) {\n    this._range = value;\n    this._inverseSquaredRange = 1.0 / (this.range * this.range);\n  }\n  /**\n   * Gets the photometric scale used to interpret the intensity.\n   * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\n   */\n  get intensityMode() {\n    return this._intensityMode;\n  }\n  /**\n   * Sets the photometric scale used to interpret the intensity.\n   * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\n   */\n  set intensityMode(value) {\n    this._intensityMode = value;\n    this._computePhotometricScale();\n  }\n  /**\n   * Gets the light radius used by PBR Materials to simulate soft area lights.\n   */\n  get radius() {\n    return this._radius;\n  }\n  /**\n   * sets the light radius used by PBR Materials to simulate soft area lights.\n   */\n  set radius(value) {\n    this._radius = value;\n    this._computePhotometricScale();\n  }\n  /**\n   * Gets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\n   * the current shadow generator.\n   */\n  get shadowEnabled() {\n    return this._shadowEnabled;\n  }\n  /**\n   * Sets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\n   * the current shadow generator.\n   */\n  set shadowEnabled(value) {\n    if (this._shadowEnabled === value) {\n      return;\n    }\n    this._shadowEnabled = value;\n    this._markMeshesAsLightDirty();\n  }\n  /**\n   * Gets the only meshes impacted by this light.\n   */\n  get includedOnlyMeshes() {\n    return this._includedOnlyMeshes;\n  }\n  /**\n   * Sets the only meshes impacted by this light.\n   */\n  set includedOnlyMeshes(value) {\n    this._includedOnlyMeshes = value;\n    this._hookArrayForIncludedOnly(value);\n  }\n  /**\n   * Gets the meshes not impacted by this light.\n   */\n  get excludedMeshes() {\n    return this._excludedMeshes;\n  }\n  /**\n   * Sets the meshes not impacted by this light.\n   */\n  set excludedMeshes(value) {\n    this._excludedMeshes = value;\n    this._hookArrayForExcluded(value);\n  }\n  /**\n   * Gets the layer id use to find what meshes are not impacted by the light.\n   * Inactive if 0\n   */\n  get excludeWithLayerMask() {\n    return this._excludeWithLayerMask;\n  }\n  /**\n   * Sets the layer id use to find what meshes are not impacted by the light.\n   * Inactive if 0\n   */\n  set excludeWithLayerMask(value) {\n    this._excludeWithLayerMask = value;\n    this._resyncMeshes();\n  }\n  /**\n   * Gets the layer id use to find what meshes are impacted by the light.\n   * Inactive if 0\n   */\n  get includeOnlyWithLayerMask() {\n    return this._includeOnlyWithLayerMask;\n  }\n  /**\n   * Sets the layer id use to find what meshes are impacted by the light.\n   * Inactive if 0\n   */\n  set includeOnlyWithLayerMask(value) {\n    this._includeOnlyWithLayerMask = value;\n    this._resyncMeshes();\n  }\n  /**\n   * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\n   */\n  get lightmapMode() {\n    return this._lightmapMode;\n  }\n  /**\n   * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\n   */\n  set lightmapMode(value) {\n    if (this._lightmapMode === value) {\n      return;\n    }\n    this._lightmapMode = value;\n    this._markMeshesAsLightDirty();\n  }\n  /**\n   * Creates a Light object in the scene.\n   * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n   * @param name The friendly name of the light\n   * @param scene The scene the light belongs too\n   */\n  constructor(name, scene) {\n    super(name, scene);\n    /**\n     * Diffuse gives the basic color to an object.\n     */\n    this.diffuse = new Color3(1.0, 1.0, 1.0);\n    /**\n     * Specular produces a highlight color on an object.\n     * Note: This is not affecting PBR materials.\n     */\n    this.specular = new Color3(1.0, 1.0, 1.0);\n    /**\n     * Defines the falloff type for this light. This lets overriding how punctual light are\n     * falling off base on range or angle.\n     * This can be set to any values in Light.FALLOFF_x.\n     *\n     * Note: This is only useful for PBR Materials at the moment. This could be extended if required to\n     * other types of materials.\n     */\n    this.falloffType = Light.FALLOFF_DEFAULT;\n    /**\n     * Strength of the light.\n     * Note: By default it is define in the framework own unit.\n     * Note: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.\n     */\n    this.intensity = 1.0;\n    this._range = Number.MAX_VALUE;\n    this._inverseSquaredRange = 0;\n    /**\n     * Cached photometric scale default to 1.0 as the automatic intensity mode defaults to 1.0 for every type\n     * of light.\n     */\n    this._photometricScale = 1.0;\n    this._intensityMode = Light.INTENSITYMODE_AUTOMATIC;\n    this._radius = 0.00001;\n    /**\n     * Defines the rendering priority of the lights. It can help in case of fallback or number of lights\n     * exceeding the number allowed of the materials.\n     */\n    this.renderPriority = 0;\n    this._shadowEnabled = true;\n    this._excludeWithLayerMask = 0;\n    this._includeOnlyWithLayerMask = 0;\n    this._lightmapMode = 0;\n    /**\n     * Shadow generators associated to the light.\n     * @internal Internal use only.\n     */\n    this._shadowGenerators = null;\n    /**\n     * @internal Internal use only.\n     */\n    this._excludedMeshesIds = new Array();\n    /**\n     * @internal Internal use only.\n     */\n    this._includedOnlyMeshesIds = new Array();\n    /** @internal */\n    this._isLight = true;\n    this.getScene().addLight(this);\n    this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), undefined, undefined, name);\n    this._buildUniformLayout();\n    this.includedOnlyMeshes = new Array();\n    this.excludedMeshes = new Array();\n    this._resyncMeshes();\n  }\n  /**\n   * Sets the passed Effect \"effect\" with the Light textures.\n   * @param effect The effect to update\n   * @param lightIndex The index of the light in the effect to update\n   * @returns The light\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  transferTexturesToEffect(effect, lightIndex) {\n    // Do nothing by default.\n    return this;\n  }\n  /**\n   * Binds the lights information from the scene to the effect for the given mesh.\n   * @param lightIndex Light index\n   * @param scene The scene where the light belongs to\n   * @param effect The effect we are binding the data to\n   * @param useSpecular Defines if specular is supported\n   * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\n   */\n  _bindLight(lightIndex, scene, effect, useSpecular, receiveShadows = true) {\n    var _a;\n    const iAsString = lightIndex.toString();\n    let needUpdate = false;\n    this._uniformBuffer.bindToEffect(effect, \"Light\" + iAsString);\n    if (this._renderId !== scene.getRenderId() || this._lastUseSpecular !== useSpecular || !this._uniformBuffer.useUbo) {\n      this._renderId = scene.getRenderId();\n      this._lastUseSpecular = useSpecular;\n      const scaledIntensity = this.getScaledIntensity();\n      this.transferToEffect(effect, iAsString);\n      this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);\n      this._uniformBuffer.updateColor4(\"vLightDiffuse\", TmpColors.Color3[0], this.range, iAsString);\n      if (useSpecular) {\n        this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);\n        this._uniformBuffer.updateColor4(\"vLightSpecular\", TmpColors.Color3[1], this.radius, iAsString);\n      }\n      needUpdate = true;\n    }\n    // Textures might still need to be rebound.\n    this.transferTexturesToEffect(effect, iAsString);\n    // Shadows\n    if (scene.shadowsEnabled && this.shadowEnabled && receiveShadows) {\n      const shadowGenerator = (_a = this.getShadowGenerator(scene.activeCamera)) !== null && _a !== void 0 ? _a : this.getShadowGenerator();\n      if (shadowGenerator) {\n        shadowGenerator.bindShadowLight(iAsString, effect);\n        needUpdate = true;\n      }\n    }\n    if (needUpdate) {\n      this._uniformBuffer.update();\n    } else {\n      this._uniformBuffer.bindUniformBuffer();\n    }\n  }\n  /**\n   * Returns the string \"Light\".\n   * @returns the class name\n   */\n  getClassName() {\n    return \"Light\";\n  }\n  /**\n   * Converts the light information to a readable string for debug purpose.\n   * @param fullDetails Supports for multiple levels of logging within scene loading\n   * @returns the human readable light info\n   */\n  toString(fullDetails) {\n    let ret = \"Name: \" + this.name;\n    ret += \", type: \" + [\"Point\", \"Directional\", \"Spot\", \"Hemispheric\"][this.getTypeID()];\n    if (this.animations) {\n      for (let i = 0; i < this.animations.length; i++) {\n        ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\n      }\n    }\n    return ret;\n  }\n  /** @internal */\n  _syncParentEnabledState() {\n    super._syncParentEnabledState();\n    if (!this.isDisposed()) {\n      this._resyncMeshes();\n    }\n  }\n  /**\n   * Set the enabled state of this node.\n   * @param value - the new enabled state\n   */\n  setEnabled(value) {\n    super.setEnabled(value);\n    this._resyncMeshes();\n  }\n  /**\n   * Returns the Light associated shadow generator if any.\n   * @param camera Camera for which the shadow generator should be retrieved (default: null). If null, retrieves the default shadow generator\n   * @returns the associated shadow generator.\n   */\n  getShadowGenerator(camera = null) {\n    var _a;\n    if (this._shadowGenerators === null) {\n      return null;\n    }\n    return (_a = this._shadowGenerators.get(camera)) !== null && _a !== void 0 ? _a : null;\n  }\n  /**\n   * Returns all the shadow generators associated to this light\n   * @returns\n   */\n  getShadowGenerators() {\n    return this._shadowGenerators;\n  }\n  /**\n   * Returns a Vector3, the absolute light position in the World.\n   * @returns the world space position of the light\n   */\n  getAbsolutePosition() {\n    return Vector3.Zero();\n  }\n  /**\n   * Specifies if the light will affect the passed mesh.\n   * @param mesh The mesh to test against the light\n   * @returns true the mesh is affected otherwise, false.\n   */\n  canAffectMesh(mesh) {\n    if (!mesh) {\n      return true;\n    }\n    if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {\n      return false;\n    }\n    if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\n      return false;\n    }\n    if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {\n      return false;\n    }\n    if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Releases resources associated with this node.\n   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n   */\n  dispose(doNotRecurse, disposeMaterialAndTextures = false) {\n    if (this._shadowGenerators) {\n      const iterator = this._shadowGenerators.values();\n      for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n        const shadowGenerator = key.value;\n        shadowGenerator.dispose();\n      }\n      this._shadowGenerators = null;\n    }\n    // Animations\n    this.getScene().stopAnimation(this);\n    if (this._parentContainer) {\n      const index = this._parentContainer.lights.indexOf(this);\n      if (index > -1) {\n        this._parentContainer.lights.splice(index, 1);\n      }\n      this._parentContainer = null;\n    }\n    // Remove from meshes\n    for (const mesh of this.getScene().meshes) {\n      mesh._removeLightSource(this, true);\n    }\n    this._uniformBuffer.dispose();\n    // Remove from scene\n    this.getScene().removeLight(this);\n    super.dispose(doNotRecurse, disposeMaterialAndTextures);\n  }\n  /**\n   * Returns the light type ID (integer).\n   * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\n   */\n  getTypeID() {\n    return 0;\n  }\n  /**\n   * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.\n   * @returns the scaled intensity in intensity mode unit\n   */\n  getScaledIntensity() {\n    return this._photometricScale * this.intensity;\n  }\n  /**\n   * Returns a new Light object, named \"name\", from the current one.\n   * @param name The name of the cloned light\n   * @param newParent The parent of this light, if it has one\n   * @returns the new created light\n   */\n  clone(name, newParent = null) {\n    const constructor = Light.GetConstructorFromName(this.getTypeID(), name, this.getScene());\n    if (!constructor) {\n      return null;\n    }\n    const clonedLight = SerializationHelper.Clone(constructor, this);\n    if (name) {\n      clonedLight.name = name;\n    }\n    if (newParent) {\n      clonedLight.parent = newParent;\n    }\n    clonedLight.setEnabled(this.isEnabled());\n    this.onClonedObservable.notifyObservers(clonedLight);\n    return clonedLight;\n  }\n  /**\n   * Serializes the current light into a Serialization object.\n   * @returns the serialized object.\n   */\n  serialize() {\n    const serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.uniqueId = this.uniqueId;\n    // Type\n    serializationObject.type = this.getTypeID();\n    // Parent\n    if (this.parent) {\n      this.parent._serializeAsParent(serializationObject);\n    }\n    // Inclusion / exclusions\n    if (this.excludedMeshes.length > 0) {\n      serializationObject.excludedMeshesIds = [];\n      this.excludedMeshes.forEach(mesh => {\n        serializationObject.excludedMeshesIds.push(mesh.id);\n      });\n    }\n    if (this.includedOnlyMeshes.length > 0) {\n      serializationObject.includedOnlyMeshesIds = [];\n      this.includedOnlyMeshes.forEach(mesh => {\n        serializationObject.includedOnlyMeshesIds.push(mesh.id);\n      });\n    }\n    // Animations\n    SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n    serializationObject.ranges = this.serializeAnimationRanges();\n    serializationObject.isEnabled = this.isEnabled();\n    return serializationObject;\n  }\n  /**\n   * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.\n   * This new light is named \"name\" and added to the passed scene.\n   * @param type Type according to the types available in Light.LIGHTTYPEID_x\n   * @param name The friendly name of the light\n   * @param scene The scene the new light will belong to\n   * @returns the constructor function\n   */\n  static GetConstructorFromName(type, name, scene) {\n    const constructorFunc = Node.Construct(\"Light_Type_\" + type, name, scene);\n    if (constructorFunc) {\n      return constructorFunc;\n    }\n    // Default to no light for none present once.\n    return null;\n  }\n  /**\n   * Parses the passed \"parsedLight\" and returns a new instanced Light from this parsing.\n   * @param parsedLight The JSON representation of the light\n   * @param scene The scene to create the parsed light in\n   * @returns the created light after parsing\n   */\n  static Parse(parsedLight, scene) {\n    const constructor = Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);\n    if (!constructor) {\n      return null;\n    }\n    const light = SerializationHelper.Parse(constructor, parsedLight, scene);\n    // Inclusion / exclusions\n    if (parsedLight.excludedMeshesIds) {\n      light._excludedMeshesIds = parsedLight.excludedMeshesIds;\n    }\n    if (parsedLight.includedOnlyMeshesIds) {\n      light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;\n    }\n    // Parent\n    if (parsedLight.parentId !== undefined) {\n      light._waitingParentId = parsedLight.parentId;\n    }\n    if (parsedLight.parentInstanceIndex !== undefined) {\n      light._waitingParentInstanceIndex = parsedLight.parentInstanceIndex;\n    }\n    // Falloff\n    if (parsedLight.falloffType !== undefined) {\n      light.falloffType = parsedLight.falloffType;\n    }\n    // Lightmaps\n    if (parsedLight.lightmapMode !== undefined) {\n      light.lightmapMode = parsedLight.lightmapMode;\n    }\n    // Animations\n    if (parsedLight.animations) {\n      for (let animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {\n        const parsedAnimation = parsedLight.animations[animationIndex];\n        const internalClass = GetClass(\"BABYLON.Animation\");\n        if (internalClass) {\n          light.animations.push(internalClass.Parse(parsedAnimation));\n        }\n      }\n      Node.ParseAnimationRanges(light, parsedLight, scene);\n    }\n    if (parsedLight.autoAnimate) {\n      scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1.0);\n    }\n    // Check if isEnabled is defined to be back compatible with prior serialized versions.\n    if (parsedLight.isEnabled !== undefined) {\n      light.setEnabled(parsedLight.isEnabled);\n    }\n    return light;\n  }\n  _hookArrayForExcluded(array) {\n    const oldPush = array.push;\n    array.push = (...items) => {\n      const result = oldPush.apply(array, items);\n      for (const item of items) {\n        item._resyncLightSource(this);\n      }\n      return result;\n    };\n    const oldSplice = array.splice;\n    array.splice = (index, deleteCount) => {\n      const deleted = oldSplice.apply(array, [index, deleteCount]);\n      for (const item of deleted) {\n        item._resyncLightSource(this);\n      }\n      return deleted;\n    };\n    for (const item of array) {\n      item._resyncLightSource(this);\n    }\n  }\n  _hookArrayForIncludedOnly(array) {\n    const oldPush = array.push;\n    array.push = (...items) => {\n      const result = oldPush.apply(array, items);\n      this._resyncMeshes();\n      return result;\n    };\n    const oldSplice = array.splice;\n    array.splice = (index, deleteCount) => {\n      const deleted = oldSplice.apply(array, [index, deleteCount]);\n      this._resyncMeshes();\n      return deleted;\n    };\n    this._resyncMeshes();\n  }\n  _resyncMeshes() {\n    for (const mesh of this.getScene().meshes) {\n      mesh._resyncLightSource(this);\n    }\n  }\n  /**\n   * Forces the meshes to update their light related information in their rendering used effects\n   * @internal Internal Use Only\n   */\n  _markMeshesAsLightDirty() {\n    for (const mesh of this.getScene().meshes) {\n      if (mesh.lightSources.indexOf(this) !== -1) {\n        mesh._markSubMeshesAsLightDirty();\n      }\n    }\n  }\n  /**\n   * Recomputes the cached photometric scale if needed.\n   */\n  _computePhotometricScale() {\n    this._photometricScale = this._getPhotometricScale();\n    this.getScene().resetCachedMaterial();\n  }\n  /**\n   * Returns the Photometric Scale according to the light type and intensity mode.\n   */\n  _getPhotometricScale() {\n    let photometricScale = 0.0;\n    const lightTypeID = this.getTypeID();\n    //get photometric mode\n    let photometricMode = this.intensityMode;\n    if (photometricMode === Light.INTENSITYMODE_AUTOMATIC) {\n      if (lightTypeID === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {\n        photometricMode = Light.INTENSITYMODE_ILLUMINANCE;\n      } else {\n        photometricMode = Light.INTENSITYMODE_LUMINOUSINTENSITY;\n      }\n    }\n    //compute photometric scale\n    switch (lightTypeID) {\n      case Light.LIGHTTYPEID_POINTLIGHT:\n      case Light.LIGHTTYPEID_SPOTLIGHT:\n        switch (photometricMode) {\n          case Light.INTENSITYMODE_LUMINOUSPOWER:\n            photometricScale = 1.0 / (4.0 * Math.PI);\n            break;\n          case Light.INTENSITYMODE_LUMINOUSINTENSITY:\n            photometricScale = 1.0;\n            break;\n          case Light.INTENSITYMODE_LUMINANCE:\n            photometricScale = this.radius * this.radius;\n            break;\n        }\n        break;\n      case Light.LIGHTTYPEID_DIRECTIONALLIGHT:\n        switch (photometricMode) {\n          case Light.INTENSITYMODE_ILLUMINANCE:\n            photometricScale = 1.0;\n            break;\n          case Light.INTENSITYMODE_LUMINANCE:\n            {\n              // When radius (and therefore solid angle) is non-zero a directional lights brightness can be specified via central (peak) luminance.\n              // For a directional light the 'radius' defines the angular radius (in radians) rather than world-space radius (e.g. in metres).\n              let apexAngleRadians = this.radius;\n              // Impose a minimum light angular size to avoid the light becoming an infinitely small angular light source (i.e. a dirac delta function).\n              apexAngleRadians = Math.max(apexAngleRadians, 0.001);\n              const solidAngle = 2.0 * Math.PI * (1.0 - Math.cos(apexAngleRadians));\n              photometricScale = solidAngle;\n              break;\n            }\n        }\n        break;\n      case Light.LIGHTTYPEID_HEMISPHERICLIGHT:\n        // No fall off in hemispheric light.\n        photometricScale = 1.0;\n        break;\n    }\n    return photometricScale;\n  }\n  /**\n   * Reorder the light in the scene according to their defined priority.\n   * @internal Internal Use Only\n   */\n  _reorderLightsInScene() {\n    const scene = this.getScene();\n    if (this._renderPriority != 0) {\n      scene.requireLightSorting = true;\n    }\n    this.getScene().sortLightsByPriority();\n  }\n}\n/**\n * Falloff Default: light is falling off following the material specification:\n * standard material is using standard falloff whereas pbr material can request special falloff per materials.\n */\nLight.FALLOFF_DEFAULT = LightConstants.FALLOFF_DEFAULT;\n/**\n * Falloff Physical: light is falling off following the inverse squared distance law.\n */\nLight.FALLOFF_PHYSICAL = LightConstants.FALLOFF_PHYSICAL;\n/**\n * Falloff gltf: light is falling off as described in the gltf moving to PBR document\n * to enhance interoperability with other engines.\n */\nLight.FALLOFF_GLTF = LightConstants.FALLOFF_GLTF;\n/**\n * Falloff Standard: light is falling off like in the standard material\n * to enhance interoperability with other materials.\n */\nLight.FALLOFF_STANDARD = LightConstants.FALLOFF_STANDARD;\n//lightmapMode Consts\n/**\n * If every light affecting the material is in this lightmapMode,\n * material.lightmapTexture adds or multiplies\n * (depends on material.useLightmapAsShadowmap)\n * after every other light calculations.\n */\nLight.LIGHTMAP_DEFAULT = LightConstants.LIGHTMAP_DEFAULT;\n/**\n * material.lightmapTexture as only diffuse lighting from this light\n * adds only specular lighting from this light\n * adds dynamic shadows\n */\nLight.LIGHTMAP_SPECULAR = LightConstants.LIGHTMAP_SPECULAR;\n/**\n * material.lightmapTexture as only lighting\n * no light calculation from this light\n * only adds dynamic shadows from this light\n */\nLight.LIGHTMAP_SHADOWSONLY = LightConstants.LIGHTMAP_SHADOWSONLY;\n// Intensity Mode Consts\n/**\n * Each light type uses the default quantity according to its type:\n *      point/spot lights use luminous intensity\n *      directional lights use illuminance\n */\nLight.INTENSITYMODE_AUTOMATIC = LightConstants.INTENSITYMODE_AUTOMATIC;\n/**\n * lumen (lm)\n */\nLight.INTENSITYMODE_LUMINOUSPOWER = LightConstants.INTENSITYMODE_LUMINOUSPOWER;\n/**\n * candela (lm/sr)\n */\nLight.INTENSITYMODE_LUMINOUSINTENSITY = LightConstants.INTENSITYMODE_LUMINOUSINTENSITY;\n/**\n * lux (lm/m^2)\n */\nLight.INTENSITYMODE_ILLUMINANCE = LightConstants.INTENSITYMODE_ILLUMINANCE;\n/**\n * nit (cd/m^2)\n */\nLight.INTENSITYMODE_LUMINANCE = LightConstants.INTENSITYMODE_LUMINANCE;\n// Light types ids const.\n/**\n * Light type const id of the point light.\n */\nLight.LIGHTTYPEID_POINTLIGHT = LightConstants.LIGHTTYPEID_POINTLIGHT;\n/**\n * Light type const id of the directional light.\n */\nLight.LIGHTTYPEID_DIRECTIONALLIGHT = LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT;\n/**\n * Light type const id of the spot light.\n */\nLight.LIGHTTYPEID_SPOTLIGHT = LightConstants.LIGHTTYPEID_SPOTLIGHT;\n/**\n * Light type const id of the hemispheric light.\n */\nLight.LIGHTTYPEID_HEMISPHERICLIGHT = LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT;\n__decorate([serializeAsColor3()], Light.prototype, \"diffuse\", void 0);\n__decorate([serializeAsColor3()], Light.prototype, \"specular\", void 0);\n__decorate([serialize()], Light.prototype, \"falloffType\", void 0);\n__decorate([serialize()], Light.prototype, \"intensity\", void 0);\n__decorate([serialize()], Light.prototype, \"range\", null);\n__decorate([serialize()], Light.prototype, \"intensityMode\", null);\n__decorate([serialize()], Light.prototype, \"radius\", null);\n__decorate([serialize()], Light.prototype, \"_renderPriority\", void 0);\n__decorate([expandToProperty(\"_reorderLightsInScene\")], Light.prototype, \"renderPriority\", void 0);\n__decorate([serialize(\"shadowEnabled\")], Light.prototype, \"_shadowEnabled\", void 0);\n__decorate([serialize(\"excludeWithLayerMask\")], Light.prototype, \"_excludeWithLayerMask\", void 0);\n__decorate([serialize(\"includeOnlyWithLayerMask\")], Light.prototype, \"_includeOnlyWithLayerMask\", void 0);\n__decorate([serialize(\"lightmapMode\")], Light.prototype, \"_lightmapMode\", void 0);","map":{"version":3,"names":["serialize","SerializationHelper","serializeAsColor3","expandToProperty","Vector3","Color3","TmpColors","Node","UniformBuffer","GetClass","LightConstants","Light","range","_range","value","_inverseSquaredRange","intensityMode","_intensityMode","_computePhotometricScale","radius","_radius","shadowEnabled","_shadowEnabled","_markMeshesAsLightDirty","includedOnlyMeshes","_includedOnlyMeshes","_hookArrayForIncludedOnly","excludedMeshes","_excludedMeshes","_hookArrayForExcluded","excludeWithLayerMask","_excludeWithLayerMask","_resyncMeshes","includeOnlyWithLayerMask","_includeOnlyWithLayerMask","lightmapMode","_lightmapMode","constructor","name","scene","diffuse","specular","falloffType","FALLOFF_DEFAULT","intensity","Number","MAX_VALUE","_photometricScale","INTENSITYMODE_AUTOMATIC","renderPriority","_shadowGenerators","_excludedMeshesIds","Array","_includedOnlyMeshesIds","_isLight","getScene","addLight","_uniformBuffer","getEngine","undefined","_buildUniformLayout","transferTexturesToEffect","effect","lightIndex","_bindLight","useSpecular","receiveShadows","iAsString","toString","needUpdate","bindToEffect","_renderId","getRenderId","_lastUseSpecular","useUbo","scaledIntensity","getScaledIntensity","transferToEffect","scaleToRef","updateColor4","shadowsEnabled","shadowGenerator","_a","getShadowGenerator","activeCamera","bindShadowLight","update","bindUniformBuffer","getClassName","fullDetails","ret","getTypeID","animations","i","length","_syncParentEnabledState","isDisposed","setEnabled","camera","get","getShadowGenerators","getAbsolutePosition","Zero","canAffectMesh","mesh","indexOf","layerMask","dispose","doNotRecurse","disposeMaterialAndTextures","iterator","values","key","next","done","stopAnimation","_parentContainer","index","lights","splice","meshes","_removeLightSource","removeLight","clone","newParent","GetConstructorFromName","clonedLight","Clone","parent","isEnabled","onClonedObservable","notifyObservers","serializationObject","Serialize","uniqueId","type","_serializeAsParent","excludedMeshesIds","forEach","push","id","includedOnlyMeshesIds","AppendSerializedAnimations","ranges","serializeAnimationRanges","constructorFunc","Construct","Parse","parsedLight","light","parentId","_waitingParentId","parentInstanceIndex","_waitingParentInstanceIndex","animationIndex","parsedAnimation","internalClass","ParseAnimationRanges","autoAnimate","beginAnimation","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","array","oldPush","items","result","apply","item","_resyncLightSource","oldSplice","deleteCount","deleted","lightSources","_markSubMeshesAsLightDirty","_getPhotometricScale","resetCachedMaterial","photometricScale","lightTypeID","photometricMode","LIGHTTYPEID_DIRECTIONALLIGHT","INTENSITYMODE_ILLUMINANCE","INTENSITYMODE_LUMINOUSINTENSITY","LIGHTTYPEID_POINTLIGHT","LIGHTTYPEID_SPOTLIGHT","INTENSITYMODE_LUMINOUSPOWER","Math","PI","INTENSITYMODE_LUMINANCE","apexAngleRadians","max","solidAngle","cos","LIGHTTYPEID_HEMISPHERICLIGHT","_reorderLightsInScene","_renderPriority","requireLightSorting","sortLightsByPriority","FALLOFF_PHYSICAL","FALLOFF_GLTF","FALLOFF_STANDARD","LIGHTMAP_DEFAULT","LIGHTMAP_SPECULAR","LIGHTMAP_SHADOWSONLY","__decorate"],"sources":["../../../../dev/core/src/Lights/light.ts"],"sourcesContent":["import { serialize, SerializationHelper, serializeAsColor3, expandToProperty } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3, TmpColors } from \"../Maths/math.color\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport type { IShadowGenerator } from \"./Shadows/shadowGenerator\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\nimport type { ISortableLight } from \"./lightConstants\";\r\nimport { LightConstants } from \"./lightConstants\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\n\r\n/**\r\n * Base class of all the lights in Babylon. It groups all the generic information about lights.\r\n * Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.\r\n * All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.\r\n */\r\nexport abstract class Light extends Node implements ISortableLight {\r\n    /**\r\n     * Falloff Default: light is falling off following the material specification:\r\n     * standard material is using standard falloff whereas pbr material can request special falloff per materials.\r\n     */\r\n    public static readonly FALLOFF_DEFAULT = LightConstants.FALLOFF_DEFAULT;\r\n\r\n    /**\r\n     * Falloff Physical: light is falling off following the inverse squared distance law.\r\n     */\r\n    public static readonly FALLOFF_PHYSICAL = LightConstants.FALLOFF_PHYSICAL;\r\n\r\n    /**\r\n     * Falloff gltf: light is falling off as described in the gltf moving to PBR document\r\n     * to enhance interoperability with other engines.\r\n     */\r\n    public static readonly FALLOFF_GLTF = LightConstants.FALLOFF_GLTF;\r\n\r\n    /**\r\n     * Falloff Standard: light is falling off like in the standard material\r\n     * to enhance interoperability with other materials.\r\n     */\r\n    public static readonly FALLOFF_STANDARD = LightConstants.FALLOFF_STANDARD;\r\n\r\n    //lightmapMode Consts\r\n    /**\r\n     * If every light affecting the material is in this lightmapMode,\r\n     * material.lightmapTexture adds or multiplies\r\n     * (depends on material.useLightmapAsShadowmap)\r\n     * after every other light calculations.\r\n     */\r\n    public static readonly LIGHTMAP_DEFAULT = LightConstants.LIGHTMAP_DEFAULT;\r\n    /**\r\n     * material.lightmapTexture as only diffuse lighting from this light\r\n     * adds only specular lighting from this light\r\n     * adds dynamic shadows\r\n     */\r\n    public static readonly LIGHTMAP_SPECULAR = LightConstants.LIGHTMAP_SPECULAR;\r\n    /**\r\n     * material.lightmapTexture as only lighting\r\n     * no light calculation from this light\r\n     * only adds dynamic shadows from this light\r\n     */\r\n    public static readonly LIGHTMAP_SHADOWSONLY = LightConstants.LIGHTMAP_SHADOWSONLY;\r\n\r\n    // Intensity Mode Consts\r\n    /**\r\n     * Each light type uses the default quantity according to its type:\r\n     *      point/spot lights use luminous intensity\r\n     *      directional lights use illuminance\r\n     */\r\n    public static readonly INTENSITYMODE_AUTOMATIC = LightConstants.INTENSITYMODE_AUTOMATIC;\r\n    /**\r\n     * lumen (lm)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINOUSPOWER = LightConstants.INTENSITYMODE_LUMINOUSPOWER;\r\n    /**\r\n     * candela (lm/sr)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINOUSINTENSITY = LightConstants.INTENSITYMODE_LUMINOUSINTENSITY;\r\n    /**\r\n     * lux (lm/m^2)\r\n     */\r\n    public static readonly INTENSITYMODE_ILLUMINANCE = LightConstants.INTENSITYMODE_ILLUMINANCE;\r\n    /**\r\n     * nit (cd/m^2)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINANCE = LightConstants.INTENSITYMODE_LUMINANCE;\r\n\r\n    // Light types ids const.\r\n    /**\r\n     * Light type const id of the point light.\r\n     */\r\n    public static readonly LIGHTTYPEID_POINTLIGHT = LightConstants.LIGHTTYPEID_POINTLIGHT;\r\n    /**\r\n     * Light type const id of the directional light.\r\n     */\r\n    public static readonly LIGHTTYPEID_DIRECTIONALLIGHT = LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT;\r\n    /**\r\n     * Light type const id of the spot light.\r\n     */\r\n    public static readonly LIGHTTYPEID_SPOTLIGHT = LightConstants.LIGHTTYPEID_SPOTLIGHT;\r\n    /**\r\n     * Light type const id of the hemispheric light.\r\n     */\r\n    public static readonly LIGHTTYPEID_HEMISPHERICLIGHT = LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT;\r\n\r\n    /**\r\n     * Diffuse gives the basic color to an object.\r\n     */\r\n    @serializeAsColor3()\r\n    public diffuse = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * Specular produces a highlight color on an object.\r\n     * Note: This is not affecting PBR materials.\r\n     */\r\n    @serializeAsColor3()\r\n    public specular = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * Defines the falloff type for this light. This lets overriding how punctual light are\r\n     * falling off base on range or angle.\r\n     * This can be set to any values in Light.FALLOFF_x.\r\n     *\r\n     * Note: This is only useful for PBR Materials at the moment. This could be extended if required to\r\n     * other types of materials.\r\n     */\r\n    @serialize()\r\n    public falloffType = Light.FALLOFF_DEFAULT;\r\n\r\n    /**\r\n     * Strength of the light.\r\n     * Note: By default it is define in the framework own unit.\r\n     * Note: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.\r\n     */\r\n    @serialize()\r\n    public intensity = 1.0;\r\n\r\n    private _range = Number.MAX_VALUE;\r\n    protected _inverseSquaredRange = 0;\r\n\r\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\r\n    @serialize()\r\n    public get range(): number {\r\n        return this._range;\r\n    }\r\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\r\n    public set range(value: number) {\r\n        this._range = value;\r\n        this._inverseSquaredRange = 1.0 / (this.range * this.range);\r\n    }\r\n\r\n    /**\r\n     * Cached photometric scale default to 1.0 as the automatic intensity mode defaults to 1.0 for every type\r\n     * of light.\r\n     */\r\n    private _photometricScale = 1.0;\r\n\r\n    private _intensityMode: number = Light.INTENSITYMODE_AUTOMATIC;\r\n    /**\r\n     * Gets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\r\n    @serialize()\r\n    public get intensityMode(): number {\r\n        return this._intensityMode;\r\n    }\r\n    /**\r\n     * Sets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\r\n    public set intensityMode(value: number) {\r\n        this._intensityMode = value;\r\n        this._computePhotometricScale();\r\n    }\r\n\r\n    private _radius = 0.00001;\r\n    /**\r\n     * Gets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\r\n    @serialize()\r\n    public get radius(): number {\r\n        return this._radius;\r\n    }\r\n    /**\r\n     * sets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\r\n    public set radius(value: number) {\r\n        this._radius = value;\r\n        this._computePhotometricScale();\r\n    }\r\n\r\n    @serialize()\r\n    private _renderPriority: number;\r\n    /**\r\n     * Defines the rendering priority of the lights. It can help in case of fallback or number of lights\r\n     * exceeding the number allowed of the materials.\r\n     */\r\n    @expandToProperty(\"_reorderLightsInScene\")\r\n    public renderPriority: number = 0;\r\n\r\n    @serialize(\"shadowEnabled\")\r\n    private _shadowEnabled: boolean = true;\r\n    /**\r\n     * Gets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\r\n    public get shadowEnabled(): boolean {\r\n        return this._shadowEnabled;\r\n    }\r\n    /**\r\n     * Sets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\r\n    public set shadowEnabled(value: boolean) {\r\n        if (this._shadowEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._shadowEnabled = value;\r\n        this._markMeshesAsLightDirty();\r\n    }\r\n\r\n    private _includedOnlyMeshes: AbstractMesh[];\r\n    /**\r\n     * Gets the only meshes impacted by this light.\r\n     */\r\n    public get includedOnlyMeshes(): AbstractMesh[] {\r\n        return this._includedOnlyMeshes;\r\n    }\r\n    /**\r\n     * Sets the only meshes impacted by this light.\r\n     */\r\n    public set includedOnlyMeshes(value: AbstractMesh[]) {\r\n        this._includedOnlyMeshes = value;\r\n        this._hookArrayForIncludedOnly(value);\r\n    }\r\n\r\n    private _excludedMeshes: AbstractMesh[];\r\n    /**\r\n     * Gets the meshes not impacted by this light.\r\n     */\r\n    public get excludedMeshes(): AbstractMesh[] {\r\n        return this._excludedMeshes;\r\n    }\r\n    /**\r\n     * Sets the meshes not impacted by this light.\r\n     */\r\n    public set excludedMeshes(value: AbstractMesh[]) {\r\n        this._excludedMeshes = value;\r\n        this._hookArrayForExcluded(value);\r\n    }\r\n\r\n    @serialize(\"excludeWithLayerMask\")\r\n    private _excludeWithLayerMask = 0;\r\n    /**\r\n     * Gets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public get excludeWithLayerMask(): number {\r\n        return this._excludeWithLayerMask;\r\n    }\r\n    /**\r\n     * Sets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public set excludeWithLayerMask(value: number) {\r\n        this._excludeWithLayerMask = value;\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    @serialize(\"includeOnlyWithLayerMask\")\r\n    private _includeOnlyWithLayerMask = 0;\r\n    /**\r\n     * Gets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public get includeOnlyWithLayerMask(): number {\r\n        return this._includeOnlyWithLayerMask;\r\n    }\r\n    /**\r\n     * Sets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public set includeOnlyWithLayerMask(value: number) {\r\n        this._includeOnlyWithLayerMask = value;\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    @serialize(\"lightmapMode\")\r\n    private _lightmapMode = 0;\r\n    /**\r\n     * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\r\n    public get lightmapMode(): number {\r\n        return this._lightmapMode;\r\n    }\r\n    /**\r\n     * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\r\n    public set lightmapMode(value: number) {\r\n        if (this._lightmapMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._lightmapMode = value;\r\n        this._markMeshesAsLightDirty();\r\n    }\r\n\r\n    /**\r\n     * Shadow generators associated to the light.\r\n     * @internal Internal use only.\r\n     */\r\n    public _shadowGenerators: Nullable<Map<Nullable<Camera>, IShadowGenerator>> = null;\r\n\r\n    /**\r\n     * @internal Internal use only.\r\n     */\r\n    public _excludedMeshesIds = new Array<string>();\r\n\r\n    /**\r\n     * @internal Internal use only.\r\n     */\r\n    public _includedOnlyMeshesIds = new Array<string>();\r\n\r\n    /**\r\n     * The current light uniform buffer.\r\n     * @internal Internal use only.\r\n     */\r\n    public _uniformBuffer: UniformBuffer;\r\n\r\n    /** @internal */\r\n    public _renderId: number;\r\n\r\n    private _lastUseSpecular: boolean;\r\n\r\n    /**\r\n     * Creates a Light object in the scene.\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The friendly name of the light\r\n     * @param scene The scene the light belongs too\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n        this.getScene().addLight(this);\r\n        this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), undefined, undefined, name);\r\n        this._buildUniformLayout();\r\n\r\n        this.includedOnlyMeshes = new Array<AbstractMesh>();\r\n        this.excludedMeshes = new Array<AbstractMesh>();\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    protected abstract _buildUniformLayout(): void;\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light information.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The light\r\n     */\r\n    public abstract transferToEffect(effect: Effect, lightIndex: string): Light;\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light textures.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The light\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public transferTexturesToEffect(effect: Effect, lightIndex: string): Light {\r\n        // Do nothing by default.\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param lightIndex Light index\r\n     * @param scene The scene where the light belongs to\r\n     * @param effect The effect we are binding the data to\r\n     * @param useSpecular Defines if specular is supported\r\n     * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\r\n     */\r\n    public _bindLight(lightIndex: number, scene: Scene, effect: Effect, useSpecular: boolean, receiveShadows = true): void {\r\n        const iAsString = lightIndex.toString();\r\n        let needUpdate = false;\r\n\r\n        this._uniformBuffer.bindToEffect(effect, \"Light\" + iAsString);\r\n\r\n        if (this._renderId !== scene.getRenderId() || this._lastUseSpecular !== useSpecular || !this._uniformBuffer.useUbo) {\r\n            this._renderId = scene.getRenderId();\r\n            this._lastUseSpecular = useSpecular;\r\n\r\n            const scaledIntensity = this.getScaledIntensity();\r\n\r\n            this.transferToEffect(effect, iAsString);\r\n\r\n            this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);\r\n            this._uniformBuffer.updateColor4(\"vLightDiffuse\", TmpColors.Color3[0], this.range, iAsString);\r\n            if (useSpecular) {\r\n                this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);\r\n                this._uniformBuffer.updateColor4(\"vLightSpecular\", TmpColors.Color3[1], this.radius, iAsString);\r\n            }\r\n            needUpdate = true;\r\n        }\r\n\r\n        // Textures might still need to be rebound.\r\n        this.transferTexturesToEffect(effect, iAsString);\r\n\r\n        // Shadows\r\n        if (scene.shadowsEnabled && this.shadowEnabled && receiveShadows) {\r\n            const shadowGenerator = this.getShadowGenerator(scene.activeCamera) ?? this.getShadowGenerator();\r\n            if (shadowGenerator) {\r\n                shadowGenerator.bindShadowLight(iAsString, effect);\r\n                needUpdate = true;\r\n            }\r\n        }\r\n\r\n        if (needUpdate) {\r\n            this._uniformBuffer.update();\r\n        } else {\r\n            this._uniformBuffer.bindUniformBuffer();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light information.\r\n     * @param effect The effect to update\r\n     * @param lightDataUniformName The uniform used to store light data (position or direction)\r\n     * @returns The light\r\n     */\r\n    public abstract transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string): Light;\r\n\r\n    /**\r\n     * Returns the string \"Light\".\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Light\";\r\n    }\r\n\r\n    /** @internal */\r\n    public readonly _isLight = true;\r\n\r\n    /**\r\n     * Converts the light information to a readable string for debug purpose.\r\n     * @param fullDetails Supports for multiple levels of logging within scene loading\r\n     * @returns the human readable light info\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name;\r\n        ret += \", type: \" + [\"Point\", \"Directional\", \"Spot\", \"Hemispheric\"][this.getTypeID()];\r\n        if (this.animations) {\r\n            for (let i = 0; i < this.animations.length; i++) {\r\n                ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _syncParentEnabledState() {\r\n        super._syncParentEnabledState();\r\n        if (!this.isDisposed()) {\r\n            this._resyncMeshes();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the enabled state of this node.\r\n     * @param value - the new enabled state\r\n     */\r\n    public setEnabled(value: boolean): void {\r\n        super.setEnabled(value);\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    /**\r\n     * Returns the Light associated shadow generator if any.\r\n     * @param camera Camera for which the shadow generator should be retrieved (default: null). If null, retrieves the default shadow generator\r\n     * @returns the associated shadow generator.\r\n     */\r\n    public getShadowGenerator(camera: Nullable<Camera> = null): Nullable<IShadowGenerator> {\r\n        if (this._shadowGenerators === null) {\r\n            return null;\r\n        }\r\n\r\n        return this._shadowGenerators.get(camera) ?? null;\r\n    }\r\n\r\n    /**\r\n     * Returns all the shadow generators associated to this light\r\n     * @returns\r\n     */\r\n    public getShadowGenerators(): Nullable<Map<Nullable<Camera>, IShadowGenerator>> {\r\n        return this._shadowGenerators;\r\n    }\r\n\r\n    /**\r\n     * Returns a Vector3, the absolute light position in the World.\r\n     * @returns the world space position of the light\r\n     */\r\n    public getAbsolutePosition(): Vector3 {\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Specifies if the light will affect the passed mesh.\r\n     * @param mesh The mesh to test against the light\r\n     * @returns true the mesh is affected otherwise, false.\r\n     */\r\n    public canAffectMesh(mesh: AbstractMesh): boolean {\r\n        if (!mesh) {\r\n            return true;\r\n        }\r\n\r\n        if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\r\n            return false;\r\n        }\r\n\r\n        if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {\r\n            return false;\r\n        }\r\n\r\n        if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this node.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        if (this._shadowGenerators) {\r\n            const iterator = this._shadowGenerators.values();\r\n            for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                const shadowGenerator = key.value;\r\n                shadowGenerator.dispose();\r\n            }\r\n            this._shadowGenerators = null;\r\n        }\r\n\r\n        // Animations\r\n        this.getScene().stopAnimation(this);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.lights.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.lights.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        // Remove from meshes\r\n        for (const mesh of this.getScene().meshes) {\r\n            mesh._removeLightSource(this, true);\r\n        }\r\n\r\n        this._uniformBuffer.dispose();\r\n\r\n        // Remove from scene\r\n        this.getScene().removeLight(this);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * Returns the light type ID (integer).\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.\r\n     * @returns the scaled intensity in intensity mode unit\r\n     */\r\n    public getScaledIntensity() {\r\n        return this._photometricScale * this.intensity;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Light object, named \"name\", from the current one.\r\n     * @param name The name of the cloned light\r\n     * @param newParent The parent of this light, if it has one\r\n     * @returns the new created light\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null): Nullable<Light> {\r\n        const constructor = Light.GetConstructorFromName(this.getTypeID(), name, this.getScene());\r\n\r\n        if (!constructor) {\r\n            return null;\r\n        }\r\n        const clonedLight = SerializationHelper.Clone(constructor, this);\r\n        if (name) {\r\n            clonedLight.name = name;\r\n        }\r\n        if (newParent) {\r\n            clonedLight.parent = newParent;\r\n        }\r\n        clonedLight.setEnabled(this.isEnabled());\r\n\r\n        this.onClonedObservable.notifyObservers(clonedLight);\r\n\r\n        return clonedLight;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current light into a Serialization object.\r\n     * @returns the serialized object.\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        // Type\r\n        serializationObject.type = this.getTypeID();\r\n\r\n        // Parent\r\n        if (this.parent) {\r\n            this.parent._serializeAsParent(serializationObject);\r\n        }\r\n\r\n        // Inclusion / exclusions\r\n        if (this.excludedMeshes.length > 0) {\r\n            serializationObject.excludedMeshesIds = [];\r\n            this.excludedMeshes.forEach((mesh: AbstractMesh) => {\r\n                serializationObject.excludedMeshesIds.push(mesh.id);\r\n            });\r\n        }\r\n\r\n        if (this.includedOnlyMeshes.length > 0) {\r\n            serializationObject.includedOnlyMeshesIds = [];\r\n            this.includedOnlyMeshes.forEach((mesh: AbstractMesh) => {\r\n                serializationObject.includedOnlyMeshesIds.push(mesh.id);\r\n            });\r\n        }\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n        serializationObject.ranges = this.serializeAnimationRanges();\r\n\r\n        serializationObject.isEnabled = this.isEnabled();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.\r\n     * This new light is named \"name\" and added to the passed scene.\r\n     * @param type Type according to the types available in Light.LIGHTTYPEID_x\r\n     * @param name The friendly name of the light\r\n     * @param scene The scene the new light will belong to\r\n     * @returns the constructor function\r\n     */\r\n    static GetConstructorFromName(type: number, name: string, scene: Scene): Nullable<() => Light> {\r\n        const constructorFunc = Node.Construct(\"Light_Type_\" + type, name, scene);\r\n\r\n        if (constructorFunc) {\r\n            return <() => Light>constructorFunc;\r\n        }\r\n\r\n        // Default to no light for none present once.\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Parses the passed \"parsedLight\" and returns a new instanced Light from this parsing.\r\n     * @param parsedLight The JSON representation of the light\r\n     * @param scene The scene to create the parsed light in\r\n     * @returns the created light after parsing\r\n     */\r\n    public static Parse(parsedLight: any, scene: Scene): Nullable<Light> {\r\n        const constructor = Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);\r\n\r\n        if (!constructor) {\r\n            return null;\r\n        }\r\n\r\n        const light = SerializationHelper.Parse(constructor, parsedLight, scene);\r\n\r\n        // Inclusion / exclusions\r\n        if (parsedLight.excludedMeshesIds) {\r\n            light._excludedMeshesIds = parsedLight.excludedMeshesIds;\r\n        }\r\n\r\n        if (parsedLight.includedOnlyMeshesIds) {\r\n            light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;\r\n        }\r\n\r\n        // Parent\r\n        if (parsedLight.parentId !== undefined) {\r\n            light._waitingParentId = parsedLight.parentId;\r\n        }\r\n\r\n        if (parsedLight.parentInstanceIndex !== undefined) {\r\n            light._waitingParentInstanceIndex = parsedLight.parentInstanceIndex;\r\n        }\r\n\r\n        // Falloff\r\n        if (parsedLight.falloffType !== undefined) {\r\n            light.falloffType = parsedLight.falloffType;\r\n        }\r\n\r\n        // Lightmaps\r\n        if (parsedLight.lightmapMode !== undefined) {\r\n            light.lightmapMode = parsedLight.lightmapMode;\r\n        }\r\n\r\n        // Animations\r\n        if (parsedLight.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedLight.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    light.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n            Node.ParseAnimationRanges(light, parsedLight, scene);\r\n        }\r\n\r\n        if (parsedLight.autoAnimate) {\r\n            scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1.0);\r\n        }\r\n\r\n        // Check if isEnabled is defined to be back compatible with prior serialized versions.\r\n        if (parsedLight.isEnabled !== undefined) {\r\n            light.setEnabled(parsedLight.isEnabled);\r\n        }\r\n\r\n        return light;\r\n    }\r\n\r\n    private _hookArrayForExcluded(array: AbstractMesh[]): void {\r\n        const oldPush = array.push;\r\n        array.push = (...items: AbstractMesh[]) => {\r\n            const result = oldPush.apply(array, items);\r\n\r\n            for (const item of items) {\r\n                item._resyncLightSource(this);\r\n            }\r\n\r\n            return result;\r\n        };\r\n\r\n        const oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            const deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            for (const item of deleted) {\r\n                item._resyncLightSource(this);\r\n            }\r\n\r\n            return deleted;\r\n        };\r\n\r\n        for (const item of array) {\r\n            item._resyncLightSource(this);\r\n        }\r\n    }\r\n\r\n    private _hookArrayForIncludedOnly(array: AbstractMesh[]): void {\r\n        const oldPush = array.push;\r\n        array.push = (...items: AbstractMesh[]) => {\r\n            const result = oldPush.apply(array, items);\r\n\r\n            this._resyncMeshes();\r\n\r\n            return result;\r\n        };\r\n\r\n        const oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            const deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            this._resyncMeshes();\r\n\r\n            return deleted;\r\n        };\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    private _resyncMeshes() {\r\n        for (const mesh of this.getScene().meshes) {\r\n            mesh._resyncLightSource(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Forces the meshes to update their light related information in their rendering used effects\r\n     * @internal Internal Use Only\r\n     */\r\n    public _markMeshesAsLightDirty() {\r\n        for (const mesh of this.getScene().meshes) {\r\n            if (mesh.lightSources.indexOf(this) !== -1) {\r\n                mesh._markSubMeshesAsLightDirty();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recomputes the cached photometric scale if needed.\r\n     */\r\n    private _computePhotometricScale(): void {\r\n        this._photometricScale = this._getPhotometricScale();\r\n        this.getScene().resetCachedMaterial();\r\n    }\r\n\r\n    /**\r\n     * Returns the Photometric Scale according to the light type and intensity mode.\r\n     */\r\n    private _getPhotometricScale() {\r\n        let photometricScale = 0.0;\r\n        const lightTypeID = this.getTypeID();\r\n\r\n        //get photometric mode\r\n        let photometricMode = this.intensityMode;\r\n        if (photometricMode === Light.INTENSITYMODE_AUTOMATIC) {\r\n            if (lightTypeID === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {\r\n                photometricMode = Light.INTENSITYMODE_ILLUMINANCE;\r\n            } else {\r\n                photometricMode = Light.INTENSITYMODE_LUMINOUSINTENSITY;\r\n            }\r\n        }\r\n\r\n        //compute photometric scale\r\n        switch (lightTypeID) {\r\n            case Light.LIGHTTYPEID_POINTLIGHT:\r\n            case Light.LIGHTTYPEID_SPOTLIGHT:\r\n                switch (photometricMode) {\r\n                    case Light.INTENSITYMODE_LUMINOUSPOWER:\r\n                        photometricScale = 1.0 / (4.0 * Math.PI);\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINOUSINTENSITY:\r\n                        photometricScale = 1.0;\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINANCE:\r\n                        photometricScale = this.radius * this.radius;\r\n                        break;\r\n                }\r\n                break;\r\n\r\n            case Light.LIGHTTYPEID_DIRECTIONALLIGHT:\r\n                switch (photometricMode) {\r\n                    case Light.INTENSITYMODE_ILLUMINANCE:\r\n                        photometricScale = 1.0;\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINANCE: {\r\n                        // When radius (and therefore solid angle) is non-zero a directional lights brightness can be specified via central (peak) luminance.\r\n                        // For a directional light the 'radius' defines the angular radius (in radians) rather than world-space radius (e.g. in metres).\r\n                        let apexAngleRadians = this.radius;\r\n                        // Impose a minimum light angular size to avoid the light becoming an infinitely small angular light source (i.e. a dirac delta function).\r\n                        apexAngleRadians = Math.max(apexAngleRadians, 0.001);\r\n                        const solidAngle = 2.0 * Math.PI * (1.0 - Math.cos(apexAngleRadians));\r\n                        photometricScale = solidAngle;\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case Light.LIGHTTYPEID_HEMISPHERICLIGHT:\r\n                // No fall off in hemispheric light.\r\n                photometricScale = 1.0;\r\n                break;\r\n        }\r\n        return photometricScale;\r\n    }\r\n\r\n    /**\r\n     * Reorder the light in the scene according to their defined priority.\r\n     * @internal Internal Use Only\r\n     */\r\n    public _reorderLightsInScene(): void {\r\n        const scene = this.getScene();\r\n        if (this._renderPriority != 0) {\r\n            scene.requireLightSorting = true;\r\n        }\r\n        this.getScene().sortLightsByPriority();\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public abstract prepareLightSpecificDefines(defines: any, lightIndex: number): void;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}