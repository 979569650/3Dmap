{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Scalar } from \"./math.scalar.js\";\nimport { Vector2, Vector3, Quaternion, Matrix } from \"./math.vector.js\";\nimport { Epsilon } from \"./math.constants.js\";\n/**\n * Defines potential orientation for back face culling\n */\nexport var Orientation;\n(function (Orientation) {\n  /**\n   * Clockwise\n   */\n  Orientation[Orientation[\"CW\"] = 0] = \"CW\";\n  /** Counter clockwise */\n  Orientation[Orientation[\"CCW\"] = 1] = \"CCW\";\n})(Orientation || (Orientation = {}));\n/** Class used to represent a Bezier curve */\nexport class BezierCurve {\n  /**\n   * Returns the cubic Bezier interpolated value (float) at \"t\" (float) from the given x1, y1, x2, y2 floats\n   * @param t defines the time\n   * @param x1 defines the left coordinate on X axis\n   * @param y1 defines the left coordinate on Y axis\n   * @param x2 defines the right coordinate on X axis\n   * @param y2 defines the right coordinate on Y axis\n   * @returns the interpolated value\n   */\n  static Interpolate(t, x1, y1, x2, y2) {\n    // Extract X (which is equal to time here)\n    const f0 = 1 - 3 * x2 + 3 * x1;\n    const f1 = 3 * x2 - 6 * x1;\n    const f2 = 3 * x1;\n    let refinedT = t;\n    for (let i = 0; i < 5; i++) {\n      const refinedT2 = refinedT * refinedT;\n      const refinedT3 = refinedT2 * refinedT;\n      const x = f0 * refinedT3 + f1 * refinedT2 + f2 * refinedT;\n      const slope = 1.0 / (3.0 * f0 * refinedT2 + 2.0 * f1 * refinedT + f2);\n      refinedT -= (x - t) * slope;\n      refinedT = Math.min(1, Math.max(0, refinedT));\n    }\n    // Resolve cubic bezier for the given x\n    return 3 * Math.pow(1 - refinedT, 2) * refinedT * y1 + 3 * (1 - refinedT) * Math.pow(refinedT, 2) * y2 + Math.pow(refinedT, 3);\n  }\n}\n/**\n * Defines angle representation\n */\nexport class Angle {\n  /**\n   * Creates an Angle object of \"radians\" radians (float).\n   * @param radians the angle in radians\n   */\n  constructor(radians) {\n    this._radians = radians;\n    if (this._radians < 0.0) {\n      this._radians += 2.0 * Math.PI;\n    }\n  }\n  /**\n   * Get value in degrees\n   * @returns the Angle value in degrees (float)\n   */\n  degrees() {\n    return this._radians * 180.0 / Math.PI;\n  }\n  /**\n   * Get value in radians\n   * @returns the Angle value in radians (float)\n   */\n  radians() {\n    return this._radians;\n  }\n  /**\n   * Gets a new Angle object valued with the gradient angle, in radians, of the line joining two points\n   * @param a defines first point as the origin\n   * @param b defines point\n   * @returns a new Angle\n   */\n  static BetweenTwoPoints(a, b) {\n    const delta = b.subtract(a);\n    const theta = Math.atan2(delta.y, delta.x);\n    return new Angle(theta);\n  }\n  /**\n   * Gets a new Angle object from the given float in radians\n   * @param radians defines the angle value in radians\n   * @returns a new Angle\n   */\n  static FromRadians(radians) {\n    return new Angle(radians);\n  }\n  /**\n   * Gets a new Angle object from the given float in degrees\n   * @param degrees defines the angle value in degrees\n   * @returns a new Angle\n   */\n  static FromDegrees(degrees) {\n    return new Angle(degrees * Math.PI / 180.0);\n  }\n}\n/**\n * This represents an arc in a 2d space.\n */\nexport class Arc2 {\n  /**\n   * Creates an Arc object from the three given points : start, middle and end.\n   * @param startPoint Defines the start point of the arc\n   * @param midPoint Defines the middle point of the arc\n   * @param endPoint Defines the end point of the arc\n   */\n  constructor( /** Defines the start point of the arc */\n  startPoint, /** Defines the mid point of the arc */\n  midPoint, /** Defines the end point of the arc */\n  endPoint) {\n    this.startPoint = startPoint;\n    this.midPoint = midPoint;\n    this.endPoint = endPoint;\n    const temp = Math.pow(midPoint.x, 2) + Math.pow(midPoint.y, 2);\n    const startToMid = (Math.pow(startPoint.x, 2) + Math.pow(startPoint.y, 2) - temp) / 2;\n    const midToEnd = (temp - Math.pow(endPoint.x, 2) - Math.pow(endPoint.y, 2)) / 2;\n    const det = (startPoint.x - midPoint.x) * (midPoint.y - endPoint.y) - (midPoint.x - endPoint.x) * (startPoint.y - midPoint.y);\n    this.centerPoint = new Vector2((startToMid * (midPoint.y - endPoint.y) - midToEnd * (startPoint.y - midPoint.y)) / det, ((startPoint.x - midPoint.x) * midToEnd - (midPoint.x - endPoint.x) * startToMid) / det);\n    this.radius = this.centerPoint.subtract(this.startPoint).length();\n    this.startAngle = Angle.BetweenTwoPoints(this.centerPoint, this.startPoint);\n    const a1 = this.startAngle.degrees();\n    let a2 = Angle.BetweenTwoPoints(this.centerPoint, this.midPoint).degrees();\n    let a3 = Angle.BetweenTwoPoints(this.centerPoint, this.endPoint).degrees();\n    // angles correction\n    if (a2 - a1 > +180.0) {\n      a2 -= 360.0;\n    }\n    if (a2 - a1 < -180.0) {\n      a2 += 360.0;\n    }\n    if (a3 - a2 > +180.0) {\n      a3 -= 360.0;\n    }\n    if (a3 - a2 < -180.0) {\n      a3 += 360.0;\n    }\n    this.orientation = a2 - a1 < 0 ? Orientation.CW : Orientation.CCW;\n    this.angle = Angle.FromDegrees(this.orientation === Orientation.CW ? a1 - a3 : a3 - a1);\n  }\n}\n/**\n * Represents a 2D path made up of multiple 2D points\n */\nexport class Path2 {\n  /**\n   * Creates a Path2 object from the starting 2D coordinates x and y.\n   * @param x the starting points x value\n   * @param y the starting points y value\n   */\n  constructor(x, y) {\n    this._points = new Array();\n    this._length = 0.0;\n    /**\n     * If the path start and end point are the same\n     */\n    this.closed = false;\n    this._points.push(new Vector2(x, y));\n  }\n  /**\n   * Adds a new segment until the given coordinates (x, y) to the current Path2.\n   * @param x the added points x value\n   * @param y the added points y value\n   * @returns the updated Path2.\n   */\n  addLineTo(x, y) {\n    if (this.closed) {\n      return this;\n    }\n    const newPoint = new Vector2(x, y);\n    const previousPoint = this._points[this._points.length - 1];\n    this._points.push(newPoint);\n    this._length += newPoint.subtract(previousPoint).length();\n    return this;\n  }\n  /**\n   * Adds _numberOfSegments_ segments according to the arc definition (middle point coordinates, end point coordinates, the arc start point being the current Path2 last point) to the current Path2.\n   * @param midX middle point x value\n   * @param midY middle point y value\n   * @param endX end point x value\n   * @param endY end point y value\n   * @param numberOfSegments (default: 36)\n   * @returns the updated Path2.\n   */\n  addArcTo(midX, midY, endX, endY, numberOfSegments = 36) {\n    if (this.closed) {\n      return this;\n    }\n    const startPoint = this._points[this._points.length - 1];\n    const midPoint = new Vector2(midX, midY);\n    const endPoint = new Vector2(endX, endY);\n    const arc = new Arc2(startPoint, midPoint, endPoint);\n    let increment = arc.angle.radians() / numberOfSegments;\n    if (arc.orientation === Orientation.CW) {\n      increment *= -1;\n    }\n    let currentAngle = arc.startAngle.radians() + increment;\n    for (let i = 0; i < numberOfSegments; i++) {\n      const x = Math.cos(currentAngle) * arc.radius + arc.centerPoint.x;\n      const y = Math.sin(currentAngle) * arc.radius + arc.centerPoint.y;\n      this.addLineTo(x, y);\n      currentAngle += increment;\n    }\n    return this;\n  }\n  /**\n   * Adds _numberOfSegments_ segments according to the quadratic curve definition to the current Path2.\n   * @param controlX control point x value\n   * @param controlY control point y value\n   * @param endX end point x value\n   * @param endY end point y value\n   * @param numberOfSegments (default: 36)\n   * @returns the updated Path2.\n   */\n  addQuadraticCurveTo(controlX, controlY, endX, endY, numberOfSegments = 36) {\n    if (this.closed) {\n      return this;\n    }\n    const equation = (t, val0, val1, val2) => {\n      const res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;\n      return res;\n    };\n    const startPoint = this._points[this._points.length - 1];\n    for (let i = 0; i <= numberOfSegments; i++) {\n      const step = i / numberOfSegments;\n      const x = equation(step, startPoint.x, controlX, endX);\n      const y = equation(step, startPoint.y, controlY, endY);\n      this.addLineTo(x, y);\n    }\n    return this;\n  }\n  /**\n   * Adds _numberOfSegments_ segments according to the bezier curve definition to the current Path2.\n   * @param originTangentX tangent vector at the origin point x value\n   * @param originTangentY tangent vector at the origin point y value\n   * @param destinationTangentX tangent vector at the destination point x value\n   * @param destinationTangentY tangent vector at the destination point y value\n   * @param endX end point x value\n   * @param endY end point y value\n   * @param numberOfSegments (default: 36)\n   * @returns the updated Path2.\n   */\n  addBezierCurveTo(originTangentX, originTangentY, destinationTangentX, destinationTangentY, endX, endY, numberOfSegments = 36) {\n    if (this.closed) {\n      return this;\n    }\n    const equation = (t, val0, val1, val2, val3) => {\n      const res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;\n      return res;\n    };\n    const startPoint = this._points[this._points.length - 1];\n    for (let i = 0; i <= numberOfSegments; i++) {\n      const step = i / numberOfSegments;\n      const x = equation(step, startPoint.x, originTangentX, destinationTangentX, endX);\n      const y = equation(step, startPoint.y, originTangentY, destinationTangentY, endY);\n      this.addLineTo(x, y);\n    }\n    return this;\n  }\n  /**\n   * Defines if a given point is inside the polygon defines by the path\n   * @param point defines the point to test\n   * @returns true if the point is inside\n   */\n  isPointInside(point) {\n    let isInside = false;\n    const count = this._points.length;\n    for (let p = count - 1, q = 0; q < count; p = q++) {\n      let edgeLow = this._points[p];\n      let edgeHigh = this._points[q];\n      let edgeDx = edgeHigh.x - edgeLow.x;\n      let edgeDy = edgeHigh.y - edgeLow.y;\n      if (Math.abs(edgeDy) > Number.EPSILON) {\n        // Not parallel\n        if (edgeDy < 0) {\n          edgeLow = this._points[q];\n          edgeDx = -edgeDx;\n          edgeHigh = this._points[p];\n          edgeDy = -edgeDy;\n        }\n        if (point.y < edgeLow.y || point.y > edgeHigh.y) {\n          continue;\n        }\n        if (point.y === edgeLow.y && point.x === edgeLow.x) {\n          return true;\n        } else {\n          const perpEdge = edgeDy * (point.x - edgeLow.x) - edgeDx * (point.y - edgeLow.y);\n          if (perpEdge === 0) {\n            return true;\n          }\n          if (perpEdge < 0) {\n            continue;\n          }\n          isInside = !isInside;\n        }\n      } else {\n        // parallel or collinear\n        if (point.y !== edgeLow.y) {\n          continue;\n        }\n        if (edgeHigh.x <= point.x && point.x <= edgeLow.x || edgeLow.x <= point.x && point.x <= edgeHigh.x) {\n          return true;\n        }\n      }\n    }\n    return isInside;\n  }\n  /**\n   * Closes the Path2.\n   * @returns the Path2.\n   */\n  close() {\n    this.closed = true;\n    return this;\n  }\n  /**\n   * Gets the sum of the distance between each sequential point in the path\n   * @returns the Path2 total length (float).\n   */\n  length() {\n    let result = this._length;\n    if (this.closed) {\n      const lastPoint = this._points[this._points.length - 1];\n      const firstPoint = this._points[0];\n      result += firstPoint.subtract(lastPoint).length();\n    }\n    return result;\n  }\n  /**\n   * Gets the area of the polygon defined by the path\n   * @returns area value\n   */\n  area() {\n    const n = this._points.length;\n    let value = 0.0;\n    for (let p = n - 1, q = 0; q < n; p = q++) {\n      value += this._points[p].x * this._points[q].y - this._points[q].x * this._points[p].y;\n    }\n    return value * 0.5;\n  }\n  /**\n   * Gets the points which construct the path\n   * @returns the Path2 internal array of points.\n   */\n  getPoints() {\n    return this._points;\n  }\n  /**\n   * Retrieves the point at the distance aways from the starting point\n   * @param normalizedLengthPosition the length along the path to retrieve the point from\n   * @returns a new Vector2 located at a percentage of the Path2 total length on this path.\n   */\n  getPointAtLengthPosition(normalizedLengthPosition) {\n    if (normalizedLengthPosition < 0 || normalizedLengthPosition > 1) {\n      return Vector2.Zero();\n    }\n    const lengthPosition = normalizedLengthPosition * this.length();\n    let previousOffset = 0;\n    for (let i = 0; i < this._points.length; i++) {\n      const j = (i + 1) % this._points.length;\n      const a = this._points[i];\n      const b = this._points[j];\n      const bToA = b.subtract(a);\n      const nextOffset = bToA.length() + previousOffset;\n      if (lengthPosition >= previousOffset && lengthPosition <= nextOffset) {\n        const dir = bToA.normalize();\n        const localOffset = lengthPosition - previousOffset;\n        return new Vector2(a.x + dir.x * localOffset, a.y + dir.y * localOffset);\n      }\n      previousOffset = nextOffset;\n    }\n    return Vector2.Zero();\n  }\n  /**\n   * Creates a new path starting from an x and y position\n   * @param x starting x value\n   * @param y starting y value\n   * @returns a new Path2 starting at the coordinates (x, y).\n   */\n  static StartingAt(x, y) {\n    return new Path2(x, y);\n  }\n}\n/**\n * Represents a 3D path made up of multiple 3D points\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/path3D\n */\nexport class Path3D {\n  /**\n   * new Path3D(path, normal, raw)\n   * Creates a Path3D. A Path3D is a logical math object, so not a mesh.\n   * please read the description in the tutorial : https://doc.babylonjs.com/features/featuresDeepDive/mesh/path3D\n   * @param path an array of Vector3, the curve axis of the Path3D\n   * @param firstNormal (options) Vector3, the first wanted normal to the curve. Ex (0, 1, 0) for a vertical normal.\n   * @param raw (optional, default false) : boolean, if true the returned Path3D isn't normalized. Useful to depict path acceleration or speed.\n   * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path.\n   */\n  constructor(\n  /**\n   * an array of Vector3, the curve axis of the Path3D\n   */\n  path, firstNormal = null, raw, alignTangentsWithPath = false) {\n    this.path = path;\n    this._curve = new Array();\n    this._distances = new Array();\n    this._tangents = new Array();\n    this._normals = new Array();\n    this._binormals = new Array();\n    // holds interpolated point data\n    this._pointAtData = {\n      id: 0,\n      point: Vector3.Zero(),\n      previousPointArrayIndex: 0,\n      position: 0,\n      subPosition: 0,\n      interpolateReady: false,\n      interpolationMatrix: Matrix.Identity()\n    };\n    for (let p = 0; p < path.length; p++) {\n      this._curve[p] = path[p].clone(); // hard copy\n    }\n\n    this._raw = raw || false;\n    this._alignTangentsWithPath = alignTangentsWithPath;\n    this._compute(firstNormal, alignTangentsWithPath);\n  }\n  /**\n   * Returns the Path3D array of successive Vector3 designing its curve.\n   * @returns the Path3D array of successive Vector3 designing its curve.\n   */\n  getCurve() {\n    return this._curve;\n  }\n  /**\n   * Returns the Path3D array of successive Vector3 designing its curve.\n   * @returns the Path3D array of successive Vector3 designing its curve.\n   */\n  getPoints() {\n    return this._curve;\n  }\n  /**\n   * @returns the computed length (float) of the path.\n   */\n  length() {\n    return this._distances[this._distances.length - 1];\n  }\n  /**\n   * Returns an array populated with tangent vectors on each Path3D curve point.\n   * @returns an array populated with tangent vectors on each Path3D curve point.\n   */\n  getTangents() {\n    return this._tangents;\n  }\n  /**\n   * Returns an array populated with normal vectors on each Path3D curve point.\n   * @returns an array populated with normal vectors on each Path3D curve point.\n   */\n  getNormals() {\n    return this._normals;\n  }\n  /**\n   * Returns an array populated with binormal vectors on each Path3D curve point.\n   * @returns an array populated with binormal vectors on each Path3D curve point.\n   */\n  getBinormals() {\n    return this._binormals;\n  }\n  /**\n   * Returns an array populated with distances (float) of the i-th point from the first curve point.\n   * @returns an array populated with distances (float) of the i-th point from the first curve point.\n   */\n  getDistances() {\n    return this._distances;\n  }\n  /**\n   * Returns an interpolated point along this path\n   * @param position the position of the point along this path, from 0.0 to 1.0\n   * @returns a new Vector3 as the point\n   */\n  getPointAt(position) {\n    return this._updatePointAtData(position).point;\n  }\n  /**\n   * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.\n   * @param position the position of the point along this path, from 0.0 to 1.0\n   * @param interpolated (optional, default false) : boolean, if true returns an interpolated tangent instead of the tangent of the previous path point.\n   * @returns a tangent vector corresponding to the interpolated Path3D curve point, if not interpolated, the tangent is taken from the precomputed tangents array.\n   */\n  getTangentAt(position, interpolated = false) {\n    this._updatePointAtData(position, interpolated);\n    return interpolated ? Vector3.TransformCoordinates(Vector3.Forward(), this._pointAtData.interpolationMatrix) : this._tangents[this._pointAtData.previousPointArrayIndex];\n  }\n  /**\n   * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.\n   * @param position the position of the point along this path, from 0.0 to 1.0\n   * @param interpolated (optional, default false) : boolean, if true returns an interpolated normal instead of the normal of the previous path point.\n   * @returns a normal vector corresponding to the interpolated Path3D curve point, if not interpolated, the normal is taken from the precomputed normals array.\n   */\n  getNormalAt(position, interpolated = false) {\n    this._updatePointAtData(position, interpolated);\n    return interpolated ? Vector3.TransformCoordinates(Vector3.Right(), this._pointAtData.interpolationMatrix) : this._normals[this._pointAtData.previousPointArrayIndex];\n  }\n  /**\n   * Returns the binormal vector of an interpolated Path3D curve point at the specified position along this path.\n   * @param position the position of the point along this path, from 0.0 to 1.0\n   * @param interpolated (optional, default false) : boolean, if true returns an interpolated binormal instead of the binormal of the previous path point.\n   * @returns a binormal vector corresponding to the interpolated Path3D curve point, if not interpolated, the binormal is taken from the precomputed binormals array.\n   */\n  getBinormalAt(position, interpolated = false) {\n    this._updatePointAtData(position, interpolated);\n    return interpolated ? Vector3.TransformCoordinates(Vector3.UpReadOnly, this._pointAtData.interpolationMatrix) : this._binormals[this._pointAtData.previousPointArrayIndex];\n  }\n  /**\n   * Returns the distance (float) of an interpolated Path3D curve point at the specified position along this path.\n   * @param position the position of the point along this path, from 0.0 to 1.0\n   * @returns the distance of the interpolated Path3D curve point at the specified position along this path.\n   */\n  getDistanceAt(position) {\n    return this.length() * position;\n  }\n  /**\n   * Returns the array index of the previous point of an interpolated point along this path\n   * @param position the position of the point to interpolate along this path, from 0.0 to 1.0\n   * @returns the array index\n   */\n  getPreviousPointIndexAt(position) {\n    this._updatePointAtData(position);\n    return this._pointAtData.previousPointArrayIndex;\n  }\n  /**\n   * Returns the position of an interpolated point relative to the two path points it lies between, from 0.0 (point A) to 1.0 (point B)\n   * @param position the position of the point to interpolate along this path, from 0.0 to 1.0\n   * @returns the sub position\n   */\n  getSubPositionAt(position) {\n    this._updatePointAtData(position);\n    return this._pointAtData.subPosition;\n  }\n  /**\n   * Returns the position of the closest virtual point on this path to an arbitrary Vector3, from 0.0 to 1.0\n   * @param target the vector of which to get the closest position to\n   * @returns the position of the closest virtual point on this path to the target vector\n   */\n  getClosestPositionTo(target) {\n    let smallestDistance = Number.MAX_VALUE;\n    let closestPosition = 0.0;\n    for (let i = 0; i < this._curve.length - 1; i++) {\n      const point = this._curve[i + 0];\n      const tangent = this._curve[i + 1].subtract(point).normalize();\n      const subLength = this._distances[i + 1] - this._distances[i + 0];\n      const subPosition = Math.min(Math.max(Vector3.Dot(tangent, target.subtract(point).normalize()), 0.0) * Vector3.Distance(point, target) / subLength, 1.0);\n      const distance = Vector3.Distance(point.add(tangent.scale(subPosition * subLength)), target);\n      if (distance < smallestDistance) {\n        smallestDistance = distance;\n        closestPosition = (this._distances[i + 0] + subLength * subPosition) / this.length();\n      }\n    }\n    return closestPosition;\n  }\n  /**\n   * Returns a sub path (slice) of this path\n   * @param start the position of the fist path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values\n   * @param end the position of the last path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values\n   * @returns a sub path (slice) of this path\n   */\n  slice(start = 0.0, end = 1.0) {\n    if (start < 0.0) {\n      start = 1 - start * -1.0 % 1.0;\n    }\n    if (end < 0.0) {\n      end = 1 - end * -1.0 % 1.0;\n    }\n    if (start > end) {\n      const _start = start;\n      start = end;\n      end = _start;\n    }\n    const curvePoints = this.getCurve();\n    const startPoint = this.getPointAt(start);\n    let startIndex = this.getPreviousPointIndexAt(start);\n    const endPoint = this.getPointAt(end);\n    const endIndex = this.getPreviousPointIndexAt(end) + 1;\n    const slicePoints = [];\n    if (start !== 0.0) {\n      startIndex++;\n      slicePoints.push(startPoint);\n    }\n    slicePoints.push(...curvePoints.slice(startIndex, endIndex));\n    if (end !== 1.0 || start === 1.0) {\n      slicePoints.push(endPoint);\n    }\n    return new Path3D(slicePoints, this.getNormalAt(start), this._raw, this._alignTangentsWithPath);\n  }\n  /**\n   * Forces the Path3D tangent, normal, binormal and distance recomputation.\n   * @param path path which all values are copied into the curves points\n   * @param firstNormal which should be projected onto the curve\n   * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path\n   * @returns the same object updated.\n   */\n  update(path, firstNormal = null, alignTangentsWithPath = false) {\n    for (let p = 0; p < path.length; p++) {\n      this._curve[p].x = path[p].x;\n      this._curve[p].y = path[p].y;\n      this._curve[p].z = path[p].z;\n    }\n    this._compute(firstNormal, alignTangentsWithPath);\n    return this;\n  }\n  // private function compute() : computes tangents, normals and binormals\n  _compute(firstNormal, alignTangentsWithPath = false) {\n    const l = this._curve.length;\n    if (l < 2) {\n      return;\n    }\n    // first and last tangents\n    this._tangents[0] = this._getFirstNonNullVector(0);\n    if (!this._raw) {\n      this._tangents[0].normalize();\n    }\n    this._tangents[l - 1] = this._curve[l - 1].subtract(this._curve[l - 2]);\n    if (!this._raw) {\n      this._tangents[l - 1].normalize();\n    }\n    // normals and binormals at first point : arbitrary vector with _normalVector()\n    const tg0 = this._tangents[0];\n    const pp0 = this._normalVector(tg0, firstNormal);\n    this._normals[0] = pp0;\n    if (!this._raw) {\n      this._normals[0].normalize();\n    }\n    this._binormals[0] = Vector3.Cross(tg0, this._normals[0]);\n    if (!this._raw) {\n      this._binormals[0].normalize();\n    }\n    this._distances[0] = 0.0;\n    // normals and binormals : next points\n    let prev; // previous vector (segment)\n    let cur; // current vector (segment)\n    let curTang; // current tangent\n    // previous normal\n    let prevNor; // previous normal\n    let prevBinor; // previous binormal\n    for (let i = 1; i < l; i++) {\n      // tangents\n      prev = this._getLastNonNullVector(i);\n      if (i < l - 1) {\n        cur = this._getFirstNonNullVector(i);\n        this._tangents[i] = alignTangentsWithPath ? cur : prev.add(cur);\n        this._tangents[i].normalize();\n      }\n      this._distances[i] = this._distances[i - 1] + this._curve[i].subtract(this._curve[i - 1]).length();\n      // normals and binormals\n      // http://www.cs.cmu.edu/afs/andrew/scs/cs/15-462/web/old/asst2camera.html\n      curTang = this._tangents[i];\n      prevBinor = this._binormals[i - 1];\n      this._normals[i] = Vector3.Cross(prevBinor, curTang);\n      if (!this._raw) {\n        if (this._normals[i].length() === 0) {\n          prevNor = this._normals[i - 1];\n          this._normals[i] = prevNor.clone();\n        } else {\n          this._normals[i].normalize();\n        }\n      }\n      this._binormals[i] = Vector3.Cross(curTang, this._normals[i]);\n      if (!this._raw) {\n        this._binormals[i].normalize();\n      }\n    }\n    this._pointAtData.id = NaN;\n  }\n  // private function getFirstNonNullVector(index)\n  // returns the first non null vector from index : curve[index + N].subtract(curve[index])\n  _getFirstNonNullVector(index) {\n    let i = 1;\n    let nNVector = this._curve[index + i].subtract(this._curve[index]);\n    while (nNVector.length() === 0 && index + i + 1 < this._curve.length) {\n      i++;\n      nNVector = this._curve[index + i].subtract(this._curve[index]);\n    }\n    return nNVector;\n  }\n  // private function getLastNonNullVector(index)\n  // returns the last non null vector from index : curve[index].subtract(curve[index - N])\n  _getLastNonNullVector(index) {\n    let i = 1;\n    let nLVector = this._curve[index].subtract(this._curve[index - i]);\n    while (nLVector.length() === 0 && index > i + 1) {\n      i++;\n      nLVector = this._curve[index].subtract(this._curve[index - i]);\n    }\n    return nLVector;\n  }\n  // private function normalVector(v0, vt, va) :\n  // returns an arbitrary point in the plane defined by the point v0 and the vector vt orthogonal to this plane\n  // if va is passed, it returns the va projection on the plane orthogonal to vt at the point v0\n  _normalVector(vt, va) {\n    let normal0;\n    let tgl = vt.length();\n    if (tgl === 0.0) {\n      tgl = 1.0;\n    }\n    if (va === undefined || va === null) {\n      let point;\n      if (!Scalar.WithinEpsilon(Math.abs(vt.y) / tgl, 1.0, Epsilon)) {\n        // search for a point in the plane\n        point = new Vector3(0.0, -1.0, 0.0);\n      } else if (!Scalar.WithinEpsilon(Math.abs(vt.x) / tgl, 1.0, Epsilon)) {\n        point = new Vector3(1.0, 0.0, 0.0);\n      } else if (!Scalar.WithinEpsilon(Math.abs(vt.z) / tgl, 1.0, Epsilon)) {\n        point = new Vector3(0.0, 0.0, 1.0);\n      } else {\n        point = Vector3.Zero();\n      }\n      normal0 = Vector3.Cross(vt, point);\n    } else {\n      normal0 = Vector3.Cross(vt, va);\n      Vector3.CrossToRef(normal0, vt, normal0);\n    }\n    normal0.normalize();\n    return normal0;\n  }\n  /**\n   * Updates the point at data for an interpolated point along this curve\n   * @param position the position of the point along this curve, from 0.0 to 1.0\n   * @param interpolateTNB\n   * @interpolateTNB whether to compute the interpolated tangent, normal and binormal\n   * @returns the (updated) point at data\n   */\n  _updatePointAtData(position, interpolateTNB = false) {\n    // set an id for caching the result\n    if (this._pointAtData.id === position) {\n      if (!this._pointAtData.interpolateReady) {\n        this._updateInterpolationMatrix();\n      }\n      return this._pointAtData;\n    } else {\n      this._pointAtData.id = position;\n    }\n    const curvePoints = this.getPoints();\n    // clamp position between 0.0 and 1.0\n    if (position <= 0.0) {\n      return this._setPointAtData(0.0, 0.0, curvePoints[0], 0, interpolateTNB);\n    } else if (position >= 1.0) {\n      return this._setPointAtData(1.0, 1.0, curvePoints[curvePoints.length - 1], curvePoints.length - 1, interpolateTNB);\n    }\n    let previousPoint = curvePoints[0];\n    let currentPoint;\n    let currentLength = 0.0;\n    const targetLength = position * this.length();\n    for (let i = 1; i < curvePoints.length; i++) {\n      currentPoint = curvePoints[i];\n      const distance = Vector3.Distance(previousPoint, currentPoint);\n      currentLength += distance;\n      if (currentLength === targetLength) {\n        return this._setPointAtData(position, 1.0, currentPoint, i, interpolateTNB);\n      } else if (currentLength > targetLength) {\n        const toLength = currentLength - targetLength;\n        const diff = toLength / distance;\n        const dir = previousPoint.subtract(currentPoint);\n        const point = currentPoint.add(dir.scaleInPlace(diff));\n        return this._setPointAtData(position, 1 - diff, point, i - 1, interpolateTNB);\n      }\n      previousPoint = currentPoint;\n    }\n    return this._pointAtData;\n  }\n  /**\n   * Updates the point at data from the specified parameters\n   * @param position where along the path the interpolated point is, from 0.0 to 1.0\n   * @param subPosition\n   * @param point the interpolated point\n   * @param parentIndex the index of an existing curve point that is on, or else positionally the first behind, the interpolated point\n   * @param interpolateTNB\n   */\n  _setPointAtData(position, subPosition, point, parentIndex, interpolateTNB) {\n    this._pointAtData.point = point;\n    this._pointAtData.position = position;\n    this._pointAtData.subPosition = subPosition;\n    this._pointAtData.previousPointArrayIndex = parentIndex;\n    this._pointAtData.interpolateReady = interpolateTNB;\n    if (interpolateTNB) {\n      this._updateInterpolationMatrix();\n    }\n    return this._pointAtData;\n  }\n  /**\n   * Updates the point at interpolation matrix for the tangents, normals and binormals\n   */\n  _updateInterpolationMatrix() {\n    this._pointAtData.interpolationMatrix = Matrix.Identity();\n    const parentIndex = this._pointAtData.previousPointArrayIndex;\n    if (parentIndex !== this._tangents.length - 1) {\n      const index = parentIndex + 1;\n      const tangentFrom = this._tangents[parentIndex].clone();\n      const normalFrom = this._normals[parentIndex].clone();\n      const binormalFrom = this._binormals[parentIndex].clone();\n      const tangentTo = this._tangents[index].clone();\n      const normalTo = this._normals[index].clone();\n      const binormalTo = this._binormals[index].clone();\n      const quatFrom = Quaternion.RotationQuaternionFromAxis(normalFrom, binormalFrom, tangentFrom);\n      const quatTo = Quaternion.RotationQuaternionFromAxis(normalTo, binormalTo, tangentTo);\n      const quatAt = Quaternion.Slerp(quatFrom, quatTo, this._pointAtData.subPosition);\n      quatAt.toRotationMatrix(this._pointAtData.interpolationMatrix);\n    }\n  }\n}\n/**\n * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\n * A Curve3 is designed from a series of successive Vector3.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves\n */\nexport class Curve3 {\n  /**\n   * Returns a Curve3 object along a Quadratic Bezier curve : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#quadratic-bezier-curve\n   * @param v0 (Vector3) the origin point of the Quadratic Bezier\n   * @param v1 (Vector3) the control point\n   * @param v2 (Vector3) the end point of the Quadratic Bezier\n   * @param nbPoints (integer) the wanted number of points in the curve\n   * @returns the created Curve3\n   */\n  static CreateQuadraticBezier(v0, v1, v2, nbPoints) {\n    nbPoints = nbPoints > 2 ? nbPoints : 3;\n    const bez = new Array();\n    const equation = (t, val0, val1, val2) => {\n      const res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;\n      return res;\n    };\n    for (let i = 0; i <= nbPoints; i++) {\n      bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x), equation(i / nbPoints, v0.y, v1.y, v2.y), equation(i / nbPoints, v0.z, v1.z, v2.z)));\n    }\n    return new Curve3(bez);\n  }\n  /**\n   * Returns a Curve3 object along a Cubic Bezier curve : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#cubic-bezier-curve\n   * @param v0 (Vector3) the origin point of the Cubic Bezier\n   * @param v1 (Vector3) the first control point\n   * @param v2 (Vector3) the second control point\n   * @param v3 (Vector3) the end point of the Cubic Bezier\n   * @param nbPoints (integer) the wanted number of points in the curve\n   * @returns the created Curve3\n   */\n  static CreateCubicBezier(v0, v1, v2, v3, nbPoints) {\n    nbPoints = nbPoints > 3 ? nbPoints : 4;\n    const bez = new Array();\n    const equation = (t, val0, val1, val2, val3) => {\n      const res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;\n      return res;\n    };\n    for (let i = 0; i <= nbPoints; i++) {\n      bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x, v3.x), equation(i / nbPoints, v0.y, v1.y, v2.y, v3.y), equation(i / nbPoints, v0.z, v1.z, v2.z, v3.z)));\n    }\n    return new Curve3(bez);\n  }\n  /**\n   * Returns a Curve3 object along a Hermite Spline curve : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#hermite-spline\n   * @param p1 (Vector3) the origin point of the Hermite Spline\n   * @param t1 (Vector3) the tangent vector at the origin point\n   * @param p2 (Vector3) the end point of the Hermite Spline\n   * @param t2 (Vector3) the tangent vector at the end point\n   * @param nSeg (integer) the number of curve segments or nSeg + 1 points in the array\n   * @returns the created Curve3\n   */\n  static CreateHermiteSpline(p1, t1, p2, t2, nSeg) {\n    const hermite = new Array();\n    const step = 1.0 / nSeg;\n    for (let i = 0; i <= nSeg; i++) {\n      hermite.push(Vector3.Hermite(p1, t1, p2, t2, i * step));\n    }\n    return new Curve3(hermite);\n  }\n  /**\n   * Returns a Curve3 object along a CatmullRom Spline curve :\n   * @param points (array of Vector3) the points the spline must pass through. At least, four points required\n   * @param nbPoints (integer) the wanted number of points between each curve control points\n   * @param closed (boolean) optional with default false, when true forms a closed loop from the points\n   * @returns the created Curve3\n   */\n  static CreateCatmullRomSpline(points, nbPoints, closed) {\n    const catmullRom = new Array();\n    const step = 1.0 / nbPoints;\n    let amount = 0.0;\n    if (closed) {\n      const pointsCount = points.length;\n      for (let i = 0; i < pointsCount; i++) {\n        amount = 0;\n        for (let c = 0; c < nbPoints; c++) {\n          catmullRom.push(Vector3.CatmullRom(points[i % pointsCount], points[(i + 1) % pointsCount], points[(i + 2) % pointsCount], points[(i + 3) % pointsCount], amount));\n          amount += step;\n        }\n      }\n      catmullRom.push(catmullRom[0]);\n    } else {\n      const totalPoints = new Array();\n      totalPoints.push(points[0].clone());\n      Array.prototype.push.apply(totalPoints, points);\n      totalPoints.push(points[points.length - 1].clone());\n      let i = 0;\n      for (; i < totalPoints.length - 3; i++) {\n        amount = 0;\n        for (let c = 0; c < nbPoints; c++) {\n          catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\n          amount += step;\n        }\n      }\n      i--;\n      catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\n    }\n    return new Curve3(catmullRom);\n  }\n  /**\n   * Returns a Curve3 object along an arc through three vector3 points:\n   * The three points should not be colinear. When they are the Curve3 is empty.\n   * @param first (Vector3) the first point the arc must pass through.\n   * @param second (Vector3) the second point the arc must pass through.\n   * @param third (Vector3) the third point the arc must pass through.\n   * @param steps (number) the larger the number of steps the more detailed the arc.\n   * @param closed (boolean) optional with default false, when true forms the chord from the first and third point\n   * @param fullCircle Circle (boolean) optional with default false, when true forms the complete circle through the three points\n   * @returns the created Curve3\n   */\n  static ArcThru3Points(first, second, third, steps = 32, closed = false, fullCircle = false) {\n    const arc = new Array();\n    const vec1 = second.subtract(first);\n    const vec2 = third.subtract(second);\n    const vec3 = first.subtract(third);\n    const zAxis = Vector3.Cross(vec1, vec2);\n    const len4 = zAxis.length();\n    if (len4 < Math.pow(10, -8)) {\n      return new Curve3(arc); // colinear points arc is empty\n    }\n\n    const len1_sq = vec1.lengthSquared();\n    const len2_sq = vec2.lengthSquared();\n    const len3_sq = vec3.lengthSquared();\n    const len4_sq = zAxis.lengthSquared();\n    const len1 = vec1.length();\n    const len2 = vec2.length();\n    const len3 = vec3.length();\n    const radius = 0.5 * len1 * len2 * len3 / len4;\n    const dot1 = Vector3.Dot(vec1, vec3);\n    const dot2 = Vector3.Dot(vec1, vec2);\n    const dot3 = Vector3.Dot(vec2, vec3);\n    const a = -0.5 * len2_sq * dot1 / len4_sq;\n    const b = -0.5 * len3_sq * dot2 / len4_sq;\n    const c = -0.5 * len1_sq * dot3 / len4_sq;\n    const center = first.scale(a).add(second.scale(b)).add(third.scale(c));\n    const radiusVec = first.subtract(center);\n    const xAxis = radiusVec.normalize();\n    const yAxis = Vector3.Cross(zAxis, xAxis).normalize();\n    if (fullCircle) {\n      const dStep = 2 * Math.PI / steps;\n      for (let theta = 0; theta <= 2 * Math.PI; theta += dStep) {\n        arc.push(center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta)))));\n      }\n      arc.push(first);\n    } else {\n      const dStep = 1 / steps;\n      let theta = 0;\n      let point = Vector3.Zero();\n      do {\n        point = center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta))));\n        arc.push(point);\n        theta += dStep;\n      } while (!point.equalsWithEpsilon(third, radius * dStep * 1.1));\n      arc.push(third);\n      if (closed) {\n        arc.push(first);\n      }\n    }\n    return new Curve3(arc);\n  }\n  /**\n   * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\n   * A Curve3 is designed from a series of successive Vector3.\n   * Tuto : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#curve3-object\n   * @param points points which make up the curve\n   */\n  constructor(points) {\n    this._length = 0.0;\n    this._points = points;\n    this._length = this._computeLength(points);\n  }\n  /**\n   * @returns the Curve3 stored array of successive Vector3\n   */\n  getPoints() {\n    return this._points;\n  }\n  /**\n   * @returns the computed length (float) of the curve.\n   */\n  length() {\n    return this._length;\n  }\n  /**\n   * Returns a new instance of Curve3 object : var curve = curveA.continue(curveB);\n   * This new Curve3 is built by translating and sticking the curveB at the end of the curveA.\n   * curveA and curveB keep unchanged.\n   * @param curve the curve to continue from this curve\n   * @returns the newly constructed curve\n   */\n  continue(curve) {\n    const lastPoint = this._points[this._points.length - 1];\n    const continuedPoints = this._points.slice();\n    const curvePoints = curve.getPoints();\n    for (let i = 1; i < curvePoints.length; i++) {\n      continuedPoints.push(curvePoints[i].subtract(curvePoints[0]).add(lastPoint));\n    }\n    const continuedCurve = new Curve3(continuedPoints);\n    return continuedCurve;\n  }\n  _computeLength(path) {\n    let l = 0;\n    for (let i = 1; i < path.length; i++) {\n      l += path[i].subtract(path[i - 1]).length();\n    }\n    return l;\n  }\n}","map":{"version":3,"names":["Scalar","Vector2","Vector3","Quaternion","Matrix","Epsilon","Orientation","BezierCurve","Interpolate","t","x1","y1","x2","y2","f0","f1","f2","refinedT","i","refinedT2","refinedT3","x","slope","Math","min","max","pow","Angle","constructor","radians","_radians","PI","degrees","BetweenTwoPoints","a","b","delta","subtract","theta","atan2","y","FromRadians","FromDegrees","Arc2","startPoint","midPoint","endPoint","temp","startToMid","midToEnd","det","centerPoint","radius","length","startAngle","a1","a2","a3","orientation","CW","CCW","angle","Path2","_points","Array","_length","closed","push","addLineTo","newPoint","previousPoint","addArcTo","midX","midY","endX","endY","numberOfSegments","arc","increment","currentAngle","cos","sin","addQuadraticCurveTo","controlX","controlY","equation","val0","val1","val2","res","step","addBezierCurveTo","originTangentX","originTangentY","destinationTangentX","destinationTangentY","val3","isPointInside","point","isInside","count","p","q","edgeLow","edgeHigh","edgeDx","edgeDy","abs","Number","EPSILON","perpEdge","close","result","lastPoint","firstPoint","area","n","value","getPoints","getPointAtLengthPosition","normalizedLengthPosition","Zero","lengthPosition","previousOffset","j","bToA","nextOffset","dir","normalize","localOffset","StartingAt","Path3D","path","firstNormal","raw","alignTangentsWithPath","_curve","_distances","_tangents","_normals","_binormals","_pointAtData","id","previousPointArrayIndex","position","subPosition","interpolateReady","interpolationMatrix","Identity","clone","_raw","_alignTangentsWithPath","_compute","getCurve","getTangents","getNormals","getBinormals","getDistances","getPointAt","_updatePointAtData","getTangentAt","interpolated","TransformCoordinates","Forward","getNormalAt","Right","getBinormalAt","UpReadOnly","getDistanceAt","getPreviousPointIndexAt","getSubPositionAt","getClosestPositionTo","target","smallestDistance","MAX_VALUE","closestPosition","tangent","subLength","Dot","Distance","distance","add","scale","slice","start","end","_start","curvePoints","startIndex","endIndex","slicePoints","update","z","l","_getFirstNonNullVector","tg0","pp0","_normalVector","Cross","prev","cur","curTang","prevNor","prevBinor","_getLastNonNullVector","NaN","index","nNVector","nLVector","vt","va","normal0","tgl","undefined","WithinEpsilon","CrossToRef","interpolateTNB","_updateInterpolationMatrix","_setPointAtData","currentPoint","currentLength","targetLength","toLength","diff","scaleInPlace","parentIndex","tangentFrom","normalFrom","binormalFrom","tangentTo","normalTo","binormalTo","quatFrom","RotationQuaternionFromAxis","quatTo","quatAt","Slerp","toRotationMatrix","Curve3","CreateQuadraticBezier","v0","v1","v2","nbPoints","bez","CreateCubicBezier","v3","CreateHermiteSpline","p1","t1","p2","t2","nSeg","hermite","Hermite","CreateCatmullRomSpline","points","catmullRom","amount","pointsCount","c","CatmullRom","totalPoints","prototype","apply","ArcThru3Points","first","second","third","steps","fullCircle","vec1","vec2","vec3","zAxis","len4","len1_sq","lengthSquared","len2_sq","len3_sq","len4_sq","len1","len2","len3","dot1","dot2","dot3","center","radiusVec","xAxis","yAxis","dStep","equalsWithEpsilon","_computeLength","continue","curve","continuedPoints","continuedCurve"],"sources":["../../../../dev/core/src/Maths/math.path.ts"],"sourcesContent":["import type { DeepImmutable, Nullable } from \"../types\";\r\nimport { Scalar } from \"./math.scalar\";\r\nimport { Vector2, Vector3, Quaternion, Matrix } from \"./math.vector\";\r\nimport { Epsilon } from \"./math.constants\";\r\n\r\n/**\r\n * Defines potential orientation for back face culling\r\n */\r\nexport enum Orientation {\r\n    /**\r\n     * Clockwise\r\n     */\r\n    CW = 0,\r\n    /** Counter clockwise */\r\n    CCW = 1,\r\n}\r\n\r\n/** Class used to represent a Bezier curve */\r\nexport class BezierCurve {\r\n    /**\r\n     * Returns the cubic Bezier interpolated value (float) at \"t\" (float) from the given x1, y1, x2, y2 floats\r\n     * @param t defines the time\r\n     * @param x1 defines the left coordinate on X axis\r\n     * @param y1 defines the left coordinate on Y axis\r\n     * @param x2 defines the right coordinate on X axis\r\n     * @param y2 defines the right coordinate on Y axis\r\n     * @returns the interpolated value\r\n     */\r\n    public static Interpolate(t: number, x1: number, y1: number, x2: number, y2: number): number {\r\n        // Extract X (which is equal to time here)\r\n        const f0 = 1 - 3 * x2 + 3 * x1;\r\n        const f1 = 3 * x2 - 6 * x1;\r\n        const f2 = 3 * x1;\r\n\r\n        let refinedT = t;\r\n        for (let i = 0; i < 5; i++) {\r\n            const refinedT2 = refinedT * refinedT;\r\n            const refinedT3 = refinedT2 * refinedT;\r\n\r\n            const x = f0 * refinedT3 + f1 * refinedT2 + f2 * refinedT;\r\n            const slope = 1.0 / (3.0 * f0 * refinedT2 + 2.0 * f1 * refinedT + f2);\r\n            refinedT -= (x - t) * slope;\r\n            refinedT = Math.min(1, Math.max(0, refinedT));\r\n        }\r\n\r\n        // Resolve cubic bezier for the given x\r\n        return 3 * Math.pow(1 - refinedT, 2) * refinedT * y1 + 3 * (1 - refinedT) * Math.pow(refinedT, 2) * y2 + Math.pow(refinedT, 3);\r\n    }\r\n}\r\n\r\n/**\r\n * Defines angle representation\r\n */\r\nexport class Angle {\r\n    private _radians: number;\r\n\r\n    /**\r\n     * Creates an Angle object of \"radians\" radians (float).\r\n     * @param radians the angle in radians\r\n     */\r\n    constructor(radians: number) {\r\n        this._radians = radians;\r\n        if (this._radians < 0.0) {\r\n            this._radians += 2.0 * Math.PI;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get value in degrees\r\n     * @returns the Angle value in degrees (float)\r\n     */\r\n    public degrees() {\r\n        return (this._radians * 180.0) / Math.PI;\r\n    }\r\n\r\n    /**\r\n     * Get value in radians\r\n     * @returns the Angle value in radians (float)\r\n     */\r\n    public radians() {\r\n        return this._radians;\r\n    }\r\n\r\n    /**\r\n     * Gets a new Angle object valued with the gradient angle, in radians, of the line joining two points\r\n     * @param a defines first point as the origin\r\n     * @param b defines point\r\n     * @returns a new Angle\r\n     */\r\n    public static BetweenTwoPoints(a: DeepImmutable<Vector2>, b: DeepImmutable<Vector2>): Angle {\r\n        const delta = b.subtract(a);\r\n        const theta = Math.atan2(delta.y, delta.x);\r\n        return new Angle(theta);\r\n    }\r\n\r\n    /**\r\n     * Gets a new Angle object from the given float in radians\r\n     * @param radians defines the angle value in radians\r\n     * @returns a new Angle\r\n     */\r\n    public static FromRadians(radians: number): Angle {\r\n        return new Angle(radians);\r\n    }\r\n    /**\r\n     * Gets a new Angle object from the given float in degrees\r\n     * @param degrees defines the angle value in degrees\r\n     * @returns a new Angle\r\n     */\r\n    public static FromDegrees(degrees: number): Angle {\r\n        return new Angle((degrees * Math.PI) / 180.0);\r\n    }\r\n}\r\n\r\n/**\r\n * This represents an arc in a 2d space.\r\n */\r\nexport class Arc2 {\r\n    /**\r\n     * Defines the center point of the arc.\r\n     */\r\n    public centerPoint: Vector2;\r\n    /**\r\n     * Defines the radius of the arc.\r\n     */\r\n    public radius: number;\r\n    /**\r\n     * Defines the angle of the arc (from mid point to end point).\r\n     */\r\n    public angle: Angle;\r\n    /**\r\n     * Defines the start angle of the arc (from start point to middle point).\r\n     */\r\n    public startAngle: Angle;\r\n    /**\r\n     * Defines the orientation of the arc (clock wise/counter clock wise).\r\n     */\r\n    public orientation: Orientation;\r\n\r\n    /**\r\n     * Creates an Arc object from the three given points : start, middle and end.\r\n     * @param startPoint Defines the start point of the arc\r\n     * @param midPoint Defines the middle point of the arc\r\n     * @param endPoint Defines the end point of the arc\r\n     */\r\n    constructor(\r\n        /** Defines the start point of the arc */\r\n        public startPoint: Vector2,\r\n        /** Defines the mid point of the arc */\r\n        public midPoint: Vector2,\r\n        /** Defines the end point of the arc */\r\n        public endPoint: Vector2\r\n    ) {\r\n        const temp = Math.pow(midPoint.x, 2) + Math.pow(midPoint.y, 2);\r\n        const startToMid = (Math.pow(startPoint.x, 2) + Math.pow(startPoint.y, 2) - temp) / 2;\r\n        const midToEnd = (temp - Math.pow(endPoint.x, 2) - Math.pow(endPoint.y, 2)) / 2;\r\n        const det = (startPoint.x - midPoint.x) * (midPoint.y - endPoint.y) - (midPoint.x - endPoint.x) * (startPoint.y - midPoint.y);\r\n\r\n        this.centerPoint = new Vector2(\r\n            (startToMid * (midPoint.y - endPoint.y) - midToEnd * (startPoint.y - midPoint.y)) / det,\r\n            ((startPoint.x - midPoint.x) * midToEnd - (midPoint.x - endPoint.x) * startToMid) / det\r\n        );\r\n\r\n        this.radius = this.centerPoint.subtract(this.startPoint).length();\r\n\r\n        this.startAngle = Angle.BetweenTwoPoints(this.centerPoint, this.startPoint);\r\n\r\n        const a1 = this.startAngle.degrees();\r\n        let a2 = Angle.BetweenTwoPoints(this.centerPoint, this.midPoint).degrees();\r\n        let a3 = Angle.BetweenTwoPoints(this.centerPoint, this.endPoint).degrees();\r\n\r\n        // angles correction\r\n        if (a2 - a1 > +180.0) {\r\n            a2 -= 360.0;\r\n        }\r\n        if (a2 - a1 < -180.0) {\r\n            a2 += 360.0;\r\n        }\r\n        if (a3 - a2 > +180.0) {\r\n            a3 -= 360.0;\r\n        }\r\n        if (a3 - a2 < -180.0) {\r\n            a3 += 360.0;\r\n        }\r\n\r\n        this.orientation = a2 - a1 < 0 ? Orientation.CW : Orientation.CCW;\r\n        this.angle = Angle.FromDegrees(this.orientation === Orientation.CW ? a1 - a3 : a3 - a1);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a 2D path made up of multiple 2D points\r\n */\r\nexport class Path2 {\r\n    private _points = new Array<Vector2>();\r\n    private _length = 0.0;\r\n\r\n    /**\r\n     * If the path start and end point are the same\r\n     */\r\n    public closed = false;\r\n\r\n    /**\r\n     * Creates a Path2 object from the starting 2D coordinates x and y.\r\n     * @param x the starting points x value\r\n     * @param y the starting points y value\r\n     */\r\n    constructor(x: number, y: number) {\r\n        this._points.push(new Vector2(x, y));\r\n    }\r\n\r\n    /**\r\n     * Adds a new segment until the given coordinates (x, y) to the current Path2.\r\n     * @param x the added points x value\r\n     * @param y the added points y value\r\n     * @returns the updated Path2.\r\n     */\r\n    public addLineTo(x: number, y: number): Path2 {\r\n        if (this.closed) {\r\n            return this;\r\n        }\r\n        const newPoint = new Vector2(x, y);\r\n        const previousPoint = this._points[this._points.length - 1];\r\n        this._points.push(newPoint);\r\n        this._length += newPoint.subtract(previousPoint).length();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds _numberOfSegments_ segments according to the arc definition (middle point coordinates, end point coordinates, the arc start point being the current Path2 last point) to the current Path2.\r\n     * @param midX middle point x value\r\n     * @param midY middle point y value\r\n     * @param endX end point x value\r\n     * @param endY end point y value\r\n     * @param numberOfSegments (default: 36)\r\n     * @returns the updated Path2.\r\n     */\r\n    public addArcTo(midX: number, midY: number, endX: number, endY: number, numberOfSegments = 36): Path2 {\r\n        if (this.closed) {\r\n            return this;\r\n        }\r\n        const startPoint = this._points[this._points.length - 1];\r\n        const midPoint = new Vector2(midX, midY);\r\n        const endPoint = new Vector2(endX, endY);\r\n\r\n        const arc = new Arc2(startPoint, midPoint, endPoint);\r\n\r\n        let increment = arc.angle.radians() / numberOfSegments;\r\n        if (arc.orientation === Orientation.CW) {\r\n            increment *= -1;\r\n        }\r\n        let currentAngle = arc.startAngle.radians() + increment;\r\n\r\n        for (let i = 0; i < numberOfSegments; i++) {\r\n            const x = Math.cos(currentAngle) * arc.radius + arc.centerPoint.x;\r\n            const y = Math.sin(currentAngle) * arc.radius + arc.centerPoint.y;\r\n            this.addLineTo(x, y);\r\n            currentAngle += increment;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds _numberOfSegments_ segments according to the quadratic curve definition to the current Path2.\r\n     * @param controlX control point x value\r\n     * @param controlY control point y value\r\n     * @param endX end point x value\r\n     * @param endY end point y value\r\n     * @param numberOfSegments (default: 36)\r\n     * @returns the updated Path2.\r\n     */\r\n    public addQuadraticCurveTo(controlX: number, controlY: number, endX: number, endY: number, numberOfSegments = 36): Path2 {\r\n        if (this.closed) {\r\n            return this;\r\n        }\r\n\r\n        const equation = (t: number, val0: number, val1: number, val2: number) => {\r\n            const res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;\r\n            return res;\r\n        };\r\n        const startPoint = this._points[this._points.length - 1];\r\n        for (let i = 0; i <= numberOfSegments; i++) {\r\n            const step = i / numberOfSegments;\r\n            const x = equation(step, startPoint.x, controlX, endX);\r\n            const y = equation(step, startPoint.y, controlY, endY);\r\n            this.addLineTo(x, y);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds _numberOfSegments_ segments according to the bezier curve definition to the current Path2.\r\n     * @param originTangentX tangent vector at the origin point x value\r\n     * @param originTangentY tangent vector at the origin point y value\r\n     * @param destinationTangentX tangent vector at the destination point x value\r\n     * @param destinationTangentY tangent vector at the destination point y value\r\n     * @param endX end point x value\r\n     * @param endY end point y value\r\n     * @param numberOfSegments (default: 36)\r\n     * @returns the updated Path2.\r\n     */\r\n    public addBezierCurveTo(\r\n        originTangentX: number,\r\n        originTangentY: number,\r\n        destinationTangentX: number,\r\n        destinationTangentY: number,\r\n        endX: number,\r\n        endY: number,\r\n        numberOfSegments = 36\r\n    ): Path2 {\r\n        if (this.closed) {\r\n            return this;\r\n        }\r\n\r\n        const equation = (t: number, val0: number, val1: number, val2: number, val3: number) => {\r\n            const res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;\r\n            return res;\r\n        };\r\n        const startPoint = this._points[this._points.length - 1];\r\n        for (let i = 0; i <= numberOfSegments; i++) {\r\n            const step = i / numberOfSegments;\r\n            const x = equation(step, startPoint.x, originTangentX, destinationTangentX, endX);\r\n            const y = equation(step, startPoint.y, originTangentY, destinationTangentY, endY);\r\n            this.addLineTo(x, y);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Defines if a given point is inside the polygon defines by the path\r\n     * @param point defines the point to test\r\n     * @returns true if the point is inside\r\n     */\r\n    public isPointInside(point: Vector2) {\r\n        let isInside = false;\r\n        const count = this._points.length;\r\n        for (let p = count - 1, q = 0; q < count; p = q++) {\r\n            let edgeLow = this._points[p];\r\n            let edgeHigh = this._points[q];\r\n\r\n            let edgeDx = edgeHigh.x - edgeLow.x;\r\n            let edgeDy = edgeHigh.y - edgeLow.y;\r\n\r\n            if (Math.abs(edgeDy) > Number.EPSILON) {\r\n                // Not parallel\r\n                if (edgeDy < 0) {\r\n                    edgeLow = this._points[q];\r\n                    edgeDx = -edgeDx;\r\n                    edgeHigh = this._points[p];\r\n                    edgeDy = -edgeDy;\r\n                }\r\n\r\n                if (point.y < edgeLow.y || point.y > edgeHigh.y) {\r\n                    continue;\r\n                }\r\n\r\n                if (point.y === edgeLow.y && point.x === edgeLow.x) {\r\n                    return true;\r\n                } else {\r\n                    const perpEdge = edgeDy * (point.x - edgeLow.x) - edgeDx * (point.y - edgeLow.y);\r\n                    if (perpEdge === 0) {\r\n                        return true;\r\n                    }\r\n                    if (perpEdge < 0) {\r\n                        continue;\r\n                    }\r\n                    isInside = !isInside;\r\n                }\r\n            } else {\r\n                // parallel or collinear\r\n                if (point.y !== edgeLow.y) {\r\n                    continue;\r\n                }\r\n\r\n                if ((edgeHigh.x <= point.x && point.x <= edgeLow.x) || (edgeLow.x <= point.x && point.x <= edgeHigh.x)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return isInside;\r\n    }\r\n\r\n    /**\r\n     * Closes the Path2.\r\n     * @returns the Path2.\r\n     */\r\n    public close(): Path2 {\r\n        this.closed = true;\r\n        return this;\r\n    }\r\n    /**\r\n     * Gets the sum of the distance between each sequential point in the path\r\n     * @returns the Path2 total length (float).\r\n     */\r\n    public length(): number {\r\n        let result = this._length;\r\n\r\n        if (this.closed) {\r\n            const lastPoint = this._points[this._points.length - 1];\r\n            const firstPoint = this._points[0];\r\n            result += firstPoint.subtract(lastPoint).length();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Gets the area of the polygon defined by the path\r\n     * @returns area value\r\n     */\r\n    public area(): number {\r\n        const n = this._points.length;\r\n        let value = 0.0;\r\n\r\n        for (let p = n - 1, q = 0; q < n; p = q++) {\r\n            value += this._points[p].x * this._points[q].y - this._points[q].x * this._points[p].y;\r\n        }\r\n\r\n        return value * 0.5;\r\n    }\r\n\r\n    /**\r\n     * Gets the points which construct the path\r\n     * @returns the Path2 internal array of points.\r\n     */\r\n    public getPoints(): Vector2[] {\r\n        return this._points;\r\n    }\r\n\r\n    /**\r\n     * Retrieves the point at the distance aways from the starting point\r\n     * @param normalizedLengthPosition the length along the path to retrieve the point from\r\n     * @returns a new Vector2 located at a percentage of the Path2 total length on this path.\r\n     */\r\n    public getPointAtLengthPosition(normalizedLengthPosition: number): Vector2 {\r\n        if (normalizedLengthPosition < 0 || normalizedLengthPosition > 1) {\r\n            return Vector2.Zero();\r\n        }\r\n\r\n        const lengthPosition = normalizedLengthPosition * this.length();\r\n\r\n        let previousOffset = 0;\r\n        for (let i = 0; i < this._points.length; i++) {\r\n            const j = (i + 1) % this._points.length;\r\n\r\n            const a = this._points[i];\r\n            const b = this._points[j];\r\n            const bToA = b.subtract(a);\r\n\r\n            const nextOffset = bToA.length() + previousOffset;\r\n            if (lengthPosition >= previousOffset && lengthPosition <= nextOffset) {\r\n                const dir = bToA.normalize();\r\n                const localOffset = lengthPosition - previousOffset;\r\n\r\n                return new Vector2(a.x + dir.x * localOffset, a.y + dir.y * localOffset);\r\n            }\r\n            previousOffset = nextOffset;\r\n        }\r\n\r\n        return Vector2.Zero();\r\n    }\r\n\r\n    /**\r\n     * Creates a new path starting from an x and y position\r\n     * @param x starting x value\r\n     * @param y starting y value\r\n     * @returns a new Path2 starting at the coordinates (x, y).\r\n     */\r\n    public static StartingAt(x: number, y: number): Path2 {\r\n        return new Path2(x, y);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a 3D path made up of multiple 3D points\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/path3D\r\n */\r\nexport class Path3D {\r\n    private _curve = new Array<Vector3>();\r\n    private _distances = new Array<number>();\r\n    private _tangents = new Array<Vector3>();\r\n    private _normals = new Array<Vector3>();\r\n    private _binormals = new Array<Vector3>();\r\n    private _raw: boolean;\r\n    private _alignTangentsWithPath: boolean;\r\n\r\n    // holds interpolated point data\r\n    private readonly _pointAtData = {\r\n        id: 0,\r\n        point: Vector3.Zero(),\r\n        previousPointArrayIndex: 0,\r\n\r\n        position: 0,\r\n        subPosition: 0,\r\n\r\n        interpolateReady: false,\r\n        interpolationMatrix: Matrix.Identity(),\r\n    };\r\n\r\n    /**\r\n     * new Path3D(path, normal, raw)\r\n     * Creates a Path3D. A Path3D is a logical math object, so not a mesh.\r\n     * please read the description in the tutorial : https://doc.babylonjs.com/features/featuresDeepDive/mesh/path3D\r\n     * @param path an array of Vector3, the curve axis of the Path3D\r\n     * @param firstNormal (options) Vector3, the first wanted normal to the curve. Ex (0, 1, 0) for a vertical normal.\r\n     * @param raw (optional, default false) : boolean, if true the returned Path3D isn't normalized. Useful to depict path acceleration or speed.\r\n     * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path.\r\n     */\r\n    constructor(\r\n        /**\r\n         * an array of Vector3, the curve axis of the Path3D\r\n         */\r\n        public path: Vector3[],\r\n        firstNormal: Nullable<Vector3> = null,\r\n        raw?: boolean,\r\n        alignTangentsWithPath = false\r\n    ) {\r\n        for (let p = 0; p < path.length; p++) {\r\n            this._curve[p] = path[p].clone(); // hard copy\r\n        }\r\n        this._raw = raw || false;\r\n        this._alignTangentsWithPath = alignTangentsWithPath;\r\n        this._compute(firstNormal, alignTangentsWithPath);\r\n    }\r\n\r\n    /**\r\n     * Returns the Path3D array of successive Vector3 designing its curve.\r\n     * @returns the Path3D array of successive Vector3 designing its curve.\r\n     */\r\n    public getCurve(): Vector3[] {\r\n        return this._curve;\r\n    }\r\n\r\n    /**\r\n     * Returns the Path3D array of successive Vector3 designing its curve.\r\n     * @returns the Path3D array of successive Vector3 designing its curve.\r\n     */\r\n    public getPoints(): Vector3[] {\r\n        return this._curve;\r\n    }\r\n\r\n    /**\r\n     * @returns the computed length (float) of the path.\r\n     */\r\n    public length() {\r\n        return this._distances[this._distances.length - 1];\r\n    }\r\n\r\n    /**\r\n     * Returns an array populated with tangent vectors on each Path3D curve point.\r\n     * @returns an array populated with tangent vectors on each Path3D curve point.\r\n     */\r\n    public getTangents(): Vector3[] {\r\n        return this._tangents;\r\n    }\r\n\r\n    /**\r\n     * Returns an array populated with normal vectors on each Path3D curve point.\r\n     * @returns an array populated with normal vectors on each Path3D curve point.\r\n     */\r\n    public getNormals(): Vector3[] {\r\n        return this._normals;\r\n    }\r\n\r\n    /**\r\n     * Returns an array populated with binormal vectors on each Path3D curve point.\r\n     * @returns an array populated with binormal vectors on each Path3D curve point.\r\n     */\r\n    public getBinormals(): Vector3[] {\r\n        return this._binormals;\r\n    }\r\n\r\n    /**\r\n     * Returns an array populated with distances (float) of the i-th point from the first curve point.\r\n     * @returns an array populated with distances (float) of the i-th point from the first curve point.\r\n     */\r\n    public getDistances(): number[] {\r\n        return this._distances;\r\n    }\r\n\r\n    /**\r\n     * Returns an interpolated point along this path\r\n     * @param position the position of the point along this path, from 0.0 to 1.0\r\n     * @returns a new Vector3 as the point\r\n     */\r\n    public getPointAt(position: number): Vector3 {\r\n        return this._updatePointAtData(position).point;\r\n    }\r\n\r\n    /**\r\n     * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.\r\n     * @param position the position of the point along this path, from 0.0 to 1.0\r\n     * @param interpolated (optional, default false) : boolean, if true returns an interpolated tangent instead of the tangent of the previous path point.\r\n     * @returns a tangent vector corresponding to the interpolated Path3D curve point, if not interpolated, the tangent is taken from the precomputed tangents array.\r\n     */\r\n    public getTangentAt(position: number, interpolated = false): Vector3 {\r\n        this._updatePointAtData(position, interpolated);\r\n        return interpolated ? Vector3.TransformCoordinates(Vector3.Forward(), this._pointAtData.interpolationMatrix) : this._tangents[this._pointAtData.previousPointArrayIndex];\r\n    }\r\n\r\n    /**\r\n     * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.\r\n     * @param position the position of the point along this path, from 0.0 to 1.0\r\n     * @param interpolated (optional, default false) : boolean, if true returns an interpolated normal instead of the normal of the previous path point.\r\n     * @returns a normal vector corresponding to the interpolated Path3D curve point, if not interpolated, the normal is taken from the precomputed normals array.\r\n     */\r\n    public getNormalAt(position: number, interpolated = false): Vector3 {\r\n        this._updatePointAtData(position, interpolated);\r\n        return interpolated ? Vector3.TransformCoordinates(Vector3.Right(), this._pointAtData.interpolationMatrix) : this._normals[this._pointAtData.previousPointArrayIndex];\r\n    }\r\n\r\n    /**\r\n     * Returns the binormal vector of an interpolated Path3D curve point at the specified position along this path.\r\n     * @param position the position of the point along this path, from 0.0 to 1.0\r\n     * @param interpolated (optional, default false) : boolean, if true returns an interpolated binormal instead of the binormal of the previous path point.\r\n     * @returns a binormal vector corresponding to the interpolated Path3D curve point, if not interpolated, the binormal is taken from the precomputed binormals array.\r\n     */\r\n    public getBinormalAt(position: number, interpolated = false): Vector3 {\r\n        this._updatePointAtData(position, interpolated);\r\n        return interpolated ? Vector3.TransformCoordinates(Vector3.UpReadOnly, this._pointAtData.interpolationMatrix) : this._binormals[this._pointAtData.previousPointArrayIndex];\r\n    }\r\n\r\n    /**\r\n     * Returns the distance (float) of an interpolated Path3D curve point at the specified position along this path.\r\n     * @param position the position of the point along this path, from 0.0 to 1.0\r\n     * @returns the distance of the interpolated Path3D curve point at the specified position along this path.\r\n     */\r\n    public getDistanceAt(position: number): number {\r\n        return this.length() * position;\r\n    }\r\n\r\n    /**\r\n     * Returns the array index of the previous point of an interpolated point along this path\r\n     * @param position the position of the point to interpolate along this path, from 0.0 to 1.0\r\n     * @returns the array index\r\n     */\r\n    public getPreviousPointIndexAt(position: number) {\r\n        this._updatePointAtData(position);\r\n        return this._pointAtData.previousPointArrayIndex;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of an interpolated point relative to the two path points it lies between, from 0.0 (point A) to 1.0 (point B)\r\n     * @param position the position of the point to interpolate along this path, from 0.0 to 1.0\r\n     * @returns the sub position\r\n     */\r\n    public getSubPositionAt(position: number) {\r\n        this._updatePointAtData(position);\r\n        return this._pointAtData.subPosition;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the closest virtual point on this path to an arbitrary Vector3, from 0.0 to 1.0\r\n     * @param target the vector of which to get the closest position to\r\n     * @returns the position of the closest virtual point on this path to the target vector\r\n     */\r\n    public getClosestPositionTo(target: Vector3) {\r\n        let smallestDistance = Number.MAX_VALUE;\r\n        let closestPosition = 0.0;\r\n        for (let i = 0; i < this._curve.length - 1; i++) {\r\n            const point = this._curve[i + 0];\r\n            const tangent = this._curve[i + 1].subtract(point).normalize();\r\n            const subLength = this._distances[i + 1] - this._distances[i + 0];\r\n            const subPosition = Math.min((Math.max(Vector3.Dot(tangent, target.subtract(point).normalize()), 0.0) * Vector3.Distance(point, target)) / subLength, 1.0);\r\n            const distance = Vector3.Distance(point.add(tangent.scale(subPosition * subLength)), target);\r\n\r\n            if (distance < smallestDistance) {\r\n                smallestDistance = distance;\r\n                closestPosition = (this._distances[i + 0] + subLength * subPosition) / this.length();\r\n            }\r\n        }\r\n        return closestPosition;\r\n    }\r\n\r\n    /**\r\n     * Returns a sub path (slice) of this path\r\n     * @param start the position of the fist path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values\r\n     * @param end the position of the last path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values\r\n     * @returns a sub path (slice) of this path\r\n     */\r\n    public slice(start: number = 0.0, end: number = 1.0) {\r\n        if (start < 0.0) {\r\n            start = 1 - ((start * -1.0) % 1.0);\r\n        }\r\n        if (end < 0.0) {\r\n            end = 1 - ((end * -1.0) % 1.0);\r\n        }\r\n        if (start > end) {\r\n            const _start = start;\r\n            start = end;\r\n            end = _start;\r\n        }\r\n        const curvePoints = this.getCurve();\r\n\r\n        const startPoint = this.getPointAt(start);\r\n        let startIndex = this.getPreviousPointIndexAt(start);\r\n\r\n        const endPoint = this.getPointAt(end);\r\n        const endIndex = this.getPreviousPointIndexAt(end) + 1;\r\n\r\n        const slicePoints: Vector3[] = [];\r\n        if (start !== 0.0) {\r\n            startIndex++;\r\n            slicePoints.push(startPoint);\r\n        }\r\n\r\n        slicePoints.push(...curvePoints.slice(startIndex, endIndex));\r\n        if (end !== 1.0 || start === 1.0) {\r\n            slicePoints.push(endPoint);\r\n        }\r\n        return new Path3D(slicePoints, this.getNormalAt(start), this._raw, this._alignTangentsWithPath);\r\n    }\r\n\r\n    /**\r\n     * Forces the Path3D tangent, normal, binormal and distance recomputation.\r\n     * @param path path which all values are copied into the curves points\r\n     * @param firstNormal which should be projected onto the curve\r\n     * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path\r\n     * @returns the same object updated.\r\n     */\r\n    public update(path: Vector3[], firstNormal: Nullable<Vector3> = null, alignTangentsWithPath = false): Path3D {\r\n        for (let p = 0; p < path.length; p++) {\r\n            this._curve[p].x = path[p].x;\r\n            this._curve[p].y = path[p].y;\r\n            this._curve[p].z = path[p].z;\r\n        }\r\n        this._compute(firstNormal, alignTangentsWithPath);\r\n        return this;\r\n    }\r\n\r\n    // private function compute() : computes tangents, normals and binormals\r\n    private _compute(firstNormal: Nullable<Vector3>, alignTangentsWithPath = false): void {\r\n        const l = this._curve.length;\r\n\r\n        if (l < 2) {\r\n            return;\r\n        }\r\n\r\n        // first and last tangents\r\n        this._tangents[0] = this._getFirstNonNullVector(0);\r\n        if (!this._raw) {\r\n            this._tangents[0].normalize();\r\n        }\r\n        this._tangents[l - 1] = this._curve[l - 1].subtract(this._curve[l - 2]);\r\n        if (!this._raw) {\r\n            this._tangents[l - 1].normalize();\r\n        }\r\n\r\n        // normals and binormals at first point : arbitrary vector with _normalVector()\r\n        const tg0 = this._tangents[0];\r\n        const pp0 = this._normalVector(tg0, firstNormal);\r\n        this._normals[0] = pp0;\r\n        if (!this._raw) {\r\n            this._normals[0].normalize();\r\n        }\r\n        this._binormals[0] = Vector3.Cross(tg0, this._normals[0]);\r\n        if (!this._raw) {\r\n            this._binormals[0].normalize();\r\n        }\r\n        this._distances[0] = 0.0;\r\n\r\n        // normals and binormals : next points\r\n        let prev: Vector3; // previous vector (segment)\r\n        let cur: Vector3; // current vector (segment)\r\n        let curTang: Vector3; // current tangent\r\n        // previous normal\r\n        let prevNor: Vector3; // previous normal\r\n        let prevBinor: Vector3; // previous binormal\r\n\r\n        for (let i = 1; i < l; i++) {\r\n            // tangents\r\n            prev = this._getLastNonNullVector(i);\r\n            if (i < l - 1) {\r\n                cur = this._getFirstNonNullVector(i);\r\n                this._tangents[i] = alignTangentsWithPath ? cur : prev.add(cur);\r\n                this._tangents[i].normalize();\r\n            }\r\n            this._distances[i] = this._distances[i - 1] + this._curve[i].subtract(this._curve[i - 1]).length();\r\n\r\n            // normals and binormals\r\n            // http://www.cs.cmu.edu/afs/andrew/scs/cs/15-462/web/old/asst2camera.html\r\n            curTang = this._tangents[i];\r\n            prevBinor = this._binormals[i - 1];\r\n            this._normals[i] = Vector3.Cross(prevBinor, curTang);\r\n            if (!this._raw) {\r\n                if (this._normals[i].length() === 0) {\r\n                    prevNor = this._normals[i - 1];\r\n                    this._normals[i] = prevNor.clone();\r\n                } else {\r\n                    this._normals[i].normalize();\r\n                }\r\n            }\r\n            this._binormals[i] = Vector3.Cross(curTang, this._normals[i]);\r\n            if (!this._raw) {\r\n                this._binormals[i].normalize();\r\n            }\r\n        }\r\n        this._pointAtData.id = NaN;\r\n    }\r\n\r\n    // private function getFirstNonNullVector(index)\r\n    // returns the first non null vector from index : curve[index + N].subtract(curve[index])\r\n    private _getFirstNonNullVector(index: number): Vector3 {\r\n        let i = 1;\r\n        let nNVector: Vector3 = this._curve[index + i].subtract(this._curve[index]);\r\n        while (nNVector.length() === 0 && index + i + 1 < this._curve.length) {\r\n            i++;\r\n            nNVector = this._curve[index + i].subtract(this._curve[index]);\r\n        }\r\n        return nNVector;\r\n    }\r\n\r\n    // private function getLastNonNullVector(index)\r\n    // returns the last non null vector from index : curve[index].subtract(curve[index - N])\r\n    private _getLastNonNullVector(index: number): Vector3 {\r\n        let i = 1;\r\n        let nLVector: Vector3 = this._curve[index].subtract(this._curve[index - i]);\r\n        while (nLVector.length() === 0 && index > i + 1) {\r\n            i++;\r\n            nLVector = this._curve[index].subtract(this._curve[index - i]);\r\n        }\r\n        return nLVector;\r\n    }\r\n\r\n    // private function normalVector(v0, vt, va) :\r\n    // returns an arbitrary point in the plane defined by the point v0 and the vector vt orthogonal to this plane\r\n    // if va is passed, it returns the va projection on the plane orthogonal to vt at the point v0\r\n    private _normalVector(vt: Vector3, va: Nullable<Vector3>): Vector3 {\r\n        let normal0: Vector3;\r\n        let tgl = vt.length();\r\n        if (tgl === 0.0) {\r\n            tgl = 1.0;\r\n        }\r\n\r\n        if (va === undefined || va === null) {\r\n            let point: Vector3;\r\n            if (!Scalar.WithinEpsilon(Math.abs(vt.y) / tgl, 1.0, Epsilon)) {\r\n                // search for a point in the plane\r\n                point = new Vector3(0.0, -1.0, 0.0);\r\n            } else if (!Scalar.WithinEpsilon(Math.abs(vt.x) / tgl, 1.0, Epsilon)) {\r\n                point = new Vector3(1.0, 0.0, 0.0);\r\n            } else if (!Scalar.WithinEpsilon(Math.abs(vt.z) / tgl, 1.0, Epsilon)) {\r\n                point = new Vector3(0.0, 0.0, 1.0);\r\n            } else {\r\n                point = Vector3.Zero();\r\n            }\r\n            normal0 = Vector3.Cross(vt, point);\r\n        } else {\r\n            normal0 = Vector3.Cross(vt, va);\r\n            Vector3.CrossToRef(normal0, vt, normal0);\r\n        }\r\n        normal0.normalize();\r\n        return normal0;\r\n    }\r\n\r\n    /**\r\n     * Updates the point at data for an interpolated point along this curve\r\n     * @param position the position of the point along this curve, from 0.0 to 1.0\r\n     * @param interpolateTNB\r\n     * @interpolateTNB whether to compute the interpolated tangent, normal and binormal\r\n     * @returns the (updated) point at data\r\n     */\r\n    private _updatePointAtData(position: number, interpolateTNB: boolean = false) {\r\n        // set an id for caching the result\r\n        if (this._pointAtData.id === position) {\r\n            if (!this._pointAtData.interpolateReady) {\r\n                this._updateInterpolationMatrix();\r\n            }\r\n            return this._pointAtData;\r\n        } else {\r\n            this._pointAtData.id = position;\r\n        }\r\n        const curvePoints = this.getPoints();\r\n\r\n        // clamp position between 0.0 and 1.0\r\n        if (position <= 0.0) {\r\n            return this._setPointAtData(0.0, 0.0, curvePoints[0], 0, interpolateTNB);\r\n        } else if (position >= 1.0) {\r\n            return this._setPointAtData(1.0, 1.0, curvePoints[curvePoints.length - 1], curvePoints.length - 1, interpolateTNB);\r\n        }\r\n\r\n        let previousPoint: Vector3 = curvePoints[0];\r\n        let currentPoint: Vector3;\r\n        let currentLength = 0.0;\r\n        const targetLength = position * this.length();\r\n\r\n        for (let i = 1; i < curvePoints.length; i++) {\r\n            currentPoint = curvePoints[i];\r\n            const distance = Vector3.Distance(previousPoint, currentPoint);\r\n            currentLength += distance;\r\n            if (currentLength === targetLength) {\r\n                return this._setPointAtData(position, 1.0, currentPoint, i, interpolateTNB);\r\n            } else if (currentLength > targetLength) {\r\n                const toLength = currentLength - targetLength;\r\n                const diff = toLength / distance;\r\n                const dir = previousPoint.subtract(currentPoint);\r\n                const point = currentPoint.add(dir.scaleInPlace(diff));\r\n                return this._setPointAtData(position, 1 - diff, point, i - 1, interpolateTNB);\r\n            }\r\n            previousPoint = currentPoint;\r\n        }\r\n        return this._pointAtData;\r\n    }\r\n\r\n    /**\r\n     * Updates the point at data from the specified parameters\r\n     * @param position where along the path the interpolated point is, from 0.0 to 1.0\r\n     * @param subPosition\r\n     * @param point the interpolated point\r\n     * @param parentIndex the index of an existing curve point that is on, or else positionally the first behind, the interpolated point\r\n     * @param interpolateTNB\r\n     */\r\n    private _setPointAtData(position: number, subPosition: number, point: Vector3, parentIndex: number, interpolateTNB: boolean) {\r\n        this._pointAtData.point = point;\r\n        this._pointAtData.position = position;\r\n        this._pointAtData.subPosition = subPosition;\r\n        this._pointAtData.previousPointArrayIndex = parentIndex;\r\n        this._pointAtData.interpolateReady = interpolateTNB;\r\n\r\n        if (interpolateTNB) {\r\n            this._updateInterpolationMatrix();\r\n        }\r\n        return this._pointAtData;\r\n    }\r\n\r\n    /**\r\n     * Updates the point at interpolation matrix for the tangents, normals and binormals\r\n     */\r\n    private _updateInterpolationMatrix() {\r\n        this._pointAtData.interpolationMatrix = Matrix.Identity();\r\n        const parentIndex = this._pointAtData.previousPointArrayIndex;\r\n\r\n        if (parentIndex !== this._tangents.length - 1) {\r\n            const index = parentIndex + 1;\r\n\r\n            const tangentFrom = this._tangents[parentIndex].clone();\r\n            const normalFrom = this._normals[parentIndex].clone();\r\n            const binormalFrom = this._binormals[parentIndex].clone();\r\n\r\n            const tangentTo = this._tangents[index].clone();\r\n            const normalTo = this._normals[index].clone();\r\n            const binormalTo = this._binormals[index].clone();\r\n\r\n            const quatFrom = Quaternion.RotationQuaternionFromAxis(normalFrom, binormalFrom, tangentFrom);\r\n            const quatTo = Quaternion.RotationQuaternionFromAxis(normalTo, binormalTo, tangentTo);\r\n            const quatAt = Quaternion.Slerp(quatFrom, quatTo, this._pointAtData.subPosition);\r\n\r\n            quatAt.toRotationMatrix(this._pointAtData.interpolationMatrix);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\r\n * A Curve3 is designed from a series of successive Vector3.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves\r\n */\r\nexport class Curve3 {\r\n    private _points: Vector3[];\r\n    private _length: number = 0.0;\r\n\r\n    /**\r\n     * Returns a Curve3 object along a Quadratic Bezier curve : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#quadratic-bezier-curve\r\n     * @param v0 (Vector3) the origin point of the Quadratic Bezier\r\n     * @param v1 (Vector3) the control point\r\n     * @param v2 (Vector3) the end point of the Quadratic Bezier\r\n     * @param nbPoints (integer) the wanted number of points in the curve\r\n     * @returns the created Curve3\r\n     */\r\n    public static CreateQuadraticBezier(v0: DeepImmutable<Vector3>, v1: DeepImmutable<Vector3>, v2: DeepImmutable<Vector3>, nbPoints: number): Curve3 {\r\n        nbPoints = nbPoints > 2 ? nbPoints : 3;\r\n        const bez = new Array<Vector3>();\r\n        const equation = (t: number, val0: number, val1: number, val2: number) => {\r\n            const res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;\r\n            return res;\r\n        };\r\n        for (let i = 0; i <= nbPoints; i++) {\r\n            bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x), equation(i / nbPoints, v0.y, v1.y, v2.y), equation(i / nbPoints, v0.z, v1.z, v2.z)));\r\n        }\r\n        return new Curve3(bez);\r\n    }\r\n\r\n    /**\r\n     * Returns a Curve3 object along a Cubic Bezier curve : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#cubic-bezier-curve\r\n     * @param v0 (Vector3) the origin point of the Cubic Bezier\r\n     * @param v1 (Vector3) the first control point\r\n     * @param v2 (Vector3) the second control point\r\n     * @param v3 (Vector3) the end point of the Cubic Bezier\r\n     * @param nbPoints (integer) the wanted number of points in the curve\r\n     * @returns the created Curve3\r\n     */\r\n    public static CreateCubicBezier(v0: DeepImmutable<Vector3>, v1: DeepImmutable<Vector3>, v2: DeepImmutable<Vector3>, v3: DeepImmutable<Vector3>, nbPoints: number): Curve3 {\r\n        nbPoints = nbPoints > 3 ? nbPoints : 4;\r\n        const bez = new Array<Vector3>();\r\n        const equation = (t: number, val0: number, val1: number, val2: number, val3: number) => {\r\n            const res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;\r\n            return res;\r\n        };\r\n        for (let i = 0; i <= nbPoints; i++) {\r\n            bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x, v3.x), equation(i / nbPoints, v0.y, v1.y, v2.y, v3.y), equation(i / nbPoints, v0.z, v1.z, v2.z, v3.z)));\r\n        }\r\n        return new Curve3(bez);\r\n    }\r\n\r\n    /**\r\n     * Returns a Curve3 object along a Hermite Spline curve : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#hermite-spline\r\n     * @param p1 (Vector3) the origin point of the Hermite Spline\r\n     * @param t1 (Vector3) the tangent vector at the origin point\r\n     * @param p2 (Vector3) the end point of the Hermite Spline\r\n     * @param t2 (Vector3) the tangent vector at the end point\r\n     * @param nSeg (integer) the number of curve segments or nSeg + 1 points in the array\r\n     * @returns the created Curve3\r\n     */\r\n    public static CreateHermiteSpline(p1: DeepImmutable<Vector3>, t1: DeepImmutable<Vector3>, p2: DeepImmutable<Vector3>, t2: DeepImmutable<Vector3>, nSeg: number): Curve3 {\r\n        const hermite = new Array<Vector3>();\r\n        const step = 1.0 / nSeg;\r\n        for (let i = 0; i <= nSeg; i++) {\r\n            hermite.push(Vector3.Hermite(p1, t1, p2, t2, i * step));\r\n        }\r\n        return new Curve3(hermite);\r\n    }\r\n\r\n    /**\r\n     * Returns a Curve3 object along a CatmullRom Spline curve :\r\n     * @param points (array of Vector3) the points the spline must pass through. At least, four points required\r\n     * @param nbPoints (integer) the wanted number of points between each curve control points\r\n     * @param closed (boolean) optional with default false, when true forms a closed loop from the points\r\n     * @returns the created Curve3\r\n     */\r\n    public static CreateCatmullRomSpline(points: DeepImmutable<Vector3[]>, nbPoints: number, closed?: boolean): Curve3 {\r\n        const catmullRom = new Array<Vector3>();\r\n        const step = 1.0 / nbPoints;\r\n        let amount = 0.0;\r\n        if (closed) {\r\n            const pointsCount = points.length;\r\n            for (let i = 0; i < pointsCount; i++) {\r\n                amount = 0;\r\n                for (let c = 0; c < nbPoints; c++) {\r\n                    catmullRom.push(\r\n                        Vector3.CatmullRom(points[i % pointsCount], points[(i + 1) % pointsCount], points[(i + 2) % pointsCount], points[(i + 3) % pointsCount], amount)\r\n                    );\r\n                    amount += step;\r\n                }\r\n            }\r\n            catmullRom.push(catmullRom[0]);\r\n        } else {\r\n            const totalPoints = new Array<Vector3>();\r\n            totalPoints.push(points[0].clone());\r\n            Array.prototype.push.apply(totalPoints, points);\r\n            totalPoints.push(points[points.length - 1].clone());\r\n            let i = 0;\r\n            for (; i < totalPoints.length - 3; i++) {\r\n                amount = 0;\r\n                for (let c = 0; c < nbPoints; c++) {\r\n                    catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\r\n                    amount += step;\r\n                }\r\n            }\r\n            i--;\r\n            catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\r\n        }\r\n        return new Curve3(catmullRom);\r\n    }\r\n\r\n    /**\r\n     * Returns a Curve3 object along an arc through three vector3 points:\r\n     * The three points should not be colinear. When they are the Curve3 is empty.\r\n     * @param first (Vector3) the first point the arc must pass through.\r\n     * @param second (Vector3) the second point the arc must pass through.\r\n     * @param third (Vector3) the third point the arc must pass through.\r\n     * @param steps (number) the larger the number of steps the more detailed the arc.\r\n     * @param closed (boolean) optional with default false, when true forms the chord from the first and third point\r\n     * @param fullCircle Circle (boolean) optional with default false, when true forms the complete circle through the three points\r\n     * @returns the created Curve3\r\n     */\r\n    public static ArcThru3Points(first: Vector3, second: Vector3, third: Vector3, steps: number = 32, closed: boolean = false, fullCircle: boolean = false): Curve3 {\r\n        const arc = new Array<Vector3>();\r\n        const vec1 = second.subtract(first);\r\n        const vec2 = third.subtract(second);\r\n        const vec3 = first.subtract(third);\r\n        const zAxis = Vector3.Cross(vec1, vec2);\r\n        const len4 = zAxis.length();\r\n        if (len4 < Math.pow(10, -8)) {\r\n            return new Curve3(arc); // colinear points arc is empty\r\n        }\r\n        const len1_sq = vec1.lengthSquared();\r\n        const len2_sq = vec2.lengthSquared();\r\n        const len3_sq = vec3.lengthSquared();\r\n        const len4_sq = zAxis.lengthSquared();\r\n        const len1 = vec1.length();\r\n        const len2 = vec2.length();\r\n        const len3 = vec3.length();\r\n        const radius = (0.5 * len1 * len2 * len3) / len4;\r\n        const dot1 = Vector3.Dot(vec1, vec3);\r\n        const dot2 = Vector3.Dot(vec1, vec2);\r\n        const dot3 = Vector3.Dot(vec2, vec3);\r\n        const a = (-0.5 * len2_sq * dot1) / len4_sq;\r\n        const b = (-0.5 * len3_sq * dot2) / len4_sq;\r\n        const c = (-0.5 * len1_sq * dot3) / len4_sq;\r\n        const center = first.scale(a).add(second.scale(b)).add(third.scale(c));\r\n        const radiusVec = first.subtract(center);\r\n        const xAxis = radiusVec.normalize();\r\n        const yAxis = Vector3.Cross(zAxis, xAxis).normalize();\r\n        if (fullCircle) {\r\n            const dStep = (2 * Math.PI) / steps;\r\n            for (let theta = 0; theta <= 2 * Math.PI; theta += dStep) {\r\n                arc.push(center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta)))));\r\n            }\r\n            arc.push(first);\r\n        } else {\r\n            const dStep = 1 / steps;\r\n            let theta = 0;\r\n            let point = Vector3.Zero();\r\n            do {\r\n                point = center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta))));\r\n                arc.push(point);\r\n                theta += dStep;\r\n            } while (!point.equalsWithEpsilon(third, radius * dStep * 1.1));\r\n            arc.push(third);\r\n            if (closed) {\r\n                arc.push(first);\r\n            }\r\n        }\r\n        return new Curve3(arc);\r\n    }\r\n\r\n    /**\r\n     * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\r\n     * A Curve3 is designed from a series of successive Vector3.\r\n     * Tuto : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#curve3-object\r\n     * @param points points which make up the curve\r\n     */\r\n    constructor(points: Vector3[]) {\r\n        this._points = points;\r\n        this._length = this._computeLength(points);\r\n    }\r\n\r\n    /**\r\n     * @returns the Curve3 stored array of successive Vector3\r\n     */\r\n    public getPoints() {\r\n        return this._points;\r\n    }\r\n\r\n    /**\r\n     * @returns the computed length (float) of the curve.\r\n     */\r\n    public length() {\r\n        return this._length;\r\n    }\r\n\r\n    /**\r\n     * Returns a new instance of Curve3 object : var curve = curveA.continue(curveB);\r\n     * This new Curve3 is built by translating and sticking the curveB at the end of the curveA.\r\n     * curveA and curveB keep unchanged.\r\n     * @param curve the curve to continue from this curve\r\n     * @returns the newly constructed curve\r\n     */\r\n    public continue(curve: DeepImmutable<Curve3>): Curve3 {\r\n        const lastPoint = this._points[this._points.length - 1];\r\n        const continuedPoints = this._points.slice();\r\n        const curvePoints = curve.getPoints();\r\n        for (let i = 1; i < curvePoints.length; i++) {\r\n            continuedPoints.push(curvePoints[i].subtract(curvePoints[0]).add(lastPoint));\r\n        }\r\n        const continuedCurve = new Curve3(continuedPoints);\r\n        return continuedCurve;\r\n    }\r\n\r\n    private _computeLength(path: DeepImmutable<Vector3[]>): number {\r\n        let l = 0;\r\n        for (let i = 1; i < path.length; i++) {\r\n            l += path[i].subtract(path[i - 1]).length();\r\n        }\r\n        return l;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}