{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n/**\n * Defines a sound that can be played in the application.\n * The sound can either be an ambient track or a simple sound played in reaction to a user action.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\n */\nexport class Sound {\n  /**\n   * Does the sound loop after it finishes playing once.\n   */\n  get loop() {\n    return this._loop;\n  }\n  set loop(value) {\n    if (value === this._loop) {\n      return;\n    }\n    this._loop = value;\n    this.updateOptions({\n      loop: value\n    });\n  }\n  /**\n   * Gets the current time for the sound.\n   */\n  get currentTime() {\n    var _a;\n    if (this._htmlAudioElement) {\n      return this._htmlAudioElement.currentTime;\n    }\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext) && (this.isPlaying || this.isPaused)) {\n      // The `_currentTime` member is only updated when the sound is paused. Add the time since the last start\n      // to get the actual current time.\n      const timeSinceLastStart = this.isPaused ? 0 : Engine.audioEngine.audioContext.currentTime - this._startTime;\n      return this._currentTime + timeSinceLastStart;\n    }\n    return 0;\n  }\n  /**\n   * Does this sound enables spatial sound.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n   */\n  get spatialSound() {\n    return this._spatialSound;\n  }\n  /**\n   * Does this sound enables spatial sound.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n   */\n  set spatialSound(newValue) {\n    if (newValue == this._spatialSound) {\n      return;\n    }\n    const wasPlaying = this.isPlaying;\n    this.pause();\n    if (newValue) {\n      this._spatialSound = newValue;\n      this._updateSpatialParameters();\n    } else {\n      this._disableSpatialSound();\n    }\n    if (wasPlaying) {\n      this.play();\n    }\n  }\n  /**\n   * Create a sound and attach it to a scene\n   * @param name Name of your sound\n   * @param urlOrArrayBuffer Url to the sound to load async or ArrayBuffer, it also works with MediaStreams and AudioBuffers\n   * @param scene defines the scene the sound belongs to\n   * @param readyToPlayCallback Provide a callback function if you'd like to load your code once the sound is ready to be played\n   * @param options Objects to provide with the current available options: autoplay, loop, volume, spatialSound, maxDistance, rolloffFactor, refDistance, distanceModel, panningModel, streaming\n   */\n  constructor(name, urlOrArrayBuffer, scene, readyToPlayCallback = null, options) {\n    var _a, _b, _c, _d, _e;\n    /**\n     * Does the sound autoplay once loaded.\n     */\n    this.autoplay = false;\n    this._loop = false;\n    /**\n     * Does the sound use a custom attenuation curve to simulate the falloff\n     * happening when the source gets further away from the camera.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-your-own-custom-attenuation-function\n     */\n    this.useCustomAttenuation = false;\n    /**\n     * Is this sound currently played.\n     */\n    this.isPlaying = false;\n    /**\n     * Is this sound currently paused.\n     */\n    this.isPaused = false;\n    /**\n     * Define the reference distance the sound should be heard perfectly.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n     */\n    this.refDistance = 1;\n    /**\n     * Define the roll off factor of spatial sounds.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n     */\n    this.rolloffFactor = 1;\n    /**\n     * Define the max distance the sound should be heard (intensity just became 0 at this point).\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n     */\n    this.maxDistance = 100;\n    /**\n     * Define the distance attenuation model the sound will follow.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n     */\n    this.distanceModel = \"linear\";\n    /**\n     * Gets or sets an object used to store user defined information for the sound.\n     */\n    this.metadata = null;\n    /**\n     * Observable event when the current playing sound finishes.\n     */\n    this.onEndedObservable = new Observable();\n    this._spatialSound = false;\n    this._panningModel = \"equalpower\";\n    this._playbackRate = 1;\n    this._streaming = false;\n    this._startTime = 0;\n    this._currentTime = 0;\n    this._position = Vector3.Zero();\n    this._localDirection = new Vector3(1, 0, 0);\n    this._volume = 1;\n    this._isReadyToPlay = false;\n    this._isDirectional = false;\n    // Used if you'd like to create a directional sound.\n    // If not set, the sound will be omnidirectional\n    this._coneInnerAngle = 360;\n    this._coneOuterAngle = 360;\n    this._coneOuterGain = 0;\n    this._isOutputConnected = false;\n    this._urlType = \"Unknown\";\n    this.name = name;\n    scene = scene || EngineStore.LastCreatedScene;\n    if (!scene) {\n      return;\n    }\n    this._scene = scene;\n    Sound._SceneComponentInitialization(scene);\n    this._readyToPlayCallback = readyToPlayCallback;\n    // Default custom attenuation function is a linear attenuation\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._customAttenuationFunction = (currentVolume, currentDistance, maxDistance, refDistance, rolloffFactor) => {\n      if (currentDistance < maxDistance) {\n        return currentVolume * (1 - currentDistance / maxDistance);\n      } else {\n        return 0;\n      }\n    };\n    if (options) {\n      this.autoplay = options.autoplay || false;\n      this._loop = options.loop || false;\n      // if volume === 0, we need another way to check this option\n      if (options.volume !== undefined) {\n        this._volume = options.volume;\n      }\n      this._spatialSound = (_a = options.spatialSound) !== null && _a !== void 0 ? _a : false;\n      this.maxDistance = (_b = options.maxDistance) !== null && _b !== void 0 ? _b : 100;\n      this.useCustomAttenuation = (_c = options.useCustomAttenuation) !== null && _c !== void 0 ? _c : false;\n      this.rolloffFactor = options.rolloffFactor || 1;\n      this.refDistance = options.refDistance || 1;\n      this.distanceModel = options.distanceModel || \"linear\";\n      this._playbackRate = options.playbackRate || 1;\n      this._streaming = (_d = options.streaming) !== null && _d !== void 0 ? _d : false;\n      this._length = options.length;\n      this._offset = options.offset;\n    }\n    if (((_e = Engine.audioEngine) === null || _e === void 0 ? void 0 : _e.canUseWebAudio) && Engine.audioEngine.audioContext) {\n      this._soundGain = Engine.audioEngine.audioContext.createGain();\n      this._soundGain.gain.value = this._volume;\n      this._inputAudioNode = this._soundGain;\n      this._outputAudioNode = this._soundGain;\n      if (this._spatialSound) {\n        this._createSpatialParameters();\n      }\n      this._scene.mainSoundTrack.addSound(this);\n      let validParameter = true;\n      // if no parameter is passed, you need to call setAudioBuffer yourself to prepare the sound\n      if (urlOrArrayBuffer) {\n        try {\n          if (typeof urlOrArrayBuffer === \"string\") {\n            this._urlType = \"String\";\n            this._url = urlOrArrayBuffer;\n          } else if (urlOrArrayBuffer instanceof ArrayBuffer) {\n            this._urlType = \"ArrayBuffer\";\n          } else if (urlOrArrayBuffer instanceof HTMLMediaElement) {\n            this._urlType = \"MediaElement\";\n          } else if (urlOrArrayBuffer instanceof MediaStream) {\n            this._urlType = \"MediaStream\";\n          } else if (urlOrArrayBuffer instanceof AudioBuffer) {\n            this._urlType = \"AudioBuffer\";\n          } else if (Array.isArray(urlOrArrayBuffer)) {\n            this._urlType = \"Array\";\n          }\n          let urls = [];\n          let codecSupportedFound = false;\n          switch (this._urlType) {\n            case \"MediaElement\":\n              this._streaming = true;\n              this._isReadyToPlay = true;\n              this._streamingSource = Engine.audioEngine.audioContext.createMediaElementSource(urlOrArrayBuffer);\n              if (this.autoplay) {\n                this.play(0, this._offset, this._length);\n              }\n              if (this._readyToPlayCallback) {\n                this._readyToPlayCallback();\n              }\n              break;\n            case \"MediaStream\":\n              this._streaming = true;\n              this._isReadyToPlay = true;\n              this._streamingSource = Engine.audioEngine.audioContext.createMediaStreamSource(urlOrArrayBuffer);\n              if (this.autoplay) {\n                this.play(0, this._offset, this._length);\n              }\n              if (this._readyToPlayCallback) {\n                this._readyToPlayCallback();\n              }\n              break;\n            case \"ArrayBuffer\":\n              if (urlOrArrayBuffer.byteLength > 0) {\n                codecSupportedFound = true;\n                this._soundLoaded(urlOrArrayBuffer);\n              }\n              break;\n            case \"AudioBuffer\":\n              this._audioBufferLoaded(urlOrArrayBuffer);\n              break;\n            case \"String\":\n              urls.push(urlOrArrayBuffer);\n            // eslint-disable-next-line no-fallthrough\n            case \"Array\":\n              if (urls.length === 0) {\n                urls = urlOrArrayBuffer;\n              }\n              // If we found a supported format, we load it immediately and stop the loop\n              for (let i = 0; i < urls.length; i++) {\n                const url = urls[i];\n                codecSupportedFound = options && options.skipCodecCheck || url.indexOf(\".mp3\", url.length - 4) !== -1 && Engine.audioEngine.isMP3supported || url.indexOf(\".ogg\", url.length - 4) !== -1 && Engine.audioEngine.isOGGsupported || url.indexOf(\".wav\", url.length - 4) !== -1 || url.indexOf(\".m4a\", url.length - 4) !== -1 || url.indexOf(\".mp4\", url.length - 4) !== -1 || url.indexOf(\"blob:\") !== -1;\n                if (codecSupportedFound) {\n                  // Loading sound\n                  if (!this._streaming) {\n                    this._scene._loadFile(url, data => {\n                      this._soundLoaded(data);\n                    }, undefined, true, true, exception => {\n                      if (exception) {\n                        Logger.Error(\"XHR \" + exception.status + \" error on: \" + url + \".\");\n                      }\n                      Logger.Error(\"Sound creation aborted.\");\n                      this._scene.mainSoundTrack.removeSound(this);\n                    });\n                  }\n                  // Streaming sound using HTML5 Audio tag\n                  else {\n                    this._htmlAudioElement = new Audio(url);\n                    this._htmlAudioElement.controls = false;\n                    this._htmlAudioElement.loop = this.loop;\n                    Tools.SetCorsBehavior(url, this._htmlAudioElement);\n                    this._htmlAudioElement.preload = \"auto\";\n                    this._htmlAudioElement.addEventListener(\"canplaythrough\", () => {\n                      this._isReadyToPlay = true;\n                      if (this.autoplay) {\n                        this.play(0, this._offset, this._length);\n                      }\n                      if (this._readyToPlayCallback) {\n                        this._readyToPlayCallback();\n                      }\n                    });\n                    document.body.appendChild(this._htmlAudioElement);\n                    this._htmlAudioElement.load();\n                  }\n                  break;\n                }\n              }\n              break;\n            default:\n              validParameter = false;\n              break;\n          }\n          if (!validParameter) {\n            Logger.Error(\"Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.\");\n          } else {\n            if (!codecSupportedFound) {\n              this._isReadyToPlay = true;\n              // Simulating a ready to play event to avoid breaking code path\n              if (this._readyToPlayCallback) {\n                setTimeout(() => {\n                  if (this._readyToPlayCallback) {\n                    this._readyToPlayCallback();\n                  }\n                }, 1000);\n              }\n            }\n          }\n        } catch (ex) {\n          Logger.Error(\"Unexpected error. Sound creation aborted.\");\n          this._scene.mainSoundTrack.removeSound(this);\n        }\n      }\n    } else {\n      // Adding an empty sound to avoid breaking audio calls for non Web Audio browsers\n      this._scene.mainSoundTrack.addSound(this);\n      if (Engine.audioEngine && !Engine.audioEngine.WarnedWebAudioUnsupported) {\n        Logger.Error(\"Web Audio is not supported by your browser.\");\n        Engine.audioEngine.WarnedWebAudioUnsupported = true;\n      }\n      // Simulating a ready to play event to avoid breaking code for non web audio browsers\n      if (this._readyToPlayCallback) {\n        setTimeout(() => {\n          if (this._readyToPlayCallback) {\n            this._readyToPlayCallback();\n          }\n        }, 1000);\n      }\n    }\n  }\n  /**\n   * Release the sound and its associated resources\n   */\n  dispose() {\n    var _a;\n    if ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) {\n      if (this.isPlaying) {\n        this.stop();\n      }\n      this._isReadyToPlay = false;\n      if (this.soundTrackId === -1) {\n        this._scene.mainSoundTrack.removeSound(this);\n      } else if (this._scene.soundTracks) {\n        this._scene.soundTracks[this.soundTrackId].removeSound(this);\n      }\n      if (this._soundGain) {\n        this._soundGain.disconnect();\n        this._soundGain = null;\n      }\n      if (this._soundPanner) {\n        this._soundPanner.disconnect();\n        this._soundPanner = null;\n      }\n      if (this._soundSource) {\n        this._soundSource.disconnect();\n        this._soundSource = null;\n      }\n      this._audioBuffer = null;\n      if (this._htmlAudioElement) {\n        this._htmlAudioElement.pause();\n        this._htmlAudioElement.src = \"\";\n        document.body.removeChild(this._htmlAudioElement);\n      }\n      if (this._streamingSource) {\n        this._streamingSource.disconnect();\n      }\n      if (this._connectedTransformNode && this._registerFunc) {\n        this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\n        this._connectedTransformNode = null;\n      }\n      this._clearTimeoutsAndObservers();\n    }\n  }\n  /**\n   * Gets if the sounds is ready to be played or not.\n   * @returns true if ready, otherwise false\n   */\n  isReady() {\n    return this._isReadyToPlay;\n  }\n  /**\n   * Get the current class name.\n   * @returns current class name\n   */\n  getClassName() {\n    return \"Sound\";\n  }\n  _audioBufferLoaded(buffer) {\n    var _a;\n    if (!((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext)) {\n      return;\n    }\n    this._audioBuffer = buffer;\n    this._isReadyToPlay = true;\n    if (this.autoplay) {\n      this.play(0, this._offset, this._length);\n    }\n    if (this._readyToPlayCallback) {\n      this._readyToPlayCallback();\n    }\n  }\n  _soundLoaded(audioData) {\n    var _a;\n    if (!((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext)) {\n      return;\n    }\n    Engine.audioEngine.audioContext.decodeAudioData(audioData, buffer => {\n      this._audioBufferLoaded(buffer);\n    }, err => {\n      Logger.Error(\"Error while decoding audio data for: \" + this.name + \" / Error: \" + err);\n    });\n  }\n  /**\n   * Sets the data of the sound from an audiobuffer\n   * @param audioBuffer The audioBuffer containing the data\n   */\n  setAudioBuffer(audioBuffer) {\n    var _a;\n    if ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) {\n      this._audioBuffer = audioBuffer;\n      this._isReadyToPlay = true;\n    }\n  }\n  /**\n   * Updates the current sounds options such as maxdistance, loop...\n   * @param options A JSON object containing values named as the object properties\n   */\n  updateOptions(options) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n    if (options) {\n      this.loop = (_a = options.loop) !== null && _a !== void 0 ? _a : this.loop;\n      this.maxDistance = (_b = options.maxDistance) !== null && _b !== void 0 ? _b : this.maxDistance;\n      this.useCustomAttenuation = (_c = options.useCustomAttenuation) !== null && _c !== void 0 ? _c : this.useCustomAttenuation;\n      this.rolloffFactor = (_d = options.rolloffFactor) !== null && _d !== void 0 ? _d : this.rolloffFactor;\n      this.refDistance = (_e = options.refDistance) !== null && _e !== void 0 ? _e : this.refDistance;\n      this.distanceModel = (_f = options.distanceModel) !== null && _f !== void 0 ? _f : this.distanceModel;\n      this._playbackRate = (_g = options.playbackRate) !== null && _g !== void 0 ? _g : this._playbackRate;\n      this._length = (_h = options.length) !== null && _h !== void 0 ? _h : undefined;\n      this.spatialSound = (_j = options.spatialSound) !== null && _j !== void 0 ? _j : this._spatialSound;\n      this._setOffset((_k = options.offset) !== null && _k !== void 0 ? _k : undefined);\n      this.setVolume((_l = options.volume) !== null && _l !== void 0 ? _l : this._volume);\n      this._updateSpatialParameters();\n      if (this.isPlaying) {\n        if (this._streaming && this._htmlAudioElement) {\n          this._htmlAudioElement.playbackRate = this._playbackRate;\n          if (this._htmlAudioElement.loop !== this.loop) {\n            this._htmlAudioElement.loop = this.loop;\n          }\n        } else {\n          if (this._soundSource) {\n            this._soundSource.playbackRate.value = this._playbackRate;\n            if (this._soundSource.loop !== this.loop) {\n              this._soundSource.loop = this.loop;\n            }\n            if (this._offset !== undefined && this._soundSource.loopStart !== this._offset) {\n              this._soundSource.loopStart = this._offset;\n            }\n            if (this._length !== undefined && this._length !== this._soundSource.loopEnd) {\n              this._soundSource.loopEnd = (this._offset | 0) + this._length;\n            }\n          }\n        }\n      }\n    }\n  }\n  _createSpatialParameters() {\n    var _a, _b;\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && Engine.audioEngine.audioContext) {\n      if (this._scene.headphone) {\n        this._panningModel = \"HRTF\";\n      }\n      this._soundPanner = (_b = this._soundPanner) !== null && _b !== void 0 ? _b : Engine.audioEngine.audioContext.createPanner();\n      if (this._soundPanner && this._outputAudioNode) {\n        this._updateSpatialParameters();\n        this._soundPanner.connect(this._outputAudioNode);\n        this._inputAudioNode = this._soundPanner;\n      }\n    }\n  }\n  _disableSpatialSound() {\n    var _a;\n    if (!this._spatialSound) {\n      return;\n    }\n    this._inputAudioNode = this._soundGain;\n    (_a = this._soundPanner) === null || _a === void 0 ? void 0 : _a.disconnect();\n    this._soundPanner = null;\n    this._spatialSound = false;\n  }\n  _updateSpatialParameters() {\n    if (!this._spatialSound) {\n      return;\n    }\n    if (this._soundPanner) {\n      if (this.useCustomAttenuation) {\n        // Tricks to disable in a way embedded Web Audio attenuation\n        this._soundPanner.distanceModel = \"linear\";\n        this._soundPanner.maxDistance = Number.MAX_VALUE;\n        this._soundPanner.refDistance = 1;\n        this._soundPanner.rolloffFactor = 1;\n        this._soundPanner.panningModel = this._panningModel;\n      } else {\n        this._soundPanner.distanceModel = this.distanceModel;\n        this._soundPanner.maxDistance = this.maxDistance;\n        this._soundPanner.refDistance = this.refDistance;\n        this._soundPanner.rolloffFactor = this.rolloffFactor;\n        this._soundPanner.panningModel = this._panningModel;\n      }\n    } else {\n      this._createSpatialParameters();\n    }\n  }\n  /**\n   * Switch the panning model to HRTF:\n   * Renders a stereo output of higher quality than equalpower — it uses a convolution with measured impulse responses from human subjects.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n   */\n  switchPanningModelToHRTF() {\n    this._panningModel = \"HRTF\";\n    this._switchPanningModel();\n  }\n  /**\n   * Switch the panning model to Equal Power:\n   * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n   */\n  switchPanningModelToEqualPower() {\n    this._panningModel = \"equalpower\";\n    this._switchPanningModel();\n  }\n  _switchPanningModel() {\n    var _a;\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner) {\n      this._soundPanner.panningModel = this._panningModel;\n    }\n  }\n  /**\n   * Connect this sound to a sound track audio node like gain...\n   * @param soundTrackAudioNode the sound track audio node to connect to\n   */\n  connectToSoundTrackAudioNode(soundTrackAudioNode) {\n    var _a;\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._outputAudioNode) {\n      if (this._isOutputConnected) {\n        this._outputAudioNode.disconnect();\n      }\n      this._outputAudioNode.connect(soundTrackAudioNode);\n      this._isOutputConnected = true;\n    }\n  }\n  /**\n   * Transform this sound into a directional source\n   * @param coneInnerAngle Size of the inner cone in degree\n   * @param coneOuterAngle Size of the outer cone in degree\n   * @param coneOuterGain Volume of the sound outside the outer cone (between 0.0 and 1.0)\n   */\n  setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {\n    if (coneOuterAngle < coneInnerAngle) {\n      Logger.Error(\"setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.\");\n      return;\n    }\n    this._coneInnerAngle = coneInnerAngle;\n    this._coneOuterAngle = coneOuterAngle;\n    this._coneOuterGain = coneOuterGain;\n    this._isDirectional = true;\n    if (this.isPlaying && this.loop) {\n      this.stop();\n      this.play(0, this._offset, this._length);\n    }\n  }\n  /**\n   * Gets or sets the inner angle for the directional cone.\n   */\n  get directionalConeInnerAngle() {\n    return this._coneInnerAngle;\n  }\n  /**\n   * Gets or sets the inner angle for the directional cone.\n   */\n  set directionalConeInnerAngle(value) {\n    var _a;\n    if (value != this._coneInnerAngle) {\n      if (this._coneOuterAngle < value) {\n        Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n        return;\n      }\n      this._coneInnerAngle = value;\n      if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner) {\n        this._soundPanner.coneInnerAngle = this._coneInnerAngle;\n      }\n    }\n  }\n  /**\n   * Gets or sets the outer angle for the directional cone.\n   */\n  get directionalConeOuterAngle() {\n    return this._coneOuterAngle;\n  }\n  /**\n   * Gets or sets the outer angle for the directional cone.\n   */\n  set directionalConeOuterAngle(value) {\n    var _a;\n    if (value != this._coneOuterAngle) {\n      if (value < this._coneInnerAngle) {\n        Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n        return;\n      }\n      this._coneOuterAngle = value;\n      if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner) {\n        this._soundPanner.coneOuterAngle = this._coneOuterAngle;\n      }\n    }\n  }\n  /**\n   * Sets the position of the emitter if spatial sound is enabled\n   * @param newPosition Defines the new position\n   */\n  setPosition(newPosition) {\n    var _a;\n    if (newPosition.equals(this._position)) {\n      return;\n    }\n    this._position.copyFrom(newPosition);\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner && !isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {\n      this._soundPanner.positionX.value = this._position.x;\n      this._soundPanner.positionY.value = this._position.y;\n      this._soundPanner.positionZ.value = this._position.z;\n    }\n  }\n  /**\n   * Sets the local direction of the emitter if spatial sound is enabled\n   * @param newLocalDirection Defines the new local direction\n   */\n  setLocalDirectionToMesh(newLocalDirection) {\n    var _a;\n    this._localDirection = newLocalDirection;\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._connectedTransformNode && this.isPlaying) {\n      this._updateDirection();\n    }\n  }\n  _updateDirection() {\n    if (!this._connectedTransformNode || !this._soundPanner) {\n      return;\n    }\n    const mat = this._connectedTransformNode.getWorldMatrix();\n    const direction = Vector3.TransformNormal(this._localDirection, mat);\n    direction.normalize();\n    this._soundPanner.orientationX.value = direction.x;\n    this._soundPanner.orientationY.value = direction.y;\n    this._soundPanner.orientationZ.value = direction.z;\n  }\n  /** @internal */\n  updateDistanceFromListener() {\n    var _a;\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._connectedTransformNode && this.useCustomAttenuation && this._soundGain && this._scene.activeCamera) {\n      const distance = this._scene.audioListenerPositionProvider ? this._connectedTransformNode.position.subtract(this._scene.audioListenerPositionProvider()).length() : this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);\n      this._soundGain.gain.value = this._customAttenuationFunction(this._volume, distance, this.maxDistance, this.refDistance, this.rolloffFactor);\n    }\n  }\n  /**\n   * Sets a new custom attenuation function for the sound.\n   * @param callback Defines the function used for the attenuation\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-your-own-custom-attenuation-function\n   */\n  setAttenuationFunction(callback) {\n    this._customAttenuationFunction = callback;\n  }\n  /**\n   * Play the sound\n   * @param time (optional) Start the sound after X seconds. Start immediately (0) by default.\n   * @param offset (optional) Start the sound at a specific time in seconds\n   * @param length (optional) Sound duration (in seconds)\n   */\n  play(time, offset, length) {\n    var _a, _b, _c, _d;\n    if (this._isReadyToPlay && this._scene.audioEnabled && ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext)) {\n      try {\n        this._clearTimeoutsAndObservers();\n        let startTime = time ? ((_b = Engine.audioEngine) === null || _b === void 0 ? void 0 : _b.audioContext.currentTime) + time : (_c = Engine.audioEngine) === null || _c === void 0 ? void 0 : _c.audioContext.currentTime;\n        if (!this._soundSource || !this._streamingSource) {\n          if (this._spatialSound && this._soundPanner) {\n            if (!isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {\n              this._soundPanner.positionX.value = this._position.x;\n              this._soundPanner.positionY.value = this._position.y;\n              this._soundPanner.positionZ.value = this._position.z;\n            }\n            if (this._isDirectional) {\n              this._soundPanner.coneInnerAngle = this._coneInnerAngle;\n              this._soundPanner.coneOuterAngle = this._coneOuterAngle;\n              this._soundPanner.coneOuterGain = this._coneOuterGain;\n              if (this._connectedTransformNode) {\n                this._updateDirection();\n              } else {\n                this._soundPanner.setOrientation(this._localDirection.x, this._localDirection.y, this._localDirection.z);\n              }\n            }\n          }\n        }\n        if (this._streaming) {\n          if (!this._streamingSource) {\n            this._streamingSource = Engine.audioEngine.audioContext.createMediaElementSource(this._htmlAudioElement);\n            this._htmlAudioElement.onended = () => {\n              this._onended();\n            };\n            this._htmlAudioElement.playbackRate = this._playbackRate;\n          }\n          this._streamingSource.disconnect();\n          if (this._inputAudioNode) {\n            this._streamingSource.connect(this._inputAudioNode);\n          }\n          if (this._htmlAudioElement) {\n            // required to manage properly the new suspended default state of Chrome\n            // When the option 'streaming: true' is used, we need first to wait for\n            // the audio engine to be unlocked by a user gesture before trying to play\n            // an HTML Audio element\n            const tryToPlay = () => {\n              var _a, _b;\n              if ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.unlocked) {\n                const playPromise = this._htmlAudioElement.play();\n                // In browsers that don’t yet support this functionality,\n                // playPromise won’t be defined.\n                if (playPromise !== undefined) {\n                  playPromise.catch(() => {\n                    var _a, _b;\n                    // Automatic playback failed.\n                    // Waiting for the audio engine to be unlocked by user click on unmute\n                    (_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.lock();\n                    if (this.loop || this.autoplay) {\n                      this._audioUnlockedObserver = (_b = Engine.audioEngine) === null || _b === void 0 ? void 0 : _b.onAudioUnlockedObservable.addOnce(() => {\n                        tryToPlay();\n                      });\n                    }\n                  });\n                }\n              } else {\n                if (this.loop || this.autoplay) {\n                  this._audioUnlockedObserver = (_b = Engine.audioEngine) === null || _b === void 0 ? void 0 : _b.onAudioUnlockedObservable.addOnce(() => {\n                    tryToPlay();\n                  });\n                }\n              }\n            };\n            tryToPlay();\n          }\n        } else {\n          const tryToPlay = () => {\n            var _a, _b, _c, _d;\n            if ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext) {\n              length = length || this._length;\n              if (offset !== undefined) {\n                this._setOffset(offset);\n              }\n              if (this._soundSource) {\n                const oldSource = this._soundSource;\n                oldSource.onended = () => {\n                  oldSource.disconnect();\n                };\n              }\n              this._soundSource = (_b = Engine.audioEngine) === null || _b === void 0 ? void 0 : _b.audioContext.createBufferSource();\n              if (this._soundSource && this._inputAudioNode) {\n                this._soundSource.buffer = this._audioBuffer;\n                this._soundSource.connect(this._inputAudioNode);\n                this._soundSource.loop = this.loop;\n                if (offset !== undefined) {\n                  this._soundSource.loopStart = offset;\n                }\n                if (length !== undefined) {\n                  this._soundSource.loopEnd = (offset | 0) + length;\n                }\n                this._soundSource.playbackRate.value = this._playbackRate;\n                this._soundSource.onended = () => {\n                  this._onended();\n                };\n                startTime = time ? ((_c = Engine.audioEngine) === null || _c === void 0 ? void 0 : _c.audioContext.currentTime) + time : Engine.audioEngine.audioContext.currentTime;\n                const actualOffset = ((this.isPaused ? this.currentTime : 0) + ((_d = this._offset) !== null && _d !== void 0 ? _d : 0)) % this._soundSource.buffer.duration;\n                this._soundSource.start(startTime, actualOffset, this.loop ? undefined : length);\n              }\n            }\n          };\n          if (((_d = Engine.audioEngine) === null || _d === void 0 ? void 0 : _d.audioContext.state) === \"suspended\") {\n            // Wait a bit for FF as context seems late to be ready.\n            this._tryToPlayTimeout = setTimeout(() => {\n              var _a;\n              if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext.state) === \"suspended\") {\n                // Automatic playback failed.\n                // Waiting for the audio engine to be unlocked by user click on unmute\n                Engine.audioEngine.lock();\n                if (this.loop || this.autoplay) {\n                  this._audioUnlockedObserver = Engine.audioEngine.onAudioUnlockedObservable.addOnce(() => {\n                    tryToPlay();\n                  });\n                }\n              } else {\n                tryToPlay();\n              }\n            }, 500);\n          } else {\n            tryToPlay();\n          }\n        }\n        this._startTime = startTime;\n        this.isPlaying = true;\n        this.isPaused = false;\n      } catch (ex) {\n        Logger.Error(\"Error while trying to play audio: \" + this.name + \", \" + ex.message);\n      }\n    }\n  }\n  _onended() {\n    this.isPlaying = false;\n    this._startTime = 0;\n    this._currentTime = 0;\n    if (this.onended) {\n      this.onended();\n    }\n    this.onEndedObservable.notifyObservers(this);\n  }\n  /**\n   * Stop the sound\n   * @param time (optional) Stop the sound after X seconds. Stop immediately (0) by default.\n   */\n  stop(time) {\n    var _a;\n    if (this.isPlaying) {\n      this._clearTimeoutsAndObservers();\n      if (this._streaming) {\n        if (this._htmlAudioElement) {\n          this._htmlAudioElement.pause();\n          // Test needed for Firefox or it will generate an Invalid State Error\n          if (this._htmlAudioElement.currentTime > 0) {\n            this._htmlAudioElement.currentTime = 0;\n          }\n        } else {\n          this._streamingSource.disconnect();\n        }\n        this.isPlaying = false;\n      } else if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext) && this._soundSource) {\n        const stopTime = time ? Engine.audioEngine.audioContext.currentTime + time : undefined;\n        this._soundSource.onended = () => {\n          this.isPlaying = false;\n          this.isPaused = false;\n          this._startTime = 0;\n          this._currentTime = 0;\n          if (this._soundSource) {\n            this._soundSource.onended = () => void 0;\n          }\n          this._onended();\n        };\n        this._soundSource.stop(stopTime);\n      } else {\n        this.isPlaying = false;\n      }\n    } else if (this.isPaused) {\n      this.isPaused = false;\n      this._startTime = 0;\n      this._currentTime = 0;\n    }\n  }\n  /**\n   * Put the sound in pause\n   */\n  pause() {\n    var _a;\n    if (this.isPlaying) {\n      this._clearTimeoutsAndObservers();\n      if (this._streaming) {\n        if (this._htmlAudioElement) {\n          this._htmlAudioElement.pause();\n        } else {\n          this._streamingSource.disconnect();\n        }\n        this.isPlaying = false;\n        this.isPaused = true;\n      } else if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext) && this._soundSource) {\n        this._soundSource.onended = () => void 0;\n        this._soundSource.stop();\n        this.isPlaying = false;\n        this.isPaused = true;\n        this._currentTime += Engine.audioEngine.audioContext.currentTime - this._startTime;\n      }\n    }\n  }\n  /**\n   * Sets a dedicated volume for this sounds\n   * @param newVolume Define the new volume of the sound\n   * @param time Define time for gradual change to new volume\n   */\n  setVolume(newVolume, time) {\n    var _a;\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._soundGain) {\n      if (time && Engine.audioEngine.audioContext) {\n        this._soundGain.gain.cancelScheduledValues(Engine.audioEngine.audioContext.currentTime);\n        this._soundGain.gain.setValueAtTime(this._soundGain.gain.value, Engine.audioEngine.audioContext.currentTime);\n        this._soundGain.gain.linearRampToValueAtTime(newVolume, Engine.audioEngine.audioContext.currentTime + time);\n      } else {\n        this._soundGain.gain.value = newVolume;\n      }\n    }\n    this._volume = newVolume;\n  }\n  /**\n   * Set the sound play back rate\n   * @param newPlaybackRate Define the playback rate the sound should be played at\n   */\n  setPlaybackRate(newPlaybackRate) {\n    this._playbackRate = newPlaybackRate;\n    if (this.isPlaying) {\n      if (this._streaming && this._htmlAudioElement) {\n        this._htmlAudioElement.playbackRate = this._playbackRate;\n      } else if (this._soundSource) {\n        this._soundSource.playbackRate.value = this._playbackRate;\n      }\n    }\n  }\n  /**\n   * Gets the sound play back rate.\n   * @returns the  play back rate of the sound\n   */\n  getPlaybackRate() {\n    return this._playbackRate;\n  }\n  /**\n   * Gets the volume of the sound.\n   * @returns the volume of the sound\n   */\n  getVolume() {\n    return this._volume;\n  }\n  /**\n   * Attach the sound to a dedicated mesh\n   * @param transformNode The transform node to connect the sound with\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#attaching-a-sound-to-a-mesh\n   */\n  attachToMesh(transformNode) {\n    if (this._connectedTransformNode && this._registerFunc) {\n      this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\n      this._registerFunc = null;\n    }\n    this._connectedTransformNode = transformNode;\n    if (!this._spatialSound) {\n      this._spatialSound = true;\n      this._createSpatialParameters();\n      if (this.isPlaying && this.loop) {\n        this.stop();\n        this.play(0, this._offset, this._length);\n      }\n    }\n    this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode);\n    this._registerFunc = transformNode => this._onRegisterAfterWorldMatrixUpdate(transformNode);\n    this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc);\n  }\n  /**\n   * Detach the sound from the previously attached mesh\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#attaching-a-sound-to-a-mesh\n   */\n  detachFromMesh() {\n    if (this._connectedTransformNode && this._registerFunc) {\n      this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\n      this._registerFunc = null;\n      this._connectedTransformNode = null;\n    }\n  }\n  _onRegisterAfterWorldMatrixUpdate(node) {\n    var _a;\n    if (!node.getBoundingInfo) {\n      this.setPosition(node.absolutePosition);\n    } else {\n      const mesh = node;\n      const boundingInfo = mesh.getBoundingInfo();\n      this.setPosition(boundingInfo.boundingSphere.centerWorld);\n    }\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._isDirectional && this.isPlaying) {\n      this._updateDirection();\n    }\n  }\n  /**\n   * Clone the current sound in the scene.\n   * @returns the new sound clone\n   */\n  clone() {\n    if (!this._streaming) {\n      const setBufferAndRun = () => {\n        if (this._isReadyToPlay) {\n          clonedSound._audioBuffer = this.getAudioBuffer();\n          clonedSound._isReadyToPlay = true;\n          if (clonedSound.autoplay) {\n            clonedSound.play(0, this._offset, this._length);\n          }\n        } else {\n          setTimeout(setBufferAndRun, 300);\n        }\n      };\n      const currentOptions = {\n        autoplay: this.autoplay,\n        loop: this.loop,\n        volume: this._volume,\n        spatialSound: this._spatialSound,\n        maxDistance: this.maxDistance,\n        useCustomAttenuation: this.useCustomAttenuation,\n        rolloffFactor: this.rolloffFactor,\n        refDistance: this.refDistance,\n        distanceModel: this.distanceModel\n      };\n      const clonedSound = new Sound(this.name + \"_cloned\", new ArrayBuffer(0), this._scene, null, currentOptions);\n      if (this.useCustomAttenuation) {\n        clonedSound.setAttenuationFunction(this._customAttenuationFunction);\n      }\n      clonedSound.setPosition(this._position);\n      clonedSound.setPlaybackRate(this._playbackRate);\n      setBufferAndRun();\n      return clonedSound;\n    }\n    // Can't clone a streaming sound\n    else {\n      return null;\n    }\n  }\n  /**\n   * Gets the current underlying audio buffer containing the data\n   * @returns the audio buffer\n   */\n  getAudioBuffer() {\n    return this._audioBuffer;\n  }\n  /**\n   * Gets the WebAudio AudioBufferSourceNode, lets you keep track of and stop instances of this Sound.\n   * @returns the source node\n   */\n  getSoundSource() {\n    return this._soundSource;\n  }\n  /**\n   * Gets the WebAudio GainNode, gives you precise control over the gain of instances of this Sound.\n   * @returns the gain node\n   */\n  getSoundGain() {\n    return this._soundGain;\n  }\n  /**\n   * Serializes the Sound in a JSON representation\n   * @returns the JSON representation of the sound\n   */\n  serialize() {\n    const serializationObject = {\n      name: this.name,\n      url: this._url,\n      autoplay: this.autoplay,\n      loop: this.loop,\n      volume: this._volume,\n      spatialSound: this._spatialSound,\n      maxDistance: this.maxDistance,\n      rolloffFactor: this.rolloffFactor,\n      refDistance: this.refDistance,\n      distanceModel: this.distanceModel,\n      playbackRate: this._playbackRate,\n      panningModel: this._panningModel,\n      soundTrackId: this.soundTrackId,\n      metadata: this.metadata\n    };\n    if (this._spatialSound) {\n      if (this._connectedTransformNode) {\n        serializationObject.connectedMeshId = this._connectedTransformNode.id;\n      }\n      serializationObject.position = this._position.asArray();\n      serializationObject.refDistance = this.refDistance;\n      serializationObject.distanceModel = this.distanceModel;\n      serializationObject.isDirectional = this._isDirectional;\n      serializationObject.localDirectionToMesh = this._localDirection.asArray();\n      serializationObject.coneInnerAngle = this._coneInnerAngle;\n      serializationObject.coneOuterAngle = this._coneOuterAngle;\n      serializationObject.coneOuterGain = this._coneOuterGain;\n    }\n    return serializationObject;\n  }\n  /**\n   * Parse a JSON representation of a sound to instantiate in a given scene\n   * @param parsedSound Define the JSON representation of the sound (usually coming from the serialize method)\n   * @param scene Define the scene the new parsed sound should be created in\n   * @param rootUrl Define the rooturl of the load in case we need to fetch relative dependencies\n   * @param sourceSound Define a sound place holder if do not need to instantiate a new one\n   * @returns the newly parsed sound\n   */\n  static Parse(parsedSound, scene, rootUrl, sourceSound) {\n    const soundName = parsedSound.name;\n    let soundUrl;\n    if (parsedSound.url) {\n      soundUrl = rootUrl + parsedSound.url;\n    } else {\n      soundUrl = rootUrl + soundName;\n    }\n    const options = {\n      autoplay: parsedSound.autoplay,\n      loop: parsedSound.loop,\n      volume: parsedSound.volume,\n      spatialSound: parsedSound.spatialSound,\n      maxDistance: parsedSound.maxDistance,\n      rolloffFactor: parsedSound.rolloffFactor,\n      refDistance: parsedSound.refDistance,\n      distanceModel: parsedSound.distanceModel,\n      playbackRate: parsedSound.playbackRate\n    };\n    let newSound;\n    if (!sourceSound) {\n      newSound = new Sound(soundName, soundUrl, scene, () => {\n        scene.removePendingData(newSound);\n      }, options);\n      scene.addPendingData(newSound);\n    } else {\n      const setBufferAndRun = () => {\n        if (sourceSound._isReadyToPlay) {\n          newSound._audioBuffer = sourceSound.getAudioBuffer();\n          newSound._isReadyToPlay = true;\n          if (newSound.autoplay) {\n            newSound.play(0, newSound._offset, newSound._length);\n          }\n        } else {\n          setTimeout(setBufferAndRun, 300);\n        }\n      };\n      newSound = new Sound(soundName, new ArrayBuffer(0), scene, null, options);\n      setBufferAndRun();\n    }\n    if (parsedSound.position) {\n      const soundPosition = Vector3.FromArray(parsedSound.position);\n      newSound.setPosition(soundPosition);\n    }\n    if (parsedSound.isDirectional) {\n      newSound.setDirectionalCone(parsedSound.coneInnerAngle || 360, parsedSound.coneOuterAngle || 360, parsedSound.coneOuterGain || 0);\n      if (parsedSound.localDirectionToMesh) {\n        const localDirectionToMesh = Vector3.FromArray(parsedSound.localDirectionToMesh);\n        newSound.setLocalDirectionToMesh(localDirectionToMesh);\n      }\n    }\n    if (parsedSound.connectedMeshId) {\n      const connectedMesh = scene.getMeshById(parsedSound.connectedMeshId);\n      if (connectedMesh) {\n        newSound.attachToMesh(connectedMesh);\n      }\n    }\n    if (parsedSound.metadata) {\n      newSound.metadata = parsedSound.metadata;\n    }\n    return newSound;\n  }\n  _setOffset(value) {\n    if (this._offset === value) {\n      return;\n    }\n    if (this.isPaused) {\n      this.stop();\n      this.isPaused = false;\n    }\n    this._offset = value;\n  }\n  _clearTimeoutsAndObservers() {\n    var _a;\n    if (this._tryToPlayTimeout) {\n      clearTimeout(this._tryToPlayTimeout);\n      this._tryToPlayTimeout = null;\n    }\n    if (this._audioUnlockedObserver) {\n      (_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.onAudioUnlockedObservable.remove(this._audioUnlockedObserver);\n      this._audioUnlockedObserver = null;\n    }\n  }\n}\n/**\n * @internal\n */\nSound._SceneComponentInitialization = _ => {\n  throw _WarnImport(\"AudioSceneComponent\");\n};","map":{"version":3,"names":["Tools","Observable","Vector3","Engine","Logger","_WarnImport","EngineStore","Sound","loop","_loop","value","updateOptions","currentTime","_htmlAudioElement","_a","audioEngine","audioContext","isPlaying","isPaused","timeSinceLastStart","_startTime","_currentTime","spatialSound","_spatialSound","newValue","wasPlaying","pause","_updateSpatialParameters","_disableSpatialSound","play","constructor","name","urlOrArrayBuffer","scene","readyToPlayCallback","options","autoplay","useCustomAttenuation","refDistance","rolloffFactor","maxDistance","distanceModel","metadata","onEndedObservable","_panningModel","_playbackRate","_streaming","_position","Zero","_localDirection","_volume","_isReadyToPlay","_isDirectional","_coneInnerAngle","_coneOuterAngle","_coneOuterGain","_isOutputConnected","_urlType","LastCreatedScene","_scene","_SceneComponentInitialization","_readyToPlayCallback","_customAttenuationFunction","currentVolume","currentDistance","volume","undefined","_b","_c","playbackRate","_d","streaming","_length","length","_offset","offset","_e","canUseWebAudio","_soundGain","createGain","gain","_inputAudioNode","_outputAudioNode","_createSpatialParameters","mainSoundTrack","addSound","validParameter","_url","ArrayBuffer","HTMLMediaElement","MediaStream","AudioBuffer","Array","isArray","urls","codecSupportedFound","_streamingSource","createMediaElementSource","createMediaStreamSource","byteLength","_soundLoaded","_audioBufferLoaded","push","i","url","skipCodecCheck","indexOf","isMP3supported","isOGGsupported","_loadFile","data","exception","Error","status","removeSound","Audio","controls","SetCorsBehavior","preload","addEventListener","document","body","appendChild","load","setTimeout","ex","WarnedWebAudioUnsupported","dispose","stop","soundTrackId","soundTracks","disconnect","_soundPanner","_soundSource","_audioBuffer","src","removeChild","_connectedTransformNode","_registerFunc","unregisterAfterWorldMatrixUpdate","_clearTimeoutsAndObservers","isReady","getClassName","buffer","audioData","decodeAudioData","err","setAudioBuffer","audioBuffer","_f","_g","_h","_j","_setOffset","_k","setVolume","_l","loopStart","loopEnd","headphone","createPanner","connect","Number","MAX_VALUE","panningModel","switchPanningModelToHRTF","_switchPanningModel","switchPanningModelToEqualPower","connectToSoundTrackAudioNode","soundTrackAudioNode","setDirectionalCone","coneInnerAngle","coneOuterAngle","coneOuterGain","directionalConeInnerAngle","directionalConeOuterAngle","setPosition","newPosition","equals","copyFrom","isNaN","x","y","z","positionX","positionY","positionZ","setLocalDirectionToMesh","newLocalDirection","_updateDirection","mat","getWorldMatrix","direction","TransformNormal","normalize","orientationX","orientationY","orientationZ","updateDistanceFromListener","activeCamera","distance","audioListenerPositionProvider","position","subtract","getDistanceToCamera","setAttenuationFunction","callback","time","audioEnabled","startTime","setOrientation","onended","_onended","tryToPlay","unlocked","playPromise","catch","lock","_audioUnlockedObserver","onAudioUnlockedObservable","addOnce","oldSource","createBufferSource","actualOffset","duration","start","state","_tryToPlayTimeout","message","notifyObservers","stopTime","newVolume","cancelScheduledValues","setValueAtTime","linearRampToValueAtTime","setPlaybackRate","newPlaybackRate","getPlaybackRate","getVolume","attachToMesh","transformNode","_onRegisterAfterWorldMatrixUpdate","registerAfterWorldMatrixUpdate","detachFromMesh","node","getBoundingInfo","absolutePosition","mesh","boundingInfo","boundingSphere","centerWorld","clone","setBufferAndRun","clonedSound","getAudioBuffer","currentOptions","getSoundSource","getSoundGain","serialize","serializationObject","connectedMeshId","id","asArray","isDirectional","localDirectionToMesh","Parse","parsedSound","rootUrl","sourceSound","soundName","soundUrl","newSound","removePendingData","addPendingData","soundPosition","FromArray","connectedMesh","getMeshById","clearTimeout","remove","_"],"sources":["../../../../dev/core/src/Audio/sound.ts"],"sourcesContent":["import { Tools } from \"../Misc/tools\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { ISoundOptions } from \"./Interfaces/ISoundOptions\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { IAudioEngine } from \"./Interfaces/IAudioEngine\";\r\nimport type { Observer } from \"../Misc/observable\";\r\n\r\n/**\r\n * Defines a sound that can be played in the application.\r\n * The sound can either be an ambient track or a simple sound played in reaction to a user action.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\r\n */\r\nexport class Sound {\r\n    /**\r\n     * The name of the sound in the scene.\r\n     */\r\n    public name: string;\r\n    /**\r\n     * Does the sound autoplay once loaded.\r\n     */\r\n    public autoplay: boolean = false;\r\n\r\n    private _loop = false;\r\n    /**\r\n     * Does the sound loop after it finishes playing once.\r\n     */\r\n    public get loop(): boolean {\r\n        return this._loop;\r\n    }\r\n\r\n    public set loop(value: boolean) {\r\n        if (value === this._loop) {\r\n            return;\r\n        }\r\n\r\n        this._loop = value;\r\n        this.updateOptions({ loop: value });\r\n    }\r\n\r\n    /**\r\n     * Does the sound use a custom attenuation curve to simulate the falloff\r\n     * happening when the source gets further away from the camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-your-own-custom-attenuation-function\r\n     */\r\n    public useCustomAttenuation: boolean = false;\r\n    /**\r\n     * The sound track id this sound belongs to.\r\n     */\r\n    public soundTrackId: number;\r\n    /**\r\n     * Is this sound currently played.\r\n     */\r\n    public isPlaying: boolean = false;\r\n    /**\r\n     * Is this sound currently paused.\r\n     */\r\n    public isPaused: boolean = false;\r\n    /**\r\n     * Define the reference distance the sound should be heard perfectly.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public refDistance: number = 1;\r\n    /**\r\n     * Define the roll off factor of spatial sounds.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public rolloffFactor: number = 1;\r\n    /**\r\n     * Define the max distance the sound should be heard (intensity just became 0 at this point).\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public maxDistance: number = 100;\r\n    /**\r\n     * Define the distance attenuation model the sound will follow.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public distanceModel: string = \"linear\";\r\n    /**\r\n     * @internal\r\n     * Back Compat\r\n     **/\r\n    public onended: () => any;\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the sound.\r\n     */\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * Observable event when the current playing sound finishes.\r\n     */\r\n    public onEndedObservable = new Observable<Sound>();\r\n\r\n    /**\r\n     * Gets the current time for the sound.\r\n     */\r\n    public get currentTime(): number {\r\n        if (this._htmlAudioElement) {\r\n            return this._htmlAudioElement.currentTime;\r\n        }\r\n\r\n        if (Engine.audioEngine?.audioContext && (this.isPlaying || this.isPaused)) {\r\n            // The `_currentTime` member is only updated when the sound is paused. Add the time since the last start\r\n            // to get the actual current time.\r\n            const timeSinceLastStart = this.isPaused ? 0 : Engine.audioEngine.audioContext.currentTime - this._startTime;\r\n            return this._currentTime + timeSinceLastStart;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Does this sound enables spatial sound.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public get spatialSound(): boolean {\r\n        return this._spatialSound;\r\n    }\r\n\r\n    /**\r\n     * Does this sound enables spatial sound.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public set spatialSound(newValue: boolean) {\r\n        if (newValue == this._spatialSound) {\r\n            return;\r\n        }\r\n\r\n        const wasPlaying = this.isPlaying;\r\n        this.pause();\r\n\r\n        if (newValue) {\r\n            this._spatialSound = newValue;\r\n            this._updateSpatialParameters();\r\n        } else {\r\n            this._disableSpatialSound();\r\n        }\r\n\r\n        if (wasPlaying) {\r\n            this.play();\r\n        }\r\n    }\r\n\r\n    private _spatialSound: boolean = false;\r\n    private _panningModel: string = \"equalpower\";\r\n    private _playbackRate: number = 1;\r\n    private _streaming: boolean = false;\r\n    private _startTime: number = 0;\r\n    private _currentTime: number = 0;\r\n    private _position: Vector3 = Vector3.Zero();\r\n    private _localDirection: Vector3 = new Vector3(1, 0, 0);\r\n    private _volume: number = 1;\r\n    private _isReadyToPlay: boolean = false;\r\n    private _isDirectional: boolean = false;\r\n    private _readyToPlayCallback: Nullable<() => any>;\r\n    private _audioBuffer: Nullable<AudioBuffer>;\r\n    private _soundSource: Nullable<AudioBufferSourceNode>;\r\n    private _streamingSource: AudioNode;\r\n    private _soundPanner: Nullable<PannerNode>;\r\n    private _soundGain: Nullable<GainNode>;\r\n    private _inputAudioNode: Nullable<AudioNode>;\r\n    private _outputAudioNode: Nullable<AudioNode>;\r\n    // Used if you'd like to create a directional sound.\r\n    // If not set, the sound will be omnidirectional\r\n    private _coneInnerAngle: number = 360;\r\n    private _coneOuterAngle: number = 360;\r\n    private _coneOuterGain: number = 0;\r\n    private _scene: Scene;\r\n    private _connectedTransformNode: Nullable<TransformNode>;\r\n    private _customAttenuationFunction: (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => number;\r\n    private _registerFunc: Nullable<(connectedMesh: TransformNode) => void>;\r\n    private _isOutputConnected = false;\r\n    private _htmlAudioElement: HTMLAudioElement;\r\n    private _urlType: \"Unknown\" | \"String\" | \"Array\" | \"ArrayBuffer\" | \"MediaStream\" | \"AudioBuffer\" | \"MediaElement\" = \"Unknown\";\r\n    private _length?: number;\r\n    private _offset?: number;\r\n    private _tryToPlayTimeout: Nullable<NodeJS.Timeout>;\r\n    private _audioUnlockedObserver?: Nullable<Observer<IAudioEngine>>;\r\n    private _url?: Nullable<string>;\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"AudioSceneComponent\");\r\n    };\r\n\r\n    /**\r\n     * Create a sound and attach it to a scene\r\n     * @param name Name of your sound\r\n     * @param urlOrArrayBuffer Url to the sound to load async or ArrayBuffer, it also works with MediaStreams and AudioBuffers\r\n     * @param scene defines the scene the sound belongs to\r\n     * @param readyToPlayCallback Provide a callback function if you'd like to load your code once the sound is ready to be played\r\n     * @param options Objects to provide with the current available options: autoplay, loop, volume, spatialSound, maxDistance, rolloffFactor, refDistance, distanceModel, panningModel, streaming\r\n     */\r\n    constructor(name: string, urlOrArrayBuffer: any, scene?: Nullable<Scene>, readyToPlayCallback: Nullable<() => void> = null, options?: ISoundOptions) {\r\n        this.name = name;\r\n        scene = scene || EngineStore.LastCreatedScene;\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this._scene = scene;\r\n        Sound._SceneComponentInitialization(scene);\r\n\r\n        this._readyToPlayCallback = readyToPlayCallback;\r\n        // Default custom attenuation function is a linear attenuation\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        this._customAttenuationFunction = (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => {\r\n            if (currentDistance < maxDistance) {\r\n                return currentVolume * (1 - currentDistance / maxDistance);\r\n            } else {\r\n                return 0;\r\n            }\r\n        };\r\n        if (options) {\r\n            this.autoplay = options.autoplay || false;\r\n            this._loop = options.loop || false;\r\n            // if volume === 0, we need another way to check this option\r\n            if (options.volume !== undefined) {\r\n                this._volume = options.volume;\r\n            }\r\n            this._spatialSound = options.spatialSound ?? false;\r\n            this.maxDistance = options.maxDistance ?? 100;\r\n            this.useCustomAttenuation = options.useCustomAttenuation ?? false;\r\n            this.rolloffFactor = options.rolloffFactor || 1;\r\n            this.refDistance = options.refDistance || 1;\r\n            this.distanceModel = options.distanceModel || \"linear\";\r\n            this._playbackRate = options.playbackRate || 1;\r\n            this._streaming = options.streaming ?? false;\r\n            this._length = options.length;\r\n            this._offset = options.offset;\r\n        }\r\n\r\n        if (Engine.audioEngine?.canUseWebAudio && Engine.audioEngine.audioContext) {\r\n            this._soundGain = Engine.audioEngine.audioContext.createGain();\r\n            this._soundGain!.gain.value = this._volume;\r\n            this._inputAudioNode = this._soundGain;\r\n            this._outputAudioNode = this._soundGain;\r\n            if (this._spatialSound) {\r\n                this._createSpatialParameters();\r\n            }\r\n            this._scene.mainSoundTrack.addSound(this);\r\n            let validParameter = true;\r\n\r\n            // if no parameter is passed, you need to call setAudioBuffer yourself to prepare the sound\r\n            if (urlOrArrayBuffer) {\r\n                try {\r\n                    if (typeof urlOrArrayBuffer === \"string\") {\r\n                        this._urlType = \"String\";\r\n                        this._url = urlOrArrayBuffer;\r\n                    } else if (urlOrArrayBuffer instanceof ArrayBuffer) {\r\n                        this._urlType = \"ArrayBuffer\";\r\n                    } else if (urlOrArrayBuffer instanceof HTMLMediaElement) {\r\n                        this._urlType = \"MediaElement\";\r\n                    } else if (urlOrArrayBuffer instanceof MediaStream) {\r\n                        this._urlType = \"MediaStream\";\r\n                    } else if (urlOrArrayBuffer instanceof AudioBuffer) {\r\n                        this._urlType = \"AudioBuffer\";\r\n                    } else if (Array.isArray(urlOrArrayBuffer)) {\r\n                        this._urlType = \"Array\";\r\n                    }\r\n\r\n                    let urls: string[] = [];\r\n                    let codecSupportedFound = false;\r\n\r\n                    switch (this._urlType) {\r\n                        case \"MediaElement\":\r\n                            this._streaming = true;\r\n                            this._isReadyToPlay = true;\r\n                            this._streamingSource = Engine.audioEngine.audioContext.createMediaElementSource(urlOrArrayBuffer);\r\n\r\n                            if (this.autoplay) {\r\n                                this.play(0, this._offset, this._length);\r\n                            }\r\n\r\n                            if (this._readyToPlayCallback) {\r\n                                this._readyToPlayCallback();\r\n                            }\r\n                            break;\r\n                        case \"MediaStream\":\r\n                            this._streaming = true;\r\n                            this._isReadyToPlay = true;\r\n                            this._streamingSource = Engine.audioEngine.audioContext.createMediaStreamSource(urlOrArrayBuffer);\r\n\r\n                            if (this.autoplay) {\r\n                                this.play(0, this._offset, this._length);\r\n                            }\r\n\r\n                            if (this._readyToPlayCallback) {\r\n                                this._readyToPlayCallback();\r\n                            }\r\n                            break;\r\n                        case \"ArrayBuffer\":\r\n                            if ((<ArrayBuffer>urlOrArrayBuffer).byteLength > 0) {\r\n                                codecSupportedFound = true;\r\n                                this._soundLoaded(urlOrArrayBuffer);\r\n                            }\r\n                            break;\r\n                        case \"AudioBuffer\":\r\n                            this._audioBufferLoaded(urlOrArrayBuffer);\r\n                            break;\r\n                        case \"String\":\r\n                            urls.push(urlOrArrayBuffer);\r\n                        // eslint-disable-next-line no-fallthrough\r\n                        case \"Array\":\r\n                            if (urls.length === 0) {\r\n                                urls = urlOrArrayBuffer;\r\n                            }\r\n                            // If we found a supported format, we load it immediately and stop the loop\r\n                            for (let i = 0; i < urls.length; i++) {\r\n                                const url = urls[i];\r\n                                codecSupportedFound =\r\n                                    (options && options.skipCodecCheck) ||\r\n                                    (url.indexOf(\".mp3\", url.length - 4) !== -1 && Engine.audioEngine.isMP3supported) ||\r\n                                    (url.indexOf(\".ogg\", url.length - 4) !== -1 && Engine.audioEngine.isOGGsupported) ||\r\n                                    url.indexOf(\".wav\", url.length - 4) !== -1 ||\r\n                                    url.indexOf(\".m4a\", url.length - 4) !== -1 ||\r\n                                    url.indexOf(\".mp4\", url.length - 4) !== -1 ||\r\n                                    url.indexOf(\"blob:\") !== -1;\r\n                                if (codecSupportedFound) {\r\n                                    // Loading sound\r\n                                    if (!this._streaming) {\r\n                                        this._scene._loadFile(\r\n                                            url,\r\n                                            (data) => {\r\n                                                this._soundLoaded(data as ArrayBuffer);\r\n                                            },\r\n                                            undefined,\r\n                                            true,\r\n                                            true,\r\n                                            (exception) => {\r\n                                                if (exception) {\r\n                                                    Logger.Error(\"XHR \" + exception.status + \" error on: \" + url + \".\");\r\n                                                }\r\n                                                Logger.Error(\"Sound creation aborted.\");\r\n                                                this._scene.mainSoundTrack.removeSound(this);\r\n                                            }\r\n                                        );\r\n                                    }\r\n                                    // Streaming sound using HTML5 Audio tag\r\n                                    else {\r\n                                        this._htmlAudioElement = new Audio(url);\r\n                                        this._htmlAudioElement.controls = false;\r\n                                        this._htmlAudioElement.loop = this.loop;\r\n                                        Tools.SetCorsBehavior(url, this._htmlAudioElement);\r\n                                        this._htmlAudioElement.preload = \"auto\";\r\n                                        this._htmlAudioElement.addEventListener(\"canplaythrough\", () => {\r\n                                            this._isReadyToPlay = true;\r\n                                            if (this.autoplay) {\r\n                                                this.play(0, this._offset, this._length);\r\n                                            }\r\n                                            if (this._readyToPlayCallback) {\r\n                                                this._readyToPlayCallback();\r\n                                            }\r\n                                        });\r\n                                        document.body.appendChild(this._htmlAudioElement);\r\n                                        this._htmlAudioElement.load();\r\n                                    }\r\n                                    break;\r\n                                }\r\n                            }\r\n                            break;\r\n                        default:\r\n                            validParameter = false;\r\n                            break;\r\n                    }\r\n\r\n                    if (!validParameter) {\r\n                        Logger.Error(\"Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.\");\r\n                    } else {\r\n                        if (!codecSupportedFound) {\r\n                            this._isReadyToPlay = true;\r\n                            // Simulating a ready to play event to avoid breaking code path\r\n                            if (this._readyToPlayCallback) {\r\n                                setTimeout(() => {\r\n                                    if (this._readyToPlayCallback) {\r\n                                        this._readyToPlayCallback();\r\n                                    }\r\n                                }, 1000);\r\n                            }\r\n                        }\r\n                    }\r\n                } catch (ex) {\r\n                    Logger.Error(\"Unexpected error. Sound creation aborted.\");\r\n                    this._scene.mainSoundTrack.removeSound(this);\r\n                }\r\n            }\r\n        } else {\r\n            // Adding an empty sound to avoid breaking audio calls for non Web Audio browsers\r\n            this._scene.mainSoundTrack.addSound(this);\r\n            if (Engine.audioEngine && !Engine.audioEngine.WarnedWebAudioUnsupported) {\r\n                Logger.Error(\"Web Audio is not supported by your browser.\");\r\n                Engine.audioEngine.WarnedWebAudioUnsupported = true;\r\n            }\r\n            // Simulating a ready to play event to avoid breaking code for non web audio browsers\r\n            if (this._readyToPlayCallback) {\r\n                setTimeout(() => {\r\n                    if (this._readyToPlayCallback) {\r\n                        this._readyToPlayCallback();\r\n                    }\r\n                }, 1000);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release the sound and its associated resources\r\n     */\r\n    public dispose() {\r\n        if (Engine.audioEngine?.canUseWebAudio) {\r\n            if (this.isPlaying) {\r\n                this.stop();\r\n            }\r\n            this._isReadyToPlay = false;\r\n            if (this.soundTrackId === -1) {\r\n                this._scene.mainSoundTrack.removeSound(this);\r\n            } else if (this._scene.soundTracks) {\r\n                this._scene.soundTracks[this.soundTrackId].removeSound(this);\r\n            }\r\n            if (this._soundGain) {\r\n                this._soundGain.disconnect();\r\n                this._soundGain = null;\r\n            }\r\n            if (this._soundPanner) {\r\n                this._soundPanner.disconnect();\r\n                this._soundPanner = null;\r\n            }\r\n            if (this._soundSource) {\r\n                this._soundSource.disconnect();\r\n                this._soundSource = null;\r\n            }\r\n            this._audioBuffer = null;\r\n\r\n            if (this._htmlAudioElement) {\r\n                this._htmlAudioElement.pause();\r\n                this._htmlAudioElement.src = \"\";\r\n                document.body.removeChild(this._htmlAudioElement);\r\n            }\r\n\r\n            if (this._streamingSource) {\r\n                this._streamingSource.disconnect();\r\n            }\r\n\r\n            if (this._connectedTransformNode && this._registerFunc) {\r\n                this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n                this._connectedTransformNode = null;\r\n            }\r\n\r\n            this._clearTimeoutsAndObservers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets if the sounds is ready to be played or not.\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    public isReady(): boolean {\r\n        return this._isReadyToPlay;\r\n    }\r\n\r\n    /**\r\n     * Get the current class name.\r\n     * @returns current class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Sound\";\r\n    }\r\n\r\n    private _audioBufferLoaded(buffer: AudioBuffer) {\r\n        if (!Engine.audioEngine?.audioContext) {\r\n            return;\r\n        }\r\n        this._audioBuffer = buffer;\r\n        this._isReadyToPlay = true;\r\n        if (this.autoplay) {\r\n            this.play(0, this._offset, this._length);\r\n        }\r\n        if (this._readyToPlayCallback) {\r\n            this._readyToPlayCallback();\r\n        }\r\n    }\r\n\r\n    private _soundLoaded(audioData: ArrayBuffer) {\r\n        if (!Engine.audioEngine?.audioContext) {\r\n            return;\r\n        }\r\n        Engine.audioEngine.audioContext.decodeAudioData(\r\n            audioData,\r\n            (buffer) => {\r\n                this._audioBufferLoaded(buffer);\r\n            },\r\n            (err: any) => {\r\n                Logger.Error(\"Error while decoding audio data for: \" + this.name + \" / Error: \" + err);\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Sets the data of the sound from an audiobuffer\r\n     * @param audioBuffer The audioBuffer containing the data\r\n     */\r\n    public setAudioBuffer(audioBuffer: AudioBuffer): void {\r\n        if (Engine.audioEngine?.canUseWebAudio) {\r\n            this._audioBuffer = audioBuffer;\r\n            this._isReadyToPlay = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the current sounds options such as maxdistance, loop...\r\n     * @param options A JSON object containing values named as the object properties\r\n     */\r\n    public updateOptions(options: ISoundOptions): void {\r\n        if (options) {\r\n            this.loop = options.loop ?? this.loop;\r\n            this.maxDistance = options.maxDistance ?? this.maxDistance;\r\n            this.useCustomAttenuation = options.useCustomAttenuation ?? this.useCustomAttenuation;\r\n            this.rolloffFactor = options.rolloffFactor ?? this.rolloffFactor;\r\n            this.refDistance = options.refDistance ?? this.refDistance;\r\n            this.distanceModel = options.distanceModel ?? this.distanceModel;\r\n            this._playbackRate = options.playbackRate ?? this._playbackRate;\r\n            this._length = options.length ?? undefined;\r\n            this.spatialSound = options.spatialSound ?? this._spatialSound;\r\n            this._setOffset(options.offset ?? undefined);\r\n            this.setVolume(options.volume ?? this._volume);\r\n            this._updateSpatialParameters();\r\n            if (this.isPlaying) {\r\n                if (this._streaming && this._htmlAudioElement) {\r\n                    this._htmlAudioElement.playbackRate = this._playbackRate;\r\n                    if (this._htmlAudioElement.loop !== this.loop) {\r\n                        this._htmlAudioElement.loop = this.loop;\r\n                    }\r\n                } else {\r\n                    if (this._soundSource) {\r\n                        this._soundSource.playbackRate.value = this._playbackRate;\r\n                        if (this._soundSource.loop !== this.loop) {\r\n                            this._soundSource.loop = this.loop;\r\n                        }\r\n                        if (this._offset !== undefined && this._soundSource.loopStart !== this._offset) {\r\n                            this._soundSource.loopStart = this._offset;\r\n                        }\r\n                        if (this._length !== undefined && this._length !== this._soundSource.loopEnd) {\r\n                            this._soundSource.loopEnd = (this._offset! | 0) + this._length!;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _createSpatialParameters() {\r\n        if (Engine.audioEngine?.canUseWebAudio && Engine.audioEngine.audioContext) {\r\n            if (this._scene.headphone) {\r\n                this._panningModel = \"HRTF\";\r\n            }\r\n            this._soundPanner = this._soundPanner ?? Engine.audioEngine.audioContext.createPanner();\r\n            if (this._soundPanner && this._outputAudioNode) {\r\n                this._updateSpatialParameters();\r\n                this._soundPanner.connect(this._outputAudioNode);\r\n                this._inputAudioNode = this._soundPanner;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _disableSpatialSound() {\r\n        if (!this._spatialSound) {\r\n            return;\r\n        }\r\n        this._inputAudioNode = this._soundGain;\r\n        this._soundPanner?.disconnect();\r\n        this._soundPanner = null;\r\n        this._spatialSound = false;\r\n    }\r\n\r\n    private _updateSpatialParameters() {\r\n        if (!this._spatialSound) {\r\n            return;\r\n        }\r\n        if (this._soundPanner) {\r\n            if (this.useCustomAttenuation) {\r\n                // Tricks to disable in a way embedded Web Audio attenuation\r\n                this._soundPanner.distanceModel = \"linear\";\r\n                this._soundPanner.maxDistance = Number.MAX_VALUE;\r\n                this._soundPanner.refDistance = 1;\r\n                this._soundPanner.rolloffFactor = 1;\r\n                this._soundPanner.panningModel = this._panningModel as any;\r\n            } else {\r\n                this._soundPanner.distanceModel = this.distanceModel as any;\r\n                this._soundPanner.maxDistance = this.maxDistance;\r\n                this._soundPanner.refDistance = this.refDistance;\r\n                this._soundPanner.rolloffFactor = this.rolloffFactor;\r\n                this._soundPanner.panningModel = this._panningModel as any;\r\n            }\r\n        } else {\r\n            this._createSpatialParameters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to HRTF:\r\n     * Renders a stereo output of higher quality than equalpower — it uses a convolution with measured impulse responses from human subjects.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToHRTF() {\r\n        this._panningModel = \"HRTF\";\r\n        this._switchPanningModel();\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to Equal Power:\r\n     * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToEqualPower() {\r\n        this._panningModel = \"equalpower\";\r\n        this._switchPanningModel();\r\n    }\r\n\r\n    private _switchPanningModel() {\r\n        if (Engine.audioEngine?.canUseWebAudio && this._spatialSound && this._soundPanner) {\r\n            this._soundPanner.panningModel = this._panningModel as any;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Connect this sound to a sound track audio node like gain...\r\n     * @param soundTrackAudioNode the sound track audio node to connect to\r\n     */\r\n    public connectToSoundTrackAudioNode(soundTrackAudioNode: AudioNode): void {\r\n        if (Engine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\r\n            if (this._isOutputConnected) {\r\n                this._outputAudioNode.disconnect();\r\n            }\r\n            this._outputAudioNode.connect(soundTrackAudioNode);\r\n            this._isOutputConnected = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transform this sound into a directional source\r\n     * @param coneInnerAngle Size of the inner cone in degree\r\n     * @param coneOuterAngle Size of the outer cone in degree\r\n     * @param coneOuterGain Volume of the sound outside the outer cone (between 0.0 and 1.0)\r\n     */\r\n    public setDirectionalCone(coneInnerAngle: number, coneOuterAngle: number, coneOuterGain: number): void {\r\n        if (coneOuterAngle < coneInnerAngle) {\r\n            Logger.Error(\"setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.\");\r\n            return;\r\n        }\r\n        this._coneInnerAngle = coneInnerAngle;\r\n        this._coneOuterAngle = coneOuterAngle;\r\n        this._coneOuterGain = coneOuterGain;\r\n        this._isDirectional = true;\r\n\r\n        if (this.isPlaying && this.loop) {\r\n            this.stop();\r\n            this.play(0, this._offset, this._length);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the inner angle for the directional cone.\r\n     */\r\n    public get directionalConeInnerAngle(): number {\r\n        return this._coneInnerAngle;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the inner angle for the directional cone.\r\n     */\r\n    public set directionalConeInnerAngle(value: number) {\r\n        if (value != this._coneInnerAngle) {\r\n            if (this._coneOuterAngle < value) {\r\n                Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                return;\r\n            }\r\n\r\n            this._coneInnerAngle = value;\r\n            if (Engine.audioEngine?.canUseWebAudio && this._spatialSound && this._soundPanner) {\r\n                this._soundPanner.coneInnerAngle = this._coneInnerAngle;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the outer angle for the directional cone.\r\n     */\r\n    public get directionalConeOuterAngle(): number {\r\n        return this._coneOuterAngle;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the outer angle for the directional cone.\r\n     */\r\n    public set directionalConeOuterAngle(value: number) {\r\n        if (value != this._coneOuterAngle) {\r\n            if (value < this._coneInnerAngle) {\r\n                Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                return;\r\n            }\r\n\r\n            this._coneOuterAngle = value;\r\n            if (Engine.audioEngine?.canUseWebAudio && this._spatialSound && this._soundPanner) {\r\n                this._soundPanner.coneOuterAngle = this._coneOuterAngle;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the position of the emitter if spatial sound is enabled\r\n     * @param newPosition Defines the new position\r\n     */\r\n    public setPosition(newPosition: Vector3): void {\r\n        if (newPosition.equals(this._position)) {\r\n            return;\r\n        }\r\n        this._position.copyFrom(newPosition);\r\n\r\n        if (Engine.audioEngine?.canUseWebAudio && this._spatialSound && this._soundPanner && !isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {\r\n            this._soundPanner.positionX.value = this._position.x;\r\n            this._soundPanner.positionY.value = this._position.y;\r\n            this._soundPanner.positionZ.value = this._position.z;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the local direction of the emitter if spatial sound is enabled\r\n     * @param newLocalDirection Defines the new local direction\r\n     */\r\n    public setLocalDirectionToMesh(newLocalDirection: Vector3): void {\r\n        this._localDirection = newLocalDirection;\r\n\r\n        if (Engine.audioEngine?.canUseWebAudio && this._connectedTransformNode && this.isPlaying) {\r\n            this._updateDirection();\r\n        }\r\n    }\r\n\r\n    private _updateDirection() {\r\n        if (!this._connectedTransformNode || !this._soundPanner) {\r\n            return;\r\n        }\r\n\r\n        const mat = this._connectedTransformNode.getWorldMatrix();\r\n        const direction = Vector3.TransformNormal(this._localDirection, mat);\r\n        direction.normalize();\r\n        this._soundPanner.orientationX.value = direction.x;\r\n        this._soundPanner.orientationY.value = direction.y;\r\n        this._soundPanner.orientationZ.value = direction.z;\r\n    }\r\n\r\n    /** @internal */\r\n    public updateDistanceFromListener() {\r\n        if (Engine.audioEngine?.canUseWebAudio && this._connectedTransformNode && this.useCustomAttenuation && this._soundGain && this._scene.activeCamera) {\r\n            const distance = this._scene.audioListenerPositionProvider\r\n                ? this._connectedTransformNode.position.subtract(this._scene.audioListenerPositionProvider()).length()\r\n                : this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);\r\n            this._soundGain.gain.value = this._customAttenuationFunction(this._volume, distance, this.maxDistance, this.refDistance, this.rolloffFactor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a new custom attenuation function for the sound.\r\n     * @param callback Defines the function used for the attenuation\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-your-own-custom-attenuation-function\r\n     */\r\n    public setAttenuationFunction(callback: (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => number): void {\r\n        this._customAttenuationFunction = callback;\r\n    }\r\n\r\n    /**\r\n     * Play the sound\r\n     * @param time (optional) Start the sound after X seconds. Start immediately (0) by default.\r\n     * @param offset (optional) Start the sound at a specific time in seconds\r\n     * @param length (optional) Sound duration (in seconds)\r\n     */\r\n    public play(time?: number, offset?: number, length?: number): void {\r\n        if (this._isReadyToPlay && this._scene.audioEnabled && Engine.audioEngine?.audioContext) {\r\n            try {\r\n                this._clearTimeoutsAndObservers();\r\n\r\n                let startTime = time ? Engine.audioEngine?.audioContext.currentTime + time : Engine.audioEngine?.audioContext.currentTime;\r\n                if (!this._soundSource || !this._streamingSource) {\r\n                    if (this._spatialSound && this._soundPanner) {\r\n                        if (!isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {\r\n                            this._soundPanner.positionX.value = this._position.x;\r\n                            this._soundPanner.positionY.value = this._position.y;\r\n                            this._soundPanner.positionZ.value = this._position.z;\r\n                        }\r\n                        if (this._isDirectional) {\r\n                            this._soundPanner.coneInnerAngle = this._coneInnerAngle;\r\n                            this._soundPanner.coneOuterAngle = this._coneOuterAngle;\r\n                            this._soundPanner.coneOuterGain = this._coneOuterGain;\r\n                            if (this._connectedTransformNode) {\r\n                                this._updateDirection();\r\n                            } else {\r\n                                this._soundPanner.setOrientation(this._localDirection.x, this._localDirection.y, this._localDirection.z);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (this._streaming) {\r\n                    if (!this._streamingSource) {\r\n                        this._streamingSource = Engine.audioEngine.audioContext.createMediaElementSource(this._htmlAudioElement);\r\n                        this._htmlAudioElement.onended = () => {\r\n                            this._onended();\r\n                        };\r\n                        this._htmlAudioElement.playbackRate = this._playbackRate;\r\n                    }\r\n                    this._streamingSource.disconnect();\r\n                    if (this._inputAudioNode) {\r\n                        this._streamingSource.connect(this._inputAudioNode);\r\n                    }\r\n                    if (this._htmlAudioElement) {\r\n                        // required to manage properly the new suspended default state of Chrome\r\n                        // When the option 'streaming: true' is used, we need first to wait for\r\n                        // the audio engine to be unlocked by a user gesture before trying to play\r\n                        // an HTML Audio element\r\n                        const tryToPlay = () => {\r\n                            if (Engine.audioEngine?.unlocked) {\r\n                                const playPromise = this._htmlAudioElement.play();\r\n\r\n                                // In browsers that don’t yet support this functionality,\r\n                                // playPromise won’t be defined.\r\n                                if (playPromise !== undefined) {\r\n                                    playPromise.catch(() => {\r\n                                        // Automatic playback failed.\r\n                                        // Waiting for the audio engine to be unlocked by user click on unmute\r\n                                        Engine.audioEngine?.lock();\r\n                                        if (this.loop || this.autoplay) {\r\n                                            this._audioUnlockedObserver = Engine.audioEngine?.onAudioUnlockedObservable.addOnce(() => {\r\n                                                tryToPlay();\r\n                                            });\r\n                                        }\r\n                                    });\r\n                                }\r\n                            } else {\r\n                                if (this.loop || this.autoplay) {\r\n                                    this._audioUnlockedObserver = Engine.audioEngine?.onAudioUnlockedObservable.addOnce(() => {\r\n                                        tryToPlay();\r\n                                    });\r\n                                }\r\n                            }\r\n                        };\r\n                        tryToPlay();\r\n                    }\r\n                } else {\r\n                    const tryToPlay = () => {\r\n                        if (Engine.audioEngine?.audioContext) {\r\n                            length = length || this._length;\r\n\r\n                            if (offset !== undefined) {\r\n                                this._setOffset(offset);\r\n                            }\r\n\r\n                            if (this._soundSource) {\r\n                                const oldSource = this._soundSource;\r\n                                oldSource.onended = () => {\r\n                                    oldSource.disconnect();\r\n                                };\r\n                            }\r\n                            this._soundSource = Engine.audioEngine?.audioContext.createBufferSource();\r\n                            if (this._soundSource && this._inputAudioNode) {\r\n                                this._soundSource.buffer = this._audioBuffer;\r\n                                this._soundSource.connect(this._inputAudioNode);\r\n                                this._soundSource.loop = this.loop;\r\n                                if (offset !== undefined) {\r\n                                    this._soundSource.loopStart = offset;\r\n                                }\r\n                                if (length !== undefined) {\r\n                                    this._soundSource.loopEnd = (offset! | 0) + length!;\r\n                                }\r\n                                this._soundSource.playbackRate.value = this._playbackRate;\r\n                                this._soundSource.onended = () => {\r\n                                    this._onended();\r\n                                };\r\n                                startTime = time ? Engine.audioEngine?.audioContext!.currentTime + time : Engine.audioEngine.audioContext!.currentTime;\r\n                                const actualOffset = ((this.isPaused ? this.currentTime : 0) + (this._offset ?? 0)) % this._soundSource!.buffer!.duration;\r\n                                this._soundSource!.start(startTime, actualOffset, this.loop ? undefined : length);\r\n                            }\r\n                        }\r\n                    };\r\n\r\n                    if (Engine.audioEngine?.audioContext.state === \"suspended\") {\r\n                        // Wait a bit for FF as context seems late to be ready.\r\n                        this._tryToPlayTimeout = setTimeout(() => {\r\n                            if (Engine.audioEngine?.audioContext!.state === \"suspended\") {\r\n                                // Automatic playback failed.\r\n                                // Waiting for the audio engine to be unlocked by user click on unmute\r\n                                Engine.audioEngine.lock();\r\n                                if (this.loop || this.autoplay) {\r\n                                    this._audioUnlockedObserver = Engine.audioEngine.onAudioUnlockedObservable.addOnce(() => {\r\n                                        tryToPlay();\r\n                                    });\r\n                                }\r\n                            } else {\r\n                                tryToPlay();\r\n                            }\r\n                        }, 500);\r\n                    } else {\r\n                        tryToPlay();\r\n                    }\r\n                }\r\n                this._startTime = startTime;\r\n                this.isPlaying = true;\r\n                this.isPaused = false;\r\n            } catch (ex) {\r\n                Logger.Error(\"Error while trying to play audio: \" + this.name + \", \" + ex.message);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onended() {\r\n        this.isPlaying = false;\r\n        this._startTime = 0;\r\n        this._currentTime = 0;\r\n        if (this.onended) {\r\n            this.onended();\r\n        }\r\n        this.onEndedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Stop the sound\r\n     * @param time (optional) Stop the sound after X seconds. Stop immediately (0) by default.\r\n     */\r\n    public stop(time?: number): void {\r\n        if (this.isPlaying) {\r\n            this._clearTimeoutsAndObservers();\r\n            if (this._streaming) {\r\n                if (this._htmlAudioElement) {\r\n                    this._htmlAudioElement.pause();\r\n                    // Test needed for Firefox or it will generate an Invalid State Error\r\n                    if (this._htmlAudioElement.currentTime > 0) {\r\n                        this._htmlAudioElement.currentTime = 0;\r\n                    }\r\n                } else {\r\n                    this._streamingSource.disconnect();\r\n                }\r\n                this.isPlaying = false;\r\n            } else if (Engine.audioEngine?.audioContext && this._soundSource) {\r\n                const stopTime = time ? Engine.audioEngine.audioContext.currentTime + time : undefined;\r\n                this._soundSource.onended = () => {\r\n                    this.isPlaying = false;\r\n                    this.isPaused = false;\r\n                    this._startTime = 0;\r\n                    this._currentTime = 0;\r\n                    if (this._soundSource) {\r\n                        this._soundSource.onended = () => void 0;\r\n                    }\r\n                    this._onended();\r\n                };\r\n                this._soundSource.stop(stopTime);\r\n            } else {\r\n                this.isPlaying = false;\r\n            }\r\n        } else if (this.isPaused) {\r\n            this.isPaused = false;\r\n            this._startTime = 0;\r\n            this._currentTime = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Put the sound in pause\r\n     */\r\n    public pause(): void {\r\n        if (this.isPlaying) {\r\n            this._clearTimeoutsAndObservers();\r\n            if (this._streaming) {\r\n                if (this._htmlAudioElement) {\r\n                    this._htmlAudioElement.pause();\r\n                } else {\r\n                    this._streamingSource.disconnect();\r\n                }\r\n                this.isPlaying = false;\r\n                this.isPaused = true;\r\n            } else if (Engine.audioEngine?.audioContext && this._soundSource) {\r\n                this._soundSource.onended = () => void 0;\r\n                this._soundSource.stop();\r\n                this.isPlaying = false;\r\n                this.isPaused = true;\r\n                this._currentTime += Engine.audioEngine.audioContext.currentTime - this._startTime;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a dedicated volume for this sounds\r\n     * @param newVolume Define the new volume of the sound\r\n     * @param time Define time for gradual change to new volume\r\n     */\r\n    public setVolume(newVolume: number, time?: number): void {\r\n        if (Engine.audioEngine?.canUseWebAudio && this._soundGain) {\r\n            if (time && Engine.audioEngine.audioContext) {\r\n                this._soundGain.gain.cancelScheduledValues(Engine.audioEngine.audioContext.currentTime);\r\n                this._soundGain.gain.setValueAtTime(this._soundGain.gain.value, Engine.audioEngine.audioContext.currentTime);\r\n                this._soundGain.gain.linearRampToValueAtTime(newVolume, Engine.audioEngine.audioContext.currentTime + time);\r\n            } else {\r\n                this._soundGain.gain.value = newVolume;\r\n            }\r\n        }\r\n        this._volume = newVolume;\r\n    }\r\n\r\n    /**\r\n     * Set the sound play back rate\r\n     * @param newPlaybackRate Define the playback rate the sound should be played at\r\n     */\r\n    public setPlaybackRate(newPlaybackRate: number): void {\r\n        this._playbackRate = newPlaybackRate;\r\n        if (this.isPlaying) {\r\n            if (this._streaming && this._htmlAudioElement) {\r\n                this._htmlAudioElement.playbackRate = this._playbackRate;\r\n            } else if (this._soundSource) {\r\n                this._soundSource.playbackRate.value = this._playbackRate;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the sound play back rate.\r\n     * @returns the  play back rate of the sound\r\n     */\r\n    public getPlaybackRate(): number {\r\n        return this._playbackRate;\r\n    }\r\n\r\n    /**\r\n     * Gets the volume of the sound.\r\n     * @returns the volume of the sound\r\n     */\r\n    public getVolume(): number {\r\n        return this._volume;\r\n    }\r\n\r\n    /**\r\n     * Attach the sound to a dedicated mesh\r\n     * @param transformNode The transform node to connect the sound with\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#attaching-a-sound-to-a-mesh\r\n     */\r\n    public attachToMesh(transformNode: TransformNode): void {\r\n        if (this._connectedTransformNode && this._registerFunc) {\r\n            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n            this._registerFunc = null;\r\n        }\r\n        this._connectedTransformNode = transformNode;\r\n        if (!this._spatialSound) {\r\n            this._spatialSound = true;\r\n            this._createSpatialParameters();\r\n            if (this.isPlaying && this.loop) {\r\n                this.stop();\r\n                this.play(0, this._offset, this._length);\r\n            }\r\n        }\r\n        this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode);\r\n        this._registerFunc = (transformNode: TransformNode) => this._onRegisterAfterWorldMatrixUpdate(transformNode);\r\n        this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc);\r\n    }\r\n\r\n    /**\r\n     * Detach the sound from the previously attached mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#attaching-a-sound-to-a-mesh\r\n     */\r\n    public detachFromMesh() {\r\n        if (this._connectedTransformNode && this._registerFunc) {\r\n            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n            this._registerFunc = null;\r\n            this._connectedTransformNode = null;\r\n        }\r\n    }\r\n\r\n    private _onRegisterAfterWorldMatrixUpdate(node: TransformNode): void {\r\n        if (!(<any>node).getBoundingInfo) {\r\n            this.setPosition(node.absolutePosition);\r\n        } else {\r\n            const mesh = node as AbstractMesh;\r\n            const boundingInfo = mesh.getBoundingInfo();\r\n            this.setPosition(boundingInfo.boundingSphere.centerWorld);\r\n        }\r\n        if (Engine.audioEngine?.canUseWebAudio && this._isDirectional && this.isPlaying) {\r\n            this._updateDirection();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the current sound in the scene.\r\n     * @returns the new sound clone\r\n     */\r\n    public clone(): Nullable<Sound> {\r\n        if (!this._streaming) {\r\n            const setBufferAndRun = () => {\r\n                if (this._isReadyToPlay) {\r\n                    clonedSound._audioBuffer = this.getAudioBuffer();\r\n                    clonedSound._isReadyToPlay = true;\r\n                    if (clonedSound.autoplay) {\r\n                        clonedSound.play(0, this._offset, this._length);\r\n                    }\r\n                } else {\r\n                    setTimeout(setBufferAndRun, 300);\r\n                }\r\n            };\r\n\r\n            const currentOptions = {\r\n                autoplay: this.autoplay,\r\n                loop: this.loop,\r\n                volume: this._volume,\r\n                spatialSound: this._spatialSound,\r\n                maxDistance: this.maxDistance,\r\n                useCustomAttenuation: this.useCustomAttenuation,\r\n                rolloffFactor: this.rolloffFactor,\r\n                refDistance: this.refDistance,\r\n                distanceModel: this.distanceModel,\r\n            };\r\n\r\n            const clonedSound = new Sound(this.name + \"_cloned\", new ArrayBuffer(0), this._scene, null, currentOptions);\r\n            if (this.useCustomAttenuation) {\r\n                clonedSound.setAttenuationFunction(this._customAttenuationFunction);\r\n            }\r\n            clonedSound.setPosition(this._position);\r\n            clonedSound.setPlaybackRate(this._playbackRate);\r\n            setBufferAndRun();\r\n\r\n            return clonedSound;\r\n        }\r\n        // Can't clone a streaming sound\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current underlying audio buffer containing the data\r\n     * @returns the audio buffer\r\n     */\r\n    public getAudioBuffer(): Nullable<AudioBuffer> {\r\n        return this._audioBuffer;\r\n    }\r\n\r\n    /**\r\n     * Gets the WebAudio AudioBufferSourceNode, lets you keep track of and stop instances of this Sound.\r\n     * @returns the source node\r\n     */\r\n    public getSoundSource(): Nullable<AudioBufferSourceNode> {\r\n        return this._soundSource;\r\n    }\r\n\r\n    /**\r\n     * Gets the WebAudio GainNode, gives you precise control over the gain of instances of this Sound.\r\n     * @returns the gain node\r\n     */\r\n    public getSoundGain(): Nullable<GainNode> {\r\n        return this._soundGain;\r\n    }\r\n\r\n    /**\r\n     * Serializes the Sound in a JSON representation\r\n     * @returns the JSON representation of the sound\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {\r\n            name: this.name,\r\n            url: this._url,\r\n            autoplay: this.autoplay,\r\n            loop: this.loop,\r\n            volume: this._volume,\r\n            spatialSound: this._spatialSound,\r\n            maxDistance: this.maxDistance,\r\n            rolloffFactor: this.rolloffFactor,\r\n            refDistance: this.refDistance,\r\n            distanceModel: this.distanceModel,\r\n            playbackRate: this._playbackRate,\r\n            panningModel: this._panningModel,\r\n            soundTrackId: this.soundTrackId,\r\n            metadata: this.metadata,\r\n        };\r\n\r\n        if (this._spatialSound) {\r\n            if (this._connectedTransformNode) {\r\n                serializationObject.connectedMeshId = this._connectedTransformNode.id;\r\n            }\r\n\r\n            serializationObject.position = this._position.asArray();\r\n            serializationObject.refDistance = this.refDistance;\r\n            serializationObject.distanceModel = this.distanceModel;\r\n\r\n            serializationObject.isDirectional = this._isDirectional;\r\n            serializationObject.localDirectionToMesh = this._localDirection.asArray();\r\n            serializationObject.coneInnerAngle = this._coneInnerAngle;\r\n            serializationObject.coneOuterAngle = this._coneOuterAngle;\r\n            serializationObject.coneOuterGain = this._coneOuterGain;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse a JSON representation of a sound to instantiate in a given scene\r\n     * @param parsedSound Define the JSON representation of the sound (usually coming from the serialize method)\r\n     * @param scene Define the scene the new parsed sound should be created in\r\n     * @param rootUrl Define the rooturl of the load in case we need to fetch relative dependencies\r\n     * @param sourceSound Define a sound place holder if do not need to instantiate a new one\r\n     * @returns the newly parsed sound\r\n     */\r\n    public static Parse(parsedSound: any, scene: Scene, rootUrl: string, sourceSound?: Sound): Sound {\r\n        const soundName = parsedSound.name;\r\n        let soundUrl;\r\n\r\n        if (parsedSound.url) {\r\n            soundUrl = rootUrl + parsedSound.url;\r\n        } else {\r\n            soundUrl = rootUrl + soundName;\r\n        }\r\n\r\n        const options = {\r\n            autoplay: parsedSound.autoplay,\r\n            loop: parsedSound.loop,\r\n            volume: parsedSound.volume,\r\n            spatialSound: parsedSound.spatialSound,\r\n            maxDistance: parsedSound.maxDistance,\r\n            rolloffFactor: parsedSound.rolloffFactor,\r\n            refDistance: parsedSound.refDistance,\r\n            distanceModel: parsedSound.distanceModel,\r\n            playbackRate: parsedSound.playbackRate,\r\n        };\r\n\r\n        let newSound: Sound;\r\n\r\n        if (!sourceSound) {\r\n            newSound = new Sound(\r\n                soundName,\r\n                soundUrl,\r\n                scene,\r\n                () => {\r\n                    scene.removePendingData(newSound);\r\n                },\r\n                options\r\n            );\r\n            scene.addPendingData(newSound);\r\n        } else {\r\n            const setBufferAndRun = () => {\r\n                if (sourceSound._isReadyToPlay) {\r\n                    newSound._audioBuffer = sourceSound.getAudioBuffer();\r\n                    newSound._isReadyToPlay = true;\r\n                    if (newSound.autoplay) {\r\n                        newSound.play(0, newSound._offset, newSound._length);\r\n                    }\r\n                } else {\r\n                    setTimeout(setBufferAndRun, 300);\r\n                }\r\n            };\r\n\r\n            newSound = new Sound(soundName, new ArrayBuffer(0), scene, null, options);\r\n            setBufferAndRun();\r\n        }\r\n\r\n        if (parsedSound.position) {\r\n            const soundPosition = Vector3.FromArray(parsedSound.position);\r\n            newSound.setPosition(soundPosition);\r\n        }\r\n        if (parsedSound.isDirectional) {\r\n            newSound.setDirectionalCone(parsedSound.coneInnerAngle || 360, parsedSound.coneOuterAngle || 360, parsedSound.coneOuterGain || 0);\r\n            if (parsedSound.localDirectionToMesh) {\r\n                const localDirectionToMesh = Vector3.FromArray(parsedSound.localDirectionToMesh);\r\n                newSound.setLocalDirectionToMesh(localDirectionToMesh);\r\n            }\r\n        }\r\n        if (parsedSound.connectedMeshId) {\r\n            const connectedMesh = scene.getMeshById(parsedSound.connectedMeshId);\r\n            if (connectedMesh) {\r\n                newSound.attachToMesh(connectedMesh);\r\n            }\r\n        }\r\n\r\n        if (parsedSound.metadata) {\r\n            newSound.metadata = parsedSound.metadata;\r\n        }\r\n\r\n        return newSound;\r\n    }\r\n\r\n    private _setOffset(value?: number) {\r\n        if (this._offset === value) {\r\n            return;\r\n        }\r\n        if (this.isPaused) {\r\n            this.stop();\r\n            this.isPaused = false;\r\n        }\r\n        this._offset = value;\r\n    }\r\n\r\n    private _clearTimeoutsAndObservers() {\r\n        if (this._tryToPlayTimeout) {\r\n            clearTimeout(this._tryToPlayTimeout);\r\n            this._tryToPlayTimeout = null;\r\n        }\r\n        if (this._audioUnlockedObserver) {\r\n            Engine.audioEngine?.onAudioUnlockedObservable.remove(this._audioUnlockedObserver);\r\n            this._audioUnlockedObserver = null;\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}