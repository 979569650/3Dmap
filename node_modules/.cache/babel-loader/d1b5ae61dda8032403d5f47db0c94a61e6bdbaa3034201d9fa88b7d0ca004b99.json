{"ast":null,"code":"import \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { AutoReleaseWorkerPool } from \"./workerPool.js\";\nimport { Tools } from \"./tools.js\";\nimport { EngineFormat, TranscodeTarget } from \"../Materials/Textures/ktx2decoderTypes.js\";\nfunction applyConfig(urls) {\n  if (urls.wasmUASTCToASTC) {\n    KTX2DECODER.LiteTranscoder_UASTC_ASTC.WasmModuleURL = urls.wasmUASTCToASTC;\n  }\n  if (urls.wasmUASTCToBC7) {\n    KTX2DECODER.LiteTranscoder_UASTC_BC7.WasmModuleURL = urls.wasmUASTCToBC7;\n  }\n  if (urls.wasmUASTCToRGBA_UNORM) {\n    KTX2DECODER.LiteTranscoder_UASTC_RGBA_UNORM.WasmModuleURL = urls.wasmUASTCToRGBA_UNORM;\n  }\n  if (urls.wasmUASTCToRGBA_SRGB) {\n    KTX2DECODER.LiteTranscoder_UASTC_RGBA_SRGB.WasmModuleURL = urls.wasmUASTCToRGBA_SRGB;\n  }\n  if (urls.wasmUASTCToR8_UNORM) {\n    KTX2DECODER.LiteTranscoder_UASTC_R8_UNORM.WasmModuleURL = urls.wasmUASTCToR8_UNORM;\n  }\n  if (urls.wasmUASTCToRG8_UNORM) {\n    KTX2DECODER.LiteTranscoder_UASTC_RG8_UNORM.WasmModuleURL = urls.wasmUASTCToRG8_UNORM;\n  }\n  if (urls.jsMSCTranscoder) {\n    KTX2DECODER.MSCTranscoder.JSModuleURL = urls.jsMSCTranscoder;\n  }\n  if (urls.wasmMSCTranscoder) {\n    KTX2DECODER.MSCTranscoder.WasmModuleURL = urls.wasmMSCTranscoder;\n  }\n  if (urls.wasmZSTDDecoder) {\n    KTX2DECODER.ZSTDDecoder.WasmModuleURL = urls.wasmZSTDDecoder;\n  }\n}\n/**\n * Class that defines the default KTX2 decoder options.\n *\n * This class is useful for providing options to the KTX2 decoder to control how the source data is transcoded.\n */\nexport class DefaultKTX2DecoderOptions {\n  constructor() {\n    this._isDirty = true;\n    this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC = true;\n    this._ktx2DecoderOptions = {};\n  }\n  /**\n   * Gets the dirty flag\n   */\n  get isDirty() {\n    return this._isDirty;\n  }\n  /**\n   * force a (uncompressed) RGBA transcoded format if transcoding a UASTC source format and ASTC + BC7 are not available as a compressed transcoded format\n   */\n  get useRGBAIfASTCBC7NotAvailableWhenUASTC() {\n    return this._useRGBAIfASTCBC7NotAvailableWhenUASTC;\n  }\n  set useRGBAIfASTCBC7NotAvailableWhenUASTC(value) {\n    if (this._useRGBAIfASTCBC7NotAvailableWhenUASTC === value) {\n      return;\n    }\n    this._useRGBAIfASTCBC7NotAvailableWhenUASTC = value;\n    this._isDirty = true;\n  }\n  /**\n   * force a (uncompressed) RGBA transcoded format if transcoding a UASTC source format and only BC1 or BC3 are available as a compressed transcoded format.\n   * This property is true by default to favor speed over memory, because currently transcoding from UASTC to BC1/3 is slow because the transcoder transcodes\n   * to uncompressed and then recompresses the texture\n   */\n  get useRGBAIfOnlyBC1BC3AvailableWhenUASTC() {\n    return this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC;\n  }\n  set useRGBAIfOnlyBC1BC3AvailableWhenUASTC(value) {\n    if (this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC === value) {\n      return;\n    }\n    this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC = value;\n    this._isDirty = true;\n  }\n  /**\n   * force to always use (uncompressed) RGBA for transcoded format\n   */\n  get forceRGBA() {\n    return this._forceRGBA;\n  }\n  set forceRGBA(value) {\n    if (this._forceRGBA === value) {\n      return;\n    }\n    this._forceRGBA = value;\n    this._isDirty = true;\n  }\n  /**\n   * force to always use (uncompressed) R8 for transcoded format\n   */\n  get forceR8() {\n    return this._forceR8;\n  }\n  set forceR8(value) {\n    if (this._forceR8 === value) {\n      return;\n    }\n    this._forceR8 = value;\n    this._isDirty = true;\n  }\n  /**\n   * force to always use (uncompressed) RG8 for transcoded format\n   */\n  get forceRG8() {\n    return this._forceRG8;\n  }\n  set forceRG8(value) {\n    if (this._forceRG8 === value) {\n      return;\n    }\n    this._forceRG8 = value;\n    this._isDirty = true;\n  }\n  /**\n   * list of transcoders to bypass when looking for a suitable transcoder. The available transcoders are:\n   *      UniversalTranscoder_UASTC_ASTC\n   *      UniversalTranscoder_UASTC_BC7\n   *      UniversalTranscoder_UASTC_RGBA_UNORM\n   *      UniversalTranscoder_UASTC_RGBA_SRGB\n   *      UniversalTranscoder_UASTC_R8_UNORM\n   *      UniversalTranscoder_UASTC_RG8_UNORM\n   *      MSCTranscoder\n   */\n  get bypassTranscoders() {\n    return this._bypassTranscoders;\n  }\n  set bypassTranscoders(value) {\n    if (this._bypassTranscoders === value) {\n      return;\n    }\n    this._bypassTranscoders = value;\n    this._isDirty = true;\n  }\n  /** @internal */\n  _getKTX2DecoderOptions() {\n    if (!this._isDirty) {\n      return this._ktx2DecoderOptions;\n    }\n    this._isDirty = false;\n    const options = {\n      useRGBAIfASTCBC7NotAvailableWhenUASTC: this._useRGBAIfASTCBC7NotAvailableWhenUASTC,\n      forceRGBA: this._forceRGBA,\n      forceR8: this._forceR8,\n      forceRG8: this._forceRG8,\n      bypassTranscoders: this._bypassTranscoders\n    };\n    if (this.useRGBAIfOnlyBC1BC3AvailableWhenUASTC) {\n      options.transcodeFormatDecisionTree = {\n        UASTC: {\n          transcodeFormat: [TranscodeTarget.BC1_RGB, TranscodeTarget.BC3_RGBA],\n          yes: {\n            transcodeFormat: TranscodeTarget.RGBA32,\n            engineFormat: EngineFormat.RGBA8Format,\n            roundToMultiple4: false\n          }\n        }\n      };\n    }\n    this._ktx2DecoderOptions = options;\n    return options;\n  }\n}\n/**\n * Class for loading KTX2 files\n */\nexport class KhronosTextureContainer2 {\n  static GetDefaultNumWorkers() {\n    if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\n      return 1;\n    }\n    // Use 50% of the available logical processors but capped at 4.\n    return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\n  }\n  static _Initialize(numWorkers) {\n    if (KhronosTextureContainer2._WorkerPoolPromise || KhronosTextureContainer2._DecoderModulePromise) {\n      return;\n    }\n    const urls = {\n      jsDecoderModule: Tools.GetBabylonScriptURL(this.URLConfig.jsDecoderModule, true),\n      wasmUASTCToASTC: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToASTC, true),\n      wasmUASTCToBC7: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToBC7, true),\n      wasmUASTCToRGBA_UNORM: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRGBA_UNORM, true),\n      wasmUASTCToRGBA_SRGB: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRGBA_SRGB, true),\n      wasmUASTCToR8_UNORM: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToR8_UNORM, true),\n      wasmUASTCToRG8_UNORM: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRG8_UNORM, true),\n      jsMSCTranscoder: Tools.GetBabylonScriptURL(this.URLConfig.jsMSCTranscoder, true),\n      wasmMSCTranscoder: Tools.GetBabylonScriptURL(this.URLConfig.wasmMSCTranscoder, true),\n      wasmZSTDDecoder: Tools.GetBabylonScriptURL(this.URLConfig.wasmZSTDDecoder, true)\n    };\n    if (numWorkers && typeof Worker === \"function\" && typeof URL !== \"undefined\") {\n      KhronosTextureContainer2._WorkerPoolPromise = new Promise(resolve => {\n        const workerContent = `${applyConfig}(${workerFunc})()`;\n        const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], {\n          type: \"application/javascript\"\n        }));\n        resolve(new AutoReleaseWorkerPool(numWorkers, () => new Promise((resolve, reject) => {\n          const worker = new Worker(workerBlobUrl);\n          const onError = error => {\n            worker.removeEventListener(\"error\", onError);\n            worker.removeEventListener(\"message\", onMessage);\n            reject(error);\n          };\n          const onMessage = message => {\n            if (message.data.action === \"init\") {\n              worker.removeEventListener(\"error\", onError);\n              worker.removeEventListener(\"message\", onMessage);\n              resolve(worker);\n            }\n          };\n          worker.addEventListener(\"error\", onError);\n          worker.addEventListener(\"message\", onMessage);\n          worker.postMessage({\n            action: \"init\",\n            urls: urls\n          });\n        })));\n      });\n    } else if (typeof KTX2DECODER === \"undefined\") {\n      KhronosTextureContainer2._DecoderModulePromise = Tools.LoadBabylonScriptAsync(urls.jsDecoderModule).then(() => {\n        KTX2DECODER.MSCTranscoder.UseFromWorkerThread = false;\n        KTX2DECODER.WASMMemoryManager.LoadBinariesFromCurrentThread = true;\n        applyConfig(urls);\n        return new KTX2DECODER.KTX2Decoder();\n      });\n    } else {\n      KTX2DECODER.MSCTranscoder.UseFromWorkerThread = false;\n      KTX2DECODER.WASMMemoryManager.LoadBinariesFromCurrentThread = true;\n      KhronosTextureContainer2._DecoderModulePromise = Promise.resolve(new KTX2DECODER.KTX2Decoder());\n    }\n  }\n  /**\n   * Constructor\n   * @param engine The engine to use\n   * @param numWorkers The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\n   */\n  constructor(engine, numWorkers = KhronosTextureContainer2.DefaultNumWorkers) {\n    this._engine = engine;\n    KhronosTextureContainer2._Initialize(numWorkers);\n  }\n  /**\n   * @internal\n   */\n  uploadAsync(data, internalTexture, options) {\n    const caps = this._engine.getCaps();\n    const compressedTexturesCaps = {\n      astc: !!caps.astc,\n      bptc: !!caps.bptc,\n      s3tc: !!caps.s3tc,\n      pvrtc: !!caps.pvrtc,\n      etc2: !!caps.etc2,\n      etc1: !!caps.etc1\n    };\n    if (KhronosTextureContainer2._WorkerPoolPromise) {\n      return KhronosTextureContainer2._WorkerPoolPromise.then(workerPool => {\n        return new Promise((resolve, reject) => {\n          workerPool.push((worker, onComplete) => {\n            const onError = error => {\n              worker.removeEventListener(\"error\", onError);\n              worker.removeEventListener(\"message\", onMessage);\n              reject(error);\n              onComplete();\n            };\n            const onMessage = message => {\n              if (message.data.action === \"decoded\") {\n                worker.removeEventListener(\"error\", onError);\n                worker.removeEventListener(\"message\", onMessage);\n                if (!message.data.success) {\n                  reject({\n                    message: message.data.msg\n                  });\n                } else {\n                  try {\n                    this._createTexture(message.data.decodedData, internalTexture, options);\n                    resolve();\n                  } catch (err) {\n                    reject({\n                      message: err\n                    });\n                  }\n                }\n                onComplete();\n              }\n            };\n            worker.addEventListener(\"error\", onError);\n            worker.addEventListener(\"message\", onMessage);\n            worker.postMessage({\n              action: \"setDefaultDecoderOptions\",\n              options: KhronosTextureContainer2.DefaultDecoderOptions._getKTX2DecoderOptions()\n            });\n            const dataCopy = new Uint8Array(data.byteLength);\n            dataCopy.set(new Uint8Array(data.buffer, data.byteOffset, data.byteLength));\n            worker.postMessage({\n              action: \"decode\",\n              data: dataCopy,\n              caps: compressedTexturesCaps,\n              options\n            }, [dataCopy.buffer]);\n          });\n        });\n      });\n    } else if (KhronosTextureContainer2._DecoderModulePromise) {\n      return KhronosTextureContainer2._DecoderModulePromise.then(decoder => {\n        if (KhronosTextureContainer2.DefaultDecoderOptions.isDirty) {\n          KTX2DECODER.KTX2Decoder.DefaultDecoderOptions = KhronosTextureContainer2.DefaultDecoderOptions._getKTX2DecoderOptions();\n        }\n        return new Promise((resolve, reject) => {\n          decoder.decode(data, caps).then(data => {\n            this._createTexture(data, internalTexture);\n            resolve();\n          }).catch(reason => {\n            reject({\n              message: reason\n            });\n          });\n        });\n      });\n    }\n    throw new Error(\"KTX2 decoder module is not available\");\n  }\n  _createTexture(data, internalTexture, options) {\n    const oglTexture2D = 3553; // gl.TEXTURE_2D\n    this._engine._bindTextureDirectly(oglTexture2D, internalTexture);\n    if (options) {\n      // return back some information about the decoded data\n      options.transcodedFormat = data.transcodedFormat;\n      options.isInGammaSpace = data.isInGammaSpace;\n      options.hasAlpha = data.hasAlpha;\n      options.transcoderName = data.transcoderName;\n    }\n    let isUncompressedFormat = true;\n    switch (data.transcodedFormat) {\n      case 0x8058 /* RGBA8 */:\n        internalTexture.type = 0;\n        internalTexture.format = 5;\n        break;\n      case 0x8229 /* R8 */:\n        internalTexture.type = 0;\n        internalTexture.format = 6;\n        break;\n      case 0x822b /* RG8 */:\n        internalTexture.type = 0;\n        internalTexture.format = 7;\n        break;\n      default:\n        internalTexture.format = data.transcodedFormat;\n        isUncompressedFormat = false;\n        break;\n    }\n    internalTexture._gammaSpace = data.isInGammaSpace;\n    internalTexture.generateMipMaps = data.mipmaps.length > 1;\n    if (data.errors) {\n      throw new Error(\"KTX2 container - could not transcode the data. \" + data.errors);\n    }\n    for (let t = 0; t < data.mipmaps.length; ++t) {\n      const mipmap = data.mipmaps[t];\n      if (!mipmap || !mipmap.data) {\n        throw new Error(\"KTX2 container - could not transcode one of the image\");\n      }\n      if (isUncompressedFormat) {\n        // uncompressed RGBA / R8 / RG8\n        internalTexture.width = mipmap.width; // need to set width/height so that the call to _uploadDataToTextureDirectly uses the right dimensions\n        internalTexture.height = mipmap.height;\n        this._engine._uploadDataToTextureDirectly(internalTexture, mipmap.data, 0, t, undefined, true);\n      } else {\n        this._engine._uploadCompressedDataToTextureDirectly(internalTexture, data.transcodedFormat, mipmap.width, mipmap.height, mipmap.data, 0, t);\n      }\n    }\n    internalTexture._extension = \".ktx2\";\n    internalTexture.width = data.mipmaps[0].width;\n    internalTexture.height = data.mipmaps[0].height;\n    internalTexture.isReady = true;\n    this._engine._bindTextureDirectly(oglTexture2D, null);\n  }\n  /**\n   * Checks if the given data starts with a KTX2 file identifier.\n   * @param data the data to check\n   * @returns true if the data is a KTX2 file or false otherwise\n   */\n  static IsValid(data) {\n    if (data.byteLength >= 12) {\n      // '«', 'K', 'T', 'X', ' ', '2', '0', '»', '\\r', '\\n', '\\x1A', '\\n'\n      const identifier = new Uint8Array(data.buffer, data.byteOffset, 12);\n      if (identifier[0] === 0xab && identifier[1] === 0x4b && identifier[2] === 0x54 && identifier[3] === 0x58 && identifier[4] === 0x20 && identifier[5] === 0x32 && identifier[6] === 0x30 && identifier[7] === 0xbb && identifier[8] === 0x0d && identifier[9] === 0x0a && identifier[10] === 0x1a && identifier[11] === 0x0a) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n/**\n * URLs to use when loading the KTX2 decoder module as well as its dependencies\n * If a url is null, the default url is used (pointing to https://preview.babylonjs.com)\n * Note that jsDecoderModule can't be null and that the other dependencies will only be loaded if necessary\n * Urls you can change:\n *     URLConfig.jsDecoderModule\n *     URLConfig.wasmUASTCToASTC\n *     URLConfig.wasmUASTCToBC7\n *     URLConfig.wasmUASTCToRGBA_UNORM\n *     URLConfig.wasmUASTCToRGBA_SRGB\n *     URLConfig.wasmUASTCToR8_UNORM\n *     URLConfig.wasmUASTCToRG8_UNORM\n *     URLConfig.jsMSCTranscoder\n *     URLConfig.wasmMSCTranscoder\n *     URLConfig.wasmZSTDDecoder\n * You can see their default values in this PG: https://playground.babylonjs.com/#EIJH8L#29\n */\nKhronosTextureContainer2.URLConfig = {\n  jsDecoderModule: \"babylon.ktx2Decoder.js\",\n  wasmUASTCToASTC: null,\n  wasmUASTCToBC7: null,\n  wasmUASTCToRGBA_UNORM: null,\n  wasmUASTCToRGBA_SRGB: null,\n  wasmUASTCToR8_UNORM: null,\n  wasmUASTCToRG8_UNORM: null,\n  jsMSCTranscoder: null,\n  wasmMSCTranscoder: null,\n  wasmZSTDDecoder: null\n};\n/**\n * Default number of workers used to handle data decoding\n */\nKhronosTextureContainer2.DefaultNumWorkers = KhronosTextureContainer2.GetDefaultNumWorkers();\n/**\n * Default configuration for the KTX2 decoder.\n * The options defined in this way have priority over those passed when creating a KTX2 texture with new Texture(...).\n */\nKhronosTextureContainer2.DefaultDecoderOptions = new DefaultKTX2DecoderOptions();\nfunction workerFunc() {\n  let ktx2Decoder;\n  onmessage = event => {\n    if (!event.data) {\n      return;\n    }\n    switch (event.data.action) {\n      case \"init\":\n        {\n          const urls = event.data.urls;\n          importScripts(urls.jsDecoderModule);\n          applyConfig(urls);\n          ktx2Decoder = new KTX2DECODER.KTX2Decoder();\n          postMessage({\n            action: \"init\"\n          });\n          break;\n        }\n      case \"setDefaultDecoderOptions\":\n        {\n          KTX2DECODER.KTX2Decoder.DefaultDecoderOptions = event.data.options;\n          break;\n        }\n      case \"decode\":\n        ktx2Decoder.decode(event.data.data, event.data.caps, event.data.options).then(data => {\n          const buffers = [];\n          for (let mip = 0; mip < data.mipmaps.length; ++mip) {\n            const mipmap = data.mipmaps[mip];\n            if (mipmap && mipmap.data) {\n              buffers.push(mipmap.data.buffer);\n            }\n          }\n          postMessage({\n            action: \"decoded\",\n            success: true,\n            decodedData: data\n          }, buffers);\n        }).catch(reason => {\n          postMessage({\n            action: \"decoded\",\n            success: false,\n            msg: reason\n          });\n        });\n        break;\n    }\n  };\n}","map":{"version":3,"names":["AutoReleaseWorkerPool","Tools","EngineFormat","TranscodeTarget","applyConfig","urls","wasmUASTCToASTC","KTX2DECODER","LiteTranscoder_UASTC_ASTC","WasmModuleURL","wasmUASTCToBC7","LiteTranscoder_UASTC_BC7","wasmUASTCToRGBA_UNORM","LiteTranscoder_UASTC_RGBA_UNORM","wasmUASTCToRGBA_SRGB","LiteTranscoder_UASTC_RGBA_SRGB","wasmUASTCToR8_UNORM","LiteTranscoder_UASTC_R8_UNORM","wasmUASTCToRG8_UNORM","LiteTranscoder_UASTC_RG8_UNORM","jsMSCTranscoder","MSCTranscoder","JSModuleURL","wasmMSCTranscoder","wasmZSTDDecoder","ZSTDDecoder","DefaultKTX2DecoderOptions","constructor","_isDirty","_useRGBAIfOnlyBC1BC3AvailableWhenUASTC","_ktx2DecoderOptions","isDirty","useRGBAIfASTCBC7NotAvailableWhenUASTC","_useRGBAIfASTCBC7NotAvailableWhenUASTC","value","useRGBAIfOnlyBC1BC3AvailableWhenUASTC","forceRGBA","_forceRGBA","forceR8","_forceR8","forceRG8","_forceRG8","bypassTranscoders","_bypassTranscoders","_getKTX2DecoderOptions","options","transcodeFormatDecisionTree","UASTC","transcodeFormat","BC1_RGB","BC3_RGBA","yes","RGBA32","engineFormat","RGBA8Format","roundToMultiple4","KhronosTextureContainer2","GetDefaultNumWorkers","navigator","hardwareConcurrency","Math","min","floor","_Initialize","numWorkers","_WorkerPoolPromise","_DecoderModulePromise","jsDecoderModule","GetBabylonScriptURL","URLConfig","Worker","URL","Promise","resolve","workerContent","workerFunc","workerBlobUrl","createObjectURL","Blob","type","reject","worker","onError","error","removeEventListener","onMessage","message","data","action","addEventListener","postMessage","LoadBabylonScriptAsync","then","UseFromWorkerThread","WASMMemoryManager","LoadBinariesFromCurrentThread","KTX2Decoder","engine","DefaultNumWorkers","_engine","uploadAsync","internalTexture","caps","getCaps","compressedTexturesCaps","astc","bptc","s3tc","pvrtc","etc2","etc1","workerPool","push","onComplete","success","msg","_createTexture","decodedData","err","DefaultDecoderOptions","dataCopy","Uint8Array","byteLength","set","buffer","byteOffset","decoder","decode","catch","reason","Error","oglTexture2D","_bindTextureDirectly","transcodedFormat","isInGammaSpace","hasAlpha","transcoderName","isUncompressedFormat","format","_gammaSpace","generateMipMaps","mipmaps","length","errors","t","mipmap","width","height","_uploadDataToTextureDirectly","undefined","_uploadCompressedDataToTextureDirectly","_extension","isReady","IsValid","identifier","ktx2Decoder","onmessage","event","importScripts","buffers","mip"],"sources":["../../../../dev/core/src/Misc/khronosTextureContainer2.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { AutoReleaseWorkerPool } from \"./workerPool\";\r\nimport { Tools } from \"./tools\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { ICompressedFormatCapabilities, IDecodedData, IKTX2DecoderOptions } from \"core/Materials/Textures/ktx2decoderTypes\";\r\nimport { EngineFormat, TranscodeTarget } from \"core/Materials/Textures/ktx2decoderTypes\";\r\n\r\ndeclare let KTX2DECODER: any;\r\n\r\nfunction applyConfig(urls: typeof KhronosTextureContainer2.URLConfig): void {\r\n    if (urls.wasmUASTCToASTC) {\r\n        KTX2DECODER.LiteTranscoder_UASTC_ASTC.WasmModuleURL = urls.wasmUASTCToASTC;\r\n    }\r\n\r\n    if (urls.wasmUASTCToBC7) {\r\n        KTX2DECODER.LiteTranscoder_UASTC_BC7.WasmModuleURL = urls.wasmUASTCToBC7;\r\n    }\r\n\r\n    if (urls.wasmUASTCToRGBA_UNORM) {\r\n        KTX2DECODER.LiteTranscoder_UASTC_RGBA_UNORM.WasmModuleURL = urls.wasmUASTCToRGBA_UNORM;\r\n    }\r\n\r\n    if (urls.wasmUASTCToRGBA_SRGB) {\r\n        KTX2DECODER.LiteTranscoder_UASTC_RGBA_SRGB.WasmModuleURL = urls.wasmUASTCToRGBA_SRGB;\r\n    }\r\n\r\n    if (urls.wasmUASTCToR8_UNORM) {\r\n        KTX2DECODER.LiteTranscoder_UASTC_R8_UNORM.WasmModuleURL = urls.wasmUASTCToR8_UNORM;\r\n    }\r\n\r\n    if (urls.wasmUASTCToRG8_UNORM) {\r\n        KTX2DECODER.LiteTranscoder_UASTC_RG8_UNORM.WasmModuleURL = urls.wasmUASTCToRG8_UNORM;\r\n    }\r\n\r\n    if (urls.jsMSCTranscoder) {\r\n        KTX2DECODER.MSCTranscoder.JSModuleURL = urls.jsMSCTranscoder;\r\n    }\r\n\r\n    if (urls.wasmMSCTranscoder) {\r\n        KTX2DECODER.MSCTranscoder.WasmModuleURL = urls.wasmMSCTranscoder;\r\n    }\r\n\r\n    if (urls.wasmZSTDDecoder) {\r\n        KTX2DECODER.ZSTDDecoder.WasmModuleURL = urls.wasmZSTDDecoder;\r\n    }\r\n}\r\n\r\n/**\r\n * Class that defines the default KTX2 decoder options.\r\n *\r\n * This class is useful for providing options to the KTX2 decoder to control how the source data is transcoded.\r\n */\r\nexport class DefaultKTX2DecoderOptions {\r\n    private _isDirty = true;\r\n\r\n    /**\r\n     * Gets the dirty flag\r\n     */\r\n    public get isDirty() {\r\n        return this._isDirty;\r\n    }\r\n\r\n    private _useRGBAIfASTCBC7NotAvailableWhenUASTC?: boolean;\r\n    /**\r\n     * force a (uncompressed) RGBA transcoded format if transcoding a UASTC source format and ASTC + BC7 are not available as a compressed transcoded format\r\n     */\r\n    public get useRGBAIfASTCBC7NotAvailableWhenUASTC() {\r\n        return this._useRGBAIfASTCBC7NotAvailableWhenUASTC;\r\n    }\r\n\r\n    public set useRGBAIfASTCBC7NotAvailableWhenUASTC(value: boolean | undefined) {\r\n        if (this._useRGBAIfASTCBC7NotAvailableWhenUASTC === value) {\r\n            return;\r\n        }\r\n        this._useRGBAIfASTCBC7NotAvailableWhenUASTC = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    private _useRGBAIfOnlyBC1BC3AvailableWhenUASTC?: boolean = true;\r\n    /**\r\n     * force a (uncompressed) RGBA transcoded format if transcoding a UASTC source format and only BC1 or BC3 are available as a compressed transcoded format.\r\n     * This property is true by default to favor speed over memory, because currently transcoding from UASTC to BC1/3 is slow because the transcoder transcodes\r\n     * to uncompressed and then recompresses the texture\r\n     */\r\n    public get useRGBAIfOnlyBC1BC3AvailableWhenUASTC() {\r\n        return this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC;\r\n    }\r\n\r\n    public set useRGBAIfOnlyBC1BC3AvailableWhenUASTC(value: boolean | undefined) {\r\n        if (this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC === value) {\r\n            return;\r\n        }\r\n        this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    private _forceRGBA?: boolean;\r\n    /**\r\n     * force to always use (uncompressed) RGBA for transcoded format\r\n     */\r\n    public get forceRGBA() {\r\n        return this._forceRGBA;\r\n    }\r\n\r\n    public set forceRGBA(value: boolean | undefined) {\r\n        if (this._forceRGBA === value) {\r\n            return;\r\n        }\r\n        this._forceRGBA = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    private _forceR8?: boolean;\r\n    /**\r\n     * force to always use (uncompressed) R8 for transcoded format\r\n     */\r\n    public get forceR8() {\r\n        return this._forceR8;\r\n    }\r\n\r\n    public set forceR8(value: boolean | undefined) {\r\n        if (this._forceR8 === value) {\r\n            return;\r\n        }\r\n        this._forceR8 = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    private _forceRG8?: boolean;\r\n    /**\r\n     * force to always use (uncompressed) RG8 for transcoded format\r\n     */\r\n    public get forceRG8() {\r\n        return this._forceRG8;\r\n    }\r\n\r\n    public set forceRG8(value: boolean | undefined) {\r\n        if (this._forceRG8 === value) {\r\n            return;\r\n        }\r\n        this._forceRG8 = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    private _bypassTranscoders?: string[];\r\n    /**\r\n     * list of transcoders to bypass when looking for a suitable transcoder. The available transcoders are:\r\n     *      UniversalTranscoder_UASTC_ASTC\r\n     *      UniversalTranscoder_UASTC_BC7\r\n     *      UniversalTranscoder_UASTC_RGBA_UNORM\r\n     *      UniversalTranscoder_UASTC_RGBA_SRGB\r\n     *      UniversalTranscoder_UASTC_R8_UNORM\r\n     *      UniversalTranscoder_UASTC_RG8_UNORM\r\n     *      MSCTranscoder\r\n     */\r\n    public get bypassTranscoders() {\r\n        return this._bypassTranscoders;\r\n    }\r\n\r\n    public set bypassTranscoders(value: string[] | undefined) {\r\n        if (this._bypassTranscoders === value) {\r\n            return;\r\n        }\r\n        this._bypassTranscoders = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    private _ktx2DecoderOptions: IKTX2DecoderOptions = {};\r\n\r\n    /** @internal */\r\n    public _getKTX2DecoderOptions(): IKTX2DecoderOptions {\r\n        if (!this._isDirty) {\r\n            return this._ktx2DecoderOptions;\r\n        }\r\n\r\n        this._isDirty = false;\r\n\r\n        const options: IKTX2DecoderOptions = {\r\n            useRGBAIfASTCBC7NotAvailableWhenUASTC: this._useRGBAIfASTCBC7NotAvailableWhenUASTC,\r\n            forceRGBA: this._forceRGBA,\r\n            forceR8: this._forceR8,\r\n            forceRG8: this._forceRG8,\r\n            bypassTranscoders: this._bypassTranscoders,\r\n        };\r\n\r\n        if (this.useRGBAIfOnlyBC1BC3AvailableWhenUASTC) {\r\n            options.transcodeFormatDecisionTree = {\r\n                UASTC: {\r\n                    transcodeFormat: [TranscodeTarget.BC1_RGB, TranscodeTarget.BC3_RGBA],\r\n                    yes: {\r\n                        transcodeFormat: TranscodeTarget.RGBA32,\r\n                        engineFormat: EngineFormat.RGBA8Format,\r\n                        roundToMultiple4: false,\r\n                    },\r\n                },\r\n            };\r\n        }\r\n\r\n        this._ktx2DecoderOptions = options;\r\n\r\n        return options;\r\n    }\r\n}\r\n\r\n/**\r\n * Class for loading KTX2 files\r\n */\r\nexport class KhronosTextureContainer2 {\r\n    private static _WorkerPoolPromise?: Promise<AutoReleaseWorkerPool>;\r\n    private static _DecoderModulePromise?: Promise<any>;\r\n\r\n    /**\r\n     * URLs to use when loading the KTX2 decoder module as well as its dependencies\r\n     * If a url is null, the default url is used (pointing to https://preview.babylonjs.com)\r\n     * Note that jsDecoderModule can't be null and that the other dependencies will only be loaded if necessary\r\n     * Urls you can change:\r\n     *     URLConfig.jsDecoderModule\r\n     *     URLConfig.wasmUASTCToASTC\r\n     *     URLConfig.wasmUASTCToBC7\r\n     *     URLConfig.wasmUASTCToRGBA_UNORM\r\n     *     URLConfig.wasmUASTCToRGBA_SRGB\r\n     *     URLConfig.wasmUASTCToR8_UNORM\r\n     *     URLConfig.wasmUASTCToRG8_UNORM\r\n     *     URLConfig.jsMSCTranscoder\r\n     *     URLConfig.wasmMSCTranscoder\r\n     *     URLConfig.wasmZSTDDecoder\r\n     * You can see their default values in this PG: https://playground.babylonjs.com/#EIJH8L#29\r\n     */\r\n    public static URLConfig: {\r\n        jsDecoderModule: string;\r\n        wasmUASTCToASTC: Nullable<string>;\r\n        wasmUASTCToBC7: Nullable<string>;\r\n        wasmUASTCToRGBA_UNORM: Nullable<string>;\r\n        wasmUASTCToRGBA_SRGB: Nullable<string>;\r\n        wasmUASTCToR8_UNORM: Nullable<string>;\r\n        wasmUASTCToRG8_UNORM: Nullable<string>;\r\n        jsMSCTranscoder: Nullable<string>;\r\n        wasmMSCTranscoder: Nullable<string>;\r\n        wasmZSTDDecoder: Nullable<string>;\r\n    } = {\r\n        jsDecoderModule: \"babylon.ktx2Decoder.js\",\r\n        wasmUASTCToASTC: null,\r\n        wasmUASTCToBC7: null,\r\n        wasmUASTCToRGBA_UNORM: null,\r\n        wasmUASTCToRGBA_SRGB: null,\r\n        wasmUASTCToR8_UNORM: null,\r\n        wasmUASTCToRG8_UNORM: null,\r\n        jsMSCTranscoder: null,\r\n        wasmMSCTranscoder: null,\r\n        wasmZSTDDecoder: null,\r\n    };\r\n\r\n    /**\r\n     * Default number of workers used to handle data decoding\r\n     */\r\n    public static DefaultNumWorkers = KhronosTextureContainer2.GetDefaultNumWorkers();\r\n\r\n    /**\r\n     * Default configuration for the KTX2 decoder.\r\n     * The options defined in this way have priority over those passed when creating a KTX2 texture with new Texture(...).\r\n     */\r\n    public static DefaultDecoderOptions = new DefaultKTX2DecoderOptions();\r\n\r\n    private static GetDefaultNumWorkers(): number {\r\n        if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\r\n            return 1;\r\n        }\r\n\r\n        // Use 50% of the available logical processors but capped at 4.\r\n        return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\r\n    }\r\n\r\n    private _engine: ThinEngine;\r\n\r\n    private static _Initialize(numWorkers: number): void {\r\n        if (KhronosTextureContainer2._WorkerPoolPromise || KhronosTextureContainer2._DecoderModulePromise) {\r\n            return;\r\n        }\r\n\r\n        const urls = {\r\n            jsDecoderModule: Tools.GetBabylonScriptURL(this.URLConfig.jsDecoderModule, true),\r\n            wasmUASTCToASTC: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToASTC, true),\r\n            wasmUASTCToBC7: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToBC7, true),\r\n            wasmUASTCToRGBA_UNORM: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRGBA_UNORM, true),\r\n            wasmUASTCToRGBA_SRGB: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRGBA_SRGB, true),\r\n            wasmUASTCToR8_UNORM: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToR8_UNORM, true),\r\n            wasmUASTCToRG8_UNORM: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRG8_UNORM, true),\r\n            jsMSCTranscoder: Tools.GetBabylonScriptURL(this.URLConfig.jsMSCTranscoder, true),\r\n            wasmMSCTranscoder: Tools.GetBabylonScriptURL(this.URLConfig.wasmMSCTranscoder, true),\r\n            wasmZSTDDecoder: Tools.GetBabylonScriptURL(this.URLConfig.wasmZSTDDecoder, true),\r\n        };\r\n\r\n        if (numWorkers && typeof Worker === \"function\" && typeof URL !== \"undefined\") {\r\n            KhronosTextureContainer2._WorkerPoolPromise = new Promise((resolve) => {\r\n                const workerContent = `${applyConfig}(${workerFunc})()`;\r\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\r\n                resolve(\r\n                    new AutoReleaseWorkerPool(\r\n                        numWorkers,\r\n                        () =>\r\n                            new Promise((resolve, reject) => {\r\n                                const worker = new Worker(workerBlobUrl);\r\n\r\n                                const onError = (error: ErrorEvent) => {\r\n                                    worker.removeEventListener(\"error\", onError);\r\n                                    worker.removeEventListener(\"message\", onMessage);\r\n                                    reject(error);\r\n                                };\r\n\r\n                                const onMessage = (message: MessageEvent) => {\r\n                                    if (message.data.action === \"init\") {\r\n                                        worker.removeEventListener(\"error\", onError);\r\n                                        worker.removeEventListener(\"message\", onMessage);\r\n                                        resolve(worker);\r\n                                    }\r\n                                };\r\n\r\n                                worker.addEventListener(\"error\", onError);\r\n                                worker.addEventListener(\"message\", onMessage);\r\n\r\n                                worker.postMessage({\r\n                                    action: \"init\",\r\n                                    urls: urls,\r\n                                });\r\n                            })\r\n                    )\r\n                );\r\n            });\r\n        } else if (typeof KTX2DECODER === \"undefined\") {\r\n            KhronosTextureContainer2._DecoderModulePromise = Tools.LoadBabylonScriptAsync(urls.jsDecoderModule).then(() => {\r\n                KTX2DECODER.MSCTranscoder.UseFromWorkerThread = false;\r\n                KTX2DECODER.WASMMemoryManager.LoadBinariesFromCurrentThread = true;\r\n                applyConfig(urls);\r\n                return new KTX2DECODER.KTX2Decoder();\r\n            });\r\n        } else {\r\n            KTX2DECODER.MSCTranscoder.UseFromWorkerThread = false;\r\n            KTX2DECODER.WASMMemoryManager.LoadBinariesFromCurrentThread = true;\r\n            KhronosTextureContainer2._DecoderModulePromise = Promise.resolve(new KTX2DECODER.KTX2Decoder());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     * @param engine The engine to use\r\n     * @param numWorkers The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\r\n     */\r\n    public constructor(engine: ThinEngine, numWorkers = KhronosTextureContainer2.DefaultNumWorkers) {\r\n        this._engine = engine;\r\n\r\n        KhronosTextureContainer2._Initialize(numWorkers);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public uploadAsync(data: ArrayBufferView, internalTexture: InternalTexture, options?: IKTX2DecoderOptions & IDecodedData): Promise<void> {\r\n        const caps = this._engine.getCaps();\r\n\r\n        const compressedTexturesCaps: ICompressedFormatCapabilities = {\r\n            astc: !!caps.astc,\r\n            bptc: !!caps.bptc,\r\n            s3tc: !!caps.s3tc,\r\n            pvrtc: !!caps.pvrtc,\r\n            etc2: !!caps.etc2,\r\n            etc1: !!caps.etc1,\r\n        };\r\n\r\n        if (KhronosTextureContainer2._WorkerPoolPromise) {\r\n            return KhronosTextureContainer2._WorkerPoolPromise.then((workerPool) => {\r\n                return new Promise((resolve, reject) => {\r\n                    workerPool.push((worker, onComplete) => {\r\n                        const onError = (error: ErrorEvent) => {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            reject(error);\r\n                            onComplete();\r\n                        };\r\n\r\n                        const onMessage = (message: MessageEvent) => {\r\n                            if (message.data.action === \"decoded\") {\r\n                                worker.removeEventListener(\"error\", onError);\r\n                                worker.removeEventListener(\"message\", onMessage);\r\n                                if (!message.data.success) {\r\n                                    reject({ message: message.data.msg });\r\n                                } else {\r\n                                    try {\r\n                                        this._createTexture(message.data.decodedData, internalTexture, options);\r\n                                        resolve();\r\n                                    } catch (err) {\r\n                                        reject({ message: err });\r\n                                    }\r\n                                }\r\n                                onComplete();\r\n                            }\r\n                        };\r\n\r\n                        worker.addEventListener(\"error\", onError);\r\n                        worker.addEventListener(\"message\", onMessage);\r\n                        worker.postMessage({ action: \"setDefaultDecoderOptions\", options: KhronosTextureContainer2.DefaultDecoderOptions._getKTX2DecoderOptions() });\r\n\r\n                        const dataCopy = new Uint8Array(data.byteLength);\r\n                        dataCopy.set(new Uint8Array(data.buffer, data.byteOffset, data.byteLength));\r\n\r\n                        worker.postMessage({ action: \"decode\", data: dataCopy, caps: compressedTexturesCaps, options }, [dataCopy.buffer]);\r\n                    });\r\n                });\r\n            });\r\n        } else if (KhronosTextureContainer2._DecoderModulePromise) {\r\n            return KhronosTextureContainer2._DecoderModulePromise.then((decoder) => {\r\n                if (KhronosTextureContainer2.DefaultDecoderOptions.isDirty) {\r\n                    KTX2DECODER.KTX2Decoder.DefaultDecoderOptions = KhronosTextureContainer2.DefaultDecoderOptions._getKTX2DecoderOptions();\r\n                }\r\n                return new Promise((resolve, reject) => {\r\n                    decoder\r\n                        .decode(data, caps)\r\n                        .then((data: IDecodedData) => {\r\n                            this._createTexture(data, internalTexture);\r\n                            resolve();\r\n                        })\r\n                        .catch((reason: any) => {\r\n                            reject({ message: reason });\r\n                        });\r\n                });\r\n            });\r\n        }\r\n\r\n        throw new Error(\"KTX2 decoder module is not available\");\r\n    }\r\n\r\n    protected _createTexture(data: IDecodedData, internalTexture: InternalTexture, options?: IKTX2DecoderOptions & IDecodedData): void {\r\n        const oglTexture2D = 3553; // gl.TEXTURE_2D\r\n\r\n        this._engine._bindTextureDirectly(oglTexture2D, internalTexture);\r\n\r\n        if (options) {\r\n            // return back some information about the decoded data\r\n            options.transcodedFormat = data.transcodedFormat;\r\n            options.isInGammaSpace = data.isInGammaSpace;\r\n            options.hasAlpha = data.hasAlpha;\r\n            options.transcoderName = data.transcoderName;\r\n        }\r\n\r\n        let isUncompressedFormat = true;\r\n\r\n        switch (data.transcodedFormat) {\r\n            case 0x8058 /* RGBA8 */:\r\n                internalTexture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n                internalTexture.format = Constants.TEXTUREFORMAT_RGBA;\r\n                break;\r\n            case 0x8229 /* R8 */:\r\n                internalTexture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n                internalTexture.format = Constants.TEXTUREFORMAT_R;\r\n                break;\r\n            case 0x822b /* RG8 */:\r\n                internalTexture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n                internalTexture.format = Constants.TEXTUREFORMAT_RG;\r\n                break;\r\n            default:\r\n                internalTexture.format = data.transcodedFormat;\r\n                isUncompressedFormat = false;\r\n                break;\r\n        }\r\n\r\n        internalTexture._gammaSpace = data.isInGammaSpace;\r\n        internalTexture.generateMipMaps = data.mipmaps.length > 1;\r\n\r\n        if (data.errors) {\r\n            throw new Error(\"KTX2 container - could not transcode the data. \" + data.errors);\r\n        }\r\n\r\n        for (let t = 0; t < data.mipmaps.length; ++t) {\r\n            const mipmap = data.mipmaps[t];\r\n\r\n            if (!mipmap || !mipmap.data) {\r\n                throw new Error(\"KTX2 container - could not transcode one of the image\");\r\n            }\r\n\r\n            if (isUncompressedFormat) {\r\n                // uncompressed RGBA / R8 / RG8\r\n                internalTexture.width = mipmap.width; // need to set width/height so that the call to _uploadDataToTextureDirectly uses the right dimensions\r\n                internalTexture.height = mipmap.height;\r\n\r\n                this._engine._uploadDataToTextureDirectly(internalTexture, mipmap.data, 0, t, undefined, true);\r\n            } else {\r\n                this._engine._uploadCompressedDataToTextureDirectly(internalTexture, data.transcodedFormat, mipmap.width, mipmap.height, mipmap.data, 0, t);\r\n            }\r\n        }\r\n\r\n        internalTexture._extension = \".ktx2\";\r\n        internalTexture.width = data.mipmaps[0].width;\r\n        internalTexture.height = data.mipmaps[0].height;\r\n        internalTexture.isReady = true;\r\n\r\n        this._engine._bindTextureDirectly(oglTexture2D, null);\r\n    }\r\n\r\n    /**\r\n     * Checks if the given data starts with a KTX2 file identifier.\r\n     * @param data the data to check\r\n     * @returns true if the data is a KTX2 file or false otherwise\r\n     */\r\n    public static IsValid(data: ArrayBufferView): boolean {\r\n        if (data.byteLength >= 12) {\r\n            // '«', 'K', 'T', 'X', ' ', '2', '0', '»', '\\r', '\\n', '\\x1A', '\\n'\r\n            const identifier = new Uint8Array(data.buffer, data.byteOffset, 12);\r\n            if (\r\n                identifier[0] === 0xab &&\r\n                identifier[1] === 0x4b &&\r\n                identifier[2] === 0x54 &&\r\n                identifier[3] === 0x58 &&\r\n                identifier[4] === 0x20 &&\r\n                identifier[5] === 0x32 &&\r\n                identifier[6] === 0x30 &&\r\n                identifier[7] === 0xbb &&\r\n                identifier[8] === 0x0d &&\r\n                identifier[9] === 0x0a &&\r\n                identifier[10] === 0x1a &&\r\n                identifier[11] === 0x0a\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n\r\ndeclare function importScripts(...urls: string[]): void;\r\ndeclare function postMessage(message: any, transfer?: any[]): void;\r\n\r\nfunction workerFunc(): void {\r\n    let ktx2Decoder: any;\r\n\r\n    onmessage = (event) => {\r\n        if (!event.data) {\r\n            return;\r\n        }\r\n        switch (event.data.action) {\r\n            case \"init\": {\r\n                const urls = event.data.urls;\r\n                importScripts(urls.jsDecoderModule);\r\n                applyConfig(urls);\r\n                ktx2Decoder = new KTX2DECODER.KTX2Decoder();\r\n                postMessage({ action: \"init\" });\r\n                break;\r\n            }\r\n            case \"setDefaultDecoderOptions\": {\r\n                KTX2DECODER.KTX2Decoder.DefaultDecoderOptions = event.data.options;\r\n                break;\r\n            }\r\n            case \"decode\":\r\n                ktx2Decoder\r\n                    .decode(event.data.data, event.data.caps, event.data.options)\r\n                    .then((data: IDecodedData) => {\r\n                        const buffers = [];\r\n                        for (let mip = 0; mip < data.mipmaps.length; ++mip) {\r\n                            const mipmap = data.mipmaps[mip];\r\n                            if (mipmap && mipmap.data) {\r\n                                buffers.push(mipmap.data.buffer);\r\n                            }\r\n                        }\r\n                        postMessage({ action: \"decoded\", success: true, decodedData: data }, buffers);\r\n                    })\r\n                    .catch((reason: any) => {\r\n                        postMessage({ action: \"decoded\", success: false, msg: reason });\r\n                    });\r\n                break;\r\n        }\r\n    };\r\n}\r\n"],"mappings":";;;;;;;AAIA,SAASA,qBAAqB,QAAQ,iBAAe;AACrD,SAASC,KAAK,QAAQ,YAAU;AAGhC,SAASC,YAAY,EAAEC,eAAe,QAAE;AAIxC,SAASC,WAAWA,CAACC,IAA+C;EAChE,IAAIA,IAAI,CAACC,eAAe,EAAE;IACtBC,WAAW,CAACC,yBAAyB,CAACC,aAAa,GAAGJ,IAAI,CAACC,eAAe;;EAG9E,IAAID,IAAI,CAACK,cAAc,EAAE;IACrBH,WAAW,CAACI,wBAAwB,CAACF,aAAa,GAAGJ,IAAI,CAACK,cAAc;;EAG5E,IAAIL,IAAI,CAACO,qBAAqB,EAAE;IAC5BL,WAAW,CAACM,+BAA+B,CAACJ,aAAa,GAAGJ,IAAI,CAACO,qBAAqB;;EAG1F,IAAIP,IAAI,CAACS,oBAAoB,EAAE;IAC3BP,WAAW,CAACQ,8BAA8B,CAACN,aAAa,GAAGJ,IAAI,CAACS,oBAAoB;;EAGxF,IAAIT,IAAI,CAACW,mBAAmB,EAAE;IAC1BT,WAAW,CAACU,6BAA6B,CAACR,aAAa,GAAGJ,IAAI,CAACW,mBAAmB;;EAGtF,IAAIX,IAAI,CAACa,oBAAoB,EAAE;IAC3BX,WAAW,CAACY,8BAA8B,CAACV,aAAa,GAAGJ,IAAI,CAACa,oBAAoB;;EAGxF,IAAIb,IAAI,CAACe,eAAe,EAAE;IACtBb,WAAW,CAACc,aAAa,CAACC,WAAW,GAAGjB,IAAI,CAACe,eAAe;;EAGhE,IAAIf,IAAI,CAACkB,iBAAiB,EAAE;IACxBhB,WAAW,CAACc,aAAa,CAACZ,aAAa,GAAGJ,IAAI,CAACkB,iBAAiB;;EAGpE,IAAIlB,IAAI,CAACmB,eAAe,EAAE;IACtBjB,WAAW,CAACkB,WAAW,CAAChB,aAAa,GAAGJ,IAAI,CAACmB,eAAe;;AAEpE;AAEA;;;;;AAKA,OAAM,MAAOE,yBAAyB;EAAtCC,YAAA;IACY,KAAAC,QAAQ,GAAG,IAAI;IAyBf,KAAAC,sCAAsC,GAAa,IAAI;IAyFvD,KAAAC,mBAAmB,GAAwB,EAAE;EAmCzD;EAnJI;;;EAGA,IAAWC,OAAOA,CAAA;IACd,OAAO,IAAI,CAACH,QAAQ;EACxB;EAGA;;;EAGA,IAAWI,qCAAqCA,CAAA;IAC5C,OAAO,IAAI,CAACC,sCAAsC;EACtD;EAEA,IAAWD,qCAAqCA,CAACE,KAA0B;IACvE,IAAI,IAAI,CAACD,sCAAsC,KAAKC,KAAK,EAAE;MACvD;;IAEJ,IAAI,CAACD,sCAAsC,GAAGC,KAAK;IACnD,IAAI,CAACN,QAAQ,GAAG,IAAI;EACxB;EAGA;;;;;EAKA,IAAWO,qCAAqCA,CAAA;IAC5C,OAAO,IAAI,CAACN,sCAAsC;EACtD;EAEA,IAAWM,qCAAqCA,CAACD,KAA0B;IACvE,IAAI,IAAI,CAACL,sCAAsC,KAAKK,KAAK,EAAE;MACvD;;IAEJ,IAAI,CAACL,sCAAsC,GAAGK,KAAK;IACnD,IAAI,CAACN,QAAQ,GAAG,IAAI;EACxB;EAGA;;;EAGA,IAAWQ,SAASA,CAAA;IAChB,OAAO,IAAI,CAACC,UAAU;EAC1B;EAEA,IAAWD,SAASA,CAACF,KAA0B;IAC3C,IAAI,IAAI,CAACG,UAAU,KAAKH,KAAK,EAAE;MAC3B;;IAEJ,IAAI,CAACG,UAAU,GAAGH,KAAK;IACvB,IAAI,CAACN,QAAQ,GAAG,IAAI;EACxB;EAGA;;;EAGA,IAAWU,OAAOA,CAAA;IACd,OAAO,IAAI,CAACC,QAAQ;EACxB;EAEA,IAAWD,OAAOA,CAACJ,KAA0B;IACzC,IAAI,IAAI,CAACK,QAAQ,KAAKL,KAAK,EAAE;MACzB;;IAEJ,IAAI,CAACK,QAAQ,GAAGL,KAAK;IACrB,IAAI,CAACN,QAAQ,GAAG,IAAI;EACxB;EAGA;;;EAGA,IAAWY,QAAQA,CAAA;IACf,OAAO,IAAI,CAACC,SAAS;EACzB;EAEA,IAAWD,QAAQA,CAACN,KAA0B;IAC1C,IAAI,IAAI,CAACO,SAAS,KAAKP,KAAK,EAAE;MAC1B;;IAEJ,IAAI,CAACO,SAAS,GAAGP,KAAK;IACtB,IAAI,CAACN,QAAQ,GAAG,IAAI;EACxB;EAGA;;;;;;;;;;EAUA,IAAWc,iBAAiBA,CAAA;IACxB,OAAO,IAAI,CAACC,kBAAkB;EAClC;EAEA,IAAWD,iBAAiBA,CAACR,KAA2B;IACpD,IAAI,IAAI,CAACS,kBAAkB,KAAKT,KAAK,EAAE;MACnC;;IAEJ,IAAI,CAACS,kBAAkB,GAAGT,KAAK;IAC/B,IAAI,CAACN,QAAQ,GAAG,IAAI;EACxB;EAIA;EACOgB,sBAAsBA,CAAA;IACzB,IAAI,CAAC,IAAI,CAAChB,QAAQ,EAAE;MAChB,OAAO,IAAI,CAACE,mBAAmB;;IAGnC,IAAI,CAACF,QAAQ,GAAG,KAAK;IAErB,MAAMiB,OAAO,GAAwB;MACjCb,qCAAqC,EAAE,IAAI,CAACC,sCAAsC;MAClFG,SAAS,EAAE,IAAI,CAACC,UAAU;MAC1BC,OAAO,EAAE,IAAI,CAACC,QAAQ;MACtBC,QAAQ,EAAE,IAAI,CAACC,SAAS;MACxBC,iBAAiB,EAAE,IAAI,CAACC;KAC3B;IAED,IAAI,IAAI,CAACR,qCAAqC,EAAE;MAC5CU,OAAO,CAACC,2BAA2B,GAAG;QAClCC,KAAK,EAAE;UACHC,eAAe,EAAE,CAAC7C,eAAe,CAAC8C,OAAO,EAAE9C,eAAe,CAAC+C,QAAQ,CAAC;UACpEC,GAAG,EAAE;YACDH,eAAe,EAAE7C,eAAe,CAACiD,MAAM;YACvCC,YAAY,EAAEnD,YAAY,CAACoD,WAAW;YACtCC,gBAAgB,EAAE;;;OAG7B;;IAGL,IAAI,CAACzB,mBAAmB,GAAGe,OAAO;IAElC,OAAOA,OAAO;EAClB;;AAGJ;;;AAGA,OAAM,MAAOW,wBAAwB;EAwDzB,OAAOC,oBAAoBA,CAAA;IAC/B,IAAI,OAAOC,SAAS,KAAK,QAAQ,IAAI,CAACA,SAAS,CAACC,mBAAmB,EAAE;MACjE,OAAO,CAAC;;IAGZ;IACA,OAAOC,IAAI,CAACC,GAAG,CAACD,IAAI,CAACE,KAAK,CAACJ,SAAS,CAACC,mBAAmB,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC;EACvE;EAIQ,OAAOI,WAAWA,CAACC,UAAkB;IACzC,IAAIR,wBAAwB,CAACS,kBAAkB,IAAIT,wBAAwB,CAACU,qBAAqB,EAAE;MAC/F;;IAGJ,MAAM7D,IAAI,GAAG;MACT8D,eAAe,EAAElE,KAAK,CAACmE,mBAAmB,CAAC,IAAI,CAACC,SAAS,CAACF,eAAe,EAAE,IAAI,CAAC;MAChF7D,eAAe,EAAEL,KAAK,CAACmE,mBAAmB,CAAC,IAAI,CAACC,SAAS,CAAC/D,eAAe,EAAE,IAAI,CAAC;MAChFI,cAAc,EAAET,KAAK,CAACmE,mBAAmB,CAAC,IAAI,CAACC,SAAS,CAAC3D,cAAc,EAAE,IAAI,CAAC;MAC9EE,qBAAqB,EAAEX,KAAK,CAACmE,mBAAmB,CAAC,IAAI,CAACC,SAAS,CAACzD,qBAAqB,EAAE,IAAI,CAAC;MAC5FE,oBAAoB,EAAEb,KAAK,CAACmE,mBAAmB,CAAC,IAAI,CAACC,SAAS,CAACvD,oBAAoB,EAAE,IAAI,CAAC;MAC1FE,mBAAmB,EAAEf,KAAK,CAACmE,mBAAmB,CAAC,IAAI,CAACC,SAAS,CAACrD,mBAAmB,EAAE,IAAI,CAAC;MACxFE,oBAAoB,EAAEjB,KAAK,CAACmE,mBAAmB,CAAC,IAAI,CAACC,SAAS,CAACnD,oBAAoB,EAAE,IAAI,CAAC;MAC1FE,eAAe,EAAEnB,KAAK,CAACmE,mBAAmB,CAAC,IAAI,CAACC,SAAS,CAACjD,eAAe,EAAE,IAAI,CAAC;MAChFG,iBAAiB,EAAEtB,KAAK,CAACmE,mBAAmB,CAAC,IAAI,CAACC,SAAS,CAAC9C,iBAAiB,EAAE,IAAI,CAAC;MACpFC,eAAe,EAAEvB,KAAK,CAACmE,mBAAmB,CAAC,IAAI,CAACC,SAAS,CAAC7C,eAAe,EAAE,IAAI;KAClF;IAED,IAAIwC,UAAU,IAAI,OAAOM,MAAM,KAAK,UAAU,IAAI,OAAOC,GAAG,KAAK,WAAW,EAAE;MAC1Ef,wBAAwB,CAACS,kBAAkB,GAAG,IAAIO,OAAO,CAAEC,OAAO,IAAI;QAClE,MAAMC,aAAa,GAAG,GAAGtE,WAAW,IAAIuE,UAAU,KAAK;QACvD,MAAMC,aAAa,GAAGL,GAAG,CAACM,eAAe,CAAC,IAAIC,IAAI,CAAC,CAACJ,aAAa,CAAC,EAAE;UAAEK,IAAI,EAAE;QAAwB,CAAE,CAAC,CAAC;QACxGN,OAAO,CACH,IAAIzE,qBAAqB,CACrBgE,UAAU,EACV,MACI,IAAIQ,OAAO,CAAC,CAACC,OAAO,EAAEO,MAAM,KAAI;UAC5B,MAAMC,MAAM,GAAG,IAAIX,MAAM,CAACM,aAAa,CAAC;UAExC,MAAMM,OAAO,GAAIC,KAAiB,IAAI;YAClCF,MAAM,CAACG,mBAAmB,CAAC,OAAO,EAAEF,OAAO,CAAC;YAC5CD,MAAM,CAACG,mBAAmB,CAAC,SAAS,EAAEC,SAAS,CAAC;YAChDL,MAAM,CAACG,KAAK,CAAC;UACjB,CAAC;UAED,MAAME,SAAS,GAAIC,OAAqB,IAAI;YACxC,IAAIA,OAAO,CAACC,IAAI,CAACC,MAAM,KAAK,MAAM,EAAE;cAChCP,MAAM,CAACG,mBAAmB,CAAC,OAAO,EAAEF,OAAO,CAAC;cAC5CD,MAAM,CAACG,mBAAmB,CAAC,SAAS,EAAEC,SAAS,CAAC;cAChDZ,OAAO,CAACQ,MAAM,CAAC;;UAEvB,CAAC;UAEDA,MAAM,CAACQ,gBAAgB,CAAC,OAAO,EAAEP,OAAO,CAAC;UACzCD,MAAM,CAACQ,gBAAgB,CAAC,SAAS,EAAEJ,SAAS,CAAC;UAE7CJ,MAAM,CAACS,WAAW,CAAC;YACfF,MAAM,EAAE,MAAM;YACdnF,IAAI,EAAEA;WACT,CAAC;QACN,CAAC,CAAC,CACT,CACJ;MACL,CAAC,CAAC;KACL,MAAM,IAAI,OAAOE,WAAW,KAAK,WAAW,EAAE;MAC3CiD,wBAAwB,CAACU,qBAAqB,GAAGjE,KAAK,CAAC0F,sBAAsB,CAACtF,IAAI,CAAC8D,eAAe,CAAC,CAACyB,IAAI,CAAC,MAAK;QAC1GrF,WAAW,CAACc,aAAa,CAACwE,mBAAmB,GAAG,KAAK;QACrDtF,WAAW,CAACuF,iBAAiB,CAACC,6BAA6B,GAAG,IAAI;QAClE3F,WAAW,CAACC,IAAI,CAAC;QACjB,OAAO,IAAIE,WAAW,CAACyF,WAAW,EAAE;MACxC,CAAC,CAAC;KACL,MAAM;MACHzF,WAAW,CAACc,aAAa,CAACwE,mBAAmB,GAAG,KAAK;MACrDtF,WAAW,CAACuF,iBAAiB,CAACC,6BAA6B,GAAG,IAAI;MAClEvC,wBAAwB,CAACU,qBAAqB,GAAGM,OAAO,CAACC,OAAO,CAAC,IAAIlE,WAAW,CAACyF,WAAW,EAAE,CAAC;;EAEvG;EAEA;;;;;EAKArE,YAAmBsE,MAAkB,EAAEjC,UAAU,GAAGR,wBAAwB,CAAC0C,iBAAiB;IAC1F,IAAI,CAACC,OAAO,GAAGF,MAAM;IAErBzC,wBAAwB,CAACO,WAAW,CAACC,UAAU,CAAC;EACpD;EAEA;;;EAGOoC,WAAWA,CAACb,IAAqB,EAAEc,eAAgC,EAAExD,OAA4C;IACpH,MAAMyD,IAAI,GAAG,IAAI,CAACH,OAAO,CAACI,OAAO,EAAE;IAEnC,MAAMC,sBAAsB,GAAkC;MAC1DC,IAAI,EAAE,CAAC,CAACH,IAAI,CAACG,IAAI;MACjBC,IAAI,EAAE,CAAC,CAACJ,IAAI,CAACI,IAAI;MACjBC,IAAI,EAAE,CAAC,CAACL,IAAI,CAACK,IAAI;MACjBC,KAAK,EAAE,CAAC,CAACN,IAAI,CAACM,KAAK;MACnBC,IAAI,EAAE,CAAC,CAACP,IAAI,CAACO,IAAI;MACjBC,IAAI,EAAE,CAAC,CAACR,IAAI,CAACQ;KAChB;IAED,IAAItD,wBAAwB,CAACS,kBAAkB,EAAE;MAC7C,OAAOT,wBAAwB,CAACS,kBAAkB,CAAC2B,IAAI,CAAEmB,UAAU,IAAI;QACnE,OAAO,IAAIvC,OAAO,CAAC,CAACC,OAAO,EAAEO,MAAM,KAAI;UACnC+B,UAAU,CAACC,IAAI,CAAC,CAAC/B,MAAM,EAAEgC,UAAU,KAAI;YACnC,MAAM/B,OAAO,GAAIC,KAAiB,IAAI;cAClCF,MAAM,CAACG,mBAAmB,CAAC,OAAO,EAAEF,OAAO,CAAC;cAC5CD,MAAM,CAACG,mBAAmB,CAAC,SAAS,EAAEC,SAAS,CAAC;cAChDL,MAAM,CAACG,KAAK,CAAC;cACb8B,UAAU,EAAE;YAChB,CAAC;YAED,MAAM5B,SAAS,GAAIC,OAAqB,IAAI;cACxC,IAAIA,OAAO,CAACC,IAAI,CAACC,MAAM,KAAK,SAAS,EAAE;gBACnCP,MAAM,CAACG,mBAAmB,CAAC,OAAO,EAAEF,OAAO,CAAC;gBAC5CD,MAAM,CAACG,mBAAmB,CAAC,SAAS,EAAEC,SAAS,CAAC;gBAChD,IAAI,CAACC,OAAO,CAACC,IAAI,CAAC2B,OAAO,EAAE;kBACvBlC,MAAM,CAAC;oBAAEM,OAAO,EAAEA,OAAO,CAACC,IAAI,CAAC4B;kBAAG,CAAE,CAAC;iBACxC,MAAM;kBACH,IAAI;oBACA,IAAI,CAACC,cAAc,CAAC9B,OAAO,CAACC,IAAI,CAAC8B,WAAW,EAAEhB,eAAe,EAAExD,OAAO,CAAC;oBACvE4B,OAAO,EAAE;mBACZ,CAAC,OAAO6C,GAAG,EAAE;oBACVtC,MAAM,CAAC;sBAAEM,OAAO,EAAEgC;oBAAG,CAAE,CAAC;;;gBAGhCL,UAAU,EAAE;;YAEpB,CAAC;YAEDhC,MAAM,CAACQ,gBAAgB,CAAC,OAAO,EAAEP,OAAO,CAAC;YACzCD,MAAM,CAACQ,gBAAgB,CAAC,SAAS,EAAEJ,SAAS,CAAC;YAC7CJ,MAAM,CAACS,WAAW,CAAC;cAAEF,MAAM,EAAE,0BAA0B;cAAE3C,OAAO,EAAEW,wBAAwB,CAAC+D,qBAAqB,CAAC3E,sBAAsB;YAAE,CAAE,CAAC;YAE5I,MAAM4E,QAAQ,GAAG,IAAIC,UAAU,CAAClC,IAAI,CAACmC,UAAU,CAAC;YAChDF,QAAQ,CAACG,GAAG,CAAC,IAAIF,UAAU,CAAClC,IAAI,CAACqC,MAAM,EAAErC,IAAI,CAACsC,UAAU,EAAEtC,IAAI,CAACmC,UAAU,CAAC,CAAC;YAE3EzC,MAAM,CAACS,WAAW,CAAC;cAAEF,MAAM,EAAE,QAAQ;cAAED,IAAI,EAAEiC,QAAQ;cAAElB,IAAI,EAAEE,sBAAsB;cAAE3D;YAAO,CAAE,EAAE,CAAC2E,QAAQ,CAACI,MAAM,CAAC,CAAC;UACtH,CAAC,CAAC;QACN,CAAC,CAAC;MACN,CAAC,CAAC;KACL,MAAM,IAAIpE,wBAAwB,CAACU,qBAAqB,EAAE;MACvD,OAAOV,wBAAwB,CAACU,qBAAqB,CAAC0B,IAAI,CAAEkC,OAAO,IAAI;QACnE,IAAItE,wBAAwB,CAAC+D,qBAAqB,CAACxF,OAAO,EAAE;UACxDxB,WAAW,CAACyF,WAAW,CAACuB,qBAAqB,GAAG/D,wBAAwB,CAAC+D,qBAAqB,CAAC3E,sBAAsB,EAAE;;QAE3H,OAAO,IAAI4B,OAAO,CAAC,CAACC,OAAO,EAAEO,MAAM,KAAI;UACnC8C,OAAO,CACFC,MAAM,CAACxC,IAAI,EAAEe,IAAI,CAAC,CAClBV,IAAI,CAAEL,IAAkB,IAAI;YACzB,IAAI,CAAC6B,cAAc,CAAC7B,IAAI,EAAEc,eAAe,CAAC;YAC1C5B,OAAO,EAAE;UACb,CAAC,CAAC,CACDuD,KAAK,CAAEC,MAAW,IAAI;YACnBjD,MAAM,CAAC;cAAEM,OAAO,EAAE2C;YAAM,CAAE,CAAC;UAC/B,CAAC,CAAC;QACV,CAAC,CAAC;MACN,CAAC,CAAC;;IAGN,MAAM,IAAIC,KAAK,CAAC,sCAAsC,CAAC;EAC3D;EAEUd,cAAcA,CAAC7B,IAAkB,EAAEc,eAAgC,EAAExD,OAA4C;IACvH,MAAMsF,YAAY,GAAG,IAAI,CAAC,CAAC;IAE3B,IAAI,CAAChC,OAAO,CAACiC,oBAAoB,CAACD,YAAY,EAAE9B,eAAe,CAAC;IAEhE,IAAIxD,OAAO,EAAE;MACT;MACAA,OAAO,CAACwF,gBAAgB,GAAG9C,IAAI,CAAC8C,gBAAgB;MAChDxF,OAAO,CAACyF,cAAc,GAAG/C,IAAI,CAAC+C,cAAc;MAC5CzF,OAAO,CAAC0F,QAAQ,GAAGhD,IAAI,CAACgD,QAAQ;MAChC1F,OAAO,CAAC2F,cAAc,GAAGjD,IAAI,CAACiD,cAAc;;IAGhD,IAAIC,oBAAoB,GAAG,IAAI;IAE/B,QAAQlD,IAAI,CAAC8C,gBAAgB;MACzB,KAAK,MAAM,CAAC;QACRhC,eAAe,CAACtB,IAAI,GAAG;QACvBsB,eAAe,CAACqC,MAAM,GAAG;QACzB;MACJ,KAAK,MAAM,CAAC;QACRrC,eAAe,CAACtB,IAAI,GAAG;QACvBsB,eAAe,CAACqC,MAAM,GAAG;QACzB;MACJ,KAAK,MAAM,CAAC;QACRrC,eAAe,CAACtB,IAAI,GAAG;QACvBsB,eAAe,CAACqC,MAAM,GAAG;QACzB;MACJ;QACIrC,eAAe,CAACqC,MAAM,GAAGnD,IAAI,CAAC8C,gBAAgB;QAC9CI,oBAAoB,GAAG,KAAK;QAC5B;;IAGRpC,eAAe,CAACsC,WAAW,GAAGpD,IAAI,CAAC+C,cAAc;IACjDjC,eAAe,CAACuC,eAAe,GAAGrD,IAAI,CAACsD,OAAO,CAACC,MAAM,GAAG,CAAC;IAEzD,IAAIvD,IAAI,CAACwD,MAAM,EAAE;MACb,MAAM,IAAIb,KAAK,CAAC,iDAAiD,GAAG3C,IAAI,CAACwD,MAAM,CAAC;;IAGpF,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGzD,IAAI,CAACsD,OAAO,CAACC,MAAM,EAAE,EAAEE,CAAC,EAAE;MAC1C,MAAMC,MAAM,GAAG1D,IAAI,CAACsD,OAAO,CAACG,CAAC,CAAC;MAE9B,IAAI,CAACC,MAAM,IAAI,CAACA,MAAM,CAAC1D,IAAI,EAAE;QACzB,MAAM,IAAI2C,KAAK,CAAC,uDAAuD,CAAC;;MAG5E,IAAIO,oBAAoB,EAAE;QACtB;QACApC,eAAe,CAAC6C,KAAK,GAAGD,MAAM,CAACC,KAAK,CAAC,CAAC;QACtC7C,eAAe,CAAC8C,MAAM,GAAGF,MAAM,CAACE,MAAM;QAEtC,IAAI,CAAChD,OAAO,CAACiD,4BAA4B,CAAC/C,eAAe,EAAE4C,MAAM,CAAC1D,IAAI,EAAE,CAAC,EAAEyD,CAAC,EAAEK,SAAS,EAAE,IAAI,CAAC;OACjG,MAAM;QACH,IAAI,CAAClD,OAAO,CAACmD,sCAAsC,CAACjD,eAAe,EAAEd,IAAI,CAAC8C,gBAAgB,EAAEY,MAAM,CAACC,KAAK,EAAED,MAAM,CAACE,MAAM,EAAEF,MAAM,CAAC1D,IAAI,EAAE,CAAC,EAAEyD,CAAC,CAAC;;;IAInJ3C,eAAe,CAACkD,UAAU,GAAG,OAAO;IACpClD,eAAe,CAAC6C,KAAK,GAAG3D,IAAI,CAACsD,OAAO,CAAC,CAAC,CAAC,CAACK,KAAK;IAC7C7C,eAAe,CAAC8C,MAAM,GAAG5D,IAAI,CAACsD,OAAO,CAAC,CAAC,CAAC,CAACM,MAAM;IAC/C9C,eAAe,CAACmD,OAAO,GAAG,IAAI;IAE9B,IAAI,CAACrD,OAAO,CAACiC,oBAAoB,CAACD,YAAY,EAAE,IAAI,CAAC;EACzD;EAEA;;;;;EAKO,OAAOsB,OAAOA,CAAClE,IAAqB;IACvC,IAAIA,IAAI,CAACmC,UAAU,IAAI,EAAE,EAAE;MACvB;MACA,MAAMgC,UAAU,GAAG,IAAIjC,UAAU,CAAClC,IAAI,CAACqC,MAAM,EAAErC,IAAI,CAACsC,UAAU,EAAE,EAAE,CAAC;MACnE,IACI6B,UAAU,CAAC,CAAC,CAAC,KAAK,IAAI,IACtBA,UAAU,CAAC,CAAC,CAAC,KAAK,IAAI,IACtBA,UAAU,CAAC,CAAC,CAAC,KAAK,IAAI,IACtBA,UAAU,CAAC,CAAC,CAAC,KAAK,IAAI,IACtBA,UAAU,CAAC,CAAC,CAAC,KAAK,IAAI,IACtBA,UAAU,CAAC,CAAC,CAAC,KAAK,IAAI,IACtBA,UAAU,CAAC,CAAC,CAAC,KAAK,IAAI,IACtBA,UAAU,CAAC,CAAC,CAAC,KAAK,IAAI,IACtBA,UAAU,CAAC,CAAC,CAAC,KAAK,IAAI,IACtBA,UAAU,CAAC,CAAC,CAAC,KAAK,IAAI,IACtBA,UAAU,CAAC,EAAE,CAAC,KAAK,IAAI,IACvBA,UAAU,CAAC,EAAE,CAAC,KAAK,IAAI,EACzB;QACE,OAAO,IAAI;;;IAInB,OAAO,KAAK;EAChB;;AA1TA;;;;;;;;;;;;;;;;;AAiBclG,wBAAA,CAAAa,SAAS,GAWnB;EACAF,eAAe,EAAE,wBAAwB;EACzC7D,eAAe,EAAE,IAAI;EACrBI,cAAc,EAAE,IAAI;EACpBE,qBAAqB,EAAE,IAAI;EAC3BE,oBAAoB,EAAE,IAAI;EAC1BE,mBAAmB,EAAE,IAAI;EACzBE,oBAAoB,EAAE,IAAI;EAC1BE,eAAe,EAAE,IAAI;EACrBG,iBAAiB,EAAE,IAAI;EACvBC,eAAe,EAAE;CACpB;AAED;;;AAGcgC,wBAAA,CAAA0C,iBAAiB,GAAG1C,wBAAwB,CAACC,oBAAoB,EAAE;AAEjF;;;;AAIcD,wBAAA,CAAA+D,qBAAqB,GAAG,IAAI7F,yBAAyB,EAAE;AA8QzE,SAASiD,UAAUA,CAAA;EACf,IAAIgF,WAAgB;EAEpBC,SAAS,GAAIC,KAAK,IAAI;IAClB,IAAI,CAACA,KAAK,CAACtE,IAAI,EAAE;MACb;;IAEJ,QAAQsE,KAAK,CAACtE,IAAI,CAACC,MAAM;MACrB,KAAK,MAAM;QAAE;UACT,MAAMnF,IAAI,GAAGwJ,KAAK,CAACtE,IAAI,CAAClF,IAAI;UAC5ByJ,aAAa,CAACzJ,IAAI,CAAC8D,eAAe,CAAC;UACnC/D,WAAW,CAACC,IAAI,CAAC;UACjBsJ,WAAW,GAAG,IAAIpJ,WAAW,CAACyF,WAAW,EAAE;UAC3CN,WAAW,CAAC;YAAEF,MAAM,EAAE;UAAM,CAAE,CAAC;UAC/B;;MAEJ,KAAK,0BAA0B;QAAE;UAC7BjF,WAAW,CAACyF,WAAW,CAACuB,qBAAqB,GAAGsC,KAAK,CAACtE,IAAI,CAAC1C,OAAO;UAClE;;MAEJ,KAAK,QAAQ;QACT8G,WAAW,CACN5B,MAAM,CAAC8B,KAAK,CAACtE,IAAI,CAACA,IAAI,EAAEsE,KAAK,CAACtE,IAAI,CAACe,IAAI,EAAEuD,KAAK,CAACtE,IAAI,CAAC1C,OAAO,CAAC,CAC5D+C,IAAI,CAAEL,IAAkB,IAAI;UACzB,MAAMwE,OAAO,GAAG,EAAE;UAClB,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGzE,IAAI,CAACsD,OAAO,CAACC,MAAM,EAAE,EAAEkB,GAAG,EAAE;YAChD,MAAMf,MAAM,GAAG1D,IAAI,CAACsD,OAAO,CAACmB,GAAG,CAAC;YAChC,IAAIf,MAAM,IAAIA,MAAM,CAAC1D,IAAI,EAAE;cACvBwE,OAAO,CAAC/C,IAAI,CAACiC,MAAM,CAAC1D,IAAI,CAACqC,MAAM,CAAC;;;UAGxClC,WAAW,CAAC;YAAEF,MAAM,EAAE,SAAS;YAAE0B,OAAO,EAAE,IAAI;YAAEG,WAAW,EAAE9B;UAAI,CAAE,EAAEwE,OAAO,CAAC;QACjF,CAAC,CAAC,CACD/B,KAAK,CAAEC,MAAW,IAAI;UACnBvC,WAAW,CAAC;YAAEF,MAAM,EAAE,SAAS;YAAE0B,OAAO,EAAE,KAAK;YAAEC,GAAG,EAAEc;UAAM,CAAE,CAAC;QACnE,CAAC,CAAC;QACN;;EAEZ,CAAC;AACL"},"metadata":{},"sourceType":"module","externalDependencies":[]}