{"ast":null,"code":"import { TransformNode } from \"../Meshes/transformNode.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { BackgroundMaterial } from \"../Materials/Background/backgroundMaterial.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Axis } from \"../Maths/math.js\";\n/**\n * Display a 360/180 degree texture on an approximately spherical surface, useful for VR applications or skyboxes.\n * As a subclass of TransformNode, this allow parenting to the camera or multiple textures with different locations in the scene.\n * This class achieves its effect with a Texture and a correctly configured BackgroundMaterial on an inverted sphere.\n * Potential additions to this helper include zoom and and non-infinite distance rendering effects.\n */\nexport class TextureDome extends TransformNode {\n  /**\n   * Gets the texture being displayed on the sphere\n   */\n  get texture() {\n    return this._texture;\n  }\n  /**\n   * Sets the texture being displayed on the sphere\n   */\n  set texture(newTexture) {\n    if (this._texture === newTexture) {\n      return;\n    }\n    this._texture = newTexture;\n    if (this._useDirectMapping) {\n      this._texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n      this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n      this._material.diffuseTexture = this._texture;\n    } else {\n      this._texture.coordinatesMode = Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE; // matches orientation\n      this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n      this._material.reflectionTexture = this._texture;\n    }\n    this._changeTextureMode(this._textureMode);\n  }\n  /**\n   * Gets the mesh used for the dome.\n   */\n  get mesh() {\n    return this._mesh;\n  }\n  /**\n   * The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values \"zoom in\" and higher values \"zoom out\".\n   * Also see the options.resolution property.\n   */\n  get fovMultiplier() {\n    return this._material.fovMultiplier;\n  }\n  set fovMultiplier(value) {\n    this._material.fovMultiplier = value;\n  }\n  /**\n   * Gets or set the current texture mode for the texture. It can be:\n   * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.\n   * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.\n   * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.\n   */\n  get textureMode() {\n    return this._textureMode;\n  }\n  /**\n   * Sets the current texture mode for the texture. It can be:\n   * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.\n   * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.\n   * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.\n   */\n  set textureMode(value) {\n    if (this._textureMode === value) {\n      return;\n    }\n    this._changeTextureMode(value);\n  }\n  /**\n   * Is it a 180 degrees dome (half dome) or 360 texture (full dome)\n   */\n  get halfDome() {\n    return this._halfDome;\n  }\n  /**\n   * Set the halfDome mode. If set, only the front (180 degrees) will be displayed and the back will be blacked out.\n   */\n  set halfDome(enabled) {\n    this._halfDome = enabled;\n    this._halfDomeMask.setEnabled(enabled);\n    this._changeTextureMode(this._textureMode);\n  }\n  /**\n   * Set the cross-eye mode. If set, images that can be seen when crossing eyes will render correctly\n   */\n  set crossEye(enabled) {\n    this._crossEye = enabled;\n    this._changeTextureMode(this._textureMode);\n  }\n  /**\n   * Is it a cross-eye texture?\n   */\n  get crossEye() {\n    return this._crossEye;\n  }\n  /**\n   * The background material of this dome.\n   */\n  get material() {\n    return this._material;\n  }\n  /**\n   * Create an instance of this class and pass through the parameters to the relevant classes- Texture, StandardMaterial, and Mesh.\n   * @param name Element's name, child elements will append suffixes for their own names.\n   * @param textureUrlOrElement defines the url(s) or the (video) HTML element to use\n   * @param options An object containing optional or exposed sub element properties\n   * @param options.resolution\n   * @param options.clickToPlay\n   * @param options.autoPlay\n   * @param options.loop\n   * @param options.size\n   * @param options.poster\n   * @param options.faceForward\n   * @param options.useDirectMapping\n   * @param options.halfDomeMode\n   * @param options.crossEyeMode\n   * @param options.generateMipMaps\n   * @param options.mesh\n   * @param scene\n   * @param onError\n   */\n  constructor(name, textureUrlOrElement, options, scene,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  onError = null) {\n    super(name, scene);\n    this.onError = onError;\n    this._halfDome = false;\n    this._crossEye = false;\n    this._useDirectMapping = false;\n    this._textureMode = TextureDome.MODE_MONOSCOPIC;\n    /**\n     * Oberserver used in Stereoscopic VR Mode.\n     */\n    this._onBeforeCameraRenderObserver = null;\n    /**\n     * Observable raised when an error occurred while loading the texture\n     */\n    this.onLoadErrorObservable = new Observable();\n    /**\n     * Observable raised when the texture finished loading\n     */\n    this.onLoadObservable = new Observable();\n    scene = this.getScene();\n    // set defaults and manage values\n    name = name || \"textureDome\";\n    options.resolution = Math.abs(options.resolution) | 0 || 32;\n    options.clickToPlay = Boolean(options.clickToPlay);\n    options.autoPlay = options.autoPlay === undefined ? true : Boolean(options.autoPlay);\n    options.loop = options.loop === undefined ? true : Boolean(options.loop);\n    options.size = Math.abs(options.size) || (scene.activeCamera ? scene.activeCamera.maxZ * 0.48 : 1000);\n    if (options.useDirectMapping === undefined) {\n      this._useDirectMapping = true;\n    } else {\n      this._useDirectMapping = options.useDirectMapping;\n    }\n    if (options.faceForward === undefined) {\n      options.faceForward = true;\n    }\n    this._setReady(false);\n    if (!options.mesh) {\n      this._mesh = CreateSphere(name + \"_mesh\", {\n        segments: options.resolution,\n        diameter: options.size,\n        updatable: false,\n        sideOrientation: Mesh.BACKSIDE\n      }, scene);\n    } else {\n      this._mesh = options.mesh;\n    }\n    // configure material\n    const material = this._material = new BackgroundMaterial(name + \"_material\", scene);\n    material.useEquirectangularFOV = true;\n    material.fovMultiplier = 1.0;\n    material.opacityFresnel = false;\n    const texture = this._initTexture(textureUrlOrElement, scene, options);\n    this.texture = texture;\n    // configure mesh\n    this._mesh.material = material;\n    this._mesh.parent = this;\n    // create a (disabled until needed) mask to cover unneeded segments of 180 texture.\n    this._halfDomeMask = CreateSphere(\"\", {\n      slice: 0.5,\n      diameter: options.size * 0.98,\n      segments: options.resolution * 2,\n      sideOrientation: Mesh.BACKSIDE\n    }, scene);\n    this._halfDomeMask.rotate(Axis.X, -Math.PI / 2);\n    // set the parent, so it will always be positioned correctly AND will be disposed when the main sphere is disposed\n    this._halfDomeMask.parent = this._mesh;\n    this._halfDome = !!options.halfDomeMode;\n    // enable or disable according to the settings\n    this._halfDomeMask.setEnabled(this._halfDome);\n    this._crossEye = !!options.crossEyeMode;\n    // create\n    this._texture.anisotropicFilteringLevel = 1;\n    this._texture.onLoadObservable.addOnce(() => {\n      this._setReady(true);\n    });\n    // Initial rotation\n    if (options.faceForward && scene.activeCamera) {\n      const camera = scene.activeCamera;\n      const forward = Vector3.Forward();\n      const direction = Vector3.TransformNormal(forward, camera.getViewMatrix());\n      direction.normalize();\n      this.rotation.y = Math.acos(Vector3.Dot(forward, direction));\n    }\n    this._changeTextureMode(this._textureMode);\n  }\n  _changeTextureMode(value) {\n    this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n    this._textureMode = value;\n    // Default Setup and Reset.\n    this._texture.uScale = 1;\n    this._texture.vScale = 1;\n    this._texture.uOffset = 0;\n    this._texture.vOffset = 0;\n    this._texture.vAng = 0;\n    switch (value) {\n      case TextureDome.MODE_MONOSCOPIC:\n        if (this._halfDome) {\n          this._texture.uScale = 2;\n          this._texture.uOffset = -1;\n        }\n        break;\n      case TextureDome.MODE_SIDEBYSIDE:\n        {\n          // in half-dome mode the uScale should be double of 360 texture\n          // Use 0.99999 to boost perf by not switching program\n          this._texture.uScale = this._halfDome ? 0.99999 : 0.5;\n          const rightOffset = this._halfDome ? 0.0 : 0.5;\n          const leftOffset = this._halfDome ? -0.5 : 0.0;\n          this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add(camera => {\n            let isRightCamera = camera.isRightCamera;\n            if (this._crossEye) {\n              isRightCamera = !isRightCamera;\n            }\n            if (isRightCamera) {\n              this._texture.uOffset = rightOffset;\n            } else {\n              this._texture.uOffset = leftOffset;\n            }\n          });\n          break;\n        }\n      case TextureDome.MODE_TOPBOTTOM:\n        // in half-dome mode the vScale should be double of 360 texture\n        // Use 0.99999 to boost perf by not switching program\n        this._texture.vScale = this._halfDome ? 0.99999 : 0.5;\n        this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add(camera => {\n          let isRightCamera = camera.isRightCamera;\n          // allow \"cross-eye\" if left and right were switched in this mode\n          if (this._crossEye) {\n            isRightCamera = !isRightCamera;\n          }\n          this._texture.vOffset = isRightCamera ? 0.5 : 0.0;\n        });\n        break;\n    }\n  }\n  /**\n   * Releases resources associated with this node.\n   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n   */\n  dispose(doNotRecurse, disposeMaterialAndTextures = false) {\n    this._texture.dispose();\n    this._mesh.dispose();\n    this._material.dispose();\n    this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n    this.onLoadErrorObservable.clear();\n    this.onLoadObservable.clear();\n    super.dispose(doNotRecurse, disposeMaterialAndTextures);\n  }\n}\n/**\n * Define the source as a Monoscopic panoramic 360/180.\n */\nTextureDome.MODE_MONOSCOPIC = 0;\n/**\n * Define the source as a Stereoscopic TopBottom/OverUnder panoramic 360/180.\n */\nTextureDome.MODE_TOPBOTTOM = 1;\n/**\n * Define the source as a Stereoscopic Side by Side panoramic 360/180.\n */\nTextureDome.MODE_SIDEBYSIDE = 2;","map":{"version":3,"names":["TransformNode","Mesh","Texture","BackgroundMaterial","CreateSphere","Observable","Vector3","Axis","TextureDome","texture","_texture","newTexture","_useDirectMapping","wrapU","CLAMP_ADDRESSMODE","wrapV","_material","diffuseTexture","coordinatesMode","FIXED_EQUIRECTANGULAR_MIRRORED_MODE","reflectionTexture","_changeTextureMode","_textureMode","mesh","_mesh","fovMultiplier","value","textureMode","halfDome","_halfDome","enabled","_halfDomeMask","setEnabled","crossEye","_crossEye","material","constructor","name","textureUrlOrElement","options","scene","onError","MODE_MONOSCOPIC","_onBeforeCameraRenderObserver","onLoadErrorObservable","onLoadObservable","getScene","resolution","Math","abs","clickToPlay","Boolean","autoPlay","undefined","loop","size","activeCamera","maxZ","useDirectMapping","faceForward","_setReady","segments","diameter","updatable","sideOrientation","BACKSIDE","useEquirectangularFOV","opacityFresnel","_initTexture","parent","slice","rotate","X","PI","halfDomeMode","crossEyeMode","anisotropicFilteringLevel","addOnce","camera","forward","Forward","direction","TransformNormal","getViewMatrix","normalize","rotation","y","acos","Dot","_scene","onBeforeCameraRenderObservable","remove","uScale","vScale","uOffset","vOffset","vAng","MODE_SIDEBYSIDE","rightOffset","leftOffset","add","isRightCamera","MODE_TOPBOTTOM","dispose","doNotRecurse","disposeMaterialAndTextures","clear"],"sources":["../../../../dev/core/src/Helpers/textureDome.ts"],"sourcesContent":["import type { Scene } from \"../scene\";\r\nimport { TransformNode } from \"../Meshes/transformNode\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { BackgroundMaterial } from \"../Materials/Background/backgroundMaterial\";\r\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Axis } from \"../Maths/math\";\r\n\r\nimport type { Camera } from \"../Cameras/camera\";\r\n\r\n/**\r\n * Display a 360/180 degree texture on an approximately spherical surface, useful for VR applications or skyboxes.\r\n * As a subclass of TransformNode, this allow parenting to the camera or multiple textures with different locations in the scene.\r\n * This class achieves its effect with a Texture and a correctly configured BackgroundMaterial on an inverted sphere.\r\n * Potential additions to this helper include zoom and and non-infinite distance rendering effects.\r\n */\r\nexport abstract class TextureDome<T extends Texture> extends TransformNode {\r\n    /**\r\n     * Define the source as a Monoscopic panoramic 360/180.\r\n     */\r\n    public static readonly MODE_MONOSCOPIC = 0;\r\n    /**\r\n     * Define the source as a Stereoscopic TopBottom/OverUnder panoramic 360/180.\r\n     */\r\n    public static readonly MODE_TOPBOTTOM = 1;\r\n    /**\r\n     * Define the source as a Stereoscopic Side by Side panoramic 360/180.\r\n     */\r\n    public static readonly MODE_SIDEBYSIDE = 2;\r\n\r\n    private _halfDome: boolean = false;\r\n    private _crossEye: boolean = false;\r\n\r\n    protected _useDirectMapping = false;\r\n\r\n    /**\r\n     * The texture being displayed on the sphere\r\n     */\r\n    protected _texture: T;\r\n\r\n    /**\r\n     * Gets the texture being displayed on the sphere\r\n     */\r\n    public get texture(): T {\r\n        return this._texture;\r\n    }\r\n\r\n    /**\r\n     * Sets the texture being displayed on the sphere\r\n     */\r\n    public set texture(newTexture: T) {\r\n        if (this._texture === newTexture) {\r\n            return;\r\n        }\r\n        this._texture = newTexture;\r\n        if (this._useDirectMapping) {\r\n            this._texture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n            this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n            this._material.diffuseTexture = this._texture;\r\n        } else {\r\n            this._texture.coordinatesMode = Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE; // matches orientation\r\n            this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n            this._material.reflectionTexture = this._texture;\r\n        }\r\n        this._changeTextureMode(this._textureMode);\r\n    }\r\n\r\n    /**\r\n     * The skybox material\r\n     */\r\n    protected _material: BackgroundMaterial;\r\n\r\n    /**\r\n     * The surface used for the dome\r\n     */\r\n    protected _mesh: Mesh;\r\n    /**\r\n     * Gets the mesh used for the dome.\r\n     */\r\n    public get mesh(): Mesh {\r\n        return this._mesh;\r\n    }\r\n\r\n    /**\r\n     * A mesh that will be used to mask the back of the dome in case it is a 180 degree movie.\r\n     */\r\n    private _halfDomeMask: Mesh;\r\n\r\n    /**\r\n     * The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values \"zoom in\" and higher values \"zoom out\".\r\n     * Also see the options.resolution property.\r\n     */\r\n    public get fovMultiplier(): number {\r\n        return this._material.fovMultiplier;\r\n    }\r\n    public set fovMultiplier(value: number) {\r\n        this._material.fovMultiplier = value;\r\n    }\r\n\r\n    protected _textureMode = TextureDome.MODE_MONOSCOPIC;\r\n    /**\r\n     * Gets or set the current texture mode for the texture. It can be:\r\n     * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.\r\n     * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.\r\n     * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.\r\n     */\r\n    public get textureMode(): number {\r\n        return this._textureMode;\r\n    }\r\n    /**\r\n     * Sets the current texture mode for the texture. It can be:\r\n     * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.\r\n     * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.\r\n     * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.\r\n     */\r\n    public set textureMode(value: number) {\r\n        if (this._textureMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._changeTextureMode(value);\r\n    }\r\n\r\n    /**\r\n     * Is it a 180 degrees dome (half dome) or 360 texture (full dome)\r\n     */\r\n    public get halfDome(): boolean {\r\n        return this._halfDome;\r\n    }\r\n\r\n    /**\r\n     * Set the halfDome mode. If set, only the front (180 degrees) will be displayed and the back will be blacked out.\r\n     */\r\n    public set halfDome(enabled: boolean) {\r\n        this._halfDome = enabled;\r\n        this._halfDomeMask.setEnabled(enabled);\r\n        this._changeTextureMode(this._textureMode);\r\n    }\r\n\r\n    /**\r\n     * Set the cross-eye mode. If set, images that can be seen when crossing eyes will render correctly\r\n     */\r\n    public set crossEye(enabled: boolean) {\r\n        this._crossEye = enabled;\r\n        this._changeTextureMode(this._textureMode);\r\n    }\r\n\r\n    /**\r\n     * Is it a cross-eye texture?\r\n     */\r\n    public get crossEye(): boolean {\r\n        return this._crossEye;\r\n    }\r\n\r\n    /**\r\n     * The background material of this dome.\r\n     */\r\n    public get material(): BackgroundMaterial {\r\n        return this._material;\r\n    }\r\n\r\n    /**\r\n     * Oberserver used in Stereoscopic VR Mode.\r\n     */\r\n    private _onBeforeCameraRenderObserver: Nullable<Observer<Camera>> = null;\r\n    /**\r\n     * Observable raised when an error occurred while loading the texture\r\n     */\r\n    public onLoadErrorObservable = new Observable<string>();\r\n    /**\r\n     * Observable raised when the texture finished loading\r\n     */\r\n    public onLoadObservable = new Observable<void>();\r\n\r\n    /**\r\n     * Create an instance of this class and pass through the parameters to the relevant classes- Texture, StandardMaterial, and Mesh.\r\n     * @param name Element's name, child elements will append suffixes for their own names.\r\n     * @param textureUrlOrElement defines the url(s) or the (video) HTML element to use\r\n     * @param options An object containing optional or exposed sub element properties\r\n     * @param options.resolution\r\n     * @param options.clickToPlay\r\n     * @param options.autoPlay\r\n     * @param options.loop\r\n     * @param options.size\r\n     * @param options.poster\r\n     * @param options.faceForward\r\n     * @param options.useDirectMapping\r\n     * @param options.halfDomeMode\r\n     * @param options.crossEyeMode\r\n     * @param options.generateMipMaps\r\n     * @param options.mesh\r\n     * @param scene\r\n     * @param onError\r\n     */\r\n    constructor(\r\n        name: string,\r\n        textureUrlOrElement: string | string[] | HTMLVideoElement,\r\n        options: {\r\n            resolution?: number;\r\n            clickToPlay?: boolean;\r\n            autoPlay?: boolean;\r\n            loop?: boolean;\r\n            size?: number;\r\n            poster?: string;\r\n            faceForward?: boolean;\r\n            useDirectMapping?: boolean;\r\n            halfDomeMode?: boolean;\r\n            crossEyeMode?: boolean;\r\n            generateMipMaps?: boolean;\r\n            mesh?: Mesh;\r\n        },\r\n        scene: Scene,\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        protected onError: Nullable<(message?: string, exception?: any) => void> = null\r\n    ) {\r\n        super(name, scene);\r\n\r\n        scene = this.getScene();\r\n\r\n        // set defaults and manage values\r\n        name = name || \"textureDome\";\r\n        options.resolution = Math.abs(options.resolution as any) | 0 || 32;\r\n        options.clickToPlay = Boolean(options.clickToPlay);\r\n        options.autoPlay = options.autoPlay === undefined ? true : Boolean(options.autoPlay);\r\n        options.loop = options.loop === undefined ? true : Boolean(options.loop);\r\n        options.size = Math.abs(options.size as any) || (scene.activeCamera ? scene.activeCamera.maxZ * 0.48 : 1000);\r\n\r\n        if (options.useDirectMapping === undefined) {\r\n            this._useDirectMapping = true;\r\n        } else {\r\n            this._useDirectMapping = options.useDirectMapping;\r\n        }\r\n\r\n        if (options.faceForward === undefined) {\r\n            options.faceForward = true;\r\n        }\r\n\r\n        this._setReady(false);\r\n        if (!options.mesh) {\r\n            this._mesh = CreateSphere(name + \"_mesh\", { segments: options.resolution, diameter: options.size, updatable: false, sideOrientation: Mesh.BACKSIDE }, scene);\r\n        } else {\r\n            this._mesh = options.mesh;\r\n        }\r\n        // configure material\r\n        const material = (this._material = new BackgroundMaterial(name + \"_material\", scene));\r\n        material.useEquirectangularFOV = true;\r\n        material.fovMultiplier = 1.0;\r\n        material.opacityFresnel = false;\r\n\r\n        const texture = this._initTexture(textureUrlOrElement, scene, options);\r\n        this.texture = texture;\r\n\r\n        // configure mesh\r\n        this._mesh.material = material;\r\n        this._mesh.parent = this;\r\n\r\n        // create a (disabled until needed) mask to cover unneeded segments of 180 texture.\r\n        this._halfDomeMask = CreateSphere(\"\", { slice: 0.5, diameter: options.size * 0.98, segments: options.resolution * 2, sideOrientation: Mesh.BACKSIDE }, scene);\r\n        this._halfDomeMask.rotate(Axis.X, -Math.PI / 2);\r\n        // set the parent, so it will always be positioned correctly AND will be disposed when the main sphere is disposed\r\n        this._halfDomeMask.parent = this._mesh;\r\n        this._halfDome = !!options.halfDomeMode;\r\n        // enable or disable according to the settings\r\n        this._halfDomeMask.setEnabled(this._halfDome);\r\n        this._crossEye = !!options.crossEyeMode;\r\n\r\n        // create\r\n        this._texture.anisotropicFilteringLevel = 1;\r\n        this._texture.onLoadObservable.addOnce(() => {\r\n            this._setReady(true);\r\n        });\r\n\r\n        // Initial rotation\r\n        if (options.faceForward && scene.activeCamera) {\r\n            const camera = scene.activeCamera;\r\n\r\n            const forward = Vector3.Forward();\r\n            const direction = Vector3.TransformNormal(forward, camera.getViewMatrix());\r\n            direction.normalize();\r\n\r\n            this.rotation.y = Math.acos(Vector3.Dot(forward, direction));\r\n        }\r\n\r\n        this._changeTextureMode(this._textureMode);\r\n    }\r\n\r\n    protected abstract _initTexture(urlsOrElement: string | string[] | HTMLElement, scene: Scene, options: any): T;\r\n\r\n    protected _changeTextureMode(value: number): void {\r\n        this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\r\n        this._textureMode = value;\r\n\r\n        // Default Setup and Reset.\r\n        this._texture.uScale = 1;\r\n        this._texture.vScale = 1;\r\n        this._texture.uOffset = 0;\r\n        this._texture.vOffset = 0;\r\n        this._texture.vAng = 0;\r\n\r\n        switch (value) {\r\n            case TextureDome.MODE_MONOSCOPIC:\r\n                if (this._halfDome) {\r\n                    this._texture.uScale = 2;\r\n                    this._texture.uOffset = -1;\r\n                }\r\n                break;\r\n            case TextureDome.MODE_SIDEBYSIDE: {\r\n                // in half-dome mode the uScale should be double of 360 texture\r\n                // Use 0.99999 to boost perf by not switching program\r\n                this._texture.uScale = this._halfDome ? 0.99999 : 0.5;\r\n                const rightOffset = this._halfDome ? 0.0 : 0.5;\r\n                const leftOffset = this._halfDome ? -0.5 : 0.0;\r\n                this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add((camera) => {\r\n                    let isRightCamera = camera.isRightCamera;\r\n                    if (this._crossEye) {\r\n                        isRightCamera = !isRightCamera;\r\n                    }\r\n                    if (isRightCamera) {\r\n                        this._texture.uOffset = rightOffset;\r\n                    } else {\r\n                        this._texture.uOffset = leftOffset;\r\n                    }\r\n                });\r\n                break;\r\n            }\r\n            case TextureDome.MODE_TOPBOTTOM:\r\n                // in half-dome mode the vScale should be double of 360 texture\r\n                // Use 0.99999 to boost perf by not switching program\r\n                this._texture.vScale = this._halfDome ? 0.99999 : 0.5;\r\n                this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add((camera) => {\r\n                    let isRightCamera = camera.isRightCamera;\r\n                    // allow \"cross-eye\" if left and right were switched in this mode\r\n                    if (this._crossEye) {\r\n                        isRightCamera = !isRightCamera;\r\n                    }\r\n                    this._texture.vOffset = isRightCamera ? 0.5 : 0.0;\r\n                });\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this node.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        this._texture.dispose();\r\n        this._mesh.dispose();\r\n        this._material.dispose();\r\n\r\n        this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\r\n        this.onLoadErrorObservable.clear();\r\n        this.onLoadObservable.clear();\r\n\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}