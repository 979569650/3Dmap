{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { Texture } from \"../../../Textures/texture.js\";\nimport { NodeMaterial } from \"../../nodeMaterial.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { EngineStore } from \"../../../../Engines/engineStore.js\";\n/**\n * Block used to provide an image for a TextureBlock\n */\nexport class ImageSourceBlock extends NodeMaterialBlock {\n  /**\n   * Gets or sets the texture associated with the node\n   */\n  get texture() {\n    return this._texture;\n  }\n  set texture(texture) {\n    var _a;\n    if (this._texture === texture) {\n      return;\n    }\n    const scene = (_a = texture === null || texture === void 0 ? void 0 : texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;\n    if (!texture && scene) {\n      scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this._texture);\n      });\n    }\n    this._texture = texture;\n    if (texture && scene) {\n      scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(texture);\n      });\n    }\n  }\n  /**\n   * Gets the sampler name associated with this image source\n   */\n  get samplerName() {\n    return this._samplerName;\n  }\n  /**\n   * Creates a new ImageSourceBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.VertexAndFragment);\n    this.registerOutput(\"source\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(\"source\", this, NodeMaterialConnectionPointDirection.Output, ImageSourceBlock, \"ImageSourceBlock\"));\n  }\n  bind(effect) {\n    if (!this.texture) {\n      return;\n    }\n    effect.setTexture(this._samplerName, this.texture);\n  }\n  isReady() {\n    if (this.texture && !this.texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ImageSourceBlock\";\n  }\n  /**\n   * Gets the output component\n   */\n  get source() {\n    return this._outputs[0];\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    if (state.target === NodeMaterialBlockTargets.Vertex) {\n      this._samplerName = state._getFreeVariableName(this.name + \"Sampler\");\n      // Declarations\n      state.sharedData.blockingBlocks.push(this);\n      state.sharedData.textureBlocks.push(this);\n      state.sharedData.bindableBlocks.push(this);\n    }\n    state._emit2DSampler(this._samplerName);\n    return this;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode();\n    if (!this.texture) {\n      return codeString;\n    }\n    codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});\\n`;\n    codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};\\n`;\n    codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};\\n`;\n    codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};\\n`;\n    codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};\\n`;\n    codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};\\n`;\n    codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};\\n`;\n    codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};\\n`;\n    codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};\\n`;\n    codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};\\n`;\n    codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\n`;\n    return codeString;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    if (this.texture && !this.texture.isRenderTarget && this.texture.getClassName() !== \"VideoTexture\") {\n      serializationObject.texture = this.texture.serialize();\n    }\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime && serializationObject.texture.url !== undefined) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n    }\n  }\n}\nRegisterClass(\"BABYLON.ImageSourceBlock\", ImageSourceBlock);","map":{"version":3,"names":["NodeMaterialBlock","NodeMaterialBlockConnectionPointTypes","NodeMaterialConnectionPointDirection","NodeMaterialBlockTargets","RegisterClass","Texture","NodeMaterial","NodeMaterialConnectionPointCustomObject","EngineStore","ImageSourceBlock","texture","_texture","scene","_a","getScene","LastCreatedScene","markAllMaterialsAsDirty","mat","hasTexture","samplerName","_samplerName","constructor","name","VertexAndFragment","registerOutput","Object","Output","bind","effect","setTexture","isReady","isReadyOrNotBlocking","getClassName","source","_outputs","_buildBlock","state","target","Vertex","_getFreeVariableName","sharedData","blockingBlocks","push","textureBlocks","bindableBlocks","_emit2DSampler","_dumpPropertiesCode","codeString","_codeVariableName","noMipmap","invertY","samplingMode","wrapU","wrapV","uAng","vAng","wAng","uOffset","vOffset","uScale","vScale","coordinatesMode","serialize","serializationObject","isRenderTarget","_deserialize","rootUrl","IgnoreTexturesAtLoadTime","url","undefined","indexOf","Parse"],"sources":["../../../../../../../dev/core/src/Materials/Node/Blocks/Dual/imageSourceBlock.ts"],"sourcesContent":["import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport { Constants } from \"../../../../Engines/constants\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport { NodeMaterial } from \"../../nodeMaterial\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport { EngineStore } from \"../../../../Engines/engineStore\";\r\n/**\r\n * Block used to provide an image for a TextureBlock\r\n */\r\nexport class ImageSourceBlock extends NodeMaterialBlock {\r\n    private _samplerName: string;\r\n    protected _texture: Nullable<Texture>;\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public get texture(): Nullable<Texture> {\r\n        return this._texture;\r\n    }\r\n\r\n    public set texture(texture: Nullable<Texture>) {\r\n        if (this._texture === texture) {\r\n            return;\r\n        }\r\n\r\n        const scene = texture?.getScene() ?? EngineStore.LastCreatedScene;\r\n\r\n        if (!texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this._texture!);\r\n            });\r\n        }\r\n\r\n        this._texture = texture;\r\n\r\n        if (texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(texture);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the sampler name associated with this image source\r\n     */\r\n    public get samplerName(): string {\r\n        return this._samplerName;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ImageSourceBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this.registerOutput(\r\n            \"source\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"source\", this, NodeMaterialConnectionPointDirection.Output, ImageSourceBlock, \"ImageSourceBlock\")\r\n        );\r\n    }\r\n\r\n    public bind(effect: Effect) {\r\n        if (!this.texture) {\r\n            return;\r\n        }\r\n\r\n        effect.setTexture(this._samplerName, this.texture);\r\n    }\r\n\r\n    public isReady() {\r\n        if (this.texture && !this.texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ImageSourceBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get source(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\r\n            this._samplerName = state._getFreeVariableName(this.name + \"Sampler\");\r\n\r\n            // Declarations\r\n            state.sharedData.blockingBlocks.push(this);\r\n            state.sharedData.textureBlocks.push(this);\r\n            state.sharedData.bindableBlocks.push(this);\r\n        }\r\n\r\n        state._emit2DSampler(this._samplerName);\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        if (!this.texture) {\r\n            return codeString;\r\n        }\r\n\r\n        codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        if (this.texture && !this.texture.isRenderTarget && this.texture.getClassName() !== \"VideoTexture\") {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime && serializationObject.texture.url !== undefined) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl) as Texture;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ImageSourceBlock\", ImageSourceBlock);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}