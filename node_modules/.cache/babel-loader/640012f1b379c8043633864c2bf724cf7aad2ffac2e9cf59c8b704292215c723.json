{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Scene } from \"../../scene.js\";\nimport { SceneComponentConstants } from \"../../sceneComponent.js\";\nimport { FluidRenderingObjectParticleSystem } from \"./fluidRenderingObjectParticleSystem.js\";\nimport { FluidRenderingTargetRenderer } from \"./fluidRenderingTargetRenderer.js\";\nimport { FluidRenderingObjectCustomParticles } from \"./fluidRenderingObjectCustomParticles.js\";\nimport { FluidRenderingDepthTextureCopy } from \"./fluidRenderingDepthTextureCopy.js\";\nimport \"../../Shaders/fluidRenderingParticleDepth.vertex.js\";\nimport \"../../Shaders/fluidRenderingParticleDepth.fragment.js\";\nimport \"../../Shaders/fluidRenderingParticleThickness.vertex.js\";\nimport \"../../Shaders/fluidRenderingParticleThickness.fragment.js\";\nimport \"../../Shaders/fluidRenderingParticleDiffuse.vertex.js\";\nimport \"../../Shaders/fluidRenderingParticleDiffuse.fragment.js\";\nimport \"../../Shaders/fluidRenderingBilateralBlur.fragment.js\";\nimport \"../../Shaders/fluidRenderingStandardBlur.fragment.js\";\nimport \"../../Shaders/fluidRenderingRender.fragment.js\";\nObject.defineProperty(Scene.prototype, \"fluidRenderer\", {\n  get: function () {\n    return this._fluidRenderer;\n  },\n  set: function (value) {\n    this._fluidRenderer = value;\n  },\n  enumerable: true,\n  configurable: true\n});\nScene.prototype.enableFluidRenderer = function () {\n  if (this._fluidRenderer) {\n    return this._fluidRenderer;\n  }\n  this._fluidRenderer = new FluidRenderer(this);\n  return this._fluidRenderer;\n};\nScene.prototype.disableFluidRenderer = function () {\n  var _a;\n  (_a = this._fluidRenderer) === null || _a === void 0 ? void 0 : _a.dispose();\n  this._fluidRenderer = null;\n};\nfunction IsParticleSystemObject(obj) {\n  return !!obj.particleSystem;\n}\n/**\n * Defines the fluid renderer scene component responsible to render objects as fluids\n */\nexport class FluidRendererSceneComponent {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  constructor(scene) {\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_FLUIDRENDERER;\n    this.scene = scene;\n  }\n  /**\n   * Registers the component in a given scene\n   */\n  register() {\n    this.scene._gatherActiveCameraRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_FLUIDRENDERER, this, this._gatherActiveCameraRenderTargets);\n    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_FLUIDRENDERER, this, this._afterCameraDraw);\n  }\n  _gatherActiveCameraRenderTargets(_renderTargets) {\n    var _a;\n    (_a = this.scene.fluidRenderer) === null || _a === void 0 ? void 0 : _a._prepareRendering();\n  }\n  _afterCameraDraw(camera) {\n    var _a;\n    (_a = this.scene.fluidRenderer) === null || _a === void 0 ? void 0 : _a._render(camera);\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  rebuild() {\n    if (this.scene._fluidRenderer) {\n      // Release resources first\n      this.scene.disableFluidRenderer();\n      // Re-enable\n      this.scene.enableFluidRenderer();\n    }\n  }\n  /**\n   * Disposes the component and the associated resources\n   */\n  dispose() {\n    this.scene.disableFluidRenderer();\n  }\n}\n/**\n * Class responsible for fluid rendering.\n * It is implementing the method described in https://developer.download.nvidia.com/presentations/2010/gdc/Direct3D_Effects.pdf\n */\nexport class FluidRenderer {\n  /** @internal */\n  static _SceneComponentInitialization(scene) {\n    let component = scene._getComponent(SceneComponentConstants.NAME_FLUIDRENDERER);\n    if (!component) {\n      component = new FluidRendererSceneComponent(scene);\n      scene._addComponent(component);\n    }\n  }\n  /**\n   * Initializes the class\n   * @param scene Scene in which the objects are part of\n   */\n  constructor(scene) {\n    this._scene = scene;\n    this._engine = scene.getEngine();\n    this._onEngineResizeObserver = null;\n    this.renderObjects = [];\n    this.targetRenderers = [];\n    this._cameras = new Map();\n    FluidRenderer._SceneComponentInitialization(this._scene);\n    this._onEngineResizeObserver = this._engine.onResizeObservable.add(() => {\n      this._initialize();\n    });\n  }\n  /**\n   * Reinitializes the class\n   * Can be used if you change the object priority (FluidRenderingObject.priority), to make sure the objects are rendered in the right order\n   */\n  recreate() {\n    this._sortRenderingObjects();\n    this._initialize();\n  }\n  /**\n   * Gets the render object corresponding to a particle system (null if the particle system is not rendered as a fluid)\n   * @param ps The particle system\n   * @returns the render object corresponding to this particle system if any, otherwise null\n   */\n  getRenderObjectFromParticleSystem(ps) {\n    const index = this._getParticleSystemIndex(ps);\n    return index !== -1 ? this.renderObjects[index] : null;\n  }\n  /**\n   * Adds a particle system to the fluid renderer.\n   * @param ps particle system\n   * @param generateDiffuseTexture True if you want to generate a diffuse texture from the particle system and use it as part of the fluid rendering (default: false)\n   * @param targetRenderer The target renderer used to display the particle system as a fluid. If not provided, the method will create a new one\n   * @param camera The camera used by the target renderer (if the target renderer is created by the method)\n   * @returns the render object corresponding to the particle system\n   */\n  addParticleSystem(ps, generateDiffuseTexture, targetRenderer, camera) {\n    const object = new FluidRenderingObjectParticleSystem(this._scene, ps);\n    object.onParticleSizeChanged.add(() => this._setParticleSizeForRenderTargets());\n    if (!targetRenderer) {\n      targetRenderer = new FluidRenderingTargetRenderer(this._scene, camera);\n      this.targetRenderers.push(targetRenderer);\n    }\n    if (!targetRenderer._onUseVelocityChanged.hasObservers()) {\n      targetRenderer._onUseVelocityChanged.add(() => this._setUseVelocityForRenderObject());\n    }\n    if (generateDiffuseTexture !== undefined) {\n      targetRenderer.generateDiffuseTexture = generateDiffuseTexture;\n    }\n    const renderObject = {\n      object,\n      targetRenderer\n    };\n    this.renderObjects.push(renderObject);\n    this._sortRenderingObjects();\n    this._setParticleSizeForRenderTargets();\n    return renderObject;\n  }\n  /**\n   * Adds a custom particle set to the fluid renderer.\n   * @param buffers The list of buffers (should contain at least a \"position\" buffer!)\n   * @param numParticles Number of particles in each buffer\n   * @param generateDiffuseTexture True if you want to generate a diffuse texture from buffers and use it as part of the fluid rendering (default: false). For the texture to be generated correctly, you need a \"color\" buffer in the set!\n   * @param targetRenderer The target renderer used to display the particle system as a fluid. If not provided, the method will create a new one\n   * @param camera The camera used by the target renderer (if the target renderer is created by the method)\n   * @returns the render object corresponding to the custom particle set\n   */\n  addCustomParticles(buffers, numParticles, generateDiffuseTexture, targetRenderer, camera) {\n    const object = new FluidRenderingObjectCustomParticles(this._scene, buffers, numParticles);\n    object.onParticleSizeChanged.add(() => this._setParticleSizeForRenderTargets());\n    if (!targetRenderer) {\n      targetRenderer = new FluidRenderingTargetRenderer(this._scene, camera);\n      this.targetRenderers.push(targetRenderer);\n    }\n    if (!targetRenderer._onUseVelocityChanged.hasObservers()) {\n      targetRenderer._onUseVelocityChanged.add(() => this._setUseVelocityForRenderObject());\n    }\n    if (generateDiffuseTexture !== undefined) {\n      targetRenderer.generateDiffuseTexture = generateDiffuseTexture;\n    }\n    const renderObject = {\n      object,\n      targetRenderer\n    };\n    this.renderObjects.push(renderObject);\n    this._sortRenderingObjects();\n    this._setParticleSizeForRenderTargets();\n    return renderObject;\n  }\n  /**\n   * Removes a render object from the fluid renderer\n   * @param renderObject the render object to remove\n   * @param removeUnusedTargetRenderer True to remove/dispose of the target renderer if it's not used anymore (default: true)\n   * @returns True if the render object has been found and released, else false\n   */\n  removeRenderObject(renderObject, removeUnusedTargetRenderer = true) {\n    const index = this.renderObjects.indexOf(renderObject);\n    if (index === -1) {\n      return false;\n    }\n    renderObject.object.dispose();\n    this.renderObjects.splice(index, 1);\n    if (removeUnusedTargetRenderer && this._removeUnusedTargetRenderers()) {\n      this._initialize();\n    } else {\n      this._setParticleSizeForRenderTargets();\n    }\n    return true;\n  }\n  _sortRenderingObjects() {\n    this.renderObjects.sort((a, b) => {\n      return a.object.priority < b.object.priority ? -1 : a.object.priority > b.object.priority ? 1 : 0;\n    });\n  }\n  _removeUnusedTargetRenderers() {\n    const indexes = {};\n    for (let i = 0; i < this.renderObjects.length; ++i) {\n      const targetRenderer = this.renderObjects[i].targetRenderer;\n      indexes[this.targetRenderers.indexOf(targetRenderer)] = true;\n    }\n    let removed = false;\n    const newList = [];\n    for (let i = 0; i < this.targetRenderers.length; ++i) {\n      if (!indexes[i]) {\n        this.targetRenderers[i].dispose();\n        removed = true;\n      } else {\n        newList.push(this.targetRenderers[i]);\n      }\n    }\n    if (removed) {\n      this.targetRenderers.length = 0;\n      this.targetRenderers.push(...newList);\n    }\n    return removed;\n  }\n  _getParticleSystemIndex(ps) {\n    for (let i = 0; i < this.renderObjects.length; ++i) {\n      const obj = this.renderObjects[i].object;\n      if (IsParticleSystemObject(obj) && obj.particleSystem === ps) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  _initialize() {\n    for (let i = 0; i < this.targetRenderers.length; ++i) {\n      this.targetRenderers[i].dispose();\n    }\n    const cameras = new Map();\n    for (let i = 0; i < this.targetRenderers.length; ++i) {\n      const targetRenderer = this.targetRenderers[i];\n      targetRenderer._initialize();\n      if (targetRenderer.camera && targetRenderer._renderPostProcess) {\n        let list = cameras.get(targetRenderer.camera);\n        if (!list) {\n          list = [[], {}];\n          cameras.set(targetRenderer.camera, list);\n        }\n        list[0].push(targetRenderer);\n        targetRenderer.camera.attachPostProcess(targetRenderer._renderPostProcess, i);\n      }\n    }\n    let iterator = cameras.keys();\n    for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n      const camera = key.value;\n      const list = cameras.get(camera);\n      const firstPostProcess = camera._getFirstPostProcess();\n      if (!firstPostProcess) {\n        continue;\n      }\n      const [targetRenderers, copyDepthTextures] = list;\n      firstPostProcess.onSizeChangedObservable.add(() => {\n        var _a;\n        if (!firstPostProcess.inputTexture.depthStencilTexture) {\n          firstPostProcess.inputTexture.createDepthStencilTexture(0, true, this._engine.isStencilEnable, targetRenderers[0].samples, this._engine.isStencilEnable ? 13 : 14, `PostProcessRTTDepthStencil-${firstPostProcess.name}`);\n        }\n        for (const targetRenderer of targetRenderers) {\n          const thicknessRT = (_a = targetRenderer._thicknessRenderTarget) === null || _a === void 0 ? void 0 : _a.renderTarget;\n          const thicknessTexture = thicknessRT === null || thicknessRT === void 0 ? void 0 : thicknessRT.texture;\n          if (thicknessRT && thicknessTexture) {\n            const key = thicknessTexture.width + \"_\" + thicknessTexture.height;\n            let copyDepthTexture = copyDepthTextures[key];\n            if (!copyDepthTexture) {\n              copyDepthTexture = copyDepthTextures[key] = new FluidRenderingDepthTextureCopy(this._engine, thicknessTexture.width, thicknessTexture.height);\n            }\n            copyDepthTexture.depthRTWrapper._shareDepth(thicknessRT);\n          }\n        }\n      });\n    }\n    // Dispose the CopyDepthTexture instances that we don't need anymore\n    iterator = this._cameras.keys();\n    for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n      const camera = key.value;\n      const list = this._cameras.get(camera);\n      const copyDepthTextures = list[1];\n      const list2 = cameras.get(camera);\n      if (!list2) {\n        for (const key in copyDepthTextures) {\n          copyDepthTextures[key].dispose();\n        }\n      } else {\n        for (const key in copyDepthTextures) {\n          if (!list2[1][key]) {\n            copyDepthTextures[key].dispose();\n          }\n        }\n      }\n    }\n    this._cameras.clear();\n    this._cameras = cameras;\n    this._setParticleSizeForRenderTargets();\n  }\n  _setParticleSizeForRenderTargets() {\n    const particleSizes = new Map();\n    for (let i = 0; i < this.renderObjects.length; ++i) {\n      const renderingObject = this.renderObjects[i];\n      let curSize = particleSizes.get(renderingObject.targetRenderer);\n      if (curSize === undefined) {\n        curSize = 0;\n      }\n      particleSizes.set(renderingObject.targetRenderer, Math.max(curSize, renderingObject.object.particleSize));\n    }\n    particleSizes.forEach((particleSize, targetRenderer) => {\n      if (targetRenderer._depthRenderTarget) {\n        targetRenderer._depthRenderTarget.particleSize = particleSize;\n      }\n    });\n  }\n  _setUseVelocityForRenderObject() {\n    for (const renderingObject of this.renderObjects) {\n      renderingObject.object.useVelocity = renderingObject.targetRenderer.useVelocity;\n    }\n  }\n  /** @internal */\n  _prepareRendering() {\n    for (const renderer of this.targetRenderers) {\n      if (renderer.needInitialization) {\n        this._initialize();\n        return;\n      }\n    }\n  }\n  /** @internal */\n  _render(forCamera) {\n    var _a;\n    for (let i = 0; i < this.targetRenderers.length; ++i) {\n      if (!forCamera || this.targetRenderers[i].camera === forCamera) {\n        this.targetRenderers[i]._clearTargets();\n      }\n    }\n    const iterator = this._cameras.keys();\n    for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n      const camera = key.value;\n      const list = this._cameras.get(camera);\n      if (forCamera && camera !== forCamera) {\n        continue;\n      }\n      const firstPostProcess = camera._getFirstPostProcess();\n      if (!firstPostProcess) {\n        continue;\n      }\n      const sourceCopyDepth = (_a = firstPostProcess.inputTexture) === null || _a === void 0 ? void 0 : _a.depthStencilTexture;\n      if (sourceCopyDepth) {\n        const [targetRenderers, copyDepthTextures] = list;\n        for (const targetRenderer of targetRenderers) {\n          targetRenderer._bgDepthTexture = sourceCopyDepth;\n        }\n        for (const key in copyDepthTextures) {\n          copyDepthTextures[key].copy(sourceCopyDepth);\n        }\n      }\n    }\n    for (let i = 0; i < this.renderObjects.length; ++i) {\n      const renderingObject = this.renderObjects[i];\n      if (!forCamera || renderingObject.targetRenderer.camera === forCamera) {\n        renderingObject.targetRenderer._render(renderingObject.object);\n      }\n    }\n  }\n  /**\n   * Disposes of all the ressources used by the class\n   */\n  dispose() {\n    this._engine.onResizeObservable.remove(this._onEngineResizeObserver);\n    this._onEngineResizeObserver = null;\n    for (let i = 0; i < this.renderObjects.length; ++i) {\n      this.renderObjects[i].object.dispose();\n    }\n    for (let i = 0; i < this.targetRenderers.length; ++i) {\n      this.targetRenderers[i].dispose();\n    }\n    this._cameras.forEach(list => {\n      const copyDepthTextures = list[1];\n      for (const key in copyDepthTextures) {\n        copyDepthTextures[key].dispose();\n      }\n    });\n    this.renderObjects = [];\n    this.targetRenderers = [];\n    this._cameras.clear();\n  }\n}","map":{"version":3,"names":["Scene","SceneComponentConstants","FluidRenderingObjectParticleSystem","FluidRenderingTargetRenderer","FluidRenderingObjectCustomParticles","FluidRenderingDepthTextureCopy","Object","defineProperty","prototype","get","_fluidRenderer","set","value","enumerable","configurable","enableFluidRenderer","FluidRenderer","disableFluidRenderer","_a","dispose","IsParticleSystemObject","obj","particleSystem","FluidRendererSceneComponent","constructor","scene","name","NAME_FLUIDRENDERER","register","_gatherActiveCameraRenderTargetsStage","registerStep","STEP_GATHERACTIVECAMERARENDERTARGETS_FLUIDRENDERER","_gatherActiveCameraRenderTargets","_afterCameraDrawStage","STEP_AFTERCAMERADRAW_FLUIDRENDERER","_afterCameraDraw","_renderTargets","fluidRenderer","_prepareRendering","camera","_render","rebuild","_SceneComponentInitialization","component","_getComponent","_addComponent","_scene","_engine","getEngine","_onEngineResizeObserver","renderObjects","targetRenderers","_cameras","Map","onResizeObservable","add","_initialize","recreate","_sortRenderingObjects","getRenderObjectFromParticleSystem","ps","index","_getParticleSystemIndex","addParticleSystem","generateDiffuseTexture","targetRenderer","object","onParticleSizeChanged","_setParticleSizeForRenderTargets","push","_onUseVelocityChanged","hasObservers","_setUseVelocityForRenderObject","undefined","renderObject","addCustomParticles","buffers","numParticles","removeRenderObject","removeUnusedTargetRenderer","indexOf","splice","_removeUnusedTargetRenderers","sort","a","b","priority","indexes","i","length","removed","newList","cameras","_renderPostProcess","list","attachPostProcess","iterator","keys","key","next","done","firstPostProcess","_getFirstPostProcess","copyDepthTextures","onSizeChangedObservable","inputTexture","depthStencilTexture","createDepthStencilTexture","isStencilEnable","samples","thicknessRT","_thicknessRenderTarget","renderTarget","thicknessTexture","texture","width","height","copyDepthTexture","depthRTWrapper","_shareDepth","list2","clear","particleSizes","renderingObject","curSize","Math","max","particleSize","forEach","_depthRenderTarget","useVelocity","renderer","needInitialization","forCamera","_clearTargets","sourceCopyDepth","_bgDepthTexture","copy","remove"],"sources":["../../../../../dev/core/src/Rendering/fluidRenderer/fluidRenderer.ts"],"sourcesContent":["import { Scene } from \"core/scene\";\r\nimport type { Engine } from \"core/Engines/engine\";\r\nimport type { FloatArray, Nullable } from \"core/types\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\nimport type { IParticleSystem } from \"core/Particles/IParticleSystem\";\r\nimport type { ISceneComponent } from \"core/sceneComponent\";\r\nimport { SceneComponentConstants } from \"core/sceneComponent\";\r\nimport type { SmartArrayNoDuplicate } from \"core/Misc/smartArray\";\r\nimport type { RenderTargetTexture } from \"core/Materials/Textures/renderTargetTexture\";\r\nimport { Constants } from \"core/Engines/constants\";\r\n\r\nimport type { FluidRenderingObject } from \"./fluidRenderingObject\";\r\nimport { FluidRenderingObjectParticleSystem } from \"./fluidRenderingObjectParticleSystem\";\r\nimport { FluidRenderingTargetRenderer } from \"./fluidRenderingTargetRenderer\";\r\nimport { FluidRenderingObjectCustomParticles } from \"./fluidRenderingObjectCustomParticles\";\r\nimport { FluidRenderingDepthTextureCopy } from \"./fluidRenderingDepthTextureCopy\";\r\n\r\nimport \"../../Shaders/fluidRenderingParticleDepth.vertex\";\r\nimport \"../../Shaders/fluidRenderingParticleDepth.fragment\";\r\nimport \"../../Shaders/fluidRenderingParticleThickness.vertex\";\r\nimport \"../../Shaders/fluidRenderingParticleThickness.fragment\";\r\nimport \"../../Shaders/fluidRenderingParticleDiffuse.vertex\";\r\nimport \"../../Shaders/fluidRenderingParticleDiffuse.fragment\";\r\nimport \"../../Shaders/fluidRenderingBilateralBlur.fragment\";\r\nimport \"../../Shaders/fluidRenderingStandardBlur.fragment\";\r\nimport \"../../Shaders/fluidRenderingRender.fragment\";\r\n\r\ndeclare module \"../../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /** @internal (Backing field) */\r\n        _fluidRenderer: Nullable<FluidRenderer>;\r\n\r\n        /**\r\n         * Gets or Sets the fluid renderer associated to the scene.\r\n         */\r\n        fluidRenderer: Nullable<FluidRenderer>;\r\n\r\n        /**\r\n         * Enables the fluid renderer and associates it with the scene\r\n         * @returns the FluidRenderer\r\n         */\r\n        enableFluidRenderer(): Nullable<FluidRenderer>;\r\n\r\n        /**\r\n         * Disables the fluid renderer associated with the scene\r\n         */\r\n        disableFluidRenderer(): void;\r\n    }\r\n}\r\n\r\nObject.defineProperty(Scene.prototype, \"fluidRenderer\", {\r\n    get: function (this: Scene) {\r\n        return this._fluidRenderer;\r\n    },\r\n    set: function (this: Scene, value: Nullable<FluidRenderer>) {\r\n        this._fluidRenderer = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nScene.prototype.enableFluidRenderer = function (): Nullable<FluidRenderer> {\r\n    if (this._fluidRenderer) {\r\n        return this._fluidRenderer;\r\n    }\r\n\r\n    this._fluidRenderer = new FluidRenderer(this);\r\n\r\n    return this._fluidRenderer;\r\n};\r\n\r\nScene.prototype.disableFluidRenderer = function (): void {\r\n    this._fluidRenderer?.dispose();\r\n    this._fluidRenderer = null;\r\n};\r\n\r\ntype CameraMapForFluidRendering = [Array<FluidRenderingTargetRenderer>, { [key: string]: FluidRenderingDepthTextureCopy }];\r\n\r\nfunction IsParticleSystemObject(obj: FluidRenderingObject): obj is FluidRenderingObjectParticleSystem {\r\n    return !!(obj as FluidRenderingObjectParticleSystem).particleSystem;\r\n}\r\n\r\n/**\r\n * Defines the fluid renderer scene component responsible to render objects as fluids\r\n */\r\nexport class FluidRendererSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_FLUIDRENDERER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._gatherActiveCameraRenderTargetsStage.registerStep(\r\n            SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_FLUIDRENDERER,\r\n            this,\r\n            this._gatherActiveCameraRenderTargets\r\n        );\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_FLUIDRENDERER, this, this._afterCameraDraw);\r\n    }\r\n\r\n    private _gatherActiveCameraRenderTargets(_renderTargets: SmartArrayNoDuplicate<RenderTargetTexture>): void {\r\n        this.scene.fluidRenderer?._prepareRendering();\r\n    }\r\n\r\n    private _afterCameraDraw(camera: Camera) {\r\n        this.scene.fluidRenderer?._render(camera);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        if (this.scene._fluidRenderer) {\r\n            // Release resources first\r\n            this.scene.disableFluidRenderer();\r\n\r\n            // Re-enable\r\n            this.scene.enableFluidRenderer();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources\r\n     */\r\n    public dispose(): void {\r\n        this.scene.disableFluidRenderer();\r\n    }\r\n}\r\n\r\n/**\r\n * An object rendered as a fluid.\r\n * It consists of the object itself as well as the render target renderer (which is used to generate the textures (render target) needed for fluid rendering)\r\n */\r\nexport interface IFluidRenderingRenderObject {\r\n    /** object rendered as a fluid */\r\n    object: FluidRenderingObject;\r\n    /** target renderer used to render the fluid object */\r\n    targetRenderer: FluidRenderingTargetRenderer;\r\n}\r\n\r\n/**\r\n * Class responsible for fluid rendering.\r\n * It is implementing the method described in https://developer.download.nvidia.com/presentations/2010/gdc/Direct3D_Effects.pdf\r\n */\r\nexport class FluidRenderer {\r\n    /** @internal */\r\n    public static _SceneComponentInitialization(scene: Scene) {\r\n        let component = scene._getComponent(SceneComponentConstants.NAME_FLUIDRENDERER) as FluidRendererSceneComponent;\r\n        if (!component) {\r\n            component = new FluidRendererSceneComponent(scene);\r\n            scene._addComponent(component);\r\n        }\r\n    }\r\n\r\n    private _scene: Scene;\r\n    private _engine: Engine;\r\n    private _onEngineResizeObserver: Nullable<Observer<Engine>>;\r\n    private _cameras: Map<Camera, CameraMapForFluidRendering>;\r\n\r\n    /** Retrieves all the render objects managed by the class */\r\n    public readonly renderObjects: Array<IFluidRenderingRenderObject>;\r\n\r\n    /** Retrieves all the render target renderers managed by the class */\r\n    public readonly targetRenderers: FluidRenderingTargetRenderer[];\r\n\r\n    /**\r\n     * Initializes the class\r\n     * @param scene Scene in which the objects are part of\r\n     */\r\n    constructor(scene: Scene) {\r\n        this._scene = scene;\r\n        this._engine = scene.getEngine();\r\n        this._onEngineResizeObserver = null;\r\n        this.renderObjects = [];\r\n        this.targetRenderers = [];\r\n        this._cameras = new Map();\r\n\r\n        FluidRenderer._SceneComponentInitialization(this._scene);\r\n\r\n        this._onEngineResizeObserver = this._engine.onResizeObservable.add(() => {\r\n            this._initialize();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Reinitializes the class\r\n     * Can be used if you change the object priority (FluidRenderingObject.priority), to make sure the objects are rendered in the right order\r\n     */\r\n    public recreate(): void {\r\n        this._sortRenderingObjects();\r\n        this._initialize();\r\n    }\r\n\r\n    /**\r\n     * Gets the render object corresponding to a particle system (null if the particle system is not rendered as a fluid)\r\n     * @param ps The particle system\r\n     * @returns the render object corresponding to this particle system if any, otherwise null\r\n     */\r\n    public getRenderObjectFromParticleSystem(ps: IParticleSystem): Nullable<IFluidRenderingRenderObject> {\r\n        const index = this._getParticleSystemIndex(ps);\r\n        return index !== -1 ? this.renderObjects[index] : null;\r\n    }\r\n\r\n    /**\r\n     * Adds a particle system to the fluid renderer.\r\n     * @param ps particle system\r\n     * @param generateDiffuseTexture True if you want to generate a diffuse texture from the particle system and use it as part of the fluid rendering (default: false)\r\n     * @param targetRenderer The target renderer used to display the particle system as a fluid. If not provided, the method will create a new one\r\n     * @param camera The camera used by the target renderer (if the target renderer is created by the method)\r\n     * @returns the render object corresponding to the particle system\r\n     */\r\n    public addParticleSystem(ps: IParticleSystem, generateDiffuseTexture?: boolean, targetRenderer?: FluidRenderingTargetRenderer, camera?: Camera): IFluidRenderingRenderObject {\r\n        const object = new FluidRenderingObjectParticleSystem(this._scene, ps);\r\n\r\n        object.onParticleSizeChanged.add(() => this._setParticleSizeForRenderTargets());\r\n\r\n        if (!targetRenderer) {\r\n            targetRenderer = new FluidRenderingTargetRenderer(this._scene, camera);\r\n            this.targetRenderers.push(targetRenderer);\r\n        }\r\n\r\n        if (!targetRenderer._onUseVelocityChanged.hasObservers()) {\r\n            targetRenderer._onUseVelocityChanged.add(() => this._setUseVelocityForRenderObject());\r\n        }\r\n\r\n        if (generateDiffuseTexture !== undefined) {\r\n            targetRenderer.generateDiffuseTexture = generateDiffuseTexture;\r\n        }\r\n\r\n        const renderObject = { object, targetRenderer };\r\n\r\n        this.renderObjects.push(renderObject);\r\n\r\n        this._sortRenderingObjects();\r\n\r\n        this._setParticleSizeForRenderTargets();\r\n\r\n        return renderObject;\r\n    }\r\n\r\n    /**\r\n     * Adds a custom particle set to the fluid renderer.\r\n     * @param buffers The list of buffers (should contain at least a \"position\" buffer!)\r\n     * @param numParticles Number of particles in each buffer\r\n     * @param generateDiffuseTexture True if you want to generate a diffuse texture from buffers and use it as part of the fluid rendering (default: false). For the texture to be generated correctly, you need a \"color\" buffer in the set!\r\n     * @param targetRenderer The target renderer used to display the particle system as a fluid. If not provided, the method will create a new one\r\n     * @param camera The camera used by the target renderer (if the target renderer is created by the method)\r\n     * @returns the render object corresponding to the custom particle set\r\n     */\r\n    public addCustomParticles(\r\n        buffers: { [key: string]: FloatArray },\r\n        numParticles: number,\r\n        generateDiffuseTexture?: boolean,\r\n        targetRenderer?: FluidRenderingTargetRenderer,\r\n        camera?: Camera\r\n    ): IFluidRenderingRenderObject {\r\n        const object = new FluidRenderingObjectCustomParticles(this._scene, buffers, numParticles);\r\n\r\n        object.onParticleSizeChanged.add(() => this._setParticleSizeForRenderTargets());\r\n\r\n        if (!targetRenderer) {\r\n            targetRenderer = new FluidRenderingTargetRenderer(this._scene, camera);\r\n            this.targetRenderers.push(targetRenderer);\r\n        }\r\n\r\n        if (!targetRenderer._onUseVelocityChanged.hasObservers()) {\r\n            targetRenderer._onUseVelocityChanged.add(() => this._setUseVelocityForRenderObject());\r\n        }\r\n\r\n        if (generateDiffuseTexture !== undefined) {\r\n            targetRenderer.generateDiffuseTexture = generateDiffuseTexture;\r\n        }\r\n\r\n        const renderObject = { object, targetRenderer };\r\n\r\n        this.renderObjects.push(renderObject);\r\n\r\n        this._sortRenderingObjects();\r\n\r\n        this._setParticleSizeForRenderTargets();\r\n\r\n        return renderObject;\r\n    }\r\n\r\n    /**\r\n     * Removes a render object from the fluid renderer\r\n     * @param renderObject the render object to remove\r\n     * @param removeUnusedTargetRenderer True to remove/dispose of the target renderer if it's not used anymore (default: true)\r\n     * @returns True if the render object has been found and released, else false\r\n     */\r\n    public removeRenderObject(renderObject: IFluidRenderingRenderObject, removeUnusedTargetRenderer = true): boolean {\r\n        const index = this.renderObjects.indexOf(renderObject);\r\n        if (index === -1) {\r\n            return false;\r\n        }\r\n\r\n        renderObject.object.dispose();\r\n\r\n        this.renderObjects.splice(index, 1);\r\n\r\n        if (removeUnusedTargetRenderer && this._removeUnusedTargetRenderers()) {\r\n            this._initialize();\r\n        } else {\r\n            this._setParticleSizeForRenderTargets();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _sortRenderingObjects(): void {\r\n        this.renderObjects.sort((a, b) => {\r\n            return a.object.priority < b.object.priority ? -1 : a.object.priority > b.object.priority ? 1 : 0;\r\n        });\r\n    }\r\n\r\n    private _removeUnusedTargetRenderers(): boolean {\r\n        const indexes: { [id: number]: boolean } = {};\r\n\r\n        for (let i = 0; i < this.renderObjects.length; ++i) {\r\n            const targetRenderer = this.renderObjects[i].targetRenderer;\r\n            indexes[this.targetRenderers.indexOf(targetRenderer)] = true;\r\n        }\r\n\r\n        let removed = false;\r\n        const newList: Array<FluidRenderingTargetRenderer> = [];\r\n        for (let i = 0; i < this.targetRenderers.length; ++i) {\r\n            if (!indexes[i]) {\r\n                this.targetRenderers[i].dispose();\r\n                removed = true;\r\n            } else {\r\n                newList.push(this.targetRenderers[i]);\r\n            }\r\n        }\r\n\r\n        if (removed) {\r\n            this.targetRenderers.length = 0;\r\n            this.targetRenderers.push(...newList);\r\n        }\r\n\r\n        return removed;\r\n    }\r\n\r\n    private _getParticleSystemIndex(ps: IParticleSystem): number {\r\n        for (let i = 0; i < this.renderObjects.length; ++i) {\r\n            const obj = this.renderObjects[i].object;\r\n            if (IsParticleSystemObject(obj) && obj.particleSystem === ps) {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    private _initialize(): void {\r\n        for (let i = 0; i < this.targetRenderers.length; ++i) {\r\n            this.targetRenderers[i].dispose();\r\n        }\r\n\r\n        const cameras: Map<Camera, CameraMapForFluidRendering> = new Map();\r\n\r\n        for (let i = 0; i < this.targetRenderers.length; ++i) {\r\n            const targetRenderer = this.targetRenderers[i];\r\n\r\n            targetRenderer._initialize();\r\n\r\n            if (targetRenderer.camera && targetRenderer._renderPostProcess) {\r\n                let list = cameras.get(targetRenderer.camera);\r\n                if (!list) {\r\n                    list = [[], {}];\r\n                    cameras.set(targetRenderer.camera, list);\r\n                }\r\n                list[0].push(targetRenderer);\r\n                targetRenderer.camera.attachPostProcess(targetRenderer._renderPostProcess, i);\r\n            }\r\n        }\r\n\r\n        let iterator = cameras.keys();\r\n        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n            const camera = key.value;\r\n            const list = cameras.get(camera)!;\r\n\r\n            const firstPostProcess = camera._getFirstPostProcess();\r\n            if (!firstPostProcess) {\r\n                continue;\r\n            }\r\n\r\n            const [targetRenderers, copyDepthTextures] = list;\r\n\r\n            firstPostProcess.onSizeChangedObservable.add(() => {\r\n                if (!firstPostProcess.inputTexture.depthStencilTexture) {\r\n                    firstPostProcess.inputTexture.createDepthStencilTexture(\r\n                        0,\r\n                        true,\r\n                        this._engine.isStencilEnable,\r\n                        targetRenderers[0].samples,\r\n                        this._engine.isStencilEnable ? Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 : Constants.TEXTUREFORMAT_DEPTH32_FLOAT,\r\n                        `PostProcessRTTDepthStencil-${firstPostProcess.name}`\r\n                    );\r\n                }\r\n                for (const targetRenderer of targetRenderers) {\r\n                    const thicknessRT = targetRenderer._thicknessRenderTarget?.renderTarget;\r\n                    const thicknessTexture = thicknessRT?.texture;\r\n                    if (thicknessRT && thicknessTexture) {\r\n                        const key = thicknessTexture.width + \"_\" + thicknessTexture.height;\r\n                        let copyDepthTexture = copyDepthTextures[key];\r\n                        if (!copyDepthTexture) {\r\n                            copyDepthTexture = copyDepthTextures[key] = new FluidRenderingDepthTextureCopy(this._engine, thicknessTexture.width, thicknessTexture.height);\r\n                        }\r\n                        copyDepthTexture.depthRTWrapper._shareDepth(thicknessRT);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        // Dispose the CopyDepthTexture instances that we don't need anymore\r\n        iterator = this._cameras.keys();\r\n        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n            const camera = key.value;\r\n            const list = this._cameras.get(camera)!;\r\n\r\n            const copyDepthTextures = list[1];\r\n\r\n            const list2 = cameras.get(camera);\r\n            if (!list2) {\r\n                for (const key in copyDepthTextures) {\r\n                    copyDepthTextures[key].dispose();\r\n                }\r\n            } else {\r\n                for (const key in copyDepthTextures) {\r\n                    if (!list2[1][key]) {\r\n                        copyDepthTextures[key].dispose();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this._cameras.clear();\r\n        this._cameras = cameras;\r\n\r\n        this._setParticleSizeForRenderTargets();\r\n    }\r\n\r\n    private _setParticleSizeForRenderTargets(): void {\r\n        const particleSizes = new Map<FluidRenderingTargetRenderer, number>();\r\n\r\n        for (let i = 0; i < this.renderObjects.length; ++i) {\r\n            const renderingObject = this.renderObjects[i];\r\n            let curSize = particleSizes.get(renderingObject.targetRenderer);\r\n            if (curSize === undefined) {\r\n                curSize = 0;\r\n            }\r\n            particleSizes.set(renderingObject.targetRenderer, Math.max(curSize, renderingObject.object.particleSize));\r\n        }\r\n\r\n        particleSizes.forEach((particleSize, targetRenderer) => {\r\n            if (targetRenderer._depthRenderTarget) {\r\n                targetRenderer._depthRenderTarget.particleSize = particleSize;\r\n            }\r\n        });\r\n    }\r\n\r\n    private _setUseVelocityForRenderObject(): void {\r\n        for (const renderingObject of this.renderObjects) {\r\n            renderingObject.object.useVelocity = renderingObject.targetRenderer.useVelocity;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _prepareRendering(): void {\r\n        for (const renderer of this.targetRenderers) {\r\n            if (renderer.needInitialization) {\r\n                this._initialize();\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _render(forCamera?: Camera): void {\r\n        for (let i = 0; i < this.targetRenderers.length; ++i) {\r\n            if (!forCamera || this.targetRenderers[i].camera === forCamera) {\r\n                this.targetRenderers[i]._clearTargets();\r\n            }\r\n        }\r\n\r\n        const iterator = this._cameras.keys();\r\n        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n            const camera = key.value;\r\n            const list = this._cameras.get(camera)!;\r\n            if (forCamera && camera !== forCamera) {\r\n                continue;\r\n            }\r\n\r\n            const firstPostProcess = camera._getFirstPostProcess();\r\n            if (!firstPostProcess) {\r\n                continue;\r\n            }\r\n\r\n            const sourceCopyDepth = firstPostProcess.inputTexture?.depthStencilTexture;\r\n            if (sourceCopyDepth) {\r\n                const [targetRenderers, copyDepthTextures] = list;\r\n                for (const targetRenderer of targetRenderers) {\r\n                    targetRenderer._bgDepthTexture = sourceCopyDepth;\r\n                }\r\n                for (const key in copyDepthTextures) {\r\n                    copyDepthTextures[key].copy(sourceCopyDepth);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < this.renderObjects.length; ++i) {\r\n            const renderingObject = this.renderObjects[i];\r\n            if (!forCamera || renderingObject.targetRenderer.camera === forCamera) {\r\n                renderingObject.targetRenderer._render(renderingObject.object);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of all the ressources used by the class\r\n     */\r\n    public dispose(): void {\r\n        this._engine.onResizeObservable.remove(this._onEngineResizeObserver);\r\n        this._onEngineResizeObserver = null;\r\n\r\n        for (let i = 0; i < this.renderObjects.length; ++i) {\r\n            this.renderObjects[i].object.dispose();\r\n        }\r\n\r\n        for (let i = 0; i < this.targetRenderers.length; ++i) {\r\n            this.targetRenderers[i].dispose();\r\n        }\r\n\r\n        this._cameras.forEach((list) => {\r\n            const copyDepthTextures = list[1];\r\n            for (const key in copyDepthTextures) {\r\n                copyDepthTextures[key].dispose();\r\n            }\r\n        });\r\n\r\n        (this.renderObjects as Array<IFluidRenderingRenderObject>) = [];\r\n        (this.targetRenderers as FluidRenderingTargetRenderer[]) = [];\r\n        this._cameras.clear();\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}