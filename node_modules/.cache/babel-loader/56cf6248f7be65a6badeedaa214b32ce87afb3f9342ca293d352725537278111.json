{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Path2 } from \"../../Maths/math.path.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { ExtrudePolygon } from \"./polygonBuilder.js\";\n// Shape functions\nclass ShapePath {\n  /** Create the ShapePath used to support glyphs */\n  constructor(resolution) {\n    this._paths = [];\n    this._tempPaths = [];\n    this._holes = [];\n    this._resolution = resolution;\n  }\n  /** Move the virtual cursor to a coordinate */\n  moveTo(x, y) {\n    this._currentPath = new Path2(x, y);\n    this._tempPaths.push(this._currentPath);\n  }\n  /** Draw a line from the virtual cursor to a given coordinate */\n  lineTo(x, y) {\n    this._currentPath.addLineTo(x, y);\n  }\n  /** Create a quadratic curve from the virtual cursor to a given coordinate */\n  quadraticCurveTo(cpx, cpy, x, y) {\n    this._currentPath.addQuadraticCurveTo(cpx, cpy, x, y, this._resolution);\n  }\n  /** Create a bezier curve from the virtual cursor to a given coordinate */\n  bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, y) {\n    this._currentPath.addBezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, y, this._resolution);\n  }\n  /** Extract holes based on CW / CCW */\n  extractHoles() {\n    for (const path of this._tempPaths) {\n      if (path.area() > 0) {\n        this._holes.push(path);\n      } else {\n        this._paths.push(path);\n      }\n    }\n    if (!this._paths.length && this._holes.length) {\n      const temp = this._holes;\n      this._holes = this._paths;\n      this._paths = temp;\n    }\n    this._tempPaths.length = 0;\n  }\n  /** Gets the list of paths */\n  get paths() {\n    return this._paths;\n  }\n  /** Gets the list of holes */\n  get holes() {\n    return this._holes;\n  }\n}\n// Utility functions\nfunction CreateShapePath(char, scale, offsetX, offsetY, resolution, fontData) {\n  const glyph = fontData.glyphs[char] || fontData.glyphs[\"?\"];\n  if (!glyph) {\n    // return if there is no glyph data\n    return null;\n  }\n  const shapePath = new ShapePath(resolution);\n  if (glyph.o) {\n    const outline = glyph.o.split(\" \");\n    for (let i = 0, l = outline.length; i < l;) {\n      const action = outline[i++];\n      switch (action) {\n        case \"m\":\n          {\n            // moveTo\n            const x = parseInt(outline[i++]) * scale + offsetX;\n            const y = parseInt(outline[i++]) * scale + offsetY;\n            shapePath.moveTo(x, y);\n            break;\n          }\n        case \"l\":\n          {\n            // lineTo\n            const x = parseInt(outline[i++]) * scale + offsetX;\n            const y = parseInt(outline[i++]) * scale + offsetY;\n            shapePath.lineTo(x, y);\n            break;\n          }\n        case \"q\":\n          {\n            // quadraticCurveTo\n            const cpx = parseInt(outline[i++]) * scale + offsetX;\n            const cpy = parseInt(outline[i++]) * scale + offsetY;\n            const cpx1 = parseInt(outline[i++]) * scale + offsetX;\n            const cpy1 = parseInt(outline[i++]) * scale + offsetY;\n            shapePath.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n            break;\n          }\n        case \"b\":\n          {\n            // bezierCurveTo\n            const cpx = parseInt(outline[i++]) * scale + offsetX;\n            const cpy = parseInt(outline[i++]) * scale + offsetY;\n            const cpx1 = parseInt(outline[i++]) * scale + offsetX;\n            const cpy1 = parseInt(outline[i++]) * scale + offsetY;\n            const cpx2 = parseInt(outline[i++]) * scale + offsetX;\n            const cpy2 = parseInt(outline[i++]) * scale + offsetY;\n            shapePath.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\n            break;\n          }\n      }\n    }\n  }\n  // Extract holes (based on clockwise data)\n  shapePath.extractHoles();\n  return {\n    offsetX: glyph.ha * scale,\n    shapePath: shapePath\n  };\n}\n/**\n * Creates shape paths from a text and font\n * @param text the text\n * @param size size of the font\n * @param resolution resolution of the font\n * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)\n * @returns array of ShapePath objects\n */\nexport function CreateTextShapePaths(text, size, resolution, fontData) {\n  const chars = Array.from(text);\n  const scale = size / fontData.resolution;\n  const line_height = (fontData.boundingBox.yMax - fontData.boundingBox.yMin + fontData.underlineThickness) * scale;\n  const shapePaths = [];\n  let offsetX = 0,\n    offsetY = 0;\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n    if (char === \"\\n\") {\n      offsetX = 0;\n      offsetY -= line_height;\n    } else {\n      const ret = CreateShapePath(char, scale, offsetX, offsetY, resolution, fontData);\n      if (ret) {\n        offsetX += ret.offsetX;\n        shapePaths.push(ret.shapePath);\n      }\n    }\n  }\n  return shapePaths;\n}\n/**\n * Create a text mesh\n * @param name defines the name of the mesh\n * @param text defines the text to use to build the mesh\n * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)\n * @param options defines options used to create the mesh\n * @param scene defines the hosting scene\n * @param earcutInjection can be used to inject your own earcut reference\n * @returns a new Mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/text\n */\nexport function CreateText(name, text, fontData, options = {\n  size: 50,\n  resolution: 8,\n  depth: 1.0\n}, scene = null, earcutInjection = earcut) {\n  var _a, _b;\n  // First we need to generate the paths\n  const shapePaths = CreateTextShapePaths(text, options.size || 50, options.resolution || 8, fontData);\n  // And extrude them\n  const meshes = [];\n  let letterIndex = 0;\n  for (const shapePath of shapePaths) {\n    if (!shapePath.paths.length) {\n      continue;\n    }\n    const holes = shapePath.holes.slice(); // Copy it as we will update the copy\n    for (const path of shapePath.paths) {\n      const holeVectors = [];\n      const shapeVectors = [];\n      const points = path.getPoints();\n      for (const point of points) {\n        shapeVectors.push(new Vector3(point.x, 0, point.y)); // ExtrudePolygon expects data on the xz plane\n      }\n      // Holes\n      const localHolesCopy = holes.slice();\n      for (const hole of localHolesCopy) {\n        const points = hole.getPoints();\n        let found = false;\n        for (const point of points) {\n          if (path.isPointInside(point)) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          continue;\n        }\n        const holePoints = [];\n        for (const point of points) {\n          holePoints.push(new Vector3(point.x, 0, point.y)); // ExtrudePolygon expects data on the xz plane\n        }\n\n        holeVectors.push(holePoints);\n        // Remove the hole as it was already used\n        holes.splice(holes.indexOf(hole), 1);\n      }\n      // There is at least a hole but it was unaffected\n      if (!holeVectors.length && holes.length) {\n        for (const hole of holes) {\n          const points = hole.getPoints();\n          const holePoints = [];\n          for (const point of points) {\n            holePoints.push(new Vector3(point.x, 0, point.y)); // ExtrudePolygon expects data on the xz plane\n          }\n\n          holeVectors.push(holePoints);\n        }\n      }\n      // Extrusion!\n      const mesh = ExtrudePolygon(name, {\n        shape: shapeVectors,\n        holes: holeVectors.length ? holeVectors : undefined,\n        depth: options.depth || 1.0,\n        faceUV: options.faceUV || ((_a = options.perLetterFaceUV) === null || _a === void 0 ? void 0 : _a.call(options, letterIndex)),\n        faceColors: options.faceColors || ((_b = options.perLetterFaceColors) === null || _b === void 0 ? void 0 : _b.call(options, letterIndex)),\n        sideOrientation: Mesh._GetDefaultSideOrientation(options.sideOrientation || Mesh.DOUBLESIDE)\n      }, scene, earcutInjection);\n      meshes.push(mesh);\n      letterIndex++;\n    }\n  }\n  // Then we can merge everyone into one single mesh\n  const newMesh = Mesh.MergeMeshes(meshes, true, true);\n  if (newMesh) {\n    // Move pivot to center\n    const bbox = newMesh === null || newMesh === void 0 ? void 0 : newMesh.getBoundingInfo();\n    newMesh.position.x = -(bbox === null || bbox === void 0 ? void 0 : bbox.boundingBox.extendSizeWorld._x);\n    newMesh.position.y = -(bbox === null || bbox === void 0 ? void 0 : bbox.boundingBox.extendSizeWorld._y);\n    newMesh.position.z = -(bbox === null || bbox === void 0 ? void 0 : bbox.boundingBox.extendSizeWorld._z);\n    newMesh.name = name;\n    newMesh.rotation.x = -Math.PI / 2;\n    newMesh.bakeCurrentTransformIntoVertices();\n  }\n  return newMesh;\n}","map":{"version":3,"names":["Path2","Vector3","Mesh","ExtrudePolygon","ShapePath","constructor","resolution","_paths","_tempPaths","_holes","_resolution","moveTo","x","y","_currentPath","push","lineTo","addLineTo","quadraticCurveTo","cpx","cpy","addQuadraticCurveTo","bezierCurveTo","cpx1","cpy1","cpx2","cpy2","addBezierCurveTo","extractHoles","path","area","length","temp","paths","holes","CreateShapePath","char","scale","offsetX","offsetY","fontData","glyph","glyphs","shapePath","o","outline","split","i","l","action","parseInt","ha","CreateTextShapePaths","text","size","chars","Array","from","line_height","boundingBox","yMax","yMin","underlineThickness","shapePaths","ret","CreateText","name","options","depth","scene","earcutInjection","earcut","meshes","letterIndex","slice","holeVectors","shapeVectors","points","getPoints","point","localHolesCopy","hole","found","isPointInside","holePoints","splice","indexOf","mesh","shape","undefined","faceUV","_a","perLetterFaceUV","call","faceColors","_b","perLetterFaceColors","sideOrientation","_GetDefaultSideOrientation","DOUBLESIDE","newMesh","MergeMeshes","bbox","getBoundingInfo","position","extendSizeWorld","_x","_y","z","_z","rotation","Math","PI","bakeCurrentTransformIntoVertices"],"sources":["../../../../../dev/core/src/Meshes/Builders/textBuilder.ts"],"sourcesContent":["import type { Color4 } from \"../../Maths/math.color\";\r\nimport { Path2 } from \"../../Maths/math.path\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { ExtrudePolygon } from \"./polygonBuilder\";\r\n\r\ndeclare let earcut: any;\r\n\r\n/**\r\n * Parser inspired by https://github.com/mrdoob/three.js/blob/master/examples/jsm/loaders/FontLoader.js\r\n */\r\n\r\n// Interfaces\r\n\r\n/**\r\n * Represents glyph data generated by http://gero3.github.io/facetype.js/\r\n */\r\nexport interface IGlyphData {\r\n    /** Commands used to draw (line, move, curve, etc..) */\r\n    o: string;\r\n\r\n    /** Width */\r\n    ha: number;\r\n}\r\n\r\n/**\r\n * Represents font data generated by http://gero3.github.io/facetype.js/\r\n */\r\nexport interface IFontData {\r\n    /**\r\n     * Font resolution\r\n     */\r\n    resolution: number;\r\n    /** Underline tickness */\r\n    underlineThickness: number;\r\n    /** Bounding box */\r\n    boundingBox: {\r\n        yMax: number;\r\n        yMin: number;\r\n    };\r\n    /** List of supported glyphs */\r\n    glyphs: { [key: string]: IGlyphData };\r\n}\r\n\r\n// Shape functions\r\nclass ShapePath {\r\n    private _paths: Path2[] = [];\r\n    private _tempPaths: Path2[] = [];\r\n    private _holes: Path2[] = [];\r\n    private _currentPath: Path2;\r\n    private _resolution: number;\r\n\r\n    /** Create the ShapePath used to support glyphs */\r\n    constructor(resolution: number) {\r\n        this._resolution = resolution;\r\n    }\r\n\r\n    /** Move the virtual cursor to a coordinate */\r\n    moveTo(x: number, y: number) {\r\n        this._currentPath = new Path2(x, y);\r\n        this._tempPaths.push(this._currentPath);\r\n    }\r\n\r\n    /** Draw a line from the virtual cursor to a given coordinate */\r\n    lineTo(x: number, y: number) {\r\n        this._currentPath.addLineTo(x, y);\r\n    }\r\n\r\n    /** Create a quadratic curve from the virtual cursor to a given coordinate */\r\n    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number) {\r\n        this._currentPath.addQuadraticCurveTo(cpx, cpy, x, y, this._resolution);\r\n    }\r\n\r\n    /** Create a bezier curve from the virtual cursor to a given coordinate */\r\n    bezierCurveTo(cpx1: number, cpy1: number, cpx2: number, cpy2: number, x: number, y: number) {\r\n        this._currentPath.addBezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, y, this._resolution);\r\n    }\r\n\r\n    /** Extract holes based on CW / CCW */\r\n    extractHoles() {\r\n        for (const path of this._tempPaths) {\r\n            if (path.area() > 0) {\r\n                this._holes.push(path);\r\n            } else {\r\n                this._paths.push(path);\r\n            }\r\n        }\r\n\r\n        if (!this._paths.length && this._holes.length) {\r\n            const temp = this._holes;\r\n            this._holes = this._paths;\r\n            this._paths = temp;\r\n        }\r\n\r\n        this._tempPaths.length = 0;\r\n    }\r\n\r\n    /** Gets the list of paths */\r\n    get paths() {\r\n        return this._paths;\r\n    }\r\n\r\n    /** Gets the list of holes */\r\n    get holes() {\r\n        return this._holes;\r\n    }\r\n}\r\n\r\n// Utility functions\r\nfunction CreateShapePath(\r\n    char: string,\r\n    scale: number,\r\n    offsetX: number,\r\n    offsetY: number,\r\n    resolution: number,\r\n    fontData: IFontData\r\n): Nullable<{\r\n    offsetX: number;\r\n    shapePath: ShapePath;\r\n}> {\r\n    const glyph = fontData.glyphs[char] || fontData.glyphs[\"?\"];\r\n\r\n    if (!glyph) {\r\n        // return if there is no glyph data\r\n        return null;\r\n    }\r\n\r\n    const shapePath = new ShapePath(resolution);\r\n\r\n    if (glyph.o) {\r\n        const outline = glyph.o.split(\" \");\r\n\r\n        for (let i = 0, l = outline.length; i < l; ) {\r\n            const action = outline[i++];\r\n\r\n            switch (action) {\r\n                case \"m\": {\r\n                    // moveTo\r\n                    const x = parseInt(outline[i++]) * scale + offsetX;\r\n                    const y = parseInt(outline[i++]) * scale + offsetY;\r\n\r\n                    shapePath.moveTo(x, y);\r\n                    break;\r\n                }\r\n                case \"l\": {\r\n                    // lineTo\r\n                    const x = parseInt(outline[i++]) * scale + offsetX;\r\n                    const y = parseInt(outline[i++]) * scale + offsetY;\r\n\r\n                    shapePath.lineTo(x, y);\r\n                    break;\r\n                }\r\n                case \"q\": {\r\n                    // quadraticCurveTo\r\n                    const cpx = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy = parseInt(outline[i++]) * scale + offsetY;\r\n                    const cpx1 = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy1 = parseInt(outline[i++]) * scale + offsetY;\r\n\r\n                    shapePath.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\r\n                    break;\r\n                }\r\n                case \"b\": {\r\n                    // bezierCurveTo\r\n                    const cpx = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy = parseInt(outline[i++]) * scale + offsetY;\r\n                    const cpx1 = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy1 = parseInt(outline[i++]) * scale + offsetY;\r\n                    const cpx2 = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy2 = parseInt(outline[i++]) * scale + offsetY;\r\n\r\n                    shapePath.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Extract holes (based on clockwise data)\r\n    shapePath.extractHoles();\r\n\r\n    return { offsetX: glyph.ha * scale, shapePath: shapePath };\r\n}\r\n\r\n/**\r\n * Creates shape paths from a text and font\r\n * @param text the text\r\n * @param size size of the font\r\n * @param resolution resolution of the font\r\n * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)\r\n * @returns array of ShapePath objects\r\n */\r\nexport function CreateTextShapePaths(text: string, size: number, resolution: number, fontData: IFontData) {\r\n    const chars = Array.from(text);\r\n    const scale = size / fontData.resolution;\r\n    const line_height = (fontData.boundingBox.yMax - fontData.boundingBox.yMin + fontData.underlineThickness) * scale;\r\n\r\n    const shapePaths: ShapePath[] = [];\r\n\r\n    let offsetX = 0,\r\n        offsetY = 0;\r\n\r\n    for (let i = 0; i < chars.length; i++) {\r\n        const char = chars[i];\r\n\r\n        if (char === \"\\n\") {\r\n            offsetX = 0;\r\n            offsetY -= line_height;\r\n        } else {\r\n            const ret = CreateShapePath(char, scale, offsetX, offsetY, resolution, fontData);\r\n\r\n            if (ret) {\r\n                offsetX += ret.offsetX;\r\n                shapePaths.push(ret.shapePath);\r\n            }\r\n        }\r\n    }\r\n\r\n    return shapePaths;\r\n}\r\n\r\n/**\r\n * Create a text mesh\r\n * @param name defines the name of the mesh\r\n * @param text defines the text to use to build the mesh\r\n * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)\r\n * @param options defines options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @param earcutInjection can be used to inject your own earcut reference\r\n * @returns a new Mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/text\r\n */\r\nexport function CreateText(\r\n    name: string,\r\n    text: string,\r\n    fontData: IFontData,\r\n    options: {\r\n        size?: number;\r\n        resolution?: number;\r\n        depth?: number;\r\n        sideOrientation?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        perLetterFaceUV?: (letterIndex: number) => Vector4[];\r\n        perLetterFaceColors?: (letterIndex: number) => Color4[];\r\n    } = {\r\n        size: 50,\r\n        resolution: 8,\r\n        depth: 1.0,\r\n    },\r\n    scene: Nullable<Scene> = null,\r\n    earcutInjection = earcut\r\n): Nullable<Mesh> {\r\n    // First we need to generate the paths\r\n    const shapePaths = CreateTextShapePaths(text, options.size || 50, options.resolution || 8, fontData);\r\n\r\n    // And extrude them\r\n    const meshes: Mesh[] = [];\r\n    let letterIndex = 0;\r\n    for (const shapePath of shapePaths) {\r\n        if (!shapePath.paths.length) {\r\n            continue;\r\n        }\r\n\r\n        const holes = shapePath.holes.slice(); // Copy it as we will update the copy\r\n        for (const path of shapePath.paths) {\r\n            const holeVectors: Vector3[][] = [];\r\n            const shapeVectors: Vector3[] = [];\r\n            const points = path.getPoints();\r\n            for (const point of points) {\r\n                shapeVectors.push(new Vector3(point.x, 0, point.y)); // ExtrudePolygon expects data on the xz plane\r\n            }\r\n\r\n            // Holes\r\n            const localHolesCopy = holes.slice();\r\n            for (const hole of localHolesCopy) {\r\n                const points = hole.getPoints();\r\n\r\n                let found = false;\r\n                for (const point of points) {\r\n                    if (path.isPointInside(point)) {\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!found) {\r\n                    continue;\r\n                }\r\n\r\n                const holePoints: Vector3[] = [];\r\n                for (const point of points) {\r\n                    holePoints.push(new Vector3(point.x, 0, point.y)); // ExtrudePolygon expects data on the xz plane\r\n                }\r\n                holeVectors.push(holePoints);\r\n\r\n                // Remove the hole as it was already used\r\n                holes.splice(holes.indexOf(hole), 1);\r\n            }\r\n\r\n            // There is at least a hole but it was unaffected\r\n            if (!holeVectors.length && holes.length) {\r\n                for (const hole of holes) {\r\n                    const points = hole.getPoints();\r\n                    const holePoints: Vector3[] = [];\r\n                    for (const point of points) {\r\n                        holePoints.push(new Vector3(point.x, 0, point.y)); // ExtrudePolygon expects data on the xz plane\r\n                    }\r\n                    holeVectors.push(holePoints);\r\n                }\r\n            }\r\n\r\n            // Extrusion!\r\n            const mesh = ExtrudePolygon(\r\n                name,\r\n                {\r\n                    shape: shapeVectors,\r\n                    holes: holeVectors.length ? holeVectors : undefined,\r\n                    depth: options.depth || 1.0,\r\n                    faceUV: options.faceUV || options.perLetterFaceUV?.(letterIndex),\r\n                    faceColors: options.faceColors || options.perLetterFaceColors?.(letterIndex),\r\n                    sideOrientation: Mesh._GetDefaultSideOrientation(options.sideOrientation || Mesh.DOUBLESIDE),\r\n                },\r\n                scene,\r\n                earcutInjection\r\n            );\r\n            meshes.push(mesh);\r\n            letterIndex++;\r\n        }\r\n    }\r\n\r\n    // Then we can merge everyone into one single mesh\r\n    const newMesh = Mesh.MergeMeshes(meshes, true, true);\r\n\r\n    if (newMesh) {\r\n        // Move pivot to center\r\n        const bbox = newMesh?.getBoundingInfo();\r\n        newMesh.position.x = -bbox?.boundingBox.extendSizeWorld._x;\r\n        newMesh.position.y = -bbox?.boundingBox.extendSizeWorld._y;\r\n        newMesh.position.z = -bbox?.boundingBox.extendSizeWorld._z;\r\n        newMesh.name = name;\r\n\r\n        newMesh.rotation.x = -Math.PI / 2;\r\n\r\n        newMesh.bakeCurrentTransformIntoVertices();\r\n    }\r\n\r\n    return newMesh;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}