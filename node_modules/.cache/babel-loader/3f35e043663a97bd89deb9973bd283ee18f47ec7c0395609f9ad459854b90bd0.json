{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize, SerializationHelper, serializeAsTexture } from \"../../Misc/decorators.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Matrix } from \"../../Maths/math.vector.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\nimport { RandomGUID } from \"../../Misc/guid.js\";\nimport \"../../Misc/fileTools.js\";\nimport { ThinTexture } from \"./thinTexture.js\";\n/**\n * Base class of all the textures in babylon.\n * It groups all the common properties the materials, post process, lights... might need\n * in order to make a correct use of the texture.\n */\nexport class BaseTexture extends ThinTexture {\n  /**\n   * Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).\n   */\n  set hasAlpha(value) {\n    if (this._hasAlpha === value) {\n      return;\n    }\n    this._hasAlpha = value;\n    if (this._scene) {\n      this._scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this);\n      });\n    }\n  }\n  get hasAlpha() {\n    return this._hasAlpha;\n  }\n  /**\n   * Defines if the alpha value should be determined via the rgb values.\n   * If true the luminance of the pixel might be used to find the corresponding alpha value.\n   */\n  set getAlphaFromRGB(value) {\n    if (this._getAlphaFromRGB === value) {\n      return;\n    }\n    this._getAlphaFromRGB = value;\n    if (this._scene) {\n      this._scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this);\n      });\n    }\n  }\n  get getAlphaFromRGB() {\n    return this._getAlphaFromRGB;\n  }\n  /**\n   * Define the UV channel to use starting from 0 and defaulting to 0.\n   * This is part of the texture as textures usually maps to one uv set.\n   */\n  set coordinatesIndex(value) {\n    if (this._coordinatesIndex === value) {\n      return;\n    }\n    this._coordinatesIndex = value;\n    if (this._scene) {\n      this._scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this);\n      });\n    }\n  }\n  get coordinatesIndex() {\n    return this._coordinatesIndex;\n  }\n  /**\n   * How a texture is mapped.\n   *\n   * | Value | Type                                | Description |\n   * | ----- | ----------------------------------- | ----------- |\n   * | 0     | EXPLICIT_MODE                       |             |\n   * | 1     | SPHERICAL_MODE                      |             |\n   * | 2     | PLANAR_MODE                         |             |\n   * | 3     | CUBIC_MODE                          |             |\n   * | 4     | PROJECTION_MODE                     |             |\n   * | 5     | SKYBOX_MODE                         |             |\n   * | 6     | INVCUBIC_MODE                       |             |\n   * | 7     | EQUIRECTANGULAR_MODE                |             |\n   * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |\n   * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |\n   */\n  set coordinatesMode(value) {\n    if (this._coordinatesMode === value) {\n      return;\n    }\n    this._coordinatesMode = value;\n    if (this._scene) {\n      this._scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this);\n      });\n    }\n  }\n  get coordinatesMode() {\n    return this._coordinatesMode;\n  }\n  /**\n   * | Value | Type               | Description |\n   * | ----- | ------------------ | ----------- |\n   * | 0     | CLAMP_ADDRESSMODE  |             |\n   * | 1     | WRAP_ADDRESSMODE   |             |\n   * | 2     | MIRROR_ADDRESSMODE |             |\n   */\n  get wrapU() {\n    return this._wrapU;\n  }\n  set wrapU(value) {\n    this._wrapU = value;\n  }\n  /**\n   * | Value | Type               | Description |\n   * | ----- | ------------------ | ----------- |\n   * | 0     | CLAMP_ADDRESSMODE  |             |\n   * | 1     | WRAP_ADDRESSMODE   |             |\n   * | 2     | MIRROR_ADDRESSMODE |             |\n   */\n  get wrapV() {\n    return this._wrapV;\n  }\n  set wrapV(value) {\n    this._wrapV = value;\n  }\n  /**\n   * Define if the texture is a cube texture or if false a 2d texture.\n   */\n  get isCube() {\n    if (!this._texture) {\n      return this._isCube;\n    }\n    return this._texture.isCube;\n  }\n  set isCube(value) {\n    if (!this._texture) {\n      this._isCube = value;\n    } else {\n      this._texture.isCube = value;\n    }\n  }\n  /**\n   * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\n   */\n  get is3D() {\n    if (!this._texture) {\n      return false;\n    }\n    return this._texture.is3D;\n  }\n  set is3D(value) {\n    if (!this._texture) {\n      return;\n    }\n    this._texture.is3D = value;\n  }\n  /**\n   * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\n   */\n  get is2DArray() {\n    if (!this._texture) {\n      return false;\n    }\n    return this._texture.is2DArray;\n  }\n  set is2DArray(value) {\n    if (!this._texture) {\n      return;\n    }\n    this._texture.is2DArray = value;\n  }\n  /**\n   * Define if the texture contains data in gamma space (most of the png/jpg aside bump).\n   * HDR texture are usually stored in linear space.\n   * This only impacts the PBR and Background materials\n   */\n  get gammaSpace() {\n    if (!this._texture) {\n      return this._gammaSpace;\n    } else {\n      if (this._texture._gammaSpace === null) {\n        this._texture._gammaSpace = this._gammaSpace;\n      }\n    }\n    return this._texture._gammaSpace && !this._texture._useSRGBBuffer;\n  }\n  set gammaSpace(gamma) {\n    if (!this._texture) {\n      if (this._gammaSpace === gamma) {\n        return;\n      }\n      this._gammaSpace = gamma;\n    } else {\n      if (this._texture._gammaSpace === gamma) {\n        return;\n      }\n      this._texture._gammaSpace = gamma;\n    }\n    this._markAllSubMeshesAsTexturesDirty();\n  }\n  /**\n   * Gets or sets whether or not the texture contains RGBD data.\n   */\n  get isRGBD() {\n    return this._texture != null && this._texture._isRGBD;\n  }\n  set isRGBD(value) {\n    if (this._texture) {\n      this._texture._isRGBD = value;\n    }\n  }\n  /**\n   * Are mip maps generated for this texture or not.\n   */\n  get noMipmap() {\n    return false;\n  }\n  /**\n   * With prefiltered texture, defined the offset used during the prefiltering steps.\n   */\n  get lodGenerationOffset() {\n    if (this._texture) {\n      return this._texture._lodGenerationOffset;\n    }\n    return 0.0;\n  }\n  set lodGenerationOffset(value) {\n    if (this._texture) {\n      this._texture._lodGenerationOffset = value;\n    }\n  }\n  /**\n   * With prefiltered texture, defined the scale used during the prefiltering steps.\n   */\n  get lodGenerationScale() {\n    if (this._texture) {\n      return this._texture._lodGenerationScale;\n    }\n    return 0.0;\n  }\n  set lodGenerationScale(value) {\n    if (this._texture) {\n      this._texture._lodGenerationScale = value;\n    }\n  }\n  /**\n   * With prefiltered texture, defined if the specular generation is based on a linear ramp.\n   * By default we are using a log2 of the linear roughness helping to keep a better resolution for\n   * average roughness values.\n   */\n  get linearSpecularLOD() {\n    if (this._texture) {\n      return this._texture._linearSpecularLOD;\n    }\n    return false;\n  }\n  set linearSpecularLOD(value) {\n    if (this._texture) {\n      this._texture._linearSpecularLOD = value;\n    }\n  }\n  /**\n   * In case a better definition than spherical harmonics is required for the diffuse part of the environment.\n   * You can set the irradiance texture to rely on a texture instead of the spherical approach.\n   * This texture need to have the same characteristics than its parent (Cube vs 2d, coordinates mode, Gamma/Linear, RGBD).\n   */\n  get irradianceTexture() {\n    if (this._texture) {\n      return this._texture._irradianceTexture;\n    }\n    return null;\n  }\n  set irradianceTexture(value) {\n    if (this._texture) {\n      this._texture._irradianceTexture = value;\n    }\n  }\n  /**\n   * Define the unique id of the texture in the scene.\n   */\n  get uid() {\n    if (!this._uid) {\n      this._uid = RandomGUID();\n    }\n    return this._uid;\n  }\n  /**\n   * Return a string representation of the texture.\n   * @returns the texture as a string\n   */\n  toString() {\n    return this.name;\n  }\n  /**\n   * Get the class name of the texture.\n   * @returns \"BaseTexture\"\n   */\n  getClassName() {\n    return \"BaseTexture\";\n  }\n  /**\n   * Callback triggered when the texture has been disposed.\n   * Kept for back compatibility, you can use the onDisposeObservable instead.\n   */\n  set onDispose(callback) {\n    if (this._onDisposeObserver) {\n      this.onDisposeObservable.remove(this._onDisposeObserver);\n    }\n    this._onDisposeObserver = this.onDisposeObservable.add(callback);\n  }\n  /**\n   * Define if the texture is preventing a material to render or not.\n   * If not and the texture is not ready, the engine will use a default black texture instead.\n   */\n  get isBlocking() {\n    return true;\n  }\n  /**\n   * Was there any loading error?\n   */\n  get loadingError() {\n    return this._loadingError;\n  }\n  /**\n   * If a loading error occurred this object will be populated with information about the error.\n   */\n  get errorObject() {\n    return this._errorObject;\n  }\n  /**\n   * Instantiates a new BaseTexture.\n   * Base class of all the textures in babylon.\n   * It groups all the common properties the materials, post process, lights... might need\n   * in order to make a correct use of the texture.\n   * @param sceneOrEngine Define the scene or engine the texture belongs to\n   * @param internalTexture Define the internal texture associated with the texture\n   */\n  constructor(sceneOrEngine, internalTexture = null) {\n    super(null);\n    /**\n     * Gets or sets an object used to store user defined information.\n     */\n    this.metadata = null;\n    /**\n     * For internal use only. Please do not use.\n     */\n    this.reservedDataStore = null;\n    this._hasAlpha = false;\n    this._getAlphaFromRGB = false;\n    /**\n     * Intensity or strength of the texture.\n     * It is commonly used by materials to fine tune the intensity of the texture\n     */\n    this.level = 1;\n    this._coordinatesIndex = 0;\n    /**\n     * Gets or sets a boolean indicating that the texture should try to reduce shader code if there is no UV manipulation.\n     * (ie. when texture.getTextureMatrix().isIdentityAs3x2() returns true)\n     */\n    this.optimizeUVAllocation = true;\n    this._coordinatesMode = 0;\n    /**\n     * | Value | Type               | Description |\n     * | ----- | ------------------ | ----------- |\n     * | 0     | CLAMP_ADDRESSMODE  |             |\n     * | 1     | WRAP_ADDRESSMODE   |             |\n     * | 2     | MIRROR_ADDRESSMODE |             |\n     */\n    this.wrapR = 1;\n    /**\n     * With compliant hardware and browser (supporting anisotropic filtering)\n     * this defines the level of anisotropic filtering in the texture.\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\n     */\n    this.anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;\n    /** @internal */\n    this._isCube = false;\n    this._gammaSpace = true;\n    /**\n     * Is Z inverted in the texture (useful in a cube texture).\n     */\n    this.invertZ = false;\n    /**\n     * @internal\n     */\n    this.lodLevelInAlpha = false;\n    /**\n     * Define if the texture is a render target.\n     */\n    this.isRenderTarget = false;\n    /** @internal */\n    this._prefiltered = false;\n    /** @internal */\n    this._forceSerialize = false;\n    /**\n     * Define the list of animation attached to the texture.\n     */\n    this.animations = new Array();\n    /**\n     * An event triggered when the texture is disposed.\n     */\n    this.onDisposeObservable = new Observable();\n    this._onDisposeObserver = null;\n    this._scene = null;\n    /** @internal */\n    this._uid = null;\n    /** @internal */\n    this._parentContainer = null;\n    this._loadingError = false;\n    if (sceneOrEngine) {\n      if (BaseTexture._IsScene(sceneOrEngine)) {\n        this._scene = sceneOrEngine;\n      } else {\n        this._engine = sceneOrEngine;\n      }\n    } else {\n      this._scene = EngineStore.LastCreatedScene;\n    }\n    if (this._scene) {\n      this.uniqueId = this._scene.getUniqueId();\n      this._scene.addTexture(this);\n      this._engine = this._scene.getEngine();\n    }\n    this._texture = internalTexture;\n    this._uid = null;\n  }\n  /**\n   * Get the scene the texture belongs to.\n   * @returns the scene or null if undefined\n   */\n  getScene() {\n    return this._scene;\n  }\n  /** @internal */\n  _getEngine() {\n    return this._engine;\n  }\n  /**\n   * Checks if the texture has the same transform matrix than another texture\n   * @param texture texture to check against\n   * @returns true if the transforms are the same, else false\n   */\n  checkTransformsAreIdentical(texture) {\n    return texture !== null;\n  }\n  /**\n   * Get the texture transform matrix used to offset tile the texture for instance.\n   * @returns the transformation matrix\n   */\n  getTextureMatrix() {\n    return Matrix.IdentityReadOnly;\n  }\n  /**\n   * Get the texture reflection matrix used to rotate/transform the reflection.\n   * @returns the reflection matrix\n   */\n  getReflectionTextureMatrix() {\n    return Matrix.IdentityReadOnly;\n  }\n  /**\n   * Gets a suitable rotate/transform matrix when the texture is used for refraction.\n   * There's a separate function from getReflectionTextureMatrix because refraction requires a special configuration of the matrix in right-handed mode.\n   * @returns The refraction matrix\n   */\n  getRefractionTextureMatrix() {\n    return this.getReflectionTextureMatrix();\n  }\n  /**\n   * Get if the texture is ready to be consumed (either it is ready or it is not blocking)\n   * @returns true if ready, not blocking or if there was an error loading the texture\n   */\n  isReadyOrNotBlocking() {\n    return !this.isBlocking || this.isReady() || this.loadingError;\n  }\n  /**\n   * Scales the texture if is `canRescale()`\n   * @param ratio the resize factor we want to use to rescale\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  scale(ratio) {}\n  /**\n   * Get if the texture can rescale.\n   */\n  get canRescale() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  _getFromCache(url, noMipmap, sampling, invertY, useSRGBBuffer, isCube) {\n    const engine = this._getEngine();\n    if (!engine) {\n      return null;\n    }\n    const correctedUseSRGBBuffer = engine._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);\n    const texturesCache = engine.getLoadedTexturesCache();\n    for (let index = 0; index < texturesCache.length; index++) {\n      const texturesCacheEntry = texturesCache[index];\n      if (useSRGBBuffer === undefined || correctedUseSRGBBuffer === texturesCacheEntry._useSRGBBuffer) {\n        if (invertY === undefined || invertY === texturesCacheEntry.invertY) {\n          if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {\n            if (!sampling || sampling === texturesCacheEntry.samplingMode) {\n              if (isCube === undefined || isCube === texturesCacheEntry.isCube) {\n                texturesCacheEntry.incrementReferences();\n                return texturesCacheEntry;\n              }\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }\n  /** @internal */\n  _rebuild() {}\n  /**\n   * Clones the texture.\n   * @returns the cloned texture\n   */\n  clone() {\n    return null;\n  }\n  /**\n   * Get the texture underlying type (INT, FLOAT...)\n   */\n  get textureType() {\n    if (!this._texture) {\n      return 0;\n    }\n    return this._texture.type !== undefined ? this._texture.type : 0;\n  }\n  /**\n   * Get the texture underlying format (RGB, RGBA...)\n   */\n  get textureFormat() {\n    if (!this._texture) {\n      return 5;\n    }\n    return this._texture.format !== undefined ? this._texture.format : 5;\n  }\n  /**\n   * Indicates that textures need to be re-calculated for all materials\n   */\n  _markAllSubMeshesAsTexturesDirty() {\n    const scene = this.getScene();\n    if (!scene) {\n      return;\n    }\n    scene.markAllMaterialsAsDirty(1);\n  }\n  /**\n   * Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.\n   * This will returns an RGBA array buffer containing either in values (0-255) or\n   * float values (0-1) depending of the underlying buffer type.\n   * @param faceIndex defines the face of the texture to read (in case of cube texture)\n   * @param level defines the LOD level of the texture to read (in case of Mip Maps)\n   * @param buffer defines a user defined buffer to fill with data (can be null)\n   * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\n   * @param noDataConversion false to convert the data to Uint8Array (if texture type is UNSIGNED_BYTE) or to Float32Array (if texture type is anything but UNSIGNED_BYTE). If true, the type of the generated buffer (if buffer==null) will depend on the type of the texture\n   * @param x defines the region x coordinates to start reading from (default to 0)\n   * @param y defines the region y coordinates to start reading from (default to 0)\n   * @param width defines the region width to read from (default to the texture size at level)\n   * @param height defines the region width to read from (default to the texture size at level)\n   * @returns The Array buffer promise containing the pixels data.\n   */\n  readPixels(faceIndex = 0, level = 0, buffer = null, flushRenderer = true, noDataConversion = false, x = 0, y = 0, width = Number.MAX_VALUE, height = Number.MAX_VALUE) {\n    if (!this._texture) {\n      return null;\n    }\n    const engine = this._getEngine();\n    if (!engine) {\n      return null;\n    }\n    const size = this.getSize();\n    let maxWidth = size.width;\n    let maxHeight = size.height;\n    if (level !== 0) {\n      maxWidth = maxWidth / Math.pow(2, level);\n      maxHeight = maxHeight / Math.pow(2, level);\n      maxWidth = Math.round(maxWidth);\n      maxHeight = Math.round(maxHeight);\n    }\n    width = Math.min(maxWidth, width);\n    height = Math.min(maxHeight, height);\n    try {\n      if (this._texture.isCube) {\n        return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y);\n      }\n      return engine._readTexturePixels(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion, x, y);\n    } catch (e) {\n      return null;\n    }\n  }\n  /**\n   * @internal\n   */\n  _readPixelsSync(faceIndex = 0, level = 0, buffer = null, flushRenderer = true, noDataConversion = false) {\n    if (!this._texture) {\n      return null;\n    }\n    const size = this.getSize();\n    let width = size.width;\n    let height = size.height;\n    const engine = this._getEngine();\n    if (!engine) {\n      return null;\n    }\n    if (level != 0) {\n      width = width / Math.pow(2, level);\n      height = height / Math.pow(2, level);\n      width = Math.round(width);\n      height = Math.round(height);\n    }\n    try {\n      if (this._texture.isCube) {\n        return engine._readTexturePixelsSync(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion);\n      }\n      return engine._readTexturePixelsSync(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion);\n    } catch (e) {\n      return null;\n    }\n  }\n  /** @internal */\n  get _lodTextureHigh() {\n    if (this._texture) {\n      return this._texture._lodTextureHigh;\n    }\n    return null;\n  }\n  /** @internal */\n  get _lodTextureMid() {\n    if (this._texture) {\n      return this._texture._lodTextureMid;\n    }\n    return null;\n  }\n  /** @internal */\n  get _lodTextureLow() {\n    if (this._texture) {\n      return this._texture._lodTextureLow;\n    }\n    return null;\n  }\n  /**\n   * Dispose the texture and release its associated resources.\n   */\n  dispose() {\n    if (this._scene) {\n      // Animations\n      if (this._scene.stopAnimation) {\n        this._scene.stopAnimation(this);\n      }\n      // Remove from scene\n      this._scene.removePendingData(this);\n      const index = this._scene.textures.indexOf(this);\n      if (index >= 0) {\n        this._scene.textures.splice(index, 1);\n      }\n      this._scene.onTextureRemovedObservable.notifyObservers(this);\n      this._scene = null;\n      if (this._parentContainer) {\n        const index = this._parentContainer.textures.indexOf(this);\n        if (index > -1) {\n          this._parentContainer.textures.splice(index, 1);\n        }\n        this._parentContainer = null;\n      }\n    }\n    // Callback\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.metadata = null;\n    super.dispose();\n  }\n  /**\n   * Serialize the texture into a JSON representation that can be parsed later on.\n   * @param allowEmptyName True to force serialization even if name is empty. Default: false\n   * @returns the JSON representation of the texture\n   */\n  serialize(allowEmptyName = false) {\n    if (!this.name && !allowEmptyName) {\n      return null;\n    }\n    const serializationObject = SerializationHelper.Serialize(this);\n    // Animations\n    SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n    return serializationObject;\n  }\n  /**\n   * Helper function to be called back once a list of texture contains only ready textures.\n   * @param textures Define the list of textures to wait for\n   * @param callback Define the callback triggered once the entire list will be ready\n   */\n  static WhenAllReady(textures, callback) {\n    let numRemaining = textures.length;\n    if (numRemaining === 0) {\n      callback();\n      return;\n    }\n    for (let i = 0; i < textures.length; i++) {\n      const texture = textures[i];\n      if (texture.isReady()) {\n        if (--numRemaining === 0) {\n          callback();\n        }\n      } else {\n        const onLoadObservable = texture.onLoadObservable;\n        if (onLoadObservable) {\n          onLoadObservable.addOnce(() => {\n            if (--numRemaining === 0) {\n              callback();\n            }\n          });\n        } else {\n          if (--numRemaining === 0) {\n            callback();\n          }\n        }\n      }\n    }\n  }\n  static _IsScene(sceneOrEngine) {\n    return sceneOrEngine.getClassName() === \"Scene\";\n  }\n}\n/**\n * Default anisotropic filtering level for the application.\n * It is set to 4 as a good tradeoff between perf and quality.\n */\nBaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;\n__decorate([serialize()], BaseTexture.prototype, \"uniqueId\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"name\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"metadata\", void 0);\n__decorate([serialize(\"hasAlpha\")], BaseTexture.prototype, \"_hasAlpha\", void 0);\n__decorate([serialize(\"getAlphaFromRGB\")], BaseTexture.prototype, \"_getAlphaFromRGB\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"level\", void 0);\n__decorate([serialize(\"coordinatesIndex\")], BaseTexture.prototype, \"_coordinatesIndex\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"optimizeUVAllocation\", void 0);\n__decorate([serialize(\"coordinatesMode\")], BaseTexture.prototype, \"_coordinatesMode\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"wrapU\", null);\n__decorate([serialize()], BaseTexture.prototype, \"wrapV\", null);\n__decorate([serialize()], BaseTexture.prototype, \"wrapR\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"anisotropicFilteringLevel\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"isCube\", null);\n__decorate([serialize()], BaseTexture.prototype, \"is3D\", null);\n__decorate([serialize()], BaseTexture.prototype, \"is2DArray\", null);\n__decorate([serialize()], BaseTexture.prototype, \"gammaSpace\", null);\n__decorate([serialize()], BaseTexture.prototype, \"invertZ\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"lodLevelInAlpha\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"lodGenerationOffset\", null);\n__decorate([serialize()], BaseTexture.prototype, \"lodGenerationScale\", null);\n__decorate([serialize()], BaseTexture.prototype, \"linearSpecularLOD\", null);\n__decorate([serializeAsTexture()], BaseTexture.prototype, \"irradianceTexture\", null);\n__decorate([serialize()], BaseTexture.prototype, \"isRenderTarget\", void 0);","map":{"version":3,"names":["serialize","SerializationHelper","serializeAsTexture","Observable","Matrix","EngineStore","RandomGUID","ThinTexture","BaseTexture","hasAlpha","value","_hasAlpha","_scene","markAllMaterialsAsDirty","mat","hasTexture","getAlphaFromRGB","_getAlphaFromRGB","coordinatesIndex","_coordinatesIndex","coordinatesMode","_coordinatesMode","wrapU","_wrapU","wrapV","_wrapV","isCube","_texture","_isCube","is3D","is2DArray","gammaSpace","_gammaSpace","_useSRGBBuffer","gamma","_markAllSubMeshesAsTexturesDirty","isRGBD","_isRGBD","noMipmap","lodGenerationOffset","_lodGenerationOffset","lodGenerationScale","_lodGenerationScale","linearSpecularLOD","_linearSpecularLOD","irradianceTexture","_irradianceTexture","uid","_uid","toString","name","getClassName","onDispose","callback","_onDisposeObserver","onDisposeObservable","remove","add","isBlocking","loadingError","_loadingError","errorObject","_errorObject","constructor","sceneOrEngine","internalTexture","metadata","reservedDataStore","level","optimizeUVAllocation","wrapR","anisotropicFilteringLevel","DEFAULT_ANISOTROPIC_FILTERING_LEVEL","invertZ","lodLevelInAlpha","isRenderTarget","_prefiltered","_forceSerialize","animations","Array","_parentContainer","_IsScene","_engine","LastCreatedScene","uniqueId","getUniqueId","addTexture","getEngine","getScene","_getEngine","checkTransformsAreIdentical","texture","getTextureMatrix","IdentityReadOnly","getReflectionTextureMatrix","getRefractionTextureMatrix","isReadyOrNotBlocking","isReady","scale","ratio","canRescale","_getFromCache","url","sampling","invertY","useSRGBBuffer","engine","correctedUseSRGBBuffer","_getUseSRGBBuffer","texturesCache","getLoadedTexturesCache","index","length","texturesCacheEntry","undefined","generateMipMaps","samplingMode","incrementReferences","_rebuild","clone","textureType","type","textureFormat","format","scene","readPixels","faceIndex","buffer","flushRenderer","noDataConversion","x","y","width","Number","MAX_VALUE","height","size","getSize","maxWidth","maxHeight","Math","pow","round","min","_readTexturePixels","e","_readPixelsSync","_readTexturePixelsSync","_lodTextureHigh","_lodTextureMid","_lodTextureLow","dispose","stopAnimation","removePendingData","textures","indexOf","splice","onTextureRemovedObservable","notifyObservers","clear","allowEmptyName","serializationObject","Serialize","AppendSerializedAnimations","WhenAllReady","numRemaining","i","onLoadObservable","addOnce","__decorate"],"sources":["../../../../../dev/core/src/Materials/Textures/baseTexture.ts"],"sourcesContent":["import { serialize, SerializationHelper, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport { RandomGUID } from \"../../Misc/guid\";\r\n\r\nimport \"../../Misc/fileTools\";\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { ThinTexture } from \"./thinTexture\";\r\nimport type { AbstractScene } from \"../../abstractScene\";\r\n\r\nimport type { Animation } from \"../../Animations/animation\";\r\n\r\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties the materials, post process, lights... might need\r\n * in order to make a correct use of the texture.\r\n */\r\nexport class BaseTexture extends ThinTexture implements IAnimatable {\r\n    /**\r\n     * Default anisotropic filtering level for the application.\r\n     * It is set to 4 as a good tradeoff between perf and quality.\r\n     */\r\n    public static DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the texture\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Define the name of the texture.\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information.\r\n     */\r\n    @serialize()\r\n    public metadata: any = null;\r\n\r\n    /** @internal */\r\n    public _internalMetadata: any;\r\n\r\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\r\n    public reservedDataStore: any = null;\r\n\r\n    @serialize(\"hasAlpha\")\r\n    private _hasAlpha = false;\r\n    /**\r\n     * Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).\r\n     */\r\n    public set hasAlpha(value: boolean) {\r\n        if (this._hasAlpha === value) {\r\n            return;\r\n        }\r\n        this._hasAlpha = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get hasAlpha(): boolean {\r\n        return this._hasAlpha;\r\n    }\r\n\r\n    @serialize(\"getAlphaFromRGB\")\r\n    private _getAlphaFromRGB = false;\r\n    /**\r\n     * Defines if the alpha value should be determined via the rgb values.\r\n     * If true the luminance of the pixel might be used to find the corresponding alpha value.\r\n     */\r\n    public set getAlphaFromRGB(value: boolean) {\r\n        if (this._getAlphaFromRGB === value) {\r\n            return;\r\n        }\r\n        this._getAlphaFromRGB = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get getAlphaFromRGB(): boolean {\r\n        return this._getAlphaFromRGB;\r\n    }\r\n\r\n    /**\r\n     * Intensity or strength of the texture.\r\n     * It is commonly used by materials to fine tune the intensity of the texture\r\n     */\r\n    @serialize()\r\n    public level = 1;\r\n\r\n    @serialize(\"coordinatesIndex\")\r\n    protected _coordinatesIndex = 0;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the texture should try to reduce shader code if there is no UV manipulation.\r\n     * (ie. when texture.getTextureMatrix().isIdentityAs3x2() returns true)\r\n     */\r\n    @serialize()\r\n    public optimizeUVAllocation = true;\r\n\r\n    /**\r\n     * Define the UV channel to use starting from 0 and defaulting to 0.\r\n     * This is part of the texture as textures usually maps to one uv set.\r\n     */\r\n    public set coordinatesIndex(value: number) {\r\n        if (this._coordinatesIndex === value) {\r\n            return;\r\n        }\r\n        this._coordinatesIndex = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get coordinatesIndex(): number {\r\n        return this._coordinatesIndex;\r\n    }\r\n\r\n    @serialize(\"coordinatesMode\")\r\n    protected _coordinatesMode = Constants.TEXTURE_EXPLICIT_MODE;\r\n\r\n    /**\r\n     * How a texture is mapped.\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 0     | EXPLICIT_MODE                       |             |\r\n     * | 1     | SPHERICAL_MODE                      |             |\r\n     * | 2     | PLANAR_MODE                         |             |\r\n     * | 3     | CUBIC_MODE                          |             |\r\n     * | 4     | PROJECTION_MODE                     |             |\r\n     * | 5     | SKYBOX_MODE                         |             |\r\n     * | 6     | INVCUBIC_MODE                       |             |\r\n     * | 7     | EQUIRECTANGULAR_MODE                |             |\r\n     * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |\r\n     * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |\r\n     */\r\n    public set coordinatesMode(value: number) {\r\n        if (this._coordinatesMode === value) {\r\n            return;\r\n        }\r\n        this._coordinatesMode = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get coordinatesMode(): number {\r\n        return this._coordinatesMode;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public get wrapU() {\r\n        return this._wrapU;\r\n    }\r\n    public set wrapU(value: number) {\r\n        this._wrapU = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public get wrapV() {\r\n        return this._wrapV;\r\n    }\r\n    public set wrapV(value: number) {\r\n        this._wrapV = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public wrapR = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n    /**\r\n     * With compliant hardware and browser (supporting anisotropic filtering)\r\n     * this defines the level of anisotropic filtering in the texture.\r\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n     */\r\n    @serialize()\r\n    public anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;\r\n\r\n    /** @internal */\r\n    public _isCube = false;\r\n    /**\r\n     * Define if the texture is a cube texture or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public get isCube(): boolean {\r\n        if (!this._texture) {\r\n            return this._isCube;\r\n        }\r\n\r\n        return this._texture.isCube;\r\n    }\r\n\r\n    protected set isCube(value: boolean) {\r\n        if (!this._texture) {\r\n            this._isCube = value;\r\n        } else {\r\n            this._texture.isCube = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public get is3D(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is3D;\r\n    }\r\n\r\n    protected set is3D(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is3D = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public get is2DArray(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is2DArray;\r\n    }\r\n\r\n    protected set is2DArray(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is2DArray = value;\r\n    }\r\n\r\n    private _gammaSpace = true;\r\n    /**\r\n     * Define if the texture contains data in gamma space (most of the png/jpg aside bump).\r\n     * HDR texture are usually stored in linear space.\r\n     * This only impacts the PBR and Background materials\r\n     */\r\n    @serialize()\r\n    public get gammaSpace(): boolean {\r\n        if (!this._texture) {\r\n            return this._gammaSpace;\r\n        } else {\r\n            if (this._texture._gammaSpace === null) {\r\n                this._texture._gammaSpace = this._gammaSpace;\r\n            }\r\n        }\r\n\r\n        return this._texture._gammaSpace && !this._texture._useSRGBBuffer;\r\n    }\r\n\r\n    public set gammaSpace(gamma: boolean) {\r\n        if (!this._texture) {\r\n            if (this._gammaSpace === gamma) {\r\n                return;\r\n            }\r\n\r\n            this._gammaSpace = gamma;\r\n        } else {\r\n            if (this._texture._gammaSpace === gamma) {\r\n                return;\r\n            }\r\n            this._texture._gammaSpace = gamma;\r\n        }\r\n\r\n        this._markAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets whether or not the texture contains RGBD data.\r\n     */\r\n    public get isRGBD(): boolean {\r\n        return this._texture != null && this._texture._isRGBD;\r\n    }\r\n    public set isRGBD(value: boolean) {\r\n        if (this._texture) {\r\n            this._texture._isRGBD = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Is Z inverted in the texture (useful in a cube texture).\r\n     */\r\n    @serialize()\r\n    public invertZ = false;\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    public get noMipmap(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    @serialize()\r\n    public lodLevelInAlpha = false;\r\n\r\n    /**\r\n     * With prefiltered texture, defined the offset used during the prefiltering steps.\r\n     */\r\n    @serialize()\r\n    public get lodGenerationOffset(): number {\r\n        if (this._texture) {\r\n            return this._texture._lodGenerationOffset;\r\n        }\r\n\r\n        return 0.0;\r\n    }\r\n    public set lodGenerationOffset(value: number) {\r\n        if (this._texture) {\r\n            this._texture._lodGenerationOffset = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * With prefiltered texture, defined the scale used during the prefiltering steps.\r\n     */\r\n    @serialize()\r\n    public get lodGenerationScale(): number {\r\n        if (this._texture) {\r\n            return this._texture._lodGenerationScale;\r\n        }\r\n\r\n        return 0.0;\r\n    }\r\n    public set lodGenerationScale(value: number) {\r\n        if (this._texture) {\r\n            this._texture._lodGenerationScale = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * With prefiltered texture, defined if the specular generation is based on a linear ramp.\r\n     * By default we are using a log2 of the linear roughness helping to keep a better resolution for\r\n     * average roughness values.\r\n     */\r\n    @serialize()\r\n    public get linearSpecularLOD(): boolean {\r\n        if (this._texture) {\r\n            return this._texture._linearSpecularLOD;\r\n        }\r\n\r\n        return false;\r\n    }\r\n    public set linearSpecularLOD(value: boolean) {\r\n        if (this._texture) {\r\n            this._texture._linearSpecularLOD = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * In case a better definition than spherical harmonics is required for the diffuse part of the environment.\r\n     * You can set the irradiance texture to rely on a texture instead of the spherical approach.\r\n     * This texture need to have the same characteristics than its parent (Cube vs 2d, coordinates mode, Gamma/Linear, RGBD).\r\n     */\r\n    @serializeAsTexture()\r\n    public get irradianceTexture(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._irradianceTexture;\r\n        }\r\n\r\n        return null;\r\n    }\r\n    public set irradianceTexture(value: Nullable<BaseTexture>) {\r\n        if (this._texture) {\r\n            this._texture._irradianceTexture = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a render target.\r\n     */\r\n    @serialize()\r\n    public isRenderTarget = false;\r\n\r\n    /**\r\n     * Define the unique id of the texture in the scene.\r\n     */\r\n    public get uid(): string {\r\n        if (!this._uid) {\r\n            this._uid = RandomGUID();\r\n        }\r\n        return this._uid;\r\n    }\r\n\r\n    /** @internal */\r\n    public _prefiltered: boolean = false;\r\n    /** @internal */\r\n    public _forceSerialize: boolean = false;\r\n\r\n    /**\r\n     * Return a string representation of the texture.\r\n     * @returns the texture as a string\r\n     */\r\n    public toString(): string {\r\n        return this.name;\r\n    }\r\n\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"BaseTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseTexture\";\r\n    }\r\n\r\n    /**\r\n     * Define the list of animation attached to the texture.\r\n     */\r\n    public animations = new Array<Animation>();\r\n\r\n    /**\r\n     * An event triggered when the texture is disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<BaseTexture>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<BaseTexture>> = null;\r\n    /**\r\n     * Callback triggered when the texture has been disposed.\r\n     * Kept for back compatibility, you can use the onDisposeObservable instead.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    protected _scene: Nullable<Scene> = null;\r\n\r\n    /** @internal */\r\n    private _uid: Nullable<string> = null;\r\n\r\n    /**\r\n     * Define if the texture is preventing a material to render or not.\r\n     * If not and the texture is not ready, the engine will use a default black texture instead.\r\n     */\r\n    public get isBlocking(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    protected _loadingError: boolean = false;\r\n    protected _errorObject?: {\r\n        message?: string;\r\n        exception?: any;\r\n    };\r\n\r\n    /**\r\n     * Was there any loading error?\r\n     */\r\n    public get loadingError(): boolean {\r\n        return this._loadingError;\r\n    }\r\n\r\n    /**\r\n     * If a loading error occurred this object will be populated with information about the error.\r\n     */\r\n    public get errorObject():\r\n        | {\r\n              message?: string;\r\n              exception?: any;\r\n          }\r\n        | undefined {\r\n        return this._errorObject;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new BaseTexture.\r\n     * Base class of all the textures in babylon.\r\n     * It groups all the common properties the materials, post process, lights... might need\r\n     * in order to make a correct use of the texture.\r\n     * @param sceneOrEngine Define the scene or engine the texture belongs to\r\n     * @param internalTexture Define the internal texture associated with the texture\r\n     */\r\n    constructor(sceneOrEngine?: Nullable<Scene | ThinEngine>, internalTexture: Nullable<InternalTexture> = null) {\r\n        super(null);\r\n\r\n        if (sceneOrEngine) {\r\n            if (BaseTexture._IsScene(sceneOrEngine)) {\r\n                this._scene = sceneOrEngine;\r\n            } else {\r\n                this._engine = sceneOrEngine;\r\n            }\r\n        } else {\r\n            this._scene = EngineStore.LastCreatedScene;\r\n        }\r\n\r\n        if (this._scene) {\r\n            this.uniqueId = this._scene.getUniqueId();\r\n            this._scene.addTexture(this);\r\n            this._engine = this._scene.getEngine();\r\n        }\r\n\r\n        this._texture = internalTexture;\r\n\r\n        this._uid = null;\r\n    }\r\n\r\n    /**\r\n     * Get the scene the texture belongs to.\r\n     * @returns the scene or null if undefined\r\n     */\r\n    public getScene(): Nullable<Scene> {\r\n        return this._scene;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _getEngine(): Nullable<ThinEngine> {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Checks if the texture has the same transform matrix than another texture\r\n     * @param texture texture to check against\r\n     * @returns true if the transforms are the same, else false\r\n     */\r\n    public checkTransformsAreIdentical(texture: Nullable<BaseTexture>): boolean {\r\n        return texture !== null;\r\n    }\r\n\r\n    /**\r\n     * Get the texture transform matrix used to offset tile the texture for instance.\r\n     * @returns the transformation matrix\r\n     */\r\n    public getTextureMatrix(): Matrix {\r\n        return <Matrix>Matrix.IdentityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Get the texture reflection matrix used to rotate/transform the reflection.\r\n     * @returns the reflection matrix\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        return <Matrix>Matrix.IdentityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Gets a suitable rotate/transform matrix when the texture is used for refraction.\r\n     * There's a separate function from getReflectionTextureMatrix because refraction requires a special configuration of the matrix in right-handed mode.\r\n     * @returns The refraction matrix\r\n     */\r\n    public getRefractionTextureMatrix(): Matrix {\r\n        return this.getReflectionTextureMatrix();\r\n    }\r\n\r\n    /**\r\n     * Get if the texture is ready to be consumed (either it is ready or it is not blocking)\r\n     * @returns true if ready, not blocking or if there was an error loading the texture\r\n     */\r\n    public isReadyOrNotBlocking(): boolean {\r\n        return !this.isBlocking || this.isReady() || this.loadingError;\r\n    }\r\n\r\n    /**\r\n     * Scales the texture if is `canRescale()`\r\n     * @param ratio the resize factor we want to use to rescale\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public scale(ratio: number): void {}\r\n\r\n    /**\r\n     * Get if the texture can rescale.\r\n     */\r\n    public get canRescale(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getFromCache(url: Nullable<string>, noMipmap: boolean, sampling?: number, invertY?: boolean, useSRGBBuffer?: boolean, isCube?: boolean): Nullable<InternalTexture> {\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        const correctedUseSRGBBuffer = engine._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);\r\n\r\n        const texturesCache = engine.getLoadedTexturesCache();\r\n        for (let index = 0; index < texturesCache.length; index++) {\r\n            const texturesCacheEntry = texturesCache[index];\r\n\r\n            if (useSRGBBuffer === undefined || correctedUseSRGBBuffer === texturesCacheEntry._useSRGBBuffer) {\r\n                if (invertY === undefined || invertY === texturesCacheEntry.invertY) {\r\n                    if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {\r\n                        if (!sampling || sampling === texturesCacheEntry.samplingMode) {\r\n                            if (isCube === undefined || isCube === texturesCacheEntry.isCube) {\r\n                                texturesCacheEntry.incrementReferences();\r\n                                return texturesCacheEntry;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {}\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get the texture underlying type (INT, FLOAT...)\r\n     */\r\n    public get textureType(): number {\r\n        if (!this._texture) {\r\n            return Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        }\r\n\r\n        return this._texture.type !== undefined ? this._texture.type : Constants.TEXTURETYPE_UNSIGNED_INT;\r\n    }\r\n\r\n    /**\r\n     * Get the texture underlying format (RGB, RGBA...)\r\n     */\r\n    public get textureFormat(): number {\r\n        if (!this._texture) {\r\n            return Constants.TEXTUREFORMAT_RGBA;\r\n        }\r\n\r\n        return this._texture.format !== undefined ? this._texture.format : Constants.TEXTUREFORMAT_RGBA;\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures need to be re-calculated for all materials\r\n     */\r\n    protected _markAllSubMeshesAsTexturesDirty() {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.\r\n     * This will returns an RGBA array buffer containing either in values (0-255) or\r\n     * float values (0-1) depending of the underlying buffer type.\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @param buffer defines a user defined buffer to fill with data (can be null)\r\n     * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\r\n     * @param noDataConversion false to convert the data to Uint8Array (if texture type is UNSIGNED_BYTE) or to Float32Array (if texture type is anything but UNSIGNED_BYTE). If true, the type of the generated buffer (if buffer==null) will depend on the type of the texture\r\n     * @param x defines the region x coordinates to start reading from (default to 0)\r\n     * @param y defines the region y coordinates to start reading from (default to 0)\r\n     * @param width defines the region width to read from (default to the texture size at level)\r\n     * @param height defines the region width to read from (default to the texture size at level)\r\n     * @returns The Array buffer promise containing the pixels data.\r\n     */\r\n    public readPixels(\r\n        faceIndex = 0,\r\n        level = 0,\r\n        buffer: Nullable<ArrayBufferView> = null,\r\n        flushRenderer = true,\r\n        noDataConversion = false,\r\n        x = 0,\r\n        y = 0,\r\n        width = Number.MAX_VALUE,\r\n        height = Number.MAX_VALUE\r\n    ): Nullable<Promise<ArrayBufferView>> {\r\n        if (!this._texture) {\r\n            return null;\r\n        }\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        const size = this.getSize();\r\n        let maxWidth = size.width;\r\n        let maxHeight = size.height;\r\n        if (level !== 0) {\r\n            maxWidth = maxWidth / Math.pow(2, level);\r\n            maxHeight = maxHeight / Math.pow(2, level);\r\n            maxWidth = Math.round(maxWidth);\r\n            maxHeight = Math.round(maxHeight);\r\n        }\r\n\r\n        width = Math.min(maxWidth, width);\r\n        height = Math.min(maxHeight, height);\r\n\r\n        try {\r\n            if (this._texture.isCube) {\r\n                return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y);\r\n            }\r\n\r\n            return engine._readTexturePixels(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion, x, y);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _readPixelsSync(faceIndex = 0, level = 0, buffer: Nullable<ArrayBufferView> = null, flushRenderer = true, noDataConversion = false): Nullable<ArrayBufferView> {\r\n        if (!this._texture) {\r\n            return null;\r\n        }\r\n\r\n        const size = this.getSize();\r\n        let width = size.width;\r\n        let height = size.height;\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        if (level != 0) {\r\n            width = width / Math.pow(2, level);\r\n            height = height / Math.pow(2, level);\r\n\r\n            width = Math.round(width);\r\n            height = Math.round(height);\r\n        }\r\n\r\n        try {\r\n            if (this._texture.isCube) {\r\n                return engine._readTexturePixelsSync(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion);\r\n            }\r\n\r\n            return engine._readTexturePixelsSync(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public get _lodTextureHigh(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureHigh;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _lodTextureMid(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureMid;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _lodTextureLow(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureLow;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._scene) {\r\n            // Animations\r\n            if (this._scene.stopAnimation) {\r\n                this._scene.stopAnimation(this);\r\n            }\r\n\r\n            // Remove from scene\r\n            this._scene.removePendingData(this);\r\n            const index = this._scene.textures.indexOf(this);\r\n\r\n            if (index >= 0) {\r\n                this._scene.textures.splice(index, 1);\r\n            }\r\n            this._scene.onTextureRemovedObservable.notifyObservers(this);\r\n            this._scene = null;\r\n\r\n            if (this._parentContainer) {\r\n                const index = this._parentContainer.textures.indexOf(this);\r\n                if (index > -1) {\r\n                    this._parentContainer.textures.splice(index, 1);\r\n                }\r\n                this._parentContainer = null;\r\n            }\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n\r\n        this.metadata = null;\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Serialize the texture into a JSON representation that can be parsed later on.\r\n     * @param allowEmptyName True to force serialization even if name is empty. Default: false\r\n     * @returns the JSON representation of the texture\r\n     */\r\n    public serialize(allowEmptyName = false): any {\r\n        if (!this.name && !allowEmptyName) {\r\n            return null;\r\n        }\r\n\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Helper function to be called back once a list of texture contains only ready textures.\r\n     * @param textures Define the list of textures to wait for\r\n     * @param callback Define the callback triggered once the entire list will be ready\r\n     */\r\n    public static WhenAllReady(textures: BaseTexture[], callback: () => void): void {\r\n        let numRemaining = textures.length;\r\n        if (numRemaining === 0) {\r\n            callback();\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < textures.length; i++) {\r\n            const texture = textures[i];\r\n\r\n            if (texture.isReady()) {\r\n                if (--numRemaining === 0) {\r\n                    callback();\r\n                }\r\n            } else {\r\n                const onLoadObservable = (texture as any).onLoadObservable as Observable<BaseTexture>;\r\n\r\n                if (onLoadObservable) {\r\n                    onLoadObservable.addOnce(() => {\r\n                        if (--numRemaining === 0) {\r\n                            callback();\r\n                        }\r\n                    });\r\n                } else {\r\n                    if (--numRemaining === 0) {\r\n                        callback();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _IsScene(sceneOrEngine: Scene | ThinEngine): sceneOrEngine is Scene {\r\n        return sceneOrEngine.getClassName() === \"Scene\";\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}