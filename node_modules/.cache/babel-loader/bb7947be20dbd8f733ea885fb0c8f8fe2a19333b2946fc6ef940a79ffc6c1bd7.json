{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { TmpVectors, Vector3 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { VolumeBasedPanel } from \"./volumeBasedPanel.js\";\nimport { Container3D } from \"./container3D.js\";\n/**\n * Class used to create a container panel where items get randomized planar mapping\n */\nexport class ScatterPanel extends VolumeBasedPanel {\n  constructor() {\n    super(...arguments);\n    this._iteration = 100.0;\n  }\n  /**\n   * Gets or sets the number of iteration to use to scatter the controls (100 by default)\n   */\n  get iteration() {\n    return this._iteration;\n  }\n  set iteration(value) {\n    if (this._iteration === value) {\n      return;\n    }\n    this._iteration = value;\n    Tools.SetImmediate(() => {\n      this._arrangeChildren();\n    });\n  }\n  _mapGridNode(control, nodePosition) {\n    const mesh = control.mesh;\n    const newPos = this._scatterMapping(nodePosition);\n    if (!mesh) {\n      return;\n    }\n    switch (this.orientation) {\n      case Container3D.FACEORIGIN_ORIENTATION:\n      case Container3D.FACEFORWARD_ORIENTATION:\n        mesh.lookAt(new Vector3(0, 0, 1));\n        break;\n      case Container3D.FACEFORWARDREVERSED_ORIENTATION:\n      case Container3D.FACEORIGINREVERSED_ORIENTATION:\n        mesh.lookAt(new Vector3(0, 0, -1));\n        break;\n    }\n    control.position = newPos;\n  }\n  _scatterMapping(source) {\n    source.x = (1.0 - Math.random() * 2.0) * this._cellWidth;\n    source.y = (1.0 - Math.random() * 2.0) * this._cellHeight;\n    return source;\n  }\n  _finalProcessing() {\n    const meshes = [];\n    for (const child of this._children) {\n      if (!child.mesh) {\n        continue;\n      }\n      meshes.push(child.mesh);\n    }\n    for (let count = 0; count < this._iteration; count++) {\n      meshes.sort((a, b) => {\n        const distance1 = a.position.lengthSquared();\n        const distance2 = b.position.lengthSquared();\n        if (distance1 < distance2) {\n          return 1;\n        } else if (distance1 > distance2) {\n          return -1;\n        }\n        return 0;\n      });\n      const radiusPaddingSquared = Math.pow(this.margin, 2.0);\n      const cellSize = Math.max(this._cellWidth, this._cellHeight);\n      const difference2D = TmpVectors.Vector2[0];\n      const difference = TmpVectors.Vector3[0];\n      for (let i = 0; i < meshes.length - 1; i++) {\n        for (let j = i + 1; j < meshes.length; j++) {\n          if (i != j) {\n            meshes[j].position.subtractToRef(meshes[i].position, difference);\n            // Ignore Z axis\n            difference2D.x = difference.x;\n            difference2D.y = difference.y;\n            const combinedRadius = cellSize;\n            let distance = difference2D.lengthSquared() - radiusPaddingSquared;\n            const minSeparation = Math.min(distance, radiusPaddingSquared);\n            distance -= minSeparation;\n            if (distance < Math.pow(combinedRadius, 2.0)) {\n              difference2D.normalize();\n              difference.scaleInPlace((combinedRadius - Math.sqrt(distance)) * 0.5);\n              meshes[j].position.addInPlace(difference);\n              meshes[i].position.subtractInPlace(difference);\n            }\n          }\n        }\n      }\n    }\n  }\n}","map":{"version":3,"names":["Tools","TmpVectors","Vector3","VolumeBasedPanel","Container3D","ScatterPanel","constructor","_iteration","iteration","value","SetImmediate","_arrangeChildren","_mapGridNode","control","nodePosition","mesh","newPos","_scatterMapping","orientation","FACEORIGIN_ORIENTATION","FACEFORWARD_ORIENTATION","lookAt","FACEFORWARDREVERSED_ORIENTATION","FACEORIGINREVERSED_ORIENTATION","position","source","x","Math","random","_cellWidth","y","_cellHeight","_finalProcessing","meshes","child","_children","push","count","sort","a","b","distance1","lengthSquared","distance2","radiusPaddingSquared","pow","margin","cellSize","max","difference2D","Vector2","difference","i","length","j","subtractToRef","combinedRadius","distance","minSeparation","min","normalize","scaleInPlace","sqrt","addInPlace","subtractInPlace"],"sources":["../../../../../dev/gui/src/3D/controls/scatterPanel.ts"],"sourcesContent":["import { Tools } from \"core/Misc/tools\";\r\nimport { TmpVectors, Vector3 } from \"core/Maths/math.vector\";\r\nimport type { float } from \"core/types\";\r\n\r\nimport { VolumeBasedPanel } from \"./volumeBasedPanel\";\r\nimport type { Control3D } from \"./control3D\";\r\nimport { Container3D } from \"./container3D\";\r\n\r\n/**\r\n * Class used to create a container panel where items get randomized planar mapping\r\n */\r\nexport class ScatterPanel extends VolumeBasedPanel {\r\n    private _iteration = 100.0;\r\n\r\n    /**\r\n     * Gets or sets the number of iteration to use to scatter the controls (100 by default)\r\n     */\r\n    public get iteration(): float {\r\n        return this._iteration;\r\n    }\r\n\r\n    public set iteration(value: float) {\r\n        if (this._iteration === value) {\r\n            return;\r\n        }\r\n\r\n        this._iteration = value;\r\n\r\n        Tools.SetImmediate(() => {\r\n            this._arrangeChildren();\r\n        });\r\n    }\r\n\r\n    protected _mapGridNode(control: Control3D, nodePosition: Vector3) {\r\n        const mesh = control.mesh;\r\n        const newPos = this._scatterMapping(nodePosition);\r\n\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        switch (this.orientation) {\r\n            case Container3D.FACEORIGIN_ORIENTATION:\r\n            case Container3D.FACEFORWARD_ORIENTATION:\r\n                mesh.lookAt(new Vector3(0, 0, 1));\r\n                break;\r\n            case Container3D.FACEFORWARDREVERSED_ORIENTATION:\r\n            case Container3D.FACEORIGINREVERSED_ORIENTATION:\r\n                mesh.lookAt(new Vector3(0, 0, -1));\r\n                break;\r\n        }\r\n\r\n        control.position = newPos;\r\n    }\r\n\r\n    private _scatterMapping(source: Vector3): Vector3 {\r\n        source.x = (1.0 - Math.random() * 2.0) * this._cellWidth;\r\n        source.y = (1.0 - Math.random() * 2.0) * this._cellHeight;\r\n\r\n        return source;\r\n    }\r\n\r\n    protected _finalProcessing() {\r\n        const meshes = [];\r\n        for (const child of this._children) {\r\n            if (!child.mesh) {\r\n                continue;\r\n            }\r\n\r\n            meshes.push(child.mesh);\r\n        }\r\n\r\n        for (let count = 0; count < this._iteration; count++) {\r\n            meshes.sort((a, b) => {\r\n                const distance1 = a.position.lengthSquared();\r\n                const distance2 = b.position.lengthSquared();\r\n\r\n                if (distance1 < distance2) {\r\n                    return 1;\r\n                } else if (distance1 > distance2) {\r\n                    return -1;\r\n                }\r\n\r\n                return 0;\r\n            });\r\n\r\n            const radiusPaddingSquared = Math.pow(this.margin, 2.0);\r\n            const cellSize = Math.max(this._cellWidth, this._cellHeight);\r\n            const difference2D = TmpVectors.Vector2[0];\r\n            const difference = TmpVectors.Vector3[0];\r\n\r\n            for (let i = 0; i < meshes.length - 1; i++) {\r\n                for (let j = i + 1; j < meshes.length; j++) {\r\n                    if (i != j) {\r\n                        meshes[j].position.subtractToRef(meshes[i].position, difference);\r\n\r\n                        // Ignore Z axis\r\n                        difference2D.x = difference.x;\r\n                        difference2D.y = difference.y;\r\n                        const combinedRadius = cellSize;\r\n                        let distance = difference2D.lengthSquared() - radiusPaddingSquared;\r\n                        const minSeparation = Math.min(distance, radiusPaddingSquared);\r\n                        distance -= minSeparation;\r\n\r\n                        if (distance < Math.pow(combinedRadius, 2.0)) {\r\n                            difference2D.normalize();\r\n                            difference.scaleInPlace((combinedRadius - Math.sqrt(distance)) * 0.5);\r\n                            meshes[j].position.addInPlace(difference);\r\n                            meshes[i].position.subtractInPlace(difference);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}