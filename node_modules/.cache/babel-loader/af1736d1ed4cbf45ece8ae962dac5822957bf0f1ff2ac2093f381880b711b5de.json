{"ast":null,"code":"import { Scene } from \"../scene.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { Collider } from \"./collider.js\";\n/** @internal */\nexport class DefaultCollisionCoordinator {\n  constructor() {\n    this._scaledPosition = Vector3.Zero();\n    this._scaledVelocity = Vector3.Zero();\n    this._finalPosition = Vector3.Zero();\n  }\n  getNewPosition(position, displacement, collider, maximumRetry, excludedMesh, onNewPosition, collisionIndex) {\n    position.divideToRef(collider._radius, this._scaledPosition);\n    displacement.divideToRef(collider._radius, this._scaledVelocity);\n    collider.collidedMesh = null;\n    collider._retry = 0;\n    collider._initialVelocity = this._scaledVelocity;\n    collider._initialPosition = this._scaledPosition;\n    this._collideWithWorld(this._scaledPosition, this._scaledVelocity, collider, maximumRetry, this._finalPosition, excludedMesh);\n    this._finalPosition.multiplyInPlace(collider._radius);\n    //run the callback\n    onNewPosition(collisionIndex, this._finalPosition, collider.collidedMesh);\n  }\n  createCollider() {\n    return new Collider();\n  }\n  init(scene) {\n    this._scene = scene;\n  }\n  _collideWithWorld(position, velocity, collider, maximumRetry, finalPosition, excludedMesh = null) {\n    const closeDistance = Engine.CollisionsEpsilon * 10.0;\n    if (collider._retry >= maximumRetry) {\n      finalPosition.copyFrom(position);\n      return;\n    }\n    // Check if this is a mesh else camera or -1\n    const collisionMask = excludedMesh ? excludedMesh.collisionMask : collider.collisionMask;\n    collider._initialize(position, velocity, closeDistance);\n    // Check if collision detection should happen against specified list of meshes or,\n    // if not specified, against all meshes in the scene\n    const meshes = excludedMesh && excludedMesh.surroundingMeshes || this._scene.meshes;\n    for (let index = 0; index < meshes.length; index++) {\n      const mesh = meshes[index];\n      if (mesh.isEnabled() && mesh.checkCollisions && mesh.subMeshes && mesh !== excludedMesh && (collisionMask & mesh.collisionGroup) !== 0) {\n        mesh._checkCollision(collider);\n      }\n    }\n    if (!collider.collisionFound) {\n      position.addToRef(velocity, finalPosition);\n      return;\n    }\n    if (velocity.x !== 0 || velocity.y !== 0 || velocity.z !== 0) {\n      collider._getResponse(position, velocity);\n    }\n    if (velocity.length() <= closeDistance) {\n      finalPosition.copyFrom(position);\n      return;\n    }\n    collider._retry++;\n    this._collideWithWorld(position, velocity, collider, maximumRetry, finalPosition, excludedMesh);\n  }\n}\nScene.CollisionCoordinatorFactory = () => {\n  return new DefaultCollisionCoordinator();\n};","map":{"version":3,"names":["Scene","Vector3","Engine","Collider","DefaultCollisionCoordinator","constructor","_scaledPosition","Zero","_scaledVelocity","_finalPosition","getNewPosition","position","displacement","collider","maximumRetry","excludedMesh","onNewPosition","collisionIndex","divideToRef","_radius","collidedMesh","_retry","_initialVelocity","_initialPosition","_collideWithWorld","multiplyInPlace","createCollider","init","scene","_scene","velocity","finalPosition","closeDistance","CollisionsEpsilon","copyFrom","collisionMask","_initialize","meshes","surroundingMeshes","index","length","mesh","isEnabled","checkCollisions","subMeshes","collisionGroup","_checkCollision","collisionFound","addToRef","x","y","z","_getResponse","CollisionCoordinatorFactory"],"sources":["../../../../dev/core/src/Collisions/collisionCoordinator.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { Collider } from \"./collider\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\n\r\n/** @internal */\r\nexport interface ICollisionCoordinator {\r\n    createCollider(): Collider;\r\n    getNewPosition(\r\n        position: Vector3,\r\n        displacement: Vector3,\r\n        collider: Collider,\r\n        maximumRetry: number,\r\n        excludedMesh: Nullable<AbstractMesh>,\r\n        onNewPosition: (collisionIndex: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh>) => void,\r\n        collisionIndex: number\r\n    ): void;\r\n    init(scene: Scene): void;\r\n}\r\n\r\n/** @internal */\r\nexport class DefaultCollisionCoordinator implements ICollisionCoordinator {\r\n    private _scene: Scene;\r\n\r\n    private _scaledPosition = Vector3.Zero();\r\n    private _scaledVelocity = Vector3.Zero();\r\n\r\n    private _finalPosition = Vector3.Zero();\r\n\r\n    public getNewPosition(\r\n        position: Vector3,\r\n        displacement: Vector3,\r\n        collider: Collider,\r\n        maximumRetry: number,\r\n        excludedMesh: AbstractMesh,\r\n        onNewPosition: (collisionIndex: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh>) => void,\r\n        collisionIndex: number\r\n    ): void {\r\n        position.divideToRef(collider._radius, this._scaledPosition);\r\n        displacement.divideToRef(collider._radius, this._scaledVelocity);\r\n        collider.collidedMesh = null;\r\n        collider._retry = 0;\r\n        collider._initialVelocity = this._scaledVelocity;\r\n        collider._initialPosition = this._scaledPosition;\r\n        this._collideWithWorld(this._scaledPosition, this._scaledVelocity, collider, maximumRetry, this._finalPosition, excludedMesh);\r\n\r\n        this._finalPosition.multiplyInPlace(collider._radius);\r\n        //run the callback\r\n        onNewPosition(collisionIndex, this._finalPosition, collider.collidedMesh);\r\n    }\r\n\r\n    public createCollider(): Collider {\r\n        return new Collider();\r\n    }\r\n\r\n    public init(scene: Scene): void {\r\n        this._scene = scene;\r\n    }\r\n\r\n    private _collideWithWorld(\r\n        position: Vector3,\r\n        velocity: Vector3,\r\n        collider: Collider,\r\n        maximumRetry: number,\r\n        finalPosition: Vector3,\r\n        excludedMesh: Nullable<AbstractMesh> = null\r\n    ): void {\r\n        const closeDistance = Engine.CollisionsEpsilon * 10.0;\r\n\r\n        if (collider._retry >= maximumRetry) {\r\n            finalPosition.copyFrom(position);\r\n            return;\r\n        }\r\n\r\n        // Check if this is a mesh else camera or -1\r\n        const collisionMask = excludedMesh ? excludedMesh.collisionMask : collider.collisionMask;\r\n\r\n        collider._initialize(position, velocity, closeDistance);\r\n\r\n        // Check if collision detection should happen against specified list of meshes or,\r\n        // if not specified, against all meshes in the scene\r\n        const meshes = (excludedMesh && excludedMesh.surroundingMeshes) || this._scene.meshes;\r\n\r\n        for (let index = 0; index < meshes.length; index++) {\r\n            const mesh = meshes[index];\r\n            if (mesh.isEnabled() && mesh.checkCollisions && mesh.subMeshes && mesh !== excludedMesh && (collisionMask & mesh.collisionGroup) !== 0) {\r\n                mesh._checkCollision(collider);\r\n            }\r\n        }\r\n\r\n        if (!collider.collisionFound) {\r\n            position.addToRef(velocity, finalPosition);\r\n            return;\r\n        }\r\n\r\n        if (velocity.x !== 0 || velocity.y !== 0 || velocity.z !== 0) {\r\n            collider._getResponse(position, velocity);\r\n        }\r\n\r\n        if (velocity.length() <= closeDistance) {\r\n            finalPosition.copyFrom(position);\r\n            return;\r\n        }\r\n\r\n        collider._retry++;\r\n        this._collideWithWorld(position, velocity, collider, maximumRetry, finalPosition, excludedMesh);\r\n    }\r\n}\r\n\r\nScene.CollisionCoordinatorFactory = () => {\r\n    return new DefaultCollisionCoordinator();\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}