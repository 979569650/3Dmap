{"ast":null,"code":"import { TouchButton3D } from \"./touchButton3D.js\";\n/**\n * Class used to create an interactable object. It's a touchable 3D button using a mesh coming from the current scene\n * @since 5.0.0\n */\nexport class TouchMeshButton3D extends TouchButton3D {\n  /**\n   * Creates a new 3D button based on a mesh\n   * @param mesh mesh to become a 3D button. By default this is also the mesh for near interaction collision checking\n   * @param name defines the control name\n   */\n  constructor(mesh, name) {\n    super(name, mesh);\n    this._currentMesh = mesh;\n    /**\n     * Provides a default behavior on hover/out & up/down\n     * Override those function to create your own desired behavior specific to your mesh\n     */\n    this.pointerEnterAnimation = () => {\n      if (!this.mesh) {\n        return;\n      }\n      this.mesh.scaling.scaleInPlace(1.1);\n    };\n    this.pointerOutAnimation = () => {\n      if (!this.mesh) {\n        return;\n      }\n      this.mesh.scaling.scaleInPlace(1.0 / 1.1);\n    };\n    this.pointerDownAnimation = () => {\n      if (!this.mesh) {\n        return;\n      }\n      this.mesh.scaling.scaleInPlace(0.95);\n    };\n    this.pointerUpAnimation = () => {\n      if (!this.mesh) {\n        return;\n      }\n      this.mesh.scaling.scaleInPlace(1.0 / 0.95);\n    };\n  }\n  _getTypeName() {\n    return \"TouchMeshButton3D\";\n  }\n  // Mesh association\n  _createNode() {\n    this._currentMesh.getChildMeshes().forEach(mesh => {\n      this._injectGUI3DReservedDataStore(mesh).control = this;\n    });\n    return this._currentMesh;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _affectMaterial(mesh) {}\n}","map":{"version":3,"names":["TouchButton3D","TouchMeshButton3D","constructor","mesh","name","_currentMesh","pointerEnterAnimation","scaling","scaleInPlace","pointerOutAnimation","pointerDownAnimation","pointerUpAnimation","_getTypeName","_createNode","getChildMeshes","forEach","_injectGUI3DReservedDataStore","control","_affectMaterial"],"sources":["../../../../../dev/gui/src/3D/controls/touchMeshButton3D.ts"],"sourcesContent":["import type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\n\r\nimport { TouchButton3D } from \"./touchButton3D\";\r\n\r\n/**\r\n * Class used to create an interactable object. It's a touchable 3D button using a mesh coming from the current scene\r\n * @since 5.0.0\r\n */\r\nexport class TouchMeshButton3D extends TouchButton3D {\r\n    /** @internal */\r\n    protected _currentMesh: Mesh;\r\n\r\n    /**\r\n     * Creates a new 3D button based on a mesh\r\n     * @param mesh mesh to become a 3D button. By default this is also the mesh for near interaction collision checking\r\n     * @param name defines the control name\r\n     */\r\n    constructor(mesh: Mesh, name?: string) {\r\n        super(name, mesh);\r\n\r\n        this._currentMesh = mesh;\r\n\r\n        /**\r\n         * Provides a default behavior on hover/out & up/down\r\n         * Override those function to create your own desired behavior specific to your mesh\r\n         */\r\n        this.pointerEnterAnimation = () => {\r\n            if (!this.mesh) {\r\n                return;\r\n            }\r\n            this.mesh.scaling.scaleInPlace(1.1);\r\n        };\r\n\r\n        this.pointerOutAnimation = () => {\r\n            if (!this.mesh) {\r\n                return;\r\n            }\r\n            this.mesh.scaling.scaleInPlace(1.0 / 1.1);\r\n        };\r\n\r\n        this.pointerDownAnimation = () => {\r\n            if (!this.mesh) {\r\n                return;\r\n            }\r\n            this.mesh.scaling.scaleInPlace(0.95);\r\n        };\r\n\r\n        this.pointerUpAnimation = () => {\r\n            if (!this.mesh) {\r\n                return;\r\n            }\r\n            this.mesh.scaling.scaleInPlace(1.0 / 0.95);\r\n        };\r\n    }\r\n\r\n    protected _getTypeName(): string {\r\n        return \"TouchMeshButton3D\";\r\n    }\r\n\r\n    // Mesh association\r\n    protected _createNode(): TransformNode {\r\n        this._currentMesh.getChildMeshes().forEach((mesh) => {\r\n            this._injectGUI3DReservedDataStore(mesh).control = this;\r\n        });\r\n\r\n        return this._currentMesh;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _affectMaterial(mesh: AbstractMesh) {}\r\n}\r\n"],"mappings":"AAIA,SAASA,aAAa,QAAQ,oBAAkB;AAEhD;;;;AAIA,OAAM,MAAOC,iBAAkB,SAAQD,aAAa;EAIhD;;;;;EAKAE,YAAYC,IAAU,EAAEC,IAAa;IACjC,KAAK,CAACA,IAAI,EAAED,IAAI,CAAC;IAEjB,IAAI,CAACE,YAAY,GAAGF,IAAI;IAExB;;;;IAIA,IAAI,CAACG,qBAAqB,GAAG,MAAK;MAC9B,IAAI,CAAC,IAAI,CAACH,IAAI,EAAE;QACZ;;MAEJ,IAAI,CAACA,IAAI,CAACI,OAAO,CAACC,YAAY,CAAC,GAAG,CAAC;IACvC,CAAC;IAED,IAAI,CAACC,mBAAmB,GAAG,MAAK;MAC5B,IAAI,CAAC,IAAI,CAACN,IAAI,EAAE;QACZ;;MAEJ,IAAI,CAACA,IAAI,CAACI,OAAO,CAACC,YAAY,CAAC,GAAG,GAAG,GAAG,CAAC;IAC7C,CAAC;IAED,IAAI,CAACE,oBAAoB,GAAG,MAAK;MAC7B,IAAI,CAAC,IAAI,CAACP,IAAI,EAAE;QACZ;;MAEJ,IAAI,CAACA,IAAI,CAACI,OAAO,CAACC,YAAY,CAAC,IAAI,CAAC;IACxC,CAAC;IAED,IAAI,CAACG,kBAAkB,GAAG,MAAK;MAC3B,IAAI,CAAC,IAAI,CAACR,IAAI,EAAE;QACZ;;MAEJ,IAAI,CAACA,IAAI,CAACI,OAAO,CAACC,YAAY,CAAC,GAAG,GAAG,IAAI,CAAC;IAC9C,CAAC;EACL;EAEUI,YAAYA,CAAA;IAClB,OAAO,mBAAmB;EAC9B;EAEA;EACUC,WAAWA,CAAA;IACjB,IAAI,CAACR,YAAY,CAACS,cAAc,EAAE,CAACC,OAAO,CAAEZ,IAAI,IAAI;MAChD,IAAI,CAACa,6BAA6B,CAACb,IAAI,CAAC,CAACc,OAAO,GAAG,IAAI;IAC3D,CAAC,CAAC;IAEF,OAAO,IAAI,CAACZ,YAAY;EAC5B;EAEA;EACUa,eAAeA,CAACf,IAAkB,GAAG"},"metadata":{},"sourceType":"module","externalDependencies":[]}