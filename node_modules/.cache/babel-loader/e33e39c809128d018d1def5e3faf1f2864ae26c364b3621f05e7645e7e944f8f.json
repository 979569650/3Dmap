{"ast":null,"code":"/**\n * Logger used throughout the application to allow configuration of\n * the log level required for the messages.\n */\nexport class Logger {\n  static _CheckLimit(message, limit) {\n    let entry = Logger._LogLimitOutputs[message];\n    if (!entry) {\n      entry = {\n        limit,\n        current: 1\n      };\n      Logger._LogLimitOutputs[message] = entry;\n    } else {\n      entry.current++;\n    }\n    return entry.current <= entry.limit;\n  }\n  static _GenerateLimitMessage(message, level = 1) {\n    var _a;\n    const entry = Logger._LogLimitOutputs[message];\n    if (!entry || !Logger.MessageLimitReached) {\n      return;\n    }\n    const type = this._Levels[level];\n    if (entry.current === entry.limit) {\n      Logger[type.name](Logger.MessageLimitReached.replace(/%LIMIT%/g, \"\" + entry.limit).replace(/%TYPE%/g, (_a = type.name) !== null && _a !== void 0 ? _a : \"\"));\n    }\n  }\n  static _AddLogEntry(entry) {\n    Logger._LogCache = entry + Logger._LogCache;\n    if (Logger.OnNewCacheEntry) {\n      Logger.OnNewCacheEntry(entry);\n    }\n  }\n  static _FormatMessage(message) {\n    const padStr = i => i < 10 ? \"0\" + i : \"\" + i;\n    const date = new Date();\n    return \"[\" + padStr(date.getHours()) + \":\" + padStr(date.getMinutes()) + \":\" + padStr(date.getSeconds()) + \"]: \" + message;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  static _LogDisabled(message, limit) {\n    // nothing to do\n  }\n  static _LogEnabled(level = 1, message, limit) {\n    if (limit !== undefined && !Logger._CheckLimit(message, limit)) {\n      return;\n    }\n    const formattedMessage = Logger._FormatMessage(message);\n    const type = this._Levels[level];\n    type.logFunc && type.logFunc(\"BJS - \" + formattedMessage);\n    const entry = `<div style='color:${type.color}'>${formattedMessage}</div><br>`;\n    Logger._AddLogEntry(entry);\n    Logger._GenerateLimitMessage(message, level);\n  }\n  /**\n   * Gets current log cache (list of logs)\n   */\n  static get LogCache() {\n    return Logger._LogCache;\n  }\n  /**\n   * Clears the log cache\n   */\n  static ClearLogCache() {\n    Logger._LogCache = \"\";\n    Logger._LogLimitOutputs = {};\n    Logger.errorsCount = 0;\n  }\n  /**\n   * Sets the current log level (MessageLogLevel / WarningLogLevel / ErrorLogLevel)\n   */\n  static set LogLevels(level) {\n    Logger.Log = Logger._LogDisabled;\n    Logger.Warn = Logger._LogDisabled;\n    Logger.Error = Logger._LogDisabled;\n    [Logger.MessageLogLevel, Logger.WarningLogLevel, Logger.ErrorLogLevel].forEach(l => {\n      if ((level & l) === l) {\n        const type = this._Levels[l];\n        Logger[type.name] = Logger._LogEnabled.bind(Logger, l);\n      }\n    });\n  }\n}\n/**\n * No log\n */\nLogger.NoneLogLevel = 0;\n/**\n * Only message logs\n */\nLogger.MessageLogLevel = 1;\n/**\n * Only warning logs\n */\nLogger.WarningLogLevel = 2;\n/**\n * Only error logs\n */\nLogger.ErrorLogLevel = 4;\n/**\n * All logs\n */\nLogger.AllLogLevel = 7;\n/**\n * Message to display when a message has been logged too many times\n */\nLogger.MessageLimitReached = \"Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.\";\nLogger._LogCache = \"\";\nLogger._LogLimitOutputs = {};\n// levels according to the (binary) numbering.\nLogger._Levels = [{}, {\n  color: \"white\",\n  logFunc: console.log,\n  name: \"Log\"\n}, {\n  color: \"orange\",\n  logFunc: console.warn,\n  name: \"Warn\"\n}, {}, {\n  color: \"red\",\n  logFunc: console.error,\n  name: \"Error\"\n}];\n/**\n * Gets a value indicating the number of loading errors\n * @ignorenaming\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nLogger.errorsCount = 0;\n/**\n * Log a message to the console\n */\nLogger.Log = Logger._LogEnabled.bind(Logger, Logger.MessageLogLevel);\n/**\n * Write a warning message to the console\n */\nLogger.Warn = Logger._LogEnabled.bind(Logger, Logger.WarningLogLevel);\n/**\n * Write an error message to the console\n */\nLogger.Error = Logger._LogEnabled.bind(Logger, Logger.ErrorLogLevel);","map":{"version":3,"names":["Logger","_CheckLimit","message","limit","entry","_LogLimitOutputs","current","_GenerateLimitMessage","level","MessageLimitReached","type","_Levels","name","replace","_a","_AddLogEntry","_LogCache","OnNewCacheEntry","_FormatMessage","padStr","i","date","Date","getHours","getMinutes","getSeconds","_LogDisabled","_LogEnabled","undefined","formattedMessage","logFunc","color","LogCache","ClearLogCache","errorsCount","LogLevels","Log","Warn","Error","MessageLogLevel","WarningLogLevel","ErrorLogLevel","forEach","l","bind","NoneLogLevel","AllLogLevel","console","log","warn","error"],"sources":["../../../../dev/core/src/Misc/logger.ts"],"sourcesContent":["/**\r\n * Logger used throughout the application to allow configuration of\r\n * the log level required for the messages.\r\n */\r\nexport class Logger {\r\n    /**\r\n     * No log\r\n     */\r\n    public static readonly NoneLogLevel = 0;\r\n    /**\r\n     * Only message logs\r\n     */\r\n    public static readonly MessageLogLevel = 1;\r\n    /**\r\n     * Only warning logs\r\n     */\r\n    public static readonly WarningLogLevel = 2;\r\n    /**\r\n     * Only error logs\r\n     */\r\n    public static readonly ErrorLogLevel = 4;\r\n    /**\r\n     * All logs\r\n     */\r\n    public static readonly AllLogLevel = 7;\r\n\r\n    /**\r\n     * Message to display when a message has been logged too many times\r\n     */\r\n    public static MessageLimitReached = \"Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.\";\r\n\r\n    private static _LogCache = \"\";\r\n    private static _LogLimitOutputs: { [message: string]: { limit: number; current: number } } = {};\r\n    // levels according to the (binary) numbering.\r\n    private static _Levels = [\r\n        {},\r\n        { color: \"white\", logFunc: console.log, name: \"Log\" },\r\n        { color: \"orange\", logFunc: console.warn, name: \"Warn\" },\r\n        {},\r\n        { color: \"red\", logFunc: console.error, name: \"Error\" },\r\n    ];\r\n\r\n    /**\r\n     * Gets a value indicating the number of loading errors\r\n     * @ignorenaming\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static errorsCount = 0;\r\n\r\n    /**\r\n     * Callback called when a new log is added\r\n     */\r\n    public static OnNewCacheEntry: (entry: string) => void;\r\n\r\n    private static _CheckLimit(message: string, limit: number): boolean {\r\n        let entry = Logger._LogLimitOutputs[message];\r\n        if (!entry) {\r\n            entry = { limit, current: 1 };\r\n            Logger._LogLimitOutputs[message] = entry;\r\n        } else {\r\n            entry.current++;\r\n        }\r\n        return entry.current <= entry.limit;\r\n    }\r\n\r\n    private static _GenerateLimitMessage(message: string, level: number = 1): void {\r\n        const entry = Logger._LogLimitOutputs[message];\r\n        if (!entry || !Logger.MessageLimitReached) {\r\n            return;\r\n        }\r\n        const type = this._Levels[level];\r\n        if (entry.current === entry.limit) {\r\n            Logger[type.name as \"Log\" | \"Warn\" | \"Error\"](Logger.MessageLimitReached.replace(/%LIMIT%/g, \"\" + entry.limit).replace(/%TYPE%/g, type.name ?? \"\"));\r\n        }\r\n    }\r\n\r\n    private static _AddLogEntry(entry: string) {\r\n        Logger._LogCache = entry + Logger._LogCache;\r\n\r\n        if (Logger.OnNewCacheEntry) {\r\n            Logger.OnNewCacheEntry(entry);\r\n        }\r\n    }\r\n\r\n    private static _FormatMessage(message: string): string {\r\n        const padStr = (i: number) => (i < 10 ? \"0\" + i : \"\" + i);\r\n\r\n        const date = new Date();\r\n        return \"[\" + padStr(date.getHours()) + \":\" + padStr(date.getMinutes()) + \":\" + padStr(date.getSeconds()) + \"]: \" + message;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private static _LogDisabled(message: string, limit?: number): void {\r\n        // nothing to do\r\n    }\r\n    private static _LogEnabled(level: number = 1, message: string, limit?: number): void {\r\n        if (limit !== undefined && !Logger._CheckLimit(message, limit)) {\r\n            return;\r\n        }\r\n\r\n        const formattedMessage = Logger._FormatMessage(message);\r\n        const type = this._Levels[level];\r\n        type.logFunc && type.logFunc(\"BJS - \" + formattedMessage);\r\n\r\n        const entry = `<div style='color:${type.color}'>${formattedMessage}</div><br>`;\r\n        Logger._AddLogEntry(entry);\r\n        Logger._GenerateLimitMessage(message, level);\r\n    }\r\n\r\n    /**\r\n     * Log a message to the console\r\n     */\r\n    public static Log: (message: string, limit?: number) => void = Logger._LogEnabled.bind(Logger, Logger.MessageLogLevel);\r\n\r\n    /**\r\n     * Write a warning message to the console\r\n     */\r\n    public static Warn: (message: string, limit?: number) => void = Logger._LogEnabled.bind(Logger, Logger.WarningLogLevel);\r\n\r\n    /**\r\n     * Write an error message to the console\r\n     */\r\n    public static Error: (message: string, limit?: number) => void = Logger._LogEnabled.bind(Logger, Logger.ErrorLogLevel);\r\n\r\n    /**\r\n     * Gets current log cache (list of logs)\r\n     */\r\n    public static get LogCache(): string {\r\n        return Logger._LogCache;\r\n    }\r\n\r\n    /**\r\n     * Clears the log cache\r\n     */\r\n    public static ClearLogCache(): void {\r\n        Logger._LogCache = \"\";\r\n        Logger._LogLimitOutputs = {};\r\n        Logger.errorsCount = 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the current log level (MessageLogLevel / WarningLogLevel / ErrorLogLevel)\r\n     */\r\n    public static set LogLevels(level: number) {\r\n        Logger.Log = Logger._LogDisabled;\r\n        Logger.Warn = Logger._LogDisabled;\r\n        Logger.Error = Logger._LogDisabled;\r\n        [Logger.MessageLogLevel, Logger.WarningLogLevel, Logger.ErrorLogLevel].forEach((l) => {\r\n            if ((level & l) === l) {\r\n                const type = this._Levels[l];\r\n                Logger[type.name as \"Log\" | \"Warn\" | \"Error\"] = Logger._LogEnabled.bind(Logger, l);\r\n            }\r\n        });\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}