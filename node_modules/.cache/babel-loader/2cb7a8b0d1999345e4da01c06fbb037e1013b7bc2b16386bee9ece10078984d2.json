{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { WebGLHardwareTexture } from \"../Engines/WebGL/webGLHardwareTexture.js\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { MultiviewRenderTarget } from \"../Materials/Textures/MultiviewRenderTarget.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\n/**\n * Provides render target textures and other important rendering information for a given XRLayer.\n * @internal\n */\nexport class WebXRLayerRenderTargetTextureProvider {\n  constructor(_scene, layerWrapper) {\n    this._scene = _scene;\n    this.layerWrapper = layerWrapper;\n    this._renderTargetTextures = new Array();\n    this._engine = _scene.getEngine();\n  }\n  _createInternalTexture(textureSize, texture) {\n    const internalTexture = new InternalTexture(this._engine, InternalTextureSource.Unknown, true);\n    internalTexture.width = textureSize.width;\n    internalTexture.height = textureSize.height;\n    internalTexture._hardwareTexture = new WebGLHardwareTexture(texture, this._engine._gl);\n    internalTexture.isReady = true;\n    return internalTexture;\n  }\n  _createRenderTargetTexture(width, height, framebuffer, colorTexture, depthStencilTexture, multiview) {\n    if (!this._engine) {\n      throw new Error(\"Engine is disposed\");\n    }\n    const textureSize = {\n      width,\n      height\n    };\n    // Create render target texture from the internal texture\n    const renderTargetTexture = multiview ? new MultiviewRenderTarget(this._scene, textureSize) : new RenderTargetTexture(\"XR renderTargetTexture\", textureSize, this._scene);\n    const renderTargetWrapper = renderTargetTexture.renderTarget;\n    renderTargetWrapper._samples = renderTargetTexture.samples;\n    // Set the framebuffer, make sure it works in all scenarios - emulator, no layers and layers\n    if (framebuffer || !colorTexture) {\n      renderTargetWrapper._framebuffer = framebuffer;\n    }\n    // Create internal texture\n    if (colorTexture) {\n      if (multiview) {\n        renderTargetWrapper._colorTextureArray = colorTexture;\n      } else {\n        const internalTexture = this._createInternalTexture(textureSize, colorTexture);\n        renderTargetWrapper.setTexture(internalTexture, 0);\n        renderTargetTexture._texture = internalTexture;\n      }\n    }\n    if (depthStencilTexture) {\n      if (multiview) {\n        renderTargetWrapper._depthStencilTextureArray = depthStencilTexture;\n      } else {\n        renderTargetWrapper._depthStencilTexture = this._createInternalTexture(textureSize, depthStencilTexture);\n      }\n    }\n    renderTargetTexture.disableRescaling();\n    // Firefox reality fails if skipInitialClear is set to true, so make sure only modern XR implementations set it.\n    if (typeof XRWebGLBinding !== \"undefined\") {\n      // WebXR pre-clears textures\n      renderTargetTexture.skipInitialClear = true;\n    }\n    this._renderTargetTextures.push(renderTargetTexture);\n    return renderTargetTexture;\n  }\n  _destroyRenderTargetTexture(renderTargetTexture) {\n    this._renderTargetTextures.splice(this._renderTargetTextures.indexOf(renderTargetTexture), 1);\n    renderTargetTexture.dispose();\n  }\n  getFramebufferDimensions() {\n    return this._framebufferDimensions;\n  }\n  dispose() {\n    this._renderTargetTextures.forEach(rtt => rtt.dispose());\n    this._renderTargetTextures.length = 0;\n  }\n}","map":{"version":3,"names":["WebGLHardwareTexture","InternalTexture","InternalTextureSource","MultiviewRenderTarget","RenderTargetTexture","WebXRLayerRenderTargetTextureProvider","constructor","_scene","layerWrapper","_renderTargetTextures","Array","_engine","getEngine","_createInternalTexture","textureSize","texture","internalTexture","Unknown","width","height","_hardwareTexture","_gl","isReady","_createRenderTargetTexture","framebuffer","colorTexture","depthStencilTexture","multiview","Error","renderTargetTexture","renderTargetWrapper","renderTarget","_samples","samples","_framebuffer","_colorTextureArray","setTexture","_texture","_depthStencilTextureArray","_depthStencilTexture","disableRescaling","XRWebGLBinding","skipInitialClear","push","_destroyRenderTargetTexture","splice","indexOf","dispose","getFramebufferDimensions","_framebufferDimensions","forEach","rtt","length"],"sources":["../../../../dev/core/src/XR/webXRRenderTargetTextureProvider.ts"],"sourcesContent":["import type { Engine } from \"../Engines/engine\";\r\nimport { WebGLHardwareTexture } from \"../Engines/WebGL/webGLHardwareTexture\";\r\nimport type { WebGLRenderTargetWrapper } from \"../Engines/WebGL/webGLRenderTargetWrapper\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { MultiviewRenderTarget } from \"../Materials/Textures/MultiviewRenderTarget\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Viewport } from \"../Maths/math.viewport\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { WebXRLayerWrapper } from \"./webXRLayerWrapper\";\r\n\r\n/**\r\n * An interface for objects that provide render target textures for XR rendering.\r\n */\r\nexport interface IWebXRRenderTargetTextureProvider extends IDisposable {\r\n    /**\r\n     * Attempts to set the framebuffer-size-normalized viewport to be rendered this frame for this view.\r\n     * In the event of a failure, the supplied viewport is not updated.\r\n     * @param viewport the viewport to which the view will be rendered\r\n     * @param view the view for which to set the viewport\r\n     * @returns whether the operation was successful\r\n     */\r\n    trySetViewportForView(viewport: Viewport, view: XRView): boolean;\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this eye\r\n     * @param eye the eye for which to get the render target\r\n     * @returns the render target for the specified eye or null if not available\r\n     */\r\n    getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture>;\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this view\r\n     * @param view the view for which to get the render target\r\n     * @returns the render target for the specified view or null if not available\r\n     */\r\n    getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture>;\r\n}\r\n\r\n/**\r\n * Provides render target textures and other important rendering information for a given XRLayer.\r\n * @internal\r\n */\r\nexport abstract class WebXRLayerRenderTargetTextureProvider implements IWebXRRenderTargetTextureProvider {\r\n    public abstract trySetViewportForView(viewport: Viewport, view: XRView): boolean;\r\n    public abstract getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture>;\r\n    public abstract getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture>;\r\n\r\n    protected _renderTargetTextures = new Array<RenderTargetTexture>();\r\n    protected _framebufferDimensions: Nullable<{ framebufferWidth: number; framebufferHeight: number }>;\r\n\r\n    private _engine: Engine;\r\n\r\n    constructor(private readonly _scene: Scene, public readonly layerWrapper: WebXRLayerWrapper) {\r\n        this._engine = _scene.getEngine();\r\n    }\r\n\r\n    private _createInternalTexture(textureSize: { width: number; height: number }, texture: WebGLTexture): InternalTexture {\r\n        const internalTexture = new InternalTexture(this._engine, InternalTextureSource.Unknown, true);\r\n        internalTexture.width = textureSize.width;\r\n        internalTexture.height = textureSize.height;\r\n        internalTexture._hardwareTexture = new WebGLHardwareTexture(texture, this._engine._gl);\r\n        internalTexture.isReady = true;\r\n        return internalTexture;\r\n    }\r\n\r\n    protected _createRenderTargetTexture(\r\n        width: number,\r\n        height: number,\r\n        framebuffer: Nullable<WebGLFramebuffer>,\r\n        colorTexture?: WebGLTexture,\r\n        depthStencilTexture?: WebGLTexture,\r\n        multiview?: boolean\r\n    ): RenderTargetTexture {\r\n        if (!this._engine) {\r\n            throw new Error(\"Engine is disposed\");\r\n        }\r\n\r\n        const textureSize = { width, height };\r\n\r\n        // Create render target texture from the internal texture\r\n        const renderTargetTexture = multiview ? new MultiviewRenderTarget(this._scene, textureSize) : new RenderTargetTexture(\"XR renderTargetTexture\", textureSize, this._scene);\r\n        const renderTargetWrapper = renderTargetTexture.renderTarget as WebGLRenderTargetWrapper;\r\n        renderTargetWrapper._samples = renderTargetTexture.samples;\r\n        // Set the framebuffer, make sure it works in all scenarios - emulator, no layers and layers\r\n        if (framebuffer || !colorTexture) {\r\n            renderTargetWrapper._framebuffer = framebuffer;\r\n        }\r\n\r\n        // Create internal texture\r\n        if (colorTexture) {\r\n            if (multiview) {\r\n                renderTargetWrapper._colorTextureArray = colorTexture;\r\n            } else {\r\n                const internalTexture = this._createInternalTexture(textureSize, colorTexture);\r\n                renderTargetWrapper.setTexture(internalTexture, 0);\r\n                renderTargetTexture._texture = internalTexture;\r\n            }\r\n        }\r\n\r\n        if (depthStencilTexture) {\r\n            if (multiview) {\r\n                renderTargetWrapper._depthStencilTextureArray = depthStencilTexture;\r\n            } else {\r\n                renderTargetWrapper._depthStencilTexture = this._createInternalTexture(textureSize, depthStencilTexture);\r\n            }\r\n        }\r\n\r\n        renderTargetTexture.disableRescaling();\r\n        // Firefox reality fails if skipInitialClear is set to true, so make sure only modern XR implementations set it.\r\n        if (typeof XRWebGLBinding !== \"undefined\") {\r\n            // WebXR pre-clears textures\r\n            renderTargetTexture.skipInitialClear = true;\r\n        }\r\n\r\n        this._renderTargetTextures.push(renderTargetTexture);\r\n\r\n        return renderTargetTexture;\r\n    }\r\n\r\n    protected _destroyRenderTargetTexture(renderTargetTexture: RenderTargetTexture) {\r\n        this._renderTargetTextures.splice(this._renderTargetTextures.indexOf(renderTargetTexture), 1);\r\n        renderTargetTexture.dispose();\r\n    }\r\n\r\n    public getFramebufferDimensions(): Nullable<{ framebufferWidth: number; framebufferHeight: number }> {\r\n        return this._framebufferDimensions;\r\n    }\r\n\r\n    public dispose() {\r\n        this._renderTargetTextures.forEach((rtt) => rtt.dispose());\r\n        this._renderTargetTextures.length = 0;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}