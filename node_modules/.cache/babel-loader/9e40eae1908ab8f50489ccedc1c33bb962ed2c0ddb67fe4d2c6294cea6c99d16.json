{"ast":null,"code":"import { Observable } from \"../Misc/observable.js\";\n/**\n * The current state of the timer\n */\nexport var TimerState;\n(function (TimerState) {\n  /**\n   * Timer initialized, not yet started\n   */\n  TimerState[TimerState[\"INIT\"] = 0] = \"INIT\";\n  /**\n   * Timer started and counting\n   */\n  TimerState[TimerState[\"STARTED\"] = 1] = \"STARTED\";\n  /**\n   * Timer ended (whether aborted or time reached)\n   */\n  TimerState[TimerState[\"ENDED\"] = 2] = \"ENDED\";\n})(TimerState || (TimerState = {}));\n/**\n * A simple version of the timer. Will take options and start the timer immediately after calling it\n *\n * @param options options with which to initialize this timer\n */\nexport function setAndStartTimer(options) {\n  var _a;\n  let timer = 0;\n  const startTime = Date.now();\n  options.observableParameters = (_a = options.observableParameters) !== null && _a !== void 0 ? _a : {};\n  const observer = options.contextObservable.add(payload => {\n    const now = Date.now();\n    timer = now - startTime;\n    const data = {\n      startTime,\n      currentTime: now,\n      deltaTime: timer,\n      completeRate: timer / options.timeout,\n      payload\n    };\n    options.onTick && options.onTick(data);\n    if (options.breakCondition && options.breakCondition()) {\n      options.contextObservable.remove(observer);\n      options.onAborted && options.onAborted(data);\n    }\n    if (timer >= options.timeout) {\n      options.contextObservable.remove(observer);\n      options.onEnded && options.onEnded(data);\n    }\n  }, options.observableParameters.mask, options.observableParameters.insertFirst, options.observableParameters.scope);\n  return observer;\n}\n/**\n * An advanced implementation of a timer class\n */\nexport class AdvancedTimer {\n  /**\n   * Will construct a new advanced timer based on the options provided. Timer will not start until start() is called.\n   * @param options construction options for this advanced timer\n   */\n  constructor(options) {\n    var _a, _b;\n    /**\n     * Will notify each time the timer calculates the remaining time\n     */\n    this.onEachCountObservable = new Observable();\n    /**\n     * Will trigger when the timer was aborted due to the break condition\n     */\n    this.onTimerAbortedObservable = new Observable();\n    /**\n     * Will trigger when the timer ended successfully\n     */\n    this.onTimerEndedObservable = new Observable();\n    /**\n     * Will trigger when the timer state has changed\n     */\n    this.onStateChangedObservable = new Observable();\n    this._observer = null;\n    this._breakOnNextTick = false;\n    this._tick = payload => {\n      const now = Date.now();\n      this._timer = now - this._startTime;\n      const data = {\n        startTime: this._startTime,\n        currentTime: now,\n        deltaTime: this._timer,\n        completeRate: this._timer / this._timeToEnd,\n        payload\n      };\n      const shouldBreak = this._breakOnNextTick || this._breakCondition(data);\n      if (shouldBreak || this._timer >= this._timeToEnd) {\n        this._stop(data, shouldBreak);\n      } else {\n        this.onEachCountObservable.notifyObservers(data);\n      }\n    };\n    this._setState(TimerState.INIT);\n    this._contextObservable = options.contextObservable;\n    this._observableParameters = (_a = options.observableParameters) !== null && _a !== void 0 ? _a : {};\n    this._breakCondition = (_b = options.breakCondition) !== null && _b !== void 0 ? _b : () => false;\n    this._timeToEnd = options.timeout;\n    if (options.onEnded) {\n      this.onTimerEndedObservable.add(options.onEnded);\n    }\n    if (options.onTick) {\n      this.onEachCountObservable.add(options.onTick);\n    }\n    if (options.onAborted) {\n      this.onTimerAbortedObservable.add(options.onAborted);\n    }\n  }\n  /**\n   * set a breaking condition for this timer. Default is to never break during count\n   * @param predicate the new break condition. Returns true to break, false otherwise\n   */\n  set breakCondition(predicate) {\n    this._breakCondition = predicate;\n  }\n  /**\n   * Reset ALL associated observables in this advanced timer\n   */\n  clearObservables() {\n    this.onEachCountObservable.clear();\n    this.onTimerAbortedObservable.clear();\n    this.onTimerEndedObservable.clear();\n    this.onStateChangedObservable.clear();\n  }\n  /**\n   * Will start a new iteration of this timer. Only one instance of this timer can run at a time.\n   *\n   * @param timeToEnd how much time to measure until timer ended\n   */\n  start(timeToEnd = this._timeToEnd) {\n    if (this._state === TimerState.STARTED) {\n      throw new Error(\"Timer already started. Please stop it before starting again\");\n    }\n    this._timeToEnd = timeToEnd;\n    this._startTime = Date.now();\n    this._timer = 0;\n    this._observer = this._contextObservable.add(this._tick, this._observableParameters.mask, this._observableParameters.insertFirst, this._observableParameters.scope);\n    this._setState(TimerState.STARTED);\n  }\n  /**\n   * Will force a stop on the next tick.\n   */\n  stop() {\n    if (this._state !== TimerState.STARTED) {\n      return;\n    }\n    this._breakOnNextTick = true;\n  }\n  /**\n   * Dispose this timer, clearing all resources\n   */\n  dispose() {\n    if (this._observer) {\n      this._contextObservable.remove(this._observer);\n    }\n    this.clearObservables();\n  }\n  _setState(newState) {\n    this._state = newState;\n    this.onStateChangedObservable.notifyObservers(this._state);\n  }\n  _stop(data, aborted = false) {\n    this._contextObservable.remove(this._observer);\n    this._setState(TimerState.ENDED);\n    if (aborted) {\n      this.onTimerAbortedObservable.notifyObservers(data);\n    } else {\n      this.onTimerEndedObservable.notifyObservers(data);\n    }\n  }\n}","map":{"version":3,"names":["Observable","TimerState","setAndStartTimer","options","timer","startTime","Date","now","observableParameters","_a","observer","contextObservable","add","payload","data","currentTime","deltaTime","completeRate","timeout","onTick","breakCondition","remove","onAborted","onEnded","mask","insertFirst","scope","AdvancedTimer","constructor","onEachCountObservable","onTimerAbortedObservable","onTimerEndedObservable","onStateChangedObservable","_observer","_breakOnNextTick","_tick","_timer","_startTime","_timeToEnd","shouldBreak","_breakCondition","_stop","notifyObservers","_setState","INIT","_contextObservable","_observableParameters","_b","predicate","clearObservables","clear","start","timeToEnd","_state","STARTED","Error","stop","dispose","newState","aborted","ENDED"],"sources":["../../../../dev/core/src/Misc/timer.ts"],"sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { IDisposable } from \"../scene\";\r\n\r\n/**\r\n * Construction options for a timer\r\n */\r\nexport interface ITimerOptions<T> {\r\n    /**\r\n     * Time-to-end\r\n     */\r\n    timeout: number;\r\n    /**\r\n     * The context observable is used to calculate time deltas and provides the context of the timer's callbacks. Will usually be OnBeforeRenderObservable.\r\n     * Countdown calculation is done ONLY when the observable is notifying its observers, meaning that if\r\n     * you choose an observable that doesn't trigger too often, the wait time might extend further than the requested max time\r\n     */\r\n    contextObservable: Observable<T>;\r\n    /**\r\n     * Optional parameters when adding an observer to the observable\r\n     */\r\n    observableParameters?: {\r\n        mask?: number;\r\n        insertFirst?: boolean;\r\n        scope?: any;\r\n    };\r\n    /**\r\n     * An optional break condition that will stop the times prematurely. In this case onEnded will not be triggered!\r\n     */\r\n    breakCondition?: (data?: ITimerData<T>) => boolean;\r\n    /**\r\n     * Will be triggered when the time condition has met\r\n     */\r\n    onEnded?: (data: ITimerData<any>) => void;\r\n    /**\r\n     * Will be triggered when the break condition has met (prematurely ended)\r\n     */\r\n    onAborted?: (data: ITimerData<any>) => void;\r\n    /**\r\n     * Optional function to execute on each tick (or count)\r\n     */\r\n    onTick?: (data: ITimerData<any>) => void;\r\n}\r\n\r\n/**\r\n * An interface defining the data sent by the timer\r\n */\r\nexport interface ITimerData<T> {\r\n    /**\r\n     * When did it start\r\n     */\r\n    startTime: number;\r\n    /**\r\n     * Time now\r\n     */\r\n    currentTime: number;\r\n    /**\r\n     * Time passed since started\r\n     */\r\n    deltaTime: number;\r\n    /**\r\n     * How much is completed, in [0.0...1.0].\r\n     * Note that this CAN be higher than 1 due to the fact that we don't actually measure time but delta between observable calls\r\n     */\r\n    completeRate: number;\r\n    /**\r\n     * What the registered observable sent in the last count\r\n     */\r\n    payload: T;\r\n}\r\n\r\n/**\r\n * The current state of the timer\r\n */\r\nexport enum TimerState {\r\n    /**\r\n     * Timer initialized, not yet started\r\n     */\r\n    INIT,\r\n    /**\r\n     * Timer started and counting\r\n     */\r\n    STARTED,\r\n    /**\r\n     * Timer ended (whether aborted or time reached)\r\n     */\r\n    ENDED,\r\n}\r\n\r\n/**\r\n * A simple version of the timer. Will take options and start the timer immediately after calling it\r\n *\r\n * @param options options with which to initialize this timer\r\n */\r\nexport function setAndStartTimer(options: ITimerOptions<any>): Nullable<Observer<any>> {\r\n    let timer = 0;\r\n    const startTime = Date.now();\r\n    options.observableParameters = options.observableParameters ?? {};\r\n    const observer = options.contextObservable.add(\r\n        (payload: any) => {\r\n            const now = Date.now();\r\n            timer = now - startTime;\r\n            const data: ITimerData<any> = {\r\n                startTime,\r\n                currentTime: now,\r\n                deltaTime: timer,\r\n                completeRate: timer / options.timeout,\r\n                payload,\r\n            };\r\n            options.onTick && options.onTick(data);\r\n            if (options.breakCondition && options.breakCondition()) {\r\n                options.contextObservable.remove(observer);\r\n                options.onAborted && options.onAborted(data);\r\n            }\r\n            if (timer >= options.timeout) {\r\n                options.contextObservable.remove(observer);\r\n                options.onEnded && options.onEnded(data);\r\n            }\r\n        },\r\n        options.observableParameters.mask,\r\n        options.observableParameters.insertFirst,\r\n        options.observableParameters.scope\r\n    );\r\n    return observer;\r\n}\r\n\r\n/**\r\n * An advanced implementation of a timer class\r\n */\r\nexport class AdvancedTimer<T = any> implements IDisposable {\r\n    /**\r\n     * Will notify each time the timer calculates the remaining time\r\n     */\r\n    public onEachCountObservable: Observable<ITimerData<T>> = new Observable();\r\n    /**\r\n     * Will trigger when the timer was aborted due to the break condition\r\n     */\r\n    public onTimerAbortedObservable: Observable<ITimerData<T>> = new Observable();\r\n    /**\r\n     * Will trigger when the timer ended successfully\r\n     */\r\n    public onTimerEndedObservable: Observable<ITimerData<T>> = new Observable();\r\n    /**\r\n     * Will trigger when the timer state has changed\r\n     */\r\n    public onStateChangedObservable: Observable<TimerState> = new Observable();\r\n\r\n    private _observer: Nullable<Observer<T>> = null;\r\n    private _contextObservable: Observable<T>;\r\n    private _observableParameters: {\r\n        mask?: number;\r\n        insertFirst?: boolean;\r\n        scope?: any;\r\n    };\r\n    private _startTime: number;\r\n    private _timer: number;\r\n    private _state: TimerState;\r\n    private _breakCondition: (data: ITimerData<T>) => boolean;\r\n    private _timeToEnd: number;\r\n    private _breakOnNextTick: boolean = false;\r\n\r\n    /**\r\n     * Will construct a new advanced timer based on the options provided. Timer will not start until start() is called.\r\n     * @param options construction options for this advanced timer\r\n     */\r\n    constructor(options: ITimerOptions<T>) {\r\n        this._setState(TimerState.INIT);\r\n        this._contextObservable = options.contextObservable;\r\n        this._observableParameters = options.observableParameters ?? {};\r\n        this._breakCondition = options.breakCondition ?? (() => false);\r\n        this._timeToEnd = options.timeout;\r\n        if (options.onEnded) {\r\n            this.onTimerEndedObservable.add(options.onEnded);\r\n        }\r\n        if (options.onTick) {\r\n            this.onEachCountObservable.add(options.onTick);\r\n        }\r\n        if (options.onAborted) {\r\n            this.onTimerAbortedObservable.add(options.onAborted);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * set a breaking condition for this timer. Default is to never break during count\r\n     * @param predicate the new break condition. Returns true to break, false otherwise\r\n     */\r\n    public set breakCondition(predicate: (data: ITimerData<T>) => boolean) {\r\n        this._breakCondition = predicate;\r\n    }\r\n\r\n    /**\r\n     * Reset ALL associated observables in this advanced timer\r\n     */\r\n    public clearObservables() {\r\n        this.onEachCountObservable.clear();\r\n        this.onTimerAbortedObservable.clear();\r\n        this.onTimerEndedObservable.clear();\r\n        this.onStateChangedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Will start a new iteration of this timer. Only one instance of this timer can run at a time.\r\n     *\r\n     * @param timeToEnd how much time to measure until timer ended\r\n     */\r\n    public start(timeToEnd: number = this._timeToEnd) {\r\n        if (this._state === TimerState.STARTED) {\r\n            throw new Error(\"Timer already started. Please stop it before starting again\");\r\n        }\r\n        this._timeToEnd = timeToEnd;\r\n        this._startTime = Date.now();\r\n        this._timer = 0;\r\n        this._observer = this._contextObservable.add(this._tick, this._observableParameters.mask, this._observableParameters.insertFirst, this._observableParameters.scope);\r\n        this._setState(TimerState.STARTED);\r\n    }\r\n\r\n    /**\r\n     * Will force a stop on the next tick.\r\n     */\r\n    public stop() {\r\n        if (this._state !== TimerState.STARTED) {\r\n            return;\r\n        }\r\n        this._breakOnNextTick = true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this timer, clearing all resources\r\n     */\r\n    public dispose() {\r\n        if (this._observer) {\r\n            this._contextObservable.remove(this._observer);\r\n        }\r\n        this.clearObservables();\r\n    }\r\n\r\n    private _setState(newState: TimerState) {\r\n        this._state = newState;\r\n        this.onStateChangedObservable.notifyObservers(this._state);\r\n    }\r\n\r\n    private _tick = (payload: T) => {\r\n        const now = Date.now();\r\n        this._timer = now - this._startTime;\r\n        const data: ITimerData<T> = {\r\n            startTime: this._startTime,\r\n            currentTime: now,\r\n            deltaTime: this._timer,\r\n            completeRate: this._timer / this._timeToEnd,\r\n            payload,\r\n        };\r\n        const shouldBreak = this._breakOnNextTick || this._breakCondition(data);\r\n        if (shouldBreak || this._timer >= this._timeToEnd) {\r\n            this._stop(data, shouldBreak);\r\n        } else {\r\n            this.onEachCountObservable.notifyObservers(data);\r\n        }\r\n    };\r\n\r\n    private _stop(data: ITimerData<T>, aborted: boolean = false) {\r\n        this._contextObservable.remove(this._observer);\r\n        this._setState(TimerState.ENDED);\r\n        if (aborted) {\r\n            this.onTimerAbortedObservable.notifyObservers(data);\r\n        } else {\r\n            this.onTimerEndedObservable.notifyObservers(data);\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}