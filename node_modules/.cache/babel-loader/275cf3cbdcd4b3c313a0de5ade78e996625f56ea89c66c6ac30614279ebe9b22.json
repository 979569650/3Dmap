{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\nimport \"core-js/modules/es.array.push.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { Tools } from \"../../Misc/tools.js\";\nimport { AutoReleaseWorkerPool } from \"../../Misc/workerPool.js\";\nimport { Geometry } from \"../geometry.js\";\nimport { VertexBuffer } from \"../buffer.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nfunction createDecoderAsync(wasmBinary) {\n  return new Promise(resolve => {\n    DracoDecoderModule({\n      wasmBinary: wasmBinary\n    }).then(module => {\n      resolve({\n        module: module\n      });\n    });\n  });\n}\nfunction decodeMesh(decoderModule, data, attributes, onIndicesData, onAttributeData) {\n  let decoder = null;\n  let buffer = null;\n  let geometry = null;\n  try {\n    decoder = new decoderModule.Decoder();\n    buffer = new decoderModule.DecoderBuffer();\n    buffer.Init(data, data.byteLength);\n    let status;\n    const type = decoder.GetEncodedGeometryType(buffer);\n    switch (type) {\n      case decoderModule.TRIANGULAR_MESH:\n        {\n          const mesh = new decoderModule.Mesh();\n          status = decoder.DecodeBufferToMesh(buffer, mesh);\n          if (!status.ok() || mesh.ptr === 0) {\n            throw new Error(status.error_msg());\n          }\n          const numFaces = mesh.num_faces();\n          const numIndices = numFaces * 3;\n          const byteLength = numIndices * 4;\n          const ptr = decoderModule._malloc(byteLength);\n          try {\n            decoder.GetTrianglesUInt32Array(mesh, byteLength, ptr);\n            const indices = new Uint32Array(numIndices);\n            indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));\n            onIndicesData(indices);\n          } finally {\n            decoderModule._free(ptr);\n          }\n          geometry = mesh;\n          break;\n        }\n      case decoderModule.POINT_CLOUD:\n        {\n          const pointCloud = new decoderModule.PointCloud();\n          status = decoder.DecodeBufferToPointCloud(buffer, pointCloud);\n          if (!status.ok() || !pointCloud.ptr) {\n            throw new Error(status.error_msg());\n          }\n          geometry = pointCloud;\n          break;\n        }\n      default:\n        {\n          throw new Error(`Invalid geometry type ${type}`);\n        }\n    }\n    const numPoints = geometry.num_points();\n    const processAttribute = (decoder, geometry, kind, attribute) => {\n      const dataType = attribute.data_type();\n      const numComponents = attribute.num_components();\n      const normalized = attribute.normalized();\n      const byteStride = attribute.byte_stride();\n      const byteOffset = attribute.byte_offset();\n      const dataTypeInfo = {\n        [decoderModule.DT_FLOAT32]: {\n          typedArrayConstructor: Float32Array,\n          heap: decoderModule.HEAPF32\n        },\n        [decoderModule.DT_INT8]: {\n          typedArrayConstructor: Int8Array,\n          heap: decoderModule.HEAP8\n        },\n        [decoderModule.DT_INT16]: {\n          typedArrayConstructor: Int16Array,\n          heap: decoderModule.HEAP16\n        },\n        [decoderModule.DT_INT32]: {\n          typedArrayConstructor: Int32Array,\n          heap: decoderModule.HEAP32\n        },\n        [decoderModule.DT_UINT8]: {\n          typedArrayConstructor: Uint8Array,\n          heap: decoderModule.HEAPU8\n        },\n        [decoderModule.DT_UINT16]: {\n          typedArrayConstructor: Uint16Array,\n          heap: decoderModule.HEAPU16\n        },\n        [decoderModule.DT_UINT32]: {\n          typedArrayConstructor: Uint32Array,\n          heap: decoderModule.HEAPU32\n        }\n      };\n      const info = dataTypeInfo[dataType];\n      if (!info) {\n        throw new Error(`Invalid data type ${dataType}`);\n      }\n      const numValues = numPoints * numComponents;\n      const byteLength = numValues * info.typedArrayConstructor.BYTES_PER_ELEMENT;\n      const ptr = decoderModule._malloc(byteLength);\n      try {\n        decoder.GetAttributeDataArrayForAllPoints(geometry, attribute, dataType, byteLength, ptr);\n        const data = new info.typedArrayConstructor(info.heap.buffer, ptr, numValues);\n        onAttributeData(kind, data.slice(), numComponents, byteOffset, byteStride, normalized);\n      } finally {\n        decoderModule._free(ptr);\n      }\n    };\n    if (attributes) {\n      for (const kind in attributes) {\n        const id = attributes[kind];\n        const attribute = decoder.GetAttributeByUniqueId(geometry, id);\n        processAttribute(decoder, geometry, kind, attribute);\n      }\n    } else {\n      const dracoAttributeTypes = {\n        position: decoderModule.POSITION,\n        normal: decoderModule.NORMAL,\n        color: decoderModule.COLOR,\n        uv: decoderModule.TEX_COORD\n      };\n      for (const kind in dracoAttributeTypes) {\n        const id = decoder.GetAttributeId(geometry, dracoAttributeTypes[kind]);\n        if (id !== -1) {\n          const attribute = decoder.GetAttribute(geometry, id);\n          processAttribute(decoder, geometry, kind, attribute);\n        }\n      }\n    }\n    return numPoints;\n  } finally {\n    if (geometry) {\n      decoderModule.destroy(geometry);\n    }\n    if (buffer) {\n      decoderModule.destroy(buffer);\n    }\n    if (decoder) {\n      decoderModule.destroy(decoder);\n    }\n  }\n}\n/**\n * The worker function that gets converted to a blob url to pass into a worker.\n */\nfunction worker() {\n  let decoderPromise;\n  onmessage = event => {\n    const message = event.data;\n    switch (message.id) {\n      case \"init\":\n        {\n          const decoder = message.decoder;\n          if (decoder.url) {\n            importScripts(decoder.url);\n            decoderPromise = DracoDecoderModule({\n              wasmBinary: decoder.wasmBinary\n            });\n          }\n          postMessage({\n            id: \"initDone\"\n          });\n          break;\n        }\n      case \"decodeMesh\":\n        {\n          if (!decoderPromise) {\n            throw new Error(\"Draco decoder module is not available\");\n          }\n          decoderPromise.then(decoder => {\n            const numPoints = decodeMesh(decoder, message.dataView, message.attributes, indices => {\n              postMessage({\n                id: \"indices\",\n                data: indices\n              }, [indices.buffer]);\n            }, (kind, data, size, offset, stride, normalized) => {\n              postMessage({\n                id: \"attribute\",\n                kind,\n                data,\n                size,\n                byteOffset: offset,\n                byteStride: stride,\n                normalized\n              }, [data.buffer]);\n            });\n            postMessage({\n              id: \"decodeMeshDone\",\n              totalVertices: numPoints\n            });\n          });\n          break;\n        }\n    }\n  };\n}\n/**\n * Draco compression (https://google.github.io/draco/)\n *\n * This class wraps the Draco module.\n *\n * **Encoder**\n *\n * The encoder is not currently implemented.\n *\n * **Decoder**\n *\n * By default, the configuration points to a copy of the Draco decoder files for glTF from the babylon.js preview cdn https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js.\n *\n * To update the configuration, use the following code:\n * ```javascript\n *     DracoCompression.Configuration = {\n *         decoder: {\n *             wasmUrl: \"<url to the WebAssembly library>\",\n *             wasmBinaryUrl: \"<url to the WebAssembly binary>\",\n *             fallbackUrl: \"<url to the fallback JavaScript library>\",\n *         }\n *     };\n * ```\n *\n * Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support WebAssembly or only support the JavaScript version.\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\n * Use `DracoCompression.DecoderAvailable` to determine if the decoder configuration is available for the current context.\n *\n * To decode Draco compressed data, get the default DracoCompression object and call decodeMeshToGeometryAsync:\n * ```javascript\n *     var geometry = await DracoCompression.Default.decodeMeshToGeometryAsync(data);\n * ```\n *\n * @see https://playground.babylonjs.com/#DMZIBD#0\n */\nexport class DracoCompression {\n  /**\n   * Returns true if the decoder configuration is available.\n   */\n  static get DecoderAvailable() {\n    const decoder = DracoCompression.Configuration.decoder;\n    return !!(decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\" || decoder.fallbackUrl);\n  }\n  static GetDefaultNumWorkers() {\n    if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\n      return 1;\n    }\n    // Use 50% of the available logical processors but capped at 4.\n    return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\n  }\n  /**\n   * Default instance for the draco compression object.\n   */\n  static get Default() {\n    if (!DracoCompression._Default) {\n      DracoCompression._Default = new DracoCompression();\n    }\n    return DracoCompression._Default;\n  }\n  /**\n   * Constructor\n   * @param numWorkers The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\n   */\n  constructor(numWorkers = DracoCompression.DefaultNumWorkers) {\n    const decoder = DracoCompression.Configuration.decoder;\n    const decoderInfo = decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\" ? {\n      url: Tools.GetBabylonScriptURL(decoder.wasmUrl, true),\n      wasmBinaryPromise: Tools.LoadFileAsync(Tools.GetBabylonScriptURL(decoder.wasmBinaryUrl, true))\n    } : {\n      url: Tools.GetBabylonScriptURL(decoder.fallbackUrl),\n      wasmBinaryPromise: Promise.resolve(undefined)\n    };\n    if (numWorkers && typeof Worker === \"function\" && typeof URL === \"function\") {\n      this._workerPoolPromise = decoderInfo.wasmBinaryPromise.then(decoderWasmBinary => {\n        const workerContent = `${decodeMesh}(${worker})()`;\n        const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], {\n          type: \"application/javascript\"\n        }));\n        return new AutoReleaseWorkerPool(numWorkers, () => {\n          return new Promise((resolve, reject) => {\n            const worker = new Worker(workerBlobUrl);\n            const onError = error => {\n              worker.removeEventListener(\"error\", onError);\n              worker.removeEventListener(\"message\", onMessage);\n              reject(error);\n            };\n            const onMessage = event => {\n              if (event.data.id === \"initDone\") {\n                worker.removeEventListener(\"error\", onError);\n                worker.removeEventListener(\"message\", onMessage);\n                resolve(worker);\n              }\n            };\n            worker.addEventListener(\"error\", onError);\n            worker.addEventListener(\"message\", onMessage);\n            worker.postMessage({\n              id: \"init\",\n              decoder: {\n                url: decoderInfo.url,\n                wasmBinary: decoderWasmBinary\n              }\n            });\n          });\n        });\n      });\n    } else {\n      this._decoderModulePromise = decoderInfo.wasmBinaryPromise.then(decoderWasmBinary => {\n        if (!decoderInfo.url) {\n          throw new Error(\"Draco decoder module is not available\");\n        }\n        return Tools.LoadBabylonScriptAsync(decoderInfo.url).then(() => {\n          return createDecoderAsync(decoderWasmBinary);\n        });\n      });\n    }\n  }\n  /**\n   * Stop all async operations and release resources.\n   */\n  dispose() {\n    if (this._workerPoolPromise) {\n      this._workerPoolPromise.then(workerPool => {\n        workerPool.dispose();\n      });\n    }\n    delete this._workerPoolPromise;\n    delete this._decoderModulePromise;\n  }\n  /**\n   * Returns a promise that resolves when ready. Call this manually to ensure draco compression is ready before use.\n   * @returns a promise that resolves when ready\n   */\n  whenReadyAsync() {\n    if (this._workerPoolPromise) {\n      return this._workerPoolPromise.then(() => {});\n    }\n    if (this._decoderModulePromise) {\n      return this._decoderModulePromise.then(() => {});\n    }\n    return Promise.resolve();\n  }\n  _decodeMeshAsync(data, attributes, gltfNormalizedOverride) {\n    const dataView = data instanceof ArrayBuffer ? new Int8Array(data) : new Int8Array(data.buffer, data.byteOffset, data.byteLength);\n    const applyGltfNormalizedOverride = (kind, normalized) => {\n      if (gltfNormalizedOverride && gltfNormalizedOverride[kind] !== undefined) {\n        if (normalized !== gltfNormalizedOverride[kind]) {\n          Logger.Warn(`Normalized flag from Draco data (${normalized}) does not match normalized flag from glTF accessor (${gltfNormalizedOverride[kind]}). Using flag from glTF accessor.`);\n        }\n        return gltfNormalizedOverride[kind];\n      } else {\n        return normalized;\n      }\n    };\n    if (this._workerPoolPromise) {\n      return this._workerPoolPromise.then(workerPool => {\n        return new Promise((resolve, reject) => {\n          workerPool.push((worker, onComplete) => {\n            let resultIndices = null;\n            const resultAttributes = [];\n            const onError = error => {\n              worker.removeEventListener(\"error\", onError);\n              worker.removeEventListener(\"message\", onMessage);\n              reject(error);\n              onComplete();\n            };\n            const onMessage = event => {\n              const message = event.data;\n              switch (message.id) {\n                case \"decodeMeshDone\":\n                  {\n                    worker.removeEventListener(\"error\", onError);\n                    worker.removeEventListener(\"message\", onMessage);\n                    resolve({\n                      indices: resultIndices,\n                      attributes: resultAttributes,\n                      totalVertices: message.totalVertices\n                    });\n                    onComplete();\n                    break;\n                  }\n                case \"indices\":\n                  {\n                    resultIndices = message.data;\n                    break;\n                  }\n                case \"attribute\":\n                  {\n                    resultAttributes.push({\n                      kind: message.kind,\n                      data: message.data,\n                      size: message.size,\n                      byteOffset: message.byteOffset,\n                      byteStride: message.byteStride,\n                      normalized: applyGltfNormalizedOverride(message.kind, message.normalized)\n                    });\n                    break;\n                  }\n              }\n            };\n            worker.addEventListener(\"error\", onError);\n            worker.addEventListener(\"message\", onMessage);\n            const dataViewCopy = dataView.slice();\n            worker.postMessage({\n              id: \"decodeMesh\",\n              dataView: dataViewCopy,\n              attributes: attributes\n            }, [dataViewCopy.buffer]);\n          });\n        });\n      });\n    }\n    if (this._decoderModulePromise) {\n      return this._decoderModulePromise.then(decoder => {\n        let resultIndices = null;\n        const resultAttributes = [];\n        const numPoints = decodeMesh(decoder.module, dataView, attributes, indices => {\n          resultIndices = indices;\n        }, (kind, data, size, byteOffset, byteStride, normalized) => {\n          resultAttributes.push({\n            kind,\n            data,\n            size,\n            byteOffset,\n            byteStride,\n            normalized\n          });\n        });\n        return {\n          indices: resultIndices,\n          attributes: resultAttributes,\n          totalVertices: numPoints\n        };\n      });\n    }\n    throw new Error(\"Draco decoder module is not available\");\n  }\n  /**\n   * Decode Draco compressed mesh data to Babylon geometry.\n   * @param name The name to use when creating the geometry\n   * @param scene The scene to use when creating the geometry\n   * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\n   * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\n   * @returns A promise that resolves with the decoded geometry\n   */\n  decodeMeshToGeometryAsync(name, scene, data, attributes) {\n    return this._decodeMeshAsync(data, attributes).then(meshData => {\n      const geometry = new Geometry(name, scene);\n      if (meshData.indices) {\n        geometry.setIndices(meshData.indices);\n      }\n      for (const attribute of meshData.attributes) {\n        geometry.setVerticesBuffer(new VertexBuffer(scene.getEngine(), attribute.data, attribute.kind, false, undefined, attribute.byteStride, undefined, attribute.byteOffset, attribute.size, undefined, attribute.normalized, true), meshData.totalVertices);\n      }\n      return geometry;\n    });\n  }\n  /** @internal */\n  _decodeMeshToGeometryForGltfAsync(name, scene, data, attributes, gltfNormalizedOverride) {\n    return this._decodeMeshAsync(data, attributes, gltfNormalizedOverride).then(meshData => {\n      const geometry = new Geometry(name, scene);\n      if (meshData.indices) {\n        geometry.setIndices(meshData.indices);\n      }\n      for (const attribute of meshData.attributes) {\n        geometry.setVerticesBuffer(new VertexBuffer(scene.getEngine(), attribute.data, attribute.kind, false, undefined, attribute.byteStride, undefined, attribute.byteOffset, attribute.size, undefined, attribute.normalized, true), meshData.totalVertices);\n      }\n      return geometry;\n    });\n  }\n  /**\n   * Decode Draco compressed mesh data to Babylon vertex data.\n   * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\n   * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\n   * @returns A promise that resolves with the decoded vertex data\n   * @deprecated Use {@link decodeMeshToGeometryAsync} for better performance in some cases\n   */\n  decodeMeshAsync(data, attributes) {\n    return this._decodeMeshAsync(data, attributes).then(meshData => {\n      const vertexData = new VertexData();\n      if (meshData.indices) {\n        vertexData.indices = meshData.indices;\n      }\n      for (const attribute of meshData.attributes) {\n        const floatData = VertexBuffer.GetFloatData(attribute.data, attribute.size, VertexBuffer.GetDataType(attribute.data), attribute.byteOffset, attribute.byteStride, attribute.normalized, meshData.totalVertices);\n        vertexData.set(floatData, attribute.kind);\n      }\n      return vertexData;\n    });\n  }\n}\n/**\n * The configuration. Defaults to the following urls:\n * - wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\"\n * - wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\"\n * - fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\"\n */\nDracoCompression.Configuration = {\n  decoder: {\n    wasmUrl: \"draco_wasm_wrapper_gltf.js\",\n    wasmBinaryUrl: \"draco_decoder_gltf.wasm\",\n    fallbackUrl: \"draco_decoder_gltf.js\"\n  }\n};\n/**\n * Default number of workers to create when creating the draco compression object.\n */\nDracoCompression.DefaultNumWorkers = DracoCompression.GetDefaultNumWorkers();\nDracoCompression._Default = null;","map":{"version":3,"names":["Tools","AutoReleaseWorkerPool","Geometry","VertexBuffer","VertexData","Logger","createDecoderAsync","wasmBinary","Promise","resolve","DracoDecoderModule","then","module","decodeMesh","decoderModule","data","attributes","onIndicesData","onAttributeData","decoder","buffer","geometry","Decoder","DecoderBuffer","Init","byteLength","status","type","GetEncodedGeometryType","TRIANGULAR_MESH","mesh","Mesh","DecodeBufferToMesh","ok","ptr","Error","error_msg","numFaces","num_faces","numIndices","_malloc","GetTrianglesUInt32Array","indices","Uint32Array","set","HEAPF32","_free","POINT_CLOUD","pointCloud","PointCloud","DecodeBufferToPointCloud","numPoints","num_points","processAttribute","kind","attribute","dataType","data_type","numComponents","num_components","normalized","byteStride","byte_stride","byteOffset","byte_offset","dataTypeInfo","DT_FLOAT32","typedArrayConstructor","Float32Array","heap","DT_INT8","Int8Array","HEAP8","DT_INT16","Int16Array","HEAP16","DT_INT32","Int32Array","HEAP32","DT_UINT8","Uint8Array","HEAPU8","DT_UINT16","Uint16Array","HEAPU16","DT_UINT32","HEAPU32","info","numValues","BYTES_PER_ELEMENT","GetAttributeDataArrayForAllPoints","slice","id","GetAttributeByUniqueId","dracoAttributeTypes","position","POSITION","normal","NORMAL","color","COLOR","uv","TEX_COORD","GetAttributeId","GetAttribute","destroy","worker","decoderPromise","onmessage","event","message","url","importScripts","postMessage","dataView","size","offset","stride","totalVertices","DracoCompression","DecoderAvailable","Configuration","wasmUrl","wasmBinaryUrl","WebAssembly","fallbackUrl","GetDefaultNumWorkers","navigator","hardwareConcurrency","Math","min","floor","Default","_Default","constructor","numWorkers","DefaultNumWorkers","decoderInfo","GetBabylonScriptURL","wasmBinaryPromise","LoadFileAsync","undefined","Worker","URL","_workerPoolPromise","decoderWasmBinary","workerContent","workerBlobUrl","createObjectURL","Blob","reject","onError","error","removeEventListener","onMessage","addEventListener","_decoderModulePromise","LoadBabylonScriptAsync","dispose","workerPool","whenReadyAsync","_decodeMeshAsync","gltfNormalizedOverride","ArrayBuffer","applyGltfNormalizedOverride","Warn","push","onComplete","resultIndices","resultAttributes","dataViewCopy","decodeMeshToGeometryAsync","name","scene","meshData","setIndices","setVerticesBuffer","getEngine","_decodeMeshToGeometryForGltfAsync","decodeMeshAsync","vertexData","floatData","GetFloatData","GetDataType"],"sources":["../../../../../dev/core/src/Meshes/Compression/dracoCompression.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { AutoReleaseWorkerPool } from \"../../Misc/workerPool\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IDisposable, Scene } from \"../../scene\";\r\nimport { Geometry } from \"../geometry\";\r\nimport { VertexBuffer } from \"../buffer\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { DracoDecoderModule } from \"draco3dgltf\";\r\nimport type { DecoderModule, DecoderBuffer, Decoder, Mesh, PointCloud, Status } from \"draco3dgltf\";\r\nimport { Logger } from \"../../Misc/logger\";\r\n\r\ndeclare let DracoDecoderModule: DracoDecoderModule;\r\n\r\ninterface AttributeData {\r\n    kind: string;\r\n    data: ArrayBufferView;\r\n    size: number;\r\n    byteOffset: number;\r\n    byteStride: number;\r\n    normalized: boolean;\r\n}\r\n\r\ninterface MeshData {\r\n    indices?: Uint16Array | Uint32Array;\r\n    attributes: Array<AttributeData>;\r\n    totalVertices: number;\r\n}\r\n\r\ninterface InitDoneMessage {\r\n    id: \"initDone\";\r\n}\r\n\r\ninterface DecodeMeshDoneMessage {\r\n    id: \"decodeMeshDone\";\r\n    totalVertices: number;\r\n}\r\n\r\ninterface IndicesMessage {\r\n    id: \"indices\";\r\n    data: Uint16Array | Uint32Array;\r\n}\r\n\r\ninterface AttributeMessage extends AttributeData {\r\n    id: \"attribute\";\r\n}\r\n\r\ntype Message = InitDoneMessage | DecodeMeshDoneMessage | IndicesMessage | AttributeMessage;\r\n\r\n// WorkerGlobalScope\r\ndeclare function importScripts(...urls: string[]): void;\r\ndeclare function postMessage(message: Message, transfer?: any[]): void;\r\n\r\nfunction createDecoderAsync(wasmBinary?: ArrayBuffer): Promise<{ module: DecoderModule }> {\r\n    return new Promise((resolve) => {\r\n        DracoDecoderModule({ wasmBinary: wasmBinary }).then((module) => {\r\n            resolve({ module: module });\r\n        });\r\n    });\r\n}\r\n\r\nfunction decodeMesh(\r\n    decoderModule: DecoderModule,\r\n    data: Int8Array,\r\n    attributes: { [kind: string]: number } | undefined,\r\n    onIndicesData: (indices: Uint16Array | Uint32Array) => void,\r\n    onAttributeData: (kind: string, data: ArrayBufferView, size: number, offset: number, stride: number, normalized: boolean) => void\r\n): number {\r\n    let decoder: Nullable<Decoder> = null;\r\n    let buffer: Nullable<DecoderBuffer> = null;\r\n    let geometry: Nullable<Mesh | PointCloud> = null;\r\n\r\n    try {\r\n        decoder = new decoderModule.Decoder();\r\n\r\n        buffer = new decoderModule.DecoderBuffer();\r\n        buffer.Init(data, data.byteLength);\r\n\r\n        let status: Status;\r\n        const type = decoder.GetEncodedGeometryType(buffer);\r\n        switch (type) {\r\n            case decoderModule.TRIANGULAR_MESH: {\r\n                const mesh = new decoderModule.Mesh();\r\n                status = decoder.DecodeBufferToMesh(buffer, mesh);\r\n                if (!status.ok() || mesh.ptr === 0) {\r\n                    throw new Error(status.error_msg());\r\n                }\r\n\r\n                const numFaces = mesh.num_faces();\r\n                const numIndices = numFaces * 3;\r\n                const byteLength = numIndices * 4;\r\n\r\n                const ptr = decoderModule._malloc(byteLength);\r\n                try {\r\n                    decoder.GetTrianglesUInt32Array(mesh, byteLength, ptr);\r\n                    const indices = new Uint32Array(numIndices);\r\n                    indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));\r\n                    onIndicesData(indices);\r\n                } finally {\r\n                    decoderModule._free(ptr);\r\n                }\r\n\r\n                geometry = mesh;\r\n                break;\r\n            }\r\n            case decoderModule.POINT_CLOUD: {\r\n                const pointCloud = new decoderModule.PointCloud();\r\n                status = decoder.DecodeBufferToPointCloud(buffer, pointCloud);\r\n                if (!status.ok() || !pointCloud.ptr) {\r\n                    throw new Error(status.error_msg());\r\n                }\r\n\r\n                geometry = pointCloud;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`Invalid geometry type ${type}`);\r\n            }\r\n        }\r\n\r\n        const numPoints = geometry.num_points();\r\n\r\n        const processAttribute = (decoder: Decoder, geometry: Mesh | PointCloud, kind: string, attribute: any) => {\r\n            const dataType = attribute.data_type();\r\n            const numComponents = attribute.num_components();\r\n            const normalized = attribute.normalized();\r\n            const byteStride = attribute.byte_stride();\r\n            const byteOffset = attribute.byte_offset();\r\n\r\n            const dataTypeInfo = {\r\n                [decoderModule.DT_FLOAT32]: { typedArrayConstructor: Float32Array, heap: decoderModule.HEAPF32 },\r\n                [decoderModule.DT_INT8]: { typedArrayConstructor: Int8Array, heap: decoderModule.HEAP8 },\r\n                [decoderModule.DT_INT16]: { typedArrayConstructor: Int16Array, heap: decoderModule.HEAP16 },\r\n                [decoderModule.DT_INT32]: { typedArrayConstructor: Int32Array, heap: decoderModule.HEAP32 },\r\n                [decoderModule.DT_UINT8]: { typedArrayConstructor: Uint8Array, heap: decoderModule.HEAPU8 },\r\n                [decoderModule.DT_UINT16]: { typedArrayConstructor: Uint16Array, heap: decoderModule.HEAPU16 },\r\n                [decoderModule.DT_UINT32]: { typedArrayConstructor: Uint32Array, heap: decoderModule.HEAPU32 },\r\n            };\r\n\r\n            const info = dataTypeInfo[dataType];\r\n            if (!info) {\r\n                throw new Error(`Invalid data type ${dataType}`);\r\n            }\r\n\r\n            const numValues = numPoints * numComponents;\r\n            const byteLength = numValues * info.typedArrayConstructor.BYTES_PER_ELEMENT;\r\n\r\n            const ptr = decoderModule._malloc(byteLength);\r\n            try {\r\n                decoder.GetAttributeDataArrayForAllPoints(geometry, attribute, dataType, byteLength, ptr);\r\n                const data = new info.typedArrayConstructor(info.heap.buffer, ptr, numValues);\r\n                onAttributeData(kind, data.slice(), numComponents, byteOffset, byteStride, normalized);\r\n            } finally {\r\n                decoderModule._free(ptr);\r\n            }\r\n        };\r\n\r\n        if (attributes) {\r\n            for (const kind in attributes) {\r\n                const id = attributes[kind];\r\n                const attribute = decoder.GetAttributeByUniqueId(geometry, id);\r\n                processAttribute(decoder, geometry, kind, attribute);\r\n            }\r\n        } else {\r\n            const dracoAttributeTypes: { [kind: string]: number } = {\r\n                position: decoderModule.POSITION,\r\n                normal: decoderModule.NORMAL,\r\n                color: decoderModule.COLOR,\r\n                uv: decoderModule.TEX_COORD,\r\n            };\r\n\r\n            for (const kind in dracoAttributeTypes) {\r\n                const id = decoder.GetAttributeId(geometry, dracoAttributeTypes[kind]);\r\n                if (id !== -1) {\r\n                    const attribute = decoder.GetAttribute(geometry, id);\r\n                    processAttribute(decoder, geometry, kind, attribute);\r\n                }\r\n            }\r\n        }\r\n\r\n        return numPoints;\r\n    } finally {\r\n        if (geometry) {\r\n            decoderModule.destroy(geometry);\r\n        }\r\n\r\n        if (buffer) {\r\n            decoderModule.destroy(buffer);\r\n        }\r\n\r\n        if (decoder) {\r\n            decoderModule.destroy(decoder);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n */\r\nfunction worker(): void {\r\n    let decoderPromise: PromiseLike<any> | undefined;\r\n\r\n    onmessage = (event) => {\r\n        const message = event.data;\r\n        switch (message.id) {\r\n            case \"init\": {\r\n                const decoder = message.decoder;\r\n                if (decoder.url) {\r\n                    importScripts(decoder.url);\r\n                    decoderPromise = DracoDecoderModule({ wasmBinary: decoder.wasmBinary });\r\n                }\r\n                postMessage({ id: \"initDone\" });\r\n                break;\r\n            }\r\n            case \"decodeMesh\": {\r\n                if (!decoderPromise) {\r\n                    throw new Error(\"Draco decoder module is not available\");\r\n                }\r\n                decoderPromise.then((decoder) => {\r\n                    const numPoints = decodeMesh(\r\n                        decoder,\r\n                        message.dataView,\r\n                        message.attributes,\r\n                        (indices) => {\r\n                            postMessage({ id: \"indices\", data: indices }, [indices.buffer]);\r\n                        },\r\n                        (kind, data, size, offset, stride, normalized) => {\r\n                            postMessage({ id: \"attribute\", kind, data, size, byteOffset: offset, byteStride: stride, normalized }, [data.buffer]);\r\n                        }\r\n                    );\r\n                    postMessage({ id: \"decodeMeshDone\", totalVertices: numPoints });\r\n                });\r\n                break;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Configuration for Draco compression\r\n */\r\nexport interface IDracoCompressionConfiguration {\r\n    /**\r\n     * Configuration for the decoder.\r\n     */\r\n    decoder: {\r\n        /**\r\n         * The url to the WebAssembly module.\r\n         */\r\n        wasmUrl?: string;\r\n\r\n        /**\r\n         * The url to the WebAssembly binary.\r\n         */\r\n        wasmBinaryUrl?: string;\r\n\r\n        /**\r\n         * The url to the fallback JavaScript module.\r\n         */\r\n        fallbackUrl?: string;\r\n    };\r\n}\r\n\r\n/**\r\n * Draco compression (https://google.github.io/draco/)\r\n *\r\n * This class wraps the Draco module.\r\n *\r\n * **Encoder**\r\n *\r\n * The encoder is not currently implemented.\r\n *\r\n * **Decoder**\r\n *\r\n * By default, the configuration points to a copy of the Draco decoder files for glTF from the babylon.js preview cdn https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js.\r\n *\r\n * To update the configuration, use the following code:\r\n * ```javascript\r\n *     DracoCompression.Configuration = {\r\n *         decoder: {\r\n *             wasmUrl: \"<url to the WebAssembly library>\",\r\n *             wasmBinaryUrl: \"<url to the WebAssembly binary>\",\r\n *             fallbackUrl: \"<url to the fallback JavaScript library>\",\r\n *         }\r\n *     };\r\n * ```\r\n *\r\n * Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support WebAssembly or only support the JavaScript version.\r\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\r\n * Use `DracoCompression.DecoderAvailable` to determine if the decoder configuration is available for the current context.\r\n *\r\n * To decode Draco compressed data, get the default DracoCompression object and call decodeMeshToGeometryAsync:\r\n * ```javascript\r\n *     var geometry = await DracoCompression.Default.decodeMeshToGeometryAsync(data);\r\n * ```\r\n *\r\n * @see https://playground.babylonjs.com/#DMZIBD#0\r\n */\r\nexport class DracoCompression implements IDisposable {\r\n    private _workerPoolPromise?: Promise<AutoReleaseWorkerPool>;\r\n    private _decoderModulePromise?: Promise<{ module: DecoderModule }>;\r\n\r\n    /**\r\n     * The configuration. Defaults to the following urls:\r\n     * - wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\"\r\n     * - wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\"\r\n     * - fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\"\r\n     */\r\n    public static Configuration: IDracoCompressionConfiguration = {\r\n        decoder: {\r\n            wasmUrl: \"draco_wasm_wrapper_gltf.js\",\r\n            wasmBinaryUrl: \"draco_decoder_gltf.wasm\",\r\n            fallbackUrl: \"draco_decoder_gltf.js\",\r\n        },\r\n    };\r\n\r\n    /**\r\n     * Returns true if the decoder configuration is available.\r\n     */\r\n    public static get DecoderAvailable(): boolean {\r\n        const decoder = DracoCompression.Configuration.decoder;\r\n        return !!((decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\") || decoder.fallbackUrl);\r\n    }\r\n\r\n    /**\r\n     * Default number of workers to create when creating the draco compression object.\r\n     */\r\n    public static DefaultNumWorkers = DracoCompression.GetDefaultNumWorkers();\r\n\r\n    private static GetDefaultNumWorkers(): number {\r\n        if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\r\n            return 1;\r\n        }\r\n\r\n        // Use 50% of the available logical processors but capped at 4.\r\n        return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\r\n    }\r\n\r\n    private static _Default: Nullable<DracoCompression> = null;\r\n\r\n    /**\r\n     * Default instance for the draco compression object.\r\n     */\r\n    public static get Default(): DracoCompression {\r\n        if (!DracoCompression._Default) {\r\n            DracoCompression._Default = new DracoCompression();\r\n        }\r\n\r\n        return DracoCompression._Default;\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     * @param numWorkers The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\r\n     */\r\n    constructor(numWorkers = DracoCompression.DefaultNumWorkers) {\r\n        const decoder = DracoCompression.Configuration.decoder;\r\n\r\n        const decoderInfo: { url: string | undefined; wasmBinaryPromise: Promise<ArrayBuffer | string | undefined> } =\r\n            decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\"\r\n                ? {\r\n                      url: Tools.GetBabylonScriptURL(decoder.wasmUrl, true),\r\n                      wasmBinaryPromise: Tools.LoadFileAsync(Tools.GetBabylonScriptURL(decoder.wasmBinaryUrl, true)),\r\n                  }\r\n                : {\r\n                      url: Tools.GetBabylonScriptURL(decoder.fallbackUrl!),\r\n                      wasmBinaryPromise: Promise.resolve(undefined),\r\n                  };\r\n\r\n        if (numWorkers && typeof Worker === \"function\" && typeof URL === \"function\") {\r\n            this._workerPoolPromise = decoderInfo.wasmBinaryPromise.then((decoderWasmBinary) => {\r\n                const workerContent = `${decodeMesh}(${worker})()`;\r\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\r\n\r\n                return new AutoReleaseWorkerPool(numWorkers, () => {\r\n                    return new Promise((resolve, reject) => {\r\n                        const worker = new Worker(workerBlobUrl);\r\n                        const onError = (error: ErrorEvent) => {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            reject(error);\r\n                        };\r\n\r\n                        const onMessage = (event: MessageEvent<Message>) => {\r\n                            if (event.data.id === \"initDone\") {\r\n                                worker.removeEventListener(\"error\", onError);\r\n                                worker.removeEventListener(\"message\", onMessage);\r\n                                resolve(worker);\r\n                            }\r\n                        };\r\n\r\n                        worker.addEventListener(\"error\", onError);\r\n                        worker.addEventListener(\"message\", onMessage);\r\n\r\n                        worker.postMessage({\r\n                            id: \"init\",\r\n                            decoder: {\r\n                                url: decoderInfo.url,\r\n                                wasmBinary: decoderWasmBinary,\r\n                            },\r\n                        });\r\n                    });\r\n                });\r\n            });\r\n        } else {\r\n            this._decoderModulePromise = decoderInfo.wasmBinaryPromise.then((decoderWasmBinary) => {\r\n                if (!decoderInfo.url) {\r\n                    throw new Error(\"Draco decoder module is not available\");\r\n                }\r\n\r\n                return Tools.LoadBabylonScriptAsync(decoderInfo.url).then(() => {\r\n                    return createDecoderAsync(decoderWasmBinary as ArrayBuffer);\r\n                });\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stop all async operations and release resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._workerPoolPromise) {\r\n            this._workerPoolPromise.then((workerPool) => {\r\n                workerPool.dispose();\r\n            });\r\n        }\r\n\r\n        delete this._workerPoolPromise;\r\n        delete this._decoderModulePromise;\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves when ready. Call this manually to ensure draco compression is ready before use.\r\n     * @returns a promise that resolves when ready\r\n     */\r\n    public whenReadyAsync(): Promise<void> {\r\n        if (this._workerPoolPromise) {\r\n            return this._workerPoolPromise.then(() => {});\r\n        }\r\n\r\n        if (this._decoderModulePromise) {\r\n            return this._decoderModulePromise.then(() => {});\r\n        }\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private _decodeMeshAsync(\r\n        data: ArrayBuffer | ArrayBufferView,\r\n        attributes?: { [kind: string]: number },\r\n        gltfNormalizedOverride?: { [kind: string]: boolean }\r\n    ): Promise<MeshData> {\r\n        const dataView = data instanceof ArrayBuffer ? new Int8Array(data) : new Int8Array(data.buffer, data.byteOffset, data.byteLength);\r\n\r\n        const applyGltfNormalizedOverride = (kind: string, normalized: boolean): boolean => {\r\n            if (gltfNormalizedOverride && gltfNormalizedOverride[kind] !== undefined) {\r\n                if (normalized !== gltfNormalizedOverride[kind]) {\r\n                    Logger.Warn(\r\n                        `Normalized flag from Draco data (${normalized}) does not match normalized flag from glTF accessor (${gltfNormalizedOverride[kind]}). Using flag from glTF accessor.`\r\n                    );\r\n                }\r\n\r\n                return gltfNormalizedOverride[kind];\r\n            } else {\r\n                return normalized;\r\n            }\r\n        };\r\n\r\n        if (this._workerPoolPromise) {\r\n            return this._workerPoolPromise.then((workerPool) => {\r\n                return new Promise<MeshData>((resolve, reject) => {\r\n                    workerPool.push((worker, onComplete) => {\r\n                        let resultIndices: Nullable<Uint16Array | Uint32Array> = null;\r\n                        const resultAttributes: Array<AttributeData> = [];\r\n\r\n                        const onError = (error: ErrorEvent) => {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            reject(error);\r\n                            onComplete();\r\n                        };\r\n\r\n                        const onMessage = (event: MessageEvent<Message>) => {\r\n                            const message = event.data;\r\n                            switch (message.id) {\r\n                                case \"decodeMeshDone\": {\r\n                                    worker.removeEventListener(\"error\", onError);\r\n                                    worker.removeEventListener(\"message\", onMessage);\r\n                                    resolve({ indices: resultIndices!, attributes: resultAttributes, totalVertices: message.totalVertices });\r\n                                    onComplete();\r\n                                    break;\r\n                                }\r\n                                case \"indices\": {\r\n                                    resultIndices = message.data;\r\n                                    break;\r\n                                }\r\n                                case \"attribute\": {\r\n                                    resultAttributes.push({\r\n                                        kind: message.kind,\r\n                                        data: message.data,\r\n                                        size: message.size,\r\n                                        byteOffset: message.byteOffset,\r\n                                        byteStride: message.byteStride,\r\n                                        normalized: applyGltfNormalizedOverride(message.kind, message.normalized),\r\n                                    });\r\n                                    break;\r\n                                }\r\n                            }\r\n                        };\r\n\r\n                        worker.addEventListener(\"error\", onError);\r\n                        worker.addEventListener(\"message\", onMessage);\r\n\r\n                        const dataViewCopy = dataView.slice();\r\n                        worker.postMessage({ id: \"decodeMesh\", dataView: dataViewCopy, attributes: attributes }, [dataViewCopy.buffer]);\r\n                    });\r\n                });\r\n            });\r\n        }\r\n\r\n        if (this._decoderModulePromise) {\r\n            return this._decoderModulePromise.then((decoder) => {\r\n                let resultIndices: Nullable<Uint16Array | Uint32Array> = null;\r\n                const resultAttributes: Array<AttributeData> = [];\r\n\r\n                const numPoints = decodeMesh(\r\n                    decoder.module,\r\n                    dataView,\r\n                    attributes,\r\n                    (indices) => {\r\n                        resultIndices = indices;\r\n                    },\r\n                    (kind, data, size, byteOffset, byteStride, normalized) => {\r\n                        resultAttributes.push({\r\n                            kind,\r\n                            data,\r\n                            size,\r\n                            byteOffset,\r\n                            byteStride,\r\n                            normalized,\r\n                        });\r\n                    }\r\n                );\r\n\r\n                return { indices: resultIndices!, attributes: resultAttributes, totalVertices: numPoints };\r\n            });\r\n        }\r\n\r\n        throw new Error(\"Draco decoder module is not available\");\r\n    }\r\n\r\n    /**\r\n     * Decode Draco compressed mesh data to Babylon geometry.\r\n     * @param name The name to use when creating the geometry\r\n     * @param scene The scene to use when creating the geometry\r\n     * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\r\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n     * @returns A promise that resolves with the decoded geometry\r\n     */\r\n    public decodeMeshToGeometryAsync(name: string, scene: Scene, data: ArrayBuffer | ArrayBufferView, attributes?: { [kind: string]: number }): Promise<Geometry> {\r\n        return this._decodeMeshAsync(data, attributes).then((meshData) => {\r\n            const geometry = new Geometry(name, scene);\r\n\r\n            if (meshData.indices) {\r\n                geometry.setIndices(meshData.indices);\r\n            }\r\n\r\n            for (const attribute of meshData.attributes) {\r\n                geometry.setVerticesBuffer(\r\n                    new VertexBuffer(\r\n                        scene.getEngine(),\r\n                        attribute.data,\r\n                        attribute.kind,\r\n                        false,\r\n                        undefined,\r\n                        attribute.byteStride,\r\n                        undefined,\r\n                        attribute.byteOffset,\r\n                        attribute.size,\r\n                        undefined,\r\n                        attribute.normalized,\r\n                        true\r\n                    ),\r\n                    meshData.totalVertices\r\n                );\r\n            }\r\n\r\n            return geometry;\r\n        });\r\n    }\r\n\r\n    /** @internal */\r\n    public _decodeMeshToGeometryForGltfAsync(\r\n        name: string,\r\n        scene: Scene,\r\n        data: ArrayBuffer | ArrayBufferView,\r\n        attributes: { [kind: string]: number },\r\n        gltfNormalizedOverride: { [kind: string]: boolean }\r\n    ): Promise<Geometry> {\r\n        return this._decodeMeshAsync(data, attributes, gltfNormalizedOverride).then((meshData) => {\r\n            const geometry = new Geometry(name, scene);\r\n\r\n            if (meshData.indices) {\r\n                geometry.setIndices(meshData.indices);\r\n            }\r\n\r\n            for (const attribute of meshData.attributes) {\r\n                geometry.setVerticesBuffer(\r\n                    new VertexBuffer(\r\n                        scene.getEngine(),\r\n                        attribute.data,\r\n                        attribute.kind,\r\n                        false,\r\n                        undefined,\r\n                        attribute.byteStride,\r\n                        undefined,\r\n                        attribute.byteOffset,\r\n                        attribute.size,\r\n                        undefined,\r\n                        attribute.normalized,\r\n                        true\r\n                    ),\r\n                    meshData.totalVertices\r\n                );\r\n            }\r\n\r\n            return geometry;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Decode Draco compressed mesh data to Babylon vertex data.\r\n     * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\r\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n     * @returns A promise that resolves with the decoded vertex data\r\n     * @deprecated Use {@link decodeMeshToGeometryAsync} for better performance in some cases\r\n     */\r\n    public decodeMeshAsync(data: ArrayBuffer | ArrayBufferView, attributes?: { [kind: string]: number }): Promise<VertexData> {\r\n        return this._decodeMeshAsync(data, attributes).then((meshData) => {\r\n            const vertexData = new VertexData();\r\n\r\n            if (meshData.indices) {\r\n                vertexData.indices = meshData.indices;\r\n            }\r\n\r\n            for (const attribute of meshData.attributes) {\r\n                const floatData = VertexBuffer.GetFloatData(\r\n                    attribute.data,\r\n                    attribute.size,\r\n                    VertexBuffer.GetDataType(attribute.data),\r\n                    attribute.byteOffset,\r\n                    attribute.byteStride,\r\n                    attribute.normalized,\r\n                    meshData.totalVertices\r\n                );\r\n\r\n                vertexData.set(floatData, attribute.kind);\r\n            }\r\n\r\n            return vertexData;\r\n        });\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}