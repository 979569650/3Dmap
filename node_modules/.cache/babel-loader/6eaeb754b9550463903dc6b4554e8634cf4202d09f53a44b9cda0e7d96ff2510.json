{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Quaternion, Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { CreateBox } from \"../Meshes/Builders/boxBuilder.js\";\nimport { CreateLines } from \"../Meshes/Builders/linesBuilder.js\";\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { PivotTools } from \"../Misc/pivotTools.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\n/**\n * Bounding box gizmo\n */\nexport class BoundingBoxGizmo extends Gizmo {\n  /**\n   * Sets the axis factor\n   * @param factor the Vector3 value\n   */\n  set axisFactor(factor) {\n    this._axisFactor = factor;\n    // update scale cube visibility\n    const scaleBoxes = this._scaleBoxesParent.getChildMeshes();\n    let index = 0;\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        for (let k = 0; k < 3; k++) {\n          const zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);\n          if (zeroAxisCount === 1 || zeroAxisCount === 3) {\n            continue;\n          }\n          if (scaleBoxes[index]) {\n            const dragAxis = new Vector3(i - 1, j - 1, k - 1);\n            dragAxis.multiplyInPlace(this._axisFactor);\n            scaleBoxes[index].setEnabled(dragAxis.lengthSquared() > Epsilon);\n          }\n          index++;\n        }\n      }\n    }\n  }\n  /**\n   * Gets the axis factor\n   * @returns the Vector3 factor value\n   */\n  get axisFactor() {\n    return this._axisFactor;\n  }\n  /**\n   * Sets scale drag speed value\n   * @param value the new speed value\n   */\n  set scaleDragSpeed(value) {\n    this._scaleDragSpeed = value;\n  }\n  /**\n   * Gets scale drag speed\n   * @returns the scale speed number\n   */\n  get scaleDragSpeed() {\n    return this._scaleDragSpeed;\n  }\n  /** Default material used to render when gizmo is not disabled or hovered */\n  get coloredMaterial() {\n    return this._coloredMaterial;\n  }\n  /** Material used to render when gizmo is hovered with mouse*/\n  get hoverMaterial() {\n    return this._hoverColoredMaterial;\n  }\n  /**\n   * Get the pointerDragBehavior\n   */\n  get pointerDragBehavior() {\n    return this._pointerDragBehavior;\n  }\n  /**\n   * Sets the color of the bounding box gizmo\n   * @param color the color to set\n   */\n  setColor(color) {\n    this._coloredMaterial.emissiveColor = color;\n    this._hoverColoredMaterial.emissiveColor = color.clone().add(new Color3(0.3, 0.3, 0.3));\n    this._lineBoundingBox.getChildren().forEach(l => {\n      if (l.color) {\n        l.color = color;\n      }\n    });\n  }\n  /**\n   * Creates an BoundingBoxGizmo\n   * @param color The color of the gizmo\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   */\n  constructor(color = Color3.Gray(), gizmoLayer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer) {\n    super(gizmoLayer);\n    this._boundingDimensions = new Vector3(1, 1, 1);\n    this._renderObserver = null;\n    this._pointerObserver = null;\n    this._scaleDragSpeed = 0.2;\n    this._tmpQuaternion = new Quaternion();\n    this._tmpVector = new Vector3(0, 0, 0);\n    this._tmpRotationMatrix = new Matrix();\n    /**\n     * If child meshes should be ignored when calculating the bounding box. This should be set to true to avoid perf hits with heavily nested meshes (Default: false)\n     */\n    this.ignoreChildren = false;\n    /**\n     * Returns true if a descendant should be included when computing the bounding box. When null, all descendants are included. If ignoreChildren is set this will be ignored. (Default: null)\n     */\n    this.includeChildPredicate = null;\n    /**\n     * The size of the rotation spheres attached to the bounding box (Default: 0.1)\n     */\n    this.rotationSphereSize = 0.1;\n    /**\n     * The size of the scale boxes attached to the bounding box (Default: 0.1)\n     */\n    this.scaleBoxSize = 0.1;\n    /**\n     * If set, the rotation spheres and scale boxes will increase in size based on the distance away from the camera to have a consistent screen size (Default: false)\n     * Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true\n     */\n    this.fixedDragMeshScreenSize = false;\n    /**\n     * If set, the rotation spheres and scale boxes will increase in size based on the size of the bounding box\n     * Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true\n     */\n    this.fixedDragMeshBoundsSize = false;\n    /**\n     * The distance away from the object which the draggable meshes should appear world sized when fixedDragMeshScreenSize is set to true (default: 10)\n     */\n    this.fixedDragMeshScreenSizeDistanceFactor = 10;\n    /**\n     * Drag distance in babylon units that the gizmo will snap scaling to when dragged\n     */\n    this.scalingSnapDistance = 0;\n    /**\n     * Drag distance in babylon units that the gizmo will snap rotation to when dragged\n     */\n    this.rotationSnapDistance = 0;\n    /**\n     * Fired when a rotation sphere or scale box is dragged\n     */\n    this.onDragStartObservable = new Observable();\n    /**\n     * Fired when a scale box is dragged\n     */\n    this.onScaleBoxDragObservable = new Observable();\n    /**\n     * Fired when a scale box drag is ended\n     */\n    this.onScaleBoxDragEndObservable = new Observable();\n    /**\n     * Fired when a rotation sphere is dragged\n     */\n    this.onRotationSphereDragObservable = new Observable();\n    /**\n     * Fired when a rotation sphere drag is ended\n     */\n    this.onRotationSphereDragEndObservable = new Observable();\n    /**\n     * Relative bounding box pivot used when scaling the attached node. When null object with scale from the opposite corner. 0.5,0.5,0.5 for center and 0.5,0,0.5 for bottom (Default: null)\n     */\n    this.scalePivot = null;\n    /**\n     * Scale factor used for masking some axis\n     */\n    this._axisFactor = new Vector3(1, 1, 1);\n    this._existingMeshScale = new Vector3();\n    // Dragging\n    this._dragMesh = null;\n    this._pointerDragBehavior = new PointerDragBehavior();\n    // Do not update the gizmo's scale so it has a fixed size to the object its attached to\n    this.updateScale = false;\n    this._anchorMesh = new AbstractMesh(\"anchor\", gizmoLayer.utilityLayerScene);\n    // Create Materials\n    this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    this._coloredMaterial.disableLighting = true;\n    this._hoverColoredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    this._hoverColoredMaterial.disableLighting = true;\n    // Build bounding box out of lines\n    this._lineBoundingBox = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\n    this._lineBoundingBox.rotationQuaternion = new Quaternion();\n    const lines = [];\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, 0), new Vector3(this._boundingDimensions.x, 0, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, 0), new Vector3(0, this._boundingDimensions.y, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, 0), new Vector3(0, 0, this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(this._boundingDimensions.x, 0, 0), new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(this._boundingDimensions.x, 0, 0), new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, this._boundingDimensions.y, 0), new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, this._boundingDimensions.y, 0), new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, this._boundingDimensions.z), new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, this._boundingDimensions.z), new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z), new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z), new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z), new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.forEach(l => {\n      l.color = color;\n      l.position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n      l.isPickable = false;\n      this._lineBoundingBox.addChild(l);\n    });\n    this._rootMesh.addChild(this._lineBoundingBox);\n    this.setColor(color);\n    // Create rotation spheres\n    this._rotateSpheresParent = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\n    this._rotateSpheresParent.rotationQuaternion = new Quaternion();\n    for (let i = 0; i < 12; i++) {\n      const sphere = CreateSphere(\"\", {\n        diameter: 1\n      }, gizmoLayer.utilityLayerScene);\n      sphere.rotationQuaternion = new Quaternion();\n      sphere.material = this._coloredMaterial;\n      sphere.isNearGrabbable = true;\n      // Drag behavior\n      const _dragBehavior = new PointerDragBehavior({});\n      _dragBehavior.moveAttached = false;\n      _dragBehavior.updateDragPlane = false;\n      sphere.addBehavior(_dragBehavior);\n      const startingTurnDirection = new Vector3(1, 0, 0);\n      let totalTurnAmountOfDrag = 0;\n      let previousProjectDist = 0;\n      _dragBehavior.onDragStartObservable.add(() => {\n        startingTurnDirection.copyFrom(sphere.forward);\n        totalTurnAmountOfDrag = 0;\n        previousProjectDist = 0;\n      });\n      _dragBehavior.onDragObservable.add(event => {\n        this.onRotationSphereDragObservable.notifyObservers({});\n        if (this.attachedMesh) {\n          const originalParent = this.attachedMesh.parent;\n          if (originalParent && originalParent.scaling && originalParent.scaling.isNonUniformWithinEpsilon(0.001)) {\n            Logger.Warn(\"BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling\");\n            return;\n          }\n          PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);\n          const worldDragDirection = startingTurnDirection;\n          // Project the world right on to the drag plane\n          const toSub = event.dragPlaneNormal.scale(Vector3.Dot(event.dragPlaneNormal, worldDragDirection));\n          const dragAxis = worldDragDirection.subtract(toSub).normalizeToNew();\n          // project drag delta on to the resulting drag axis and rotate based on that\n          let projectDist = Vector3.Dot(dragAxis, event.delta) < 0 ? Math.abs(event.delta.length()) : -Math.abs(event.delta.length());\n          // Make rotation relative to size of mesh.\n          projectDist = projectDist / this._boundingDimensions.length() * this._anchorMesh.scaling.length();\n          // Rotate based on axis\n          if (!this.attachedMesh.rotationQuaternion) {\n            this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);\n          }\n          if (!this._anchorMesh.rotationQuaternion) {\n            this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._anchorMesh.rotation.y, this._anchorMesh.rotation.x, this._anchorMesh.rotation.z);\n          }\n          // Do not allow the object to turn more than a full circle\n          totalTurnAmountOfDrag += projectDist;\n          if (Math.abs(totalTurnAmountOfDrag) <= 2 * Math.PI) {\n            if (this.rotationSnapDistance > 0) {\n              const dragSteps = Math.floor(Math.abs(totalTurnAmountOfDrag) / this.rotationSnapDistance) * (totalTurnAmountOfDrag < 0 ? -1 : 1);\n              const angle = this.rotationSnapDistance * dragSteps;\n              projectDist = angle - previousProjectDist;\n              previousProjectDist = angle;\n            }\n            if (i >= 8) {\n              Quaternion.RotationYawPitchRollToRef(0, 0, projectDist, this._tmpQuaternion);\n            } else if (i >= 4) {\n              Quaternion.RotationYawPitchRollToRef(projectDist, 0, 0, this._tmpQuaternion);\n            } else {\n              Quaternion.RotationYawPitchRollToRef(0, projectDist, 0, this._tmpQuaternion);\n            }\n            // if using pivot, move anchor so mesh will be at relative (0,0,0) when parented\n            if (this.attachedMesh.isUsingPivotMatrix()) {\n              this._anchorMesh.position.copyFrom(this.attachedMesh.position);\n            }\n            // Rotate around center of bounding box\n            this._anchorMesh.addChild(this.attachedMesh);\n            if (this._anchorMesh.getScene().useRightHandedSystem) {\n              this._tmpQuaternion.conjugateInPlace();\n            }\n            this._tmpQuaternion.normalize();\n            this._anchorMesh.rotationQuaternion.multiplyToRef(this._tmpQuaternion, this._anchorMesh.rotationQuaternion);\n            this._anchorMesh.rotationQuaternion.normalize();\n            this._anchorMesh.removeChild(this.attachedMesh);\n            this.attachedMesh.setParent(originalParent);\n          }\n          this.updateBoundingBox();\n          PivotTools._RestorePivotPoint(this.attachedMesh);\n        }\n        this._updateDummy();\n      });\n      // Selection/deselection\n      _dragBehavior.onDragStartObservable.add(() => {\n        this.onDragStartObservable.notifyObservers({});\n        this._selectNode(sphere);\n      });\n      _dragBehavior.onDragEndObservable.add(event => {\n        this.onRotationSphereDragEndObservable.notifyObservers({});\n        this._selectNode(null);\n        this._updateDummy();\n        this._unhoverMeshOnTouchUp(event.pointerInfo, sphere);\n      });\n      this._rotateSpheresParent.addChild(sphere);\n    }\n    this._rootMesh.addChild(this._rotateSpheresParent);\n    // Create scale cubes\n    this._scaleBoxesParent = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\n    this._scaleBoxesParent.rotationQuaternion = new Quaternion();\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        for (let k = 0; k < 3; k++) {\n          // create box for relevant axis\n          const zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);\n          if (zeroAxisCount === 1 || zeroAxisCount === 3) {\n            continue;\n          }\n          const box = CreateBox(\"\", {\n            size: 1\n          }, gizmoLayer.utilityLayerScene);\n          box.material = this._coloredMaterial;\n          box._internalMetadata = zeroAxisCount === 2; // None homogenous scale handle\n          box.isNearGrabbable = true;\n          // Dragging logic\n          const dragAxis = new Vector3(i - 1, j - 1, k - 1).normalize();\n          const _dragBehavior = new PointerDragBehavior({\n            dragAxis: dragAxis\n          });\n          _dragBehavior.updateDragPlane = false;\n          _dragBehavior.moveAttached = false;\n          let totalRelativeDragDistance = 0;\n          let previousScale = 0;\n          box.addBehavior(_dragBehavior);\n          _dragBehavior.onDragObservable.add(event => {\n            this.onScaleBoxDragObservable.notifyObservers({});\n            if (this.attachedMesh) {\n              const originalParent = this.attachedMesh.parent;\n              if (originalParent && originalParent.scaling && originalParent.scaling.isNonUniformWithinEpsilon(0.001)) {\n                Logger.Warn(\"BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling\");\n                return;\n              }\n              PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);\n              let relativeDragDistance = event.dragDistance / this._boundingDimensions.length() * this._anchorMesh.scaling.length();\n              totalRelativeDragDistance += relativeDragDistance;\n              if (this.scalingSnapDistance > 0) {\n                const dragSteps = Math.floor(Math.abs(totalRelativeDragDistance) / this.scalingSnapDistance) * (totalRelativeDragDistance < 0 ? -1 : 1);\n                const scale = this.scalingSnapDistance * dragSteps;\n                relativeDragDistance = scale - previousScale;\n                previousScale = scale;\n              }\n              const deltaScale = new Vector3(relativeDragDistance, relativeDragDistance, relativeDragDistance);\n              if (zeroAxisCount === 2) {\n                // scale on 1 axis when using the anchor box in the face middle\n                deltaScale.x *= Math.abs(dragAxis.x);\n                deltaScale.y *= Math.abs(dragAxis.y);\n                deltaScale.z *= Math.abs(dragAxis.z);\n              }\n              deltaScale.scaleInPlace(this._scaleDragSpeed);\n              deltaScale.multiplyInPlace(this._axisFactor);\n              this.updateBoundingBox();\n              if (this.scalePivot) {\n                this.attachedMesh.getWorldMatrix().getRotationMatrixToRef(this._tmpRotationMatrix);\n                // Move anchor to desired pivot point (Bottom left corner + dimension/2)\n                this._boundingDimensions.scaleToRef(0.5, this._tmpVector);\n                Vector3.TransformCoordinatesToRef(this._tmpVector, this._tmpRotationMatrix, this._tmpVector);\n                this._anchorMesh.position.subtractInPlace(this._tmpVector);\n                this._boundingDimensions.multiplyToRef(this.scalePivot, this._tmpVector);\n                Vector3.TransformCoordinatesToRef(this._tmpVector, this._tmpRotationMatrix, this._tmpVector);\n                this._anchorMesh.position.addInPlace(this._tmpVector);\n              } else {\n                // Scale from the position of the opposite corner\n                box.absolutePosition.subtractToRef(this._anchorMesh.position, this._tmpVector);\n                this._anchorMesh.position.subtractInPlace(this._tmpVector);\n                if (this.attachedMesh.isUsingPivotMatrix()) {\n                  this._anchorMesh.position.subtractInPlace(this.attachedMesh.getPivotPoint());\n                }\n              }\n              this._anchorMesh.addChild(this.attachedMesh);\n              this._anchorMesh.scaling.addInPlace(deltaScale);\n              if (this._anchorMesh.scaling.x < 0 || this._anchorMesh.scaling.y < 0 || this._anchorMesh.scaling.z < 0) {\n                this._anchorMesh.scaling.subtractInPlace(deltaScale);\n              }\n              this._anchorMesh.removeChild(this.attachedMesh);\n              this.attachedMesh.setParent(originalParent);\n              PivotTools._RestorePivotPoint(this.attachedMesh);\n            }\n            this._updateDummy();\n          });\n          // Selection/deselection\n          _dragBehavior.onDragStartObservable.add(() => {\n            this.onDragStartObservable.notifyObservers({});\n            this._selectNode(box);\n            totalRelativeDragDistance = 0;\n            previousScale = 0;\n          });\n          _dragBehavior.onDragEndObservable.add(event => {\n            this.onScaleBoxDragEndObservable.notifyObservers({});\n            this._selectNode(null);\n            this._updateDummy();\n            this._unhoverMeshOnTouchUp(event.pointerInfo, box);\n          });\n          this._scaleBoxesParent.addChild(box);\n        }\n      }\n    }\n    this._rootMesh.addChild(this._scaleBoxesParent);\n    // Hover color change\n    const pointerIds = new Array();\n    this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(pointerInfo => {\n      if (!pointerIds[pointerInfo.event.pointerId]) {\n        this._rotateSpheresParent.getChildMeshes().concat(this._scaleBoxesParent.getChildMeshes()).forEach(mesh => {\n          if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh == mesh) {\n            pointerIds[pointerInfo.event.pointerId] = mesh;\n            mesh.material = this._hoverColoredMaterial;\n            this._isHovered = true;\n          }\n        });\n      } else {\n        if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh != pointerIds[pointerInfo.event.pointerId]) {\n          pointerIds[pointerInfo.event.pointerId].material = this._coloredMaterial;\n          delete pointerIds[pointerInfo.event.pointerId];\n          this._isHovered = false;\n        }\n      }\n    });\n    // Update bounding box positions\n    this._renderObserver = this.gizmoLayer.originalScene.onBeforeRenderObservable.add(() => {\n      // Only update the bounding box if scaling has changed\n      if (this.attachedMesh && !this._existingMeshScale.equals(this.attachedMesh.scaling)) {\n        this.updateBoundingBox();\n      } else if (this.fixedDragMeshScreenSize || this.fixedDragMeshBoundsSize) {\n        this._updateRotationSpheres();\n        this._updateScaleBoxes();\n      }\n      // If drag mesh is enabled and dragging, update the attached mesh pose to match the drag mesh\n      if (this._dragMesh && this.attachedMesh && this._pointerDragBehavior.dragging) {\n        this._lineBoundingBox.position.rotateByQuaternionToRef(this._rootMesh.rotationQuaternion, this._tmpVector);\n        this.attachedMesh.setAbsolutePosition(this._dragMesh.position.add(this._tmpVector.scale(-1)));\n      }\n    });\n    this.updateBoundingBox();\n  }\n  _attachedNodeChanged(value) {\n    if (value) {\n      // Reset anchor mesh to match attached mesh's scale\n      // This is needed to avoid invalid box/sphere position on first drag\n      this._anchorMesh.scaling.setAll(1);\n      PivotTools._RemoveAndStorePivotPoint(value);\n      const originalParent = value.parent;\n      this._anchorMesh.addChild(value);\n      this._anchorMesh.removeChild(value);\n      value.setParent(originalParent);\n      PivotTools._RestorePivotPoint(value);\n      this.updateBoundingBox();\n      value.getChildMeshes(false).forEach(m => {\n        m.markAsDirty(\"scaling\");\n      });\n      this.gizmoLayer.utilityLayerScene.onAfterRenderObservable.addOnce(() => {\n        this._updateDummy();\n      });\n    }\n  }\n  _selectNode(selectedMesh) {\n    this._rotateSpheresParent.getChildMeshes().concat(this._scaleBoxesParent.getChildMeshes()).forEach(m => {\n      m.isVisible = !selectedMesh || m == selectedMesh;\n    });\n  }\n  _unhoverMeshOnTouchUp(pointerInfo, selectedMesh) {\n    // force unhover mesh if not a mouse event\n    if ((pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.event) instanceof PointerEvent && (pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.event.pointerType) === \"touch\") {\n      selectedMesh.material = this._coloredMaterial;\n    }\n  }\n  /**\n   * returns an array containing all boxes used for scaling (in increasing x, y and z orders)\n   */\n  getScaleBoxes() {\n    return this._scaleBoxesParent.getChildMeshes();\n  }\n  /**\n   * Updates the bounding box information for the Gizmo\n   */\n  updateBoundingBox() {\n    if (this.attachedMesh) {\n      PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);\n      // Store original parent\n      const originalParent = this.attachedMesh.parent;\n      this.attachedMesh.setParent(null);\n      this._update();\n      // Rotate based on axis\n      if (!this.attachedMesh.rotationQuaternion) {\n        this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);\n      }\n      if (!this._anchorMesh.rotationQuaternion) {\n        this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._anchorMesh.rotation.y, this._anchorMesh.rotation.x, this._anchorMesh.rotation.z);\n      }\n      this._anchorMesh.rotationQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);\n      // Store original position and reset mesh to origin before computing the bounding box\n      this._tmpQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);\n      this._tmpVector.copyFrom(this.attachedMesh.position);\n      this.attachedMesh.rotationQuaternion.set(0, 0, 0, 1);\n      this.attachedMesh.position.set(0, 0, 0);\n      // Update bounding dimensions/positions\n      const boundingMinMax = this.attachedMesh.getHierarchyBoundingVectors(!this.ignoreChildren, this.includeChildPredicate);\n      boundingMinMax.max.subtractToRef(boundingMinMax.min, this._boundingDimensions);\n      // Update gizmo to match bounding box scaling and rotation\n      // The position set here is the offset from the origin for the boundingbox when the attached mesh is at the origin\n      // The position of the gizmo is then set to the attachedMesh in gizmo._update\n      this._lineBoundingBox.scaling.copyFrom(this._boundingDimensions);\n      this._lineBoundingBox.position.set((boundingMinMax.max.x + boundingMinMax.min.x) / 2, (boundingMinMax.max.y + boundingMinMax.min.y) / 2, (boundingMinMax.max.z + boundingMinMax.min.z) / 2);\n      this._rotateSpheresParent.position.copyFrom(this._lineBoundingBox.position);\n      this._scaleBoxesParent.position.copyFrom(this._lineBoundingBox.position);\n      this._lineBoundingBox.computeWorldMatrix();\n      this._anchorMesh.position.copyFrom(this._lineBoundingBox.absolutePosition);\n      // Restore position/rotation values\n      this.attachedMesh.rotationQuaternion.copyFrom(this._tmpQuaternion);\n      this.attachedMesh.position.copyFrom(this._tmpVector);\n      // Restore original parent\n      this.attachedMesh.setParent(originalParent);\n    }\n    this._updateRotationSpheres();\n    this._updateScaleBoxes();\n    if (this.attachedMesh) {\n      this._existingMeshScale.copyFrom(this.attachedMesh.scaling);\n      PivotTools._RestorePivotPoint(this.attachedMesh);\n    }\n  }\n  _updateRotationSpheres() {\n    const rotateSpheres = this._rotateSpheresParent.getChildMeshes();\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 2; j++) {\n        for (let k = 0; k < 2; k++) {\n          const index = i * 4 + j * 2 + k;\n          if (i == 0) {\n            rotateSpheres[index].position.set(this._boundingDimensions.x / 2, this._boundingDimensions.y * j, this._boundingDimensions.z * k);\n            rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n            rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Right()).normalizeToNew().add(rotateSpheres[index].position));\n          }\n          if (i == 1) {\n            rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y / 2, this._boundingDimensions.z * k);\n            rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n            rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Up()).normalizeToNew().add(rotateSpheres[index].position));\n          }\n          if (i == 2) {\n            rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y * k, this._boundingDimensions.z / 2);\n            rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n            rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Forward()).normalizeToNew().add(rotateSpheres[index].position));\n          }\n          if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {\n            rotateSpheres[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);\n            const distanceFromCamera = this.rotationSphereSize * this._tmpVector.length() / this.fixedDragMeshScreenSizeDistanceFactor;\n            rotateSpheres[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);\n          } else if (this.fixedDragMeshBoundsSize) {\n            rotateSpheres[index].scaling.set(this.rotationSphereSize * this._boundingDimensions.x, this.rotationSphereSize * this._boundingDimensions.y, this.rotationSphereSize * this._boundingDimensions.z);\n          } else {\n            rotateSpheres[index].scaling.set(this.rotationSphereSize, this.rotationSphereSize, this.rotationSphereSize);\n          }\n        }\n      }\n    }\n  }\n  _updateScaleBoxes() {\n    const scaleBoxes = this._scaleBoxesParent.getChildMeshes();\n    let index = 0;\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        for (let k = 0; k < 3; k++) {\n          const zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);\n          if (zeroAxisCount === 1 || zeroAxisCount === 3) {\n            continue;\n          }\n          if (scaleBoxes[index]) {\n            scaleBoxes[index].position.set(this._boundingDimensions.x * (i / 2), this._boundingDimensions.y * (j / 2), this._boundingDimensions.z * (k / 2));\n            scaleBoxes[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n            if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {\n              scaleBoxes[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);\n              const distanceFromCamera = this.scaleBoxSize * this._tmpVector.length() / this.fixedDragMeshScreenSizeDistanceFactor;\n              scaleBoxes[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);\n            } else if (this.fixedDragMeshBoundsSize) {\n              scaleBoxes[index].scaling.set(this.scaleBoxSize * this._boundingDimensions.x, this.scaleBoxSize * this._boundingDimensions.y, this.scaleBoxSize * this._boundingDimensions.z);\n            } else {\n              scaleBoxes[index].scaling.set(this.scaleBoxSize, this.scaleBoxSize, this.scaleBoxSize);\n            }\n          }\n          index++;\n        }\n      }\n    }\n  }\n  /**\n   * Enables rotation on the specified axis and disables rotation on the others\n   * @param axis The list of axis that should be enabled (eg. \"xy\" or \"xyz\")\n   */\n  setEnabledRotationAxis(axis) {\n    this._rotateSpheresParent.getChildMeshes().forEach((m, i) => {\n      if (i < 4) {\n        m.setEnabled(axis.indexOf(\"x\") != -1);\n      } else if (i < 8) {\n        m.setEnabled(axis.indexOf(\"y\") != -1);\n      } else {\n        m.setEnabled(axis.indexOf(\"z\") != -1);\n      }\n    });\n  }\n  /**\n   * Enables/disables scaling\n   * @param enable if scaling should be enabled\n   * @param homogeneousScaling defines if scaling should only be homogeneous\n   */\n  setEnabledScaling(enable, homogeneousScaling = false) {\n    this._scaleBoxesParent.getChildMeshes().forEach(m => {\n      let enableMesh = enable;\n      // Disable heterogeneous scale handles if requested.\n      if (homogeneousScaling && m._internalMetadata === true) {\n        enableMesh = false;\n      }\n      m.setEnabled(enableMesh);\n    });\n  }\n  _updateDummy() {\n    if (this._dragMesh) {\n      this._dragMesh.position.copyFrom(this._lineBoundingBox.getAbsolutePosition());\n      this._dragMesh.scaling.copyFrom(this._lineBoundingBox.scaling);\n      this._dragMesh.rotationQuaternion.copyFrom(this._rootMesh.rotationQuaternion);\n    }\n  }\n  /**\n   * Enables a pointer drag behavior on the bounding box of the gizmo\n   */\n  enableDragBehavior() {\n    this._dragMesh = CreateBox(\"dummy\", {\n      size: 1\n    }, this.gizmoLayer.utilityLayerScene);\n    this._dragMesh.visibility = 0;\n    this._dragMesh.rotationQuaternion = new Quaternion();\n    this._pointerDragBehavior.useObjectOrientationForDragging = false;\n    this._dragMesh.addBehavior(this._pointerDragBehavior);\n  }\n  /**\n   * Disposes of the gizmo\n   */\n  dispose() {\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n    this.gizmoLayer.originalScene.onBeforeRenderObservable.remove(this._renderObserver);\n    this._lineBoundingBox.dispose();\n    this._rotateSpheresParent.dispose();\n    this._scaleBoxesParent.dispose();\n    if (this._dragMesh) {\n      this._dragMesh.dispose();\n    }\n    super.dispose();\n  }\n  /**\n   * Makes a mesh not pickable and wraps the mesh inside of a bounding box mesh that is pickable. (This is useful to avoid picking within complex geometry)\n   * @param mesh the mesh to wrap in the bounding box mesh and make not pickable\n   * @returns the bounding box mesh with the passed in mesh as a child\n   */\n  static MakeNotPickableAndWrapInBoundingBox(mesh) {\n    const makeNotPickable = root => {\n      root.isPickable = false;\n      root.getChildMeshes().forEach(c => {\n        makeNotPickable(c);\n      });\n    };\n    makeNotPickable(mesh);\n    // Reset position to get bounding box from origin with no rotation\n    if (!mesh.rotationQuaternion) {\n      mesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(mesh.rotation.y, mesh.rotation.x, mesh.rotation.z);\n    }\n    const oldPos = mesh.position.clone();\n    const oldRot = mesh.rotationQuaternion.clone();\n    mesh.rotationQuaternion.set(0, 0, 0, 1);\n    mesh.position.set(0, 0, 0);\n    // Update bounding dimensions/positions\n    const box = CreateBox(\"box\", {\n      size: 1\n    }, mesh.getScene());\n    const boundingMinMax = mesh.getHierarchyBoundingVectors();\n    boundingMinMax.max.subtractToRef(boundingMinMax.min, box.scaling);\n    // Adjust scale to avoid undefined behavior when adding child\n    if (box.scaling.y === 0) {\n      box.scaling.y = Epsilon;\n    }\n    if (box.scaling.x === 0) {\n      box.scaling.x = Epsilon;\n    }\n    if (box.scaling.z === 0) {\n      box.scaling.z = Epsilon;\n    }\n    box.position.set((boundingMinMax.max.x + boundingMinMax.min.x) / 2, (boundingMinMax.max.y + boundingMinMax.min.y) / 2, (boundingMinMax.max.z + boundingMinMax.min.z) / 2);\n    // Restore original positions\n    mesh.addChild(box);\n    mesh.rotationQuaternion.copyFrom(oldRot);\n    mesh.position.copyFrom(oldPos);\n    // Reverse parenting\n    mesh.removeChild(box);\n    box.addChild(mesh);\n    box.visibility = 0;\n    return box;\n  }\n  /**\n   * CustomMeshes are not supported by this gizmo\n   */\n  setCustomMesh() {\n    Logger.Error(\"Custom meshes are not supported on this gizmo\");\n  }\n}","map":{"version":3,"names":["Observable","Logger","Quaternion","Matrix","Vector3","AbstractMesh","CreateSphere","CreateBox","CreateLines","PointerDragBehavior","Gizmo","UtilityLayerRenderer","StandardMaterial","PivotTools","Color3","Epsilon","BoundingBoxGizmo","axisFactor","factor","_axisFactor","scaleBoxes","_scaleBoxesParent","getChildMeshes","index","i","j","k","zeroAxisCount","dragAxis","multiplyInPlace","setEnabled","lengthSquared","scaleDragSpeed","value","_scaleDragSpeed","coloredMaterial","_coloredMaterial","hoverMaterial","_hoverColoredMaterial","pointerDragBehavior","_pointerDragBehavior","setColor","color","emissiveColor","clone","add","_lineBoundingBox","getChildren","forEach","l","constructor","Gray","gizmoLayer","DefaultKeepDepthUtilityLayer","_boundingDimensions","_renderObserver","_pointerObserver","_tmpQuaternion","_tmpVector","_tmpRotationMatrix","ignoreChildren","includeChildPredicate","rotationSphereSize","scaleBoxSize","fixedDragMeshScreenSize","fixedDragMeshBoundsSize","fixedDragMeshScreenSizeDistanceFactor","scalingSnapDistance","rotationSnapDistance","onDragStartObservable","onScaleBoxDragObservable","onScaleBoxDragEndObservable","onRotationSphereDragObservable","onRotationSphereDragEndObservable","scalePivot","_existingMeshScale","_dragMesh","updateScale","_anchorMesh","utilityLayerScene","disableLighting","rotationQuaternion","lines","push","points","x","y","z","position","addInPlace","isPickable","addChild","_rootMesh","_rotateSpheresParent","sphere","diameter","material","isNearGrabbable","_dragBehavior","moveAttached","updateDragPlane","addBehavior","startingTurnDirection","totalTurnAmountOfDrag","previousProjectDist","copyFrom","forward","onDragObservable","event","notifyObservers","attachedMesh","originalParent","parent","scaling","isNonUniformWithinEpsilon","Warn","_RemoveAndStorePivotPoint","worldDragDirection","toSub","dragPlaneNormal","scale","Dot","subtract","normalizeToNew","projectDist","delta","Math","abs","length","RotationYawPitchRoll","rotation","PI","dragSteps","floor","angle","RotationYawPitchRollToRef","isUsingPivotMatrix","getScene","useRightHandedSystem","conjugateInPlace","normalize","multiplyToRef","removeChild","setParent","updateBoundingBox","_RestorePivotPoint","_updateDummy","_selectNode","onDragEndObservable","_unhoverMeshOnTouchUp","pointerInfo","box","size","_internalMetadata","totalRelativeDragDistance","previousScale","relativeDragDistance","dragDistance","deltaScale","scaleInPlace","getWorldMatrix","getRotationMatrixToRef","scaleToRef","TransformCoordinatesToRef","subtractInPlace","absolutePosition","subtractToRef","getPivotPoint","pointerIds","Array","onPointerObservable","pointerId","concat","mesh","pickInfo","pickedMesh","_isHovered","originalScene","onBeforeRenderObservable","equals","_updateRotationSpheres","_updateScaleBoxes","dragging","rotateByQuaternionToRef","setAbsolutePosition","_attachedNodeChanged","setAll","m","markAsDirty","onAfterRenderObservable","addOnce","selectedMesh","isVisible","PointerEvent","pointerType","getScaleBoxes","_update","set","boundingMinMax","getHierarchyBoundingVectors","max","min","computeWorldMatrix","rotateSpheres","lookAt","Cross","Right","Up","Forward","activeCamera","distanceFromCamera","setEnabledRotationAxis","axis","indexOf","setEnabledScaling","enable","homogeneousScaling","enableMesh","getAbsolutePosition","enableDragBehavior","visibility","useObjectOrientationForDragging","dispose","remove","MakeNotPickableAndWrapInBoundingBox","makeNotPickable","root","c","oldPos","oldRot","setCustomMesh","Error"],"sources":["../../../../dev/core/src/Gizmos/boundingBoxGizmo.ts"],"sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder\";\r\nimport { CreateBox } from \"../Meshes/Builders/boxBuilder\";\r\nimport { CreateLines } from \"../Meshes/Builders/linesBuilder\";\r\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior\";\r\nimport type { IGizmo } from \"./gizmo\";\r\nimport { Gizmo } from \"./gizmo\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport { PivotTools } from \"../Misc/pivotTools\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { LinesMesh } from \"../Meshes/linesMesh\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport type { IPointerEvent } from \"../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Interface for bounding box gizmo\r\n */\r\nexport interface IBoundingBoxGizmo extends IGizmo {\r\n    /**\r\n     * If child meshes should be ignored when calculating the bounding box. This should be set to true to avoid perf hits with heavily nested meshes.\r\n     */\r\n    ignoreChildren: boolean;\r\n    /**\r\n     * Returns true if a descendant should be included when computing the bounding box. When null, all descendants are included. If ignoreChildren is set this will be ignored.\r\n     */\r\n    includeChildPredicate: Nullable<(abstractMesh: AbstractMesh) => boolean>;\r\n    /** The size of the rotation spheres attached to the bounding box */\r\n    rotationSphereSize: number;\r\n    /** The size of the scale boxes attached to the bounding box */\r\n    scaleBoxSize: number;\r\n    /**\r\n     * If set, the rotation spheres and scale boxes will increase in size based on the distance away from the camera to have a consistent screen size\r\n     * Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true\r\n     */\r\n    fixedDragMeshScreenSize: boolean;\r\n    /**\r\n     * If set, the rotation spheres and scale boxes will increase in size based on the size of the bounding box\r\n     * Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true\r\n     */\r\n    fixedDragMeshBoundsSize: boolean;\r\n    /**\r\n     * The distance away from the object which the draggable meshes should appear world sized when fixedDragMeshScreenSize is set to true\r\n     */\r\n    fixedDragMeshScreenSizeDistanceFactor: number;\r\n    /** Fired when a rotation sphere or scale box is dragged */\r\n    onDragStartObservable: Observable<{}>;\r\n    /** Fired when a scale box is dragged */\r\n    onScaleBoxDragObservable: Observable<{}>;\r\n    /** Fired when a scale box drag is ended */\r\n    onScaleBoxDragEndObservable: Observable<{}>;\r\n    /** Fired when a rotation sphere is dragged */\r\n    onRotationSphereDragObservable: Observable<{}>;\r\n    /** Fired when a rotation sphere drag is ended */\r\n    onRotationSphereDragEndObservable: Observable<{}>;\r\n    /** Relative bounding box pivot used when scaling the attached node. */\r\n    scalePivot: Nullable<Vector3>;\r\n    /** Scale factor vector used for masking some axis */\r\n    axisFactor: Vector3;\r\n    /** Scale factor scalar affecting all axes' drag speed */\r\n    scaleDragSpeed: number;\r\n    /**\r\n     * Sets the color of the bounding box gizmo\r\n     * @param color the color to set\r\n     */\r\n    setColor(color: Color3): void;\r\n    /** Returns an array containing all boxes used for scaling (in increasing x, y and z orders) */\r\n    getScaleBoxes(): AbstractMesh[];\r\n    /** Updates the bounding box information for the Gizmo */\r\n    updateBoundingBox(): void;\r\n    /**\r\n     * Enables rotation on the specified axis and disables rotation on the others\r\n     * @param axis The list of axis that should be enabled (eg. \"xy\" or \"xyz\")\r\n     */\r\n    setEnabledRotationAxis(axis: string): void;\r\n    /**\r\n     * Enables/disables scaling\r\n     * @param enable if scaling should be enabled\r\n     * @param homogeneousScaling defines if scaling should only be homogeneous\r\n     */\r\n    setEnabledScaling(enable: boolean, homogeneousScaling?: boolean): void;\r\n    /** Enables a pointer drag behavior on the bounding box of the gizmo */\r\n    enableDragBehavior(): void;\r\n\r\n    /** Default material used to render when gizmo is not disabled or hovered */\r\n    coloredMaterial: StandardMaterial;\r\n    /** Material used to render when gizmo is hovered with mouse*/\r\n    hoverMaterial: StandardMaterial;\r\n\r\n    /** Drag distance in babylon units that the gizmo will snap scaling to when dragged */\r\n    scalingSnapDistance: number;\r\n    /** Drag distance in babylon units that the gizmo will snap rotation to when dragged */\r\n    rotationSnapDistance: number;\r\n}\r\n\r\n/**\r\n * Bounding box gizmo\r\n */\r\nexport class BoundingBoxGizmo extends Gizmo implements IBoundingBoxGizmo {\r\n    protected _lineBoundingBox: AbstractMesh;\r\n    protected _rotateSpheresParent: AbstractMesh;\r\n    protected _scaleBoxesParent: AbstractMesh;\r\n    protected _boundingDimensions = new Vector3(1, 1, 1);\r\n    protected _renderObserver: Nullable<Observer<Scene>> = null;\r\n    protected _pointerObserver: Nullable<Observer<PointerInfo>> = null;\r\n    protected _scaleDragSpeed = 0.2;\r\n\r\n    private _tmpQuaternion = new Quaternion();\r\n    private _tmpVector = new Vector3(0, 0, 0);\r\n    private _tmpRotationMatrix = new Matrix();\r\n    /**\r\n     * If child meshes should be ignored when calculating the bounding box. This should be set to true to avoid perf hits with heavily nested meshes (Default: false)\r\n     */\r\n    public ignoreChildren = false;\r\n    /**\r\n     * Returns true if a descendant should be included when computing the bounding box. When null, all descendants are included. If ignoreChildren is set this will be ignored. (Default: null)\r\n     */\r\n    public includeChildPredicate: Nullable<(abstractMesh: AbstractMesh) => boolean> = null;\r\n\r\n    /**\r\n     * The size of the rotation spheres attached to the bounding box (Default: 0.1)\r\n     */\r\n    public rotationSphereSize = 0.1;\r\n    /**\r\n     * The size of the scale boxes attached to the bounding box (Default: 0.1)\r\n     */\r\n    public scaleBoxSize = 0.1;\r\n    /**\r\n     * If set, the rotation spheres and scale boxes will increase in size based on the distance away from the camera to have a consistent screen size (Default: false)\r\n     * Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true\r\n     */\r\n    public fixedDragMeshScreenSize = false;\r\n    /**\r\n     * If set, the rotation spheres and scale boxes will increase in size based on the size of the bounding box\r\n     * Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true\r\n     */\r\n    public fixedDragMeshBoundsSize = false;\r\n    /**\r\n     * The distance away from the object which the draggable meshes should appear world sized when fixedDragMeshScreenSize is set to true (default: 10)\r\n     */\r\n    public fixedDragMeshScreenSizeDistanceFactor = 10;\r\n    /**\r\n     * Drag distance in babylon units that the gizmo will snap scaling to when dragged\r\n     */\r\n    public scalingSnapDistance = 0;\r\n    /**\r\n     * Drag distance in babylon units that the gizmo will snap rotation to when dragged\r\n     */\r\n    public rotationSnapDistance = 0;\r\n    /**\r\n     * Fired when a rotation sphere or scale box is dragged\r\n     */\r\n    public onDragStartObservable = new Observable<{}>();\r\n    /**\r\n     * Fired when a scale box is dragged\r\n     */\r\n    public onScaleBoxDragObservable = new Observable<{}>();\r\n    /**\r\n     * Fired when a scale box drag is ended\r\n     */\r\n    public onScaleBoxDragEndObservable = new Observable<{}>();\r\n    /**\r\n     * Fired when a rotation sphere is dragged\r\n     */\r\n    public onRotationSphereDragObservable = new Observable<{}>();\r\n    /**\r\n     * Fired when a rotation sphere drag is ended\r\n     */\r\n    public onRotationSphereDragEndObservable = new Observable<{}>();\r\n    /**\r\n     * Relative bounding box pivot used when scaling the attached node. When null object with scale from the opposite corner. 0.5,0.5,0.5 for center and 0.5,0,0.5 for bottom (Default: null)\r\n     */\r\n    public scalePivot: Nullable<Vector3> = null;\r\n    /**\r\n     * Scale factor used for masking some axis\r\n     */\r\n    protected _axisFactor = new Vector3(1, 1, 1);\r\n\r\n    /**\r\n     * Sets the axis factor\r\n     * @param factor the Vector3 value\r\n     */\r\n    public set axisFactor(factor: Vector3) {\r\n        this._axisFactor = factor;\r\n        // update scale cube visibility\r\n        const scaleBoxes = this._scaleBoxesParent.getChildMeshes();\r\n        let index = 0;\r\n        for (let i = 0; i < 3; i++) {\r\n            for (let j = 0; j < 3; j++) {\r\n                for (let k = 0; k < 3; k++) {\r\n                    const zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);\r\n                    if (zeroAxisCount === 1 || zeroAxisCount === 3) {\r\n                        continue;\r\n                    }\r\n                    if (scaleBoxes[index]) {\r\n                        const dragAxis = new Vector3(i - 1, j - 1, k - 1);\r\n                        dragAxis.multiplyInPlace(this._axisFactor);\r\n                        scaleBoxes[index].setEnabled(dragAxis.lengthSquared() > Epsilon);\r\n                    }\r\n                    index++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the axis factor\r\n     * @returns the Vector3 factor value\r\n     */\r\n    public get axisFactor(): Vector3 {\r\n        return this._axisFactor;\r\n    }\r\n\r\n    /**\r\n     * Sets scale drag speed value\r\n     * @param value the new speed value\r\n     */\r\n    public set scaleDragSpeed(value: number) {\r\n        this._scaleDragSpeed = value;\r\n    }\r\n\r\n    /**\r\n     * Gets scale drag speed\r\n     * @returns the scale speed number\r\n     */\r\n    public get scaleDragSpeed(): number {\r\n        return this._scaleDragSpeed;\r\n    }\r\n\r\n    /**\r\n     * Mesh used as a pivot to rotate the attached node\r\n     */\r\n    protected _anchorMesh: AbstractMesh;\r\n\r\n    protected _existingMeshScale = new Vector3();\r\n\r\n    // Dragging\r\n    protected _dragMesh: Nullable<Mesh> = null;\r\n    protected _pointerDragBehavior = new PointerDragBehavior();\r\n\r\n    protected _coloredMaterial: StandardMaterial;\r\n    protected _hoverColoredMaterial: StandardMaterial;\r\n\r\n    /** Default material used to render when gizmo is not disabled or hovered */\r\n    public get coloredMaterial() {\r\n        return this._coloredMaterial;\r\n    }\r\n\r\n    /** Material used to render when gizmo is hovered with mouse*/\r\n    public get hoverMaterial() {\r\n        return this._hoverColoredMaterial;\r\n    }\r\n    /**\r\n     * Get the pointerDragBehavior\r\n     */\r\n    public get pointerDragBehavior(): PointerDragBehavior {\r\n        return this._pointerDragBehavior;\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the bounding box gizmo\r\n     * @param color the color to set\r\n     */\r\n    public setColor(color: Color3) {\r\n        this._coloredMaterial.emissiveColor = color;\r\n        this._hoverColoredMaterial.emissiveColor = color.clone().add(new Color3(0.3, 0.3, 0.3));\r\n        this._lineBoundingBox.getChildren().forEach((l) => {\r\n            if ((l as LinesMesh).color) {\r\n                (l as LinesMesh).color = color;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Creates an BoundingBoxGizmo\r\n     * @param color The color of the gizmo\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     */\r\n    constructor(color: Color3 = Color3.Gray(), gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer) {\r\n        super(gizmoLayer);\r\n\r\n        // Do not update the gizmo's scale so it has a fixed size to the object its attached to\r\n        this.updateScale = false;\r\n\r\n        this._anchorMesh = new AbstractMesh(\"anchor\", gizmoLayer.utilityLayerScene);\r\n        // Create Materials\r\n        this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\r\n        this._coloredMaterial.disableLighting = true;\r\n        this._hoverColoredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\r\n        this._hoverColoredMaterial.disableLighting = true;\r\n\r\n        // Build bounding box out of lines\r\n        this._lineBoundingBox = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\r\n        this._lineBoundingBox.rotationQuaternion = new Quaternion();\r\n        const lines = [];\r\n        lines.push(CreateLines(\"lines\", { points: [new Vector3(0, 0, 0), new Vector3(this._boundingDimensions.x, 0, 0)] }, gizmoLayer.utilityLayerScene));\r\n        lines.push(CreateLines(\"lines\", { points: [new Vector3(0, 0, 0), new Vector3(0, this._boundingDimensions.y, 0)] }, gizmoLayer.utilityLayerScene));\r\n        lines.push(CreateLines(\"lines\", { points: [new Vector3(0, 0, 0), new Vector3(0, 0, this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                { points: [new Vector3(this._boundingDimensions.x, 0, 0), new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0)] },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                { points: [new Vector3(this._boundingDimensions.x, 0, 0), new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z)] },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                { points: [new Vector3(0, this._boundingDimensions.y, 0), new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0)] },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                { points: [new Vector3(0, this._boundingDimensions.y, 0), new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z)] },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                { points: [new Vector3(0, 0, this._boundingDimensions.z), new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z)] },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                { points: [new Vector3(0, 0, this._boundingDimensions.z), new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z)] },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                {\r\n                    points: [\r\n                        new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z),\r\n                        new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z),\r\n                    ],\r\n                },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                {\r\n                    points: [\r\n                        new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z),\r\n                        new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z),\r\n                    ],\r\n                },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                {\r\n                    points: [\r\n                        new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z),\r\n                        new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0),\r\n                    ],\r\n                },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.forEach((l) => {\r\n            l.color = color;\r\n            l.position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\r\n            l.isPickable = false;\r\n            this._lineBoundingBox.addChild(l);\r\n        });\r\n        this._rootMesh.addChild(this._lineBoundingBox);\r\n\r\n        this.setColor(color);\r\n\r\n        // Create rotation spheres\r\n        this._rotateSpheresParent = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\r\n        this._rotateSpheresParent.rotationQuaternion = new Quaternion();\r\n        for (let i = 0; i < 12; i++) {\r\n            const sphere = CreateSphere(\"\", { diameter: 1 }, gizmoLayer.utilityLayerScene);\r\n            sphere.rotationQuaternion = new Quaternion();\r\n            sphere.material = this._coloredMaterial;\r\n            sphere.isNearGrabbable = true;\r\n\r\n            // Drag behavior\r\n            const _dragBehavior = new PointerDragBehavior({});\r\n            _dragBehavior.moveAttached = false;\r\n            _dragBehavior.updateDragPlane = false;\r\n            sphere.addBehavior(_dragBehavior);\r\n            const startingTurnDirection = new Vector3(1, 0, 0);\r\n            let totalTurnAmountOfDrag = 0;\r\n            let previousProjectDist = 0;\r\n            _dragBehavior.onDragStartObservable.add(() => {\r\n                startingTurnDirection.copyFrom(sphere.forward);\r\n                totalTurnAmountOfDrag = 0;\r\n                previousProjectDist = 0;\r\n            });\r\n            _dragBehavior.onDragObservable.add((event) => {\r\n                this.onRotationSphereDragObservable.notifyObservers({});\r\n                if (this.attachedMesh) {\r\n                    const originalParent = this.attachedMesh.parent;\r\n                    if (originalParent && (originalParent as Mesh).scaling && (originalParent as Mesh).scaling.isNonUniformWithinEpsilon(0.001)) {\r\n                        Logger.Warn(\"BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling\");\r\n                        return;\r\n                    }\r\n                    PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);\r\n\r\n                    const worldDragDirection = startingTurnDirection;\r\n\r\n                    // Project the world right on to the drag plane\r\n                    const toSub = event.dragPlaneNormal.scale(Vector3.Dot(event.dragPlaneNormal, worldDragDirection));\r\n                    const dragAxis = worldDragDirection.subtract(toSub).normalizeToNew();\r\n\r\n                    // project drag delta on to the resulting drag axis and rotate based on that\r\n                    let projectDist = Vector3.Dot(dragAxis, event.delta) < 0 ? Math.abs(event.delta.length()) : -Math.abs(event.delta.length());\r\n\r\n                    // Make rotation relative to size of mesh.\r\n                    projectDist = (projectDist / this._boundingDimensions.length()) * this._anchorMesh.scaling.length();\r\n\r\n                    // Rotate based on axis\r\n                    if (!this.attachedMesh.rotationQuaternion) {\r\n                        this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(\r\n                            this.attachedMesh.rotation.y,\r\n                            this.attachedMesh.rotation.x,\r\n                            this.attachedMesh.rotation.z\r\n                        );\r\n                    }\r\n                    if (!this._anchorMesh.rotationQuaternion) {\r\n                        this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(\r\n                            this._anchorMesh.rotation.y,\r\n                            this._anchorMesh.rotation.x,\r\n                            this._anchorMesh.rotation.z\r\n                        );\r\n                    }\r\n\r\n                    // Do not allow the object to turn more than a full circle\r\n                    totalTurnAmountOfDrag += projectDist;\r\n                    if (Math.abs(totalTurnAmountOfDrag) <= 2 * Math.PI) {\r\n                        if (this.rotationSnapDistance > 0) {\r\n                            const dragSteps = Math.floor(Math.abs(totalTurnAmountOfDrag) / this.rotationSnapDistance) * (totalTurnAmountOfDrag < 0 ? -1 : 1);\r\n                            const angle = this.rotationSnapDistance * dragSteps;\r\n                            projectDist = angle - previousProjectDist;\r\n                            previousProjectDist = angle;\r\n                        }\r\n                        if (i >= 8) {\r\n                            Quaternion.RotationYawPitchRollToRef(0, 0, projectDist, this._tmpQuaternion);\r\n                        } else if (i >= 4) {\r\n                            Quaternion.RotationYawPitchRollToRef(projectDist, 0, 0, this._tmpQuaternion);\r\n                        } else {\r\n                            Quaternion.RotationYawPitchRollToRef(0, projectDist, 0, this._tmpQuaternion);\r\n                        }\r\n\r\n                        // if using pivot, move anchor so mesh will be at relative (0,0,0) when parented\r\n                        if (this.attachedMesh.isUsingPivotMatrix()) {\r\n                            this._anchorMesh.position.copyFrom(this.attachedMesh.position);\r\n                        }\r\n                        // Rotate around center of bounding box\r\n                        this._anchorMesh.addChild(this.attachedMesh);\r\n                        if (this._anchorMesh.getScene().useRightHandedSystem) {\r\n                            this._tmpQuaternion.conjugateInPlace();\r\n                        }\r\n                        this._tmpQuaternion.normalize();\r\n                        this._anchorMesh.rotationQuaternion!.multiplyToRef(this._tmpQuaternion, this._anchorMesh.rotationQuaternion!);\r\n                        this._anchorMesh.rotationQuaternion.normalize();\r\n                        this._anchorMesh.removeChild(this.attachedMesh);\r\n                        this.attachedMesh.setParent(originalParent);\r\n                    }\r\n                    this.updateBoundingBox();\r\n\r\n                    PivotTools._RestorePivotPoint(this.attachedMesh);\r\n                }\r\n                this._updateDummy();\r\n            });\r\n\r\n            // Selection/deselection\r\n            _dragBehavior.onDragStartObservable.add(() => {\r\n                this.onDragStartObservable.notifyObservers({});\r\n                this._selectNode(sphere);\r\n            });\r\n            _dragBehavior.onDragEndObservable.add((event) => {\r\n                this.onRotationSphereDragEndObservable.notifyObservers({});\r\n                this._selectNode(null);\r\n                this._updateDummy();\r\n                this._unhoverMeshOnTouchUp(event.pointerInfo, sphere);\r\n            });\r\n\r\n            this._rotateSpheresParent.addChild(sphere);\r\n        }\r\n        this._rootMesh.addChild(this._rotateSpheresParent);\r\n\r\n        // Create scale cubes\r\n        this._scaleBoxesParent = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\r\n        this._scaleBoxesParent.rotationQuaternion = new Quaternion();\r\n        for (let i = 0; i < 3; i++) {\r\n            for (let j = 0; j < 3; j++) {\r\n                for (let k = 0; k < 3; k++) {\r\n                    // create box for relevant axis\r\n                    const zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);\r\n                    if (zeroAxisCount === 1 || zeroAxisCount === 3) {\r\n                        continue;\r\n                    }\r\n\r\n                    const box = CreateBox(\"\", { size: 1 }, gizmoLayer.utilityLayerScene);\r\n                    box.material = this._coloredMaterial;\r\n                    box._internalMetadata = zeroAxisCount === 2; // None homogenous scale handle\r\n                    box.isNearGrabbable = true;\r\n\r\n                    // Dragging logic\r\n                    const dragAxis = new Vector3(i - 1, j - 1, k - 1).normalize();\r\n                    const _dragBehavior = new PointerDragBehavior({ dragAxis: dragAxis });\r\n                    _dragBehavior.updateDragPlane = false;\r\n                    _dragBehavior.moveAttached = false;\r\n                    let totalRelativeDragDistance = 0;\r\n                    let previousScale = 0;\r\n                    box.addBehavior(_dragBehavior);\r\n                    _dragBehavior.onDragObservable.add((event) => {\r\n                        this.onScaleBoxDragObservable.notifyObservers({});\r\n                        if (this.attachedMesh) {\r\n                            const originalParent = this.attachedMesh.parent;\r\n                            if (originalParent && (originalParent as Mesh).scaling && (originalParent as Mesh).scaling.isNonUniformWithinEpsilon(0.001)) {\r\n                                Logger.Warn(\"BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling\");\r\n                                return;\r\n                            }\r\n                            PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);\r\n                            let relativeDragDistance = (event.dragDistance / this._boundingDimensions.length()) * this._anchorMesh.scaling.length();\r\n                            totalRelativeDragDistance += relativeDragDistance;\r\n                            if (this.scalingSnapDistance > 0) {\r\n                                const dragSteps = Math.floor(Math.abs(totalRelativeDragDistance) / this.scalingSnapDistance) * (totalRelativeDragDistance < 0 ? -1 : 1);\r\n                                const scale = this.scalingSnapDistance * dragSteps;\r\n                                relativeDragDistance = scale - previousScale;\r\n                                previousScale = scale;\r\n                            }\r\n\r\n                            const deltaScale = new Vector3(relativeDragDistance, relativeDragDistance, relativeDragDistance);\r\n                            if (zeroAxisCount === 2) {\r\n                                // scale on 1 axis when using the anchor box in the face middle\r\n                                deltaScale.x *= Math.abs(dragAxis.x);\r\n                                deltaScale.y *= Math.abs(dragAxis.y);\r\n                                deltaScale.z *= Math.abs(dragAxis.z);\r\n                            }\r\n                            deltaScale.scaleInPlace(this._scaleDragSpeed);\r\n                            deltaScale.multiplyInPlace(this._axisFactor);\r\n                            this.updateBoundingBox();\r\n                            if (this.scalePivot) {\r\n                                this.attachedMesh.getWorldMatrix().getRotationMatrixToRef(this._tmpRotationMatrix);\r\n                                // Move anchor to desired pivot point (Bottom left corner + dimension/2)\r\n                                this._boundingDimensions.scaleToRef(0.5, this._tmpVector);\r\n                                Vector3.TransformCoordinatesToRef(this._tmpVector, this._tmpRotationMatrix, this._tmpVector);\r\n                                this._anchorMesh.position.subtractInPlace(this._tmpVector);\r\n                                this._boundingDimensions.multiplyToRef(this.scalePivot, this._tmpVector);\r\n                                Vector3.TransformCoordinatesToRef(this._tmpVector, this._tmpRotationMatrix, this._tmpVector);\r\n                                this._anchorMesh.position.addInPlace(this._tmpVector);\r\n                            } else {\r\n                                // Scale from the position of the opposite corner\r\n                                box.absolutePosition.subtractToRef(this._anchorMesh.position, this._tmpVector);\r\n                                this._anchorMesh.position.subtractInPlace(this._tmpVector);\r\n                                if (this.attachedMesh.isUsingPivotMatrix()) {\r\n                                    this._anchorMesh.position.subtractInPlace(this.attachedMesh.getPivotPoint());\r\n                                }\r\n                            }\r\n\r\n                            this._anchorMesh.addChild(this.attachedMesh);\r\n                            this._anchorMesh.scaling.addInPlace(deltaScale);\r\n                            if (this._anchorMesh.scaling.x < 0 || this._anchorMesh.scaling.y < 0 || this._anchorMesh.scaling.z < 0) {\r\n                                this._anchorMesh.scaling.subtractInPlace(deltaScale);\r\n                            }\r\n                            this._anchorMesh.removeChild(this.attachedMesh);\r\n                            this.attachedMesh.setParent(originalParent);\r\n                            PivotTools._RestorePivotPoint(this.attachedMesh);\r\n                        }\r\n                        this._updateDummy();\r\n                    });\r\n\r\n                    // Selection/deselection\r\n                    _dragBehavior.onDragStartObservable.add(() => {\r\n                        this.onDragStartObservable.notifyObservers({});\r\n                        this._selectNode(box);\r\n                        totalRelativeDragDistance = 0;\r\n                        previousScale = 0;\r\n                    });\r\n                    _dragBehavior.onDragEndObservable.add((event) => {\r\n                        this.onScaleBoxDragEndObservable.notifyObservers({});\r\n                        this._selectNode(null);\r\n                        this._updateDummy();\r\n                        this._unhoverMeshOnTouchUp(event.pointerInfo, box);\r\n                    });\r\n\r\n                    this._scaleBoxesParent.addChild(box);\r\n                }\r\n            }\r\n        }\r\n        this._rootMesh.addChild(this._scaleBoxesParent);\r\n\r\n        // Hover color change\r\n        const pointerIds = new Array<AbstractMesh>();\r\n        this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\r\n            if (!pointerIds[(<IPointerEvent>pointerInfo.event).pointerId]) {\r\n                this._rotateSpheresParent\r\n                    .getChildMeshes()\r\n                    .concat(this._scaleBoxesParent.getChildMeshes())\r\n                    .forEach((mesh) => {\r\n                        if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh == mesh) {\r\n                            pointerIds[(<IPointerEvent>pointerInfo.event).pointerId] = mesh;\r\n                            mesh.material = this._hoverColoredMaterial;\r\n                            this._isHovered = true;\r\n                        }\r\n                    });\r\n            } else {\r\n                if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh != pointerIds[(<IPointerEvent>pointerInfo.event).pointerId]) {\r\n                    pointerIds[(<IPointerEvent>pointerInfo.event).pointerId].material = this._coloredMaterial;\r\n                    delete pointerIds[(<IPointerEvent>pointerInfo.event).pointerId];\r\n                    this._isHovered = false;\r\n                }\r\n            }\r\n        });\r\n\r\n        // Update bounding box positions\r\n        this._renderObserver = this.gizmoLayer.originalScene.onBeforeRenderObservable.add(() => {\r\n            // Only update the bounding box if scaling has changed\r\n            if (this.attachedMesh && !this._existingMeshScale.equals(this.attachedMesh.scaling)) {\r\n                this.updateBoundingBox();\r\n            } else if (this.fixedDragMeshScreenSize || this.fixedDragMeshBoundsSize) {\r\n                this._updateRotationSpheres();\r\n                this._updateScaleBoxes();\r\n            }\r\n\r\n            // If drag mesh is enabled and dragging, update the attached mesh pose to match the drag mesh\r\n            if (this._dragMesh && this.attachedMesh && this._pointerDragBehavior.dragging) {\r\n                this._lineBoundingBox.position.rotateByQuaternionToRef(this._rootMesh.rotationQuaternion!, this._tmpVector);\r\n                this.attachedMesh.setAbsolutePosition(this._dragMesh.position.add(this._tmpVector.scale(-1)));\r\n            }\r\n        });\r\n        this.updateBoundingBox();\r\n    }\r\n\r\n    protected _attachedNodeChanged(value: Nullable<AbstractMesh>) {\r\n        if (value) {\r\n            // Reset anchor mesh to match attached mesh's scale\r\n            // This is needed to avoid invalid box/sphere position on first drag\r\n            this._anchorMesh.scaling.setAll(1);\r\n            PivotTools._RemoveAndStorePivotPoint(value);\r\n            const originalParent = value.parent;\r\n            this._anchorMesh.addChild(value);\r\n            this._anchorMesh.removeChild(value);\r\n            value.setParent(originalParent);\r\n            PivotTools._RestorePivotPoint(value);\r\n            this.updateBoundingBox();\r\n            value.getChildMeshes(false).forEach((m) => {\r\n                m.markAsDirty(\"scaling\");\r\n            });\r\n\r\n            this.gizmoLayer.utilityLayerScene.onAfterRenderObservable.addOnce(() => {\r\n                this._updateDummy();\r\n            });\r\n        }\r\n    }\r\n\r\n    protected _selectNode(selectedMesh: Nullable<Mesh>) {\r\n        this._rotateSpheresParent\r\n            .getChildMeshes()\r\n            .concat(this._scaleBoxesParent.getChildMeshes())\r\n            .forEach((m) => {\r\n                m.isVisible = !selectedMesh || m == selectedMesh;\r\n            });\r\n    }\r\n\r\n    protected _unhoverMeshOnTouchUp(pointerInfo: Nullable<PointerInfo>, selectedMesh: AbstractMesh) {\r\n        // force unhover mesh if not a mouse event\r\n        if (pointerInfo?.event instanceof PointerEvent && pointerInfo?.event.pointerType === \"touch\") {\r\n            selectedMesh.material = this._coloredMaterial;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * returns an array containing all boxes used for scaling (in increasing x, y and z orders)\r\n     */\r\n    public getScaleBoxes() {\r\n        return this._scaleBoxesParent.getChildMeshes();\r\n    }\r\n\r\n    /**\r\n     * Updates the bounding box information for the Gizmo\r\n     */\r\n    public updateBoundingBox() {\r\n        if (this.attachedMesh) {\r\n            PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);\r\n\r\n            // Store original parent\r\n            const originalParent = this.attachedMesh.parent;\r\n            this.attachedMesh.setParent(null);\r\n\r\n            this._update();\r\n\r\n            // Rotate based on axis\r\n            if (!this.attachedMesh.rotationQuaternion) {\r\n                this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);\r\n            }\r\n            if (!this._anchorMesh.rotationQuaternion) {\r\n                this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._anchorMesh.rotation.y, this._anchorMesh.rotation.x, this._anchorMesh.rotation.z);\r\n            }\r\n            this._anchorMesh.rotationQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);\r\n\r\n            // Store original position and reset mesh to origin before computing the bounding box\r\n            this._tmpQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);\r\n            this._tmpVector.copyFrom(this.attachedMesh.position);\r\n            this.attachedMesh.rotationQuaternion.set(0, 0, 0, 1);\r\n            this.attachedMesh.position.set(0, 0, 0);\r\n\r\n            // Update bounding dimensions/positions\r\n            const boundingMinMax = this.attachedMesh.getHierarchyBoundingVectors(!this.ignoreChildren, this.includeChildPredicate);\r\n            boundingMinMax.max.subtractToRef(boundingMinMax.min, this._boundingDimensions);\r\n\r\n            // Update gizmo to match bounding box scaling and rotation\r\n            // The position set here is the offset from the origin for the boundingbox when the attached mesh is at the origin\r\n            // The position of the gizmo is then set to the attachedMesh in gizmo._update\r\n            this._lineBoundingBox.scaling.copyFrom(this._boundingDimensions);\r\n            this._lineBoundingBox.position.set(\r\n                (boundingMinMax.max.x + boundingMinMax.min.x) / 2,\r\n                (boundingMinMax.max.y + boundingMinMax.min.y) / 2,\r\n                (boundingMinMax.max.z + boundingMinMax.min.z) / 2\r\n            );\r\n            this._rotateSpheresParent.position.copyFrom(this._lineBoundingBox.position);\r\n            this._scaleBoxesParent.position.copyFrom(this._lineBoundingBox.position);\r\n            this._lineBoundingBox.computeWorldMatrix();\r\n            this._anchorMesh.position.copyFrom(this._lineBoundingBox.absolutePosition);\r\n\r\n            // Restore position/rotation values\r\n            this.attachedMesh.rotationQuaternion.copyFrom(this._tmpQuaternion);\r\n            this.attachedMesh.position.copyFrom(this._tmpVector);\r\n\r\n            // Restore original parent\r\n            this.attachedMesh.setParent(originalParent);\r\n        }\r\n\r\n        this._updateRotationSpheres();\r\n        this._updateScaleBoxes();\r\n\r\n        if (this.attachedMesh) {\r\n            this._existingMeshScale.copyFrom(this.attachedMesh.scaling);\r\n            PivotTools._RestorePivotPoint(this.attachedMesh);\r\n        }\r\n    }\r\n\r\n    protected _updateRotationSpheres() {\r\n        const rotateSpheres = this._rotateSpheresParent.getChildMeshes();\r\n        for (let i = 0; i < 3; i++) {\r\n            for (let j = 0; j < 2; j++) {\r\n                for (let k = 0; k < 2; k++) {\r\n                    const index = i * 4 + j * 2 + k;\r\n                    if (i == 0) {\r\n                        rotateSpheres[index].position.set(this._boundingDimensions.x / 2, this._boundingDimensions.y * j, this._boundingDimensions.z * k);\r\n                        rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\r\n                        rotateSpheres[index].lookAt(\r\n                            Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Right()).normalizeToNew().add(rotateSpheres[index].position)\r\n                        );\r\n                    }\r\n                    if (i == 1) {\r\n                        rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y / 2, this._boundingDimensions.z * k);\r\n                        rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\r\n                        rotateSpheres[index].lookAt(\r\n                            Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Up()).normalizeToNew().add(rotateSpheres[index].position)\r\n                        );\r\n                    }\r\n                    if (i == 2) {\r\n                        rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y * k, this._boundingDimensions.z / 2);\r\n                        rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\r\n                        rotateSpheres[index].lookAt(\r\n                            Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Forward()).normalizeToNew().add(rotateSpheres[index].position)\r\n                        );\r\n                    }\r\n                    if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {\r\n                        rotateSpheres[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);\r\n                        const distanceFromCamera = (this.rotationSphereSize * this._tmpVector.length()) / this.fixedDragMeshScreenSizeDistanceFactor;\r\n                        rotateSpheres[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);\r\n                    } else if (this.fixedDragMeshBoundsSize) {\r\n                        rotateSpheres[index].scaling.set(\r\n                            this.rotationSphereSize * this._boundingDimensions.x,\r\n                            this.rotationSphereSize * this._boundingDimensions.y,\r\n                            this.rotationSphereSize * this._boundingDimensions.z\r\n                        );\r\n                    } else {\r\n                        rotateSpheres[index].scaling.set(this.rotationSphereSize, this.rotationSphereSize, this.rotationSphereSize);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _updateScaleBoxes() {\r\n        const scaleBoxes = this._scaleBoxesParent.getChildMeshes();\r\n        let index = 0;\r\n        for (let i = 0; i < 3; i++) {\r\n            for (let j = 0; j < 3; j++) {\r\n                for (let k = 0; k < 3; k++) {\r\n                    const zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);\r\n                    if (zeroAxisCount === 1 || zeroAxisCount === 3) {\r\n                        continue;\r\n                    }\r\n                    if (scaleBoxes[index]) {\r\n                        scaleBoxes[index].position.set(this._boundingDimensions.x * (i / 2), this._boundingDimensions.y * (j / 2), this._boundingDimensions.z * (k / 2));\r\n                        scaleBoxes[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\r\n                        if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {\r\n                            scaleBoxes[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);\r\n                            const distanceFromCamera = (this.scaleBoxSize * this._tmpVector.length()) / this.fixedDragMeshScreenSizeDistanceFactor;\r\n                            scaleBoxes[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);\r\n                        } else if (this.fixedDragMeshBoundsSize) {\r\n                            scaleBoxes[index].scaling.set(\r\n                                this.scaleBoxSize * this._boundingDimensions.x,\r\n                                this.scaleBoxSize * this._boundingDimensions.y,\r\n                                this.scaleBoxSize * this._boundingDimensions.z\r\n                            );\r\n                        } else {\r\n                            scaleBoxes[index].scaling.set(this.scaleBoxSize, this.scaleBoxSize, this.scaleBoxSize);\r\n                        }\r\n                    }\r\n                    index++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables rotation on the specified axis and disables rotation on the others\r\n     * @param axis The list of axis that should be enabled (eg. \"xy\" or \"xyz\")\r\n     */\r\n    public setEnabledRotationAxis(axis: string) {\r\n        this._rotateSpheresParent.getChildMeshes().forEach((m, i) => {\r\n            if (i < 4) {\r\n                m.setEnabled(axis.indexOf(\"x\") != -1);\r\n            } else if (i < 8) {\r\n                m.setEnabled(axis.indexOf(\"y\") != -1);\r\n            } else {\r\n                m.setEnabled(axis.indexOf(\"z\") != -1);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Enables/disables scaling\r\n     * @param enable if scaling should be enabled\r\n     * @param homogeneousScaling defines if scaling should only be homogeneous\r\n     */\r\n    public setEnabledScaling(enable: boolean, homogeneousScaling = false) {\r\n        this._scaleBoxesParent.getChildMeshes().forEach((m) => {\r\n            let enableMesh = enable;\r\n            // Disable heterogeneous scale handles if requested.\r\n            if (homogeneousScaling && m._internalMetadata === true) {\r\n                enableMesh = false;\r\n            }\r\n            m.setEnabled(enableMesh);\r\n        });\r\n    }\r\n\r\n    protected _updateDummy() {\r\n        if (this._dragMesh) {\r\n            this._dragMesh.position.copyFrom(this._lineBoundingBox.getAbsolutePosition());\r\n            this._dragMesh.scaling.copyFrom(this._lineBoundingBox.scaling);\r\n            this._dragMesh.rotationQuaternion!.copyFrom(this._rootMesh.rotationQuaternion!);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables a pointer drag behavior on the bounding box of the gizmo\r\n     */\r\n    public enableDragBehavior() {\r\n        this._dragMesh = CreateBox(\"dummy\", { size: 1 }, this.gizmoLayer.utilityLayerScene);\r\n        this._dragMesh.visibility = 0;\r\n        this._dragMesh.rotationQuaternion = new Quaternion();\r\n        this._pointerDragBehavior.useObjectOrientationForDragging = false;\r\n        this._dragMesh.addBehavior(this._pointerDragBehavior);\r\n    }\r\n\r\n    /**\r\n     * Disposes of the gizmo\r\n     */\r\n    public dispose() {\r\n        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\r\n        this.gizmoLayer.originalScene.onBeforeRenderObservable.remove(this._renderObserver);\r\n        this._lineBoundingBox.dispose();\r\n        this._rotateSpheresParent.dispose();\r\n        this._scaleBoxesParent.dispose();\r\n        if (this._dragMesh) {\r\n            this._dragMesh.dispose();\r\n        }\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Makes a mesh not pickable and wraps the mesh inside of a bounding box mesh that is pickable. (This is useful to avoid picking within complex geometry)\r\n     * @param mesh the mesh to wrap in the bounding box mesh and make not pickable\r\n     * @returns the bounding box mesh with the passed in mesh as a child\r\n     */\r\n    public static MakeNotPickableAndWrapInBoundingBox(mesh: Mesh): Mesh {\r\n        const makeNotPickable = (root: AbstractMesh) => {\r\n            root.isPickable = false;\r\n            root.getChildMeshes().forEach((c) => {\r\n                makeNotPickable(c);\r\n            });\r\n        };\r\n        makeNotPickable(mesh);\r\n\r\n        // Reset position to get bounding box from origin with no rotation\r\n        if (!mesh.rotationQuaternion) {\r\n            mesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(mesh.rotation.y, mesh.rotation.x, mesh.rotation.z);\r\n        }\r\n        const oldPos = mesh.position.clone();\r\n        const oldRot = mesh.rotationQuaternion.clone();\r\n        mesh.rotationQuaternion.set(0, 0, 0, 1);\r\n        mesh.position.set(0, 0, 0);\r\n\r\n        // Update bounding dimensions/positions\r\n        const box = CreateBox(\"box\", { size: 1 }, mesh.getScene());\r\n        const boundingMinMax = mesh.getHierarchyBoundingVectors();\r\n        boundingMinMax.max.subtractToRef(boundingMinMax.min, box.scaling);\r\n\r\n        // Adjust scale to avoid undefined behavior when adding child\r\n        if (box.scaling.y === 0) {\r\n            box.scaling.y = Epsilon;\r\n        }\r\n        if (box.scaling.x === 0) {\r\n            box.scaling.x = Epsilon;\r\n        }\r\n        if (box.scaling.z === 0) {\r\n            box.scaling.z = Epsilon;\r\n        }\r\n\r\n        box.position.set((boundingMinMax.max.x + boundingMinMax.min.x) / 2, (boundingMinMax.max.y + boundingMinMax.min.y) / 2, (boundingMinMax.max.z + boundingMinMax.min.z) / 2);\r\n\r\n        // Restore original positions\r\n        mesh.addChild(box);\r\n        mesh.rotationQuaternion.copyFrom(oldRot);\r\n        mesh.position.copyFrom(oldPos);\r\n\r\n        // Reverse parenting\r\n        mesh.removeChild(box);\r\n\r\n        box.addChild(mesh);\r\n        box.visibility = 0;\r\n        return box;\r\n    }\r\n    /**\r\n     * CustomMeshes are not supported by this gizmo\r\n     */\r\n    public setCustomMesh() {\r\n        Logger.Error(\"Custom meshes are not supported on this gizmo\");\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}