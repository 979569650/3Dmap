{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Tools } from \"../Misc/tools.js\";\n/**\n * A list of the currently available features without referencing them\n */\nexport class WebXRFeatureName {}\n/**\n * The name of the anchor system feature\n */\nWebXRFeatureName.ANCHOR_SYSTEM = \"xr-anchor-system\";\n/**\n * The name of the background remover feature\n */\nWebXRFeatureName.BACKGROUND_REMOVER = \"xr-background-remover\";\n/**\n * The name of the hit test feature\n */\nWebXRFeatureName.HIT_TEST = \"xr-hit-test\";\n/**\n * The name of the mesh detection feature\n */\nWebXRFeatureName.MESH_DETECTION = \"xr-mesh-detection\";\n/**\n * physics impostors for xr controllers feature\n */\nWebXRFeatureName.PHYSICS_CONTROLLERS = \"xr-physics-controller\";\n/**\n * The name of the plane detection feature\n */\nWebXRFeatureName.PLANE_DETECTION = \"xr-plane-detection\";\n/**\n * The name of the pointer selection feature\n */\nWebXRFeatureName.POINTER_SELECTION = \"xr-controller-pointer-selection\";\n/**\n * The name of the teleportation feature\n */\nWebXRFeatureName.TELEPORTATION = \"xr-controller-teleportation\";\n/**\n * The name of the feature points feature.\n */\nWebXRFeatureName.FEATURE_POINTS = \"xr-feature-points\";\n/**\n * The name of the hand tracking feature.\n */\nWebXRFeatureName.HAND_TRACKING = \"xr-hand-tracking\";\n/**\n * The name of the image tracking feature\n */\nWebXRFeatureName.IMAGE_TRACKING = \"xr-image-tracking\";\n/**\n * The name of the near interaction feature\n */\nWebXRFeatureName.NEAR_INTERACTION = \"xr-near-interaction\";\n/**\n * The name of the DOM overlay feature\n */\nWebXRFeatureName.DOM_OVERLAY = \"xr-dom-overlay\";\n/**\n * The name of the movement feature\n */\nWebXRFeatureName.MOVEMENT = \"xr-controller-movement\";\n/**\n * The name of the light estimation feature\n */\nWebXRFeatureName.LIGHT_ESTIMATION = \"xr-light-estimation\";\n/**\n * The name of the eye tracking feature\n */\nWebXRFeatureName.EYE_TRACKING = \"xr-eye-tracking\";\n/**\n * The name of the walking locomotion feature\n */\nWebXRFeatureName.WALKING_LOCOMOTION = \"xr-walking-locomotion\";\n/**\n * The name of the composition layers feature\n */\nWebXRFeatureName.LAYERS = \"xr-layers\";\n/**\n * The name of the depth sensing feature\n */\nWebXRFeatureName.DEPTH_SENSING = \"xr-depth-sensing\";\n/**\n * The name of the WebXR Space Warp feature\n */\nWebXRFeatureName.SPACE_WARP = \"xr-space-warp\";\n/**\n * The WebXR features manager is responsible of enabling or disabling features required for the current XR session.\n * It is mainly used in AR sessions.\n *\n * A feature can have a version that is defined by Babylon (and does not correspond with the webxr version).\n */\nexport class WebXRFeaturesManager {\n  /**\n   * constructs a new features manages.\n   *\n   * @param _xrSessionManager an instance of WebXRSessionManager\n   */\n  constructor(_xrSessionManager) {\n    this._xrSessionManager = _xrSessionManager;\n    this._features = {};\n    // when session starts / initialized - attach\n    this._xrSessionManager.onXRSessionInit.add(() => {\n      this.getEnabledFeatures().forEach(featureName => {\n        const feature = this._features[featureName];\n        if (feature.enabled && !feature.featureImplementation.attached && !feature.featureImplementation.disableAutoAttach) {\n          this.attachFeature(featureName);\n        }\n      });\n    });\n    // when session ends - detach\n    this._xrSessionManager.onXRSessionEnded.add(() => {\n      this.getEnabledFeatures().forEach(featureName => {\n        const feature = this._features[featureName];\n        if (feature.enabled && feature.featureImplementation.attached) {\n          // detach, but don't disable!\n          this.detachFeature(featureName);\n        }\n      });\n    });\n  }\n  /**\n   * Used to register a module. After calling this function a developer can use this feature in the scene.\n   * Mainly used internally.\n   *\n   * @param featureName the name of the feature to register\n   * @param constructorFunction the function used to construct the module\n   * @param version the (babylon) version of the module\n   * @param stable is that a stable version of this module\n   */\n  static AddWebXRFeature(featureName, constructorFunction, version = 1, stable = false) {\n    this._AvailableFeatures[featureName] = this._AvailableFeatures[featureName] || {\n      latest: version\n    };\n    if (version > this._AvailableFeatures[featureName].latest) {\n      this._AvailableFeatures[featureName].latest = version;\n    }\n    if (stable) {\n      this._AvailableFeatures[featureName].stable = version;\n    }\n    this._AvailableFeatures[featureName][version] = constructorFunction;\n  }\n  /**\n   * Returns a constructor of a specific feature.\n   *\n   * @param featureName the name of the feature to construct\n   * @param version the version of the feature to load\n   * @param xrSessionManager the xrSessionManager. Used to construct the module\n   * @param options optional options provided to the module.\n   * @returns a function that, when called, will return a new instance of this feature\n   */\n  static ConstructFeature(featureName, version = 1, xrSessionManager, options) {\n    const constructorFunction = this._AvailableFeatures[featureName][version];\n    if (!constructorFunction) {\n      // throw an error? return nothing?\n      throw new Error(\"feature not found\");\n    }\n    return constructorFunction(xrSessionManager, options);\n  }\n  /**\n   * Can be used to return the list of features currently registered\n   *\n   * @returns an Array of available features\n   */\n  static GetAvailableFeatures() {\n    return Object.keys(this._AvailableFeatures);\n  }\n  /**\n   * Gets the versions available for a specific feature\n   * @param featureName the name of the feature\n   * @returns an array with the available versions\n   */\n  static GetAvailableVersions(featureName) {\n    return Object.keys(this._AvailableFeatures[featureName]);\n  }\n  /**\n   * Return the latest unstable version of this feature\n   * @param featureName the name of the feature to search\n   * @returns the version number. if not found will return -1\n   */\n  static GetLatestVersionOfFeature(featureName) {\n    return this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].latest || -1;\n  }\n  /**\n   * Return the latest stable version of this feature\n   * @param featureName the name of the feature to search\n   * @returns the version number. if not found will return -1\n   */\n  static GetStableVersionOfFeature(featureName) {\n    return this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].stable || -1;\n  }\n  /**\n   * Attach a feature to the current session. Mainly used when session started to start the feature effect.\n   * Can be used during a session to start a feature\n   * @param featureName the name of feature to attach\n   */\n  attachFeature(featureName) {\n    const feature = this._features[featureName];\n    if (feature && feature.enabled && !feature.featureImplementation.attached) {\n      feature.featureImplementation.attach();\n    }\n  }\n  /**\n   * Can be used inside a session or when the session ends to detach a specific feature\n   * @param featureName the name of the feature to detach\n   */\n  detachFeature(featureName) {\n    const feature = this._features[featureName];\n    if (feature && feature.featureImplementation.attached) {\n      feature.featureImplementation.detach();\n    }\n  }\n  /**\n   * Used to disable an already-enabled feature\n   * The feature will be disposed and will be recreated once enabled.\n   * @param featureName the feature to disable\n   * @returns true if disable was successful\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  disableFeature(featureName) {\n    const name = typeof featureName === \"string\" ? featureName : featureName.Name;\n    const feature = this._features[name];\n    if (feature && feature.enabled) {\n      feature.enabled = false;\n      this.detachFeature(name);\n      feature.featureImplementation.dispose();\n      delete this._features[name];\n      return true;\n    }\n    return false;\n  }\n  /**\n   * dispose this features manager\n   */\n  dispose() {\n    this.getEnabledFeatures().forEach(feature => {\n      this.disableFeature(feature);\n    });\n  }\n  /**\n   * Enable a feature using its name and a version. This will enable it in the scene, and will be responsible to attach it when the session starts.\n   * If used twice, the old version will be disposed and a new one will be constructed. This way you can re-enable with different configuration.\n   *\n   * @param featureName the name of the feature to load or the class of the feature\n   * @param version optional version to load. if not provided the latest version will be enabled\n   * @param moduleOptions options provided to the module. Ses the module documentation / constructor\n   * @param attachIfPossible if set to true (default) the feature will be automatically attached, if it is currently possible\n   * @param required is this feature required to the app. If set to true the session init will fail if the feature is not available.\n   * @returns a new constructed feature or throws an error if feature not found or conflicts with another enabled feature.\n   */\n  enableFeature(\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  featureName, version = \"latest\", moduleOptions = {}, attachIfPossible = true, required = true) {\n    const name = typeof featureName === \"string\" ? featureName : featureName.Name;\n    let versionToLoad = 0;\n    if (typeof version === \"string\") {\n      if (!version) {\n        throw new Error(`Error in provided version - ${name} (${version})`);\n      }\n      if (version === \"stable\") {\n        versionToLoad = WebXRFeaturesManager.GetStableVersionOfFeature(name);\n      } else if (version === \"latest\") {\n        versionToLoad = WebXRFeaturesManager.GetLatestVersionOfFeature(name);\n      } else {\n        // try loading the number the string represents\n        versionToLoad = +version;\n      }\n      if (versionToLoad === -1 || isNaN(versionToLoad)) {\n        throw new Error(`feature not found - ${name} (${version})`);\n      }\n    } else {\n      versionToLoad = version;\n    }\n    // check if there is a feature conflict\n    const conflictingFeature = WebXRFeaturesManager._ConflictingFeatures[name];\n    if (conflictingFeature !== undefined && this.getEnabledFeatures().indexOf(conflictingFeature) !== -1) {\n      throw new Error(`Feature ${name} cannot be enabled while ${conflictingFeature} is enabled.`);\n    }\n    // check if already initialized\n    const feature = this._features[name];\n    const constructFunction = WebXRFeaturesManager.ConstructFeature(name, versionToLoad, this._xrSessionManager, moduleOptions);\n    if (!constructFunction) {\n      // report error?\n      throw new Error(`feature not found - ${name}`);\n    }\n    /* If the feature is already enabled, detach and dispose it, and create a new one */\n    if (feature) {\n      this.disableFeature(name);\n    }\n    const constructed = constructFunction();\n    if (constructed.dependsOn) {\n      const dependentsFound = constructed.dependsOn.every(featureName => !!this._features[featureName]);\n      if (!dependentsFound) {\n        throw new Error(`Dependant features missing. Make sure the following features are enabled - ${constructed.dependsOn.join(\", \")}`);\n      }\n    }\n    if (constructed.isCompatible()) {\n      this._features[name] = {\n        featureImplementation: constructed,\n        enabled: true,\n        version: versionToLoad,\n        required\n      };\n      if (attachIfPossible) {\n        // if session started already, request and enable\n        if (this._xrSessionManager.session && !this._features[name].featureImplementation.attached) {\n          // enable feature\n          this.attachFeature(name);\n        }\n      } else {\n        // disable auto-attach when session starts\n        this._features[name].featureImplementation.disableAutoAttach = true;\n      }\n      return this._features[name].featureImplementation;\n    } else {\n      if (required) {\n        throw new Error(\"required feature not compatible\");\n      } else {\n        Tools.Warn(`Feature ${name} not compatible with the current environment/browser and was not enabled.`);\n        return constructed;\n      }\n    }\n  }\n  /**\n   * get the implementation of an enabled feature.\n   * @param featureName the name of the feature to load\n   * @returns the feature class, if found\n   */\n  getEnabledFeature(featureName) {\n    return this._features[featureName] && this._features[featureName].featureImplementation;\n  }\n  /**\n   * Get the list of enabled features\n   * @returns an array of enabled features\n   */\n  getEnabledFeatures() {\n    return Object.keys(this._features);\n  }\n  /**\n   * This function will extend the session creation configuration object with enabled features.\n   * If, for example, the anchors feature is enabled, it will be automatically added to the optional or required features list,\n   * according to the defined \"required\" variable, provided during enableFeature call\n   * @param xrSessionInit the xr Session init object to extend\n   *\n   * @returns an extended XRSessionInit object\n   */\n  async _extendXRSessionInitObject(xrSessionInit) {\n    const enabledFeatures = this.getEnabledFeatures();\n    for (const featureName of enabledFeatures) {\n      const feature = this._features[featureName];\n      const nativeName = feature.featureImplementation.xrNativeFeatureName;\n      if (nativeName) {\n        if (feature.required) {\n          xrSessionInit.requiredFeatures = xrSessionInit.requiredFeatures || [];\n          if (xrSessionInit.requiredFeatures.indexOf(nativeName) === -1) {\n            xrSessionInit.requiredFeatures.push(nativeName);\n          }\n        } else {\n          xrSessionInit.optionalFeatures = xrSessionInit.optionalFeatures || [];\n          if (xrSessionInit.optionalFeatures.indexOf(nativeName) === -1) {\n            xrSessionInit.optionalFeatures.push(nativeName);\n          }\n        }\n      }\n      if (feature.featureImplementation.getXRSessionInitExtension) {\n        const extended = await feature.featureImplementation.getXRSessionInitExtension();\n        xrSessionInit = Object.assign(Object.assign({}, xrSessionInit), extended);\n      }\n    }\n    return xrSessionInit;\n  }\n}\nWebXRFeaturesManager._AvailableFeatures = {};\n/**\n * The key is the feature to check and the value is the feature that conflicts.\n */\nWebXRFeaturesManager._ConflictingFeatures = {\n  [WebXRFeatureName.TELEPORTATION]: WebXRFeatureName.MOVEMENT,\n  [WebXRFeatureName.MOVEMENT]: WebXRFeatureName.TELEPORTATION\n};","map":{"version":3,"names":["Tools","WebXRFeatureName","ANCHOR_SYSTEM","BACKGROUND_REMOVER","HIT_TEST","MESH_DETECTION","PHYSICS_CONTROLLERS","PLANE_DETECTION","POINTER_SELECTION","TELEPORTATION","FEATURE_POINTS","HAND_TRACKING","IMAGE_TRACKING","NEAR_INTERACTION","DOM_OVERLAY","MOVEMENT","LIGHT_ESTIMATION","EYE_TRACKING","WALKING_LOCOMOTION","LAYERS","DEPTH_SENSING","SPACE_WARP","WebXRFeaturesManager","constructor","_xrSessionManager","_features","onXRSessionInit","add","getEnabledFeatures","forEach","featureName","feature","enabled","featureImplementation","attached","disableAutoAttach","attachFeature","onXRSessionEnded","detachFeature","AddWebXRFeature","constructorFunction","version","stable","_AvailableFeatures","latest","ConstructFeature","xrSessionManager","options","Error","GetAvailableFeatures","Object","keys","GetAvailableVersions","GetLatestVersionOfFeature","GetStableVersionOfFeature","attach","detach","disableFeature","name","Name","dispose","enableFeature","moduleOptions","attachIfPossible","required","versionToLoad","isNaN","conflictingFeature","_ConflictingFeatures","undefined","indexOf","constructFunction","constructed","dependsOn","dependentsFound","every","join","isCompatible","session","Warn","getEnabledFeature","_extendXRSessionInitObject","xrSessionInit","enabledFeatures","nativeName","xrNativeFeatureName","requiredFeatures","push","optionalFeatures","getXRSessionInitExtension","extended","assign"],"sources":["../../../../dev/core/src/XR/webXRFeaturesManager.ts"],"sourcesContent":["import type { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport type { IDisposable } from \"../scene\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\n/**\r\n * Defining the interface required for a (webxr) feature\r\n */\r\nexport interface IWebXRFeature extends IDisposable {\r\n    /**\r\n     * Is this feature attached\r\n     */\r\n    attached: boolean;\r\n    /**\r\n     * Should auto-attach be disabled?\r\n     */\r\n    disableAutoAttach: boolean;\r\n\r\n    /**\r\n     * Attach the feature to the session\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @param force should attachment be forced (even when already attached)\r\n     * @returns true if successful.\r\n     */\r\n    attach(force?: boolean): boolean;\r\n    /**\r\n     * Detach the feature from the session\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    detach(): boolean;\r\n\r\n    /**\r\n     * This function will be executed during before enabling the feature and can be used to not-allow enabling it.\r\n     * Note that at this point the session has NOT started, so this is purely checking if the browser supports it\r\n     *\r\n     * @returns whether or not the feature is compatible in this environment\r\n     */\r\n    isCompatible(): boolean;\r\n\r\n    /**\r\n     * Was this feature disposed;\r\n     */\r\n    isDisposed: boolean;\r\n\r\n    /**\r\n     * The name of the native xr feature name, if applicable (like anchor, hit-test, or hand-tracking)\r\n     */\r\n    xrNativeFeatureName?: string;\r\n\r\n    /**\r\n     * A list of (Babylon WebXR) features this feature depends on\r\n     */\r\n    dependsOn?: string[];\r\n\r\n    /**\r\n     * If this feature requires to extend the XRSessionInit object, this function will return the partial XR session init object\r\n     */\r\n    getXRSessionInitExtension?: () => Promise<Partial<XRSessionInit>>;\r\n}\r\n\r\n/**\r\n * A list of the currently available features without referencing them\r\n */\r\nexport class WebXRFeatureName {\r\n    /**\r\n     * The name of the anchor system feature\r\n     */\r\n    public static readonly ANCHOR_SYSTEM = \"xr-anchor-system\";\r\n    /**\r\n     * The name of the background remover feature\r\n     */\r\n    public static readonly BACKGROUND_REMOVER = \"xr-background-remover\";\r\n    /**\r\n     * The name of the hit test feature\r\n     */\r\n    public static readonly HIT_TEST = \"xr-hit-test\";\r\n    /**\r\n     * The name of the mesh detection feature\r\n     */\r\n    public static readonly MESH_DETECTION = \"xr-mesh-detection\";\r\n    /**\r\n     * physics impostors for xr controllers feature\r\n     */\r\n    public static readonly PHYSICS_CONTROLLERS = \"xr-physics-controller\";\r\n    /**\r\n     * The name of the plane detection feature\r\n     */\r\n    public static readonly PLANE_DETECTION = \"xr-plane-detection\";\r\n    /**\r\n     * The name of the pointer selection feature\r\n     */\r\n    public static readonly POINTER_SELECTION = \"xr-controller-pointer-selection\";\r\n    /**\r\n     * The name of the teleportation feature\r\n     */\r\n    public static readonly TELEPORTATION = \"xr-controller-teleportation\";\r\n    /**\r\n     * The name of the feature points feature.\r\n     */\r\n    public static readonly FEATURE_POINTS = \"xr-feature-points\";\r\n    /**\r\n     * The name of the hand tracking feature.\r\n     */\r\n    public static readonly HAND_TRACKING = \"xr-hand-tracking\";\r\n    /**\r\n     * The name of the image tracking feature\r\n     */\r\n    public static readonly IMAGE_TRACKING = \"xr-image-tracking\";\r\n    /**\r\n     * The name of the near interaction feature\r\n     */\r\n    public static readonly NEAR_INTERACTION = \"xr-near-interaction\";\r\n    /**\r\n     * The name of the DOM overlay feature\r\n     */\r\n    public static readonly DOM_OVERLAY = \"xr-dom-overlay\";\r\n    /**\r\n     * The name of the movement feature\r\n     */\r\n    public static readonly MOVEMENT = \"xr-controller-movement\";\r\n    /**\r\n     * The name of the light estimation feature\r\n     */\r\n    public static readonly LIGHT_ESTIMATION = \"xr-light-estimation\";\r\n    /**\r\n     * The name of the eye tracking feature\r\n     */\r\n    public static readonly EYE_TRACKING = \"xr-eye-tracking\";\r\n    /**\r\n     * The name of the walking locomotion feature\r\n     */\r\n    public static readonly WALKING_LOCOMOTION = \"xr-walking-locomotion\";\r\n    /**\r\n     * The name of the composition layers feature\r\n     */\r\n    public static readonly LAYERS = \"xr-layers\";\r\n    /**\r\n     * The name of the depth sensing feature\r\n     */\r\n    public static readonly DEPTH_SENSING = \"xr-depth-sensing\";\r\n    /**\r\n     * The name of the WebXR Space Warp feature\r\n     */\r\n    public static readonly SPACE_WARP = \"xr-space-warp\";\r\n}\r\n\r\n/**\r\n * Defining the constructor of a feature. Used to register the modules.\r\n */\r\nexport type WebXRFeatureConstructor = (xrSessionManager: WebXRSessionManager, options?: any) => () => IWebXRFeature;\r\n\r\n/**\r\n * The WebXR features manager is responsible of enabling or disabling features required for the current XR session.\r\n * It is mainly used in AR sessions.\r\n *\r\n * A feature can have a version that is defined by Babylon (and does not correspond with the webxr version).\r\n */\r\nexport class WebXRFeaturesManager implements IDisposable {\r\n    private static readonly _AvailableFeatures: {\r\n        [name: string]: {\r\n            stable: number;\r\n            latest: number;\r\n            [version: number]: WebXRFeatureConstructor;\r\n        };\r\n    } = {};\r\n\r\n    private _features: {\r\n        [name: string]: {\r\n            featureImplementation: IWebXRFeature;\r\n            version: number;\r\n            enabled: boolean;\r\n            required: boolean;\r\n        };\r\n    } = {};\r\n\r\n    /**\r\n     * The key is the feature to check and the value is the feature that conflicts.\r\n     */\r\n    private static readonly _ConflictingFeatures: { [key: string]: string } = {\r\n        [WebXRFeatureName.TELEPORTATION]: WebXRFeatureName.MOVEMENT,\r\n        [WebXRFeatureName.MOVEMENT]: WebXRFeatureName.TELEPORTATION,\r\n    };\r\n\r\n    /**\r\n     * constructs a new features manages.\r\n     *\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     */\r\n    constructor(private _xrSessionManager: WebXRSessionManager) {\r\n        // when session starts / initialized - attach\r\n        this._xrSessionManager.onXRSessionInit.add(() => {\r\n            this.getEnabledFeatures().forEach((featureName) => {\r\n                const feature = this._features[featureName];\r\n                if (feature.enabled && !feature.featureImplementation.attached && !feature.featureImplementation.disableAutoAttach) {\r\n                    this.attachFeature(featureName);\r\n                }\r\n            });\r\n        });\r\n\r\n        // when session ends - detach\r\n        this._xrSessionManager.onXRSessionEnded.add(() => {\r\n            this.getEnabledFeatures().forEach((featureName) => {\r\n                const feature = this._features[featureName];\r\n                if (feature.enabled && feature.featureImplementation.attached) {\r\n                    // detach, but don't disable!\r\n                    this.detachFeature(featureName);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Used to register a module. After calling this function a developer can use this feature in the scene.\r\n     * Mainly used internally.\r\n     *\r\n     * @param featureName the name of the feature to register\r\n     * @param constructorFunction the function used to construct the module\r\n     * @param version the (babylon) version of the module\r\n     * @param stable is that a stable version of this module\r\n     */\r\n    public static AddWebXRFeature(featureName: string, constructorFunction: WebXRFeatureConstructor, version: number = 1, stable: boolean = false) {\r\n        this._AvailableFeatures[featureName] = this._AvailableFeatures[featureName] || { latest: version };\r\n        if (version > this._AvailableFeatures[featureName].latest) {\r\n            this._AvailableFeatures[featureName].latest = version;\r\n        }\r\n        if (stable) {\r\n            this._AvailableFeatures[featureName].stable = version;\r\n        }\r\n        this._AvailableFeatures[featureName][version] = constructorFunction;\r\n    }\r\n\r\n    /**\r\n     * Returns a constructor of a specific feature.\r\n     *\r\n     * @param featureName the name of the feature to construct\r\n     * @param version the version of the feature to load\r\n     * @param xrSessionManager the xrSessionManager. Used to construct the module\r\n     * @param options optional options provided to the module.\r\n     * @returns a function that, when called, will return a new instance of this feature\r\n     */\r\n    public static ConstructFeature(featureName: string, version: number = 1, xrSessionManager: WebXRSessionManager, options?: any): () => IWebXRFeature {\r\n        const constructorFunction = this._AvailableFeatures[featureName][version];\r\n        if (!constructorFunction) {\r\n            // throw an error? return nothing?\r\n            throw new Error(\"feature not found\");\r\n        }\r\n\r\n        return constructorFunction(xrSessionManager, options);\r\n    }\r\n\r\n    /**\r\n     * Can be used to return the list of features currently registered\r\n     *\r\n     * @returns an Array of available features\r\n     */\r\n    public static GetAvailableFeatures() {\r\n        return Object.keys(this._AvailableFeatures);\r\n    }\r\n\r\n    /**\r\n     * Gets the versions available for a specific feature\r\n     * @param featureName the name of the feature\r\n     * @returns an array with the available versions\r\n     */\r\n    public static GetAvailableVersions(featureName: string) {\r\n        return Object.keys(this._AvailableFeatures[featureName]);\r\n    }\r\n\r\n    /**\r\n     * Return the latest unstable version of this feature\r\n     * @param featureName the name of the feature to search\r\n     * @returns the version number. if not found will return -1\r\n     */\r\n    public static GetLatestVersionOfFeature(featureName: string): number {\r\n        return (this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].latest) || -1;\r\n    }\r\n\r\n    /**\r\n     * Return the latest stable version of this feature\r\n     * @param featureName the name of the feature to search\r\n     * @returns the version number. if not found will return -1\r\n     */\r\n    public static GetStableVersionOfFeature(featureName: string): number {\r\n        return (this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].stable) || -1;\r\n    }\r\n\r\n    /**\r\n     * Attach a feature to the current session. Mainly used when session started to start the feature effect.\r\n     * Can be used during a session to start a feature\r\n     * @param featureName the name of feature to attach\r\n     */\r\n    public attachFeature(featureName: string) {\r\n        const feature = this._features[featureName];\r\n        if (feature && feature.enabled && !feature.featureImplementation.attached) {\r\n            feature.featureImplementation.attach();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Can be used inside a session or when the session ends to detach a specific feature\r\n     * @param featureName the name of the feature to detach\r\n     */\r\n    public detachFeature(featureName: string) {\r\n        const feature = this._features[featureName];\r\n        if (feature && feature.featureImplementation.attached) {\r\n            feature.featureImplementation.detach();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Used to disable an already-enabled feature\r\n     * The feature will be disposed and will be recreated once enabled.\r\n     * @param featureName the feature to disable\r\n     * @returns true if disable was successful\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public disableFeature(featureName: string | { Name: string }): boolean {\r\n        const name = typeof featureName === \"string\" ? featureName : featureName.Name;\r\n        const feature = this._features[name];\r\n        if (feature && feature.enabled) {\r\n            feature.enabled = false;\r\n            this.detachFeature(name);\r\n            feature.featureImplementation.dispose();\r\n            delete this._features[name];\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * dispose this features manager\r\n     */\r\n    public dispose(): void {\r\n        this.getEnabledFeatures().forEach((feature) => {\r\n            this.disableFeature(feature);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Enable a feature using its name and a version. This will enable it in the scene, and will be responsible to attach it when the session starts.\r\n     * If used twice, the old version will be disposed and a new one will be constructed. This way you can re-enable with different configuration.\r\n     *\r\n     * @param featureName the name of the feature to load or the class of the feature\r\n     * @param version optional version to load. if not provided the latest version will be enabled\r\n     * @param moduleOptions options provided to the module. Ses the module documentation / constructor\r\n     * @param attachIfPossible if set to true (default) the feature will be automatically attached, if it is currently possible\r\n     * @param required is this feature required to the app. If set to true the session init will fail if the feature is not available.\r\n     * @returns a new constructed feature or throws an error if feature not found or conflicts with another enabled feature.\r\n     */\r\n    public enableFeature(\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        featureName: string | { Name: string },\r\n        version: number | string = \"latest\",\r\n        moduleOptions: any = {},\r\n        attachIfPossible: boolean = true,\r\n        required: boolean = true\r\n    ): IWebXRFeature {\r\n        const name = typeof featureName === \"string\" ? featureName : featureName.Name;\r\n        let versionToLoad = 0;\r\n        if (typeof version === \"string\") {\r\n            if (!version) {\r\n                throw new Error(`Error in provided version - ${name} (${version})`);\r\n            }\r\n            if (version === \"stable\") {\r\n                versionToLoad = WebXRFeaturesManager.GetStableVersionOfFeature(name);\r\n            } else if (version === \"latest\") {\r\n                versionToLoad = WebXRFeaturesManager.GetLatestVersionOfFeature(name);\r\n            } else {\r\n                // try loading the number the string represents\r\n                versionToLoad = +version;\r\n            }\r\n            if (versionToLoad === -1 || isNaN(versionToLoad)) {\r\n                throw new Error(`feature not found - ${name} (${version})`);\r\n            }\r\n        } else {\r\n            versionToLoad = version;\r\n        }\r\n\r\n        // check if there is a feature conflict\r\n        const conflictingFeature = WebXRFeaturesManager._ConflictingFeatures[name];\r\n        if (conflictingFeature !== undefined && this.getEnabledFeatures().indexOf(conflictingFeature) !== -1) {\r\n            throw new Error(`Feature ${name} cannot be enabled while ${conflictingFeature} is enabled.`);\r\n        }\r\n\r\n        // check if already initialized\r\n        const feature = this._features[name];\r\n        const constructFunction = WebXRFeaturesManager.ConstructFeature(name, versionToLoad, this._xrSessionManager, moduleOptions);\r\n        if (!constructFunction) {\r\n            // report error?\r\n            throw new Error(`feature not found - ${name}`);\r\n        }\r\n\r\n        /* If the feature is already enabled, detach and dispose it, and create a new one */\r\n        if (feature) {\r\n            this.disableFeature(name);\r\n        }\r\n\r\n        const constructed = constructFunction();\r\n        if (constructed.dependsOn) {\r\n            const dependentsFound = constructed.dependsOn.every((featureName) => !!this._features[featureName]);\r\n            if (!dependentsFound) {\r\n                throw new Error(`Dependant features missing. Make sure the following features are enabled - ${constructed.dependsOn.join(\", \")}`);\r\n            }\r\n        }\r\n        if (constructed.isCompatible()) {\r\n            this._features[name] = {\r\n                featureImplementation: constructed,\r\n                enabled: true,\r\n                version: versionToLoad,\r\n                required,\r\n            };\r\n\r\n            if (attachIfPossible) {\r\n                // if session started already, request and enable\r\n                if (this._xrSessionManager.session && !this._features[name].featureImplementation.attached) {\r\n                    // enable feature\r\n                    this.attachFeature(name);\r\n                }\r\n            } else {\r\n                // disable auto-attach when session starts\r\n                this._features[name].featureImplementation.disableAutoAttach = true;\r\n            }\r\n\r\n            return this._features[name].featureImplementation;\r\n        } else {\r\n            if (required) {\r\n                throw new Error(\"required feature not compatible\");\r\n            } else {\r\n                Tools.Warn(`Feature ${name} not compatible with the current environment/browser and was not enabled.`);\r\n                return constructed;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get the implementation of an enabled feature.\r\n     * @param featureName the name of the feature to load\r\n     * @returns the feature class, if found\r\n     */\r\n    public getEnabledFeature(featureName: string): IWebXRFeature {\r\n        return this._features[featureName] && this._features[featureName].featureImplementation;\r\n    }\r\n\r\n    /**\r\n     * Get the list of enabled features\r\n     * @returns an array of enabled features\r\n     */\r\n    public getEnabledFeatures() {\r\n        return Object.keys(this._features);\r\n    }\r\n\r\n    /**\r\n     * This function will extend the session creation configuration object with enabled features.\r\n     * If, for example, the anchors feature is enabled, it will be automatically added to the optional or required features list,\r\n     * according to the defined \"required\" variable, provided during enableFeature call\r\n     * @param xrSessionInit the xr Session init object to extend\r\n     *\r\n     * @returns an extended XRSessionInit object\r\n     */\r\n    public async _extendXRSessionInitObject(xrSessionInit: XRSessionInit): Promise<XRSessionInit> {\r\n        const enabledFeatures = this.getEnabledFeatures();\r\n        for (const featureName of enabledFeatures) {\r\n            const feature = this._features[featureName];\r\n            const nativeName = feature.featureImplementation.xrNativeFeatureName;\r\n            if (nativeName) {\r\n                if (feature.required) {\r\n                    xrSessionInit.requiredFeatures = xrSessionInit.requiredFeatures || [];\r\n                    if (xrSessionInit.requiredFeatures.indexOf(nativeName) === -1) {\r\n                        xrSessionInit.requiredFeatures.push(nativeName);\r\n                    }\r\n                } else {\r\n                    xrSessionInit.optionalFeatures = xrSessionInit.optionalFeatures || [];\r\n                    if (xrSessionInit.optionalFeatures.indexOf(nativeName) === -1) {\r\n                        xrSessionInit.optionalFeatures.push(nativeName);\r\n                    }\r\n                }\r\n            }\r\n            if (feature.featureImplementation.getXRSessionInitExtension) {\r\n                const extended = await feature.featureImplementation.getXRSessionInitExtension();\r\n                xrSessionInit = {\r\n                    ...xrSessionInit,\r\n                    ...extended,\r\n                };\r\n            }\r\n        }\r\n        return xrSessionInit;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}