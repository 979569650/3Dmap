{"ast":null,"code":"import { VolumeBasedPanel } from \"./volumeBasedPanel.js\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh.js\";\nimport { CreateBox } from \"@babylonjs/core/Meshes/Builders/boxBuilder.js\";\nimport { FluentMaterial } from \"../materials/fluent/fluentMaterial.js\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { Logger } from \"@babylonjs/core/Misc/logger.js\";\n/**\n * Simple menu that can contain holographic buttons\n */\nexport class TouchHolographicMenu extends VolumeBasedPanel {\n  /**\n   * Gets or sets the margin size of the backplate in button size units.\n   * Setting this to 1, will make the backPlate margin the size of 1 button\n   */\n  get backPlateMargin() {\n    return this._backPlateMargin;\n  }\n  set backPlateMargin(value) {\n    this._backPlateMargin = value;\n    if (this._children.length >= 1) {\n      this.children.forEach(control => {\n        this._updateCurrentMinMax(control.position);\n      });\n      this._updateMargins();\n    }\n  }\n  _createNode(scene) {\n    const node = new Mesh(`menu_${this.name}`, scene);\n    this._backPlate = CreateBox(\"backPlate\" + this.name, {\n      size: 1\n    }, scene);\n    this._backPlate.parent = node;\n    return node;\n  }\n  _affectMaterial(mesh) {\n    this._backPlateMaterial = new FluentMaterial(this.name + \"backPlateMaterial\", mesh.getScene());\n    this._backPlateMaterial.albedoColor = new Color3(0.08, 0.15, 0.55);\n    this._backPlateMaterial.renderBorders = true;\n    this._backPlateMaterial.renderHoverLight = true;\n    this._pickedPointObserver = this._host.onPickedPointChangedObservable.add(pickedPoint => {\n      if (pickedPoint) {\n        this._backPlateMaterial.hoverPosition = pickedPoint;\n        this._backPlateMaterial.hoverColor.a = 1.0;\n      } else {\n        this._backPlateMaterial.hoverColor.a = 0;\n      }\n    });\n    this._backPlate.material = this._backPlateMaterial;\n  }\n  _mapGridNode(control, nodePosition) {\n    // Simple plane mapping for the menu\n    const mesh = control.mesh;\n    if (!mesh) {\n      return;\n    }\n    control.position = nodePosition.clone();\n    this._updateCurrentMinMax(nodePosition);\n  }\n  _finalProcessing() {\n    this._updateMargins();\n  }\n  _updateCurrentMinMax(nodePosition) {\n    if (!this._currentMin) {\n      this._currentMin = nodePosition.clone();\n      this._currentMax = nodePosition.clone();\n    }\n    this._currentMin.minimizeInPlace(nodePosition);\n    this._currentMax.maximizeInPlace(nodePosition);\n  }\n  _updateMargins() {\n    if (this._children.length > 0) {\n      this._currentMin.addInPlaceFromFloats(-this._cellWidth / 2, -this._cellHeight / 2, 0);\n      this._currentMax.addInPlaceFromFloats(this._cellWidth / 2, this._cellHeight / 2, 0);\n      const extendSize = this._currentMax.subtract(this._currentMin);\n      // Also add a % margin\n      this._backPlate.scaling.x = extendSize.x + this._cellWidth * this.backPlateMargin;\n      this._backPlate.scaling.y = extendSize.y + this._cellHeight * this.backPlateMargin;\n      this._backPlate.scaling.z = 0.001;\n      for (let i = 0; i < this._children.length; i++) {\n        this._children[i].position.subtractInPlace(this._currentMin).subtractInPlace(extendSize.scale(0.5));\n        this._children[i].position.z -= 0.01;\n      }\n    }\n    this._currentMin = null;\n    this._currentMax = null;\n  }\n  /**\n   * Creates a holographic menu GUI 3D control\n   * @param name name of the menu\n   */\n  constructor(name) {\n    super(name);\n    this._backPlateMargin = 1.25;\n  }\n  /**\n   * Adds a button to the menu.\n   * Please note that the back material of the button will be set to transparent as it is attached to the menu.\n   *\n   * @param button Button to add\n   * @returns This menu\n   */\n  addButton(button) {\n    // Block updating the layout until the button is resized (which has to happen after node creation)\n    const wasLayoutBlocked = this.blockLayout;\n    if (!wasLayoutBlocked) {\n      this.blockLayout = true;\n    }\n    super.addControl(button);\n    button.isBackplateVisible = false;\n    button.scaling.scaleInPlace(TouchHolographicMenu.MENU_BUTTON_SCALE);\n    // Unblocking the layout triggers the pending layout update that uses the size of the buttons to determine the size of the backing mesh\n    if (!wasLayoutBlocked) {\n      this.blockLayout = false;\n    }\n    return this;\n  }\n  /**\n   * This method should not be used directly. It is inherited from `Container3D`.\n   * Please use `addButton` instead.\n   * @param _control\n   * @returns\n   */\n  addControl(_control) {\n    Logger.Warn(\"TouchHolographicMenu can only contain buttons. Please use the method `addButton` instead.\");\n    return this;\n  }\n  /**\n   * Disposes the menu\n   */\n  dispose() {\n    super.dispose();\n    this._host.onPickedPointChangedObservable.remove(this._pickedPointObserver);\n  }\n}\n/**\n * Scale for the buttons added to the menu\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nTouchHolographicMenu.MENU_BUTTON_SCALE = 1;","map":{"version":3,"names":["VolumeBasedPanel","Mesh","CreateBox","FluentMaterial","Color3","Logger","TouchHolographicMenu","backPlateMargin","_backPlateMargin","value","_children","length","children","forEach","control","_updateCurrentMinMax","position","_updateMargins","_createNode","scene","node","name","_backPlate","size","parent","_affectMaterial","mesh","_backPlateMaterial","getScene","albedoColor","renderBorders","renderHoverLight","_pickedPointObserver","_host","onPickedPointChangedObservable","add","pickedPoint","hoverPosition","hoverColor","a","material","_mapGridNode","nodePosition","clone","_finalProcessing","_currentMin","_currentMax","minimizeInPlace","maximizeInPlace","addInPlaceFromFloats","_cellWidth","_cellHeight","extendSize","subtract","scaling","x","y","z","i","subtractInPlace","scale","constructor","addButton","button","wasLayoutBlocked","blockLayout","addControl","isBackplateVisible","scaleInPlace","MENU_BUTTON_SCALE","_control","Warn","dispose","remove"],"sources":["../../../../../dev/gui/src/3D/controls/touchHolographicMenu.ts"],"sourcesContent":["import type { Scene } from \"core/scene\";\r\nimport type { Vector3 } from \"core/Maths/math.vector\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Control3D } from \"./control3D\";\r\nimport { VolumeBasedPanel } from \"./volumeBasedPanel\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport { CreateBox } from \"core/Meshes/Builders/boxBuilder\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { FluentMaterial } from \"../materials/fluent/fluentMaterial\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport type { Container3D } from \"./container3D\";\r\nimport type { TouchHolographicButton } from \"./touchHolographicButton\";\r\n\r\n/**\r\n * Simple menu that can contain holographic buttons\r\n */\r\nexport class TouchHolographicMenu extends VolumeBasedPanel {\r\n    protected _backPlate: Mesh;\r\n    private _backPlateMaterial: FluentMaterial;\r\n    private _pickedPointObserver: Nullable<Observer<Nullable<Vector3>>>;\r\n\r\n    private _currentMin: Nullable<Vector3>;\r\n    private _currentMax: Nullable<Vector3>;\r\n\r\n    private _backPlateMargin = 1.25;\r\n\r\n    /**\r\n     * Scale for the buttons added to the menu\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected static MENU_BUTTON_SCALE: number = 1;\r\n\r\n    /**\r\n     * Gets or sets the margin size of the backplate in button size units.\r\n     * Setting this to 1, will make the backPlate margin the size of 1 button\r\n     */\r\n    public get backPlateMargin(): number {\r\n        return this._backPlateMargin;\r\n    }\r\n\r\n    public set backPlateMargin(value: number) {\r\n        this._backPlateMargin = value;\r\n\r\n        if (this._children.length >= 1) {\r\n            this.children.forEach((control) => {\r\n                this._updateCurrentMinMax(control.position);\r\n            });\r\n\r\n            this._updateMargins();\r\n        }\r\n    }\r\n\r\n    protected _createNode(scene: Scene): Nullable<TransformNode> {\r\n        const node = new Mesh(`menu_${this.name}`, scene);\r\n\r\n        this._backPlate = CreateBox(\"backPlate\" + this.name, { size: 1 }, scene);\r\n        this._backPlate.parent = node;\r\n\r\n        return node;\r\n    }\r\n\r\n    protected _affectMaterial(mesh: AbstractMesh) {\r\n        this._backPlateMaterial = new FluentMaterial(this.name + \"backPlateMaterial\", mesh.getScene());\r\n        this._backPlateMaterial.albedoColor = new Color3(0.08, 0.15, 0.55);\r\n        this._backPlateMaterial.renderBorders = true;\r\n        this._backPlateMaterial.renderHoverLight = true;\r\n\r\n        this._pickedPointObserver = this._host.onPickedPointChangedObservable.add((pickedPoint) => {\r\n            if (pickedPoint) {\r\n                this._backPlateMaterial.hoverPosition = pickedPoint;\r\n                this._backPlateMaterial.hoverColor.a = 1.0;\r\n            } else {\r\n                this._backPlateMaterial.hoverColor.a = 0;\r\n            }\r\n        });\r\n\r\n        this._backPlate.material = this._backPlateMaterial;\r\n    }\r\n\r\n    protected _mapGridNode(control: Control3D, nodePosition: Vector3) {\r\n        // Simple plane mapping for the menu\r\n        const mesh = control.mesh;\r\n\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        control.position = nodePosition.clone();\r\n\r\n        this._updateCurrentMinMax(nodePosition);\r\n    }\r\n\r\n    protected _finalProcessing() {\r\n        this._updateMargins();\r\n    }\r\n\r\n    private _updateCurrentMinMax(nodePosition: Vector3) {\r\n        if (!this._currentMin) {\r\n            this._currentMin = nodePosition.clone();\r\n            this._currentMax = nodePosition.clone();\r\n        }\r\n\r\n        this._currentMin.minimizeInPlace(nodePosition);\r\n        this._currentMax!.maximizeInPlace(nodePosition);\r\n    }\r\n\r\n    private _updateMargins() {\r\n        if (this._children.length > 0) {\r\n            this._currentMin!.addInPlaceFromFloats(-this._cellWidth / 2, -this._cellHeight / 2, 0);\r\n            this._currentMax!.addInPlaceFromFloats(this._cellWidth / 2, this._cellHeight / 2, 0);\r\n            const extendSize = this._currentMax!.subtract(this._currentMin!);\r\n\r\n            // Also add a % margin\r\n            this._backPlate.scaling.x = extendSize.x + this._cellWidth * this.backPlateMargin;\r\n            this._backPlate.scaling.y = extendSize.y + this._cellHeight * this.backPlateMargin;\r\n            this._backPlate.scaling.z = 0.001;\r\n\r\n            for (let i = 0; i < this._children.length; i++) {\r\n                this._children[i].position.subtractInPlace(this._currentMin!).subtractInPlace(extendSize.scale(0.5));\r\n                this._children[i].position.z -= 0.01;\r\n            }\r\n        }\r\n\r\n        this._currentMin = null;\r\n        this._currentMax = null;\r\n    }\r\n\r\n    /**\r\n     * Creates a holographic menu GUI 3D control\r\n     * @param name name of the menu\r\n     */\r\n    constructor(name?: string) {\r\n        super(name);\r\n    }\r\n\r\n    /**\r\n     * Adds a button to the menu.\r\n     * Please note that the back material of the button will be set to transparent as it is attached to the menu.\r\n     *\r\n     * @param button Button to add\r\n     * @returns This menu\r\n     */\r\n    public addButton(button: TouchHolographicButton): TouchHolographicMenu {\r\n        // Block updating the layout until the button is resized (which has to happen after node creation)\r\n        const wasLayoutBlocked = this.blockLayout;\r\n        if (!wasLayoutBlocked) {\r\n            this.blockLayout = true;\r\n        }\r\n\r\n        super.addControl(button);\r\n\r\n        button.isBackplateVisible = false;\r\n        button.scaling.scaleInPlace(TouchHolographicMenu.MENU_BUTTON_SCALE);\r\n\r\n        // Unblocking the layout triggers the pending layout update that uses the size of the buttons to determine the size of the backing mesh\r\n        if (!wasLayoutBlocked) {\r\n            this.blockLayout = false;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * This method should not be used directly. It is inherited from `Container3D`.\r\n     * Please use `addButton` instead.\r\n     * @param _control\r\n     * @returns\r\n     */\r\n    public addControl(_control: Control3D): Container3D {\r\n        Logger.Warn(\"TouchHolographicMenu can only contain buttons. Please use the method `addButton` instead.\");\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes the menu\r\n     */\r\n    public dispose() {\r\n        super.dispose();\r\n\r\n        this._host.onPickedPointChangedObservable.remove(this._pickedPointObserver);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}