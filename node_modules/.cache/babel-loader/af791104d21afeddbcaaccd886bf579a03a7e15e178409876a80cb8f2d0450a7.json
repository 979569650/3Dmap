{"ast":null,"code":"import { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector.js\";\n/**\n * @internal\n */\nclass FaceDirectionInfo {\n  constructor(direction, rotatedDirection = new Vector3(), diff = 0, ignore = false) {\n    this.direction = direction;\n    this.rotatedDirection = rotatedDirection;\n    this.diff = diff;\n    this.ignore = ignore;\n  }\n}\n/**\n * A behavior that when attached to a mesh will will place a specified node on the meshes face pointing towards the camera\n */\nexport class AttachToBoxBehavior {\n  /**\n   * Creates the AttachToBoxBehavior, used to attach UI to the closest face of the box to a camera\n   * @param _ui The transform node that should be attached to the mesh\n   */\n  constructor(_ui) {\n    this._ui = _ui;\n    /**\n     *  The name of the behavior\n     */\n    this.name = \"AttachToBoxBehavior\";\n    /**\n     * The distance away from the face of the mesh that the UI should be attached to (default: 0.15)\n     */\n    this.distanceAwayFromFace = 0.15;\n    /**\n     * The distance from the bottom of the face that the UI should be attached to (default: 0.15)\n     */\n    this.distanceAwayFromBottomOfFace = 0.15;\n    this._faceVectors = [new FaceDirectionInfo(Vector3.Up()), new FaceDirectionInfo(Vector3.Down()), new FaceDirectionInfo(Vector3.Left()), new FaceDirectionInfo(Vector3.Right()), new FaceDirectionInfo(Vector3.Forward()), new FaceDirectionInfo(Vector3.Forward().scaleInPlace(-1))];\n    this._tmpMatrix = new Matrix();\n    this._tmpVector = new Vector3();\n    this._zeroVector = Vector3.Zero();\n    this._lookAtTmpMatrix = new Matrix();\n    /* Does nothing */\n  }\n  /**\n   *  Initializes the behavior\n   */\n  init() {\n    /* Does nothing */\n  }\n  _closestFace(targetDirection) {\n    // Go over each face and calculate the angle between the face's normal and targetDirection\n    this._faceVectors.forEach(v => {\n      if (!this._target.rotationQuaternion) {\n        this._target.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._target.rotation.y, this._target.rotation.x, this._target.rotation.z);\n      }\n      this._target.rotationQuaternion.toRotationMatrix(this._tmpMatrix);\n      Vector3.TransformCoordinatesToRef(v.direction, this._tmpMatrix, v.rotatedDirection);\n      v.diff = Vector3.GetAngleBetweenVectors(v.rotatedDirection, targetDirection, Vector3.Cross(v.rotatedDirection, targetDirection));\n    });\n    // Return the face information of the one with the normal closest to target direction\n    return this._faceVectors.reduce((min, p) => {\n      if (min.ignore) {\n        return p;\n      } else if (p.ignore) {\n        return min;\n      } else {\n        return min.diff < p.diff ? min : p;\n      }\n    }, this._faceVectors[0]);\n  }\n  _lookAtToRef(pos, up = new Vector3(0, 1, 0), ref) {\n    Matrix.LookAtLHToRef(this._zeroVector, pos, up, this._lookAtTmpMatrix);\n    this._lookAtTmpMatrix.invert();\n    Quaternion.FromRotationMatrixToRef(this._lookAtTmpMatrix, ref);\n  }\n  /**\n   * Attaches the AttachToBoxBehavior to the passed in mesh\n   * @param target The mesh that the specified node will be attached to\n   */\n  attach(target) {\n    this._target = target;\n    this._scene = this._target.getScene();\n    // Every frame, update the app bars position\n    this._onRenderObserver = this._scene.onBeforeRenderObservable.add(() => {\n      if (!this._scene.activeCamera) {\n        return;\n      }\n      // Find the face closest to the cameras position\n      let cameraPos = this._scene.activeCamera.position;\n      if (this._scene.activeCamera.devicePosition) {\n        cameraPos = this._scene.activeCamera.devicePosition;\n      }\n      const facing = this._closestFace(cameraPos.subtract(target.position));\n      if (this._scene.activeCamera.leftCamera) {\n        this._scene.activeCamera.leftCamera.computeWorldMatrix().getRotationMatrixToRef(this._tmpMatrix);\n      } else {\n        this._scene.activeCamera.computeWorldMatrix().getRotationMatrixToRef(this._tmpMatrix);\n      }\n      // Get camera up direction\n      Vector3.TransformCoordinatesToRef(Vector3.Up(), this._tmpMatrix, this._tmpVector);\n      // Ignore faces to not select a parallel face for the up vector of the UI\n      this._faceVectors.forEach(v => {\n        if (facing.direction.x && v.direction.x) {\n          v.ignore = true;\n        }\n        if (facing.direction.y && v.direction.y) {\n          v.ignore = true;\n        }\n        if (facing.direction.z && v.direction.z) {\n          v.ignore = true;\n        }\n      });\n      const facingUp = this._closestFace(this._tmpVector);\n      // Unignore faces\n      this._faceVectors.forEach(v => {\n        v.ignore = false;\n      });\n      // Position the app bar on that face\n      this._ui.position.copyFrom(target.position);\n      if (facing.direction.x) {\n        facing.rotatedDirection.scaleToRef(target.scaling.x / 2 + this.distanceAwayFromFace, this._tmpVector);\n        this._ui.position.addInPlace(this._tmpVector);\n      }\n      if (facing.direction.y) {\n        facing.rotatedDirection.scaleToRef(target.scaling.y / 2 + this.distanceAwayFromFace, this._tmpVector);\n        this._ui.position.addInPlace(this._tmpVector);\n      }\n      if (facing.direction.z) {\n        facing.rotatedDirection.scaleToRef(target.scaling.z / 2 + this.distanceAwayFromFace, this._tmpVector);\n        this._ui.position.addInPlace(this._tmpVector);\n      }\n      // Rotate to be oriented properly to the camera\n      if (!this._ui.rotationQuaternion) {\n        this._ui.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._ui.rotation.y, this._ui.rotation.x, this._ui.rotation.z);\n      }\n      facing.rotatedDirection.scaleToRef(-1, this._tmpVector);\n      this._lookAtToRef(this._tmpVector, facingUp.rotatedDirection, this._ui.rotationQuaternion);\n      // Place ui the correct distance from the bottom of the mesh\n      if (facingUp.direction.x) {\n        this._ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.x / 2, this._tmpVector);\n      }\n      if (facingUp.direction.y) {\n        this._ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.y / 2, this._tmpVector);\n      }\n      if (facingUp.direction.z) {\n        this._ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.z / 2, this._tmpVector);\n      }\n      this._ui.position.addInPlace(this._tmpVector);\n    });\n  }\n  /**\n   *  Detaches the behavior from the mesh\n   */\n  detach() {\n    this._scene.onBeforeRenderObservable.remove(this._onRenderObserver);\n  }\n}","map":{"version":3,"names":["Vector3","Matrix","Quaternion","FaceDirectionInfo","constructor","direction","rotatedDirection","diff","ignore","AttachToBoxBehavior","_ui","name","distanceAwayFromFace","distanceAwayFromBottomOfFace","_faceVectors","Up","Down","Left","Right","Forward","scaleInPlace","_tmpMatrix","_tmpVector","_zeroVector","Zero","_lookAtTmpMatrix","init","_closestFace","targetDirection","forEach","v","_target","rotationQuaternion","RotationYawPitchRoll","rotation","y","x","z","toRotationMatrix","TransformCoordinatesToRef","GetAngleBetweenVectors","Cross","reduce","min","p","_lookAtToRef","pos","up","ref","LookAtLHToRef","invert","FromRotationMatrixToRef","attach","target","_scene","getScene","_onRenderObserver","onBeforeRenderObservable","add","activeCamera","cameraPos","position","devicePosition","facing","subtract","leftCamera","computeWorldMatrix","getRotationMatrixToRef","facingUp","copyFrom","scaleToRef","scaling","addInPlace","detach","remove"],"sources":["../../../../../dev/core/src/Behaviors/Meshes/attachToBoxBehavior.ts"],"sourcesContent":["import { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Behavior } from \"../../Behaviors/behavior\";\r\n\r\n/**\r\n * @internal\r\n */\r\nclass FaceDirectionInfo {\r\n    constructor(public direction: Vector3, public rotatedDirection = new Vector3(), public diff = 0, public ignore = false) {}\r\n}\r\n\r\n/**\r\n * A behavior that when attached to a mesh will will place a specified node on the meshes face pointing towards the camera\r\n */\r\nexport class AttachToBoxBehavior implements Behavior<Mesh> {\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public name = \"AttachToBoxBehavior\";\r\n    /**\r\n     * The distance away from the face of the mesh that the UI should be attached to (default: 0.15)\r\n     */\r\n    public distanceAwayFromFace = 0.15;\r\n    /**\r\n     * The distance from the bottom of the face that the UI should be attached to (default: 0.15)\r\n     */\r\n    public distanceAwayFromBottomOfFace = 0.15;\r\n    private _faceVectors = [\r\n        new FaceDirectionInfo(Vector3.Up()),\r\n        new FaceDirectionInfo(Vector3.Down()),\r\n        new FaceDirectionInfo(Vector3.Left()),\r\n        new FaceDirectionInfo(Vector3.Right()),\r\n        new FaceDirectionInfo(Vector3.Forward()),\r\n        new FaceDirectionInfo(Vector3.Forward().scaleInPlace(-1)),\r\n    ];\r\n    private _target: Mesh;\r\n    private _scene: Scene;\r\n    private _onRenderObserver: Nullable<Observer<Scene>>;\r\n    private _tmpMatrix = new Matrix();\r\n    private _tmpVector = new Vector3();\r\n\r\n    /**\r\n     * Creates the AttachToBoxBehavior, used to attach UI to the closest face of the box to a camera\r\n     * @param _ui The transform node that should be attached to the mesh\r\n     */\r\n    constructor(private _ui: TransformNode) {\r\n        /* Does nothing */\r\n    }\r\n\r\n    /**\r\n     *  Initializes the behavior\r\n     */\r\n    public init() {\r\n        /* Does nothing */\r\n    }\r\n\r\n    private _closestFace(targetDirection: Vector3) {\r\n        // Go over each face and calculate the angle between the face's normal and targetDirection\r\n        this._faceVectors.forEach((v) => {\r\n            if (!this._target.rotationQuaternion) {\r\n                this._target.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._target.rotation.y, this._target.rotation.x, this._target.rotation.z);\r\n            }\r\n            this._target.rotationQuaternion.toRotationMatrix(this._tmpMatrix);\r\n            Vector3.TransformCoordinatesToRef(v.direction, this._tmpMatrix, v.rotatedDirection);\r\n            v.diff = Vector3.GetAngleBetweenVectors(v.rotatedDirection, targetDirection, Vector3.Cross(v.rotatedDirection, targetDirection));\r\n        });\r\n        // Return the face information of the one with the normal closest to target direction\r\n        return this._faceVectors.reduce((min, p) => {\r\n            if (min.ignore) {\r\n                return p;\r\n            } else if (p.ignore) {\r\n                return min;\r\n            } else {\r\n                return min.diff < p.diff ? min : p;\r\n            }\r\n        }, this._faceVectors[0]);\r\n    }\r\n\r\n    private _zeroVector = Vector3.Zero();\r\n    private _lookAtTmpMatrix = new Matrix();\r\n    private _lookAtToRef(pos: Vector3, up = new Vector3(0, 1, 0), ref: Quaternion) {\r\n        Matrix.LookAtLHToRef(this._zeroVector, pos, up, this._lookAtTmpMatrix);\r\n        this._lookAtTmpMatrix.invert();\r\n        Quaternion.FromRotationMatrixToRef(this._lookAtTmpMatrix, ref);\r\n    }\r\n\r\n    /**\r\n     * Attaches the AttachToBoxBehavior to the passed in mesh\r\n     * @param target The mesh that the specified node will be attached to\r\n     */\r\n    attach(target: Mesh) {\r\n        this._target = target;\r\n        this._scene = this._target.getScene();\r\n\r\n        // Every frame, update the app bars position\r\n        this._onRenderObserver = this._scene.onBeforeRenderObservable.add(() => {\r\n            if (!this._scene.activeCamera) {\r\n                return;\r\n            }\r\n\r\n            // Find the face closest to the cameras position\r\n            let cameraPos = this._scene.activeCamera.position;\r\n            if ((<any>this._scene.activeCamera).devicePosition) {\r\n                cameraPos = (<any>this._scene.activeCamera).devicePosition;\r\n            }\r\n            const facing = this._closestFace(cameraPos.subtract(target.position));\r\n            if (this._scene.activeCamera.leftCamera) {\r\n                this._scene.activeCamera.leftCamera.computeWorldMatrix().getRotationMatrixToRef(this._tmpMatrix);\r\n            } else {\r\n                this._scene.activeCamera.computeWorldMatrix().getRotationMatrixToRef(this._tmpMatrix);\r\n            }\r\n\r\n            // Get camera up direction\r\n            Vector3.TransformCoordinatesToRef(Vector3.Up(), this._tmpMatrix, this._tmpVector);\r\n            // Ignore faces to not select a parallel face for the up vector of the UI\r\n            this._faceVectors.forEach((v) => {\r\n                if (facing.direction.x && v.direction.x) {\r\n                    v.ignore = true;\r\n                }\r\n                if (facing.direction.y && v.direction.y) {\r\n                    v.ignore = true;\r\n                }\r\n                if (facing.direction.z && v.direction.z) {\r\n                    v.ignore = true;\r\n                }\r\n            });\r\n            const facingUp = this._closestFace(this._tmpVector);\r\n            // Unignore faces\r\n            this._faceVectors.forEach((v) => {\r\n                v.ignore = false;\r\n            });\r\n\r\n            // Position the app bar on that face\r\n            this._ui.position.copyFrom(target.position);\r\n            if (facing.direction.x) {\r\n                facing.rotatedDirection.scaleToRef(target.scaling.x / 2 + this.distanceAwayFromFace, this._tmpVector);\r\n                this._ui.position.addInPlace(this._tmpVector);\r\n            }\r\n            if (facing.direction.y) {\r\n                facing.rotatedDirection.scaleToRef(target.scaling.y / 2 + this.distanceAwayFromFace, this._tmpVector);\r\n                this._ui.position.addInPlace(this._tmpVector);\r\n            }\r\n            if (facing.direction.z) {\r\n                facing.rotatedDirection.scaleToRef(target.scaling.z / 2 + this.distanceAwayFromFace, this._tmpVector);\r\n                this._ui.position.addInPlace(this._tmpVector);\r\n            }\r\n\r\n            // Rotate to be oriented properly to the camera\r\n            if (!this._ui.rotationQuaternion) {\r\n                this._ui.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._ui.rotation.y, this._ui.rotation.x, this._ui.rotation.z);\r\n            }\r\n            facing.rotatedDirection.scaleToRef(-1, this._tmpVector);\r\n            this._lookAtToRef(this._tmpVector, facingUp.rotatedDirection, this._ui.rotationQuaternion);\r\n\r\n            // Place ui the correct distance from the bottom of the mesh\r\n            if (facingUp.direction.x) {\r\n                this._ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.x / 2, this._tmpVector);\r\n            }\r\n            if (facingUp.direction.y) {\r\n                this._ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.y / 2, this._tmpVector);\r\n            }\r\n            if (facingUp.direction.z) {\r\n                this._ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.z / 2, this._tmpVector);\r\n            }\r\n            this._ui.position.addInPlace(this._tmpVector);\r\n        });\r\n    }\r\n\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    detach() {\r\n        this._scene.onBeforeRenderObservable.remove(this._onRenderObserver);\r\n    }\r\n}\r\n"],"mappings":"AAAA,SAASA,OAAO,EAAEC,MAAM,EAAEC,UAAU,QAAQ,4BAA0B;AAQtE;;;AAGA,MAAMC,iBAAiB;EACnBC,YAAmBC,SAAkB,EAASC,gBAAA,GAAmB,IAAIN,OAAO,EAAE,EAASO,IAAA,GAAO,CAAC,EAASC,MAAA,GAAS,KAAK;IAAnG,KAAAH,SAAS,GAATA,SAAS;IAAkB,KAAAC,gBAAgB,GAAhBA,gBAAgB;IAAyB,KAAAC,IAAI,GAAJA,IAAI;IAAa,KAAAC,MAAM,GAANA,MAAM;EAAW;;AAG7H;;;AAGA,OAAM,MAAOC,mBAAmB;EA2B5B;;;;EAIAL,YAAoBM,GAAkB;IAAlB,KAAAA,GAAG,GAAHA,GAAG;IA9BvB;;;IAGO,KAAAC,IAAI,GAAG,qBAAqB;IACnC;;;IAGO,KAAAC,oBAAoB,GAAG,IAAI;IAClC;;;IAGO,KAAAC,4BAA4B,GAAG,IAAI;IAClC,KAAAC,YAAY,GAAG,CACnB,IAAIX,iBAAiB,CAACH,OAAO,CAACe,EAAE,EAAE,CAAC,EACnC,IAAIZ,iBAAiB,CAACH,OAAO,CAACgB,IAAI,EAAE,CAAC,EACrC,IAAIb,iBAAiB,CAACH,OAAO,CAACiB,IAAI,EAAE,CAAC,EACrC,IAAId,iBAAiB,CAACH,OAAO,CAACkB,KAAK,EAAE,CAAC,EACtC,IAAIf,iBAAiB,CAACH,OAAO,CAACmB,OAAO,EAAE,CAAC,EACxC,IAAIhB,iBAAiB,CAACH,OAAO,CAACmB,OAAO,EAAE,CAACC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAC5D;IAIO,KAAAC,UAAU,GAAG,IAAIpB,MAAM,EAAE;IACzB,KAAAqB,UAAU,GAAG,IAAItB,OAAO,EAAE;IAuC1B,KAAAuB,WAAW,GAAGvB,OAAO,CAACwB,IAAI,EAAE;IAC5B,KAAAC,gBAAgB,GAAG,IAAIxB,MAAM,EAAE;IAjCnC;EACJ;EAEA;;;EAGOyB,IAAIA,CAAA;IACP;EAAA;EAGIC,YAAYA,CAACC,eAAwB;IACzC;IACA,IAAI,CAACd,YAAY,CAACe,OAAO,CAAEC,CAAC,IAAI;MAC5B,IAAI,CAAC,IAAI,CAACC,OAAO,CAACC,kBAAkB,EAAE;QAClC,IAAI,CAACD,OAAO,CAACC,kBAAkB,GAAG9B,UAAU,CAAC+B,oBAAoB,CAAC,IAAI,CAACF,OAAO,CAACG,QAAQ,CAACC,CAAC,EAAE,IAAI,CAACJ,OAAO,CAACG,QAAQ,CAACE,CAAC,EAAE,IAAI,CAACL,OAAO,CAACG,QAAQ,CAACG,CAAC,CAAC;;MAEhJ,IAAI,CAACN,OAAO,CAACC,kBAAkB,CAACM,gBAAgB,CAAC,IAAI,CAACjB,UAAU,CAAC;MACjErB,OAAO,CAACuC,yBAAyB,CAACT,CAAC,CAACzB,SAAS,EAAE,IAAI,CAACgB,UAAU,EAAES,CAAC,CAACxB,gBAAgB,CAAC;MACnFwB,CAAC,CAACvB,IAAI,GAAGP,OAAO,CAACwC,sBAAsB,CAACV,CAAC,CAACxB,gBAAgB,EAAEsB,eAAe,EAAE5B,OAAO,CAACyC,KAAK,CAACX,CAAC,CAACxB,gBAAgB,EAAEsB,eAAe,CAAC,CAAC;IACpI,CAAC,CAAC;IACF;IACA,OAAO,IAAI,CAACd,YAAY,CAAC4B,MAAM,CAAC,CAACC,GAAG,EAAEC,CAAC,KAAI;MACvC,IAAID,GAAG,CAACnC,MAAM,EAAE;QACZ,OAAOoC,CAAC;OACX,MAAM,IAAIA,CAAC,CAACpC,MAAM,EAAE;QACjB,OAAOmC,GAAG;OACb,MAAM;QACH,OAAOA,GAAG,CAACpC,IAAI,GAAGqC,CAAC,CAACrC,IAAI,GAAGoC,GAAG,GAAGC,CAAC;;IAE1C,CAAC,EAAE,IAAI,CAAC9B,YAAY,CAAC,CAAC,CAAC,CAAC;EAC5B;EAIQ+B,YAAYA,CAACC,GAAY,EAAEC,EAAE,GAAG,IAAI/C,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAEgD,GAAe;IACzE/C,MAAM,CAACgD,aAAa,CAAC,IAAI,CAAC1B,WAAW,EAAEuB,GAAG,EAAEC,EAAE,EAAE,IAAI,CAACtB,gBAAgB,CAAC;IACtE,IAAI,CAACA,gBAAgB,CAACyB,MAAM,EAAE;IAC9BhD,UAAU,CAACiD,uBAAuB,CAAC,IAAI,CAAC1B,gBAAgB,EAAEuB,GAAG,CAAC;EAClE;EAEA;;;;EAIAI,MAAMA,CAACC,MAAY;IACf,IAAI,CAACtB,OAAO,GAAGsB,MAAM;IACrB,IAAI,CAACC,MAAM,GAAG,IAAI,CAACvB,OAAO,CAACwB,QAAQ,EAAE;IAErC;IACA,IAAI,CAACC,iBAAiB,GAAG,IAAI,CAACF,MAAM,CAACG,wBAAwB,CAACC,GAAG,CAAC,MAAK;MACnE,IAAI,CAAC,IAAI,CAACJ,MAAM,CAACK,YAAY,EAAE;QAC3B;;MAGJ;MACA,IAAIC,SAAS,GAAG,IAAI,CAACN,MAAM,CAACK,YAAY,CAACE,QAAQ;MACjD,IAAU,IAAI,CAACP,MAAM,CAACK,YAAa,CAACG,cAAc,EAAE;QAChDF,SAAS,GAAS,IAAI,CAACN,MAAM,CAACK,YAAa,CAACG,cAAc;;MAE9D,MAAMC,MAAM,GAAG,IAAI,CAACpC,YAAY,CAACiC,SAAS,CAACI,QAAQ,CAACX,MAAM,CAACQ,QAAQ,CAAC,CAAC;MACrE,IAAI,IAAI,CAACP,MAAM,CAACK,YAAY,CAACM,UAAU,EAAE;QACrC,IAAI,CAACX,MAAM,CAACK,YAAY,CAACM,UAAU,CAACC,kBAAkB,EAAE,CAACC,sBAAsB,CAAC,IAAI,CAAC9C,UAAU,CAAC;OACnG,MAAM;QACH,IAAI,CAACiC,MAAM,CAACK,YAAY,CAACO,kBAAkB,EAAE,CAACC,sBAAsB,CAAC,IAAI,CAAC9C,UAAU,CAAC;;MAGzF;MACArB,OAAO,CAACuC,yBAAyB,CAACvC,OAAO,CAACe,EAAE,EAAE,EAAE,IAAI,CAACM,UAAU,EAAE,IAAI,CAACC,UAAU,CAAC;MACjF;MACA,IAAI,CAACR,YAAY,CAACe,OAAO,CAAEC,CAAC,IAAI;QAC5B,IAAIiC,MAAM,CAAC1D,SAAS,CAAC+B,CAAC,IAAIN,CAAC,CAACzB,SAAS,CAAC+B,CAAC,EAAE;UACrCN,CAAC,CAACtB,MAAM,GAAG,IAAI;;QAEnB,IAAIuD,MAAM,CAAC1D,SAAS,CAAC8B,CAAC,IAAIL,CAAC,CAACzB,SAAS,CAAC8B,CAAC,EAAE;UACrCL,CAAC,CAACtB,MAAM,GAAG,IAAI;;QAEnB,IAAIuD,MAAM,CAAC1D,SAAS,CAACgC,CAAC,IAAIP,CAAC,CAACzB,SAAS,CAACgC,CAAC,EAAE;UACrCP,CAAC,CAACtB,MAAM,GAAG,IAAI;;MAEvB,CAAC,CAAC;MACF,MAAM4D,QAAQ,GAAG,IAAI,CAACzC,YAAY,CAAC,IAAI,CAACL,UAAU,CAAC;MACnD;MACA,IAAI,CAACR,YAAY,CAACe,OAAO,CAAEC,CAAC,IAAI;QAC5BA,CAAC,CAACtB,MAAM,GAAG,KAAK;MACpB,CAAC,CAAC;MAEF;MACA,IAAI,CAACE,GAAG,CAACmD,QAAQ,CAACQ,QAAQ,CAAChB,MAAM,CAACQ,QAAQ,CAAC;MAC3C,IAAIE,MAAM,CAAC1D,SAAS,CAAC+B,CAAC,EAAE;QACpB2B,MAAM,CAACzD,gBAAgB,CAACgE,UAAU,CAACjB,MAAM,CAACkB,OAAO,CAACnC,CAAC,GAAG,CAAC,GAAG,IAAI,CAACxB,oBAAoB,EAAE,IAAI,CAACU,UAAU,CAAC;QACrG,IAAI,CAACZ,GAAG,CAACmD,QAAQ,CAACW,UAAU,CAAC,IAAI,CAAClD,UAAU,CAAC;;MAEjD,IAAIyC,MAAM,CAAC1D,SAAS,CAAC8B,CAAC,EAAE;QACpB4B,MAAM,CAACzD,gBAAgB,CAACgE,UAAU,CAACjB,MAAM,CAACkB,OAAO,CAACpC,CAAC,GAAG,CAAC,GAAG,IAAI,CAACvB,oBAAoB,EAAE,IAAI,CAACU,UAAU,CAAC;QACrG,IAAI,CAACZ,GAAG,CAACmD,QAAQ,CAACW,UAAU,CAAC,IAAI,CAAClD,UAAU,CAAC;;MAEjD,IAAIyC,MAAM,CAAC1D,SAAS,CAACgC,CAAC,EAAE;QACpB0B,MAAM,CAACzD,gBAAgB,CAACgE,UAAU,CAACjB,MAAM,CAACkB,OAAO,CAAClC,CAAC,GAAG,CAAC,GAAG,IAAI,CAACzB,oBAAoB,EAAE,IAAI,CAACU,UAAU,CAAC;QACrG,IAAI,CAACZ,GAAG,CAACmD,QAAQ,CAACW,UAAU,CAAC,IAAI,CAAClD,UAAU,CAAC;;MAGjD;MACA,IAAI,CAAC,IAAI,CAACZ,GAAG,CAACsB,kBAAkB,EAAE;QAC9B,IAAI,CAACtB,GAAG,CAACsB,kBAAkB,GAAG9B,UAAU,CAAC+B,oBAAoB,CAAC,IAAI,CAACvB,GAAG,CAACwB,QAAQ,CAACC,CAAC,EAAE,IAAI,CAACzB,GAAG,CAACwB,QAAQ,CAACE,CAAC,EAAE,IAAI,CAAC1B,GAAG,CAACwB,QAAQ,CAACG,CAAC,CAAC;;MAEhI0B,MAAM,CAACzD,gBAAgB,CAACgE,UAAU,CAAC,CAAC,CAAC,EAAE,IAAI,CAAChD,UAAU,CAAC;MACvD,IAAI,CAACuB,YAAY,CAAC,IAAI,CAACvB,UAAU,EAAE8C,QAAQ,CAAC9D,gBAAgB,EAAE,IAAI,CAACI,GAAG,CAACsB,kBAAkB,CAAC;MAE1F;MACA,IAAIoC,QAAQ,CAAC/D,SAAS,CAAC+B,CAAC,EAAE;QACtB,IAAI,CAAC1B,GAAG,CAACqC,EAAE,CAACuB,UAAU,CAAC,IAAI,CAACzD,4BAA4B,GAAGwC,MAAM,CAACkB,OAAO,CAACnC,CAAC,GAAG,CAAC,EAAE,IAAI,CAACd,UAAU,CAAC;;MAErG,IAAI8C,QAAQ,CAAC/D,SAAS,CAAC8B,CAAC,EAAE;QACtB,IAAI,CAACzB,GAAG,CAACqC,EAAE,CAACuB,UAAU,CAAC,IAAI,CAACzD,4BAA4B,GAAGwC,MAAM,CAACkB,OAAO,CAACpC,CAAC,GAAG,CAAC,EAAE,IAAI,CAACb,UAAU,CAAC;;MAErG,IAAI8C,QAAQ,CAAC/D,SAAS,CAACgC,CAAC,EAAE;QACtB,IAAI,CAAC3B,GAAG,CAACqC,EAAE,CAACuB,UAAU,CAAC,IAAI,CAACzD,4BAA4B,GAAGwC,MAAM,CAACkB,OAAO,CAAClC,CAAC,GAAG,CAAC,EAAE,IAAI,CAACf,UAAU,CAAC;;MAErG,IAAI,CAACZ,GAAG,CAACmD,QAAQ,CAACW,UAAU,CAAC,IAAI,CAAClD,UAAU,CAAC;IACjD,CAAC,CAAC;EACN;EAEA;;;EAGAmD,MAAMA,CAAA;IACF,IAAI,CAACnB,MAAM,CAACG,wBAAwB,CAACiB,MAAM,CAAC,IAAI,CAAClB,iBAAiB,CAAC;EACvE"},"metadata":{},"sourceType":"module","externalDependencies":[]}