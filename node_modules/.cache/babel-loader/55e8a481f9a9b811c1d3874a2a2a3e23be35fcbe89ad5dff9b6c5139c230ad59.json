{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator.js\";\n/**\n * Block used to retrieve the depth (zbuffer) of the scene\n * @since 5.0.0\n */\nexport class SceneDepthBlock extends NodeMaterialBlock {\n  /**\n   * Create a new SceneDepthBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.VertexAndFragment);\n    /**\n     * Defines if the depth renderer should be setup in non linear mode\n     */\n    this.useNonLinearDepth = false;\n    /**\n     * Defines if the depth renderer should be setup in camera space Z mode (if set, useNonLinearDepth has no effect)\n     */\n    this.storeCameraSpaceZ = false;\n    /**\n     * Defines if the depth renderer should be setup in full 32 bits float mode\n     */\n    this.force32itsFloat = false;\n    this._isUnique = true;\n    this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);\n    this.registerOutput(\"depth\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n    this._inputs[0]._prioritizeVertex = false;\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"SceneDepthBlock\";\n  }\n  /**\n   * Gets the uv input component\n   */\n  get uv() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the depth output component\n   */\n  get depth() {\n    return this._outputs[0];\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  initialize(state) {\n    state._excludeVariableName(\"textureSampler\");\n  }\n  get target() {\n    if (!this.uv.isConnected) {\n      return NodeMaterialBlockTargets.VertexAndFragment;\n    }\n    if (this.uv.sourceBlock.isInput) {\n      return NodeMaterialBlockTargets.VertexAndFragment;\n    }\n    return NodeMaterialBlockTargets.Fragment;\n  }\n  _getTexture(scene) {\n    const depthRenderer = scene.enableDepthRenderer(undefined, this.useNonLinearDepth, this.force32itsFloat, undefined, this.storeCameraSpaceZ);\n    return depthRenderer.getDepthMap();\n  }\n  bind(effect, nodeMaterial) {\n    const texture = this._getTexture(nodeMaterial.getScene());\n    effect.setTexture(this._samplerName, texture);\n  }\n  _injectVertexCode(state) {\n    const uvInput = this.uv;\n    if (uvInput.connectedPoint.ownerBlock.isInput) {\n      const uvInputOwnerBlock = uvInput.connectedPoint.ownerBlock;\n      if (!uvInputOwnerBlock.isAttribute) {\n        state._emitUniformFromString(uvInput.associatedVariableName, \"vec\" + (uvInput.type === NodeMaterialBlockConnectionPointTypes.Vector3 ? \"3\" : uvInput.type === NodeMaterialBlockConnectionPointTypes.Vector4 ? \"4\" : \"2\"));\n      }\n    }\n    this._mainUVName = \"vMain\" + uvInput.associatedVariableName;\n    state._emitVaryingFromString(this._mainUVName, \"vec2\");\n    state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;\\n`;\n    if (!this._outputs.some(o => o.isConnectedInVertexShader)) {\n      return;\n    }\n    this._writeTextureRead(state, true);\n    for (const output of this._outputs) {\n      if (output.hasEndpoints) {\n        this._writeOutput(state, output, \"r\", true);\n      }\n    }\n  }\n  _writeTextureRead(state, vertexMode = false) {\n    const uvInput = this.uv;\n    if (vertexMode) {\n      if (state.target === NodeMaterialBlockTargets.Fragment) {\n        return;\n      }\n      state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName}.xy);\\n`;\n      return;\n    }\n    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n      state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName}.xy);\\n`;\n      return;\n    }\n    state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${this._mainUVName});\\n`;\n  }\n  _writeOutput(state, output, swizzle, vertexMode = false) {\n    if (vertexMode) {\n      if (state.target === NodeMaterialBlockTargets.Fragment) {\n        return;\n      }\n      state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\n`;\n      return;\n    }\n    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n      state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\n`;\n      return;\n    }\n    state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\n`;\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    this._samplerName = state._getFreeVariableName(this.name + \"Sampler\");\n    this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\n    if (state.sharedData.bindableBlocks.indexOf(this) < 0) {\n      state.sharedData.bindableBlocks.push(this);\n    }\n    if (state.target !== NodeMaterialBlockTargets.Fragment) {\n      // Vertex\n      state._emit2DSampler(this._samplerName);\n      this._injectVertexCode(state);\n      return;\n    }\n    // Fragment\n    if (!this._outputs.some(o => o.isConnectedInFragmentShader)) {\n      return;\n    }\n    state._emit2DSampler(this._samplerName);\n    this._writeTextureRead(state);\n    for (const output of this._outputs) {\n      if (output.hasEndpoints) {\n        this._writeOutput(state, output, \"r\");\n      }\n    }\n    return this;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.useNonLinearDepth = this.useNonLinearDepth;\n    serializationObject.storeCameraSpaceZ = this.storeCameraSpaceZ;\n    serializationObject.force32itsFloat = this.force32itsFloat;\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    this.useNonLinearDepth = serializationObject.useNonLinearDepth;\n    this.storeCameraSpaceZ = !!serializationObject.storeCameraSpaceZ;\n    this.force32itsFloat = serializationObject.force32itsFloat;\n  }\n}\n__decorate([editableInPropertyPage(\"Use non linear depth\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    activatePreviewCommand: true,\n    callback: (scene, block) => {\n      const sceneDepthBlock = block;\n      let retVal = false;\n      if (sceneDepthBlock.useNonLinearDepth) {\n        sceneDepthBlock.storeCameraSpaceZ = false;\n        retVal = true;\n      }\n      if (scene) {\n        scene.disableDepthRenderer();\n      }\n      return retVal;\n    }\n  }\n})], SceneDepthBlock.prototype, \"useNonLinearDepth\", void 0);\n__decorate([editableInPropertyPage(\"Store Camera space Z\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    activatePreviewCommand: true,\n    callback: (scene, block) => {\n      const sceneDepthBlock = block;\n      let retVal = false;\n      if (sceneDepthBlock.storeCameraSpaceZ) {\n        sceneDepthBlock.useNonLinearDepth = false;\n        retVal = true;\n      }\n      if (scene) {\n        scene.disableDepthRenderer();\n      }\n      return retVal;\n    }\n  }\n})], SceneDepthBlock.prototype, \"storeCameraSpaceZ\", void 0);\n__decorate([editableInPropertyPage(\"Force 32 bits float\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    activatePreviewCommand: true,\n    callback: scene => scene === null || scene === void 0 ? void 0 : scene.disableDepthRenderer()\n  }\n})], SceneDepthBlock.prototype, \"force32itsFloat\", void 0);\nRegisterClass(\"BABYLON.SceneDepthBlock\", SceneDepthBlock);","map":{"version":3,"names":["NodeMaterialBlock","NodeMaterialBlockConnectionPointTypes","NodeMaterialBlockTargets","RegisterClass","editableInPropertyPage","PropertyTypeForEdition","SceneDepthBlock","constructor","name","VertexAndFragment","useNonLinearDepth","storeCameraSpaceZ","force32itsFloat","_isUnique","registerInput","AutoDetect","registerOutput","Float","Neutral","_inputs","addExcludedConnectionPointFromAllowedTypes","Vector2","Vector3","Vector4","_prioritizeVertex","getClassName","uv","depth","_outputs","initialize","state","_excludeVariableName","target","isConnected","sourceBlock","isInput","Fragment","_getTexture","scene","depthRenderer","enableDepthRenderer","undefined","getDepthMap","bind","effect","nodeMaterial","texture","getScene","setTexture","_samplerName","_injectVertexCode","uvInput","connectedPoint","ownerBlock","uvInputOwnerBlock","isAttribute","_emitUniformFromString","associatedVariableName","type","_mainUVName","_emitVaryingFromString","compilationString","some","o","isConnectedInVertexShader","_writeTextureRead","output","hasEndpoints","_writeOutput","vertexMode","_tempTextureRead","swizzle","_declareOutput","_buildBlock","_getFreeVariableName","sharedData","bindableBlocks","indexOf","push","_emit2DSampler","isConnectedInFragmentShader","serialize","serializationObject","_deserialize","rootUrl","__decorate","Boolean","notifiers","activatePreviewCommand","callback","block","sceneDepthBlock","retVal","disableDepthRenderer"],"sources":["../../../../../../../dev/core/src/Materials/Node/Blocks/Dual/sceneDepthBlock.ts"],"sourcesContent":["import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { InputBlock } from \"../Input/inputBlock\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\nimport type { Effect } from \"../../../effect\";\r\n\r\nimport type { NodeMaterial } from \"../../nodeMaterial\";\r\n\r\n/**\r\n * Block used to retrieve the depth (zbuffer) of the scene\r\n * @since 5.0.0\r\n */\r\nexport class SceneDepthBlock extends NodeMaterialBlock {\r\n    private _samplerName: string;\r\n    private _mainUVName: string;\r\n    private _tempTextureRead: string;\r\n\r\n    /**\r\n     * Defines if the depth renderer should be setup in non linear mode\r\n     */\r\n    @editableInPropertyPage(\"Use non linear depth\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\r\n        notifiers: {\r\n            activatePreviewCommand: true,\r\n            callback: (scene, block) => {\r\n                const sceneDepthBlock = block as SceneDepthBlock;\r\n                let retVal = false;\r\n                if (sceneDepthBlock.useNonLinearDepth) {\r\n                    sceneDepthBlock.storeCameraSpaceZ = false;\r\n                    retVal = true;\r\n                }\r\n                if (scene) {\r\n                    scene.disableDepthRenderer();\r\n                }\r\n                return retVal;\r\n            },\r\n        },\r\n    })\r\n    public useNonLinearDepth = false;\r\n\r\n    /**\r\n     * Defines if the depth renderer should be setup in camera space Z mode (if set, useNonLinearDepth has no effect)\r\n     */\r\n    @editableInPropertyPage(\"Store Camera space Z\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\r\n        notifiers: {\r\n            activatePreviewCommand: true,\r\n            callback: (scene, block) => {\r\n                const sceneDepthBlock = block as SceneDepthBlock;\r\n                let retVal = false;\r\n                if (sceneDepthBlock.storeCameraSpaceZ) {\r\n                    sceneDepthBlock.useNonLinearDepth = false;\r\n                    retVal = true;\r\n                }\r\n                if (scene) {\r\n                    scene.disableDepthRenderer();\r\n                }\r\n                return retVal;\r\n            },\r\n        },\r\n    })\r\n    public storeCameraSpaceZ = false;\r\n\r\n    /**\r\n     * Defines if the depth renderer should be setup in full 32 bits float mode\r\n     */\r\n    @editableInPropertyPage(\"Force 32 bits float\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\r\n        notifiers: { activatePreviewCommand: true, callback: (scene) => scene?.disableDepthRenderer() },\r\n    })\r\n    public force32itsFloat = false;\r\n\r\n    /**\r\n     * Create a new SceneDepthBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this.registerOutput(\"depth\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n\r\n        this._inputs[0]._prioritizeVertex = false;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"SceneDepthBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the depth output component\r\n     */\r\n    public get depth(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"textureSampler\");\r\n    }\r\n\r\n    public get target() {\r\n        if (!this.uv.isConnected) {\r\n            return NodeMaterialBlockTargets.VertexAndFragment;\r\n        }\r\n\r\n        if (this.uv.sourceBlock!.isInput) {\r\n            return NodeMaterialBlockTargets.VertexAndFragment;\r\n        }\r\n\r\n        return NodeMaterialBlockTargets.Fragment;\r\n    }\r\n\r\n    private _getTexture(scene: Scene): BaseTexture {\r\n        const depthRenderer = scene.enableDepthRenderer(undefined, this.useNonLinearDepth, this.force32itsFloat, undefined, this.storeCameraSpaceZ);\r\n\r\n        return depthRenderer.getDepthMap();\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial) {\r\n        const texture = this._getTexture(nodeMaterial.getScene());\r\n\r\n        effect.setTexture(this._samplerName, texture);\r\n    }\r\n\r\n    private _injectVertexCode(state: NodeMaterialBuildState) {\r\n        const uvInput = this.uv;\r\n\r\n        if (uvInput.connectedPoint!.ownerBlock.isInput) {\r\n            const uvInputOwnerBlock = uvInput.connectedPoint!.ownerBlock as InputBlock;\r\n\r\n            if (!uvInputOwnerBlock.isAttribute) {\r\n                state._emitUniformFromString(\r\n                    uvInput.associatedVariableName,\r\n                    \"vec\" + (uvInput.type === NodeMaterialBlockConnectionPointTypes.Vector3 ? \"3\" : uvInput.type === NodeMaterialBlockConnectionPointTypes.Vector4 ? \"4\" : \"2\")\r\n                );\r\n            }\r\n        }\r\n\r\n        this._mainUVName = \"vMain\" + uvInput.associatedVariableName;\r\n\r\n        state._emitVaryingFromString(this._mainUVName, \"vec2\");\r\n\r\n        state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;\\n`;\r\n\r\n        if (!this._outputs.some((o) => o.isConnectedInVertexShader)) {\r\n            return;\r\n        }\r\n\r\n        this._writeTextureRead(state, true);\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                this._writeOutput(state, output, \"r\", true);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _writeTextureRead(state: NodeMaterialBuildState, vertexMode = false) {\r\n        const uvInput = this.uv;\r\n\r\n        if (vertexMode) {\r\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n                return;\r\n            }\r\n\r\n            state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName}.xy);\\n`;\r\n            return;\r\n        }\r\n\r\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName}.xy);\\n`;\r\n            return;\r\n        }\r\n\r\n        state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${this._mainUVName});\\n`;\r\n    }\r\n\r\n    private _writeOutput(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string, vertexMode = false) {\r\n        if (vertexMode) {\r\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n                return;\r\n            }\r\n\r\n            state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\n`;\r\n            return;\r\n        }\r\n\r\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\n`;\r\n            return;\r\n        }\r\n\r\n        state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\n`;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        this._samplerName = state._getFreeVariableName(this.name + \"Sampler\");\r\n        this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\r\n\r\n        if (state.sharedData.bindableBlocks.indexOf(this) < 0) {\r\n            state.sharedData.bindableBlocks.push(this);\r\n        }\r\n\r\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\r\n            // Vertex\r\n            state._emit2DSampler(this._samplerName);\r\n            this._injectVertexCode(state);\r\n            return;\r\n        }\r\n\r\n        // Fragment\r\n        if (!this._outputs.some((o) => o.isConnectedInFragmentShader)) {\r\n            return;\r\n        }\r\n\r\n        state._emit2DSampler(this._samplerName);\r\n\r\n        this._writeTextureRead(state);\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                this._writeOutput(state, output, \"r\");\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.useNonLinearDepth = this.useNonLinearDepth;\r\n        serializationObject.storeCameraSpaceZ = this.storeCameraSpaceZ;\r\n        serializationObject.force32itsFloat = this.force32itsFloat;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.useNonLinearDepth = serializationObject.useNonLinearDepth;\r\n        this.storeCameraSpaceZ = !!serializationObject.storeCameraSpaceZ;\r\n        this.force32itsFloat = serializationObject.force32itsFloat;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SceneDepthBlock\", SceneDepthBlock);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}