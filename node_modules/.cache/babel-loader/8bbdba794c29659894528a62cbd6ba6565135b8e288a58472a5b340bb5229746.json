{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Scene } from \"../scene.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { SceneLoaderFlags } from \"./sceneLoaderFlags.js\";\nimport { IsBase64DataUrl } from \"../Misc/fileTools.js\";\nimport { RuntimeError, ErrorCodes } from \"../Misc/error.js\";\n/**\n * Mode that determines how to handle old animation groups before loading new ones.\n */\nexport var SceneLoaderAnimationGroupLoadingMode;\n(function (SceneLoaderAnimationGroupLoadingMode) {\n  /**\n   * Reset all old animations to initial state then dispose them.\n   */\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Clean\"] = 0] = \"Clean\";\n  /**\n   * Stop all old animations.\n   */\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Stop\"] = 1] = \"Stop\";\n  /**\n   * Restart old animations from first frame.\n   */\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Sync\"] = 2] = \"Sync\";\n  /**\n   * Old animations remains untouched.\n   */\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"NoSync\"] = 3] = \"NoSync\";\n})(SceneLoaderAnimationGroupLoadingMode || (SceneLoaderAnimationGroupLoadingMode = {}));\n/**\n * Class used to load scene from various file formats using registered plugins\n * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes\n */\nexport class SceneLoader {\n  /**\n   * Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data\n   */\n  static get ForceFullSceneLoadingForIncremental() {\n    return SceneLoaderFlags.ForceFullSceneLoadingForIncremental;\n  }\n  static set ForceFullSceneLoadingForIncremental(value) {\n    SceneLoaderFlags.ForceFullSceneLoadingForIncremental = value;\n  }\n  /**\n   * Gets or sets a boolean indicating if loading screen must be displayed while loading a scene\n   */\n  static get ShowLoadingScreen() {\n    return SceneLoaderFlags.ShowLoadingScreen;\n  }\n  static set ShowLoadingScreen(value) {\n    SceneLoaderFlags.ShowLoadingScreen = value;\n  }\n  /**\n   * Defines the current logging level (while loading the scene)\n   * @ignorenaming\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static get loggingLevel() {\n    return SceneLoaderFlags.loggingLevel;\n  }\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static set loggingLevel(value) {\n    SceneLoaderFlags.loggingLevel = value;\n  }\n  /**\n   * Gets or set a boolean indicating if matrix weights must be cleaned upon loading\n   */\n  static get CleanBoneMatrixWeights() {\n    return SceneLoaderFlags.CleanBoneMatrixWeights;\n  }\n  static set CleanBoneMatrixWeights(value) {\n    SceneLoaderFlags.CleanBoneMatrixWeights = value;\n  }\n  /**\n   * Gets the default plugin (used to load Babylon files)\n   * @returns the .babylon plugin\n   */\n  static GetDefaultPlugin() {\n    return SceneLoader._RegisteredPlugins[\".babylon\"];\n  }\n  static _GetPluginForExtension(extension) {\n    const registeredPlugin = SceneLoader._RegisteredPlugins[extension];\n    if (registeredPlugin) {\n      return registeredPlugin;\n    }\n    Logger.Warn(\"Unable to find a plugin to load \" + extension + \" files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes\");\n    return SceneLoader.GetDefaultPlugin();\n  }\n  static _GetPluginForDirectLoad(data) {\n    for (const extension in SceneLoader._RegisteredPlugins) {\n      const plugin = SceneLoader._RegisteredPlugins[extension].plugin;\n      if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {\n        return SceneLoader._RegisteredPlugins[extension];\n      }\n    }\n    return SceneLoader.GetDefaultPlugin();\n  }\n  static _GetPluginForFilename(sceneFilename) {\n    const queryStringPosition = sceneFilename.indexOf(\"?\");\n    if (queryStringPosition !== -1) {\n      sceneFilename = sceneFilename.substring(0, queryStringPosition);\n    }\n    const dotPosition = sceneFilename.lastIndexOf(\".\");\n    const extension = sceneFilename.substring(dotPosition, sceneFilename.length).toLowerCase();\n    return SceneLoader._GetPluginForExtension(extension);\n  }\n  static _GetDirectLoad(sceneFilename) {\n    if (sceneFilename.substr(0, 5) === \"data:\") {\n      return sceneFilename.substr(5);\n    }\n    return null;\n  }\n  static _FormatErrorMessage(fileInfo, message, exception) {\n    const fromLoad = fileInfo.rawData ? \"binary data\" : fileInfo.url;\n    let errorMessage = \"Unable to load from \" + fromLoad;\n    if (message) {\n      errorMessage += `: ${message}`;\n    } else if (exception) {\n      errorMessage += `: ${exception}`;\n    }\n    return errorMessage;\n  }\n  static _LoadData(fileInfo, scene, onSuccess, onProgress, onError, onDispose, pluginExtension, name) {\n    const directLoad = SceneLoader._GetDirectLoad(fileInfo.url);\n    if (fileInfo.rawData && !pluginExtension) {\n      throw \"When using ArrayBufferView to load data the file extension must be provided.\";\n    }\n    const registeredPlugin = pluginExtension ? SceneLoader._GetPluginForExtension(pluginExtension) : directLoad ? SceneLoader._GetPluginForDirectLoad(fileInfo.url) : SceneLoader._GetPluginForFilename(fileInfo.url);\n    if (fileInfo.rawData && !registeredPlugin.isBinary) {\n      throw \"Loading from ArrayBufferView can not be used with plugins that don't support binary loading.\";\n    }\n    let plugin;\n    if (registeredPlugin.plugin.createPlugin !== undefined) {\n      plugin = registeredPlugin.plugin.createPlugin();\n    } else {\n      plugin = registeredPlugin.plugin;\n    }\n    if (!plugin) {\n      throw \"The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.\";\n    }\n    SceneLoader.OnPluginActivatedObservable.notifyObservers(plugin);\n    // Check if we have a direct load url. If the plugin is registered to handle\n    // it or it's not a base64 data url, then pass it through the direct load path.\n    if (directLoad && (plugin.canDirectLoad && plugin.canDirectLoad(fileInfo.url) || !IsBase64DataUrl(fileInfo.url))) {\n      if (plugin.directLoad) {\n        const result = plugin.directLoad(scene, directLoad);\n        if (result.then) {\n          result.then(data => {\n            onSuccess(plugin, data);\n          }).catch(error => {\n            onError(\"Error in directLoad of _loadData: \" + error, error);\n          });\n        } else {\n          onSuccess(plugin, result);\n        }\n      } else {\n        onSuccess(plugin, directLoad);\n      }\n      return plugin;\n    }\n    const useArrayBuffer = registeredPlugin.isBinary;\n    const dataCallback = (data, responseURL) => {\n      if (scene.isDisposed) {\n        onError(\"Scene has been disposed\");\n        return;\n      }\n      onSuccess(plugin, data, responseURL);\n    };\n    let request = null;\n    let pluginDisposed = false;\n    const onDisposeObservable = plugin.onDisposeObservable;\n    if (onDisposeObservable) {\n      onDisposeObservable.add(() => {\n        pluginDisposed = true;\n        if (request) {\n          request.abort();\n          request = null;\n        }\n        onDispose();\n      });\n    }\n    const manifestChecked = () => {\n      if (pluginDisposed) {\n        return;\n      }\n      const errorCallback = (request, exception) => {\n        onError(request === null || request === void 0 ? void 0 : request.statusText, exception);\n      };\n      if (!plugin.loadFile && fileInfo.rawData) {\n        throw \"Plugin does not support loading ArrayBufferView.\";\n      }\n      request = plugin.loadFile ? plugin.loadFile(scene, fileInfo.rawData || fileInfo.file || fileInfo.url, fileInfo.rootUrl, dataCallback, onProgress, useArrayBuffer, errorCallback, name) : scene._loadFile(fileInfo.file || fileInfo.url, dataCallback, onProgress, true, useArrayBuffer, errorCallback);\n    };\n    const engine = scene.getEngine();\n    let canUseOfflineSupport = engine.enableOfflineSupport;\n    if (canUseOfflineSupport) {\n      // Also check for exceptions\n      let exceptionFound = false;\n      for (const regex of scene.disableOfflineSupportExceptionRules) {\n        if (regex.test(fileInfo.url)) {\n          exceptionFound = true;\n          break;\n        }\n      }\n      canUseOfflineSupport = !exceptionFound;\n    }\n    if (canUseOfflineSupport && Engine.OfflineProviderFactory) {\n      // Checking if a manifest file has been set for this scene and if offline mode has been requested\n      scene.offlineProvider = Engine.OfflineProviderFactory(fileInfo.url, manifestChecked, engine.disableManifestCheck);\n    } else {\n      manifestChecked();\n    }\n    return plugin;\n  }\n  static _GetFileInfo(rootUrl, sceneFilename) {\n    let url;\n    let name;\n    let file = null;\n    let rawData = null;\n    if (!sceneFilename) {\n      url = rootUrl;\n      name = Tools.GetFilename(rootUrl);\n      rootUrl = Tools.GetFolderPath(rootUrl);\n    } else if (sceneFilename.name) {\n      const sceneFile = sceneFilename;\n      url = `file:${sceneFile.name}`;\n      name = sceneFile.name;\n      file = sceneFile;\n    } else if (ArrayBuffer.isView(sceneFilename)) {\n      url = \"\";\n      name = \"arrayBuffer\";\n      rawData = sceneFilename;\n    } else if (typeof sceneFilename === \"string\" && sceneFilename.startsWith(\"data:\")) {\n      url = sceneFilename;\n      name = \"\";\n    } else {\n      const filename = sceneFilename;\n      if (filename.substr(0, 1) === \"/\") {\n        Tools.Error(\"Wrong sceneFilename parameter\");\n        return null;\n      }\n      url = rootUrl + filename;\n      name = filename;\n    }\n    return {\n      url: url,\n      rootUrl: rootUrl,\n      name: name,\n      file: file,\n      rawData\n    };\n  }\n  // Public functions\n  /**\n   * Gets a plugin that can load the given extension\n   * @param extension defines the extension to load\n   * @returns a plugin or null if none works\n   */\n  static GetPluginForExtension(extension) {\n    return SceneLoader._GetPluginForExtension(extension).plugin;\n  }\n  /**\n   * Gets a boolean indicating that the given extension can be loaded\n   * @param extension defines the extension to load\n   * @returns true if the extension is supported\n   */\n  static IsPluginForExtensionAvailable(extension) {\n    return !!SceneLoader._RegisteredPlugins[extension];\n  }\n  /**\n   * Adds a new plugin to the list of registered plugins\n   * @param plugin defines the plugin to add\n   */\n  static RegisterPlugin(plugin) {\n    if (typeof plugin.extensions === \"string\") {\n      const extension = plugin.extensions;\n      SceneLoader._RegisteredPlugins[extension.toLowerCase()] = {\n        plugin: plugin,\n        isBinary: false\n      };\n    } else {\n      const extensions = plugin.extensions;\n      Object.keys(extensions).forEach(extension => {\n        SceneLoader._RegisteredPlugins[extension.toLowerCase()] = {\n          plugin: plugin,\n          isBinary: extensions[extension].isBinary\n        };\n      });\n    }\n  }\n  /**\n   * Import meshes into a scene\n   * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene the instance of BABYLON.Scene to append to\n   * @param onSuccess a callback with a list of imported meshes, particleSystems, skeletons, and animationGroups when import succeeds\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns The loaded plugin\n   */\n  static ImportMesh(meshNames, rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name = \"\") {\n    if (!scene) {\n      Logger.Error(\"No scene available to import mesh to\");\n      return null;\n    }\n    const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\n    if (!fileInfo) {\n      return null;\n    }\n    const loadingToken = {};\n    scene.addPendingData(loadingToken);\n    const disposeHandler = () => {\n      scene.removePendingData(loadingToken);\n    };\n    const errorHandler = (message, exception) => {\n      const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);\n      if (onError) {\n        onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\n      } else {\n        Logger.Error(errorMessage);\n        // should the exception be thrown?\n      }\n\n      disposeHandler();\n    };\n    const progressHandler = onProgress ? event => {\n      try {\n        onProgress(event);\n      } catch (e) {\n        errorHandler(\"Error in onProgress callback: \" + e, e);\n      }\n    } : undefined;\n    const successHandler = (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) => {\n      scene.importedMeshesFiles.push(fileInfo.url);\n      if (onSuccess) {\n        try {\n          onSuccess(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights);\n        } catch (e) {\n          errorHandler(\"Error in onSuccess callback: \" + e, e);\n        }\n      }\n      scene.removePendingData(loadingToken);\n    };\n    return SceneLoader._LoadData(fileInfo, scene, (plugin, data, responseURL) => {\n      if (plugin.rewriteRootURL) {\n        fileInfo.rootUrl = plugin.rewriteRootURL(fileInfo.rootUrl, responseURL);\n      }\n      if (plugin.importMesh) {\n        const syncedPlugin = plugin;\n        const meshes = new Array();\n        const particleSystems = new Array();\n        const skeletons = new Array();\n        if (!syncedPlugin.importMesh(meshNames, scene, data, fileInfo.rootUrl, meshes, particleSystems, skeletons, errorHandler)) {\n          return;\n        }\n        scene.loadingPluginName = plugin.name;\n        successHandler(meshes, particleSystems, skeletons, [], [], [], []);\n      } else {\n        const asyncedPlugin = plugin;\n        asyncedPlugin.importMeshAsync(meshNames, scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(result => {\n          scene.loadingPluginName = plugin.name;\n          successHandler(result.meshes, result.particleSystems, result.skeletons, result.animationGroups, result.transformNodes, result.geometries, result.lights);\n        }).catch(error => {\n          errorHandler(error.message, error);\n        });\n      }\n    }, progressHandler, errorHandler, disposeHandler, pluginExtension, name);\n  }\n  /**\n   * Import meshes into a scene\n   * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene the instance of BABYLON.Scene to append to\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns The loaded list of imported meshes, particle systems, skeletons, and animation groups\n   */\n  static ImportMeshAsync(meshNames, rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, onProgress = null, pluginExtension = null, name = \"\") {\n    return new Promise((resolve, reject) => {\n      SceneLoader.ImportMesh(meshNames, rootUrl, sceneFilename, scene, (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) => {\n        resolve({\n          meshes: meshes,\n          particleSystems: particleSystems,\n          skeletons: skeletons,\n          animationGroups: animationGroups,\n          transformNodes: transformNodes,\n          geometries: geometries,\n          lights: lights\n        });\n      }, onProgress, (scene, message, exception) => {\n        reject(exception || new Error(message));\n      }, pluginExtension, name);\n    });\n  }\n  /**\n   * Load a scene\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param engine is the instance of BABYLON.Engine to use to create the scene\n   * @param onSuccess a callback with the scene when import succeeds\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns The loaded plugin\n   */\n  static Load(rootUrl, sceneFilename = \"\", engine = EngineStore.LastCreatedEngine, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name = \"\") {\n    if (!engine) {\n      Tools.Error(\"No engine available\");\n      return null;\n    }\n    return SceneLoader.Append(rootUrl, sceneFilename, new Scene(engine), onSuccess, onProgress, onError, pluginExtension, name);\n  }\n  /**\n   * Load a scene\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param engine is the instance of BABYLON.Engine to use to create the scene\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns The loaded scene\n   */\n  static LoadAsync(rootUrl, sceneFilename = \"\", engine = EngineStore.LastCreatedEngine, onProgress = null, pluginExtension = null, name = \"\") {\n    return new Promise((resolve, reject) => {\n      SceneLoader.Load(rootUrl, sceneFilename, engine, scene => {\n        resolve(scene);\n      }, onProgress, (scene, message, exception) => {\n        reject(exception || new Error(message));\n      }, pluginExtension, name);\n    });\n  }\n  /**\n   * Append a scene\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene is the instance of BABYLON.Scene to append to\n   * @param onSuccess a callback with the scene when import succeeds\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns The loaded plugin\n   */\n  static Append(rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name = \"\") {\n    if (!scene) {\n      Logger.Error(\"No scene available to append to\");\n      return null;\n    }\n    const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\n    if (!fileInfo) {\n      return null;\n    }\n    const loadingToken = {};\n    scene.addPendingData(loadingToken);\n    const disposeHandler = () => {\n      scene.removePendingData(loadingToken);\n    };\n    if (SceneLoader.ShowLoadingScreen && !this._ShowingLoadingScreen) {\n      this._ShowingLoadingScreen = true;\n      scene.getEngine().displayLoadingUI();\n      scene.executeWhenReady(() => {\n        scene.getEngine().hideLoadingUI();\n        this._ShowingLoadingScreen = false;\n      });\n    }\n    const errorHandler = (message, exception) => {\n      const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);\n      if (onError) {\n        onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\n      } else {\n        Logger.Error(errorMessage);\n        // should the exception be thrown?\n      }\n\n      disposeHandler();\n    };\n    const progressHandler = onProgress ? event => {\n      try {\n        onProgress(event);\n      } catch (e) {\n        errorHandler(\"Error in onProgress callback\", e);\n      }\n    } : undefined;\n    const successHandler = () => {\n      if (onSuccess) {\n        try {\n          onSuccess(scene);\n        } catch (e) {\n          errorHandler(\"Error in onSuccess callback\", e);\n        }\n      }\n      scene.removePendingData(loadingToken);\n    };\n    return SceneLoader._LoadData(fileInfo, scene, (plugin, data) => {\n      if (plugin.load) {\n        const syncedPlugin = plugin;\n        if (!syncedPlugin.load(scene, data, fileInfo.rootUrl, errorHandler)) {\n          return;\n        }\n        scene.loadingPluginName = plugin.name;\n        successHandler();\n      } else {\n        const asyncedPlugin = plugin;\n        asyncedPlugin.loadAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(() => {\n          scene.loadingPluginName = plugin.name;\n          successHandler();\n        }).catch(error => {\n          errorHandler(error.message, error);\n        });\n      }\n    }, progressHandler, errorHandler, disposeHandler, pluginExtension, name);\n  }\n  /**\n   * Append a scene\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene is the instance of BABYLON.Scene to append to\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns The given scene\n   */\n  static AppendAsync(rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, onProgress = null, pluginExtension = null, name = \"\") {\n    return new Promise((resolve, reject) => {\n      SceneLoader.Append(rootUrl, sceneFilename, scene, scene => {\n        resolve(scene);\n      }, onProgress, (scene, message, exception) => {\n        reject(exception || new Error(message));\n      }, pluginExtension, name);\n    });\n  }\n  /**\n   * Load a scene into an asset container\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\n   * @param onSuccess a callback with the scene when import succeeds\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns The loaded plugin\n   */\n  static LoadAssetContainer(rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name = \"\") {\n    if (!scene) {\n      Logger.Error(\"No scene available to load asset container to\");\n      return null;\n    }\n    const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\n    if (!fileInfo) {\n      return null;\n    }\n    const loadingToken = {};\n    scene.addPendingData(loadingToken);\n    const disposeHandler = () => {\n      scene.removePendingData(loadingToken);\n    };\n    const errorHandler = (message, exception) => {\n      const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);\n      if (onError) {\n        onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\n      } else {\n        Logger.Error(errorMessage);\n        // should the exception be thrown?\n      }\n\n      disposeHandler();\n    };\n    const progressHandler = onProgress ? event => {\n      try {\n        onProgress(event);\n      } catch (e) {\n        errorHandler(\"Error in onProgress callback\", e);\n      }\n    } : undefined;\n    const successHandler = assets => {\n      if (onSuccess) {\n        try {\n          onSuccess(assets);\n        } catch (e) {\n          errorHandler(\"Error in onSuccess callback\", e);\n        }\n      }\n      scene.removePendingData(loadingToken);\n    };\n    return SceneLoader._LoadData(fileInfo, scene, (plugin, data) => {\n      if (plugin.loadAssetContainer) {\n        const syncedPlugin = plugin;\n        const assetContainer = syncedPlugin.loadAssetContainer(scene, data, fileInfo.rootUrl, errorHandler);\n        if (!assetContainer) {\n          return;\n        }\n        assetContainer.populateRootNodes();\n        scene.loadingPluginName = plugin.name;\n        successHandler(assetContainer);\n      } else if (plugin.loadAssetContainerAsync) {\n        const asyncedPlugin = plugin;\n        asyncedPlugin.loadAssetContainerAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(assetContainer => {\n          assetContainer.populateRootNodes();\n          scene.loadingPluginName = plugin.name;\n          successHandler(assetContainer);\n        }).catch(error => {\n          errorHandler(error.message, error);\n        });\n      } else {\n        errorHandler(\"LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.\");\n      }\n    }, progressHandler, errorHandler, disposeHandler, pluginExtension, name);\n  }\n  /**\n   * Load a scene into an asset container\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene (default: empty string)\n   * @param scene is the instance of Scene to append to\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns The loaded asset container\n   */\n  static LoadAssetContainerAsync(rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, onProgress = null, pluginExtension = null) {\n    return new Promise((resolve, reject) => {\n      SceneLoader.LoadAssetContainer(rootUrl, sceneFilename, scene, assetContainer => {\n        resolve(assetContainer);\n      }, onProgress, (scene, message, exception) => {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  }\n  /**\n   * Import animations from a file into a scene\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\n   * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\n   * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\n   * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\n   * @param onSuccess a callback with the scene when import succeeds\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\n   * @param pluginExtension the extension used to determine the plugin\n   */\n  static ImportAnimations(rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, overwriteAnimations = true, animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean, targetConverter = null, onSuccess = null, onProgress = null, onError = null, pluginExtension = null) {\n    if (!scene) {\n      Logger.Error(\"No scene available to load animations to\");\n      return;\n    }\n    if (overwriteAnimations) {\n      // Reset, stop and dispose all animations before loading new ones\n      for (const animatable of scene.animatables) {\n        animatable.reset();\n      }\n      scene.stopAllAnimations();\n      scene.animationGroups.slice().forEach(animationGroup => {\n        animationGroup.dispose();\n      });\n      const nodes = scene.getNodes();\n      nodes.forEach(node => {\n        if (node.animations) {\n          node.animations = [];\n        }\n      });\n    } else {\n      switch (animationGroupLoadingMode) {\n        case SceneLoaderAnimationGroupLoadingMode.Clean:\n          scene.animationGroups.slice().forEach(animationGroup => {\n            animationGroup.dispose();\n          });\n          break;\n        case SceneLoaderAnimationGroupLoadingMode.Stop:\n          scene.animationGroups.forEach(animationGroup => {\n            animationGroup.stop();\n          });\n          break;\n        case SceneLoaderAnimationGroupLoadingMode.Sync:\n          scene.animationGroups.forEach(animationGroup => {\n            animationGroup.reset();\n            animationGroup.restart();\n          });\n          break;\n        case SceneLoaderAnimationGroupLoadingMode.NoSync:\n          // nothing to do\n          break;\n        default:\n          Logger.Error(\"Unknown animation group loading mode value '\" + animationGroupLoadingMode + \"'\");\n          return;\n      }\n    }\n    const startingIndexForNewAnimatables = scene.animatables.length;\n    const onAssetContainerLoaded = container => {\n      container.mergeAnimationsTo(scene, scene.animatables.slice(startingIndexForNewAnimatables), targetConverter);\n      container.dispose();\n      scene.onAnimationFileImportedObservable.notifyObservers(scene);\n      if (onSuccess) {\n        onSuccess(scene);\n      }\n    };\n    this.LoadAssetContainer(rootUrl, sceneFilename, scene, onAssetContainerLoaded, onProgress, onError, pluginExtension);\n  }\n  /**\n   * Import animations from a file into a scene\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\n   * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\n   * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\n   * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\n   * @param onSuccess a callback with the scene when import succeeds\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns the updated scene with imported animations\n   */\n  static ImportAnimationsAsync(rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, overwriteAnimations = true, animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean, targetConverter = null,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onSuccess = null, onProgress = null,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onError = null, pluginExtension = null) {\n    return new Promise((resolve, reject) => {\n      SceneLoader.ImportAnimations(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, _scene => {\n        resolve(_scene);\n      }, onProgress, (_scene, message, exception) => {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  }\n}\n/**\n * No logging while loading\n */\nSceneLoader.NO_LOGGING = 0;\n/**\n * Minimal logging while loading\n */\nSceneLoader.MINIMAL_LOGGING = 1;\n/**\n * Summary logging while loading\n */\nSceneLoader.SUMMARY_LOGGING = 2;\n/**\n * Detailed logging while loading\n */\nSceneLoader.DETAILED_LOGGING = 3;\n// Members\n/**\n * Event raised when a plugin is used to load a scene\n */\nSceneLoader.OnPluginActivatedObservable = new Observable();\nSceneLoader._RegisteredPlugins = {};\nSceneLoader._ShowingLoadingScreen = false;","map":{"version":3,"names":["Tools","Observable","Scene","Engine","EngineStore","Logger","SceneLoaderFlags","IsBase64DataUrl","RuntimeError","ErrorCodes","SceneLoaderAnimationGroupLoadingMode","SceneLoader","ForceFullSceneLoadingForIncremental","value","ShowLoadingScreen","loggingLevel","CleanBoneMatrixWeights","GetDefaultPlugin","_RegisteredPlugins","_GetPluginForExtension","extension","registeredPlugin","Warn","_GetPluginForDirectLoad","data","plugin","canDirectLoad","_GetPluginForFilename","sceneFilename","queryStringPosition","indexOf","substring","dotPosition","lastIndexOf","length","toLowerCase","_GetDirectLoad","substr","_FormatErrorMessage","fileInfo","message","exception","fromLoad","rawData","url","errorMessage","_LoadData","scene","onSuccess","onProgress","onError","onDispose","pluginExtension","name","directLoad","isBinary","createPlugin","undefined","OnPluginActivatedObservable","notifyObservers","result","then","catch","error","useArrayBuffer","dataCallback","responseURL","isDisposed","request","pluginDisposed","onDisposeObservable","add","abort","manifestChecked","errorCallback","statusText","loadFile","file","rootUrl","_loadFile","engine","getEngine","canUseOfflineSupport","enableOfflineSupport","exceptionFound","regex","disableOfflineSupportExceptionRules","test","OfflineProviderFactory","offlineProvider","disableManifestCheck","_GetFileInfo","GetFilename","GetFolderPath","sceneFile","ArrayBuffer","isView","startsWith","filename","Error","GetPluginForExtension","IsPluginForExtensionAvailable","RegisterPlugin","extensions","Object","keys","forEach","ImportMesh","meshNames","LastCreatedScene","loadingToken","addPendingData","disposeHandler","removePendingData","errorHandler","SceneLoaderError","progressHandler","event","e","successHandler","meshes","particleSystems","skeletons","animationGroups","transformNodes","geometries","lights","importedMeshesFiles","push","rewriteRootURL","importMesh","syncedPlugin","Array","loadingPluginName","asyncedPlugin","importMeshAsync","ImportMeshAsync","Promise","resolve","reject","Load","LastCreatedEngine","Append","LoadAsync","_ShowingLoadingScreen","displayLoadingUI","executeWhenReady","hideLoadingUI","load","loadAsync","AppendAsync","LoadAssetContainer","assets","loadAssetContainer","assetContainer","populateRootNodes","loadAssetContainerAsync","LoadAssetContainerAsync","ImportAnimations","overwriteAnimations","animationGroupLoadingMode","Clean","targetConverter","animatable","animatables","reset","stopAllAnimations","slice","animationGroup","dispose","nodes","getNodes","node","animations","Stop","stop","Sync","restart","NoSync","startingIndexForNewAnimatables","onAssetContainerLoaded","container","mergeAnimationsTo","onAnimationFileImportedObservable","ImportAnimationsAsync","_scene","NO_LOGGING","MINIMAL_LOGGING","SUMMARY_LOGGING","DETAILED_LOGGING"],"sources":["../../../../dev/core/src/Loading/sceneLoader.ts"],"sourcesContent":["import { Tools } from \"../Misc/tools\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { AnimationGroup } from \"../Animations/animationGroup\";\r\nimport type { AssetContainer } from \"../assetContainer\";\r\nimport type { IParticleSystem } from \"../Particles/IParticleSystem\";\r\nimport type { Skeleton } from \"../Bones/skeleton\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { SceneLoaderFlags } from \"./sceneLoaderFlags\";\r\nimport type { IFileRequest } from \"../Misc/fileRequest\";\r\nimport type { WebRequest } from \"../Misc/webRequest\";\r\nimport type { LoadFileError } from \"../Misc/fileTools\";\r\nimport { IsBase64DataUrl } from \"../Misc/fileTools\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { Geometry } from \"../Meshes/geometry\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport { RuntimeError, ErrorCodes } from \"../Misc/error\";\r\n\r\n/**\r\n * Type used for the success callback of ImportMesh\r\n */\r\nexport type SceneLoaderSuccessCallback = (\r\n    meshes: AbstractMesh[],\r\n    particleSystems: IParticleSystem[],\r\n    skeletons: Skeleton[],\r\n    animationGroups: AnimationGroup[],\r\n    transformNodes: TransformNode[],\r\n    geometries: Geometry[],\r\n    lights: Light[]\r\n) => void;\r\n\r\n/**\r\n * Interface used for the result of ImportMeshAsync\r\n */\r\nexport interface ISceneLoaderAsyncResult {\r\n    /**\r\n     * The array of loaded meshes\r\n     */\r\n    readonly meshes: AbstractMesh[];\r\n\r\n    /**\r\n     * The array of loaded particle systems\r\n     */\r\n    readonly particleSystems: IParticleSystem[];\r\n\r\n    /**\r\n     * The array of loaded skeletons\r\n     */\r\n    readonly skeletons: Skeleton[];\r\n\r\n    /**\r\n     * The array of loaded animation groups\r\n     */\r\n    readonly animationGroups: AnimationGroup[];\r\n\r\n    /**\r\n     * The array of loaded transform nodes\r\n     */\r\n    readonly transformNodes: TransformNode[];\r\n\r\n    /**\r\n     * The array of loaded geometries\r\n     */\r\n    readonly geometries: Geometry[];\r\n\r\n    /**\r\n     * The array of loaded lights\r\n     */\r\n    readonly lights: Light[];\r\n}\r\n\r\n/**\r\n * Interface used to represent data loading progression\r\n */\r\nexport interface ISceneLoaderProgressEvent {\r\n    /**\r\n     * Defines if data length to load can be evaluated\r\n     */\r\n    readonly lengthComputable: boolean;\r\n\r\n    /**\r\n     * Defines the loaded data length\r\n     */\r\n    readonly loaded: number;\r\n\r\n    /**\r\n     * Defines the data length to load\r\n     */\r\n    readonly total: number;\r\n}\r\n\r\n/**\r\n * Interface used by SceneLoader plugins to define supported file extensions\r\n */\r\nexport interface ISceneLoaderPluginExtensions {\r\n    /**\r\n     * Defines the list of supported extensions\r\n     */\r\n    [extension: string]: {\r\n        isBinary: boolean;\r\n    };\r\n}\r\n\r\n/**\r\n * Interface used by SceneLoader plugin factory\r\n */\r\nexport interface ISceneLoaderPluginFactory {\r\n    /**\r\n     * Defines the name of the factory\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * Function called to create a new plugin\r\n     * @returns the new plugin\r\n     */\r\n    createPlugin(): ISceneLoaderPlugin | ISceneLoaderPluginAsync;\r\n\r\n    /**\r\n     * The callback that returns true if the data can be directly loaded.\r\n     * @param data string containing the file data\r\n     * @returns if the data can be loaded directly\r\n     */\r\n    canDirectLoad?(data: string): boolean;\r\n}\r\n\r\n/**\r\n * Interface used to define the base of ISceneLoaderPlugin and ISceneLoaderPluginAsync\r\n */\r\nexport interface ISceneLoaderPluginBase {\r\n    /**\r\n     * The friendly name of this plugin.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * The file extensions supported by this plugin.\r\n     */\r\n    extensions: string | ISceneLoaderPluginExtensions;\r\n\r\n    /**\r\n     * The callback called when loading from a url.\r\n     * @param scene scene loading this url\r\n     * @param fileOrUrl file or url to load\r\n     * @param onSuccess callback called when the file successfully loads\r\n     * @param onProgress callback called while file is loading (if the server supports this mode)\r\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n     * @param onError callback called when the file fails to load\r\n     * @returns a file request object\r\n     */\r\n    loadFile?(\r\n        scene: Scene,\r\n        fileOrUrl: File | string | ArrayBufferView,\r\n        rootUrl: string,\r\n        onSuccess: (data: any, responseURL?: string) => void,\r\n        onProgress?: (ev: ISceneLoaderProgressEvent) => void,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void,\r\n        name?: string\r\n    ): Nullable<IFileRequest>;\r\n\r\n    /**\r\n     * The callback that returns true if the data can be directly loaded.\r\n     * @param data string containing the file data\r\n     * @returns if the data can be loaded directly\r\n     */\r\n    canDirectLoad?(data: string): boolean;\r\n\r\n    /**\r\n     * The callback that returns the data to pass to the plugin if the data can be directly loaded.\r\n     * @param scene scene loading this data\r\n     * @param data string containing the data\r\n     * @returns data to pass to the plugin\r\n     */\r\n    directLoad?(scene: Scene, data: string): any;\r\n\r\n    /**\r\n     * The callback that allows custom handling of the root url based on the response url.\r\n     * @param rootUrl the original root url\r\n     * @param responseURL the response url if available\r\n     * @returns the new root url\r\n     */\r\n    rewriteRootURL?(rootUrl: string, responseURL?: string): string;\r\n}\r\n\r\n/**\r\n * Interface used to define a SceneLoader plugin\r\n */\r\nexport interface ISceneLoaderPlugin extends ISceneLoaderPluginBase {\r\n    /**\r\n     * Import meshes into a scene.\r\n     * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param scene The scene to import into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param meshes The meshes array to import into\r\n     * @param particleSystems The particle systems array to import into\r\n     * @param skeletons The skeletons array to import into\r\n     * @param onError The callback when import fails\r\n     * @returns True if successful or false otherwise\r\n     */\r\n    importMesh(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        data: any,\r\n        rootUrl: string,\r\n        meshes: AbstractMesh[],\r\n        particleSystems: IParticleSystem[],\r\n        skeletons: Skeleton[],\r\n        onError?: (message: string, exception?: any) => void\r\n    ): boolean;\r\n\r\n    /**\r\n     * Load into a scene.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onError The callback when import fails\r\n     * @returns True if successful or false otherwise\r\n     */\r\n    load(scene: Scene, data: any, rootUrl: string, onError?: (message: string, exception?: any) => void): boolean;\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onError The callback when import fails\r\n     * @returns The loaded asset container\r\n     */\r\n    loadAssetContainer(scene: Scene, data: any, rootUrl: string, onError?: (message: string, exception?: any) => void): AssetContainer;\r\n}\r\n\r\n/**\r\n * Interface used to define an async SceneLoader plugin\r\n */\r\nexport interface ISceneLoaderPluginAsync extends ISceneLoaderPluginBase {\r\n    /**\r\n     * Import meshes into a scene.\r\n     * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param scene The scene to import into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns The loaded objects (e.g. meshes, particle systems, skeletons, animation groups, etc.)\r\n     */\r\n    importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        data: any,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName?: string\r\n    ): Promise<ISceneLoaderAsyncResult>;\r\n\r\n    /**\r\n     * Load into a scene.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns Nothing\r\n     */\r\n    loadAsync(scene: Scene, data: any, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<void>;\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns The loaded asset container\r\n     */\r\n    loadAssetContainerAsync(scene: Scene, data: any, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<AssetContainer>;\r\n}\r\n\r\n/**\r\n * Mode that determines how to handle old animation groups before loading new ones.\r\n */\r\nexport enum SceneLoaderAnimationGroupLoadingMode {\r\n    /**\r\n     * Reset all old animations to initial state then dispose them.\r\n     */\r\n    Clean = 0,\r\n\r\n    /**\r\n     * Stop all old animations.\r\n     */\r\n    Stop = 1,\r\n\r\n    /**\r\n     * Restart old animations from first frame.\r\n     */\r\n    Sync = 2,\r\n\r\n    /**\r\n     * Old animations remains untouched.\r\n     */\r\n    NoSync = 3,\r\n}\r\n\r\n/**\r\n * Defines a plugin registered by the SceneLoader\r\n */\r\ninterface IRegisteredPlugin {\r\n    /**\r\n     * Defines the plugin to use\r\n     */\r\n    plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync | ISceneLoaderPluginFactory;\r\n    /**\r\n     * Defines if the plugin supports binary data\r\n     */\r\n    isBinary: boolean;\r\n}\r\n\r\n/**\r\n * Defines file information\r\n */\r\ninterface IFileInfo {\r\n    /**\r\n     * Gets the file url\r\n     */\r\n    url: string;\r\n    /**\r\n     * Gets the root url\r\n     */\r\n    rootUrl: string;\r\n    /**\r\n     * Gets filename\r\n     */\r\n    name: string;\r\n    /**\r\n     * Gets the file\r\n     */\r\n    file: Nullable<File>;\r\n\r\n    /**\r\n     * Gets raw binary data.\r\n     */\r\n    rawData: Nullable<ArrayBufferView>;\r\n}\r\n\r\n/**\r\n * Class used to load scene from various file formats using registered plugins\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes\r\n */\r\nexport class SceneLoader {\r\n    /**\r\n     * No logging while loading\r\n     */\r\n    public static readonly NO_LOGGING = Constants.SCENELOADER_NO_LOGGING;\r\n\r\n    /**\r\n     * Minimal logging while loading\r\n     */\r\n    public static readonly MINIMAL_LOGGING = Constants.SCENELOADER_MINIMAL_LOGGING;\r\n\r\n    /**\r\n     * Summary logging while loading\r\n     */\r\n    public static readonly SUMMARY_LOGGING = Constants.SCENELOADER_SUMMARY_LOGGING;\r\n\r\n    /**\r\n     * Detailed logging while loading\r\n     */\r\n    public static readonly DETAILED_LOGGING = Constants.SCENELOADER_DETAILED_LOGGING;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data\r\n     */\r\n    public static get ForceFullSceneLoadingForIncremental() {\r\n        return SceneLoaderFlags.ForceFullSceneLoadingForIncremental;\r\n    }\r\n\r\n    public static set ForceFullSceneLoadingForIncremental(value: boolean) {\r\n        SceneLoaderFlags.ForceFullSceneLoadingForIncremental = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if loading screen must be displayed while loading a scene\r\n     */\r\n    public static get ShowLoadingScreen(): boolean {\r\n        return SceneLoaderFlags.ShowLoadingScreen;\r\n    }\r\n\r\n    public static set ShowLoadingScreen(value: boolean) {\r\n        SceneLoaderFlags.ShowLoadingScreen = value;\r\n    }\r\n\r\n    /**\r\n     * Defines the current logging level (while loading the scene)\r\n     * @ignorenaming\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static get loggingLevel(): number {\r\n        return SceneLoaderFlags.loggingLevel;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static set loggingLevel(value: number) {\r\n        SceneLoaderFlags.loggingLevel = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or set a boolean indicating if matrix weights must be cleaned upon loading\r\n     */\r\n    public static get CleanBoneMatrixWeights(): boolean {\r\n        return SceneLoaderFlags.CleanBoneMatrixWeights;\r\n    }\r\n\r\n    public static set CleanBoneMatrixWeights(value: boolean) {\r\n        SceneLoaderFlags.CleanBoneMatrixWeights = value;\r\n    }\r\n\r\n    // Members\r\n\r\n    /**\r\n     * Event raised when a plugin is used to load a scene\r\n     */\r\n    public static OnPluginActivatedObservable = new Observable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>();\r\n\r\n    private static _RegisteredPlugins: { [extension: string]: IRegisteredPlugin } = {};\r\n\r\n    private static _ShowingLoadingScreen = false;\r\n\r\n    /**\r\n     * Gets the default plugin (used to load Babylon files)\r\n     * @returns the .babylon plugin\r\n     */\r\n    public static GetDefaultPlugin(): IRegisteredPlugin {\r\n        return SceneLoader._RegisteredPlugins[\".babylon\"];\r\n    }\r\n\r\n    private static _GetPluginForExtension(extension: string): IRegisteredPlugin {\r\n        const registeredPlugin = SceneLoader._RegisteredPlugins[extension];\r\n        if (registeredPlugin) {\r\n            return registeredPlugin;\r\n        }\r\n        Logger.Warn(\r\n            \"Unable to find a plugin to load \" +\r\n                extension +\r\n                \" files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes\"\r\n        );\r\n        return SceneLoader.GetDefaultPlugin();\r\n    }\r\n\r\n    private static _GetPluginForDirectLoad(data: string): IRegisteredPlugin {\r\n        for (const extension in SceneLoader._RegisteredPlugins) {\r\n            const plugin = SceneLoader._RegisteredPlugins[extension].plugin;\r\n\r\n            if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {\r\n                return SceneLoader._RegisteredPlugins[extension];\r\n            }\r\n        }\r\n\r\n        return SceneLoader.GetDefaultPlugin();\r\n    }\r\n\r\n    private static _GetPluginForFilename(sceneFilename: string): IRegisteredPlugin {\r\n        const queryStringPosition = sceneFilename.indexOf(\"?\");\r\n\r\n        if (queryStringPosition !== -1) {\r\n            sceneFilename = sceneFilename.substring(0, queryStringPosition);\r\n        }\r\n\r\n        const dotPosition = sceneFilename.lastIndexOf(\".\");\r\n\r\n        const extension = sceneFilename.substring(dotPosition, sceneFilename.length).toLowerCase();\r\n        return SceneLoader._GetPluginForExtension(extension);\r\n    }\r\n\r\n    private static _GetDirectLoad(sceneFilename: string): Nullable<string> {\r\n        if (sceneFilename.substr(0, 5) === \"data:\") {\r\n            return sceneFilename.substr(5);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private static _FormatErrorMessage(fileInfo: IFileInfo, message?: string, exception?: any): string {\r\n        const fromLoad = fileInfo.rawData ? \"binary data\" : fileInfo.url;\r\n        let errorMessage = \"Unable to load from \" + fromLoad;\r\n\r\n        if (message) {\r\n            errorMessage += `: ${message}`;\r\n        } else if (exception) {\r\n            errorMessage += `: ${exception}`;\r\n        }\r\n\r\n        return errorMessage;\r\n    }\r\n\r\n    private static _LoadData(\r\n        fileInfo: IFileInfo,\r\n        scene: Scene,\r\n        onSuccess: (plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync, data: any, responseURL?: string) => void,\r\n        onProgress: ((event: ISceneLoaderProgressEvent) => void) | undefined,\r\n        onError: (message?: string, exception?: any) => void,\r\n        onDispose: () => void,\r\n        pluginExtension: Nullable<string>,\r\n        name: string\r\n    ): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync> {\r\n        const directLoad = SceneLoader._GetDirectLoad(fileInfo.url);\r\n\r\n        if (fileInfo.rawData && !pluginExtension) {\r\n            throw \"When using ArrayBufferView to load data the file extension must be provided.\";\r\n        }\r\n\r\n        const registeredPlugin = pluginExtension\r\n            ? SceneLoader._GetPluginForExtension(pluginExtension)\r\n            : directLoad\r\n            ? SceneLoader._GetPluginForDirectLoad(fileInfo.url)\r\n            : SceneLoader._GetPluginForFilename(fileInfo.url);\r\n\r\n        if (fileInfo.rawData && !registeredPlugin.isBinary) {\r\n            throw \"Loading from ArrayBufferView can not be used with plugins that don't support binary loading.\";\r\n        }\r\n\r\n        let plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync;\r\n\r\n        if ((registeredPlugin.plugin as ISceneLoaderPluginFactory).createPlugin !== undefined) {\r\n            plugin = (registeredPlugin.plugin as ISceneLoaderPluginFactory).createPlugin();\r\n        } else {\r\n            plugin = <any>registeredPlugin.plugin;\r\n        }\r\n\r\n        if (!plugin) {\r\n            throw \"The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.\";\r\n        }\r\n\r\n        SceneLoader.OnPluginActivatedObservable.notifyObservers(plugin);\r\n\r\n        // Check if we have a direct load url. If the plugin is registered to handle\r\n        // it or it's not a base64 data url, then pass it through the direct load path.\r\n        if (directLoad && ((plugin.canDirectLoad && plugin.canDirectLoad(fileInfo.url)) || !IsBase64DataUrl(fileInfo.url))) {\r\n            if (plugin.directLoad) {\r\n                const result = plugin.directLoad(scene, directLoad);\r\n                if (result.then) {\r\n                    result\r\n                        .then((data: any) => {\r\n                            onSuccess(plugin, data);\r\n                        })\r\n                        .catch((error: any) => {\r\n                            onError(\"Error in directLoad of _loadData: \" + error, error);\r\n                        });\r\n                } else {\r\n                    onSuccess(plugin, result);\r\n                }\r\n            } else {\r\n                onSuccess(plugin, directLoad);\r\n            }\r\n            return plugin;\r\n        }\r\n\r\n        const useArrayBuffer = registeredPlugin.isBinary;\r\n\r\n        const dataCallback = (data: any, responseURL?: string) => {\r\n            if (scene.isDisposed) {\r\n                onError(\"Scene has been disposed\");\r\n                return;\r\n            }\r\n\r\n            onSuccess(plugin, data, responseURL);\r\n        };\r\n\r\n        let request: Nullable<IFileRequest> = null;\r\n        let pluginDisposed = false;\r\n        const onDisposeObservable = (plugin as any).onDisposeObservable as Observable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>;\r\n        if (onDisposeObservable) {\r\n            onDisposeObservable.add(() => {\r\n                pluginDisposed = true;\r\n\r\n                if (request) {\r\n                    request.abort();\r\n                    request = null;\r\n                }\r\n\r\n                onDispose();\r\n            });\r\n        }\r\n\r\n        const manifestChecked = () => {\r\n            if (pluginDisposed) {\r\n                return;\r\n            }\r\n\r\n            const errorCallback = (request?: WebRequest, exception?: LoadFileError) => {\r\n                onError(request?.statusText, exception);\r\n            };\r\n\r\n            if (!plugin.loadFile && fileInfo.rawData) {\r\n                throw \"Plugin does not support loading ArrayBufferView.\";\r\n            }\r\n\r\n            request = plugin.loadFile\r\n                ? plugin.loadFile(scene, fileInfo.rawData || fileInfo.file || fileInfo.url, fileInfo.rootUrl, dataCallback, onProgress, useArrayBuffer, errorCallback, name)\r\n                : scene._loadFile(fileInfo.file || fileInfo.url, dataCallback, onProgress, true, useArrayBuffer, errorCallback);\r\n        };\r\n\r\n        const engine = scene.getEngine();\r\n        let canUseOfflineSupport = engine.enableOfflineSupport;\r\n        if (canUseOfflineSupport) {\r\n            // Also check for exceptions\r\n            let exceptionFound = false;\r\n            for (const regex of scene.disableOfflineSupportExceptionRules) {\r\n                if (regex.test(fileInfo.url)) {\r\n                    exceptionFound = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            canUseOfflineSupport = !exceptionFound;\r\n        }\r\n\r\n        if (canUseOfflineSupport && Engine.OfflineProviderFactory) {\r\n            // Checking if a manifest file has been set for this scene and if offline mode has been requested\r\n            scene.offlineProvider = Engine.OfflineProviderFactory(fileInfo.url, manifestChecked, engine.disableManifestCheck);\r\n        } else {\r\n            manifestChecked();\r\n        }\r\n\r\n        return plugin;\r\n    }\r\n\r\n    private static _GetFileInfo(rootUrl: string, sceneFilename: string | File | ArrayBufferView): Nullable<IFileInfo> {\r\n        let url: string;\r\n        let name: string;\r\n        let file: Nullable<File> = null;\r\n        let rawData: Nullable<ArrayBufferView> = null;\r\n\r\n        if (!sceneFilename) {\r\n            url = rootUrl;\r\n            name = Tools.GetFilename(rootUrl);\r\n            rootUrl = Tools.GetFolderPath(rootUrl);\r\n        } else if ((sceneFilename as File).name) {\r\n            const sceneFile = sceneFilename as File;\r\n            url = `file:${sceneFile.name}`;\r\n            name = sceneFile.name;\r\n            file = sceneFile;\r\n        } else if (ArrayBuffer.isView(sceneFilename)) {\r\n            url = \"\";\r\n            name = \"arrayBuffer\";\r\n            rawData = sceneFilename as ArrayBufferView;\r\n        } else if (typeof sceneFilename === \"string\" && sceneFilename.startsWith(\"data:\")) {\r\n            url = sceneFilename;\r\n            name = \"\";\r\n        } else {\r\n            const filename = sceneFilename as string;\r\n            if (filename.substr(0, 1) === \"/\") {\r\n                Tools.Error(\"Wrong sceneFilename parameter\");\r\n                return null;\r\n            }\r\n\r\n            url = rootUrl + filename;\r\n            name = filename;\r\n        }\r\n\r\n        return {\r\n            url: url,\r\n            rootUrl: rootUrl,\r\n            name: name,\r\n            file: file,\r\n            rawData,\r\n        };\r\n    }\r\n\r\n    // Public functions\r\n\r\n    /**\r\n     * Gets a plugin that can load the given extension\r\n     * @param extension defines the extension to load\r\n     * @returns a plugin or null if none works\r\n     */\r\n    public static GetPluginForExtension(extension: string): ISceneLoaderPlugin | ISceneLoaderPluginAsync | ISceneLoaderPluginFactory {\r\n        return SceneLoader._GetPluginForExtension(extension).plugin;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the given extension can be loaded\r\n     * @param extension defines the extension to load\r\n     * @returns true if the extension is supported\r\n     */\r\n    public static IsPluginForExtensionAvailable(extension: string): boolean {\r\n        return !!SceneLoader._RegisteredPlugins[extension];\r\n    }\r\n\r\n    /**\r\n     * Adds a new plugin to the list of registered plugins\r\n     * @param plugin defines the plugin to add\r\n     */\r\n    public static RegisterPlugin(plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync): void {\r\n        if (typeof plugin.extensions === \"string\") {\r\n            const extension = <string>plugin.extensions;\r\n            SceneLoader._RegisteredPlugins[extension.toLowerCase()] = {\r\n                plugin: plugin,\r\n                isBinary: false,\r\n            };\r\n        } else {\r\n            const extensions = <ISceneLoaderPluginExtensions>plugin.extensions;\r\n            Object.keys(extensions).forEach((extension) => {\r\n                SceneLoader._RegisteredPlugins[extension.toLowerCase()] = {\r\n                    plugin: plugin,\r\n                    isBinary: extensions[extension].isBinary,\r\n                };\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Import meshes into a scene\r\n     * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene the instance of BABYLON.Scene to append to\r\n     * @param onSuccess a callback with a list of imported meshes, particleSystems, skeletons, and animationGroups when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded plugin\r\n     */\r\n    public static ImportMesh(\r\n        meshNames: any,\r\n        rootUrl: string,\r\n        sceneFilename: string | File | ArrayBufferView = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        onSuccess: Nullable<SceneLoaderSuccessCallback> = null,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n        pluginExtension: Nullable<string> = null,\r\n        name: string = \"\"\r\n    ): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync> {\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to import mesh to\");\r\n            return null;\r\n        }\r\n\r\n        const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\r\n        if (!fileInfo) {\r\n            return null;\r\n        }\r\n\r\n        const loadingToken = {};\r\n        scene.addPendingData(loadingToken);\r\n\r\n        const disposeHandler = () => {\r\n            scene.removePendingData(loadingToken);\r\n        };\r\n\r\n        const errorHandler = (message?: string, exception?: any) => {\r\n            const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);\r\n\r\n            if (onError) {\r\n                onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\r\n            } else {\r\n                Logger.Error(errorMessage);\r\n                // should the exception be thrown?\r\n            }\r\n\r\n            disposeHandler();\r\n        };\r\n\r\n        const progressHandler = onProgress\r\n            ? (event: ISceneLoaderProgressEvent) => {\r\n                  try {\r\n                      onProgress(event);\r\n                  } catch (e) {\r\n                      errorHandler(\"Error in onProgress callback: \" + e, e);\r\n                  }\r\n              }\r\n            : undefined;\r\n\r\n        const successHandler: SceneLoaderSuccessCallback = (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) => {\r\n            scene.importedMeshesFiles.push(fileInfo.url);\r\n\r\n            if (onSuccess) {\r\n                try {\r\n                    onSuccess(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights);\r\n                } catch (e) {\r\n                    errorHandler(\"Error in onSuccess callback: \" + e, e);\r\n                }\r\n            }\r\n\r\n            scene.removePendingData(loadingToken);\r\n        };\r\n\r\n        return SceneLoader._LoadData(\r\n            fileInfo,\r\n            scene,\r\n            (plugin, data, responseURL) => {\r\n                if (plugin.rewriteRootURL) {\r\n                    fileInfo.rootUrl = plugin.rewriteRootURL(fileInfo.rootUrl, responseURL);\r\n                }\r\n\r\n                if ((<any>plugin).importMesh) {\r\n                    const syncedPlugin = <ISceneLoaderPlugin>plugin;\r\n                    const meshes = new Array<AbstractMesh>();\r\n                    const particleSystems = new Array<IParticleSystem>();\r\n                    const skeletons = new Array<Skeleton>();\r\n\r\n                    if (!syncedPlugin.importMesh(meshNames, scene, data, fileInfo.rootUrl, meshes, particleSystems, skeletons, errorHandler)) {\r\n                        return;\r\n                    }\r\n\r\n                    scene.loadingPluginName = plugin.name;\r\n                    successHandler(meshes, particleSystems, skeletons, [], [], [], []);\r\n                } else {\r\n                    const asyncedPlugin = <ISceneLoaderPluginAsync>plugin;\r\n                    asyncedPlugin\r\n                        .importMeshAsync(meshNames, scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name)\r\n                        .then((result) => {\r\n                            scene.loadingPluginName = plugin.name;\r\n                            successHandler(\r\n                                result.meshes,\r\n                                result.particleSystems,\r\n                                result.skeletons,\r\n                                result.animationGroups,\r\n                                result.transformNodes,\r\n                                result.geometries,\r\n                                result.lights\r\n                            );\r\n                        })\r\n                        .catch((error) => {\r\n                            errorHandler(error.message, error);\r\n                        });\r\n                }\r\n            },\r\n            progressHandler,\r\n            errorHandler,\r\n            disposeHandler,\r\n            pluginExtension,\r\n            name\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Import meshes into a scene\r\n     * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene the instance of BABYLON.Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded list of imported meshes, particle systems, skeletons, and animation groups\r\n     */\r\n    public static ImportMeshAsync(\r\n        meshNames: any,\r\n        rootUrl: string,\r\n        sceneFilename: string | File | ArrayBufferView = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        pluginExtension: Nullable<string> = null,\r\n        name: string = \"\"\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        return new Promise((resolve, reject) => {\r\n            SceneLoader.ImportMesh(\r\n                meshNames,\r\n                rootUrl,\r\n                sceneFilename,\r\n                scene,\r\n                (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) => {\r\n                    resolve({\r\n                        meshes: meshes,\r\n                        particleSystems: particleSystems,\r\n                        skeletons: skeletons,\r\n                        animationGroups: animationGroups,\r\n                        transformNodes: transformNodes,\r\n                        geometries: geometries,\r\n                        lights: lights,\r\n                    });\r\n                },\r\n                onProgress,\r\n                (scene, message, exception) => {\r\n                    reject(exception || new Error(message));\r\n                },\r\n                pluginExtension,\r\n                name\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded plugin\r\n     */\r\n    public static Load(\r\n        rootUrl: string,\r\n        sceneFilename: string | File | ArrayBufferView = \"\",\r\n        engine: Nullable<Engine> = EngineStore.LastCreatedEngine,\r\n        onSuccess: Nullable<(scene: Scene) => void> = null,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n        pluginExtension: Nullable<string> = null,\r\n        name: string = \"\"\r\n    ): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync> {\r\n        if (!engine) {\r\n            Tools.Error(\"No engine available\");\r\n            return null;\r\n        }\r\n\r\n        return SceneLoader.Append(rootUrl, sceneFilename, new Scene(engine), onSuccess, onProgress, onError, pluginExtension, name);\r\n    }\r\n\r\n    /**\r\n     * Load a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded scene\r\n     */\r\n    public static LoadAsync(\r\n        rootUrl: string,\r\n        sceneFilename: string | File | ArrayBufferView = \"\",\r\n        engine: Nullable<Engine> = EngineStore.LastCreatedEngine,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        pluginExtension: Nullable<string> = null,\r\n        name: string = \"\"\r\n    ): Promise<Scene> {\r\n        return new Promise((resolve, reject) => {\r\n            SceneLoader.Load(\r\n                rootUrl,\r\n                sceneFilename,\r\n                engine,\r\n                (scene) => {\r\n                    resolve(scene);\r\n                },\r\n                onProgress,\r\n                (scene, message, exception) => {\r\n                    reject(exception || new Error(message));\r\n                },\r\n                pluginExtension,\r\n                name\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Append a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded plugin\r\n     */\r\n    public static Append(\r\n        rootUrl: string,\r\n        sceneFilename: string | File | ArrayBufferView = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        onSuccess: Nullable<(scene: Scene) => void> = null,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n        pluginExtension: Nullable<string> = null,\r\n        name: string = \"\"\r\n    ): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync> {\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to append to\");\r\n            return null;\r\n        }\r\n\r\n        const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\r\n        if (!fileInfo) {\r\n            return null;\r\n        }\r\n\r\n        const loadingToken = {};\r\n        scene.addPendingData(loadingToken);\r\n\r\n        const disposeHandler = () => {\r\n            scene.removePendingData(loadingToken);\r\n        };\r\n\r\n        if (SceneLoader.ShowLoadingScreen && !this._ShowingLoadingScreen) {\r\n            this._ShowingLoadingScreen = true;\r\n            scene.getEngine().displayLoadingUI();\r\n            scene.executeWhenReady(() => {\r\n                scene.getEngine().hideLoadingUI();\r\n                this._ShowingLoadingScreen = false;\r\n            });\r\n        }\r\n\r\n        const errorHandler = (message?: string, exception?: any) => {\r\n            const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);\r\n\r\n            if (onError) {\r\n                onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\r\n            } else {\r\n                Logger.Error(errorMessage);\r\n                // should the exception be thrown?\r\n            }\r\n\r\n            disposeHandler();\r\n        };\r\n\r\n        const progressHandler = onProgress\r\n            ? (event: ISceneLoaderProgressEvent) => {\r\n                  try {\r\n                      onProgress(event);\r\n                  } catch (e) {\r\n                      errorHandler(\"Error in onProgress callback\", e);\r\n                  }\r\n              }\r\n            : undefined;\r\n\r\n        const successHandler = () => {\r\n            if (onSuccess) {\r\n                try {\r\n                    onSuccess(scene);\r\n                } catch (e) {\r\n                    errorHandler(\"Error in onSuccess callback\", e);\r\n                }\r\n            }\r\n\r\n            scene.removePendingData(loadingToken);\r\n        };\r\n\r\n        return SceneLoader._LoadData(\r\n            fileInfo,\r\n            scene,\r\n            (plugin, data) => {\r\n                if ((<any>plugin).load) {\r\n                    const syncedPlugin = <ISceneLoaderPlugin>plugin;\r\n                    if (!syncedPlugin.load(scene, data, fileInfo.rootUrl, errorHandler)) {\r\n                        return;\r\n                    }\r\n\r\n                    scene.loadingPluginName = plugin.name;\r\n                    successHandler();\r\n                } else {\r\n                    const asyncedPlugin = <ISceneLoaderPluginAsync>plugin;\r\n                    asyncedPlugin\r\n                        .loadAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name)\r\n                        .then(() => {\r\n                            scene.loadingPluginName = plugin.name;\r\n                            successHandler();\r\n                        })\r\n                        .catch((error) => {\r\n                            errorHandler(error.message, error);\r\n                        });\r\n                }\r\n            },\r\n            progressHandler,\r\n            errorHandler,\r\n            disposeHandler,\r\n            pluginExtension,\r\n            name\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Append a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The given scene\r\n     */\r\n    public static AppendAsync(\r\n        rootUrl: string,\r\n        sceneFilename: string | File | ArrayBufferView = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        pluginExtension: Nullable<string> = null,\r\n        name: string = \"\"\r\n    ): Promise<Scene> {\r\n        return new Promise((resolve, reject) => {\r\n            SceneLoader.Append(\r\n                rootUrl,\r\n                sceneFilename,\r\n                scene,\r\n                (scene) => {\r\n                    resolve(scene);\r\n                },\r\n                onProgress,\r\n                (scene, message, exception) => {\r\n                    reject(exception || new Error(message));\r\n                },\r\n                pluginExtension,\r\n                name\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load a scene into an asset container\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded plugin\r\n     */\r\n    public static LoadAssetContainer(\r\n        rootUrl: string,\r\n        sceneFilename: string | File | ArrayBufferView = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        onSuccess: Nullable<(assets: AssetContainer) => void> = null,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n        pluginExtension: Nullable<string> = null,\r\n        name: string = \"\"\r\n    ): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync> {\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to load asset container to\");\r\n            return null;\r\n        }\r\n\r\n        const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\r\n        if (!fileInfo) {\r\n            return null;\r\n        }\r\n\r\n        const loadingToken = {};\r\n        scene.addPendingData(loadingToken);\r\n\r\n        const disposeHandler = () => {\r\n            scene.removePendingData(loadingToken);\r\n        };\r\n\r\n        const errorHandler = (message?: string, exception?: any) => {\r\n            const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);\r\n\r\n            if (onError) {\r\n                onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\r\n            } else {\r\n                Logger.Error(errorMessage);\r\n                // should the exception be thrown?\r\n            }\r\n\r\n            disposeHandler();\r\n        };\r\n\r\n        const progressHandler = onProgress\r\n            ? (event: ISceneLoaderProgressEvent) => {\r\n                  try {\r\n                      onProgress(event);\r\n                  } catch (e) {\r\n                      errorHandler(\"Error in onProgress callback\", e);\r\n                  }\r\n              }\r\n            : undefined;\r\n\r\n        const successHandler = (assets: AssetContainer) => {\r\n            if (onSuccess) {\r\n                try {\r\n                    onSuccess(assets);\r\n                } catch (e) {\r\n                    errorHandler(\"Error in onSuccess callback\", e);\r\n                }\r\n            }\r\n\r\n            scene.removePendingData(loadingToken);\r\n        };\r\n\r\n        return SceneLoader._LoadData(\r\n            fileInfo,\r\n            scene,\r\n            (plugin, data) => {\r\n                if ((<any>plugin).loadAssetContainer) {\r\n                    const syncedPlugin = <ISceneLoaderPlugin>plugin;\r\n                    const assetContainer = syncedPlugin.loadAssetContainer(scene, data, fileInfo.rootUrl, errorHandler);\r\n                    if (!assetContainer) {\r\n                        return;\r\n                    }\r\n                    assetContainer.populateRootNodes();\r\n                    scene.loadingPluginName = plugin.name;\r\n                    successHandler(assetContainer);\r\n                } else if ((<any>plugin).loadAssetContainerAsync) {\r\n                    const asyncedPlugin = <ISceneLoaderPluginAsync>plugin;\r\n                    asyncedPlugin\r\n                        .loadAssetContainerAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name)\r\n                        .then((assetContainer) => {\r\n                            assetContainer.populateRootNodes();\r\n                            scene.loadingPluginName = plugin.name;\r\n                            successHandler(assetContainer);\r\n                        })\r\n                        .catch((error) => {\r\n                            errorHandler(error.message, error);\r\n                        });\r\n                } else {\r\n                    errorHandler(\"LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.\");\r\n                }\r\n            },\r\n            progressHandler,\r\n            errorHandler,\r\n            disposeHandler,\r\n            pluginExtension,\r\n            name\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Load a scene into an asset container\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene (default: empty string)\r\n     * @param scene is the instance of Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded asset container\r\n     */\r\n    public static LoadAssetContainerAsync(\r\n        rootUrl: string,\r\n        sceneFilename: string | File = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        pluginExtension: Nullable<string> = null\r\n    ): Promise<AssetContainer> {\r\n        return new Promise((resolve, reject) => {\r\n            SceneLoader.LoadAssetContainer(\r\n                rootUrl,\r\n                sceneFilename,\r\n                scene,\r\n                (assetContainer) => {\r\n                    resolve(assetContainer);\r\n                },\r\n                onProgress,\r\n                (scene, message, exception) => {\r\n                    reject(exception || new Error(message));\r\n                },\r\n                pluginExtension\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Import animations from a file into a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\r\n     * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\r\n     * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     */\r\n    public static ImportAnimations(\r\n        rootUrl: string,\r\n        sceneFilename: string | File = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        overwriteAnimations = true,\r\n        animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean,\r\n        targetConverter: Nullable<(target: any) => any> = null,\r\n        onSuccess: Nullable<(scene: Scene) => void> = null,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n        pluginExtension: Nullable<string> = null\r\n    ): void {\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to load animations to\");\r\n            return;\r\n        }\r\n\r\n        if (overwriteAnimations) {\r\n            // Reset, stop and dispose all animations before loading new ones\r\n            for (const animatable of scene.animatables) {\r\n                animatable.reset();\r\n            }\r\n            scene.stopAllAnimations();\r\n            scene.animationGroups.slice().forEach((animationGroup) => {\r\n                animationGroup.dispose();\r\n            });\r\n            const nodes = scene.getNodes();\r\n            nodes.forEach((node) => {\r\n                if (node.animations) {\r\n                    node.animations = [];\r\n                }\r\n            });\r\n        } else {\r\n            switch (animationGroupLoadingMode) {\r\n                case SceneLoaderAnimationGroupLoadingMode.Clean:\r\n                    scene.animationGroups.slice().forEach((animationGroup) => {\r\n                        animationGroup.dispose();\r\n                    });\r\n                    break;\r\n                case SceneLoaderAnimationGroupLoadingMode.Stop:\r\n                    scene.animationGroups.forEach((animationGroup) => {\r\n                        animationGroup.stop();\r\n                    });\r\n                    break;\r\n                case SceneLoaderAnimationGroupLoadingMode.Sync:\r\n                    scene.animationGroups.forEach((animationGroup) => {\r\n                        animationGroup.reset();\r\n                        animationGroup.restart();\r\n                    });\r\n                    break;\r\n                case SceneLoaderAnimationGroupLoadingMode.NoSync:\r\n                    // nothing to do\r\n                    break;\r\n                default:\r\n                    Logger.Error(\"Unknown animation group loading mode value '\" + animationGroupLoadingMode + \"'\");\r\n                    return;\r\n            }\r\n        }\r\n\r\n        const startingIndexForNewAnimatables = scene.animatables.length;\r\n\r\n        const onAssetContainerLoaded = (container: AssetContainer) => {\r\n            container.mergeAnimationsTo(scene, scene.animatables.slice(startingIndexForNewAnimatables), targetConverter);\r\n\r\n            container.dispose();\r\n\r\n            scene.onAnimationFileImportedObservable.notifyObservers(scene);\r\n\r\n            if (onSuccess) {\r\n                onSuccess(scene);\r\n            }\r\n        };\r\n\r\n        this.LoadAssetContainer(rootUrl, sceneFilename, scene, onAssetContainerLoaded, onProgress, onError, pluginExtension);\r\n    }\r\n\r\n    /**\r\n     * Import animations from a file into a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\r\n     * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\r\n     * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns the updated scene with imported animations\r\n     */\r\n    public static ImportAnimationsAsync(\r\n        rootUrl: string,\r\n        sceneFilename: string | File = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        overwriteAnimations = true,\r\n        animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean,\r\n        targetConverter: Nullable<(target: any) => any> = null,\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        onSuccess: Nullable<(scene: Scene) => void> = null,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n        pluginExtension: Nullable<string> = null\r\n    ): Promise<Scene> {\r\n        return new Promise((resolve, reject) => {\r\n            SceneLoader.ImportAnimations(\r\n                rootUrl,\r\n                sceneFilename,\r\n                scene,\r\n                overwriteAnimations,\r\n                animationGroupLoadingMode,\r\n                targetConverter,\r\n                (_scene: Scene) => {\r\n                    resolve(_scene);\r\n                },\r\n                onProgress,\r\n                (_scene: Scene, message: string, exception: any) => {\r\n                    reject(exception || new Error(message));\r\n                },\r\n                pluginExtension\r\n            );\r\n        });\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}