{"ast":null,"code":"import \"core-js/modules/web.dom-exception.stack.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { GetDOMTextContent, IsWindowObjectExist } from \"../Misc/domManagement.js\";\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor.js\";\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport { ShaderLanguage } from \"../Materials/shaderLanguage.js\";\n/**\n * Effect wrapping a compute shader and let execute (dispatch) the shader\n */\nexport class ComputeEffect {\n  /**\n   * Creates a compute effect that can be used to execute a compute shader\n   * @param baseName Name of the effect\n   * @param options Set of all options to create the effect\n   * @param engine The engine the effect is created for\n   * @param key Effect Key identifying uniquely compiled shader variants\n   */\n  constructor(baseName, options, engine, key = \"\") {\n    var _a, _b;\n    /**\n     * Name of the effect.\n     */\n    this.name = null;\n    /**\n     * String container all the define statements that should be set on the shader.\n     */\n    this.defines = \"\";\n    /**\n     * Callback that will be called when the shader is compiled.\n     */\n    this.onCompiled = null;\n    /**\n     * Callback that will be called if an error occurs during shader compilation.\n     */\n    this.onError = null;\n    /**\n     * Unique ID of the effect.\n     */\n    this.uniqueId = 0;\n    /**\n     * Observable that will be called when the shader is compiled.\n     * It is recommended to use executeWhenCompile() or to make sure that scene.isReady() is called to get this observable raised.\n     */\n    this.onCompileObservable = new Observable();\n    /**\n     * Observable that will be called if an error occurs during shader compilation.\n     */\n    this.onErrorObservable = new Observable();\n    /**\n     * Observable that will be called when effect is bound.\n     */\n    this.onBindObservable = new Observable();\n    /**\n     * @internal\n     * Specifies if the effect was previously ready\n     */\n    this._wasPreviouslyReady = false;\n    this._isReady = false;\n    this._compilationError = \"\";\n    /** @internal */\n    this._key = \"\";\n    this._computeSourceCodeOverride = \"\";\n    /** @internal */\n    this._pipelineContext = null;\n    /** @internal */\n    this._computeSourceCode = \"\";\n    this._rawComputeSourceCode = \"\";\n    this._shaderLanguage = ShaderLanguage.WGSL;\n    this.name = baseName;\n    this._key = key;\n    this._engine = engine;\n    this.uniqueId = ComputeEffect._UniqueIdSeed++;\n    this.defines = (_a = options.defines) !== null && _a !== void 0 ? _a : \"\";\n    this.onError = options.onError;\n    this.onCompiled = options.onCompiled;\n    this._entryPoint = (_b = options.entryPoint) !== null && _b !== void 0 ? _b : \"main\";\n    this._shaderStore = ShaderStore.GetShadersStore(this._shaderLanguage);\n    this._shaderRepository = ShaderStore.GetShadersRepository(this._shaderLanguage);\n    this._includeShaderStore = ShaderStore.GetIncludesShadersStore(this._shaderLanguage);\n    let computeSource;\n    const hostDocument = IsWindowObjectExist() ? this._engine.getHostDocument() : null;\n    if (baseName.computeSource) {\n      computeSource = \"source:\" + baseName.computeSource;\n    } else if (baseName.computeElement) {\n      computeSource = hostDocument ? hostDocument.getElementById(baseName.computeElement) : null;\n      if (!computeSource) {\n        computeSource = baseName.computeElement;\n      }\n    } else {\n      computeSource = baseName.compute || baseName;\n    }\n    const processorOptions = {\n      defines: this.defines.split(\"\\n\"),\n      indexParameters: undefined,\n      isFragment: false,\n      shouldUseHighPrecisionShader: false,\n      processor: null,\n      supportsUniformBuffers: this._engine.supportsUniformBuffers,\n      shadersRepository: this._shaderRepository,\n      includesShadersStore: this._includeShaderStore,\n      version: (this._engine.version * 100).toString(),\n      platformName: this._engine.shaderPlatformName,\n      processingContext: null,\n      isNDCHalfZRange: this._engine.isNDCHalfZRange,\n      useReverseDepthBuffer: this._engine.useReverseDepthBuffer\n    };\n    this._loadShader(computeSource, \"Compute\", \"\", computeCode => {\n      ShaderProcessor.Initialize(processorOptions);\n      ShaderProcessor.PreProcess(computeCode, processorOptions, migratedCommputeCode => {\n        this._rawComputeSourceCode = computeCode;\n        if (options.processFinalCode) {\n          migratedCommputeCode = options.processFinalCode(migratedCommputeCode);\n        }\n        const finalShaders = ShaderProcessor.Finalize(migratedCommputeCode, \"\", processorOptions);\n        this._useFinalCode(finalShaders.vertexCode, baseName);\n      }, this._engine);\n    });\n  }\n  _useFinalCode(migratedCommputeCode, baseName) {\n    if (baseName) {\n      const compute = baseName.computeElement || baseName.compute || baseName.spectorName || baseName;\n      this._computeSourceCode = \"//#define SHADER_NAME compute:\" + compute + \"\\n\" + migratedCommputeCode;\n    } else {\n      this._computeSourceCode = migratedCommputeCode;\n    }\n    this._prepareEffect();\n  }\n  /**\n   * Unique key for this effect\n   */\n  get key() {\n    return this._key;\n  }\n  /**\n   * If the effect has been compiled and prepared.\n   * @returns if the effect is compiled and prepared.\n   */\n  isReady() {\n    try {\n      return this._isReadyInternal();\n    } catch (_a) {\n      return false;\n    }\n  }\n  _isReadyInternal() {\n    if (this._isReady) {\n      return true;\n    }\n    if (this._pipelineContext) {\n      return this._pipelineContext.isReady;\n    }\n    return false;\n  }\n  /**\n   * The engine the effect was initialized with.\n   * @returns the engine.\n   */\n  getEngine() {\n    return this._engine;\n  }\n  /**\n   * The pipeline context for this effect\n   * @returns the associated pipeline context\n   */\n  getPipelineContext() {\n    return this._pipelineContext;\n  }\n  /**\n   * The error from the last compilation.\n   * @returns the error string.\n   */\n  getCompilationError() {\n    return this._compilationError;\n  }\n  /**\n   * Adds a callback to the onCompiled observable and call the callback immediately if already ready.\n   * @param func The callback to be used.\n   */\n  executeWhenCompiled(func) {\n    if (this.isReady()) {\n      func(this);\n      return;\n    }\n    this.onCompileObservable.add(effect => {\n      func(effect);\n    });\n    if (!this._pipelineContext || this._pipelineContext.isAsync) {\n      setTimeout(() => {\n        this._checkIsReady(null);\n      }, 16);\n    }\n  }\n  _checkIsReady(previousPipelineContext) {\n    try {\n      if (this._isReadyInternal()) {\n        return;\n      }\n    } catch (e) {\n      this._processCompilationErrors(e, previousPipelineContext);\n      return;\n    }\n    setTimeout(() => {\n      this._checkIsReady(previousPipelineContext);\n    }, 16);\n  }\n  _loadShader(shader, key, optionalKey, callback) {\n    if (typeof HTMLElement !== \"undefined\") {\n      // DOM element ?\n      if (shader instanceof HTMLElement) {\n        const shaderCode = GetDOMTextContent(shader);\n        callback(shaderCode);\n        return;\n      }\n    }\n    // Direct source ?\n    if (shader.substr(0, 7) === \"source:\") {\n      callback(shader.substr(7));\n      return;\n    }\n    // Base64 encoded ?\n    if (shader.substr(0, 7) === \"base64:\") {\n      const shaderBinary = window.atob(shader.substr(7));\n      callback(shaderBinary);\n      return;\n    }\n    // Is in local store ?\n    if (this._shaderStore[shader + key + \"Shader\"]) {\n      callback(this._shaderStore[shader + key + \"Shader\"]);\n      return;\n    }\n    if (optionalKey && this._shaderStore[shader + optionalKey + \"Shader\"]) {\n      callback(this._shaderStore[shader + optionalKey + \"Shader\"]);\n      return;\n    }\n    let shaderUrl;\n    if (shader[0] === \".\" || shader[0] === \"/\" || shader.indexOf(\"http\") > -1) {\n      shaderUrl = shader;\n    } else {\n      shaderUrl = this._shaderRepository + shader;\n    }\n    this._engine._loadFile(shaderUrl + \".\" + key.toLowerCase() + \".fx\", callback);\n  }\n  /**\n   * Gets the compute shader source code of this effect\n   */\n  get computeSourceCode() {\n    var _a, _b;\n    return this._computeSourceCodeOverride ? this._computeSourceCodeOverride : (_b = (_a = this._pipelineContext) === null || _a === void 0 ? void 0 : _a._getComputeShaderCode()) !== null && _b !== void 0 ? _b : this._computeSourceCode;\n  }\n  /**\n   * Gets the compute shader source code before it has been processed by the preprocessor\n   */\n  get rawComputeSourceCode() {\n    return this._rawComputeSourceCode;\n  }\n  /**\n   * Prepares the effect\n   * @internal\n   */\n  _prepareEffect() {\n    const defines = this.defines;\n    const previousPipelineContext = this._pipelineContext;\n    this._isReady = false;\n    try {\n      const engine = this._engine;\n      this._pipelineContext = engine.createComputePipelineContext();\n      this._pipelineContext._name = this._key;\n      engine._prepareComputePipelineContext(this._pipelineContext, this._computeSourceCodeOverride ? this._computeSourceCodeOverride : this._computeSourceCode, this._rawComputeSourceCode, this._computeSourceCodeOverride ? null : defines, this._entryPoint);\n      engine._executeWhenComputeStateIsCompiled(this._pipelineContext, () => {\n        this._compilationError = \"\";\n        this._isReady = true;\n        if (this.onCompiled) {\n          this.onCompiled(this);\n        }\n        this.onCompileObservable.notifyObservers(this);\n        this.onCompileObservable.clear();\n        if (previousPipelineContext) {\n          this.getEngine()._deleteComputePipelineContext(previousPipelineContext);\n        }\n      });\n      if (this._pipelineContext.isAsync) {\n        this._checkIsReady(previousPipelineContext);\n      }\n    } catch (e) {\n      this._processCompilationErrors(e, previousPipelineContext);\n    }\n  }\n  _getShaderCodeAndErrorLine(code, error) {\n    const regexp = /COMPUTE SHADER ERROR: 0:(\\d+?):/;\n    let errorLine = null;\n    if (error && code) {\n      const res = error.match(regexp);\n      if (res && res.length === 2) {\n        const lineNumber = parseInt(res[1]);\n        const lines = code.split(\"\\n\", -1);\n        if (lines.length >= lineNumber) {\n          errorLine = `Offending line [${lineNumber}] in compute code: ${lines[lineNumber - 1]}`;\n        }\n      }\n    }\n    return [code, errorLine];\n  }\n  _processCompilationErrors(e, previousPipelineContext = null) {\n    var _a;\n    this._compilationError = e.message;\n    // Let's go through fallbacks then\n    Logger.Error(\"Unable to compile compute effect:\");\n    Logger.Error(\"Defines:\\n\" + this.defines);\n    if (ComputeEffect.LogShaderCodeOnCompilationError) {\n      let lineErrorVertex = null,\n        code = null;\n      if ((_a = this._pipelineContext) === null || _a === void 0 ? void 0 : _a._getComputeShaderCode()) {\n        [code, lineErrorVertex] = this._getShaderCodeAndErrorLine(this._pipelineContext._getComputeShaderCode(), this._compilationError);\n        if (code) {\n          Logger.Error(\"Compute code:\");\n          Logger.Error(code);\n        }\n      }\n      if (lineErrorVertex) {\n        Logger.Error(lineErrorVertex);\n      }\n    }\n    Logger.Error(\"Error: \" + this._compilationError);\n    if (previousPipelineContext) {\n      this._pipelineContext = previousPipelineContext;\n      this._isReady = true;\n      if (this.onError) {\n        this.onError(this, this._compilationError);\n      }\n      this.onErrorObservable.notifyObservers(this);\n    }\n  }\n  /**\n   * Release all associated resources.\n   **/\n  dispose() {\n    if (this._pipelineContext) {\n      this._pipelineContext.dispose();\n    }\n    this._engine._releaseComputeEffect(this);\n  }\n  /**\n   * This function will add a new compute shader to the shader store\n   * @param name the name of the shader\n   * @param computeShader compute shader content\n   */\n  static RegisterShader(name, computeShader) {\n    ShaderStore.GetShadersStore(ShaderLanguage.WGSL)[`${name}ComputeShader`] = computeShader;\n  }\n}\nComputeEffect._UniqueIdSeed = 0;\n/**\n * Enable logging of the shader code when a compilation error occurs\n */\nComputeEffect.LogShaderCodeOnCompilationError = true;","map":{"version":3,"names":["Logger","Observable","GetDOMTextContent","IsWindowObjectExist","ShaderProcessor","ShaderStore","ShaderLanguage","ComputeEffect","constructor","baseName","options","engine","key","name","defines","onCompiled","onError","uniqueId","onCompileObservable","onErrorObservable","onBindObservable","_wasPreviouslyReady","_isReady","_compilationError","_key","_computeSourceCodeOverride","_pipelineContext","_computeSourceCode","_rawComputeSourceCode","_shaderLanguage","WGSL","_engine","_UniqueIdSeed","_a","_entryPoint","_b","entryPoint","_shaderStore","GetShadersStore","_shaderRepository","GetShadersRepository","_includeShaderStore","GetIncludesShadersStore","computeSource","hostDocument","getHostDocument","computeElement","getElementById","compute","processorOptions","split","indexParameters","undefined","isFragment","shouldUseHighPrecisionShader","processor","supportsUniformBuffers","shadersRepository","includesShadersStore","version","toString","platformName","shaderPlatformName","processingContext","isNDCHalfZRange","useReverseDepthBuffer","_loadShader","computeCode","Initialize","PreProcess","migratedCommputeCode","processFinalCode","finalShaders","Finalize","_useFinalCode","vertexCode","spectorName","_prepareEffect","isReady","_isReadyInternal","getEngine","getPipelineContext","getCompilationError","executeWhenCompiled","func","add","effect","isAsync","setTimeout","_checkIsReady","previousPipelineContext","e","_processCompilationErrors","shader","optionalKey","callback","HTMLElement","shaderCode","substr","shaderBinary","window","atob","shaderUrl","indexOf","_loadFile","toLowerCase","computeSourceCode","_getComputeShaderCode","rawComputeSourceCode","createComputePipelineContext","_name","_prepareComputePipelineContext","_executeWhenComputeStateIsCompiled","notifyObservers","clear","_deleteComputePipelineContext","_getShaderCodeAndErrorLine","code","error","regexp","errorLine","res","match","length","lineNumber","parseInt","lines","message","Error","LogShaderCodeOnCompilationError","lineErrorVertex","dispose","_releaseComputeEffect","RegisterShader","computeShader"],"sources":["../../../../dev/core/src/Compute/computeEffect.ts"],"sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { IComputePipelineContext } from \"./IComputePipelineContext\";\r\nimport { GetDOMTextContent, IsWindowObjectExist } from \"../Misc/domManagement\";\r\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor\";\r\nimport type { ProcessingOptions } from \"../Engines/Processors/shaderProcessingOptions\";\r\nimport { ShaderStore } from \"../Engines/shaderStore\";\r\nimport { ShaderLanguage } from \"../Materials/shaderLanguage\";\r\n\r\nimport type { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n * Options to be used when creating a compute effect.\r\n */\r\nexport interface IComputeEffectCreationOptions {\r\n    /**\r\n     * Define statements that will be set in the shader.\r\n     */\r\n    defines: any;\r\n    /**\r\n     * The name of the entry point in the shader source (default: \"main\")\r\n     */\r\n    entryPoint?: string;\r\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\r\n    onCompiled: Nullable<(effect: ComputeEffect) => void>;\r\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\r\n    onError: Nullable<(effect: ComputeEffect, errors: string) => void>;\r\n    /**\r\n     * If provided, will be called with the shader code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<(code: string) => string>;\r\n}\r\n\r\n/**\r\n * Effect wrapping a compute shader and let execute (dispatch) the shader\r\n */\r\nexport class ComputeEffect {\r\n    private static _UniqueIdSeed = 0;\r\n\r\n    /**\r\n     * Enable logging of the shader code when a compilation error occurs\r\n     */\r\n    public static LogShaderCodeOnCompilationError = true;\r\n    /**\r\n     * Name of the effect.\r\n     */\r\n    public name: any = null;\r\n    /**\r\n     * String container all the define statements that should be set on the shader.\r\n     */\r\n    public defines: string = \"\";\r\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\r\n    public onCompiled: Nullable<(effect: ComputeEffect) => void> = null;\r\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\r\n    public onError: Nullable<(effect: ComputeEffect, errors: string) => void> = null;\r\n    /**\r\n     * Unique ID of the effect.\r\n     */\r\n    public uniqueId = 0;\r\n    /**\r\n     * Observable that will be called when the shader is compiled.\r\n     * It is recommended to use executeWhenCompile() or to make sure that scene.isReady() is called to get this observable raised.\r\n     */\r\n    public onCompileObservable = new Observable<ComputeEffect>();\r\n    /**\r\n     * Observable that will be called if an error occurs during shader compilation.\r\n     */\r\n    public onErrorObservable = new Observable<ComputeEffect>();\r\n    /**\r\n     * Observable that will be called when effect is bound.\r\n     */\r\n    public onBindObservable = new Observable<ComputeEffect>();\r\n\r\n    /**\r\n     * @internal\r\n     * Specifies if the effect was previously ready\r\n     */\r\n    public _wasPreviouslyReady = false;\r\n\r\n    private _engine: Engine;\r\n    private _isReady = false;\r\n    private _compilationError = \"\";\r\n    /** @internal */\r\n    public _key: string = \"\";\r\n    private _computeSourceCodeOverride: string = \"\";\r\n    /** @internal */\r\n    public _pipelineContext: Nullable<IComputePipelineContext> = null;\r\n    /** @internal */\r\n    public _computeSourceCode: string = \"\";\r\n    private _rawComputeSourceCode: string = \"\";\r\n    private _entryPoint: string;\r\n    private _shaderLanguage = ShaderLanguage.WGSL;\r\n    private _shaderStore: { [key: string]: string };\r\n    private _shaderRepository: string;\r\n    private _includeShaderStore: { [key: string]: string };\r\n\r\n    /**\r\n     * Creates a compute effect that can be used to execute a compute shader\r\n     * @param baseName Name of the effect\r\n     * @param options Set of all options to create the effect\r\n     * @param engine The engine the effect is created for\r\n     * @param key Effect Key identifying uniquely compiled shader variants\r\n     */\r\n    constructor(baseName: any, options: IComputeEffectCreationOptions, engine: Engine, key = \"\") {\r\n        this.name = baseName;\r\n        this._key = key;\r\n\r\n        this._engine = engine;\r\n        this.uniqueId = ComputeEffect._UniqueIdSeed++;\r\n\r\n        this.defines = options.defines ?? \"\";\r\n        this.onError = options.onError;\r\n        this.onCompiled = options.onCompiled;\r\n        this._entryPoint = options.entryPoint ?? \"main\";\r\n\r\n        this._shaderStore = ShaderStore.GetShadersStore(this._shaderLanguage);\r\n        this._shaderRepository = ShaderStore.GetShadersRepository(this._shaderLanguage);\r\n        this._includeShaderStore = ShaderStore.GetIncludesShadersStore(this._shaderLanguage);\r\n\r\n        let computeSource: any;\r\n\r\n        const hostDocument = IsWindowObjectExist() ? this._engine.getHostDocument() : null;\r\n\r\n        if (baseName.computeSource) {\r\n            computeSource = \"source:\" + baseName.computeSource;\r\n        } else if (baseName.computeElement) {\r\n            computeSource = hostDocument ? hostDocument.getElementById(baseName.computeElement) : null;\r\n\r\n            if (!computeSource) {\r\n                computeSource = baseName.computeElement;\r\n            }\r\n        } else {\r\n            computeSource = baseName.compute || baseName;\r\n        }\r\n\r\n        const processorOptions: ProcessingOptions = {\r\n            defines: this.defines.split(\"\\n\"),\r\n            indexParameters: undefined,\r\n            isFragment: false,\r\n            shouldUseHighPrecisionShader: false,\r\n            processor: null,\r\n            supportsUniformBuffers: this._engine.supportsUniformBuffers,\r\n            shadersRepository: this._shaderRepository,\r\n            includesShadersStore: this._includeShaderStore,\r\n            version: (this._engine.version * 100).toString(),\r\n            platformName: this._engine.shaderPlatformName,\r\n            processingContext: null,\r\n            isNDCHalfZRange: this._engine.isNDCHalfZRange,\r\n            useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\r\n        };\r\n\r\n        this._loadShader(computeSource, \"Compute\", \"\", (computeCode) => {\r\n            ShaderProcessor.Initialize(processorOptions);\r\n            ShaderProcessor.PreProcess(\r\n                computeCode,\r\n                processorOptions,\r\n                (migratedCommputeCode) => {\r\n                    this._rawComputeSourceCode = computeCode;\r\n                    if (options.processFinalCode) {\r\n                        migratedCommputeCode = options.processFinalCode(migratedCommputeCode);\r\n                    }\r\n                    const finalShaders = ShaderProcessor.Finalize(migratedCommputeCode, \"\", processorOptions);\r\n                    this._useFinalCode(finalShaders.vertexCode, baseName);\r\n                },\r\n                this._engine\r\n            );\r\n        });\r\n    }\r\n\r\n    private _useFinalCode(migratedCommputeCode: string, baseName: any) {\r\n        if (baseName) {\r\n            const compute = baseName.computeElement || baseName.compute || baseName.spectorName || baseName;\r\n\r\n            this._computeSourceCode = \"//#define SHADER_NAME compute:\" + compute + \"\\n\" + migratedCommputeCode;\r\n        } else {\r\n            this._computeSourceCode = migratedCommputeCode;\r\n        }\r\n        this._prepareEffect();\r\n    }\r\n\r\n    /**\r\n     * Unique key for this effect\r\n     */\r\n    public get key(): string {\r\n        return this._key;\r\n    }\r\n\r\n    /**\r\n     * If the effect has been compiled and prepared.\r\n     * @returns if the effect is compiled and prepared.\r\n     */\r\n    public isReady(): boolean {\r\n        try {\r\n            return this._isReadyInternal();\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private _isReadyInternal(): boolean {\r\n        if (this._isReady) {\r\n            return true;\r\n        }\r\n        if (this._pipelineContext) {\r\n            return this._pipelineContext.isReady;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * The engine the effect was initialized with.\r\n     * @returns the engine.\r\n     */\r\n    public getEngine(): Engine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * The pipeline context for this effect\r\n     * @returns the associated pipeline context\r\n     */\r\n    public getPipelineContext(): Nullable<IComputePipelineContext> {\r\n        return this._pipelineContext;\r\n    }\r\n\r\n    /**\r\n     * The error from the last compilation.\r\n     * @returns the error string.\r\n     */\r\n    public getCompilationError(): string {\r\n        return this._compilationError;\r\n    }\r\n\r\n    /**\r\n     * Adds a callback to the onCompiled observable and call the callback immediately if already ready.\r\n     * @param func The callback to be used.\r\n     */\r\n    public executeWhenCompiled(func: (effect: ComputeEffect) => void): void {\r\n        if (this.isReady()) {\r\n            func(this);\r\n            return;\r\n        }\r\n\r\n        this.onCompileObservable.add((effect) => {\r\n            func(effect);\r\n        });\r\n\r\n        if (!this._pipelineContext || this._pipelineContext.isAsync) {\r\n            setTimeout(() => {\r\n                this._checkIsReady(null);\r\n            }, 16);\r\n        }\r\n    }\r\n\r\n    private _checkIsReady(previousPipelineContext: Nullable<IComputePipelineContext>) {\r\n        try {\r\n            if (this._isReadyInternal()) {\r\n                return;\r\n            }\r\n        } catch (e) {\r\n            this._processCompilationErrors(e, previousPipelineContext);\r\n            return;\r\n        }\r\n\r\n        setTimeout(() => {\r\n            this._checkIsReady(previousPipelineContext);\r\n        }, 16);\r\n    }\r\n\r\n    private _loadShader(shader: any, key: string, optionalKey: string, callback: (data: any) => void): void {\r\n        if (typeof HTMLElement !== \"undefined\") {\r\n            // DOM element ?\r\n            if (shader instanceof HTMLElement) {\r\n                const shaderCode = GetDOMTextContent(shader);\r\n                callback(shaderCode);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Direct source ?\r\n        if (shader.substr(0, 7) === \"source:\") {\r\n            callback(shader.substr(7));\r\n            return;\r\n        }\r\n\r\n        // Base64 encoded ?\r\n        if (shader.substr(0, 7) === \"base64:\") {\r\n            const shaderBinary = window.atob(shader.substr(7));\r\n            callback(shaderBinary);\r\n            return;\r\n        }\r\n\r\n        // Is in local store ?\r\n        if (this._shaderStore[shader + key + \"Shader\"]) {\r\n            callback(this._shaderStore[shader + key + \"Shader\"]);\r\n            return;\r\n        }\r\n\r\n        if (optionalKey && this._shaderStore[shader + optionalKey + \"Shader\"]) {\r\n            callback(this._shaderStore[shader + optionalKey + \"Shader\"]);\r\n            return;\r\n        }\r\n\r\n        let shaderUrl;\r\n\r\n        if (shader[0] === \".\" || shader[0] === \"/\" || shader.indexOf(\"http\") > -1) {\r\n            shaderUrl = shader;\r\n        } else {\r\n            shaderUrl = this._shaderRepository + shader;\r\n        }\r\n\r\n        this._engine._loadFile(shaderUrl + \".\" + key.toLowerCase() + \".fx\", callback);\r\n    }\r\n\r\n    /**\r\n     * Gets the compute shader source code of this effect\r\n     */\r\n    public get computeSourceCode(): string {\r\n        return this._computeSourceCodeOverride ? this._computeSourceCodeOverride : this._pipelineContext?._getComputeShaderCode() ?? this._computeSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Gets the compute shader source code before it has been processed by the preprocessor\r\n     */\r\n    public get rawComputeSourceCode(): string {\r\n        return this._rawComputeSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Prepares the effect\r\n     * @internal\r\n     */\r\n    public _prepareEffect() {\r\n        const defines = this.defines;\r\n\r\n        const previousPipelineContext = this._pipelineContext;\r\n\r\n        this._isReady = false;\r\n\r\n        try {\r\n            const engine = this._engine;\r\n\r\n            this._pipelineContext = engine.createComputePipelineContext();\r\n            this._pipelineContext._name = this._key;\r\n\r\n            engine._prepareComputePipelineContext(\r\n                this._pipelineContext,\r\n                this._computeSourceCodeOverride ? this._computeSourceCodeOverride : this._computeSourceCode,\r\n                this._rawComputeSourceCode,\r\n                this._computeSourceCodeOverride ? null : defines,\r\n                this._entryPoint\r\n            );\r\n\r\n            engine._executeWhenComputeStateIsCompiled(this._pipelineContext, () => {\r\n                this._compilationError = \"\";\r\n                this._isReady = true;\r\n                if (this.onCompiled) {\r\n                    this.onCompiled(this);\r\n                }\r\n                this.onCompileObservable.notifyObservers(this);\r\n                this.onCompileObservable.clear();\r\n\r\n                if (previousPipelineContext) {\r\n                    this.getEngine()._deleteComputePipelineContext(previousPipelineContext);\r\n                }\r\n            });\r\n\r\n            if (this._pipelineContext.isAsync) {\r\n                this._checkIsReady(previousPipelineContext);\r\n            }\r\n        } catch (e) {\r\n            this._processCompilationErrors(e, previousPipelineContext);\r\n        }\r\n    }\r\n\r\n    private _getShaderCodeAndErrorLine(code: Nullable<string>, error: Nullable<string>): [Nullable<string>, Nullable<string>] {\r\n        const regexp = /COMPUTE SHADER ERROR: 0:(\\d+?):/;\r\n\r\n        let errorLine = null;\r\n\r\n        if (error && code) {\r\n            const res = error.match(regexp);\r\n            if (res && res.length === 2) {\r\n                const lineNumber = parseInt(res[1]);\r\n                const lines = code.split(\"\\n\", -1);\r\n                if (lines.length >= lineNumber) {\r\n                    errorLine = `Offending line [${lineNumber}] in compute code: ${lines[lineNumber - 1]}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return [code, errorLine];\r\n    }\r\n\r\n    private _processCompilationErrors(e: any, previousPipelineContext: Nullable<IComputePipelineContext> = null) {\r\n        this._compilationError = e.message;\r\n\r\n        // Let's go through fallbacks then\r\n        Logger.Error(\"Unable to compile compute effect:\");\r\n        Logger.Error(\"Defines:\\n\" + this.defines);\r\n        if (ComputeEffect.LogShaderCodeOnCompilationError) {\r\n            let lineErrorVertex = null,\r\n                code = null;\r\n            if (this._pipelineContext?._getComputeShaderCode()) {\r\n                [code, lineErrorVertex] = this._getShaderCodeAndErrorLine(this._pipelineContext._getComputeShaderCode(), this._compilationError);\r\n                if (code) {\r\n                    Logger.Error(\"Compute code:\");\r\n                    Logger.Error(code);\r\n                }\r\n            }\r\n            if (lineErrorVertex) {\r\n                Logger.Error(lineErrorVertex);\r\n            }\r\n        }\r\n        Logger.Error(\"Error: \" + this._compilationError);\r\n        if (previousPipelineContext) {\r\n            this._pipelineContext = previousPipelineContext;\r\n            this._isReady = true;\r\n            if (this.onError) {\r\n                this.onError(this, this._compilationError);\r\n            }\r\n            this.onErrorObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources.\r\n     **/\r\n    public dispose() {\r\n        if (this._pipelineContext) {\r\n            this._pipelineContext.dispose();\r\n        }\r\n        this._engine._releaseComputeEffect(this);\r\n    }\r\n\r\n    /**\r\n     * This function will add a new compute shader to the shader store\r\n     * @param name the name of the shader\r\n     * @param computeShader compute shader content\r\n     */\r\n    public static RegisterShader(name: string, computeShader: string) {\r\n        ShaderStore.GetShadersStore(ShaderLanguage.WGSL)[`${name}ComputeShader`] = computeShader;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}