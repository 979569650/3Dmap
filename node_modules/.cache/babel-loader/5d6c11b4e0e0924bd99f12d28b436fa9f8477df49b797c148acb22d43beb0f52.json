{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { AdvancedTimer } from \"../../../../Misc/timer.js\";\nimport { FlowGraphAsyncExecutionBlock } from \"../../../flowGraphAsyncExecutionBlock.js\";\nimport { RichTypeNumber } from \"../../../flowGraphRichTypes.js\";\nimport { Tools } from \"../../../../Misc/tools.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\n/**\n * @experimental\n * Block that provides two different output flows. One is started immediately once the block is executed,\n * and the other is executed after a set time. The timer for this block runs based on the scene's render loop.\n */\nexport class FlowGraphTimerBlock extends FlowGraphAsyncExecutionBlock {\n  constructor(config) {\n    super(config);\n    this.timeout = this._registerDataInput(\"timeout\", RichTypeNumber);\n    this.onTimerDone = this._registerSignalOutput(\"onTimerDone\");\n  }\n  _preparePendingTasks(context) {\n    const currentTimeout = this.timeout.getValue(context);\n    if (currentTimeout !== undefined && currentTimeout >= 0) {\n      const timers = context._getExecutionVariable(this, \"runningTimers\") || [];\n      const scene = context.configuration.scene;\n      const timer = new AdvancedTimer({\n        timeout: currentTimeout,\n        contextObservable: scene.onBeforeRenderObservable,\n        onEnded: () => this._onEnded(timer, context)\n      });\n      timer.start();\n      timers.push(timer);\n      context._setExecutionVariable(this, \"runningTimers\", timers);\n    }\n  }\n  /**\n   * @internal\n   */\n  _execute(context) {\n    this._startPendingTasks(context);\n    this.onDone._activateSignal(context);\n  }\n  _onEnded(timer, context) {\n    const timers = context._getExecutionVariable(this, \"runningTimers\") || [];\n    const index = timers.indexOf(timer);\n    if (index !== -1) {\n      timers.splice(index, 1);\n    } else {\n      Tools.Warn(\"FlowGraphTimerBlock: Timer ended but was not found in the running timers list\");\n    }\n    context._removePendingBlock(this);\n    this.onTimerDone._activateSignal(context);\n  }\n  _cancelPendingTasks(context) {\n    const timers = context._getExecutionVariable(this, \"runningTimers\") || [];\n    for (const timer of timers) {\n      timer.dispose();\n    }\n    context._deleteExecutionVariable(this, \"runningTimers\");\n  }\n  getClassName() {\n    return \"FGTimerBlock\";\n  }\n}\nRegisterClass(\"FGTimerBlock\", FlowGraphTimerBlock);","map":{"version":3,"names":["AdvancedTimer","FlowGraphAsyncExecutionBlock","RichTypeNumber","Tools","RegisterClass","FlowGraphTimerBlock","constructor","config","timeout","_registerDataInput","onTimerDone","_registerSignalOutput","_preparePendingTasks","context","currentTimeout","getValue","undefined","timers","_getExecutionVariable","scene","configuration","timer","contextObservable","onBeforeRenderObservable","onEnded","_onEnded","start","push","_setExecutionVariable","_execute","_startPendingTasks","onDone","_activateSignal","index","indexOf","splice","Warn","_removePendingBlock","_cancelPendingTasks","dispose","_deleteExecutionVariable","getClassName"],"sources":["../../../../../../../dev/core/src/FlowGraph/Blocks/Execution/ControlFlow/flowGraphTimerBlock.ts"],"sourcesContent":["import type { FlowGraphDataConnection } from \"../../../flowGraphDataConnection\";\r\nimport type { FlowGraphSignalConnection } from \"../../../flowGraphSignalConnection\";\r\nimport { AdvancedTimer } from \"../../../../Misc/timer\";\r\nimport type { FlowGraphContext } from \"../../../flowGraphContext\";\r\nimport { FlowGraphAsyncExecutionBlock } from \"../../../flowGraphAsyncExecutionBlock\";\r\nimport { RichTypeNumber } from \"../../../flowGraphRichTypes\";\r\nimport { Tools } from \"../../../../Misc/tools\";\r\nimport type { IFlowGraphBlockConfiguration } from \"../../../flowGraphBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\n/**\r\n * @experimental\r\n * Block that provides two different output flows. One is started immediately once the block is executed,\r\n * and the other is executed after a set time. The timer for this block runs based on the scene's render loop.\r\n */\r\nexport class FlowGraphTimerBlock extends FlowGraphAsyncExecutionBlock {\r\n    /**\r\n     * Input connection: The timeout of the timer.\r\n     */\r\n    public readonly timeout: FlowGraphDataConnection<number>;\r\n    /**\r\n     * Output connection: The signal that is activated when the timer is done.\r\n     * This signal is activated asynchronically.\r\n     */\r\n    public readonly onTimerDone: FlowGraphSignalConnection;\r\n\r\n    constructor(config?: IFlowGraphBlockConfiguration) {\r\n        super(config);\r\n\r\n        this.timeout = this._registerDataInput(\"timeout\", RichTypeNumber);\r\n        this.onTimerDone = this._registerSignalOutput(\"onTimerDone\");\r\n    }\r\n\r\n    public _preparePendingTasks(context: FlowGraphContext): void {\r\n        const currentTimeout = this.timeout.getValue(context);\r\n\r\n        if (currentTimeout !== undefined && currentTimeout >= 0) {\r\n            const timers = context._getExecutionVariable(this, \"runningTimers\") || [];\r\n            const scene = context.configuration.scene;\r\n            const timer: AdvancedTimer = new AdvancedTimer({\r\n                timeout: currentTimeout,\r\n                contextObservable: scene.onBeforeRenderObservable,\r\n                onEnded: () => this._onEnded(timer, context),\r\n            });\r\n            timer.start();\r\n\r\n            timers.push(timer);\r\n            context._setExecutionVariable(this, \"runningTimers\", timers);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _execute(context: FlowGraphContext) {\r\n        this._startPendingTasks(context);\r\n        this.onDone._activateSignal(context);\r\n    }\r\n\r\n    private _onEnded(timer: AdvancedTimer, context: FlowGraphContext) {\r\n        const timers = context._getExecutionVariable(this, \"runningTimers\") || [];\r\n        const index = timers.indexOf(timer);\r\n        if (index !== -1) {\r\n            timers.splice(index, 1);\r\n        } else {\r\n            Tools.Warn(\"FlowGraphTimerBlock: Timer ended but was not found in the running timers list\");\r\n        }\r\n        context._removePendingBlock(this);\r\n        this.onTimerDone._activateSignal(context);\r\n    }\r\n\r\n    public _cancelPendingTasks(context: FlowGraphContext): void {\r\n        const timers = context._getExecutionVariable(this, \"runningTimers\") || [];\r\n        for (const timer of timers) {\r\n            timer.dispose();\r\n        }\r\n        context._deleteExecutionVariable(this, \"runningTimers\");\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"FGTimerBlock\";\r\n    }\r\n}\r\nRegisterClass(\"FGTimerBlock\", FlowGraphTimerBlock);\r\n"],"mappings":";AAEA,SAASA,aAAa,QAAQ,2BAAyB;AAEvD,SAASC,4BAA4B,QAAQ,0CAAwC;AACrF,SAASC,cAAc,QAAQ,gCAA8B;AAC7D,SAASC,KAAK,QAAQ,2BAAyB;AAE/C,SAASC,aAAa,QAAQ,+BAA6B;AAC3D;;;;;AAKA,OAAM,MAAOC,mBAAoB,SAAQJ,4BAA4B;EAWjEK,YAAYC,MAAqC;IAC7C,KAAK,CAACA,MAAM,CAAC;IAEb,IAAI,CAACC,OAAO,GAAG,IAAI,CAACC,kBAAkB,CAAC,SAAS,EAAEP,cAAc,CAAC;IACjE,IAAI,CAACQ,WAAW,GAAG,IAAI,CAACC,qBAAqB,CAAC,aAAa,CAAC;EAChE;EAEOC,oBAAoBA,CAACC,OAAyB;IACjD,MAAMC,cAAc,GAAG,IAAI,CAACN,OAAO,CAACO,QAAQ,CAACF,OAAO,CAAC;IAErD,IAAIC,cAAc,KAAKE,SAAS,IAAIF,cAAc,IAAI,CAAC,EAAE;MACrD,MAAMG,MAAM,GAAGJ,OAAO,CAACK,qBAAqB,CAAC,IAAI,EAAE,eAAe,CAAC,IAAI,EAAE;MACzE,MAAMC,KAAK,GAAGN,OAAO,CAACO,aAAa,CAACD,KAAK;MACzC,MAAME,KAAK,GAAkB,IAAIrB,aAAa,CAAC;QAC3CQ,OAAO,EAAEM,cAAc;QACvBQ,iBAAiB,EAAEH,KAAK,CAACI,wBAAwB;QACjDC,OAAO,EAAEA,CAAA,KAAM,IAAI,CAACC,QAAQ,CAACJ,KAAK,EAAER,OAAO;OAC9C,CAAC;MACFQ,KAAK,CAACK,KAAK,EAAE;MAEbT,MAAM,CAACU,IAAI,CAACN,KAAK,CAAC;MAClBR,OAAO,CAACe,qBAAqB,CAAC,IAAI,EAAE,eAAe,EAAEX,MAAM,CAAC;;EAEpE;EAEA;;;EAGOY,QAAQA,CAAChB,OAAyB;IACrC,IAAI,CAACiB,kBAAkB,CAACjB,OAAO,CAAC;IAChC,IAAI,CAACkB,MAAM,CAACC,eAAe,CAACnB,OAAO,CAAC;EACxC;EAEQY,QAAQA,CAACJ,KAAoB,EAAER,OAAyB;IAC5D,MAAMI,MAAM,GAAGJ,OAAO,CAACK,qBAAqB,CAAC,IAAI,EAAE,eAAe,CAAC,IAAI,EAAE;IACzE,MAAMe,KAAK,GAAGhB,MAAM,CAACiB,OAAO,CAACb,KAAK,CAAC;IACnC,IAAIY,KAAK,KAAK,CAAC,CAAC,EAAE;MACdhB,MAAM,CAACkB,MAAM,CAACF,KAAK,EAAE,CAAC,CAAC;KAC1B,MAAM;MACH9B,KAAK,CAACiC,IAAI,CAAC,+EAA+E,CAAC;;IAE/FvB,OAAO,CAACwB,mBAAmB,CAAC,IAAI,CAAC;IACjC,IAAI,CAAC3B,WAAW,CAACsB,eAAe,CAACnB,OAAO,CAAC;EAC7C;EAEOyB,mBAAmBA,CAACzB,OAAyB;IAChD,MAAMI,MAAM,GAAGJ,OAAO,CAACK,qBAAqB,CAAC,IAAI,EAAE,eAAe,CAAC,IAAI,EAAE;IACzE,KAAK,MAAMG,KAAK,IAAIJ,MAAM,EAAE;MACxBI,KAAK,CAACkB,OAAO,EAAE;;IAEnB1B,OAAO,CAAC2B,wBAAwB,CAAC,IAAI,EAAE,eAAe,CAAC;EAC3D;EAEOC,YAAYA,CAAA;IACf,OAAO,cAAc;EACzB;;AAEJrC,aAAa,CAAC,cAAc,EAAEC,mBAAmB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}