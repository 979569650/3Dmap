{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"@babylonjs/core/tslib.es6.js\";\nimport { Observable } from \"@babylonjs/core/Misc/observable.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { Control } from \"./control.js\";\nimport { RegisterClass } from \"@babylonjs/core/Misc/typeStore.js\";\nimport { serialize } from \"@babylonjs/core/Misc/decorators.js\";\nimport { EngineStore } from \"@babylonjs/core/Engines/engineStore.js\";\n/**\n * Class used to create 2D images\n */\nexport class Image extends Control {\n  /**\n   * Gets a boolean indicating that the content is loaded\n   */\n  get isLoaded() {\n    return this._loaded;\n  }\n  isReady() {\n    return this.isLoaded;\n  }\n  /**\n   * Gets or sets a boolean indicating if pointers should only be validated on pixels with alpha > 0.\n   * Beware using this as this will consume more memory as the image has to be stored twice\n   */\n  get detectPointerOnOpaqueOnly() {\n    return this._detectPointerOnOpaqueOnly;\n  }\n  set detectPointerOnOpaqueOnly(value) {\n    if (this._detectPointerOnOpaqueOnly === value) {\n      return;\n    }\n    this._detectPointerOnOpaqueOnly = value;\n  }\n  /**\n   * Gets or sets the left value for slicing (9-patch)\n   */\n  get sliceLeft() {\n    return this._sliceLeft;\n  }\n  set sliceLeft(value) {\n    if (this._sliceLeft === value) {\n      return;\n    }\n    this._sliceLeft = value;\n    this._markAsDirty();\n  }\n  /**\n   * Gets or sets the right value for slicing (9-patch)\n   */\n  get sliceRight() {\n    return this._sliceRight;\n  }\n  set sliceRight(value) {\n    if (this._sliceRight === value) {\n      return;\n    }\n    this._sliceRight = value;\n    this._markAsDirty();\n  }\n  /**\n   * Gets or sets the top value for slicing (9-patch)\n   */\n  get sliceTop() {\n    return this._sliceTop;\n  }\n  set sliceTop(value) {\n    if (this._sliceTop === value) {\n      return;\n    }\n    this._sliceTop = value;\n    this._markAsDirty();\n  }\n  /**\n   * Gets or sets the bottom value for slicing (9-patch)\n   */\n  get sliceBottom() {\n    return this._sliceBottom;\n  }\n  set sliceBottom(value) {\n    if (this._sliceBottom === value) {\n      return;\n    }\n    this._sliceBottom = value;\n    this._markAsDirty();\n  }\n  /**\n   * Gets or sets the left coordinate in the source image\n   */\n  get sourceLeft() {\n    return this._sourceLeft;\n  }\n  set sourceLeft(value) {\n    if (this._sourceLeft === value) {\n      return;\n    }\n    this._sourceLeft = value;\n    this._markAsDirty();\n  }\n  /**\n   * Gets or sets the top coordinate in the source image\n   */\n  get sourceTop() {\n    return this._sourceTop;\n  }\n  set sourceTop(value) {\n    if (this._sourceTop === value) {\n      return;\n    }\n    this._sourceTop = value;\n    this._markAsDirty();\n  }\n  /**\n   * Gets or sets the width to capture in the source image\n   */\n  get sourceWidth() {\n    return this._sourceWidth;\n  }\n  set sourceWidth(value) {\n    if (this._sourceWidth === value) {\n      return;\n    }\n    this._sourceWidth = value;\n    this._markAsDirty();\n  }\n  /**\n   * Gets or sets the height to capture in the source image\n   */\n  get sourceHeight() {\n    return this._sourceHeight;\n  }\n  set sourceHeight(value) {\n    if (this._sourceHeight === value) {\n      return;\n    }\n    this._sourceHeight = value;\n    this._markAsDirty();\n  }\n  /**\n   * Gets the image width\n   */\n  get imageWidth() {\n    return this._imageWidth;\n  }\n  /**\n   * Gets the image height\n   */\n  get imageHeight() {\n    return this._imageHeight;\n  }\n  /**\n   * Gets or sets a boolean indicating if nine patch slices (left, top, right, bottom) should be read from image data\n   */\n  get populateNinePatchSlicesFromImage() {\n    return this._populateNinePatchSlicesFromImage;\n  }\n  set populateNinePatchSlicesFromImage(value) {\n    if (this._populateNinePatchSlicesFromImage === value) {\n      return;\n    }\n    this._populateNinePatchSlicesFromImage = value;\n    if (this._populateNinePatchSlicesFromImage && this._loaded) {\n      this._extractNinePatchSliceDataFromImage();\n    }\n  }\n  /** Indicates if the format of the image is SVG */\n  get isSVG() {\n    return this._isSVG;\n  }\n  /** Gets the status of the SVG attributes computation (sourceLeft, sourceTop, sourceWidth, sourceHeight) */\n  get svgAttributesComputationCompleted() {\n    return this._svgAttributesComputationCompleted;\n  }\n  /**\n   * Gets or sets a boolean indicating if the image can force its container to adapt its size\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#image\n   */\n  get autoScale() {\n    return this._autoScale;\n  }\n  set autoScale(value) {\n    if (this._autoScale === value) {\n      return;\n    }\n    this._autoScale = value;\n    if (value && this._loaded) {\n      this.synchronizeSizeWithContent();\n    }\n  }\n  /** Gets or sets the stretching mode used by the image */\n  get stretch() {\n    return this._stretch;\n  }\n  set stretch(value) {\n    if (this._stretch === value) {\n      return;\n    }\n    this._stretch = value;\n    this._markAsDirty();\n  }\n  /**\n   * @internal\n   */\n  _rotate90(n, preserveProperties = false) {\n    var _a, _b;\n    const width = this._domImage.width;\n    const height = this._domImage.height;\n    // Should abstract platform instead of using LastCreatedEngine\n    const engine = ((_b = (_a = this._host) === null || _a === void 0 ? void 0 : _a.getScene()) === null || _b === void 0 ? void 0 : _b.getEngine()) || EngineStore.LastCreatedEngine;\n    if (!engine) {\n      throw new Error(\"Invalid engine. Unable to create a canvas.\");\n    }\n    const canvas = engine.createCanvas(height, width);\n    const context = canvas.getContext(\"2d\");\n    context.translate(canvas.width / 2, canvas.height / 2);\n    context.rotate(n * Math.PI / 2);\n    context.drawImage(this._domImage, 0, 0, width, height, -width / 2, -height / 2, width, height);\n    const dataUrl = canvas.toDataURL(\"image/jpg\");\n    const rotatedImage = new Image(this.name + \"rotated\", dataUrl);\n    if (preserveProperties) {\n      rotatedImage._stretch = this._stretch;\n      rotatedImage._autoScale = this._autoScale;\n      rotatedImage._cellId = this._cellId;\n      rotatedImage._cellWidth = n % 1 ? this._cellHeight : this._cellWidth;\n      rotatedImage._cellHeight = n % 1 ? this._cellWidth : this._cellHeight;\n    }\n    this._handleRotationForSVGImage(this, rotatedImage, n);\n    this._imageDataCache.data = null;\n    return rotatedImage;\n  }\n  _handleRotationForSVGImage(srcImage, dstImage, n) {\n    if (!srcImage._isSVG) {\n      return;\n    }\n    if (srcImage._svgAttributesComputationCompleted) {\n      this._rotate90SourceProperties(srcImage, dstImage, n);\n      this._markAsDirty();\n    } else {\n      srcImage.onSVGAttributesComputedObservable.addOnce(() => {\n        this._rotate90SourceProperties(srcImage, dstImage, n);\n        this._markAsDirty();\n      });\n    }\n  }\n  _rotate90SourceProperties(srcImage, dstImage, n) {\n    let srcLeft = srcImage.sourceLeft,\n      srcTop = srcImage.sourceTop,\n      srcWidth = srcImage.domImage.width,\n      srcHeight = srcImage.domImage.height;\n    let dstLeft = srcLeft,\n      dstTop = srcTop,\n      dstWidth = srcImage.sourceWidth,\n      dstHeight = srcImage.sourceHeight;\n    if (n != 0) {\n      const mult = n < 0 ? -1 : 1;\n      n = n % 4;\n      for (let i = 0; i < Math.abs(n); ++i) {\n        dstLeft = -(srcTop - srcHeight / 2) * mult + srcHeight / 2;\n        dstTop = (srcLeft - srcWidth / 2) * mult + srcWidth / 2;\n        [dstWidth, dstHeight] = [dstHeight, dstWidth];\n        if (n < 0) {\n          dstTop -= dstHeight;\n        } else {\n          dstLeft -= dstWidth;\n        }\n        srcLeft = dstLeft;\n        srcTop = dstTop;\n        [srcWidth, srcHeight] = [srcHeight, srcWidth];\n      }\n    }\n    dstImage.sourceLeft = dstLeft;\n    dstImage.sourceTop = dstTop;\n    dstImage.sourceWidth = dstWidth;\n    dstImage.sourceHeight = dstHeight;\n  }\n  _extractNinePatchSliceDataFromImage() {\n    var _a, _b;\n    const width = this._domImage.width;\n    const height = this._domImage.height;\n    if (!this._workingCanvas) {\n      const engine = ((_b = (_a = this._host) === null || _a === void 0 ? void 0 : _a.getScene()) === null || _b === void 0 ? void 0 : _b.getEngine()) || EngineStore.LastCreatedEngine;\n      if (!engine) {\n        throw new Error(\"Invalid engine. Unable to create a canvas.\");\n      }\n      this._workingCanvas = engine.createCanvas(width, height);\n    }\n    const canvas = this._workingCanvas;\n    const context = canvas.getContext(\"2d\");\n    context.drawImage(this._domImage, 0, 0, width, height);\n    const imageData = context.getImageData(0, 0, width, height);\n    // Left and right\n    this._sliceLeft = -1;\n    this._sliceRight = -1;\n    for (let x = 0; x < width; x++) {\n      const alpha = imageData.data[x * 4 + 3];\n      if (alpha > 127 && this._sliceLeft === -1) {\n        this._sliceLeft = x;\n        continue;\n      }\n      if (alpha < 127 && this._sliceLeft > -1) {\n        this._sliceRight = x;\n        break;\n      }\n    }\n    // top and bottom\n    this._sliceTop = -1;\n    this._sliceBottom = -1;\n    for (let y = 0; y < height; y++) {\n      const alpha = imageData.data[y * width * 4 + 3];\n      if (alpha > 127 && this._sliceTop === -1) {\n        this._sliceTop = y;\n        continue;\n      }\n      if (alpha < 127 && this._sliceTop > -1) {\n        this._sliceBottom = y;\n        break;\n      }\n    }\n  }\n  /**\n   * Gets or sets the internal DOM image used to render the control\n   */\n  set domImage(value) {\n    this._domImage = value;\n    this._loaded = false;\n    this._imageDataCache.data = null;\n    if (this._domImage.width) {\n      this._onImageLoaded();\n    } else {\n      this._domImage.onload = () => {\n        this._onImageLoaded();\n      };\n    }\n  }\n  get domImage() {\n    return this._domImage;\n  }\n  _onImageLoaded() {\n    this._imageDataCache.data = null;\n    this._imageWidth = this._domImage.width;\n    this._imageHeight = this._domImage.height;\n    this._loaded = true;\n    if (this._populateNinePatchSlicesFromImage) {\n      this._extractNinePatchSliceDataFromImage();\n    }\n    if (this._autoScale) {\n      this.synchronizeSizeWithContent();\n    }\n    this.onImageLoadedObservable.notifyObservers(this);\n    this._markAsDirty();\n  }\n  /**\n   * Gets the image source url\n   */\n  get source() {\n    return this._source;\n  }\n  /**\n   * Resets the internal Image Element cache. Can reduce memory usage.\n   */\n  static ResetImageCache() {\n    Image.SourceImgCache.clear();\n  }\n  _removeCacheUsage(source) {\n    const value = source && Image.SourceImgCache.get(source);\n    if (value) {\n      value.timesUsed -= 1;\n      // Since the image isn't being used anymore, we can clean it from the cache\n      if (value.timesUsed === 0) {\n        Image.SourceImgCache.delete(source);\n      }\n    }\n  }\n  /**\n   * Gets or sets image source url\n   */\n  set source(value) {\n    var _a, _b;\n    if (this._source === value) {\n      return;\n    }\n    this._removeCacheUsage(this._source);\n    this._loaded = false;\n    this._source = value;\n    this._imageDataCache.data = null;\n    if (value) {\n      value = this._svgCheck(value);\n    }\n    // Should abstract platform instead of using LastCreatedEngine\n    const engine = ((_b = (_a = this._host) === null || _a === void 0 ? void 0 : _a.getScene()) === null || _b === void 0 ? void 0 : _b.getEngine()) || EngineStore.LastCreatedEngine;\n    if (!engine) {\n      throw new Error(\"Invalid engine. Unable to create a canvas.\");\n    }\n    if (value && Image.SourceImgCache.has(value)) {\n      const cachedData = Image.SourceImgCache.get(value);\n      this._domImage = cachedData.img;\n      cachedData.timesUsed += 1;\n      if (cachedData.loaded) {\n        this._onImageLoaded();\n      } else {\n        cachedData.waitingForLoadCallback.push(this._onImageLoaded.bind(this));\n      }\n      return;\n    }\n    this._domImage = engine.createCanvasImage();\n    if (value) {\n      Image.SourceImgCache.set(value, {\n        img: this._domImage,\n        timesUsed: 1,\n        loaded: false,\n        waitingForLoadCallback: [this._onImageLoaded.bind(this)]\n      });\n    }\n    this._domImage.onload = () => {\n      if (value) {\n        const cachedData = Image.SourceImgCache.get(value);\n        if (cachedData) {\n          cachedData.loaded = true;\n          for (const waitingCallback of cachedData.waitingForLoadCallback) {\n            waitingCallback();\n          }\n          cachedData.waitingForLoadCallback.length = 0;\n          return;\n        }\n      }\n      this._onImageLoaded();\n    };\n    if (value) {\n      Tools.SetCorsBehavior(value, this._domImage);\n      Tools.SetReferrerPolicyBehavior(this.referrerPolicy, this._domImage);\n      this._domImage.src = value;\n    }\n  }\n  /**\n   * Checks for svg document with icon id present\n   * @param value\n   */\n  _svgCheck(value) {\n    if (window.SVGSVGElement && value.search(/.svg#/gi) !== -1 && value.indexOf(\"#\") === value.lastIndexOf(\"#\")) {\n      this._isSVG = true;\n      const svgsrc = value.split(\"#\")[0];\n      const elemid = value.split(\"#\")[1];\n      // check if object alr exist in document\n      const svgExist = document.body.querySelector('object[data=\"' + svgsrc + '\"]');\n      if (svgExist) {\n        const svgDoc = svgExist.contentDocument;\n        // get viewbox width and height, get svg document width and height in px\n        if (svgDoc && svgDoc.documentElement) {\n          const vb = svgDoc.documentElement.getAttribute(\"viewBox\");\n          const docwidth = Number(svgDoc.documentElement.getAttribute(\"width\"));\n          const docheight = Number(svgDoc.documentElement.getAttribute(\"height\"));\n          const elem = svgDoc.getElementById(elemid);\n          if (elem && vb && docwidth && docheight) {\n            this._getSVGAttribs(svgExist, elemid);\n            return value;\n          }\n        }\n        // wait for object to load\n        svgExist.addEventListener(\"load\", () => {\n          this._getSVGAttribs(svgExist, elemid);\n        });\n      } else {\n        // create document object\n        const svgImage = document.createElement(\"object\");\n        svgImage.data = svgsrc;\n        svgImage.type = \"image/svg+xml\";\n        svgImage.width = \"0%\";\n        svgImage.height = \"0%\";\n        document.body.appendChild(svgImage);\n        // when the object has loaded, get the element attribs\n        svgImage.onload = () => {\n          const svgobj = document.body.querySelector('object[data=\"' + svgsrc + '\"]');\n          if (svgobj) {\n            this._getSVGAttribs(svgobj, elemid);\n          }\n        };\n      }\n      return svgsrc;\n    } else {\n      return value;\n    }\n  }\n  /**\n   * Sets sourceLeft, sourceTop, sourceWidth, sourceHeight automatically\n   * given external svg file and icon id\n   * @param svgsrc\n   * @param elemid\n   */\n  _getSVGAttribs(svgsrc, elemid) {\n    const svgDoc = svgsrc.contentDocument;\n    // get viewbox width and height, get svg document width and height in px\n    if (svgDoc && svgDoc.documentElement) {\n      const vb = svgDoc.documentElement.getAttribute(\"viewBox\");\n      const docwidth = Number(svgDoc.documentElement.getAttribute(\"width\"));\n      const docheight = Number(svgDoc.documentElement.getAttribute(\"height\"));\n      // get element bbox and matrix transform\n      const elem = svgDoc.getElementById(elemid);\n      if (vb && docwidth && docheight && elem) {\n        const vb_width = Number(vb.split(\" \")[2]);\n        const vb_height = Number(vb.split(\" \")[3]);\n        const elem_bbox = elem.getBBox();\n        let elem_matrix_a = 1;\n        let elem_matrix_d = 1;\n        let elem_matrix_e = 0;\n        let elem_matrix_f = 0;\n        const mainMatrix = elem.transform.baseVal.consolidate().matrix;\n        if (elem.transform && elem.transform.baseVal.consolidate()) {\n          elem_matrix_a = mainMatrix.a;\n          elem_matrix_d = mainMatrix.d;\n          elem_matrix_e = mainMatrix.e;\n          elem_matrix_f = mainMatrix.f;\n        }\n        // compute source coordinates and dimensions\n        this.sourceLeft = (elem_matrix_a * elem_bbox.x + elem_matrix_e) * docwidth / vb_width;\n        this.sourceTop = (elem_matrix_d * elem_bbox.y + elem_matrix_f) * docheight / vb_height;\n        this.sourceWidth = elem_bbox.width * elem_matrix_a * (docwidth / vb_width);\n        this.sourceHeight = elem_bbox.height * elem_matrix_d * (docheight / vb_height);\n        this._svgAttributesComputationCompleted = true;\n        this.onSVGAttributesComputedObservable.notifyObservers(this);\n      }\n    }\n  }\n  /**\n   * Gets or sets the cell width to use when animation sheet is enabled\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#image\n   */\n  get cellWidth() {\n    return this._cellWidth;\n  }\n  set cellWidth(value) {\n    if (this._cellWidth === value) {\n      return;\n    }\n    this._cellWidth = value;\n    this._markAsDirty();\n  }\n  /**\n   * Gets or sets the cell height to use when animation sheet is enabled\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#image\n   */\n  get cellHeight() {\n    return this._cellHeight;\n  }\n  set cellHeight(value) {\n    if (this._cellHeight === value) {\n      return;\n    }\n    this._cellHeight = value;\n    this._markAsDirty();\n  }\n  /**\n   * Gets or sets the cell id to use (this will turn on the animation sheet mode)\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#image\n   */\n  get cellId() {\n    return this._cellId;\n  }\n  set cellId(value) {\n    if (this._cellId === value) {\n      return;\n    }\n    this._cellId = value;\n    this._markAsDirty();\n  }\n  /**\n   * Creates a new Image\n   * @param name defines the control name\n   * @param url defines the image url\n   */\n  constructor(name, url = null) {\n    super(name);\n    this.name = name;\n    this._workingCanvas = null;\n    this._loaded = false;\n    this._stretch = Image.STRETCH_FILL;\n    this._autoScale = false;\n    this._sourceLeft = 0;\n    this._sourceTop = 0;\n    this._sourceWidth = 0;\n    this._sourceHeight = 0;\n    this._svgAttributesComputationCompleted = false;\n    this._isSVG = false;\n    this._cellWidth = 0;\n    this._cellHeight = 0;\n    this._cellId = -1;\n    this._populateNinePatchSlicesFromImage = false;\n    this._imageDataCache = {\n      data: null,\n      key: \"\"\n    };\n    /**\n     * Observable notified when the content is loaded\n     */\n    this.onImageLoadedObservable = new Observable();\n    /**\n     * Observable notified when _sourceLeft, _sourceTop, _sourceWidth and _sourceHeight are computed\n     */\n    this.onSVGAttributesComputedObservable = new Observable();\n    this.source = url;\n  }\n  /**\n   * Tests if a given coordinates belong to the current control\n   * @param x defines x coordinate to test\n   * @param y defines y coordinate to test\n   * @returns true if the coordinates are inside the control\n   */\n  contains(x, y) {\n    if (!super.contains(x, y)) {\n      return false;\n    }\n    if (!this._detectPointerOnOpaqueOnly || !this._workingCanvas) {\n      return true;\n    }\n    const width = this._currentMeasure.width | 0;\n    const height = this._currentMeasure.height | 0;\n    const key = width + \"_\" + height;\n    let imageData = this._imageDataCache.data;\n    if (!imageData || this._imageDataCache.key !== key) {\n      const canvas = this._workingCanvas;\n      const context = canvas.getContext(\"2d\");\n      this._imageDataCache.data = imageData = context.getImageData(0, 0, width, height).data;\n      this._imageDataCache.key = key;\n    }\n    x = x - this._currentMeasure.left | 0;\n    y = y - this._currentMeasure.top | 0;\n    const pickedPixel = imageData[(x + y * width) * 4 + 3];\n    return pickedPixel > 0;\n  }\n  _getTypeName() {\n    return \"Image\";\n  }\n  /** Force the control to synchronize with its content */\n  synchronizeSizeWithContent() {\n    if (!this._loaded) {\n      return;\n    }\n    this.width = this._domImage.width + \"px\";\n    this.height = this._domImage.height + \"px\";\n  }\n  _processMeasures(parentMeasure, context) {\n    if (this._loaded) {\n      switch (this._stretch) {\n        case Image.STRETCH_NONE:\n          break;\n        case Image.STRETCH_FILL:\n          break;\n        case Image.STRETCH_UNIFORM:\n          break;\n        case Image.STRETCH_NINE_PATCH:\n          break;\n        case Image.STRETCH_EXTEND:\n          if (this._autoScale) {\n            this.synchronizeSizeWithContent();\n          }\n          if (this.parent && this.parent.parent) {\n            // Will update root size if root is not the top root\n            this.parent.adaptWidthToChildren = true;\n            this.parent.adaptHeightToChildren = true;\n          }\n          break;\n      }\n    }\n    super._processMeasures(parentMeasure, context);\n  }\n  _prepareWorkingCanvasForOpaqueDetection() {\n    var _a, _b;\n    if (!this._detectPointerOnOpaqueOnly) {\n      return;\n    }\n    const width = this._currentMeasure.width;\n    const height = this._currentMeasure.height;\n    if (!this._workingCanvas) {\n      const engine = ((_b = (_a = this._host) === null || _a === void 0 ? void 0 : _a.getScene()) === null || _b === void 0 ? void 0 : _b.getEngine()) || EngineStore.LastCreatedEngine;\n      if (!engine) {\n        throw new Error(\"Invalid engine. Unable to create a canvas.\");\n      }\n      this._workingCanvas = engine.createCanvas(width, height);\n    }\n    const canvas = this._workingCanvas;\n    const context = canvas.getContext(\"2d\");\n    context.clearRect(0, 0, width, height);\n  }\n  _drawImage(context, sx, sy, sw, sh, tx, ty, tw, th) {\n    context.drawImage(this._domImage, sx, sy, sw, sh, tx, ty, tw, th);\n    if (!this._detectPointerOnOpaqueOnly) {\n      return;\n    }\n    const canvas = this._workingCanvas;\n    context = canvas.getContext(\"2d\");\n    context.drawImage(this._domImage, sx, sy, sw, sh, tx - this._currentMeasure.left, ty - this._currentMeasure.top, tw, th);\n  }\n  _draw(context) {\n    context.save();\n    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\n      context.shadowColor = this.shadowColor;\n      context.shadowBlur = this.shadowBlur;\n      context.shadowOffsetX = this.shadowOffsetX;\n      context.shadowOffsetY = this.shadowOffsetY;\n    }\n    let x, y, width, height;\n    if (this.cellId == -1) {\n      x = this._sourceLeft;\n      y = this._sourceTop;\n      width = this._sourceWidth ? this._sourceWidth : this._imageWidth;\n      height = this._sourceHeight ? this._sourceHeight : this._imageHeight;\n    } else {\n      const rowCount = this._domImage.naturalWidth / this.cellWidth;\n      const column = this.cellId / rowCount >> 0;\n      const row = this.cellId % rowCount;\n      x = this.cellWidth * row;\n      y = this.cellHeight * column;\n      width = this.cellWidth;\n      height = this.cellHeight;\n    }\n    this._prepareWorkingCanvasForOpaqueDetection();\n    this._applyStates(context);\n    if (this._loaded) {\n      switch (this._stretch) {\n        case Image.STRETCH_NONE:\n          this._drawImage(context, x, y, width, height, this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\n          break;\n        case Image.STRETCH_FILL:\n          this._drawImage(context, x, y, width, height, this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\n          break;\n        case Image.STRETCH_UNIFORM:\n          {\n            const hRatio = this._currentMeasure.width / width;\n            const vRatio = this._currentMeasure.height / height;\n            const ratio = Math.min(hRatio, vRatio);\n            const centerX = (this._currentMeasure.width - width * ratio) / 2;\n            const centerY = (this._currentMeasure.height - height * ratio) / 2;\n            this._drawImage(context, x, y, width, height, this._currentMeasure.left + centerX, this._currentMeasure.top + centerY, width * ratio, height * ratio);\n            break;\n          }\n        case Image.STRETCH_EXTEND:\n          this._drawImage(context, x, y, width, height, this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\n          break;\n        case Image.STRETCH_NINE_PATCH:\n          this._renderNinePatch(context, x, y, width, height);\n          break;\n      }\n    }\n    context.restore();\n  }\n  _renderNinePatch(context, sx, sy, sw, sh) {\n    const leftWidth = this._sliceLeft;\n    const topHeight = this._sliceTop;\n    const bottomHeight = sh - this._sliceBottom;\n    const rightWidth = sw - this._sliceRight;\n    const centerWidth = this._sliceRight - this._sliceLeft;\n    const centerHeight = this._sliceBottom - this._sliceTop;\n    const targetCenterWidth = this._currentMeasure.width - rightWidth - leftWidth + 2;\n    const targetCenterHeight = this._currentMeasure.height - bottomHeight - topHeight + 2;\n    const centerLeftOffset = this._currentMeasure.left + leftWidth - 1;\n    const centerTopOffset = this._currentMeasure.top + topHeight - 1;\n    const rightOffset = this._currentMeasure.left + this._currentMeasure.width - rightWidth;\n    const bottomOffset = this._currentMeasure.top + this._currentMeasure.height - bottomHeight;\n    //Top Left\n    this._drawImage(context, sx, sy, leftWidth, topHeight, this._currentMeasure.left, this._currentMeasure.top, leftWidth, topHeight);\n    //Top\n    this._drawImage(context, sx + this._sliceLeft, sy, centerWidth, topHeight, centerLeftOffset + 1, this._currentMeasure.top, targetCenterWidth - 2, topHeight);\n    //Top Right\n    this._drawImage(context, sx + this._sliceRight, sy, rightWidth, topHeight, rightOffset, this._currentMeasure.top, rightWidth, topHeight);\n    //Left\n    this._drawImage(context, sx, sy + this._sliceTop, leftWidth, centerHeight, this._currentMeasure.left, centerTopOffset + 1, leftWidth, targetCenterHeight - 2);\n    // Center\n    this._drawImage(context, sx + this._sliceLeft, sy + this._sliceTop, centerWidth, centerHeight, centerLeftOffset, centerTopOffset, targetCenterWidth, targetCenterHeight);\n    //Right\n    this._drawImage(context, sx + this._sliceRight, sy + this._sliceTop, rightWidth, centerHeight, rightOffset, centerTopOffset + 1, rightWidth, targetCenterHeight - 2);\n    //Bottom Left\n    this._drawImage(context, sx, sy + this._sliceBottom, leftWidth, bottomHeight, this._currentMeasure.left, bottomOffset, leftWidth, bottomHeight);\n    //Bottom\n    this._drawImage(context, sx + this.sliceLeft, sy + this._sliceBottom, centerWidth, bottomHeight, centerLeftOffset + 1, bottomOffset, targetCenterWidth - 2, bottomHeight);\n    //Bottom Right\n    this._drawImage(context, sx + this._sliceRight, sy + this._sliceBottom, rightWidth, bottomHeight, rightOffset, bottomOffset, rightWidth, bottomHeight);\n  }\n  dispose() {\n    super.dispose();\n    this.onImageLoadedObservable.clear();\n    this.onSVGAttributesComputedObservable.clear();\n    this._removeCacheUsage(this._source);\n  }\n}\n/**\n * Cache of images to avoid loading the same image multiple times\n */\nImage.SourceImgCache = new Map();\n// Static\n/** STRETCH_NONE */\nImage.STRETCH_NONE = 0;\n/** STRETCH_FILL */\nImage.STRETCH_FILL = 1;\n/** STRETCH_UNIFORM */\nImage.STRETCH_UNIFORM = 2;\n/** STRETCH_EXTEND */\nImage.STRETCH_EXTEND = 3;\n/** NINE_PATCH */\nImage.STRETCH_NINE_PATCH = 4;\n__decorate([serialize()], Image.prototype, \"detectPointerOnOpaqueOnly\", null);\n__decorate([serialize()], Image.prototype, \"sliceLeft\", null);\n__decorate([serialize()], Image.prototype, \"sliceRight\", null);\n__decorate([serialize()], Image.prototype, \"sliceTop\", null);\n__decorate([serialize()], Image.prototype, \"sliceBottom\", null);\n__decorate([serialize()], Image.prototype, \"sourceLeft\", null);\n__decorate([serialize()], Image.prototype, \"sourceTop\", null);\n__decorate([serialize()], Image.prototype, \"sourceWidth\", null);\n__decorate([serialize()], Image.prototype, \"sourceHeight\", null);\n__decorate([serialize()], Image.prototype, \"populateNinePatchSlicesFromImage\", null);\n__decorate([serialize()], Image.prototype, \"autoScale\", null);\n__decorate([serialize()], Image.prototype, \"stretch\", null);\n__decorate([serialize()], Image.prototype, \"source\", null);\n__decorate([serialize()], Image.prototype, \"cellWidth\", null);\n__decorate([serialize()], Image.prototype, \"cellHeight\", null);\n__decorate([serialize()], Image.prototype, \"cellId\", null);\nRegisterClass(\"BABYLON.GUI.Image\", Image);","map":{"version":3,"names":["Observable","Tools","Control","RegisterClass","serialize","EngineStore","Image","isLoaded","_loaded","isReady","detectPointerOnOpaqueOnly","_detectPointerOnOpaqueOnly","value","sliceLeft","_sliceLeft","_markAsDirty","sliceRight","_sliceRight","sliceTop","_sliceTop","sliceBottom","_sliceBottom","sourceLeft","_sourceLeft","sourceTop","_sourceTop","sourceWidth","_sourceWidth","sourceHeight","_sourceHeight","imageWidth","_imageWidth","imageHeight","_imageHeight","populateNinePatchSlicesFromImage","_populateNinePatchSlicesFromImage","_extractNinePatchSliceDataFromImage","isSVG","_isSVG","svgAttributesComputationCompleted","_svgAttributesComputationCompleted","autoScale","_autoScale","synchronizeSizeWithContent","stretch","_stretch","_rotate90","n","preserveProperties","width","_domImage","height","engine","_b","_a","_host","getScene","getEngine","LastCreatedEngine","Error","canvas","createCanvas","context","getContext","translate","rotate","Math","PI","drawImage","dataUrl","toDataURL","rotatedImage","name","_cellId","_cellWidth","_cellHeight","_handleRotationForSVGImage","_imageDataCache","data","srcImage","dstImage","_rotate90SourceProperties","onSVGAttributesComputedObservable","addOnce","srcLeft","srcTop","srcWidth","domImage","srcHeight","dstLeft","dstTop","dstWidth","dstHeight","mult","i","abs","_workingCanvas","imageData","getImageData","x","alpha","y","_onImageLoaded","onload","onImageLoadedObservable","notifyObservers","source","_source","ResetImageCache","SourceImgCache","clear","_removeCacheUsage","get","timesUsed","delete","_svgCheck","has","cachedData","img","loaded","waitingForLoadCallback","push","bind","createCanvasImage","set","waitingCallback","length","SetCorsBehavior","SetReferrerPolicyBehavior","referrerPolicy","src","window","SVGSVGElement","search","indexOf","lastIndexOf","svgsrc","split","elemid","svgExist","document","body","querySelector","svgDoc","contentDocument","documentElement","vb","getAttribute","docwidth","Number","docheight","elem","getElementById","_getSVGAttribs","addEventListener","svgImage","createElement","type","appendChild","svgobj","vb_width","vb_height","elem_bbox","getBBox","elem_matrix_a","elem_matrix_d","elem_matrix_e","elem_matrix_f","mainMatrix","transform","baseVal","consolidate","matrix","a","d","e","f","cellWidth","cellHeight","cellId","constructor","url","STRETCH_FILL","key","contains","_currentMeasure","left","top","pickedPixel","_getTypeName","_processMeasures","parentMeasure","STRETCH_NONE","STRETCH_UNIFORM","STRETCH_NINE_PATCH","STRETCH_EXTEND","parent","adaptWidthToChildren","adaptHeightToChildren","_prepareWorkingCanvasForOpaqueDetection","clearRect","_drawImage","sx","sy","sw","sh","tx","ty","tw","th","_draw","save","shadowBlur","shadowOffsetX","shadowOffsetY","shadowColor","rowCount","naturalWidth","column","row","_applyStates","hRatio","vRatio","ratio","min","centerX","centerY","_renderNinePatch","restore","leftWidth","topHeight","bottomHeight","rightWidth","centerWidth","centerHeight","targetCenterWidth","targetCenterHeight","centerLeftOffset","centerTopOffset","rightOffset","bottomOffset","dispose","Map","__decorate"],"sources":["../../../../../dev/gui/src/2D/controls/image.ts"],"sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Tools } from \"core/Misc/tools\";\r\n\r\nimport { Control } from \"./control\";\r\nimport type { Measure } from \"../measure\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport type { ICanvas, ICanvasRenderingContext, IImage } from \"core/Engines/ICanvas\";\r\nimport { EngineStore } from \"core/Engines/engineStore\";\r\n\r\n/**\r\n * Class used to create 2D images\r\n */\r\nexport class Image extends Control {\r\n    /**\r\n     *  Specifies an alternate text for the image, if the image for some reason cannot be displayed.\r\n     */\r\n    public alt?: string;\r\n\r\n    private _workingCanvas: Nullable<ICanvas> = null;\r\n\r\n    private _domImage: IImage;\r\n    private _imageWidth: number;\r\n    private _imageHeight: number;\r\n    private _loaded = false;\r\n    private _stretch = Image.STRETCH_FILL;\r\n    private _source: Nullable<string>;\r\n    private _autoScale = false;\r\n\r\n    private _sourceLeft = 0;\r\n    private _sourceTop = 0;\r\n    private _sourceWidth = 0;\r\n    private _sourceHeight = 0;\r\n    private _svgAttributesComputationCompleted: boolean = false;\r\n    private _isSVG: boolean = false;\r\n\r\n    private _cellWidth: number = 0;\r\n    private _cellHeight: number = 0;\r\n    private _cellId: number = -1;\r\n\r\n    private _sliceLeft: number;\r\n    private _sliceRight: number;\r\n    private _sliceTop: number;\r\n    private _sliceBottom: number;\r\n\r\n    private _populateNinePatchSlicesFromImage = false;\r\n\r\n    private _detectPointerOnOpaqueOnly: boolean;\r\n\r\n    private _imageDataCache: {\r\n        data: Uint8ClampedArray | null;\r\n        key: string;\r\n    } = { data: null, key: \"\" };\r\n\r\n    /**\r\n     * Cache of images to avoid loading the same image multiple times\r\n     */\r\n    public static SourceImgCache = new Map<string, { img: IImage; timesUsed: number; loaded: boolean; waitingForLoadCallback: Array<() => void> }>();\r\n\r\n    /**\r\n     * Observable notified when the content is loaded\r\n     */\r\n    public onImageLoadedObservable = new Observable<Image>();\r\n\r\n    /**\r\n     * Observable notified when _sourceLeft, _sourceTop, _sourceWidth and _sourceHeight are computed\r\n     */\r\n    public onSVGAttributesComputedObservable = new Observable<Image>();\r\n\r\n    /**\r\n     * Gets or sets the referrer policy to apply on the img element load request.\r\n     * You should set referrerPolicy before set the source of the image if you want to ensure the header will be present on the xhr loading request\r\n     */\r\n    public referrerPolicy: Nullable<ReferrerPolicy>;\r\n\r\n    /**\r\n     * Gets a boolean indicating that the content is loaded\r\n     */\r\n    public get isLoaded(): boolean {\r\n        return this._loaded;\r\n    }\r\n\r\n    public isReady(): boolean {\r\n        return this.isLoaded;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if pointers should only be validated on pixels with alpha > 0.\r\n     * Beware using this as this will consume more memory as the image has to be stored twice\r\n     */\r\n    @serialize()\r\n    public get detectPointerOnOpaqueOnly(): boolean {\r\n        return this._detectPointerOnOpaqueOnly;\r\n    }\r\n\r\n    public set detectPointerOnOpaqueOnly(value: boolean) {\r\n        if (this._detectPointerOnOpaqueOnly === value) {\r\n            return;\r\n        }\r\n\r\n        this._detectPointerOnOpaqueOnly = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the left value for slicing (9-patch)\r\n     */\r\n    @serialize()\r\n    public get sliceLeft(): number {\r\n        return this._sliceLeft;\r\n    }\r\n\r\n    public set sliceLeft(value: number) {\r\n        if (this._sliceLeft === value) {\r\n            return;\r\n        }\r\n\r\n        this._sliceLeft = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the right value for slicing (9-patch)\r\n     */\r\n    @serialize()\r\n    public get sliceRight(): number {\r\n        return this._sliceRight;\r\n    }\r\n\r\n    public set sliceRight(value: number) {\r\n        if (this._sliceRight === value) {\r\n            return;\r\n        }\r\n\r\n        this._sliceRight = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the top value for slicing (9-patch)\r\n     */\r\n    @serialize()\r\n    public get sliceTop(): number {\r\n        return this._sliceTop;\r\n    }\r\n\r\n    public set sliceTop(value: number) {\r\n        if (this._sliceTop === value) {\r\n            return;\r\n        }\r\n\r\n        this._sliceTop = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the bottom value for slicing (9-patch)\r\n     */\r\n    @serialize()\r\n    public get sliceBottom(): number {\r\n        return this._sliceBottom;\r\n    }\r\n\r\n    public set sliceBottom(value: number) {\r\n        if (this._sliceBottom === value) {\r\n            return;\r\n        }\r\n\r\n        this._sliceBottom = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the left coordinate in the source image\r\n     */\r\n    @serialize()\r\n    public get sourceLeft(): number {\r\n        return this._sourceLeft;\r\n    }\r\n\r\n    public set sourceLeft(value: number) {\r\n        if (this._sourceLeft === value) {\r\n            return;\r\n        }\r\n\r\n        this._sourceLeft = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the top coordinate in the source image\r\n     */\r\n    @serialize()\r\n    public get sourceTop(): number {\r\n        return this._sourceTop;\r\n    }\r\n\r\n    public set sourceTop(value: number) {\r\n        if (this._sourceTop === value) {\r\n            return;\r\n        }\r\n\r\n        this._sourceTop = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the width to capture in the source image\r\n     */\r\n    @serialize()\r\n    public get sourceWidth(): number {\r\n        return this._sourceWidth;\r\n    }\r\n\r\n    public set sourceWidth(value: number) {\r\n        if (this._sourceWidth === value) {\r\n            return;\r\n        }\r\n\r\n        this._sourceWidth = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the height to capture in the source image\r\n     */\r\n    @serialize()\r\n    public get sourceHeight(): number {\r\n        return this._sourceHeight;\r\n    }\r\n\r\n    public set sourceHeight(value: number) {\r\n        if (this._sourceHeight === value) {\r\n            return;\r\n        }\r\n\r\n        this._sourceHeight = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets the image width\r\n     */\r\n    public get imageWidth(): number {\r\n        return this._imageWidth;\r\n    }\r\n\r\n    /**\r\n     * Gets the image height\r\n     */\r\n    public get imageHeight(): number {\r\n        return this._imageHeight;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if nine patch slices (left, top, right, bottom) should be read from image data\r\n     */\r\n    @serialize()\r\n    public get populateNinePatchSlicesFromImage(): boolean {\r\n        return this._populateNinePatchSlicesFromImage;\r\n    }\r\n\r\n    public set populateNinePatchSlicesFromImage(value: boolean) {\r\n        if (this._populateNinePatchSlicesFromImage === value) {\r\n            return;\r\n        }\r\n\r\n        this._populateNinePatchSlicesFromImage = value;\r\n\r\n        if (this._populateNinePatchSlicesFromImage && this._loaded) {\r\n            this._extractNinePatchSliceDataFromImage();\r\n        }\r\n    }\r\n\r\n    /** Indicates if the format of the image is SVG */\r\n    public get isSVG(): boolean {\r\n        return this._isSVG;\r\n    }\r\n\r\n    /** Gets the status of the SVG attributes computation (sourceLeft, sourceTop, sourceWidth, sourceHeight) */\r\n    public get svgAttributesComputationCompleted(): boolean {\r\n        return this._svgAttributesComputationCompleted;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the image can force its container to adapt its size\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#image\r\n     */\r\n    @serialize()\r\n    public get autoScale(): boolean {\r\n        return this._autoScale;\r\n    }\r\n\r\n    public set autoScale(value: boolean) {\r\n        if (this._autoScale === value) {\r\n            return;\r\n        }\r\n\r\n        this._autoScale = value;\r\n\r\n        if (value && this._loaded) {\r\n            this.synchronizeSizeWithContent();\r\n        }\r\n    }\r\n\r\n    /** Gets or sets the stretching mode used by the image */\r\n    @serialize()\r\n    public get stretch(): number {\r\n        return this._stretch;\r\n    }\r\n\r\n    public set stretch(value: number) {\r\n        if (this._stretch === value) {\r\n            return;\r\n        }\r\n\r\n        this._stretch = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _rotate90(n: number, preserveProperties: boolean = false): Image {\r\n        const width = this._domImage.width;\r\n        const height = this._domImage.height;\r\n\r\n        // Should abstract platform instead of using LastCreatedEngine\r\n        const engine = this._host?.getScene()?.getEngine() || EngineStore.LastCreatedEngine;\r\n        if (!engine) {\r\n            throw new Error(\"Invalid engine. Unable to create a canvas.\");\r\n        }\r\n        const canvas = engine.createCanvas(height, width);\r\n\r\n        const context = canvas.getContext(\"2d\")!;\r\n\r\n        context.translate(canvas.width / 2, canvas.height / 2);\r\n        context.rotate((n * Math.PI) / 2);\r\n\r\n        context.drawImage(this._domImage, 0, 0, width, height, -width / 2, -height / 2, width, height);\r\n\r\n        const dataUrl: string = canvas.toDataURL(\"image/jpg\");\r\n        const rotatedImage = new Image(this.name + \"rotated\", dataUrl);\r\n\r\n        if (preserveProperties) {\r\n            rotatedImage._stretch = this._stretch;\r\n            rotatedImage._autoScale = this._autoScale;\r\n            rotatedImage._cellId = this._cellId;\r\n            rotatedImage._cellWidth = n % 1 ? this._cellHeight : this._cellWidth;\r\n            rotatedImage._cellHeight = n % 1 ? this._cellWidth : this._cellHeight;\r\n        }\r\n\r\n        this._handleRotationForSVGImage(this, rotatedImage, n);\r\n\r\n        this._imageDataCache.data = null;\r\n\r\n        return rotatedImage;\r\n    }\r\n\r\n    private _handleRotationForSVGImage(srcImage: Image, dstImage: Image, n: number): void {\r\n        if (!srcImage._isSVG) {\r\n            return;\r\n        }\r\n\r\n        if (srcImage._svgAttributesComputationCompleted) {\r\n            this._rotate90SourceProperties(srcImage, dstImage, n);\r\n            this._markAsDirty();\r\n        } else {\r\n            srcImage.onSVGAttributesComputedObservable.addOnce(() => {\r\n                this._rotate90SourceProperties(srcImage, dstImage, n);\r\n                this._markAsDirty();\r\n            });\r\n        }\r\n    }\r\n\r\n    private _rotate90SourceProperties(srcImage: Image, dstImage: Image, n: number): void {\r\n        let srcLeft = srcImage.sourceLeft,\r\n            srcTop = srcImage.sourceTop,\r\n            srcWidth = srcImage.domImage.width,\r\n            srcHeight = srcImage.domImage.height;\r\n\r\n        let dstLeft = srcLeft,\r\n            dstTop = srcTop,\r\n            dstWidth = srcImage.sourceWidth,\r\n            dstHeight = srcImage.sourceHeight;\r\n\r\n        if (n != 0) {\r\n            const mult = n < 0 ? -1 : 1;\r\n            n = n % 4;\r\n            for (let i = 0; i < Math.abs(n); ++i) {\r\n                dstLeft = -(srcTop - srcHeight / 2) * mult + srcHeight / 2;\r\n                dstTop = (srcLeft - srcWidth / 2) * mult + srcWidth / 2;\r\n                [dstWidth, dstHeight] = [dstHeight, dstWidth];\r\n                if (n < 0) {\r\n                    dstTop -= dstHeight;\r\n                } else {\r\n                    dstLeft -= dstWidth;\r\n                }\r\n                srcLeft = dstLeft;\r\n                srcTop = dstTop;\r\n                [srcWidth, srcHeight] = [srcHeight, srcWidth];\r\n            }\r\n        }\r\n\r\n        dstImage.sourceLeft = dstLeft;\r\n        dstImage.sourceTop = dstTop;\r\n        dstImage.sourceWidth = dstWidth;\r\n        dstImage.sourceHeight = dstHeight;\r\n    }\r\n\r\n    private _extractNinePatchSliceDataFromImage() {\r\n        const width = this._domImage.width;\r\n        const height = this._domImage.height;\r\n\r\n        if (!this._workingCanvas) {\r\n            const engine = this._host?.getScene()?.getEngine() || EngineStore.LastCreatedEngine;\r\n            if (!engine) {\r\n                throw new Error(\"Invalid engine. Unable to create a canvas.\");\r\n            }\r\n            this._workingCanvas = engine.createCanvas(width, height);\r\n        }\r\n        const canvas = this._workingCanvas;\r\n        const context = canvas.getContext(\"2d\")!;\r\n\r\n        context.drawImage(this._domImage, 0, 0, width, height);\r\n        const imageData = context.getImageData(0, 0, width, height);\r\n\r\n        // Left and right\r\n        this._sliceLeft = -1;\r\n        this._sliceRight = -1;\r\n        for (let x = 0; x < width; x++) {\r\n            const alpha = imageData.data[x * 4 + 3];\r\n\r\n            if (alpha > 127 && this._sliceLeft === -1) {\r\n                this._sliceLeft = x;\r\n                continue;\r\n            }\r\n\r\n            if (alpha < 127 && this._sliceLeft > -1) {\r\n                this._sliceRight = x;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // top and bottom\r\n        this._sliceTop = -1;\r\n        this._sliceBottom = -1;\r\n        for (let y = 0; y < height; y++) {\r\n            const alpha = imageData.data[y * width * 4 + 3];\r\n\r\n            if (alpha > 127 && this._sliceTop === -1) {\r\n                this._sliceTop = y;\r\n                continue;\r\n            }\r\n\r\n            if (alpha < 127 && this._sliceTop > -1) {\r\n                this._sliceBottom = y;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the internal DOM image used to render the control\r\n     */\r\n    public set domImage(value: IImage) {\r\n        this._domImage = value;\r\n        this._loaded = false;\r\n        this._imageDataCache.data = null;\r\n\r\n        if (this._domImage.width) {\r\n            this._onImageLoaded();\r\n        } else {\r\n            this._domImage.onload = () => {\r\n                this._onImageLoaded();\r\n            };\r\n        }\r\n    }\r\n\r\n    public get domImage(): IImage {\r\n        return this._domImage;\r\n    }\r\n\r\n    private _onImageLoaded(): void {\r\n        this._imageDataCache.data = null;\r\n        this._imageWidth = this._domImage.width;\r\n        this._imageHeight = this._domImage.height;\r\n        this._loaded = true;\r\n\r\n        if (this._populateNinePatchSlicesFromImage) {\r\n            this._extractNinePatchSliceDataFromImage();\r\n        }\r\n\r\n        if (this._autoScale) {\r\n            this.synchronizeSizeWithContent();\r\n        }\r\n\r\n        this.onImageLoadedObservable.notifyObservers(this);\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets the image source url\r\n     */\r\n    @serialize()\r\n    public get source() {\r\n        return this._source;\r\n    }\r\n\r\n    /**\r\n     * Resets the internal Image Element cache. Can reduce memory usage.\r\n     */\r\n    public static ResetImageCache() {\r\n        Image.SourceImgCache.clear();\r\n    }\r\n\r\n    private _removeCacheUsage(source: Nullable<string>) {\r\n        const value = source && Image.SourceImgCache.get(source);\r\n        if (value) {\r\n            value.timesUsed -= 1;\r\n            // Since the image isn't being used anymore, we can clean it from the cache\r\n            if (value.timesUsed === 0) {\r\n                Image.SourceImgCache.delete(source);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets image source url\r\n     */\r\n    public set source(value: Nullable<string>) {\r\n        if (this._source === value) {\r\n            return;\r\n        }\r\n\r\n        this._removeCacheUsage(this._source);\r\n\r\n        this._loaded = false;\r\n        this._source = value;\r\n        this._imageDataCache.data = null;\r\n\r\n        if (value) {\r\n            value = this._svgCheck(value);\r\n        }\r\n\r\n        // Should abstract platform instead of using LastCreatedEngine\r\n        const engine = this._host?.getScene()?.getEngine() || EngineStore.LastCreatedEngine;\r\n        if (!engine) {\r\n            throw new Error(\"Invalid engine. Unable to create a canvas.\");\r\n        }\r\n        if (value && Image.SourceImgCache.has(value)) {\r\n            const cachedData = Image.SourceImgCache.get(value)!;\r\n            this._domImage = cachedData.img;\r\n            cachedData.timesUsed += 1;\r\n            if (cachedData.loaded) {\r\n                this._onImageLoaded();\r\n            } else {\r\n                cachedData.waitingForLoadCallback.push(this._onImageLoaded.bind(this));\r\n            }\r\n            return;\r\n        }\r\n        this._domImage = engine.createCanvasImage();\r\n        if (value) {\r\n            Image.SourceImgCache.set(value, { img: this._domImage, timesUsed: 1, loaded: false, waitingForLoadCallback: [this._onImageLoaded.bind(this)] });\r\n        }\r\n\r\n        this._domImage.onload = () => {\r\n            if (value) {\r\n                const cachedData = Image.SourceImgCache.get(value);\r\n                if (cachedData) {\r\n                    cachedData.loaded = true;\r\n                    for (const waitingCallback of cachedData.waitingForLoadCallback) {\r\n                        waitingCallback();\r\n                    }\r\n                    cachedData.waitingForLoadCallback.length = 0;\r\n                    return;\r\n                }\r\n            }\r\n            this._onImageLoaded();\r\n        };\r\n        if (value) {\r\n            Tools.SetCorsBehavior(value, this._domImage);\r\n            Tools.SetReferrerPolicyBehavior(this.referrerPolicy, this._domImage);\r\n            this._domImage.src = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks for svg document with icon id present\r\n     * @param value\r\n     */\r\n    private _svgCheck(value: string): string {\r\n        if (window.SVGSVGElement && value.search(/.svg#/gi) !== -1 && value.indexOf(\"#\") === value.lastIndexOf(\"#\")) {\r\n            this._isSVG = true;\r\n            const svgsrc = value.split(\"#\")[0];\r\n            const elemid = value.split(\"#\")[1];\r\n            // check if object alr exist in document\r\n            const svgExist = <HTMLObjectElement>document.body.querySelector('object[data=\"' + svgsrc + '\"]');\r\n            if (svgExist) {\r\n                const svgDoc = svgExist.contentDocument;\r\n                // get viewbox width and height, get svg document width and height in px\r\n                if (svgDoc && svgDoc.documentElement) {\r\n                    const vb = svgDoc.documentElement.getAttribute(\"viewBox\");\r\n                    const docwidth = Number(svgDoc.documentElement.getAttribute(\"width\"));\r\n                    const docheight = Number(svgDoc.documentElement.getAttribute(\"height\"));\r\n                    const elem = <SVGGraphicsElement>(<unknown>svgDoc.getElementById(elemid));\r\n                    if (elem && vb && docwidth && docheight) {\r\n                        this._getSVGAttribs(svgExist, elemid);\r\n                        return value;\r\n                    }\r\n                }\r\n\r\n                // wait for object to load\r\n                svgExist.addEventListener(\"load\", () => {\r\n                    this._getSVGAttribs(svgExist, elemid);\r\n                });\r\n            } else {\r\n                // create document object\r\n                const svgImage = document.createElement(\"object\");\r\n                svgImage.data = svgsrc;\r\n                svgImage.type = \"image/svg+xml\";\r\n                svgImage.width = \"0%\";\r\n                svgImage.height = \"0%\";\r\n                document.body.appendChild(svgImage);\r\n                // when the object has loaded, get the element attribs\r\n                svgImage.onload = () => {\r\n                    const svgobj = <HTMLObjectElement>document.body.querySelector('object[data=\"' + svgsrc + '\"]');\r\n                    if (svgobj) {\r\n                        this._getSVGAttribs(svgobj, elemid);\r\n                    }\r\n                };\r\n            }\r\n            return svgsrc;\r\n        } else {\r\n            return value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets sourceLeft, sourceTop, sourceWidth, sourceHeight automatically\r\n     * given external svg file and icon id\r\n     * @param svgsrc\r\n     * @param elemid\r\n     */\r\n    private _getSVGAttribs(svgsrc: HTMLObjectElement, elemid: string) {\r\n        const svgDoc = svgsrc.contentDocument;\r\n        // get viewbox width and height, get svg document width and height in px\r\n        if (svgDoc && svgDoc.documentElement) {\r\n            const vb = svgDoc.documentElement.getAttribute(\"viewBox\");\r\n            const docwidth = Number(svgDoc.documentElement.getAttribute(\"width\"));\r\n            const docheight = Number(svgDoc.documentElement.getAttribute(\"height\"));\r\n            // get element bbox and matrix transform\r\n            const elem = svgDoc.getElementById(elemid) as Nullable<SVGGraphicsElement>;\r\n            if (vb && docwidth && docheight && elem) {\r\n                const vb_width = Number(vb.split(\" \")[2]);\r\n                const vb_height = Number(vb.split(\" \")[3]);\r\n                const elem_bbox = elem.getBBox();\r\n                let elem_matrix_a = 1;\r\n                let elem_matrix_d = 1;\r\n                let elem_matrix_e = 0;\r\n                let elem_matrix_f = 0;\r\n                const mainMatrix = elem.transform.baseVal.consolidate()!.matrix;\r\n                if (elem.transform && elem.transform.baseVal.consolidate()) {\r\n                    elem_matrix_a = mainMatrix.a;\r\n                    elem_matrix_d = mainMatrix.d;\r\n                    elem_matrix_e = mainMatrix.e;\r\n                    elem_matrix_f = mainMatrix.f;\r\n                }\r\n\r\n                // compute source coordinates and dimensions\r\n                this.sourceLeft = ((elem_matrix_a * elem_bbox.x + elem_matrix_e) * docwidth) / vb_width;\r\n                this.sourceTop = ((elem_matrix_d * elem_bbox.y + elem_matrix_f) * docheight) / vb_height;\r\n                this.sourceWidth = elem_bbox.width * elem_matrix_a * (docwidth / vb_width);\r\n                this.sourceHeight = elem_bbox.height * elem_matrix_d * (docheight / vb_height);\r\n                this._svgAttributesComputationCompleted = true;\r\n                this.onSVGAttributesComputedObservable.notifyObservers(this);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the cell width to use when animation sheet is enabled\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#image\r\n     */\r\n    @serialize()\r\n    get cellWidth(): number {\r\n        return this._cellWidth;\r\n    }\r\n    set cellWidth(value: number) {\r\n        if (this._cellWidth === value) {\r\n            return;\r\n        }\r\n\r\n        this._cellWidth = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the cell height to use when animation sheet is enabled\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#image\r\n     */\r\n    @serialize()\r\n    get cellHeight(): number {\r\n        return this._cellHeight;\r\n    }\r\n    set cellHeight(value: number) {\r\n        if (this._cellHeight === value) {\r\n            return;\r\n        }\r\n\r\n        this._cellHeight = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the cell id to use (this will turn on the animation sheet mode)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#image\r\n     */\r\n    @serialize()\r\n    get cellId(): number {\r\n        return this._cellId;\r\n    }\r\n    set cellId(value: number) {\r\n        if (this._cellId === value) {\r\n            return;\r\n        }\r\n\r\n        this._cellId = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Creates a new Image\r\n     * @param name defines the control name\r\n     * @param url defines the image url\r\n     */\r\n    constructor(public name?: string, url: Nullable<string> = null) {\r\n        super(name);\r\n        this.source = url;\r\n    }\r\n\r\n    /**\r\n     * Tests if a given coordinates belong to the current control\r\n     * @param x defines x coordinate to test\r\n     * @param y defines y coordinate to test\r\n     * @returns true if the coordinates are inside the control\r\n     */\r\n    public contains(x: number, y: number): boolean {\r\n        if (!super.contains(x, y)) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._detectPointerOnOpaqueOnly || !this._workingCanvas) {\r\n            return true;\r\n        }\r\n\r\n        const width = this._currentMeasure.width | 0;\r\n        const height = this._currentMeasure.height | 0;\r\n        const key = width + \"_\" + height;\r\n\r\n        let imageData = this._imageDataCache.data;\r\n\r\n        if (!imageData || this._imageDataCache.key !== key) {\r\n            const canvas = this._workingCanvas;\r\n            const context = canvas.getContext(\"2d\")!;\r\n\r\n            this._imageDataCache.data = imageData = context.getImageData(0, 0, width, height).data;\r\n            this._imageDataCache.key = key;\r\n        }\r\n\r\n        x = (x - this._currentMeasure.left) | 0;\r\n        y = (y - this._currentMeasure.top) | 0;\r\n\r\n        const pickedPixel = imageData[(x + y * width) * 4 + 3];\r\n\r\n        return pickedPixel > 0;\r\n    }\r\n\r\n    protected _getTypeName(): string {\r\n        return \"Image\";\r\n    }\r\n\r\n    /** Force the control to synchronize with its content */\r\n    public synchronizeSizeWithContent() {\r\n        if (!this._loaded) {\r\n            return;\r\n        }\r\n\r\n        this.width = this._domImage.width + \"px\";\r\n        this.height = this._domImage.height + \"px\";\r\n    }\r\n\r\n    protected _processMeasures(parentMeasure: Measure, context: ICanvasRenderingContext): void {\r\n        if (this._loaded) {\r\n            switch (this._stretch) {\r\n                case Image.STRETCH_NONE:\r\n                    break;\r\n                case Image.STRETCH_FILL:\r\n                    break;\r\n                case Image.STRETCH_UNIFORM:\r\n                    break;\r\n                case Image.STRETCH_NINE_PATCH:\r\n                    break;\r\n                case Image.STRETCH_EXTEND:\r\n                    if (this._autoScale) {\r\n                        this.synchronizeSizeWithContent();\r\n                    }\r\n                    if (this.parent && this.parent.parent) {\r\n                        // Will update root size if root is not the top root\r\n                        this.parent.adaptWidthToChildren = true;\r\n                        this.parent.adaptHeightToChildren = true;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n\r\n        super._processMeasures(parentMeasure, context);\r\n    }\r\n\r\n    private _prepareWorkingCanvasForOpaqueDetection() {\r\n        if (!this._detectPointerOnOpaqueOnly) {\r\n            return;\r\n        }\r\n\r\n        const width = this._currentMeasure.width;\r\n        const height = this._currentMeasure.height;\r\n\r\n        if (!this._workingCanvas) {\r\n            const engine = this._host?.getScene()?.getEngine() || EngineStore.LastCreatedEngine;\r\n            if (!engine) {\r\n                throw new Error(\"Invalid engine. Unable to create a canvas.\");\r\n            }\r\n            this._workingCanvas = engine.createCanvas(width, height);\r\n        }\r\n        const canvas = this._workingCanvas;\r\n\r\n        const context = canvas.getContext(\"2d\")!;\r\n\r\n        context.clearRect(0, 0, width, height);\r\n    }\r\n\r\n    private _drawImage(context: ICanvasRenderingContext, sx: number, sy: number, sw: number, sh: number, tx: number, ty: number, tw: number, th: number) {\r\n        context.drawImage(this._domImage, sx, sy, sw, sh, tx, ty, tw, th);\r\n\r\n        if (!this._detectPointerOnOpaqueOnly) {\r\n            return;\r\n        }\r\n\r\n        const canvas = this._workingCanvas!;\r\n        context = canvas.getContext(\"2d\")!;\r\n\r\n        context.drawImage(this._domImage, sx, sy, sw, sh, tx - this._currentMeasure.left, ty - this._currentMeasure.top, tw, th);\r\n    }\r\n\r\n    public _draw(context: ICanvasRenderingContext): void {\r\n        context.save();\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowColor = this.shadowColor;\r\n            context.shadowBlur = this.shadowBlur;\r\n            context.shadowOffsetX = this.shadowOffsetX;\r\n            context.shadowOffsetY = this.shadowOffsetY;\r\n        }\r\n\r\n        let x, y, width, height;\r\n        if (this.cellId == -1) {\r\n            x = this._sourceLeft;\r\n            y = this._sourceTop;\r\n\r\n            width = this._sourceWidth ? this._sourceWidth : this._imageWidth;\r\n            height = this._sourceHeight ? this._sourceHeight : this._imageHeight;\r\n        } else {\r\n            const rowCount = this._domImage.naturalWidth / this.cellWidth;\r\n            const column = (this.cellId / rowCount) >> 0;\r\n            const row = this.cellId % rowCount;\r\n\r\n            x = this.cellWidth * row;\r\n            y = this.cellHeight * column;\r\n            width = this.cellWidth;\r\n            height = this.cellHeight;\r\n        }\r\n\r\n        this._prepareWorkingCanvasForOpaqueDetection();\r\n\r\n        this._applyStates(context);\r\n        if (this._loaded) {\r\n            switch (this._stretch) {\r\n                case Image.STRETCH_NONE:\r\n                    this._drawImage(context, x, y, width, height, this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\r\n                    break;\r\n                case Image.STRETCH_FILL:\r\n                    this._drawImage(context, x, y, width, height, this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\r\n                    break;\r\n                case Image.STRETCH_UNIFORM: {\r\n                    const hRatio = this._currentMeasure.width / width;\r\n                    const vRatio = this._currentMeasure.height / height;\r\n                    const ratio = Math.min(hRatio, vRatio);\r\n                    const centerX = (this._currentMeasure.width - width * ratio) / 2;\r\n                    const centerY = (this._currentMeasure.height - height * ratio) / 2;\r\n\r\n                    this._drawImage(context, x, y, width, height, this._currentMeasure.left + centerX, this._currentMeasure.top + centerY, width * ratio, height * ratio);\r\n                    break;\r\n                }\r\n                case Image.STRETCH_EXTEND:\r\n                    this._drawImage(context, x, y, width, height, this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\r\n                    break;\r\n                case Image.STRETCH_NINE_PATCH:\r\n                    this._renderNinePatch(context, x, y, width, height);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        context.restore();\r\n    }\r\n\r\n    private _renderNinePatch(context: ICanvasRenderingContext, sx: number, sy: number, sw: number, sh: number): void {\r\n        const leftWidth = this._sliceLeft;\r\n        const topHeight = this._sliceTop;\r\n        const bottomHeight = sh - this._sliceBottom;\r\n        const rightWidth = sw - this._sliceRight;\r\n        const centerWidth = this._sliceRight - this._sliceLeft;\r\n        const centerHeight = this._sliceBottom - this._sliceTop;\r\n        const targetCenterWidth = this._currentMeasure.width - rightWidth - leftWidth + 2;\r\n        const targetCenterHeight = this._currentMeasure.height - bottomHeight - topHeight + 2;\r\n        const centerLeftOffset = this._currentMeasure.left + leftWidth - 1;\r\n        const centerTopOffset = this._currentMeasure.top + topHeight - 1;\r\n        const rightOffset = this._currentMeasure.left + this._currentMeasure.width - rightWidth;\r\n        const bottomOffset = this._currentMeasure.top + this._currentMeasure.height - bottomHeight;\r\n\r\n        //Top Left\r\n        this._drawImage(context, sx, sy, leftWidth, topHeight, this._currentMeasure.left, this._currentMeasure.top, leftWidth, topHeight);\r\n        //Top\r\n        this._drawImage(context, sx + this._sliceLeft, sy, centerWidth, topHeight, centerLeftOffset + 1, this._currentMeasure.top, targetCenterWidth - 2, topHeight);\r\n        //Top Right\r\n        this._drawImage(context, sx + this._sliceRight, sy, rightWidth, topHeight, rightOffset, this._currentMeasure.top, rightWidth, topHeight);\r\n        //Left\r\n        this._drawImage(context, sx, sy + this._sliceTop, leftWidth, centerHeight, this._currentMeasure.left, centerTopOffset + 1, leftWidth, targetCenterHeight - 2);\r\n        // Center\r\n        this._drawImage(context, sx + this._sliceLeft, sy + this._sliceTop, centerWidth, centerHeight, centerLeftOffset, centerTopOffset, targetCenterWidth, targetCenterHeight);\r\n        //Right\r\n        this._drawImage(context, sx + this._sliceRight, sy + this._sliceTop, rightWidth, centerHeight, rightOffset, centerTopOffset + 1, rightWidth, targetCenterHeight - 2);\r\n        //Bottom Left\r\n        this._drawImage(context, sx, sy + this._sliceBottom, leftWidth, bottomHeight, this._currentMeasure.left, bottomOffset, leftWidth, bottomHeight);\r\n        //Bottom\r\n        this._drawImage(context, sx + this.sliceLeft, sy + this._sliceBottom, centerWidth, bottomHeight, centerLeftOffset + 1, bottomOffset, targetCenterWidth - 2, bottomHeight);\r\n        //Bottom Right\r\n        this._drawImage(context, sx + this._sliceRight, sy + this._sliceBottom, rightWidth, bottomHeight, rightOffset, bottomOffset, rightWidth, bottomHeight);\r\n    }\r\n\r\n    public dispose() {\r\n        super.dispose();\r\n        this.onImageLoadedObservable.clear();\r\n        this.onSVGAttributesComputedObservable.clear();\r\n        this._removeCacheUsage(this._source);\r\n    }\r\n\r\n    // Static\r\n    /** STRETCH_NONE */\r\n    public static readonly STRETCH_NONE = 0;\r\n    /** STRETCH_FILL */\r\n    public static readonly STRETCH_FILL = 1;\r\n    /** STRETCH_UNIFORM */\r\n    public static readonly STRETCH_UNIFORM = 2;\r\n    /** STRETCH_EXTEND */\r\n    public static readonly STRETCH_EXTEND = 3;\r\n    /** NINE_PATCH */\r\n    public static readonly STRETCH_NINE_PATCH = 4;\r\n}\r\nRegisterClass(\"BABYLON.GUI.Image\", Image);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}