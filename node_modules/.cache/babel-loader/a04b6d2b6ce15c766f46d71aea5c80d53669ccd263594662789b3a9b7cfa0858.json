{"ast":null,"code":"import { Texture } from \"./texture.js\";\nimport \"../../Engines/Extensions/engine.rawTexture.js\";\n/**\n * Raw texture can help creating a texture directly from an array of data.\n * This can be super useful if you either get the data from an uncompressed source or\n * if you wish to create your texture pixel by pixel.\n */\nexport class RawTexture extends Texture {\n  /**\n   * Instantiates a new RawTexture.\n   * Raw texture can help creating a texture directly from an array of data.\n   * This can be super useful if you either get the data from an uncompressed source or\n   * if you wish to create your texture pixel by pixel.\n   * @param data define the array of data to use to create the texture (null to create an empty texture)\n   * @param width define the width of the texture\n   * @param height define the height of the texture\n   * @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps define whether mip maps should be generated or not\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n   */\n  constructor(data, width, height,\n  /**\n   * Define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\n   */\n  format, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags, useSRGBBuffer) {\n    super(null, sceneOrEngine, !generateMipMaps, invertY, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, creationFlags);\n    this.format = format;\n    if (!this._engine) {\n      return;\n    }\n    if (!this._engine._caps.textureFloatLinearFiltering && type === 1) {\n      samplingMode = 1;\n    }\n    if (!this._engine._caps.textureHalfFloatLinearFiltering && type === 2) {\n      samplingMode = 1;\n    }\n    this._texture = this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type, creationFlags !== null && creationFlags !== void 0 ? creationFlags : 0, useSRGBBuffer !== null && useSRGBBuffer !== void 0 ? useSRGBBuffer : false);\n    this.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this.wrapV = Texture.CLAMP_ADDRESSMODE;\n  }\n  /**\n   * Updates the texture underlying data.\n   * @param data Define the new data of the texture\n   */\n  update(data) {\n    this._getEngine().updateRawTexture(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type, this._texture._useSRGBBuffer);\n  }\n  /**\n   * Creates a luminance texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @returns the luminance texture\n   */\n  static CreateLuminanceTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {\n    return new RawTexture(data, width, height, 1, sceneOrEngine, generateMipMaps, invertY, samplingMode);\n  }\n  /**\n   * Creates a luminance alpha texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @returns the luminance alpha texture\n   */\n  static CreateLuminanceAlphaTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {\n    return new RawTexture(data, width, height, 2, sceneOrEngine, generateMipMaps, invertY, samplingMode);\n  }\n  /**\n   * Creates an alpha texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @returns the alpha texture\n   */\n  static CreateAlphaTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {\n    return new RawTexture(data, width, height, 0, sceneOrEngine, generateMipMaps, invertY, samplingMode);\n  }\n  /**\n   * Creates a RGB texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n   * @returns the RGB alpha texture\n   */\n  static CreateRGBTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags = 0, useSRGBBuffer = false) {\n    return new RawTexture(data, width, height, 4, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);\n  }\n  /**\n   * Creates a RGBA texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n   * @returns the RGBA texture\n   */\n  static CreateRGBATexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags = 0, useSRGBBuffer = false) {\n    return new RawTexture(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);\n  }\n  /**\n   * Creates a RGBA storage texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n   * @returns the RGBA texture\n   */\n  static CreateRGBAStorageTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, useSRGBBuffer = false) {\n    return new RawTexture(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, 1, useSRGBBuffer);\n  }\n  /**\n   * Creates a R texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n   * @returns the R texture\n   */\n  static CreateRTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, type = 1) {\n    return new RawTexture(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\n  }\n  /**\n   * Creates a R storage texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n   * @returns the R texture\n   */\n  static CreateRStorageTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, type = 1) {\n    return new RawTexture(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, 1);\n  }\n}","map":{"version":3,"names":["Texture","RawTexture","constructor","data","width","height","format","sceneOrEngine","generateMipMaps","invertY","samplingMode","type","creationFlags","useSRGBBuffer","undefined","_engine","_caps","textureFloatLinearFiltering","textureHalfFloatLinearFiltering","_texture","createRawTexture","wrapU","CLAMP_ADDRESSMODE","wrapV","update","_getEngine","updateRawTexture","_useSRGBBuffer","CreateLuminanceTexture","CreateLuminanceAlphaTexture","CreateAlphaTexture","CreateRGBTexture","CreateRGBATexture","CreateRGBAStorageTexture","CreateRTexture","TRILINEAR_SAMPLINGMODE","CreateRStorageTexture"],"sources":["../../../../../dev/core/src/Materials/Textures/rawTexture.ts"],"sourcesContent":["import { Texture } from \"./texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\n\r\nimport type { Scene } from \"../../scene\";\r\n\r\n/**\r\n * Raw texture can help creating a texture directly from an array of data.\r\n * This can be super useful if you either get the data from an uncompressed source or\r\n * if you wish to create your texture pixel by pixel.\r\n */\r\nexport class RawTexture extends Texture {\r\n    /**\r\n     * Instantiates a new RawTexture.\r\n     * Raw texture can help creating a texture directly from an array of data.\r\n     * This can be super useful if you either get the data from an uncompressed source or\r\n     * if you wish to create your texture pixel by pixel.\r\n     * @param data define the array of data to use to create the texture (null to create an empty texture)\r\n     * @param width define the width of the texture\r\n     * @param height define the height of the texture\r\n     * @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps define whether mip maps should be generated or not\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     */\r\n    constructor(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        /**\r\n         * Define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n         */\r\n        public format: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        creationFlags?: number,\r\n        useSRGBBuffer?: boolean\r\n    ) {\r\n        super(null, sceneOrEngine, !generateMipMaps, invertY, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, creationFlags);\r\n\r\n        if (!this._engine) {\r\n            return;\r\n        }\r\n\r\n        if (!this._engine._caps.textureFloatLinearFiltering && type === Constants.TEXTURETYPE_FLOAT) {\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n        if (!this._engine._caps.textureHalfFloatLinearFiltering && type === Constants.TEXTURETYPE_HALF_FLOAT) {\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n\r\n        this._texture = this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type, creationFlags ?? 0, useSRGBBuffer ?? false);\r\n\r\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n    }\r\n\r\n    /**\r\n     * Updates the texture underlying data.\r\n     * @param data Define the new data of the texture\r\n     */\r\n    public update(data: ArrayBufferView): void {\r\n        this._getEngine()!.updateRawTexture(this._texture, data, this._texture!.format, this._texture!.invertY, null, this._texture!.type, this._texture!._useSRGBBuffer);\r\n    }\r\n\r\n    /**\r\n     * Creates a luminance texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the luminance texture\r\n     */\r\n    public static CreateLuminanceTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_LUMINANCE, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates a luminance alpha texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the luminance alpha texture\r\n     */\r\n    public static CreateLuminanceAlphaTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_LUMINANCE_ALPHA, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates an alpha texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the alpha texture\r\n     */\r\n    public static CreateAlphaTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_ALPHA, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGB texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the RGB alpha texture\r\n     */\r\n    public static CreateRGBTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        creationFlags: number = 0,\r\n        useSRGBBuffer: boolean = false\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_RGB, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBATexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        creationFlags: number = 0,\r\n        useSRGBBuffer: boolean = false\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_RGBA, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA storage texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBAStorageTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        useSRGBBuffer: boolean = false\r\n    ): RawTexture {\r\n        return new RawTexture(\r\n            data,\r\n            width,\r\n            height,\r\n            Constants.TEXTUREFORMAT_RGBA,\r\n            sceneOrEngine,\r\n            generateMipMaps,\r\n            invertY,\r\n            samplingMode,\r\n            type,\r\n            Constants.TEXTURE_CREATIONFLAG_STORAGE,\r\n            useSRGBBuffer\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a R texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the R texture\r\n     */\r\n    public static CreateRTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_FLOAT\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_R, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\r\n    }\r\n\r\n    /**\r\n     * Creates a R storage texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the R texture\r\n     */\r\n    public static CreateRStorageTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_FLOAT\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_R, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, Constants.TEXTURE_CREATIONFLAG_STORAGE);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}