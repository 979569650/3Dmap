{"ast":null,"code":"import { WebGLHardwareTexture } from \"../../Engines/WebGL/webGLHardwareTexture.js\";\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { DirectionalLight } from \"../../Lights/directionalLight.js\";\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture.js\";\nimport { SphericalHarmonics, SphericalPolynomial } from \"../../Maths/sphericalPolynomial.js\";\nimport { LightConstants } from \"../../Lights/lightConstants.js\";\n/**\n * Light Estimation Feature\n *\n * @since 5.0.0\n */\nexport class WebXRLightEstimation extends WebXRAbstractFeature {\n  /**\n   * Creates a new instance of the light estimation feature\n   * @param _xrSessionManager an instance of WebXRSessionManager\n   * @param options options to use when constructing this feature\n   */\n  constructor(_xrSessionManager,\n  /**\n   * options to use when constructing this feature\n   */\n  options) {\n    super(_xrSessionManager);\n    this.options = options;\n    this._canvasContext = null;\n    this._reflectionCubeMap = null;\n    this._xrLightEstimate = null;\n    this._xrLightProbe = null;\n    this._xrWebGLBinding = null;\n    this._lightDirection = Vector3.Up().negateInPlace();\n    this._lightColor = Color3.White();\n    this._intensity = 1;\n    this._sphericalHarmonics = new SphericalHarmonics();\n    this._cubeMapPollTime = Date.now();\n    this._lightEstimationPollTime = Date.now();\n    /**\n     * ARCore's reflection cube map size is 16x16.\n     * Once other systems support this feature we will need to change this to be dynamic.\n     * see https://github.com/immersive-web/lighting-estimation/blob/main/lighting-estimation-explainer.md#cube-map-open-questions\n     */\n    this._reflectionCubeMapTextureSize = 16;\n    /**\n     * If createDirectionalLightSource is set to true this light source will be created automatically.\n     * Otherwise this can be set with an external directional light source.\n     * This light will be updated whenever the light estimation values change.\n     */\n    this.directionalLight = null;\n    /**\n     * This observable will notify when the reflection cube map is updated.\n     */\n    this.onReflectionCubeMapUpdatedObservable = new Observable();\n    /**\n     * Event Listener for \"reflectionchange\" events.\n     */\n    this._updateReflectionCubeMap = () => {\n      var _a;\n      if (!this._xrLightProbe) {\n        return;\n      }\n      // check poll time, do not update if it has not been long enough\n      if (this.options.cubeMapPollInterval) {\n        const now = Date.now();\n        if (now - this._cubeMapPollTime < this.options.cubeMapPollInterval) {\n          return;\n        }\n        this._cubeMapPollTime = now;\n      }\n      const lp = this._getXRGLBinding().getReflectionCubeMap(this._xrLightProbe);\n      if (lp && this._reflectionCubeMap) {\n        if (!this._reflectionCubeMap._texture) {\n          const internalTexture = new InternalTexture(this._xrSessionManager.scene.getEngine(), InternalTextureSource.Unknown);\n          internalTexture.isCube = true;\n          internalTexture.invertY = false;\n          internalTexture._useSRGBBuffer = this.options.reflectionFormat === \"srgba8\";\n          internalTexture.format = 5;\n          internalTexture.generateMipMaps = true;\n          internalTexture.type = this.options.reflectionFormat !== \"srgba8\" ? 2 : 0;\n          internalTexture.samplingMode = 3;\n          internalTexture.width = this._reflectionCubeMapTextureSize;\n          internalTexture.height = this._reflectionCubeMapTextureSize;\n          internalTexture._cachedWrapU = 1;\n          internalTexture._cachedWrapV = 1;\n          internalTexture._hardwareTexture = new WebGLHardwareTexture(lp, this._getCanvasContext());\n          this._reflectionCubeMap._texture = internalTexture;\n        } else {\n          (_a = this._reflectionCubeMap._texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.set(lp);\n          this._reflectionCubeMap._texture.getEngine().resetTextureCache();\n        }\n        this._reflectionCubeMap._texture.isReady = true;\n        this._xrSessionManager.scene.markAllMaterialsAsDirty(1);\n        this.onReflectionCubeMapUpdatedObservable.notifyObservers(this._reflectionCubeMap);\n      }\n    };\n    this.xrNativeFeatureName = \"light-estimation\";\n    if (this.options.createDirectionalLightSource) {\n      this.directionalLight = new DirectionalLight(\"light estimation directional\", this._lightDirection, this._xrSessionManager.scene);\n      this.directionalLight.position = new Vector3(0, 8, 0);\n      // intensity will be set later\n      this.directionalLight.intensity = 0;\n      this.directionalLight.falloffType = LightConstants.FALLOFF_GLTF;\n    }\n    // https://immersive-web.github.io/lighting-estimation/\n    Tools.Warn(\"light-estimation is an experimental and unstable feature.\");\n  }\n  /**\n   * While the estimated cube map is expected to update over time to better reflect the user's environment as they move around those changes are unlikely to happen with every XRFrame.\n   * Since creating and processing the cube map is potentially expensive, especially if mip maps are needed, you can listen to the onReflectionCubeMapUpdatedObservable to determine\n   * when it has been updated.\n   */\n  get reflectionCubeMapTexture() {\n    return this._reflectionCubeMap;\n  }\n  /**\n   * The most recent light estimate.  Available starting on the first frame where the device provides a light probe.\n   */\n  get xrLightingEstimate() {\n    if (this._xrLightEstimate) {\n      return {\n        lightColor: this._lightColor,\n        lightDirection: this._lightDirection,\n        lightIntensity: this._intensity,\n        sphericalHarmonics: this._sphericalHarmonics\n      };\n    }\n    return this._xrLightEstimate;\n  }\n  _getCanvasContext() {\n    if (this._canvasContext === null) {\n      this._canvasContext = this._xrSessionManager.scene.getEngine()._gl;\n    }\n    return this._canvasContext;\n  }\n  _getXRGLBinding() {\n    if (this._xrWebGLBinding === null) {\n      const context = this._getCanvasContext();\n      this._xrWebGLBinding = new XRWebGLBinding(this._xrSessionManager.session, context);\n    }\n    return this._xrWebGLBinding;\n  }\n  /**\n   * attach this feature\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  attach() {\n    var _a;\n    if (!super.attach()) {\n      return false;\n    }\n    const reflectionFormat = (_a = this.options.reflectionFormat) !== null && _a !== void 0 ? _a : this._xrSessionManager.session.preferredReflectionFormat || \"srgba8\";\n    this.options.reflectionFormat = reflectionFormat;\n    this._xrSessionManager.session.requestLightProbe({\n      reflectionFormat\n    }).then(xrLightProbe => {\n      this._xrLightProbe = xrLightProbe;\n      if (!this.options.disableCubeMapReflection) {\n        if (!this._reflectionCubeMap) {\n          this._reflectionCubeMap = new BaseTexture(this._xrSessionManager.scene);\n          this._reflectionCubeMap._isCube = true;\n          this._reflectionCubeMap.coordinatesMode = 3;\n          if (this.options.setSceneEnvironmentTexture) {\n            this._xrSessionManager.scene.environmentTexture = this._reflectionCubeMap;\n          }\n        }\n        this._xrLightProbe.addEventListener(\"reflectionchange\", this._updateReflectionCubeMap);\n      }\n    });\n    return true;\n  }\n  /**\n   * detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  detach() {\n    const detached = super.detach();\n    if (this._xrLightProbe !== null && !this.options.disableCubeMapReflection) {\n      this._xrLightProbe.removeEventListener(\"reflectionchange\", this._updateReflectionCubeMap);\n      this._xrLightProbe = null;\n    }\n    this._canvasContext = null;\n    this._xrLightEstimate = null;\n    // When the session ends (on detach) we must clear our XRWebGLBinging instance, which references the ended session.\n    this._xrWebGLBinding = null;\n    return detached;\n  }\n  /**\n   * Dispose this feature and all of the resources attached\n   */\n  dispose() {\n    super.dispose();\n    this.onReflectionCubeMapUpdatedObservable.clear();\n    if (this.directionalLight) {\n      this.directionalLight.dispose();\n      this.directionalLight = null;\n    }\n    if (this._reflectionCubeMap !== null) {\n      if (this._reflectionCubeMap._texture) {\n        this._reflectionCubeMap._texture.dispose();\n      }\n      this._reflectionCubeMap.dispose();\n      this._reflectionCubeMap = null;\n    }\n  }\n  _onXRFrame(_xrFrame) {\n    var _a;\n    if (this._xrLightProbe !== null) {\n      if (this.options.lightEstimationPollInterval) {\n        const now = Date.now();\n        if (now - this._lightEstimationPollTime < this.options.lightEstimationPollInterval) {\n          return;\n        }\n        this._lightEstimationPollTime = now;\n      }\n      this._xrLightEstimate = _xrFrame.getLightEstimate(this._xrLightProbe);\n      if (this._xrLightEstimate) {\n        this._intensity = Math.max(1.0, this._xrLightEstimate.primaryLightIntensity.x, this._xrLightEstimate.primaryLightIntensity.y, this._xrLightEstimate.primaryLightIntensity.z);\n        const rhsFactor = this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0;\n        // recreate the vector caches, so that the last one provided to the user will persist\n        if (this.options.disableVectorReuse) {\n          this._lightDirection = new Vector3();\n          this._lightColor = new Color3();\n          if (this.directionalLight) {\n            this.directionalLight.direction = this._lightDirection;\n            this.directionalLight.diffuse = this._lightColor;\n          }\n        }\n        this._lightDirection.copyFromFloats(this._xrLightEstimate.primaryLightDirection.x, this._xrLightEstimate.primaryLightDirection.y, this._xrLightEstimate.primaryLightDirection.z * rhsFactor);\n        this._lightColor.copyFromFloats(this._xrLightEstimate.primaryLightIntensity.x / this._intensity, this._xrLightEstimate.primaryLightIntensity.y / this._intensity, this._xrLightEstimate.primaryLightIntensity.z / this._intensity);\n        this._sphericalHarmonics.updateFromFloatsArray(this._xrLightEstimate.sphericalHarmonicsCoefficients);\n        if (this._reflectionCubeMap && !this.options.disableSphericalPolynomial) {\n          this._reflectionCubeMap.sphericalPolynomial = this._reflectionCubeMap.sphericalPolynomial || new SphericalPolynomial();\n          (_a = this._reflectionCubeMap.sphericalPolynomial) === null || _a === void 0 ? void 0 : _a.updateFromHarmonics(this._sphericalHarmonics);\n        }\n        // direction from instead of direction to\n        this._lightDirection.negateInPlace();\n        // set the values after calculating them\n        if (this.directionalLight) {\n          this.directionalLight.direction.copyFrom(this._lightDirection);\n          this.directionalLight.intensity = Math.min(this._intensity, 1.0);\n          this.directionalLight.diffuse.copyFrom(this._lightColor);\n        }\n      }\n    }\n  }\n}\n/**\n * The module's name\n */\nWebXRLightEstimation.Name = WebXRFeatureName.LIGHT_ESTIMATION;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRLightEstimation.Version = 1;\n// register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRLightEstimation.Name, (xrSessionManager, options) => {\n  return () => new WebXRLightEstimation(xrSessionManager, options);\n}, WebXRLightEstimation.Version, false);","map":{"version":3,"names":["WebGLHardwareTexture","InternalTexture","InternalTextureSource","Observable","Tools","WebXRFeatureName","WebXRFeaturesManager","WebXRAbstractFeature","Color3","Vector3","DirectionalLight","BaseTexture","SphericalHarmonics","SphericalPolynomial","LightConstants","WebXRLightEstimation","constructor","_xrSessionManager","options","_canvasContext","_reflectionCubeMap","_xrLightEstimate","_xrLightProbe","_xrWebGLBinding","_lightDirection","Up","negateInPlace","_lightColor","White","_intensity","_sphericalHarmonics","_cubeMapPollTime","Date","now","_lightEstimationPollTime","_reflectionCubeMapTextureSize","directionalLight","onReflectionCubeMapUpdatedObservable","_updateReflectionCubeMap","cubeMapPollInterval","lp","_getXRGLBinding","getReflectionCubeMap","_texture","internalTexture","scene","getEngine","Unknown","isCube","invertY","_useSRGBBuffer","reflectionFormat","format","generateMipMaps","type","samplingMode","width","height","_cachedWrapU","_cachedWrapV","_hardwareTexture","_getCanvasContext","_a","set","resetTextureCache","isReady","markAllMaterialsAsDirty","notifyObservers","xrNativeFeatureName","createDirectionalLightSource","position","intensity","falloffType","FALLOFF_GLTF","Warn","reflectionCubeMapTexture","xrLightingEstimate","lightColor","lightDirection","lightIntensity","sphericalHarmonics","_gl","context","XRWebGLBinding","session","attach","preferredReflectionFormat","requestLightProbe","then","xrLightProbe","disableCubeMapReflection","_isCube","coordinatesMode","setSceneEnvironmentTexture","environmentTexture","addEventListener","detach","detached","removeEventListener","dispose","clear","_onXRFrame","_xrFrame","lightEstimationPollInterval","getLightEstimate","Math","max","primaryLightIntensity","x","y","z","rhsFactor","useRightHandedSystem","disableVectorReuse","direction","diffuse","copyFromFloats","primaryLightDirection","updateFromFloatsArray","sphericalHarmonicsCoefficients","disableSphericalPolynomial","sphericalPolynomial","updateFromHarmonics","copyFrom","min","Name","LIGHT_ESTIMATION","Version","AddWebXRFeature","xrSessionManager"],"sources":["../../../../../dev/core/src/XR/features/WebXRLightEstimation.ts"],"sourcesContent":["import { WebGLHardwareTexture } from \"../../Engines/WebGL/webGLHardwareTexture\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { DirectionalLight } from \"../../Lights/directionalLight\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { SphericalHarmonics, SphericalPolynomial } from \"../../Maths/sphericalPolynomial\";\r\nimport { LightConstants } from \"../../Lights/lightConstants\";\r\n\r\n/**\r\n * Options for Light Estimation feature\r\n */\r\nexport interface IWebXRLightEstimationOptions {\r\n    /**\r\n     * Disable the cube map reflection feature. In this case only light direction and color will be updated\r\n     */\r\n    disableCubeMapReflection?: boolean;\r\n    /**\r\n     * Should the scene's env texture be set to the cube map reflection texture\r\n     * Note that this doesn't work is disableCubeMapReflection if set to false\r\n     */\r\n    setSceneEnvironmentTexture?: boolean;\r\n    /**\r\n     * How often should the cubemap update in ms.\r\n     * If not set the cubemap will be updated every time the underlying system updates the environment texture.\r\n     */\r\n    cubeMapPollInterval?: number;\r\n    /**\r\n     * How often should the light estimation properties update in ms.\r\n     * If not set the light estimation properties will be updated on every frame (depending on the underlying system)\r\n     */\r\n    lightEstimationPollInterval?: number;\r\n    /**\r\n     * Should a directional light source be created.\r\n     * If created, this light source will be updated whenever the light estimation values change\r\n     */\r\n    createDirectionalLightSource?: boolean;\r\n    /**\r\n     * Define the format to be used for the light estimation texture.\r\n     */\r\n    reflectionFormat?: XRReflectionFormat;\r\n    /**\r\n     * Should the light estimation's needed vectors be constructed on each frame.\r\n     * Use this when you use those vectors and don't want their values to change outside of the light estimation feature\r\n     */\r\n    disableVectorReuse?: boolean;\r\n\r\n    /**\r\n     * disable applying the spherical polynomial to the cube map texture\r\n     */\r\n    disableSphericalPolynomial?: boolean;\r\n}\r\n\r\n/**\r\n * An interface describing the result of a light estimation\r\n */\r\nexport interface IWebXRLightEstimation {\r\n    /**\r\n     * The intensity of the light source\r\n     */\r\n    lightIntensity: number;\r\n    /**\r\n     * Color of light source\r\n     */\r\n    lightColor: Color3;\r\n    /**\r\n     * The direction from the light source\r\n     */\r\n    lightDirection: Vector3;\r\n    /**\r\n     * Spherical harmonics coefficients of the light source\r\n     */\r\n    sphericalHarmonics: SphericalHarmonics;\r\n}\r\n\r\n/**\r\n * Light Estimation Feature\r\n *\r\n * @since 5.0.0\r\n */\r\nexport class WebXRLightEstimation extends WebXRAbstractFeature {\r\n    private _canvasContext: Nullable<WebGLRenderingContext | WebGL2RenderingContext> = null;\r\n    private _reflectionCubeMap: Nullable<BaseTexture> = null;\r\n    private _xrLightEstimate: Nullable<XRLightEstimate> = null;\r\n    private _xrLightProbe: Nullable<XRLightProbe> = null;\r\n    private _xrWebGLBinding: Nullable<XRWebGLBinding> = null;\r\n    private _lightDirection: Vector3 = Vector3.Up().negateInPlace();\r\n    private _lightColor: Color3 = Color3.White();\r\n    private _intensity: number = 1;\r\n    private _sphericalHarmonics: SphericalHarmonics = new SphericalHarmonics();\r\n    private _cubeMapPollTime = Date.now();\r\n    private _lightEstimationPollTime = Date.now();\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.LIGHT_ESTIMATION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * ARCore's reflection cube map size is 16x16.\r\n     * Once other systems support this feature we will need to change this to be dynamic.\r\n     * see https://github.com/immersive-web/lighting-estimation/blob/main/lighting-estimation-explainer.md#cube-map-open-questions\r\n     */\r\n    private _reflectionCubeMapTextureSize: number = 16;\r\n\r\n    /**\r\n     * If createDirectionalLightSource is set to true this light source will be created automatically.\r\n     * Otherwise this can be set with an external directional light source.\r\n     * This light will be updated whenever the light estimation values change.\r\n     */\r\n    public directionalLight: Nullable<DirectionalLight> = null;\r\n\r\n    /**\r\n     * This observable will notify when the reflection cube map is updated.\r\n     */\r\n    public onReflectionCubeMapUpdatedObservable: Observable<BaseTexture> = new Observable();\r\n\r\n    /**\r\n     * Creates a new instance of the light estimation feature\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param options options to use when constructing this feature\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        /**\r\n         * options to use when constructing this feature\r\n         */\r\n        public readonly options: IWebXRLightEstimationOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"light-estimation\";\r\n\r\n        if (this.options.createDirectionalLightSource) {\r\n            this.directionalLight = new DirectionalLight(\"light estimation directional\", this._lightDirection, this._xrSessionManager.scene);\r\n            this.directionalLight.position = new Vector3(0, 8, 0);\r\n            // intensity will be set later\r\n            this.directionalLight.intensity = 0;\r\n            this.directionalLight.falloffType = LightConstants.FALLOFF_GLTF;\r\n        }\r\n\r\n        // https://immersive-web.github.io/lighting-estimation/\r\n        Tools.Warn(\"light-estimation is an experimental and unstable feature.\");\r\n    }\r\n\r\n    /**\r\n     * While the estimated cube map is expected to update over time to better reflect the user's environment as they move around those changes are unlikely to happen with every XRFrame.\r\n     * Since creating and processing the cube map is potentially expensive, especially if mip maps are needed, you can listen to the onReflectionCubeMapUpdatedObservable to determine\r\n     * when it has been updated.\r\n     */\r\n    public get reflectionCubeMapTexture(): Nullable<BaseTexture> {\r\n        return this._reflectionCubeMap;\r\n    }\r\n\r\n    /**\r\n     * The most recent light estimate.  Available starting on the first frame where the device provides a light probe.\r\n     */\r\n    public get xrLightingEstimate(): Nullable<IWebXRLightEstimation> {\r\n        if (this._xrLightEstimate) {\r\n            return {\r\n                lightColor: this._lightColor,\r\n                lightDirection: this._lightDirection,\r\n                lightIntensity: this._intensity,\r\n                sphericalHarmonics: this._sphericalHarmonics,\r\n            };\r\n        }\r\n        return this._xrLightEstimate;\r\n    }\r\n\r\n    private _getCanvasContext(): WebGLRenderingContext | WebGL2RenderingContext {\r\n        if (this._canvasContext === null) {\r\n            this._canvasContext = this._xrSessionManager.scene.getEngine()._gl;\r\n        }\r\n        return this._canvasContext;\r\n    }\r\n\r\n    private _getXRGLBinding(): XRWebGLBinding {\r\n        if (this._xrWebGLBinding === null) {\r\n            const context = this._getCanvasContext();\r\n            this._xrWebGLBinding = new XRWebGLBinding(this._xrSessionManager.session, context);\r\n        }\r\n        return this._xrWebGLBinding;\r\n    }\r\n\r\n    /**\r\n     * Event Listener for \"reflectionchange\" events.\r\n     */\r\n    private _updateReflectionCubeMap = (): void => {\r\n        if (!this._xrLightProbe) {\r\n            return;\r\n        }\r\n        // check poll time, do not update if it has not been long enough\r\n        if (this.options.cubeMapPollInterval) {\r\n            const now = Date.now();\r\n            if (now - this._cubeMapPollTime < this.options.cubeMapPollInterval) {\r\n                return;\r\n            }\r\n            this._cubeMapPollTime = now;\r\n        }\r\n        const lp = this._getXRGLBinding().getReflectionCubeMap(this._xrLightProbe);\r\n        if (lp && this._reflectionCubeMap) {\r\n            if (!this._reflectionCubeMap._texture) {\r\n                const internalTexture = new InternalTexture(this._xrSessionManager.scene.getEngine(), InternalTextureSource.Unknown);\r\n                internalTexture.isCube = true;\r\n                internalTexture.invertY = false;\r\n                internalTexture._useSRGBBuffer = this.options.reflectionFormat === \"srgba8\";\r\n                internalTexture.format = Constants.TEXTUREFORMAT_RGBA;\r\n                internalTexture.generateMipMaps = true;\r\n                internalTexture.type = this.options.reflectionFormat !== \"srgba8\" ? Constants.TEXTURETYPE_HALF_FLOAT : Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n                internalTexture.samplingMode = Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR;\r\n                internalTexture.width = this._reflectionCubeMapTextureSize;\r\n                internalTexture.height = this._reflectionCubeMapTextureSize;\r\n                internalTexture._cachedWrapU = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n                internalTexture._cachedWrapV = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n                internalTexture._hardwareTexture = new WebGLHardwareTexture(lp, this._getCanvasContext() as WebGLRenderingContext);\r\n                this._reflectionCubeMap._texture = internalTexture;\r\n            } else {\r\n                this._reflectionCubeMap._texture._hardwareTexture?.set(lp);\r\n                this._reflectionCubeMap._texture.getEngine().resetTextureCache();\r\n            }\r\n            this._reflectionCubeMap._texture.isReady = true;\r\n            this._xrSessionManager.scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n\r\n            this.onReflectionCubeMapUpdatedObservable.notifyObservers(this._reflectionCubeMap);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        const reflectionFormat = this.options.reflectionFormat ?? (this._xrSessionManager.session.preferredReflectionFormat || \"srgba8\");\r\n        this.options.reflectionFormat = reflectionFormat;\r\n        this._xrSessionManager.session\r\n            .requestLightProbe({\r\n                reflectionFormat,\r\n            })\r\n            .then((xrLightProbe: XRLightProbe) => {\r\n                this._xrLightProbe = xrLightProbe;\r\n                if (!this.options.disableCubeMapReflection) {\r\n                    if (!this._reflectionCubeMap) {\r\n                        this._reflectionCubeMap = new BaseTexture(this._xrSessionManager.scene);\r\n                        this._reflectionCubeMap._isCube = true;\r\n                        this._reflectionCubeMap.coordinatesMode = Constants.TEXTURE_CUBIC_MODE;\r\n                        if (this.options.setSceneEnvironmentTexture) {\r\n                            this._xrSessionManager.scene.environmentTexture = this._reflectionCubeMap;\r\n                        }\r\n                    }\r\n                    this._xrLightProbe.addEventListener(\"reflectionchange\", this._updateReflectionCubeMap);\r\n                }\r\n            });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        const detached = super.detach();\r\n\r\n        if (this._xrLightProbe !== null && !this.options.disableCubeMapReflection) {\r\n            this._xrLightProbe.removeEventListener(\"reflectionchange\", this._updateReflectionCubeMap);\r\n            this._xrLightProbe = null;\r\n        }\r\n\r\n        this._canvasContext = null;\r\n        this._xrLightEstimate = null;\r\n        // When the session ends (on detach) we must clear our XRWebGLBinging instance, which references the ended session.\r\n        this._xrWebGLBinding = null;\r\n\r\n        return detached;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        this.onReflectionCubeMapUpdatedObservable.clear();\r\n\r\n        if (this.directionalLight) {\r\n            this.directionalLight.dispose();\r\n            this.directionalLight = null;\r\n        }\r\n\r\n        if (this._reflectionCubeMap !== null) {\r\n            if (this._reflectionCubeMap._texture) {\r\n                this._reflectionCubeMap._texture.dispose();\r\n            }\r\n            this._reflectionCubeMap.dispose();\r\n            this._reflectionCubeMap = null;\r\n        }\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame): void {\r\n        if (this._xrLightProbe !== null) {\r\n            if (this.options.lightEstimationPollInterval) {\r\n                const now = Date.now();\r\n                if (now - this._lightEstimationPollTime < this.options.lightEstimationPollInterval) {\r\n                    return;\r\n                }\r\n                this._lightEstimationPollTime = now;\r\n            }\r\n            this._xrLightEstimate = _xrFrame.getLightEstimate(this._xrLightProbe);\r\n            if (this._xrLightEstimate) {\r\n                this._intensity = Math.max(\r\n                    1.0,\r\n                    this._xrLightEstimate.primaryLightIntensity.x,\r\n                    this._xrLightEstimate.primaryLightIntensity.y,\r\n                    this._xrLightEstimate.primaryLightIntensity.z\r\n                );\r\n\r\n                const rhsFactor = this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0;\r\n\r\n                // recreate the vector caches, so that the last one provided to the user will persist\r\n                if (this.options.disableVectorReuse) {\r\n                    this._lightDirection = new Vector3();\r\n                    this._lightColor = new Color3();\r\n                    if (this.directionalLight) {\r\n                        this.directionalLight.direction = this._lightDirection;\r\n                        this.directionalLight.diffuse = this._lightColor;\r\n                    }\r\n                }\r\n\r\n                this._lightDirection.copyFromFloats(\r\n                    this._xrLightEstimate.primaryLightDirection.x,\r\n                    this._xrLightEstimate.primaryLightDirection.y,\r\n                    this._xrLightEstimate.primaryLightDirection.z * rhsFactor\r\n                );\r\n                this._lightColor.copyFromFloats(\r\n                    this._xrLightEstimate.primaryLightIntensity.x / this._intensity,\r\n                    this._xrLightEstimate.primaryLightIntensity.y / this._intensity,\r\n                    this._xrLightEstimate.primaryLightIntensity.z / this._intensity\r\n                );\r\n                this._sphericalHarmonics.updateFromFloatsArray(this._xrLightEstimate.sphericalHarmonicsCoefficients);\r\n                if (this._reflectionCubeMap && !this.options.disableSphericalPolynomial) {\r\n                    this._reflectionCubeMap.sphericalPolynomial = this._reflectionCubeMap.sphericalPolynomial || new SphericalPolynomial();\r\n                    this._reflectionCubeMap.sphericalPolynomial?.updateFromHarmonics(this._sphericalHarmonics);\r\n                }\r\n\r\n                // direction from instead of direction to\r\n                this._lightDirection.negateInPlace();\r\n                // set the values after calculating them\r\n                if (this.directionalLight) {\r\n                    this.directionalLight.direction.copyFrom(this._lightDirection);\r\n                    this.directionalLight.intensity = Math.min(this._intensity, 1.0);\r\n                    this.directionalLight.diffuse.copyFrom(this._lightColor);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRLightEstimation.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRLightEstimation(xrSessionManager, options);\r\n    },\r\n    WebXRLightEstimation.Version,\r\n    false\r\n);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}