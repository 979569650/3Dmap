{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator.js\";\nimport { MaterialHelper } from \"../../../materialHelper.js\";\n/**\n * Block used to output the final color\n */\nexport class FragmentOutputBlock extends NodeMaterialBlock {\n  /**\n   * Create a new FragmentOutputBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Fragment, true);\n    /** Gets or sets a boolean indicating if content needs to be converted to gamma space */\n    this.convertToGammaSpace = false;\n    /** Gets or sets a boolean indicating if content needs to be converted to linear space */\n    this.convertToLinearSpace = false;\n    /** Gets or sets a boolean indicating if logarithmic depth should be used */\n    this.useLogarithmicDepth = false;\n    this.registerInput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, true);\n    this.registerInput(\"rgb\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\n    this.registerInput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, true);\n    this.rgb.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Float);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"FragmentOutputBlock\";\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  initialize(state) {\n    state._excludeVariableName(\"logarithmicDepthConstant\");\n    state._excludeVariableName(\"vFragmentDepth\");\n  }\n  /**\n   * Gets the rgba input component\n   */\n  get rgba() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the rgb input component\n   */\n  get rgb() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the a input component\n   */\n  get a() {\n    return this._inputs[2];\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    defines.setValue(this._linearDefineName, this.convertToLinearSpace, true);\n    defines.setValue(this._gammaDefineName, this.convertToGammaSpace, true);\n  }\n  bind(effect, nodeMaterial, mesh) {\n    if (this.useLogarithmicDepth && mesh) {\n      MaterialHelper.BindLogDepth(undefined, effect, mesh.getScene());\n    }\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    const rgba = this.rgba;\n    const rgb = this.rgb;\n    const a = this.a;\n    state.sharedData.hints.needAlphaBlending = rgba.isConnected || a.isConnected;\n    state.sharedData.blocksWithDefines.push(this);\n    if (this.useLogarithmicDepth) {\n      state._emitUniformFromString(\"logarithmicDepthConstant\", \"float\");\n      state._emitVaryingFromString(\"vFragmentDepth\", \"float\");\n      state.sharedData.bindableBlocks.push(this);\n    }\n    this._linearDefineName = state._getFreeDefineName(\"CONVERTTOLINEAR\");\n    this._gammaDefineName = state._getFreeDefineName(\"CONVERTTOGAMMA\");\n    const comments = `//${this.name}`;\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n    if (rgba.connectedPoint) {\n      if (a.isConnected) {\n        state.compilationString += `gl_FragColor = vec4(${rgba.associatedVariableName}.rgb, ${a.associatedVariableName});\\n`;\n      } else {\n        state.compilationString += `gl_FragColor = ${rgba.associatedVariableName};\\n`;\n      }\n    } else if (rgb.connectedPoint) {\n      let aValue = \"1.0\";\n      if (a.connectedPoint) {\n        aValue = a.associatedVariableName;\n      }\n      if (rgb.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Float) {\n        state.compilationString += `gl_FragColor = vec4(${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${aValue});\\n`;\n      } else {\n        state.compilationString += `gl_FragColor = vec4(${rgb.associatedVariableName}, ${aValue});\\n`;\n      }\n    } else {\n      state.sharedData.checks.notConnectedNonOptionalInputs.push(rgba);\n    }\n    state.compilationString += `#ifdef ${this._linearDefineName}\\n`;\n    state.compilationString += `gl_FragColor = toLinearSpace(gl_FragColor);\\n`;\n    state.compilationString += `#endif\\n`;\n    state.compilationString += `#ifdef ${this._gammaDefineName}\\n`;\n    state.compilationString += `gl_FragColor = toGammaSpace(gl_FragColor);\\n`;\n    state.compilationString += `#endif\\n`;\n    if (this.useLogarithmicDepth) {\n      state.compilationString += `gl_FragDepthEXT = log2(vFragmentDepth) * logarithmicDepthConstant * 0.5;\\n`;\n    }\n    state.compilationString += `#if defined(PREPASS)\\r\\n`;\n    state.compilationString += `gl_FragData[0] = gl_FragColor;\\r\\n`;\n    state.compilationString += `#endif\\r\\n`;\n    return this;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode();\n    codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\\n`;\n    codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\\n`;\n    codeString += `${this._codeVariableName}.useLogarithmicDepth = ${this.useLogarithmicDepth};\\n`;\n    return codeString;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.convertToGammaSpace = this.convertToGammaSpace;\n    serializationObject.convertToLinearSpace = this.convertToLinearSpace;\n    serializationObject.useLogarithmicDepth = this.useLogarithmicDepth;\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    var _a;\n    super._deserialize(serializationObject, scene, rootUrl);\n    this.convertToGammaSpace = serializationObject.convertToGammaSpace;\n    this.convertToLinearSpace = serializationObject.convertToLinearSpace;\n    this.useLogarithmicDepth = (_a = serializationObject.useLogarithmicDepth) !== null && _a !== void 0 ? _a : false;\n  }\n}\n__decorate([editableInPropertyPage(\"Convert to gamma space\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", {\n  notifiers: {\n    update: true\n  }\n})], FragmentOutputBlock.prototype, \"convertToGammaSpace\", void 0);\n__decorate([editableInPropertyPage(\"Convert to linear space\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", {\n  notifiers: {\n    update: true\n  }\n})], FragmentOutputBlock.prototype, \"convertToLinearSpace\", void 0);\n__decorate([editableInPropertyPage(\"Use logarithmic depth\", PropertyTypeForEdition.Boolean, \"PROPERTIES\")], FragmentOutputBlock.prototype, \"useLogarithmicDepth\", void 0);\nRegisterClass(\"BABYLON.FragmentOutputBlock\", FragmentOutputBlock);","map":{"version":3,"names":["NodeMaterialBlock","NodeMaterialBlockConnectionPointTypes","NodeMaterialBlockTargets","RegisterClass","editableInPropertyPage","PropertyTypeForEdition","MaterialHelper","FragmentOutputBlock","constructor","name","Fragment","convertToGammaSpace","convertToLinearSpace","useLogarithmicDepth","registerInput","Color4","AutoDetect","Float","rgb","addExcludedConnectionPointFromAllowedTypes","Color3","Vector3","getClassName","initialize","state","_excludeVariableName","rgba","_inputs","a","prepareDefines","mesh","nodeMaterial","defines","setValue","_linearDefineName","_gammaDefineName","bind","effect","BindLogDepth","undefined","getScene","_buildBlock","sharedData","hints","needAlphaBlending","isConnected","blocksWithDefines","push","_emitUniformFromString","_emitVaryingFromString","bindableBlocks","_getFreeDefineName","comments","_emitFunctionFromInclude","connectedPoint","compilationString","associatedVariableName","aValue","type","checks","notConnectedNonOptionalInputs","_dumpPropertiesCode","codeString","_codeVariableName","serialize","serializationObject","_deserialize","scene","rootUrl","_a","__decorate","Boolean","notifiers","update"],"sources":["../../../../../../../dev/core/src/Materials/Node/Blocks/Fragment/fragmentOutputBlock.ts"],"sourcesContent":["import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterialDefines, NodeMaterial } from \"../../nodeMaterial\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\nimport { MaterialHelper } from \"../../../materialHelper\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\n\r\n/**\r\n * Block used to output the final color\r\n */\r\nexport class FragmentOutputBlock extends NodeMaterialBlock {\r\n    private _linearDefineName: string;\r\n    private _gammaDefineName: string;\r\n\r\n    /**\r\n     * Create a new FragmentOutputBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment, true);\r\n\r\n        this.registerInput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, true);\r\n        this.registerInput(\"rgb\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\r\n        this.registerInput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.rgb.addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Float\r\n        );\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if content needs to be converted to gamma space */\r\n    @editableInPropertyPage(\"Convert to gamma space\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { notifiers: { update: true } })\r\n    public convertToGammaSpace = false;\r\n\r\n    /** Gets or sets a boolean indicating if content needs to be converted to linear space */\r\n    @editableInPropertyPage(\"Convert to linear space\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { notifiers: { update: true } })\r\n    public convertToLinearSpace = false;\r\n\r\n    /** Gets or sets a boolean indicating if logarithmic depth should be used */\r\n    @editableInPropertyPage(\"Use logarithmic depth\", PropertyTypeForEdition.Boolean, \"PROPERTIES\")\r\n    public useLogarithmicDepth = false;\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"FragmentOutputBlock\";\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"logarithmicDepthConstant\");\r\n        state._excludeVariableName(\"vFragmentDepth\");\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba input component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb input component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the a input component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        defines.setValue(this._linearDefineName, this.convertToLinearSpace, true);\r\n        defines.setValue(this._gammaDefineName, this.convertToGammaSpace, true);\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if (this.useLogarithmicDepth && mesh) {\r\n            MaterialHelper.BindLogDepth(undefined, effect, mesh.getScene());\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const rgba = this.rgba;\r\n        const rgb = this.rgb;\r\n        const a = this.a;\r\n\r\n        state.sharedData.hints.needAlphaBlending = rgba.isConnected || a.isConnected;\r\n        state.sharedData.blocksWithDefines.push(this);\r\n        if (this.useLogarithmicDepth) {\r\n            state._emitUniformFromString(\"logarithmicDepthConstant\", \"float\");\r\n            state._emitVaryingFromString(\"vFragmentDepth\", \"float\");\r\n            state.sharedData.bindableBlocks.push(this);\r\n        }\r\n        this._linearDefineName = state._getFreeDefineName(\"CONVERTTOLINEAR\");\r\n        this._gammaDefineName = state._getFreeDefineName(\"CONVERTTOGAMMA\");\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        if (rgba.connectedPoint) {\r\n            if (a.isConnected) {\r\n                state.compilationString += `gl_FragColor = vec4(${rgba.associatedVariableName}.rgb, ${a.associatedVariableName});\\n`;\r\n            } else {\r\n                state.compilationString += `gl_FragColor = ${rgba.associatedVariableName};\\n`;\r\n            }\r\n        } else if (rgb.connectedPoint) {\r\n            let aValue = \"1.0\";\r\n\r\n            if (a.connectedPoint) {\r\n                aValue = a.associatedVariableName;\r\n            }\r\n\r\n            if (rgb.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n                state.compilationString += `gl_FragColor = vec4(${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${aValue});\\n`;\r\n            } else {\r\n                state.compilationString += `gl_FragColor = vec4(${rgb.associatedVariableName}, ${aValue});\\n`;\r\n            }\r\n        } else {\r\n            state.sharedData.checks.notConnectedNonOptionalInputs.push(rgba);\r\n        }\r\n\r\n        state.compilationString += `#ifdef ${this._linearDefineName}\\n`;\r\n        state.compilationString += `gl_FragColor = toLinearSpace(gl_FragColor);\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._gammaDefineName}\\n`;\r\n        state.compilationString += `gl_FragColor = toGammaSpace(gl_FragColor);\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n\r\n        if (this.useLogarithmicDepth) {\r\n            state.compilationString += `gl_FragDepthEXT = log2(vFragmentDepth) * logarithmicDepthConstant * 0.5;\\n`;\r\n        }\r\n\r\n        state.compilationString += `#if defined(PREPASS)\\r\\n`;\r\n        state.compilationString += `gl_FragData[0] = gl_FragColor;\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n        codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\\n`;\r\n        codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\\n`;\r\n        codeString += `${this._codeVariableName}.useLogarithmicDepth = ${this.useLogarithmicDepth};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n        serializationObject.useLogarithmicDepth = this.useLogarithmicDepth;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = serializationObject.convertToLinearSpace;\r\n        this.useLogarithmicDepth = serializationObject.useLogarithmicDepth ?? false;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.FragmentOutputBlock\", FragmentOutputBlock);\r\n"],"mappings":";;AAAA,SAASA,iBAAiB,QAAQ,4BAA0B;AAC5D,SAASC,qCAAqC,QAAQ,sDAAoD;AAE1G,SAASC,wBAAwB,QAAQ,yCAAuC;AAEhF,SAASC,aAAa,QAAQ,+BAA6B;AAI3D,SAASC,sBAAsB,EAAEC,sBAAsB,QAAQ,yCAAuC;AACtG,SAASC,cAAc,QAAQ,4BAA0B;AAIzD;;;AAGA,OAAM,MAAOC,mBAAoB,SAAQP,iBAAiB;EAItD;;;;EAIAQ,YAAmBC,IAAY;IAC3B,KAAK,CAACA,IAAI,EAAEP,wBAAwB,CAACQ,QAAQ,EAAE,IAAI,CAAC;IAUxD;IAEO,KAAAC,mBAAmB,GAAG,KAAK;IAElC;IAEO,KAAAC,oBAAoB,GAAG,KAAK;IAEnC;IAEO,KAAAC,mBAAmB,GAAG,KAAK;IAlB9B,IAAI,CAACC,aAAa,CAAC,MAAM,EAAEb,qCAAqC,CAACc,MAAM,EAAE,IAAI,CAAC;IAC9E,IAAI,CAACD,aAAa,CAAC,KAAK,EAAEb,qCAAqC,CAACe,UAAU,EAAE,IAAI,CAAC;IACjF,IAAI,CAACF,aAAa,CAAC,GAAG,EAAEb,qCAAqC,CAACgB,KAAK,EAAE,IAAI,CAAC;IAC1E,IAAI,CAACC,GAAG,CAACC,0CAA0C,CAC/ClB,qCAAqC,CAACmB,MAAM,GAAGnB,qCAAqC,CAACoB,OAAO,GAAGpB,qCAAqC,CAACgB,KAAK,CAC7I;EACL;EAcA;;;;EAIOK,YAAYA,CAAA;IACf,OAAO,qBAAqB;EAChC;EAEA;;;;EAIOC,UAAUA,CAACC,KAA6B;IAC3CA,KAAK,CAACC,oBAAoB,CAAC,0BAA0B,CAAC;IACtDD,KAAK,CAACC,oBAAoB,CAAC,gBAAgB,CAAC;EAChD;EAEA;;;EAGA,IAAWC,IAAIA,CAAA;IACX,OAAO,IAAI,CAACC,OAAO,CAAC,CAAC,CAAC;EAC1B;EAEA;;;EAGA,IAAWT,GAAGA,CAAA;IACV,OAAO,IAAI,CAACS,OAAO,CAAC,CAAC,CAAC;EAC1B;EAEA;;;EAGA,IAAWC,CAACA,CAAA;IACR,OAAO,IAAI,CAACD,OAAO,CAAC,CAAC,CAAC;EAC1B;EAEOE,cAAcA,CAACC,IAAkB,EAAEC,YAA0B,EAAEC,OAA4B;IAC9FA,OAAO,CAACC,QAAQ,CAAC,IAAI,CAACC,iBAAiB,EAAE,IAAI,CAACtB,oBAAoB,EAAE,IAAI,CAAC;IACzEoB,OAAO,CAACC,QAAQ,CAAC,IAAI,CAACE,gBAAgB,EAAE,IAAI,CAACxB,mBAAmB,EAAE,IAAI,CAAC;EAC3E;EAEOyB,IAAIA,CAACC,MAAc,EAAEN,YAA0B,EAAED,IAAW;IAC/D,IAAI,IAAI,CAACjB,mBAAmB,IAAIiB,IAAI,EAAE;MAClCxB,cAAc,CAACgC,YAAY,CAACC,SAAS,EAAEF,MAAM,EAAEP,IAAI,CAACU,QAAQ,EAAE,CAAC;;EAEvE;EAEUC,WAAWA,CAACjB,KAA6B;IAC/C,KAAK,CAACiB,WAAW,CAACjB,KAAK,CAAC;IAExB,MAAME,IAAI,GAAG,IAAI,CAACA,IAAI;IACtB,MAAMR,GAAG,GAAG,IAAI,CAACA,GAAG;IACpB,MAAMU,CAAC,GAAG,IAAI,CAACA,CAAC;IAEhBJ,KAAK,CAACkB,UAAU,CAACC,KAAK,CAACC,iBAAiB,GAAGlB,IAAI,CAACmB,WAAW,IAAIjB,CAAC,CAACiB,WAAW;IAC5ErB,KAAK,CAACkB,UAAU,CAACI,iBAAiB,CAACC,IAAI,CAAC,IAAI,CAAC;IAC7C,IAAI,IAAI,CAAClC,mBAAmB,EAAE;MAC1BW,KAAK,CAACwB,sBAAsB,CAAC,0BAA0B,EAAE,OAAO,CAAC;MACjExB,KAAK,CAACyB,sBAAsB,CAAC,gBAAgB,EAAE,OAAO,CAAC;MACvDzB,KAAK,CAACkB,UAAU,CAACQ,cAAc,CAACH,IAAI,CAAC,IAAI,CAAC;;IAE9C,IAAI,CAACb,iBAAiB,GAAGV,KAAK,CAAC2B,kBAAkB,CAAC,iBAAiB,CAAC;IACpE,IAAI,CAAChB,gBAAgB,GAAGX,KAAK,CAAC2B,kBAAkB,CAAC,gBAAgB,CAAC;IAElE,MAAMC,QAAQ,GAAG,KAAK,IAAI,CAAC3C,IAAI,EAAE;IACjCe,KAAK,CAAC6B,wBAAwB,CAAC,iBAAiB,EAAED,QAAQ,CAAC;IAE3D,IAAI1B,IAAI,CAAC4B,cAAc,EAAE;MACrB,IAAI1B,CAAC,CAACiB,WAAW,EAAE;QACfrB,KAAK,CAAC+B,iBAAiB,IAAI,uBAAuB7B,IAAI,CAAC8B,sBAAsB,SAAS5B,CAAC,CAAC4B,sBAAsB,MAAM;OACvH,MAAM;QACHhC,KAAK,CAAC+B,iBAAiB,IAAI,kBAAkB7B,IAAI,CAAC8B,sBAAsB,KAAK;;KAEpF,MAAM,IAAItC,GAAG,CAACoC,cAAc,EAAE;MAC3B,IAAIG,MAAM,GAAG,KAAK;MAElB,IAAI7B,CAAC,CAAC0B,cAAc,EAAE;QAClBG,MAAM,GAAG7B,CAAC,CAAC4B,sBAAsB;;MAGrC,IAAItC,GAAG,CAACoC,cAAc,CAACI,IAAI,KAAKzD,qCAAqC,CAACgB,KAAK,EAAE;QACzEO,KAAK,CAAC+B,iBAAiB,IAAI,uBAAuBrC,GAAG,CAACsC,sBAAsB,KAAKtC,GAAG,CAACsC,sBAAsB,KAAKtC,GAAG,CAACsC,sBAAsB,KAAKC,MAAM,MAAM;OAC9J,MAAM;QACHjC,KAAK,CAAC+B,iBAAiB,IAAI,uBAAuBrC,GAAG,CAACsC,sBAAsB,KAAKC,MAAM,MAAM;;KAEpG,MAAM;MACHjC,KAAK,CAACkB,UAAU,CAACiB,MAAM,CAACC,6BAA6B,CAACb,IAAI,CAACrB,IAAI,CAAC;;IAGpEF,KAAK,CAAC+B,iBAAiB,IAAI,UAAU,IAAI,CAACrB,iBAAiB,IAAI;IAC/DV,KAAK,CAAC+B,iBAAiB,IAAI,+CAA+C;IAC1E/B,KAAK,CAAC+B,iBAAiB,IAAI,UAAU;IAErC/B,KAAK,CAAC+B,iBAAiB,IAAI,UAAU,IAAI,CAACpB,gBAAgB,IAAI;IAC9DX,KAAK,CAAC+B,iBAAiB,IAAI,8CAA8C;IACzE/B,KAAK,CAAC+B,iBAAiB,IAAI,UAAU;IAErC,IAAI,IAAI,CAAC1C,mBAAmB,EAAE;MAC1BW,KAAK,CAAC+B,iBAAiB,IAAI,4EAA4E;;IAG3G/B,KAAK,CAAC+B,iBAAiB,IAAI,0BAA0B;IACrD/B,KAAK,CAAC+B,iBAAiB,IAAI,oCAAoC;IAC/D/B,KAAK,CAAC+B,iBAAiB,IAAI,YAAY;IAEvC,OAAO,IAAI;EACf;EAEUM,mBAAmBA,CAAA;IACzB,IAAIC,UAAU,GAAG,KAAK,CAACD,mBAAmB,EAAE;IAC5CC,UAAU,IAAI,GAAG,IAAI,CAACC,iBAAiB,0BAA0B,IAAI,CAACpD,mBAAmB,KAAK;IAC9FmD,UAAU,IAAI,GAAG,IAAI,CAACC,iBAAiB,2BAA2B,IAAI,CAACnD,oBAAoB,KAAK;IAChGkD,UAAU,IAAI,GAAG,IAAI,CAACC,iBAAiB,0BAA0B,IAAI,CAAClD,mBAAmB,KAAK;IAE9F,OAAOiD,UAAU;EACrB;EAEOE,SAASA,CAAA;IACZ,MAAMC,mBAAmB,GAAG,KAAK,CAACD,SAAS,EAAE;IAE7CC,mBAAmB,CAACtD,mBAAmB,GAAG,IAAI,CAACA,mBAAmB;IAClEsD,mBAAmB,CAACrD,oBAAoB,GAAG,IAAI,CAACA,oBAAoB;IACpEqD,mBAAmB,CAACpD,mBAAmB,GAAG,IAAI,CAACA,mBAAmB;IAElE,OAAOoD,mBAAmB;EAC9B;EAEOC,YAAYA,CAACD,mBAAwB,EAAEE,KAAY,EAAEC,OAAe;;IACvE,KAAK,CAACF,YAAY,CAACD,mBAAmB,EAAEE,KAAK,EAAEC,OAAO,CAAC;IAEvD,IAAI,CAACzD,mBAAmB,GAAGsD,mBAAmB,CAACtD,mBAAmB;IAClE,IAAI,CAACC,oBAAoB,GAAGqD,mBAAmB,CAACrD,oBAAoB;IACpE,IAAI,CAACC,mBAAmB,GAAG,CAAAwD,EAAA,GAAAJ,mBAAmB,CAACpD,mBAAmB,cAAAwD,EAAA,cAAAA,EAAA,GAAI,KAAK;EAC/E;;AAjJOC,UAAA,EADNlE,sBAAsB,CAAC,wBAAwB,EAAEC,sBAAsB,CAACkE,OAAO,EAAE,YAAY,EAAE;EAAEC,SAAS,EAAE;IAAEC,MAAM,EAAE;EAAI;AAAE,CAAE,CAAC,C,+DAC7F;AAI5BH,UAAA,EADNlE,sBAAsB,CAAC,yBAAyB,EAAEC,sBAAsB,CAACkE,OAAO,EAAE,YAAY,EAAE;EAAEC,SAAS,EAAE;IAAEC,MAAM,EAAE;EAAI;AAAE,CAAE,CAAC,C,gEAC7F;AAI7BH,UAAA,EADNlE,sBAAsB,CAAC,uBAAuB,EAAEC,sBAAsB,CAACkE,OAAO,EAAE,YAAY,CAAC,C,+DAC3D;AA4IvCpE,aAAa,CAAC,6BAA6B,EAAEI,mBAAmB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}