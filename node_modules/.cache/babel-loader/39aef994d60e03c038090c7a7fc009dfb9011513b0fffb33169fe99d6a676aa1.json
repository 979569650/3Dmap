{"ast":null,"code":"import { __decorate } from \"../../../tslib.es6.js\";\nimport { NodeGeometryBlock } from \"../nodeGeometryBlock.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../Decorators/nodeDecorator.js\";\nimport { Vector2, Vector3 } from \"../../../Maths/math.vector.js\";\n/**\n * Type of mappings supported by the mapping block\n */\nexport var MappingTypes;\n(function (MappingTypes) {\n  /** Spherical */\n  MappingTypes[MappingTypes[\"Spherical\"] = 0] = \"Spherical\";\n  /** Cylindrical */\n  MappingTypes[MappingTypes[\"Cylindrical\"] = 1] = \"Cylindrical\";\n  /** Cubic */\n  MappingTypes[MappingTypes[\"Cubic\"] = 2] = \"Cubic\";\n})(MappingTypes || (MappingTypes = {}));\n/**\n * Block used to generate UV coordinates\n */\nexport class MappingBlock extends NodeGeometryBlock {\n  /**\n   * Create a new MappingBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    /**\n     * Gets or sets the mapping type used by the block\n     */\n    this.mapping = MappingTypes.Spherical;\n    this.registerInput(\"position\", NodeGeometryBlockConnectionPointTypes.Vector3);\n    this.registerInput(\"normal\", NodeGeometryBlockConnectionPointTypes.Vector3);\n    this.registerInput(\"center\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());\n    this.registerOutput(\"uv\", NodeGeometryBlockConnectionPointTypes.Vector2);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"MappingBlock\";\n  }\n  /**\n   * Gets the position input component\n   */\n  get position() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the normal input component\n   */\n  get normal() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the center input component\n   */\n  get center() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the output component\n   */\n  get uv() {\n    return this._outputs[0];\n  }\n  _buildBlock() {\n    if (!this.position.isConnected) {\n      this.uv._storedFunction = null;\n      this.uv._storedValue = null;\n      return;\n    }\n    const tempDirection = Vector3.Zero();\n    const func = state => {\n      const position = this.position.getConnectedValue(state) || Vector3.Zero();\n      const normal = this.normal.getConnectedValue(state) || Vector3.Zero();\n      const center = this.center.getConnectedValue(state);\n      const uv = Vector2.Zero();\n      switch (this.mapping) {\n        case MappingTypes.Spherical:\n          {\n            position.subtractToRef(center, tempDirection);\n            const len = tempDirection.length();\n            if (len > 0) {\n              uv.x = Math.acos(tempDirection.y / len) / Math.PI;\n              if (tempDirection.x !== 0 || tempDirection.z !== 0) {\n                uv.y = Math.atan2(tempDirection.x, tempDirection.z) / (Math.PI * 2);\n              }\n            }\n            break;\n          }\n        case MappingTypes.Cylindrical:\n          {\n            position.subtractToRef(center, tempDirection);\n            const len = tempDirection.length();\n            if (len > 0) {\n              uv.x = Math.atan2(tempDirection.x / len, tempDirection.z / len) / (Math.PI * 2);\n              uv.y = (tempDirection.y + 1.0) / 2.0;\n            }\n            break;\n          }\n        case MappingTypes.Cubic:\n          {\n            // Find the largest component of the normal vector\n            const absX = Math.abs(normal.x);\n            const absY = Math.abs(normal.y);\n            const absZ = Math.abs(normal.z);\n            const maxDim = Math.max(Math.abs(position.x), Math.abs(position.y), Math.abs(position.z));\n            let u = 0,\n              v = 0;\n            if (absX >= absY && absX >= absZ) {\n              u = position.y / maxDim - center.y;\n              v = position.z / maxDim - center.z;\n            } else if (absY >= absX && absY >= absZ) {\n              u = position.x / maxDim - center.x;\n              v = position.z / maxDim - center.z;\n            } else {\n              u = position.x / maxDim - center.x;\n              v = position.y / maxDim - center.y;\n            }\n            uv.x = (u + 1) / 2;\n            uv.y = (v + 1) / 2;\n          }\n      }\n      return uv;\n    };\n    this.uv._storedFunction = state => {\n      return func(state);\n    };\n  }\n  _dumpPropertiesCode() {\n    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.mapping = BABYLON.MappingTypes.${MappingTypes[this.mapping]};\\n`;\n    return codeString;\n  }\n  /**\n   * Serializes this block in a JSON representation\n   * @returns the serialized block object\n   */\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.mapping = this.mapping;\n    return serializationObject;\n  }\n  _deserialize(serializationObject) {\n    super._deserialize(serializationObject);\n    this.mapping = serializationObject.mapping;\n  }\n}\n__decorate([editableInPropertyPage(\"Mapping\", PropertyTypeForEdition.List, \"ADVANCED\", {\n  notifiers: {\n    rebuild: true\n  },\n  options: [{\n    label: \"Spherical\",\n    value: MappingTypes.Spherical\n  }, {\n    label: \"Cylindrical\",\n    value: MappingTypes.Cylindrical\n  }, {\n    label: \"Cubic\",\n    value: MappingTypes.Cubic\n  }]\n})], MappingBlock.prototype, \"mapping\", void 0);\nRegisterClass(\"BABYLON.MappingBlock\", MappingBlock);","map":{"version":3,"names":["NodeGeometryBlock","RegisterClass","NodeGeometryBlockConnectionPointTypes","PropertyTypeForEdition","editableInPropertyPage","Vector2","Vector3","MappingTypes","MappingBlock","constructor","name","mapping","Spherical","registerInput","Zero","registerOutput","getClassName","position","_inputs","normal","center","uv","_outputs","_buildBlock","isConnected","_storedFunction","_storedValue","tempDirection","func","state","getConnectedValue","subtractToRef","len","length","x","Math","acos","y","PI","z","atan2","Cylindrical","Cubic","absX","abs","absY","absZ","maxDim","max","u","v","_dumpPropertiesCode","codeString","_codeVariableName","serialize","serializationObject","_deserialize","__decorate","List","notifiers","rebuild","options","label","value"],"sources":["../../../../../../dev/core/src/Meshes/Node/Blocks/mappingBlock.ts"],"sourcesContent":["import { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../nodeGeometryBuildState\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../Decorators/nodeDecorator\";\r\nimport { Vector2, Vector3 } from \"../../../Maths/math.vector\";\r\n\r\n/**\r\n * Type of mappings supported by the mapping block\r\n */\r\nexport enum MappingTypes {\r\n    /** Spherical */\r\n    Spherical,\r\n    /** Cylindrical */\r\n    Cylindrical,\r\n    /** Cubic */\r\n    Cubic,\r\n}\r\n\r\n/**\r\n * Block used to generate UV coordinates\r\n */\r\nexport class MappingBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Gets or sets the mapping type used by the block\r\n     */\r\n    @editableInPropertyPage(\"Mapping\", PropertyTypeForEdition.List, \"ADVANCED\", {\r\n        notifiers: { rebuild: true },\r\n        options: [\r\n            { label: \"Spherical\", value: MappingTypes.Spherical },\r\n            { label: \"Cylindrical\", value: MappingTypes.Cylindrical },\r\n            { label: \"Cubic\", value: MappingTypes.Cubic },\r\n        ],\r\n    })\r\n    public mapping = MappingTypes.Spherical;\r\n\r\n    /**\r\n     * Create a new MappingBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"position\", NodeGeometryBlockConnectionPointTypes.Vector3);\r\n        this.registerInput(\"normal\", NodeGeometryBlockConnectionPointTypes.Vector3);\r\n        this.registerInput(\"center\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());\r\n        this.registerOutput(\"uv\", NodeGeometryBlockConnectionPointTypes.Vector2);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"MappingBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the position input component\r\n     */\r\n    public get position(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the normal input component\r\n     */\r\n    public get normal(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the center input component\r\n     */\r\n    public get center(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get uv(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock() {\r\n        if (!this.position.isConnected) {\r\n            this.uv._storedFunction = null;\r\n            this.uv._storedValue = null;\r\n            return;\r\n        }\r\n        const tempDirection = Vector3.Zero();\r\n\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            const position = (this.position.getConnectedValue(state) as Vector3) || Vector3.Zero();\r\n            const normal = (this.normal.getConnectedValue(state) as Vector3) || Vector3.Zero();\r\n            const center = this.center.getConnectedValue(state) as Vector3;\r\n            const uv = Vector2.Zero();\r\n\r\n            switch (this.mapping) {\r\n                case MappingTypes.Spherical: {\r\n                    position.subtractToRef(center, tempDirection);\r\n                    const len = tempDirection.length();\r\n                    if (len > 0) {\r\n                        uv.x = Math.acos(tempDirection.y / len) / Math.PI;\r\n                        if (tempDirection.x !== 0 || tempDirection.z !== 0) {\r\n                            uv.y = Math.atan2(tempDirection.x, tempDirection.z) / (Math.PI * 2);\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case MappingTypes.Cylindrical: {\r\n                    position.subtractToRef(center, tempDirection);\r\n                    const len = tempDirection.length();\r\n                    if (len > 0) {\r\n                        uv.x = Math.atan2(tempDirection.x / len, tempDirection.z / len) / (Math.PI * 2);\r\n                        uv.y = (tempDirection.y + 1.0) / 2.0;\r\n                    }\r\n                    break;\r\n                }\r\n                case MappingTypes.Cubic: {\r\n                    // Find the largest component of the normal vector\r\n                    const absX = Math.abs(normal.x);\r\n                    const absY = Math.abs(normal.y);\r\n                    const absZ = Math.abs(normal.z);\r\n                    const maxDim = Math.max(Math.abs(position.x), Math.abs(position.y), Math.abs(position.z));\r\n\r\n                    let u = 0,\r\n                        v = 0;\r\n\r\n                    if (absX >= absY && absX >= absZ) {\r\n                        u = position.y / maxDim - center.y;\r\n                        v = position.z / maxDim - center.z;\r\n                    } else if (absY >= absX && absY >= absZ) {\r\n                        u = position.x / maxDim - center.x;\r\n                        v = position.z / maxDim - center.z;\r\n                    } else {\r\n                        u = position.x / maxDim - center.x;\r\n                        v = position.y / maxDim - center.y;\r\n                    }\r\n\r\n                    uv.x = (u + 1) / 2;\r\n                    uv.y = (v + 1) / 2;\r\n                }\r\n            }\r\n            return uv;\r\n        };\r\n\r\n        this.uv._storedFunction = (state) => {\r\n            return func(state);\r\n        };\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.mapping = BABYLON.MappingTypes.${MappingTypes[this.mapping]};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.mapping = this.mapping;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.mapping = serializationObject.mapping;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MappingBlock\", MappingBlock);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}