{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { SceneLoader } from \"../Loading/sceneLoader.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { FilesInputStore } from \"./filesInputStore.js\";\n/**\n * Class used to help managing file picking and drag-n-drop\n */\nexport class FilesInput {\n  /**\n   * List of files ready to be loaded\n   */\n  static get FilesToLoad() {\n    return FilesInputStore.FilesToLoad;\n  }\n  /**\n   * Creates a new FilesInput\n   * @param engine defines the rendering engine\n   * @param scene defines the hosting scene\n   * @param sceneLoadedCallback callback called when scene (files provided) is loaded\n   * @param progressCallback callback called to track progress\n   * @param additionalRenderLoopLogicCallback callback called to add user logic to the rendering loop\n   * @param textureLoadingCallback callback called when a texture is loading\n   * @param startingProcessingFilesCallback callback called when the system is about to process all files\n   * @param onReloadCallback callback called when a reload is requested\n   * @param errorCallback callback call if an error occurs\n   * @param useAppend defines if the file loaded must be appended (true) or have the scene replaced (false, default behavior)\n   */\n  constructor(engine, scene, sceneLoadedCallback, progressCallback, additionalRenderLoopLogicCallback, textureLoadingCallback, startingProcessingFilesCallback, onReloadCallback, errorCallback, useAppend = false) {\n    this.useAppend = useAppend;\n    /**\n     * Callback called when a file is processed\n     */\n    this.onProcessFileCallback = () => {\n      return true;\n    };\n    this.displayLoadingUI = true;\n    /**\n     * Function used when loading the scene file\n     * @param sceneFile\n     * @param onProgress\n     */\n    this.loadAsync = (sceneFile, onProgress) => this.useAppend ? SceneLoader.AppendAsync(\"file:\", sceneFile, this._currentScene, onProgress) : SceneLoader.LoadAsync(\"file:\", sceneFile, this._engine, onProgress);\n    this._engine = engine;\n    this._currentScene = scene;\n    this._sceneLoadedCallback = sceneLoadedCallback;\n    this._progressCallback = progressCallback;\n    this._additionalRenderLoopLogicCallback = additionalRenderLoopLogicCallback;\n    this._textureLoadingCallback = textureLoadingCallback;\n    this._startingProcessingFilesCallback = startingProcessingFilesCallback;\n    this._onReloadCallback = onReloadCallback;\n    this._errorCallback = errorCallback;\n  }\n  /**\n   * Calls this function to listen to drag'n'drop events on a specific DOM element\n   * @param elementToMonitor defines the DOM element to track\n   */\n  monitorElementForDragNDrop(elementToMonitor) {\n    if (elementToMonitor) {\n      this._elementToMonitor = elementToMonitor;\n      this._dragEnterHandler = e => {\n        this._drag(e);\n      };\n      this._dragOverHandler = e => {\n        this._drag(e);\n      };\n      this._dropHandler = e => {\n        this._drop(e);\n      };\n      this._elementToMonitor.addEventListener(\"dragenter\", this._dragEnterHandler, false);\n      this._elementToMonitor.addEventListener(\"dragover\", this._dragOverHandler, false);\n      this._elementToMonitor.addEventListener(\"drop\", this._dropHandler, false);\n    }\n  }\n  /** Gets the current list of files to load */\n  get filesToLoad() {\n    return this._filesToLoad;\n  }\n  /**\n   * Release all associated resources\n   */\n  dispose() {\n    if (!this._elementToMonitor) {\n      return;\n    }\n    this._elementToMonitor.removeEventListener(\"dragenter\", this._dragEnterHandler);\n    this._elementToMonitor.removeEventListener(\"dragover\", this._dragOverHandler);\n    this._elementToMonitor.removeEventListener(\"drop\", this._dropHandler);\n  }\n  _renderFunction() {\n    if (this._additionalRenderLoopLogicCallback) {\n      this._additionalRenderLoopLogicCallback();\n    }\n    if (this._currentScene) {\n      if (this._textureLoadingCallback) {\n        const remaining = this._currentScene.getWaitingItemsCount();\n        if (remaining > 0) {\n          this._textureLoadingCallback(remaining);\n        }\n      }\n      this._currentScene.render();\n    }\n  }\n  _drag(e) {\n    e.stopPropagation();\n    e.preventDefault();\n  }\n  _drop(eventDrop) {\n    eventDrop.stopPropagation();\n    eventDrop.preventDefault();\n    this.loadFiles(eventDrop);\n  }\n  _traverseFolder(folder, files, remaining, callback) {\n    const reader = folder.createReader();\n    const relativePath = folder.fullPath.replace(/^\\//, \"\").replace(/(.+?)\\/?$/, \"$1/\");\n    reader.readEntries(entries => {\n      remaining.count += entries.length;\n      for (const entry of entries) {\n        if (entry.isFile) {\n          entry.file(file => {\n            file.correctName = relativePath + file.name;\n            files.push(file);\n            if (--remaining.count === 0) {\n              callback();\n            }\n          });\n        } else if (entry.isDirectory) {\n          this._traverseFolder(entry, files, remaining, callback);\n        }\n      }\n      if (--remaining.count === 0) {\n        callback();\n      }\n    });\n  }\n  _processFiles(files) {\n    for (let i = 0; i < files.length; i++) {\n      const name = files[i].correctName.toLowerCase();\n      const extension = name.split(\".\").pop();\n      if (!this.onProcessFileCallback(files[i], name, extension, sceneFile => this._sceneFileToLoad = sceneFile)) {\n        continue;\n      }\n      if (SceneLoader.IsPluginForExtensionAvailable(\".\" + extension)) {\n        this._sceneFileToLoad = files[i];\n      }\n      FilesInput.FilesToLoad[name] = files[i];\n    }\n  }\n  /**\n   * Load files from a drop event\n   * @param event defines the drop event to use as source\n   */\n  loadFiles(event) {\n    // Handling data transfer via drag'n'drop\n    if (event && event.dataTransfer && event.dataTransfer.files) {\n      this._filesToLoad = event.dataTransfer.files;\n    }\n    // Handling files from input files\n    if (event && event.target && event.target.files) {\n      this._filesToLoad = event.target.files;\n    }\n    if (!this._filesToLoad || this._filesToLoad.length === 0) {\n      return;\n    }\n    if (this._startingProcessingFilesCallback) {\n      this._startingProcessingFilesCallback(this._filesToLoad);\n    }\n    if (this._filesToLoad && this._filesToLoad.length > 0) {\n      const files = new Array();\n      const folders = [];\n      const items = event.dataTransfer ? event.dataTransfer.items : null;\n      for (let i = 0; i < this._filesToLoad.length; i++) {\n        const fileToLoad = this._filesToLoad[i];\n        const name = fileToLoad.name.toLowerCase();\n        let entry;\n        fileToLoad.correctName = name;\n        if (items) {\n          const item = items[i];\n          if (item.getAsEntry) {\n            entry = item.getAsEntry();\n          } else if (item.webkitGetAsEntry) {\n            entry = item.webkitGetAsEntry();\n          }\n        }\n        if (!entry) {\n          files.push(fileToLoad);\n        } else {\n          if (entry.isDirectory) {\n            folders.push(entry);\n          } else {\n            files.push(fileToLoad);\n          }\n        }\n      }\n      if (folders.length === 0) {\n        this._processFiles(files);\n        this._processReload();\n      } else {\n        const remaining = {\n          count: folders.length\n        };\n        for (const folder of folders) {\n          this._traverseFolder(folder, files, remaining, () => {\n            this._processFiles(files);\n            if (remaining.count === 0) {\n              this._processReload();\n            }\n          });\n        }\n      }\n    }\n  }\n  _processReload() {\n    if (this._onReloadCallback) {\n      this._onReloadCallback(this._sceneFileToLoad);\n    } else {\n      this.reload();\n    }\n  }\n  /**\n   * Reload the current scene from the loaded files\n   */\n  reload() {\n    // If a scene file has been provided\n    if (this._sceneFileToLoad) {\n      if (!this.useAppend) {\n        if (this._currentScene) {\n          if (Logger.errorsCount > 0) {\n            Logger.ClearLogCache();\n          }\n          this._engine.stopRenderLoop();\n        }\n      }\n      SceneLoader.ShowLoadingScreen = false;\n      if (this.displayLoadingUI) {\n        this._engine.displayLoadingUI();\n      }\n      this.loadAsync(this._sceneFileToLoad, this._progressCallback).then(scene => {\n        // if appending do nothing\n        if (!this.useAppend) {\n          if (this._currentScene) {\n            this._currentScene.dispose();\n          }\n          this._currentScene = scene;\n          // Wait for textures and shaders to be ready\n          this._currentScene.executeWhenReady(() => {\n            if (this.displayLoadingUI) {\n              this._engine.hideLoadingUI();\n            }\n            this._engine.runRenderLoop(() => {\n              this._renderFunction();\n            });\n          });\n        } else {\n          if (this.displayLoadingUI) {\n            this._engine.hideLoadingUI();\n          }\n        }\n        if (this._sceneLoadedCallback && this._currentScene) {\n          this._sceneLoadedCallback(this._sceneFileToLoad, this._currentScene);\n        }\n      }).catch(error => {\n        if (this.displayLoadingUI) {\n          this._engine.hideLoadingUI();\n        }\n        if (this._errorCallback) {\n          this._errorCallback(this._sceneFileToLoad, this._currentScene, error.message);\n        }\n      });\n    } else {\n      Logger.Error(\"Please provide a valid .babylon file.\");\n    }\n  }\n}","map":{"version":3,"names":["SceneLoader","Logger","FilesInputStore","FilesInput","FilesToLoad","constructor","engine","scene","sceneLoadedCallback","progressCallback","additionalRenderLoopLogicCallback","textureLoadingCallback","startingProcessingFilesCallback","onReloadCallback","errorCallback","useAppend","onProcessFileCallback","displayLoadingUI","loadAsync","sceneFile","onProgress","AppendAsync","_currentScene","LoadAsync","_engine","_sceneLoadedCallback","_progressCallback","_additionalRenderLoopLogicCallback","_textureLoadingCallback","_startingProcessingFilesCallback","_onReloadCallback","_errorCallback","monitorElementForDragNDrop","elementToMonitor","_elementToMonitor","_dragEnterHandler","e","_drag","_dragOverHandler","_dropHandler","_drop","addEventListener","filesToLoad","_filesToLoad","dispose","removeEventListener","_renderFunction","remaining","getWaitingItemsCount","render","stopPropagation","preventDefault","eventDrop","loadFiles","_traverseFolder","folder","files","callback","reader","createReader","relativePath","fullPath","replace","readEntries","entries","count","length","entry","isFile","file","correctName","name","push","isDirectory","_processFiles","i","toLowerCase","extension","split","pop","_sceneFileToLoad","IsPluginForExtensionAvailable","event","dataTransfer","target","Array","folders","items","fileToLoad","item","getAsEntry","webkitGetAsEntry","_processReload","reload","errorsCount","ClearLogCache","stopRenderLoop","ShowLoadingScreen","then","executeWhenReady","hideLoadingUI","runRenderLoop","catch","error","message","Error"],"sources":["../../../../dev/core/src/Misc/filesInput.ts"],"sourcesContent":["import type { Engine } from \"../Engines/engine\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { ISceneLoaderProgressEvent } from \"../Loading/sceneLoader\";\r\nimport { SceneLoader } from \"../Loading/sceneLoader\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { FilesInputStore } from \"./filesInputStore\";\r\nimport type { Nullable } from \"../types\";\r\n\r\n/**\r\n * Class used to help managing file picking and drag-n-drop\r\n */\r\nexport class FilesInput {\r\n    /**\r\n     * List of files ready to be loaded\r\n     */\r\n    public static get FilesToLoad() {\r\n        return FilesInputStore.FilesToLoad;\r\n    }\r\n\r\n    /**\r\n     * Callback called when a file is processed\r\n     */\r\n    public onProcessFileCallback: (file: File, name: string, extension: string, setSceneFileToLoad: (sceneFile: File) => void) => boolean = () => {\r\n        return true;\r\n    };\r\n\r\n    public displayLoadingUI: boolean = true;\r\n\r\n    /**\r\n     * Function used when loading the scene file\r\n     * @param sceneFile\r\n     * @param onProgress\r\n     */\r\n    public loadAsync: (sceneFile: File, onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void>) => Promise<Scene> = (sceneFile, onProgress) =>\r\n        this.useAppend ? SceneLoader.AppendAsync(\"file:\", sceneFile, this._currentScene, onProgress) : SceneLoader.LoadAsync(\"file:\", sceneFile, this._engine, onProgress);\r\n\r\n    private _engine: Engine;\r\n    private _currentScene: Nullable<Scene>;\r\n    private _sceneLoadedCallback: Nullable<(sceneFile: File, scene: Scene) => void>;\r\n    private _progressCallback: Nullable<(progress: ISceneLoaderProgressEvent) => void>;\r\n    private _additionalRenderLoopLogicCallback: Nullable<() => void>;\r\n    private _textureLoadingCallback: Nullable<(remaining: number) => void>;\r\n    private _startingProcessingFilesCallback: Nullable<(files?: File[]) => void>;\r\n    private _onReloadCallback: Nullable<(sceneFile: File) => void>;\r\n    private _errorCallback: Nullable<(sceneFile: File, scene: Nullable<Scene>, message: string) => void>;\r\n    private _elementToMonitor: HTMLElement;\r\n\r\n    private _sceneFileToLoad: File;\r\n    private _filesToLoad: File[];\r\n\r\n    /**\r\n     * Creates a new FilesInput\r\n     * @param engine defines the rendering engine\r\n     * @param scene defines the hosting scene\r\n     * @param sceneLoadedCallback callback called when scene (files provided) is loaded\r\n     * @param progressCallback callback called to track progress\r\n     * @param additionalRenderLoopLogicCallback callback called to add user logic to the rendering loop\r\n     * @param textureLoadingCallback callback called when a texture is loading\r\n     * @param startingProcessingFilesCallback callback called when the system is about to process all files\r\n     * @param onReloadCallback callback called when a reload is requested\r\n     * @param errorCallback callback call if an error occurs\r\n     * @param useAppend defines if the file loaded must be appended (true) or have the scene replaced (false, default behavior)\r\n     */\r\n    constructor(\r\n        engine: Engine,\r\n        scene: Nullable<Scene>,\r\n        sceneLoadedCallback: Nullable<(sceneFile: File, scene: Scene) => void>,\r\n        progressCallback: Nullable<(progress: ISceneLoaderProgressEvent) => void>,\r\n        additionalRenderLoopLogicCallback: Nullable<() => void>,\r\n        textureLoadingCallback: Nullable<(remaining: number) => void>,\r\n        startingProcessingFilesCallback: Nullable<(files?: File[]) => void>,\r\n        onReloadCallback: Nullable<(sceneFile: File) => void>,\r\n        errorCallback: Nullable<(sceneFile: File, scene: Nullable<Scene>, message: string) => void>,\r\n        public readonly useAppend = false\r\n    ) {\r\n        this._engine = engine;\r\n        this._currentScene = scene;\r\n\r\n        this._sceneLoadedCallback = sceneLoadedCallback;\r\n        this._progressCallback = progressCallback;\r\n        this._additionalRenderLoopLogicCallback = additionalRenderLoopLogicCallback;\r\n        this._textureLoadingCallback = textureLoadingCallback;\r\n        this._startingProcessingFilesCallback = startingProcessingFilesCallback;\r\n        this._onReloadCallback = onReloadCallback;\r\n        this._errorCallback = errorCallback;\r\n    }\r\n\r\n    private _dragEnterHandler: (e: any) => void;\r\n    private _dragOverHandler: (e: any) => void;\r\n    private _dropHandler: (e: any) => void;\r\n\r\n    /**\r\n     * Calls this function to listen to drag'n'drop events on a specific DOM element\r\n     * @param elementToMonitor defines the DOM element to track\r\n     */\r\n    public monitorElementForDragNDrop(elementToMonitor: HTMLElement): void {\r\n        if (elementToMonitor) {\r\n            this._elementToMonitor = elementToMonitor;\r\n\r\n            this._dragEnterHandler = (e) => {\r\n                this._drag(e);\r\n            };\r\n            this._dragOverHandler = (e) => {\r\n                this._drag(e);\r\n            };\r\n            this._dropHandler = (e) => {\r\n                this._drop(e);\r\n            };\r\n\r\n            this._elementToMonitor.addEventListener(\"dragenter\", this._dragEnterHandler, false);\r\n            this._elementToMonitor.addEventListener(\"dragover\", this._dragOverHandler, false);\r\n            this._elementToMonitor.addEventListener(\"drop\", this._dropHandler, false);\r\n        }\r\n    }\r\n\r\n    /** Gets the current list of files to load */\r\n    public get filesToLoad() {\r\n        return this._filesToLoad;\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources\r\n     */\r\n    public dispose() {\r\n        if (!this._elementToMonitor) {\r\n            return;\r\n        }\r\n\r\n        this._elementToMonitor.removeEventListener(\"dragenter\", this._dragEnterHandler);\r\n        this._elementToMonitor.removeEventListener(\"dragover\", this._dragOverHandler);\r\n        this._elementToMonitor.removeEventListener(\"drop\", this._dropHandler);\r\n    }\r\n\r\n    private _renderFunction(): void {\r\n        if (this._additionalRenderLoopLogicCallback) {\r\n            this._additionalRenderLoopLogicCallback();\r\n        }\r\n\r\n        if (this._currentScene) {\r\n            if (this._textureLoadingCallback) {\r\n                const remaining = this._currentScene.getWaitingItemsCount();\r\n\r\n                if (remaining > 0) {\r\n                    this._textureLoadingCallback(remaining);\r\n                }\r\n            }\r\n            this._currentScene.render();\r\n        }\r\n    }\r\n\r\n    private _drag(e: DragEvent): void {\r\n        e.stopPropagation();\r\n        e.preventDefault();\r\n    }\r\n\r\n    private _drop(eventDrop: DragEvent): void {\r\n        eventDrop.stopPropagation();\r\n        eventDrop.preventDefault();\r\n\r\n        this.loadFiles(eventDrop);\r\n    }\r\n\r\n    private _traverseFolder(folder: any, files: Array<any>, remaining: { count: number }, callback: () => void) {\r\n        const reader = folder.createReader();\r\n        const relativePath = folder.fullPath.replace(/^\\//, \"\").replace(/(.+?)\\/?$/, \"$1/\");\r\n        reader.readEntries((entries: any) => {\r\n            remaining.count += entries.length;\r\n            for (const entry of entries) {\r\n                if (entry.isFile) {\r\n                    entry.file((file: any) => {\r\n                        file.correctName = relativePath + file.name;\r\n                        files.push(file);\r\n\r\n                        if (--remaining.count === 0) {\r\n                            callback();\r\n                        }\r\n                    });\r\n                } else if (entry.isDirectory) {\r\n                    this._traverseFolder(entry, files, remaining, callback);\r\n                }\r\n            }\r\n\r\n            if (--remaining.count === 0) {\r\n                callback();\r\n            }\r\n        });\r\n    }\r\n\r\n    private _processFiles(files: Array<any>): void {\r\n        for (let i = 0; i < files.length; i++) {\r\n            const name = files[i].correctName.toLowerCase();\r\n            const extension = name.split(\".\").pop();\r\n\r\n            if (!this.onProcessFileCallback(files[i], name, extension, (sceneFile) => (this._sceneFileToLoad = sceneFile))) {\r\n                continue;\r\n            }\r\n\r\n            if (SceneLoader.IsPluginForExtensionAvailable(\".\" + extension)) {\r\n                this._sceneFileToLoad = files[i];\r\n            }\r\n\r\n            FilesInput.FilesToLoad[name] = files[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load files from a drop event\r\n     * @param event defines the drop event to use as source\r\n     */\r\n    public loadFiles(event: any): void {\r\n        // Handling data transfer via drag'n'drop\r\n        if (event && event.dataTransfer && event.dataTransfer.files) {\r\n            this._filesToLoad = event.dataTransfer.files;\r\n        }\r\n\r\n        // Handling files from input files\r\n        if (event && event.target && event.target.files) {\r\n            this._filesToLoad = event.target.files;\r\n        }\r\n\r\n        if (!this._filesToLoad || this._filesToLoad.length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (this._startingProcessingFilesCallback) {\r\n            this._startingProcessingFilesCallback(this._filesToLoad);\r\n        }\r\n\r\n        if (this._filesToLoad && this._filesToLoad.length > 0) {\r\n            const files = new Array<File>();\r\n            const folders = [];\r\n            const items = event.dataTransfer ? event.dataTransfer.items : null;\r\n\r\n            for (let i = 0; i < this._filesToLoad.length; i++) {\r\n                const fileToLoad: any = this._filesToLoad[i];\r\n                const name = fileToLoad.name.toLowerCase();\r\n                let entry;\r\n\r\n                fileToLoad.correctName = name;\r\n\r\n                if (items) {\r\n                    const item = items[i];\r\n                    if (item.getAsEntry) {\r\n                        entry = item.getAsEntry();\r\n                    } else if (item.webkitGetAsEntry) {\r\n                        entry = item.webkitGetAsEntry();\r\n                    }\r\n                }\r\n\r\n                if (!entry) {\r\n                    files.push(fileToLoad);\r\n                } else {\r\n                    if (entry.isDirectory) {\r\n                        folders.push(entry);\r\n                    } else {\r\n                        files.push(fileToLoad);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (folders.length === 0) {\r\n                this._processFiles(files);\r\n                this._processReload();\r\n            } else {\r\n                const remaining = { count: folders.length };\r\n                for (const folder of folders) {\r\n                    this._traverseFolder(folder, files, remaining, () => {\r\n                        this._processFiles(files);\r\n\r\n                        if (remaining.count === 0) {\r\n                            this._processReload();\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _processReload() {\r\n        if (this._onReloadCallback) {\r\n            this._onReloadCallback(this._sceneFileToLoad);\r\n        } else {\r\n            this.reload();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reload the current scene from the loaded files\r\n     */\r\n    public reload() {\r\n        // If a scene file has been provided\r\n        if (this._sceneFileToLoad) {\r\n            if (!this.useAppend) {\r\n                if (this._currentScene) {\r\n                    if (Logger.errorsCount > 0) {\r\n                        Logger.ClearLogCache();\r\n                    }\r\n                    this._engine.stopRenderLoop();\r\n                }\r\n            }\r\n\r\n            SceneLoader.ShowLoadingScreen = false;\r\n            if (this.displayLoadingUI) {\r\n                this._engine.displayLoadingUI();\r\n            }\r\n\r\n            this.loadAsync(this._sceneFileToLoad, this._progressCallback)\r\n                .then((scene) => {\r\n                    // if appending do nothing\r\n                    if (!this.useAppend) {\r\n                        if (this._currentScene) {\r\n                            this._currentScene.dispose();\r\n                        }\r\n\r\n                        this._currentScene = scene;\r\n\r\n                        // Wait for textures and shaders to be ready\r\n                        this._currentScene.executeWhenReady(() => {\r\n                            if (this.displayLoadingUI) {\r\n                                this._engine.hideLoadingUI();\r\n                            }\r\n                            this._engine.runRenderLoop(() => {\r\n                                this._renderFunction();\r\n                            });\r\n                        });\r\n                    } else {\r\n                        if (this.displayLoadingUI) {\r\n                            this._engine.hideLoadingUI();\r\n                        }\r\n                    }\r\n                    if (this._sceneLoadedCallback && this._currentScene) {\r\n                        this._sceneLoadedCallback(this._sceneFileToLoad, this._currentScene);\r\n                    }\r\n                })\r\n                .catch((error) => {\r\n                    if (this.displayLoadingUI) {\r\n                        this._engine.hideLoadingUI();\r\n                    }\r\n                    if (this._errorCallback) {\r\n                        this._errorCallback(this._sceneFileToLoad, this._currentScene, error.message);\r\n                    }\r\n                });\r\n        } else {\r\n            Logger.Error(\"Please provide a valid .babylon file.\");\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}