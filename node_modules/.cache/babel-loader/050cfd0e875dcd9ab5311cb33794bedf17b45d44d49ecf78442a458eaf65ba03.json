{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { VertexData } from \"../../Meshes/mesh.vertexData.js\";\nimport { Mesh } from \"../../Meshes/mesh.js\";\nimport { Epsilon, Vector3, Matrix } from \"../../Maths/math.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\n/**\n * RecastJS navigation plugin\n */\nexport class RecastJSPlugin {\n  /**\n   * Initializes the recastJS plugin\n   * @param recastInjection can be used to inject your own recast reference\n   */\n  constructor(recastInjection = Recast) {\n    /**\n     * Reference to the Recast library\n     */\n    this.bjsRECAST = {};\n    /**\n     * plugin name\n     */\n    this.name = \"RecastJSPlugin\";\n    this._maximumSubStepCount = 10;\n    this._timeStep = 1 / 60;\n    this._timeFactor = 1;\n    this._worker = null;\n    if (typeof recastInjection === \"function\") {\n      Logger.Error(\"RecastJS is not ready. Please make sure you await Recast() before using the plugin.\");\n    } else {\n      this.bjsRECAST = recastInjection;\n    }\n    if (!this.isSupported()) {\n      Logger.Error(\"RecastJS is not available. Please make sure you included the js file.\");\n      return;\n    }\n    this.setTimeStep();\n    this._tempVec1 = new this.bjsRECAST.Vec3();\n    this._tempVec2 = new this.bjsRECAST.Vec3();\n  }\n  /**\n   * Set worker URL to be used when generating a new navmesh\n   * @param workerURL url string\n   * @returns boolean indicating if worker is created\n   */\n  setWorkerURL(workerURL) {\n    if (window && window.Worker) {\n      this._worker = new Worker(workerURL);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Set the time step of the navigation tick update.\n   * Default is 1/60.\n   * A value of 0 will disable fixed time update\n   * @param newTimeStep the new timestep to apply to this world.\n   */\n  setTimeStep(newTimeStep = 1 / 60) {\n    this._timeStep = newTimeStep;\n  }\n  /**\n   * Get the time step of the navigation tick update.\n   * @returns the current time step\n   */\n  getTimeStep() {\n    return this._timeStep;\n  }\n  /**\n   * If delta time in navigation tick update is greater than the time step\n   * a number of sub iterations are done. If more iterations are need to reach deltatime\n   * they will be discarded.\n   * A value of 0 will set to no maximum and update will use as many substeps as needed\n   * @param newStepCount the maximum number of iterations\n   */\n  setMaximumSubStepCount(newStepCount = 10) {\n    this._maximumSubStepCount = newStepCount;\n  }\n  /**\n   * Get the maximum number of iterations per navigation tick update\n   * @returns the maximum number of iterations\n   */\n  getMaximumSubStepCount() {\n    return this._maximumSubStepCount;\n  }\n  /**\n   * Time factor applied when updating crowd agents (default 1). A value of 0 will pause crowd updates.\n   * @param value the time factor applied at update\n   */\n  set timeFactor(value) {\n    this._timeFactor = Math.max(value, 0);\n  }\n  /**\n   * Get the time factor used for crowd agent update\n   * @returns the time factor\n   */\n  get timeFactor() {\n    return this._timeFactor;\n  }\n  /**\n   * Creates a navigation mesh\n   * @param meshes array of all the geometry used to compute the navigation mesh\n   * @param parameters bunch of parameters used to filter geometry\n   * @param completion callback when data is available from the worker. Not used without a worker\n   */\n  createNavMesh(meshes, parameters, completion) {\n    if (this._worker && !completion) {\n      console.warn(\"A worker is avaible but no completion callback. Defaulting to blocking navmesh creation\");\n    } else if (!this._worker && completion) {\n      console.warn(\"A completion callback is avaible but no worker. Defaulting to blocking navmesh creation\");\n    }\n    this.navMesh = new this.bjsRECAST.NavMesh();\n    let index;\n    let tri;\n    let pt;\n    const indices = [];\n    const positions = [];\n    let offset = 0;\n    for (index = 0; index < meshes.length; index++) {\n      if (meshes[index]) {\n        const mesh = meshes[index];\n        const meshIndices = mesh.getIndices();\n        if (!meshIndices) {\n          continue;\n        }\n        const meshPositions = mesh.getVerticesData(VertexBuffer.PositionKind, false, false);\n        if (!meshPositions) {\n          continue;\n        }\n        const worldMatrices = [];\n        const worldMatrix = mesh.computeWorldMatrix(true);\n        if (mesh.hasThinInstances) {\n          const thinMatrices = mesh.thinInstanceGetWorldMatrices();\n          for (let instanceIndex = 0; instanceIndex < thinMatrices.length; instanceIndex++) {\n            const tmpMatrix = new Matrix();\n            const thinMatrix = thinMatrices[instanceIndex];\n            thinMatrix.multiplyToRef(worldMatrix, tmpMatrix);\n            worldMatrices.push(tmpMatrix);\n          }\n        } else {\n          worldMatrices.push(worldMatrix);\n        }\n        for (let matrixIndex = 0; matrixIndex < worldMatrices.length; matrixIndex++) {\n          const wm = worldMatrices[matrixIndex];\n          for (tri = 0; tri < meshIndices.length; tri++) {\n            indices.push(meshIndices[tri] + offset);\n          }\n          const transformed = Vector3.Zero();\n          const position = Vector3.Zero();\n          for (pt = 0; pt < meshPositions.length; pt += 3) {\n            Vector3.FromArrayToRef(meshPositions, pt, position);\n            Vector3.TransformCoordinatesToRef(position, wm, transformed);\n            positions.push(transformed.x, transformed.y, transformed.z);\n          }\n          offset += meshPositions.length / 3;\n        }\n      }\n    }\n    if (this._worker && completion) {\n      // spawn worker and send message\n      this._worker.postMessage([positions, offset, indices, indices.length, parameters]);\n      this._worker.onmessage = function (e) {\n        completion(e.data);\n      };\n    } else {\n      // blocking calls\n      const rc = new this.bjsRECAST.rcConfig();\n      rc.cs = parameters.cs;\n      rc.ch = parameters.ch;\n      rc.borderSize = parameters.borderSize ? parameters.borderSize : 0;\n      rc.tileSize = parameters.tileSize ? parameters.tileSize : 0;\n      rc.walkableSlopeAngle = parameters.walkableSlopeAngle;\n      rc.walkableHeight = parameters.walkableHeight;\n      rc.walkableClimb = parameters.walkableClimb;\n      rc.walkableRadius = parameters.walkableRadius;\n      rc.maxEdgeLen = parameters.maxEdgeLen;\n      rc.maxSimplificationError = parameters.maxSimplificationError;\n      rc.minRegionArea = parameters.minRegionArea;\n      rc.mergeRegionArea = parameters.mergeRegionArea;\n      rc.maxVertsPerPoly = parameters.maxVertsPerPoly;\n      rc.detailSampleDist = parameters.detailSampleDist;\n      rc.detailSampleMaxError = parameters.detailSampleMaxError;\n      this.navMesh.build(positions, offset, indices, indices.length, rc);\n    }\n  }\n  /**\n   * Create a navigation mesh debug mesh\n   * @param scene is where the mesh will be added\n   * @returns debug display mesh\n   */\n  createDebugNavMesh(scene) {\n    let tri;\n    let pt;\n    const debugNavMesh = this.navMesh.getDebugNavMesh();\n    const triangleCount = debugNavMesh.getTriangleCount();\n    const indices = [];\n    const positions = [];\n    for (tri = 0; tri < triangleCount * 3; tri++) {\n      indices.push(tri);\n    }\n    for (tri = 0; tri < triangleCount; tri++) {\n      for (pt = 0; pt < 3; pt++) {\n        const point = debugNavMesh.getTriangle(tri).getPoint(pt);\n        positions.push(point.x, point.y, point.z);\n      }\n    }\n    const mesh = new Mesh(\"NavMeshDebug\", scene);\n    const vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.applyToMesh(mesh, false);\n    return mesh;\n  }\n  /**\n   * Get a navigation mesh constrained position, closest to the parameter position\n   * @param position world position\n   * @returns the closest point to position constrained by the navigation mesh\n   */\n  getClosestPoint(position) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    const ret = this.navMesh.getClosestPoint(this._tempVec1);\n    const pr = new Vector3(ret.x, ret.y, ret.z);\n    return pr;\n  }\n  /**\n   * Get a navigation mesh constrained position, closest to the parameter position\n   * @param position world position\n   * @param result output the closest point to position constrained by the navigation mesh\n   */\n  getClosestPointToRef(position, result) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    const ret = this.navMesh.getClosestPoint(this._tempVec1);\n    result.set(ret.x, ret.y, ret.z);\n  }\n  /**\n   * Get a navigation mesh constrained position, within a particular radius\n   * @param position world position\n   * @param maxRadius the maximum distance to the constrained world position\n   * @returns the closest point to position constrained by the navigation mesh\n   */\n  getRandomPointAround(position, maxRadius) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    const ret = this.navMesh.getRandomPointAround(this._tempVec1, maxRadius);\n    const pr = new Vector3(ret.x, ret.y, ret.z);\n    return pr;\n  }\n  /**\n   * Get a navigation mesh constrained position, within a particular radius\n   * @param position world position\n   * @param maxRadius the maximum distance to the constrained world position\n   * @param result output the closest point to position constrained by the navigation mesh\n   */\n  getRandomPointAroundToRef(position, maxRadius, result) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    const ret = this.navMesh.getRandomPointAround(this._tempVec1, maxRadius);\n    result.set(ret.x, ret.y, ret.z);\n  }\n  /**\n   * Compute the final position from a segment made of destination-position\n   * @param position world position\n   * @param destination world position\n   * @returns the resulting point along the navmesh\n   */\n  moveAlong(position, destination) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    this._tempVec2.x = destination.x;\n    this._tempVec2.y = destination.y;\n    this._tempVec2.z = destination.z;\n    const ret = this.navMesh.moveAlong(this._tempVec1, this._tempVec2);\n    const pr = new Vector3(ret.x, ret.y, ret.z);\n    return pr;\n  }\n  /**\n   * Compute the final position from a segment made of destination-position\n   * @param position world position\n   * @param destination world position\n   * @param result output the resulting point along the navmesh\n   */\n  moveAlongToRef(position, destination, result) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    this._tempVec2.x = destination.x;\n    this._tempVec2.y = destination.y;\n    this._tempVec2.z = destination.z;\n    const ret = this.navMesh.moveAlong(this._tempVec1, this._tempVec2);\n    result.set(ret.x, ret.y, ret.z);\n  }\n  /**\n   * Compute a navigation path from start to end. Returns an empty array if no path can be computed\n   * @param start world position\n   * @param end world position\n   * @returns array containing world position composing the path\n   */\n  computePath(start, end) {\n    let pt;\n    this._tempVec1.x = start.x;\n    this._tempVec1.y = start.y;\n    this._tempVec1.z = start.z;\n    this._tempVec2.x = end.x;\n    this._tempVec2.y = end.y;\n    this._tempVec2.z = end.z;\n    const navPath = this.navMesh.computePath(this._tempVec1, this._tempVec2);\n    const pointCount = navPath.getPointCount();\n    const positions = [];\n    for (pt = 0; pt < pointCount; pt++) {\n      const p = navPath.getPoint(pt);\n      positions.push(new Vector3(p.x, p.y, p.z));\n    }\n    return positions;\n  }\n  /**\n   * Create a new Crowd so you can add agents\n   * @param maxAgents the maximum agent count in the crowd\n   * @param maxAgentRadius the maximum radius an agent can have\n   * @param scene to attach the crowd to\n   * @returns the crowd you can add agents to\n   */\n  createCrowd(maxAgents, maxAgentRadius, scene) {\n    const crowd = new RecastJSCrowd(this, maxAgents, maxAgentRadius, scene);\n    return crowd;\n  }\n  /**\n   * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\n   * The queries will try to find a solution within those bounds\n   * default is (1,1,1)\n   * @param extent x,y,z value that define the extent around the queries point of reference\n   */\n  setDefaultQueryExtent(extent) {\n    this._tempVec1.x = extent.x;\n    this._tempVec1.y = extent.y;\n    this._tempVec1.z = extent.z;\n    this.navMesh.setDefaultQueryExtent(this._tempVec1);\n  }\n  /**\n   * Get the Bounding box extent specified by setDefaultQueryExtent\n   * @returns the box extent values\n   */\n  getDefaultQueryExtent() {\n    const p = this.navMesh.getDefaultQueryExtent();\n    return new Vector3(p.x, p.y, p.z);\n  }\n  /**\n   * build the navmesh from a previously saved state using getNavmeshData\n   * @param data the Uint8Array returned by getNavmeshData\n   */\n  buildFromNavmeshData(data) {\n    const nDataBytes = data.length * data.BYTES_PER_ELEMENT;\n    const dataPtr = this.bjsRECAST._malloc(nDataBytes);\n    const dataHeap = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, dataPtr, nDataBytes);\n    dataHeap.set(data);\n    const buf = new this.bjsRECAST.NavmeshData();\n    buf.dataPointer = dataHeap.byteOffset;\n    buf.size = data.length;\n    this.navMesh = new this.bjsRECAST.NavMesh();\n    this.navMesh.buildFromNavmeshData(buf);\n    // Free memory\n    this.bjsRECAST._free(dataHeap.byteOffset);\n  }\n  /**\n   * returns the navmesh data that can be used later. The navmesh must be built before retrieving the data\n   * @returns data the Uint8Array that can be saved and reused\n   */\n  getNavmeshData() {\n    const navmeshData = this.navMesh.getNavmeshData();\n    const arrView = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, navmeshData.dataPointer, navmeshData.size);\n    const ret = new Uint8Array(navmeshData.size);\n    ret.set(arrView);\n    this.navMesh.freeNavmeshData(navmeshData);\n    return ret;\n  }\n  /**\n   * Get the Bounding box extent result specified by setDefaultQueryExtent\n   * @param result output the box extent values\n   */\n  getDefaultQueryExtentToRef(result) {\n    const p = this.navMesh.getDefaultQueryExtent();\n    result.set(p.x, p.y, p.z);\n  }\n  /**\n   * Disposes\n   */\n  dispose() {}\n  /**\n   * Creates a cylinder obstacle and add it to the navigation\n   * @param position world position\n   * @param radius cylinder radius\n   * @param height cylinder height\n   * @returns the obstacle freshly created\n   */\n  addCylinderObstacle(position, radius, height) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    return this.navMesh.addCylinderObstacle(this._tempVec1, radius, height);\n  }\n  /**\n   * Creates an oriented box obstacle and add it to the navigation\n   * @param position world position\n   * @param extent box size\n   * @param angle angle in radians of the box orientation on Y axis\n   * @returns the obstacle freshly created\n   */\n  addBoxObstacle(position, extent, angle) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    this._tempVec2.x = extent.x;\n    this._tempVec2.y = extent.y;\n    this._tempVec2.z = extent.z;\n    return this.navMesh.addBoxObstacle(this._tempVec1, this._tempVec2, angle);\n  }\n  /**\n   * Removes an obstacle created by addCylinderObstacle or addBoxObstacle\n   * @param obstacle obstacle to remove from the navigation\n   */\n  removeObstacle(obstacle) {\n    this.navMesh.removeObstacle(obstacle);\n  }\n  /**\n   * If this plugin is supported\n   * @returns true if plugin is supported\n   */\n  isSupported() {\n    return this.bjsRECAST !== undefined;\n  }\n}\n/**\n * Recast detour crowd implementation\n */\nexport class RecastJSCrowd {\n  /**\n   * Constructor\n   * @param plugin recastJS plugin\n   * @param maxAgents the maximum agent count in the crowd\n   * @param maxAgentRadius the maximum radius an agent can have\n   * @param scene to attach the crowd to\n   * @returns the crowd you can add agents to\n   */\n  constructor(plugin, maxAgents, maxAgentRadius, scene) {\n    /**\n     * Link to the detour crowd\n     */\n    this.recastCrowd = {};\n    /**\n     * One transform per agent\n     */\n    this.transforms = new Array();\n    /**\n     * All agents created\n     */\n    this.agents = new Array();\n    /**\n     * agents reach radius\n     */\n    this.reachRadii = new Array();\n    /**\n     * true when a destination is active for an agent and notifier hasn't been notified of reach\n     */\n    this._agentDestinationArmed = new Array();\n    /**\n     * agent current target\n     */\n    this._agentDestination = new Array();\n    /**\n     * Observer for crowd updates\n     */\n    this._onBeforeAnimationsObserver = null;\n    /**\n     * Fires each time an agent is in reach radius of its destination\n     */\n    this.onReachTargetObservable = new Observable();\n    this.bjsRECASTPlugin = plugin;\n    this.recastCrowd = new this.bjsRECASTPlugin.bjsRECAST.Crowd(maxAgents, maxAgentRadius, this.bjsRECASTPlugin.navMesh.getNavMesh());\n    this._scene = scene;\n    this._onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\n      this.update(scene.getEngine().getDeltaTime() * 0.001 * plugin.timeFactor);\n    });\n  }\n  /**\n   * Add a new agent to the crowd with the specified parameter a corresponding transformNode.\n   * You can attach anything to that node. The node position is updated in the scene update tick.\n   * @param pos world position that will be constrained by the navigation mesh\n   * @param parameters agent parameters\n   * @param transform hooked to the agent that will be update by the scene\n   * @returns agent index\n   */\n  addAgent(pos, parameters, transform) {\n    const agentParams = new this.bjsRECASTPlugin.bjsRECAST.dtCrowdAgentParams();\n    agentParams.radius = parameters.radius;\n    agentParams.height = parameters.height;\n    agentParams.maxAcceleration = parameters.maxAcceleration;\n    agentParams.maxSpeed = parameters.maxSpeed;\n    agentParams.collisionQueryRange = parameters.collisionQueryRange;\n    agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\n    agentParams.separationWeight = parameters.separationWeight;\n    agentParams.updateFlags = 7;\n    agentParams.obstacleAvoidanceType = 0;\n    agentParams.queryFilterType = 0;\n    agentParams.userData = 0;\n    const agentIndex = this.recastCrowd.addAgent(new this.bjsRECASTPlugin.bjsRECAST.Vec3(pos.x, pos.y, pos.z), agentParams);\n    this.transforms.push(transform);\n    this.agents.push(agentIndex);\n    this.reachRadii.push(parameters.reachRadius ? parameters.reachRadius : parameters.radius);\n    this._agentDestinationArmed.push(false);\n    this._agentDestination.push(new Vector3(0, 0, 0));\n    return agentIndex;\n  }\n  /**\n   * Returns the agent position in world space\n   * @param index agent index returned by addAgent\n   * @returns world space position\n   */\n  getAgentPosition(index) {\n    const agentPos = this.recastCrowd.getAgentPosition(index);\n    return new Vector3(agentPos.x, agentPos.y, agentPos.z);\n  }\n  /**\n   * Returns the agent position result in world space\n   * @param index agent index returned by addAgent\n   * @param result output world space position\n   */\n  getAgentPositionToRef(index, result) {\n    const agentPos = this.recastCrowd.getAgentPosition(index);\n    result.set(agentPos.x, agentPos.y, agentPos.z);\n  }\n  /**\n   * Returns the agent velocity in world space\n   * @param index agent index returned by addAgent\n   * @returns world space velocity\n   */\n  getAgentVelocity(index) {\n    const agentVel = this.recastCrowd.getAgentVelocity(index);\n    return new Vector3(agentVel.x, agentVel.y, agentVel.z);\n  }\n  /**\n   * Returns the agent velocity result in world space\n   * @param index agent index returned by addAgent\n   * @param result output world space velocity\n   */\n  getAgentVelocityToRef(index, result) {\n    const agentVel = this.recastCrowd.getAgentVelocity(index);\n    result.set(agentVel.x, agentVel.y, agentVel.z);\n  }\n  /**\n   * Returns the agent next target point on the path\n   * @param index agent index returned by addAgent\n   * @returns world space position\n   */\n  getAgentNextTargetPath(index) {\n    const pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\n    return new Vector3(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\n  }\n  /**\n   * Returns the agent next target point on the path\n   * @param index agent index returned by addAgent\n   * @param result output world space position\n   */\n  getAgentNextTargetPathToRef(index, result) {\n    const pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\n    result.set(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\n  }\n  /**\n   * Gets the agent state\n   * @param index agent index returned by addAgent\n   * @returns agent state\n   */\n  getAgentState(index) {\n    return this.recastCrowd.getAgentState(index);\n  }\n  /**\n   * returns true if the agent in over an off mesh link connection\n   * @param index agent index returned by addAgent\n   * @returns true if over an off mesh link connection\n   */\n  overOffmeshConnection(index) {\n    return this.recastCrowd.overOffmeshConnection(index);\n  }\n  /**\n   * Asks a particular agent to go to a destination. That destination is constrained by the navigation mesh\n   * @param index agent index returned by addAgent\n   * @param destination targeted world position\n   */\n  agentGoto(index, destination) {\n    this.recastCrowd.agentGoto(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));\n    // arm observer\n    const item = this.agents.indexOf(index);\n    if (item > -1) {\n      this._agentDestinationArmed[item] = true;\n      this._agentDestination[item].set(destination.x, destination.y, destination.z);\n    }\n  }\n  /**\n   * Teleport the agent to a new position\n   * @param index agent index returned by addAgent\n   * @param destination targeted world position\n   */\n  agentTeleport(index, destination) {\n    this.recastCrowd.agentTeleport(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));\n  }\n  /**\n   * Update agent parameters\n   * @param index agent index returned by addAgent\n   * @param parameters agent parameters\n   */\n  updateAgentParameters(index, parameters) {\n    const agentParams = this.recastCrowd.getAgentParameters(index);\n    if (parameters.radius !== undefined) {\n      agentParams.radius = parameters.radius;\n    }\n    if (parameters.height !== undefined) {\n      agentParams.height = parameters.height;\n    }\n    if (parameters.maxAcceleration !== undefined) {\n      agentParams.maxAcceleration = parameters.maxAcceleration;\n    }\n    if (parameters.maxSpeed !== undefined) {\n      agentParams.maxSpeed = parameters.maxSpeed;\n    }\n    if (parameters.collisionQueryRange !== undefined) {\n      agentParams.collisionQueryRange = parameters.collisionQueryRange;\n    }\n    if (parameters.pathOptimizationRange !== undefined) {\n      agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\n    }\n    if (parameters.separationWeight !== undefined) {\n      agentParams.separationWeight = parameters.separationWeight;\n    }\n    this.recastCrowd.setAgentParameters(index, agentParams);\n  }\n  /**\n   * remove a particular agent previously created\n   * @param index agent index returned by addAgent\n   */\n  removeAgent(index) {\n    this.recastCrowd.removeAgent(index);\n    const item = this.agents.indexOf(index);\n    if (item > -1) {\n      this.agents.splice(item, 1);\n      this.transforms.splice(item, 1);\n      this.reachRadii.splice(item, 1);\n      this._agentDestinationArmed.splice(item, 1);\n      this._agentDestination.splice(item, 1);\n    }\n  }\n  /**\n   * get the list of all agents attached to this crowd\n   * @returns list of agent indices\n   */\n  getAgents() {\n    return this.agents;\n  }\n  /**\n   * Tick update done by the Scene. Agent position/velocity/acceleration is updated by this function\n   * @param deltaTime in seconds\n   */\n  update(deltaTime) {\n    // update obstacles\n    this.bjsRECASTPlugin.navMesh.update();\n    if (deltaTime <= Epsilon) {\n      return;\n    }\n    // update crowd\n    const timeStep = this.bjsRECASTPlugin.getTimeStep();\n    const maxStepCount = this.bjsRECASTPlugin.getMaximumSubStepCount();\n    if (timeStep <= Epsilon) {\n      this.recastCrowd.update(deltaTime);\n    } else {\n      let iterationCount = Math.floor(deltaTime / timeStep);\n      if (maxStepCount && iterationCount > maxStepCount) {\n        iterationCount = maxStepCount;\n      }\n      if (iterationCount < 1) {\n        iterationCount = 1;\n      }\n      const step = deltaTime / iterationCount;\n      for (let i = 0; i < iterationCount; i++) {\n        this.recastCrowd.update(step);\n      }\n    }\n    // update transforms\n    for (let index = 0; index < this.agents.length; index++) {\n      // update transform position\n      const agentIndex = this.agents[index];\n      const agentPosition = this.getAgentPosition(agentIndex);\n      this.transforms[index].position = agentPosition;\n      // check agent reach destination\n      if (this._agentDestinationArmed[index]) {\n        const dx = agentPosition.x - this._agentDestination[index].x;\n        const dz = agentPosition.z - this._agentDestination[index].z;\n        const radius = this.reachRadii[index];\n        const groundY = this._agentDestination[index].y - this.reachRadii[index];\n        const ceilingY = this._agentDestination[index].y + this.reachRadii[index];\n        const distanceXZSquared = dx * dx + dz * dz;\n        if (agentPosition.y > groundY && agentPosition.y < ceilingY && distanceXZSquared < radius * radius) {\n          this.onReachTargetObservable.notifyObservers({\n            agentIndex: agentIndex,\n            destination: this._agentDestination[index]\n          });\n          this._agentDestinationArmed[index] = false;\n        }\n      }\n    }\n  }\n  /**\n   * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\n   * The queries will try to find a solution within those bounds\n   * default is (1,1,1)\n   * @param extent x,y,z value that define the extent around the queries point of reference\n   */\n  setDefaultQueryExtent(extent) {\n    const ext = new this.bjsRECASTPlugin.bjsRECAST.Vec3(extent.x, extent.y, extent.z);\n    this.recastCrowd.setDefaultQueryExtent(ext);\n  }\n  /**\n   * Get the Bounding box extent specified by setDefaultQueryExtent\n   * @returns the box extent values\n   */\n  getDefaultQueryExtent() {\n    const p = this.recastCrowd.getDefaultQueryExtent();\n    return new Vector3(p.x, p.y, p.z);\n  }\n  /**\n   * Get the Bounding box extent result specified by setDefaultQueryExtent\n   * @param result output the box extent values\n   */\n  getDefaultQueryExtentToRef(result) {\n    const p = this.recastCrowd.getDefaultQueryExtent();\n    result.set(p.x, p.y, p.z);\n  }\n  /**\n   * Get the next corner points composing the path (max 4 points)\n   * @param index agent index returned by addAgent\n   * @returns array containing world position composing the path\n   */\n  getCorners(index) {\n    let pt;\n    const navPath = this.recastCrowd.getCorners(index);\n    const pointCount = navPath.getPointCount();\n    const positions = [];\n    for (pt = 0; pt < pointCount; pt++) {\n      const p = navPath.getPoint(pt);\n      positions.push(new Vector3(p.x, p.y, p.z));\n    }\n    return positions;\n  }\n  /**\n   * Release all resources\n   */\n  dispose() {\n    this.recastCrowd.destroy();\n    this._scene.onBeforeAnimationsObservable.remove(this._onBeforeAnimationsObserver);\n    this._onBeforeAnimationsObserver = null;\n    this.onReachTargetObservable.clear();\n  }\n}","map":{"version":3,"names":["Logger","VertexData","Mesh","Epsilon","Vector3","Matrix","Observable","VertexBuffer","RecastJSPlugin","constructor","recastInjection","Recast","bjsRECAST","name","_maximumSubStepCount","_timeStep","_timeFactor","_worker","Error","isSupported","setTimeStep","_tempVec1","Vec3","_tempVec2","setWorkerURL","workerURL","window","Worker","newTimeStep","getTimeStep","setMaximumSubStepCount","newStepCount","getMaximumSubStepCount","timeFactor","value","Math","max","createNavMesh","meshes","parameters","completion","console","warn","navMesh","NavMesh","index","tri","pt","indices","positions","offset","length","mesh","meshIndices","getIndices","meshPositions","getVerticesData","PositionKind","worldMatrices","worldMatrix","computeWorldMatrix","hasThinInstances","thinMatrices","thinInstanceGetWorldMatrices","instanceIndex","tmpMatrix","thinMatrix","multiplyToRef","push","matrixIndex","wm","transformed","Zero","position","FromArrayToRef","TransformCoordinatesToRef","x","y","z","postMessage","onmessage","e","data","rc","rcConfig","cs","ch","borderSize","tileSize","walkableSlopeAngle","walkableHeight","walkableClimb","walkableRadius","maxEdgeLen","maxSimplificationError","minRegionArea","mergeRegionArea","maxVertsPerPoly","detailSampleDist","detailSampleMaxError","build","createDebugNavMesh","scene","debugNavMesh","getDebugNavMesh","triangleCount","getTriangleCount","point","getTriangle","getPoint","vertexData","applyToMesh","getClosestPoint","ret","pr","getClosestPointToRef","result","set","getRandomPointAround","maxRadius","getRandomPointAroundToRef","moveAlong","destination","moveAlongToRef","computePath","start","end","navPath","pointCount","getPointCount","p","createCrowd","maxAgents","maxAgentRadius","crowd","RecastJSCrowd","setDefaultQueryExtent","extent","getDefaultQueryExtent","buildFromNavmeshData","nDataBytes","BYTES_PER_ELEMENT","dataPtr","_malloc","dataHeap","Uint8Array","HEAPU8","buffer","buf","NavmeshData","dataPointer","byteOffset","size","_free","getNavmeshData","navmeshData","arrView","freeNavmeshData","getDefaultQueryExtentToRef","dispose","addCylinderObstacle","radius","height","addBoxObstacle","angle","removeObstacle","obstacle","undefined","plugin","recastCrowd","transforms","Array","agents","reachRadii","_agentDestinationArmed","_agentDestination","_onBeforeAnimationsObserver","onReachTargetObservable","bjsRECASTPlugin","Crowd","getNavMesh","_scene","onBeforeAnimationsObservable","add","update","getEngine","getDeltaTime","addAgent","pos","transform","agentParams","dtCrowdAgentParams","maxAcceleration","maxSpeed","collisionQueryRange","pathOptimizationRange","separationWeight","updateFlags","obstacleAvoidanceType","queryFilterType","userData","agentIndex","reachRadius","getAgentPosition","agentPos","getAgentPositionToRef","getAgentVelocity","agentVel","getAgentVelocityToRef","getAgentNextTargetPath","pathTargetPos","getAgentNextTargetPathToRef","getAgentState","overOffmeshConnection","agentGoto","item","indexOf","agentTeleport","updateAgentParameters","getAgentParameters","setAgentParameters","removeAgent","splice","getAgents","deltaTime","timeStep","maxStepCount","iterationCount","floor","step","i","agentPosition","dx","dz","groundY","ceilingY","distanceXZSquared","notifyObservers","ext","getCorners","destroy","remove","clear"],"sources":["../../../../../dev/core/src/Navigation/Plugins/recastJSPlugin.ts"],"sourcesContent":["import type { INavigationEnginePlugin, ICrowd, IAgentParameters, INavMeshParameters, IObstacle } from \"../../Navigation/INavigationEngine\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { VertexData } from \"../../Meshes/mesh.vertexData\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Epsilon, Vector3, Matrix } from \"../../Maths/math\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let Recast: any;\r\n\r\n/**\r\n * RecastJS navigation plugin\r\n */\r\nexport class RecastJSPlugin implements INavigationEnginePlugin {\r\n    /**\r\n     * Reference to the Recast library\r\n     */\r\n    public bjsRECAST: any = {};\r\n\r\n    /**\r\n     * plugin name\r\n     */\r\n    public name: string = \"RecastJSPlugin\";\r\n\r\n    /**\r\n     * the first navmesh created. We might extend this to support multiple navmeshes\r\n     */\r\n    public navMesh: any;\r\n\r\n    private _maximumSubStepCount: number = 10;\r\n    private _timeStep: number = 1 / 60;\r\n    private _timeFactor: number = 1;\r\n\r\n    private _tempVec1: any;\r\n    private _tempVec2: any;\r\n\r\n    private _worker: Nullable<Worker> = null;\r\n\r\n    /**\r\n     * Initializes the recastJS plugin\r\n     * @param recastInjection can be used to inject your own recast reference\r\n     */\r\n    public constructor(recastInjection: any = Recast) {\r\n        if (typeof recastInjection === \"function\") {\r\n            Logger.Error(\"RecastJS is not ready. Please make sure you await Recast() before using the plugin.\");\r\n        } else {\r\n            this.bjsRECAST = recastInjection;\r\n        }\r\n\r\n        if (!this.isSupported()) {\r\n            Logger.Error(\"RecastJS is not available. Please make sure you included the js file.\");\r\n            return;\r\n        }\r\n        this.setTimeStep();\r\n\r\n        this._tempVec1 = new this.bjsRECAST.Vec3();\r\n        this._tempVec2 = new this.bjsRECAST.Vec3();\r\n    }\r\n\r\n    /**\r\n     * Set worker URL to be used when generating a new navmesh\r\n     * @param workerURL url string\r\n     * @returns boolean indicating if worker is created\r\n     */\r\n    public setWorkerURL(workerURL: string): boolean {\r\n        if (window && window.Worker) {\r\n            this._worker = new Worker(workerURL);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set the time step of the navigation tick update.\r\n     * Default is 1/60.\r\n     * A value of 0 will disable fixed time update\r\n     * @param newTimeStep the new timestep to apply to this world.\r\n     */\r\n    setTimeStep(newTimeStep: number = 1 / 60): void {\r\n        this._timeStep = newTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Get the time step of the navigation tick update.\r\n     * @returns the current time step\r\n     */\r\n    getTimeStep(): number {\r\n        return this._timeStep;\r\n    }\r\n\r\n    /**\r\n     * If delta time in navigation tick update is greater than the time step\r\n     * a number of sub iterations are done. If more iterations are need to reach deltatime\r\n     * they will be discarded.\r\n     * A value of 0 will set to no maximum and update will use as many substeps as needed\r\n     * @param newStepCount the maximum number of iterations\r\n     */\r\n    setMaximumSubStepCount(newStepCount: number = 10): void {\r\n        this._maximumSubStepCount = newStepCount;\r\n    }\r\n\r\n    /**\r\n     * Get the maximum number of iterations per navigation tick update\r\n     * @returns the maximum number of iterations\r\n     */\r\n    getMaximumSubStepCount(): number {\r\n        return this._maximumSubStepCount;\r\n    }\r\n\r\n    /**\r\n     * Time factor applied when updating crowd agents (default 1). A value of 0 will pause crowd updates.\r\n     * @param value the time factor applied at update\r\n     */\r\n    public set timeFactor(value: number) {\r\n        this._timeFactor = Math.max(value, 0);\r\n    }\r\n\r\n    /**\r\n     * Get the time factor used for crowd agent update\r\n     * @returns the time factor\r\n     */\r\n    public get timeFactor(): number {\r\n        return this._timeFactor;\r\n    }\r\n\r\n    /**\r\n     * Creates a navigation mesh\r\n     * @param meshes array of all the geometry used to compute the navigation mesh\r\n     * @param parameters bunch of parameters used to filter geometry\r\n     * @param completion callback when data is available from the worker. Not used without a worker\r\n     */\r\n    createNavMesh(meshes: Array<Mesh>, parameters: INavMeshParameters, completion?: (navmeshData: Uint8Array) => void): void {\r\n        if (this._worker && !completion) {\r\n            console.warn(\"A worker is avaible but no completion callback. Defaulting to blocking navmesh creation\");\r\n        } else if (!this._worker && completion) {\r\n            console.warn(\"A completion callback is avaible but no worker. Defaulting to blocking navmesh creation\");\r\n        }\r\n\r\n        this.navMesh = new this.bjsRECAST.NavMesh();\r\n\r\n        let index: number;\r\n        let tri: number;\r\n        let pt: number;\r\n\r\n        const indices = [];\r\n        const positions = [];\r\n        let offset = 0;\r\n        for (index = 0; index < meshes.length; index++) {\r\n            if (meshes[index]) {\r\n                const mesh = meshes[index];\r\n\r\n                const meshIndices = mesh.getIndices();\r\n                if (!meshIndices) {\r\n                    continue;\r\n                }\r\n                const meshPositions = mesh.getVerticesData(VertexBuffer.PositionKind, false, false);\r\n                if (!meshPositions) {\r\n                    continue;\r\n                }\r\n\r\n                const worldMatrices = [];\r\n                const worldMatrix = mesh.computeWorldMatrix(true);\r\n\r\n                if (mesh.hasThinInstances) {\r\n                    const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                    for (let instanceIndex = 0; instanceIndex < thinMatrices.length; instanceIndex++) {\r\n                        const tmpMatrix = new Matrix();\r\n                        const thinMatrix = thinMatrices[instanceIndex];\r\n                        thinMatrix.multiplyToRef(worldMatrix, tmpMatrix);\r\n                        worldMatrices.push(tmpMatrix);\r\n                    }\r\n                } else {\r\n                    worldMatrices.push(worldMatrix);\r\n                }\r\n\r\n                for (let matrixIndex = 0; matrixIndex < worldMatrices.length; matrixIndex++) {\r\n                    const wm = worldMatrices[matrixIndex];\r\n                    for (tri = 0; tri < meshIndices.length; tri++) {\r\n                        indices.push(meshIndices[tri] + offset);\r\n                    }\r\n\r\n                    const transformed = Vector3.Zero();\r\n                    const position = Vector3.Zero();\r\n                    for (pt = 0; pt < meshPositions.length; pt += 3) {\r\n                        Vector3.FromArrayToRef(meshPositions, pt, position);\r\n                        Vector3.TransformCoordinatesToRef(position, wm, transformed);\r\n                        positions.push(transformed.x, transformed.y, transformed.z);\r\n                    }\r\n\r\n                    offset += meshPositions.length / 3;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._worker && completion) {\r\n            // spawn worker and send message\r\n            this._worker.postMessage([positions, offset, indices, indices.length, parameters]);\r\n            this._worker.onmessage = function (e) {\r\n                completion(e.data);\r\n            };\r\n        } else {\r\n            // blocking calls\r\n            const rc = new this.bjsRECAST.rcConfig();\r\n            rc.cs = parameters.cs;\r\n            rc.ch = parameters.ch;\r\n            rc.borderSize = parameters.borderSize ? parameters.borderSize : 0;\r\n            rc.tileSize = parameters.tileSize ? parameters.tileSize : 0;\r\n            rc.walkableSlopeAngle = parameters.walkableSlopeAngle;\r\n            rc.walkableHeight = parameters.walkableHeight;\r\n            rc.walkableClimb = parameters.walkableClimb;\r\n            rc.walkableRadius = parameters.walkableRadius;\r\n            rc.maxEdgeLen = parameters.maxEdgeLen;\r\n            rc.maxSimplificationError = parameters.maxSimplificationError;\r\n            rc.minRegionArea = parameters.minRegionArea;\r\n            rc.mergeRegionArea = parameters.mergeRegionArea;\r\n            rc.maxVertsPerPoly = parameters.maxVertsPerPoly;\r\n            rc.detailSampleDist = parameters.detailSampleDist;\r\n            rc.detailSampleMaxError = parameters.detailSampleMaxError;\r\n\r\n            this.navMesh.build(positions, offset, indices, indices.length, rc);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a navigation mesh debug mesh\r\n     * @param scene is where the mesh will be added\r\n     * @returns debug display mesh\r\n     */\r\n    createDebugNavMesh(scene: Scene): Mesh {\r\n        let tri: number;\r\n        let pt: number;\r\n        const debugNavMesh = this.navMesh.getDebugNavMesh();\r\n        const triangleCount = debugNavMesh.getTriangleCount();\r\n\r\n        const indices = [];\r\n        const positions = [];\r\n        for (tri = 0; tri < triangleCount * 3; tri++) {\r\n            indices.push(tri);\r\n        }\r\n        for (tri = 0; tri < triangleCount; tri++) {\r\n            for (pt = 0; pt < 3; pt++) {\r\n                const point = debugNavMesh.getTriangle(tri).getPoint(pt);\r\n                positions.push(point.x, point.y, point.z);\r\n            }\r\n        }\r\n\r\n        const mesh = new Mesh(\"NavMeshDebug\", scene);\r\n        const vertexData = new VertexData();\r\n\r\n        vertexData.indices = indices;\r\n        vertexData.positions = positions;\r\n        vertexData.applyToMesh(mesh, false);\r\n        return mesh;\r\n    }\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, closest to the parameter position\r\n     * @param position world position\r\n     * @returns the closest point to position constrained by the navigation mesh\r\n     */\r\n    getClosestPoint(position: Vector3): Vector3 {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        const ret = this.navMesh.getClosestPoint(this._tempVec1);\r\n        const pr = new Vector3(ret.x, ret.y, ret.z);\r\n        return pr;\r\n    }\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, closest to the parameter position\r\n     * @param position world position\r\n     * @param result output the closest point to position constrained by the navigation mesh\r\n     */\r\n    getClosestPointToRef(position: Vector3, result: Vector3): void {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        const ret = this.navMesh.getClosestPoint(this._tempVec1);\r\n        result.set(ret.x, ret.y, ret.z);\r\n    }\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, within a particular radius\r\n     * @param position world position\r\n     * @param maxRadius the maximum distance to the constrained world position\r\n     * @returns the closest point to position constrained by the navigation mesh\r\n     */\r\n    getRandomPointAround(position: Vector3, maxRadius: number): Vector3 {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        const ret = this.navMesh.getRandomPointAround(this._tempVec1, maxRadius);\r\n        const pr = new Vector3(ret.x, ret.y, ret.z);\r\n        return pr;\r\n    }\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, within a particular radius\r\n     * @param position world position\r\n     * @param maxRadius the maximum distance to the constrained world position\r\n     * @param result output the closest point to position constrained by the navigation mesh\r\n     */\r\n    getRandomPointAroundToRef(position: Vector3, maxRadius: number, result: Vector3): void {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        const ret = this.navMesh.getRandomPointAround(this._tempVec1, maxRadius);\r\n        result.set(ret.x, ret.y, ret.z);\r\n    }\r\n\r\n    /**\r\n     * Compute the final position from a segment made of destination-position\r\n     * @param position world position\r\n     * @param destination world position\r\n     * @returns the resulting point along the navmesh\r\n     */\r\n    moveAlong(position: Vector3, destination: Vector3): Vector3 {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        this._tempVec2.x = destination.x;\r\n        this._tempVec2.y = destination.y;\r\n        this._tempVec2.z = destination.z;\r\n        const ret = this.navMesh.moveAlong(this._tempVec1, this._tempVec2);\r\n        const pr = new Vector3(ret.x, ret.y, ret.z);\r\n        return pr;\r\n    }\r\n\r\n    /**\r\n     * Compute the final position from a segment made of destination-position\r\n     * @param position world position\r\n     * @param destination world position\r\n     * @param result output the resulting point along the navmesh\r\n     */\r\n    moveAlongToRef(position: Vector3, destination: Vector3, result: Vector3): void {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        this._tempVec2.x = destination.x;\r\n        this._tempVec2.y = destination.y;\r\n        this._tempVec2.z = destination.z;\r\n        const ret = this.navMesh.moveAlong(this._tempVec1, this._tempVec2);\r\n        result.set(ret.x, ret.y, ret.z);\r\n    }\r\n\r\n    /**\r\n     * Compute a navigation path from start to end. Returns an empty array if no path can be computed\r\n     * @param start world position\r\n     * @param end world position\r\n     * @returns array containing world position composing the path\r\n     */\r\n    computePath(start: Vector3, end: Vector3): Vector3[] {\r\n        let pt: number;\r\n        this._tempVec1.x = start.x;\r\n        this._tempVec1.y = start.y;\r\n        this._tempVec1.z = start.z;\r\n        this._tempVec2.x = end.x;\r\n        this._tempVec2.y = end.y;\r\n        this._tempVec2.z = end.z;\r\n        const navPath = this.navMesh.computePath(this._tempVec1, this._tempVec2);\r\n        const pointCount = navPath.getPointCount();\r\n        const positions = [];\r\n        for (pt = 0; pt < pointCount; pt++) {\r\n            const p = navPath.getPoint(pt);\r\n            positions.push(new Vector3(p.x, p.y, p.z));\r\n        }\r\n        return positions;\r\n    }\r\n\r\n    /**\r\n     * Create a new Crowd so you can add agents\r\n     * @param maxAgents the maximum agent count in the crowd\r\n     * @param maxAgentRadius the maximum radius an agent can have\r\n     * @param scene to attach the crowd to\r\n     * @returns the crowd you can add agents to\r\n     */\r\n    createCrowd(maxAgents: number, maxAgentRadius: number, scene: Scene): ICrowd {\r\n        const crowd = new RecastJSCrowd(this, maxAgents, maxAgentRadius, scene);\r\n        return crowd;\r\n    }\r\n\r\n    /**\r\n     * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\r\n     * The queries will try to find a solution within those bounds\r\n     * default is (1,1,1)\r\n     * @param extent x,y,z value that define the extent around the queries point of reference\r\n     */\r\n    setDefaultQueryExtent(extent: Vector3): void {\r\n        this._tempVec1.x = extent.x;\r\n        this._tempVec1.y = extent.y;\r\n        this._tempVec1.z = extent.z;\r\n        this.navMesh.setDefaultQueryExtent(this._tempVec1);\r\n    }\r\n\r\n    /**\r\n     * Get the Bounding box extent specified by setDefaultQueryExtent\r\n     * @returns the box extent values\r\n     */\r\n    getDefaultQueryExtent(): Vector3 {\r\n        const p = this.navMesh.getDefaultQueryExtent();\r\n        return new Vector3(p.x, p.y, p.z);\r\n    }\r\n\r\n    /**\r\n     * build the navmesh from a previously saved state using getNavmeshData\r\n     * @param data the Uint8Array returned by getNavmeshData\r\n     */\r\n    buildFromNavmeshData(data: Uint8Array): void {\r\n        const nDataBytes = data.length * data.BYTES_PER_ELEMENT;\r\n        const dataPtr = this.bjsRECAST._malloc(nDataBytes);\r\n\r\n        const dataHeap = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, dataPtr, nDataBytes);\r\n        dataHeap.set(data);\r\n\r\n        const buf = new this.bjsRECAST.NavmeshData();\r\n        buf.dataPointer = dataHeap.byteOffset;\r\n        buf.size = data.length;\r\n        this.navMesh = new this.bjsRECAST.NavMesh();\r\n        this.navMesh.buildFromNavmeshData(buf);\r\n\r\n        // Free memory\r\n        this.bjsRECAST._free(dataHeap.byteOffset);\r\n    }\r\n\r\n    /**\r\n     * returns the navmesh data that can be used later. The navmesh must be built before retrieving the data\r\n     * @returns data the Uint8Array that can be saved and reused\r\n     */\r\n    getNavmeshData(): Uint8Array {\r\n        const navmeshData = this.navMesh.getNavmeshData();\r\n        const arrView = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, navmeshData.dataPointer, navmeshData.size);\r\n        const ret = new Uint8Array(navmeshData.size);\r\n        ret.set(arrView);\r\n        this.navMesh.freeNavmeshData(navmeshData);\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Get the Bounding box extent result specified by setDefaultQueryExtent\r\n     * @param result output the box extent values\r\n     */\r\n    getDefaultQueryExtentToRef(result: Vector3): void {\r\n        const p = this.navMesh.getDefaultQueryExtent();\r\n        result.set(p.x, p.y, p.z);\r\n    }\r\n\r\n    /**\r\n     * Disposes\r\n     */\r\n    public dispose() {}\r\n\r\n    /**\r\n     * Creates a cylinder obstacle and add it to the navigation\r\n     * @param position world position\r\n     * @param radius cylinder radius\r\n     * @param height cylinder height\r\n     * @returns the obstacle freshly created\r\n     */\r\n    addCylinderObstacle(position: Vector3, radius: number, height: number): IObstacle {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        return this.navMesh.addCylinderObstacle(this._tempVec1, radius, height);\r\n    }\r\n\r\n    /**\r\n     * Creates an oriented box obstacle and add it to the navigation\r\n     * @param position world position\r\n     * @param extent box size\r\n     * @param angle angle in radians of the box orientation on Y axis\r\n     * @returns the obstacle freshly created\r\n     */\r\n    addBoxObstacle(position: Vector3, extent: Vector3, angle: number): IObstacle {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        this._tempVec2.x = extent.x;\r\n        this._tempVec2.y = extent.y;\r\n        this._tempVec2.z = extent.z;\r\n        return this.navMesh.addBoxObstacle(this._tempVec1, this._tempVec2, angle);\r\n    }\r\n\r\n    /**\r\n     * Removes an obstacle created by addCylinderObstacle or addBoxObstacle\r\n     * @param obstacle obstacle to remove from the navigation\r\n     */\r\n    removeObstacle(obstacle: IObstacle): void {\r\n        this.navMesh.removeObstacle(obstacle);\r\n    }\r\n\r\n    /**\r\n     * If this plugin is supported\r\n     * @returns true if plugin is supported\r\n     */\r\n    public isSupported(): boolean {\r\n        return this.bjsRECAST !== undefined;\r\n    }\r\n}\r\n\r\n/**\r\n * Recast detour crowd implementation\r\n */\r\nexport class RecastJSCrowd implements ICrowd {\r\n    /**\r\n     * Recast/detour plugin\r\n     */\r\n    public bjsRECASTPlugin: RecastJSPlugin;\r\n    /**\r\n     * Link to the detour crowd\r\n     */\r\n    public recastCrowd: any = {};\r\n    /**\r\n     * One transform per agent\r\n     */\r\n    public transforms: TransformNode[] = new Array<TransformNode>();\r\n    /**\r\n     * All agents created\r\n     */\r\n    public agents: number[] = new Array<number>();\r\n    /**\r\n     * agents reach radius\r\n     */\r\n    public reachRadii: number[] = new Array<number>();\r\n    /**\r\n     * true when a destination is active for an agent and notifier hasn't been notified of reach\r\n     */\r\n    private _agentDestinationArmed: boolean[] = new Array<boolean>();\r\n    /**\r\n     * agent current target\r\n     */\r\n    private _agentDestination: Vector3[] = new Array<Vector3>();\r\n    /**\r\n     * Link to the scene is kept to unregister the crowd from the scene\r\n     */\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Observer for crowd updates\r\n     */\r\n    private _onBeforeAnimationsObserver: Nullable<Observer<Scene>> = null;\r\n\r\n    /**\r\n     * Fires each time an agent is in reach radius of its destination\r\n     */\r\n    public onReachTargetObservable = new Observable<{ agentIndex: number; destination: Vector3 }>();\r\n\r\n    /**\r\n     * Constructor\r\n     * @param plugin recastJS plugin\r\n     * @param maxAgents the maximum agent count in the crowd\r\n     * @param maxAgentRadius the maximum radius an agent can have\r\n     * @param scene to attach the crowd to\r\n     * @returns the crowd you can add agents to\r\n     */\r\n    public constructor(plugin: RecastJSPlugin, maxAgents: number, maxAgentRadius: number, scene: Scene) {\r\n        this.bjsRECASTPlugin = plugin;\r\n        this.recastCrowd = new this.bjsRECASTPlugin.bjsRECAST.Crowd(maxAgents, maxAgentRadius, this.bjsRECASTPlugin.navMesh.getNavMesh());\r\n        this._scene = scene;\r\n\r\n        this._onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\r\n            this.update(scene.getEngine().getDeltaTime() * 0.001 * plugin.timeFactor);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Add a new agent to the crowd with the specified parameter a corresponding transformNode.\r\n     * You can attach anything to that node. The node position is updated in the scene update tick.\r\n     * @param pos world position that will be constrained by the navigation mesh\r\n     * @param parameters agent parameters\r\n     * @param transform hooked to the agent that will be update by the scene\r\n     * @returns agent index\r\n     */\r\n    addAgent(pos: Vector3, parameters: IAgentParameters, transform: TransformNode): number {\r\n        const agentParams = new this.bjsRECASTPlugin.bjsRECAST.dtCrowdAgentParams();\r\n        agentParams.radius = parameters.radius;\r\n        agentParams.height = parameters.height;\r\n        agentParams.maxAcceleration = parameters.maxAcceleration;\r\n        agentParams.maxSpeed = parameters.maxSpeed;\r\n        agentParams.collisionQueryRange = parameters.collisionQueryRange;\r\n        agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\r\n        agentParams.separationWeight = parameters.separationWeight;\r\n        agentParams.updateFlags = 7;\r\n        agentParams.obstacleAvoidanceType = 0;\r\n        agentParams.queryFilterType = 0;\r\n        agentParams.userData = 0;\r\n\r\n        const agentIndex = this.recastCrowd.addAgent(new this.bjsRECASTPlugin.bjsRECAST.Vec3(pos.x, pos.y, pos.z), agentParams);\r\n        this.transforms.push(transform);\r\n        this.agents.push(agentIndex);\r\n        this.reachRadii.push(parameters.reachRadius ? parameters.reachRadius : parameters.radius);\r\n        this._agentDestinationArmed.push(false);\r\n        this._agentDestination.push(new Vector3(0, 0, 0));\r\n        return agentIndex;\r\n    }\r\n\r\n    /**\r\n     * Returns the agent position in world space\r\n     * @param index agent index returned by addAgent\r\n     * @returns world space position\r\n     */\r\n    getAgentPosition(index: number): Vector3 {\r\n        const agentPos = this.recastCrowd.getAgentPosition(index);\r\n        return new Vector3(agentPos.x, agentPos.y, agentPos.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent position result in world space\r\n     * @param index agent index returned by addAgent\r\n     * @param result output world space position\r\n     */\r\n    getAgentPositionToRef(index: number, result: Vector3): void {\r\n        const agentPos = this.recastCrowd.getAgentPosition(index);\r\n        result.set(agentPos.x, agentPos.y, agentPos.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent velocity in world space\r\n     * @param index agent index returned by addAgent\r\n     * @returns world space velocity\r\n     */\r\n    getAgentVelocity(index: number): Vector3 {\r\n        const agentVel = this.recastCrowd.getAgentVelocity(index);\r\n        return new Vector3(agentVel.x, agentVel.y, agentVel.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent velocity result in world space\r\n     * @param index agent index returned by addAgent\r\n     * @param result output world space velocity\r\n     */\r\n    getAgentVelocityToRef(index: number, result: Vector3): void {\r\n        const agentVel = this.recastCrowd.getAgentVelocity(index);\r\n        result.set(agentVel.x, agentVel.y, agentVel.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent next target point on the path\r\n     * @param index agent index returned by addAgent\r\n     * @returns world space position\r\n     */\r\n    getAgentNextTargetPath(index: number): Vector3 {\r\n        const pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\r\n        return new Vector3(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent next target point on the path\r\n     * @param index agent index returned by addAgent\r\n     * @param result output world space position\r\n     */\r\n    getAgentNextTargetPathToRef(index: number, result: Vector3): void {\r\n        const pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\r\n        result.set(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\r\n    }\r\n\r\n    /**\r\n     * Gets the agent state\r\n     * @param index agent index returned by addAgent\r\n     * @returns agent state\r\n     */\r\n    getAgentState(index: number): number {\r\n        return this.recastCrowd.getAgentState(index);\r\n    }\r\n\r\n    /**\r\n     * returns true if the agent in over an off mesh link connection\r\n     * @param index agent index returned by addAgent\r\n     * @returns true if over an off mesh link connection\r\n     */\r\n    overOffmeshConnection(index: number): boolean {\r\n        return this.recastCrowd.overOffmeshConnection(index);\r\n    }\r\n\r\n    /**\r\n     * Asks a particular agent to go to a destination. That destination is constrained by the navigation mesh\r\n     * @param index agent index returned by addAgent\r\n     * @param destination targeted world position\r\n     */\r\n    agentGoto(index: number, destination: Vector3): void {\r\n        this.recastCrowd.agentGoto(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));\r\n\r\n        // arm observer\r\n        const item = this.agents.indexOf(index);\r\n        if (item > -1) {\r\n            this._agentDestinationArmed[item] = true;\r\n            this._agentDestination[item].set(destination.x, destination.y, destination.z);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Teleport the agent to a new position\r\n     * @param index agent index returned by addAgent\r\n     * @param destination targeted world position\r\n     */\r\n    agentTeleport(index: number, destination: Vector3): void {\r\n        this.recastCrowd.agentTeleport(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));\r\n    }\r\n\r\n    /**\r\n     * Update agent parameters\r\n     * @param index agent index returned by addAgent\r\n     * @param parameters agent parameters\r\n     */\r\n    updateAgentParameters(index: number, parameters: IAgentParameters): void {\r\n        const agentParams = this.recastCrowd.getAgentParameters(index);\r\n\r\n        if (parameters.radius !== undefined) {\r\n            agentParams.radius = parameters.radius;\r\n        }\r\n        if (parameters.height !== undefined) {\r\n            agentParams.height = parameters.height;\r\n        }\r\n        if (parameters.maxAcceleration !== undefined) {\r\n            agentParams.maxAcceleration = parameters.maxAcceleration;\r\n        }\r\n        if (parameters.maxSpeed !== undefined) {\r\n            agentParams.maxSpeed = parameters.maxSpeed;\r\n        }\r\n        if (parameters.collisionQueryRange !== undefined) {\r\n            agentParams.collisionQueryRange = parameters.collisionQueryRange;\r\n        }\r\n        if (parameters.pathOptimizationRange !== undefined) {\r\n            agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\r\n        }\r\n        if (parameters.separationWeight !== undefined) {\r\n            agentParams.separationWeight = parameters.separationWeight;\r\n        }\r\n\r\n        this.recastCrowd.setAgentParameters(index, agentParams);\r\n    }\r\n\r\n    /**\r\n     * remove a particular agent previously created\r\n     * @param index agent index returned by addAgent\r\n     */\r\n    removeAgent(index: number): void {\r\n        this.recastCrowd.removeAgent(index);\r\n\r\n        const item = this.agents.indexOf(index);\r\n        if (item > -1) {\r\n            this.agents.splice(item, 1);\r\n            this.transforms.splice(item, 1);\r\n            this.reachRadii.splice(item, 1);\r\n            this._agentDestinationArmed.splice(item, 1);\r\n            this._agentDestination.splice(item, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get the list of all agents attached to this crowd\r\n     * @returns list of agent indices\r\n     */\r\n    getAgents(): number[] {\r\n        return this.agents;\r\n    }\r\n\r\n    /**\r\n     * Tick update done by the Scene. Agent position/velocity/acceleration is updated by this function\r\n     * @param deltaTime in seconds\r\n     */\r\n    update(deltaTime: number): void {\r\n        // update obstacles\r\n        this.bjsRECASTPlugin.navMesh.update();\r\n\r\n        if (deltaTime <= Epsilon) {\r\n            return;\r\n        }\r\n        // update crowd\r\n        const timeStep = this.bjsRECASTPlugin.getTimeStep();\r\n        const maxStepCount = this.bjsRECASTPlugin.getMaximumSubStepCount();\r\n        if (timeStep <= Epsilon) {\r\n            this.recastCrowd.update(deltaTime);\r\n        } else {\r\n            let iterationCount = Math.floor(deltaTime / timeStep);\r\n            if (maxStepCount && iterationCount > maxStepCount) {\r\n                iterationCount = maxStepCount;\r\n            }\r\n            if (iterationCount < 1) {\r\n                iterationCount = 1;\r\n            }\r\n\r\n            const step = deltaTime / iterationCount;\r\n            for (let i = 0; i < iterationCount; i++) {\r\n                this.recastCrowd.update(step);\r\n            }\r\n        }\r\n\r\n        // update transforms\r\n        for (let index = 0; index < this.agents.length; index++) {\r\n            // update transform position\r\n            const agentIndex = this.agents[index];\r\n            const agentPosition = this.getAgentPosition(agentIndex);\r\n            this.transforms[index].position = agentPosition;\r\n            // check agent reach destination\r\n            if (this._agentDestinationArmed[index]) {\r\n                const dx = agentPosition.x - this._agentDestination[index].x;\r\n                const dz = agentPosition.z - this._agentDestination[index].z;\r\n                const radius = this.reachRadii[index];\r\n                const groundY = this._agentDestination[index].y - this.reachRadii[index];\r\n                const ceilingY = this._agentDestination[index].y + this.reachRadii[index];\r\n                const distanceXZSquared = dx * dx + dz * dz;\r\n                if (agentPosition.y > groundY && agentPosition.y < ceilingY && distanceXZSquared < radius * radius) {\r\n                    this.onReachTargetObservable.notifyObservers({ agentIndex: agentIndex, destination: this._agentDestination[index] });\r\n                    this._agentDestinationArmed[index] = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\r\n     * The queries will try to find a solution within those bounds\r\n     * default is (1,1,1)\r\n     * @param extent x,y,z value that define the extent around the queries point of reference\r\n     */\r\n    setDefaultQueryExtent(extent: Vector3): void {\r\n        const ext = new this.bjsRECASTPlugin.bjsRECAST.Vec3(extent.x, extent.y, extent.z);\r\n        this.recastCrowd.setDefaultQueryExtent(ext);\r\n    }\r\n\r\n    /**\r\n     * Get the Bounding box extent specified by setDefaultQueryExtent\r\n     * @returns the box extent values\r\n     */\r\n    getDefaultQueryExtent(): Vector3 {\r\n        const p = this.recastCrowd.getDefaultQueryExtent();\r\n        return new Vector3(p.x, p.y, p.z);\r\n    }\r\n\r\n    /**\r\n     * Get the Bounding box extent result specified by setDefaultQueryExtent\r\n     * @param result output the box extent values\r\n     */\r\n    getDefaultQueryExtentToRef(result: Vector3): void {\r\n        const p = this.recastCrowd.getDefaultQueryExtent();\r\n        result.set(p.x, p.y, p.z);\r\n    }\r\n\r\n    /**\r\n     * Get the next corner points composing the path (max 4 points)\r\n     * @param index agent index returned by addAgent\r\n     * @returns array containing world position composing the path\r\n     */\r\n    getCorners(index: number): Vector3[] {\r\n        let pt: number;\r\n        const navPath = this.recastCrowd.getCorners(index);\r\n        const pointCount = navPath.getPointCount();\r\n        const positions = [];\r\n        for (pt = 0; pt < pointCount; pt++) {\r\n            const p = navPath.getPoint(pt);\r\n            positions.push(new Vector3(p.x, p.y, p.z));\r\n        }\r\n        return positions;\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    dispose(): void {\r\n        this.recastCrowd.destroy();\r\n        this._scene.onBeforeAnimationsObservable.remove(this._onBeforeAnimationsObserver);\r\n        this._onBeforeAnimationsObserver = null;\r\n        this.onReachTargetObservable.clear();\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}