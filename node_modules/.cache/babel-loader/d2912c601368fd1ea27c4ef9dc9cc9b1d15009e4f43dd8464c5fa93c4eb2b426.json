{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { BaseCameraPointersInput } from \"../../Cameras/Inputs/BaseCameraPointersInput.js\";\n/**\n * Manage the pointers inputs to control an follow camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class FollowCameraPointersInput extends BaseCameraPointersInput {\n  constructor() {\n    super(...arguments);\n    /**\n     * Defines the pointer angular sensibility along the X axis or how fast is\n     * the camera rotating.\n     * A negative number will reverse the axis direction.\n     */\n    this.angularSensibilityX = 1;\n    /**\n     * Defines the pointer angular sensibility along the Y axis or how fast is\n     * the camera rotating.\n     * A negative number will reverse the axis direction.\n     */\n    this.angularSensibilityY = 1;\n    /**\n     * Defines the pointer pinch precision or how fast is the camera zooming.\n     * A negative number will reverse the axis direction.\n     */\n    this.pinchPrecision = 10000.0;\n    /**\n     * pinchDeltaPercentage will be used instead of pinchPrecision if different\n     * from 0.\n     * It defines the percentage of current camera.radius to use as delta when\n     * pinch zoom is used.\n     */\n    this.pinchDeltaPercentage = 0;\n    /**\n     * Pointer X axis controls zoom. (X axis modifies camera.radius value.)\n     */\n    this.axisXControlRadius = false;\n    /**\n     * Pointer X axis controls height. (X axis modifies camera.heightOffset value.)\n     */\n    this.axisXControlHeight = false;\n    /**\n     * Pointer X axis controls angle. (X axis modifies camera.rotationOffset value.)\n     */\n    this.axisXControlRotation = true;\n    /**\n     * Pointer Y axis controls zoom. (Y axis modifies camera.radius value.)\n     */\n    this.axisYControlRadius = false;\n    /**\n     * Pointer Y axis controls height. (Y axis modifies camera.heightOffset value.)\n     */\n    this.axisYControlHeight = true;\n    /**\n     * Pointer Y axis controls angle. (Y axis modifies camera.rotationOffset value.)\n     */\n    this.axisYControlRotation = false;\n    /**\n     * Pinch controls zoom. (Pinch modifies camera.radius value.)\n     */\n    this.axisPinchControlRadius = true;\n    /**\n     * Pinch controls height. (Pinch modifies camera.heightOffset value.)\n     */\n    this.axisPinchControlHeight = false;\n    /**\n     * Pinch controls angle. (Pinch modifies camera.rotationOffset value.)\n     */\n    this.axisPinchControlRotation = false;\n    /**\n     * Log error messages if basic misconfiguration has occurred.\n     */\n    this.warningEnable = true;\n    /* Check for obvious misconfiguration. */\n    this._warningCounter = 0;\n  }\n  /**\n   * Gets the class name of the current input.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"FollowCameraPointersInput\";\n  }\n  onTouch(pointA, offsetX, offsetY) {\n    this._warning();\n    if (this.axisXControlRotation) {\n      this.camera.rotationOffset += offsetX / this.angularSensibilityX;\n    } else if (this.axisYControlRotation) {\n      this.camera.rotationOffset += offsetY / this.angularSensibilityX;\n    }\n    if (this.axisXControlHeight) {\n      this.camera.heightOffset += offsetX / this.angularSensibilityY;\n    } else if (this.axisYControlHeight) {\n      this.camera.heightOffset += offsetY / this.angularSensibilityY;\n    }\n    if (this.axisXControlRadius) {\n      this.camera.radius -= offsetX / this.angularSensibilityY;\n    } else if (this.axisYControlRadius) {\n      this.camera.radius -= offsetY / this.angularSensibilityY;\n    }\n  }\n  onMultiTouch(pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {\n    if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\n      // First time this method is called for new pinch.\n      // Next time this is called there will be a\n      // previousPinchSquaredDistance and pinchSquaredDistance to compare.\n      return;\n    }\n    if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\n      // Last time this method is called at the end of a pinch.\n      return;\n    }\n    let pinchDelta = (pinchSquaredDistance - previousPinchSquaredDistance) / (this.pinchPrecision * (this.angularSensibilityX + this.angularSensibilityY) / 2);\n    if (this.pinchDeltaPercentage) {\n      pinchDelta *= 0.01 * this.pinchDeltaPercentage;\n      if (this.axisPinchControlRotation) {\n        this.camera.rotationOffset += pinchDelta * this.camera.rotationOffset;\n      }\n      if (this.axisPinchControlHeight) {\n        this.camera.heightOffset += pinchDelta * this.camera.heightOffset;\n      }\n      if (this.axisPinchControlRadius) {\n        this.camera.radius -= pinchDelta * this.camera.radius;\n      }\n    } else {\n      if (this.axisPinchControlRotation) {\n        this.camera.rotationOffset += pinchDelta;\n      }\n      if (this.axisPinchControlHeight) {\n        this.camera.heightOffset += pinchDelta;\n      }\n      if (this.axisPinchControlRadius) {\n        this.camera.radius -= pinchDelta;\n      }\n    }\n  }\n  _warning() {\n    if (!this.warningEnable || this._warningCounter++ % 100 !== 0) {\n      return;\n    }\n    const warn = \"It probably only makes sense to control ONE camera \" + \"property with each pointer axis. Set 'warningEnable = false' \" + \"if you are sure. Currently enabled: \";\n    console.assert(this.axisXControlRotation + this.axisXControlHeight + this.axisXControlRadius <= 1, warn + \"axisXControlRotation: \" + this.axisXControlRotation + \", axisXControlHeight: \" + this.axisXControlHeight + \", axisXControlRadius: \" + this.axisXControlRadius);\n    console.assert(this.axisYControlRotation + this.axisYControlHeight + this.axisYControlRadius <= 1, warn + \"axisYControlRotation: \" + this.axisYControlRotation + \", axisYControlHeight: \" + this.axisYControlHeight + \", axisYControlRadius: \" + this.axisYControlRadius);\n    console.assert(this.axisPinchControlRotation + this.axisPinchControlHeight + this.axisPinchControlRadius <= 1, warn + \"axisPinchControlRotation: \" + this.axisPinchControlRotation + \", axisPinchControlHeight: \" + this.axisPinchControlHeight + \", axisPinchControlRadius: \" + this.axisPinchControlRadius);\n  }\n}\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"angularSensibilityX\", void 0);\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"angularSensibilityY\", void 0);\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"pinchPrecision\", void 0);\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"pinchDeltaPercentage\", void 0);\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"axisXControlRadius\", void 0);\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"axisXControlHeight\", void 0);\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"axisXControlRotation\", void 0);\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"axisYControlRadius\", void 0);\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"axisYControlHeight\", void 0);\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"axisYControlRotation\", void 0);\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"axisPinchControlRadius\", void 0);\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"axisPinchControlHeight\", void 0);\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"axisPinchControlRotation\", void 0);\nCameraInputTypes[\"FollowCameraPointersInput\"] = FollowCameraPointersInput;","map":{"version":3,"names":["serialize","CameraInputTypes","BaseCameraPointersInput","FollowCameraPointersInput","constructor","angularSensibilityX","angularSensibilityY","pinchPrecision","pinchDeltaPercentage","axisXControlRadius","axisXControlHeight","axisXControlRotation","axisYControlRadius","axisYControlHeight","axisYControlRotation","axisPinchControlRadius","axisPinchControlHeight","axisPinchControlRotation","warningEnable","_warningCounter","getClassName","onTouch","pointA","offsetX","offsetY","_warning","camera","rotationOffset","heightOffset","radius","onMultiTouch","pointB","previousPinchSquaredDistance","pinchSquaredDistance","previousMultiTouchPanPosition","multiTouchPanPosition","pinchDelta","warn","console","assert","__decorate"],"sources":["../../../../../dev/core/src/Cameras/Inputs/followCameraPointersInput.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { FollowCamera } from \"../../Cameras/followCamera\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { BaseCameraPointersInput } from \"../../Cameras/Inputs/BaseCameraPointersInput\";\r\nimport type { PointerTouch } from \"../../Events/pointerEvents\";\r\n\r\n/**\r\n * Manage the pointers inputs to control an follow camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FollowCameraPointersInput extends BaseCameraPointersInput {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FollowCamera;\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FollowCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility along the X axis or how fast is\r\n     * the camera rotating.\r\n     * A negative number will reverse the axis direction.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityX = 1;\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility along the Y axis or how fast is\r\n     * the camera rotating.\r\n     * A negative number will reverse the axis direction.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityY = 1;\r\n\r\n    /**\r\n     * Defines the pointer pinch precision or how fast is the camera zooming.\r\n     * A negative number will reverse the axis direction.\r\n     */\r\n    @serialize()\r\n    public pinchPrecision = 10000.0;\r\n\r\n    /**\r\n     * pinchDeltaPercentage will be used instead of pinchPrecision if different\r\n     * from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when\r\n     * pinch zoom is used.\r\n     */\r\n    @serialize()\r\n    public pinchDeltaPercentage = 0;\r\n\r\n    /**\r\n     * Pointer X axis controls zoom. (X axis modifies camera.radius value.)\r\n     */\r\n    @serialize()\r\n    public axisXControlRadius: boolean = false;\r\n\r\n    /**\r\n     * Pointer X axis controls height. (X axis modifies camera.heightOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisXControlHeight: boolean = false;\r\n\r\n    /**\r\n     * Pointer X axis controls angle. (X axis modifies camera.rotationOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisXControlRotation: boolean = true;\r\n\r\n    /**\r\n     * Pointer Y axis controls zoom. (Y axis modifies camera.radius value.)\r\n     */\r\n    @serialize()\r\n    public axisYControlRadius: boolean = false;\r\n\r\n    /**\r\n     * Pointer Y axis controls height. (Y axis modifies camera.heightOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisYControlHeight: boolean = true;\r\n\r\n    /**\r\n     * Pointer Y axis controls angle. (Y axis modifies camera.rotationOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisYControlRotation: boolean = false;\r\n\r\n    /**\r\n     * Pinch controls zoom. (Pinch modifies camera.radius value.)\r\n     */\r\n    @serialize()\r\n    public axisPinchControlRadius: boolean = true;\r\n\r\n    /**\r\n     * Pinch controls height. (Pinch modifies camera.heightOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisPinchControlHeight: boolean = false;\r\n\r\n    /**\r\n     * Pinch controls angle. (Pinch modifies camera.rotationOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisPinchControlRotation: boolean = false;\r\n\r\n    /**\r\n     * Log error messages if basic misconfiguration has occurred.\r\n     */\r\n    public warningEnable: boolean = true;\r\n\r\n    public onTouch(pointA: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {\r\n        this._warning();\r\n\r\n        if (this.axisXControlRotation) {\r\n            this.camera.rotationOffset += offsetX / this.angularSensibilityX;\r\n        } else if (this.axisYControlRotation) {\r\n            this.camera.rotationOffset += offsetY / this.angularSensibilityX;\r\n        }\r\n\r\n        if (this.axisXControlHeight) {\r\n            this.camera.heightOffset += offsetX / this.angularSensibilityY;\r\n        } else if (this.axisYControlHeight) {\r\n            this.camera.heightOffset += offsetY / this.angularSensibilityY;\r\n        }\r\n\r\n        if (this.axisXControlRadius) {\r\n            this.camera.radius -= offsetX / this.angularSensibilityY;\r\n        } else if (this.axisYControlRadius) {\r\n            this.camera.radius -= offsetY / this.angularSensibilityY;\r\n        }\r\n    }\r\n\r\n    public onMultiTouch(\r\n        pointA: Nullable<PointerTouch>,\r\n        pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {\r\n        if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\r\n            // First time this method is called for new pinch.\r\n            // Next time this is called there will be a\r\n            // previousPinchSquaredDistance and pinchSquaredDistance to compare.\r\n            return;\r\n        }\r\n        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\r\n            // Last time this method is called at the end of a pinch.\r\n            return;\r\n        }\r\n        let pinchDelta = (pinchSquaredDistance - previousPinchSquaredDistance) / ((this.pinchPrecision * (this.angularSensibilityX + this.angularSensibilityY)) / 2);\r\n\r\n        if (this.pinchDeltaPercentage) {\r\n            pinchDelta *= 0.01 * this.pinchDeltaPercentage;\r\n            if (this.axisPinchControlRotation) {\r\n                this.camera.rotationOffset += pinchDelta * this.camera.rotationOffset;\r\n            }\r\n            if (this.axisPinchControlHeight) {\r\n                this.camera.heightOffset += pinchDelta * this.camera.heightOffset;\r\n            }\r\n            if (this.axisPinchControlRadius) {\r\n                this.camera.radius -= pinchDelta * this.camera.radius;\r\n            }\r\n        } else {\r\n            if (this.axisPinchControlRotation) {\r\n                this.camera.rotationOffset += pinchDelta;\r\n            }\r\n\r\n            if (this.axisPinchControlHeight) {\r\n                this.camera.heightOffset += pinchDelta;\r\n            }\r\n\r\n            if (this.axisPinchControlRadius) {\r\n                this.camera.radius -= pinchDelta;\r\n            }\r\n        }\r\n    }\r\n\r\n    /* Check for obvious misconfiguration. */\r\n    private _warningCounter: number = 0;\r\n    private _warning(): void {\r\n        if (!this.warningEnable || this._warningCounter++ % 100 !== 0) {\r\n            return;\r\n        }\r\n        const warn =\r\n            \"It probably only makes sense to control ONE camera \" + \"property with each pointer axis. Set 'warningEnable = false' \" + \"if you are sure. Currently enabled: \";\r\n\r\n        console.assert(\r\n            <number>(<unknown>this.axisXControlRotation) + <number>(<unknown>this.axisXControlHeight) + <number>(<unknown>this.axisXControlRadius) <= 1,\r\n            warn + \"axisXControlRotation: \" + this.axisXControlRotation + \", axisXControlHeight: \" + this.axisXControlHeight + \", axisXControlRadius: \" + this.axisXControlRadius\r\n        );\r\n        console.assert(\r\n            <number>(<unknown>this.axisYControlRotation) + <number>(<unknown>this.axisYControlHeight) + <number>(<unknown>this.axisYControlRadius) <= 1,\r\n            warn + \"axisYControlRotation: \" + this.axisYControlRotation + \", axisYControlHeight: \" + this.axisYControlHeight + \", axisYControlRadius: \" + this.axisYControlRadius\r\n        );\r\n        console.assert(\r\n            <number>(<unknown>this.axisPinchControlRotation) + <number>(<unknown>this.axisPinchControlHeight) + <number>(<unknown>this.axisPinchControlRadius) <= 1,\r\n            warn +\r\n                \"axisPinchControlRotation: \" +\r\n                this.axisPinchControlRotation +\r\n                \", axisPinchControlHeight: \" +\r\n                this.axisPinchControlHeight +\r\n                \", axisPinchControlRadius: \" +\r\n                this.axisPinchControlRadius\r\n        );\r\n    }\r\n}\r\n(<any>CameraInputTypes)[\"FollowCameraPointersInput\"] = FollowCameraPointersInput;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}