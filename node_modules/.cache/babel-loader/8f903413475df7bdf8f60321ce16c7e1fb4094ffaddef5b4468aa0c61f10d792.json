{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Vector3, Matrix } from \"../../Maths/math.vector.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nlet planeIdProvider = 0;\n/**\n * The plane detector is used to detect planes in the real world when in AR\n * For more information see https://github.com/immersive-web/real-world-geometry/\n */\nexport class WebXRPlaneDetector extends WebXRAbstractFeature {\n  /**\n   * construct a new Plane Detector\n   * @param _xrSessionManager an instance of xr Session manager\n   * @param _options configuration to use when constructing this feature\n   */\n  constructor(_xrSessionManager, _options = {}) {\n    super(_xrSessionManager);\n    this._options = _options;\n    this._detectedPlanes = [];\n    this._enabled = false;\n    this._lastFrameDetected = new Set();\n    /**\n     * Observers registered here will be executed when a new plane was added to the session\n     */\n    this.onPlaneAddedObservable = new Observable();\n    /**\n     * Observers registered here will be executed when a plane is no longer detected in the session\n     */\n    this.onPlaneRemovedObservable = new Observable();\n    /**\n     * Observers registered here will be executed when an existing plane updates (for example - expanded)\n     * This can execute N times every frame\n     */\n    this.onPlaneUpdatedObservable = new Observable();\n    this.xrNativeFeatureName = \"plane-detection\";\n    if (this._xrSessionManager.session) {\n      this._init();\n    } else {\n      this._xrSessionManager.onXRSessionInit.addOnce(() => {\n        this._init();\n      });\n    }\n  }\n  /**\n   * detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    if (!this._options.doNotRemovePlanesOnSessionEnded) {\n      while (this._detectedPlanes.length) {\n        const toRemove = this._detectedPlanes.pop();\n        if (toRemove) {\n          this.onPlaneRemovedObservable.notifyObservers(toRemove);\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * Dispose this feature and all of the resources attached\n   */\n  dispose() {\n    super.dispose();\n    this.onPlaneAddedObservable.clear();\n    this.onPlaneRemovedObservable.clear();\n    this.onPlaneUpdatedObservable.clear();\n  }\n  /**\n   * Check if the needed objects are defined.\n   * This does not mean that the feature is enabled, but that the objects needed are well defined.\n   */\n  isCompatible() {\n    return typeof XRPlane !== \"undefined\";\n  }\n  /**\n   * Enable room capture mode.\n   * When enabled and supported by the system,\n   * the detectedPlanes array will be populated with the detected room boundaries\n   * @see https://immersive-web.github.io/real-world-geometry/plane-detection.html#dom-xrsession-initiateroomcapture\n   * @returns true if plane detection is enabled and supported. Will reject if not supported.\n   */\n  async initiateRoomCapture() {\n    if (this._xrSessionManager.session.initiateRoomCapture) {\n      return this._xrSessionManager.session.initiateRoomCapture();\n    }\n    return Promise.reject(\"initiateRoomCapture is not supported on this session\");\n  }\n  _onXRFrame(frame) {\n    var _a;\n    if (!this.attached || !this._enabled || !frame) {\n      return;\n    }\n    const detectedPlanes = frame.detectedPlanes || ((_a = frame.worldInformation) === null || _a === void 0 ? void 0 : _a.detectedPlanes);\n    if (detectedPlanes) {\n      // remove all planes that are not currently detected in the frame\n      for (let planeIdx = 0; planeIdx < this._detectedPlanes.length; planeIdx++) {\n        const plane = this._detectedPlanes[planeIdx];\n        if (!detectedPlanes.has(plane.xrPlane)) {\n          this._detectedPlanes.splice(planeIdx--, 1);\n          this.onPlaneRemovedObservable.notifyObservers(plane);\n        }\n      }\n      // now check for new ones\n      detectedPlanes.forEach(xrPlane => {\n        if (!this._lastFrameDetected.has(xrPlane)) {\n          const newPlane = {\n            id: planeIdProvider++,\n            xrPlane: xrPlane,\n            polygonDefinition: []\n          };\n          const plane = this._updatePlaneWithXRPlane(xrPlane, newPlane, frame);\n          this._detectedPlanes.push(plane);\n          this.onPlaneAddedObservable.notifyObservers(plane);\n        } else {\n          // updated?\n          if (xrPlane.lastChangedTime === this._xrSessionManager.currentTimestamp) {\n            const index = this._findIndexInPlaneArray(xrPlane);\n            const plane = this._detectedPlanes[index];\n            this._updatePlaneWithXRPlane(xrPlane, plane, frame);\n            this.onPlaneUpdatedObservable.notifyObservers(plane);\n          }\n        }\n      });\n      this._lastFrameDetected = detectedPlanes;\n    }\n  }\n  _init() {\n    const internalInit = () => {\n      this._enabled = true;\n      if (this._detectedPlanes.length) {\n        this._detectedPlanes.length = 0;\n      }\n    };\n    // Only supported by BabylonNative\n    if (!!this._xrSessionManager.isNative && !!this._options.preferredDetectorOptions && !!this._xrSessionManager.session.trySetPreferredPlaneDetectorOptions) {\n      this._xrSessionManager.session.trySetPreferredPlaneDetectorOptions(this._options.preferredDetectorOptions);\n    }\n    if (!this._xrSessionManager.session.updateWorldTrackingState) {\n      internalInit();\n      return;\n    }\n    this._xrSessionManager.session.updateWorldTrackingState({\n      planeDetectionState: {\n        enabled: true\n      }\n    });\n    internalInit();\n  }\n  _updatePlaneWithXRPlane(xrPlane, plane, xrFrame) {\n    plane.polygonDefinition = xrPlane.polygon.map(xrPoint => {\n      const rightHandedSystem = this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1;\n      return new Vector3(xrPoint.x, xrPoint.y, xrPoint.z * rightHandedSystem);\n    });\n    // matrix\n    const pose = xrFrame.getPose(xrPlane.planeSpace, this._xrSessionManager.referenceSpace);\n    if (pose) {\n      const mat = plane.transformationMatrix || new Matrix();\n      Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\n      if (!this._xrSessionManager.scene.useRightHandedSystem) {\n        mat.toggleModelMatrixHandInPlace();\n      }\n      plane.transformationMatrix = mat;\n      if (this._options.worldParentNode) {\n        mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\n      }\n    }\n    return plane;\n  }\n  /**\n   * avoiding using Array.find for global support.\n   * @param xrPlane the plane to find in the array\n   */\n  _findIndexInPlaneArray(xrPlane) {\n    for (let i = 0; i < this._detectedPlanes.length; ++i) {\n      if (this._detectedPlanes[i].xrPlane === xrPlane) {\n        return i;\n      }\n    }\n    return -1;\n  }\n}\n/**\n * The module's name\n */\nWebXRPlaneDetector.Name = WebXRFeatureName.PLANE_DETECTION;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRPlaneDetector.Version = 1;\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRPlaneDetector.Name, (xrSessionManager, options) => {\n  return () => new WebXRPlaneDetector(xrSessionManager, options);\n}, WebXRPlaneDetector.Version);","map":{"version":3,"names":["WebXRFeaturesManager","WebXRFeatureName","Observable","Vector3","Matrix","WebXRAbstractFeature","planeIdProvider","WebXRPlaneDetector","constructor","_xrSessionManager","_options","_detectedPlanes","_enabled","_lastFrameDetected","Set","onPlaneAddedObservable","onPlaneRemovedObservable","onPlaneUpdatedObservable","xrNativeFeatureName","session","_init","onXRSessionInit","addOnce","detach","doNotRemovePlanesOnSessionEnded","length","toRemove","pop","notifyObservers","dispose","clear","isCompatible","XRPlane","initiateRoomCapture","Promise","reject","_onXRFrame","frame","attached","detectedPlanes","_a","worldInformation","planeIdx","plane","has","xrPlane","splice","forEach","newPlane","id","polygonDefinition","_updatePlaneWithXRPlane","push","lastChangedTime","currentTimestamp","index","_findIndexInPlaneArray","internalInit","isNative","preferredDetectorOptions","trySetPreferredPlaneDetectorOptions","updateWorldTrackingState","planeDetectionState","enabled","xrFrame","polygon","map","xrPoint","rightHandedSystem","scene","useRightHandedSystem","x","y","z","pose","getPose","planeSpace","referenceSpace","mat","transformationMatrix","FromArrayToRef","transform","matrix","toggleModelMatrixHandInPlace","worldParentNode","multiplyToRef","getWorldMatrix","i","Name","PLANE_DETECTION","Version","AddWebXRFeature","xrSessionManager","options"],"sources":["../../../../../dev/core/src/XR/features/WebXRPlaneDetector.ts"],"sourcesContent":["import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\n\r\ndeclare const XRPlane: XRPlane;\r\n\r\n/**\r\n * Options used in the plane detector module\r\n */\r\nexport interface IWebXRPlaneDetectorOptions {\r\n    /**\r\n     * The node to use to transform the local results to world coordinates\r\n     */\r\n    worldParentNode?: TransformNode;\r\n    /**\r\n     * If set to true a reference of the created planes will be kept until the next session starts\r\n     * If not defined, planes will be removed from the array when the feature is detached or the session ended.\r\n     */\r\n    doNotRemovePlanesOnSessionEnded?: boolean;\r\n    /**\r\n     * Preferred detector configuration, not all preferred options will be supported by all platforms.\r\n     */\r\n    preferredDetectorOptions?: XRGeometryDetectorOptions;\r\n}\r\n\r\n/**\r\n * A babylon interface for a WebXR plane.\r\n * A Plane is actually a polygon, built from N points in space\r\n *\r\n * Supported in chrome 79, not supported in canary 81 ATM\r\n */\r\nexport interface IWebXRPlane {\r\n    /**\r\n     * a babylon-assigned ID for this polygon\r\n     */\r\n    id: number;\r\n    /**\r\n     * an array of vector3 points in babylon space. right/left hand system is taken into account.\r\n     */\r\n    polygonDefinition: Array<Vector3>;\r\n    /**\r\n     * A transformation matrix to apply on the mesh that will be built using the polygonDefinition\r\n     * Local vs. World are decided if worldParentNode was provided or not in the options when constructing the module\r\n     */\r\n    transformationMatrix: Matrix;\r\n    /**\r\n     * the native xr-plane object\r\n     */\r\n    xrPlane: XRPlane;\r\n}\r\n\r\nlet planeIdProvider = 0;\r\n\r\n/**\r\n * The plane detector is used to detect planes in the real world when in AR\r\n * For more information see https://github.com/immersive-web/real-world-geometry/\r\n */\r\nexport class WebXRPlaneDetector extends WebXRAbstractFeature {\r\n    private _detectedPlanes: Array<IWebXRPlane> = [];\r\n    private _enabled: boolean = false;\r\n    private _lastFrameDetected: XRPlaneSet = new Set();\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.PLANE_DETECTION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Observers registered here will be executed when a new plane was added to the session\r\n     */\r\n    public onPlaneAddedObservable: Observable<IWebXRPlane> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed when a plane is no longer detected in the session\r\n     */\r\n    public onPlaneRemovedObservable: Observable<IWebXRPlane> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed when an existing plane updates (for example - expanded)\r\n     * This can execute N times every frame\r\n     */\r\n    public onPlaneUpdatedObservable: Observable<IWebXRPlane> = new Observable();\r\n\r\n    /**\r\n     * construct a new Plane Detector\r\n     * @param _xrSessionManager an instance of xr Session manager\r\n     * @param _options configuration to use when constructing this feature\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private _options: IWebXRPlaneDetectorOptions = {}) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"plane-detection\";\r\n        if (this._xrSessionManager.session) {\r\n            this._init();\r\n        } else {\r\n            this._xrSessionManager.onXRSessionInit.addOnce(() => {\r\n                this._init();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._options.doNotRemovePlanesOnSessionEnded) {\r\n            while (this._detectedPlanes.length) {\r\n                const toRemove = this._detectedPlanes.pop();\r\n                if (toRemove) {\r\n                    this.onPlaneRemovedObservable.notifyObservers(toRemove);\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this.onPlaneAddedObservable.clear();\r\n        this.onPlaneRemovedObservable.clear();\r\n        this.onPlaneUpdatedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Check if the needed objects are defined.\r\n     * This does not mean that the feature is enabled, but that the objects needed are well defined.\r\n     */\r\n    public isCompatible(): boolean {\r\n        return typeof XRPlane !== \"undefined\";\r\n    }\r\n\r\n    /**\r\n     * Enable room capture mode.\r\n     * When enabled and supported by the system,\r\n     * the detectedPlanes array will be populated with the detected room boundaries\r\n     * @see https://immersive-web.github.io/real-world-geometry/plane-detection.html#dom-xrsession-initiateroomcapture\r\n     * @returns true if plane detection is enabled and supported. Will reject if not supported.\r\n     */\r\n    public async initiateRoomCapture(): Promise<void> {\r\n        if (this._xrSessionManager.session.initiateRoomCapture) {\r\n            return this._xrSessionManager.session.initiateRoomCapture();\r\n        }\r\n        return Promise.reject(\"initiateRoomCapture is not supported on this session\");\r\n    }\r\n\r\n    protected _onXRFrame(frame: XRFrame) {\r\n        if (!this.attached || !this._enabled || !frame) {\r\n            return;\r\n        }\r\n\r\n        const detectedPlanes = frame.detectedPlanes || frame.worldInformation?.detectedPlanes;\r\n        if (detectedPlanes) {\r\n            // remove all planes that are not currently detected in the frame\r\n            for (let planeIdx = 0; planeIdx < this._detectedPlanes.length; planeIdx++) {\r\n                const plane = this._detectedPlanes[planeIdx];\r\n                if (!detectedPlanes.has(plane.xrPlane)) {\r\n                    this._detectedPlanes.splice(planeIdx--, 1);\r\n                    this.onPlaneRemovedObservable.notifyObservers(plane);\r\n                }\r\n            }\r\n\r\n            // now check for new ones\r\n            detectedPlanes.forEach((xrPlane) => {\r\n                if (!this._lastFrameDetected.has(xrPlane)) {\r\n                    const newPlane: Partial<IWebXRPlane> = {\r\n                        id: planeIdProvider++,\r\n                        xrPlane: xrPlane,\r\n                        polygonDefinition: [],\r\n                    };\r\n                    const plane = this._updatePlaneWithXRPlane(xrPlane, newPlane, frame);\r\n                    this._detectedPlanes.push(plane);\r\n                    this.onPlaneAddedObservable.notifyObservers(plane);\r\n                } else {\r\n                    // updated?\r\n                    if (xrPlane.lastChangedTime === this._xrSessionManager.currentTimestamp) {\r\n                        const index = this._findIndexInPlaneArray(xrPlane);\r\n                        const plane = this._detectedPlanes[index];\r\n                        this._updatePlaneWithXRPlane(xrPlane, plane, frame);\r\n                        this.onPlaneUpdatedObservable.notifyObservers(plane);\r\n                    }\r\n                }\r\n            });\r\n            this._lastFrameDetected = detectedPlanes;\r\n        }\r\n    }\r\n\r\n    private _init() {\r\n        const internalInit = () => {\r\n            this._enabled = true;\r\n            if (this._detectedPlanes.length) {\r\n                this._detectedPlanes.length = 0;\r\n            }\r\n        };\r\n\r\n        // Only supported by BabylonNative\r\n        if (!!this._xrSessionManager.isNative && !!this._options.preferredDetectorOptions && !!this._xrSessionManager.session.trySetPreferredPlaneDetectorOptions) {\r\n            this._xrSessionManager.session.trySetPreferredPlaneDetectorOptions(this._options.preferredDetectorOptions);\r\n        }\r\n\r\n        if (!this._xrSessionManager.session.updateWorldTrackingState) {\r\n            internalInit();\r\n            return;\r\n        }\r\n        this._xrSessionManager.session.updateWorldTrackingState({ planeDetectionState: { enabled: true } });\r\n        internalInit();\r\n    }\r\n\r\n    private _updatePlaneWithXRPlane(xrPlane: XRPlane, plane: Partial<IWebXRPlane>, xrFrame: XRFrame): IWebXRPlane {\r\n        plane.polygonDefinition = xrPlane.polygon.map((xrPoint) => {\r\n            const rightHandedSystem = this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1;\r\n            return new Vector3(xrPoint.x, xrPoint.y, xrPoint.z * rightHandedSystem);\r\n        });\r\n        // matrix\r\n        const pose = xrFrame.getPose(xrPlane.planeSpace, this._xrSessionManager.referenceSpace);\r\n        if (pose) {\r\n            const mat = plane.transformationMatrix || new Matrix();\r\n            Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\r\n            if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                mat.toggleModelMatrixHandInPlace();\r\n            }\r\n            plane.transformationMatrix = mat;\r\n            if (this._options.worldParentNode) {\r\n                mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\r\n            }\r\n        }\r\n\r\n        return <IWebXRPlane>plane;\r\n    }\r\n\r\n    /**\r\n     * avoiding using Array.find for global support.\r\n     * @param xrPlane the plane to find in the array\r\n     */\r\n    private _findIndexInPlaneArray(xrPlane: XRPlane) {\r\n        for (let i = 0; i < this._detectedPlanes.length; ++i) {\r\n            if (this._detectedPlanes[i].xrPlane === xrPlane) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRPlaneDetector.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRPlaneDetector(xrSessionManager, options);\r\n    },\r\n    WebXRPlaneDetector.Version\r\n);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}