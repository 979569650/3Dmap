{"ast":null,"code":"import { PointerInfoPre, PointerInfo, PointerEventTypes } from \"../Events/pointerEvents.js\";\nimport { AbstractActionManager } from \"../Actions/abstractActionManager.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { Vector2, Matrix } from \"../Maths/math.vector.js\";\nimport { ActionEvent } from \"../Actions/actionEvent.js\";\nimport { KeyboardEventTypes, KeyboardInfoPre, KeyboardInfo } from \"../Events/keyboardEvents.js\";\nimport { DeviceType, PointerInput } from \"../DeviceInput/InputDevices/deviceEnums.js\";\nimport { DeviceSourceManager } from \"../DeviceInput/InputDevices/deviceSourceManager.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n/** @internal */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nclass _ClickInfo {\n  constructor() {\n    this._singleClick = false;\n    this._doubleClick = false;\n    this._hasSwiped = false;\n    this._ignore = false;\n  }\n  get singleClick() {\n    return this._singleClick;\n  }\n  get doubleClick() {\n    return this._doubleClick;\n  }\n  get hasSwiped() {\n    return this._hasSwiped;\n  }\n  get ignore() {\n    return this._ignore;\n  }\n  set singleClick(b) {\n    this._singleClick = b;\n  }\n  set doubleClick(b) {\n    this._doubleClick = b;\n  }\n  set hasSwiped(b) {\n    this._hasSwiped = b;\n  }\n  set ignore(b) {\n    this._ignore = b;\n  }\n}\n/**\n * Class used to manage all inputs for the scene.\n */\nexport class InputManager {\n  /**\n   * Creates a new InputManager\n   * @param scene - defines the hosting scene\n   */\n  constructor(scene) {\n    /** This is a defensive check to not allow control attachment prior to an already active one. If already attached, previous control is unattached before attaching the new one. */\n    this._alreadyAttached = false;\n    this._meshPickProceed = false;\n    this._currentPickResult = null;\n    this._previousPickResult = null;\n    this._totalPointersPressed = 0;\n    this._doubleClickOccured = false;\n    this._isSwiping = false;\n    this._swipeButtonPressed = -1;\n    this._skipPointerTap = false;\n    this._isMultiTouchGesture = false;\n    this._pointerX = 0;\n    this._pointerY = 0;\n    this._startingPointerPosition = new Vector2(0, 0);\n    this._previousStartingPointerPosition = new Vector2(0, 0);\n    this._startingPointerTime = 0;\n    this._previousStartingPointerTime = 0;\n    this._pointerCaptures = {};\n    this._meshUnderPointerId = {};\n    this._movePointerInfo = null;\n    this._cameraObserverCount = 0;\n    this._delayedClicks = [null, null, null, null, null];\n    this._deviceSourceManager = null;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    if (!this._scene) {\n      return;\n    }\n  }\n  /**\n   * Gets the mesh that is currently under the pointer\n   * @returns Mesh that the pointer is pointer is hovering over\n   */\n  get meshUnderPointer() {\n    if (this._movePointerInfo) {\n      // Because _pointerOverMesh is populated as part of _pickMove, we need to force a pick to update it.\n      // Calling _pickMove calls _setCursorAndPointerOverMesh which calls setPointerOverMesh\n      this._movePointerInfo._generatePickInfo();\n      // Once we have what we need, we can clear _movePointerInfo because we don't need it anymore\n      this._movePointerInfo = null;\n    }\n    return this._pointerOverMesh;\n  }\n  /**\n   * When using more than one pointer (for example in XR) you can get the mesh under the specific pointer\n   * @param pointerId - the pointer id to use\n   * @returns The mesh under this pointer id or null if not found\n   */\n  getMeshUnderPointerByPointerId(pointerId) {\n    return this._meshUnderPointerId[pointerId] || null;\n  }\n  /**\n   * Gets the pointer coordinates in 2D without any translation (ie. straight out of the pointer event)\n   * @returns Vector with X/Y values directly from pointer event\n   */\n  get unTranslatedPointer() {\n    return new Vector2(this._unTranslatedPointerX, this._unTranslatedPointerY);\n  }\n  /**\n   * Gets or sets the current on-screen X position of the pointer\n   * @returns Translated X with respect to screen\n   */\n  get pointerX() {\n    return this._pointerX;\n  }\n  set pointerX(value) {\n    this._pointerX = value;\n  }\n  /**\n   * Gets or sets the current on-screen Y position of the pointer\n   * @returns Translated Y with respect to screen\n   */\n  get pointerY() {\n    return this._pointerY;\n  }\n  set pointerY(value) {\n    this._pointerY = value;\n  }\n  _updatePointerPosition(evt) {\n    const canvasRect = this._scene.getEngine().getInputElementClientRect();\n    if (!canvasRect) {\n      return;\n    }\n    this._pointerX = evt.clientX - canvasRect.left;\n    this._pointerY = evt.clientY - canvasRect.top;\n    this._unTranslatedPointerX = this._pointerX;\n    this._unTranslatedPointerY = this._pointerY;\n  }\n  _processPointerMove(pickResult, evt) {\n    const scene = this._scene;\n    const engine = scene.getEngine();\n    const canvas = engine.getInputElement();\n    if (canvas) {\n      canvas.tabIndex = engine.canvasTabIndex;\n      // Restore pointer\n      if (!scene.doNotHandleCursors) {\n        canvas.style.cursor = scene.defaultCursor;\n      }\n    }\n    this._setCursorAndPointerOverMesh(pickResult, evt, scene);\n    for (const step of scene._pointerMoveStage) {\n      // If _pointerMoveState is defined, we have an active spriteManager and can't use Lazy Picking\n      // Therefore, we need to force a pick to update the pickResult\n      pickResult = pickResult || this._pickMove(evt);\n      const isMeshPicked = (pickResult === null || pickResult === void 0 ? void 0 : pickResult.pickedMesh) ? true : false;\n      pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, isMeshPicked, canvas);\n    }\n    const type = evt.inputIndex >= PointerInput.MouseWheelX && evt.inputIndex <= PointerInput.MouseWheelZ ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE;\n    if (scene.onPointerMove) {\n      // Because of lazy picking, we need to force a pick to update the pickResult\n      pickResult = pickResult || this._pickMove(evt);\n      scene.onPointerMove(evt, pickResult, type);\n    }\n    let pointerInfo;\n    if (pickResult) {\n      pointerInfo = new PointerInfo(type, evt, pickResult);\n      this._setRayOnPointerInfo(pickResult, evt);\n    } else {\n      pointerInfo = new PointerInfo(type, evt, null, this);\n      this._movePointerInfo = pointerInfo;\n    }\n    if (scene.onPointerObservable.hasObservers()) {\n      scene.onPointerObservable.notifyObservers(pointerInfo, type);\n    }\n  }\n  // Pointers handling\n  /** @internal */\n  _setRayOnPointerInfo(pickInfo, event) {\n    const scene = this._scene;\n    if (pickInfo && scene._pickingAvailable) {\n      if (!pickInfo.ray) {\n        pickInfo.ray = scene.createPickingRay(event.offsetX, event.offsetY, Matrix.Identity(), scene.activeCamera);\n      }\n    }\n  }\n  /** @internal */\n  _addCameraPointerObserver(observer, mask) {\n    this._cameraObserverCount++;\n    return this._scene.onPointerObservable.add(observer, mask);\n  }\n  /** @internal */\n  _removeCameraPointerObserver(observer) {\n    this._cameraObserverCount--;\n    return this._scene.onPointerObservable.remove(observer);\n  }\n  _checkForPicking() {\n    return !!(this._scene.onPointerObservable.observers.length > this._cameraObserverCount || this._scene.onPointerPick);\n  }\n  _checkPrePointerObservable(pickResult, evt, type) {\n    const scene = this._scene;\n    const pi = new PointerInfoPre(type, evt, this._unTranslatedPointerX, this._unTranslatedPointerY);\n    if (pickResult) {\n      pi.originalPickingInfo = pickResult;\n      pi.ray = pickResult.ray;\n      if (pickResult.originMesh) {\n        pi.nearInteractionPickingInfo = pickResult;\n      }\n    }\n    scene.onPrePointerObservable.notifyObservers(pi, type);\n    if (pi.skipOnPointerObservable) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  /** @internal */\n  _pickMove(evt) {\n    const scene = this._scene;\n    const pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerMovePredicate, scene.pointerMoveFastCheck, scene.cameraToUseForPointers, scene.pointerMoveTrianglePredicate);\n    this._setCursorAndPointerOverMesh(pickResult, evt, scene);\n    return pickResult;\n  }\n  _setCursorAndPointerOverMesh(pickResult, evt, scene) {\n    const engine = scene.getEngine();\n    const canvas = engine.getInputElement();\n    if (pickResult === null || pickResult === void 0 ? void 0 : pickResult.pickedMesh) {\n      this.setPointerOverMesh(pickResult.pickedMesh, evt.pointerId, pickResult, evt);\n      if (!scene.doNotHandleCursors && canvas && this._pointerOverMesh) {\n        const actionManager = this._pointerOverMesh._getActionManagerForTrigger();\n        if (actionManager && actionManager.hasPointerTriggers) {\n          canvas.style.cursor = actionManager.hoverCursor || scene.hoverCursor;\n        }\n      }\n    } else {\n      this.setPointerOverMesh(null, evt.pointerId, pickResult, evt);\n    }\n  }\n  /**\n   * Use this method to simulate a pointer move on a mesh\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n   * @param pickResult - pickingInfo of the object wished to simulate pointer event on\n   * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n   */\n  simulatePointerMove(pickResult, pointerEventInit) {\n    const evt = new PointerEvent(\"pointermove\", pointerEventInit);\n    evt.inputIndex = PointerInput.Move;\n    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERMOVE)) {\n      return;\n    }\n    this._processPointerMove(pickResult, evt);\n  }\n  /**\n   * Use this method to simulate a pointer down on a mesh\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n   * @param pickResult - pickingInfo of the object wished to simulate pointer event on\n   * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n   */\n  simulatePointerDown(pickResult, pointerEventInit) {\n    const evt = new PointerEvent(\"pointerdown\", pointerEventInit);\n    evt.inputIndex = evt.button + 2;\n    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERDOWN)) {\n      return;\n    }\n    this._processPointerDown(pickResult, evt);\n  }\n  _processPointerDown(pickResult, evt) {\n    const scene = this._scene;\n    if (pickResult === null || pickResult === void 0 ? void 0 : pickResult.pickedMesh) {\n      this._pickedDownMesh = pickResult.pickedMesh;\n      const actionManager = pickResult.pickedMesh._getActionManagerForTrigger();\n      if (actionManager) {\n        if (actionManager.hasPickTriggers) {\n          actionManager.processTrigger(5, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\n          switch (evt.button) {\n            case 0:\n              actionManager.processTrigger(2, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\n              break;\n            case 1:\n              actionManager.processTrigger(4, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\n              break;\n            case 2:\n              actionManager.processTrigger(3, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\n              break;\n          }\n        }\n        if (actionManager.hasSpecificTrigger(8)) {\n          window.setTimeout(() => {\n            const pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, mesh => mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.actionManager && mesh.actionManager.hasSpecificTrigger(8) && mesh === this._pickedDownMesh, false, scene.cameraToUseForPointers);\n            if ((pickResult === null || pickResult === void 0 ? void 0 : pickResult.pickedMesh) && actionManager) {\n              if (this._totalPointersPressed !== 0 && Date.now() - this._startingPointerTime > InputManager.LongPressDelay && !this._isPointerSwiping()) {\n                this._startingPointerTime = 0;\n                actionManager.processTrigger(8, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n              }\n            }\n          }, InputManager.LongPressDelay);\n        }\n      }\n    } else {\n      for (const step of scene._pointerDownStage) {\n        pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt, false);\n      }\n    }\n    let pointerInfo;\n    const type = PointerEventTypes.POINTERDOWN;\n    if (pickResult) {\n      if (scene.onPointerDown) {\n        scene.onPointerDown(evt, pickResult, type);\n      }\n      pointerInfo = new PointerInfo(type, evt, pickResult);\n      this._setRayOnPointerInfo(pickResult, evt);\n    } else {\n      pointerInfo = new PointerInfo(type, evt, null, this);\n    }\n    if (scene.onPointerObservable.hasObservers()) {\n      scene.onPointerObservable.notifyObservers(pointerInfo, type);\n    }\n  }\n  /**\n   * @internal\n   * @internals Boolean if delta for pointer exceeds drag movement threshold\n   */\n  _isPointerSwiping() {\n    return this._isSwiping;\n  }\n  /**\n   * Use this method to simulate a pointer up on a mesh\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n   * @param pickResult - pickingInfo of the object wished to simulate pointer event on\n   * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n   * @param doubleTap - indicates that the pointer up event should be considered as part of a double click (false by default)\n   */\n  simulatePointerUp(pickResult, pointerEventInit, doubleTap) {\n    const evt = new PointerEvent(\"pointerup\", pointerEventInit);\n    evt.inputIndex = PointerInput.Move;\n    const clickInfo = new _ClickInfo();\n    if (doubleTap) {\n      clickInfo.doubleClick = true;\n    } else {\n      clickInfo.singleClick = true;\n    }\n    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERUP)) {\n      return;\n    }\n    this._processPointerUp(pickResult, evt, clickInfo);\n  }\n  _processPointerUp(pickResult, evt, clickInfo) {\n    const scene = this._scene;\n    if (pickResult === null || pickResult === void 0 ? void 0 : pickResult.pickedMesh) {\n      this._pickedUpMesh = pickResult.pickedMesh;\n      if (this._pickedDownMesh === this._pickedUpMesh) {\n        if (scene.onPointerPick) {\n          scene.onPointerPick(evt, pickResult);\n        }\n        if (clickInfo.singleClick && !clickInfo.ignore && scene.onPointerObservable.observers.length > this._cameraObserverCount) {\n          const type = PointerEventTypes.POINTERPICK;\n          const pi = new PointerInfo(type, evt, pickResult);\n          this._setRayOnPointerInfo(pickResult, evt);\n          scene.onPointerObservable.notifyObservers(pi, type);\n        }\n      }\n      const actionManager = pickResult.pickedMesh._getActionManagerForTrigger();\n      if (actionManager && !clickInfo.ignore) {\n        actionManager.processTrigger(7, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\n        if (!clickInfo.hasSwiped && clickInfo.singleClick) {\n          actionManager.processTrigger(1, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\n        }\n        const doubleClickActionManager = pickResult.pickedMesh._getActionManagerForTrigger(6);\n        if (clickInfo.doubleClick && doubleClickActionManager) {\n          doubleClickActionManager.processTrigger(6, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\n        }\n      }\n    } else {\n      if (!clickInfo.ignore) {\n        for (const step of scene._pointerUpStage) {\n          pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt, clickInfo.doubleClick);\n        }\n      }\n    }\n    if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) {\n      const pickedDownActionManager = this._pickedDownMesh._getActionManagerForTrigger(16);\n      if (pickedDownActionManager) {\n        pickedDownActionManager.processTrigger(16, ActionEvent.CreateNew(this._pickedDownMesh, evt));\n      }\n    }\n    if (!clickInfo.ignore) {\n      const pi = new PointerInfo(PointerEventTypes.POINTERUP, evt, pickResult);\n      // Set ray on picking info.  Note that this info will also be reused for the tap notification.\n      this._setRayOnPointerInfo(pickResult, evt);\n      scene.onPointerObservable.notifyObservers(pi, PointerEventTypes.POINTERUP);\n      if (scene.onPointerUp) {\n        scene.onPointerUp(evt, pickResult, PointerEventTypes.POINTERUP);\n      }\n      if (!clickInfo.hasSwiped && !this._skipPointerTap && !this._isMultiTouchGesture) {\n        let type = 0;\n        if (clickInfo.singleClick) {\n          type = PointerEventTypes.POINTERTAP;\n        } else if (clickInfo.doubleClick) {\n          type = PointerEventTypes.POINTERDOUBLETAP;\n        }\n        if (type) {\n          const pi = new PointerInfo(type, evt, pickResult);\n          if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {\n            scene.onPointerObservable.notifyObservers(pi, type);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)\n   * @param pointerId - defines the pointer id to use in a multi-touch scenario (0 by default)\n   * @returns true if the pointer was captured\n   */\n  isPointerCaptured(pointerId = 0) {\n    return this._pointerCaptures[pointerId];\n  }\n  /**\n   * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp\n   * @param attachUp - defines if you want to attach events to pointerup\n   * @param attachDown - defines if you want to attach events to pointerdown\n   * @param attachMove - defines if you want to attach events to pointermove\n   * @param elementToAttachTo - defines the target DOM element to attach to (will use the canvas by default)\n   */\n  attachControl(attachUp = true, attachDown = true, attachMove = true, elementToAttachTo = null) {\n    const scene = this._scene;\n    const engine = scene.getEngine();\n    if (!elementToAttachTo) {\n      elementToAttachTo = engine.getInputElement();\n    }\n    if (this._alreadyAttached) {\n      this.detachControl();\n    }\n    if (elementToAttachTo) {\n      this._alreadyAttachedTo = elementToAttachTo;\n    }\n    this._deviceSourceManager = new DeviceSourceManager(engine);\n    // Because this is only called from _initClickEvent, which is called in _onPointerUp, we'll use the pointerUpPredicate for the pick call\n    this._initActionManager = act => {\n      if (!this._meshPickProceed) {\n        const pickResult = scene.skipPointerUpPicking || scene._registeredActions === 0 && !this._checkForPicking() && !scene.onPointerUp ? null : scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerUpPredicate, scene.pointerUpFastCheck, scene.cameraToUseForPointers);\n        this._currentPickResult = pickResult;\n        if (pickResult) {\n          act = pickResult.hit && pickResult.pickedMesh ? pickResult.pickedMesh._getActionManagerForTrigger() : null;\n        }\n        this._meshPickProceed = true;\n      }\n      return act;\n    };\n    this._delayedSimpleClick = (btn, clickInfo, cb) => {\n      // double click delay is over and that no double click has been raised since, or the 2 consecutive keys pressed are different\n      if (Date.now() - this._previousStartingPointerTime > InputManager.DoubleClickDelay && !this._doubleClickOccured || btn !== this._previousButtonPressed) {\n        this._doubleClickOccured = false;\n        clickInfo.singleClick = true;\n        clickInfo.ignore = false;\n        // If we have a delayed click, we need to resolve the TAP event\n        if (this._delayedClicks[btn]) {\n          const evt = this._delayedClicks[btn].evt;\n          const type = PointerEventTypes.POINTERTAP;\n          const pi = new PointerInfo(type, evt, this._currentPickResult);\n          if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {\n            scene.onPointerObservable.notifyObservers(pi, type);\n          }\n          // Clear the delayed click\n          this._delayedClicks[btn] = null;\n        }\n      }\n    };\n    this._initClickEvent = (obs1, obs2, evt, cb) => {\n      var _a, _b;\n      const clickInfo = new _ClickInfo();\n      this._currentPickResult = null;\n      let act = null;\n      let checkPicking = obs1.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs2.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs1.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\n      if (!checkPicking && AbstractActionManager) {\n        act = this._initActionManager(act, clickInfo);\n        if (act) {\n          checkPicking = act.hasPickTriggers;\n        }\n      }\n      let needToIgnoreNext = false;\n      if (checkPicking) {\n        const btn = evt.button;\n        clickInfo.hasSwiped = this._isPointerSwiping();\n        if (!clickInfo.hasSwiped) {\n          let checkSingleClickImmediately = !InputManager.ExclusiveDoubleClickMode;\n          if (!checkSingleClickImmediately) {\n            checkSingleClickImmediately = !obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) && !obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\n            if (checkSingleClickImmediately && !AbstractActionManager.HasSpecificTrigger(6)) {\n              act = this._initActionManager(act, clickInfo);\n              if (act) {\n                checkSingleClickImmediately = !act.hasSpecificTrigger(6);\n              }\n            }\n          }\n          if (checkSingleClickImmediately) {\n            // single click detected if double click delay is over or two different successive keys pressed without exclusive double click or no double click required\n            if (Date.now() - this._previousStartingPointerTime > InputManager.DoubleClickDelay || btn !== this._previousButtonPressed) {\n              clickInfo.singleClick = true;\n              cb(clickInfo, this._currentPickResult);\n              needToIgnoreNext = true;\n            }\n          }\n          // at least one double click is required to be check and exclusive double click is enabled\n          else {\n            // Queue up a delayed click, just in case this isn't a double click\n            // It should be noted that while this delayed event happens\n            // because of user input, it shouldn't be considered as a direct,\n            // timing-dependent result of that input.  It's meant to just fire the TAP event\n            const delayedClick = {\n              evt: evt,\n              clickInfo: clickInfo,\n              timeoutId: window.setTimeout(this._delayedSimpleClick.bind(this, btn, clickInfo, cb), InputManager.DoubleClickDelay)\n            };\n            this._delayedClicks[btn] = delayedClick;\n          }\n          let checkDoubleClick = obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\n          if (!checkDoubleClick && AbstractActionManager.HasSpecificTrigger(6)) {\n            act = this._initActionManager(act, clickInfo);\n            if (act) {\n              checkDoubleClick = act.hasSpecificTrigger(6);\n            }\n          }\n          if (checkDoubleClick) {\n            // two successive keys pressed are equal, double click delay is not over and double click has not just occurred\n            if (btn === this._previousButtonPressed && Date.now() - this._previousStartingPointerTime < InputManager.DoubleClickDelay && !this._doubleClickOccured) {\n              // pointer has not moved for 2 clicks, it's a double click\n              if (!clickInfo.hasSwiped && !this._isPointerSwiping()) {\n                this._previousStartingPointerTime = 0;\n                this._doubleClickOccured = true;\n                clickInfo.doubleClick = true;\n                clickInfo.ignore = false;\n                // If we have a pending click, we need to cancel it\n                if (InputManager.ExclusiveDoubleClickMode && this._delayedClicks[btn]) {\n                  clearTimeout((_a = this._delayedClicks[btn]) === null || _a === void 0 ? void 0 : _a.timeoutId);\n                  this._delayedClicks[btn] = null;\n                }\n                cb(clickInfo, this._currentPickResult);\n              }\n              // if the two successive clicks are too far, it's just two simple clicks\n              else {\n                this._doubleClickOccured = false;\n                this._previousStartingPointerTime = this._startingPointerTime;\n                this._previousStartingPointerPosition.x = this._startingPointerPosition.x;\n                this._previousStartingPointerPosition.y = this._startingPointerPosition.y;\n                this._previousButtonPressed = btn;\n                if (InputManager.ExclusiveDoubleClickMode) {\n                  // If we have a delayed click, we need to cancel it\n                  if (this._delayedClicks[btn]) {\n                    clearTimeout((_b = this._delayedClicks[btn]) === null || _b === void 0 ? void 0 : _b.timeoutId);\n                    this._delayedClicks[btn] = null;\n                  }\n                  cb(clickInfo, this._previousPickResult);\n                } else {\n                  cb(clickInfo, this._currentPickResult);\n                }\n              }\n              needToIgnoreNext = true;\n            }\n            // just the first click of the double has been raised\n            else {\n              this._doubleClickOccured = false;\n              this._previousStartingPointerTime = this._startingPointerTime;\n              this._previousStartingPointerPosition.x = this._startingPointerPosition.x;\n              this._previousStartingPointerPosition.y = this._startingPointerPosition.y;\n              this._previousButtonPressed = btn;\n            }\n          }\n        }\n      }\n      // Even if ExclusiveDoubleClickMode is true, we need to always handle\n      // up events at time of execution, unless we're explicitly ignoring them.\n      if (!needToIgnoreNext) {\n        cb(clickInfo, this._currentPickResult);\n      }\n    };\n    this._onPointerMove = evt => {\n      this._updatePointerPosition(evt);\n      // Check if pointer leaves DragMovementThreshold range to determine if swipe is occurring\n      if (!this._isSwiping && this._swipeButtonPressed !== -1) {\n        this._isSwiping = Math.abs(this._startingPointerPosition.x - this._pointerX) > InputManager.DragMovementThreshold || Math.abs(this._startingPointerPosition.y - this._pointerY) > InputManager.DragMovementThreshold;\n      }\n      // Because there's a race condition between pointermove and pointerlockchange events, we need to\n      // verify that the pointer is still locked after each pointermove event.\n      if (engine.isPointerLock) {\n        engine._verifyPointerLock();\n      }\n      // PreObservable support\n      if (this._checkPrePointerObservable(null, evt, evt.inputIndex >= PointerInput.MouseWheelX && evt.inputIndex <= PointerInput.MouseWheelZ ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE)) {\n        return;\n      }\n      if (!scene.cameraToUseForPointers && !scene.activeCamera) {\n        return;\n      }\n      if (scene.skipPointerMovePicking) {\n        this._processPointerMove(new PickingInfo(), evt);\n        return;\n      }\n      if (!scene.pointerMovePredicate) {\n        scene.pointerMovePredicate = mesh => mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (mesh.enablePointerMoveEvents || scene.constantlyUpdateMeshUnderPointer || mesh._getActionManagerForTrigger() !== null) && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\n      }\n      const pickResult = scene._registeredActions > 0 || scene.constantlyUpdateMeshUnderPointer ? this._pickMove(evt) : null;\n      this._processPointerMove(pickResult, evt);\n    };\n    this._onPointerDown = evt => {\n      var _a;\n      this._totalPointersPressed++;\n      this._pickedDownMesh = null;\n      this._meshPickProceed = false;\n      // If ExclusiveDoubleClickMode is true, we need to resolve any pending delayed clicks\n      if (InputManager.ExclusiveDoubleClickMode) {\n        for (let i = 0; i < this._delayedClicks.length; i++) {\n          if (this._delayedClicks[i]) {\n            // If the button that was pressed is the same as the one that was released,\n            // just clear the timer.  This will be resolved in the up event.\n            if (evt.button === i) {\n              clearTimeout((_a = this._delayedClicks[i]) === null || _a === void 0 ? void 0 : _a.timeoutId);\n            } else {\n              // Otherwise, we need to resolve the click\n              const clickInfo = this._delayedClicks[i].clickInfo;\n              this._doubleClickOccured = false;\n              clickInfo.singleClick = true;\n              clickInfo.ignore = false;\n              const prevEvt = this._delayedClicks[i].evt;\n              const type = PointerEventTypes.POINTERTAP;\n              const pi = new PointerInfo(type, prevEvt, this._currentPickResult);\n              if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {\n                scene.onPointerObservable.notifyObservers(pi, type);\n              }\n              // Clear the delayed click\n              this._delayedClicks[i] = null;\n            }\n          }\n        }\n      }\n      this._updatePointerPosition(evt);\n      if (this._swipeButtonPressed === -1) {\n        this._swipeButtonPressed = evt.button;\n      }\n      if (scene.preventDefaultOnPointerDown && elementToAttachTo) {\n        evt.preventDefault();\n        elementToAttachTo.focus();\n      }\n      this._startingPointerPosition.x = this._pointerX;\n      this._startingPointerPosition.y = this._pointerY;\n      this._startingPointerTime = Date.now();\n      // PreObservable support\n      if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOWN)) {\n        return;\n      }\n      if (!scene.cameraToUseForPointers && !scene.activeCamera) {\n        return;\n      }\n      this._pointerCaptures[evt.pointerId] = true;\n      if (!scene.pointerDownPredicate) {\n        scene.pointerDownPredicate = mesh => {\n          return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\n        };\n      }\n      // Meshes\n      this._pickedDownMesh = null;\n      let pickResult;\n      if (scene.skipPointerDownPicking || scene._registeredActions === 0 && !this._checkForPicking() && !scene.onPointerDown) {\n        pickResult = new PickingInfo();\n      } else {\n        pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerDownPredicate, scene.pointerDownFastCheck, scene.cameraToUseForPointers);\n      }\n      this._processPointerDown(pickResult, evt);\n    };\n    this._onPointerUp = evt => {\n      if (this._totalPointersPressed === 0) {\n        // We are attaching the pointer up to windows because of a bug in FF\n        return; // So we need to test it the pointer down was pressed before.\n      }\n\n      this._totalPointersPressed--;\n      this._pickedUpMesh = null;\n      this._meshPickProceed = false;\n      this._updatePointerPosition(evt);\n      if (scene.preventDefaultOnPointerUp && elementToAttachTo) {\n        evt.preventDefault();\n        elementToAttachTo.focus();\n      }\n      this._initClickEvent(scene.onPrePointerObservable, scene.onPointerObservable, evt, (clickInfo, pickResult) => {\n        // PreObservable support\n        if (scene.onPrePointerObservable.hasObservers()) {\n          this._skipPointerTap = false;\n          if (!clickInfo.ignore) {\n            if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERUP)) {\n              // If we're skipping the next observable, we need to reset the swipe state before returning\n              if (this._swipeButtonPressed === evt.button) {\n                this._isSwiping = false;\n                this._swipeButtonPressed = -1;\n              }\n              // If we're going to skip the POINTERUP, we need to reset the pointer capture\n              if (evt.buttons === 0) {\n                this._pointerCaptures[evt.pointerId] = false;\n              }\n              return;\n            }\n            if (!clickInfo.hasSwiped) {\n              if (clickInfo.singleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {\n                if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERTAP)) {\n                  this._skipPointerTap = true;\n                }\n              }\n              if (clickInfo.doubleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {\n                if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOUBLETAP)) {\n                  this._skipPointerTap = true;\n                }\n              }\n            }\n          }\n        }\n        // There should be a pointer captured at this point so if there isn't we should reset and return\n        if (!this._pointerCaptures[evt.pointerId]) {\n          if (this._swipeButtonPressed === evt.button) {\n            this._isSwiping = false;\n            this._swipeButtonPressed = -1;\n          }\n          return;\n        }\n        // Only release capture if all buttons are released\n        if (evt.buttons === 0) {\n          this._pointerCaptures[evt.pointerId] = false;\n        }\n        if (!scene.cameraToUseForPointers && !scene.activeCamera) {\n          return;\n        }\n        if (!scene.pointerUpPredicate) {\n          scene.pointerUpPredicate = mesh => {\n            return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\n          };\n        }\n        // Meshes\n        if (!this._meshPickProceed && (AbstractActionManager && AbstractActionManager.HasTriggers || this._checkForPicking() || scene.onPointerUp)) {\n          this._initActionManager(null, clickInfo);\n        }\n        if (!pickResult) {\n          pickResult = this._currentPickResult;\n        }\n        this._processPointerUp(pickResult, evt, clickInfo);\n        this._previousPickResult = this._currentPickResult;\n        if (this._swipeButtonPressed === evt.button) {\n          this._isSwiping = false;\n          this._swipeButtonPressed = -1;\n        }\n      });\n    };\n    this._onKeyDown = evt => {\n      const type = KeyboardEventTypes.KEYDOWN;\n      if (scene.onPreKeyboardObservable.hasObservers()) {\n        const pi = new KeyboardInfoPre(type, evt);\n        scene.onPreKeyboardObservable.notifyObservers(pi, type);\n        if (pi.skipOnKeyboardObservable) {\n          return;\n        }\n      }\n      if (scene.onKeyboardObservable.hasObservers()) {\n        const pi = new KeyboardInfo(type, evt);\n        scene.onKeyboardObservable.notifyObservers(pi, type);\n      }\n      if (scene.actionManager) {\n        scene.actionManager.processTrigger(14, ActionEvent.CreateNewFromScene(scene, evt));\n      }\n    };\n    this._onKeyUp = evt => {\n      const type = KeyboardEventTypes.KEYUP;\n      if (scene.onPreKeyboardObservable.hasObservers()) {\n        const pi = new KeyboardInfoPre(type, evt);\n        scene.onPreKeyboardObservable.notifyObservers(pi, type);\n        if (pi.skipOnKeyboardObservable) {\n          return;\n        }\n      }\n      if (scene.onKeyboardObservable.hasObservers()) {\n        const pi = new KeyboardInfo(type, evt);\n        scene.onKeyboardObservable.notifyObservers(pi, type);\n      }\n      if (scene.actionManager) {\n        scene.actionManager.processTrigger(15, ActionEvent.CreateNewFromScene(scene, evt));\n      }\n    };\n    // If a device connects that we can handle, wire up the observable\n    this._deviceSourceManager.onDeviceConnectedObservable.add(deviceSource => {\n      if (deviceSource.deviceType === DeviceType.Mouse) {\n        deviceSource.onInputChangedObservable.add(eventData => {\n          if (eventData.inputIndex === PointerInput.LeftClick || eventData.inputIndex === PointerInput.MiddleClick || eventData.inputIndex === PointerInput.RightClick || eventData.inputIndex === PointerInput.BrowserBack || eventData.inputIndex === PointerInput.BrowserForward) {\n            if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {\n              this._onPointerDown(eventData);\n            } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {\n              this._onPointerUp(eventData);\n            }\n          } else if (attachMove) {\n            if (eventData.inputIndex === PointerInput.Move) {\n              this._onPointerMove(eventData);\n            } else if (eventData.inputIndex === PointerInput.MouseWheelX || eventData.inputIndex === PointerInput.MouseWheelY || eventData.inputIndex === PointerInput.MouseWheelZ) {\n              this._onPointerMove(eventData);\n            }\n          }\n        });\n      } else if (deviceSource.deviceType === DeviceType.Touch) {\n        deviceSource.onInputChangedObservable.add(eventData => {\n          if (eventData.inputIndex === PointerInput.LeftClick) {\n            if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {\n              this._onPointerDown(eventData);\n              if (this._totalPointersPressed > 1) {\n                this._isMultiTouchGesture = true;\n              }\n            } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {\n              this._onPointerUp(eventData);\n              if (this._totalPointersPressed === 0) {\n                this._isMultiTouchGesture = false;\n              }\n            }\n          }\n          if (attachMove && eventData.inputIndex === PointerInput.Move) {\n            this._onPointerMove(eventData);\n          }\n        });\n      } else if (deviceSource.deviceType === DeviceType.Keyboard) {\n        deviceSource.onInputChangedObservable.add(eventData => {\n          if (eventData.type === \"keydown\") {\n            this._onKeyDown(eventData);\n          } else if (eventData.type === \"keyup\") {\n            this._onKeyUp(eventData);\n          }\n        });\n      }\n    });\n    this._alreadyAttached = true;\n  }\n  /**\n   * Detaches all event handlers\n   */\n  detachControl() {\n    if (this._alreadyAttached) {\n      this._deviceSourceManager.dispose();\n      this._deviceSourceManager = null;\n      // Cursor\n      if (this._alreadyAttachedTo && !this._scene.doNotHandleCursors) {\n        this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor;\n      }\n      this._alreadyAttached = false;\n      this._alreadyAttachedTo = null;\n    }\n  }\n  /**\n   * Force the value of meshUnderPointer\n   * @param mesh - defines the mesh to use\n   * @param pointerId - optional pointer id when using more than one pointer. Defaults to 0\n   * @param pickResult - optional pickingInfo data used to find mesh\n   * @param evt - optional pointer event\n   */\n  setPointerOverMesh(mesh, pointerId = 0, pickResult, evt) {\n    if (this._meshUnderPointerId[pointerId] === mesh && (!mesh || !mesh._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting)) {\n      return;\n    }\n    const underPointerMesh = this._meshUnderPointerId[pointerId];\n    let actionManager;\n    if (underPointerMesh) {\n      actionManager = underPointerMesh._getActionManagerForTrigger(10);\n      if (actionManager) {\n        actionManager.processTrigger(10, ActionEvent.CreateNew(underPointerMesh, evt, {\n          pointerId\n        }));\n      }\n    }\n    if (mesh) {\n      this._meshUnderPointerId[pointerId] = mesh;\n      this._pointerOverMesh = mesh;\n      actionManager = mesh._getActionManagerForTrigger(9);\n      if (actionManager) {\n        actionManager.processTrigger(9, ActionEvent.CreateNew(mesh, evt, {\n          pointerId,\n          pickResult\n        }));\n      }\n    } else {\n      delete this._meshUnderPointerId[pointerId];\n      this._pointerOverMesh = null;\n    }\n  }\n  /**\n   * Gets the mesh under the pointer\n   * @returns a Mesh or null if no mesh is under the pointer\n   */\n  getPointerOverMesh() {\n    return this.meshUnderPointer;\n  }\n  /**\n   * @param mesh - Mesh to invalidate\n   * @internal\n   */\n  _invalidateMesh(mesh) {\n    if (this._pointerOverMesh === mesh) {\n      this._pointerOverMesh = null;\n    }\n    if (this._pickedDownMesh === mesh) {\n      this._pickedDownMesh = null;\n    }\n    if (this._pickedUpMesh === mesh) {\n      this._pickedUpMesh = null;\n    }\n    for (const pointerId in this._meshUnderPointerId) {\n      if (this._meshUnderPointerId[pointerId] === mesh) {\n        delete this._meshUnderPointerId[pointerId];\n      }\n    }\n  }\n}\n/** The distance in pixel that you have to move to prevent some events */\nInputManager.DragMovementThreshold = 10; // in pixels\n/** Time in milliseconds to wait to raise long press events if button is still pressed */\nInputManager.LongPressDelay = 500; // in milliseconds\n/** Time in milliseconds with two consecutive clicks will be considered as a double click */\nInputManager.DoubleClickDelay = 300; // in milliseconds\n/**\n * This flag will modify the behavior so that, when true, a click will happen if and only if\n * another click DOES NOT happen within the DoubleClickDelay time frame.  If another click does\n * happen within that time frame, the first click will not fire an event and and a double click will occur.\n */\nInputManager.ExclusiveDoubleClickMode = false;","map":{"version":3,"names":["PointerInfoPre","PointerInfo","PointerEventTypes","AbstractActionManager","PickingInfo","Vector2","Matrix","ActionEvent","KeyboardEventTypes","KeyboardInfoPre","KeyboardInfo","DeviceType","PointerInput","DeviceSourceManager","EngineStore","_ClickInfo","constructor","_singleClick","_doubleClick","_hasSwiped","_ignore","singleClick","doubleClick","hasSwiped","ignore","b","InputManager","scene","_alreadyAttached","_meshPickProceed","_currentPickResult","_previousPickResult","_totalPointersPressed","_doubleClickOccured","_isSwiping","_swipeButtonPressed","_skipPointerTap","_isMultiTouchGesture","_pointerX","_pointerY","_startingPointerPosition","_previousStartingPointerPosition","_startingPointerTime","_previousStartingPointerTime","_pointerCaptures","_meshUnderPointerId","_movePointerInfo","_cameraObserverCount","_delayedClicks","_deviceSourceManager","_scene","LastCreatedScene","meshUnderPointer","_generatePickInfo","_pointerOverMesh","getMeshUnderPointerByPointerId","pointerId","unTranslatedPointer","_unTranslatedPointerX","_unTranslatedPointerY","pointerX","value","pointerY","_updatePointerPosition","evt","canvasRect","getEngine","getInputElementClientRect","clientX","left","clientY","top","_processPointerMove","pickResult","engine","canvas","getInputElement","tabIndex","canvasTabIndex","doNotHandleCursors","style","cursor","defaultCursor","_setCursorAndPointerOverMesh","step","_pointerMoveStage","_pickMove","isMeshPicked","pickedMesh","action","type","inputIndex","MouseWheelX","MouseWheelZ","POINTERWHEEL","POINTERMOVE","onPointerMove","pointerInfo","_setRayOnPointerInfo","onPointerObservable","hasObservers","notifyObservers","pickInfo","event","_pickingAvailable","ray","createPickingRay","offsetX","offsetY","Identity","activeCamera","_addCameraPointerObserver","observer","mask","add","_removeCameraPointerObserver","remove","_checkForPicking","observers","length","onPointerPick","_checkPrePointerObservable","pi","originalPickingInfo","originMesh","nearInteractionPickingInfo","onPrePointerObservable","skipOnPointerObservable","pick","pointerMovePredicate","pointerMoveFastCheck","cameraToUseForPointers","pointerMoveTrianglePredicate","setPointerOverMesh","actionManager","_getActionManagerForTrigger","hasPointerTriggers","hoverCursor","simulatePointerMove","pointerEventInit","PointerEvent","Move","simulatePointerDown","button","POINTERDOWN","_processPointerDown","_pickedDownMesh","hasPickTriggers","processTrigger","CreateNew","hasSpecificTrigger","window","setTimeout","mesh","isPickable","isVisible","isReady","Date","now","LongPressDelay","_isPointerSwiping","_pointerDownStage","onPointerDown","simulatePointerUp","doubleTap","clickInfo","POINTERUP","_processPointerUp","_pickedUpMesh","POINTERPICK","doubleClickActionManager","_pointerUpStage","pickedDownActionManager","onPointerUp","POINTERTAP","POINTERDOUBLETAP","hasSpecificMask","isPointerCaptured","attachControl","attachUp","attachDown","attachMove","elementToAttachTo","detachControl","_alreadyAttachedTo","_initActionManager","act","skipPointerUpPicking","_registeredActions","pointerUpPredicate","pointerUpFastCheck","hit","_delayedSimpleClick","btn","cb","DoubleClickDelay","_previousButtonPressed","_initClickEvent","obs1","obs2","checkPicking","needToIgnoreNext","checkSingleClickImmediately","ExclusiveDoubleClickMode","HasSpecificTrigger","delayedClick","timeoutId","bind","checkDoubleClick","clearTimeout","_a","x","y","_b","_onPointerMove","Math","abs","DragMovementThreshold","isPointerLock","_verifyPointerLock","skipPointerMovePicking","isEnabled","enablePointerMoveEvents","constantlyUpdateMeshUnderPointer","layerMask","_onPointerDown","i","prevEvt","preventDefaultOnPointerDown","preventDefault","focus","pointerDownPredicate","skipPointerDownPicking","pointerDownFastCheck","_onPointerUp","preventDefaultOnPointerUp","buttons","HasTriggers","_onKeyDown","KEYDOWN","onPreKeyboardObservable","skipOnKeyboardObservable","onKeyboardObservable","CreateNewFromScene","_onKeyUp","KEYUP","onDeviceConnectedObservable","deviceSource","deviceType","Mouse","onInputChangedObservable","eventData","LeftClick","MiddleClick","RightClick","BrowserBack","BrowserForward","getInput","MouseWheelY","Touch","Keyboard","dispose","_internalAbstractMeshDataInfo","_pointerOverDisableMeshTesting","underPointerMesh","getPointerOverMesh","_invalidateMesh"],"sources":["../../../../dev/core/src/Inputs/scene.inputManager.ts"],"sourcesContent":["import type { EventState, Observable, Observer } from \"../Misc/observable\";\r\nimport { PointerInfoPre, PointerInfo, PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport type { Nullable } from \"../types\";\r\nimport { AbstractActionManager } from \"../Actions/abstractActionManager\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { Vector2, Matrix } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { ActionEvent } from \"../Actions/actionEvent\";\r\nimport { KeyboardEventTypes, KeyboardInfoPre, KeyboardInfo } from \"../Events/keyboardEvents\";\r\nimport { DeviceType, PointerInput } from \"../DeviceInput/InputDevices/deviceEnums\";\r\nimport type { IKeyboardEvent, IMouseEvent, IPointerEvent } from \"../Events/deviceInputEvents\";\r\nimport { DeviceSourceManager } from \"../DeviceInput/InputDevices/deviceSourceManager\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\nimport type { Scene } from \"../scene\";\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nclass _ClickInfo {\r\n    private _singleClick = false;\r\n    private _doubleClick = false;\r\n    private _hasSwiped = false;\r\n    private _ignore = false;\r\n\r\n    public get singleClick(): boolean {\r\n        return this._singleClick;\r\n    }\r\n    public get doubleClick(): boolean {\r\n        return this._doubleClick;\r\n    }\r\n    public get hasSwiped(): boolean {\r\n        return this._hasSwiped;\r\n    }\r\n    public get ignore(): boolean {\r\n        return this._ignore;\r\n    }\r\n\r\n    public set singleClick(b: boolean) {\r\n        this._singleClick = b;\r\n    }\r\n    public set doubleClick(b: boolean) {\r\n        this._doubleClick = b;\r\n    }\r\n    public set hasSwiped(b: boolean) {\r\n        this._hasSwiped = b;\r\n    }\r\n    public set ignore(b: boolean) {\r\n        this._ignore = b;\r\n    }\r\n}\r\n\r\n/** @internal */\r\ninterface _IClickEvent {\r\n    clickInfo: _ClickInfo;\r\n    evt: IPointerEvent;\r\n    timeoutId: number;\r\n}\r\n\r\n/**\r\n * Class used to manage all inputs for the scene.\r\n */\r\nexport class InputManager {\r\n    /** The distance in pixel that you have to move to prevent some events */\r\n    public static DragMovementThreshold = 10; // in pixels\r\n    /** Time in milliseconds to wait to raise long press events if button is still pressed */\r\n    public static LongPressDelay = 500; // in milliseconds\r\n    /** Time in milliseconds with two consecutive clicks will be considered as a double click */\r\n    public static DoubleClickDelay = 300; // in milliseconds\r\n    /**\r\n     * This flag will modify the behavior so that, when true, a click will happen if and only if\r\n     * another click DOES NOT happen within the DoubleClickDelay time frame.  If another click does\r\n     * happen within that time frame, the first click will not fire an event and and a double click will occur.\r\n     */\r\n    public static ExclusiveDoubleClickMode = false;\r\n\r\n    /** This is a defensive check to not allow control attachment prior to an already active one. If already attached, previous control is unattached before attaching the new one. */\r\n    private _alreadyAttached = false;\r\n    private _alreadyAttachedTo: Nullable<HTMLElement>;\r\n\r\n    // Pointers\r\n    private _onPointerMove: (evt: IMouseEvent) => void;\r\n    private _onPointerDown: (evt: IPointerEvent) => void;\r\n    private _onPointerUp: (evt: IPointerEvent) => void;\r\n\r\n    private _initClickEvent: (\r\n        obs1: Observable<PointerInfoPre>,\r\n        obs2: Observable<PointerInfo>,\r\n        evt: IPointerEvent,\r\n        cb: (clickInfo: _ClickInfo, pickResult: Nullable<PickingInfo>) => void\r\n    ) => void;\r\n    private _initActionManager: (act: Nullable<AbstractActionManager>, clickInfo: _ClickInfo) => Nullable<AbstractActionManager>;\r\n    private _delayedSimpleClick: (btn: number, clickInfo: _ClickInfo, cb: (clickInfo: _ClickInfo, pickResult: Nullable<PickingInfo>) => void) => void;\r\n    private _meshPickProceed = false;\r\n\r\n    private _previousButtonPressed: number;\r\n    private _currentPickResult: Nullable<PickingInfo> = null;\r\n    private _previousPickResult: Nullable<PickingInfo> = null;\r\n    private _totalPointersPressed = 0;\r\n    private _doubleClickOccured = false;\r\n    private _isSwiping: boolean = false;\r\n    private _swipeButtonPressed: number = -1;\r\n    private _skipPointerTap: boolean = false;\r\n    private _isMultiTouchGesture: boolean = false;\r\n\r\n    private _pointerOverMesh: Nullable<AbstractMesh>;\r\n\r\n    private _pickedDownMesh: Nullable<AbstractMesh>;\r\n    private _pickedUpMesh: Nullable<AbstractMesh>;\r\n\r\n    private _pointerX: number = 0;\r\n    private _pointerY: number = 0;\r\n    private _unTranslatedPointerX: number;\r\n    private _unTranslatedPointerY: number;\r\n    private _startingPointerPosition = new Vector2(0, 0);\r\n    private _previousStartingPointerPosition = new Vector2(0, 0);\r\n    private _startingPointerTime = 0;\r\n    private _previousStartingPointerTime = 0;\r\n    private _pointerCaptures: { [pointerId: number]: boolean } = {};\r\n    private _meshUnderPointerId: { [pointerId: number]: Nullable<AbstractMesh> } = {};\r\n    private _movePointerInfo: Nullable<PointerInfo> = null;\r\n    private _cameraObserverCount = 0;\r\n    private _delayedClicks: Array<Nullable<_IClickEvent>> = [null, null, null, null, null];\r\n\r\n    // Keyboard\r\n    private _onKeyDown: (evt: IKeyboardEvent) => void;\r\n    private _onKeyUp: (evt: IKeyboardEvent) => void;\r\n\r\n    private _scene: Scene;\r\n    private _deviceSourceManager: Nullable<DeviceSourceManager> = null;\r\n\r\n    /**\r\n     * Creates a new InputManager\r\n     * @param scene - defines the hosting scene\r\n     */\r\n    constructor(scene?: Scene) {\r\n        this._scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        if (!this._scene) {\r\n            return;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the mesh that is currently under the pointer\r\n     * @returns Mesh that the pointer is pointer is hovering over\r\n     */\r\n    public get meshUnderPointer(): Nullable<AbstractMesh> {\r\n        if (this._movePointerInfo) {\r\n            // Because _pointerOverMesh is populated as part of _pickMove, we need to force a pick to update it.\r\n            // Calling _pickMove calls _setCursorAndPointerOverMesh which calls setPointerOverMesh\r\n            this._movePointerInfo._generatePickInfo();\r\n            // Once we have what we need, we can clear _movePointerInfo because we don't need it anymore\r\n            this._movePointerInfo = null;\r\n        }\r\n        return this._pointerOverMesh;\r\n    }\r\n\r\n    /**\r\n     * When using more than one pointer (for example in XR) you can get the mesh under the specific pointer\r\n     * @param pointerId - the pointer id to use\r\n     * @returns The mesh under this pointer id or null if not found\r\n     */\r\n    public getMeshUnderPointerByPointerId(pointerId: number): Nullable<AbstractMesh> {\r\n        return this._meshUnderPointerId[pointerId] || null;\r\n    }\r\n\r\n    /**\r\n     * Gets the pointer coordinates in 2D without any translation (ie. straight out of the pointer event)\r\n     * @returns Vector with X/Y values directly from pointer event\r\n     */\r\n    public get unTranslatedPointer(): Vector2 {\r\n        return new Vector2(this._unTranslatedPointerX, this._unTranslatedPointerY);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current on-screen X position of the pointer\r\n     * @returns Translated X with respect to screen\r\n     */\r\n    public get pointerX(): number {\r\n        return this._pointerX;\r\n    }\r\n\r\n    public set pointerX(value: number) {\r\n        this._pointerX = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current on-screen Y position of the pointer\r\n     * @returns Translated Y with respect to screen\r\n     */\r\n    public get pointerY(): number {\r\n        return this._pointerY;\r\n    }\r\n\r\n    public set pointerY(value: number) {\r\n        this._pointerY = value;\r\n    }\r\n\r\n    private _updatePointerPosition(evt: IPointerEvent): void {\r\n        const canvasRect = this._scene.getEngine().getInputElementClientRect();\r\n\r\n        if (!canvasRect) {\r\n            return;\r\n        }\r\n\r\n        this._pointerX = evt.clientX - canvasRect.left;\r\n        this._pointerY = evt.clientY - canvasRect.top;\r\n\r\n        this._unTranslatedPointerX = this._pointerX;\r\n        this._unTranslatedPointerY = this._pointerY;\r\n    }\r\n\r\n    private _processPointerMove(pickResult: Nullable<PickingInfo>, evt: IPointerEvent) {\r\n        const scene = this._scene;\r\n        const engine = scene.getEngine();\r\n        const canvas = engine.getInputElement();\r\n\r\n        if (canvas) {\r\n            canvas.tabIndex = engine.canvasTabIndex;\r\n\r\n            // Restore pointer\r\n            if (!scene.doNotHandleCursors) {\r\n                canvas.style.cursor = scene.defaultCursor;\r\n            }\r\n        }\r\n\r\n        this._setCursorAndPointerOverMesh(pickResult, evt, scene);\r\n\r\n        for (const step of scene._pointerMoveStage) {\r\n            // If _pointerMoveState is defined, we have an active spriteManager and can't use Lazy Picking\r\n            // Therefore, we need to force a pick to update the pickResult\r\n            pickResult = pickResult || this._pickMove(evt);\r\n            const isMeshPicked = pickResult?.pickedMesh ? true : false;\r\n            pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, isMeshPicked, canvas);\r\n        }\r\n\r\n        const type = evt.inputIndex >= PointerInput.MouseWheelX && evt.inputIndex <= PointerInput.MouseWheelZ ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE;\r\n\r\n        if (scene.onPointerMove) {\r\n            // Because of lazy picking, we need to force a pick to update the pickResult\r\n            pickResult = pickResult || this._pickMove(evt);\r\n            scene.onPointerMove(evt, pickResult, type);\r\n        }\r\n\r\n        let pointerInfo: PointerInfo;\r\n        if (pickResult) {\r\n            pointerInfo = new PointerInfo(type, evt, pickResult);\r\n            this._setRayOnPointerInfo(pickResult, evt);\r\n        } else {\r\n            pointerInfo = new PointerInfo(type, evt, null, this);\r\n            this._movePointerInfo = pointerInfo;\r\n        }\r\n\r\n        if (scene.onPointerObservable.hasObservers()) {\r\n            scene.onPointerObservable.notifyObservers(pointerInfo, type);\r\n        }\r\n    }\r\n\r\n    // Pointers handling\r\n    /** @internal */\r\n    public _setRayOnPointerInfo(pickInfo: Nullable<PickingInfo>, event: IMouseEvent) {\r\n        const scene = this._scene;\r\n        if (pickInfo && scene._pickingAvailable) {\r\n            if (!pickInfo.ray) {\r\n                pickInfo.ray = scene.createPickingRay(event.offsetX, event.offsetY, Matrix.Identity(), scene.activeCamera);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _addCameraPointerObserver(observer: (p: PointerInfo, s: EventState) => void, mask?: number): Nullable<Observer<PointerInfo>> {\r\n        this._cameraObserverCount++;\r\n        return this._scene.onPointerObservable.add(observer, mask);\r\n    }\r\n\r\n    /** @internal */\r\n    public _removeCameraPointerObserver(observer: Observer<PointerInfo>): boolean {\r\n        this._cameraObserverCount--;\r\n        return this._scene.onPointerObservable.remove(observer);\r\n    }\r\n\r\n    private _checkForPicking(): boolean {\r\n        return !!(this._scene.onPointerObservable.observers.length > this._cameraObserverCount || this._scene.onPointerPick);\r\n    }\r\n\r\n    private _checkPrePointerObservable(pickResult: Nullable<PickingInfo>, evt: IPointerEvent, type: number) {\r\n        const scene = this._scene;\r\n        const pi = new PointerInfoPre(type, evt, this._unTranslatedPointerX, this._unTranslatedPointerY);\r\n        if (pickResult) {\r\n            pi.originalPickingInfo = pickResult;\r\n            pi.ray = pickResult.ray;\r\n            if (pickResult.originMesh) {\r\n                pi.nearInteractionPickingInfo = pickResult;\r\n            }\r\n        }\r\n\r\n        scene.onPrePointerObservable.notifyObservers(pi, type);\r\n        if (pi.skipOnPointerObservable) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _pickMove(evt: IPointerEvent): PickingInfo {\r\n        const scene = this._scene;\r\n        const pickResult = scene.pick(\r\n            this._unTranslatedPointerX,\r\n            this._unTranslatedPointerY,\r\n            scene.pointerMovePredicate,\r\n            scene.pointerMoveFastCheck,\r\n            scene.cameraToUseForPointers,\r\n            scene.pointerMoveTrianglePredicate\r\n        );\r\n\r\n        this._setCursorAndPointerOverMesh(pickResult, evt, scene);\r\n\r\n        return pickResult;\r\n    }\r\n\r\n    private _setCursorAndPointerOverMesh(pickResult: Nullable<PickingInfo>, evt: IPointerEvent, scene: Scene) {\r\n        const engine = scene.getEngine();\r\n        const canvas = engine.getInputElement();\r\n\r\n        if (pickResult?.pickedMesh) {\r\n            this.setPointerOverMesh(pickResult.pickedMesh, evt.pointerId, pickResult, evt);\r\n\r\n            if (!scene.doNotHandleCursors && canvas && this._pointerOverMesh) {\r\n                const actionManager = this._pointerOverMesh._getActionManagerForTrigger();\r\n                if (actionManager && actionManager.hasPointerTriggers) {\r\n                    canvas.style.cursor = actionManager.hoverCursor || scene.hoverCursor;\r\n                }\r\n            }\r\n        } else {\r\n            this.setPointerOverMesh(null, evt.pointerId, pickResult, evt);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Use this method to simulate a pointer move on a mesh\r\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n     * @param pickResult - pickingInfo of the object wished to simulate pointer event on\r\n     * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n     */\r\n    public simulatePointerMove(pickResult: PickingInfo, pointerEventInit?: PointerEventInit): void {\r\n        const evt = new PointerEvent(\"pointermove\", pointerEventInit);\r\n        evt.inputIndex = PointerInput.Move;\r\n\r\n        if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERMOVE)) {\r\n            return;\r\n        }\r\n        this._processPointerMove(pickResult, evt);\r\n    }\r\n\r\n    /**\r\n     * Use this method to simulate a pointer down on a mesh\r\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n     * @param pickResult - pickingInfo of the object wished to simulate pointer event on\r\n     * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n     */\r\n    public simulatePointerDown(pickResult: PickingInfo, pointerEventInit?: PointerEventInit): void {\r\n        const evt = new PointerEvent(\"pointerdown\", pointerEventInit);\r\n        evt.inputIndex = evt.button + 2;\r\n\r\n        if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERDOWN)) {\r\n            return;\r\n        }\r\n\r\n        this._processPointerDown(pickResult, evt);\r\n    }\r\n\r\n    private _processPointerDown(pickResult: Nullable<PickingInfo>, evt: IPointerEvent): void {\r\n        const scene = this._scene;\r\n        if (pickResult?.pickedMesh) {\r\n            this._pickedDownMesh = pickResult.pickedMesh;\r\n            const actionManager = pickResult.pickedMesh._getActionManagerForTrigger();\r\n            if (actionManager) {\r\n                if (actionManager.hasPickTriggers) {\r\n                    actionManager.processTrigger(Constants.ACTION_OnPickDownTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\r\n                    switch (evt.button) {\r\n                        case 0:\r\n                            actionManager.processTrigger(Constants.ACTION_OnLeftPickTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\r\n                            break;\r\n                        case 1:\r\n                            actionManager.processTrigger(Constants.ACTION_OnCenterPickTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\r\n                            break;\r\n                        case 2:\r\n                            actionManager.processTrigger(Constants.ACTION_OnRightPickTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\r\n                            break;\r\n                    }\r\n                }\r\n\r\n                if (actionManager.hasSpecificTrigger(Constants.ACTION_OnLongPressTrigger)) {\r\n                    window.setTimeout(() => {\r\n                        const pickResult = scene.pick(\r\n                            this._unTranslatedPointerX,\r\n                            this._unTranslatedPointerY,\r\n                            (mesh: AbstractMesh): boolean =>\r\n                                <boolean>(\r\n                                    (mesh.isPickable &&\r\n                                        mesh.isVisible &&\r\n                                        mesh.isReady() &&\r\n                                        mesh.actionManager &&\r\n                                        mesh.actionManager.hasSpecificTrigger(Constants.ACTION_OnLongPressTrigger) &&\r\n                                        mesh === this._pickedDownMesh)\r\n                                ),\r\n                            false,\r\n                            scene.cameraToUseForPointers\r\n                        );\r\n\r\n                        if (pickResult?.pickedMesh && actionManager) {\r\n                            if (this._totalPointersPressed !== 0 && Date.now() - this._startingPointerTime > InputManager.LongPressDelay && !this._isPointerSwiping()) {\r\n                                this._startingPointerTime = 0;\r\n                                actionManager.processTrigger(Constants.ACTION_OnLongPressTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\r\n                            }\r\n                        }\r\n                    }, InputManager.LongPressDelay);\r\n                }\r\n            }\r\n        } else {\r\n            for (const step of scene._pointerDownStage) {\r\n                pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt, false);\r\n            }\r\n        }\r\n\r\n        let pointerInfo: PointerInfo;\r\n        const type = PointerEventTypes.POINTERDOWN;\r\n\r\n        if (pickResult) {\r\n            if (scene.onPointerDown) {\r\n                scene.onPointerDown(evt, pickResult, type);\r\n            }\r\n\r\n            pointerInfo = new PointerInfo(type, evt, pickResult);\r\n            this._setRayOnPointerInfo(pickResult, evt);\r\n        } else {\r\n            pointerInfo = new PointerInfo(type, evt, null, this);\r\n        }\r\n\r\n        if (scene.onPointerObservable.hasObservers()) {\r\n            scene.onPointerObservable.notifyObservers(pointerInfo, type);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @internals Boolean if delta for pointer exceeds drag movement threshold\r\n     */\r\n    public _isPointerSwiping(): boolean {\r\n        return this._isSwiping;\r\n    }\r\n\r\n    /**\r\n     * Use this method to simulate a pointer up on a mesh\r\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n     * @param pickResult - pickingInfo of the object wished to simulate pointer event on\r\n     * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n     * @param doubleTap - indicates that the pointer up event should be considered as part of a double click (false by default)\r\n     */\r\n    public simulatePointerUp(pickResult: PickingInfo, pointerEventInit?: PointerEventInit, doubleTap?: boolean): void {\r\n        const evt = new PointerEvent(\"pointerup\", pointerEventInit);\r\n        evt.inputIndex = PointerInput.Move;\r\n        const clickInfo = new _ClickInfo();\r\n\r\n        if (doubleTap) {\r\n            clickInfo.doubleClick = true;\r\n        } else {\r\n            clickInfo.singleClick = true;\r\n        }\r\n\r\n        if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERUP)) {\r\n            return;\r\n        }\r\n\r\n        this._processPointerUp(pickResult, evt, clickInfo);\r\n    }\r\n\r\n    private _processPointerUp(pickResult: Nullable<PickingInfo>, evt: IPointerEvent, clickInfo: _ClickInfo): void {\r\n        const scene = this._scene;\r\n        if (pickResult?.pickedMesh) {\r\n            this._pickedUpMesh = pickResult.pickedMesh;\r\n            if (this._pickedDownMesh === this._pickedUpMesh) {\r\n                if (scene.onPointerPick) {\r\n                    scene.onPointerPick(evt, pickResult);\r\n                }\r\n                if (clickInfo.singleClick && !clickInfo.ignore && scene.onPointerObservable.observers.length > this._cameraObserverCount) {\r\n                    const type = PointerEventTypes.POINTERPICK;\r\n                    const pi = new PointerInfo(type, evt, pickResult);\r\n                    this._setRayOnPointerInfo(pickResult, evt);\r\n                    scene.onPointerObservable.notifyObservers(pi, type);\r\n                }\r\n            }\r\n            const actionManager = pickResult.pickedMesh._getActionManagerForTrigger();\r\n            if (actionManager && !clickInfo.ignore) {\r\n                actionManager.processTrigger(Constants.ACTION_OnPickUpTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\r\n\r\n                if (!clickInfo.hasSwiped && clickInfo.singleClick) {\r\n                    actionManager.processTrigger(Constants.ACTION_OnPickTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\r\n                }\r\n\r\n                const doubleClickActionManager = pickResult.pickedMesh._getActionManagerForTrigger(Constants.ACTION_OnDoublePickTrigger);\r\n                if (clickInfo.doubleClick && doubleClickActionManager) {\r\n                    doubleClickActionManager.processTrigger(Constants.ACTION_OnDoublePickTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\r\n                }\r\n            }\r\n        } else {\r\n            if (!clickInfo.ignore) {\r\n                for (const step of scene._pointerUpStage) {\r\n                    pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt, clickInfo.doubleClick);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) {\r\n            const pickedDownActionManager = this._pickedDownMesh._getActionManagerForTrigger(Constants.ACTION_OnPickOutTrigger);\r\n            if (pickedDownActionManager) {\r\n                pickedDownActionManager.processTrigger(Constants.ACTION_OnPickOutTrigger, ActionEvent.CreateNew(this._pickedDownMesh, evt));\r\n            }\r\n        }\r\n\r\n        if (!clickInfo.ignore) {\r\n            const pi = new PointerInfo(PointerEventTypes.POINTERUP, evt, pickResult);\r\n            // Set ray on picking info.  Note that this info will also be reused for the tap notification.\r\n            this._setRayOnPointerInfo(pickResult, evt);\r\n            scene.onPointerObservable.notifyObservers(pi, PointerEventTypes.POINTERUP);\r\n\r\n            if (scene.onPointerUp) {\r\n                scene.onPointerUp(evt, pickResult, PointerEventTypes.POINTERUP);\r\n            }\r\n\r\n            if (!clickInfo.hasSwiped && !this._skipPointerTap && !this._isMultiTouchGesture) {\r\n                let type = 0;\r\n                if (clickInfo.singleClick) {\r\n                    type = PointerEventTypes.POINTERTAP;\r\n                } else if (clickInfo.doubleClick) {\r\n                    type = PointerEventTypes.POINTERDOUBLETAP;\r\n                }\r\n\r\n                if (type) {\r\n                    const pi = new PointerInfo(type, evt, pickResult);\r\n                    if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {\r\n                        scene.onPointerObservable.notifyObservers(pi, type);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)\r\n     * @param pointerId - defines the pointer id to use in a multi-touch scenario (0 by default)\r\n     * @returns true if the pointer was captured\r\n     */\r\n    public isPointerCaptured(pointerId = 0): boolean {\r\n        return this._pointerCaptures[pointerId];\r\n    }\r\n\r\n    /**\r\n     * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp\r\n     * @param attachUp - defines if you want to attach events to pointerup\r\n     * @param attachDown - defines if you want to attach events to pointerdown\r\n     * @param attachMove - defines if you want to attach events to pointermove\r\n     * @param elementToAttachTo - defines the target DOM element to attach to (will use the canvas by default)\r\n     */\r\n    public attachControl(attachUp = true, attachDown = true, attachMove = true, elementToAttachTo: Nullable<HTMLElement> = null): void {\r\n        const scene = this._scene;\r\n        const engine = scene.getEngine();\r\n\r\n        if (!elementToAttachTo) {\r\n            elementToAttachTo = engine.getInputElement();\r\n        }\r\n\r\n        if (this._alreadyAttached) {\r\n            this.detachControl();\r\n        }\r\n\r\n        if (elementToAttachTo) {\r\n            this._alreadyAttachedTo = elementToAttachTo;\r\n        }\r\n        this._deviceSourceManager = new DeviceSourceManager(engine);\r\n\r\n        // Because this is only called from _initClickEvent, which is called in _onPointerUp, we'll use the pointerUpPredicate for the pick call\r\n        this._initActionManager = (act: Nullable<AbstractActionManager>): Nullable<AbstractActionManager> => {\r\n            if (!this._meshPickProceed) {\r\n                const pickResult =\r\n                    scene.skipPointerUpPicking || (scene._registeredActions === 0 && !this._checkForPicking() && !scene.onPointerUp)\r\n                        ? null\r\n                        : scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerUpPredicate, scene.pointerUpFastCheck, scene.cameraToUseForPointers);\r\n                this._currentPickResult = pickResult;\r\n                if (pickResult) {\r\n                    act = pickResult.hit && pickResult.pickedMesh ? pickResult.pickedMesh._getActionManagerForTrigger() : null;\r\n                }\r\n                this._meshPickProceed = true;\r\n            }\r\n            return act;\r\n        };\r\n\r\n        this._delayedSimpleClick = (btn: number, clickInfo: _ClickInfo, cb: (clickInfo: _ClickInfo, pickResult: Nullable<PickingInfo>) => void) => {\r\n            // double click delay is over and that no double click has been raised since, or the 2 consecutive keys pressed are different\r\n            if ((Date.now() - this._previousStartingPointerTime > InputManager.DoubleClickDelay && !this._doubleClickOccured) || btn !== this._previousButtonPressed) {\r\n                this._doubleClickOccured = false;\r\n                clickInfo.singleClick = true;\r\n                clickInfo.ignore = false;\r\n\r\n                // If we have a delayed click, we need to resolve the TAP event\r\n                if (this._delayedClicks[btn]) {\r\n                    const evt = this._delayedClicks[btn]!.evt;\r\n                    const type = PointerEventTypes.POINTERTAP;\r\n                    const pi = new PointerInfo(type, evt, this._currentPickResult);\r\n                    if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {\r\n                        scene.onPointerObservable.notifyObservers(pi, type);\r\n                    }\r\n\r\n                    // Clear the delayed click\r\n                    this._delayedClicks[btn] = null;\r\n                }\r\n            }\r\n        };\r\n\r\n        this._initClickEvent = (\r\n            obs1: Observable<PointerInfoPre>,\r\n            obs2: Observable<PointerInfo>,\r\n            evt: IPointerEvent,\r\n            cb: (clickInfo: _ClickInfo, pickResult: Nullable<PickingInfo>) => void\r\n        ): void => {\r\n            const clickInfo = new _ClickInfo();\r\n            this._currentPickResult = null;\r\n            let act: Nullable<AbstractActionManager> = null;\r\n\r\n            let checkPicking =\r\n                obs1.hasSpecificMask(PointerEventTypes.POINTERPICK) ||\r\n                obs2.hasSpecificMask(PointerEventTypes.POINTERPICK) ||\r\n                obs1.hasSpecificMask(PointerEventTypes.POINTERTAP) ||\r\n                obs2.hasSpecificMask(PointerEventTypes.POINTERTAP) ||\r\n                obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) ||\r\n                obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\r\n            if (!checkPicking && AbstractActionManager) {\r\n                act = this._initActionManager(act, clickInfo);\r\n                if (act) {\r\n                    checkPicking = act.hasPickTriggers;\r\n                }\r\n            }\r\n\r\n            let needToIgnoreNext = false;\r\n\r\n            if (checkPicking) {\r\n                const btn = evt.button;\r\n                clickInfo.hasSwiped = this._isPointerSwiping();\r\n\r\n                if (!clickInfo.hasSwiped) {\r\n                    let checkSingleClickImmediately = !InputManager.ExclusiveDoubleClickMode;\r\n\r\n                    if (!checkSingleClickImmediately) {\r\n                        checkSingleClickImmediately = !obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) && !obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\r\n\r\n                        if (checkSingleClickImmediately && !AbstractActionManager.HasSpecificTrigger(Constants.ACTION_OnDoublePickTrigger)) {\r\n                            act = this._initActionManager(act, clickInfo);\r\n                            if (act) {\r\n                                checkSingleClickImmediately = !act.hasSpecificTrigger(Constants.ACTION_OnDoublePickTrigger);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (checkSingleClickImmediately) {\r\n                        // single click detected if double click delay is over or two different successive keys pressed without exclusive double click or no double click required\r\n                        if (Date.now() - this._previousStartingPointerTime > InputManager.DoubleClickDelay || btn !== this._previousButtonPressed) {\r\n                            clickInfo.singleClick = true;\r\n                            cb(clickInfo, this._currentPickResult);\r\n                            needToIgnoreNext = true;\r\n                        }\r\n                    }\r\n                    // at least one double click is required to be check and exclusive double click is enabled\r\n                    else {\r\n                        // Queue up a delayed click, just in case this isn't a double click\r\n                        // It should be noted that while this delayed event happens\r\n                        // because of user input, it shouldn't be considered as a direct,\r\n                        // timing-dependent result of that input.  It's meant to just fire the TAP event\r\n                        const delayedClick = {\r\n                            evt: evt,\r\n                            clickInfo: clickInfo,\r\n                            timeoutId: window.setTimeout(this._delayedSimpleClick.bind(this, btn, clickInfo, cb), InputManager.DoubleClickDelay),\r\n                        };\r\n\r\n                        this._delayedClicks[btn] = delayedClick;\r\n                    }\r\n\r\n                    let checkDoubleClick = obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\r\n                    if (!checkDoubleClick && AbstractActionManager.HasSpecificTrigger(Constants.ACTION_OnDoublePickTrigger)) {\r\n                        act = this._initActionManager(act, clickInfo);\r\n                        if (act) {\r\n                            checkDoubleClick = act.hasSpecificTrigger(Constants.ACTION_OnDoublePickTrigger);\r\n                        }\r\n                    }\r\n                    if (checkDoubleClick) {\r\n                        // two successive keys pressed are equal, double click delay is not over and double click has not just occurred\r\n                        if (btn === this._previousButtonPressed && Date.now() - this._previousStartingPointerTime < InputManager.DoubleClickDelay && !this._doubleClickOccured) {\r\n                            // pointer has not moved for 2 clicks, it's a double click\r\n                            if (!clickInfo.hasSwiped && !this._isPointerSwiping()) {\r\n                                this._previousStartingPointerTime = 0;\r\n                                this._doubleClickOccured = true;\r\n                                clickInfo.doubleClick = true;\r\n                                clickInfo.ignore = false;\r\n                                // If we have a pending click, we need to cancel it\r\n                                if (InputManager.ExclusiveDoubleClickMode && this._delayedClicks[btn]) {\r\n                                    clearTimeout(this._delayedClicks[btn]?.timeoutId);\r\n                                    this._delayedClicks[btn] = null;\r\n                                }\r\n\r\n                                cb(clickInfo, this._currentPickResult);\r\n                            }\r\n                            // if the two successive clicks are too far, it's just two simple clicks\r\n                            else {\r\n                                this._doubleClickOccured = false;\r\n                                this._previousStartingPointerTime = this._startingPointerTime;\r\n                                this._previousStartingPointerPosition.x = this._startingPointerPosition.x;\r\n                                this._previousStartingPointerPosition.y = this._startingPointerPosition.y;\r\n                                this._previousButtonPressed = btn;\r\n                                if (InputManager.ExclusiveDoubleClickMode) {\r\n                                    // If we have a delayed click, we need to cancel it\r\n                                    if (this._delayedClicks[btn]) {\r\n                                        clearTimeout(this._delayedClicks[btn]?.timeoutId);\r\n                                        this._delayedClicks[btn] = null;\r\n                                    }\r\n                                    cb(clickInfo, this._previousPickResult);\r\n                                } else {\r\n                                    cb(clickInfo, this._currentPickResult);\r\n                                }\r\n                            }\r\n                            needToIgnoreNext = true;\r\n                        }\r\n                        // just the first click of the double has been raised\r\n                        else {\r\n                            this._doubleClickOccured = false;\r\n                            this._previousStartingPointerTime = this._startingPointerTime;\r\n                            this._previousStartingPointerPosition.x = this._startingPointerPosition.x;\r\n                            this._previousStartingPointerPosition.y = this._startingPointerPosition.y;\r\n                            this._previousButtonPressed = btn!;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Even if ExclusiveDoubleClickMode is true, we need to always handle\r\n            // up events at time of execution, unless we're explicitly ignoring them.\r\n            if (!needToIgnoreNext) {\r\n                cb(clickInfo, this._currentPickResult);\r\n            }\r\n        };\r\n\r\n        this._onPointerMove = (evt: IMouseEvent) => {\r\n            this._updatePointerPosition(evt as IPointerEvent);\r\n\r\n            // Check if pointer leaves DragMovementThreshold range to determine if swipe is occurring\r\n            if (!this._isSwiping && this._swipeButtonPressed !== -1) {\r\n                this._isSwiping =\r\n                    Math.abs(this._startingPointerPosition.x - this._pointerX) > InputManager.DragMovementThreshold ||\r\n                    Math.abs(this._startingPointerPosition.y - this._pointerY) > InputManager.DragMovementThreshold;\r\n            }\r\n\r\n            // Because there's a race condition between pointermove and pointerlockchange events, we need to\r\n            // verify that the pointer is still locked after each pointermove event.\r\n            if (engine.isPointerLock) {\r\n                engine._verifyPointerLock();\r\n            }\r\n\r\n            // PreObservable support\r\n            if (\r\n                this._checkPrePointerObservable(\r\n                    null,\r\n                    evt as IPointerEvent,\r\n                    evt.inputIndex >= PointerInput.MouseWheelX && evt.inputIndex <= PointerInput.MouseWheelZ ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE\r\n                )\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            if (!scene.cameraToUseForPointers && !scene.activeCamera) {\r\n                return;\r\n            }\r\n\r\n            if (scene.skipPointerMovePicking) {\r\n                this._processPointerMove(new PickingInfo(), evt as IPointerEvent);\r\n                return;\r\n            }\r\n\r\n            if (!scene.pointerMovePredicate) {\r\n                scene.pointerMovePredicate = (mesh: AbstractMesh): boolean =>\r\n                    mesh.isPickable &&\r\n                    mesh.isVisible &&\r\n                    mesh.isReady() &&\r\n                    mesh.isEnabled() &&\r\n                    (mesh.enablePointerMoveEvents || scene.constantlyUpdateMeshUnderPointer || mesh._getActionManagerForTrigger() !== null) &&\r\n                    (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\r\n            }\r\n\r\n            const pickResult = scene._registeredActions > 0 || scene.constantlyUpdateMeshUnderPointer ? this._pickMove(evt as IPointerEvent) : null;\r\n            this._processPointerMove(pickResult, evt as IPointerEvent);\r\n        };\r\n\r\n        this._onPointerDown = (evt: IPointerEvent) => {\r\n            this._totalPointersPressed++;\r\n            this._pickedDownMesh = null;\r\n            this._meshPickProceed = false;\r\n\r\n            // If ExclusiveDoubleClickMode is true, we need to resolve any pending delayed clicks\r\n            if (InputManager.ExclusiveDoubleClickMode) {\r\n                for (let i = 0; i < this._delayedClicks.length; i++) {\r\n                    if (this._delayedClicks[i]) {\r\n                        // If the button that was pressed is the same as the one that was released,\r\n                        // just clear the timer.  This will be resolved in the up event.\r\n                        if (evt.button === i) {\r\n                            clearTimeout(this._delayedClicks[i]?.timeoutId);\r\n                        } else {\r\n                            // Otherwise, we need to resolve the click\r\n                            const clickInfo = this._delayedClicks[i]!.clickInfo;\r\n                            this._doubleClickOccured = false;\r\n                            clickInfo.singleClick = true;\r\n                            clickInfo.ignore = false;\r\n\r\n                            const prevEvt = this._delayedClicks[i]!.evt;\r\n                            const type = PointerEventTypes.POINTERTAP;\r\n                            const pi = new PointerInfo(type, prevEvt, this._currentPickResult);\r\n                            if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {\r\n                                scene.onPointerObservable.notifyObservers(pi, type);\r\n                            }\r\n\r\n                            // Clear the delayed click\r\n                            this._delayedClicks[i] = null;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            this._updatePointerPosition(evt);\r\n\r\n            if (this._swipeButtonPressed === -1) {\r\n                this._swipeButtonPressed = evt.button;\r\n            }\r\n\r\n            if (scene.preventDefaultOnPointerDown && elementToAttachTo) {\r\n                evt.preventDefault();\r\n                elementToAttachTo.focus();\r\n            }\r\n\r\n            this._startingPointerPosition.x = this._pointerX;\r\n            this._startingPointerPosition.y = this._pointerY;\r\n            this._startingPointerTime = Date.now();\r\n\r\n            // PreObservable support\r\n            if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOWN)) {\r\n                return;\r\n            }\r\n\r\n            if (!scene.cameraToUseForPointers && !scene.activeCamera) {\r\n                return;\r\n            }\r\n\r\n            this._pointerCaptures[evt.pointerId] = true;\r\n\r\n            if (!scene.pointerDownPredicate) {\r\n                scene.pointerDownPredicate = (mesh: AbstractMesh): boolean => {\r\n                    return (\r\n                        mesh.isPickable &&\r\n                        mesh.isVisible &&\r\n                        mesh.isReady() &&\r\n                        mesh.isEnabled() &&\r\n                        (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0)\r\n                    );\r\n                };\r\n            }\r\n\r\n            // Meshes\r\n            this._pickedDownMesh = null;\r\n            let pickResult;\r\n            if (scene.skipPointerDownPicking || (scene._registeredActions === 0 && !this._checkForPicking() && !scene.onPointerDown)) {\r\n                pickResult = new PickingInfo();\r\n            } else {\r\n                pickResult = scene.pick(\r\n                    this._unTranslatedPointerX,\r\n                    this._unTranslatedPointerY,\r\n                    scene.pointerDownPredicate,\r\n                    scene.pointerDownFastCheck,\r\n                    scene.cameraToUseForPointers\r\n                );\r\n            }\r\n\r\n            this._processPointerDown(pickResult, evt);\r\n        };\r\n\r\n        this._onPointerUp = (evt: IPointerEvent) => {\r\n            if (this._totalPointersPressed === 0) {\r\n                // We are attaching the pointer up to windows because of a bug in FF\r\n                return; // So we need to test it the pointer down was pressed before.\r\n            }\r\n\r\n            this._totalPointersPressed--;\r\n            this._pickedUpMesh = null;\r\n            this._meshPickProceed = false;\r\n\r\n            this._updatePointerPosition(evt);\r\n\r\n            if (scene.preventDefaultOnPointerUp && elementToAttachTo) {\r\n                evt.preventDefault();\r\n                elementToAttachTo.focus();\r\n            }\r\n\r\n            this._initClickEvent(scene.onPrePointerObservable, scene.onPointerObservable, evt, (clickInfo: _ClickInfo, pickResult: Nullable<PickingInfo>) => {\r\n                // PreObservable support\r\n                if (scene.onPrePointerObservable.hasObservers()) {\r\n                    this._skipPointerTap = false;\r\n                    if (!clickInfo.ignore) {\r\n                        if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERUP)) {\r\n                            // If we're skipping the next observable, we need to reset the swipe state before returning\r\n                            if (this._swipeButtonPressed === evt.button) {\r\n                                this._isSwiping = false;\r\n                                this._swipeButtonPressed = -1;\r\n                            }\r\n\r\n                            // If we're going to skip the POINTERUP, we need to reset the pointer capture\r\n                            if (evt.buttons === 0) {\r\n                                this._pointerCaptures[evt.pointerId] = false;\r\n                            }\r\n\r\n                            return;\r\n                        }\r\n                        if (!clickInfo.hasSwiped) {\r\n                            if (clickInfo.singleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {\r\n                                if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERTAP)) {\r\n                                    this._skipPointerTap = true;\r\n                                }\r\n                            }\r\n                            if (clickInfo.doubleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {\r\n                                if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOUBLETAP)) {\r\n                                    this._skipPointerTap = true;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // There should be a pointer captured at this point so if there isn't we should reset and return\r\n                if (!this._pointerCaptures[evt.pointerId]) {\r\n                    if (this._swipeButtonPressed === evt.button) {\r\n                        this._isSwiping = false;\r\n                        this._swipeButtonPressed = -1;\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                // Only release capture if all buttons are released\r\n                if (evt.buttons === 0) {\r\n                    this._pointerCaptures[evt.pointerId] = false;\r\n                }\r\n                if (!scene.cameraToUseForPointers && !scene.activeCamera) {\r\n                    return;\r\n                }\r\n\r\n                if (!scene.pointerUpPredicate) {\r\n                    scene.pointerUpPredicate = (mesh: AbstractMesh): boolean => {\r\n                        return (\r\n                            mesh.isPickable &&\r\n                            mesh.isVisible &&\r\n                            mesh.isReady() &&\r\n                            mesh.isEnabled() &&\r\n                            (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0)\r\n                        );\r\n                    };\r\n                }\r\n\r\n                // Meshes\r\n                if (!this._meshPickProceed && ((AbstractActionManager && AbstractActionManager.HasTriggers) || this._checkForPicking() || scene.onPointerUp)) {\r\n                    this._initActionManager(null, clickInfo);\r\n                }\r\n                if (!pickResult) {\r\n                    pickResult = this._currentPickResult;\r\n                }\r\n\r\n                this._processPointerUp(pickResult, evt, clickInfo);\r\n\r\n                this._previousPickResult = this._currentPickResult;\r\n\r\n                if (this._swipeButtonPressed === evt.button) {\r\n                    this._isSwiping = false;\r\n                    this._swipeButtonPressed = -1;\r\n                }\r\n            });\r\n        };\r\n\r\n        this._onKeyDown = (evt: IKeyboardEvent) => {\r\n            const type = KeyboardEventTypes.KEYDOWN;\r\n            if (scene.onPreKeyboardObservable.hasObservers()) {\r\n                const pi = new KeyboardInfoPre(type, evt);\r\n                scene.onPreKeyboardObservable.notifyObservers(pi, type);\r\n                if (pi.skipOnKeyboardObservable) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (scene.onKeyboardObservable.hasObservers()) {\r\n                const pi = new KeyboardInfo(type, evt);\r\n                scene.onKeyboardObservable.notifyObservers(pi, type);\r\n            }\r\n\r\n            if (scene.actionManager) {\r\n                scene.actionManager.processTrigger(Constants.ACTION_OnKeyDownTrigger, ActionEvent.CreateNewFromScene(scene, evt));\r\n            }\r\n        };\r\n\r\n        this._onKeyUp = (evt: IKeyboardEvent) => {\r\n            const type = KeyboardEventTypes.KEYUP;\r\n            if (scene.onPreKeyboardObservable.hasObservers()) {\r\n                const pi = new KeyboardInfoPre(type, evt);\r\n                scene.onPreKeyboardObservable.notifyObservers(pi, type);\r\n                if (pi.skipOnKeyboardObservable) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (scene.onKeyboardObservable.hasObservers()) {\r\n                const pi = new KeyboardInfo(type, evt);\r\n                scene.onKeyboardObservable.notifyObservers(pi, type);\r\n            }\r\n\r\n            if (scene.actionManager) {\r\n                scene.actionManager.processTrigger(Constants.ACTION_OnKeyUpTrigger, ActionEvent.CreateNewFromScene(scene, evt));\r\n            }\r\n        };\r\n\r\n        // If a device connects that we can handle, wire up the observable\r\n        this._deviceSourceManager.onDeviceConnectedObservable.add((deviceSource) => {\r\n            if (deviceSource.deviceType === DeviceType.Mouse) {\r\n                deviceSource.onInputChangedObservable.add((eventData) => {\r\n                    if (\r\n                        eventData.inputIndex === PointerInput.LeftClick ||\r\n                        eventData.inputIndex === PointerInput.MiddleClick ||\r\n                        eventData.inputIndex === PointerInput.RightClick ||\r\n                        eventData.inputIndex === PointerInput.BrowserBack ||\r\n                        eventData.inputIndex === PointerInput.BrowserForward\r\n                    ) {\r\n                        if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {\r\n                            this._onPointerDown(eventData);\r\n                        } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {\r\n                            this._onPointerUp(eventData);\r\n                        }\r\n                    } else if (attachMove) {\r\n                        if (eventData.inputIndex === PointerInput.Move) {\r\n                            this._onPointerMove(eventData);\r\n                        } else if (\r\n                            eventData.inputIndex === PointerInput.MouseWheelX ||\r\n                            eventData.inputIndex === PointerInput.MouseWheelY ||\r\n                            eventData.inputIndex === PointerInput.MouseWheelZ\r\n                        ) {\r\n                            this._onPointerMove(eventData);\r\n                        }\r\n                    }\r\n                });\r\n            } else if (deviceSource.deviceType === DeviceType.Touch) {\r\n                deviceSource.onInputChangedObservable.add((eventData) => {\r\n                    if (eventData.inputIndex === PointerInput.LeftClick) {\r\n                        if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {\r\n                            this._onPointerDown(eventData);\r\n                            if (this._totalPointersPressed > 1) {\r\n                                this._isMultiTouchGesture = true;\r\n                            }\r\n                        } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {\r\n                            this._onPointerUp(eventData);\r\n                            if (this._totalPointersPressed === 0) {\r\n                                this._isMultiTouchGesture = false;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (attachMove && eventData.inputIndex === PointerInput.Move) {\r\n                        this._onPointerMove(eventData);\r\n                    }\r\n                });\r\n            } else if (deviceSource.deviceType === DeviceType.Keyboard) {\r\n                deviceSource.onInputChangedObservable.add((eventData) => {\r\n                    if (eventData.type === \"keydown\") {\r\n                        this._onKeyDown(eventData);\r\n                    } else if (eventData.type === \"keyup\") {\r\n                        this._onKeyUp(eventData);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n        this._alreadyAttached = true;\r\n    }\r\n\r\n    /**\r\n     * Detaches all event handlers\r\n     */\r\n    public detachControl() {\r\n        if (this._alreadyAttached) {\r\n            this._deviceSourceManager!.dispose();\r\n            this._deviceSourceManager = null;\r\n\r\n            // Cursor\r\n            if (this._alreadyAttachedTo && !this._scene.doNotHandleCursors) {\r\n                this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor;\r\n            }\r\n\r\n            this._alreadyAttached = false;\r\n            this._alreadyAttachedTo = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force the value of meshUnderPointer\r\n     * @param mesh - defines the mesh to use\r\n     * @param pointerId - optional pointer id when using more than one pointer. Defaults to 0\r\n     * @param pickResult - optional pickingInfo data used to find mesh\r\n     * @param evt - optional pointer event\r\n     */\r\n    public setPointerOverMesh(mesh: Nullable<AbstractMesh>, pointerId: number = 0, pickResult?: Nullable<PickingInfo>, evt?: IPointerEvent): void {\r\n        if (this._meshUnderPointerId[pointerId] === mesh && (!mesh || !mesh._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting)) {\r\n            return;\r\n        }\r\n\r\n        const underPointerMesh = this._meshUnderPointerId[pointerId];\r\n\r\n        let actionManager: Nullable<AbstractActionManager>;\r\n        if (underPointerMesh) {\r\n            actionManager = underPointerMesh._getActionManagerForTrigger(Constants.ACTION_OnPointerOutTrigger);\r\n            if (actionManager) {\r\n                actionManager.processTrigger(Constants.ACTION_OnPointerOutTrigger, ActionEvent.CreateNew(underPointerMesh, evt, { pointerId }));\r\n            }\r\n        }\r\n\r\n        if (mesh) {\r\n            this._meshUnderPointerId[pointerId] = mesh;\r\n            this._pointerOverMesh = mesh;\r\n\r\n            actionManager = mesh._getActionManagerForTrigger(Constants.ACTION_OnPointerOverTrigger);\r\n            if (actionManager) {\r\n                actionManager.processTrigger(Constants.ACTION_OnPointerOverTrigger, ActionEvent.CreateNew(mesh, evt, { pointerId, pickResult }));\r\n            }\r\n        } else {\r\n            delete this._meshUnderPointerId[pointerId];\r\n            this._pointerOverMesh = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the mesh under the pointer\r\n     * @returns a Mesh or null if no mesh is under the pointer\r\n     */\r\n    public getPointerOverMesh(): Nullable<AbstractMesh> {\r\n        return this.meshUnderPointer;\r\n    }\r\n\r\n    /**\r\n     * @param mesh - Mesh to invalidate\r\n     * @internal\r\n     */\r\n    public _invalidateMesh(mesh: AbstractMesh) {\r\n        if (this._pointerOverMesh === mesh) {\r\n            this._pointerOverMesh = null;\r\n        }\r\n        if (this._pickedDownMesh === mesh) {\r\n            this._pickedDownMesh = null;\r\n        }\r\n        if (this._pickedUpMesh === mesh) {\r\n            this._pickedUpMesh = null;\r\n        }\r\n        for (const pointerId in this._meshUnderPointerId) {\r\n            if (this._meshUnderPointerId[pointerId] === mesh) {\r\n                delete this._meshUnderPointerId[pointerId];\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}