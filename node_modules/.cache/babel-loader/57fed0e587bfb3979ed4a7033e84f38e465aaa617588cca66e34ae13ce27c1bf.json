{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Scene } from \"../scene.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { GeometryBufferRenderer } from \"./geometryBufferRenderer.js\";\nObject.defineProperty(Scene.prototype, \"geometryBufferRenderer\", {\n  get: function () {\n    return this._geometryBufferRenderer;\n  },\n  set: function (value) {\n    if (value && value.isSupported) {\n      this._geometryBufferRenderer = value;\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\nScene.prototype.enableGeometryBufferRenderer = function (ratio = 1, depthFormat = 15) {\n  if (this._geometryBufferRenderer) {\n    return this._geometryBufferRenderer;\n  }\n  this._geometryBufferRenderer = new GeometryBufferRenderer(this, ratio, depthFormat);\n  if (!this._geometryBufferRenderer.isSupported) {\n    this._geometryBufferRenderer = null;\n  }\n  return this._geometryBufferRenderer;\n};\nScene.prototype.disableGeometryBufferRenderer = function () {\n  if (!this._geometryBufferRenderer) {\n    return;\n  }\n  this._geometryBufferRenderer.dispose();\n  this._geometryBufferRenderer = null;\n};\n/**\n * Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful\n * in several rendering techniques.\n */\nexport class GeometryBufferRendererSceneComponent {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  constructor(scene) {\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER;\n    this.scene = scene;\n  }\n  /**\n   * Registers the component in a given scene\n   */\n  register() {\n    this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER, this, this._gatherRenderTargets);\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  rebuild() {\n    // Nothing to do for this component\n  }\n  /**\n   * Disposes the component and the associated resources\n   */\n  dispose() {\n    // Nothing to do for this component\n  }\n  _gatherRenderTargets(renderTargets) {\n    if (this.scene._geometryBufferRenderer) {\n      renderTargets.push(this.scene._geometryBufferRenderer.getGBuffer());\n    }\n  }\n}\nGeometryBufferRenderer._SceneComponentInitialization = scene => {\n  // Register the G Buffer component to the scene.\n  let component = scene._getComponent(SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER);\n  if (!component) {\n    component = new GeometryBufferRendererSceneComponent(scene);\n    scene._addComponent(component);\n  }\n};","map":{"version":3,"names":["Scene","SceneComponentConstants","GeometryBufferRenderer","Object","defineProperty","prototype","get","_geometryBufferRenderer","set","value","isSupported","enumerable","configurable","enableGeometryBufferRenderer","ratio","depthFormat","disableGeometryBufferRenderer","dispose","GeometryBufferRendererSceneComponent","constructor","scene","name","NAME_GEOMETRYBUFFERRENDERER","register","_gatherRenderTargetsStage","registerStep","STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER","_gatherRenderTargets","rebuild","renderTargets","push","getGBuffer","_SceneComponentInitialization","component","_getComponent","_addComponent"],"sources":["../../../../dev/core/src/Rendering/geometryBufferRendererSceneComponent.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport type { SmartArrayNoDuplicate } from \"../Misc/smartArray\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { GeometryBufferRenderer } from \"./geometryBufferRenderer\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @internal (Backing field) */\r\n        _geometryBufferRenderer: Nullable<GeometryBufferRenderer>;\r\n\r\n        /**\r\n         * Gets or Sets the current geometry buffer associated to the scene.\r\n         */\r\n        geometryBufferRenderer: Nullable<GeometryBufferRenderer>;\r\n\r\n        /**\r\n         * Enables a GeometryBufferRender and associates it with the scene\r\n         * @param ratio defines the scaling ratio to apply to the renderer (1 by default which means same resolution)\r\n         * @param depthFormat Format of the depth texture (default: Constants.TEXTUREFORMAT_DEPTH16)\r\n         * @returns the GeometryBufferRenderer\r\n         */\r\n        enableGeometryBufferRenderer(ratio?: number, depthFormat?: number): Nullable<GeometryBufferRenderer>;\r\n\r\n        /**\r\n         * Disables the GeometryBufferRender associated with the scene\r\n         */\r\n        disableGeometryBufferRenderer(): void;\r\n    }\r\n}\r\n\r\nObject.defineProperty(Scene.prototype, \"geometryBufferRenderer\", {\r\n    get: function (this: Scene) {\r\n        return this._geometryBufferRenderer;\r\n    },\r\n    set: function (this: Scene, value: Nullable<GeometryBufferRenderer>) {\r\n        if (value && value.isSupported) {\r\n            this._geometryBufferRenderer = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nScene.prototype.enableGeometryBufferRenderer = function (ratio: number = 1, depthFormat = Constants.TEXTUREFORMAT_DEPTH16): Nullable<GeometryBufferRenderer> {\r\n    if (this._geometryBufferRenderer) {\r\n        return this._geometryBufferRenderer;\r\n    }\r\n\r\n    this._geometryBufferRenderer = new GeometryBufferRenderer(this, ratio, depthFormat);\r\n    if (!this._geometryBufferRenderer.isSupported) {\r\n        this._geometryBufferRenderer = null;\r\n    }\r\n\r\n    return this._geometryBufferRenderer;\r\n};\r\n\r\nScene.prototype.disableGeometryBufferRenderer = function (): void {\r\n    if (!this._geometryBufferRenderer) {\r\n        return;\r\n    }\r\n\r\n    this._geometryBufferRenderer.dispose();\r\n    this._geometryBufferRenderer = null;\r\n};\r\n\r\n/**\r\n * Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful\r\n * in several rendering techniques.\r\n */\r\nexport class GeometryBufferRendererSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER, this, this._gatherRenderTargets);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do for this component\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources\r\n     */\r\n    public dispose(): void {\r\n        // Nothing to do for this component\r\n    }\r\n\r\n    private _gatherRenderTargets(renderTargets: SmartArrayNoDuplicate<RenderTargetTexture>): void {\r\n        if (this.scene._geometryBufferRenderer) {\r\n            renderTargets.push(this.scene._geometryBufferRenderer.getGBuffer());\r\n        }\r\n    }\r\n}\r\n\r\nGeometryBufferRenderer._SceneComponentInitialization = (scene: Scene) => {\r\n    // Register the G Buffer component to the scene.\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER) as GeometryBufferRendererSceneComponent;\r\n    if (!component) {\r\n        component = new GeometryBufferRendererSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n};\r\n"],"mappings":";AACA,SAASA,KAAK,QAAQ,aAAW;AAEjC,SAASC,uBAAuB,QAAQ,sBAAoB;AAG5D,SAASC,sBAAsB,QAAQ,6BAA2B;AA4BlEC,MAAM,CAACC,cAAc,CAACJ,KAAK,CAACK,SAAS,EAAE,wBAAwB,EAAE;EAC7DC,GAAG,EAAE,SAAAA,CAAA;IACD,OAAO,IAAI,CAACC,uBAAuB;EACvC,CAAC;EACDC,GAAG,EAAE,SAAAA,CAAuBC,KAAuC;IAC/D,IAAIA,KAAK,IAAIA,KAAK,CAACC,WAAW,EAAE;MAC5B,IAAI,CAACH,uBAAuB,GAAGE,KAAK;;EAE5C,CAAC;EACDE,UAAU,EAAE,IAAI;EAChBC,YAAY,EAAE;CACjB,CAAC;AAEFZ,KAAK,CAACK,SAAS,CAACQ,4BAA4B,GAAG,UAAUC,KAAA,GAAgB,CAAC,EAAEC,WAAW,GAAG;EACtF,IAAI,IAAI,CAACR,uBAAuB,EAAE;IAC9B,OAAO,IAAI,CAACA,uBAAuB;;EAGvC,IAAI,CAACA,uBAAuB,GAAG,IAAIL,sBAAsB,CAAC,IAAI,EAAEY,KAAK,EAAEC,WAAW,CAAC;EACnF,IAAI,CAAC,IAAI,CAACR,uBAAuB,CAACG,WAAW,EAAE;IAC3C,IAAI,CAACH,uBAAuB,GAAG,IAAI;;EAGvC,OAAO,IAAI,CAACA,uBAAuB;AACvC,CAAC;AAEDP,KAAK,CAACK,SAAS,CAACW,6BAA6B,GAAG;EAC5C,IAAI,CAAC,IAAI,CAACT,uBAAuB,EAAE;IAC/B;;EAGJ,IAAI,CAACA,uBAAuB,CAACU,OAAO,EAAE;EACtC,IAAI,CAACV,uBAAuB,GAAG,IAAI;AACvC,CAAC;AAED;;;;AAIA,OAAM,MAAOW,oCAAoC;EAW7C;;;;EAIAC,YAAYC,KAAY;IAdxB;;;IAGgB,KAAAC,IAAI,GAAGpB,uBAAuB,CAACqB,2BAA2B;IAYtE,IAAI,CAACF,KAAK,GAAGA,KAAK;EACtB;EAEA;;;EAGOG,QAAQA,CAAA;IACX,IAAI,CAACH,KAAK,CAACI,yBAAyB,CAACC,YAAY,CAACxB,uBAAuB,CAACyB,+CAA+C,EAAE,IAAI,EAAE,IAAI,CAACC,oBAAoB,CAAC;EAC/J;EAEA;;;;EAIOC,OAAOA,CAAA;IACV;EAAA;EAGJ;;;EAGOX,OAAOA,CAAA;IACV;EAAA;EAGIU,oBAAoBA,CAACE,aAAyD;IAClF,IAAI,IAAI,CAACT,KAAK,CAACb,uBAAuB,EAAE;MACpCsB,aAAa,CAACC,IAAI,CAAC,IAAI,CAACV,KAAK,CAACb,uBAAuB,CAACwB,UAAU,EAAE,CAAC;;EAE3E;;AAGJ7B,sBAAsB,CAAC8B,6BAA6B,GAAIZ,KAAY,IAAI;EACpE;EACA,IAAIa,SAAS,GAAGb,KAAK,CAACc,aAAa,CAACjC,uBAAuB,CAACqB,2BAA2B,CAAyC;EAChI,IAAI,CAACW,SAAS,EAAE;IACZA,SAAS,GAAG,IAAIf,oCAAoC,CAACE,KAAK,CAAC;IAC3DA,KAAK,CAACe,aAAa,CAACF,SAAS,CAAC;;AAEtC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}