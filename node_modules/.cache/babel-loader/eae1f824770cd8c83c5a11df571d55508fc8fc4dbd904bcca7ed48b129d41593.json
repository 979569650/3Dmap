{"ast":null,"code":"import { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\n/**\n * Class used to store bounding box information\n */\nexport class BoundingBox {\n  /**\n   * Creates a new bounding box\n   * @param min defines the minimum vector (in local space)\n   * @param max defines the maximum vector (in local space)\n   * @param worldMatrix defines the new world matrix\n   */\n  constructor(min, max, worldMatrix) {\n    /**\n     * Gets the 8 vectors representing the bounding box in local space\n     */\n    this.vectors = ArrayTools.BuildArray(8, Vector3.Zero);\n    /**\n     * Gets the center of the bounding box in local space\n     */\n    this.center = Vector3.Zero();\n    /**\n     * Gets the center of the bounding box in world space\n     */\n    this.centerWorld = Vector3.Zero();\n    /**\n     * Gets the extend size in local space\n     */\n    this.extendSize = Vector3.Zero();\n    /**\n     * Gets the extend size in world space\n     */\n    this.extendSizeWorld = Vector3.Zero();\n    /**\n     * Gets the OBB (object bounding box) directions\n     */\n    this.directions = ArrayTools.BuildArray(3, Vector3.Zero);\n    /**\n     * Gets the 8 vectors representing the bounding box in world space\n     */\n    this.vectorsWorld = ArrayTools.BuildArray(8, Vector3.Zero);\n    /**\n     * Gets the minimum vector in world space\n     */\n    this.minimumWorld = Vector3.Zero();\n    /**\n     * Gets the maximum vector in world space\n     */\n    this.maximumWorld = Vector3.Zero();\n    /**\n     * Gets the minimum vector in local space\n     */\n    this.minimum = Vector3.Zero();\n    /**\n     * Gets the maximum vector in local space\n     */\n    this.maximum = Vector3.Zero();\n    /** @internal */\n    this._drawWrapperFront = null;\n    /** @internal */\n    this._drawWrapperBack = null;\n    this.reConstruct(min, max, worldMatrix);\n  }\n  // Methods\n  /**\n   * Recreates the entire bounding box from scratch as if we call the constructor in place\n   * @param min defines the new minimum vector (in local space)\n   * @param max defines the new maximum vector (in local space)\n   * @param worldMatrix defines the new world matrix\n   */\n  reConstruct(min, max, worldMatrix) {\n    const minX = min.x,\n      minY = min.y,\n      minZ = min.z,\n      maxX = max.x,\n      maxY = max.y,\n      maxZ = max.z;\n    const vectors = this.vectors;\n    this.minimum.copyFromFloats(minX, minY, minZ);\n    this.maximum.copyFromFloats(maxX, maxY, maxZ);\n    vectors[0].copyFromFloats(minX, minY, minZ);\n    vectors[1].copyFromFloats(maxX, maxY, maxZ);\n    vectors[2].copyFromFloats(maxX, minY, minZ);\n    vectors[3].copyFromFloats(minX, maxY, minZ);\n    vectors[4].copyFromFloats(minX, minY, maxZ);\n    vectors[5].copyFromFloats(maxX, maxY, minZ);\n    vectors[6].copyFromFloats(minX, maxY, maxZ);\n    vectors[7].copyFromFloats(maxX, minY, maxZ);\n    // OBB\n    max.addToRef(min, this.center).scaleInPlace(0.5);\n    max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);\n    this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;\n    this._update(this._worldMatrix);\n  }\n  /**\n   * Scale the current bounding box by applying a scale factor\n   * @param factor defines the scale factor to apply\n   * @returns the current bounding box\n   */\n  scale(factor) {\n    const tmpVectors = BoundingBox._TmpVector3;\n    const diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);\n    const len = diff.length();\n    diff.normalizeFromLength(len);\n    const distance = len * factor;\n    const newRadius = diff.scaleInPlace(distance * 0.5);\n    const min = this.center.subtractToRef(newRadius, tmpVectors[1]);\n    const max = this.center.addToRef(newRadius, tmpVectors[2]);\n    this.reConstruct(min, max, this._worldMatrix);\n    return this;\n  }\n  /**\n   * Gets the world matrix of the bounding box\n   * @returns a matrix\n   */\n  getWorldMatrix() {\n    return this._worldMatrix;\n  }\n  /**\n   * @internal\n   */\n  _update(world) {\n    const minWorld = this.minimumWorld;\n    const maxWorld = this.maximumWorld;\n    const directions = this.directions;\n    const vectorsWorld = this.vectorsWorld;\n    const vectors = this.vectors;\n    if (!world.isIdentity()) {\n      minWorld.setAll(Number.MAX_VALUE);\n      maxWorld.setAll(-Number.MAX_VALUE);\n      for (let index = 0; index < 8; ++index) {\n        const v = vectorsWorld[index];\n        Vector3.TransformCoordinatesToRef(vectors[index], world, v);\n        minWorld.minimizeInPlace(v);\n        maxWorld.maximizeInPlace(v);\n      }\n      // Extend\n      maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);\n      maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);\n    } else {\n      minWorld.copyFrom(this.minimum);\n      maxWorld.copyFrom(this.maximum);\n      for (let index = 0; index < 8; ++index) {\n        vectorsWorld[index].copyFrom(vectors[index]);\n      }\n      // Extend\n      this.extendSizeWorld.copyFrom(this.extendSize);\n      this.centerWorld.copyFrom(this.center);\n    }\n    Vector3.FromArrayToRef(world.m, 0, directions[0]);\n    Vector3.FromArrayToRef(world.m, 4, directions[1]);\n    Vector3.FromArrayToRef(world.m, 8, directions[2]);\n    this._worldMatrix = world;\n  }\n  /**\n   * Tests if the bounding box is intersecting the frustum planes\n   * @param frustumPlanes defines the frustum planes to test\n   * @returns true if there is an intersection\n   */\n  isInFrustum(frustumPlanes) {\n    return BoundingBox.IsInFrustum(this.vectorsWorld, frustumPlanes);\n  }\n  /**\n   * Tests if the bounding box is entirely inside the frustum planes\n   * @param frustumPlanes defines the frustum planes to test\n   * @returns true if there is an inclusion\n   */\n  isCompletelyInFrustum(frustumPlanes) {\n    return BoundingBox.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);\n  }\n  /**\n   * Tests if a point is inside the bounding box\n   * @param point defines the point to test\n   * @returns true if the point is inside the bounding box\n   */\n  intersectsPoint(point) {\n    const min = this.minimumWorld;\n    const max = this.maximumWorld;\n    const minX = min.x,\n      minY = min.y,\n      minZ = min.z,\n      maxX = max.x,\n      maxY = max.y,\n      maxZ = max.z;\n    const pointX = point.x,\n      pointY = point.y,\n      pointZ = point.z;\n    const delta = -Epsilon;\n    if (maxX - pointX < delta || delta > pointX - minX) {\n      return false;\n    }\n    if (maxY - pointY < delta || delta > pointY - minY) {\n      return false;\n    }\n    if (maxZ - pointZ < delta || delta > pointZ - minZ) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Tests if the bounding box intersects with a bounding sphere\n   * @param sphere defines the sphere to test\n   * @returns true if there is an intersection\n   */\n  intersectsSphere(sphere) {\n    return BoundingBox.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);\n  }\n  /**\n   * Tests if the bounding box intersects with a box defined by a min and max vectors\n   * @param min defines the min vector to use\n   * @param max defines the max vector to use\n   * @returns true if there is an intersection\n   */\n  intersectsMinMax(min, max) {\n    const myMin = this.minimumWorld;\n    const myMax = this.maximumWorld;\n    const myMinX = myMin.x,\n      myMinY = myMin.y,\n      myMinZ = myMin.z,\n      myMaxX = myMax.x,\n      myMaxY = myMax.y,\n      myMaxZ = myMax.z;\n    const minX = min.x,\n      minY = min.y,\n      minZ = min.z,\n      maxX = max.x,\n      maxY = max.y,\n      maxZ = max.z;\n    if (myMaxX < minX || myMinX > maxX) {\n      return false;\n    }\n    if (myMaxY < minY || myMinY > maxY) {\n      return false;\n    }\n    if (myMaxZ < minZ || myMinZ > maxZ) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Disposes the resources of the class\n   */\n  dispose() {\n    var _a, _b;\n    (_a = this._drawWrapperFront) === null || _a === void 0 ? void 0 : _a.dispose();\n    (_b = this._drawWrapperBack) === null || _b === void 0 ? void 0 : _b.dispose();\n  }\n  // Statics\n  /**\n   * Tests if two bounding boxes are intersections\n   * @param box0 defines the first box to test\n   * @param box1 defines the second box to test\n   * @returns true if there is an intersection\n   */\n  static Intersects(box0, box1) {\n    return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);\n  }\n  /**\n   * Tests if a bounding box defines by a min/max vectors intersects a sphere\n   * @param minPoint defines the minimum vector of the bounding box\n   * @param maxPoint defines the maximum vector of the bounding box\n   * @param sphereCenter defines the sphere center\n   * @param sphereRadius defines the sphere radius\n   * @returns true if there is an intersection\n   */\n  static IntersectsSphere(minPoint, maxPoint, sphereCenter, sphereRadius) {\n    const vector = BoundingBox._TmpVector3[0];\n    Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);\n    const num = Vector3.DistanceSquared(sphereCenter, vector);\n    return num <= sphereRadius * sphereRadius;\n  }\n  /**\n   * Tests if a bounding box defined with 8 vectors is entirely inside frustum planes\n   * @param boundingVectors defines an array of 8 vectors representing a bounding box\n   * @param frustumPlanes defines the frustum planes to test\n   * @returns true if there is an inclusion\n   */\n  static IsCompletelyInFrustum(boundingVectors, frustumPlanes) {\n    for (let p = 0; p < 6; ++p) {\n      const frustumPlane = frustumPlanes[p];\n      for (let i = 0; i < 8; ++i) {\n        if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * Tests if a bounding box defined with 8 vectors intersects frustum planes\n   * @param boundingVectors defines an array of 8 vectors representing a bounding box\n   * @param frustumPlanes defines the frustum planes to test\n   * @returns true if there is an intersection\n   */\n  static IsInFrustum(boundingVectors, frustumPlanes) {\n    for (let p = 0; p < 6; ++p) {\n      let canReturnFalse = true;\n      const frustumPlane = frustumPlanes[p];\n      for (let i = 0; i < 8; ++i) {\n        if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {\n          canReturnFalse = false;\n          break;\n        }\n      }\n      if (canReturnFalse) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nBoundingBox._TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);","map":{"version":3,"names":["ArrayTools","Matrix","Vector3","Epsilon","BoundingBox","constructor","min","max","worldMatrix","vectors","BuildArray","Zero","center","centerWorld","extendSize","extendSizeWorld","directions","vectorsWorld","minimumWorld","maximumWorld","minimum","maximum","_drawWrapperFront","_drawWrapperBack","reConstruct","minX","x","minY","y","minZ","z","maxX","maxY","maxZ","copyFromFloats","addToRef","scaleInPlace","subtractToRef","_worldMatrix","IdentityReadOnly","_update","scale","factor","tmpVectors","_TmpVector3","diff","len","length","normalizeFromLength","distance","newRadius","getWorldMatrix","world","minWorld","maxWorld","isIdentity","setAll","Number","MAX_VALUE","index","v","TransformCoordinatesToRef","minimizeInPlace","maximizeInPlace","copyFrom","FromArrayToRef","m","isInFrustum","frustumPlanes","IsInFrustum","isCompletelyInFrustum","IsCompletelyInFrustum","intersectsPoint","point","pointX","pointY","pointZ","delta","intersectsSphere","sphere","IntersectsSphere","radiusWorld","intersectsMinMax","myMin","myMax","myMinX","myMinY","myMinZ","myMaxX","myMaxY","myMaxZ","dispose","_a","_b","Intersects","box0","box1","minPoint","maxPoint","sphereCenter","sphereRadius","vector","ClampToRef","num","DistanceSquared","boundingVectors","p","frustumPlane","i","dotCoordinate","canReturnFalse"],"sources":["../../../../dev/core/src/Culling/boundingBox.ts"],"sourcesContent":["import type { DeepImmutable, Nullable } from \"../types\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { BoundingSphere } from \"../Culling/boundingSphere\";\r\n\r\nimport type { ICullable } from \"./boundingInfo\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\nimport type { DrawWrapper } from \"../Materials/drawWrapper\";\r\n\r\n/**\r\n * Class used to store bounding box information\r\n */\r\nexport class BoundingBox implements ICullable {\r\n    /**\r\n     * Gets the 8 vectors representing the bounding box in local space\r\n     */\r\n    public readonly vectors: Vector3[] = ArrayTools.BuildArray(8, Vector3.Zero);\r\n    /**\r\n     * Gets the center of the bounding box in local space\r\n     */\r\n    public readonly center: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the center of the bounding box in world space\r\n     */\r\n    public readonly centerWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the extend size in local space\r\n     */\r\n    public readonly extendSize: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the extend size in world space\r\n     */\r\n    public readonly extendSizeWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the OBB (object bounding box) directions\r\n     */\r\n    public readonly directions: Vector3[] = ArrayTools.BuildArray(3, Vector3.Zero);\r\n    /**\r\n     * Gets the 8 vectors representing the bounding box in world space\r\n     */\r\n    public readonly vectorsWorld: Vector3[] = ArrayTools.BuildArray(8, Vector3.Zero);\r\n    /**\r\n     * Gets the minimum vector in world space\r\n     */\r\n    public readonly minimumWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in world space\r\n     */\r\n    public readonly maximumWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the minimum vector in local space\r\n     */\r\n    public readonly minimum: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in local space\r\n     */\r\n    public readonly maximum: Vector3 = Vector3.Zero();\r\n\r\n    private _worldMatrix: DeepImmutable<Matrix>;\r\n    private static readonly _TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _tag: number;\r\n\r\n    /** @internal */\r\n    public _drawWrapperFront: Nullable<DrawWrapper> = null;\r\n    /** @internal */\r\n    public _drawWrapperBack: Nullable<DrawWrapper> = null;\r\n\r\n    /**\r\n     * Creates a new bounding box\r\n     * @param min defines the minimum vector (in local space)\r\n     * @param max defines the maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    constructor(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.reConstruct(min, max, worldMatrix);\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Recreates the entire bounding box from scratch as if we call the constructor in place\r\n     * @param min defines the new minimum vector (in local space)\r\n     * @param max defines the new maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    public reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        const vectors = this.vectors;\r\n\r\n        this.minimum.copyFromFloats(minX, minY, minZ);\r\n        this.maximum.copyFromFloats(maxX, maxY, maxZ);\r\n        vectors[0].copyFromFloats(minX, minY, minZ);\r\n        vectors[1].copyFromFloats(maxX, maxY, maxZ);\r\n        vectors[2].copyFromFloats(maxX, minY, minZ);\r\n        vectors[3].copyFromFloats(minX, maxY, minZ);\r\n        vectors[4].copyFromFloats(minX, minY, maxZ);\r\n        vectors[5].copyFromFloats(maxX, maxY, minZ);\r\n        vectors[6].copyFromFloats(minX, maxY, maxZ);\r\n        vectors[7].copyFromFloats(maxX, minY, maxZ);\r\n\r\n        // OBB\r\n        max.addToRef(min, this.center).scaleInPlace(0.5);\r\n        max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);\r\n\r\n        this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;\r\n\r\n        this._update(this._worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Scale the current bounding box by applying a scale factor\r\n     * @param factor defines the scale factor to apply\r\n     * @returns the current bounding box\r\n     */\r\n    public scale(factor: number): BoundingBox {\r\n        const tmpVectors = BoundingBox._TmpVector3;\r\n        const diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);\r\n        const len = diff.length();\r\n        diff.normalizeFromLength(len);\r\n        const distance = len * factor;\r\n        const newRadius = diff.scaleInPlace(distance * 0.5);\r\n\r\n        const min = this.center.subtractToRef(newRadius, tmpVectors[1]);\r\n        const max = this.center.addToRef(newRadius, tmpVectors[2]);\r\n\r\n        this.reConstruct(min, max, this._worldMatrix);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the world matrix of the bounding box\r\n     * @returns a matrix\r\n     */\r\n    public getWorldMatrix(): DeepImmutable<Matrix> {\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _update(world: DeepImmutable<Matrix>): void {\r\n        const minWorld = this.minimumWorld;\r\n        const maxWorld = this.maximumWorld;\r\n        const directions = this.directions;\r\n        const vectorsWorld = this.vectorsWorld;\r\n        const vectors = this.vectors;\r\n\r\n        if (!world.isIdentity()) {\r\n            minWorld.setAll(Number.MAX_VALUE);\r\n            maxWorld.setAll(-Number.MAX_VALUE);\r\n\r\n            for (let index = 0; index < 8; ++index) {\r\n                const v = vectorsWorld[index];\r\n                Vector3.TransformCoordinatesToRef(vectors[index], world, v);\r\n                minWorld.minimizeInPlace(v);\r\n                maxWorld.maximizeInPlace(v);\r\n            }\r\n\r\n            // Extend\r\n            maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);\r\n            maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);\r\n        } else {\r\n            minWorld.copyFrom(this.minimum);\r\n            maxWorld.copyFrom(this.maximum);\r\n            for (let index = 0; index < 8; ++index) {\r\n                vectorsWorld[index].copyFrom(vectors[index]);\r\n            }\r\n\r\n            // Extend\r\n            this.extendSizeWorld.copyFrom(this.extendSize);\r\n            this.centerWorld.copyFrom(this.center);\r\n        }\r\n\r\n        Vector3.FromArrayToRef(world.m, 0, directions[0]);\r\n        Vector3.FromArrayToRef(world.m, 4, directions[1]);\r\n        Vector3.FromArrayToRef(world.m, 8, directions[2]);\r\n\r\n        this._worldMatrix = world;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box is intersecting the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return BoundingBox.IsInFrustum(this.vectorsWorld, frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box is entirely inside the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an inclusion\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return BoundingBox.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Tests if a point is inside the bounding box\r\n     * @param point defines the point to test\r\n     * @returns true if the point is inside the bounding box\r\n     */\r\n    public intersectsPoint(point: DeepImmutable<Vector3>): boolean {\r\n        const min = this.minimumWorld;\r\n        const max = this.maximumWorld;\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        const pointX = point.x,\r\n            pointY = point.y,\r\n            pointZ = point.z;\r\n        const delta = -Epsilon;\r\n\r\n        if (maxX - pointX < delta || delta > pointX - minX) {\r\n            return false;\r\n        }\r\n\r\n        if (maxY - pointY < delta || delta > pointY - minY) {\r\n            return false;\r\n        }\r\n\r\n        if (maxZ - pointZ < delta || delta > pointZ - minZ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box intersects with a bounding sphere\r\n     * @param sphere defines the sphere to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsSphere(sphere: DeepImmutable<BoundingSphere>): boolean {\r\n        return BoundingBox.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box intersects with a box defined by a min and max vectors\r\n     * @param min defines the min vector to use\r\n     * @param max defines the max vector to use\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsMinMax(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>): boolean {\r\n        const myMin = this.minimumWorld;\r\n        const myMax = this.maximumWorld;\r\n        const myMinX = myMin.x,\r\n            myMinY = myMin.y,\r\n            myMinZ = myMin.z,\r\n            myMaxX = myMax.x,\r\n            myMaxY = myMax.y,\r\n            myMaxZ = myMax.z;\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        if (myMaxX < minX || myMinX > maxX) {\r\n            return false;\r\n        }\r\n\r\n        if (myMaxY < minY || myMinY > maxY) {\r\n            return false;\r\n        }\r\n\r\n        if (myMaxZ < minZ || myMinZ > maxZ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Disposes the resources of the class\r\n     */\r\n    public dispose(): void {\r\n        this._drawWrapperFront?.dispose();\r\n        this._drawWrapperBack?.dispose();\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Tests if two bounding boxes are intersections\r\n     * @param box0 defines the first box to test\r\n     * @param box1 defines the second box to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static Intersects(box0: DeepImmutable<BoundingBox>, box1: DeepImmutable<BoundingBox>): boolean {\r\n        return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defines by a min/max vectors intersects a sphere\r\n     * @param minPoint defines the minimum vector of the bounding box\r\n     * @param maxPoint defines the maximum vector of the bounding box\r\n     * @param sphereCenter defines the sphere center\r\n     * @param sphereRadius defines the sphere radius\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static IntersectsSphere(minPoint: DeepImmutable<Vector3>, maxPoint: DeepImmutable<Vector3>, sphereCenter: DeepImmutable<Vector3>, sphereRadius: number): boolean {\r\n        const vector = BoundingBox._TmpVector3[0];\r\n        Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);\r\n        const num = Vector3.DistanceSquared(sphereCenter, vector);\r\n        return num <= sphereRadius * sphereRadius;\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defined with 8 vectors is entirely inside frustum planes\r\n     * @param boundingVectors defines an array of 8 vectors representing a bounding box\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an inclusion\r\n     */\r\n    public static IsCompletelyInFrustum(boundingVectors: Array<DeepImmutable<Vector3>>, frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        for (let p = 0; p < 6; ++p) {\r\n            const frustumPlane = frustumPlanes[p];\r\n            for (let i = 0; i < 8; ++i) {\r\n                if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defined with 8 vectors intersects frustum planes\r\n     * @param boundingVectors defines an array of 8 vectors representing a bounding box\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static IsInFrustum(boundingVectors: Array<DeepImmutable<Vector3>>, frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        for (let p = 0; p < 6; ++p) {\r\n            let canReturnFalse = true;\r\n            const frustumPlane = frustumPlanes[p];\r\n            for (let i = 0; i < 8; ++i) {\r\n                if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {\r\n                    canReturnFalse = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (canReturnFalse) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}