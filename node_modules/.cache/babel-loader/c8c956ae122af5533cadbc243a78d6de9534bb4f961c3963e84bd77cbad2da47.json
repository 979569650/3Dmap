{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { SubMesh } from \"../Meshes/subMesh.js\";\nimport { SceneLoaderFlags } from \"../Loading/sceneLoaderFlags.js\";\nimport { BoundingInfo } from \"../Culling/boundingInfo.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Tags } from \"../Misc/tags.js\";\nimport { extractMinAndMax } from \"../Maths/math.functions.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { CompatibilityOptions } from \"../Compat/compatibilityOptions.js\";\n/**\n * Class used to store geometry data (vertex buffers + index buffer)\n */\nexport class Geometry {\n  /**\n   *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\n   */\n  get boundingBias() {\n    return this._boundingBias;\n  }\n  /**\n   *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\n   */\n  set boundingBias(value) {\n    if (this._boundingBias) {\n      this._boundingBias.copyFrom(value);\n    } else {\n      this._boundingBias = value.clone();\n    }\n    this._updateBoundingInfo(true, null);\n  }\n  /**\n   * Static function used to attach a new empty geometry to a mesh\n   * @param mesh defines the mesh to attach the geometry to\n   * @returns the new Geometry\n   */\n  static CreateGeometryForMesh(mesh) {\n    const geometry = new Geometry(Geometry.RandomId(), mesh.getScene());\n    geometry.applyToMesh(mesh);\n    return geometry;\n  }\n  /** Get the list of meshes using this geometry */\n  get meshes() {\n    return this._meshes;\n  }\n  /**\n   * Creates a new geometry\n   * @param id defines the unique ID\n   * @param scene defines the hosting scene\n   * @param vertexData defines the VertexData used to get geometry data\n   * @param updatable defines if geometry must be updatable (false by default)\n   * @param mesh defines the mesh that will be associated with the geometry\n   */\n  constructor(id, scene, vertexData, updatable = false, mesh = null) {\n    /**\n     * Gets the delay loading state of the geometry (none by default which means not delayed)\n     */\n    this.delayLoadState = 0;\n    this._totalVertices = 0;\n    this._isDisposed = false;\n    this._indexBufferIsUpdatable = false;\n    this._positionsCache = [];\n    /** @internal */\n    this._parentContainer = null;\n    /**\n     * If set to true (false by default), the bounding info applied to the meshes sharing this geometry will be the bounding info defined at the class level\n     * and won't be computed based on the vertex positions (which is what we get when useBoundingInfoFromGeometry = false)\n     */\n    this.useBoundingInfoFromGeometry = false;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    if (!this._scene) {\n      return;\n    }\n    this.id = id;\n    this.uniqueId = this._scene.getUniqueId();\n    this._engine = this._scene.getEngine();\n    this._meshes = [];\n    //Init vertex buffer cache\n    this._vertexBuffers = {};\n    this._indices = [];\n    this._updatable = updatable;\n    // vertexData\n    if (vertexData) {\n      this.setAllVerticesData(vertexData, updatable);\n    } else {\n      this._totalVertices = 0;\n    }\n    if (this._engine.getCaps().vertexArrayObject) {\n      this._vertexArrayObjects = {};\n    }\n    // applyToMesh\n    if (mesh) {\n      this.applyToMesh(mesh);\n      mesh.computeWorldMatrix(true);\n    }\n  }\n  /**\n   * Gets the current extend of the geometry\n   */\n  get extend() {\n    return this._extend;\n  }\n  /**\n   * Gets the hosting scene\n   * @returns the hosting Scene\n   */\n  getScene() {\n    return this._scene;\n  }\n  /**\n   * Gets the hosting engine\n   * @returns the hosting Engine\n   */\n  getEngine() {\n    return this._engine;\n  }\n  /**\n   * Defines if the geometry is ready to use\n   * @returns true if the geometry is ready to be used\n   */\n  isReady() {\n    return this.delayLoadState === 1 || this.delayLoadState === 0;\n  }\n  /**\n   * Gets a value indicating that the geometry should not be serialized\n   */\n  get doNotSerialize() {\n    for (let index = 0; index < this._meshes.length; index++) {\n      if (!this._meshes[index].doNotSerialize) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /** @internal */\n  _rebuild() {\n    if (this._vertexArrayObjects) {\n      this._vertexArrayObjects = {};\n    }\n    // Index buffer\n    if (this._meshes.length !== 0 && this._indices) {\n      this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);\n    }\n    // Vertex buffers\n    for (const key in this._vertexBuffers) {\n      const vertexBuffer = this._vertexBuffers[key];\n      vertexBuffer._rebuild();\n    }\n  }\n  /**\n   * Affects all geometry data in one call\n   * @param vertexData defines the geometry data\n   * @param updatable defines if the geometry must be flagged as updatable (false as default)\n   */\n  setAllVerticesData(vertexData, updatable) {\n    vertexData.applyToGeometry(this, updatable);\n    this._notifyUpdate();\n  }\n  /**\n   * Set specific vertex data\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @param data defines the vertex data to use\n   * @param updatable defines if the vertex must be flagged as updatable (false as default)\n   * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified\n   */\n  setVerticesData(kind, data, updatable = false, stride) {\n    if (updatable && Array.isArray(data)) {\n      // to avoid converting to Float32Array at each draw call in engine.updateDynamicVertexBuffer, we make the conversion a single time here\n      data = new Float32Array(data);\n    }\n    const buffer = new VertexBuffer(this._engine, data, kind, {\n      updatable,\n      postponeInternalCreation: this._meshes.length === 0,\n      stride,\n      label: \"Geometry_\" + this.id + \"_\" + kind\n    });\n    this.setVerticesBuffer(buffer);\n  }\n  /**\n   * Removes a specific vertex data\n   * @param kind defines the data kind (Position, normal, etc...)\n   */\n  removeVerticesData(kind) {\n    if (this._vertexBuffers[kind]) {\n      this._vertexBuffers[kind].dispose();\n      delete this._vertexBuffers[kind];\n    }\n    if (this._vertexArrayObjects) {\n      this._disposeVertexArrayObjects();\n    }\n  }\n  /**\n   * Affect a vertex buffer to the geometry. the vertexBuffer.getKind() function is used to determine where to store the data\n   * @param buffer defines the vertex buffer to use\n   * @param totalVertices defines the total number of vertices for position kind (could be null)\n   * @param disposeExistingBuffer disposes the existing buffer, if any (default: true)\n   */\n  setVerticesBuffer(buffer, totalVertices = null, disposeExistingBuffer = true) {\n    const kind = buffer.getKind();\n    if (this._vertexBuffers[kind] && disposeExistingBuffer) {\n      this._vertexBuffers[kind].dispose();\n    }\n    if (buffer._buffer) {\n      buffer._buffer._increaseReferences();\n    }\n    this._vertexBuffers[kind] = buffer;\n    const meshes = this._meshes;\n    const numOfMeshes = meshes.length;\n    if (kind === VertexBuffer.PositionKind) {\n      this._totalVertices = totalVertices !== null && totalVertices !== void 0 ? totalVertices : buffer.totalVertices;\n      this._updateExtend(buffer.getFloatData());\n      this._resetPointsArrayCache();\n      // this._extend can be empty if buffer.getFloatData() returned null\n      const minimum = this._extend && this._extend.minimum || new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n      const maximum = this._extend && this._extend.maximum || new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n      for (let index = 0; index < numOfMeshes; index++) {\n        const mesh = meshes[index];\n        mesh.buildBoundingInfo(minimum, maximum);\n        mesh._createGlobalSubMesh(mesh.isUnIndexed);\n        mesh.computeWorldMatrix(true);\n        mesh.synchronizeInstances();\n      }\n    }\n    this._notifyUpdate(kind);\n  }\n  /**\n   * Update a specific vertex buffer\n   * This function will directly update the underlying DataBuffer according to the passed numeric array or Float32Array\n   * It will do nothing if the buffer is not updatable\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @param data defines the data to use\n   * @param offset defines the offset in the target buffer where to store the data\n   * @param useBytes set to true if the offset is in bytes\n   */\n  updateVerticesDataDirectly(kind, data, offset, useBytes = false) {\n    const vertexBuffer = this.getVertexBuffer(kind);\n    if (!vertexBuffer) {\n      return;\n    }\n    vertexBuffer.updateDirectly(data, offset, useBytes);\n    this._notifyUpdate(kind);\n  }\n  /**\n   * Update a specific vertex buffer\n   * This function will create a new buffer if the current one is not updatable\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @param data defines the data to use\n   * @param updateExtends defines if the geometry extends must be recomputed (false by default)\n   */\n  updateVerticesData(kind, data, updateExtends = false) {\n    const vertexBuffer = this.getVertexBuffer(kind);\n    if (!vertexBuffer) {\n      return;\n    }\n    vertexBuffer.update(data);\n    if (kind === VertexBuffer.PositionKind) {\n      this._updateBoundingInfo(updateExtends, data);\n    }\n    this._notifyUpdate(kind);\n  }\n  _updateBoundingInfo(updateExtends, data) {\n    if (updateExtends) {\n      this._updateExtend(data);\n    }\n    this._resetPointsArrayCache();\n    if (updateExtends) {\n      const meshes = this._meshes;\n      for (const mesh of meshes) {\n        if (mesh.hasBoundingInfo) {\n          mesh.getBoundingInfo().reConstruct(this._extend.minimum, this._extend.maximum);\n        } else {\n          mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\n        }\n        const subMeshes = mesh.subMeshes;\n        for (const subMesh of subMeshes) {\n          subMesh.refreshBoundingInfo();\n        }\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _bind(effect, indexToBind, overrideVertexBuffers, overrideVertexArrayObjects) {\n    if (!effect) {\n      return;\n    }\n    if (indexToBind === undefined) {\n      indexToBind = this._indexBuffer;\n    }\n    const vbs = this.getVertexBuffers();\n    if (!vbs) {\n      return;\n    }\n    if (indexToBind != this._indexBuffer || !this._vertexArrayObjects && !overrideVertexArrayObjects) {\n      this._engine.bindBuffers(vbs, indexToBind, effect, overrideVertexBuffers);\n      return;\n    }\n    const vaos = overrideVertexArrayObjects ? overrideVertexArrayObjects : this._vertexArrayObjects;\n    // Using VAO\n    if (!vaos[effect.key]) {\n      vaos[effect.key] = this._engine.recordVertexArrayObject(vbs, indexToBind, effect, overrideVertexBuffers);\n    }\n    this._engine.bindVertexArrayObject(vaos[effect.key], indexToBind);\n  }\n  /**\n   * Gets total number of vertices\n   * @returns the total number of vertices\n   */\n  getTotalVertices() {\n    if (!this.isReady()) {\n      return 0;\n    }\n    return this._totalVertices;\n  }\n  /**\n   * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\n   * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\n   * @returns a float array containing vertex data\n   */\n  getVerticesData(kind, copyWhenShared, forceCopy) {\n    const vertexBuffer = this.getVertexBuffer(kind);\n    if (!vertexBuffer) {\n      return null;\n    }\n    return vertexBuffer.getFloatData(this._totalVertices, forceCopy || copyWhenShared && this._meshes.length !== 1);\n  }\n  /**\n   * Returns a boolean defining if the vertex data for the requested `kind` is updatable\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @returns true if the vertex buffer with the specified kind is updatable\n   */\n  isVertexBufferUpdatable(kind) {\n    const vb = this._vertexBuffers[kind];\n    if (!vb) {\n      return false;\n    }\n    return vb.isUpdatable();\n  }\n  /**\n   * Gets a specific vertex buffer\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @returns a VertexBuffer\n   */\n  getVertexBuffer(kind) {\n    if (!this.isReady()) {\n      return null;\n    }\n    return this._vertexBuffers[kind];\n  }\n  /**\n   * Returns all vertex buffers\n   * @returns an object holding all vertex buffers indexed by kind\n   */\n  getVertexBuffers() {\n    if (!this.isReady()) {\n      return null;\n    }\n    return this._vertexBuffers;\n  }\n  /**\n   * Gets a boolean indicating if specific vertex buffer is present\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @returns true if data is present\n   */\n  isVerticesDataPresent(kind) {\n    if (!this._vertexBuffers) {\n      if (this._delayInfo) {\n        return this._delayInfo.indexOf(kind) !== -1;\n      }\n      return false;\n    }\n    return this._vertexBuffers[kind] !== undefined;\n  }\n  /**\n   * Gets a list of all attached data kinds (Position, normal, etc...)\n   * @returns a list of string containing all kinds\n   */\n  getVerticesDataKinds() {\n    const result = [];\n    let kind;\n    if (!this._vertexBuffers && this._delayInfo) {\n      for (kind in this._delayInfo) {\n        result.push(kind);\n      }\n    } else {\n      for (kind in this._vertexBuffers) {\n        result.push(kind);\n      }\n    }\n    return result;\n  }\n  /**\n   * Update index buffer\n   * @param indices defines the indices to store in the index buffer\n   * @param offset defines the offset in the target buffer where to store the data\n   * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\n   */\n  updateIndices(indices, offset, gpuMemoryOnly = false) {\n    if (!this._indexBuffer) {\n      return;\n    }\n    if (!this._indexBufferIsUpdatable) {\n      this.setIndices(indices, null, true);\n    } else {\n      const needToUpdateSubMeshes = indices.length !== this._indices.length;\n      if (!gpuMemoryOnly) {\n        this._indices = indices.slice();\n      }\n      this._engine.updateDynamicIndexBuffer(this._indexBuffer, indices, offset);\n      if (needToUpdateSubMeshes) {\n        for (const mesh of this._meshes) {\n          mesh._createGlobalSubMesh(true);\n        }\n      }\n    }\n  }\n  /**\n   * Creates a new index buffer\n   * @param indices defines the indices to store in the index buffer\n   * @param totalVertices defines the total number of vertices (could be null)\n   * @param updatable defines if the index buffer must be flagged as updatable (false by default)\n   */\n  setIndices(indices, totalVertices = null, updatable = false) {\n    if (this._indexBuffer) {\n      this._engine._releaseBuffer(this._indexBuffer);\n    }\n    this._indices = indices;\n    this._indexBufferIsUpdatable = updatable;\n    if (this._meshes.length !== 0 && this._indices) {\n      this._indexBuffer = this._engine.createIndexBuffer(this._indices, updatable);\n    }\n    if (totalVertices != undefined) {\n      // including null and undefined\n      this._totalVertices = totalVertices;\n    }\n    for (const mesh of this._meshes) {\n      mesh._createGlobalSubMesh(true);\n      mesh.synchronizeInstances();\n    }\n    this._notifyUpdate();\n  }\n  /**\n   * Return the total number of indices\n   * @returns the total number of indices\n   */\n  getTotalIndices() {\n    if (!this.isReady()) {\n      return 0;\n    }\n    return this._indices.length;\n  }\n  /**\n   * Gets the index buffer array\n   * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\n   * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\n   * @returns the index buffer array\n   */\n  getIndices(copyWhenShared, forceCopy) {\n    if (!this.isReady()) {\n      return null;\n    }\n    const orig = this._indices;\n    if (!forceCopy && (!copyWhenShared || this._meshes.length === 1)) {\n      return orig;\n    } else {\n      return orig.slice();\n    }\n  }\n  /**\n   * Gets the index buffer\n   * @returns the index buffer\n   */\n  getIndexBuffer() {\n    if (!this.isReady()) {\n      return null;\n    }\n    return this._indexBuffer;\n  }\n  /**\n   * @internal\n   */\n  _releaseVertexArrayObject(effect = null) {\n    if (!effect || !this._vertexArrayObjects) {\n      return;\n    }\n    if (this._vertexArrayObjects[effect.key]) {\n      this._engine.releaseVertexArrayObject(this._vertexArrayObjects[effect.key]);\n      delete this._vertexArrayObjects[effect.key];\n    }\n  }\n  /**\n   * Release the associated resources for a specific mesh\n   * @param mesh defines the source mesh\n   * @param shouldDispose defines if the geometry must be disposed if there is no more mesh pointing to it\n   */\n  releaseForMesh(mesh, shouldDispose) {\n    const meshes = this._meshes;\n    const index = meshes.indexOf(mesh);\n    if (index === -1) {\n      return;\n    }\n    meshes.splice(index, 1);\n    if (this._vertexArrayObjects) {\n      mesh._invalidateInstanceVertexArrayObject();\n    }\n    mesh._geometry = null;\n    if (meshes.length === 0 && shouldDispose) {\n      this.dispose();\n    }\n  }\n  /**\n   * Apply current geometry to a given mesh\n   * @param mesh defines the mesh to apply geometry to\n   */\n  applyToMesh(mesh) {\n    if (mesh._geometry === this) {\n      return;\n    }\n    const previousGeometry = mesh._geometry;\n    if (previousGeometry) {\n      previousGeometry.releaseForMesh(mesh);\n    }\n    if (this._vertexArrayObjects) {\n      mesh._invalidateInstanceVertexArrayObject();\n    }\n    const meshes = this._meshes;\n    // must be done before setting vertexBuffers because of mesh._createGlobalSubMesh()\n    mesh._geometry = this;\n    mesh._internalAbstractMeshDataInfo._positions = null;\n    this._scene.pushGeometry(this);\n    meshes.push(mesh);\n    if (this.isReady()) {\n      this._applyToMesh(mesh);\n    } else if (this._boundingInfo) {\n      mesh.setBoundingInfo(this._boundingInfo);\n    }\n  }\n  _updateExtend(data = null) {\n    if (this.useBoundingInfoFromGeometry && this._boundingInfo) {\n      this._extend = {\n        minimum: this._boundingInfo.minimum.clone(),\n        maximum: this._boundingInfo.maximum.clone()\n      };\n    } else {\n      if (!data) {\n        data = this.getVerticesData(VertexBuffer.PositionKind);\n        // This can happen if the buffer comes from a Hardware Buffer where\n        // The data have not been uploaded by Babylon. (ex: Compute Shaders and Storage Buffers)\n        if (!data) {\n          return;\n        }\n      }\n      this._extend = extractMinAndMax(data, 0, this._totalVertices, this.boundingBias, 3);\n    }\n  }\n  _applyToMesh(mesh) {\n    const numOfMeshes = this._meshes.length;\n    // vertexBuffers\n    for (const kind in this._vertexBuffers) {\n      if (numOfMeshes === 1) {\n        this._vertexBuffers[kind].create();\n      }\n      if (kind === VertexBuffer.PositionKind) {\n        if (!this._extend) {\n          this._updateExtend();\n        }\n        mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\n        mesh._createGlobalSubMesh(mesh.isUnIndexed);\n        //bounding info was just created again, world matrix should be applied again.\n        mesh._updateBoundingInfo();\n      }\n    }\n    // indexBuffer\n    if (numOfMeshes === 1 && this._indices && this._indices.length > 0) {\n      this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);\n    }\n    // morphTargets\n    mesh._syncGeometryWithMorphTargetManager();\n    // instances\n    mesh.synchronizeInstances();\n  }\n  _notifyUpdate(kind) {\n    if (this.onGeometryUpdated) {\n      this.onGeometryUpdated(this, kind);\n    }\n    if (this._vertexArrayObjects) {\n      this._disposeVertexArrayObjects();\n    }\n    for (const mesh of this._meshes) {\n      mesh._markSubMeshesAsAttributesDirty();\n    }\n  }\n  /**\n   * Load the geometry if it was flagged as delay loaded\n   * @param scene defines the hosting scene\n   * @param onLoaded defines a callback called when the geometry is loaded\n   */\n  load(scene, onLoaded) {\n    if (this.delayLoadState === 2) {\n      return;\n    }\n    if (this.isReady()) {\n      if (onLoaded) {\n        onLoaded();\n      }\n      return;\n    }\n    this.delayLoadState = 2;\n    this._queueLoad(scene, onLoaded);\n  }\n  _queueLoad(scene, onLoaded) {\n    if (!this.delayLoadingFile) {\n      return;\n    }\n    scene.addPendingData(this);\n    scene._loadFile(this.delayLoadingFile, data => {\n      if (!this._delayLoadingFunction) {\n        return;\n      }\n      this._delayLoadingFunction(JSON.parse(data), this);\n      this.delayLoadState = 1;\n      this._delayInfo = [];\n      scene.removePendingData(this);\n      const meshes = this._meshes;\n      const numOfMeshes = meshes.length;\n      for (let index = 0; index < numOfMeshes; index++) {\n        this._applyToMesh(meshes[index]);\n      }\n      if (onLoaded) {\n        onLoaded();\n      }\n    }, undefined, true);\n  }\n  /**\n   * Invert the geometry to move from a right handed system to a left handed one.\n   */\n  toLeftHanded() {\n    // Flip faces\n    const tIndices = this.getIndices(false);\n    if (tIndices != null && tIndices.length > 0) {\n      for (let i = 0; i < tIndices.length; i += 3) {\n        const tTemp = tIndices[i + 0];\n        tIndices[i + 0] = tIndices[i + 2];\n        tIndices[i + 2] = tTemp;\n      }\n      this.setIndices(tIndices);\n    }\n    // Negate position.z\n    const tPositions = this.getVerticesData(VertexBuffer.PositionKind, false);\n    if (tPositions != null && tPositions.length > 0) {\n      for (let i = 0; i < tPositions.length; i += 3) {\n        tPositions[i + 2] = -tPositions[i + 2];\n      }\n      this.setVerticesData(VertexBuffer.PositionKind, tPositions, false);\n    }\n    // Negate normal.z\n    const tNormals = this.getVerticesData(VertexBuffer.NormalKind, false);\n    if (tNormals != null && tNormals.length > 0) {\n      for (let i = 0; i < tNormals.length; i += 3) {\n        tNormals[i + 2] = -tNormals[i + 2];\n      }\n      this.setVerticesData(VertexBuffer.NormalKind, tNormals, false);\n    }\n  }\n  // Cache\n  /** @internal */\n  _resetPointsArrayCache() {\n    this._positions = null;\n  }\n  /** @internal */\n  _generatePointsArray() {\n    if (this._positions) {\n      return true;\n    }\n    const data = this.getVerticesData(VertexBuffer.PositionKind);\n    if (!data || data.length === 0) {\n      return false;\n    }\n    for (let index = this._positionsCache.length * 3, arrayIdx = this._positionsCache.length; index < data.length; index += 3, ++arrayIdx) {\n      this._positionsCache[arrayIdx] = Vector3.FromArray(data, index);\n    }\n    for (let index = 0, arrayIdx = 0; index < data.length; index += 3, ++arrayIdx) {\n      this._positionsCache[arrayIdx].set(data[0 + index], data[1 + index], data[2 + index]);\n    }\n    // just in case the number of positions was reduced, splice the array\n    this._positionsCache.length = data.length / 3;\n    this._positions = this._positionsCache;\n    return true;\n  }\n  /**\n   * Gets a value indicating if the geometry is disposed\n   * @returns true if the geometry was disposed\n   */\n  isDisposed() {\n    return this._isDisposed;\n  }\n  _disposeVertexArrayObjects() {\n    if (this._vertexArrayObjects) {\n      for (const kind in this._vertexArrayObjects) {\n        this._engine.releaseVertexArrayObject(this._vertexArrayObjects[kind]);\n      }\n      this._vertexArrayObjects = {}; // Will trigger a rebuild of the VAO if supported\n      const meshes = this._meshes;\n      const numOfMeshes = meshes.length;\n      for (let index = 0; index < numOfMeshes; index++) {\n        meshes[index]._invalidateInstanceVertexArrayObject();\n      }\n    }\n  }\n  /**\n   * Free all associated resources\n   */\n  dispose() {\n    const meshes = this._meshes;\n    const numOfMeshes = meshes.length;\n    let index;\n    for (index = 0; index < numOfMeshes; index++) {\n      this.releaseForMesh(meshes[index]);\n    }\n    this._meshes.length = 0;\n    this._disposeVertexArrayObjects();\n    for (const kind in this._vertexBuffers) {\n      this._vertexBuffers[kind].dispose();\n    }\n    this._vertexBuffers = {};\n    this._totalVertices = 0;\n    if (this._indexBuffer) {\n      this._engine._releaseBuffer(this._indexBuffer);\n    }\n    this._indexBuffer = null;\n    this._indices = [];\n    this.delayLoadState = 0;\n    this.delayLoadingFile = null;\n    this._delayLoadingFunction = null;\n    this._delayInfo = [];\n    this._boundingInfo = null;\n    this._scene.removeGeometry(this);\n    if (this._parentContainer) {\n      const index = this._parentContainer.geometries.indexOf(this);\n      if (index > -1) {\n        this._parentContainer.geometries.splice(index, 1);\n      }\n      this._parentContainer = null;\n    }\n    this._isDisposed = true;\n  }\n  /**\n   * Clone the current geometry into a new geometry\n   * @param id defines the unique ID of the new geometry\n   * @returns a new geometry object\n   */\n  copy(id) {\n    const vertexData = new VertexData();\n    vertexData.indices = [];\n    const indices = this.getIndices();\n    if (indices) {\n      for (let index = 0; index < indices.length; index++) {\n        vertexData.indices.push(indices[index]);\n      }\n    }\n    let updatable = false;\n    let stopChecking = false;\n    let kind;\n    for (kind in this._vertexBuffers) {\n      // using slice() to make a copy of the array and not just reference it\n      const data = this.getVerticesData(kind);\n      if (data) {\n        if (data instanceof Float32Array) {\n          vertexData.set(new Float32Array(data), kind);\n        } else {\n          vertexData.set(data.slice(0), kind);\n        }\n        if (!stopChecking) {\n          const vb = this.getVertexBuffer(kind);\n          if (vb) {\n            updatable = vb.isUpdatable();\n            stopChecking = !updatable;\n          }\n        }\n      }\n    }\n    const geometry = new Geometry(id, this._scene, vertexData, updatable);\n    geometry.delayLoadState = this.delayLoadState;\n    geometry.delayLoadingFile = this.delayLoadingFile;\n    geometry._delayLoadingFunction = this._delayLoadingFunction;\n    for (kind in this._delayInfo) {\n      geometry._delayInfo = geometry._delayInfo || [];\n      geometry._delayInfo.push(kind);\n    }\n    // Bounding info\n    geometry._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\n    return geometry;\n  }\n  /**\n   * Serialize the current geometry info (and not the vertices data) into a JSON object\n   * @returns a JSON representation of the current geometry data (without the vertices data)\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.id = this.id;\n    serializationObject.uniqueId = this.uniqueId;\n    serializationObject.updatable = this._updatable;\n    if (Tags && Tags.HasTags(this)) {\n      serializationObject.tags = Tags.GetTags(this);\n    }\n    return serializationObject;\n  }\n  _toNumberArray(origin) {\n    if (Array.isArray(origin)) {\n      return origin;\n    } else {\n      return Array.prototype.slice.call(origin);\n    }\n  }\n  /**\n   * Release any memory retained by the cached data on the Geometry.\n   *\n   * Call this function to reduce memory footprint of the mesh.\n   * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)\n   */\n  clearCachedData() {\n    this._indices = [];\n    this._resetPointsArrayCache();\n    for (const vbName in this._vertexBuffers) {\n      if (!Object.prototype.hasOwnProperty.call(this._vertexBuffers, vbName)) {\n        continue;\n      }\n      this._vertexBuffers[vbName]._buffer._data = null;\n    }\n  }\n  /**\n   * Serialize all vertices data into a JSON object\n   * @returns a JSON representation of the current geometry data\n   */\n  serializeVerticeData() {\n    const serializationObject = this.serialize();\n    if (this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n      serializationObject.positions = this._toNumberArray(this.getVerticesData(VertexBuffer.PositionKind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {\n        serializationObject.positions._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      serializationObject.normals = this._toNumberArray(this.getVerticesData(VertexBuffer.NormalKind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {\n        serializationObject.normals._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n      serializationObject.tangents = this._toNumberArray(this.getVerticesData(VertexBuffer.TangentKind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.TangentKind)) {\n        serializationObject.tangents._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.UVKind)) {\n      serializationObject.uvs = this._toNumberArray(this.getVerticesData(VertexBuffer.UVKind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.UVKind)) {\n        serializationObject.uvs._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n      serializationObject.uvs2 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV2Kind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV2Kind)) {\n        serializationObject.uvs2._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\n      serializationObject.uvs3 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV3Kind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV3Kind)) {\n        serializationObject.uvs3._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\n      serializationObject.uvs4 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV4Kind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV4Kind)) {\n        serializationObject.uvs4._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\n      serializationObject.uvs5 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV5Kind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV5Kind)) {\n        serializationObject.uvs5._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\n      serializationObject.uvs6 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV6Kind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV6Kind)) {\n        serializationObject.uvs6._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.ColorKind)) {\n      serializationObject.colors = this._toNumberArray(this.getVerticesData(VertexBuffer.ColorKind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.ColorKind)) {\n        serializationObject.colors._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\n      serializationObject.matricesIndices = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesIndicesKind));\n      serializationObject.matricesIndices._isExpanded = true;\n      if (this.isVertexBufferUpdatable(VertexBuffer.MatricesIndicesKind)) {\n        serializationObject.matricesIndices._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n      serializationObject.matricesWeights = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesWeightsKind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.MatricesWeightsKind)) {\n        serializationObject.matricesWeights._updatable = true;\n      }\n    }\n    serializationObject.indices = this._toNumberArray(this.getIndices());\n    return serializationObject;\n  }\n  // Statics\n  /**\n   * Extracts a clone of a mesh geometry\n   * @param mesh defines the source mesh\n   * @param id defines the unique ID of the new geometry object\n   * @returns the new geometry object\n   */\n  static ExtractFromMesh(mesh, id) {\n    const geometry = mesh._geometry;\n    if (!geometry) {\n      return null;\n    }\n    return geometry.copy(id);\n  }\n  /**\n   * You should now use Tools.RandomId(), this method is still here for legacy reasons.\n   * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523\n   * Be aware Math.random() could cause collisions, but:\n   * \"All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide\"\n   * @returns a string containing a new GUID\n   */\n  static RandomId() {\n    return Tools.RandomId();\n  }\n  static _GetGeometryByLoadedUniqueId(uniqueId, scene) {\n    for (let index = 0; index < scene.geometries.length; index++) {\n      if (scene.geometries[index]._loadedUniqueId === uniqueId) {\n        return scene.geometries[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * @internal\n   */\n  static _ImportGeometry(parsedGeometry, mesh) {\n    const scene = mesh.getScene();\n    // Geometry\n    const geometryUniqueId = parsedGeometry.geometryUniqueId;\n    const geometryId = parsedGeometry.geometryId;\n    if (geometryUniqueId || geometryId) {\n      const geometry = geometryUniqueId ? this._GetGeometryByLoadedUniqueId(geometryUniqueId, scene) : scene.getGeometryById(geometryId);\n      if (geometry) {\n        geometry.applyToMesh(mesh);\n      }\n    } else if (parsedGeometry instanceof ArrayBuffer) {\n      const binaryInfo = mesh._binaryInfo;\n      if (binaryInfo.positionsAttrDesc && binaryInfo.positionsAttrDesc.count > 0) {\n        const positionsData = new Float32Array(parsedGeometry, binaryInfo.positionsAttrDesc.offset, binaryInfo.positionsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.PositionKind, positionsData, false);\n      }\n      if (binaryInfo.normalsAttrDesc && binaryInfo.normalsAttrDesc.count > 0) {\n        const normalsData = new Float32Array(parsedGeometry, binaryInfo.normalsAttrDesc.offset, binaryInfo.normalsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.NormalKind, normalsData, false);\n      }\n      if (binaryInfo.tangetsAttrDesc && binaryInfo.tangetsAttrDesc.count > 0) {\n        const tangentsData = new Float32Array(parsedGeometry, binaryInfo.tangetsAttrDesc.offset, binaryInfo.tangetsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.TangentKind, tangentsData, false);\n      }\n      if (binaryInfo.uvsAttrDesc && binaryInfo.uvsAttrDesc.count > 0) {\n        const uvsData = new Float32Array(parsedGeometry, binaryInfo.uvsAttrDesc.offset, binaryInfo.uvsAttrDesc.count);\n        if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n          for (let index = 1; index < uvsData.length; index += 2) {\n            uvsData[index] = 1 - uvsData[index];\n          }\n        }\n        mesh.setVerticesData(VertexBuffer.UVKind, uvsData, false);\n      }\n      if (binaryInfo.uvs2AttrDesc && binaryInfo.uvs2AttrDesc.count > 0) {\n        const uvs2Data = new Float32Array(parsedGeometry, binaryInfo.uvs2AttrDesc.offset, binaryInfo.uvs2AttrDesc.count);\n        if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n          for (let index = 1; index < uvs2Data.length; index += 2) {\n            uvs2Data[index] = 1 - uvs2Data[index];\n          }\n        }\n        mesh.setVerticesData(VertexBuffer.UV2Kind, uvs2Data, false);\n      }\n      if (binaryInfo.uvs3AttrDesc && binaryInfo.uvs3AttrDesc.count > 0) {\n        const uvs3Data = new Float32Array(parsedGeometry, binaryInfo.uvs3AttrDesc.offset, binaryInfo.uvs3AttrDesc.count);\n        if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n          for (let index = 1; index < uvs3Data.length; index += 2) {\n            uvs3Data[index] = 1 - uvs3Data[index];\n          }\n        }\n        mesh.setVerticesData(VertexBuffer.UV3Kind, uvs3Data, false);\n      }\n      if (binaryInfo.uvs4AttrDesc && binaryInfo.uvs4AttrDesc.count > 0) {\n        const uvs4Data = new Float32Array(parsedGeometry, binaryInfo.uvs4AttrDesc.offset, binaryInfo.uvs4AttrDesc.count);\n        if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n          for (let index = 1; index < uvs4Data.length; index += 2) {\n            uvs4Data[index] = 1 - uvs4Data[index];\n          }\n        }\n        mesh.setVerticesData(VertexBuffer.UV4Kind, uvs4Data, false);\n      }\n      if (binaryInfo.uvs5AttrDesc && binaryInfo.uvs5AttrDesc.count > 0) {\n        const uvs5Data = new Float32Array(parsedGeometry, binaryInfo.uvs5AttrDesc.offset, binaryInfo.uvs5AttrDesc.count);\n        if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n          for (let index = 1; index < uvs5Data.length; index += 2) {\n            uvs5Data[index] = 1 - uvs5Data[index];\n          }\n        }\n        mesh.setVerticesData(VertexBuffer.UV5Kind, uvs5Data, false);\n      }\n      if (binaryInfo.uvs6AttrDesc && binaryInfo.uvs6AttrDesc.count > 0) {\n        const uvs6Data = new Float32Array(parsedGeometry, binaryInfo.uvs6AttrDesc.offset, binaryInfo.uvs6AttrDesc.count);\n        if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n          for (let index = 1; index < uvs6Data.length; index += 2) {\n            uvs6Data[index] = 1 - uvs6Data[index];\n          }\n        }\n        mesh.setVerticesData(VertexBuffer.UV6Kind, uvs6Data, false);\n      }\n      if (binaryInfo.colorsAttrDesc && binaryInfo.colorsAttrDesc.count > 0) {\n        const colorsData = new Float32Array(parsedGeometry, binaryInfo.colorsAttrDesc.offset, binaryInfo.colorsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.ColorKind, colorsData, false, binaryInfo.colorsAttrDesc.stride);\n      }\n      if (binaryInfo.matricesIndicesAttrDesc && binaryInfo.matricesIndicesAttrDesc.count > 0) {\n        const matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesAttrDesc.offset, binaryInfo.matricesIndicesAttrDesc.count);\n        const floatIndices = [];\n        for (let i = 0; i < matricesIndicesData.length; i++) {\n          const index = matricesIndicesData[i];\n          floatIndices.push(index & 0x000000ff);\n          floatIndices.push((index & 0x0000ff00) >> 8);\n          floatIndices.push((index & 0x00ff0000) >> 16);\n          floatIndices.push(index >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0\n        }\n\n        mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, false);\n      }\n      if (binaryInfo.matricesIndicesExtraAttrDesc && binaryInfo.matricesIndicesExtraAttrDesc.count > 0) {\n        const matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesExtraAttrDesc.offset, binaryInfo.matricesIndicesExtraAttrDesc.count);\n        const floatIndices = [];\n        for (let i = 0; i < matricesIndicesData.length; i++) {\n          const index = matricesIndicesData[i];\n          floatIndices.push(index & 0x000000ff);\n          floatIndices.push((index & 0x0000ff00) >> 8);\n          floatIndices.push((index & 0x00ff0000) >> 16);\n          floatIndices.push(index >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0\n        }\n\n        mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, false);\n      }\n      if (binaryInfo.matricesWeightsAttrDesc && binaryInfo.matricesWeightsAttrDesc.count > 0) {\n        const matricesWeightsData = new Float32Array(parsedGeometry, binaryInfo.matricesWeightsAttrDesc.offset, binaryInfo.matricesWeightsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsData, false);\n      }\n      if (binaryInfo.indicesAttrDesc && binaryInfo.indicesAttrDesc.count > 0) {\n        const indicesData = new Int32Array(parsedGeometry, binaryInfo.indicesAttrDesc.offset, binaryInfo.indicesAttrDesc.count);\n        mesh.setIndices(indicesData, null);\n      }\n      if (binaryInfo.subMeshesAttrDesc && binaryInfo.subMeshesAttrDesc.count > 0) {\n        const subMeshesData = new Int32Array(parsedGeometry, binaryInfo.subMeshesAttrDesc.offset, binaryInfo.subMeshesAttrDesc.count * 5);\n        mesh.subMeshes = [];\n        for (let i = 0; i < binaryInfo.subMeshesAttrDesc.count; i++) {\n          const materialIndex = subMeshesData[i * 5 + 0];\n          const verticesStart = subMeshesData[i * 5 + 1];\n          const verticesCount = subMeshesData[i * 5 + 2];\n          const indexStart = subMeshesData[i * 5 + 3];\n          const indexCount = subMeshesData[i * 5 + 4];\n          SubMesh.AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh);\n        }\n      }\n    } else if (parsedGeometry.positions && parsedGeometry.normals && parsedGeometry.indices) {\n      mesh.setVerticesData(VertexBuffer.PositionKind, parsedGeometry.positions, parsedGeometry.positions._updatable);\n      mesh.setVerticesData(VertexBuffer.NormalKind, parsedGeometry.normals, parsedGeometry.normals._updatable);\n      if (parsedGeometry.tangents) {\n        mesh.setVerticesData(VertexBuffer.TangentKind, parsedGeometry.tangents, parsedGeometry.tangents._updatable);\n      }\n      if (parsedGeometry.uvs) {\n        mesh.setVerticesData(VertexBuffer.UVKind, parsedGeometry.uvs, parsedGeometry.uvs._updatable);\n      }\n      if (parsedGeometry.uvs2) {\n        mesh.setVerticesData(VertexBuffer.UV2Kind, parsedGeometry.uvs2, parsedGeometry.uvs2._updatable);\n      }\n      if (parsedGeometry.uvs3) {\n        mesh.setVerticesData(VertexBuffer.UV3Kind, parsedGeometry.uvs3, parsedGeometry.uvs3._updatable);\n      }\n      if (parsedGeometry.uvs4) {\n        mesh.setVerticesData(VertexBuffer.UV4Kind, parsedGeometry.uvs4, parsedGeometry.uvs4._updatable);\n      }\n      if (parsedGeometry.uvs5) {\n        mesh.setVerticesData(VertexBuffer.UV5Kind, parsedGeometry.uvs5, parsedGeometry.uvs5._updatable);\n      }\n      if (parsedGeometry.uvs6) {\n        mesh.setVerticesData(VertexBuffer.UV6Kind, parsedGeometry.uvs6, parsedGeometry.uvs6._updatable);\n      }\n      if (parsedGeometry.colors) {\n        mesh.setVerticesData(VertexBuffer.ColorKind, Color4.CheckColors4(parsedGeometry.colors, parsedGeometry.positions.length / 3), parsedGeometry.colors._updatable);\n      }\n      if (parsedGeometry.matricesIndices) {\n        if (!parsedGeometry.matricesIndices._isExpanded) {\n          const floatIndices = [];\n          for (let i = 0; i < parsedGeometry.matricesIndices.length; i++) {\n            const matricesIndex = parsedGeometry.matricesIndices[i];\n            floatIndices.push(matricesIndex & 0x000000ff);\n            floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\n            floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\n            floatIndices.push(matricesIndex >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0\n          }\n\n          mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, parsedGeometry.matricesIndices._updatable);\n        } else {\n          delete parsedGeometry.matricesIndices._isExpanded;\n          mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, parsedGeometry.matricesIndices, parsedGeometry.matricesIndices._updatable);\n        }\n      }\n      if (parsedGeometry.matricesIndicesExtra) {\n        if (!parsedGeometry.matricesIndicesExtra._isExpanded) {\n          const floatIndices = [];\n          for (let i = 0; i < parsedGeometry.matricesIndicesExtra.length; i++) {\n            const matricesIndex = parsedGeometry.matricesIndicesExtra[i];\n            floatIndices.push(matricesIndex & 0x000000ff);\n            floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\n            floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\n            floatIndices.push(matricesIndex >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0\n          }\n\n          mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, parsedGeometry.matricesIndicesExtra._updatable);\n        } else {\n          delete parsedGeometry.matricesIndices._isExpanded;\n          mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, parsedGeometry.matricesIndicesExtra, parsedGeometry.matricesIndicesExtra._updatable);\n        }\n      }\n      if (parsedGeometry.matricesWeights) {\n        Geometry._CleanMatricesWeights(parsedGeometry, mesh);\n        mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, parsedGeometry.matricesWeights, parsedGeometry.matricesWeights._updatable);\n      }\n      if (parsedGeometry.matricesWeightsExtra) {\n        mesh.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, parsedGeometry.matricesWeightsExtra, parsedGeometry.matricesWeights._updatable);\n      }\n      mesh.setIndices(parsedGeometry.indices, null);\n    }\n    // SubMeshes\n    if (parsedGeometry.subMeshes) {\n      mesh.subMeshes = [];\n      for (let subIndex = 0; subIndex < parsedGeometry.subMeshes.length; subIndex++) {\n        const parsedSubMesh = parsedGeometry.subMeshes[subIndex];\n        SubMesh.AddToMesh(parsedSubMesh.materialIndex, parsedSubMesh.verticesStart, parsedSubMesh.verticesCount, parsedSubMesh.indexStart, parsedSubMesh.indexCount, mesh);\n      }\n    }\n    // Flat shading\n    if (mesh._shouldGenerateFlatShading) {\n      mesh.convertToFlatShadedMesh();\n      mesh._shouldGenerateFlatShading = false;\n    }\n    // Update\n    mesh.computeWorldMatrix(true);\n    scene.onMeshImportedObservable.notifyObservers(mesh);\n  }\n  static _CleanMatricesWeights(parsedGeometry, mesh) {\n    const epsilon = 1e-3;\n    if (!SceneLoaderFlags.CleanBoneMatrixWeights) {\n      return;\n    }\n    let noInfluenceBoneIndex = 0.0;\n    if (parsedGeometry.skeletonId > -1) {\n      const skeleton = mesh.getScene().getLastSkeletonById(parsedGeometry.skeletonId);\n      if (!skeleton) {\n        return;\n      }\n      noInfluenceBoneIndex = skeleton.bones.length;\n    } else {\n      return;\n    }\n    const matricesIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);\n    const matricesIndicesExtra = mesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);\n    const matricesWeights = parsedGeometry.matricesWeights;\n    const matricesWeightsExtra = parsedGeometry.matricesWeightsExtra;\n    const influencers = parsedGeometry.numBoneInfluencer;\n    const size = matricesWeights.length;\n    for (let i = 0; i < size; i += 4) {\n      let weight = 0.0;\n      let firstZeroWeight = -1;\n      for (let j = 0; j < 4; j++) {\n        const w = matricesWeights[i + j];\n        weight += w;\n        if (w < epsilon && firstZeroWeight < 0) {\n          firstZeroWeight = j;\n        }\n      }\n      if (matricesWeightsExtra) {\n        for (let j = 0; j < 4; j++) {\n          const w = matricesWeightsExtra[i + j];\n          weight += w;\n          if (w < epsilon && firstZeroWeight < 0) {\n            firstZeroWeight = j + 4;\n          }\n        }\n      }\n      if (firstZeroWeight < 0 || firstZeroWeight > influencers - 1) {\n        firstZeroWeight = influencers - 1;\n      }\n      if (weight > epsilon) {\n        const mweight = 1.0 / weight;\n        for (let j = 0; j < 4; j++) {\n          matricesWeights[i + j] *= mweight;\n        }\n        if (matricesWeightsExtra) {\n          for (let j = 0; j < 4; j++) {\n            matricesWeightsExtra[i + j] *= mweight;\n          }\n        }\n      } else {\n        if (firstZeroWeight >= 4) {\n          matricesWeightsExtra[i + firstZeroWeight - 4] = 1.0 - weight;\n          matricesIndicesExtra[i + firstZeroWeight - 4] = noInfluenceBoneIndex;\n        } else {\n          matricesWeights[i + firstZeroWeight] = 1.0 - weight;\n          matricesIndices[i + firstZeroWeight] = noInfluenceBoneIndex;\n        }\n      }\n    }\n    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, matricesIndices);\n    if (parsedGeometry.matricesWeightsExtra) {\n      mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, matricesIndicesExtra);\n    }\n  }\n  /**\n   * Create a new geometry from persisted data (Using .babylon file format)\n   * @param parsedVertexData defines the persisted data\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root url to use to load assets (like delayed data)\n   * @returns the new geometry object\n   */\n  static Parse(parsedVertexData, scene, rootUrl) {\n    const geometry = new Geometry(parsedVertexData.id, scene, undefined, parsedVertexData.updatable);\n    geometry._loadedUniqueId = parsedVertexData.uniqueId;\n    if (Tags) {\n      Tags.AddTagsTo(geometry, parsedVertexData.tags);\n    }\n    if (parsedVertexData.delayLoadingFile) {\n      geometry.delayLoadState = 4;\n      geometry.delayLoadingFile = rootUrl + parsedVertexData.delayLoadingFile;\n      geometry._boundingInfo = new BoundingInfo(Vector3.FromArray(parsedVertexData.boundingBoxMinimum), Vector3.FromArray(parsedVertexData.boundingBoxMaximum));\n      geometry._delayInfo = [];\n      if (parsedVertexData.hasUVs) {\n        geometry._delayInfo.push(VertexBuffer.UVKind);\n      }\n      if (parsedVertexData.hasUVs2) {\n        geometry._delayInfo.push(VertexBuffer.UV2Kind);\n      }\n      if (parsedVertexData.hasUVs3) {\n        geometry._delayInfo.push(VertexBuffer.UV3Kind);\n      }\n      if (parsedVertexData.hasUVs4) {\n        geometry._delayInfo.push(VertexBuffer.UV4Kind);\n      }\n      if (parsedVertexData.hasUVs5) {\n        geometry._delayInfo.push(VertexBuffer.UV5Kind);\n      }\n      if (parsedVertexData.hasUVs6) {\n        geometry._delayInfo.push(VertexBuffer.UV6Kind);\n      }\n      if (parsedVertexData.hasColors) {\n        geometry._delayInfo.push(VertexBuffer.ColorKind);\n      }\n      if (parsedVertexData.hasMatricesIndices) {\n        geometry._delayInfo.push(VertexBuffer.MatricesIndicesKind);\n      }\n      if (parsedVertexData.hasMatricesWeights) {\n        geometry._delayInfo.push(VertexBuffer.MatricesWeightsKind);\n      }\n      geometry._delayLoadingFunction = VertexData.ImportVertexData;\n    } else {\n      VertexData.ImportVertexData(parsedVertexData, geometry);\n    }\n    scene.pushGeometry(geometry, true);\n    return geometry;\n  }\n}","map":{"version":3,"names":["Vector3","Color4","VertexData","VertexBuffer","SubMesh","SceneLoaderFlags","BoundingInfo","Tools","Tags","extractMinAndMax","EngineStore","CompatibilityOptions","Geometry","boundingBias","_boundingBias","value","copyFrom","clone","_updateBoundingInfo","CreateGeometryForMesh","mesh","geometry","RandomId","getScene","applyToMesh","meshes","_meshes","constructor","id","scene","vertexData","updatable","delayLoadState","_totalVertices","_isDisposed","_indexBufferIsUpdatable","_positionsCache","_parentContainer","useBoundingInfoFromGeometry","_scene","LastCreatedScene","uniqueId","getUniqueId","_engine","getEngine","_vertexBuffers","_indices","_updatable","setAllVerticesData","getCaps","vertexArrayObject","_vertexArrayObjects","computeWorldMatrix","extend","_extend","isReady","doNotSerialize","index","length","_rebuild","_indexBuffer","createIndexBuffer","key","vertexBuffer","applyToGeometry","_notifyUpdate","setVerticesData","kind","data","stride","Array","isArray","Float32Array","buffer","postponeInternalCreation","label","setVerticesBuffer","removeVerticesData","dispose","_disposeVertexArrayObjects","totalVertices","disposeExistingBuffer","getKind","_buffer","_increaseReferences","numOfMeshes","PositionKind","_updateExtend","getFloatData","_resetPointsArrayCache","minimum","Number","MAX_VALUE","maximum","buildBoundingInfo","_createGlobalSubMesh","isUnIndexed","synchronizeInstances","updateVerticesDataDirectly","offset","useBytes","getVertexBuffer","updateDirectly","updateVerticesData","updateExtends","update","hasBoundingInfo","getBoundingInfo","reConstruct","subMeshes","subMesh","refreshBoundingInfo","_bind","effect","indexToBind","overrideVertexBuffers","overrideVertexArrayObjects","undefined","vbs","getVertexBuffers","bindBuffers","vaos","recordVertexArrayObject","bindVertexArrayObject","getTotalVertices","getVerticesData","copyWhenShared","forceCopy","isVertexBufferUpdatable","vb","isUpdatable","isVerticesDataPresent","_delayInfo","indexOf","getVerticesDataKinds","result","push","updateIndices","indices","gpuMemoryOnly","setIndices","needToUpdateSubMeshes","slice","updateDynamicIndexBuffer","_releaseBuffer","getTotalIndices","getIndices","orig","getIndexBuffer","_releaseVertexArrayObject","releaseVertexArrayObject","releaseForMesh","shouldDispose","splice","_invalidateInstanceVertexArrayObject","_geometry","previousGeometry","_internalAbstractMeshDataInfo","_positions","pushGeometry","_applyToMesh","_boundingInfo","setBoundingInfo","create","_syncGeometryWithMorphTargetManager","onGeometryUpdated","_markSubMeshesAsAttributesDirty","load","onLoaded","_queueLoad","delayLoadingFile","addPendingData","_loadFile","_delayLoadingFunction","JSON","parse","removePendingData","toLeftHanded","tIndices","i","tTemp","tPositions","tNormals","NormalKind","_generatePointsArray","arrayIdx","FromArray","set","isDisposed","removeGeometry","geometries","copy","stopChecking","serialize","serializationObject","HasTags","tags","GetTags","_toNumberArray","origin","prototype","call","clearCachedData","vbName","Object","hasOwnProperty","_data","serializeVerticeData","positions","normals","TangentKind","tangents","UVKind","uvs","UV2Kind","uvs2","UV3Kind","uvs3","UV4Kind","uvs4","UV5Kind","uvs5","UV6Kind","uvs6","ColorKind","colors","MatricesIndicesKind","matricesIndices","_isExpanded","MatricesWeightsKind","matricesWeights","ExtractFromMesh","_GetGeometryByLoadedUniqueId","_loadedUniqueId","_ImportGeometry","parsedGeometry","geometryUniqueId","geometryId","getGeometryById","ArrayBuffer","binaryInfo","_binaryInfo","positionsAttrDesc","count","positionsData","normalsAttrDesc","normalsData","tangetsAttrDesc","tangentsData","uvsAttrDesc","uvsData","UseOpenGLOrientationForUV","uvs2AttrDesc","uvs2Data","uvs3AttrDesc","uvs3Data","uvs4AttrDesc","uvs4Data","uvs5AttrDesc","uvs5Data","uvs6AttrDesc","uvs6Data","colorsAttrDesc","colorsData","matricesIndicesAttrDesc","matricesIndicesData","Int32Array","floatIndices","matricesIndicesExtraAttrDesc","MatricesIndicesExtraKind","matricesWeightsAttrDesc","matricesWeightsData","indicesAttrDesc","indicesData","subMeshesAttrDesc","subMeshesData","materialIndex","verticesStart","verticesCount","indexStart","indexCount","AddToMesh","CheckColors4","matricesIndex","matricesIndicesExtra","_CleanMatricesWeights","matricesWeightsExtra","MatricesWeightsExtraKind","subIndex","parsedSubMesh","_shouldGenerateFlatShading","convertToFlatShadedMesh","onMeshImportedObservable","notifyObservers","epsilon","CleanBoneMatrixWeights","noInfluenceBoneIndex","skeletonId","skeleton","getLastSkeletonById","bones","influencers","numBoneInfluencer","size","weight","firstZeroWeight","j","w","mweight","Parse","parsedVertexData","rootUrl","AddTagsTo","boundingBoxMinimum","boundingBoxMaximum","hasUVs","hasUVs2","hasUVs3","hasUVs4","hasUVs5","hasUVs6","hasColors","hasMatricesIndices","hasMatricesWeights","ImportVertexData"],"sources":["../../../../dev/core/src/Meshes/geometry.ts"],"sourcesContent":["import type { Nullable, FloatArray, DataArray, IndicesArray } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Vector2 } from \"../Maths/math.vector\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { IGetSetVerticesData } from \"../Meshes/mesh.vertexData\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { SceneLoaderFlags } from \"../Loading/sceneLoaderFlags\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { Tags } from \"../Misc/tags\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { extractMinAndMax } from \"../Maths/math.functions\";\r\nimport type { AbstractScene } from \"../abstractScene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { CompatibilityOptions } from \"../Compat/compatibilityOptions\";\r\n\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\n\r\n/**\r\n * Class used to store geometry data (vertex buffers + index buffer)\r\n */\r\nexport class Geometry implements IGetSetVerticesData {\r\n    // Members\r\n    /**\r\n     * Gets or sets the ID of the geometry\r\n     */\r\n    public id: string;\r\n    /**\r\n     * Gets or sets the unique ID of the geometry\r\n     */\r\n    public uniqueId: number;\r\n    /**\r\n     * Gets the delay loading state of the geometry (none by default which means not delayed)\r\n     */\r\n    public delayLoadState = Constants.DELAYLOADSTATE_NONE;\r\n    /**\r\n     * Gets the file containing the data to load when running in delay load state\r\n     */\r\n    public delayLoadingFile: Nullable<string>;\r\n    /**\r\n     * Callback called when the geometry is updated\r\n     */\r\n    public onGeometryUpdated: (geometry: Geometry, kind?: string) => void;\r\n\r\n    // Private\r\n    private _scene: Scene;\r\n    private _engine: Engine;\r\n    private _meshes: Mesh[];\r\n    private _totalVertices = 0;\r\n    /** @internal */\r\n    public _loadedUniqueId: string;\r\n    /** @internal */\r\n    public _indices: IndicesArray;\r\n    /** @internal */\r\n    public _vertexBuffers: { [key: string]: VertexBuffer };\r\n    private _isDisposed = false;\r\n    private _extend: { minimum: Vector3; maximum: Vector3 };\r\n    private _boundingBias: Vector2;\r\n    /** @internal */\r\n    public _delayInfo: Array<string>;\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _indexBufferIsUpdatable = false;\r\n    /** @internal */\r\n    public _boundingInfo: Nullable<BoundingInfo>;\r\n    /** @internal */\r\n    public _delayLoadingFunction: Nullable<(any: any, geometry: Geometry) => void>;\r\n    /** @internal */\r\n    public _softwareSkinningFrameId: number;\r\n    private _vertexArrayObjects: { [key: string]: WebGLVertexArrayObject };\r\n    private _updatable: boolean;\r\n\r\n    // Cache\r\n    /** @internal */\r\n    public _positions: Nullable<Vector3[]>;\r\n    private _positionsCache: Vector3[] = [];\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    /**\r\n     *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\r\n     */\r\n    public get boundingBias(): Vector2 {\r\n        return this._boundingBias;\r\n    }\r\n\r\n    /**\r\n     *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\r\n     */\r\n    public set boundingBias(value: Vector2) {\r\n        if (this._boundingBias) {\r\n            this._boundingBias.copyFrom(value);\r\n        } else {\r\n            this._boundingBias = value.clone();\r\n        }\r\n\r\n        this._updateBoundingInfo(true, null);\r\n    }\r\n\r\n    /**\r\n     * Static function used to attach a new empty geometry to a mesh\r\n     * @param mesh defines the mesh to attach the geometry to\r\n     * @returns the new Geometry\r\n     */\r\n    public static CreateGeometryForMesh(mesh: Mesh): Geometry {\r\n        const geometry = new Geometry(Geometry.RandomId(), mesh.getScene());\r\n\r\n        geometry.applyToMesh(mesh);\r\n\r\n        return geometry;\r\n    }\r\n\r\n    /** Get the list of meshes using this geometry */\r\n    public get meshes(): Mesh[] {\r\n        return this._meshes;\r\n    }\r\n\r\n    /**\r\n     * If set to true (false by default), the bounding info applied to the meshes sharing this geometry will be the bounding info defined at the class level\r\n     * and won't be computed based on the vertex positions (which is what we get when useBoundingInfoFromGeometry = false)\r\n     */\r\n    public useBoundingInfoFromGeometry = false;\r\n\r\n    /**\r\n     * Creates a new geometry\r\n     * @param id defines the unique ID\r\n     * @param scene defines the hosting scene\r\n     * @param vertexData defines the VertexData used to get geometry data\r\n     * @param updatable defines if geometry must be updatable (false by default)\r\n     * @param mesh defines the mesh that will be associated with the geometry\r\n     */\r\n    constructor(id: string, scene?: Scene, vertexData?: VertexData, updatable: boolean = false, mesh: Nullable<Mesh> = null) {\r\n        this._scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        if (!this._scene) {\r\n            return;\r\n        }\r\n        this.id = id;\r\n        this.uniqueId = this._scene.getUniqueId();\r\n        this._engine = this._scene.getEngine();\r\n        this._meshes = [];\r\n        //Init vertex buffer cache\r\n        this._vertexBuffers = {};\r\n        this._indices = [];\r\n        this._updatable = updatable;\r\n\r\n        // vertexData\r\n        if (vertexData) {\r\n            this.setAllVerticesData(vertexData, updatable);\r\n        } else {\r\n            this._totalVertices = 0;\r\n        }\r\n\r\n        if (this._engine.getCaps().vertexArrayObject) {\r\n            this._vertexArrayObjects = {};\r\n        }\r\n\r\n        // applyToMesh\r\n        if (mesh) {\r\n            this.applyToMesh(mesh);\r\n            mesh.computeWorldMatrix(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current extend of the geometry\r\n     */\r\n    public get extend(): { minimum: Vector3; maximum: Vector3 } {\r\n        return this._extend;\r\n    }\r\n\r\n    /**\r\n     * Gets the hosting scene\r\n     * @returns the hosting Scene\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Gets the hosting engine\r\n     * @returns the hosting Engine\r\n     */\r\n    public getEngine(): Engine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Defines if the geometry is ready to use\r\n     * @returns true if the geometry is ready to be used\r\n     */\r\n    public isReady(): boolean {\r\n        return this.delayLoadState === Constants.DELAYLOADSTATE_LOADED || this.delayLoadState === Constants.DELAYLOADSTATE_NONE;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating that the geometry should not be serialized\r\n     */\r\n    public get doNotSerialize(): boolean {\r\n        for (let index = 0; index < this._meshes.length; index++) {\r\n            if (!this._meshes[index].doNotSerialize) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        if (this._vertexArrayObjects) {\r\n            this._vertexArrayObjects = {};\r\n        }\r\n\r\n        // Index buffer\r\n        if (this._meshes.length !== 0 && this._indices) {\r\n            this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);\r\n        }\r\n\r\n        // Vertex buffers\r\n        for (const key in this._vertexBuffers) {\r\n            const vertexBuffer = <VertexBuffer>this._vertexBuffers[key];\r\n            vertexBuffer._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Affects all geometry data in one call\r\n     * @param vertexData defines the geometry data\r\n     * @param updatable defines if the geometry must be flagged as updatable (false as default)\r\n     */\r\n    public setAllVerticesData(vertexData: VertexData, updatable?: boolean): void {\r\n        vertexData.applyToGeometry(this, updatable);\r\n        this._notifyUpdate();\r\n    }\r\n\r\n    /**\r\n     * Set specific vertex data\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the vertex data to use\r\n     * @param updatable defines if the vertex must be flagged as updatable (false as default)\r\n     * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified\r\n     */\r\n    public setVerticesData(kind: string, data: FloatArray, updatable: boolean = false, stride?: number): void {\r\n        if (updatable && Array.isArray(data)) {\r\n            // to avoid converting to Float32Array at each draw call in engine.updateDynamicVertexBuffer, we make the conversion a single time here\r\n            data = new Float32Array(data);\r\n        }\r\n        const buffer = new VertexBuffer(this._engine, data, kind, {\r\n            updatable,\r\n            postponeInternalCreation: this._meshes.length === 0,\r\n            stride,\r\n            label: \"Geometry_\" + this.id + \"_\" + kind,\r\n        });\r\n        this.setVerticesBuffer(buffer);\r\n    }\r\n\r\n    /**\r\n     * Removes a specific vertex data\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     */\r\n    public removeVerticesData(kind: string) {\r\n        if (this._vertexBuffers[kind]) {\r\n            this._vertexBuffers[kind].dispose();\r\n            delete this._vertexBuffers[kind];\r\n        }\r\n\r\n        if (this._vertexArrayObjects) {\r\n            this._disposeVertexArrayObjects();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Affect a vertex buffer to the geometry. the vertexBuffer.getKind() function is used to determine where to store the data\r\n     * @param buffer defines the vertex buffer to use\r\n     * @param totalVertices defines the total number of vertices for position kind (could be null)\r\n     * @param disposeExistingBuffer disposes the existing buffer, if any (default: true)\r\n     */\r\n    public setVerticesBuffer(buffer: VertexBuffer, totalVertices: Nullable<number> = null, disposeExistingBuffer = true): void {\r\n        const kind = buffer.getKind();\r\n        if (this._vertexBuffers[kind] && disposeExistingBuffer) {\r\n            this._vertexBuffers[kind].dispose();\r\n        }\r\n\r\n        if (buffer._buffer) {\r\n            buffer._buffer._increaseReferences();\r\n        }\r\n\r\n        this._vertexBuffers[kind] = buffer;\r\n        const meshes = this._meshes;\r\n        const numOfMeshes = meshes.length;\r\n\r\n        if (kind === VertexBuffer.PositionKind) {\r\n            this._totalVertices = totalVertices ?? buffer.totalVertices;\r\n\r\n            this._updateExtend(buffer.getFloatData());\r\n            this._resetPointsArrayCache();\r\n\r\n            // this._extend can be empty if buffer.getFloatData() returned null\r\n            const minimum = (this._extend && this._extend.minimum) || new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n            const maximum = (this._extend && this._extend.maximum) || new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n\r\n            for (let index = 0; index < numOfMeshes; index++) {\r\n                const mesh = meshes[index];\r\n                mesh.buildBoundingInfo(minimum, maximum);\r\n                mesh._createGlobalSubMesh(mesh.isUnIndexed);\r\n                mesh.computeWorldMatrix(true);\r\n                mesh.synchronizeInstances();\r\n            }\r\n        }\r\n\r\n        this._notifyUpdate(kind);\r\n    }\r\n\r\n    /**\r\n     * Update a specific vertex buffer\r\n     * This function will directly update the underlying DataBuffer according to the passed numeric array or Float32Array\r\n     * It will do nothing if the buffer is not updatable\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the data to use\r\n     * @param offset defines the offset in the target buffer where to store the data\r\n     * @param useBytes set to true if the offset is in bytes\r\n     */\r\n    public updateVerticesDataDirectly(kind: string, data: DataArray, offset: number, useBytes: boolean = false): void {\r\n        const vertexBuffer = this.getVertexBuffer(kind);\r\n\r\n        if (!vertexBuffer) {\r\n            return;\r\n        }\r\n\r\n        vertexBuffer.updateDirectly(data, offset, useBytes);\r\n        this._notifyUpdate(kind);\r\n    }\r\n\r\n    /**\r\n     * Update a specific vertex buffer\r\n     * This function will create a new buffer if the current one is not updatable\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the data to use\r\n     * @param updateExtends defines if the geometry extends must be recomputed (false by default)\r\n     */\r\n    public updateVerticesData(kind: string, data: FloatArray, updateExtends: boolean = false): void {\r\n        const vertexBuffer = this.getVertexBuffer(kind);\r\n\r\n        if (!vertexBuffer) {\r\n            return;\r\n        }\r\n\r\n        vertexBuffer.update(data);\r\n\r\n        if (kind === VertexBuffer.PositionKind) {\r\n            this._updateBoundingInfo(updateExtends, data);\r\n        }\r\n        this._notifyUpdate(kind);\r\n    }\r\n\r\n    private _updateBoundingInfo(updateExtends: boolean, data: Nullable<FloatArray>) {\r\n        if (updateExtends) {\r\n            this._updateExtend(data);\r\n        }\r\n\r\n        this._resetPointsArrayCache();\r\n\r\n        if (updateExtends) {\r\n            const meshes = this._meshes;\r\n            for (const mesh of meshes) {\r\n                if (mesh.hasBoundingInfo) {\r\n                    mesh.getBoundingInfo().reConstruct(this._extend.minimum, this._extend.maximum);\r\n                } else {\r\n                    mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\r\n                }\r\n\r\n                const subMeshes = mesh.subMeshes;\r\n                for (const subMesh of subMeshes) {\r\n                    subMesh.refreshBoundingInfo();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bind(\r\n        effect: Nullable<Effect>,\r\n        indexToBind?: Nullable<DataBuffer>,\r\n        overrideVertexBuffers?: { [kind: string]: Nullable<VertexBuffer> },\r\n        overrideVertexArrayObjects?: { [key: string]: WebGLVertexArrayObject }\r\n    ): void {\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        if (indexToBind === undefined) {\r\n            indexToBind = this._indexBuffer;\r\n        }\r\n        const vbs = this.getVertexBuffers();\r\n\r\n        if (!vbs) {\r\n            return;\r\n        }\r\n\r\n        if (indexToBind != this._indexBuffer || (!this._vertexArrayObjects && !overrideVertexArrayObjects)) {\r\n            this._engine.bindBuffers(vbs, indexToBind, effect, overrideVertexBuffers);\r\n            return;\r\n        }\r\n\r\n        const vaos = overrideVertexArrayObjects ? overrideVertexArrayObjects : this._vertexArrayObjects;\r\n\r\n        // Using VAO\r\n        if (!vaos[effect.key]) {\r\n            vaos[effect.key] = this._engine.recordVertexArrayObject(vbs, indexToBind, effect, overrideVertexBuffers);\r\n        }\r\n\r\n        this._engine.bindVertexArrayObject(vaos[effect.key], indexToBind);\r\n    }\r\n\r\n    /**\r\n     * Gets total number of vertices\r\n     * @returns the total number of vertices\r\n     */\r\n    public getTotalVertices(): number {\r\n        if (!this.isReady()) {\r\n            return 0;\r\n        }\r\n\r\n        return this._totalVertices;\r\n    }\r\n\r\n    /**\r\n     * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns a float array containing vertex data\r\n     */\r\n    public getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray> {\r\n        const vertexBuffer = this.getVertexBuffer(kind);\r\n        if (!vertexBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return vertexBuffer.getFloatData(this._totalVertices, forceCopy || (copyWhenShared && this._meshes.length !== 1));\r\n    }\r\n\r\n    /**\r\n     * Returns a boolean defining if the vertex data for the requested `kind` is updatable\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @returns true if the vertex buffer with the specified kind is updatable\r\n     */\r\n    public isVertexBufferUpdatable(kind: string): boolean {\r\n        const vb = this._vertexBuffers[kind];\r\n\r\n        if (!vb) {\r\n            return false;\r\n        }\r\n\r\n        return vb.isUpdatable();\r\n    }\r\n\r\n    /**\r\n     * Gets a specific vertex buffer\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @returns a VertexBuffer\r\n     */\r\n    public getVertexBuffer(kind: string): Nullable<VertexBuffer> {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        return this._vertexBuffers[kind];\r\n    }\r\n\r\n    /**\r\n     * Returns all vertex buffers\r\n     * @returns an object holding all vertex buffers indexed by kind\r\n     */\r\n    public getVertexBuffers(): Nullable<{ [key: string]: VertexBuffer }> {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        return this._vertexBuffers;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if specific vertex buffer is present\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @returns true if data is present\r\n     */\r\n    public isVerticesDataPresent(kind: string): boolean {\r\n        if (!this._vertexBuffers) {\r\n            if (this._delayInfo) {\r\n                return this._delayInfo.indexOf(kind) !== -1;\r\n            }\r\n            return false;\r\n        }\r\n        return this._vertexBuffers[kind] !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Gets a list of all attached data kinds (Position, normal, etc...)\r\n     * @returns a list of string containing all kinds\r\n     */\r\n    public getVerticesDataKinds(): string[] {\r\n        const result = [];\r\n        let kind;\r\n        if (!this._vertexBuffers && this._delayInfo) {\r\n            for (kind in this._delayInfo) {\r\n                result.push(kind);\r\n            }\r\n        } else {\r\n            for (kind in this._vertexBuffers) {\r\n                result.push(kind);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Update index buffer\r\n     * @param indices defines the indices to store in the index buffer\r\n     * @param offset defines the offset in the target buffer where to store the data\r\n     * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\r\n     */\r\n    public updateIndices(indices: IndicesArray, offset?: number, gpuMemoryOnly = false): void {\r\n        if (!this._indexBuffer) {\r\n            return;\r\n        }\r\n\r\n        if (!this._indexBufferIsUpdatable) {\r\n            this.setIndices(indices, null, true);\r\n        } else {\r\n            const needToUpdateSubMeshes = indices.length !== this._indices.length;\r\n\r\n            if (!gpuMemoryOnly) {\r\n                this._indices = indices.slice();\r\n            }\r\n            this._engine.updateDynamicIndexBuffer(this._indexBuffer, indices, offset);\r\n            if (needToUpdateSubMeshes) {\r\n                for (const mesh of this._meshes) {\r\n                    mesh._createGlobalSubMesh(true);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the indices to store in the index buffer\r\n     * @param totalVertices defines the total number of vertices (could be null)\r\n     * @param updatable defines if the index buffer must be flagged as updatable (false by default)\r\n     */\r\n    public setIndices(indices: IndicesArray, totalVertices: Nullable<number> = null, updatable: boolean = false): void {\r\n        if (this._indexBuffer) {\r\n            this._engine._releaseBuffer(this._indexBuffer);\r\n        }\r\n\r\n        this._indices = indices;\r\n        this._indexBufferIsUpdatable = updatable;\r\n        if (this._meshes.length !== 0 && this._indices) {\r\n            this._indexBuffer = this._engine.createIndexBuffer(this._indices, updatable);\r\n        }\r\n\r\n        if (totalVertices != undefined) {\r\n            // including null and undefined\r\n            this._totalVertices = totalVertices;\r\n        }\r\n\r\n        for (const mesh of this._meshes) {\r\n            mesh._createGlobalSubMesh(true);\r\n            mesh.synchronizeInstances();\r\n        }\r\n\r\n        this._notifyUpdate();\r\n    }\r\n\r\n    /**\r\n     * Return the total number of indices\r\n     * @returns the total number of indices\r\n     */\r\n    public getTotalIndices(): number {\r\n        if (!this.isReady()) {\r\n            return 0;\r\n        }\r\n        return this._indices.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the index buffer array\r\n     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns the index buffer array\r\n     */\r\n    public getIndices(copyWhenShared?: boolean, forceCopy?: boolean): Nullable<IndicesArray> {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        const orig = this._indices;\r\n        if (!forceCopy && (!copyWhenShared || this._meshes.length === 1)) {\r\n            return orig;\r\n        } else {\r\n            return orig.slice();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the index buffer\r\n     * @returns the index buffer\r\n     */\r\n    public getIndexBuffer(): Nullable<DataBuffer> {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        return this._indexBuffer;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _releaseVertexArrayObject(effect: Nullable<Effect> = null) {\r\n        if (!effect || !this._vertexArrayObjects) {\r\n            return;\r\n        }\r\n\r\n        if (this._vertexArrayObjects[effect.key]) {\r\n            this._engine.releaseVertexArrayObject(this._vertexArrayObjects[effect.key]);\r\n            delete this._vertexArrayObjects[effect.key];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release the associated resources for a specific mesh\r\n     * @param mesh defines the source mesh\r\n     * @param shouldDispose defines if the geometry must be disposed if there is no more mesh pointing to it\r\n     */\r\n    public releaseForMesh(mesh: Mesh, shouldDispose?: boolean): void {\r\n        const meshes = this._meshes;\r\n        const index = meshes.indexOf(mesh);\r\n\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        meshes.splice(index, 1);\r\n\r\n        if (this._vertexArrayObjects) {\r\n            mesh._invalidateInstanceVertexArrayObject();\r\n        }\r\n\r\n        mesh._geometry = null;\r\n\r\n        if (meshes.length === 0 && shouldDispose) {\r\n            this.dispose();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply current geometry to a given mesh\r\n     * @param mesh defines the mesh to apply geometry to\r\n     */\r\n    public applyToMesh(mesh: Mesh): void {\r\n        if (mesh._geometry === this) {\r\n            return;\r\n        }\r\n\r\n        const previousGeometry = mesh._geometry;\r\n        if (previousGeometry) {\r\n            previousGeometry.releaseForMesh(mesh);\r\n        }\r\n\r\n        if (this._vertexArrayObjects) {\r\n            mesh._invalidateInstanceVertexArrayObject();\r\n        }\r\n\r\n        const meshes = this._meshes;\r\n\r\n        // must be done before setting vertexBuffers because of mesh._createGlobalSubMesh()\r\n        mesh._geometry = this;\r\n        mesh._internalAbstractMeshDataInfo._positions = null;\r\n\r\n        this._scene.pushGeometry(this);\r\n\r\n        meshes.push(mesh);\r\n\r\n        if (this.isReady()) {\r\n            this._applyToMesh(mesh);\r\n        } else if (this._boundingInfo) {\r\n            mesh.setBoundingInfo(this._boundingInfo);\r\n        }\r\n    }\r\n\r\n    private _updateExtend(data: Nullable<FloatArray> = null) {\r\n        if (this.useBoundingInfoFromGeometry && this._boundingInfo) {\r\n            this._extend = {\r\n                minimum: this._boundingInfo.minimum.clone(),\r\n                maximum: this._boundingInfo.maximum.clone(),\r\n            };\r\n        } else {\r\n            if (!data) {\r\n                data = this.getVerticesData(VertexBuffer.PositionKind)!;\r\n                // This can happen if the buffer comes from a Hardware Buffer where\r\n                // The data have not been uploaded by Babylon. (ex: Compute Shaders and Storage Buffers)\r\n                if (!data) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            this._extend = extractMinAndMax(data, 0, this._totalVertices, this.boundingBias, 3);\r\n        }\r\n    }\r\n\r\n    private _applyToMesh(mesh: Mesh): void {\r\n        const numOfMeshes = this._meshes.length;\r\n\r\n        // vertexBuffers\r\n        for (const kind in this._vertexBuffers) {\r\n            if (numOfMeshes === 1) {\r\n                this._vertexBuffers[kind].create();\r\n            }\r\n\r\n            if (kind === VertexBuffer.PositionKind) {\r\n                if (!this._extend) {\r\n                    this._updateExtend();\r\n                }\r\n                mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\r\n\r\n                mesh._createGlobalSubMesh(mesh.isUnIndexed);\r\n\r\n                //bounding info was just created again, world matrix should be applied again.\r\n                mesh._updateBoundingInfo();\r\n            }\r\n        }\r\n\r\n        // indexBuffer\r\n        if (numOfMeshes === 1 && this._indices && this._indices.length > 0) {\r\n            this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);\r\n        }\r\n\r\n        // morphTargets\r\n        mesh._syncGeometryWithMorphTargetManager();\r\n\r\n        // instances\r\n        mesh.synchronizeInstances();\r\n    }\r\n\r\n    private _notifyUpdate(kind?: string) {\r\n        if (this.onGeometryUpdated) {\r\n            this.onGeometryUpdated(this, kind);\r\n        }\r\n\r\n        if (this._vertexArrayObjects) {\r\n            this._disposeVertexArrayObjects();\r\n        }\r\n\r\n        for (const mesh of this._meshes) {\r\n            mesh._markSubMeshesAsAttributesDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load the geometry if it was flagged as delay loaded\r\n     * @param scene defines the hosting scene\r\n     * @param onLoaded defines a callback called when the geometry is loaded\r\n     */\r\n    public load(scene: Scene, onLoaded?: () => void): void {\r\n        if (this.delayLoadState === Constants.DELAYLOADSTATE_LOADING) {\r\n            return;\r\n        }\r\n\r\n        if (this.isReady()) {\r\n            if (onLoaded) {\r\n                onLoaded();\r\n            }\r\n            return;\r\n        }\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_LOADING;\r\n\r\n        this._queueLoad(scene, onLoaded);\r\n    }\r\n\r\n    private _queueLoad(scene: Scene, onLoaded?: () => void): void {\r\n        if (!this.delayLoadingFile) {\r\n            return;\r\n        }\r\n\r\n        scene.addPendingData(this);\r\n        scene._loadFile(\r\n            this.delayLoadingFile,\r\n            (data) => {\r\n                if (!this._delayLoadingFunction) {\r\n                    return;\r\n                }\r\n\r\n                this._delayLoadingFunction(JSON.parse(data as string), this);\r\n\r\n                this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\r\n                this._delayInfo = [];\r\n\r\n                scene.removePendingData(this);\r\n\r\n                const meshes = this._meshes;\r\n                const numOfMeshes = meshes.length;\r\n                for (let index = 0; index < numOfMeshes; index++) {\r\n                    this._applyToMesh(meshes[index]);\r\n                }\r\n\r\n                if (onLoaded) {\r\n                    onLoaded();\r\n                }\r\n            },\r\n            undefined,\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Invert the geometry to move from a right handed system to a left handed one.\r\n     */\r\n    public toLeftHanded(): void {\r\n        // Flip faces\r\n        const tIndices = this.getIndices(false);\r\n        if (tIndices != null && tIndices.length > 0) {\r\n            for (let i = 0; i < tIndices.length; i += 3) {\r\n                const tTemp = tIndices[i + 0];\r\n                tIndices[i + 0] = tIndices[i + 2];\r\n                tIndices[i + 2] = tTemp;\r\n            }\r\n            this.setIndices(tIndices);\r\n        }\r\n\r\n        // Negate position.z\r\n        const tPositions = this.getVerticesData(VertexBuffer.PositionKind, false);\r\n        if (tPositions != null && tPositions.length > 0) {\r\n            for (let i = 0; i < tPositions.length; i += 3) {\r\n                tPositions[i + 2] = -tPositions[i + 2];\r\n            }\r\n            this.setVerticesData(VertexBuffer.PositionKind, tPositions, false);\r\n        }\r\n\r\n        // Negate normal.z\r\n        const tNormals = this.getVerticesData(VertexBuffer.NormalKind, false);\r\n        if (tNormals != null && tNormals.length > 0) {\r\n            for (let i = 0; i < tNormals.length; i += 3) {\r\n                tNormals[i + 2] = -tNormals[i + 2];\r\n            }\r\n            this.setVerticesData(VertexBuffer.NormalKind, tNormals, false);\r\n        }\r\n    }\r\n\r\n    // Cache\r\n    /** @internal */\r\n    public _resetPointsArrayCache(): void {\r\n        this._positions = null;\r\n    }\r\n\r\n    /** @internal */\r\n    public _generatePointsArray(): boolean {\r\n        if (this._positions) {\r\n            return true;\r\n        }\r\n\r\n        const data = this.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n        if (!data || data.length === 0) {\r\n            return false;\r\n        }\r\n\r\n        for (let index = this._positionsCache.length * 3, arrayIdx = this._positionsCache.length; index < data.length; index += 3, ++arrayIdx) {\r\n            this._positionsCache[arrayIdx] = Vector3.FromArray(data, index);\r\n        }\r\n\r\n        for (let index = 0, arrayIdx = 0; index < data.length; index += 3, ++arrayIdx) {\r\n            this._positionsCache[arrayIdx].set(data[0 + index], data[1 + index], data[2 + index]);\r\n        }\r\n\r\n        // just in case the number of positions was reduced, splice the array\r\n        this._positionsCache.length = data.length / 3;\r\n\r\n        this._positions = this._positionsCache;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating if the geometry is disposed\r\n     * @returns true if the geometry was disposed\r\n     */\r\n    public isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    private _disposeVertexArrayObjects(): void {\r\n        if (this._vertexArrayObjects) {\r\n            for (const kind in this._vertexArrayObjects) {\r\n                this._engine.releaseVertexArrayObject(this._vertexArrayObjects[kind]);\r\n            }\r\n            this._vertexArrayObjects = {}; // Will trigger a rebuild of the VAO if supported\r\n\r\n            const meshes = this._meshes;\r\n            const numOfMeshes = meshes.length;\r\n            for (let index = 0; index < numOfMeshes; index++) {\r\n                meshes[index]._invalidateInstanceVertexArrayObject();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Free all associated resources\r\n     */\r\n    public dispose(): void {\r\n        const meshes = this._meshes;\r\n        const numOfMeshes = meshes.length;\r\n        let index: number;\r\n        for (index = 0; index < numOfMeshes; index++) {\r\n            this.releaseForMesh(meshes[index]);\r\n        }\r\n        this._meshes.length = 0;\r\n\r\n        this._disposeVertexArrayObjects();\r\n\r\n        for (const kind in this._vertexBuffers) {\r\n            this._vertexBuffers[kind].dispose();\r\n        }\r\n        this._vertexBuffers = {};\r\n        this._totalVertices = 0;\r\n\r\n        if (this._indexBuffer) {\r\n            this._engine._releaseBuffer(this._indexBuffer);\r\n        }\r\n        this._indexBuffer = null;\r\n        this._indices = [];\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_NONE;\r\n        this.delayLoadingFile = null;\r\n        this._delayLoadingFunction = null;\r\n        this._delayInfo = [];\r\n\r\n        this._boundingInfo = null;\r\n\r\n        this._scene.removeGeometry(this);\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.geometries.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.geometries.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        this._isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * Clone the current geometry into a new geometry\r\n     * @param id defines the unique ID of the new geometry\r\n     * @returns a new geometry object\r\n     */\r\n    public copy(id: string): Geometry {\r\n        const vertexData = new VertexData();\r\n\r\n        vertexData.indices = [];\r\n\r\n        const indices = this.getIndices();\r\n        if (indices) {\r\n            for (let index = 0; index < indices.length; index++) {\r\n                (<number[]>vertexData.indices).push(indices[index]);\r\n            }\r\n        }\r\n\r\n        let updatable = false;\r\n        let stopChecking = false;\r\n        let kind;\r\n        for (kind in this._vertexBuffers) {\r\n            // using slice() to make a copy of the array and not just reference it\r\n            const data = this.getVerticesData(kind);\r\n\r\n            if (data) {\r\n                if (data instanceof Float32Array) {\r\n                    vertexData.set(new Float32Array(<Float32Array>data), kind);\r\n                } else {\r\n                    vertexData.set((<number[]>data).slice(0), kind);\r\n                }\r\n                if (!stopChecking) {\r\n                    const vb = this.getVertexBuffer(kind);\r\n\r\n                    if (vb) {\r\n                        updatable = vb.isUpdatable();\r\n                        stopChecking = !updatable;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const geometry = new Geometry(id, this._scene, vertexData, updatable);\r\n\r\n        geometry.delayLoadState = this.delayLoadState;\r\n        geometry.delayLoadingFile = this.delayLoadingFile;\r\n        geometry._delayLoadingFunction = this._delayLoadingFunction;\r\n\r\n        for (kind in this._delayInfo) {\r\n            geometry._delayInfo = geometry._delayInfo || [];\r\n            geometry._delayInfo.push(kind);\r\n        }\r\n\r\n        // Bounding info\r\n        geometry._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\r\n\r\n        return geometry;\r\n    }\r\n\r\n    /**\r\n     * Serialize the current geometry info (and not the vertices data) into a JSON object\r\n     * @returns a JSON representation of the current geometry data (without the vertices data)\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.id = this.id;\r\n        serializationObject.uniqueId = this.uniqueId;\r\n        serializationObject.updatable = this._updatable;\r\n\r\n        if (Tags && Tags.HasTags(this)) {\r\n            serializationObject.tags = Tags.GetTags(this);\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private _toNumberArray(origin: Nullable<Float32Array | IndicesArray>): number[] {\r\n        if (Array.isArray(origin)) {\r\n            return origin;\r\n        } else {\r\n            return Array.prototype.slice.call(origin);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release any memory retained by the cached data on the Geometry.\r\n     *\r\n     * Call this function to reduce memory footprint of the mesh.\r\n     * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)\r\n     */\r\n    public clearCachedData(): void {\r\n        this._indices = [];\r\n        this._resetPointsArrayCache();\r\n\r\n        for (const vbName in this._vertexBuffers) {\r\n            if (!Object.prototype.hasOwnProperty.call(this._vertexBuffers, vbName)) {\r\n                continue;\r\n            }\r\n            this._vertexBuffers[vbName]._buffer._data = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serialize all vertices data into a JSON object\r\n     * @returns a JSON representation of the current geometry data\r\n     */\r\n    public serializeVerticeData(): any {\r\n        const serializationObject = this.serialize();\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\r\n            serializationObject.positions = this._toNumberArray(this.getVerticesData(VertexBuffer.PositionKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {\r\n                serializationObject.positions._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            serializationObject.normals = this._toNumberArray(this.getVerticesData(VertexBuffer.NormalKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {\r\n                serializationObject.normals._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            serializationObject.tangents = this._toNumberArray(this.getVerticesData(VertexBuffer.TangentKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.TangentKind)) {\r\n                serializationObject.tangents._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            serializationObject.uvs = this._toNumberArray(this.getVerticesData(VertexBuffer.UVKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UVKind)) {\r\n                serializationObject.uvs._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n            serializationObject.uvs2 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV2Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV2Kind)) {\r\n                serializationObject.uvs2._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\r\n            serializationObject.uvs3 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV3Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV3Kind)) {\r\n                serializationObject.uvs3._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\r\n            serializationObject.uvs4 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV4Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV4Kind)) {\r\n                serializationObject.uvs4._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\r\n            serializationObject.uvs5 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV5Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV5Kind)) {\r\n                serializationObject.uvs5._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\r\n            serializationObject.uvs6 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV6Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV6Kind)) {\r\n                serializationObject.uvs6._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            serializationObject.colors = this._toNumberArray(this.getVerticesData(VertexBuffer.ColorKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.ColorKind)) {\r\n                serializationObject.colors._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\r\n            serializationObject.matricesIndices = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesIndicesKind));\r\n            serializationObject.matricesIndices._isExpanded = true;\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.MatricesIndicesKind)) {\r\n                serializationObject.matricesIndices._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\r\n            serializationObject.matricesWeights = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesWeightsKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.MatricesWeightsKind)) {\r\n                serializationObject.matricesWeights._updatable = true;\r\n            }\r\n        }\r\n\r\n        serializationObject.indices = this._toNumberArray(this.getIndices());\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Extracts a clone of a mesh geometry\r\n     * @param mesh defines the source mesh\r\n     * @param id defines the unique ID of the new geometry object\r\n     * @returns the new geometry object\r\n     */\r\n    public static ExtractFromMesh(mesh: Mesh, id: string): Nullable<Geometry> {\r\n        const geometry = mesh._geometry;\r\n\r\n        if (!geometry) {\r\n            return null;\r\n        }\r\n\r\n        return geometry.copy(id);\r\n    }\r\n\r\n    /**\r\n     * You should now use Tools.RandomId(), this method is still here for legacy reasons.\r\n     * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523\r\n     * Be aware Math.random() could cause collisions, but:\r\n     * \"All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide\"\r\n     * @returns a string containing a new GUID\r\n     */\r\n    public static RandomId(): string {\r\n        return Tools.RandomId();\r\n    }\r\n\r\n    private static _GetGeometryByLoadedUniqueId(uniqueId: string, scene: Scene) {\r\n        for (let index = 0; index < scene.geometries.length; index++) {\r\n            if (scene.geometries[index]._loadedUniqueId === uniqueId) {\r\n                return scene.geometries[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _ImportGeometry(parsedGeometry: any, mesh: Mesh): void {\r\n        const scene = mesh.getScene();\r\n\r\n        // Geometry\r\n        const geometryUniqueId = parsedGeometry.geometryUniqueId;\r\n        const geometryId = parsedGeometry.geometryId;\r\n        if (geometryUniqueId || geometryId) {\r\n            const geometry = geometryUniqueId ? this._GetGeometryByLoadedUniqueId(geometryUniqueId, scene) : scene.getGeometryById(geometryId);\r\n            if (geometry) {\r\n                geometry.applyToMesh(mesh);\r\n            }\r\n        } else if (parsedGeometry instanceof ArrayBuffer) {\r\n            const binaryInfo = mesh._binaryInfo;\r\n\r\n            if (binaryInfo.positionsAttrDesc && binaryInfo.positionsAttrDesc.count > 0) {\r\n                const positionsData = new Float32Array(parsedGeometry, binaryInfo.positionsAttrDesc.offset, binaryInfo.positionsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.PositionKind, positionsData, false);\r\n            }\r\n\r\n            if (binaryInfo.normalsAttrDesc && binaryInfo.normalsAttrDesc.count > 0) {\r\n                const normalsData = new Float32Array(parsedGeometry, binaryInfo.normalsAttrDesc.offset, binaryInfo.normalsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.NormalKind, normalsData, false);\r\n            }\r\n\r\n            if (binaryInfo.tangetsAttrDesc && binaryInfo.tangetsAttrDesc.count > 0) {\r\n                const tangentsData = new Float32Array(parsedGeometry, binaryInfo.tangetsAttrDesc.offset, binaryInfo.tangetsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.TangentKind, tangentsData, false);\r\n            }\r\n\r\n            if (binaryInfo.uvsAttrDesc && binaryInfo.uvsAttrDesc.count > 0) {\r\n                const uvsData = new Float32Array(parsedGeometry, binaryInfo.uvsAttrDesc.offset, binaryInfo.uvsAttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvsData.length; index += 2) {\r\n                        uvsData[index] = 1 - uvsData[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UVKind, uvsData, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs2AttrDesc && binaryInfo.uvs2AttrDesc.count > 0) {\r\n                const uvs2Data = new Float32Array(parsedGeometry, binaryInfo.uvs2AttrDesc.offset, binaryInfo.uvs2AttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvs2Data.length; index += 2) {\r\n                        uvs2Data[index] = 1 - uvs2Data[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UV2Kind, uvs2Data, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs3AttrDesc && binaryInfo.uvs3AttrDesc.count > 0) {\r\n                const uvs3Data = new Float32Array(parsedGeometry, binaryInfo.uvs3AttrDesc.offset, binaryInfo.uvs3AttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvs3Data.length; index += 2) {\r\n                        uvs3Data[index] = 1 - uvs3Data[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UV3Kind, uvs3Data, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs4AttrDesc && binaryInfo.uvs4AttrDesc.count > 0) {\r\n                const uvs4Data = new Float32Array(parsedGeometry, binaryInfo.uvs4AttrDesc.offset, binaryInfo.uvs4AttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvs4Data.length; index += 2) {\r\n                        uvs4Data[index] = 1 - uvs4Data[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UV4Kind, uvs4Data, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs5AttrDesc && binaryInfo.uvs5AttrDesc.count > 0) {\r\n                const uvs5Data = new Float32Array(parsedGeometry, binaryInfo.uvs5AttrDesc.offset, binaryInfo.uvs5AttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvs5Data.length; index += 2) {\r\n                        uvs5Data[index] = 1 - uvs5Data[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UV5Kind, uvs5Data, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs6AttrDesc && binaryInfo.uvs6AttrDesc.count > 0) {\r\n                const uvs6Data = new Float32Array(parsedGeometry, binaryInfo.uvs6AttrDesc.offset, binaryInfo.uvs6AttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvs6Data.length; index += 2) {\r\n                        uvs6Data[index] = 1 - uvs6Data[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UV6Kind, uvs6Data, false);\r\n            }\r\n\r\n            if (binaryInfo.colorsAttrDesc && binaryInfo.colorsAttrDesc.count > 0) {\r\n                const colorsData = new Float32Array(parsedGeometry, binaryInfo.colorsAttrDesc.offset, binaryInfo.colorsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.ColorKind, colorsData, false, binaryInfo.colorsAttrDesc.stride);\r\n            }\r\n\r\n            if (binaryInfo.matricesIndicesAttrDesc && binaryInfo.matricesIndicesAttrDesc.count > 0) {\r\n                const matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesAttrDesc.offset, binaryInfo.matricesIndicesAttrDesc.count);\r\n                const floatIndices = [];\r\n                for (let i = 0; i < matricesIndicesData.length; i++) {\r\n                    const index = matricesIndicesData[i];\r\n                    floatIndices.push(index & 0x000000ff);\r\n                    floatIndices.push((index & 0x0000ff00) >> 8);\r\n                    floatIndices.push((index & 0x00ff0000) >> 16);\r\n                    floatIndices.push((index >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, false);\r\n            }\r\n\r\n            if (binaryInfo.matricesIndicesExtraAttrDesc && binaryInfo.matricesIndicesExtraAttrDesc.count > 0) {\r\n                const matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesExtraAttrDesc.offset, binaryInfo.matricesIndicesExtraAttrDesc.count);\r\n                const floatIndices = [];\r\n                for (let i = 0; i < matricesIndicesData.length; i++) {\r\n                    const index = matricesIndicesData[i];\r\n                    floatIndices.push(index & 0x000000ff);\r\n                    floatIndices.push((index & 0x0000ff00) >> 8);\r\n                    floatIndices.push((index & 0x00ff0000) >> 16);\r\n                    floatIndices.push((index >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, false);\r\n            }\r\n\r\n            if (binaryInfo.matricesWeightsAttrDesc && binaryInfo.matricesWeightsAttrDesc.count > 0) {\r\n                const matricesWeightsData = new Float32Array(parsedGeometry, binaryInfo.matricesWeightsAttrDesc.offset, binaryInfo.matricesWeightsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsData, false);\r\n            }\r\n\r\n            if (binaryInfo.indicesAttrDesc && binaryInfo.indicesAttrDesc.count > 0) {\r\n                const indicesData = new Int32Array(parsedGeometry, binaryInfo.indicesAttrDesc.offset, binaryInfo.indicesAttrDesc.count);\r\n                mesh.setIndices(indicesData, null);\r\n            }\r\n\r\n            if (binaryInfo.subMeshesAttrDesc && binaryInfo.subMeshesAttrDesc.count > 0) {\r\n                const subMeshesData = new Int32Array(parsedGeometry, binaryInfo.subMeshesAttrDesc.offset, binaryInfo.subMeshesAttrDesc.count * 5);\r\n\r\n                mesh.subMeshes = [];\r\n                for (let i = 0; i < binaryInfo.subMeshesAttrDesc.count; i++) {\r\n                    const materialIndex = subMeshesData[i * 5 + 0];\r\n                    const verticesStart = subMeshesData[i * 5 + 1];\r\n                    const verticesCount = subMeshesData[i * 5 + 2];\r\n                    const indexStart = subMeshesData[i * 5 + 3];\r\n                    const indexCount = subMeshesData[i * 5 + 4];\r\n\r\n                    SubMesh.AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, <AbstractMesh>mesh);\r\n                }\r\n            }\r\n        } else if (parsedGeometry.positions && parsedGeometry.normals && parsedGeometry.indices) {\r\n            mesh.setVerticesData(VertexBuffer.PositionKind, parsedGeometry.positions, parsedGeometry.positions._updatable);\r\n\r\n            mesh.setVerticesData(VertexBuffer.NormalKind, parsedGeometry.normals, parsedGeometry.normals._updatable);\r\n\r\n            if (parsedGeometry.tangents) {\r\n                mesh.setVerticesData(VertexBuffer.TangentKind, parsedGeometry.tangents, parsedGeometry.tangents._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs) {\r\n                mesh.setVerticesData(VertexBuffer.UVKind, parsedGeometry.uvs, parsedGeometry.uvs._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs2) {\r\n                mesh.setVerticesData(VertexBuffer.UV2Kind, parsedGeometry.uvs2, parsedGeometry.uvs2._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs3) {\r\n                mesh.setVerticesData(VertexBuffer.UV3Kind, parsedGeometry.uvs3, parsedGeometry.uvs3._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs4) {\r\n                mesh.setVerticesData(VertexBuffer.UV4Kind, parsedGeometry.uvs4, parsedGeometry.uvs4._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs5) {\r\n                mesh.setVerticesData(VertexBuffer.UV5Kind, parsedGeometry.uvs5, parsedGeometry.uvs5._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs6) {\r\n                mesh.setVerticesData(VertexBuffer.UV6Kind, parsedGeometry.uvs6, parsedGeometry.uvs6._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.colors) {\r\n                mesh.setVerticesData(VertexBuffer.ColorKind, Color4.CheckColors4(parsedGeometry.colors, parsedGeometry.positions.length / 3), parsedGeometry.colors._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.matricesIndices) {\r\n                if (!parsedGeometry.matricesIndices._isExpanded) {\r\n                    const floatIndices = [];\r\n\r\n                    for (let i = 0; i < parsedGeometry.matricesIndices.length; i++) {\r\n                        const matricesIndex = parsedGeometry.matricesIndices[i];\r\n\r\n                        floatIndices.push(matricesIndex & 0x000000ff);\r\n                        floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\r\n                        floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\r\n                        floatIndices.push((matricesIndex >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                    }\r\n\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, parsedGeometry.matricesIndices._updatable);\r\n                } else {\r\n                    delete parsedGeometry.matricesIndices._isExpanded;\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, parsedGeometry.matricesIndices, parsedGeometry.matricesIndices._updatable);\r\n                }\r\n            }\r\n\r\n            if (parsedGeometry.matricesIndicesExtra) {\r\n                if (!parsedGeometry.matricesIndicesExtra._isExpanded) {\r\n                    const floatIndices = [];\r\n\r\n                    for (let i = 0; i < parsedGeometry.matricesIndicesExtra.length; i++) {\r\n                        const matricesIndex = parsedGeometry.matricesIndicesExtra[i];\r\n\r\n                        floatIndices.push(matricesIndex & 0x000000ff);\r\n                        floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\r\n                        floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\r\n                        floatIndices.push((matricesIndex >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                    }\r\n\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, parsedGeometry.matricesIndicesExtra._updatable);\r\n                } else {\r\n                    delete parsedGeometry.matricesIndices._isExpanded;\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, parsedGeometry.matricesIndicesExtra, parsedGeometry.matricesIndicesExtra._updatable);\r\n                }\r\n            }\r\n\r\n            if (parsedGeometry.matricesWeights) {\r\n                Geometry._CleanMatricesWeights(parsedGeometry, mesh);\r\n                mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, parsedGeometry.matricesWeights, parsedGeometry.matricesWeights._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.matricesWeightsExtra) {\r\n                mesh.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, parsedGeometry.matricesWeightsExtra, parsedGeometry.matricesWeights._updatable);\r\n            }\r\n\r\n            mesh.setIndices(parsedGeometry.indices, null);\r\n        }\r\n\r\n        // SubMeshes\r\n        if (parsedGeometry.subMeshes) {\r\n            mesh.subMeshes = [];\r\n            for (let subIndex = 0; subIndex < parsedGeometry.subMeshes.length; subIndex++) {\r\n                const parsedSubMesh = parsedGeometry.subMeshes[subIndex];\r\n\r\n                SubMesh.AddToMesh(\r\n                    parsedSubMesh.materialIndex,\r\n                    parsedSubMesh.verticesStart,\r\n                    parsedSubMesh.verticesCount,\r\n                    parsedSubMesh.indexStart,\r\n                    parsedSubMesh.indexCount,\r\n                    <AbstractMesh>mesh\r\n                );\r\n            }\r\n        }\r\n\r\n        // Flat shading\r\n        if (mesh._shouldGenerateFlatShading) {\r\n            mesh.convertToFlatShadedMesh();\r\n            mesh._shouldGenerateFlatShading = false;\r\n        }\r\n\r\n        // Update\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        scene.onMeshImportedObservable.notifyObservers(<AbstractMesh>mesh);\r\n    }\r\n\r\n    private static _CleanMatricesWeights(parsedGeometry: any, mesh: Mesh): void {\r\n        const epsilon: number = 1e-3;\r\n        if (!SceneLoaderFlags.CleanBoneMatrixWeights) {\r\n            return;\r\n        }\r\n        let noInfluenceBoneIndex = 0.0;\r\n        if (parsedGeometry.skeletonId > -1) {\r\n            const skeleton = mesh.getScene().getLastSkeletonById(parsedGeometry.skeletonId);\r\n\r\n            if (!skeleton) {\r\n                return;\r\n            }\r\n            noInfluenceBoneIndex = skeleton.bones.length;\r\n        } else {\r\n            return;\r\n        }\r\n        const matricesIndices = <FloatArray>mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);\r\n        const matricesIndicesExtra = <FloatArray>mesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);\r\n        const matricesWeights = parsedGeometry.matricesWeights;\r\n        const matricesWeightsExtra = parsedGeometry.matricesWeightsExtra;\r\n        const influencers = parsedGeometry.numBoneInfluencer;\r\n        const size = matricesWeights.length;\r\n\r\n        for (let i = 0; i < size; i += 4) {\r\n            let weight = 0.0;\r\n            let firstZeroWeight = -1;\r\n            for (let j = 0; j < 4; j++) {\r\n                const w = matricesWeights[i + j];\r\n                weight += w;\r\n                if (w < epsilon && firstZeroWeight < 0) {\r\n                    firstZeroWeight = j;\r\n                }\r\n            }\r\n            if (matricesWeightsExtra) {\r\n                for (let j = 0; j < 4; j++) {\r\n                    const w = matricesWeightsExtra[i + j];\r\n                    weight += w;\r\n                    if (w < epsilon && firstZeroWeight < 0) {\r\n                        firstZeroWeight = j + 4;\r\n                    }\r\n                }\r\n            }\r\n            if (firstZeroWeight < 0 || firstZeroWeight > influencers - 1) {\r\n                firstZeroWeight = influencers - 1;\r\n            }\r\n            if (weight > epsilon) {\r\n                const mweight = 1.0 / weight;\r\n                for (let j = 0; j < 4; j++) {\r\n                    matricesWeights[i + j] *= mweight;\r\n                }\r\n                if (matricesWeightsExtra) {\r\n                    for (let j = 0; j < 4; j++) {\r\n                        matricesWeightsExtra[i + j] *= mweight;\r\n                    }\r\n                }\r\n            } else {\r\n                if (firstZeroWeight >= 4) {\r\n                    matricesWeightsExtra[i + firstZeroWeight - 4] = 1.0 - weight;\r\n                    matricesIndicesExtra[i + firstZeroWeight - 4] = noInfluenceBoneIndex;\r\n                } else {\r\n                    matricesWeights[i + firstZeroWeight] = 1.0 - weight;\r\n                    matricesIndices[i + firstZeroWeight] = noInfluenceBoneIndex;\r\n                }\r\n            }\r\n        }\r\n\r\n        mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, matricesIndices);\r\n        if (parsedGeometry.matricesWeightsExtra) {\r\n            mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, matricesIndicesExtra);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new geometry from persisted data (Using .babylon file format)\r\n     * @param parsedVertexData defines the persisted data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root url to use to load assets (like delayed data)\r\n     * @returns the new geometry object\r\n     */\r\n    public static Parse(parsedVertexData: any, scene: Scene, rootUrl: string): Nullable<Geometry> {\r\n        const geometry = new Geometry(parsedVertexData.id, scene, undefined, parsedVertexData.updatable);\r\n        geometry._loadedUniqueId = parsedVertexData.uniqueId;\r\n\r\n        if (Tags) {\r\n            Tags.AddTagsTo(geometry, parsedVertexData.tags);\r\n        }\r\n\r\n        if (parsedVertexData.delayLoadingFile) {\r\n            geometry.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n            geometry.delayLoadingFile = rootUrl + parsedVertexData.delayLoadingFile;\r\n            geometry._boundingInfo = new BoundingInfo(Vector3.FromArray(parsedVertexData.boundingBoxMinimum), Vector3.FromArray(parsedVertexData.boundingBoxMaximum));\r\n\r\n            geometry._delayInfo = [];\r\n            if (parsedVertexData.hasUVs) {\r\n                geometry._delayInfo.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs2) {\r\n                geometry._delayInfo.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs3) {\r\n                geometry._delayInfo.push(VertexBuffer.UV3Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs4) {\r\n                geometry._delayInfo.push(VertexBuffer.UV4Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs5) {\r\n                geometry._delayInfo.push(VertexBuffer.UV5Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs6) {\r\n                geometry._delayInfo.push(VertexBuffer.UV6Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasColors) {\r\n                geometry._delayInfo.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            if (parsedVertexData.hasMatricesIndices) {\r\n                geometry._delayInfo.push(VertexBuffer.MatricesIndicesKind);\r\n            }\r\n\r\n            if (parsedVertexData.hasMatricesWeights) {\r\n                geometry._delayInfo.push(VertexBuffer.MatricesWeightsKind);\r\n            }\r\n\r\n            geometry._delayLoadingFunction = VertexData.ImportVertexData;\r\n        } else {\r\n            VertexData.ImportVertexData(parsedVertexData, geometry);\r\n        }\r\n\r\n        scene.pushGeometry(geometry, true);\r\n\r\n        return geometry;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}