{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../tslib.es6.js\";\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { serialize, SerializationHelper } from \"../Misc/decorators.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector2 } from \"../Maths/math.vector.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { PostProcess } from \"../PostProcesses/postProcess.js\";\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess.js\";\nimport { BlurPostProcess } from \"../PostProcesses/blurPostProcess.js\";\nimport { EffectLayer } from \"./effectLayer.js\";\nimport { AbstractScene } from \"../abstractScene.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { Color4, Color3 } from \"../Maths/math.color.js\";\nimport \"../Shaders/glowMapMerge.fragment.js\";\nimport \"../Shaders/glowMapMerge.vertex.js\";\nimport \"../Shaders/glowBlurPostProcess.fragment.js\";\nimport \"../Layers/effectLayerSceneComponent.js\";\nAbstractScene.prototype.getHighlightLayerByName = function (name) {\n  var _a;\n  for (let index = 0; index < ((_a = this.effectLayers) === null || _a === void 0 ? void 0 : _a.length); index++) {\n    if (this.effectLayers[index].name === name && this.effectLayers[index].getEffectName() === HighlightLayer.EffectName) {\n      return this.effectLayers[index];\n    }\n  }\n  return null;\n};\n/**\n * Special Glow Blur post process only blurring the alpha channel\n * It enforces keeping the most luminous color in the color channel.\n */\nclass GlowBlurPostProcess extends PostProcess {\n  constructor(name, direction, kernel, options, camera, samplingMode = Texture.BILINEAR_SAMPLINGMODE, engine, reusable) {\n    super(name, \"glowBlurPostProcess\", [\"screenSize\", \"direction\", \"blurWidth\"], null, options, camera, samplingMode, engine, reusable);\n    this.direction = direction;\n    this.kernel = kernel;\n    this.onApplyObservable.add(effect => {\n      effect.setFloat2(\"screenSize\", this.width, this.height);\n      effect.setVector2(\"direction\", this.direction);\n      effect.setFloat(\"blurWidth\", this.kernel);\n    });\n  }\n}\n/**\n * The highlight layer Helps adding a glow effect around a mesh.\n *\n * Once instantiated in a scene, simply use the addMesh or removeMesh method to add or remove\n * glowy meshes to your scene.\n *\n * !!! THIS REQUIRES AN ACTIVE STENCIL BUFFER ON THE CANVAS !!!\n */\nexport class HighlightLayer extends EffectLayer {\n  /**\n   * Specifies the horizontal size of the blur.\n   */\n  set blurHorizontalSize(value) {\n    this._horizontalBlurPostprocess.kernel = value;\n    this._options.blurHorizontalSize = value;\n  }\n  /**\n   * Specifies the vertical size of the blur.\n   */\n  set blurVerticalSize(value) {\n    this._verticalBlurPostprocess.kernel = value;\n    this._options.blurVerticalSize = value;\n  }\n  /**\n   * Gets the horizontal size of the blur.\n   */\n  get blurHorizontalSize() {\n    return this._horizontalBlurPostprocess.kernel;\n  }\n  /**\n   * Gets the vertical size of the blur.\n   */\n  get blurVerticalSize() {\n    return this._verticalBlurPostprocess.kernel;\n  }\n  /**\n   * Instantiates a new highlight Layer and references it to the scene..\n   * @param name The name of the layer\n   * @param scene The scene to use the layer in\n   * @param options Sets of none mandatory options to use with the layer (see IHighlightLayerOptions for more information)\n   */\n  constructor(name, scene, options) {\n    super(name, scene);\n    this.name = name;\n    /**\n     * Specifies whether or not the inner glow is ACTIVE in the layer.\n     */\n    this.innerGlow = true;\n    /**\n     * Specifies whether or not the outer glow is ACTIVE in the layer.\n     */\n    this.outerGlow = true;\n    /**\n     * An event triggered when the highlight layer is being blurred.\n     */\n    this.onBeforeBlurObservable = new Observable();\n    /**\n     * An event triggered when the highlight layer has been blurred.\n     */\n    this.onAfterBlurObservable = new Observable();\n    this._instanceGlowingMeshStencilReference = HighlightLayer.GlowingMeshStencilReference++;\n    this._meshes = {};\n    this._excludedMeshes = {};\n    this.neutralColor = HighlightLayer.NeutralColor;\n    // Warn on stencil\n    if (!this._engine.isStencilEnable) {\n      Logger.Warn(\"Rendering the Highlight Layer requires the stencil to be active on the canvas. var engine = new Engine(canvas, antialias, { stencil: true }\");\n    }\n    // Adapt options\n    this._options = Object.assign({\n      mainTextureRatio: 0.5,\n      blurTextureSizeRatio: 0.5,\n      blurHorizontalSize: 1.0,\n      blurVerticalSize: 1.0,\n      alphaBlendingMode: 2,\n      camera: null,\n      renderingGroupId: -1,\n      mainTextureType: 0\n    }, options);\n    // Initialize the layer\n    this._init({\n      alphaBlendingMode: this._options.alphaBlendingMode,\n      camera: this._options.camera,\n      mainTextureFixedSize: this._options.mainTextureFixedSize,\n      mainTextureRatio: this._options.mainTextureRatio,\n      renderingGroupId: this._options.renderingGroupId,\n      mainTextureType: this._options.mainTextureType\n    });\n    // Do not render as long as no meshes have been added\n    this._shouldRender = false;\n  }\n  /**\n   * Get the effect name of the layer.\n   * @returns The effect name\n   */\n  getEffectName() {\n    return HighlightLayer.EffectName;\n  }\n  _numInternalDraws() {\n    return 2; // we need two rendering, one for the inner glow and the other for the outer glow\n  }\n  /**\n   * Create the merge effect. This is the shader use to blit the information back\n   * to the main canvas at the end of the scene rendering.\n   */\n  _createMergeEffect() {\n    // Effect\n    return this._engine.createEffect(\"glowMapMerge\", [VertexBuffer.PositionKind], [\"offset\"], [\"textureSampler\"], this._options.isStroke ? \"#define STROKE \\n\" : undefined);\n  }\n  /**\n   * Creates the render target textures and post processes used in the highlight layer.\n   */\n  _createTextureAndPostProcesses() {\n    let blurTextureWidth = this._mainTextureDesiredSize.width * this._options.blurTextureSizeRatio;\n    let blurTextureHeight = this._mainTextureDesiredSize.height * this._options.blurTextureSizeRatio;\n    blurTextureWidth = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;\n    blurTextureHeight = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;\n    let textureType = 0;\n    if (this._engine.getCaps().textureHalfFloatRender) {\n      textureType = 2;\n    } else {\n      textureType = 0;\n    }\n    this._blurTexture = new RenderTargetTexture(\"HighlightLayerBlurRTT\", {\n      width: blurTextureWidth,\n      height: blurTextureHeight\n    }, this._scene, false, true, textureType);\n    this._blurTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._blurTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._blurTexture.anisotropicFilteringLevel = 16;\n    this._blurTexture.updateSamplingMode(Texture.TRILINEAR_SAMPLINGMODE);\n    this._blurTexture.renderParticles = false;\n    this._blurTexture.ignoreCameraViewport = true;\n    this._textures = [this._blurTexture];\n    if (this._options.alphaBlendingMode === 2) {\n      this._downSamplePostprocess = new PassPostProcess(\"HighlightLayerPPP\", this._options.blurTextureSizeRatio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\n      this._downSamplePostprocess.externalTextureSamplerBinding = true;\n      this._downSamplePostprocess.onApplyObservable.add(effect => {\n        effect.setTexture(\"textureSampler\", this._mainTexture);\n      });\n      this._horizontalBlurPostprocess = new GlowBlurPostProcess(\"HighlightLayerHBP\", new Vector2(1.0, 0), this._options.blurHorizontalSize, 1, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\n      this._horizontalBlurPostprocess.onApplyObservable.add(effect => {\n        effect.setFloat2(\"screenSize\", blurTextureWidth, blurTextureHeight);\n      });\n      this._verticalBlurPostprocess = new GlowBlurPostProcess(\"HighlightLayerVBP\", new Vector2(0, 1.0), this._options.blurVerticalSize, 1, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\n      this._verticalBlurPostprocess.onApplyObservable.add(effect => {\n        effect.setFloat2(\"screenSize\", blurTextureWidth, blurTextureHeight);\n      });\n      this._postProcesses = [this._downSamplePostprocess, this._horizontalBlurPostprocess, this._verticalBlurPostprocess];\n    } else {\n      this._horizontalBlurPostprocess = new BlurPostProcess(\"HighlightLayerHBP\", new Vector2(1.0, 0), this._options.blurHorizontalSize / 2, {\n        width: blurTextureWidth,\n        height: blurTextureHeight\n      }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n      this._horizontalBlurPostprocess.width = blurTextureWidth;\n      this._horizontalBlurPostprocess.height = blurTextureHeight;\n      this._horizontalBlurPostprocess.externalTextureSamplerBinding = true;\n      this._horizontalBlurPostprocess.onApplyObservable.add(effect => {\n        effect.setTexture(\"textureSampler\", this._mainTexture);\n      });\n      this._verticalBlurPostprocess = new BlurPostProcess(\"HighlightLayerVBP\", new Vector2(0, 1.0), this._options.blurVerticalSize / 2, {\n        width: blurTextureWidth,\n        height: blurTextureHeight\n      }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n      this._postProcesses = [this._horizontalBlurPostprocess, this._verticalBlurPostprocess];\n    }\n    this._mainTexture.onAfterUnbindObservable.add(() => {\n      this.onBeforeBlurObservable.notifyObservers(this);\n      const internalTexture = this._blurTexture.renderTarget;\n      if (internalTexture) {\n        this._scene.postProcessManager.directRender(this._postProcesses, internalTexture, true);\n        this._engine.unBindFramebuffer(internalTexture, true);\n      }\n      this.onAfterBlurObservable.notifyObservers(this);\n    });\n    // Prevent autoClear.\n    this._postProcesses.map(pp => {\n      pp.autoClear = false;\n    });\n  }\n  /**\n   * Returns whether or not the layer needs stencil enabled during the mesh rendering.\n   */\n  needStencil() {\n    return true;\n  }\n  /**\n   * Checks for the readiness of the element composing the layer.\n   * @param subMesh the mesh to check for\n   * @param useInstances specify whether or not to use instances to render the mesh\n   * @returns true if ready otherwise, false\n   */\n  isReady(subMesh, useInstances) {\n    const material = subMesh.getMaterial();\n    const mesh = subMesh.getRenderingMesh();\n    if (!material || !mesh || !this._meshes) {\n      return false;\n    }\n    let emissiveTexture = null;\n    const highlightLayerMesh = this._meshes[mesh.uniqueId];\n    if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {\n      emissiveTexture = material.emissiveTexture;\n    }\n    return super._isReady(subMesh, useInstances, emissiveTexture);\n  }\n  /**\n   * Implementation specific of rendering the generating effect on the main canvas.\n   * @param effect The effect used to render through\n   * @param renderIndex\n   */\n  _internalRender(effect, renderIndex) {\n    // Texture\n    effect.setTexture(\"textureSampler\", this._blurTexture);\n    // Cache\n    const engine = this._engine;\n    engine.cacheStencilState();\n    // Stencil operations\n    engine.setStencilOperationPass(7681);\n    engine.setStencilOperationFail(7680);\n    engine.setStencilOperationDepthFail(7680);\n    // Draw order\n    engine.setStencilMask(0x00);\n    engine.setStencilBuffer(true);\n    engine.setStencilFunctionReference(this._instanceGlowingMeshStencilReference);\n    // 2 passes inner outer\n    if (this.outerGlow && renderIndex === 0) {\n      // the outer glow is rendered the first time _internalRender is called, so when renderIndex == 0 (and only if outerGlow is enabled)\n      effect.setFloat(\"offset\", 0);\n      engine.setStencilFunction(517);\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    }\n    if (this.innerGlow && renderIndex === 1) {\n      // the inner glow is rendered the second time _internalRender is called, so when renderIndex == 1 (and only if innerGlow is enabled)\n      effect.setFloat(\"offset\", 1);\n      engine.setStencilFunction(514);\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    }\n    // Restore Cache\n    engine.restoreStencilState();\n  }\n  /**\n   * Returns true if the layer contains information to display, otherwise false.\n   */\n  shouldRender() {\n    if (super.shouldRender()) {\n      return this._meshes ? true : false;\n    }\n    return false;\n  }\n  /**\n   * Returns true if the mesh should render, otherwise false.\n   * @param mesh The mesh to render\n   * @returns true if it should render otherwise false\n   */\n  _shouldRenderMesh(mesh) {\n    // Excluded Mesh\n    if (this._excludedMeshes && this._excludedMeshes[mesh.uniqueId]) {\n      return false;\n    }\n    if (!super.hasMesh(mesh)) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Returns true if the mesh can be rendered, otherwise false.\n   * @param mesh The mesh to render\n   * @param material The material used on the mesh\n   * @returns true if it can be rendered otherwise false\n   */\n  _canRenderMesh(mesh, material) {\n    // all meshes can be rendered in the highlight layer, even transparent ones\n    return true;\n  }\n  /**\n   * Adds specific effects defines.\n   * @param defines The defines to add specifics to.\n   */\n  _addCustomEffectDefines(defines) {\n    defines.push(\"#define HIGHLIGHT\");\n  }\n  /**\n   * Sets the required values for both the emissive texture and and the main color.\n   * @param mesh\n   * @param subMesh\n   * @param material\n   */\n  _setEmissiveTextureAndColor(mesh, subMesh, material) {\n    const highlightLayerMesh = this._meshes[mesh.uniqueId];\n    if (highlightLayerMesh) {\n      this._emissiveTextureAndColor.color.set(highlightLayerMesh.color.r, highlightLayerMesh.color.g, highlightLayerMesh.color.b, 1.0);\n    } else {\n      this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);\n    }\n    if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {\n      this._emissiveTextureAndColor.texture = material.emissiveTexture;\n      this._emissiveTextureAndColor.color.set(1.0, 1.0, 1.0, 1.0);\n    } else {\n      this._emissiveTextureAndColor.texture = null;\n    }\n  }\n  /**\n   * Add a mesh in the exclusion list to prevent it to impact or being impacted by the highlight layer.\n   * @param mesh The mesh to exclude from the highlight layer\n   */\n  addExcludedMesh(mesh) {\n    if (!this._excludedMeshes) {\n      return;\n    }\n    const meshExcluded = this._excludedMeshes[mesh.uniqueId];\n    if (!meshExcluded) {\n      const obj = {\n        mesh: mesh,\n        beforeBind: null,\n        afterRender: null,\n        stencilState: false\n      };\n      obj.beforeBind = mesh.onBeforeBindObservable.add(mesh => {\n        obj.stencilState = mesh.getEngine().getStencilBuffer();\n        mesh.getEngine().setStencilBuffer(false);\n      });\n      obj.afterRender = mesh.onAfterRenderObservable.add(mesh => {\n        mesh.getEngine().setStencilBuffer(obj.stencilState);\n      });\n      this._excludedMeshes[mesh.uniqueId] = obj;\n    }\n  }\n  /**\n   * Remove a mesh from the exclusion list to let it impact or being impacted by the highlight layer.\n   * @param mesh The mesh to highlight\n   */\n  removeExcludedMesh(mesh) {\n    if (!this._excludedMeshes) {\n      return;\n    }\n    const meshExcluded = this._excludedMeshes[mesh.uniqueId];\n    if (meshExcluded) {\n      if (meshExcluded.beforeBind) {\n        mesh.onBeforeBindObservable.remove(meshExcluded.beforeBind);\n      }\n      if (meshExcluded.afterRender) {\n        mesh.onAfterRenderObservable.remove(meshExcluded.afterRender);\n      }\n    }\n    this._excludedMeshes[mesh.uniqueId] = null;\n  }\n  /**\n   * Determine if a given mesh will be highlighted by the current HighlightLayer\n   * @param mesh mesh to test\n   * @returns true if the mesh will be highlighted by the current HighlightLayer\n   */\n  hasMesh(mesh) {\n    if (!this._meshes) {\n      return false;\n    }\n    if (!super.hasMesh(mesh)) {\n      return false;\n    }\n    return this._meshes[mesh.uniqueId] !== undefined && this._meshes[mesh.uniqueId] !== null;\n  }\n  /**\n   * Add a mesh in the highlight layer in order to make it glow with the chosen color.\n   * @param mesh The mesh to highlight\n   * @param color The color of the highlight\n   * @param glowEmissiveOnly Extract the glow from the emissive texture\n   */\n  addMesh(mesh, color, glowEmissiveOnly = false) {\n    if (!this._meshes) {\n      return;\n    }\n    const meshHighlight = this._meshes[mesh.uniqueId];\n    if (meshHighlight) {\n      meshHighlight.color = color;\n    } else {\n      this._meshes[mesh.uniqueId] = {\n        mesh: mesh,\n        color: color,\n        // Lambda required for capture due to Observable this context\n        observerHighlight: mesh.onBeforeBindObservable.add(mesh => {\n          if (this.isEnabled) {\n            if (this._excludedMeshes && this._excludedMeshes[mesh.uniqueId]) {\n              this._defaultStencilReference(mesh);\n            } else {\n              mesh.getScene().getEngine().setStencilFunctionReference(this._instanceGlowingMeshStencilReference);\n            }\n          }\n        }),\n        observerDefault: mesh.onAfterRenderObservable.add(mesh => {\n          if (this.isEnabled) {\n            this._defaultStencilReference(mesh);\n          }\n        }),\n        glowEmissiveOnly: glowEmissiveOnly\n      };\n      mesh.onDisposeObservable.add(() => {\n        this._disposeMesh(mesh);\n      });\n    }\n    this._shouldRender = true;\n  }\n  /**\n   * Remove a mesh from the highlight layer in order to make it stop glowing.\n   * @param mesh The mesh to highlight\n   */\n  removeMesh(mesh) {\n    if (!this._meshes) {\n      return;\n    }\n    const meshHighlight = this._meshes[mesh.uniqueId];\n    if (meshHighlight) {\n      if (meshHighlight.observerHighlight) {\n        mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);\n      }\n      if (meshHighlight.observerDefault) {\n        mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);\n      }\n      delete this._meshes[mesh.uniqueId];\n    }\n    this._shouldRender = false;\n    for (const meshHighlightToCheck in this._meshes) {\n      if (this._meshes[meshHighlightToCheck]) {\n        this._shouldRender = true;\n        break;\n      }\n    }\n  }\n  /**\n   * Remove all the meshes currently referenced in the highlight layer\n   */\n  removeAllMeshes() {\n    if (!this._meshes) {\n      return;\n    }\n    for (const uniqueId in this._meshes) {\n      if (Object.prototype.hasOwnProperty.call(this._meshes, uniqueId)) {\n        const mesh = this._meshes[uniqueId];\n        if (mesh) {\n          this.removeMesh(mesh.mesh);\n        }\n      }\n    }\n  }\n  /**\n   * Force the stencil to the normal expected value for none glowing parts\n   * @param mesh\n   */\n  _defaultStencilReference(mesh) {\n    mesh.getScene().getEngine().setStencilFunctionReference(HighlightLayer.NormalMeshStencilReference);\n  }\n  /**\n   * Free any resources and references associated to a mesh.\n   * Internal use\n   * @param mesh The mesh to free.\n   * @internal\n   */\n  _disposeMesh(mesh) {\n    this.removeMesh(mesh);\n    this.removeExcludedMesh(mesh);\n  }\n  /**\n   * Dispose the highlight layer and free resources.\n   */\n  dispose() {\n    if (this._meshes) {\n      // Clean mesh references\n      for (const id in this._meshes) {\n        const meshHighlight = this._meshes[id];\n        if (meshHighlight && meshHighlight.mesh) {\n          if (meshHighlight.observerHighlight) {\n            meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);\n          }\n          if (meshHighlight.observerDefault) {\n            meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);\n          }\n        }\n      }\n      this._meshes = null;\n    }\n    if (this._excludedMeshes) {\n      for (const id in this._excludedMeshes) {\n        const meshHighlight = this._excludedMeshes[id];\n        if (meshHighlight) {\n          if (meshHighlight.beforeBind) {\n            meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.beforeBind);\n          }\n          if (meshHighlight.afterRender) {\n            meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.afterRender);\n          }\n        }\n      }\n      this._excludedMeshes = null;\n    }\n    super.dispose();\n  }\n  /**\n   * Gets the class name of the effect layer\n   * @returns the string with the class name of the effect layer\n   */\n  getClassName() {\n    return \"HighlightLayer\";\n  }\n  /**\n   * Serializes this Highlight layer\n   * @returns a serialized Highlight layer object\n   */\n  serialize() {\n    const serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.customType = \"BABYLON.HighlightLayer\";\n    // Highlighted meshes\n    serializationObject.meshes = [];\n    if (this._meshes) {\n      for (const m in this._meshes) {\n        const mesh = this._meshes[m];\n        if (mesh) {\n          serializationObject.meshes.push({\n            glowEmissiveOnly: mesh.glowEmissiveOnly,\n            color: mesh.color.asArray(),\n            meshId: mesh.mesh.id\n          });\n        }\n      }\n    }\n    // Excluded meshes\n    serializationObject.excludedMeshes = [];\n    if (this._excludedMeshes) {\n      for (const e in this._excludedMeshes) {\n        const excludedMesh = this._excludedMeshes[e];\n        if (excludedMesh) {\n          serializationObject.excludedMeshes.push(excludedMesh.mesh.id);\n        }\n      }\n    }\n    return serializationObject;\n  }\n  /**\n   * Creates a Highlight layer from parsed Highlight layer data\n   * @param parsedHightlightLayer defines the Highlight layer data\n   * @param scene defines the current scene\n   * @param rootUrl defines the root URL containing the Highlight layer information\n   * @returns a parsed Highlight layer\n   */\n  static Parse(parsedHightlightLayer, scene, rootUrl) {\n    const hl = SerializationHelper.Parse(() => new HighlightLayer(parsedHightlightLayer.name, scene, parsedHightlightLayer.options), parsedHightlightLayer, scene, rootUrl);\n    let index;\n    // Excluded meshes\n    for (index = 0; index < parsedHightlightLayer.excludedMeshes.length; index++) {\n      const mesh = scene.getMeshById(parsedHightlightLayer.excludedMeshes[index]);\n      if (mesh) {\n        hl.addExcludedMesh(mesh);\n      }\n    }\n    // Included meshes\n    for (index = 0; index < parsedHightlightLayer.meshes.length; index++) {\n      const highlightedMesh = parsedHightlightLayer.meshes[index];\n      const mesh = scene.getMeshById(highlightedMesh.meshId);\n      if (mesh) {\n        hl.addMesh(mesh, Color3.FromArray(highlightedMesh.color), highlightedMesh.glowEmissiveOnly);\n      }\n    }\n    return hl;\n  }\n}\n/**\n * Effect Name of the highlight layer.\n */\nHighlightLayer.EffectName = \"HighlightLayer\";\n/**\n * The neutral color used during the preparation of the glow effect.\n * This is black by default as the blend operation is a blend operation.\n */\nHighlightLayer.NeutralColor = new Color4(0, 0, 0, 0);\n/**\n * Stencil value used for glowing meshes.\n */\nHighlightLayer.GlowingMeshStencilReference = 0x02;\n/**\n * Stencil value used for the other meshes in the scene.\n */\nHighlightLayer.NormalMeshStencilReference = 0x01;\n__decorate([serialize()], HighlightLayer.prototype, \"innerGlow\", void 0);\n__decorate([serialize()], HighlightLayer.prototype, \"outerGlow\", void 0);\n__decorate([serialize()], HighlightLayer.prototype, \"blurHorizontalSize\", null);\n__decorate([serialize()], HighlightLayer.prototype, \"blurVerticalSize\", null);\n__decorate([serialize(\"options\")], HighlightLayer.prototype, \"_options\", void 0);\nRegisterClass(\"BABYLON.HighlightLayer\", HighlightLayer);","map":{"version":3,"names":["serialize","SerializationHelper","Observable","Vector2","Engine","VertexBuffer","Material","Texture","RenderTargetTexture","PostProcess","PassPostProcess","BlurPostProcess","EffectLayer","AbstractScene","Logger","RegisterClass","Color4","Color3","prototype","getHighlightLayerByName","name","index","_a","effectLayers","length","getEffectName","HighlightLayer","EffectName","GlowBlurPostProcess","constructor","direction","kernel","options","camera","samplingMode","BILINEAR_SAMPLINGMODE","engine","reusable","onApplyObservable","add","effect","setFloat2","width","height","setVector2","setFloat","blurHorizontalSize","value","_horizontalBlurPostprocess","_options","blurVerticalSize","_verticalBlurPostprocess","scene","innerGlow","outerGlow","onBeforeBlurObservable","onAfterBlurObservable","_instanceGlowingMeshStencilReference","GlowingMeshStencilReference","_meshes","_excludedMeshes","neutralColor","NeutralColor","_engine","isStencilEnable","Warn","Object","assign","mainTextureRatio","blurTextureSizeRatio","alphaBlendingMode","renderingGroupId","mainTextureType","_init","mainTextureFixedSize","_shouldRender","_numInternalDraws","_createMergeEffect","createEffect","PositionKind","isStroke","undefined","_createTextureAndPostProcesses","blurTextureWidth","_mainTextureDesiredSize","blurTextureHeight","needPOTTextures","GetExponentOfTwo","_maxSize","textureType","getCaps","textureHalfFloatRender","_blurTexture","_scene","wrapU","CLAMP_ADDRESSMODE","wrapV","anisotropicFilteringLevel","updateSamplingMode","TRILINEAR_SAMPLINGMODE","renderParticles","ignoreCameraViewport","_textures","_downSamplePostprocess","getEngine","externalTextureSamplerBinding","setTexture","_mainTexture","_postProcesses","onAfterUnbindObservable","notifyObservers","internalTexture","renderTarget","postProcessManager","directRender","unBindFramebuffer","map","pp","autoClear","needStencil","isReady","subMesh","useInstances","material","getMaterial","mesh","getRenderingMesh","emissiveTexture","highlightLayerMesh","uniqueId","glowEmissiveOnly","_isReady","_internalRender","renderIndex","cacheStencilState","setStencilOperationPass","setStencilOperationFail","setStencilOperationDepthFail","setStencilMask","setStencilBuffer","setStencilFunctionReference","setStencilFunction","drawElementsType","TriangleFillMode","restoreStencilState","shouldRender","_shouldRenderMesh","hasMesh","_canRenderMesh","_addCustomEffectDefines","defines","push","_setEmissiveTextureAndColor","_emissiveTextureAndColor","color","set","r","g","b","a","texture","addExcludedMesh","meshExcluded","obj","beforeBind","afterRender","stencilState","onBeforeBindObservable","getStencilBuffer","onAfterRenderObservable","removeExcludedMesh","remove","addMesh","meshHighlight","observerHighlight","isEnabled","_defaultStencilReference","getScene","observerDefault","onDisposeObservable","_disposeMesh","removeMesh","meshHighlightToCheck","removeAllMeshes","hasOwnProperty","call","NormalMeshStencilReference","dispose","id","getClassName","serializationObject","Serialize","customType","meshes","m","asArray","meshId","excludedMeshes","e","excludedMesh","Parse","parsedHightlightLayer","rootUrl","hl","getMeshById","highlightedMesh","FromArray","__decorate"],"sources":["../../../../dev/core/src/Layers/highlightLayer.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { PostProcessOptions } from \"../PostProcesses/postProcess\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess\";\r\nimport { BlurPostProcess } from \"../PostProcesses/blurPostProcess\";\r\nimport { EffectLayer } from \"./effectLayer\";\r\nimport { AbstractScene } from \"../abstractScene\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { Color4, Color3 } from \"../Maths/math.color\";\r\n\r\nimport \"../Shaders/glowMapMerge.fragment\";\r\nimport \"../Shaders/glowMapMerge.vertex\";\r\nimport \"../Shaders/glowBlurPostProcess.fragment\";\r\nimport \"../Layers/effectLayerSceneComponent\";\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * Return a the first highlight layer of the scene with a given name.\r\n         * @param name The name of the highlight layer to look for.\r\n         * @returns The highlight layer if found otherwise null.\r\n         */\r\n        getHighlightLayerByName(name: string): Nullable<HighlightLayer>;\r\n    }\r\n}\r\n\r\nAbstractScene.prototype.getHighlightLayerByName = function (name: string): Nullable<HighlightLayer> {\r\n    for (let index = 0; index < this.effectLayers?.length; index++) {\r\n        if (this.effectLayers[index].name === name && this.effectLayers[index].getEffectName() === HighlightLayer.EffectName) {\r\n            return (<any>this.effectLayers[index]) as HighlightLayer;\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Special Glow Blur post process only blurring the alpha channel\r\n * It enforces keeping the most luminous color in the color channel.\r\n */\r\nclass GlowBlurPostProcess extends PostProcess {\r\n    constructor(\r\n        name: string,\r\n        public direction: Vector2,\r\n        public kernel: number,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode: number = Texture.BILINEAR_SAMPLINGMODE,\r\n        engine?: Engine,\r\n        reusable?: boolean\r\n    ) {\r\n        super(name, \"glowBlurPostProcess\", [\"screenSize\", \"direction\", \"blurWidth\"], null, options, camera, samplingMode, engine, reusable);\r\n\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            effect.setFloat2(\"screenSize\", this.width, this.height);\r\n            effect.setVector2(\"direction\", this.direction);\r\n            effect.setFloat(\"blurWidth\", this.kernel);\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Highlight layer options. This helps customizing the behaviour\r\n * of the highlight layer.\r\n */\r\nexport interface IHighlightLayerOptions {\r\n    /**\r\n     * Multiplication factor apply to the canvas size to compute the render target size\r\n     * used to generated the glowing objects (the smaller the faster). Default: 0.5\r\n     */\r\n    mainTextureRatio: number;\r\n\r\n    /**\r\n     * Enforces a fixed size texture to ensure resize independent blur. Default: undefined\r\n     */\r\n    mainTextureFixedSize?: number;\r\n\r\n    /**\r\n     * Multiplication factor apply to the main texture size in the first step of the blur to reduce the size\r\n     * of the picture to blur (the smaller the faster). Default: 0.5\r\n     */\r\n    blurTextureSizeRatio: number;\r\n\r\n    /**\r\n     * How big in texel of the blur texture is the vertical blur. Default: 1\r\n     */\r\n    blurVerticalSize: number;\r\n\r\n    /**\r\n     * How big in texel of the blur texture is the horizontal blur. Default: 1\r\n     */\r\n    blurHorizontalSize: number;\r\n\r\n    /**\r\n     * Alpha blending mode used to apply the blur.  Default: ALPHA_COMBINE\r\n     */\r\n    alphaBlendingMode: number;\r\n\r\n    /**\r\n     * The camera attached to the layer. Default: null\r\n     */\r\n    camera: Nullable<Camera>;\r\n\r\n    /**\r\n     * Should we display highlight as a solid stroke? Default: false\r\n     */\r\n    isStroke?: boolean;\r\n\r\n    /**\r\n     * The rendering group to draw the layer in. Default: -1\r\n     */\r\n    renderingGroupId: number;\r\n\r\n    /**\r\n     * The type of the main texture. Default: TEXTURETYPE_UNSIGNED_INT\r\n     */\r\n    mainTextureType: number;\r\n}\r\n\r\n/**\r\n * Storage interface grouping all the information required for glowing a mesh.\r\n */\r\ninterface IHighlightLayerMesh {\r\n    /**\r\n     * The glowy mesh\r\n     */\r\n    mesh: Mesh;\r\n    /**\r\n     * The color of the glow\r\n     */\r\n    color: Color3;\r\n    /**\r\n     * The mesh render callback use to insert stencil information\r\n     */\r\n    observerHighlight: Nullable<Observer<Mesh>>;\r\n    /**\r\n     * The mesh render callback use to come to the default behavior\r\n     */\r\n    observerDefault: Nullable<Observer<Mesh>>;\r\n    /**\r\n     * If it exists, the emissive color of the material will be used to generate the glow.\r\n     * Else it falls back to the current color.\r\n     */\r\n    glowEmissiveOnly: boolean;\r\n}\r\n\r\n/**\r\n * Storage interface grouping all the information required for an excluded mesh.\r\n */\r\ninterface IHighlightLayerExcludedMesh {\r\n    /**\r\n     * The glowy mesh\r\n     */\r\n    mesh: Mesh;\r\n    /**\r\n     * The mesh render callback use to prevent stencil use\r\n     */\r\n    beforeBind: Nullable<Observer<Mesh>>;\r\n    /**\r\n     * The mesh render callback use to restore previous stencil use\r\n     */\r\n    afterRender: Nullable<Observer<Mesh>>;\r\n    /**\r\n     * Current stencil state of the engine\r\n     */\r\n    stencilState: boolean;\r\n}\r\n\r\n/**\r\n * The highlight layer Helps adding a glow effect around a mesh.\r\n *\r\n * Once instantiated in a scene, simply use the addMesh or removeMesh method to add or remove\r\n * glowy meshes to your scene.\r\n *\r\n * !!! THIS REQUIRES AN ACTIVE STENCIL BUFFER ON THE CANVAS !!!\r\n */\r\nexport class HighlightLayer extends EffectLayer {\r\n    /**\r\n     * Effect Name of the highlight layer.\r\n     */\r\n    public static readonly EffectName = \"HighlightLayer\";\r\n\r\n    /**\r\n     * The neutral color used during the preparation of the glow effect.\r\n     * This is black by default as the blend operation is a blend operation.\r\n     */\r\n    public static NeutralColor: Color4 = new Color4(0, 0, 0, 0);\r\n\r\n    /**\r\n     * Stencil value used for glowing meshes.\r\n     */\r\n    public static GlowingMeshStencilReference = 0x02;\r\n\r\n    /**\r\n     * Stencil value used for the other meshes in the scene.\r\n     */\r\n    public static NormalMeshStencilReference = 0x01;\r\n\r\n    /**\r\n     * Specifies whether or not the inner glow is ACTIVE in the layer.\r\n     */\r\n    @serialize()\r\n    public innerGlow: boolean = true;\r\n\r\n    /**\r\n     * Specifies whether or not the outer glow is ACTIVE in the layer.\r\n     */\r\n    @serialize()\r\n    public outerGlow: boolean = true;\r\n\r\n    /**\r\n     * Specifies the horizontal size of the blur.\r\n     */\r\n    public set blurHorizontalSize(value: number) {\r\n        this._horizontalBlurPostprocess.kernel = value;\r\n        this._options.blurHorizontalSize = value;\r\n    }\r\n\r\n    /**\r\n     * Specifies the vertical size of the blur.\r\n     */\r\n    public set blurVerticalSize(value: number) {\r\n        this._verticalBlurPostprocess.kernel = value;\r\n        this._options.blurVerticalSize = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the horizontal size of the blur.\r\n     */\r\n    @serialize()\r\n    public get blurHorizontalSize(): number {\r\n        return this._horizontalBlurPostprocess.kernel;\r\n    }\r\n\r\n    /**\r\n     * Gets the vertical size of the blur.\r\n     */\r\n    @serialize()\r\n    public get blurVerticalSize(): number {\r\n        return this._verticalBlurPostprocess.kernel;\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the highlight layer is being blurred.\r\n     */\r\n    public onBeforeBlurObservable = new Observable<HighlightLayer>();\r\n\r\n    /**\r\n     * An event triggered when the highlight layer has been blurred.\r\n     */\r\n    public onAfterBlurObservable = new Observable<HighlightLayer>();\r\n\r\n    private _instanceGlowingMeshStencilReference = HighlightLayer.GlowingMeshStencilReference++;\r\n\r\n    @serialize(\"options\")\r\n    private _options: IHighlightLayerOptions;\r\n    private _downSamplePostprocess: PassPostProcess;\r\n    private _horizontalBlurPostprocess: GlowBlurPostProcess;\r\n    private _verticalBlurPostprocess: GlowBlurPostProcess;\r\n    private _blurTexture: RenderTargetTexture;\r\n\r\n    private _meshes: Nullable<{ [id: string]: Nullable<IHighlightLayerMesh> }> = {};\r\n    private _excludedMeshes: Nullable<{ [id: string]: Nullable<IHighlightLayerExcludedMesh> }> = {};\r\n\r\n    /**\r\n     * Instantiates a new highlight Layer and references it to the scene..\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     * @param options Sets of none mandatory options to use with the layer (see IHighlightLayerOptions for more information)\r\n     */\r\n    constructor(public name: string, scene?: Scene, options?: Partial<IHighlightLayerOptions>) {\r\n        super(name, scene);\r\n        this.neutralColor = HighlightLayer.NeutralColor;\r\n\r\n        // Warn on stencil\r\n        if (!this._engine.isStencilEnable) {\r\n            Logger.Warn(\"Rendering the Highlight Layer requires the stencil to be active on the canvas. var engine = new Engine(canvas, antialias, { stencil: true }\");\r\n        }\r\n\r\n        // Adapt options\r\n        this._options = {\r\n            mainTextureRatio: 0.5,\r\n            blurTextureSizeRatio: 0.5,\r\n            blurHorizontalSize: 1.0,\r\n            blurVerticalSize: 1.0,\r\n            alphaBlendingMode: Constants.ALPHA_COMBINE,\r\n            camera: null,\r\n            renderingGroupId: -1,\r\n            mainTextureType: Constants.TEXTURETYPE_UNSIGNED_INT,\r\n            ...options,\r\n        };\r\n\r\n        // Initialize the layer\r\n        this._init({\r\n            alphaBlendingMode: this._options.alphaBlendingMode,\r\n            camera: this._options.camera,\r\n            mainTextureFixedSize: this._options.mainTextureFixedSize,\r\n            mainTextureRatio: this._options.mainTextureRatio,\r\n            renderingGroupId: this._options.renderingGroupId,\r\n            mainTextureType: this._options.mainTextureType,\r\n        });\r\n\r\n        // Do not render as long as no meshes have been added\r\n        this._shouldRender = false;\r\n    }\r\n\r\n    /**\r\n     * Get the effect name of the layer.\r\n     * @returns The effect name\r\n     */\r\n    public getEffectName(): string {\r\n        return HighlightLayer.EffectName;\r\n    }\r\n\r\n    protected _numInternalDraws(): number {\r\n        return 2; // we need two rendering, one for the inner glow and the other for the outer glow\r\n    }\r\n\r\n    /**\r\n     * Create the merge effect. This is the shader use to blit the information back\r\n     * to the main canvas at the end of the scene rendering.\r\n     */\r\n    protected _createMergeEffect(): Effect {\r\n        // Effect\r\n        return this._engine.createEffect(\"glowMapMerge\", [VertexBuffer.PositionKind], [\"offset\"], [\"textureSampler\"], this._options.isStroke ? \"#define STROKE \\n\" : undefined);\r\n    }\r\n\r\n    /**\r\n     * Creates the render target textures and post processes used in the highlight layer.\r\n     */\r\n    protected _createTextureAndPostProcesses(): void {\r\n        let blurTextureWidth = this._mainTextureDesiredSize.width * this._options.blurTextureSizeRatio;\r\n        let blurTextureHeight = this._mainTextureDesiredSize.height * this._options.blurTextureSizeRatio;\r\n        blurTextureWidth = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;\r\n        blurTextureHeight = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;\r\n\r\n        let textureType = 0;\r\n        if (this._engine.getCaps().textureHalfFloatRender) {\r\n            textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        } else {\r\n            textureType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        }\r\n\r\n        this._blurTexture = new RenderTargetTexture(\r\n            \"HighlightLayerBlurRTT\",\r\n            {\r\n                width: blurTextureWidth,\r\n                height: blurTextureHeight,\r\n            },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            textureType\r\n        );\r\n        this._blurTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture.anisotropicFilteringLevel = 16;\r\n        this._blurTexture.updateSamplingMode(Texture.TRILINEAR_SAMPLINGMODE);\r\n        this._blurTexture.renderParticles = false;\r\n        this._blurTexture.ignoreCameraViewport = true;\r\n\r\n        this._textures = [this._blurTexture];\r\n\r\n        if (this._options.alphaBlendingMode === Constants.ALPHA_COMBINE) {\r\n            this._downSamplePostprocess = new PassPostProcess(\r\n                \"HighlightLayerPPP\",\r\n                this._options.blurTextureSizeRatio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                this._scene.getEngine()\r\n            );\r\n            this._downSamplePostprocess.externalTextureSamplerBinding = true;\r\n            this._downSamplePostprocess.onApplyObservable.add((effect) => {\r\n                effect.setTexture(\"textureSampler\", this._mainTexture);\r\n            });\r\n\r\n            this._horizontalBlurPostprocess = new GlowBlurPostProcess(\r\n                \"HighlightLayerHBP\",\r\n                new Vector2(1.0, 0),\r\n                this._options.blurHorizontalSize,\r\n                1,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                this._scene.getEngine()\r\n            );\r\n            this._horizontalBlurPostprocess.onApplyObservable.add((effect) => {\r\n                effect.setFloat2(\"screenSize\", blurTextureWidth, blurTextureHeight);\r\n            });\r\n\r\n            this._verticalBlurPostprocess = new GlowBlurPostProcess(\r\n                \"HighlightLayerVBP\",\r\n                new Vector2(0, 1.0),\r\n                this._options.blurVerticalSize,\r\n                1,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                this._scene.getEngine()\r\n            );\r\n            this._verticalBlurPostprocess.onApplyObservable.add((effect) => {\r\n                effect.setFloat2(\"screenSize\", blurTextureWidth, blurTextureHeight);\r\n            });\r\n\r\n            this._postProcesses = [this._downSamplePostprocess, this._horizontalBlurPostprocess, this._verticalBlurPostprocess];\r\n        } else {\r\n            this._horizontalBlurPostprocess = new BlurPostProcess(\r\n                \"HighlightLayerHBP\",\r\n                new Vector2(1.0, 0),\r\n                this._options.blurHorizontalSize / 2,\r\n                {\r\n                    width: blurTextureWidth,\r\n                    height: blurTextureHeight,\r\n                },\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                this._scene.getEngine(),\r\n                false,\r\n                textureType\r\n            );\r\n            this._horizontalBlurPostprocess.width = blurTextureWidth;\r\n            this._horizontalBlurPostprocess.height = blurTextureHeight;\r\n            this._horizontalBlurPostprocess.externalTextureSamplerBinding = true;\r\n            this._horizontalBlurPostprocess.onApplyObservable.add((effect) => {\r\n                effect.setTexture(\"textureSampler\", this._mainTexture);\r\n            });\r\n\r\n            this._verticalBlurPostprocess = new BlurPostProcess(\r\n                \"HighlightLayerVBP\",\r\n                new Vector2(0, 1.0),\r\n                this._options.blurVerticalSize / 2,\r\n                {\r\n                    width: blurTextureWidth,\r\n                    height: blurTextureHeight,\r\n                },\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                this._scene.getEngine(),\r\n                false,\r\n                textureType\r\n            );\r\n\r\n            this._postProcesses = [this._horizontalBlurPostprocess, this._verticalBlurPostprocess];\r\n        }\r\n\r\n        this._mainTexture.onAfterUnbindObservable.add(() => {\r\n            this.onBeforeBlurObservable.notifyObservers(this);\r\n\r\n            const internalTexture = this._blurTexture.renderTarget;\r\n            if (internalTexture) {\r\n                this._scene.postProcessManager.directRender(this._postProcesses, internalTexture, true);\r\n                this._engine.unBindFramebuffer(internalTexture, true);\r\n            }\r\n\r\n            this.onAfterBlurObservable.notifyObservers(this);\r\n        });\r\n\r\n        // Prevent autoClear.\r\n        this._postProcesses.map((pp) => {\r\n            pp.autoClear = false;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the layer needs stencil enabled during the mesh rendering.\r\n     */\r\n    public needStencil(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @returns true if ready otherwise, false\r\n     */\r\n    public isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        const material = subMesh.getMaterial();\r\n        const mesh = subMesh.getRenderingMesh();\r\n\r\n        if (!material || !mesh || !this._meshes) {\r\n            return false;\r\n        }\r\n\r\n        let emissiveTexture: Nullable<Texture> = null;\r\n        const highlightLayerMesh = this._meshes[mesh.uniqueId];\r\n\r\n        if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {\r\n            emissiveTexture = (<any>material).emissiveTexture;\r\n        }\r\n        return super._isReady(subMesh, useInstances, emissiveTexture);\r\n    }\r\n\r\n    /**\r\n     * Implementation specific of rendering the generating effect on the main canvas.\r\n     * @param effect The effect used to render through\r\n     * @param renderIndex\r\n     */\r\n    protected _internalRender(effect: Effect, renderIndex: number): void {\r\n        // Texture\r\n        effect.setTexture(\"textureSampler\", this._blurTexture);\r\n\r\n        // Cache\r\n        const engine = this._engine;\r\n        engine.cacheStencilState();\r\n\r\n        // Stencil operations\r\n        engine.setStencilOperationPass(Constants.REPLACE);\r\n        engine.setStencilOperationFail(Constants.KEEP);\r\n        engine.setStencilOperationDepthFail(Constants.KEEP);\r\n\r\n        // Draw order\r\n        engine.setStencilMask(0x00);\r\n        engine.setStencilBuffer(true);\r\n        engine.setStencilFunctionReference(this._instanceGlowingMeshStencilReference);\r\n\r\n        // 2 passes inner outer\r\n        if (this.outerGlow && renderIndex === 0) {\r\n            // the outer glow is rendered the first time _internalRender is called, so when renderIndex == 0 (and only if outerGlow is enabled)\r\n            effect.setFloat(\"offset\", 0);\r\n            engine.setStencilFunction(Constants.NOTEQUAL);\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n        if (this.innerGlow && renderIndex === 1) {\r\n            // the inner glow is rendered the second time _internalRender is called, so when renderIndex == 1 (and only if innerGlow is enabled)\r\n            effect.setFloat(\"offset\", 1);\r\n            engine.setStencilFunction(Constants.EQUAL);\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n\r\n        // Restore Cache\r\n        engine.restoreStencilState();\r\n    }\r\n\r\n    /**\r\n     * Returns true if the layer contains information to display, otherwise false.\r\n     */\r\n    public shouldRender(): boolean {\r\n        if (super.shouldRender()) {\r\n            return this._meshes ? true : false;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    protected _shouldRenderMesh(mesh: Mesh): boolean {\r\n        // Excluded Mesh\r\n        if (this._excludedMeshes && this._excludedMeshes[mesh.uniqueId]) {\r\n            return false;\r\n        }\r\n\r\n        if (!super.hasMesh(mesh)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh can be rendered, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @param material The material used on the mesh\r\n     * @returns true if it can be rendered otherwise false\r\n     */\r\n    protected _canRenderMesh(mesh: AbstractMesh, material: Material): boolean {\r\n        // all meshes can be rendered in the highlight layer, even transparent ones\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Adds specific effects defines.\r\n     * @param defines The defines to add specifics to.\r\n     */\r\n    protected _addCustomEffectDefines(defines: string[]): void {\r\n        defines.push(\"#define HIGHLIGHT\");\r\n    }\r\n\r\n    /**\r\n     * Sets the required values for both the emissive texture and and the main color.\r\n     * @param mesh\r\n     * @param subMesh\r\n     * @param material\r\n     */\r\n    protected _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void {\r\n        const highlightLayerMesh = this._meshes![mesh.uniqueId];\r\n        if (highlightLayerMesh) {\r\n            this._emissiveTextureAndColor.color.set(highlightLayerMesh.color.r, highlightLayerMesh.color.g, highlightLayerMesh.color.b, 1.0);\r\n        } else {\r\n            this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);\r\n        }\r\n\r\n        if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {\r\n            this._emissiveTextureAndColor.texture = (<any>material).emissiveTexture;\r\n            this._emissiveTextureAndColor.color.set(1.0, 1.0, 1.0, 1.0);\r\n        } else {\r\n            this._emissiveTextureAndColor.texture = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the exclusion list to prevent it to impact or being impacted by the highlight layer.\r\n     * @param mesh The mesh to exclude from the highlight layer\r\n     */\r\n    public addExcludedMesh(mesh: Mesh) {\r\n        if (!this._excludedMeshes) {\r\n            return;\r\n        }\r\n\r\n        const meshExcluded = this._excludedMeshes[mesh.uniqueId];\r\n        if (!meshExcluded) {\r\n            const obj: IHighlightLayerExcludedMesh = {\r\n                mesh: mesh,\r\n                beforeBind: null,\r\n                afterRender: null,\r\n                stencilState: false,\r\n            };\r\n\r\n            obj.beforeBind = mesh.onBeforeBindObservable.add((mesh: Mesh) => {\r\n                obj.stencilState = mesh.getEngine().getStencilBuffer();\r\n                mesh.getEngine().setStencilBuffer(false);\r\n            });\r\n\r\n            obj.afterRender = mesh.onAfterRenderObservable.add((mesh: Mesh) => {\r\n                mesh.getEngine().setStencilBuffer(obj.stencilState);\r\n            });\r\n\r\n            this._excludedMeshes[mesh.uniqueId] = obj;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the exclusion list to let it impact or being impacted by the highlight layer.\r\n     * @param mesh The mesh to highlight\r\n     */\r\n    public removeExcludedMesh(mesh: Mesh) {\r\n        if (!this._excludedMeshes) {\r\n            return;\r\n        }\r\n\r\n        const meshExcluded = this._excludedMeshes[mesh.uniqueId];\r\n        if (meshExcluded) {\r\n            if (meshExcluded.beforeBind) {\r\n                mesh.onBeforeBindObservable.remove(meshExcluded.beforeBind);\r\n            }\r\n\r\n            if (meshExcluded.afterRender) {\r\n                mesh.onAfterRenderObservable.remove(meshExcluded.afterRender);\r\n            }\r\n        }\r\n\r\n        this._excludedMeshes[mesh.uniqueId] = null;\r\n    }\r\n\r\n    /**\r\n     * Determine if a given mesh will be highlighted by the current HighlightLayer\r\n     * @param mesh mesh to test\r\n     * @returns true if the mesh will be highlighted by the current HighlightLayer\r\n     */\r\n    public hasMesh(mesh: AbstractMesh): boolean {\r\n        if (!this._meshes) {\r\n            return false;\r\n        }\r\n\r\n        if (!super.hasMesh(mesh)) {\r\n            return false;\r\n        }\r\n\r\n        return this._meshes[mesh.uniqueId] !== undefined && this._meshes[mesh.uniqueId] !== null;\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the highlight layer in order to make it glow with the chosen color.\r\n     * @param mesh The mesh to highlight\r\n     * @param color The color of the highlight\r\n     * @param glowEmissiveOnly Extract the glow from the emissive texture\r\n     */\r\n    public addMesh(mesh: Mesh, color: Color3, glowEmissiveOnly = false) {\r\n        if (!this._meshes) {\r\n            return;\r\n        }\r\n\r\n        const meshHighlight = this._meshes[mesh.uniqueId];\r\n        if (meshHighlight) {\r\n            meshHighlight.color = color;\r\n        } else {\r\n            this._meshes[mesh.uniqueId] = {\r\n                mesh: mesh,\r\n                color: color,\r\n                // Lambda required for capture due to Observable this context\r\n                observerHighlight: mesh.onBeforeBindObservable.add((mesh: Mesh) => {\r\n                    if (this.isEnabled) {\r\n                        if (this._excludedMeshes && this._excludedMeshes[mesh.uniqueId]) {\r\n                            this._defaultStencilReference(mesh);\r\n                        } else {\r\n                            mesh.getScene().getEngine().setStencilFunctionReference(this._instanceGlowingMeshStencilReference);\r\n                        }\r\n                    }\r\n                }),\r\n                observerDefault: mesh.onAfterRenderObservable.add((mesh: Mesh) => {\r\n                    if (this.isEnabled) {\r\n                        this._defaultStencilReference(mesh);\r\n                    }\r\n                }),\r\n                glowEmissiveOnly: glowEmissiveOnly,\r\n            };\r\n\r\n            mesh.onDisposeObservable.add(() => {\r\n                this._disposeMesh(mesh);\r\n            });\r\n        }\r\n\r\n        this._shouldRender = true;\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the highlight layer in order to make it stop glowing.\r\n     * @param mesh The mesh to highlight\r\n     */\r\n    public removeMesh(mesh: Mesh) {\r\n        if (!this._meshes) {\r\n            return;\r\n        }\r\n\r\n        const meshHighlight = this._meshes[mesh.uniqueId];\r\n        if (meshHighlight) {\r\n            if (meshHighlight.observerHighlight) {\r\n                mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);\r\n            }\r\n\r\n            if (meshHighlight.observerDefault) {\r\n                mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);\r\n            }\r\n            delete this._meshes[mesh.uniqueId];\r\n        }\r\n\r\n        this._shouldRender = false;\r\n        for (const meshHighlightToCheck in this._meshes) {\r\n            if (this._meshes[meshHighlightToCheck]) {\r\n                this._shouldRender = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all the meshes currently referenced in the highlight layer\r\n     */\r\n    public removeAllMeshes(): void {\r\n        if (!this._meshes) {\r\n            return;\r\n        }\r\n\r\n        for (const uniqueId in this._meshes) {\r\n            if (Object.prototype.hasOwnProperty.call(this._meshes, uniqueId)) {\r\n                const mesh = this._meshes[uniqueId];\r\n                if (mesh) {\r\n                    this.removeMesh(mesh.mesh);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force the stencil to the normal expected value for none glowing parts\r\n     * @param mesh\r\n     */\r\n    private _defaultStencilReference(mesh: Mesh) {\r\n        mesh.getScene().getEngine().setStencilFunctionReference(HighlightLayer.NormalMeshStencilReference);\r\n    }\r\n\r\n    /**\r\n     * Free any resources and references associated to a mesh.\r\n     * Internal use\r\n     * @param mesh The mesh to free.\r\n     * @internal\r\n     */\r\n    public _disposeMesh(mesh: Mesh): void {\r\n        this.removeMesh(mesh);\r\n        this.removeExcludedMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Dispose the highlight layer and free resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._meshes) {\r\n            // Clean mesh references\r\n            for (const id in this._meshes) {\r\n                const meshHighlight = this._meshes[id];\r\n                if (meshHighlight && meshHighlight.mesh) {\r\n                    if (meshHighlight.observerHighlight) {\r\n                        meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);\r\n                    }\r\n\r\n                    if (meshHighlight.observerDefault) {\r\n                        meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);\r\n                    }\r\n                }\r\n            }\r\n            this._meshes = null;\r\n        }\r\n\r\n        if (this._excludedMeshes) {\r\n            for (const id in this._excludedMeshes) {\r\n                const meshHighlight = this._excludedMeshes[id];\r\n                if (meshHighlight) {\r\n                    if (meshHighlight.beforeBind) {\r\n                        meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.beforeBind);\r\n                    }\r\n\r\n                    if (meshHighlight.afterRender) {\r\n                        meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.afterRender);\r\n                    }\r\n                }\r\n            }\r\n            this._excludedMeshes = null;\r\n        }\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the effect layer\r\n     * @returns the string with the class name of the effect layer\r\n     */\r\n    public getClassName(): string {\r\n        return \"HighlightLayer\";\r\n    }\r\n\r\n    /**\r\n     * Serializes this Highlight layer\r\n     * @returns a serialized Highlight layer object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.HighlightLayer\";\r\n\r\n        // Highlighted meshes\r\n        serializationObject.meshes = [];\r\n\r\n        if (this._meshes) {\r\n            for (const m in this._meshes) {\r\n                const mesh = this._meshes[m];\r\n\r\n                if (mesh) {\r\n                    serializationObject.meshes.push({\r\n                        glowEmissiveOnly: mesh.glowEmissiveOnly,\r\n                        color: mesh.color.asArray(),\r\n                        meshId: mesh.mesh.id,\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        // Excluded meshes\r\n        serializationObject.excludedMeshes = [];\r\n\r\n        if (this._excludedMeshes) {\r\n            for (const e in this._excludedMeshes) {\r\n                const excludedMesh = this._excludedMeshes[e];\r\n\r\n                if (excludedMesh) {\r\n                    serializationObject.excludedMeshes.push(excludedMesh.mesh.id);\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a Highlight layer from parsed Highlight layer data\r\n     * @param parsedHightlightLayer defines the Highlight layer data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing the Highlight layer information\r\n     * @returns a parsed Highlight layer\r\n     */\r\n    public static Parse(parsedHightlightLayer: any, scene: Scene, rootUrl: string): HighlightLayer {\r\n        const hl = SerializationHelper.Parse(() => new HighlightLayer(parsedHightlightLayer.name, scene, parsedHightlightLayer.options), parsedHightlightLayer, scene, rootUrl);\r\n        let index;\r\n\r\n        // Excluded meshes\r\n        for (index = 0; index < parsedHightlightLayer.excludedMeshes.length; index++) {\r\n            const mesh = scene.getMeshById(parsedHightlightLayer.excludedMeshes[index]);\r\n            if (mesh) {\r\n                hl.addExcludedMesh(<Mesh>mesh);\r\n            }\r\n        }\r\n\r\n        // Included meshes\r\n        for (index = 0; index < parsedHightlightLayer.meshes.length; index++) {\r\n            const highlightedMesh = parsedHightlightLayer.meshes[index];\r\n            const mesh = scene.getMeshById(highlightedMesh.meshId);\r\n\r\n            if (mesh) {\r\n                hl.addMesh(<Mesh>mesh, Color3.FromArray(highlightedMesh.color), highlightedMesh.glowEmissiveOnly);\r\n            }\r\n        }\r\n\r\n        return hl;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.HighlightLayer\", HighlightLayer);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}