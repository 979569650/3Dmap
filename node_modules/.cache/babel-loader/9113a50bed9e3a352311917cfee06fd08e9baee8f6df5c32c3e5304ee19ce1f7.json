{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { TextureSampler } from \"./textureSampler.js\";\n/**\n * Defines the source of the internal texture\n */\nexport var InternalTextureSource;\n(function (InternalTextureSource) {\n  /**\n   * The source of the texture data is unknown\n   */\n  InternalTextureSource[InternalTextureSource[\"Unknown\"] = 0] = \"Unknown\";\n  /**\n   * Texture data comes from an URL\n   */\n  InternalTextureSource[InternalTextureSource[\"Url\"] = 1] = \"Url\";\n  /**\n   * Texture data is only used for temporary storage\n   */\n  InternalTextureSource[InternalTextureSource[\"Temp\"] = 2] = \"Temp\";\n  /**\n   * Texture data comes from raw data (ArrayBuffer)\n   */\n  InternalTextureSource[InternalTextureSource[\"Raw\"] = 3] = \"Raw\";\n  /**\n   * Texture content is dynamic (video or dynamic texture)\n   */\n  InternalTextureSource[InternalTextureSource[\"Dynamic\"] = 4] = \"Dynamic\";\n  /**\n   * Texture content is generated by rendering to it\n   */\n  InternalTextureSource[InternalTextureSource[\"RenderTarget\"] = 5] = \"RenderTarget\";\n  /**\n   * Texture content is part of a multi render target process\n   */\n  InternalTextureSource[InternalTextureSource[\"MultiRenderTarget\"] = 6] = \"MultiRenderTarget\";\n  /**\n   * Texture data comes from a cube data file\n   */\n  InternalTextureSource[InternalTextureSource[\"Cube\"] = 7] = \"Cube\";\n  /**\n   * Texture data comes from a raw cube data\n   */\n  InternalTextureSource[InternalTextureSource[\"CubeRaw\"] = 8] = \"CubeRaw\";\n  /**\n   * Texture data come from a prefiltered cube data file\n   */\n  InternalTextureSource[InternalTextureSource[\"CubePrefiltered\"] = 9] = \"CubePrefiltered\";\n  /**\n   * Texture content is raw 3D data\n   */\n  InternalTextureSource[InternalTextureSource[\"Raw3D\"] = 10] = \"Raw3D\";\n  /**\n   * Texture content is raw 2D array data\n   */\n  InternalTextureSource[InternalTextureSource[\"Raw2DArray\"] = 11] = \"Raw2DArray\";\n  /**\n   * Texture content is a depth/stencil texture\n   */\n  InternalTextureSource[InternalTextureSource[\"DepthStencil\"] = 12] = \"DepthStencil\";\n  /**\n   * Texture data comes from a raw cube data encoded with RGBD\n   */\n  InternalTextureSource[InternalTextureSource[\"CubeRawRGBD\"] = 13] = \"CubeRawRGBD\";\n  /**\n   * Texture content is a depth texture\n   */\n  InternalTextureSource[InternalTextureSource[\"Depth\"] = 14] = \"Depth\";\n})(InternalTextureSource || (InternalTextureSource = {}));\n/**\n * Class used to store data associated with WebGL texture data for the engine\n * This class should not be used directly\n */\nexport class InternalTexture extends TextureSampler {\n  /**\n   * Gets a boolean indicating if the texture uses mipmaps\n   * TODO implements useMipMaps as a separate setting from generateMipMaps\n   */\n  get useMipMaps() {\n    return this.generateMipMaps;\n  }\n  set useMipMaps(value) {\n    this.generateMipMaps = value;\n  }\n  /** Gets the unique id of the internal texture */\n  get uniqueId() {\n    return this._uniqueId;\n  }\n  /** @internal */\n  _setUniqueId(id) {\n    this._uniqueId = id;\n  }\n  /**\n   * Gets the Engine the texture belongs to.\n   * @returns The babylon engine\n   */\n  getEngine() {\n    return this._engine;\n  }\n  /**\n   * Gets the data source type of the texture\n   */\n  get source() {\n    return this._source;\n  }\n  /**\n   * Creates a new InternalTexture\n   * @param engine defines the engine to use\n   * @param source defines the type of data that will be used\n   * @param delayAllocation if the texture allocation should be delayed (default: false)\n   */\n  constructor(engine, source, delayAllocation = false) {\n    super();\n    /**\n     * Defines if the texture is ready\n     */\n    this.isReady = false;\n    /**\n     * Defines if the texture is a cube texture\n     */\n    this.isCube = false;\n    /**\n     * Defines if the texture contains 3D data\n     */\n    this.is3D = false;\n    /**\n     * Defines if the texture contains 2D array data\n     */\n    this.is2DArray = false;\n    /**\n     * Defines if the texture contains multiview data\n     */\n    this.isMultiview = false;\n    /**\n     * Gets the URL used to load this texture\n     */\n    this.url = \"\";\n    /**\n     * Gets a boolean indicating if the texture needs mipmaps generation\n     */\n    this.generateMipMaps = false;\n    /**\n     * Gets the number of samples used by the texture (WebGL2+ only)\n     */\n    this.samples = 0;\n    /**\n     * Gets the type of the texture (int, float...)\n     */\n    this.type = -1;\n    /**\n     * Gets the format of the texture (RGB, RGBA...)\n     */\n    this.format = -1;\n    /**\n     * Observable called when the texture is loaded\n     */\n    this.onLoadedObservable = new Observable();\n    /**\n     * Observable called when the texture load is raising an error\n     */\n    this.onErrorObservable = new Observable();\n    /**\n     * If this callback is defined it will be called instead of the default _rebuild function\n     */\n    this.onRebuildCallback = null;\n    /**\n     * Gets the width of the texture\n     */\n    this.width = 0;\n    /**\n     * Gets the height of the texture\n     */\n    this.height = 0;\n    /**\n     * Gets the depth of the texture\n     */\n    this.depth = 0;\n    /**\n     * Gets the initial width of the texture (It could be rescaled if the current system does not support non power of two textures)\n     */\n    this.baseWidth = 0;\n    /**\n     * Gets the initial height of the texture (It could be rescaled if the current system does not support non power of two textures)\n     */\n    this.baseHeight = 0;\n    /**\n     * Gets the initial depth of the texture (It could be rescaled if the current system does not support non power of two textures)\n     */\n    this.baseDepth = 0;\n    /**\n     * Gets a boolean indicating if the texture is inverted on Y axis\n     */\n    this.invertY = false;\n    // Private\n    /** @internal */\n    this._invertVScale = false;\n    /** @internal */\n    this._associatedChannel = -1;\n    /** @internal */\n    this._source = InternalTextureSource.Unknown;\n    /** @internal */\n    this._buffer = null;\n    /** @internal */\n    this._bufferView = null;\n    /** @internal */\n    this._bufferViewArray = null;\n    /** @internal */\n    this._bufferViewArrayArray = null;\n    /** @internal */\n    this._size = 0;\n    /** @internal */\n    this._extension = \"\";\n    /** @internal */\n    this._files = null;\n    /** @internal */\n    this._workingCanvas = null;\n    /** @internal */\n    this._workingContext = null;\n    /** @internal */\n    this._cachedCoordinatesMode = null;\n    /** @internal */\n    this._isDisabled = false;\n    /** @internal */\n    this._compression = null;\n    /** @internal */\n    this._sphericalPolynomial = null;\n    /** @internal */\n    this._sphericalPolynomialPromise = null;\n    /** @internal */\n    this._sphericalPolynomialComputed = false;\n    /** @internal */\n    this._lodGenerationScale = 0;\n    /** @internal */\n    this._lodGenerationOffset = 0;\n    /** @internal */\n    this._useSRGBBuffer = false;\n    // The following three fields helps sharing generated fixed LODs for texture filtering\n    // In environment not supporting the textureLOD extension like EDGE. They are for internal use only.\n    // They are at the level of the gl texture to benefit from the cache.\n    /** @internal */\n    this._lodTextureHigh = null;\n    /** @internal */\n    this._lodTextureMid = null;\n    /** @internal */\n    this._lodTextureLow = null;\n    /** @internal */\n    this._isRGBD = false;\n    /** @internal */\n    this._linearSpecularLOD = false;\n    /** @internal */\n    this._irradianceTexture = null;\n    /** @internal */\n    this._hardwareTexture = null;\n    /** @internal */\n    this._maxLodLevel = null;\n    /** @internal */\n    this._references = 1;\n    /** @internal */\n    this._gammaSpace = null;\n    this._engine = engine;\n    this._source = source;\n    this._uniqueId = InternalTexture._Counter++;\n    if (!delayAllocation) {\n      this._hardwareTexture = engine._createHardwareTexture();\n    }\n  }\n  /**\n   * Increments the number of references (ie. the number of Texture that point to it)\n   */\n  incrementReferences() {\n    this._references++;\n  }\n  /**\n   * Change the size of the texture (not the size of the content)\n   * @param width defines the new width\n   * @param height defines the new height\n   * @param depth defines the new depth (1 by default)\n   */\n  updateSize(width, height, depth = 1) {\n    this._engine.updateTextureDimensions(this, width, height, depth);\n    this.width = width;\n    this.height = height;\n    this.depth = depth;\n    this.baseWidth = width;\n    this.baseHeight = height;\n    this.baseDepth = depth;\n    this._size = width * height * depth;\n  }\n  /** @internal */\n  _rebuild() {\n    var _a;\n    this.isReady = false;\n    this._cachedCoordinatesMode = null;\n    this._cachedWrapU = null;\n    this._cachedWrapV = null;\n    this._cachedWrapR = null;\n    this._cachedAnisotropicFilteringLevel = null;\n    if (this.onRebuildCallback) {\n      const data = this.onRebuildCallback(this);\n      const swapAndSetIsReady = proxyInternalTexture => {\n        proxyInternalTexture._swapAndDie(this, false);\n        this.isReady = data.isReady;\n      };\n      if (data.isAsync) {\n        data.proxy.then(swapAndSetIsReady);\n      } else {\n        swapAndSetIsReady(data.proxy);\n      }\n      return;\n    }\n    let proxy;\n    switch (this.source) {\n      case InternalTextureSource.Temp:\n        break;\n      case InternalTextureSource.Url:\n        proxy = this._engine.createTexture((_a = this._originalUrl) !== null && _a !== void 0 ? _a : this.url, !this.generateMipMaps, this.invertY, null, this.samplingMode,\n        // Do not use Proxy here as it could be fully synchronous\n        // and proxy would be undefined.\n        temp => {\n          temp._swapAndDie(this, false);\n          this.isReady = true;\n        }, null, this._buffer, undefined, this.format, this._extension, undefined, undefined, undefined, this._useSRGBBuffer);\n        return;\n      case InternalTextureSource.Raw:\n        proxy = this._engine.createRawTexture(this._bufferView, this.baseWidth, this.baseHeight, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type, undefined, this._useSRGBBuffer);\n        proxy._swapAndDie(this, false);\n        this.isReady = true;\n        break;\n      case InternalTextureSource.Raw3D:\n        proxy = this._engine.createRawTexture3D(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type);\n        proxy._swapAndDie(this, false);\n        this.isReady = true;\n        break;\n      case InternalTextureSource.Raw2DArray:\n        proxy = this._engine.createRawTexture2DArray(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type);\n        proxy._swapAndDie(this, false);\n        this.isReady = true;\n        break;\n      case InternalTextureSource.Dynamic:\n        proxy = this._engine.createDynamicTexture(this.baseWidth, this.baseHeight, this.generateMipMaps, this.samplingMode);\n        proxy._swapAndDie(this, false);\n        this._engine.updateDynamicTexture(this, this._engine.getRenderingCanvas(), this.invertY, undefined, undefined, true);\n        // The engine will make sure to update content so no need to flag it as isReady = true\n        break;\n      case InternalTextureSource.Cube:\n        proxy = this._engine.createCubeTexture(this.url, null, this._files, !this.generateMipMaps, () => {\n          proxy._swapAndDie(this, false);\n          this.isReady = true;\n        }, null, this.format, this._extension, false, 0, 0, null, undefined, this._useSRGBBuffer);\n        return;\n      case InternalTextureSource.CubeRaw:\n        proxy = this._engine.createRawCubeTexture(this._bufferViewArray, this.width, this.format, this.type, this.generateMipMaps, this.invertY, this.samplingMode, this._compression);\n        proxy._swapAndDie(this, false);\n        this.isReady = true;\n        break;\n      case InternalTextureSource.CubeRawRGBD:\n        // This case is being handeled by the environment texture tools and is not a part of the rebuild process.\n        // To use CubeRawRGBD use updateRGBDAsync on the cube texture.\n        return;\n      case InternalTextureSource.CubePrefiltered:\n        proxy = this._engine.createPrefilteredCubeTexture(this.url, null, this._lodGenerationScale, this._lodGenerationOffset, proxy => {\n          if (proxy) {\n            proxy._swapAndDie(this, false);\n          }\n          this.isReady = true;\n        }, null, this.format, this._extension);\n        proxy._sphericalPolynomial = this._sphericalPolynomial;\n        return;\n    }\n  }\n  /**\n   * @internal\n   */\n  _swapAndDie(target, swapAll = true) {\n    // TODO what about refcount on target?\n    var _a;\n    (_a = this._hardwareTexture) === null || _a === void 0 ? void 0 : _a.setUsage(target._source, this.generateMipMaps, this.isCube, this.width, this.height);\n    target._hardwareTexture = this._hardwareTexture;\n    if (swapAll) {\n      target._isRGBD = this._isRGBD;\n    }\n    if (this._lodTextureHigh) {\n      if (target._lodTextureHigh) {\n        target._lodTextureHigh.dispose();\n      }\n      target._lodTextureHigh = this._lodTextureHigh;\n    }\n    if (this._lodTextureMid) {\n      if (target._lodTextureMid) {\n        target._lodTextureMid.dispose();\n      }\n      target._lodTextureMid = this._lodTextureMid;\n    }\n    if (this._lodTextureLow) {\n      if (target._lodTextureLow) {\n        target._lodTextureLow.dispose();\n      }\n      target._lodTextureLow = this._lodTextureLow;\n    }\n    if (this._irradianceTexture) {\n      if (target._irradianceTexture) {\n        target._irradianceTexture.dispose();\n      }\n      target._irradianceTexture = this._irradianceTexture;\n    }\n    const cache = this._engine.getLoadedTexturesCache();\n    let index = cache.indexOf(this);\n    if (index !== -1) {\n      cache.splice(index, 1);\n    }\n    index = cache.indexOf(target);\n    if (index === -1) {\n      cache.push(target);\n    }\n  }\n  /**\n   * Dispose the current allocated resources\n   */\n  dispose() {\n    this._references--;\n    this.onLoadedObservable.clear();\n    this.onErrorObservable.clear();\n    if (this._references === 0) {\n      this._engine._releaseTexture(this);\n      this._hardwareTexture = null;\n    }\n  }\n}\n/** @internal */\nInternalTexture._Counter = 0;","map":{"version":3,"names":["Observable","TextureSampler","InternalTextureSource","InternalTexture","useMipMaps","generateMipMaps","value","uniqueId","_uniqueId","_setUniqueId","id","getEngine","_engine","source","_source","constructor","engine","delayAllocation","isReady","isCube","is3D","is2DArray","isMultiview","url","samples","type","format","onLoadedObservable","onErrorObservable","onRebuildCallback","width","height","depth","baseWidth","baseHeight","baseDepth","invertY","_invertVScale","_associatedChannel","Unknown","_buffer","_bufferView","_bufferViewArray","_bufferViewArrayArray","_size","_extension","_files","_workingCanvas","_workingContext","_cachedCoordinatesMode","_isDisabled","_compression","_sphericalPolynomial","_sphericalPolynomialPromise","_sphericalPolynomialComputed","_lodGenerationScale","_lodGenerationOffset","_useSRGBBuffer","_lodTextureHigh","_lodTextureMid","_lodTextureLow","_isRGBD","_linearSpecularLOD","_irradianceTexture","_hardwareTexture","_maxLodLevel","_references","_gammaSpace","_Counter","_createHardwareTexture","incrementReferences","updateSize","updateTextureDimensions","_rebuild","_cachedWrapU","_cachedWrapV","_cachedWrapR","_cachedAnisotropicFilteringLevel","data","swapAndSetIsReady","proxyInternalTexture","_swapAndDie","isAsync","proxy","then","Temp","Url","createTexture","_a","_originalUrl","samplingMode","temp","undefined","Raw","createRawTexture","Raw3D","createRawTexture3D","Raw2DArray","createRawTexture2DArray","Dynamic","createDynamicTexture","updateDynamicTexture","getRenderingCanvas","Cube","createCubeTexture","CubeRaw","createRawCubeTexture","CubeRawRGBD","CubePrefiltered","createPrefilteredCubeTexture","target","swapAll","setUsage","dispose","cache","getLoadedTexturesCache","index","indexOf","splice","push","clear","_releaseTexture"],"sources":["../../../../../dev/core/src/Materials/Textures/internalTexture.ts"],"sourcesContent":["import { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable, int } from \"../../types\";\r\nimport type { ICanvas, ICanvasRenderingContext } from \"../../Engines/ICanvas\";\r\nimport type { HardwareTextureWrapper } from \"./hardwareTextureWrapper\";\r\nimport { TextureSampler } from \"./textureSampler\";\r\n\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { SphericalPolynomial } from \"../../Maths/sphericalPolynomial\";\r\n\r\n/**\r\n * Defines the source of the internal texture\r\n */\r\nexport enum InternalTextureSource {\r\n    /**\r\n     * The source of the texture data is unknown\r\n     */\r\n    Unknown,\r\n    /**\r\n     * Texture data comes from an URL\r\n     */\r\n    Url,\r\n    /**\r\n     * Texture data is only used for temporary storage\r\n     */\r\n    Temp,\r\n    /**\r\n     * Texture data comes from raw data (ArrayBuffer)\r\n     */\r\n    Raw,\r\n    /**\r\n     * Texture content is dynamic (video or dynamic texture)\r\n     */\r\n    Dynamic,\r\n    /**\r\n     * Texture content is generated by rendering to it\r\n     */\r\n    RenderTarget,\r\n    /**\r\n     * Texture content is part of a multi render target process\r\n     */\r\n    MultiRenderTarget,\r\n    /**\r\n     * Texture data comes from a cube data file\r\n     */\r\n    Cube,\r\n    /**\r\n     * Texture data comes from a raw cube data\r\n     */\r\n    CubeRaw,\r\n    /**\r\n     * Texture data come from a prefiltered cube data file\r\n     */\r\n    CubePrefiltered,\r\n    /**\r\n     * Texture content is raw 3D data\r\n     */\r\n    Raw3D,\r\n    /**\r\n     * Texture content is raw 2D array data\r\n     */\r\n    Raw2DArray,\r\n    /**\r\n     * Texture content is a depth/stencil texture\r\n     */\r\n    DepthStencil,\r\n    /**\r\n     * Texture data comes from a raw cube data encoded with RGBD\r\n     */\r\n    CubeRawRGBD,\r\n    /**\r\n     * Texture content is a depth texture\r\n     */\r\n    Depth,\r\n}\r\n\r\n/**\r\n * Class used to store data associated with WebGL texture data for the engine\r\n * This class should not be used directly\r\n */\r\nexport class InternalTexture extends TextureSampler {\r\n    /**\r\n     * Defines if the texture is ready\r\n     */\r\n    public isReady: boolean = false;\r\n    /**\r\n     * Defines if the texture is a cube texture\r\n     */\r\n    public isCube: boolean = false;\r\n    /**\r\n     * Defines if the texture contains 3D data\r\n     */\r\n    public is3D: boolean = false;\r\n    /**\r\n     * Defines if the texture contains 2D array data\r\n     */\r\n    public is2DArray: boolean = false;\r\n    /**\r\n     * Defines if the texture contains multiview data\r\n     */\r\n    public isMultiview: boolean = false;\r\n    /**\r\n     * Gets the URL used to load this texture\r\n     */\r\n    public url: string = \"\";\r\n    /** @internal */\r\n    public _originalUrl: string; // not empty only if different from url\r\n    /**\r\n     * Gets a boolean indicating if the texture needs mipmaps generation\r\n     */\r\n    public generateMipMaps: boolean = false;\r\n    /**\r\n     * Gets a boolean indicating if the texture uses mipmaps\r\n     * TODO implements useMipMaps as a separate setting from generateMipMaps\r\n     */\r\n    public get useMipMaps() {\r\n        return this.generateMipMaps;\r\n    }\r\n    public set useMipMaps(value: boolean) {\r\n        this.generateMipMaps = value;\r\n    }\r\n    /**\r\n     * Gets the number of samples used by the texture (WebGL2+ only)\r\n     */\r\n    public samples: number = 0;\r\n    /**\r\n     * Gets the type of the texture (int, float...)\r\n     */\r\n    public type: number = -1;\r\n    /**\r\n     * Gets the format of the texture (RGB, RGBA...)\r\n     */\r\n    public format: number = -1;\r\n    /**\r\n     * Observable called when the texture is loaded\r\n     */\r\n    public onLoadedObservable = new Observable<InternalTexture>();\r\n    /**\r\n     * Observable called when the texture load is raising an error\r\n     */\r\n    public onErrorObservable = new Observable<Partial<{ message: string; exception: any }>>();\r\n    /**\r\n     * If this callback is defined it will be called instead of the default _rebuild function\r\n     */\r\n    public onRebuildCallback: Nullable<\r\n        (internalTexture: InternalTexture) => {\r\n            proxy: Nullable<InternalTexture | Promise<InternalTexture>>;\r\n            isReady: boolean;\r\n            isAsync: boolean;\r\n        }\r\n    > = null;\r\n    /**\r\n     * Gets the width of the texture\r\n     */\r\n    public width: number = 0;\r\n    /**\r\n     * Gets the height of the texture\r\n     */\r\n    public height: number = 0;\r\n    /**\r\n     * Gets the depth of the texture\r\n     */\r\n    public depth: number = 0;\r\n    /**\r\n     * Gets the initial width of the texture (It could be rescaled if the current system does not support non power of two textures)\r\n     */\r\n    public baseWidth: number = 0;\r\n    /**\r\n     * Gets the initial height of the texture (It could be rescaled if the current system does not support non power of two textures)\r\n     */\r\n    public baseHeight: number = 0;\r\n    /**\r\n     * Gets the initial depth of the texture (It could be rescaled if the current system does not support non power of two textures)\r\n     */\r\n    public baseDepth: number = 0;\r\n    /**\r\n     * Gets a boolean indicating if the texture is inverted on Y axis\r\n     */\r\n    public invertY: boolean = false;\r\n    /**\r\n     * Used for debugging purpose only\r\n     */\r\n    public label?: string;\r\n\r\n    // Private\r\n    /** @internal */\r\n    public _invertVScale = false;\r\n    /** @internal */\r\n    public _associatedChannel = -1;\r\n    /** @internal */\r\n    public _source = InternalTextureSource.Unknown;\r\n    /** @internal */\r\n    public _buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null;\r\n    /** @internal */\r\n    public _bufferView: Nullable<ArrayBufferView> = null;\r\n    /** @internal */\r\n    public _bufferViewArray: Nullable<ArrayBufferView[]> = null;\r\n    /** @internal */\r\n    public _bufferViewArrayArray: Nullable<ArrayBufferView[][]> = null;\r\n    /** @internal */\r\n    public _size: number = 0;\r\n    /** @internal */\r\n    public _extension: string = \"\";\r\n    /** @internal */\r\n    public _files: Nullable<string[]> = null;\r\n    /** @internal */\r\n    public _workingCanvas: Nullable<ICanvas> = null;\r\n    /** @internal */\r\n    public _workingContext: Nullable<ICanvasRenderingContext> = null;\r\n    /** @internal */\r\n    public _cachedCoordinatesMode: Nullable<number> = null;\r\n    /** @internal */\r\n    public _isDisabled: boolean = false;\r\n    /** @internal */\r\n    public _compression: Nullable<string> = null;\r\n    /** @internal */\r\n    public _sphericalPolynomial: Nullable<SphericalPolynomial> = null;\r\n    /** @internal */\r\n    public _sphericalPolynomialPromise: Nullable<Promise<SphericalPolynomial>> = null;\r\n    /** @internal */\r\n    public _sphericalPolynomialComputed = false;\r\n    /** @internal */\r\n    public _lodGenerationScale: number = 0;\r\n    /** @internal */\r\n    public _lodGenerationOffset: number = 0;\r\n    /** @internal */\r\n    public _useSRGBBuffer: boolean = false;\r\n\r\n    // The following three fields helps sharing generated fixed LODs for texture filtering\r\n    // In environment not supporting the textureLOD extension like EDGE. They are for internal use only.\r\n    // They are at the level of the gl texture to benefit from the cache.\r\n    /** @internal */\r\n    public _lodTextureHigh: Nullable<BaseTexture> = null;\r\n    /** @internal */\r\n    public _lodTextureMid: Nullable<BaseTexture> = null;\r\n    /** @internal */\r\n    public _lodTextureLow: Nullable<BaseTexture> = null;\r\n    /** @internal */\r\n    public _isRGBD: boolean = false;\r\n\r\n    /** @internal */\r\n    public _linearSpecularLOD: boolean = false;\r\n    /** @internal */\r\n    public _irradianceTexture: Nullable<BaseTexture> = null;\r\n\r\n    /** @internal */\r\n    public _hardwareTexture: Nullable<HardwareTextureWrapper> = null;\r\n\r\n    /** @internal */\r\n    public _maxLodLevel: Nullable<number> = null;\r\n\r\n    /** @internal */\r\n    public _references: number = 1;\r\n\r\n    /** @internal */\r\n    public _gammaSpace: Nullable<boolean> = null;\r\n\r\n    private _engine: ThinEngine;\r\n    private _uniqueId: number;\r\n\r\n    /** @internal */\r\n    public static _Counter = 0;\r\n\r\n    /** Gets the unique id of the internal texture */\r\n    public get uniqueId() {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /** @internal */\r\n    public _setUniqueId(id: number) {\r\n        this._uniqueId = id;\r\n    }\r\n\r\n    /**\r\n     * Gets the Engine the texture belongs to.\r\n     * @returns The babylon engine\r\n     */\r\n    public getEngine(): ThinEngine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Gets the data source type of the texture\r\n     */\r\n    public get source(): InternalTextureSource {\r\n        return this._source;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InternalTexture\r\n     * @param engine defines the engine to use\r\n     * @param source defines the type of data that will be used\r\n     * @param delayAllocation if the texture allocation should be delayed (default: false)\r\n     */\r\n    constructor(engine: ThinEngine, source: InternalTextureSource, delayAllocation = false) {\r\n        super();\r\n\r\n        this._engine = engine;\r\n        this._source = source;\r\n        this._uniqueId = InternalTexture._Counter++;\r\n\r\n        if (!delayAllocation) {\r\n            this._hardwareTexture = engine._createHardwareTexture();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Increments the number of references (ie. the number of Texture that point to it)\r\n     */\r\n    public incrementReferences(): void {\r\n        this._references++;\r\n    }\r\n\r\n    /**\r\n     * Change the size of the texture (not the size of the content)\r\n     * @param width defines the new width\r\n     * @param height defines the new height\r\n     * @param depth defines the new depth (1 by default)\r\n     */\r\n    public updateSize(width: int, height: int, depth: int = 1): void {\r\n        this._engine.updateTextureDimensions(this, width, height, depth);\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n        this.depth = depth;\r\n\r\n        this.baseWidth = width;\r\n        this.baseHeight = height;\r\n        this.baseDepth = depth;\r\n\r\n        this._size = width * height * depth;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        this.isReady = false;\r\n        this._cachedCoordinatesMode = null;\r\n        this._cachedWrapU = null;\r\n        this._cachedWrapV = null;\r\n        this._cachedWrapR = null;\r\n        this._cachedAnisotropicFilteringLevel = null;\r\n        if (this.onRebuildCallback) {\r\n            const data = this.onRebuildCallback(this);\r\n            const swapAndSetIsReady = (proxyInternalTexture: InternalTexture) => {\r\n                proxyInternalTexture._swapAndDie(this, false);\r\n                this.isReady = data.isReady;\r\n            };\r\n            if (data.isAsync) {\r\n                (data.proxy as Promise<InternalTexture>).then(swapAndSetIsReady);\r\n            } else {\r\n                swapAndSetIsReady(data.proxy as InternalTexture);\r\n            }\r\n            return;\r\n        }\r\n\r\n        let proxy: InternalTexture;\r\n        switch (this.source) {\r\n            case InternalTextureSource.Temp:\r\n                break;\r\n\r\n            case InternalTextureSource.Url:\r\n                proxy = this._engine.createTexture(\r\n                    this._originalUrl ?? this.url,\r\n                    !this.generateMipMaps,\r\n                    this.invertY,\r\n                    null,\r\n                    this.samplingMode,\r\n                    // Do not use Proxy here as it could be fully synchronous\r\n                    // and proxy would be undefined.\r\n                    (temp) => {\r\n                        temp._swapAndDie(this, false);\r\n                        this.isReady = true;\r\n                    },\r\n                    null,\r\n                    this._buffer,\r\n                    undefined,\r\n                    this.format,\r\n                    this._extension,\r\n                    undefined,\r\n                    undefined,\r\n                    undefined,\r\n                    this._useSRGBBuffer\r\n                );\r\n                return;\r\n\r\n            case InternalTextureSource.Raw:\r\n                proxy = this._engine.createRawTexture(\r\n                    this._bufferView,\r\n                    this.baseWidth,\r\n                    this.baseHeight,\r\n                    this.format,\r\n                    this.generateMipMaps,\r\n                    this.invertY,\r\n                    this.samplingMode,\r\n                    this._compression,\r\n                    this.type,\r\n                    undefined,\r\n                    this._useSRGBBuffer\r\n                );\r\n                proxy._swapAndDie(this, false);\r\n\r\n                this.isReady = true;\r\n                break;\r\n\r\n            case InternalTextureSource.Raw3D:\r\n                proxy = this._engine.createRawTexture3D(\r\n                    this._bufferView,\r\n                    this.baseWidth,\r\n                    this.baseHeight,\r\n                    this.baseDepth,\r\n                    this.format,\r\n                    this.generateMipMaps,\r\n                    this.invertY,\r\n                    this.samplingMode,\r\n                    this._compression,\r\n                    this.type\r\n                );\r\n                proxy._swapAndDie(this, false);\r\n\r\n                this.isReady = true;\r\n                break;\r\n\r\n            case InternalTextureSource.Raw2DArray:\r\n                proxy = this._engine.createRawTexture2DArray(\r\n                    this._bufferView,\r\n                    this.baseWidth,\r\n                    this.baseHeight,\r\n                    this.baseDepth,\r\n                    this.format,\r\n                    this.generateMipMaps,\r\n                    this.invertY,\r\n                    this.samplingMode,\r\n                    this._compression,\r\n                    this.type\r\n                );\r\n                proxy._swapAndDie(this, false);\r\n\r\n                this.isReady = true;\r\n                break;\r\n\r\n            case InternalTextureSource.Dynamic:\r\n                proxy = this._engine.createDynamicTexture(this.baseWidth, this.baseHeight, this.generateMipMaps, this.samplingMode);\r\n                proxy._swapAndDie(this, false);\r\n                this._engine.updateDynamicTexture(this, this._engine.getRenderingCanvas()!, this.invertY, undefined, undefined, true);\r\n\r\n                // The engine will make sure to update content so no need to flag it as isReady = true\r\n                break;\r\n\r\n            case InternalTextureSource.Cube:\r\n                proxy = this._engine.createCubeTexture(\r\n                    this.url,\r\n                    null,\r\n                    this._files,\r\n                    !this.generateMipMaps,\r\n                    () => {\r\n                        proxy._swapAndDie(this, false);\r\n                        this.isReady = true;\r\n                    },\r\n                    null,\r\n                    this.format,\r\n                    this._extension,\r\n                    false,\r\n                    0,\r\n                    0,\r\n                    null,\r\n                    undefined,\r\n                    this._useSRGBBuffer\r\n                );\r\n                return;\r\n\r\n            case InternalTextureSource.CubeRaw:\r\n                proxy = this._engine.createRawCubeTexture(\r\n                    this._bufferViewArray!,\r\n                    this.width,\r\n                    this.format,\r\n                    this.type,\r\n                    this.generateMipMaps,\r\n                    this.invertY,\r\n                    this.samplingMode,\r\n                    this._compression\r\n                );\r\n                proxy._swapAndDie(this, false);\r\n                this.isReady = true;\r\n                break;\r\n\r\n            case InternalTextureSource.CubeRawRGBD:\r\n                // This case is being handeled by the environment texture tools and is not a part of the rebuild process.\r\n                // To use CubeRawRGBD use updateRGBDAsync on the cube texture.\r\n                return;\r\n\r\n            case InternalTextureSource.CubePrefiltered:\r\n                proxy = this._engine.createPrefilteredCubeTexture(\r\n                    this.url,\r\n                    null,\r\n                    this._lodGenerationScale,\r\n                    this._lodGenerationOffset,\r\n                    (proxy) => {\r\n                        if (proxy) {\r\n                            proxy._swapAndDie(this, false);\r\n                        }\r\n                        this.isReady = true;\r\n                    },\r\n                    null,\r\n                    this.format,\r\n                    this._extension\r\n                );\r\n                proxy._sphericalPolynomial = this._sphericalPolynomial;\r\n                return;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _swapAndDie(target: InternalTexture, swapAll = true): void {\r\n        // TODO what about refcount on target?\r\n\r\n        this._hardwareTexture?.setUsage(target._source, this.generateMipMaps, this.isCube, this.width, this.height);\r\n\r\n        target._hardwareTexture = this._hardwareTexture;\r\n        if (swapAll) {\r\n            target._isRGBD = this._isRGBD;\r\n        }\r\n\r\n        if (this._lodTextureHigh) {\r\n            if (target._lodTextureHigh) {\r\n                target._lodTextureHigh.dispose();\r\n            }\r\n            target._lodTextureHigh = this._lodTextureHigh;\r\n        }\r\n\r\n        if (this._lodTextureMid) {\r\n            if (target._lodTextureMid) {\r\n                target._lodTextureMid.dispose();\r\n            }\r\n            target._lodTextureMid = this._lodTextureMid;\r\n        }\r\n\r\n        if (this._lodTextureLow) {\r\n            if (target._lodTextureLow) {\r\n                target._lodTextureLow.dispose();\r\n            }\r\n            target._lodTextureLow = this._lodTextureLow;\r\n        }\r\n\r\n        if (this._irradianceTexture) {\r\n            if (target._irradianceTexture) {\r\n                target._irradianceTexture.dispose();\r\n            }\r\n            target._irradianceTexture = this._irradianceTexture;\r\n        }\r\n\r\n        const cache = this._engine.getLoadedTexturesCache();\r\n        let index = cache.indexOf(this);\r\n        if (index !== -1) {\r\n            cache.splice(index, 1);\r\n        }\r\n\r\n        index = cache.indexOf(target);\r\n        if (index === -1) {\r\n            cache.push(target);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the current allocated resources\r\n     */\r\n    public dispose(): void {\r\n        this._references--;\r\n        this.onLoadedObservable.clear();\r\n        this.onErrorObservable.clear();\r\n        if (this._references === 0) {\r\n            this._engine._releaseTexture(this);\r\n            this._hardwareTexture = null;\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}