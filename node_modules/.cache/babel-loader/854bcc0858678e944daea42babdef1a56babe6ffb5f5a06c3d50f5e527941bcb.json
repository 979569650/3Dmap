{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\n/**\n * Base class for Camera Pointer Inputs.\n * See FollowCameraPointersInput in src/Cameras/Inputs/followCameraPointersInput.ts\n * for example usage.\n */\nexport class BaseCameraPointersInput {\n  constructor() {\n    this._currentActiveButton = -1;\n    /**\n     * Defines the buttons associated with the input to handle camera move.\n     */\n    this.buttons = [0, 1, 2];\n  }\n  /**\n   * Attach the input controls to a specific dom element to get the input from.\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n   */\n  attachControl(noPreventDefault) {\n    // eslint-disable-next-line prefer-rest-params\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    const engine = this.camera.getEngine();\n    const element = engine.getInputElement();\n    let previousPinchSquaredDistance = 0;\n    let previousMultiTouchPanPosition = null;\n    this._pointA = null;\n    this._pointB = null;\n    this._altKey = false;\n    this._ctrlKey = false;\n    this._metaKey = false;\n    this._shiftKey = false;\n    this._buttonsPressed = 0;\n    this._pointerInput = p => {\n      var _a, _b;\n      const evt = p.event;\n      const isTouch = evt.pointerType === \"touch\";\n      if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\n        return;\n      }\n      const srcElement = evt.target;\n      this._altKey = evt.altKey;\n      this._ctrlKey = evt.ctrlKey;\n      this._metaKey = evt.metaKey;\n      this._shiftKey = evt.shiftKey;\n      this._buttonsPressed = evt.buttons;\n      if (engine.isPointerLock) {\n        const offsetX = evt.movementX;\n        const offsetY = evt.movementY;\n        this.onTouch(null, offsetX, offsetY);\n        this._pointA = null;\n        this._pointB = null;\n      } else if (p.type !== PointerEventTypes.POINTERDOWN && isTouch && ((_a = this._pointA) === null || _a === void 0 ? void 0 : _a.pointerId) !== evt.pointerId && ((_b = this._pointB) === null || _b === void 0 ? void 0 : _b.pointerId) !== evt.pointerId) {\n        return; // If we get a non-down event for a touch that we're not tracking, ignore it\n      } else if (p.type === PointerEventTypes.POINTERDOWN && (this._currentActiveButton === -1 || isTouch)) {\n        try {\n          srcElement === null || srcElement === void 0 ? void 0 : srcElement.setPointerCapture(evt.pointerId);\n        } catch (e) {\n          //Nothing to do with the error. Execution will continue.\n        }\n        if (this._pointA === null) {\n          this._pointA = {\n            x: evt.clientX,\n            y: evt.clientY,\n            pointerId: evt.pointerId,\n            type: evt.pointerType\n          };\n        } else if (this._pointB === null) {\n          this._pointB = {\n            x: evt.clientX,\n            y: evt.clientY,\n            pointerId: evt.pointerId,\n            type: evt.pointerType\n          };\n        } else {\n          return; // We are already tracking two pointers so ignore this one\n        }\n\n        if (this._currentActiveButton === -1 && !isTouch) {\n          this._currentActiveButton = evt.button;\n        }\n        this.onButtonDown(evt);\n        if (!noPreventDefault) {\n          evt.preventDefault();\n          element && element.focus();\n        }\n      } else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {\n        this.onDoubleTap(evt.pointerType);\n      } else if (p.type === PointerEventTypes.POINTERUP && (this._currentActiveButton === evt.button || isTouch)) {\n        try {\n          srcElement === null || srcElement === void 0 ? void 0 : srcElement.releasePointerCapture(evt.pointerId);\n        } catch (e) {\n          //Nothing to do with the error.\n        }\n        if (!isTouch) {\n          this._pointB = null; // Mouse and pen are mono pointer\n        }\n        //would be better to use pointers.remove(evt.pointerId) for multitouch gestures,\n        //but emptying completely pointers collection is required to fix a bug on iPhone :\n        //when changing orientation while pinching camera,\n        //one pointer stay pressed forever if we don't release all pointers\n        //will be ok to put back pointers.remove(evt.pointerId); when iPhone bug corrected\n        if (engine._badOS) {\n          this._pointA = this._pointB = null;\n        } else {\n          //only remove the impacted pointer in case of multitouch allowing on most\n          //platforms switching from rotate to zoom and pan seamlessly.\n          if (this._pointB && this._pointA && this._pointA.pointerId == evt.pointerId) {\n            this._pointA = this._pointB;\n            this._pointB = null;\n          } else if (this._pointA && this._pointB && this._pointB.pointerId == evt.pointerId) {\n            this._pointB = null;\n          } else {\n            this._pointA = this._pointB = null;\n          }\n        }\n        if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {\n          // Previous pinch data is populated but a button has been lifted\n          // so pinch has ended.\n          this.onMultiTouch(this._pointA, this._pointB, previousPinchSquaredDistance, 0,\n          // pinchSquaredDistance\n          previousMultiTouchPanPosition, null // multiTouchPanPosition\n          );\n\n          previousPinchSquaredDistance = 0;\n          previousMultiTouchPanPosition = null;\n        }\n        this._currentActiveButton = -1;\n        this.onButtonUp(evt);\n        if (!noPreventDefault) {\n          evt.preventDefault();\n        }\n      } else if (p.type === PointerEventTypes.POINTERMOVE) {\n        if (!noPreventDefault) {\n          evt.preventDefault();\n        }\n        // One button down\n        if (this._pointA && this._pointB === null) {\n          const offsetX = evt.clientX - this._pointA.x;\n          const offsetY = evt.clientY - this._pointA.y;\n          this.onTouch(this._pointA, offsetX, offsetY);\n          this._pointA.x = evt.clientX;\n          this._pointA.y = evt.clientY;\n        }\n        // Two buttons down: pinch\n        else if (this._pointA && this._pointB) {\n          const ed = this._pointA.pointerId === evt.pointerId ? this._pointA : this._pointB;\n          ed.x = evt.clientX;\n          ed.y = evt.clientY;\n          const distX = this._pointA.x - this._pointB.x;\n          const distY = this._pointA.y - this._pointB.y;\n          const pinchSquaredDistance = distX * distX + distY * distY;\n          const multiTouchPanPosition = {\n            x: (this._pointA.x + this._pointB.x) / 2,\n            y: (this._pointA.y + this._pointB.y) / 2,\n            pointerId: evt.pointerId,\n            type: p.type\n          };\n          this.onMultiTouch(this._pointA, this._pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);\n          previousMultiTouchPanPosition = multiTouchPanPosition;\n          previousPinchSquaredDistance = pinchSquaredDistance;\n        }\n      }\n    };\n    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE | PointerEventTypes.POINTERDOUBLETAP);\n    this._onLostFocus = () => {\n      this._pointA = this._pointB = null;\n      previousPinchSquaredDistance = 0;\n      previousMultiTouchPanPosition = null;\n      this.onLostFocus();\n    };\n    this._contextMenuBind = evt => this.onContextMenu(evt);\n    element && element.addEventListener(\"contextmenu\", this._contextMenuBind, false);\n    const hostWindow = this.camera.getScene().getEngine().getHostWindow();\n    if (hostWindow) {\n      Tools.RegisterTopRootEvents(hostWindow, [{\n        name: \"blur\",\n        handler: this._onLostFocus\n      }]);\n    }\n  }\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n  detachControl() {\n    if (this._onLostFocus) {\n      const hostWindow = this.camera.getScene().getEngine().getHostWindow();\n      if (hostWindow) {\n        Tools.UnregisterTopRootEvents(hostWindow, [{\n          name: \"blur\",\n          handler: this._onLostFocus\n        }]);\n      }\n    }\n    if (this._observer) {\n      this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\n      this._observer = null;\n      if (this._contextMenuBind) {\n        const inputElement = this.camera.getScene().getEngine().getInputElement();\n        inputElement && inputElement.removeEventListener(\"contextmenu\", this._contextMenuBind);\n      }\n      this._onLostFocus = null;\n    }\n    this._altKey = false;\n    this._ctrlKey = false;\n    this._metaKey = false;\n    this._shiftKey = false;\n    this._buttonsPressed = 0;\n    this._currentActiveButton = -1;\n  }\n  /**\n   * Gets the class name of the current input.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"BaseCameraPointersInput\";\n  }\n  /**\n   * Get the friendly name associated with the input class.\n   * @returns the input friendly name\n   */\n  getSimpleName() {\n    return \"pointers\";\n  }\n  /**\n   * Called on pointer POINTERDOUBLETAP event.\n   * Override this method to provide functionality on POINTERDOUBLETAP event.\n   * @param type\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onDoubleTap(type) {}\n  /**\n   * Called on pointer POINTERMOVE event if only a single touch is active.\n   * Override this method to provide functionality.\n   * @param point\n   * @param offsetX\n   * @param offsetY\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onTouch(point, offsetX, offsetY) {}\n  /**\n   * Called on pointer POINTERMOVE event if multiple touches are active.\n   * Override this method to provide functionality.\n   * @param _pointA\n   * @param _pointB\n   * @param previousPinchSquaredDistance\n   * @param pinchSquaredDistance\n   * @param previousMultiTouchPanPosition\n   * @param multiTouchPanPosition\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onMultiTouch(_pointA, _pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {}\n  /**\n   * Called on JS contextmenu event.\n   * Override this method to provide functionality.\n   * @param evt\n   */\n  onContextMenu(evt) {\n    evt.preventDefault();\n  }\n  /**\n   * Called each time a new POINTERDOWN event occurs. Ie, for each button\n   * press.\n   * Override this method to provide functionality.\n   * @param _evt Defines the event to track\n   */\n  onButtonDown(_evt) {}\n  /**\n   * Called each time a new POINTERUP event occurs. Ie, for each button\n   * release.\n   * Override this method to provide functionality.\n   * @param _evt Defines the event to track\n   */\n  onButtonUp(_evt) {}\n  /**\n   * Called when window becomes inactive.\n   * Override this method to provide functionality.\n   */\n  onLostFocus() {}\n}\n__decorate([serialize()], BaseCameraPointersInput.prototype, \"buttons\", void 0);","map":{"version":3,"names":["serialize","Tools","PointerEventTypes","BaseCameraPointersInput","constructor","_currentActiveButton","buttons","attachControl","noPreventDefault","BackCompatCameraNoPreventDefault","arguments","engine","camera","getEngine","element","getInputElement","previousPinchSquaredDistance","previousMultiTouchPanPosition","_pointA","_pointB","_altKey","_ctrlKey","_metaKey","_shiftKey","_buttonsPressed","_pointerInput","p","evt","event","isTouch","pointerType","type","POINTERMOVE","indexOf","button","srcElement","target","altKey","ctrlKey","metaKey","shiftKey","isPointerLock","offsetX","movementX","offsetY","movementY","onTouch","POINTERDOWN","_a","pointerId","_b","setPointerCapture","e","x","clientX","y","clientY","onButtonDown","preventDefault","focus","POINTERDOUBLETAP","onDoubleTap","POINTERUP","releasePointerCapture","_badOS","onMultiTouch","onButtonUp","ed","distX","distY","pinchSquaredDistance","multiTouchPanPosition","_observer","getScene","_inputManager","_addCameraPointerObserver","_onLostFocus","onLostFocus","_contextMenuBind","onContextMenu","addEventListener","hostWindow","getHostWindow","RegisterTopRootEvents","name","handler","detachControl","UnregisterTopRootEvents","_removeCameraPointerObserver","inputElement","removeEventListener","getClassName","getSimpleName","point","_evt","__decorate"],"sources":["../../../../../dev/core/src/Cameras/Inputs/BaseCameraPointersInput.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo, PointerTouch } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Base class for Camera Pointer Inputs.\r\n * See FollowCameraPointersInput in src/Cameras/Inputs/followCameraPointersInput.ts\r\n * for example usage.\r\n */\r\nexport abstract class BaseCameraPointersInput implements ICameraInput<Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public abstract camera: Camera;\r\n\r\n    /**\r\n     * Whether keyboard modifier keys are pressed at time of last mouse event.\r\n     */\r\n    protected _altKey: boolean;\r\n    protected _ctrlKey: boolean;\r\n    protected _metaKey: boolean;\r\n    protected _shiftKey: boolean;\r\n\r\n    /**\r\n     * Which mouse buttons were pressed at time of last mouse event.\r\n     * https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\r\n     */\r\n    protected _buttonsPressed: number;\r\n\r\n    private _currentActiveButton: number = -1;\r\n    private _contextMenuBind: EventListener;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        const engine = this.camera.getEngine();\r\n        const element = engine.getInputElement();\r\n        let previousPinchSquaredDistance = 0;\r\n        let previousMultiTouchPanPosition: Nullable<PointerTouch> = null;\r\n\r\n        this._pointA = null;\r\n        this._pointB = null;\r\n\r\n        this._altKey = false;\r\n        this._ctrlKey = false;\r\n        this._metaKey = false;\r\n        this._shiftKey = false;\r\n        this._buttonsPressed = 0;\r\n\r\n        this._pointerInput = (p) => {\r\n            const evt = <IPointerEvent>p.event;\r\n            const isTouch = evt.pointerType === \"touch\";\r\n\r\n            if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\r\n                return;\r\n            }\r\n\r\n            const srcElement = <HTMLElement>evt.target;\r\n\r\n            this._altKey = evt.altKey;\r\n            this._ctrlKey = evt.ctrlKey;\r\n            this._metaKey = evt.metaKey;\r\n            this._shiftKey = evt.shiftKey;\r\n            this._buttonsPressed = evt.buttons;\r\n\r\n            if (engine.isPointerLock) {\r\n                const offsetX = evt.movementX;\r\n                const offsetY = evt.movementY;\r\n\r\n                this.onTouch(null, offsetX, offsetY);\r\n                this._pointA = null;\r\n                this._pointB = null;\r\n            } else if (p.type !== PointerEventTypes.POINTERDOWN && isTouch && this._pointA?.pointerId !== evt.pointerId && this._pointB?.pointerId !== evt.pointerId) {\r\n                return; // If we get a non-down event for a touch that we're not tracking, ignore it\r\n            } else if (p.type === PointerEventTypes.POINTERDOWN && (this._currentActiveButton === -1 || isTouch)) {\r\n                try {\r\n                    srcElement?.setPointerCapture(evt.pointerId);\r\n                } catch (e) {\r\n                    //Nothing to do with the error. Execution will continue.\r\n                }\r\n\r\n                if (this._pointA === null) {\r\n                    this._pointA = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                        pointerId: evt.pointerId,\r\n                        type: evt.pointerType,\r\n                    };\r\n                } else if (this._pointB === null) {\r\n                    this._pointB = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                        pointerId: evt.pointerId,\r\n                        type: evt.pointerType,\r\n                    };\r\n                } else {\r\n                    return; // We are already tracking two pointers so ignore this one\r\n                }\r\n\r\n                if (this._currentActiveButton === -1 && !isTouch) {\r\n                    this._currentActiveButton = evt.button;\r\n                }\r\n                this.onButtonDown(evt);\r\n\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                    element && element.focus();\r\n                }\r\n            } else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {\r\n                this.onDoubleTap(evt.pointerType);\r\n            } else if (p.type === PointerEventTypes.POINTERUP && (this._currentActiveButton === evt.button || isTouch)) {\r\n                try {\r\n                    srcElement?.releasePointerCapture(evt.pointerId);\r\n                } catch (e) {\r\n                    //Nothing to do with the error.\r\n                }\r\n\r\n                if (!isTouch) {\r\n                    this._pointB = null; // Mouse and pen are mono pointer\r\n                }\r\n\r\n                //would be better to use pointers.remove(evt.pointerId) for multitouch gestures,\r\n                //but emptying completely pointers collection is required to fix a bug on iPhone :\r\n                //when changing orientation while pinching camera,\r\n                //one pointer stay pressed forever if we don't release all pointers\r\n                //will be ok to put back pointers.remove(evt.pointerId); when iPhone bug corrected\r\n                if (engine._badOS) {\r\n                    this._pointA = this._pointB = null;\r\n                } else {\r\n                    //only remove the impacted pointer in case of multitouch allowing on most\r\n                    //platforms switching from rotate to zoom and pan seamlessly.\r\n                    if (this._pointB && this._pointA && this._pointA.pointerId == evt.pointerId) {\r\n                        this._pointA = this._pointB;\r\n                        this._pointB = null;\r\n                    } else if (this._pointA && this._pointB && this._pointB.pointerId == evt.pointerId) {\r\n                        this._pointB = null;\r\n                    } else {\r\n                        this._pointA = this._pointB = null;\r\n                    }\r\n                }\r\n\r\n                if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {\r\n                    // Previous pinch data is populated but a button has been lifted\r\n                    // so pinch has ended.\r\n                    this.onMultiTouch(\r\n                        this._pointA,\r\n                        this._pointB,\r\n                        previousPinchSquaredDistance,\r\n                        0, // pinchSquaredDistance\r\n                        previousMultiTouchPanPosition,\r\n                        null // multiTouchPanPosition\r\n                    );\r\n                    previousPinchSquaredDistance = 0;\r\n                    previousMultiTouchPanPosition = null;\r\n                }\r\n\r\n                this._currentActiveButton = -1;\r\n                this.onButtonUp(evt);\r\n\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                }\r\n            } else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                }\r\n\r\n                // One button down\r\n                if (this._pointA && this._pointB === null) {\r\n                    const offsetX = evt.clientX - this._pointA.x;\r\n                    const offsetY = evt.clientY - this._pointA.y;\r\n                    this.onTouch(this._pointA, offsetX, offsetY);\r\n\r\n                    this._pointA.x = evt.clientX;\r\n                    this._pointA.y = evt.clientY;\r\n                }\r\n                // Two buttons down: pinch\r\n                else if (this._pointA && this._pointB) {\r\n                    const ed = this._pointA.pointerId === evt.pointerId ? this._pointA : this._pointB;\r\n                    ed.x = evt.clientX;\r\n                    ed.y = evt.clientY;\r\n                    const distX = this._pointA.x - this._pointB.x;\r\n                    const distY = this._pointA.y - this._pointB.y;\r\n                    const pinchSquaredDistance = distX * distX + distY * distY;\r\n                    const multiTouchPanPosition = {\r\n                        x: (this._pointA.x + this._pointB.x) / 2,\r\n                        y: (this._pointA.y + this._pointB.y) / 2,\r\n                        pointerId: evt.pointerId,\r\n                        type: p.type,\r\n                    };\r\n\r\n                    this.onMultiTouch(this._pointA, this._pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n                    previousMultiTouchPanPosition = multiTouchPanPosition;\r\n                    previousPinchSquaredDistance = pinchSquaredDistance;\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(\r\n                this._pointerInput,\r\n                PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE | PointerEventTypes.POINTERDOUBLETAP\r\n            );\r\n\r\n        this._onLostFocus = () => {\r\n            this._pointA = this._pointB = null;\r\n            previousPinchSquaredDistance = 0;\r\n            previousMultiTouchPanPosition = null;\r\n            this.onLostFocus();\r\n        };\r\n\r\n        this._contextMenuBind = (evt: Event) => this.onContextMenu(evt as PointerEvent);\r\n\r\n        element && element.addEventListener(\"contextmenu\", this._contextMenuBind, false);\r\n\r\n        const hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n\r\n        if (hostWindow) {\r\n            Tools.RegisterTopRootEvents(hostWindow, [{ name: \"blur\", handler: this._onLostFocus }]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._onLostFocus) {\r\n            const hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n            if (hostWindow) {\r\n                Tools.UnregisterTopRootEvents(hostWindow, [{ name: \"blur\", handler: this._onLostFocus }]);\r\n            }\r\n        }\r\n\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n\r\n            if (this._contextMenuBind) {\r\n                const inputElement = this.camera.getScene().getEngine().getInputElement();\r\n                inputElement && inputElement.removeEventListener(\"contextmenu\", this._contextMenuBind);\r\n            }\r\n\r\n            this._onLostFocus = null;\r\n        }\r\n\r\n        this._altKey = false;\r\n        this._ctrlKey = false;\r\n        this._metaKey = false;\r\n        this._shiftKey = false;\r\n        this._buttonsPressed = 0;\r\n        this._currentActiveButton = -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"pointers\";\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERDOUBLETAP event.\r\n     * Override this method to provide functionality on POINTERDOUBLETAP event.\r\n     * @param type\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onDoubleTap(type: string) {}\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if only a single touch is active.\r\n     * Override this method to provide functionality.\r\n     * @param point\r\n     * @param offsetX\r\n     * @param offsetY\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {}\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     * Override this method to provide functionality.\r\n     * @param _pointA\r\n     * @param _pointB\r\n     * @param previousPinchSquaredDistance\r\n     * @param pinchSquaredDistance\r\n     * @param previousMultiTouchPanPosition\r\n     * @param multiTouchPanPosition\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onMultiTouch(\r\n        _pointA: Nullable<PointerTouch>,\r\n        _pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {}\r\n\r\n    /**\r\n     * Called on JS contextmenu event.\r\n     * Override this method to provide functionality.\r\n     * @param evt\r\n     */\r\n    public onContextMenu(evt: PointerEvent): void {\r\n        evt.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n     * press.\r\n     * Override this method to provide functionality.\r\n     * @param _evt Defines the event to track\r\n     */\r\n    public onButtonDown(_evt: IPointerEvent): void {}\r\n\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     * Override this method to provide functionality.\r\n     * @param _evt Defines the event to track\r\n     */\r\n    public onButtonUp(_evt: IPointerEvent): void {}\r\n\r\n    /**\r\n     * Called when window becomes inactive.\r\n     * Override this method to provide functionality.\r\n     */\r\n    public onLostFocus(): void {}\r\n\r\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\r\n    private _pointA: Nullable<PointerTouch>;\r\n    private _pointB: Nullable<PointerTouch>;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}