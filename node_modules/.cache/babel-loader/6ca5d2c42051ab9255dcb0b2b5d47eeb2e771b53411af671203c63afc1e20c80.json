{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\n/** @internal */\nexport class ShaderDefineExpression {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  isTrue(preprocessors) {\n    return true;\n  }\n  static postfixToInfix(postfix) {\n    const stack = [];\n    for (const c of postfix) {\n      if (ShaderDefineExpression._OperatorPriority[c] === undefined) {\n        stack.push(c);\n      } else {\n        const v1 = stack[stack.length - 1],\n          v2 = stack[stack.length - 2];\n        stack.length -= 2;\n        stack.push(`(${v2}${c}${v1})`);\n      }\n    }\n    return stack[stack.length - 1];\n  }\n  /**\n   * Converts an infix expression to a postfix expression.\n   *\n   * This method is used to transform infix expressions, which are more human-readable,\n   * into postfix expressions, also known as Reverse Polish Notation (RPN), that can be\n   * evaluated more efficiently by a computer. The conversion is based on the operator\n   * priority defined in _OperatorPriority.\n   *\n   * The function employs a stack-based algorithm for the conversion and caches the result\n   * to improve performance. The cache keeps track of each converted expression's access time\n   * to manage the cache size and optimize memory usage. When the cache size exceeds a specified\n   * limit, the least recently accessed items in the cache are deleted.\n   *\n   * The cache mechanism is particularly helpful for shader compilation, where the same infix\n   * expressions might be encountered repeatedly, hence the caching can speed up the process.\n   *\n   * @param infix - The infix expression to be converted.\n   * @returns The postfix expression as an array of strings.\n   */\n  static infixToPostfix(infix) {\n    // Is infix already in cache\n    const cacheItem = ShaderDefineExpression._InfixToPostfixCache.get(infix);\n    if (cacheItem) {\n      cacheItem.accessTime = Date.now();\n      return cacheItem.result;\n    }\n    // Is infix contain any operator\n    if (!infix.includes(\"&&\") && !infix.includes(\"||\") && !infix.includes(\")\") && !infix.includes(\"(\")) {\n      return [infix];\n    }\n    const result = [];\n    let stackIdx = -1;\n    const pushOperand = () => {\n      operand = operand.trim();\n      if (operand !== \"\") {\n        result.push(operand);\n        operand = \"\";\n      }\n    };\n    const push = s => {\n      if (stackIdx < ShaderDefineExpression._Stack.length - 1) {\n        ShaderDefineExpression._Stack[++stackIdx] = s;\n      }\n    };\n    const peek = () => ShaderDefineExpression._Stack[stackIdx];\n    const pop = () => stackIdx === -1 ? \"!!INVALID EXPRESSION!!\" : ShaderDefineExpression._Stack[stackIdx--];\n    let idx = 0,\n      operand = \"\";\n    while (idx < infix.length) {\n      const c = infix.charAt(idx),\n        token = idx < infix.length - 1 ? infix.substr(idx, 2) : \"\";\n      if (c === \"(\") {\n        operand = \"\";\n        push(c);\n      } else if (c === \")\") {\n        pushOperand();\n        while (stackIdx !== -1 && peek() !== \"(\") {\n          result.push(pop());\n        }\n        pop();\n      } else if (ShaderDefineExpression._OperatorPriority[token] > 1) {\n        pushOperand();\n        while (stackIdx !== -1 && ShaderDefineExpression._OperatorPriority[peek()] >= ShaderDefineExpression._OperatorPriority[token]) {\n          result.push(pop());\n        }\n        push(token);\n        idx++;\n      } else {\n        operand += c;\n      }\n      idx++;\n    }\n    pushOperand();\n    while (stackIdx !== -1) {\n      if (peek() === \"(\") {\n        pop();\n      } else {\n        result.push(pop());\n      }\n    }\n    // If the cache is at capacity, clear it before adding a new item\n    if (ShaderDefineExpression._InfixToPostfixCache.size >= ShaderDefineExpression.InfixToPostfixCacheLimitSize) {\n      ShaderDefineExpression.ClearCache();\n    }\n    // Add the new item to the cache, including the current time as the last access time\n    ShaderDefineExpression._InfixToPostfixCache.set(infix, {\n      result,\n      accessTime: Date.now()\n    });\n    return result;\n  }\n  static ClearCache() {\n    // Convert the cache to an array and sort by last access time\n    const sortedCache = Array.from(ShaderDefineExpression._InfixToPostfixCache.entries()).sort((a, b) => a[1].accessTime - b[1].accessTime);\n    // Remove the least recently accessed half of the cache\n    for (let i = 0; i < ShaderDefineExpression.InfixToPostfixCacheCleanupSize; i++) {\n      ShaderDefineExpression._InfixToPostfixCache.delete(sortedCache[i][0]);\n    }\n  }\n}\n/**\n * Cache items count limit for the InfixToPostfix cache.\n * It uses to improve the performance of the shader compilation.\n * For details see PR: https://github.com/BabylonJS/Babylon.js/pull/13936\n */\nShaderDefineExpression.InfixToPostfixCacheLimitSize = 50000;\n/**\n * When the cache size is exceeded, a cache cleanup will be triggered\n * and the cache will be reduced by the size specified\n * in the InfixToPostfixCacheCleanupSize variable, removing entries\n * that have not been accessed the longest.\n */\nShaderDefineExpression.InfixToPostfixCacheCleanupSize = 25000;\nShaderDefineExpression._InfixToPostfixCache = new Map();\nShaderDefineExpression._OperatorPriority = {\n  \")\": 0,\n  \"(\": 1,\n  \"||\": 2,\n  \"&&\": 3\n};\nShaderDefineExpression._Stack = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"];","map":{"version":3,"names":["ShaderDefineExpression","isTrue","preprocessors","postfixToInfix","postfix","stack","c","_OperatorPriority","undefined","push","v1","length","v2","infixToPostfix","infix","cacheItem","_InfixToPostfixCache","get","accessTime","Date","now","result","includes","stackIdx","pushOperand","operand","trim","s","_Stack","peek","pop","idx","charAt","token","substr","size","InfixToPostfixCacheLimitSize","ClearCache","set","sortedCache","Array","from","entries","sort","a","b","i","InfixToPostfixCacheCleanupSize","delete","Map"],"sources":["../../../../../../dev/core/src/Engines/Processors/Expressions/shaderDefineExpression.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\n/** @internal */\r\nexport class ShaderDefineExpression {\r\n    /**\r\n     * Cache items count limit for the InfixToPostfix cache.\r\n     * It uses to improve the performance of the shader compilation.\r\n     * For details see PR: https://github.com/BabylonJS/Babylon.js/pull/13936\r\n     */\r\n    static InfixToPostfixCacheLimitSize = 50000;\r\n\r\n    /**\r\n     * When the cache size is exceeded, a cache cleanup will be triggered\r\n     * and the cache will be reduced by the size specified\r\n     * in the InfixToPostfixCacheCleanupSize variable, removing entries\r\n     * that have not been accessed the longest.\r\n     */\r\n    static InfixToPostfixCacheCleanupSize = 25000;\r\n\r\n    protected static _InfixToPostfixCache: Map<\r\n        string,\r\n        {\r\n            accessTime: number;\r\n            result: string[];\r\n        }\r\n    > = new Map();\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isTrue(preprocessors: { [key: string]: string }): boolean {\r\n        return true;\r\n    }\r\n\r\n    private static _OperatorPriority: { [name: string]: number } = {\r\n        \")\": 0,\r\n        \"(\": 1,\r\n        \"||\": 2,\r\n        \"&&\": 3,\r\n    };\r\n\r\n    private static _Stack = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"];\r\n\r\n    public static postfixToInfix(postfix: string[]): string {\r\n        const stack: string[] = [];\r\n\r\n        for (const c of postfix) {\r\n            if (ShaderDefineExpression._OperatorPriority[c] === undefined) {\r\n                stack.push(c);\r\n            } else {\r\n                const v1 = stack[stack.length - 1],\r\n                    v2 = stack[stack.length - 2];\r\n\r\n                stack.length -= 2;\r\n                stack.push(`(${v2}${c}${v1})`);\r\n            }\r\n        }\r\n\r\n        return stack[stack.length - 1];\r\n    }\r\n\r\n    /**\r\n     * Converts an infix expression to a postfix expression.\r\n     *\r\n     * This method is used to transform infix expressions, which are more human-readable,\r\n     * into postfix expressions, also known as Reverse Polish Notation (RPN), that can be\r\n     * evaluated more efficiently by a computer. The conversion is based on the operator\r\n     * priority defined in _OperatorPriority.\r\n     *\r\n     * The function employs a stack-based algorithm for the conversion and caches the result\r\n     * to improve performance. The cache keeps track of each converted expression's access time\r\n     * to manage the cache size and optimize memory usage. When the cache size exceeds a specified\r\n     * limit, the least recently accessed items in the cache are deleted.\r\n     *\r\n     * The cache mechanism is particularly helpful for shader compilation, where the same infix\r\n     * expressions might be encountered repeatedly, hence the caching can speed up the process.\r\n     *\r\n     * @param infix - The infix expression to be converted.\r\n     * @returns The postfix expression as an array of strings.\r\n     */\r\n    public static infixToPostfix(infix: string): string[] {\r\n        // Is infix already in cache\r\n        const cacheItem = ShaderDefineExpression._InfixToPostfixCache.get(infix);\r\n        if (cacheItem) {\r\n            cacheItem.accessTime = Date.now();\r\n            return cacheItem.result;\r\n        }\r\n\r\n        // Is infix contain any operator\r\n        if (!infix.includes(\"&&\") && !infix.includes(\"||\") && !infix.includes(\")\") && !infix.includes(\"(\")) {\r\n            return [infix];\r\n        }\r\n\r\n        const result: string[] = [];\r\n\r\n        let stackIdx = -1;\r\n\r\n        const pushOperand = () => {\r\n            operand = operand.trim();\r\n            if (operand !== \"\") {\r\n                result.push(operand);\r\n                operand = \"\";\r\n            }\r\n        };\r\n\r\n        const push = (s: string) => {\r\n            if (stackIdx < ShaderDefineExpression._Stack.length - 1) {\r\n                ShaderDefineExpression._Stack[++stackIdx] = s;\r\n            }\r\n        };\r\n\r\n        const peek = () => ShaderDefineExpression._Stack[stackIdx];\r\n\r\n        const pop = () => (stackIdx === -1 ? \"!!INVALID EXPRESSION!!\" : ShaderDefineExpression._Stack[stackIdx--]);\r\n\r\n        let idx = 0,\r\n            operand = \"\";\r\n\r\n        while (idx < infix.length) {\r\n            const c = infix.charAt(idx),\r\n                token = idx < infix.length - 1 ? infix.substr(idx, 2) : \"\";\r\n\r\n            if (c === \"(\") {\r\n                operand = \"\";\r\n                push(c);\r\n            } else if (c === \")\") {\r\n                pushOperand();\r\n                while (stackIdx !== -1 && peek() !== \"(\") {\r\n                    result.push(pop());\r\n                }\r\n                pop();\r\n            } else if (ShaderDefineExpression._OperatorPriority[token] > 1) {\r\n                pushOperand();\r\n                while (stackIdx !== -1 && ShaderDefineExpression._OperatorPriority[peek()] >= ShaderDefineExpression._OperatorPriority[token]) {\r\n                    result.push(pop());\r\n                }\r\n                push(token);\r\n                idx++;\r\n            } else {\r\n                operand += c;\r\n            }\r\n            idx++;\r\n        }\r\n\r\n        pushOperand();\r\n\r\n        while (stackIdx !== -1) {\r\n            if (peek() === \"(\") {\r\n                pop();\r\n            } else {\r\n                result.push(pop());\r\n            }\r\n        }\r\n\r\n        // If the cache is at capacity, clear it before adding a new item\r\n        if (ShaderDefineExpression._InfixToPostfixCache.size >= ShaderDefineExpression.InfixToPostfixCacheLimitSize) {\r\n            ShaderDefineExpression.ClearCache();\r\n        }\r\n\r\n        // Add the new item to the cache, including the current time as the last access time\r\n        ShaderDefineExpression._InfixToPostfixCache.set(infix, { result, accessTime: Date.now() });\r\n\r\n        return result;\r\n    }\r\n\r\n    private static ClearCache(): void {\r\n        // Convert the cache to an array and sort by last access time\r\n        const sortedCache = Array.from(ShaderDefineExpression._InfixToPostfixCache.entries()).sort((a, b) => a[1].accessTime - b[1].accessTime);\r\n\r\n        // Remove the least recently accessed half of the cache\r\n        for (let i = 0; i < ShaderDefineExpression.InfixToPostfixCacheCleanupSize; i++) {\r\n            ShaderDefineExpression._InfixToPostfixCache.delete(sortedCache[i][0]);\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}