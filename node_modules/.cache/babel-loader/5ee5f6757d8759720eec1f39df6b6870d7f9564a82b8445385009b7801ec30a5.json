{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { SmartArray, SmartArrayNoDuplicate } from \"../Misc/smartArray.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\n\n/**\n * This represents the object necessary to create a rendering group.\n * This is exclusively used and created by the rendering manager.\n * To modify the behavior, you use the available helpers in your scene or meshes.\n * @internal\n */\nexport class RenderingGroup {\n  /**\n   * Set the opaque sort comparison function.\n   * If null the sub meshes will be render in the order they were created\n   */\n  set opaqueSortCompareFn(value) {\n    if (value) {\n      this._opaqueSortCompareFn = value;\n    } else {\n      this._opaqueSortCompareFn = RenderingGroup.PainterSortCompare;\n    }\n    this._renderOpaque = this._renderOpaqueSorted;\n  }\n  /**\n   * Set the alpha test sort comparison function.\n   * If null the sub meshes will be render in the order they were created\n   */\n  set alphaTestSortCompareFn(value) {\n    if (value) {\n      this._alphaTestSortCompareFn = value;\n    } else {\n      this._alphaTestSortCompareFn = RenderingGroup.PainterSortCompare;\n    }\n    this._renderAlphaTest = this._renderAlphaTestSorted;\n  }\n  /**\n   * Set the transparent sort comparison function.\n   * If null the sub meshes will be render in the order they were created\n   */\n  set transparentSortCompareFn(value) {\n    if (value) {\n      this._transparentSortCompareFn = value;\n    } else {\n      this._transparentSortCompareFn = RenderingGroup.defaultTransparentSortCompare;\n    }\n    this._renderTransparent = this._renderTransparentSorted;\n  }\n  /**\n   * Creates a new rendering group.\n   * @param index The rendering group index\n   * @param scene\n   * @param opaqueSortCompareFn The opaque sort comparison function. If null no order is applied\n   * @param alphaTestSortCompareFn The alpha test sort comparison function. If null no order is applied\n   * @param transparentSortCompareFn The transparent sort comparison function. If null back to front + alpha index sort is applied\n   */\n  constructor(index, scene, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {\n    this.index = index;\n    this._opaqueSubMeshes = new SmartArray(256);\n    this._transparentSubMeshes = new SmartArray(256);\n    this._alphaTestSubMeshes = new SmartArray(256);\n    this._depthOnlySubMeshes = new SmartArray(256);\n    this._particleSystems = new SmartArray(256);\n    this._spriteManagers = new SmartArray(256);\n    /** @internal */\n    this._empty = true;\n    /** @internal */\n    this._edgesRenderers = new SmartArrayNoDuplicate(16);\n    this._scene = scene;\n    this.opaqueSortCompareFn = opaqueSortCompareFn;\n    this.alphaTestSortCompareFn = alphaTestSortCompareFn;\n    this.transparentSortCompareFn = transparentSortCompareFn;\n  }\n  /**\n   * Render all the sub meshes contained in the group.\n   * @param customRenderFunction Used to override the default render behaviour of the group.\n   * @param renderSprites\n   * @param renderParticles\n   * @param activeMeshes\n   * @returns true if rendered some submeshes.\n   */\n  render(customRenderFunction, renderSprites, renderParticles, activeMeshes) {\n    if (customRenderFunction) {\n      customRenderFunction(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);\n      return;\n    }\n    const engine = this._scene.getEngine();\n    // Depth only\n    if (this._depthOnlySubMeshes.length !== 0) {\n      engine.setColorWrite(false);\n      this._renderAlphaTest(this._depthOnlySubMeshes);\n      engine.setColorWrite(true);\n    }\n    // Opaque\n    if (this._opaqueSubMeshes.length !== 0) {\n      this._renderOpaque(this._opaqueSubMeshes);\n    }\n    // Alpha test\n    if (this._alphaTestSubMeshes.length !== 0) {\n      this._renderAlphaTest(this._alphaTestSubMeshes);\n    }\n    const stencilState = engine.getStencilBuffer();\n    engine.setStencilBuffer(false);\n    // Sprites\n    if (renderSprites) {\n      this._renderSprites();\n    }\n    // Particles\n    if (renderParticles) {\n      this._renderParticles(activeMeshes);\n    }\n    if (this.onBeforeTransparentRendering) {\n      this.onBeforeTransparentRendering();\n    }\n    // Transparent\n    if (this._transparentSubMeshes.length !== 0 || this._scene.useOrderIndependentTransparency) {\n      engine.setStencilBuffer(stencilState);\n      if (this._scene.useOrderIndependentTransparency) {\n        const excludedMeshes = this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);\n        if (excludedMeshes.length) {\n          // Render leftover meshes that could not be processed by depth peeling\n          this._renderTransparent(excludedMeshes);\n        }\n      } else {\n        this._renderTransparent(this._transparentSubMeshes);\n      }\n      engine.setAlphaMode(0);\n    }\n    // Set back stencil to false in case it changes before the edge renderer.\n    engine.setStencilBuffer(false);\n    // Edges\n    if (this._edgesRenderers.length) {\n      for (let edgesRendererIndex = 0; edgesRendererIndex < this._edgesRenderers.length; edgesRendererIndex++) {\n        this._edgesRenderers.data[edgesRendererIndex].render();\n      }\n      engine.setAlphaMode(0);\n    }\n    // Restore Stencil state.\n    engine.setStencilBuffer(stencilState);\n  }\n  /**\n   * Renders the opaque submeshes in the order from the opaqueSortCompareFn.\n   * @param subMeshes The submeshes to render\n   */\n  _renderOpaqueSorted(subMeshes) {\n    return RenderingGroup._RenderSorted(subMeshes, this._opaqueSortCompareFn, this._scene.activeCamera, false);\n  }\n  /**\n   * Renders the opaque submeshes in the order from the alphatestSortCompareFn.\n   * @param subMeshes The submeshes to render\n   */\n  _renderAlphaTestSorted(subMeshes) {\n    return RenderingGroup._RenderSorted(subMeshes, this._alphaTestSortCompareFn, this._scene.activeCamera, false);\n  }\n  /**\n   * Renders the opaque submeshes in the order from the transparentSortCompareFn.\n   * @param subMeshes The submeshes to render\n   */\n  _renderTransparentSorted(subMeshes) {\n    return RenderingGroup._RenderSorted(subMeshes, this._transparentSortCompareFn, this._scene.activeCamera, true);\n  }\n  /**\n   * Renders the submeshes in a specified order.\n   * @param subMeshes The submeshes to sort before render\n   * @param sortCompareFn The comparison function use to sort\n   * @param camera The camera position use to preprocess the submeshes to help sorting\n   * @param transparent Specifies to activate blending if true\n   */\n  static _RenderSorted(subMeshes, sortCompareFn, camera, transparent) {\n    let subIndex = 0;\n    let subMesh;\n    const cameraPosition = camera ? camera.globalPosition : RenderingGroup._ZeroVector;\n    if (transparent) {\n      for (; subIndex < subMeshes.length; subIndex++) {\n        subMesh = subMeshes.data[subIndex];\n        subMesh._alphaIndex = subMesh.getMesh().alphaIndex;\n        subMesh._distanceToCamera = Vector3.Distance(subMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);\n      }\n    }\n    const sortedArray = subMeshes.length === subMeshes.data.length ? subMeshes.data : subMeshes.data.slice(0, subMeshes.length);\n    if (sortCompareFn) {\n      sortedArray.sort(sortCompareFn);\n    }\n    const scene = sortedArray[0].getMesh().getScene();\n    for (subIndex = 0; subIndex < sortedArray.length; subIndex++) {\n      subMesh = sortedArray[subIndex];\n      if (scene._activeMeshesFrozenButKeepClipping && !subMesh.isInFrustum(scene._frustumPlanes)) {\n        continue;\n      }\n      if (transparent) {\n        const material = subMesh.getMaterial();\n        if (material && material.needDepthPrePass) {\n          const engine = material.getScene().getEngine();\n          engine.setColorWrite(false);\n          engine.setAlphaMode(0);\n          subMesh.render(false);\n          engine.setColorWrite(true);\n        }\n      }\n      subMesh.render(transparent);\n    }\n  }\n  /**\n   * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n   * are rendered back to front if in the same alpha index.\n   *\n   * @param a The first submesh\n   * @param b The second submesh\n   * @returns The result of the comparison\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static defaultTransparentSortCompare(a, b) {\n    // Alpha index first\n    if (a._alphaIndex > b._alphaIndex) {\n      return 1;\n    }\n    if (a._alphaIndex < b._alphaIndex) {\n      return -1;\n    }\n    // Then distance to camera\n    return RenderingGroup.backToFrontSortCompare(a, b);\n  }\n  /**\n   * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n   * are rendered back to front.\n   *\n   * @param a The first submesh\n   * @param b The second submesh\n   * @returns The result of the comparison\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static backToFrontSortCompare(a, b) {\n    // Then distance to camera\n    if (a._distanceToCamera < b._distanceToCamera) {\n      return 1;\n    }\n    if (a._distanceToCamera > b._distanceToCamera) {\n      return -1;\n    }\n    return 0;\n  }\n  /**\n   * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n   * are rendered front to back (prevent overdraw).\n   *\n   * @param a The first submesh\n   * @param b The second submesh\n   * @returns The result of the comparison\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static frontToBackSortCompare(a, b) {\n    // Then distance to camera\n    if (a._distanceToCamera < b._distanceToCamera) {\n      return -1;\n    }\n    if (a._distanceToCamera > b._distanceToCamera) {\n      return 1;\n    }\n    return 0;\n  }\n  /**\n   * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n   * are grouped by material then geometry.\n   *\n   * @param a The first submesh\n   * @param b The second submesh\n   * @returns The result of the comparison\n   */\n  static PainterSortCompare(a, b) {\n    const meshA = a.getMesh();\n    const meshB = b.getMesh();\n    if (meshA.material && meshB.material) {\n      return meshA.material.uniqueId - meshB.material.uniqueId;\n    }\n    return meshA.uniqueId - meshB.uniqueId;\n  }\n  /**\n   * Resets the different lists of submeshes to prepare a new frame.\n   */\n  prepare() {\n    this._opaqueSubMeshes.reset();\n    this._transparentSubMeshes.reset();\n    this._alphaTestSubMeshes.reset();\n    this._depthOnlySubMeshes.reset();\n    this._particleSystems.reset();\n    this.prepareSprites();\n    this._edgesRenderers.reset();\n    this._empty = true;\n  }\n  /**\n   * Resets the different lists of sprites to prepare a new frame.\n   */\n  prepareSprites() {\n    this._spriteManagers.reset();\n  }\n  dispose() {\n    this._opaqueSubMeshes.dispose();\n    this._transparentSubMeshes.dispose();\n    this._alphaTestSubMeshes.dispose();\n    this._depthOnlySubMeshes.dispose();\n    this._particleSystems.dispose();\n    this._spriteManagers.dispose();\n    this._edgesRenderers.dispose();\n  }\n  /**\n   * Inserts the submesh in its correct queue depending on its material.\n   * @param subMesh The submesh to dispatch\n   * @param [mesh] Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\n   * @param [material] Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\n   */\n  dispatch(subMesh, mesh, material) {\n    // Get mesh and materials if not provided\n    if (mesh === undefined) {\n      mesh = subMesh.getMesh();\n    }\n    if (material === undefined) {\n      material = subMesh.getMaterial();\n    }\n    if (material === null || material === undefined) {\n      return;\n    }\n    if (material.needAlphaBlendingForMesh(mesh)) {\n      // Transparent\n      this._transparentSubMeshes.push(subMesh);\n    } else if (material.needAlphaTesting()) {\n      // Alpha test\n      if (material.needDepthPrePass) {\n        this._depthOnlySubMeshes.push(subMesh);\n      }\n      this._alphaTestSubMeshes.push(subMesh);\n    } else {\n      if (material.needDepthPrePass) {\n        this._depthOnlySubMeshes.push(subMesh);\n      }\n      this._opaqueSubMeshes.push(subMesh); // Opaque\n    }\n\n    mesh._renderingGroup = this;\n    if (mesh._edgesRenderer && mesh._edgesRenderer.isEnabled) {\n      this._edgesRenderers.pushNoDuplicate(mesh._edgesRenderer);\n    }\n    this._empty = false;\n  }\n  dispatchSprites(spriteManager) {\n    this._spriteManagers.push(spriteManager);\n    this._empty = false;\n  }\n  dispatchParticles(particleSystem) {\n    this._particleSystems.push(particleSystem);\n    this._empty = false;\n  }\n  _renderParticles(activeMeshes) {\n    if (this._particleSystems.length === 0) {\n      return;\n    }\n    // Particles\n    const activeCamera = this._scene.activeCamera;\n    this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);\n    for (let particleIndex = 0; particleIndex < this._particleSystems.length; particleIndex++) {\n      const particleSystem = this._particleSystems.data[particleIndex];\n      if ((activeCamera && activeCamera.layerMask & particleSystem.layerMask) === 0) {\n        continue;\n      }\n      const emitter = particleSystem.emitter;\n      if (!emitter.position || !activeMeshes || activeMeshes.indexOf(emitter) !== -1) {\n        this._scene._activeParticles.addCount(particleSystem.render(), false);\n      }\n    }\n    this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);\n  }\n  _renderSprites() {\n    if (!this._scene.spritesEnabled || this._spriteManagers.length === 0) {\n      return;\n    }\n    // Sprites\n    const activeCamera = this._scene.activeCamera;\n    this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);\n    for (let id = 0; id < this._spriteManagers.length; id++) {\n      const spriteManager = this._spriteManagers.data[id];\n      if ((activeCamera && activeCamera.layerMask & spriteManager.layerMask) !== 0) {\n        spriteManager.render();\n      }\n    }\n    this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene);\n  }\n}\nRenderingGroup._ZeroVector = Vector3.Zero();","map":{"version":3,"names":["SmartArray","SmartArrayNoDuplicate","Vector3","RenderingGroup","opaqueSortCompareFn","value","_opaqueSortCompareFn","PainterSortCompare","_renderOpaque","_renderOpaqueSorted","alphaTestSortCompareFn","_alphaTestSortCompareFn","_renderAlphaTest","_renderAlphaTestSorted","transparentSortCompareFn","_transparentSortCompareFn","defaultTransparentSortCompare","_renderTransparent","_renderTransparentSorted","constructor","index","scene","_opaqueSubMeshes","_transparentSubMeshes","_alphaTestSubMeshes","_depthOnlySubMeshes","_particleSystems","_spriteManagers","_empty","_edgesRenderers","_scene","render","customRenderFunction","renderSprites","renderParticles","activeMeshes","engine","getEngine","length","setColorWrite","stencilState","getStencilBuffer","setStencilBuffer","_renderSprites","_renderParticles","onBeforeTransparentRendering","useOrderIndependentTransparency","excludedMeshes","depthPeelingRenderer","setAlphaMode","edgesRendererIndex","data","subMeshes","_RenderSorted","activeCamera","sortCompareFn","camera","transparent","subIndex","subMesh","cameraPosition","globalPosition","_ZeroVector","_alphaIndex","getMesh","alphaIndex","_distanceToCamera","Distance","getBoundingInfo","boundingSphere","centerWorld","sortedArray","slice","sort","getScene","_activeMeshesFrozenButKeepClipping","isInFrustum","_frustumPlanes","material","getMaterial","needDepthPrePass","a","b","backToFrontSortCompare","frontToBackSortCompare","meshA","meshB","uniqueId","prepare","reset","prepareSprites","dispose","dispatch","mesh","undefined","needAlphaBlendingForMesh","push","needAlphaTesting","_renderingGroup","_edgesRenderer","isEnabled","pushNoDuplicate","dispatchSprites","spriteManager","dispatchParticles","particleSystem","onBeforeParticlesRenderingObservable","notifyObservers","particleIndex","layerMask","emitter","position","indexOf","_activeParticles","addCount","onAfterParticlesRenderingObservable","spritesEnabled","onBeforeSpritesRenderingObservable","id","onAfterSpritesRenderingObservable","Zero"],"sources":["../../../../dev/core/src/Rendering/renderingGroup.ts"],"sourcesContent":["import { SmartArray, SmartArrayNoDuplicate } from \"../Misc/smartArray\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Nullable, DeepImmutable } from \"../types\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { IParticleSystem } from \"../Particles/IParticleSystem\";\r\nimport type { IEdgesRenderer } from \"./edgesRenderer\";\r\nimport type { ISpriteManager } from \"../Sprites/spriteManager\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\n\r\n/**\r\n * This represents the object necessary to create a rendering group.\r\n * This is exclusively used and created by the rendering manager.\r\n * To modify the behavior, you use the available helpers in your scene or meshes.\r\n * @internal\r\n */\r\nexport class RenderingGroup {\r\n    private static _ZeroVector: DeepImmutable<Vector3> = Vector3.Zero();\r\n    private _scene: Scene;\r\n    private _opaqueSubMeshes = new SmartArray<SubMesh>(256);\r\n    private _transparentSubMeshes = new SmartArray<SubMesh>(256);\r\n    private _alphaTestSubMeshes = new SmartArray<SubMesh>(256);\r\n    private _depthOnlySubMeshes = new SmartArray<SubMesh>(256);\r\n    private _particleSystems = new SmartArray<IParticleSystem>(256);\r\n    private _spriteManagers = new SmartArray<ISpriteManager>(256);\r\n\r\n    private _opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number>;\r\n    private _alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number>;\r\n    private _transparentSortCompareFn: (a: SubMesh, b: SubMesh) => number;\r\n\r\n    private _renderOpaque: (subMeshes: SmartArray<SubMesh>) => void;\r\n    private _renderAlphaTest: (subMeshes: SmartArray<SubMesh>) => void;\r\n    private _renderTransparent: (subMeshes: SmartArray<SubMesh>) => void;\r\n\r\n    /** @internal */\r\n    public _empty = true;\r\n\r\n    /** @internal */\r\n    public _edgesRenderers = new SmartArrayNoDuplicate<IEdgesRenderer>(16);\r\n\r\n    public onBeforeTransparentRendering: () => void;\r\n\r\n    /**\r\n     * Set the opaque sort comparison function.\r\n     * If null the sub meshes will be render in the order they were created\r\n     */\r\n    public set opaqueSortCompareFn(value: Nullable<(a: SubMesh, b: SubMesh) => number>) {\r\n        if (value) {\r\n            this._opaqueSortCompareFn = value;\r\n        } else {\r\n            this._opaqueSortCompareFn = RenderingGroup.PainterSortCompare;\r\n        }\r\n        this._renderOpaque = this._renderOpaqueSorted;\r\n    }\r\n\r\n    /**\r\n     * Set the alpha test sort comparison function.\r\n     * If null the sub meshes will be render in the order they were created\r\n     */\r\n    public set alphaTestSortCompareFn(value: Nullable<(a: SubMesh, b: SubMesh) => number>) {\r\n        if (value) {\r\n            this._alphaTestSortCompareFn = value;\r\n        } else {\r\n            this._alphaTestSortCompareFn = RenderingGroup.PainterSortCompare;\r\n        }\r\n        this._renderAlphaTest = this._renderAlphaTestSorted;\r\n    }\r\n\r\n    /**\r\n     * Set the transparent sort comparison function.\r\n     * If null the sub meshes will be render in the order they were created\r\n     */\r\n    public set transparentSortCompareFn(value: Nullable<(a: SubMesh, b: SubMesh) => number>) {\r\n        if (value) {\r\n            this._transparentSortCompareFn = value;\r\n        } else {\r\n            this._transparentSortCompareFn = RenderingGroup.defaultTransparentSortCompare;\r\n        }\r\n        this._renderTransparent = this._renderTransparentSorted;\r\n    }\r\n\r\n    /**\r\n     * Creates a new rendering group.\r\n     * @param index The rendering group index\r\n     * @param scene\r\n     * @param opaqueSortCompareFn The opaque sort comparison function. If null no order is applied\r\n     * @param alphaTestSortCompareFn The alpha test sort comparison function. If null no order is applied\r\n     * @param transparentSortCompareFn The transparent sort comparison function. If null back to front + alpha index sort is applied\r\n     */\r\n    constructor(\r\n        public index: number,\r\n        scene: Scene,\r\n        opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        transparentSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null\r\n    ) {\r\n        this._scene = scene;\r\n\r\n        this.opaqueSortCompareFn = opaqueSortCompareFn;\r\n        this.alphaTestSortCompareFn = alphaTestSortCompareFn;\r\n        this.transparentSortCompareFn = transparentSortCompareFn;\r\n    }\r\n\r\n    /**\r\n     * Render all the sub meshes contained in the group.\r\n     * @param customRenderFunction Used to override the default render behaviour of the group.\r\n     * @param renderSprites\r\n     * @param renderParticles\r\n     * @param activeMeshes\r\n     * @returns true if rendered some submeshes.\r\n     */\r\n    public render(\r\n        customRenderFunction: Nullable<\r\n            (\r\n                opaqueSubMeshes: SmartArray<SubMesh>,\r\n                transparentSubMeshes: SmartArray<SubMesh>,\r\n                alphaTestSubMeshes: SmartArray<SubMesh>,\r\n                depthOnlySubMeshes: SmartArray<SubMesh>\r\n            ) => void\r\n        >,\r\n        renderSprites: boolean,\r\n        renderParticles: boolean,\r\n        activeMeshes: Nullable<AbstractMesh[]>\r\n    ): void {\r\n        if (customRenderFunction) {\r\n            customRenderFunction(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);\r\n            return;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        // Depth only\r\n        if (this._depthOnlySubMeshes.length !== 0) {\r\n            engine.setColorWrite(false);\r\n            this._renderAlphaTest(this._depthOnlySubMeshes);\r\n            engine.setColorWrite(true);\r\n        }\r\n\r\n        // Opaque\r\n        if (this._opaqueSubMeshes.length !== 0) {\r\n            this._renderOpaque(this._opaqueSubMeshes);\r\n        }\r\n\r\n        // Alpha test\r\n        if (this._alphaTestSubMeshes.length !== 0) {\r\n            this._renderAlphaTest(this._alphaTestSubMeshes);\r\n        }\r\n\r\n        const stencilState = engine.getStencilBuffer();\r\n        engine.setStencilBuffer(false);\r\n\r\n        // Sprites\r\n        if (renderSprites) {\r\n            this._renderSprites();\r\n        }\r\n\r\n        // Particles\r\n        if (renderParticles) {\r\n            this._renderParticles(activeMeshes);\r\n        }\r\n\r\n        if (this.onBeforeTransparentRendering) {\r\n            this.onBeforeTransparentRendering();\r\n        }\r\n\r\n        // Transparent\r\n        if (this._transparentSubMeshes.length !== 0 || this._scene.useOrderIndependentTransparency) {\r\n            engine.setStencilBuffer(stencilState);\r\n            if (this._scene.useOrderIndependentTransparency) {\r\n                const excludedMeshes = this._scene.depthPeelingRenderer!.render(this._transparentSubMeshes);\r\n                if (excludedMeshes.length) {\r\n                    // Render leftover meshes that could not be processed by depth peeling\r\n                    this._renderTransparent(excludedMeshes);\r\n                }\r\n            } else {\r\n                this._renderTransparent(this._transparentSubMeshes);\r\n            }\r\n            engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        }\r\n\r\n        // Set back stencil to false in case it changes before the edge renderer.\r\n        engine.setStencilBuffer(false);\r\n\r\n        // Edges\r\n        if (this._edgesRenderers.length) {\r\n            for (let edgesRendererIndex = 0; edgesRendererIndex < this._edgesRenderers.length; edgesRendererIndex++) {\r\n                this._edgesRenderers.data[edgesRendererIndex].render();\r\n            }\r\n\r\n            engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        }\r\n\r\n        // Restore Stencil state.\r\n        engine.setStencilBuffer(stencilState);\r\n    }\r\n\r\n    /**\r\n     * Renders the opaque submeshes in the order from the opaqueSortCompareFn.\r\n     * @param subMeshes The submeshes to render\r\n     */\r\n    private _renderOpaqueSorted(subMeshes: SmartArray<SubMesh>): void {\r\n        return RenderingGroup._RenderSorted(subMeshes, this._opaqueSortCompareFn, this._scene.activeCamera, false);\r\n    }\r\n\r\n    /**\r\n     * Renders the opaque submeshes in the order from the alphatestSortCompareFn.\r\n     * @param subMeshes The submeshes to render\r\n     */\r\n    private _renderAlphaTestSorted(subMeshes: SmartArray<SubMesh>): void {\r\n        return RenderingGroup._RenderSorted(subMeshes, this._alphaTestSortCompareFn, this._scene.activeCamera, false);\r\n    }\r\n\r\n    /**\r\n     * Renders the opaque submeshes in the order from the transparentSortCompareFn.\r\n     * @param subMeshes The submeshes to render\r\n     */\r\n    private _renderTransparentSorted(subMeshes: SmartArray<SubMesh>): void {\r\n        return RenderingGroup._RenderSorted(subMeshes, this._transparentSortCompareFn, this._scene.activeCamera, true);\r\n    }\r\n\r\n    /**\r\n     * Renders the submeshes in a specified order.\r\n     * @param subMeshes The submeshes to sort before render\r\n     * @param sortCompareFn The comparison function use to sort\r\n     * @param camera The camera position use to preprocess the submeshes to help sorting\r\n     * @param transparent Specifies to activate blending if true\r\n     */\r\n    private static _RenderSorted(\r\n        subMeshes: SmartArray<SubMesh>,\r\n        sortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number>,\r\n        camera: Nullable<Camera>,\r\n        transparent: boolean\r\n    ): void {\r\n        let subIndex = 0;\r\n        let subMesh: SubMesh;\r\n        const cameraPosition = camera ? camera.globalPosition : RenderingGroup._ZeroVector;\r\n\r\n        if (transparent) {\r\n            for (; subIndex < subMeshes.length; subIndex++) {\r\n                subMesh = subMeshes.data[subIndex];\r\n                subMesh._alphaIndex = subMesh.getMesh().alphaIndex;\r\n                subMesh._distanceToCamera = Vector3.Distance(subMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);\r\n            }\r\n        }\r\n\r\n        const sortedArray = subMeshes.length === subMeshes.data.length ? subMeshes.data : subMeshes.data.slice(0, subMeshes.length);\r\n\r\n        if (sortCompareFn) {\r\n            sortedArray.sort(sortCompareFn);\r\n        }\r\n\r\n        const scene = sortedArray[0].getMesh().getScene();\r\n        for (subIndex = 0; subIndex < sortedArray.length; subIndex++) {\r\n            subMesh = sortedArray[subIndex];\r\n\r\n            if (scene._activeMeshesFrozenButKeepClipping && !subMesh.isInFrustum(scene._frustumPlanes)) {\r\n                continue;\r\n            }\r\n\r\n            if (transparent) {\r\n                const material = subMesh.getMaterial();\r\n\r\n                if (material && material.needDepthPrePass) {\r\n                    const engine = material.getScene().getEngine();\r\n                    engine.setColorWrite(false);\r\n                    engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n                    subMesh.render(false);\r\n                    engine.setColorWrite(true);\r\n                }\r\n            }\r\n\r\n            subMesh.render(transparent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n     * are rendered back to front if in the same alpha index.\r\n     *\r\n     * @param a The first submesh\r\n     * @param b The second submesh\r\n     * @returns The result of the comparison\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static defaultTransparentSortCompare(a: SubMesh, b: SubMesh): number {\r\n        // Alpha index first\r\n        if (a._alphaIndex > b._alphaIndex) {\r\n            return 1;\r\n        }\r\n        if (a._alphaIndex < b._alphaIndex) {\r\n            return -1;\r\n        }\r\n\r\n        // Then distance to camera\r\n        return RenderingGroup.backToFrontSortCompare(a, b);\r\n    }\r\n\r\n    /**\r\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n     * are rendered back to front.\r\n     *\r\n     * @param a The first submesh\r\n     * @param b The second submesh\r\n     * @returns The result of the comparison\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static backToFrontSortCompare(a: SubMesh, b: SubMesh): number {\r\n        // Then distance to camera\r\n        if (a._distanceToCamera < b._distanceToCamera) {\r\n            return 1;\r\n        }\r\n        if (a._distanceToCamera > b._distanceToCamera) {\r\n            return -1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n     * are rendered front to back (prevent overdraw).\r\n     *\r\n     * @param a The first submesh\r\n     * @param b The second submesh\r\n     * @returns The result of the comparison\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static frontToBackSortCompare(a: SubMesh, b: SubMesh): number {\r\n        // Then distance to camera\r\n        if (a._distanceToCamera < b._distanceToCamera) {\r\n            return -1;\r\n        }\r\n        if (a._distanceToCamera > b._distanceToCamera) {\r\n            return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n     * are grouped by material then geometry.\r\n     *\r\n     * @param a The first submesh\r\n     * @param b The second submesh\r\n     * @returns The result of the comparison\r\n     */\r\n    public static PainterSortCompare(a: SubMesh, b: SubMesh): number {\r\n        const meshA = a.getMesh();\r\n        const meshB = b.getMesh();\r\n\r\n        if (meshA.material && meshB.material) {\r\n            return meshA.material.uniqueId - meshB.material.uniqueId;\r\n        }\r\n\r\n        return meshA.uniqueId - meshB.uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Resets the different lists of submeshes to prepare a new frame.\r\n     */\r\n    public prepare(): void {\r\n        this._opaqueSubMeshes.reset();\r\n        this._transparentSubMeshes.reset();\r\n        this._alphaTestSubMeshes.reset();\r\n        this._depthOnlySubMeshes.reset();\r\n        this._particleSystems.reset();\r\n        this.prepareSprites();\r\n        this._edgesRenderers.reset();\r\n        this._empty = true;\r\n    }\r\n\r\n    /**\r\n     * Resets the different lists of sprites to prepare a new frame.\r\n     */\r\n    public prepareSprites(): void {\r\n        this._spriteManagers.reset();\r\n    }\r\n\r\n    public dispose(): void {\r\n        this._opaqueSubMeshes.dispose();\r\n        this._transparentSubMeshes.dispose();\r\n        this._alphaTestSubMeshes.dispose();\r\n        this._depthOnlySubMeshes.dispose();\r\n        this._particleSystems.dispose();\r\n        this._spriteManagers.dispose();\r\n        this._edgesRenderers.dispose();\r\n    }\r\n\r\n    /**\r\n     * Inserts the submesh in its correct queue depending on its material.\r\n     * @param subMesh The submesh to dispatch\r\n     * @param [mesh] Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\r\n     * @param [material] Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\r\n     */\r\n    public dispatch(subMesh: SubMesh, mesh?: AbstractMesh, material?: Nullable<Material>): void {\r\n        // Get mesh and materials if not provided\r\n        if (mesh === undefined) {\r\n            mesh = subMesh.getMesh();\r\n        }\r\n        if (material === undefined) {\r\n            material = subMesh.getMaterial();\r\n        }\r\n\r\n        if (material === null || material === undefined) {\r\n            return;\r\n        }\r\n\r\n        if (material.needAlphaBlendingForMesh(mesh)) {\r\n            // Transparent\r\n            this._transparentSubMeshes.push(subMesh);\r\n        } else if (material.needAlphaTesting()) {\r\n            // Alpha test\r\n            if (material.needDepthPrePass) {\r\n                this._depthOnlySubMeshes.push(subMesh);\r\n            }\r\n\r\n            this._alphaTestSubMeshes.push(subMesh);\r\n        } else {\r\n            if (material.needDepthPrePass) {\r\n                this._depthOnlySubMeshes.push(subMesh);\r\n            }\r\n\r\n            this._opaqueSubMeshes.push(subMesh); // Opaque\r\n        }\r\n\r\n        mesh._renderingGroup = this;\r\n\r\n        if (mesh._edgesRenderer && mesh._edgesRenderer.isEnabled) {\r\n            this._edgesRenderers.pushNoDuplicate(mesh._edgesRenderer);\r\n        }\r\n\r\n        this._empty = false;\r\n    }\r\n\r\n    public dispatchSprites(spriteManager: ISpriteManager) {\r\n        this._spriteManagers.push(spriteManager);\r\n        this._empty = false;\r\n    }\r\n\r\n    public dispatchParticles(particleSystem: IParticleSystem) {\r\n        this._particleSystems.push(particleSystem);\r\n        this._empty = false;\r\n    }\r\n\r\n    private _renderParticles(activeMeshes: Nullable<AbstractMesh[]>): void {\r\n        if (this._particleSystems.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Particles\r\n        const activeCamera = this._scene.activeCamera;\r\n        this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);\r\n        for (let particleIndex = 0; particleIndex < this._particleSystems.length; particleIndex++) {\r\n            const particleSystem = this._particleSystems.data[particleIndex];\r\n\r\n            if ((activeCamera && activeCamera.layerMask & particleSystem.layerMask) === 0) {\r\n                continue;\r\n            }\r\n\r\n            const emitter: any = particleSystem.emitter;\r\n            if (!emitter.position || !activeMeshes || activeMeshes.indexOf(emitter) !== -1) {\r\n                this._scene._activeParticles.addCount(particleSystem.render(), false);\r\n            }\r\n        }\r\n        this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);\r\n    }\r\n\r\n    private _renderSprites(): void {\r\n        if (!this._scene.spritesEnabled || this._spriteManagers.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Sprites\r\n        const activeCamera = this._scene.activeCamera;\r\n        this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);\r\n        for (let id = 0; id < this._spriteManagers.length; id++) {\r\n            const spriteManager = this._spriteManagers.data[id];\r\n\r\n            if ((activeCamera && activeCamera.layerMask & spriteManager.layerMask) !== 0) {\r\n                spriteManager.render();\r\n            }\r\n        }\r\n        this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}