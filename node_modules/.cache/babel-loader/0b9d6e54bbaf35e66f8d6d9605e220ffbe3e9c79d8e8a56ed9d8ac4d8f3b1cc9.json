{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\nimport { __decorate } from \"../../../../tslib.es6.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock.js\";\nimport { TextureTools } from \"../../../../Misc/textureTools.js\";\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator.js\";\n/**\n * Block used to load texture data\n */\nexport class GeometryTextureBlock extends NodeGeometryBlock {\n  /**\n   * Gets the texture data\n   */\n  get textureData() {\n    return this._data;\n  }\n  /**\n   * Gets the texture width\n   */\n  get textureWidth() {\n    return this._width;\n  }\n  /**\n   * Gets the texture height\n   */\n  get textureHeight() {\n    return this._height;\n  }\n  /**\n   * Creates a new GeometryTextureBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    this._data = null;\n    /**\n     * Gets or sets a boolean indicating that this block should serialize its cached data\n     */\n    this.serializedCachedData = false;\n    this.registerOutput(\"texture\", NodeGeometryBlockConnectionPointTypes.Texture);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"GeometryTextureBlock\";\n  }\n  /**\n   * Gets the texture component\n   */\n  get texture() {\n    return this._outputs[0];\n  }\n  _prepareImgToLoadAsync(url) {\n    return new Promise((resolve, reject) => {\n      const img = new Image();\n      const canvas = document.createElement(\"canvas\");\n      const ctx = canvas.getContext(\"2d\");\n      img.onload = () => {\n        canvas.width = img.width;\n        canvas.height = img.height;\n        ctx.drawImage(img, 0, 0);\n        const imageData = ctx.getImageData(0, 0, img.width, img.height);\n        const pixels = imageData.data;\n        const floatArray = new Float32Array(pixels.length);\n        for (let i = 0; i < pixels.length; i++) {\n          floatArray[i] = pixels[i] / 255.0;\n        }\n        this._data = floatArray;\n        this._width = img.width;\n        this._height = img.height;\n        resolve();\n      };\n      img.onerror = () => {\n        this._data = null;\n        reject();\n      };\n      img.src = url;\n    });\n  }\n  /**\n   * Remove stored data\n   */\n  cleanData() {\n    this._data = null;\n  }\n  /**\n   * Load the texture data\n   * @param imageFile defines the file to load data from\n   * @returns a promise fulfilled when image data is loaded\n   */\n  loadTextureFromFileAsync(imageFile) {\n    return this._prepareImgToLoadAsync(URL.createObjectURL(imageFile));\n  }\n  /**\n   * Load the texture data\n   * @param url defines the url to load data from\n   * @returns a promise fulfilled when image data is loaded\n   */\n  loadTextureFromUrlAsync(url) {\n    return this._prepareImgToLoadAsync(url);\n  }\n  /**\n   * Load the texture data\n   * @param url defines the url to load data from\n   * @returns a promise fulfilled when image data is loaded\n   */\n  extractFromTextureAsync(texture) {\n    return new Promise((resolve, reject) => {\n      if (!texture.isReady()) {\n        texture.onLoadObservable.addOnce(() => {\n          return this.extractFromTextureAsync(texture).then(resolve).catch(reject);\n        });\n        return;\n      }\n      const size = texture.getSize();\n      TextureTools.GetTextureDataAsync(texture, size.width, size.height).then(async data => {\n        const floatArray = new Float32Array(data.length);\n        for (let i = 0; i < data.length; i++) {\n          floatArray[i] = data[i] / 255.0;\n        }\n        this._data = floatArray;\n        this._width = size.width;\n        this._height = size.height;\n        resolve();\n      }).catch(reject);\n    });\n  }\n  _buildBlock() {\n    if (!this._data) {\n      this.texture._storedValue = null;\n      return;\n    }\n    const textureData = {\n      data: this._data,\n      width: this._width,\n      height: this._height\n    };\n    this.texture._storedValue = textureData;\n  }\n  /**\n   * Serializes this block in a JSON representation\n   * @returns the serialized block object\n   */\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.width = this._width;\n    serializationObject.height = this._height;\n    serializationObject.serializedCachedData = this.serializedCachedData;\n    if (this._data && this.serializedCachedData) {\n      serializationObject.data = Array.from(this._data);\n    }\n    return serializationObject;\n  }\n  _deserialize(serializationObject) {\n    super._deserialize(serializationObject);\n    this._width = serializationObject.width;\n    this._height = serializationObject.height;\n    if (serializationObject.data) {\n      this._data = new Float32Array(serializationObject.data);\n      this.serializedCachedData = true;\n    } else {\n      this.serializedCachedData = !!serializationObject.serializedCachedData;\n    }\n  }\n}\n__decorate([editableInPropertyPage(\"Serialize cached data\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    rebuild: true\n  }\n})], GeometryTextureBlock.prototype, \"serializedCachedData\", void 0);\nRegisterClass(\"BABYLON.GeometryTextureBlock\", GeometryTextureBlock);","map":{"version":3,"names":["RegisterClass","NodeGeometryBlockConnectionPointTypes","NodeGeometryBlock","TextureTools","PropertyTypeForEdition","editableInPropertyPage","GeometryTextureBlock","textureData","_data","textureWidth","_width","textureHeight","_height","constructor","name","serializedCachedData","registerOutput","Texture","getClassName","texture","_outputs","_prepareImgToLoadAsync","url","Promise","resolve","reject","img","Image","canvas","document","createElement","ctx","getContext","onload","width","height","drawImage","imageData","getImageData","pixels","data","floatArray","Float32Array","length","i","onerror","src","cleanData","loadTextureFromFileAsync","imageFile","URL","createObjectURL","loadTextureFromUrlAsync","extractFromTextureAsync","isReady","onLoadObservable","addOnce","then","catch","size","getSize","GetTextureDataAsync","_buildBlock","_storedValue","serialize","serializationObject","Array","from","_deserialize","__decorate","Boolean","notifiers","rebuild"],"sources":["../../../../../../../dev/core/src/Meshes/Node/Blocks/Textures/geometryTextureBlock.ts"],"sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { INodeGeometryTextureData } from \"../../Interfaces/nodeGeometryTextureData\";\r\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { TextureTools } from \"core/Misc/textureTools\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"core/Decorators/nodeDecorator\";\r\n/**\r\n * Block used to load texture data\r\n */\r\nexport class GeometryTextureBlock extends NodeGeometryBlock {\r\n    private _data: Nullable<Float32Array> = null;\r\n    private _width: number;\r\n    private _height: number;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this block should serialize its cached data\r\n     */\r\n    @editableInPropertyPage(\"Serialize cached data\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public serializedCachedData = false;\r\n\r\n    /**\r\n     * Gets the texture data\r\n     */\r\n    public get textureData() {\r\n        return this._data;\r\n    }\r\n\r\n    /**\r\n     * Gets the texture width\r\n     */\r\n    public get textureWidth() {\r\n        return this._width;\r\n    }\r\n\r\n    /**\r\n     * Gets the texture height\r\n     */\r\n    public get textureHeight() {\r\n        return this._height;\r\n    }\r\n\r\n    /**\r\n     * Creates a new GeometryTextureBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerOutput(\"texture\", NodeGeometryBlockConnectionPointTypes.Texture);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"GeometryTextureBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the texture component\r\n     */\r\n    public get texture(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    private _prepareImgToLoadAsync(url: string) {\r\n        return new Promise<void>((resolve, reject) => {\r\n            const img = new Image();\r\n            const canvas = document.createElement(\"canvas\");\r\n            const ctx = canvas.getContext(\"2d\");\r\n\r\n            img.onload = () => {\r\n                canvas.width = img.width;\r\n                canvas.height = img.height;\r\n\r\n                ctx!.drawImage(img, 0, 0);\r\n\r\n                const imageData = ctx!.getImageData(0, 0, img.width, img.height);\r\n                const pixels = imageData.data;\r\n                const floatArray = new Float32Array(pixels.length);\r\n\r\n                for (let i = 0; i < pixels.length; i++) {\r\n                    floatArray[i] = pixels[i] / 255.0;\r\n                }\r\n\r\n                this._data = floatArray;\r\n                this._width = img.width;\r\n                this._height = img.height;\r\n                resolve();\r\n            };\r\n\r\n            img.onerror = () => {\r\n                this._data = null;\r\n                reject();\r\n            };\r\n\r\n            img.src = url;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Remove stored data\r\n     */\r\n    public cleanData() {\r\n        this._data = null;\r\n    }\r\n\r\n    /**\r\n     * Load the texture data\r\n     * @param imageFile defines the file to load data from\r\n     * @returns a promise fulfilled when image data is loaded\r\n     */\r\n    public loadTextureFromFileAsync(imageFile: File) {\r\n        return this._prepareImgToLoadAsync(URL.createObjectURL(imageFile));\r\n    }\r\n\r\n    /**\r\n     * Load the texture data\r\n     * @param url defines the url to load data from\r\n     * @returns a promise fulfilled when image data is loaded\r\n     */\r\n    public loadTextureFromUrlAsync(url: string) {\r\n        return this._prepareImgToLoadAsync(url);\r\n    }\r\n\r\n    /**\r\n     * Load the texture data\r\n     * @param url defines the url to load data from\r\n     * @returns a promise fulfilled when image data is loaded\r\n     */\r\n    public extractFromTextureAsync(texture: Texture) {\r\n        return new Promise<void>((resolve, reject) => {\r\n            if (!texture.isReady()) {\r\n                texture.onLoadObservable.addOnce(() => {\r\n                    return this.extractFromTextureAsync(texture).then(resolve).catch(reject);\r\n                });\r\n                return;\r\n            }\r\n            const size = texture.getSize();\r\n            TextureTools.GetTextureDataAsync(texture, size.width, size.height)\r\n                .then(async (data) => {\r\n                    const floatArray = new Float32Array(data.length);\r\n\r\n                    for (let i = 0; i < data.length; i++) {\r\n                        floatArray[i] = data[i] / 255.0;\r\n                    }\r\n                    this._data = floatArray;\r\n                    this._width = size.width;\r\n                    this._height = size.height;\r\n                    resolve();\r\n                })\r\n                .catch(reject);\r\n        });\r\n    }\r\n\r\n    protected _buildBlock() {\r\n        if (!this._data) {\r\n            this.texture._storedValue = null;\r\n            return;\r\n        }\r\n\r\n        const textureData: INodeGeometryTextureData = {\r\n            data: this._data,\r\n            width: this._width,\r\n            height: this._height,\r\n        };\r\n\r\n        this.texture._storedValue = textureData;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.width = this._width;\r\n        serializationObject.height = this._height;\r\n        serializationObject.serializedCachedData = this.serializedCachedData;\r\n        if (this._data && this.serializedCachedData) {\r\n            serializationObject.data = Array.from(this._data);\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this._width = serializationObject.width;\r\n        this._height = serializationObject.height;\r\n        if (serializationObject.data) {\r\n            this._data = new Float32Array(serializationObject.data);\r\n            this.serializedCachedData = true;\r\n        } else {\r\n            this.serializedCachedData = !!serializationObject.serializedCachedData;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GeometryTextureBlock\", GeometryTextureBlock);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}