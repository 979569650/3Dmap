{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * EffectFallbacks can be used to add fallbacks (properties to disable) to certain properties when desired to improve performance.\n * (Eg. Start at high quality with reflection and fog, if fps is low, remove reflection, if still low remove fog)\n */\nexport class EffectFallbacks {\n  constructor() {\n    this._defines = {};\n    this._currentRank = 32;\n    this._maxRank = -1;\n    this._mesh = null;\n  }\n  /**\n   * Removes the fallback from the bound mesh.\n   */\n  unBindMesh() {\n    this._mesh = null;\n  }\n  /**\n   * Adds a fallback on the specified property.\n   * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)\n   * @param define The name of the define in the shader\n   */\n  addFallback(rank, define) {\n    if (!this._defines[rank]) {\n      if (rank < this._currentRank) {\n        this._currentRank = rank;\n      }\n      if (rank > this._maxRank) {\n        this._maxRank = rank;\n      }\n      this._defines[rank] = new Array();\n    }\n    this._defines[rank].push(define);\n  }\n  /**\n   * Sets the mesh to use CPU skinning when needing to fallback.\n   * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)\n   * @param mesh The mesh to use the fallbacks.\n   */\n  addCPUSkinningFallback(rank, mesh) {\n    this._mesh = mesh;\n    if (rank < this._currentRank) {\n      this._currentRank = rank;\n    }\n    if (rank > this._maxRank) {\n      this._maxRank = rank;\n    }\n  }\n  /**\n   * Checks to see if more fallbacks are still available.\n   */\n  get hasMoreFallbacks() {\n    return this._currentRank <= this._maxRank;\n  }\n  /**\n   * Removes the defines that should be removed when falling back.\n   * @param currentDefines defines the current define statements for the shader.\n   * @param effect defines the current effect we try to compile\n   * @returns The resulting defines with defines of the current rank removed.\n   */\n  reduce(currentDefines, effect) {\n    // First we try to switch to CPU skinning\n    if (this._mesh && this._mesh.computeBonesUsingShaders && this._mesh.numBoneInfluencers > 0) {\n      this._mesh.computeBonesUsingShaders = false;\n      currentDefines = currentDefines.replace(\"#define NUM_BONE_INFLUENCERS \" + this._mesh.numBoneInfluencers, \"#define NUM_BONE_INFLUENCERS 0\");\n      effect._bonesComputationForcedToCPU = true;\n      const scene = this._mesh.getScene();\n      for (let index = 0; index < scene.meshes.length; index++) {\n        const otherMesh = scene.meshes[index];\n        if (!otherMesh.material) {\n          if (!this._mesh.material && otherMesh.computeBonesUsingShaders && otherMesh.numBoneInfluencers > 0) {\n            otherMesh.computeBonesUsingShaders = false;\n          }\n          continue;\n        }\n        if (!otherMesh.computeBonesUsingShaders || otherMesh.numBoneInfluencers === 0) {\n          continue;\n        }\n        if (otherMesh.material.getEffect() === effect) {\n          otherMesh.computeBonesUsingShaders = false;\n        } else if (otherMesh.subMeshes) {\n          for (const subMesh of otherMesh.subMeshes) {\n            const subMeshEffect = subMesh.effect;\n            if (subMeshEffect === effect) {\n              otherMesh.computeBonesUsingShaders = false;\n              break;\n            }\n          }\n        }\n      }\n    } else {\n      const currentFallbacks = this._defines[this._currentRank];\n      if (currentFallbacks) {\n        for (let index = 0; index < currentFallbacks.length; index++) {\n          currentDefines = currentDefines.replace(\"#define \" + currentFallbacks[index], \"\");\n        }\n      }\n      this._currentRank++;\n    }\n    return currentDefines;\n  }\n}","map":{"version":3,"names":["EffectFallbacks","constructor","_defines","_currentRank","_maxRank","_mesh","unBindMesh","addFallback","rank","define","Array","push","addCPUSkinningFallback","mesh","hasMoreFallbacks","reduce","currentDefines","effect","computeBonesUsingShaders","numBoneInfluencers","replace","_bonesComputationForcedToCPU","scene","getScene","index","meshes","length","otherMesh","material","getEffect","subMeshes","subMesh","subMeshEffect","currentFallbacks"],"sources":["../../../../dev/core/src/Materials/effectFallbacks.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { IEffectFallbacks } from \"./iEffectFallbacks\";\r\n\r\nimport type { Effect } from \"./effect\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\n\r\n/**\r\n * EffectFallbacks can be used to add fallbacks (properties to disable) to certain properties when desired to improve performance.\r\n * (Eg. Start at high quality with reflection and fog, if fps is low, remove reflection, if still low remove fog)\r\n */\r\nexport class EffectFallbacks implements IEffectFallbacks {\r\n    private _defines: { [key: string]: Array<String> } = {};\r\n\r\n    private _currentRank = 32;\r\n    private _maxRank = -1;\r\n\r\n    private _mesh: Nullable<AbstractMesh> = null;\r\n\r\n    /**\r\n     * Removes the fallback from the bound mesh.\r\n     */\r\n    public unBindMesh() {\r\n        this._mesh = null;\r\n    }\r\n\r\n    /**\r\n     * Adds a fallback on the specified property.\r\n     * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)\r\n     * @param define The name of the define in the shader\r\n     */\r\n    public addFallback(rank: number, define: string): void {\r\n        if (!this._defines[rank]) {\r\n            if (rank < this._currentRank) {\r\n                this._currentRank = rank;\r\n            }\r\n\r\n            if (rank > this._maxRank) {\r\n                this._maxRank = rank;\r\n            }\r\n\r\n            this._defines[rank] = new Array<String>();\r\n        }\r\n\r\n        this._defines[rank].push(define);\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh to use CPU skinning when needing to fallback.\r\n     * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)\r\n     * @param mesh The mesh to use the fallbacks.\r\n     */\r\n    public addCPUSkinningFallback(rank: number, mesh: AbstractMesh) {\r\n        this._mesh = mesh;\r\n\r\n        if (rank < this._currentRank) {\r\n            this._currentRank = rank;\r\n        }\r\n        if (rank > this._maxRank) {\r\n            this._maxRank = rank;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks to see if more fallbacks are still available.\r\n     */\r\n    public get hasMoreFallbacks(): boolean {\r\n        return this._currentRank <= this._maxRank;\r\n    }\r\n\r\n    /**\r\n     * Removes the defines that should be removed when falling back.\r\n     * @param currentDefines defines the current define statements for the shader.\r\n     * @param effect defines the current effect we try to compile\r\n     * @returns The resulting defines with defines of the current rank removed.\r\n     */\r\n    public reduce(currentDefines: string, effect: Effect): string {\r\n        // First we try to switch to CPU skinning\r\n        if (this._mesh && this._mesh.computeBonesUsingShaders && this._mesh.numBoneInfluencers > 0) {\r\n            this._mesh.computeBonesUsingShaders = false;\r\n            currentDefines = currentDefines.replace(\"#define NUM_BONE_INFLUENCERS \" + this._mesh.numBoneInfluencers, \"#define NUM_BONE_INFLUENCERS 0\");\r\n            effect._bonesComputationForcedToCPU = true;\r\n\r\n            const scene = this._mesh.getScene();\r\n            for (let index = 0; index < scene.meshes.length; index++) {\r\n                const otherMesh = scene.meshes[index];\r\n\r\n                if (!otherMesh.material) {\r\n                    if (!this._mesh.material && otherMesh.computeBonesUsingShaders && otherMesh.numBoneInfluencers > 0) {\r\n                        otherMesh.computeBonesUsingShaders = false;\r\n                    }\r\n                    continue;\r\n                }\r\n\r\n                if (!otherMesh.computeBonesUsingShaders || otherMesh.numBoneInfluencers === 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (otherMesh.material.getEffect() === effect) {\r\n                    otherMesh.computeBonesUsingShaders = false;\r\n                } else if (otherMesh.subMeshes) {\r\n                    for (const subMesh of otherMesh.subMeshes) {\r\n                        const subMeshEffect = subMesh.effect;\r\n\r\n                        if (subMeshEffect === effect) {\r\n                            otherMesh.computeBonesUsingShaders = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const currentFallbacks = this._defines[this._currentRank];\r\n            if (currentFallbacks) {\r\n                for (let index = 0; index < currentFallbacks.length; index++) {\r\n                    currentDefines = currentDefines.replace(\"#define \" + currentFallbacks[index], \"\");\r\n                }\r\n            }\r\n\r\n            this._currentRank++;\r\n        }\r\n\r\n        return currentDefines;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}