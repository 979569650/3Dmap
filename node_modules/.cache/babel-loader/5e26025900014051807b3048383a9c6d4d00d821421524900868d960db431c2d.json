{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { serializeAsVector3, serialize } from \"../Misc/decorators.js\";\nimport { Vector3, Vector2 } from \"../Maths/math.vector.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { TargetCamera } from \"./targetCamera.js\";\nimport { FreeCameraInputsManager } from \"./freeCameraInputsManager.js\";\nimport { Tools } from \"../Misc/tools.js\";\n/**\n * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\n * Please consider using the new UniversalCamera instead as it adds more functionality like the gamepad.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\n */\nexport class FreeCamera extends TargetCamera {\n  /**\n   * Gets the input sensibility for a mouse input. (default is 2000.0)\n   * Higher values reduce sensitivity.\n   */\n  get angularSensibility() {\n    const mouse = this.inputs.attached[\"mouse\"];\n    if (mouse) {\n      return mouse.angularSensibility;\n    }\n    return 0;\n  }\n  /**\n   * Sets the input sensibility for a mouse input. (default is 2000.0)\n   * Higher values reduce sensitivity.\n   */\n  set angularSensibility(value) {\n    const mouse = this.inputs.attached[\"mouse\"];\n    if (mouse) {\n      mouse.angularSensibility = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the forward move of the camera.\n   */\n  get keysUp() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysUp;\n    }\n    return [];\n  }\n  set keysUp(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysUp = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the upward move of the camera.\n   */\n  get keysUpward() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysUpward;\n    }\n    return [];\n  }\n  set keysUpward(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysUpward = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the backward move of the camera.\n   */\n  get keysDown() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysDown;\n    }\n    return [];\n  }\n  set keysDown(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysDown = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the downward move of the camera.\n   */\n  get keysDownward() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysDownward;\n    }\n    return [];\n  }\n  set keysDownward(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysDownward = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\n   */\n  get keysLeft() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysLeft;\n    }\n    return [];\n  }\n  set keysLeft(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysLeft = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\n   */\n  get keysRight() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysRight;\n    }\n    return [];\n  }\n  set keysRight(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysRight = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\n   */\n  get keysRotateLeft() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysRotateLeft;\n    }\n    return [];\n  }\n  set keysRotateLeft(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysRotateLeft = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\n   */\n  get keysRotateRight() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysRotateRight;\n    }\n    return [];\n  }\n  set keysRotateRight(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysRotateRight = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the up rotation move of the camera.\n   */\n  get keysRotateUp() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysRotateUp;\n    }\n    return [];\n  }\n  set keysRotateUp(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysRotateUp = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the down rotation move of the camera.\n   */\n  get keysRotateDown() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysRotateDown;\n    }\n    return [];\n  }\n  set keysRotateDown(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysRotateDown = value;\n    }\n  }\n  /**\n   * Instantiates a Free Camera.\n   * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\n   * Please consider using the new UniversalCamera instead as it adds more functionality like touch to this camera.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\n   * @param name Define the name of the camera in the scene\n   * @param position Define the start position of the camera in the scene\n   * @param scene Define the scene the camera belongs to\n   * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\n   */\n  constructor(name, position, scene, setActiveOnSceneIfNoneActive = true) {\n    super(name, position, scene, setActiveOnSceneIfNoneActive);\n    /**\n     * Define the collision ellipsoid of the camera.\n     * This is helpful to simulate a camera body like the player body around the camera\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#arcrotatecamera\n     */\n    this.ellipsoid = new Vector3(0.5, 1, 0.5);\n    /**\n     * Define an offset for the position of the ellipsoid around the camera.\n     * This can be helpful to determine the center of the body near the gravity center of the body\n     * instead of its head.\n     */\n    this.ellipsoidOffset = new Vector3(0, 0, 0);\n    /**\n     * Enable or disable collisions of the camera with the rest of the scene objects.\n     */\n    this.checkCollisions = false;\n    /**\n     * Enable or disable gravity on the camera.\n     */\n    this.applyGravity = false;\n    this._needMoveForGravity = false;\n    this._oldPosition = Vector3.Zero();\n    this._diffPosition = Vector3.Zero();\n    this._newPosition = Vector3.Zero();\n    // Collisions\n    this._collisionMask = -1;\n    this._onCollisionPositionChange = (collisionId, newPosition, collidedMesh = null) => {\n      this._newPosition.copyFrom(newPosition);\n      this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);\n      if (this._diffPosition.length() > Engine.CollisionsEpsilon) {\n        this.position.addToRef(this._diffPosition, this._deferredPositionUpdate);\n        if (!this._deferOnly) {\n          this.position.copyFrom(this._deferredPositionUpdate);\n        } else {\n          this._deferredUpdated = true;\n        }\n        // call onCollide, if defined. Note that in case of deferred update, the actual position change might happen in the next frame.\n        if (this.onCollide && collidedMesh) {\n          this.onCollide(collidedMesh);\n        }\n      }\n    };\n    this.inputs = new FreeCameraInputsManager(this);\n    this.inputs.addKeyboard().addMouse();\n  }\n  /**\n   * Attached controls to the current camera.\n   * @param ignored defines an ignored parameter kept for backward compatibility.\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n   */\n  attachControl(ignored, noPreventDefault) {\n    // eslint-disable-next-line prefer-rest-params\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    this.inputs.attachElement(noPreventDefault);\n  }\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n  detachControl() {\n    this.inputs.detachElement();\n    this.cameraDirection = new Vector3(0, 0, 0);\n    this.cameraRotation = new Vector2(0, 0);\n  }\n  /**\n   * Define a collision mask to limit the list of object the camera can collide with\n   */\n  get collisionMask() {\n    return this._collisionMask;\n  }\n  set collisionMask(mask) {\n    this._collisionMask = !isNaN(mask) ? mask : -1;\n  }\n  /**\n   * @internal\n   */\n  _collideWithWorld(displacement) {\n    let globalPosition;\n    if (this.parent) {\n      globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\n    } else {\n      globalPosition = this.position;\n    }\n    globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\n    this._oldPosition.addInPlace(this.ellipsoidOffset);\n    const coordinator = this.getScene().collisionCoordinator;\n    if (!this._collider) {\n      this._collider = coordinator.createCollider();\n    }\n    this._collider._radius = this.ellipsoid;\n    this._collider.collisionMask = this._collisionMask;\n    //no need for clone, as long as gravity is not on.\n    let actualDisplacement = displacement;\n    //add gravity to the direction to prevent the dual-collision checking\n    if (this.applyGravity) {\n      //this prevents mending with cameraDirection, a global variable of the free camera class.\n      actualDisplacement = displacement.add(this.getScene().gravity);\n    }\n    coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\n  }\n  /** @internal */\n  _checkInputs() {\n    if (!this._localDirection) {\n      this._localDirection = Vector3.Zero();\n      this._transformedDirection = Vector3.Zero();\n    }\n    this.inputs.checkInputs();\n    super._checkInputs();\n  }\n  /**\n   * Enable movement without a user input. This allows gravity to always be applied.\n   */\n  set needMoveForGravity(value) {\n    this._needMoveForGravity = value;\n  }\n  /**\n   * When true, gravity is applied whether there is user input or not.\n   */\n  get needMoveForGravity() {\n    return this._needMoveForGravity;\n  }\n  /** @internal */\n  _decideIfNeedsToMove() {\n    return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\n  }\n  /** @internal */\n  _updatePosition() {\n    if (this.checkCollisions && this.getScene().collisionsEnabled) {\n      this._collideWithWorld(this.cameraDirection);\n    } else {\n      super._updatePosition();\n    }\n  }\n  /**\n   * Destroy the camera and release the current resources hold by it.\n   */\n  dispose() {\n    this.inputs.clear();\n    super.dispose();\n  }\n  /**\n   * Gets the current object class name.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"FreeCamera\";\n  }\n}\n__decorate([serializeAsVector3()], FreeCamera.prototype, \"ellipsoid\", void 0);\n__decorate([serializeAsVector3()], FreeCamera.prototype, \"ellipsoidOffset\", void 0);\n__decorate([serialize()], FreeCamera.prototype, \"checkCollisions\", void 0);\n__decorate([serialize()], FreeCamera.prototype, \"applyGravity\", void 0);","map":{"version":3,"names":["serializeAsVector3","serialize","Vector3","Vector2","Engine","TargetCamera","FreeCameraInputsManager","Tools","FreeCamera","angularSensibility","mouse","inputs","attached","value","keysUp","keyboard","keysUpward","keysDown","keysDownward","keysLeft","keysRight","keysRotateLeft","keysRotateRight","keysRotateUp","keysRotateDown","constructor","name","position","scene","setActiveOnSceneIfNoneActive","ellipsoid","ellipsoidOffset","checkCollisions","applyGravity","_needMoveForGravity","_oldPosition","Zero","_diffPosition","_newPosition","_collisionMask","_onCollisionPositionChange","collisionId","newPosition","collidedMesh","copyFrom","subtractToRef","length","CollisionsEpsilon","addToRef","_deferredPositionUpdate","_deferOnly","_deferredUpdated","onCollide","addKeyboard","addMouse","attachControl","ignored","noPreventDefault","BackCompatCameraNoPreventDefault","arguments","attachElement","detachControl","detachElement","cameraDirection","cameraRotation","collisionMask","mask","isNaN","_collideWithWorld","displacement","globalPosition","parent","TransformCoordinates","getWorldMatrix","subtractFromFloatsToRef","y","addInPlace","coordinator","getScene","collisionCoordinator","_collider","createCollider","_radius","actualDisplacement","add","gravity","getNewPosition","uniqueId","_checkInputs","_localDirection","_transformedDirection","checkInputs","needMoveForGravity","_decideIfNeedsToMove","Math","abs","x","z","_updatePosition","collisionsEnabled","dispose","clear","getClassName","__decorate"],"sources":["../../../../dev/core/src/Cameras/freeCamera.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { serializeAsVector3, serialize } from \"../Misc/decorators\";\r\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport { FreeCameraInputsManager } from \"./freeCameraInputsManager\";\r\nimport type { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport type { FreeCameraKeyboardMoveInput } from \"../Cameras/Inputs/freeCameraKeyboardMoveInput\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\nimport type { Collider } from \"../Collisions/collider\";\r\n\r\n/**\r\n * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n * Please consider using the new UniversalCamera instead as it adds more functionality like the gamepad.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n */\r\nexport class FreeCamera extends TargetCamera {\r\n    /**\r\n     * Define the collision ellipsoid of the camera.\r\n     * This is helpful to simulate a camera body like the player body around the camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#arcrotatecamera\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoid = new Vector3(0.5, 1, 0.5);\r\n\r\n    /**\r\n     * Define an offset for the position of the ellipsoid around the camera.\r\n     * This can be helpful to determine the center of the body near the gravity center of the body\r\n     * instead of its head.\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoidOffset = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Enable or disable collisions of the camera with the rest of the scene objects.\r\n     */\r\n    @serialize()\r\n    public checkCollisions = false;\r\n\r\n    /**\r\n     * Enable or disable gravity on the camera.\r\n     */\r\n    @serialize()\r\n    public applyGravity = false;\r\n\r\n    /**\r\n     * Define the input manager associated to the camera.\r\n     */\r\n    public inputs: FreeCameraInputsManager;\r\n\r\n    /**\r\n     * Gets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public get angularSensibility(): number {\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            return mouse.angularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public set angularSensibility(value: number) {\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            mouse.angularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    public get keysUp(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUp(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the upward move of the camera.\r\n     */\r\n    public get keysUpward(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUpward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUpward(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUpward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    public get keysDown(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDown(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the downward move of the camera.\r\n     */\r\n    public get keysDownward(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDownward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDownward(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDownward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\r\n     */\r\n    public get keysLeft(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysLeft(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\r\n     */\r\n    public get keysRight(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRight(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\r\n     */\r\n    public get keysRotateLeft(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateLeft(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\r\n     */\r\n    public get keysRotateRight(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateRight(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the up rotation move of the camera.\r\n     */\r\n    public get keysRotateUp(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateUp(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the down rotation move of the camera.\r\n     */\r\n    public get keysRotateDown(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateDown(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Event raised when the camera collide with a mesh in the scene.\r\n     */\r\n    public onCollide: (collidedMesh: AbstractMesh) => void;\r\n\r\n    private _collider: Collider;\r\n    private _needMoveForGravity = false;\r\n    private _oldPosition = Vector3.Zero();\r\n    private _diffPosition = Vector3.Zero();\r\n    private _newPosition = Vector3.Zero();\r\n\r\n    /** @internal */\r\n    public _localDirection: Vector3;\r\n    /** @internal */\r\n    public _transformedDirection: Vector3;\r\n\r\n    /**\r\n     * Instantiates a Free Camera.\r\n     * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n     * Please consider using the new UniversalCamera instead as it adds more functionality like touch to this camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n        this.inputs = new FreeCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouse();\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * BACK COMPAT SIGNATURE ONLY.\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(ignored?: any, noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this.inputs.attachElement(noPreventDefault);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.inputs.detachElement();\r\n\r\n        this.cameraDirection = new Vector3(0, 0, 0);\r\n        this.cameraRotation = new Vector2(0, 0);\r\n    }\r\n\r\n    // Collisions\r\n    private _collisionMask = -1;\r\n\r\n    /**\r\n     * Define a collision mask to limit the list of object the camera can collide with\r\n     */\r\n    public get collisionMask(): number {\r\n        return this._collisionMask;\r\n    }\r\n\r\n    public set collisionMask(mask: number) {\r\n        this._collisionMask = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _collideWithWorld(displacement: Vector3): void {\r\n        let globalPosition: Vector3;\r\n\r\n        if (this.parent) {\r\n            globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\r\n        } else {\r\n            globalPosition = this.position;\r\n        }\r\n\r\n        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\r\n        this._oldPosition.addInPlace(this.ellipsoidOffset);\r\n\r\n        const coordinator = this.getScene().collisionCoordinator;\r\n        if (!this._collider) {\r\n            this._collider = coordinator.createCollider();\r\n        }\r\n\r\n        this._collider._radius = this.ellipsoid;\r\n        this._collider.collisionMask = this._collisionMask;\r\n\r\n        //no need for clone, as long as gravity is not on.\r\n        let actualDisplacement = displacement;\r\n\r\n        //add gravity to the direction to prevent the dual-collision checking\r\n        if (this.applyGravity) {\r\n            //this prevents mending with cameraDirection, a global variable of the free camera class.\r\n            actualDisplacement = displacement.add(this.getScene().gravity);\r\n        }\r\n\r\n        coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\r\n    }\r\n\r\n    private _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh> = null) => {\r\n        this._newPosition.copyFrom(newPosition);\r\n\r\n        this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);\r\n\r\n        if (this._diffPosition.length() > Engine.CollisionsEpsilon) {\r\n            this.position.addToRef(this._diffPosition, this._deferredPositionUpdate);\r\n            if (!this._deferOnly) {\r\n                this.position.copyFrom(this._deferredPositionUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n            // call onCollide, if defined. Note that in case of deferred update, the actual position change might happen in the next frame.\r\n            if (this.onCollide && collidedMesh) {\r\n                this.onCollide(collidedMesh);\r\n            }\r\n        }\r\n    };\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        if (!this._localDirection) {\r\n            this._localDirection = Vector3.Zero();\r\n            this._transformedDirection = Vector3.Zero();\r\n        }\r\n\r\n        this.inputs.checkInputs();\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    /**\r\n     * Enable movement without a user input. This allows gravity to always be applied.\r\n     */\r\n    public set needMoveForGravity(value: boolean) {\r\n        this._needMoveForGravity = value;\r\n    }\r\n\r\n    /**\r\n     * When true, gravity is applied whether there is user input or not.\r\n     */\r\n    public get needMoveForGravity(): boolean {\r\n        return this._needMoveForGravity;\r\n    }\r\n\r\n    /** @internal */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public _updatePosition(): void {\r\n        if (this.checkCollisions && this.getScene().collisionsEnabled) {\r\n            this._collideWithWorld(this.cameraDirection);\r\n        } else {\r\n            super._updatePosition();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy the camera and release the current resources hold by it.\r\n     */\r\n    public dispose(): void {\r\n        this.inputs.clear();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCamera\";\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}