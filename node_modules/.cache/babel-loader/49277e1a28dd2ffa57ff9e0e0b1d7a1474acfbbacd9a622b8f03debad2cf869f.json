{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { MultiMaterial } from \"../Materials/multiMaterial.js\";\nimport { SerializationHelper } from \"./decorators.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nlet serializedGeometries = [];\nconst SerializeGeometry = (geometry, serializationGeometries) => {\n  if (geometry.doNotSerialize) {\n    return;\n  }\n  serializationGeometries.vertexData.push(geometry.serializeVerticeData());\n  serializedGeometries[geometry.id] = true;\n};\nconst SerializeMesh = (mesh, serializationScene) => {\n  const serializationObject = {};\n  // Geometry\n  const geometry = mesh._geometry;\n  if (geometry) {\n    if (!mesh.getScene().getGeometryById(geometry.id)) {\n      // Geometry was in the memory but not added to the scene, nevertheless it's better to serialize to be able to reload the mesh with its geometry\n      SerializeGeometry(geometry, serializationScene.geometries);\n    }\n  }\n  // Custom\n  if (mesh.serialize) {\n    mesh.serialize(serializationObject);\n  }\n  return serializationObject;\n};\nconst FinalizeSingleNode = (node, serializationObject) => {\n  if (node._isMesh) {\n    const mesh = node;\n    //only works if the mesh is already loaded\n    if (mesh.delayLoadState === 1 || mesh.delayLoadState === 0) {\n      const serializeMaterial = material => {\n        serializationObject.materials = serializationObject.materials || [];\n        if (mesh.material && !serializationObject.materials.some(mat => mat.id === mesh.material.id)) {\n          serializationObject.materials.push(material.serialize());\n        }\n      };\n      //serialize material\n      if (mesh.material && !mesh.material.doNotSerialize) {\n        if (mesh.material instanceof MultiMaterial) {\n          serializationObject.multiMaterials = serializationObject.multiMaterials || [];\n          if (!serializationObject.multiMaterials.some(mat => mat.id === mesh.material.id)) {\n            serializationObject.multiMaterials.push(mesh.material.serialize());\n            for (const submaterial of mesh.material.subMaterials) {\n              if (submaterial) {\n                serializeMaterial(submaterial);\n              }\n            }\n          }\n        } else {\n          serializeMaterial(mesh.material);\n        }\n      } else if (!mesh.material) {\n        serializeMaterial(mesh.getScene().defaultMaterial);\n      }\n      //serialize geometry\n      const geometry = mesh._geometry;\n      if (geometry) {\n        if (!serializationObject.geometries) {\n          serializationObject.geometries = {};\n          serializationObject.geometries.boxes = [];\n          serializationObject.geometries.spheres = [];\n          serializationObject.geometries.cylinders = [];\n          serializationObject.geometries.toruses = [];\n          serializationObject.geometries.grounds = [];\n          serializationObject.geometries.planes = [];\n          serializationObject.geometries.torusKnots = [];\n          serializationObject.geometries.vertexData = [];\n        }\n        SerializeGeometry(geometry, serializationObject.geometries);\n      }\n      // Skeletons\n      if (mesh.skeleton && !mesh.skeleton.doNotSerialize) {\n        serializationObject.skeletons = serializationObject.skeletons || [];\n        serializationObject.skeletons.push(mesh.skeleton.serialize());\n      }\n      //serialize the actual mesh\n      serializationObject.meshes = serializationObject.meshes || [];\n      serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));\n    }\n  } else if (node.getClassName() === \"TransformNode\") {\n    const transformNode = node;\n    serializationObject.transformNodes.push(transformNode.serialize());\n  } else if (node.getClassName().indexOf(\"Camera\") !== -1) {\n    const camera = node;\n    serializationObject.cameras.push(camera.serialize());\n  } else if (node.getClassName().indexOf(\"Light\") !== -1) {\n    const light = node;\n    serializationObject.lights.push(light.serialize());\n  }\n};\n/**\n * Class used to serialize a scene into a string\n */\nexport class SceneSerializer {\n  /**\n   * Clear cache used by a previous serialization\n   */\n  static ClearCache() {\n    serializedGeometries = [];\n  }\n  /**\n   * Serialize a scene into a JSON compatible object\n   * Note that if the current engine does not support synchronous texture reading (like WebGPU), you should use SerializeAsync instead\n   * as else you may not retrieve the proper base64 encoded texture data (when using the Texture.ForceSerializeBuffers flag)\n   * @param scene defines the scene to serialize\n   * @returns a JSON compatible object\n   */\n  static Serialize(scene) {\n    return SceneSerializer._Serialize(scene);\n  }\n  static _Serialize(scene, checkSyncReadSupported = true) {\n    const serializationObject = {};\n    if (checkSyncReadSupported && !scene.getEngine()._features.supportSyncTextureRead && Texture.ForceSerializeBuffers) {\n      console.warn(\"The serialization object may not contain the proper base64 encoded texture data! You should use the SerializeAsync method instead.\");\n    }\n    SceneSerializer.ClearCache();\n    // Scene\n    serializationObject.useDelayedTextureLoading = scene.useDelayedTextureLoading;\n    serializationObject.autoClear = scene.autoClear;\n    serializationObject.clearColor = scene.clearColor.asArray();\n    serializationObject.ambientColor = scene.ambientColor.asArray();\n    serializationObject.gravity = scene.gravity.asArray();\n    serializationObject.collisionsEnabled = scene.collisionsEnabled;\n    serializationObject.useRightHandedSystem = scene.useRightHandedSystem;\n    // Fog\n    if (scene.fogMode && scene.fogMode !== 0) {\n      serializationObject.fogMode = scene.fogMode;\n      serializationObject.fogColor = scene.fogColor.asArray();\n      serializationObject.fogStart = scene.fogStart;\n      serializationObject.fogEnd = scene.fogEnd;\n      serializationObject.fogDensity = scene.fogDensity;\n    }\n    //Physics\n    if (scene.isPhysicsEnabled && scene.isPhysicsEnabled()) {\n      const physicEngine = scene.getPhysicsEngine();\n      if (physicEngine) {\n        serializationObject.physicsEnabled = true;\n        serializationObject.physicsGravity = physicEngine.gravity.asArray();\n        serializationObject.physicsEngine = physicEngine.getPhysicsPluginName();\n      }\n    }\n    // Metadata\n    if (scene.metadata) {\n      serializationObject.metadata = scene.metadata;\n    }\n    // Morph targets\n    serializationObject.morphTargetManagers = [];\n    for (const abstractMesh of scene.meshes) {\n      const manager = abstractMesh.morphTargetManager;\n      if (manager) {\n        serializationObject.morphTargetManagers.push(manager.serialize());\n      }\n    }\n    // Lights\n    serializationObject.lights = [];\n    let index;\n    let light;\n    for (index = 0; index < scene.lights.length; index++) {\n      light = scene.lights[index];\n      if (!light.doNotSerialize) {\n        serializationObject.lights.push(light.serialize());\n      }\n    }\n    // Cameras\n    serializationObject.cameras = [];\n    for (index = 0; index < scene.cameras.length; index++) {\n      const camera = scene.cameras[index];\n      if (!camera.doNotSerialize) {\n        serializationObject.cameras.push(camera.serialize());\n      }\n    }\n    if (scene.activeCamera) {\n      serializationObject.activeCameraID = scene.activeCamera.id;\n    }\n    // Animations\n    SerializationHelper.AppendSerializedAnimations(scene, serializationObject);\n    // Animation Groups\n    if (scene.animationGroups && scene.animationGroups.length > 0) {\n      serializationObject.animationGroups = [];\n      for (let animationGroupIndex = 0; animationGroupIndex < scene.animationGroups.length; animationGroupIndex++) {\n        const animationGroup = scene.animationGroups[animationGroupIndex];\n        serializationObject.animationGroups.push(animationGroup.serialize());\n      }\n    }\n    // Reflection probes\n    if (scene.reflectionProbes && scene.reflectionProbes.length > 0) {\n      serializationObject.reflectionProbes = [];\n      for (index = 0; index < scene.reflectionProbes.length; index++) {\n        const reflectionProbe = scene.reflectionProbes[index];\n        serializationObject.reflectionProbes.push(reflectionProbe.serialize());\n      }\n    }\n    // Materials\n    serializationObject.materials = [];\n    serializationObject.multiMaterials = [];\n    let material;\n    for (index = 0; index < scene.materials.length; index++) {\n      material = scene.materials[index];\n      if (!material.doNotSerialize) {\n        serializationObject.materials.push(material.serialize());\n      }\n    }\n    // MultiMaterials\n    serializationObject.multiMaterials = [];\n    for (index = 0; index < scene.multiMaterials.length; index++) {\n      const multiMaterial = scene.multiMaterials[index];\n      serializationObject.multiMaterials.push(multiMaterial.serialize());\n    }\n    // Environment texture\n    if (scene.environmentTexture) {\n      if (scene.environmentTexture._files) {\n        serializationObject.environmentTexture = scene.environmentTexture.serialize();\n      } else {\n        serializationObject.environmentTexture = scene.environmentTexture.name;\n        serializationObject.environmentTextureRotationY = scene.environmentTexture.rotationY;\n      }\n    }\n    // Environment Intensity\n    serializationObject.environmentIntensity = scene.environmentIntensity;\n    // Skeletons\n    serializationObject.skeletons = [];\n    for (index = 0; index < scene.skeletons.length; index++) {\n      const skeleton = scene.skeletons[index];\n      if (!skeleton.doNotSerialize) {\n        serializationObject.skeletons.push(skeleton.serialize());\n      }\n    }\n    // Transform nodes\n    serializationObject.transformNodes = [];\n    for (index = 0; index < scene.transformNodes.length; index++) {\n      if (!scene.transformNodes[index].doNotSerialize) {\n        serializationObject.transformNodes.push(scene.transformNodes[index].serialize());\n      }\n    }\n    // Geometries\n    serializationObject.geometries = {};\n    serializationObject.geometries.boxes = [];\n    serializationObject.geometries.spheres = [];\n    serializationObject.geometries.cylinders = [];\n    serializationObject.geometries.toruses = [];\n    serializationObject.geometries.grounds = [];\n    serializationObject.geometries.planes = [];\n    serializationObject.geometries.torusKnots = [];\n    serializationObject.geometries.vertexData = [];\n    serializedGeometries = [];\n    const geometries = scene.getGeometries();\n    for (index = 0; index < geometries.length; index++) {\n      const geometry = geometries[index];\n      if (geometry.isReady()) {\n        SerializeGeometry(geometry, serializationObject.geometries);\n      }\n    }\n    // Meshes\n    serializationObject.meshes = [];\n    for (index = 0; index < scene.meshes.length; index++) {\n      const abstractMesh = scene.meshes[index];\n      if (abstractMesh instanceof Mesh) {\n        const mesh = abstractMesh;\n        if (!mesh.doNotSerialize) {\n          if (mesh.delayLoadState === 1 || mesh.delayLoadState === 0) {\n            serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));\n          }\n        }\n      }\n    }\n    // Particles Systems\n    serializationObject.particleSystems = [];\n    for (index = 0; index < scene.particleSystems.length; index++) {\n      serializationObject.particleSystems.push(scene.particleSystems[index].serialize(false));\n    }\n    // Post processes\n    serializationObject.postProcesses = [];\n    for (index = 0; index < scene.postProcesses.length; index++) {\n      serializationObject.postProcesses.push(scene.postProcesses[index].serialize());\n    }\n    // Action Manager\n    if (scene.actionManager) {\n      serializationObject.actions = scene.actionManager.serialize(\"scene\");\n    }\n    // Components\n    for (const component of scene._serializableComponents) {\n      component.serialize(serializationObject);\n    }\n    return serializationObject;\n  }\n  /**\n   * Serialize a scene into a JSON compatible object\n   * @param scene defines the scene to serialize\n   * @returns a JSON promise compatible object\n   */\n  static SerializeAsync(scene) {\n    const serializationObject = SceneSerializer._Serialize(scene, false);\n    const promises = [];\n    this._CollectPromises(serializationObject, promises);\n    return Promise.all(promises).then(() => serializationObject);\n  }\n  static _CollectPromises(obj, promises) {\n    if (Array.isArray(obj)) {\n      for (let i = 0; i < obj.length; ++i) {\n        const o = obj[i];\n        if (o instanceof Promise) {\n          promises.push(o.then(res => obj[i] = res));\n        } else if (o instanceof Object || Array.isArray(o)) {\n          this._CollectPromises(o, promises);\n        }\n      }\n    } else if (obj instanceof Object) {\n      for (const name in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, name)) {\n          const o = obj[name];\n          if (o instanceof Promise) {\n            promises.push(o.then(res => obj[name] = res));\n          } else if (o instanceof Object || Array.isArray(o)) {\n            this._CollectPromises(o, promises);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Serialize a mesh into a JSON compatible object\n   * @param toSerialize defines the mesh to serialize\n   * @param withParents defines if parents must be serialized as well\n   * @param withChildren defines if children must be serialized as well\n   * @returns a JSON compatible object\n   */\n  static SerializeMesh(toSerialize /* Mesh || Mesh[] */, withParents = false, withChildren = false) {\n    const serializationObject = {};\n    serializationObject.meshes = [];\n    serializationObject.transformNodes = [];\n    serializationObject.cameras = [];\n    serializationObject.lights = [];\n    SceneSerializer.ClearCache();\n    toSerialize = toSerialize instanceof Array ? toSerialize : [toSerialize];\n    if (withParents || withChildren) {\n      //deliberate for loop! not for each, appended should be processed as well.\n      for (let i = 0; i < toSerialize.length; ++i) {\n        if (withChildren) {\n          toSerialize[i].getDescendants().forEach(node => {\n            if (toSerialize.indexOf(node) < 0 && !node.doNotSerialize) {\n              toSerialize.push(node);\n            }\n          });\n        }\n        //make sure the array doesn't contain the object already\n        if (withParents && toSerialize[i].parent && toSerialize.indexOf(toSerialize[i].parent) < 0 && !toSerialize[i].parent.doNotSerialize) {\n          toSerialize.push(toSerialize[i].parent);\n        }\n      }\n    }\n    toSerialize.forEach(mesh => {\n      FinalizeSingleNode(mesh, serializationObject);\n    });\n    return serializationObject;\n  }\n}","map":{"version":3,"names":["Mesh","MultiMaterial","SerializationHelper","Texture","serializedGeometries","SerializeGeometry","geometry","serializationGeometries","doNotSerialize","vertexData","push","serializeVerticeData","id","SerializeMesh","mesh","serializationScene","serializationObject","_geometry","getScene","getGeometryById","geometries","serialize","FinalizeSingleNode","node","_isMesh","delayLoadState","serializeMaterial","material","materials","some","mat","multiMaterials","submaterial","subMaterials","defaultMaterial","boxes","spheres","cylinders","toruses","grounds","planes","torusKnots","skeleton","skeletons","meshes","getClassName","transformNode","transformNodes","indexOf","camera","cameras","light","lights","SceneSerializer","ClearCache","Serialize","scene","_Serialize","checkSyncReadSupported","getEngine","_features","supportSyncTextureRead","ForceSerializeBuffers","console","warn","useDelayedTextureLoading","autoClear","clearColor","asArray","ambientColor","gravity","collisionsEnabled","useRightHandedSystem","fogMode","fogColor","fogStart","fogEnd","fogDensity","isPhysicsEnabled","physicEngine","getPhysicsEngine","physicsEnabled","physicsGravity","physicsEngine","getPhysicsPluginName","metadata","morphTargetManagers","abstractMesh","manager","morphTargetManager","index","length","activeCamera","activeCameraID","AppendSerializedAnimations","animationGroups","animationGroupIndex","animationGroup","reflectionProbes","reflectionProbe","multiMaterial","environmentTexture","_files","name","environmentTextureRotationY","rotationY","environmentIntensity","getGeometries","isReady","particleSystems","postProcesses","actionManager","actions","component","_serializableComponents","SerializeAsync","promises","_CollectPromises","Promise","all","then","obj","Array","isArray","i","o","res","Object","prototype","hasOwnProperty","call","toSerialize","withParents","withChildren","getDescendants","forEach","parent"],"sources":["../../../../dev/core/src/Misc/sceneSerializer.ts"],"sourcesContent":["import type { Geometry } from \"../Meshes/geometry\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { MultiMaterial } from \"../Materials/multiMaterial\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport { SerializationHelper } from \"./decorators\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { CubeTexture } from \"../Materials/Textures/cubeTexture\";\r\nimport type { Node } from \"../node\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\n\r\nlet serializedGeometries: Geometry[] = [];\r\nconst SerializeGeometry = (geometry: Geometry, serializationGeometries: any): any => {\r\n    if (geometry.doNotSerialize) {\r\n        return;\r\n    }\r\n\r\n    serializationGeometries.vertexData.push(geometry.serializeVerticeData());\r\n\r\n    (<any>serializedGeometries)[geometry.id] = true;\r\n};\r\n\r\nconst SerializeMesh = (mesh: Mesh, serializationScene: any): any => {\r\n    const serializationObject: any = {};\r\n\r\n    // Geometry\r\n    const geometry = mesh._geometry;\r\n    if (geometry) {\r\n        if (!mesh.getScene().getGeometryById(geometry.id)) {\r\n            // Geometry was in the memory but not added to the scene, nevertheless it's better to serialize to be able to reload the mesh with its geometry\r\n            SerializeGeometry(geometry, serializationScene.geometries);\r\n        }\r\n    }\r\n\r\n    // Custom\r\n    if (mesh.serialize) {\r\n        mesh.serialize(serializationObject);\r\n    }\r\n\r\n    return serializationObject;\r\n};\r\n\r\nconst FinalizeSingleNode = (node: Node, serializationObject: any) => {\r\n    if ((node as Mesh)._isMesh) {\r\n        const mesh = node as Mesh;\r\n        //only works if the mesh is already loaded\r\n        if (mesh.delayLoadState === Constants.DELAYLOADSTATE_LOADED || mesh.delayLoadState === Constants.DELAYLOADSTATE_NONE) {\r\n            const serializeMaterial = (material: Material) => {\r\n                serializationObject.materials = serializationObject.materials || [];\r\n                if (mesh.material && !serializationObject.materials.some((mat: Material) => mat.id === (<Material>mesh.material).id)) {\r\n                    serializationObject.materials.push(material.serialize());\r\n                }\r\n            };\r\n\r\n            //serialize material\r\n            if (mesh.material && !mesh.material.doNotSerialize) {\r\n                if (mesh.material instanceof MultiMaterial) {\r\n                    serializationObject.multiMaterials = serializationObject.multiMaterials || [];\r\n                    if (!serializationObject.multiMaterials.some((mat: Material) => mat.id === (<Material>mesh.material).id)) {\r\n                        serializationObject.multiMaterials.push(mesh.material.serialize());\r\n                        for (const submaterial of mesh.material.subMaterials) {\r\n                            if (submaterial) {\r\n                                serializeMaterial(submaterial);\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    serializeMaterial(mesh.material);\r\n                }\r\n            } else if (!mesh.material) {\r\n                serializeMaterial(mesh.getScene().defaultMaterial);\r\n            }\r\n\r\n            //serialize geometry\r\n            const geometry = mesh._geometry;\r\n            if (geometry) {\r\n                if (!serializationObject.geometries) {\r\n                    serializationObject.geometries = {};\r\n\r\n                    serializationObject.geometries.boxes = [];\r\n                    serializationObject.geometries.spheres = [];\r\n                    serializationObject.geometries.cylinders = [];\r\n                    serializationObject.geometries.toruses = [];\r\n                    serializationObject.geometries.grounds = [];\r\n                    serializationObject.geometries.planes = [];\r\n                    serializationObject.geometries.torusKnots = [];\r\n                    serializationObject.geometries.vertexData = [];\r\n                }\r\n\r\n                SerializeGeometry(geometry, serializationObject.geometries);\r\n            }\r\n            // Skeletons\r\n            if (mesh.skeleton && !mesh.skeleton.doNotSerialize) {\r\n                serializationObject.skeletons = serializationObject.skeletons || [];\r\n                serializationObject.skeletons.push(mesh.skeleton.serialize());\r\n            }\r\n\r\n            //serialize the actual mesh\r\n            serializationObject.meshes = serializationObject.meshes || [];\r\n            serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));\r\n        }\r\n    } else if (node.getClassName() === \"TransformNode\") {\r\n        const transformNode = node as TransformNode;\r\n        serializationObject.transformNodes.push(transformNode.serialize());\r\n    } else if (node.getClassName().indexOf(\"Camera\") !== -1) {\r\n        const camera = node as Camera;\r\n        serializationObject.cameras.push(camera.serialize());\r\n    } else if (node.getClassName().indexOf(\"Light\") !== -1) {\r\n        const light = node as Light;\r\n        serializationObject.lights.push(light.serialize());\r\n    }\r\n};\r\n\r\n/**\r\n * Class used to serialize a scene into a string\r\n */\r\nexport class SceneSerializer {\r\n    /**\r\n     * Clear cache used by a previous serialization\r\n     */\r\n    public static ClearCache(): void {\r\n        serializedGeometries = [];\r\n    }\r\n\r\n    /**\r\n     * Serialize a scene into a JSON compatible object\r\n     * Note that if the current engine does not support synchronous texture reading (like WebGPU), you should use SerializeAsync instead\r\n     * as else you may not retrieve the proper base64 encoded texture data (when using the Texture.ForceSerializeBuffers flag)\r\n     * @param scene defines the scene to serialize\r\n     * @returns a JSON compatible object\r\n     */\r\n    public static Serialize(scene: Scene): any {\r\n        return SceneSerializer._Serialize(scene);\r\n    }\r\n\r\n    private static _Serialize(scene: Scene, checkSyncReadSupported = true): any {\r\n        const serializationObject: any = {};\r\n\r\n        if (checkSyncReadSupported && !scene.getEngine()._features.supportSyncTextureRead && Texture.ForceSerializeBuffers) {\r\n            console.warn(\"The serialization object may not contain the proper base64 encoded texture data! You should use the SerializeAsync method instead.\");\r\n        }\r\n\r\n        SceneSerializer.ClearCache();\r\n\r\n        // Scene\r\n        serializationObject.useDelayedTextureLoading = scene.useDelayedTextureLoading;\r\n        serializationObject.autoClear = scene.autoClear;\r\n        serializationObject.clearColor = scene.clearColor.asArray();\r\n        serializationObject.ambientColor = scene.ambientColor.asArray();\r\n        serializationObject.gravity = scene.gravity.asArray();\r\n        serializationObject.collisionsEnabled = scene.collisionsEnabled;\r\n        serializationObject.useRightHandedSystem = scene.useRightHandedSystem;\r\n\r\n        // Fog\r\n        if (scene.fogMode && scene.fogMode !== 0) {\r\n            serializationObject.fogMode = scene.fogMode;\r\n            serializationObject.fogColor = scene.fogColor.asArray();\r\n            serializationObject.fogStart = scene.fogStart;\r\n            serializationObject.fogEnd = scene.fogEnd;\r\n            serializationObject.fogDensity = scene.fogDensity;\r\n        }\r\n\r\n        //Physics\r\n        if (scene.isPhysicsEnabled && scene.isPhysicsEnabled()) {\r\n            const physicEngine = scene.getPhysicsEngine();\r\n\r\n            if (physicEngine) {\r\n                serializationObject.physicsEnabled = true;\r\n                serializationObject.physicsGravity = physicEngine.gravity.asArray();\r\n                serializationObject.physicsEngine = physicEngine.getPhysicsPluginName();\r\n            }\r\n        }\r\n\r\n        // Metadata\r\n        if (scene.metadata) {\r\n            serializationObject.metadata = scene.metadata;\r\n        }\r\n\r\n        // Morph targets\r\n        serializationObject.morphTargetManagers = [];\r\n        for (const abstractMesh of scene.meshes) {\r\n            const manager = (<Mesh>abstractMesh).morphTargetManager;\r\n\r\n            if (manager) {\r\n                serializationObject.morphTargetManagers.push(manager.serialize());\r\n            }\r\n        }\r\n\r\n        // Lights\r\n        serializationObject.lights = [];\r\n        let index: number;\r\n        let light: Light;\r\n        for (index = 0; index < scene.lights.length; index++) {\r\n            light = scene.lights[index];\r\n\r\n            if (!light.doNotSerialize) {\r\n                serializationObject.lights.push(light.serialize());\r\n            }\r\n        }\r\n\r\n        // Cameras\r\n        serializationObject.cameras = [];\r\n        for (index = 0; index < scene.cameras.length; index++) {\r\n            const camera = scene.cameras[index];\r\n\r\n            if (!camera.doNotSerialize) {\r\n                serializationObject.cameras.push(camera.serialize());\r\n            }\r\n        }\r\n\r\n        if (scene.activeCamera) {\r\n            serializationObject.activeCameraID = scene.activeCamera.id;\r\n        }\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(scene, serializationObject);\r\n\r\n        // Animation Groups\r\n        if (scene.animationGroups && scene.animationGroups.length > 0) {\r\n            serializationObject.animationGroups = [];\r\n            for (let animationGroupIndex = 0; animationGroupIndex < scene.animationGroups.length; animationGroupIndex++) {\r\n                const animationGroup = scene.animationGroups[animationGroupIndex];\r\n\r\n                serializationObject.animationGroups.push(animationGroup.serialize());\r\n            }\r\n        }\r\n\r\n        // Reflection probes\r\n        if (scene.reflectionProbes && scene.reflectionProbes.length > 0) {\r\n            serializationObject.reflectionProbes = [];\r\n\r\n            for (index = 0; index < scene.reflectionProbes.length; index++) {\r\n                const reflectionProbe = scene.reflectionProbes[index];\r\n                serializationObject.reflectionProbes.push(reflectionProbe.serialize());\r\n            }\r\n        }\r\n\r\n        // Materials\r\n        serializationObject.materials = [];\r\n        serializationObject.multiMaterials = [];\r\n        let material: Material;\r\n        for (index = 0; index < scene.materials.length; index++) {\r\n            material = scene.materials[index];\r\n            if (!material.doNotSerialize) {\r\n                serializationObject.materials.push(material.serialize());\r\n            }\r\n        }\r\n\r\n        // MultiMaterials\r\n        serializationObject.multiMaterials = [];\r\n        for (index = 0; index < scene.multiMaterials.length; index++) {\r\n            const multiMaterial = scene.multiMaterials[index];\r\n            serializationObject.multiMaterials.push(multiMaterial.serialize());\r\n        }\r\n\r\n        // Environment texture\r\n        if (scene.environmentTexture) {\r\n            if ((scene.environmentTexture as CubeTexture)._files) {\r\n                serializationObject.environmentTexture = scene.environmentTexture.serialize();\r\n            } else {\r\n                serializationObject.environmentTexture = scene.environmentTexture.name;\r\n                serializationObject.environmentTextureRotationY = (scene.environmentTexture as CubeTexture).rotationY;\r\n            }\r\n        }\r\n\r\n        // Environment Intensity\r\n        serializationObject.environmentIntensity = scene.environmentIntensity;\r\n\r\n        // Skeletons\r\n        serializationObject.skeletons = [];\r\n        for (index = 0; index < scene.skeletons.length; index++) {\r\n            const skeleton = scene.skeletons[index];\r\n            if (!skeleton.doNotSerialize) {\r\n                serializationObject.skeletons.push(skeleton.serialize());\r\n            }\r\n        }\r\n\r\n        // Transform nodes\r\n        serializationObject.transformNodes = [];\r\n        for (index = 0; index < scene.transformNodes.length; index++) {\r\n            if (!scene.transformNodes[index].doNotSerialize) {\r\n                serializationObject.transformNodes.push(scene.transformNodes[index].serialize());\r\n            }\r\n        }\r\n\r\n        // Geometries\r\n        serializationObject.geometries = {};\r\n\r\n        serializationObject.geometries.boxes = [];\r\n        serializationObject.geometries.spheres = [];\r\n        serializationObject.geometries.cylinders = [];\r\n        serializationObject.geometries.toruses = [];\r\n        serializationObject.geometries.grounds = [];\r\n        serializationObject.geometries.planes = [];\r\n        serializationObject.geometries.torusKnots = [];\r\n        serializationObject.geometries.vertexData = [];\r\n\r\n        serializedGeometries = [];\r\n        const geometries = scene.getGeometries();\r\n        for (index = 0; index < geometries.length; index++) {\r\n            const geometry = geometries[index];\r\n\r\n            if (geometry.isReady()) {\r\n                SerializeGeometry(geometry, serializationObject.geometries);\r\n            }\r\n        }\r\n\r\n        // Meshes\r\n        serializationObject.meshes = [];\r\n        for (index = 0; index < scene.meshes.length; index++) {\r\n            const abstractMesh = scene.meshes[index];\r\n\r\n            if (abstractMesh instanceof Mesh) {\r\n                const mesh = abstractMesh;\r\n                if (!mesh.doNotSerialize) {\r\n                    if (mesh.delayLoadState === Constants.DELAYLOADSTATE_LOADED || mesh.delayLoadState === Constants.DELAYLOADSTATE_NONE) {\r\n                        serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Particles Systems\r\n        serializationObject.particleSystems = [];\r\n        for (index = 0; index < scene.particleSystems.length; index++) {\r\n            serializationObject.particleSystems.push(scene.particleSystems[index].serialize(false));\r\n        }\r\n\r\n        // Post processes\r\n        serializationObject.postProcesses = [];\r\n        for (index = 0; index < scene.postProcesses.length; index++) {\r\n            serializationObject.postProcesses.push(scene.postProcesses[index].serialize());\r\n        }\r\n\r\n        // Action Manager\r\n        if (scene.actionManager) {\r\n            serializationObject.actions = scene.actionManager.serialize(\"scene\");\r\n        }\r\n\r\n        // Components\r\n        for (const component of scene._serializableComponents) {\r\n            component.serialize(serializationObject);\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Serialize a scene into a JSON compatible object\r\n     * @param scene defines the scene to serialize\r\n     * @returns a JSON promise compatible object\r\n     */\r\n    public static SerializeAsync(scene: Scene): Promise<any> {\r\n        const serializationObject = SceneSerializer._Serialize(scene, false);\r\n\r\n        const promises: Array<Promise<any>> = [];\r\n\r\n        this._CollectPromises(serializationObject, promises);\r\n\r\n        return Promise.all(promises).then(() => serializationObject);\r\n    }\r\n\r\n    private static _CollectPromises(obj: any, promises: Array<Promise<any>>): void {\r\n        if (Array.isArray(obj)) {\r\n            for (let i = 0; i < obj.length; ++i) {\r\n                const o = obj[i];\r\n                if (o instanceof Promise) {\r\n                    promises.push(o.then((res: any) => (obj[i] = res)));\r\n                } else if (o instanceof Object || Array.isArray(o)) {\r\n                    this._CollectPromises(o, promises);\r\n                }\r\n            }\r\n        } else if (obj instanceof Object) {\r\n            for (const name in obj) {\r\n                if (Object.prototype.hasOwnProperty.call(obj, name)) {\r\n                    const o = obj[name];\r\n                    if (o instanceof Promise) {\r\n                        promises.push(o.then((res: any) => (obj[name] = res)));\r\n                    } else if (o instanceof Object || Array.isArray(o)) {\r\n                        this._CollectPromises(o, promises);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serialize a mesh into a JSON compatible object\r\n     * @param toSerialize defines the mesh to serialize\r\n     * @param withParents defines if parents must be serialized as well\r\n     * @param withChildren defines if children must be serialized as well\r\n     * @returns a JSON compatible object\r\n     */\r\n    public static SerializeMesh(toSerialize: any /* Mesh || Mesh[] */, withParents: boolean = false, withChildren: boolean = false): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.meshes = [];\r\n        serializationObject.transformNodes = [];\r\n        serializationObject.cameras = [];\r\n        serializationObject.lights = [];\r\n\r\n        SceneSerializer.ClearCache();\r\n\r\n        toSerialize = toSerialize instanceof Array ? toSerialize : [toSerialize];\r\n\r\n        if (withParents || withChildren) {\r\n            //deliberate for loop! not for each, appended should be processed as well.\r\n            for (let i = 0; i < toSerialize.length; ++i) {\r\n                if (withChildren) {\r\n                    toSerialize[i].getDescendants().forEach((node: Node) => {\r\n                        if (toSerialize.indexOf(node) < 0 && !node.doNotSerialize) {\r\n                            toSerialize.push(node);\r\n                        }\r\n                    });\r\n                }\r\n                //make sure the array doesn't contain the object already\r\n                if (withParents && toSerialize[i].parent && toSerialize.indexOf(toSerialize[i].parent) < 0 && !toSerialize[i].parent.doNotSerialize) {\r\n                    toSerialize.push(toSerialize[i].parent);\r\n                }\r\n            }\r\n        }\r\n\r\n        toSerialize.forEach((mesh: Node) => {\r\n            FinalizeSingleNode(mesh, serializationObject);\r\n        });\r\n\r\n        return serializationObject;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}