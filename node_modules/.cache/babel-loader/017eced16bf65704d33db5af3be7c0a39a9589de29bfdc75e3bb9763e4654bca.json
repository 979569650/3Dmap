{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { NodeMaterialBlock } from \"../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\n/**\n * Block used to transform a vector (2, 3 or 4) with a matrix. It will generate a Vector4\n */\nexport class TransformBlock extends NodeMaterialBlock {\n  /**\n   * Creates a new TransformBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Neutral);\n    /**\n     * Defines the value to use to complement W value to transform it to a Vector4\n     */\n    this.complementW = 1;\n    /**\n     * Defines the value to use to complement z value to transform it to a Vector4\n     */\n    this.complementZ = 0;\n    this.target = NodeMaterialBlockTargets.Vertex;\n    this.registerInput(\"vector\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\n    this.registerInput(\"transform\", NodeMaterialBlockConnectionPointTypes.Matrix);\n    this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector4);\n    this.registerOutput(\"xyz\", NodeMaterialBlockConnectionPointTypes.Vector3);\n    this._inputs[0].onConnectionObservable.add(other => {\n      if (other.ownerBlock.isInput) {\n        const otherAsInput = other.ownerBlock;\n        if (otherAsInput.name === \"normal\" || otherAsInput.name === \"tangent\") {\n          this.complementW = 0;\n        }\n      }\n    });\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"TransformBlock\";\n  }\n  /**\n   * Gets the vector input\n   */\n  get vector() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the output component\n   */\n  get output() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the xyz output component\n   */\n  get xyz() {\n    return this._outputs[1];\n  }\n  /**\n   * Gets the matrix transform input\n   */\n  get transform() {\n    return this._inputs[1];\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    const vector = this.vector;\n    const transform = this.transform;\n    if (vector.connectedPoint) {\n      // None uniform scaling case.\n      if (this.complementW === 0) {\n        const comments = `//${this.name}`;\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\n        state.sharedData.blocksWithDefines.push(this);\n        const transformName = state._getFreeVariableName(`${transform.associatedVariableName}_NUS`);\n        state.compilationString += `mat3 ${transformName} = mat3(${transform.associatedVariableName});\\n`;\n        state.compilationString += `#ifdef NONUNIFORMSCALING\\n`;\n        state.compilationString += `${transformName} = transposeMat3(inverseMat3(${transformName}));\\n`;\n        state.compilationString += `#endif\\n`;\n        switch (vector.connectedPoint.type) {\n          case NodeMaterialBlockConnectionPointTypes.Vector2:\n            state.compilationString += this._declareOutput(this.output, state) + ` = vec4(${transformName} * vec3(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}), ${this._writeFloat(this.complementW)});\\n`;\n            break;\n          case NodeMaterialBlockConnectionPointTypes.Vector3:\n          case NodeMaterialBlockConnectionPointTypes.Color3:\n            state.compilationString += this._declareOutput(this.output, state) + ` = vec4(${transformName} * ${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});\\n`;\n            break;\n          default:\n            state.compilationString += this._declareOutput(this.output, state) + ` = vec4(${transformName} * ${vector.associatedVariableName}.xyz, ${this._writeFloat(this.complementW)});\\n`;\n            break;\n        }\n      } else {\n        const transformName = transform.associatedVariableName;\n        switch (vector.connectedPoint.type) {\n          case NodeMaterialBlockConnectionPointTypes.Vector2:\n            state.compilationString += this._declareOutput(this.output, state) + ` = ${transformName} * vec4(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}, ${this._writeFloat(this.complementW)});\\n`;\n            break;\n          case NodeMaterialBlockConnectionPointTypes.Vector3:\n          case NodeMaterialBlockConnectionPointTypes.Color3:\n            state.compilationString += this._declareOutput(this.output, state) + ` = ${transformName} * vec4(${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});\\n`;\n            break;\n          default:\n            state.compilationString += this._declareOutput(this.output, state) + ` = ${transformName} * ${vector.associatedVariableName};\\n`;\n            break;\n        }\n      }\n      if (this.xyz.hasEndpoints) {\n        state.compilationString += this._declareOutput(this.xyz, state) + ` = ${this.output.associatedVariableName}.xyz;\\n`;\n      }\n    }\n    return this;\n  }\n  /**\n   * Update defines for shader compilation\n   * @param mesh defines the mesh to be rendered\n   * @param nodeMaterial defines the node material requesting the update\n   * @param defines defines the material defines to update\n   */\n  prepareDefines(mesh, nodeMaterial, defines) {\n    // Do nothing\n    if (mesh.nonUniformScaling) {\n      defines.setValue(\"NONUNIFORMSCALING\", true);\n    }\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.complementZ = this.complementZ;\n    serializationObject.complementW = this.complementW;\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    this.complementZ = serializationObject.complementZ !== undefined ? serializationObject.complementZ : 0.0;\n    this.complementW = serializationObject.complementW !== undefined ? serializationObject.complementW : 1.0;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.complementZ = ${this.complementZ};\\n`;\n    codeString += `${this._codeVariableName}.complementW = ${this.complementW};\\n`;\n    return codeString;\n  }\n}\nRegisterClass(\"BABYLON.TransformBlock\", TransformBlock);","map":{"version":3,"names":["NodeMaterialBlock","NodeMaterialBlockConnectionPointTypes","NodeMaterialBlockTargets","RegisterClass","TransformBlock","constructor","name","Neutral","complementW","complementZ","target","Vertex","registerInput","AutoDetect","Matrix","registerOutput","Vector4","Vector3","_inputs","onConnectionObservable","add","other","ownerBlock","isInput","otherAsInput","getClassName","vector","output","_outputs","xyz","transform","_buildBlock","state","connectedPoint","comments","_emitFunctionFromInclude","sharedData","blocksWithDefines","push","transformName","_getFreeVariableName","associatedVariableName","compilationString","type","Vector2","_declareOutput","_writeFloat","Color3","hasEndpoints","prepareDefines","mesh","nodeMaterial","defines","nonUniformScaling","setValue","serialize","serializationObject","_deserialize","scene","rootUrl","undefined","_dumpPropertiesCode","codeString","_codeVariableName"],"sources":["../../../../../../dev/core/src/Materials/Node/Blocks/transformBlock.ts"],"sourcesContent":["import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { InputBlock } from \"./Input/inputBlock\";\r\nimport type { AbstractMesh } from \"../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../nodeMaterial\";\r\n\r\n/**\r\n * Block used to transform a vector (2, 3 or 4) with a matrix. It will generate a Vector4\r\n */\r\nexport class TransformBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Defines the value to use to complement W value to transform it to a Vector4\r\n     */\r\n    public complementW = 1;\r\n\r\n    /**\r\n     * Defines the value to use to complement z value to transform it to a Vector4\r\n     */\r\n    public complementZ = 0;\r\n\r\n    /**\r\n     * Creates a new TransformBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.target = NodeMaterialBlockTargets.Vertex;\r\n\r\n        this.registerInput(\"vector\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"transform\", NodeMaterialBlockConnectionPointTypes.Matrix);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerOutput(\"xyz\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n\r\n        this._inputs[0].onConnectionObservable.add((other) => {\r\n            if (other.ownerBlock.isInput) {\r\n                const otherAsInput = other.ownerBlock as InputBlock;\r\n\r\n                if (otherAsInput.name === \"normal\" || otherAsInput.name === \"tangent\") {\r\n                    this.complementW = 0;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"TransformBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the vector input\r\n     */\r\n    public get vector(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the xyz output component\r\n     */\r\n    public get xyz(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix transform input\r\n     */\r\n    public get transform(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const vector = this.vector;\r\n        const transform = this.transform;\r\n\r\n        if (vector.connectedPoint) {\r\n            // None uniform scaling case.\r\n            if (this.complementW === 0) {\r\n                const comments = `//${this.name}`;\r\n                state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n                state.sharedData.blocksWithDefines.push(this);\r\n\r\n                const transformName = state._getFreeVariableName(`${transform.associatedVariableName}_NUS`);\r\n                state.compilationString += `mat3 ${transformName} = mat3(${transform.associatedVariableName});\\n`;\r\n                state.compilationString += `#ifdef NONUNIFORMSCALING\\n`;\r\n                state.compilationString += `${transformName} = transposeMat3(inverseMat3(${transformName}));\\n`;\r\n                state.compilationString += `#endif\\n`;\r\n                switch (vector.connectedPoint.type) {\r\n                    case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                        state.compilationString +=\r\n                            this._declareOutput(this.output, state) +\r\n                            ` = vec4(${transformName} * vec3(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}), ${this._writeFloat(this.complementW)});\\n`;\r\n                        break;\r\n                    case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                    case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                        state.compilationString +=\r\n                            this._declareOutput(this.output, state) + ` = vec4(${transformName} * ${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});\\n`;\r\n                        break;\r\n                    default:\r\n                        state.compilationString +=\r\n                            this._declareOutput(this.output, state) + ` = vec4(${transformName} * ${vector.associatedVariableName}.xyz, ${this._writeFloat(this.complementW)});\\n`;\r\n                        break;\r\n                }\r\n            } else {\r\n                const transformName = transform.associatedVariableName;\r\n                switch (vector.connectedPoint.type) {\r\n                    case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                        state.compilationString +=\r\n                            this._declareOutput(this.output, state) +\r\n                            ` = ${transformName} * vec4(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}, ${this._writeFloat(this.complementW)});\\n`;\r\n                        break;\r\n                    case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                    case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                        state.compilationString +=\r\n                            this._declareOutput(this.output, state) + ` = ${transformName} * vec4(${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});\\n`;\r\n                        break;\r\n                    default:\r\n                        state.compilationString += this._declareOutput(this.output, state) + ` = ${transformName} * ${vector.associatedVariableName};\\n`;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            if (this.xyz.hasEndpoints) {\r\n                state.compilationString += this._declareOutput(this.xyz, state) + ` = ${this.output.associatedVariableName}.xyz;\\n`;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Update defines for shader compilation\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     */\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        // Do nothing\r\n        if (mesh.nonUniformScaling) {\r\n            defines.setValue(\"NONUNIFORMSCALING\", true);\r\n        }\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.complementZ = this.complementZ;\r\n        serializationObject.complementW = this.complementW;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.complementZ = serializationObject.complementZ !== undefined ? serializationObject.complementZ : 0.0;\r\n        this.complementW = serializationObject.complementW !== undefined ? serializationObject.complementW : 1.0;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.complementZ = ${this.complementZ};\\n`;\r\n\r\n        codeString += `${this._codeVariableName}.complementW = ${this.complementW};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TransformBlock\", TransformBlock);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}