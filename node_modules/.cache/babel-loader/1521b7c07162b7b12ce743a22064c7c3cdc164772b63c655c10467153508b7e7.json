{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * PostProcessRenderPipelineManager class\n * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline\n */\nexport class PostProcessRenderPipelineManager {\n  /**\n   * Initializes a PostProcessRenderPipelineManager\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline\n   */\n  constructor() {\n    this._renderPipelines = {};\n  }\n  /**\n   * Gets the list of supported render pipelines\n   */\n  get supportedPipelines() {\n    const result = [];\n    for (const renderPipelineName in this._renderPipelines) {\n      if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\n        const pipeline = this._renderPipelines[renderPipelineName];\n        if (pipeline.isSupported) {\n          result.push(pipeline);\n        }\n      }\n    }\n    return result;\n  }\n  /**\n   * Adds a pipeline to the manager\n   * @param renderPipeline The pipeline to add\n   */\n  addPipeline(renderPipeline) {\n    this._renderPipelines[renderPipeline._name] = renderPipeline;\n  }\n  /**\n   * Remove the pipeline from the manager\n   * @param renderPipelineName the name of the pipeline to remove\n   */\n  removePipeline(renderPipelineName) {\n    delete this._renderPipelines[renderPipelineName];\n  }\n  /**\n   * Attaches a camera to the pipeline\n   * @param renderPipelineName The name of the pipeline to attach to\n   * @param cameras the camera to attach\n   * @param unique if the camera can be attached multiple times to the pipeline\n   */\n  attachCamerasToRenderPipeline(renderPipelineName, cameras, unique = false) {\n    const renderPipeline = this._renderPipelines[renderPipelineName];\n    if (!renderPipeline) {\n      return;\n    }\n    renderPipeline._attachCameras(cameras, unique);\n  }\n  /**\n   * Detaches a camera from the pipeline\n   * @param renderPipelineName The name of the pipeline to detach from\n   * @param cameras the camera to detach\n   */\n  detachCamerasFromRenderPipeline(renderPipelineName, cameras) {\n    const renderPipeline = this._renderPipelines[renderPipelineName];\n    if (!renderPipeline) {\n      return;\n    }\n    renderPipeline._detachCameras(cameras);\n  }\n  /**\n   * Enables an effect by name on a pipeline\n   * @param renderPipelineName the name of the pipeline to enable the effect in\n   * @param renderEffectName the name of the effect to enable\n   * @param cameras the cameras that the effect should be enabled on\n   */\n  enableEffectInPipeline(renderPipelineName, renderEffectName, cameras) {\n    const renderPipeline = this._renderPipelines[renderPipelineName];\n    if (!renderPipeline) {\n      return;\n    }\n    renderPipeline._enableEffect(renderEffectName, cameras);\n  }\n  /**\n   * Disables an effect by name on a pipeline\n   * @param renderPipelineName the name of the pipeline to disable the effect in\n   * @param renderEffectName the name of the effect to disable\n   * @param cameras the cameras that the effect should be disabled on\n   */\n  disableEffectInPipeline(renderPipelineName, renderEffectName, cameras) {\n    const renderPipeline = this._renderPipelines[renderPipelineName];\n    if (!renderPipeline) {\n      return;\n    }\n    renderPipeline._disableEffect(renderEffectName, cameras);\n  }\n  /**\n   * Updates the state of all contained render pipelines and disposes of any non supported pipelines\n   */\n  update() {\n    for (const renderPipelineName in this._renderPipelines) {\n      if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\n        const pipeline = this._renderPipelines[renderPipelineName];\n        if (!pipeline.isSupported) {\n          pipeline.dispose();\n          delete this._renderPipelines[renderPipelineName];\n        } else {\n          pipeline._update();\n        }\n      }\n    }\n  }\n  /** @internal */\n  _rebuild() {\n    for (const renderPipelineName in this._renderPipelines) {\n      if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\n        const pipeline = this._renderPipelines[renderPipelineName];\n        pipeline._rebuild();\n      }\n    }\n  }\n  /**\n   * Disposes of the manager and pipelines\n   */\n  dispose() {\n    for (const renderPipelineName in this._renderPipelines) {\n      if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\n        const pipeline = this._renderPipelines[renderPipelineName];\n        pipeline.dispose();\n      }\n    }\n  }\n}","map":{"version":3,"names":["PostProcessRenderPipelineManager","constructor","_renderPipelines","supportedPipelines","result","renderPipelineName","Object","prototype","hasOwnProperty","call","pipeline","isSupported","push","addPipeline","renderPipeline","_name","removePipeline","attachCamerasToRenderPipeline","cameras","unique","_attachCameras","detachCamerasFromRenderPipeline","_detachCameras","enableEffectInPipeline","renderEffectName","_enableEffect","disableEffectInPipeline","_disableEffect","update","dispose","_update","_rebuild"],"sources":["../../../../../dev/core/src/PostProcesses/RenderPipeline/postProcessRenderPipelineManager.ts"],"sourcesContent":["import type { Camera } from \"../../Cameras/camera\";\r\nimport type { PostProcessRenderPipeline } from \"./postProcessRenderPipeline\";\r\n/**\r\n * PostProcessRenderPipelineManager class\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline\r\n */\r\nexport class PostProcessRenderPipelineManager {\r\n    private _renderPipelines: { [Key: string]: PostProcessRenderPipeline };\r\n\r\n    /**\r\n     * Initializes a PostProcessRenderPipelineManager\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline\r\n     */\r\n    constructor() {\r\n        this._renderPipelines = {};\r\n    }\r\n\r\n    /**\r\n     * Gets the list of supported render pipelines\r\n     */\r\n    public get supportedPipelines(): PostProcessRenderPipeline[] {\r\n        const result = [];\r\n\r\n        for (const renderPipelineName in this._renderPipelines) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\r\n                const pipeline = this._renderPipelines[renderPipelineName];\r\n                if (pipeline.isSupported) {\r\n                    result.push(pipeline);\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Adds a pipeline to the manager\r\n     * @param renderPipeline The pipeline to add\r\n     */\r\n    public addPipeline(renderPipeline: PostProcessRenderPipeline): void {\r\n        this._renderPipelines[renderPipeline._name] = renderPipeline;\r\n    }\r\n\r\n    /**\r\n     * Remove the pipeline from the manager\r\n     * @param renderPipelineName the name of the pipeline to remove\r\n     */\r\n    public removePipeline(renderPipelineName: string): void {\r\n        delete this._renderPipelines[renderPipelineName];\r\n    }\r\n\r\n    /**\r\n     * Attaches a camera to the pipeline\r\n     * @param renderPipelineName The name of the pipeline to attach to\r\n     * @param cameras the camera to attach\r\n     * @param unique if the camera can be attached multiple times to the pipeline\r\n     */\r\n    public attachCamerasToRenderPipeline(renderPipelineName: string, cameras: any | Camera[] | Camera, unique: boolean = false): void {\r\n        const renderPipeline: PostProcessRenderPipeline = this._renderPipelines[renderPipelineName];\r\n\r\n        if (!renderPipeline) {\r\n            return;\r\n        }\r\n\r\n        renderPipeline._attachCameras(cameras, unique);\r\n    }\r\n\r\n    /**\r\n     * Detaches a camera from the pipeline\r\n     * @param renderPipelineName The name of the pipeline to detach from\r\n     * @param cameras the camera to detach\r\n     */\r\n    public detachCamerasFromRenderPipeline(renderPipelineName: string, cameras: any | Camera[] | Camera): void {\r\n        const renderPipeline: PostProcessRenderPipeline = this._renderPipelines[renderPipelineName];\r\n\r\n        if (!renderPipeline) {\r\n            return;\r\n        }\r\n\r\n        renderPipeline._detachCameras(cameras);\r\n    }\r\n\r\n    /**\r\n     * Enables an effect by name on a pipeline\r\n     * @param renderPipelineName the name of the pipeline to enable the effect in\r\n     * @param renderEffectName the name of the effect to enable\r\n     * @param cameras the cameras that the effect should be enabled on\r\n     */\r\n    public enableEffectInPipeline(renderPipelineName: string, renderEffectName: string, cameras: any | Camera[] | Camera): void {\r\n        const renderPipeline: PostProcessRenderPipeline = this._renderPipelines[renderPipelineName];\r\n\r\n        if (!renderPipeline) {\r\n            return;\r\n        }\r\n\r\n        renderPipeline._enableEffect(renderEffectName, cameras);\r\n    }\r\n\r\n    /**\r\n     * Disables an effect by name on a pipeline\r\n     * @param renderPipelineName the name of the pipeline to disable the effect in\r\n     * @param renderEffectName the name of the effect to disable\r\n     * @param cameras the cameras that the effect should be disabled on\r\n     */\r\n    public disableEffectInPipeline(renderPipelineName: string, renderEffectName: string, cameras: any | Camera[] | Camera): void {\r\n        const renderPipeline: PostProcessRenderPipeline = this._renderPipelines[renderPipelineName];\r\n\r\n        if (!renderPipeline) {\r\n            return;\r\n        }\r\n\r\n        renderPipeline._disableEffect(renderEffectName, cameras);\r\n    }\r\n\r\n    /**\r\n     * Updates the state of all contained render pipelines and disposes of any non supported pipelines\r\n     */\r\n    public update(): void {\r\n        for (const renderPipelineName in this._renderPipelines) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\r\n                const pipeline = this._renderPipelines[renderPipelineName];\r\n                if (!pipeline.isSupported) {\r\n                    pipeline.dispose();\r\n                    delete this._renderPipelines[renderPipelineName];\r\n                } else {\r\n                    pipeline._update();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        for (const renderPipelineName in this._renderPipelines) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\r\n                const pipeline = this._renderPipelines[renderPipelineName];\r\n                pipeline._rebuild();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the manager and pipelines\r\n     */\r\n    public dispose(): void {\r\n        for (const renderPipelineName in this._renderPipelines) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\r\n                const pipeline = this._renderPipelines[renderPipelineName];\r\n                pipeline.dispose();\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}