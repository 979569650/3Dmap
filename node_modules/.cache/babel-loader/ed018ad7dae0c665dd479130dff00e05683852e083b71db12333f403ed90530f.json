{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { TBNBlock } from \"../Fragment/TBNBlock.js\";\n/**\n * Block used to implement the anisotropy module of the PBR material\n */\nexport class AnisotropyBlock extends NodeMaterialBlock {\n  /**\n   * Create a new AnisotropyBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Fragment);\n    this._tangentCorrectionFactorName = \"\";\n    this._isUnique = true;\n    this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"direction\", NodeMaterialBlockConnectionPointTypes.Vector2, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, true); // need this property and the next one in case there's no PerturbNormal block connected to the main PBR block\n    this.registerInput(\"worldTangent\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\n    this.registerInput(\"TBN\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(\"TBN\", this, NodeMaterialConnectionPointDirection.Input, TBNBlock, \"TBNBlock\"));\n    this.registerInput(\"roughness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"anisotropy\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"anisotropy\", this, NodeMaterialConnectionPointDirection.Output, AnisotropyBlock, \"AnisotropyBlock\"));\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  initialize(state) {\n    state._excludeVariableName(\"anisotropicOut\");\n    state._excludeVariableName(\"TBN\");\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"AnisotropyBlock\";\n  }\n  /**\n   * Gets the intensity input component\n   */\n  get intensity() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the direction input component\n   */\n  get direction() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the uv input component\n   */\n  get uv() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the worldTangent input component\n   */\n  get worldTangent() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the TBN input component\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  get TBN() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the roughness input component\n   */\n  get roughness() {\n    return this._inputs[5];\n  }\n  /**\n   * Gets the anisotropy object output component\n   */\n  get anisotropy() {\n    return this._outputs[0];\n  }\n  _generateTBNSpace(state) {\n    let code = \"\";\n    const comments = `//${this.name}`;\n    const uv = this.uv;\n    const worldPosition = this.worldPositionConnectionPoint;\n    const worldNormal = this.worldNormalConnectionPoint;\n    const worldTangent = this.worldTangent;\n    if (!uv.isConnected) {\n      // we must set the uv input as optional because we may not end up in this method (in case a PerturbNormal block is linked to the PBR material)\n      // in which case uv is not required. But if we do come here, we do need the uv, so we have to raise an error but not with throw, else\n      // it will stop the building of the node material and will lead to errors in the editor!\n      console.error(\"You must connect the 'uv' input of the Anisotropy block!\");\n    }\n    state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\n    const tangentReplaceString = {\n      search: /defined\\(TANGENT\\)/g,\n      replace: worldTangent.isConnected ? \"defined(TANGENT)\" : \"defined(IGNORE)\"\n    };\n    const TBN = this.TBN;\n    if (TBN.isConnected) {\n      state.compilationString += `\n            #ifdef TBNBLOCK\n            mat3 vTBN = ${TBN.associatedVariableName};\n            #endif\n            `;\n    } else if (worldTangent.isConnected) {\n      code += `vec3 tbnNormal = normalize(${worldNormal.associatedVariableName}.xyz);\\n`;\n      code += `vec3 tbnTangent = normalize(${worldTangent.associatedVariableName}.xyz);\\n`;\n      code += `vec3 tbnBitangent = cross(tbnNormal, tbnTangent) * ${this._tangentCorrectionFactorName};\\n`;\n      code += `mat3 vTBN = mat3(tbnTangent, tbnBitangent, tbnNormal);\\n`;\n    }\n    code += `\n            #if defined(${worldTangent.isConnected ? \"TANGENT\" : \"IGNORE\"}) && defined(NORMAL)\n                mat3 TBN = vTBN;\n            #else\n                mat3 TBN = cotangent_frame(${worldNormal.associatedVariableName + \".xyz\"}, ${\"v_\" + worldPosition.associatedVariableName + \".xyz\"}, ${uv.isConnected ? uv.associatedVariableName : \"vec2(0.)\"}, vec2(1., 1.));\n            #endif\\n`;\n    state._emitFunctionFromInclude(\"bumpFragmentMainFunctions\", comments, {\n      replaceStrings: [tangentReplaceString]\n    });\n    return code;\n  }\n  /**\n   * Gets the main code of the block (fragment side)\n   * @param state current state of the node material building\n   * @param generateTBNSpace if true, the code needed to create the TBN coordinate space is generated\n   * @returns the shader code\n   */\n  getCode(state, generateTBNSpace = false) {\n    let code = \"\";\n    if (generateTBNSpace) {\n      code += this._generateTBNSpace(state);\n    }\n    const intensity = this.intensity.isConnected ? this.intensity.associatedVariableName : \"1.0\";\n    const direction = this.direction.isConnected ? this.direction.associatedVariableName : \"vec2(1., 0.)\";\n    const roughness = this.roughness.isConnected ? this.roughness.associatedVariableName : \"0.\";\n    code += `anisotropicOutParams anisotropicOut;\n            anisotropicBlock(\n                vec3(${direction}, ${intensity}),\n                ${roughness},\n            #ifdef ANISOTROPIC_TEXTURE\n                vec3(0.),\n            #endif\n                TBN,\n                normalW,\n                viewDirectionW,\n                anisotropicOut\n            );\\n`;\n    return code;\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    super.prepareDefines(mesh, nodeMaterial, defines);\n    defines.setValue(\"ANISOTROPIC\", true);\n    defines.setValue(\"ANISOTROPIC_TEXTURE\", false, true);\n    defines.setValue(\"ANISOTROPIC_LEGACY\", !this.roughness.isConnected);\n  }\n  bind(effect, nodeMaterial, mesh) {\n    super.bind(effect, nodeMaterial, mesh);\n    if (mesh) {\n      effect.setFloat(this._tangentCorrectionFactorName, mesh.getWorldMatrix().determinant() < 0 ? -1 : 1);\n    }\n  }\n  _buildBlock(state) {\n    if (state.target === NodeMaterialBlockTargets.Fragment) {\n      state.sharedData.blocksWithDefines.push(this);\n      state.sharedData.bindableBlocks.push(this);\n      this._tangentCorrectionFactorName = state._getFreeDefineName(\"tangentCorrectionFactor\");\n      state._emitUniformFromString(this._tangentCorrectionFactorName, \"float\");\n    }\n    return this;\n  }\n}\nRegisterClass(\"BABYLON.AnisotropyBlock\", AnisotropyBlock);","map":{"version":3,"names":["NodeMaterialBlock","NodeMaterialBlockConnectionPointTypes","NodeMaterialConnectionPointDirection","NodeMaterialBlockTargets","RegisterClass","NodeMaterialConnectionPointCustomObject","TBNBlock","AnisotropyBlock","constructor","name","Fragment","_tangentCorrectionFactorName","_isUnique","registerInput","Float","Vector2","Vector4","Object","VertexAndFragment","Input","registerOutput","Output","initialize","state","_excludeVariableName","getClassName","intensity","_inputs","direction","uv","worldTangent","TBN","roughness","anisotropy","_outputs","_generateTBNSpace","code","comments","worldPosition","worldPositionConnectionPoint","worldNormal","worldNormalConnectionPoint","isConnected","console","error","_emitExtension","tangentReplaceString","search","replace","compilationString","associatedVariableName","_emitFunctionFromInclude","replaceStrings","getCode","generateTBNSpace","prepareDefines","mesh","nodeMaterial","defines","setValue","bind","effect","setFloat","getWorldMatrix","determinant","_buildBlock","target","sharedData","blocksWithDefines","push","bindableBlocks","_getFreeDefineName","_emitUniformFromString"],"sources":["../../../../../../../dev/core/src/Materials/Node/Blocks/PBR/anisotropyBlock.ts"],"sourcesContent":["import type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport { TBNBlock } from \"../Fragment/TBNBlock\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport type { Effect } from \"../../../effect\";\r\n\r\n/**\r\n * Block used to implement the anisotropy module of the PBR material\r\n */\r\nexport class AnisotropyBlock extends NodeMaterialBlock {\r\n    private _tangentCorrectionFactorName = \"\";\r\n\r\n    /**\r\n     * The two properties below are set by the main PBR block prior to calling methods of this class.\r\n     * This is to avoid having to add them as inputs here whereas they are already inputs of the main block, so already known.\r\n     * It's less burden on the user side in the editor part.\r\n     */\r\n\r\n    /** @internal */\r\n    public worldPositionConnectionPoint: NodeMaterialConnectionPoint;\r\n    /** @internal */\r\n    public worldNormalConnectionPoint: NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Create a new AnisotropyBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"direction\", NodeMaterialBlockConnectionPointTypes.Vector2, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, true); // need this property and the next one in case there's no PerturbNormal block connected to the main PBR block\r\n        this.registerInput(\"worldTangent\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\r\n        this.registerInput(\r\n            \"TBN\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"TBN\", this, NodeMaterialConnectionPointDirection.Input, TBNBlock, \"TBNBlock\")\r\n        );\r\n        this.registerInput(\"roughness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\r\n            \"anisotropy\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"anisotropy\", this, NodeMaterialConnectionPointDirection.Output, AnisotropyBlock, \"AnisotropyBlock\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"anisotropicOut\");\r\n        state._excludeVariableName(\"TBN\");\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"AnisotropyBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the intensity input component\r\n     */\r\n    public get intensity(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the direction input component\r\n     */\r\n    public get direction(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the worldTangent input component\r\n     */\r\n    public get worldTangent(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the TBN input component\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get TBN(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the roughness input component\r\n     */\r\n    public get roughness(): NodeMaterialConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the anisotropy object output component\r\n     */\r\n    public get anisotropy(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    private _generateTBNSpace(state: NodeMaterialBuildState) {\r\n        let code = \"\";\r\n\r\n        const comments = `//${this.name}`;\r\n        const uv = this.uv;\r\n        const worldPosition = this.worldPositionConnectionPoint;\r\n        const worldNormal = this.worldNormalConnectionPoint;\r\n        const worldTangent = this.worldTangent;\r\n\r\n        if (!uv.isConnected) {\r\n            // we must set the uv input as optional because we may not end up in this method (in case a PerturbNormal block is linked to the PBR material)\r\n            // in which case uv is not required. But if we do come here, we do need the uv, so we have to raise an error but not with throw, else\r\n            // it will stop the building of the node material and will lead to errors in the editor!\r\n            console.error(\"You must connect the 'uv' input of the Anisotropy block!\");\r\n        }\r\n\r\n        state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\r\n\r\n        const tangentReplaceString = { search: /defined\\(TANGENT\\)/g, replace: worldTangent.isConnected ? \"defined(TANGENT)\" : \"defined(IGNORE)\" };\r\n\r\n        const TBN = this.TBN;\r\n        if (TBN.isConnected) {\r\n            state.compilationString += `\r\n            #ifdef TBNBLOCK\r\n            mat3 vTBN = ${TBN.associatedVariableName};\r\n            #endif\r\n            `;\r\n        } else if (worldTangent.isConnected) {\r\n            code += `vec3 tbnNormal = normalize(${worldNormal.associatedVariableName}.xyz);\\n`;\r\n            code += `vec3 tbnTangent = normalize(${worldTangent.associatedVariableName}.xyz);\\n`;\r\n            code += `vec3 tbnBitangent = cross(tbnNormal, tbnTangent) * ${this._tangentCorrectionFactorName};\\n`;\r\n            code += `mat3 vTBN = mat3(tbnTangent, tbnBitangent, tbnNormal);\\n`;\r\n        }\r\n\r\n        code += `\r\n            #if defined(${worldTangent.isConnected ? \"TANGENT\" : \"IGNORE\"}) && defined(NORMAL)\r\n                mat3 TBN = vTBN;\r\n            #else\r\n                mat3 TBN = cotangent_frame(${worldNormal.associatedVariableName + \".xyz\"}, ${\"v_\" + worldPosition.associatedVariableName + \".xyz\"}, ${\r\n            uv.isConnected ? uv.associatedVariableName : \"vec2(0.)\"\r\n        }, vec2(1., 1.));\r\n            #endif\\n`;\r\n\r\n        state._emitFunctionFromInclude(\"bumpFragmentMainFunctions\", comments, {\r\n            replaceStrings: [tangentReplaceString],\r\n        });\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Gets the main code of the block (fragment side)\r\n     * @param state current state of the node material building\r\n     * @param generateTBNSpace if true, the code needed to create the TBN coordinate space is generated\r\n     * @returns the shader code\r\n     */\r\n    public getCode(state: NodeMaterialBuildState, generateTBNSpace = false): string {\r\n        let code = \"\";\r\n\r\n        if (generateTBNSpace) {\r\n            code += this._generateTBNSpace(state);\r\n        }\r\n\r\n        const intensity = this.intensity.isConnected ? this.intensity.associatedVariableName : \"1.0\";\r\n        const direction = this.direction.isConnected ? this.direction.associatedVariableName : \"vec2(1., 0.)\";\r\n        const roughness = this.roughness.isConnected ? this.roughness.associatedVariableName : \"0.\";\r\n\r\n        code += `anisotropicOutParams anisotropicOut;\r\n            anisotropicBlock(\r\n                vec3(${direction}, ${intensity}),\r\n                ${roughness},\r\n            #ifdef ANISOTROPIC_TEXTURE\r\n                vec3(0.),\r\n            #endif\r\n                TBN,\r\n                normalW,\r\n                viewDirectionW,\r\n                anisotropicOut\r\n            );\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        super.prepareDefines(mesh, nodeMaterial, defines);\r\n\r\n        defines.setValue(\"ANISOTROPIC\", true);\r\n        defines.setValue(\"ANISOTROPIC_TEXTURE\", false, true);\r\n        defines.setValue(\"ANISOTROPIC_LEGACY\", !this.roughness.isConnected);\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        super.bind(effect, nodeMaterial, mesh);\r\n\r\n        if (mesh) {\r\n            effect.setFloat(this._tangentCorrectionFactorName, mesh.getWorldMatrix().determinant() < 0 ? -1 : 1);\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.sharedData.blocksWithDefines.push(this);\r\n            state.sharedData.bindableBlocks.push(this);\r\n\r\n            this._tangentCorrectionFactorName = state._getFreeDefineName(\"tangentCorrectionFactor\");\r\n            state._emitUniformFromString(this._tangentCorrectionFactorName, \"float\");\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.AnisotropyBlock\", AnisotropyBlock);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}