{"ast":null,"code":"import { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { FxaaPostProcess } from \"../PostProcesses/fxaaPostProcess.js\";\nimport { Logger } from \"./logger.js\";\nimport { Tools } from \"./tools.js\";\nimport { DumpTools } from \"./dumpTools.js\";\nimport { ApplyPostProcess } from \"./textureTools.js\";\nlet screenshotCanvas = null;\n/**\n * Captures a screenshot of the current rendering\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n * @param engine defines the rendering engine\n * @param camera defines the source camera\n * @param size This parameter can be set to a single number or to an object with the\n * following (optional) properties: precision, width, height. If a single number is passed,\n * it will be used for both width and height. If an object is passed, the screenshot size\n * will be derived from the parameters. The precision property is a multiplier allowing\n * rendering at a higher or lower resolution\n * @param successCallback defines the callback receives a single parameter which contains the\n * screenshot as a string of base64-encoded characters. This string can be assigned to the\n * src parameter of an <img> to display it\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n * Check your browser for supported MIME types\n * @param forceDownload force the system to download the image even if a successCallback is provided\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n */\nexport function CreateScreenshot(engine, camera, size, successCallback, mimeType = \"image/png\", forceDownload = false, quality) {\n  const {\n    height,\n    width\n  } = _GetScreenshotSize(engine, camera, size);\n  if (!(height && width)) {\n    Logger.Error(\"Invalid 'size' parameter !\");\n    return;\n  }\n  if (!screenshotCanvas) {\n    screenshotCanvas = document.createElement(\"canvas\");\n  }\n  screenshotCanvas.width = width;\n  screenshotCanvas.height = height;\n  const renderContext = screenshotCanvas.getContext(\"2d\");\n  const ratio = engine.getRenderWidth() / engine.getRenderHeight();\n  let newWidth = width;\n  let newHeight = newWidth / ratio;\n  if (newHeight > height) {\n    newHeight = height;\n    newWidth = newHeight * ratio;\n  }\n  const offsetX = Math.max(0, width - newWidth) / 2;\n  const offsetY = Math.max(0, height - newHeight) / 2;\n  const scene = camera.getScene();\n  if (scene.activeCamera !== camera) {\n    CreateScreenshotUsingRenderTarget(engine, camera, size, data => {\n      if (forceDownload) {\n        const blob = new Blob([data]);\n        Tools.DownloadBlob(blob);\n        if (successCallback) {\n          successCallback(\"\");\n        }\n      } else if (successCallback) {\n        successCallback(data);\n      }\n    }, mimeType, 1.0, engine.getCreationOptions().antialias, undefined, undefined, undefined, undefined, quality);\n  } else {\n    engine.onEndFrameObservable.addOnce(() => {\n      const renderingCanvas = engine.getRenderingCanvas();\n      if (renderContext && renderingCanvas) {\n        renderContext.drawImage(renderingCanvas, offsetX, offsetY, newWidth, newHeight);\n      }\n      if (screenshotCanvas) {\n        if (forceDownload) {\n          Tools.EncodeScreenshotCanvasData(screenshotCanvas, undefined, mimeType, undefined, quality);\n          if (successCallback) {\n            successCallback(\"\");\n          }\n        } else {\n          Tools.EncodeScreenshotCanvasData(screenshotCanvas, successCallback, mimeType, undefined, quality);\n        }\n      }\n    });\n  }\n}\n/**\n * Captures a screenshot of the current rendering\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n * @param engine defines the rendering engine\n * @param camera defines the source camera\n * @param size This parameter can be set to a single number or to an object with the\n * following (optional) properties: precision, width, height. If a single number is passed,\n * it will be used for both width and height. If an object is passed, the screenshot size\n * will be derived from the parameters. The precision property is a multiplier allowing\n * rendering at a higher or lower resolution\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n * Check your browser for supported MIME types\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n * to the src parameter of an <img> to display it\n */\nexport function CreateScreenshotAsync(engine, camera, size, mimeType = \"image/png\", quality) {\n  return new Promise((resolve, reject) => {\n    CreateScreenshot(engine, camera, size, data => {\n      if (typeof data !== \"undefined\") {\n        resolve(data);\n      } else {\n        reject(new Error(\"Data is undefined\"));\n      }\n    }, mimeType, undefined, quality);\n  });\n}\n/**\n * Captures a screenshot of the current rendering for a specific size. This will render the entire canvas but will generate a blink (due to canvas resize)\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n * @param engine defines the rendering engine\n * @param camera defines the source camera\n * @param width defines the expected width\n * @param height defines the expected height\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n * Check your browser for supported MIME types\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n * to the src parameter of an <img> to display it\n */\nexport function CreateScreenshotWithResizeAsync(engine, camera, width, height, mimeType = \"image/png\", quality) {\n  return new Promise(resolve => {\n    CreateScreenshot(engine, camera, {\n      width: width,\n      height: height\n    }, () => {\n      resolve();\n    }, mimeType, true, quality);\n  });\n}\n/**\n * Generates an image screenshot from the specified camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n * @param engine The engine to use for rendering\n * @param camera The camera to use for rendering\n * @param size This parameter can be set to a single number or to an object with the\n * following (optional) properties: precision, width, height, finalWidth, finalHeight. If a single number is passed,\n * it will be used for both width and height, as well as finalWidth, finalHeight. If an object is passed, the screenshot size\n * will be derived from the parameters. The precision property is a multiplier allowing\n * rendering at a higher or lower resolution\n * @param successCallback The callback receives a single parameter which contains the\n * screenshot as a string of base64-encoded characters. This string can be assigned to the\n * src parameter of an <img> to display it\n * @param mimeType The MIME type of the screenshot image (default: image/png).\n * Check your browser for supported MIME types\n * @param samples Texture samples (default: 1)\n * @param antialiasing Whether antialiasing should be turned on or not (default: false)\n * @param fileName A name for for the downloaded file.\n * @param renderSprites Whether the sprites should be rendered or not (default: false)\n * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\n * @param useLayerMask if the camera's layer mask should be used to filter what should be rendered (default: true)\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n */\nexport function CreateScreenshotUsingRenderTarget(engine, camera, size, successCallback, mimeType = \"image/png\", samples = 1, antialiasing = false, fileName, renderSprites = false, enableStencilBuffer = false, useLayerMask = true, quality) {\n  const {\n    height,\n    width,\n    finalWidth,\n    finalHeight\n  } = _GetScreenshotSize(engine, camera, size);\n  const targetTextureSize = {\n    width,\n    height\n  };\n  if (!(height && width)) {\n    Logger.Error(\"Invalid 'size' parameter !\");\n    return;\n  }\n  const originalSize = {\n    width: engine.getRenderWidth(),\n    height: engine.getRenderHeight()\n  };\n  engine.setSize(width, height); // we need this call to trigger onResizeObservable with the screenshot width/height on all the subsystems that are observing this event and that needs to (re)create some resources with the right dimensions\n  const scene = camera.getScene();\n  // At this point size can be a number, or an object (according to engine.prototype.createRenderTargetTexture method)\n  const texture = new RenderTargetTexture(\"screenShot\", targetTextureSize, scene, false, false, 0, false, Texture.BILINEAR_SAMPLINGMODE, undefined, enableStencilBuffer, undefined, undefined, undefined, samples);\n  texture.renderList = scene.meshes.slice();\n  texture.samples = samples;\n  texture.renderSprites = renderSprites;\n  texture.activeCamera = camera;\n  texture.forceLayerMaskCheck = useLayerMask;\n  const renderToTexture = () => {\n    engine.onEndFrameObservable.addOnce(() => {\n      if (finalWidth === width && finalHeight === height) {\n        texture.readPixels(undefined, undefined, undefined, false).then(data => {\n          DumpTools.DumpData(width, height, data, successCallback, mimeType, fileName, true, undefined, quality);\n          texture.dispose();\n        });\n      } else {\n        ApplyPostProcess(\"pass\", texture.getInternalTexture(), scene, undefined, undefined, undefined, finalWidth, finalHeight).then(texture => {\n          engine._readTexturePixels(texture, finalWidth, finalHeight, -1, 0, null, true, false, 0, 0).then(data => {\n            DumpTools.DumpData(finalWidth, finalHeight, data, successCallback, mimeType, fileName, true, undefined, quality);\n            texture.dispose();\n          });\n        });\n      }\n    });\n    // render the RTT\n    scene.incrementRenderId();\n    scene.resetCachedMaterial();\n    texture.render(true);\n    // re-render the scene after the camera has been reset to the original camera to avoid a flicker that could occur\n    // if the camera used for the RTT rendering stays in effect for the next frame (and if that camera was different from the original camera)\n    scene.incrementRenderId();\n    scene.resetCachedMaterial();\n    engine.setSize(originalSize.width, originalSize.height);\n    camera.getProjectionMatrix(true); // Force cache refresh;\n    scene.render();\n  };\n  if (antialiasing) {\n    const fxaaPostProcess = new FxaaPostProcess(\"antialiasing\", 1.0, scene.activeCamera);\n    texture.addPostProcess(fxaaPostProcess);\n    // Async Shader Compilation can lead to none ready effects in synchronous code\n    if (!fxaaPostProcess.getEffect().isReady()) {\n      fxaaPostProcess.getEffect().onCompiled = () => {\n        renderToTexture();\n      };\n    }\n    // The effect is ready we can render\n    else {\n      renderToTexture();\n    }\n  } else {\n    // No need to wait for extra resources to be ready\n    renderToTexture();\n  }\n}\n/**\n * Generates an image screenshot from the specified camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n * @param engine The engine to use for rendering\n * @param camera The camera to use for rendering\n * @param size This parameter can be set to a single number or to an object with the\n * following (optional) properties: precision, width, height. If a single number is passed,\n * it will be used for both width and height. If an object is passed, the screenshot size\n * will be derived from the parameters. The precision property is a multiplier allowing\n * rendering at a higher or lower resolution\n * @param mimeType The MIME type of the screenshot image (default: image/png).\n * Check your browser for supported MIME types\n * @param samples Texture samples (default: 1)\n * @param antialiasing Whether antialiasing should be turned on or not (default: false)\n * @param fileName A name for for the downloaded file.\n * @param renderSprites Whether the sprites should be rendered or not (default: false)\n * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\n * @param useLayerMask if the camera's layer mask should be used to filter what should be rendered (default: true)\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n * to the src parameter of an <img> to display it\n */\nexport function CreateScreenshotUsingRenderTargetAsync(engine, camera, size, mimeType = \"image/png\", samples = 1, antialiasing = false, fileName, renderSprites = false, enableStencilBuffer = false, useLayerMask = true, quality) {\n  return new Promise((resolve, reject) => {\n    CreateScreenshotUsingRenderTarget(engine, camera, size, data => {\n      if (typeof data !== \"undefined\") {\n        resolve(data);\n      } else {\n        reject(new Error(\"Data is undefined\"));\n      }\n    }, mimeType, samples, antialiasing, fileName, renderSprites, enableStencilBuffer, useLayerMask, quality);\n  });\n}\n/**\n * Gets height and width for screenshot size\n * @param engine\n * @param camera\n * @param size\n * @private\n */\nfunction _GetScreenshotSize(engine, camera, size) {\n  let height = 0;\n  let width = 0;\n  let finalWidth = 0;\n  let finalHeight = 0;\n  //If a size value defined as object\n  if (typeof size === \"object\") {\n    const precision = size.precision ? Math.abs(size.precision) // prevent GL_INVALID_VALUE : glViewport: negative width/height\n    : 1;\n    //If a width and height values is specified\n    if (size.width && size.height) {\n      height = size.height * precision;\n      width = size.width * precision;\n    }\n    //If passing only width, computing height to keep display canvas ratio.\n    else if (size.width && !size.height) {\n      width = size.width * precision;\n      height = Math.round(width / engine.getAspectRatio(camera));\n    }\n    //If passing only height, computing width to keep display canvas ratio.\n    else if (size.height && !size.width) {\n      height = size.height * precision;\n      width = Math.round(height * engine.getAspectRatio(camera));\n    } else {\n      width = Math.round(engine.getRenderWidth() * precision);\n      height = Math.round(width / engine.getAspectRatio(camera));\n    }\n    //If a finalWidth and finalHeight values is specified\n    if (size.finalWidth && size.finalHeight) {\n      finalHeight = size.finalHeight;\n      finalWidth = size.finalWidth;\n    }\n    //If passing only finalWidth, computing finalHeight to keep display canvas ratio.\n    else if (size.finalWidth && !size.finalHeight) {\n      finalWidth = size.finalWidth;\n      finalHeight = Math.round(finalWidth / engine.getAspectRatio(camera));\n    }\n    //If passing only finalHeight, computing finalWidth to keep display canvas ratio.\n    else if (size.finalHeight && !size.finalWidth) {\n      finalHeight = size.finalHeight;\n      finalWidth = Math.round(finalHeight * engine.getAspectRatio(camera));\n    } else {\n      finalWidth = width;\n      finalHeight = height;\n    }\n  }\n  //Assuming here that \"size\" parameter is a number\n  else if (!isNaN(size)) {\n    height = size;\n    width = size;\n    finalWidth = size;\n    finalHeight = size;\n  }\n  // When creating the image data from the CanvasRenderingContext2D, the width and height is clamped to the size of the _gl context\n  // On certain GPUs, it seems as if the _gl context truncates to an integer automatically. Therefore, if a user tries to pass the width of their canvas element\n  // and it happens to be a float (1000.5 x 600.5 px), the engine.readPixels will return a different size array than context.createImageData\n  // to resolve this, we truncate the floats here to ensure the same size\n  if (width) {\n    width = Math.floor(width);\n  }\n  if (height) {\n    height = Math.floor(height);\n  }\n  if (finalWidth) {\n    finalWidth = Math.floor(finalWidth);\n  }\n  if (finalHeight) {\n    finalHeight = Math.floor(finalHeight);\n  }\n  return {\n    height: height | 0,\n    width: width | 0,\n    finalWidth: finalWidth | 0,\n    finalHeight: finalHeight | 0\n  };\n}\n/**\n * Class containing a set of static utilities functions for screenshots\n */\nexport const ScreenshotTools = {\n  /**\n   * Captures a screenshot of the current rendering\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n   * @param engine defines the rendering engine\n   * @param camera defines the source camera\n   * @param size This parameter can be set to a single number or to an object with the\n   * following (optional) properties: precision, width, height. If a single number is passed,\n   * it will be used for both width and height. If an object is passed, the screenshot size\n   * will be derived from the parameters. The precision property is a multiplier allowing\n   * rendering at a higher or lower resolution\n   * @param successCallback defines the callback receives a single parameter which contains the\n   * screenshot as a string of base64-encoded characters. This string can be assigned to the\n   * src parameter of an <img> to display it\n   * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n   * Check your browser for supported MIME types\n   * @param forceDownload force the system to download the image even if a successCallback is provided\n   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n   */\n  CreateScreenshot,\n  /**\n   * Captures a screenshot of the current rendering\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n   * @param engine defines the rendering engine\n   * @param camera defines the source camera\n   * @param size This parameter can be set to a single number or to an object with the\n   * following (optional) properties: precision, width, height. If a single number is passed,\n   * it will be used for both width and height. If an object is passed, the screenshot size\n   * will be derived from the parameters. The precision property is a multiplier allowing\n   * rendering at a higher or lower resolution\n   * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n   * Check your browser for supported MIME types\n   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n   * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n   * to the src parameter of an <img> to display it\n   */\n  CreateScreenshotAsync,\n  /**\n   * Captures a screenshot of the current rendering for a specific size. This will render the entire canvas but will generate a blink (due to canvas resize)\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n   * @param engine defines the rendering engine\n   * @param camera defines the source camera\n   * @param width defines the expected width\n   * @param height defines the expected height\n   * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n   * Check your browser for supported MIME types\n   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n   * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n   * to the src parameter of an <img> to display it\n   */\n  CreateScreenshotWithResizeAsync,\n  /**\n   * Generates an image screenshot from the specified camera.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n   * @param engine The engine to use for rendering\n   * @param camera The camera to use for rendering\n   * @param size This parameter can be set to a single number or to an object with the\n   * following (optional) properties: precision, width, height. If a single number is passed,\n   * it will be used for both width and height. If an object is passed, the screenshot size\n   * will be derived from the parameters. The precision property is a multiplier allowing\n   * rendering at a higher or lower resolution\n   * @param successCallback The callback receives a single parameter which contains the\n   * screenshot as a string of base64-encoded characters. This string can be assigned to the\n   * src parameter of an <img> to display it\n   * @param mimeType The MIME type of the screenshot image (default: image/png).\n   * Check your browser for supported MIME types\n   * @param samples Texture samples (default: 1)\n   * @param antialiasing Whether antialiasing should be turned on or not (default: false)\n   * @param fileName A name for for the downloaded file.\n   * @param renderSprites Whether the sprites should be rendered or not (default: false)\n   * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\n   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n   */\n  CreateScreenshotUsingRenderTarget,\n  /**\n   * Generates an image screenshot from the specified camera.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n   * @param engine The engine to use for rendering\n   * @param camera The camera to use for rendering\n   * @param size This parameter can be set to a single number or to an object with the\n   * following (optional) properties: precision, width, height. If a single number is passed,\n   * it will be used for both width and height. If an object is passed, the screenshot size\n   * will be derived from the parameters. The precision property is a multiplier allowing\n   * rendering at a higher or lower resolution\n   * @param mimeType The MIME type of the screenshot image (default: image/png).\n   * Check your browser for supported MIME types\n   * @param samples Texture samples (default: 1)\n   * @param antialiasing Whether antialiasing should be turned on or not (default: false)\n   * @param fileName A name for for the downloaded file.\n   * @param renderSprites Whether the sprites should be rendered or not (default: false)\n   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n   * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n   * to the src parameter of an <img> to display it\n   */\n  CreateScreenshotUsingRenderTargetAsync\n};\n/**\n * This will be executed automatically for UMD and es5.\n * If esm dev wants the side effects to execute they will have to run it manually\n * Once we build native modules those need to be exported.\n * @internal\n */\nconst initSideEffects = () => {\n  // References the dependencies.\n  Tools.CreateScreenshot = CreateScreenshot;\n  Tools.CreateScreenshotAsync = CreateScreenshotAsync;\n  Tools.CreateScreenshotUsingRenderTarget = CreateScreenshotUsingRenderTarget;\n  Tools.CreateScreenshotUsingRenderTargetAsync = CreateScreenshotUsingRenderTargetAsync;\n};\ninitSideEffects();","map":{"version":3,"names":["Texture","RenderTargetTexture","FxaaPostProcess","Logger","Tools","DumpTools","ApplyPostProcess","screenshotCanvas","CreateScreenshot","engine","camera","size","successCallback","mimeType","forceDownload","quality","height","width","_GetScreenshotSize","Error","document","createElement","renderContext","getContext","ratio","getRenderWidth","getRenderHeight","newWidth","newHeight","offsetX","Math","max","offsetY","scene","getScene","activeCamera","CreateScreenshotUsingRenderTarget","data","blob","Blob","DownloadBlob","getCreationOptions","antialias","undefined","onEndFrameObservable","addOnce","renderingCanvas","getRenderingCanvas","drawImage","EncodeScreenshotCanvasData","CreateScreenshotAsync","Promise","resolve","reject","CreateScreenshotWithResizeAsync","samples","antialiasing","fileName","renderSprites","enableStencilBuffer","useLayerMask","finalWidth","finalHeight","targetTextureSize","originalSize","setSize","texture","BILINEAR_SAMPLINGMODE","renderList","meshes","slice","forceLayerMaskCheck","renderToTexture","readPixels","then","DumpData","dispose","getInternalTexture","_readTexturePixels","incrementRenderId","resetCachedMaterial","render","getProjectionMatrix","fxaaPostProcess","addPostProcess","getEffect","isReady","onCompiled","CreateScreenshotUsingRenderTargetAsync","precision","abs","round","getAspectRatio","isNaN","floor","ScreenshotTools","initSideEffects"],"sources":["../../../../dev/core/src/Misc/screenshotTools.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { FxaaPostProcess } from \"../PostProcesses/fxaaPostProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"./logger\";\r\nimport { Tools } from \"./tools\";\r\nimport type { IScreenshotSize } from \"./interfaces/screenshotSize\";\r\nimport { DumpTools } from \"./dumpTools\";\r\nimport type { Nullable } from \"../types\";\r\nimport { ApplyPostProcess } from \"./textureTools\";\r\n\r\nimport type { Engine } from \"../Engines/engine\";\r\n\r\nlet screenshotCanvas: Nullable<HTMLCanvasElement> = null;\r\n\r\n/**\r\n * Captures a screenshot of the current rendering\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n * @param engine defines the rendering engine\r\n * @param camera defines the source camera\r\n * @param size This parameter can be set to a single number or to an object with the\r\n * following (optional) properties: precision, width, height. If a single number is passed,\r\n * it will be used for both width and height. If an object is passed, the screenshot size\r\n * will be derived from the parameters. The precision property is a multiplier allowing\r\n * rendering at a higher or lower resolution\r\n * @param successCallback defines the callback receives a single parameter which contains the\r\n * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n * src parameter of an <img> to display it\r\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n * Check your browser for supported MIME types\r\n * @param forceDownload force the system to download the image even if a successCallback is provided\r\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n */\r\nexport function CreateScreenshot(\r\n    engine: Engine,\r\n    camera: Camera,\r\n    size: IScreenshotSize | number,\r\n    successCallback?: (data: string) => void,\r\n    mimeType = \"image/png\",\r\n    forceDownload = false,\r\n    quality?: number\r\n): void {\r\n    const { height, width } = _GetScreenshotSize(engine, camera, size);\r\n\r\n    if (!(height && width)) {\r\n        Logger.Error(\"Invalid 'size' parameter !\");\r\n        return;\r\n    }\r\n\r\n    if (!screenshotCanvas) {\r\n        screenshotCanvas = document.createElement(\"canvas\");\r\n    }\r\n\r\n    screenshotCanvas.width = width;\r\n    screenshotCanvas.height = height;\r\n\r\n    const renderContext = screenshotCanvas.getContext(\"2d\");\r\n\r\n    const ratio = engine.getRenderWidth() / engine.getRenderHeight();\r\n    let newWidth = width;\r\n    let newHeight = newWidth / ratio;\r\n    if (newHeight > height) {\r\n        newHeight = height;\r\n        newWidth = newHeight * ratio;\r\n    }\r\n\r\n    const offsetX = Math.max(0, width - newWidth) / 2;\r\n    const offsetY = Math.max(0, height - newHeight) / 2;\r\n\r\n    const scene = camera.getScene();\r\n    if (scene.activeCamera !== camera) {\r\n        CreateScreenshotUsingRenderTarget(\r\n            engine,\r\n            camera,\r\n            size,\r\n            (data) => {\r\n                if (forceDownload) {\r\n                    const blob = new Blob([data]);\r\n                    Tools.DownloadBlob(blob);\r\n                    if (successCallback) {\r\n                        successCallback(\"\");\r\n                    }\r\n                } else if (successCallback) {\r\n                    successCallback(data);\r\n                }\r\n            },\r\n            mimeType,\r\n            1.0,\r\n            engine.getCreationOptions().antialias,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            quality\r\n        );\r\n    } else {\r\n        engine.onEndFrameObservable.addOnce(() => {\r\n            const renderingCanvas = engine.getRenderingCanvas();\r\n            if (renderContext && renderingCanvas) {\r\n                renderContext.drawImage(renderingCanvas, offsetX, offsetY, newWidth, newHeight);\r\n            }\r\n\r\n            if (screenshotCanvas) {\r\n                if (forceDownload) {\r\n                    Tools.EncodeScreenshotCanvasData(screenshotCanvas, undefined, mimeType, undefined, quality);\r\n                    if (successCallback) {\r\n                        successCallback(\"\");\r\n                    }\r\n                } else {\r\n                    Tools.EncodeScreenshotCanvasData(screenshotCanvas, successCallback, mimeType, undefined, quality);\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Captures a screenshot of the current rendering\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n * @param engine defines the rendering engine\r\n * @param camera defines the source camera\r\n * @param size This parameter can be set to a single number or to an object with the\r\n * following (optional) properties: precision, width, height. If a single number is passed,\r\n * it will be used for both width and height. If an object is passed, the screenshot size\r\n * will be derived from the parameters. The precision property is a multiplier allowing\r\n * rendering at a higher or lower resolution\r\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n * Check your browser for supported MIME types\r\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n * to the src parameter of an <img> to display it\r\n */\r\nexport function CreateScreenshotAsync(engine: Engine, camera: Camera, size: IScreenshotSize | number, mimeType = \"image/png\", quality?: number): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n        CreateScreenshot(\r\n            engine,\r\n            camera,\r\n            size,\r\n            (data) => {\r\n                if (typeof data !== \"undefined\") {\r\n                    resolve(data);\r\n                } else {\r\n                    reject(new Error(\"Data is undefined\"));\r\n                }\r\n            },\r\n            mimeType,\r\n            undefined,\r\n            quality\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * Captures a screenshot of the current rendering for a specific size. This will render the entire canvas but will generate a blink (due to canvas resize)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n * @param engine defines the rendering engine\r\n * @param camera defines the source camera\r\n * @param width defines the expected width\r\n * @param height defines the expected height\r\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n * Check your browser for supported MIME types\r\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n * to the src parameter of an <img> to display it\r\n */\r\nexport function CreateScreenshotWithResizeAsync(engine: Engine, camera: Camera, width: number, height: number, mimeType = \"image/png\", quality?: number): Promise<void> {\r\n    return new Promise((resolve) => {\r\n        CreateScreenshot(\r\n            engine,\r\n            camera,\r\n            { width: width, height: height },\r\n            () => {\r\n                resolve();\r\n            },\r\n            mimeType,\r\n            true,\r\n            quality\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * Generates an image screenshot from the specified camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n * @param engine The engine to use for rendering\r\n * @param camera The camera to use for rendering\r\n * @param size This parameter can be set to a single number or to an object with the\r\n * following (optional) properties: precision, width, height, finalWidth, finalHeight. If a single number is passed,\r\n * it will be used for both width and height, as well as finalWidth, finalHeight. If an object is passed, the screenshot size\r\n * will be derived from the parameters. The precision property is a multiplier allowing\r\n * rendering at a higher or lower resolution\r\n * @param successCallback The callback receives a single parameter which contains the\r\n * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n * src parameter of an <img> to display it\r\n * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n * Check your browser for supported MIME types\r\n * @param samples Texture samples (default: 1)\r\n * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n * @param fileName A name for for the downloaded file.\r\n * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\r\n * @param useLayerMask if the camera's layer mask should be used to filter what should be rendered (default: true)\r\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n */\r\nexport function CreateScreenshotUsingRenderTarget(\r\n    engine: Engine,\r\n    camera: Camera,\r\n    size: IScreenshotSize | number,\r\n    successCallback?: (data: string) => void,\r\n    mimeType = \"image/png\",\r\n    samples = 1,\r\n    antialiasing = false,\r\n    fileName?: string,\r\n    renderSprites = false,\r\n    enableStencilBuffer = false,\r\n    useLayerMask = true,\r\n    quality?: number\r\n): void {\r\n    const { height, width, finalWidth, finalHeight } = _GetScreenshotSize(engine, camera, size);\r\n    const targetTextureSize = { width, height };\r\n\r\n    if (!(height && width)) {\r\n        Logger.Error(\"Invalid 'size' parameter !\");\r\n        return;\r\n    }\r\n\r\n    const originalSize = { width: engine.getRenderWidth(), height: engine.getRenderHeight() };\r\n    engine.setSize(width, height); // we need this call to trigger onResizeObservable with the screenshot width/height on all the subsystems that are observing this event and that needs to (re)create some resources with the right dimensions\r\n\r\n    const scene = camera.getScene();\r\n\r\n    // At this point size can be a number, or an object (according to engine.prototype.createRenderTargetTexture method)\r\n    const texture = new RenderTargetTexture(\r\n        \"screenShot\",\r\n        targetTextureSize,\r\n        scene,\r\n        false,\r\n        false,\r\n        Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        false,\r\n        Texture.BILINEAR_SAMPLINGMODE,\r\n        undefined,\r\n        enableStencilBuffer,\r\n        undefined,\r\n        undefined,\r\n        undefined,\r\n        samples\r\n    );\r\n    texture.renderList = scene.meshes.slice();\r\n    texture.samples = samples;\r\n    texture.renderSprites = renderSprites;\r\n    texture.activeCamera = camera;\r\n    texture.forceLayerMaskCheck = useLayerMask;\r\n\r\n    const renderToTexture = () => {\r\n        engine.onEndFrameObservable.addOnce(() => {\r\n            if (finalWidth === width && finalHeight === height) {\r\n                texture.readPixels(undefined, undefined, undefined, false)!.then((data) => {\r\n                    DumpTools.DumpData(width, height, data, successCallback as (data: string | ArrayBuffer) => void, mimeType, fileName, true, undefined, quality);\r\n                    texture.dispose();\r\n                });\r\n            } else {\r\n                ApplyPostProcess(\"pass\", texture.getInternalTexture()!, scene, undefined, undefined, undefined, finalWidth, finalHeight).then((texture) => {\r\n                    engine._readTexturePixels(texture, finalWidth, finalHeight, -1, 0, null, true, false, 0, 0).then((data) => {\r\n                        DumpTools.DumpData(finalWidth, finalHeight, data, successCallback as (data: string | ArrayBuffer) => void, mimeType, fileName, true, undefined, quality);\r\n                        texture.dispose();\r\n                    });\r\n                });\r\n            }\r\n        });\r\n\r\n        // render the RTT\r\n        scene.incrementRenderId();\r\n        scene.resetCachedMaterial();\r\n        texture.render(true);\r\n\r\n        // re-render the scene after the camera has been reset to the original camera to avoid a flicker that could occur\r\n        // if the camera used for the RTT rendering stays in effect for the next frame (and if that camera was different from the original camera)\r\n        scene.incrementRenderId();\r\n        scene.resetCachedMaterial();\r\n        engine.setSize(originalSize.width, originalSize.height);\r\n        camera.getProjectionMatrix(true); // Force cache refresh;\r\n        scene.render();\r\n    };\r\n\r\n    if (antialiasing) {\r\n        const fxaaPostProcess = new FxaaPostProcess(\"antialiasing\", 1.0, scene.activeCamera);\r\n        texture.addPostProcess(fxaaPostProcess);\r\n        // Async Shader Compilation can lead to none ready effects in synchronous code\r\n        if (!fxaaPostProcess.getEffect().isReady()) {\r\n            fxaaPostProcess.getEffect().onCompiled = () => {\r\n                renderToTexture();\r\n            };\r\n        }\r\n        // The effect is ready we can render\r\n        else {\r\n            renderToTexture();\r\n        }\r\n    } else {\r\n        // No need to wait for extra resources to be ready\r\n        renderToTexture();\r\n    }\r\n}\r\n\r\n/**\r\n * Generates an image screenshot from the specified camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n * @param engine The engine to use for rendering\r\n * @param camera The camera to use for rendering\r\n * @param size This parameter can be set to a single number or to an object with the\r\n * following (optional) properties: precision, width, height. If a single number is passed,\r\n * it will be used for both width and height. If an object is passed, the screenshot size\r\n * will be derived from the parameters. The precision property is a multiplier allowing\r\n * rendering at a higher or lower resolution\r\n * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n * Check your browser for supported MIME types\r\n * @param samples Texture samples (default: 1)\r\n * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n * @param fileName A name for for the downloaded file.\r\n * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\r\n * @param useLayerMask if the camera's layer mask should be used to filter what should be rendered (default: true)\r\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n * to the src parameter of an <img> to display it\r\n */\r\nexport function CreateScreenshotUsingRenderTargetAsync(\r\n    engine: Engine,\r\n    camera: Camera,\r\n    size: IScreenshotSize | number,\r\n    mimeType = \"image/png\",\r\n    samples = 1,\r\n    antialiasing = false,\r\n    fileName?: string,\r\n    renderSprites = false,\r\n    enableStencilBuffer = false,\r\n    useLayerMask = true,\r\n    quality?: number\r\n): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n        CreateScreenshotUsingRenderTarget(\r\n            engine,\r\n            camera,\r\n            size,\r\n            (data) => {\r\n                if (typeof data !== \"undefined\") {\r\n                    resolve(data);\r\n                } else {\r\n                    reject(new Error(\"Data is undefined\"));\r\n                }\r\n            },\r\n            mimeType,\r\n            samples,\r\n            antialiasing,\r\n            fileName,\r\n            renderSprites,\r\n            enableStencilBuffer,\r\n            useLayerMask,\r\n            quality\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * Gets height and width for screenshot size\r\n * @param engine\r\n * @param camera\r\n * @param size\r\n * @private\r\n */\r\nfunction _GetScreenshotSize(engine: Engine, camera: Camera, size: IScreenshotSize | number): { height: number; width: number; finalWidth: number; finalHeight: number } {\r\n    let height = 0;\r\n    let width = 0;\r\n    let finalWidth = 0;\r\n    let finalHeight = 0;\r\n\r\n    //If a size value defined as object\r\n    if (typeof size === \"object\") {\r\n        const precision = size.precision\r\n            ? Math.abs(size.precision) // prevent GL_INVALID_VALUE : glViewport: negative width/height\r\n            : 1;\r\n\r\n        //If a width and height values is specified\r\n        if (size.width && size.height) {\r\n            height = size.height * precision;\r\n            width = size.width * precision;\r\n        }\r\n        //If passing only width, computing height to keep display canvas ratio.\r\n        else if (size.width && !size.height) {\r\n            width = size.width * precision;\r\n            height = Math.round(width / engine.getAspectRatio(camera));\r\n        }\r\n        //If passing only height, computing width to keep display canvas ratio.\r\n        else if (size.height && !size.width) {\r\n            height = size.height * precision;\r\n            width = Math.round(height * engine.getAspectRatio(camera));\r\n        } else {\r\n            width = Math.round(engine.getRenderWidth() * precision);\r\n            height = Math.round(width / engine.getAspectRatio(camera));\r\n        }\r\n\r\n        //If a finalWidth and finalHeight values is specified\r\n        if (size.finalWidth && size.finalHeight) {\r\n            finalHeight = size.finalHeight;\r\n            finalWidth = size.finalWidth;\r\n        }\r\n        //If passing only finalWidth, computing finalHeight to keep display canvas ratio.\r\n        else if (size.finalWidth && !size.finalHeight) {\r\n            finalWidth = size.finalWidth;\r\n            finalHeight = Math.round(finalWidth / engine.getAspectRatio(camera));\r\n        }\r\n        //If passing only finalHeight, computing finalWidth to keep display canvas ratio.\r\n        else if (size.finalHeight && !size.finalWidth) {\r\n            finalHeight = size.finalHeight;\r\n            finalWidth = Math.round(finalHeight * engine.getAspectRatio(camera));\r\n        } else {\r\n            finalWidth = width;\r\n            finalHeight = height;\r\n        }\r\n    }\r\n    //Assuming here that \"size\" parameter is a number\r\n    else if (!isNaN(size)) {\r\n        height = size;\r\n        width = size;\r\n        finalWidth = size;\r\n        finalHeight = size;\r\n    }\r\n\r\n    // When creating the image data from the CanvasRenderingContext2D, the width and height is clamped to the size of the _gl context\r\n    // On certain GPUs, it seems as if the _gl context truncates to an integer automatically. Therefore, if a user tries to pass the width of their canvas element\r\n    // and it happens to be a float (1000.5 x 600.5 px), the engine.readPixels will return a different size array than context.createImageData\r\n    // to resolve this, we truncate the floats here to ensure the same size\r\n    if (width) {\r\n        width = Math.floor(width);\r\n    }\r\n    if (height) {\r\n        height = Math.floor(height);\r\n    }\r\n    if (finalWidth) {\r\n        finalWidth = Math.floor(finalWidth);\r\n    }\r\n    if (finalHeight) {\r\n        finalHeight = Math.floor(finalHeight);\r\n    }\r\n\r\n    return { height: height | 0, width: width | 0, finalWidth: finalWidth | 0, finalHeight: finalHeight | 0 };\r\n}\r\n\r\n/**\r\n * Class containing a set of static utilities functions for screenshots\r\n */\r\nexport const ScreenshotTools = {\r\n    /**\r\n     * Captures a screenshot of the current rendering\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n     * @param engine defines the rendering engine\r\n     * @param camera defines the source camera\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param successCallback defines the callback receives a single parameter which contains the\r\n     * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n     * src parameter of an <img> to display it\r\n     * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @param forceDownload force the system to download the image even if a successCallback is provided\r\n     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n     */\r\n    CreateScreenshot,\r\n\r\n    /**\r\n     * Captures a screenshot of the current rendering\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n     * @param engine defines the rendering engine\r\n     * @param camera defines the source camera\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n     * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n     * to the src parameter of an <img> to display it\r\n     */\r\n    CreateScreenshotAsync,\r\n\r\n    /**\r\n     * Captures a screenshot of the current rendering for a specific size. This will render the entire canvas but will generate a blink (due to canvas resize)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n     * @param engine defines the rendering engine\r\n     * @param camera defines the source camera\r\n     * @param width defines the expected width\r\n     * @param height defines the expected height\r\n     * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n     * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n     * to the src parameter of an <img> to display it\r\n     */\r\n    CreateScreenshotWithResizeAsync,\r\n\r\n    /**\r\n     * Generates an image screenshot from the specified camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n     * @param engine The engine to use for rendering\r\n     * @param camera The camera to use for rendering\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param successCallback The callback receives a single parameter which contains the\r\n     * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n     * src parameter of an <img> to display it\r\n     * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @param samples Texture samples (default: 1)\r\n     * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n     * @param fileName A name for for the downloaded file.\r\n     * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n     * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\r\n     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n     */\r\n    CreateScreenshotUsingRenderTarget,\r\n\r\n    /**\r\n     * Generates an image screenshot from the specified camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n     * @param engine The engine to use for rendering\r\n     * @param camera The camera to use for rendering\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @param samples Texture samples (default: 1)\r\n     * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n     * @param fileName A name for for the downloaded file.\r\n     * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n     * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n     * to the src parameter of an <img> to display it\r\n     */\r\n    CreateScreenshotUsingRenderTargetAsync,\r\n};\r\n\r\n/**\r\n * This will be executed automatically for UMD and es5.\r\n * If esm dev wants the side effects to execute they will have to run it manually\r\n * Once we build native modules those need to be exported.\r\n * @internal\r\n */\r\nconst initSideEffects = () => {\r\n    // References the dependencies.\r\n    Tools.CreateScreenshot = CreateScreenshot;\r\n    Tools.CreateScreenshotAsync = CreateScreenshotAsync;\r\n    Tools.CreateScreenshotUsingRenderTarget = CreateScreenshotUsingRenderTarget;\r\n    Tools.CreateScreenshotUsingRenderTargetAsync = CreateScreenshotUsingRenderTargetAsync;\r\n};\r\n\r\ninitSideEffects();\r\n"],"mappings":"AAEA,SAASA,OAAO,QAAQ,kCAAgC;AACxD,SAASC,mBAAmB,QAAQ,8CAA4C;AAChF,SAASC,eAAe,QAAQ,qCAAmC;AAEnE,SAASC,MAAM,QAAQ,aAAW;AAClC,SAASC,KAAK,QAAQ,YAAU;AAEhC,SAASC,SAAS,QAAQ,gBAAc;AAExC,SAASC,gBAAgB,QAAQ,mBAAiB;AAIlD,IAAIC,gBAAgB,GAAgC,IAAI;AAExD;;;;;;;;;;;;;;;;;;AAkBA,OAAM,SAAUC,gBAAgBA,CAC5BC,MAAc,EACdC,MAAc,EACdC,IAA8B,EAC9BC,eAAwC,EACxCC,QAAQ,GAAG,WAAW,EACtBC,aAAa,GAAG,KAAK,EACrBC,OAAgB;EAEhB,MAAM;IAAEC,MAAM;IAAEC;EAAK,CAAE,GAAGC,kBAAkB,CAACT,MAAM,EAAEC,MAAM,EAAEC,IAAI,CAAC;EAElE,IAAI,EAAEK,MAAM,IAAIC,KAAK,CAAC,EAAE;IACpBd,MAAM,CAACgB,KAAK,CAAC,4BAA4B,CAAC;IAC1C;;EAGJ,IAAI,CAACZ,gBAAgB,EAAE;IACnBA,gBAAgB,GAAGa,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;;EAGvDd,gBAAgB,CAACU,KAAK,GAAGA,KAAK;EAC9BV,gBAAgB,CAACS,MAAM,GAAGA,MAAM;EAEhC,MAAMM,aAAa,GAAGf,gBAAgB,CAACgB,UAAU,CAAC,IAAI,CAAC;EAEvD,MAAMC,KAAK,GAAGf,MAAM,CAACgB,cAAc,EAAE,GAAGhB,MAAM,CAACiB,eAAe,EAAE;EAChE,IAAIC,QAAQ,GAAGV,KAAK;EACpB,IAAIW,SAAS,GAAGD,QAAQ,GAAGH,KAAK;EAChC,IAAII,SAAS,GAAGZ,MAAM,EAAE;IACpBY,SAAS,GAAGZ,MAAM;IAClBW,QAAQ,GAAGC,SAAS,GAAGJ,KAAK;;EAGhC,MAAMK,OAAO,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEd,KAAK,GAAGU,QAAQ,CAAC,GAAG,CAAC;EACjD,MAAMK,OAAO,GAAGF,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEf,MAAM,GAAGY,SAAS,CAAC,GAAG,CAAC;EAEnD,MAAMK,KAAK,GAAGvB,MAAM,CAACwB,QAAQ,EAAE;EAC/B,IAAID,KAAK,CAACE,YAAY,KAAKzB,MAAM,EAAE;IAC/B0B,iCAAiC,CAC7B3B,MAAM,EACNC,MAAM,EACNC,IAAI,EACH0B,IAAI,IAAI;MACL,IAAIvB,aAAa,EAAE;QACf,MAAMwB,IAAI,GAAG,IAAIC,IAAI,CAAC,CAACF,IAAI,CAAC,CAAC;QAC7BjC,KAAK,CAACoC,YAAY,CAACF,IAAI,CAAC;QACxB,IAAI1B,eAAe,EAAE;UACjBA,eAAe,CAAC,EAAE,CAAC;;OAE1B,MAAM,IAAIA,eAAe,EAAE;QACxBA,eAAe,CAACyB,IAAI,CAAC;;IAE7B,CAAC,EACDxB,QAAQ,EACR,GAAG,EACHJ,MAAM,CAACgC,kBAAkB,EAAE,CAACC,SAAS,EACrCC,SAAS,EACTA,SAAS,EACTA,SAAS,EACTA,SAAS,EACT5B,OAAO,CACV;GACJ,MAAM;IACHN,MAAM,CAACmC,oBAAoB,CAACC,OAAO,CAAC,MAAK;MACrC,MAAMC,eAAe,GAAGrC,MAAM,CAACsC,kBAAkB,EAAE;MACnD,IAAIzB,aAAa,IAAIwB,eAAe,EAAE;QAClCxB,aAAa,CAAC0B,SAAS,CAACF,eAAe,EAAEjB,OAAO,EAAEG,OAAO,EAAEL,QAAQ,EAAEC,SAAS,CAAC;;MAGnF,IAAIrB,gBAAgB,EAAE;QAClB,IAAIO,aAAa,EAAE;UACfV,KAAK,CAAC6C,0BAA0B,CAAC1C,gBAAgB,EAAEoC,SAAS,EAAE9B,QAAQ,EAAE8B,SAAS,EAAE5B,OAAO,CAAC;UAC3F,IAAIH,eAAe,EAAE;YACjBA,eAAe,CAAC,EAAE,CAAC;;SAE1B,MAAM;UACHR,KAAK,CAAC6C,0BAA0B,CAAC1C,gBAAgB,EAAEK,eAAe,EAAEC,QAAQ,EAAE8B,SAAS,EAAE5B,OAAO,CAAC;;;IAG7G,CAAC,CAAC;;AAEV;AAEA;;;;;;;;;;;;;;;;AAgBA,OAAM,SAAUmC,qBAAqBA,CAACzC,MAAc,EAAEC,MAAc,EAAEC,IAA8B,EAAEE,QAAQ,GAAG,WAAW,EAAEE,OAAgB;EAC1I,OAAO,IAAIoC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAI;IACnC7C,gBAAgB,CACZC,MAAM,EACNC,MAAM,EACNC,IAAI,EACH0B,IAAI,IAAI;MACL,IAAI,OAAOA,IAAI,KAAK,WAAW,EAAE;QAC7Be,OAAO,CAACf,IAAI,CAAC;OAChB,MAAM;QACHgB,MAAM,CAAC,IAAIlC,KAAK,CAAC,mBAAmB,CAAC,CAAC;;IAE9C,CAAC,EACDN,QAAQ,EACR8B,SAAS,EACT5B,OAAO,CACV;EACL,CAAC,CAAC;AACN;AAEA;;;;;;;;;;;;;AAaA,OAAM,SAAUuC,+BAA+BA,CAAC7C,MAAc,EAAEC,MAAc,EAAEO,KAAa,EAAED,MAAc,EAAEH,QAAQ,GAAG,WAAW,EAAEE,OAAgB;EACnJ,OAAO,IAAIoC,OAAO,CAAEC,OAAO,IAAI;IAC3B5C,gBAAgB,CACZC,MAAM,EACNC,MAAM,EACN;MAAEO,KAAK,EAAEA,KAAK;MAAED,MAAM,EAAEA;IAAM,CAAE,EAChC,MAAK;MACDoC,OAAO,EAAE;IACb,CAAC,EACDvC,QAAQ,EACR,IAAI,EACJE,OAAO,CACV;EACL,CAAC,CAAC;AACN;AAEA;;;;;;;;;;;;;;;;;;;;;;;AAuBA,OAAM,SAAUqB,iCAAiCA,CAC7C3B,MAAc,EACdC,MAAc,EACdC,IAA8B,EAC9BC,eAAwC,EACxCC,QAAQ,GAAG,WAAW,EACtB0C,OAAO,GAAG,CAAC,EACXC,YAAY,GAAG,KAAK,EACpBC,QAAiB,EACjBC,aAAa,GAAG,KAAK,EACrBC,mBAAmB,GAAG,KAAK,EAC3BC,YAAY,GAAG,IAAI,EACnB7C,OAAgB;EAEhB,MAAM;IAAEC,MAAM;IAAEC,KAAK;IAAE4C,UAAU;IAAEC;EAAW,CAAE,GAAG5C,kBAAkB,CAACT,MAAM,EAAEC,MAAM,EAAEC,IAAI,CAAC;EAC3F,MAAMoD,iBAAiB,GAAG;IAAE9C,KAAK;IAAED;EAAM,CAAE;EAE3C,IAAI,EAAEA,MAAM,IAAIC,KAAK,CAAC,EAAE;IACpBd,MAAM,CAACgB,KAAK,CAAC,4BAA4B,CAAC;IAC1C;;EAGJ,MAAM6C,YAAY,GAAG;IAAE/C,KAAK,EAAER,MAAM,CAACgB,cAAc,EAAE;IAAET,MAAM,EAAEP,MAAM,CAACiB,eAAe;EAAE,CAAE;EACzFjB,MAAM,CAACwD,OAAO,CAAChD,KAAK,EAAED,MAAM,CAAC,CAAC,CAAC;EAE/B,MAAMiB,KAAK,GAAGvB,MAAM,CAACwB,QAAQ,EAAE;EAE/B;EACA,MAAMgC,OAAO,GAAG,IAAIjE,mBAAmB,CACnC,YAAY,EACZ8D,iBAAiB,EACjB9B,KAAK,EACL,KAAK,EACL,KAAK,EACL,UAAUjC,OAAA,CAAAmE,qBACV,EAAKxB,SACE,EAACgB,mBAAA,EAAqBhB,SAC7B,EAASA,SACT,EAAAA,SAAmB,EACnBY,OAAA;EAKJW,OAAO,CAACE,UAAU,GAAGnC,KAAK,CAACoC,MAAM,CAACC,KAAK,EAAE;EACzCJ,OAAO,CAACX,OAAO,GAAGA,OAAO;EACzBW,OAAO,CAACR,aAAa,GAAGA,aAAa;EACrCQ,OAAO,CAAC/B,YAAY,GAAGzB,MAAM;EAC7BwD,OAAO,CAACK,mBAAmB,GAAGX,YAAY;EAE1C,MAAMY,eAAe,GAAGA,CAAA,KAAK;IACzB/D,MAAM,CAACmC,oBAAoB,CAACC,OAAO,CAAC,MAAK;MACrC,IAAIgB,UAAU,KAAK5C,KAAK,IAAI6C,WAAW,KAAK9C,MAAM,EAAE;QAChDkD,OAAO,CAACO,UAAU,CAAC9B,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAE,KAAK,CAAE,CAAC+B,IAAI,CAAErC,IAAI,IAAI;UACtEhC,SAAS,CAACsE,QAAQ,CAAC1D,KAAK,EAAED,MAAM,EAAEqB,IAAI,EAAEzB,eAAuD,EAAEC,QAAQ,EAAE4C,QAAQ,EAAE,IAAI,EAAEd,SAAS,EAAE5B,OAAO,CAAC;UAC9ImD,OAAO,CAACU,OAAO,EAAE;QACrB,CAAC,CAAC;OACL,MAAM;QACHtE,gBAAgB,CAAC,MAAM,EAAE4D,OAAO,CAACW,kBAAkB,EAAG,EAAE5C,KAAK,EAAEU,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEkB,UAAU,EAAEC,WAAW,CAAC,CAACY,IAAI,CAAER,OAAO,IAAI;UACtIzD,MAAM,CAACqE,kBAAkB,CAACZ,OAAO,EAAEL,UAAU,EAAEC,WAAW,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,CAACY,IAAI,CAAErC,IAAI,IAAI;YACtGhC,SAAS,CAACsE,QAAQ,CAACd,UAAU,EAAEC,WAAW,EAAEzB,IAAI,EAAEzB,eAAuD,EAAEC,QAAQ,EAAE4C,QAAQ,EAAE,IAAI,EAAEd,SAAS,EAAE5B,OAAO,CAAC;YACxJmD,OAAO,CAACU,OAAO,EAAE;UACrB,CAAC,CAAC;QACN,CAAC,CAAC;;IAEV,CAAC,CAAC;IAEF;IACA3C,KAAK,CAAC8C,iBAAiB,EAAE;IACzB9C,KAAK,CAAC+C,mBAAmB,EAAE;IAC3Bd,OAAO,CAACe,MAAM,CAAC,IAAI,CAAC;IAEpB;IACA;IACAhD,KAAK,CAAC8C,iBAAiB,EAAE;IACzB9C,KAAK,CAAC+C,mBAAmB,EAAE;IAC3BvE,MAAM,CAACwD,OAAO,CAACD,YAAY,CAAC/C,KAAK,EAAE+C,YAAY,CAAChD,MAAM,CAAC;IACvDN,MAAM,CAACwE,mBAAmB,CAAC,IAAI,CAAC,CAAC,CAAC;IAClCjD,KAAK,CAACgD,MAAM,EAAE;EAClB,CAAC;EAED,IAAIzB,YAAY,EAAE;IACd,MAAM2B,eAAe,GAAG,IAAIjF,eAAe,CAAC,cAAc,EAAE,GAAG,EAAE+B,KAAK,CAACE,YAAY,CAAC;IACpF+B,OAAO,CAACkB,cAAc,CAACD,eAAe,CAAC;IACvC;IACA,IAAI,CAACA,eAAe,CAACE,SAAS,EAAE,CAACC,OAAO,EAAE,EAAE;MACxCH,eAAe,CAACE,SAAS,EAAE,CAACE,UAAU,GAAG,MAAK;QAC1Cf,eAAe,EAAE;MACrB,CAAC;;IAEL;IAAA,KACK;MACDA,eAAe,EAAE;;GAExB,MAAM;IACH;IACAA,eAAe,EAAE;;AAEzB;AAEA;;;;;;;;;;;;;;;;;;;;;;AAsBA,OAAM,SAAUgB,sCAAsCA,CAClD/E,MAAc,EACdC,MAAc,EACdC,IAA8B,EAC9BE,QAAQ,GAAG,WAAW,EACtB0C,OAAO,GAAG,CAAC,EACXC,YAAY,GAAG,KAAK,EACpBC,QAAiB,EACjBC,aAAa,GAAG,KAAK,EACrBC,mBAAmB,GAAG,KAAK,EAC3BC,YAAY,GAAG,IAAI,EACnB7C,OAAgB;EAEhB,OAAO,IAAIoC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAI;IACnCjB,iCAAiC,CAC7B3B,MAAM,EACNC,MAAM,EACNC,IAAI,EACH0B,IAAI,IAAI;MACL,IAAI,OAAOA,IAAI,KAAK,WAAW,EAAE;QAC7Be,OAAO,CAACf,IAAI,CAAC;OAChB,MAAM;QACHgB,MAAM,CAAC,IAAIlC,KAAK,CAAC,mBAAmB,CAAC,CAAC;;IAE9C,CAAC,EACDN,QAAQ,EACR0C,OAAO,EACPC,YAAY,EACZC,QAAQ,EACRC,aAAa,EACbC,mBAAmB,EACnBC,YAAY,EACZ7C,OAAO,CACV;EACL,CAAC,CAAC;AACN;AAEA;;;;;;;AAOA,SAASG,kBAAkBA,CAACT,MAAc,EAAEC,MAAc,EAAEC,IAA8B;EACtF,IAAIK,MAAM,GAAG,CAAC;EACd,IAAIC,KAAK,GAAG,CAAC;EACb,IAAI4C,UAAU,GAAG,CAAC;EAClB,IAAIC,WAAW,GAAG,CAAC;EAEnB;EACA,IAAI,OAAOnD,IAAI,KAAK,QAAQ,EAAE;IAC1B,MAAM8E,SAAS,GAAG9E,IAAI,CAAC8E,SAAS,GAC1B3D,IAAI,CAAC4D,GAAG,CAAC/E,IAAI,CAAC8E,SAAS,CAAC,CAAC;IAAA,EACzB,CAAC;IAEP;IACA,IAAI9E,IAAI,CAACM,KAAK,IAAIN,IAAI,CAACK,MAAM,EAAE;MAC3BA,MAAM,GAAGL,IAAI,CAACK,MAAM,GAAGyE,SAAS;MAChCxE,KAAK,GAAGN,IAAI,CAACM,KAAK,GAAGwE,SAAS;;IAElC;IAAA,KACK,IAAI9E,IAAI,CAACM,KAAK,IAAI,CAACN,IAAI,CAACK,MAAM,EAAE;MACjCC,KAAK,GAAGN,IAAI,CAACM,KAAK,GAAGwE,SAAS;MAC9BzE,MAAM,GAAGc,IAAI,CAAC6D,KAAK,CAAC1E,KAAK,GAAGR,MAAM,CAACmF,cAAc,CAAClF,MAAM,CAAC,CAAC;;IAE9D;IAAA,KACK,IAAIC,IAAI,CAACK,MAAM,IAAI,CAACL,IAAI,CAACM,KAAK,EAAE;MACjCD,MAAM,GAAGL,IAAI,CAACK,MAAM,GAAGyE,SAAS;MAChCxE,KAAK,GAAGa,IAAI,CAAC6D,KAAK,CAAC3E,MAAM,GAAGP,MAAM,CAACmF,cAAc,CAAClF,MAAM,CAAC,CAAC;KAC7D,MAAM;MACHO,KAAK,GAAGa,IAAI,CAAC6D,KAAK,CAAClF,MAAM,CAACgB,cAAc,EAAE,GAAGgE,SAAS,CAAC;MACvDzE,MAAM,GAAGc,IAAI,CAAC6D,KAAK,CAAC1E,KAAK,GAAGR,MAAM,CAACmF,cAAc,CAAClF,MAAM,CAAC,CAAC;;IAG9D;IACA,IAAIC,IAAI,CAACkD,UAAU,IAAIlD,IAAI,CAACmD,WAAW,EAAE;MACrCA,WAAW,GAAGnD,IAAI,CAACmD,WAAW;MAC9BD,UAAU,GAAGlD,IAAI,CAACkD,UAAU;;IAEhC;IAAA,KACK,IAAIlD,IAAI,CAACkD,UAAU,IAAI,CAAClD,IAAI,CAACmD,WAAW,EAAE;MAC3CD,UAAU,GAAGlD,IAAI,CAACkD,UAAU;MAC5BC,WAAW,GAAGhC,IAAI,CAAC6D,KAAK,CAAC9B,UAAU,GAAGpD,MAAM,CAACmF,cAAc,CAAClF,MAAM,CAAC,CAAC;;IAExE;IAAA,KACK,IAAIC,IAAI,CAACmD,WAAW,IAAI,CAACnD,IAAI,CAACkD,UAAU,EAAE;MAC3CC,WAAW,GAAGnD,IAAI,CAACmD,WAAW;MAC9BD,UAAU,GAAG/B,IAAI,CAAC6D,KAAK,CAAC7B,WAAW,GAAGrD,MAAM,CAACmF,cAAc,CAAClF,MAAM,CAAC,CAAC;KACvE,MAAM;MACHmD,UAAU,GAAG5C,KAAK;MAClB6C,WAAW,GAAG9C,MAAM;;;EAG5B;EAAA,KACK,IAAI,CAAC6E,KAAK,CAAClF,IAAI,CAAC,EAAE;IACnBK,MAAM,GAAGL,IAAI;IACbM,KAAK,GAAGN,IAAI;IACZkD,UAAU,GAAGlD,IAAI;IACjBmD,WAAW,GAAGnD,IAAI;;EAGtB;EACA;EACA;EACA;EACA,IAAIM,KAAK,EAAE;IACPA,KAAK,GAAGa,IAAI,CAACgE,KAAK,CAAC7E,KAAK,CAAC;;EAE7B,IAAID,MAAM,EAAE;IACRA,MAAM,GAAGc,IAAI,CAACgE,KAAK,CAAC9E,MAAM,CAAC;;EAE/B,IAAI6C,UAAU,EAAE;IACZA,UAAU,GAAG/B,IAAI,CAACgE,KAAK,CAACjC,UAAU,CAAC;;EAEvC,IAAIC,WAAW,EAAE;IACbA,WAAW,GAAGhC,IAAI,CAACgE,KAAK,CAAChC,WAAW,CAAC;;EAGzC,OAAO;IAAE9C,MAAM,EAAEA,MAAM,GAAG,CAAC;IAAEC,KAAK,EAAEA,KAAK,GAAG,CAAC;IAAE4C,UAAU,EAAEA,UAAU,GAAG,CAAC;IAAEC,WAAW,EAAEA,WAAW,GAAG;EAAC,CAAE;AAC7G;AAEA;;;AAGA,OAAO,MAAMiC,eAAe,GAAG;EAC3B;;;;;;;;;;;;;;;;;;EAkBAvF,gBAAgB;EAEhB;;;;;;;;;;;;;;;;EAgBA0C,qBAAqB;EAErB;;;;;;;;;;;;;EAaAI,+BAA+B;EAE/B;;;;;;;;;;;;;;;;;;;;;;EAsBAlB,iCAAiC;EAEjC;;;;;;;;;;;;;;;;;;;;EAoBAoD;CACH;AAED;;;;;;AAMA,MAAMQ,eAAe,GAAGA,CAAA,KAAK;EACzB;EACA5F,KAAK,CAACI,gBAAgB,GAAGA,gBAAgB;EACzCJ,KAAK,CAAC8C,qBAAqB,GAAGA,qBAAqB;EACnD9C,KAAK,CAACgC,iCAAiC,GAAGA,iCAAiC;EAC3EhC,KAAK,CAACoF,sCAAsC,GAAGA,sCAAsC;AACzF,CAAC;AAEDQ,eAAe,EAAE"},"metadata":{},"sourceType":"module","externalDependencies":[]}