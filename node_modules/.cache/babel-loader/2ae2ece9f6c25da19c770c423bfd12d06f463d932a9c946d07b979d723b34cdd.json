{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { PhysicsImpostor } from \"../physicsImpostor.js\";\nimport { PhysicsJoint } from \"../physicsJoint.js\";\nimport { Vector3, Quaternion } from \"../../../Maths/math.vector.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nimport { PhysicsRaycastResult } from \"../../physicsRaycastResult.js\";\nimport { Epsilon } from \"../../../Maths/math.constants.js\";\n/** @internal */\nexport class OimoJSPlugin {\n  constructor(_useDeltaForWorldStep = true, iterations, oimoInjection = OIMO) {\n    this._useDeltaForWorldStep = _useDeltaForWorldStep;\n    this.name = \"OimoJSPlugin\";\n    this._fixedTimeStep = 1 / 60;\n    this._tmpImpostorsArray = [];\n    this._tmpPositionVector = Vector3.Zero();\n    this.BJSOIMO = oimoInjection;\n    this.world = new this.BJSOIMO.World({\n      iterations: iterations\n    });\n    this.world.clear();\n    this._raycastResult = new PhysicsRaycastResult();\n  }\n  /**\n   *\n   * @returns plugin version\n   */\n  getPluginVersion() {\n    return 1;\n  }\n  setGravity(gravity) {\n    this.world.gravity.set(gravity.x, gravity.y, gravity.z);\n  }\n  setTimeStep(timeStep) {\n    this.world.timeStep = timeStep;\n  }\n  getTimeStep() {\n    return this.world.timeStep;\n  }\n  executeStep(delta, impostors) {\n    impostors.forEach(function (impostor) {\n      impostor.beforeStep();\n    });\n    this.world.timeStep = this._useDeltaForWorldStep ? delta : this._fixedTimeStep;\n    this.world.step();\n    impostors.forEach(impostor => {\n      impostor.afterStep();\n      //update the ordered impostors array\n      this._tmpImpostorsArray[impostor.uniqueId] = impostor;\n    });\n    //check for collisions\n    let contact = this.world.contacts;\n    while (contact !== null) {\n      if (contact.touching && !contact.body1.sleeping && !contact.body2.sleeping) {\n        contact = contact.next;\n        continue;\n      }\n      //is this body colliding with any other? get the impostor\n      const mainImpostor = this._tmpImpostorsArray[+contact.body1.name];\n      const collidingImpostor = this._tmpImpostorsArray[+contact.body2.name];\n      if (!mainImpostor || !collidingImpostor) {\n        contact = contact.next;\n        continue;\n      }\n      mainImpostor.onCollide({\n        body: collidingImpostor.physicsBody,\n        point: null,\n        distance: 0,\n        impulse: 0,\n        normal: null\n      });\n      collidingImpostor.onCollide({\n        body: mainImpostor.physicsBody,\n        point: null,\n        distance: 0,\n        impulse: 0,\n        normal: null\n      });\n      contact = contact.next;\n    }\n  }\n  applyImpulse(impostor, force, contactPoint) {\n    const mass = impostor.physicsBody.mass;\n    impostor.physicsBody.applyImpulse(contactPoint.scale(this.world.invScale), force.scale(this.world.invScale * mass));\n  }\n  applyForce(impostor, force, contactPoint) {\n    Logger.Warn(\"Oimo doesn't support applying force. Using impulse instead.\");\n    this.applyImpulse(impostor, force, contactPoint);\n  }\n  generatePhysicsBody(impostor) {\n    //parent-child relationship. Does this impostor has a parent impostor?\n    if (impostor.parent) {\n      if (impostor.physicsBody) {\n        this.removePhysicsBody(impostor);\n        //TODO is that needed?\n        impostor.forceUpdate();\n      }\n      return;\n    }\n    if (impostor.isBodyInitRequired()) {\n      const bodyConfig = {\n        name: impostor.uniqueId,\n        //Oimo must have mass, also for static objects.\n        config: [impostor.getParam(\"mass\") || 0.001, impostor.getParam(\"friction\"), impostor.getParam(\"restitution\")],\n        size: [],\n        type: [],\n        pos: [],\n        posShape: [],\n        rot: [],\n        rotShape: [],\n        move: impostor.getParam(\"mass\") !== 0,\n        density: impostor.getParam(\"mass\"),\n        friction: impostor.getParam(\"friction\"),\n        restitution: impostor.getParam(\"restitution\"),\n        //Supporting older versions of Oimo\n        world: this.world\n      };\n      const impostors = [impostor];\n      const addToArray = parent => {\n        if (!parent.getChildMeshes) {\n          return;\n        }\n        parent.getChildMeshes().forEach(function (m) {\n          if (m.physicsImpostor) {\n            impostors.push(m.physicsImpostor);\n            //m.physicsImpostor._init();\n          }\n        });\n      };\n\n      addToArray(impostor.object);\n      const checkWithEpsilon = value => {\n        return Math.max(value, Epsilon);\n      };\n      const globalQuaternion = new Quaternion();\n      impostors.forEach(i => {\n        if (!i.object.rotationQuaternion) {\n          return;\n        }\n        //get the correct bounding box\n        const oldQuaternion = i.object.rotationQuaternion;\n        globalQuaternion.copyFrom(oldQuaternion);\n        i.object.rotationQuaternion.set(0, 0, 0, 1);\n        i.object.computeWorldMatrix(true);\n        const rot = globalQuaternion.toEulerAngles();\n        const impostorExtents = i.getObjectExtents();\n        // eslint-disable-next-line no-loss-of-precision\n        const radToDeg = 57.295779513082320876;\n        if (i === impostor) {\n          const center = impostor.getObjectCenter();\n          impostor.object.getAbsolutePivotPoint().subtractToRef(center, this._tmpPositionVector);\n          this._tmpPositionVector.divideInPlace(impostor.object.scaling);\n          //Can also use Array.prototype.push.apply\n          bodyConfig.pos.push(center.x);\n          bodyConfig.pos.push(center.y);\n          bodyConfig.pos.push(center.z);\n          bodyConfig.posShape.push(0, 0, 0);\n          bodyConfig.rotShape.push(0, 0, 0);\n        } else {\n          const localPosition = i.object.position.clone();\n          bodyConfig.posShape.push(localPosition.x);\n          bodyConfig.posShape.push(localPosition.y);\n          bodyConfig.posShape.push(localPosition.z);\n          // bodyConfig.pos.push(0, 0, 0);\n          bodyConfig.rotShape.push(rot.x * radToDeg, rot.y * radToDeg, rot.z * radToDeg);\n        }\n        i.object.rotationQuaternion.copyFrom(globalQuaternion);\n        // register mesh\n        switch (i.type) {\n          case PhysicsImpostor.ParticleImpostor:\n            Logger.Warn(\"No Particle support in OIMO.js. using SphereImpostor instead\");\n          // eslint-disable-next-line no-fallthrough\n          case PhysicsImpostor.SphereImpostor:\n            {\n              const radiusX = impostorExtents.x;\n              const radiusY = impostorExtents.y;\n              const radiusZ = impostorExtents.z;\n              const size = Math.max(checkWithEpsilon(radiusX), checkWithEpsilon(radiusY), checkWithEpsilon(radiusZ)) / 2;\n              bodyConfig.type.push(\"sphere\");\n              //due to the way oimo works with compounds, add 3 times\n              bodyConfig.size.push(size);\n              bodyConfig.size.push(size);\n              bodyConfig.size.push(size);\n              break;\n            }\n          case PhysicsImpostor.CylinderImpostor:\n            {\n              const sizeX = checkWithEpsilon(impostorExtents.x) / 2;\n              const sizeY = checkWithEpsilon(impostorExtents.y);\n              bodyConfig.type.push(\"cylinder\");\n              bodyConfig.size.push(sizeX);\n              bodyConfig.size.push(sizeY);\n              //due to the way oimo works with compounds, add one more value.\n              bodyConfig.size.push(sizeY);\n              break;\n            }\n          case PhysicsImpostor.PlaneImpostor:\n          case PhysicsImpostor.BoxImpostor:\n          default:\n            {\n              const sizeX = checkWithEpsilon(impostorExtents.x);\n              const sizeY = checkWithEpsilon(impostorExtents.y);\n              const sizeZ = checkWithEpsilon(impostorExtents.z);\n              bodyConfig.type.push(\"box\");\n              //if (i === impostor) {\n              bodyConfig.size.push(sizeX);\n              bodyConfig.size.push(sizeY);\n              bodyConfig.size.push(sizeZ);\n              //} else {\n              //    bodyConfig.size.push(0,0,0);\n              //}\n              break;\n            }\n        }\n        //actually not needed, but hey...\n        i.object.rotationQuaternion = oldQuaternion;\n      });\n      impostor.physicsBody = this.world.add(bodyConfig);\n      // set the quaternion, ignoring the previously defined (euler) rotation\n      impostor.physicsBody.resetQuaternion(globalQuaternion);\n      // update with delta 0, so the body will receive the new rotation.\n      impostor.physicsBody.updatePosition(0);\n    } else {\n      this._tmpPositionVector.copyFromFloats(0, 0, 0);\n    }\n    impostor.setDeltaPosition(this._tmpPositionVector);\n    //this._tmpPositionVector.addInPlace(impostor.mesh.getBoundingInfo().boundingBox.center);\n    //this.setPhysicsBodyTransformation(impostor, this._tmpPositionVector, impostor.mesh.rotationQuaternion);\n  }\n\n  removePhysicsBody(impostor) {\n    //impostor.physicsBody.dispose();\n    this.world.removeRigidBody(impostor.physicsBody);\n  }\n  generateJoint(impostorJoint) {\n    const mainBody = impostorJoint.mainImpostor.physicsBody;\n    const connectedBody = impostorJoint.connectedImpostor.physicsBody;\n    if (!mainBody || !connectedBody) {\n      return;\n    }\n    const jointData = impostorJoint.joint.jointData;\n    const options = jointData.nativeParams || {};\n    let type;\n    const nativeJointData = {\n      body1: mainBody,\n      body2: connectedBody,\n      axe1: options.axe1 || (jointData.mainAxis ? jointData.mainAxis.asArray() : null),\n      axe2: options.axe2 || (jointData.connectedAxis ? jointData.connectedAxis.asArray() : null),\n      pos1: options.pos1 || (jointData.mainPivot ? jointData.mainPivot.asArray() : null),\n      pos2: options.pos2 || (jointData.connectedPivot ? jointData.connectedPivot.asArray() : null),\n      min: options.min,\n      max: options.max,\n      collision: options.collision || jointData.collision,\n      spring: options.spring,\n      //supporting older version of Oimo\n      world: this.world\n    };\n    switch (impostorJoint.joint.type) {\n      case PhysicsJoint.BallAndSocketJoint:\n        type = \"jointBall\";\n        break;\n      case PhysicsJoint.SpringJoint:\n        {\n          Logger.Warn(\"OIMO.js doesn't support Spring Constraint. Simulating using DistanceJoint instead\");\n          const springData = jointData;\n          nativeJointData.min = springData.length || nativeJointData.min;\n          //Max should also be set, just make sure it is at least min\n          nativeJointData.max = Math.max(nativeJointData.min, nativeJointData.max);\n        }\n      // eslint-disable-next-line no-fallthrough\n      case PhysicsJoint.DistanceJoint:\n        type = \"jointDistance\";\n        nativeJointData.max = jointData.maxDistance;\n        break;\n      case PhysicsJoint.PrismaticJoint:\n        type = \"jointPrisme\";\n        break;\n      case PhysicsJoint.SliderJoint:\n        type = \"jointSlide\";\n        break;\n      case PhysicsJoint.WheelJoint:\n        type = \"jointWheel\";\n        break;\n      case PhysicsJoint.HingeJoint:\n      default:\n        type = \"jointHinge\";\n        break;\n    }\n    nativeJointData.type = type;\n    impostorJoint.joint.physicsJoint = this.world.add(nativeJointData);\n  }\n  removeJoint(impostorJoint) {\n    //Bug in Oimo prevents us from disposing a joint in the playground\n    //joint.joint.physicsJoint.dispose();\n    //So we will bruteforce it!\n    try {\n      this.world.removeJoint(impostorJoint.joint.physicsJoint);\n    } catch (e) {\n      Logger.Warn(e);\n    }\n  }\n  isSupported() {\n    return this.BJSOIMO !== undefined;\n  }\n  setTransformationFromPhysicsBody(impostor) {\n    if (!impostor.physicsBody.sleeping) {\n      if (impostor.physicsBody.shapes.next) {\n        let parent = impostor.physicsBody.shapes;\n        while (parent.next) {\n          parent = parent.next;\n        }\n        impostor.object.position.set(parent.position.x, parent.position.y, parent.position.z);\n      } else {\n        const pos = impostor.physicsBody.getPosition();\n        impostor.object.position.set(pos.x, pos.y, pos.z);\n      }\n      if (impostor.object.rotationQuaternion) {\n        const quat = impostor.physicsBody.getQuaternion();\n        impostor.object.rotationQuaternion.set(quat.x, quat.y, quat.z, quat.w);\n      }\n    }\n  }\n  setPhysicsBodyTransformation(impostor, newPosition, newRotation) {\n    const body = impostor.physicsBody;\n    // disable bidirectional for compound meshes\n    if (impostor.physicsBody.shapes.next) {\n      return;\n    }\n    body.position.set(newPosition.x, newPosition.y, newPosition.z);\n    body.orientation.set(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\n    body.syncShapes();\n    body.awake();\n  }\n  /*private _getLastShape(body: any): any {\n      var lastShape = body.shapes;\n      while (lastShape.next) {\n          lastShape = lastShape.next;\n      }\n      return lastShape;\n  }*/\n  setLinearVelocity(impostor, velocity) {\n    impostor.physicsBody.linearVelocity.set(velocity.x, velocity.y, velocity.z);\n  }\n  setAngularVelocity(impostor, velocity) {\n    impostor.physicsBody.angularVelocity.set(velocity.x, velocity.y, velocity.z);\n  }\n  getLinearVelocity(impostor) {\n    const v = impostor.physicsBody.linearVelocity;\n    if (!v) {\n      return null;\n    }\n    return new Vector3(v.x, v.y, v.z);\n  }\n  getAngularVelocity(impostor) {\n    const v = impostor.physicsBody.angularVelocity;\n    if (!v) {\n      return null;\n    }\n    return new Vector3(v.x, v.y, v.z);\n  }\n  setBodyMass(impostor, mass) {\n    const staticBody = mass === 0;\n    //this will actually set the body's density and not its mass.\n    //But this is how oimo treats the mass variable.\n    impostor.physicsBody.shapes.density = staticBody ? 1 : mass;\n    impostor.physicsBody.setupMass(staticBody ? 0x2 : 0x1);\n  }\n  getBodyMass(impostor) {\n    return impostor.physicsBody.shapes.density;\n  }\n  getBodyFriction(impostor) {\n    return impostor.physicsBody.shapes.friction;\n  }\n  setBodyFriction(impostor, friction) {\n    impostor.physicsBody.shapes.friction = friction;\n  }\n  getBodyRestitution(impostor) {\n    return impostor.physicsBody.shapes.restitution;\n  }\n  setBodyRestitution(impostor, restitution) {\n    impostor.physicsBody.shapes.restitution = restitution;\n  }\n  sleepBody(impostor) {\n    impostor.physicsBody.sleep();\n  }\n  wakeUpBody(impostor) {\n    impostor.physicsBody.awake();\n  }\n  updateDistanceJoint(joint, maxDistance, minDistance) {\n    joint.physicsJoint.limitMotor.upperLimit = maxDistance;\n    if (minDistance !== void 0) {\n      joint.physicsJoint.limitMotor.lowerLimit = minDistance;\n    }\n  }\n  setMotor(joint, speed, force, motorIndex) {\n    if (force !== undefined) {\n      Logger.Warn(\"OimoJS plugin currently has unexpected behavior when using setMotor with force parameter\");\n    } else {\n      force = 1e6;\n    }\n    speed *= -1;\n    //TODO separate rotational and transational motors.\n    const motor = motorIndex ? joint.physicsJoint.rotationalLimitMotor2 : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;\n    if (motor) {\n      motor.setMotor(speed, force);\n    }\n  }\n  setLimit(joint, upperLimit, lowerLimit, motorIndex) {\n    //TODO separate rotational and transational motors.\n    const motor = motorIndex ? joint.physicsJoint.rotationalLimitMotor2 : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;\n    if (motor) {\n      motor.setLimit(upperLimit, lowerLimit === void 0 ? -upperLimit : lowerLimit);\n    }\n  }\n  syncMeshWithImpostor(mesh, impostor) {\n    const body = impostor.physicsBody;\n    mesh.position.x = body.position.x;\n    mesh.position.y = body.position.y;\n    mesh.position.z = body.position.z;\n    if (mesh.rotationQuaternion) {\n      mesh.rotationQuaternion.x = body.orientation.x;\n      mesh.rotationQuaternion.y = body.orientation.y;\n      mesh.rotationQuaternion.z = body.orientation.z;\n      mesh.rotationQuaternion.w = body.orientation.w;\n    }\n  }\n  getRadius(impostor) {\n    return impostor.physicsBody.shapes.radius;\n  }\n  getBoxSizeToRef(impostor, result) {\n    const shape = impostor.physicsBody.shapes;\n    result.x = shape.halfWidth * 2;\n    result.y = shape.halfHeight * 2;\n    result.z = shape.halfDepth * 2;\n  }\n  dispose() {\n    this.world.clear();\n  }\n  /**\n   * Does a raycast in the physics world\n   * @param from when should the ray start?\n   * @param to when should the ray end?\n   * @returns PhysicsRaycastResult\n   */\n  raycast(from, to) {\n    Logger.Warn(\"raycast is not currently supported by the Oimo physics plugin\");\n    this._raycastResult.reset(from, to);\n    return this._raycastResult;\n  }\n  /**\n   * Does a raycast in the physics world\n   * @param from when should the ray start?\n   * @param to when should the ray end?\n   * @param result resulting PhysicsRaycastResult\n   */\n  raycastToRef(from, to, result) {\n    Logger.Warn(\"raycast is not currently supported by the Oimo physics plugin\");\n    result.reset(from, to);\n  }\n}","map":{"version":3,"names":["PhysicsImpostor","PhysicsJoint","Vector3","Quaternion","Logger","PhysicsRaycastResult","Epsilon","OimoJSPlugin","constructor","_useDeltaForWorldStep","iterations","oimoInjection","OIMO","name","_fixedTimeStep","_tmpImpostorsArray","_tmpPositionVector","Zero","BJSOIMO","world","World","clear","_raycastResult","getPluginVersion","setGravity","gravity","set","x","y","z","setTimeStep","timeStep","getTimeStep","executeStep","delta","impostors","forEach","impostor","beforeStep","step","afterStep","uniqueId","contact","contacts","touching","body1","sleeping","body2","next","mainImpostor","collidingImpostor","onCollide","body","physicsBody","point","distance","impulse","normal","applyImpulse","force","contactPoint","mass","scale","invScale","applyForce","Warn","generatePhysicsBody","parent","removePhysicsBody","forceUpdate","isBodyInitRequired","bodyConfig","config","getParam","size","type","pos","posShape","rot","rotShape","move","density","friction","restitution","addToArray","getChildMeshes","m","physicsImpostor","push","object","checkWithEpsilon","value","Math","max","globalQuaternion","i","rotationQuaternion","oldQuaternion","copyFrom","computeWorldMatrix","toEulerAngles","impostorExtents","getObjectExtents","radToDeg","center","getObjectCenter","getAbsolutePivotPoint","subtractToRef","divideInPlace","scaling","localPosition","position","clone","ParticleImpostor","SphereImpostor","radiusX","radiusY","radiusZ","CylinderImpostor","sizeX","sizeY","PlaneImpostor","BoxImpostor","sizeZ","add","resetQuaternion","updatePosition","copyFromFloats","setDeltaPosition","removeRigidBody","generateJoint","impostorJoint","mainBody","connectedBody","connectedImpostor","jointData","joint","options","nativeParams","nativeJointData","axe1","mainAxis","asArray","axe2","connectedAxis","pos1","mainPivot","pos2","connectedPivot","min","collision","spring","BallAndSocketJoint","SpringJoint","springData","length","DistanceJoint","maxDistance","PrismaticJoint","SliderJoint","WheelJoint","HingeJoint","physicsJoint","removeJoint","e","isSupported","undefined","setTransformationFromPhysicsBody","shapes","getPosition","quat","getQuaternion","w","setPhysicsBodyTransformation","newPosition","newRotation","orientation","syncShapes","awake","setLinearVelocity","velocity","linearVelocity","setAngularVelocity","angularVelocity","getLinearVelocity","v","getAngularVelocity","setBodyMass","staticBody","setupMass","getBodyMass","getBodyFriction","setBodyFriction","getBodyRestitution","setBodyRestitution","sleepBody","sleep","wakeUpBody","updateDistanceJoint","minDistance","limitMotor","upperLimit","lowerLimit","setMotor","speed","motorIndex","motor","rotationalLimitMotor2","rotationalLimitMotor1","rotationalLimitMotor","setLimit","syncMeshWithImpostor","mesh","getRadius","radius","getBoxSizeToRef","result","shape","halfWidth","halfHeight","halfDepth","dispose","raycast","from","to","reset","raycastToRef"],"sources":["../../../../../../dev/core/src/Physics/v1/Plugins/oimoJSPlugin.ts"],"sourcesContent":["import type { IPhysicsEnabledObject } from \"../physicsImpostor\";\r\nimport { PhysicsImpostor } from \"../physicsImpostor\";\r\nimport type { IMotorEnabledJoint, DistanceJointData, SpringJointData } from \"../physicsJoint\";\r\nimport { PhysicsJoint } from \"../physicsJoint\";\r\nimport type { AbstractMesh } from \"../../../Meshes/abstractMesh\";\r\nimport { Vector3, Quaternion } from \"../../../Maths/math.vector\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport { PhysicsRaycastResult } from \"../../physicsRaycastResult\";\r\nimport type { IPhysicsEnginePlugin, PhysicsImpostorJoint } from \"../IPhysicsEnginePlugin\";\r\nimport { Epsilon } from \"../../../Maths/math.constants\";\r\n\r\ndeclare let OIMO: any;\r\n\r\n/** @internal */\r\nexport class OimoJSPlugin implements IPhysicsEnginePlugin {\r\n    public world: any;\r\n    public name: string = \"OimoJSPlugin\";\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public BJSOIMO: any;\r\n    private _raycastResult: PhysicsRaycastResult;\r\n    private _fixedTimeStep: number = 1 / 60;\r\n\r\n    constructor(private _useDeltaForWorldStep: boolean = true, iterations?: number, oimoInjection = OIMO) {\r\n        this.BJSOIMO = oimoInjection;\r\n        this.world = new this.BJSOIMO.World({\r\n            iterations: iterations,\r\n        });\r\n        this.world.clear();\r\n        this._raycastResult = new PhysicsRaycastResult();\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @returns plugin version\r\n     */\r\n    public getPluginVersion(): number {\r\n        return 1;\r\n    }\r\n\r\n    public setGravity(gravity: Vector3) {\r\n        this.world.gravity.set(gravity.x, gravity.y, gravity.z);\r\n    }\r\n\r\n    public setTimeStep(timeStep: number) {\r\n        this.world.timeStep = timeStep;\r\n    }\r\n\r\n    public getTimeStep(): number {\r\n        return this.world.timeStep;\r\n    }\r\n\r\n    private _tmpImpostorsArray: Array<PhysicsImpostor> = [];\r\n\r\n    public executeStep(delta: number, impostors: Array<PhysicsImpostor>) {\r\n        impostors.forEach(function (impostor) {\r\n            impostor.beforeStep();\r\n        });\r\n\r\n        this.world.timeStep = this._useDeltaForWorldStep ? delta : this._fixedTimeStep;\r\n        this.world.step();\r\n\r\n        impostors.forEach((impostor) => {\r\n            impostor.afterStep();\r\n            //update the ordered impostors array\r\n            this._tmpImpostorsArray[impostor.uniqueId] = impostor;\r\n        });\r\n\r\n        //check for collisions\r\n        let contact = this.world.contacts;\r\n\r\n        while (contact !== null) {\r\n            if (contact.touching && !contact.body1.sleeping && !contact.body2.sleeping) {\r\n                contact = contact.next;\r\n                continue;\r\n            }\r\n            //is this body colliding with any other? get the impostor\r\n            const mainImpostor = this._tmpImpostorsArray[+contact.body1.name];\r\n            const collidingImpostor = this._tmpImpostorsArray[+contact.body2.name];\r\n\r\n            if (!mainImpostor || !collidingImpostor) {\r\n                contact = contact.next;\r\n                continue;\r\n            }\r\n\r\n            mainImpostor.onCollide({ body: collidingImpostor.physicsBody, point: null, distance: 0, impulse: 0, normal: null });\r\n            collidingImpostor.onCollide({ body: mainImpostor.physicsBody, point: null, distance: 0, impulse: 0, normal: null });\r\n            contact = contact.next;\r\n        }\r\n    }\r\n\r\n    public applyImpulse(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        const mass = impostor.physicsBody.mass;\r\n        impostor.physicsBody.applyImpulse(contactPoint.scale(this.world.invScale), force.scale(this.world.invScale * mass));\r\n    }\r\n    public applyForce(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        Logger.Warn(\"Oimo doesn't support applying force. Using impulse instead.\");\r\n        this.applyImpulse(impostor, force, contactPoint);\r\n    }\r\n    public generatePhysicsBody(impostor: PhysicsImpostor) {\r\n        //parent-child relationship. Does this impostor has a parent impostor?\r\n        if (impostor.parent) {\r\n            if (impostor.physicsBody) {\r\n                this.removePhysicsBody(impostor);\r\n                //TODO is that needed?\r\n                impostor.forceUpdate();\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (impostor.isBodyInitRequired()) {\r\n            const bodyConfig: any = {\r\n                name: impostor.uniqueId,\r\n                //Oimo must have mass, also for static objects.\r\n                config: [impostor.getParam(\"mass\") || 0.001, impostor.getParam(\"friction\"), impostor.getParam(\"restitution\")],\r\n                size: [],\r\n                type: [],\r\n                pos: [],\r\n                posShape: [],\r\n                rot: [],\r\n                rotShape: [],\r\n                move: impostor.getParam(\"mass\") !== 0,\r\n                density: impostor.getParam(\"mass\"),\r\n                friction: impostor.getParam(\"friction\"),\r\n                restitution: impostor.getParam(\"restitution\"),\r\n                //Supporting older versions of Oimo\r\n                world: this.world,\r\n            };\r\n\r\n            const impostors = [impostor];\r\n            const addToArray = (parent: IPhysicsEnabledObject) => {\r\n                if (!parent.getChildMeshes) {\r\n                    return;\r\n                }\r\n                parent.getChildMeshes().forEach(function (m) {\r\n                    if (m.physicsImpostor) {\r\n                        impostors.push(m.physicsImpostor);\r\n                        //m.physicsImpostor._init();\r\n                    }\r\n                });\r\n            };\r\n            addToArray(impostor.object);\r\n\r\n            const checkWithEpsilon = (value: number): number => {\r\n                return Math.max(value, Epsilon);\r\n            };\r\n\r\n            const globalQuaternion: Quaternion = new Quaternion();\r\n\r\n            impostors.forEach((i) => {\r\n                if (!i.object.rotationQuaternion) {\r\n                    return;\r\n                }\r\n                //get the correct bounding box\r\n                const oldQuaternion = i.object.rotationQuaternion;\r\n                globalQuaternion.copyFrom(oldQuaternion);\r\n\r\n                i.object.rotationQuaternion.set(0, 0, 0, 1);\r\n                i.object.computeWorldMatrix(true);\r\n\r\n                const rot = globalQuaternion.toEulerAngles();\r\n                const impostorExtents = i.getObjectExtents();\r\n\r\n                // eslint-disable-next-line no-loss-of-precision\r\n                const radToDeg = 57.295779513082320876;\r\n\r\n                if (i === impostor) {\r\n                    const center = impostor.getObjectCenter();\r\n\r\n                    impostor.object.getAbsolutePivotPoint().subtractToRef(center, this._tmpPositionVector);\r\n                    this._tmpPositionVector.divideInPlace(impostor.object.scaling);\r\n\r\n                    //Can also use Array.prototype.push.apply\r\n                    bodyConfig.pos.push(center.x);\r\n                    bodyConfig.pos.push(center.y);\r\n                    bodyConfig.pos.push(center.z);\r\n                    bodyConfig.posShape.push(0, 0, 0);\r\n\r\n                    bodyConfig.rotShape.push(0, 0, 0);\r\n                } else {\r\n                    const localPosition = i.object.position.clone();\r\n                    bodyConfig.posShape.push(localPosition.x);\r\n                    bodyConfig.posShape.push(localPosition.y);\r\n                    bodyConfig.posShape.push(localPosition.z);\r\n\r\n                    // bodyConfig.pos.push(0, 0, 0);\r\n\r\n                    bodyConfig.rotShape.push(rot.x * radToDeg, rot.y * radToDeg, rot.z * radToDeg);\r\n                }\r\n\r\n                i.object.rotationQuaternion.copyFrom(globalQuaternion);\r\n\r\n                // register mesh\r\n                switch (i.type) {\r\n                    case PhysicsImpostor.ParticleImpostor:\r\n                        Logger.Warn(\"No Particle support in OIMO.js. using SphereImpostor instead\");\r\n                    // eslint-disable-next-line no-fallthrough\r\n                    case PhysicsImpostor.SphereImpostor: {\r\n                        const radiusX = impostorExtents.x;\r\n                        const radiusY = impostorExtents.y;\r\n                        const radiusZ = impostorExtents.z;\r\n\r\n                        const size = Math.max(checkWithEpsilon(radiusX), checkWithEpsilon(radiusY), checkWithEpsilon(radiusZ)) / 2;\r\n\r\n                        bodyConfig.type.push(\"sphere\");\r\n                        //due to the way oimo works with compounds, add 3 times\r\n                        bodyConfig.size.push(size);\r\n                        bodyConfig.size.push(size);\r\n                        bodyConfig.size.push(size);\r\n                        break;\r\n                    }\r\n                    case PhysicsImpostor.CylinderImpostor: {\r\n                        const sizeX = checkWithEpsilon(impostorExtents.x) / 2;\r\n                        const sizeY = checkWithEpsilon(impostorExtents.y);\r\n                        bodyConfig.type.push(\"cylinder\");\r\n                        bodyConfig.size.push(sizeX);\r\n                        bodyConfig.size.push(sizeY);\r\n                        //due to the way oimo works with compounds, add one more value.\r\n                        bodyConfig.size.push(sizeY);\r\n                        break;\r\n                    }\r\n                    case PhysicsImpostor.PlaneImpostor:\r\n                    case PhysicsImpostor.BoxImpostor:\r\n                    default: {\r\n                        const sizeX = checkWithEpsilon(impostorExtents.x);\r\n                        const sizeY = checkWithEpsilon(impostorExtents.y);\r\n                        const sizeZ = checkWithEpsilon(impostorExtents.z);\r\n\r\n                        bodyConfig.type.push(\"box\");\r\n                        //if (i === impostor) {\r\n                        bodyConfig.size.push(sizeX);\r\n                        bodyConfig.size.push(sizeY);\r\n                        bodyConfig.size.push(sizeZ);\r\n                        //} else {\r\n                        //    bodyConfig.size.push(0,0,0);\r\n                        //}\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                //actually not needed, but hey...\r\n                i.object.rotationQuaternion = oldQuaternion;\r\n            });\r\n            impostor.physicsBody = this.world.add(bodyConfig);\r\n            // set the quaternion, ignoring the previously defined (euler) rotation\r\n            impostor.physicsBody.resetQuaternion(globalQuaternion);\r\n            // update with delta 0, so the body will receive the new rotation.\r\n            impostor.physicsBody.updatePosition(0);\r\n        } else {\r\n            this._tmpPositionVector.copyFromFloats(0, 0, 0);\r\n        }\r\n\r\n        impostor.setDeltaPosition(this._tmpPositionVector);\r\n\r\n        //this._tmpPositionVector.addInPlace(impostor.mesh.getBoundingInfo().boundingBox.center);\r\n        //this.setPhysicsBodyTransformation(impostor, this._tmpPositionVector, impostor.mesh.rotationQuaternion);\r\n    }\r\n\r\n    private _tmpPositionVector: Vector3 = Vector3.Zero();\r\n\r\n    public removePhysicsBody(impostor: PhysicsImpostor) {\r\n        //impostor.physicsBody.dispose();\r\n        this.world.removeRigidBody(impostor.physicsBody);\r\n    }\r\n\r\n    public generateJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        const mainBody = impostorJoint.mainImpostor.physicsBody;\r\n        const connectedBody = impostorJoint.connectedImpostor.physicsBody;\r\n\r\n        if (!mainBody || !connectedBody) {\r\n            return;\r\n        }\r\n        const jointData = impostorJoint.joint.jointData;\r\n        const options = jointData.nativeParams || {};\r\n        let type;\r\n        const nativeJointData: any = {\r\n            body1: mainBody,\r\n            body2: connectedBody,\r\n\r\n            axe1: options.axe1 || (jointData.mainAxis ? jointData.mainAxis.asArray() : null),\r\n            axe2: options.axe2 || (jointData.connectedAxis ? jointData.connectedAxis.asArray() : null),\r\n            pos1: options.pos1 || (jointData.mainPivot ? jointData.mainPivot.asArray() : null),\r\n            pos2: options.pos2 || (jointData.connectedPivot ? jointData.connectedPivot.asArray() : null),\r\n\r\n            min: options.min,\r\n            max: options.max,\r\n            collision: options.collision || jointData.collision,\r\n            spring: options.spring,\r\n\r\n            //supporting older version of Oimo\r\n            world: this.world,\r\n        };\r\n        switch (impostorJoint.joint.type) {\r\n            case PhysicsJoint.BallAndSocketJoint:\r\n                type = \"jointBall\";\r\n                break;\r\n            case PhysicsJoint.SpringJoint: {\r\n                Logger.Warn(\"OIMO.js doesn't support Spring Constraint. Simulating using DistanceJoint instead\");\r\n                const springData = <SpringJointData>jointData;\r\n                nativeJointData.min = springData.length || nativeJointData.min;\r\n                //Max should also be set, just make sure it is at least min\r\n                nativeJointData.max = Math.max(nativeJointData.min, nativeJointData.max);\r\n            }\r\n            // eslint-disable-next-line no-fallthrough\r\n            case PhysicsJoint.DistanceJoint:\r\n                type = \"jointDistance\";\r\n                nativeJointData.max = (<DistanceJointData>jointData).maxDistance;\r\n                break;\r\n            case PhysicsJoint.PrismaticJoint:\r\n                type = \"jointPrisme\";\r\n                break;\r\n            case PhysicsJoint.SliderJoint:\r\n                type = \"jointSlide\";\r\n                break;\r\n            case PhysicsJoint.WheelJoint:\r\n                type = \"jointWheel\";\r\n                break;\r\n            case PhysicsJoint.HingeJoint:\r\n            default:\r\n                type = \"jointHinge\";\r\n                break;\r\n        }\r\n        nativeJointData.type = type;\r\n        impostorJoint.joint.physicsJoint = this.world.add(nativeJointData);\r\n    }\r\n\r\n    public removeJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        //Bug in Oimo prevents us from disposing a joint in the playground\r\n        //joint.joint.physicsJoint.dispose();\r\n        //So we will bruteforce it!\r\n        try {\r\n            this.world.removeJoint(impostorJoint.joint.physicsJoint);\r\n        } catch (e) {\r\n            Logger.Warn(e);\r\n        }\r\n    }\r\n\r\n    public isSupported(): boolean {\r\n        return this.BJSOIMO !== undefined;\r\n    }\r\n\r\n    public setTransformationFromPhysicsBody(impostor: PhysicsImpostor) {\r\n        if (!impostor.physicsBody.sleeping) {\r\n            if (impostor.physicsBody.shapes.next) {\r\n                let parent = impostor.physicsBody.shapes;\r\n                while (parent.next) {\r\n                    parent = parent.next;\r\n                }\r\n                impostor.object.position.set(parent.position.x, parent.position.y, parent.position.z);\r\n            } else {\r\n                const pos = impostor.physicsBody.getPosition();\r\n                impostor.object.position.set(pos.x, pos.y, pos.z);\r\n            }\r\n\r\n            if (impostor.object.rotationQuaternion) {\r\n                const quat = impostor.physicsBody.getQuaternion();\r\n                impostor.object.rotationQuaternion.set(quat.x, quat.y, quat.z, quat.w);\r\n            }\r\n        }\r\n    }\r\n\r\n    public setPhysicsBodyTransformation(impostor: PhysicsImpostor, newPosition: Vector3, newRotation: Quaternion) {\r\n        const body = impostor.physicsBody;\r\n        // disable bidirectional for compound meshes\r\n        if (impostor.physicsBody.shapes.next) {\r\n            return;\r\n        }\r\n        body.position.set(newPosition.x, newPosition.y, newPosition.z);\r\n        body.orientation.set(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\r\n        body.syncShapes();\r\n        body.awake();\r\n    }\r\n\r\n    /*private _getLastShape(body: any): any {\r\n        var lastShape = body.shapes;\r\n        while (lastShape.next) {\r\n            lastShape = lastShape.next;\r\n        }\r\n        return lastShape;\r\n    }*/\r\n\r\n    public setLinearVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        impostor.physicsBody.linearVelocity.set(velocity.x, velocity.y, velocity.z);\r\n    }\r\n\r\n    public setAngularVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        impostor.physicsBody.angularVelocity.set(velocity.x, velocity.y, velocity.z);\r\n    }\r\n\r\n    public getLinearVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        const v = impostor.physicsBody.linearVelocity;\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        return new Vector3(v.x, v.y, v.z);\r\n    }\r\n    public getAngularVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        const v = impostor.physicsBody.angularVelocity;\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        return new Vector3(v.x, v.y, v.z);\r\n    }\r\n\r\n    public setBodyMass(impostor: PhysicsImpostor, mass: number) {\r\n        const staticBody: boolean = mass === 0;\r\n        //this will actually set the body's density and not its mass.\r\n        //But this is how oimo treats the mass variable.\r\n        impostor.physicsBody.shapes.density = staticBody ? 1 : mass;\r\n        impostor.physicsBody.setupMass(staticBody ? 0x2 : 0x1);\r\n    }\r\n\r\n    public getBodyMass(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.shapes.density;\r\n    }\r\n\r\n    public getBodyFriction(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.shapes.friction;\r\n    }\r\n\r\n    public setBodyFriction(impostor: PhysicsImpostor, friction: number) {\r\n        impostor.physicsBody.shapes.friction = friction;\r\n    }\r\n\r\n    public getBodyRestitution(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.shapes.restitution;\r\n    }\r\n\r\n    public setBodyRestitution(impostor: PhysicsImpostor, restitution: number) {\r\n        impostor.physicsBody.shapes.restitution = restitution;\r\n    }\r\n\r\n    public sleepBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.sleep();\r\n    }\r\n\r\n    public wakeUpBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.awake();\r\n    }\r\n\r\n    public updateDistanceJoint(joint: PhysicsJoint, maxDistance: number, minDistance?: number) {\r\n        joint.physicsJoint.limitMotor.upperLimit = maxDistance;\r\n        if (minDistance !== void 0) {\r\n            joint.physicsJoint.limitMotor.lowerLimit = minDistance;\r\n        }\r\n    }\r\n\r\n    public setMotor(joint: IMotorEnabledJoint, speed: number, force?: number, motorIndex?: number) {\r\n        if (force !== undefined) {\r\n            Logger.Warn(\"OimoJS plugin currently has unexpected behavior when using setMotor with force parameter\");\r\n        } else {\r\n            force = 1e6;\r\n        }\r\n        speed *= -1;\r\n\r\n        //TODO separate rotational and transational motors.\r\n        const motor = motorIndex\r\n            ? joint.physicsJoint.rotationalLimitMotor2\r\n            : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;\r\n        if (motor) {\r\n            motor.setMotor(speed, force);\r\n        }\r\n    }\r\n\r\n    public setLimit(joint: IMotorEnabledJoint, upperLimit: number, lowerLimit?: number, motorIndex?: number) {\r\n        //TODO separate rotational and transational motors.\r\n        const motor = motorIndex\r\n            ? joint.physicsJoint.rotationalLimitMotor2\r\n            : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;\r\n        if (motor) {\r\n            motor.setLimit(upperLimit, lowerLimit === void 0 ? -upperLimit : lowerLimit);\r\n        }\r\n    }\r\n\r\n    public syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor) {\r\n        const body = impostor.physicsBody;\r\n\r\n        mesh.position.x = body.position.x;\r\n        mesh.position.y = body.position.y;\r\n        mesh.position.z = body.position.z;\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            mesh.rotationQuaternion.x = body.orientation.x;\r\n            mesh.rotationQuaternion.y = body.orientation.y;\r\n            mesh.rotationQuaternion.z = body.orientation.z;\r\n            mesh.rotationQuaternion.w = body.orientation.w;\r\n        }\r\n    }\r\n\r\n    public getRadius(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.shapes.radius;\r\n    }\r\n\r\n    public getBoxSizeToRef(impostor: PhysicsImpostor, result: Vector3): void {\r\n        const shape = impostor.physicsBody.shapes;\r\n        result.x = shape.halfWidth * 2;\r\n        result.y = shape.halfHeight * 2;\r\n        result.z = shape.halfDepth * 2;\r\n    }\r\n\r\n    public dispose() {\r\n        this.world.clear();\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @returns PhysicsRaycastResult\r\n     */\r\n    public raycast(from: Vector3, to: Vector3): PhysicsRaycastResult {\r\n        Logger.Warn(\"raycast is not currently supported by the Oimo physics plugin\");\r\n\r\n        this._raycastResult.reset(from, to);\r\n\r\n        return this._raycastResult;\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @param result resulting PhysicsRaycastResult\r\n     */\r\n    public raycastToRef(from: Vector3, to: Vector3, result: PhysicsRaycastResult): void {\r\n        Logger.Warn(\"raycast is not currently supported by the Oimo physics plugin\");\r\n\r\n        result.reset(from, to);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}