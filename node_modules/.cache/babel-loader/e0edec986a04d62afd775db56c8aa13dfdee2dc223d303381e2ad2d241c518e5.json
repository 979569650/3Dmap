{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { Matrix, Quaternion, Vector3 } from \"../../../../Maths/math.vector.js\";\nimport { InstantiateBaseBlock } from \"./instantiateBaseBlock.js\";\n/**\n * Block used to clone geometry in a radial shape\n */\nexport class InstantiateRadialBlock extends InstantiateBaseBlock {\n  /**\n   * Create a new InstantiateRadialBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    this.registerInput(\"radius\", NodeGeometryBlockConnectionPointTypes.Int, true, 0, 0);\n    // Angle start and end\n    this.registerInput(\"angleStart\", NodeGeometryBlockConnectionPointTypes.Float, true, 0);\n    this.registerInput(\"angleEnd\", NodeGeometryBlockConnectionPointTypes.Float, true, Math.PI * 2);\n    // Transform offset\n    this.registerInput(\"transform\", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(0, 0, 0));\n    // Rotation is magnitude per step\n    this.registerInput(\"rotation\", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(0, 0, 0));\n    // Scale is magnitude per step\n    this.registerInput(\"scaling\", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(0, 0, 0));\n    this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"InstantiateRadialBlock\";\n  }\n  /**\n   * Gets the direction input component\n   */\n  get radius() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the direction input component\n   */\n  get angleStart() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the direction input component\n   */\n  get angleEnd() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the transform input component\n   */\n  get transform() {\n    return this._inputs[5];\n  }\n  /**\n   * Gets the rotation input component\n   */\n  get rotation() {\n    return this._inputs[6];\n  }\n  /**\n   * Gets the scaling input component\n   */\n  get scaling() {\n    return this._inputs[7];\n  }\n  _buildBlock(state) {\n    const func = state => {\n      state.pushExecutionContext(this);\n      state.pushInstancingContext(this);\n      const iterationCount = this.count.getConnectedValue(state);\n      const additionalVertexData = [];\n      const rotMatrix = Matrix.Identity();\n      const radiusMatrix = Matrix.Identity();\n      const transformMatrix = Matrix.Identity();\n      const transformOffset = Vector3.Zero();\n      const rotationOffset = Vector3.Zero();\n      const scaleOffset = Vector3.Zero();\n      for (this._currentIndex = 0; this._currentIndex < iterationCount; this._currentIndex++) {\n        const instanceGeometry = this.instance.getConnectedValue(state);\n        if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {\n          continue;\n        }\n        // Clone the instance\n        const clone = instanceGeometry.clone();\n        const radius = this.radius.getConnectedValue(state);\n        const angleStart = this.angleStart.getConnectedValue(state);\n        const angleEnd = this.angleEnd.getConnectedValue(state);\n        const transform = this.transform.getConnectedValue(state);\n        const rotation = this.rotation.getConnectedValue(state);\n        const scale = state.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);\n        // Define arc size\n        const pieSlice = angleEnd - angleStart;\n        const rStep = pieSlice / iterationCount;\n        const angle = angleStart + rStep * this._currentIndex;\n        const angleQuat = Quaternion.FromEulerAngles(0, angle, 0);\n        // Get local transforms\n        transformOffset.copyFrom(transform.clone().scale(this._currentIndex));\n        rotationOffset.copyFrom(rotation.clone().scale(this._currentIndex));\n        scaleOffset.copyFrom(scale.clone().scale(this._currentIndex));\n        scaleOffset.addInPlaceFromFloats(1, 1, 1);\n        // Compose (rotMatrix x radius x scale x angle x user transform)\n        Matrix.RotationYawPitchRollToRef(rotationOffset.y, rotationOffset.x, rotationOffset.z, rotMatrix);\n        radiusMatrix.setTranslationFromFloats(0, 0, radius);\n        Matrix.ComposeToRef(scaleOffset, angleQuat, transformOffset, transformMatrix);\n        rotMatrix.multiplyToRef(radiusMatrix, radiusMatrix);\n        radiusMatrix.multiplyToRef(transformMatrix, transformMatrix);\n        state._instantiateWithMatrix(clone, transformMatrix, additionalVertexData);\n      }\n      // Merge\n      if (additionalVertexData.length) {\n        if (additionalVertexData.length === 1) {\n          this._vertexData = additionalVertexData[0];\n        } else {\n          // We do not merge the main one as user can use a merge node if wanted\n          const main = additionalVertexData.splice(0, 1)[0];\n          this._vertexData = main.merge(additionalVertexData, true, false, true, true);\n        }\n      }\n      // Storage\n      state.restoreExecutionContext();\n      state.restoreInstancingContext();\n      return this._vertexData;\n    };\n    if (this.evaluateContext) {\n      this.output._storedFunction = func;\n    } else {\n      this.output._storedFunction = null;\n      this.output._storedValue = func(state);\n    }\n  }\n}\nRegisterClass(\"BABYLON.InstantiateRadialBlock\", InstantiateRadialBlock);","map":{"version":3,"names":["RegisterClass","NodeGeometryBlockConnectionPointTypes","Matrix","Quaternion","Vector3","InstantiateBaseBlock","InstantiateRadialBlock","constructor","name","registerInput","Int","Float","Math","PI","scaling","acceptedConnectionPointTypes","push","getClassName","radius","_inputs","angleStart","angleEnd","transform","rotation","_buildBlock","state","func","pushExecutionContext","pushInstancingContext","iterationCount","count","getConnectedValue","additionalVertexData","rotMatrix","Identity","radiusMatrix","transformMatrix","transformOffset","Zero","rotationOffset","scaleOffset","_currentIndex","instanceGeometry","instance","positions","length","clone","scale","adaptInput","OneReadOnly","pieSlice","rStep","angle","angleQuat","FromEulerAngles","copyFrom","addInPlaceFromFloats","RotationYawPitchRollToRef","y","x","z","setTranslationFromFloats","ComposeToRef","multiplyToRef","_instantiateWithMatrix","_vertexData","main","splice","merge","restoreExecutionContext","restoreInstancingContext","evaluateContext","output","_storedFunction","_storedValue"],"sources":["../../../../../../../dev/core/src/Meshes/Node/Blocks/Instances/instantiateRadialBlock.ts"],"sourcesContent":["import type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { Matrix, Quaternion, Vector3 } from \"../../../../Maths/math.vector\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport type { VertexData } from \"core/Meshes/mesh.vertexData\";\r\nimport { InstantiateBaseBlock } from \"./instantiateBaseBlock\";\r\n\r\n/**\r\n * Block used to clone geometry in a radial shape\r\n */\r\nexport class InstantiateRadialBlock extends InstantiateBaseBlock {\r\n    /**\r\n     * Create a new InstantiateRadialBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n        this.registerInput(\"radius\", NodeGeometryBlockConnectionPointTypes.Int, true, 0, 0);\r\n\r\n        // Angle start and end\r\n        this.registerInput(\"angleStart\", NodeGeometryBlockConnectionPointTypes.Float, true, 0);\r\n        this.registerInput(\"angleEnd\", NodeGeometryBlockConnectionPointTypes.Float, true, Math.PI * 2);\r\n\r\n        // Transform offset\r\n        this.registerInput(\"transform\", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(0, 0, 0));\r\n\r\n        // Rotation is magnitude per step\r\n        this.registerInput(\"rotation\", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(0, 0, 0));\r\n\r\n        // Scale is magnitude per step\r\n        this.registerInput(\"scaling\", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(0, 0, 0));\r\n        this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"InstantiateRadialBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the direction input component\r\n     */\r\n    public get radius(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the direction input component\r\n     */\r\n    public get angleStart(): NodeGeometryConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the direction input component\r\n     */\r\n    public get angleEnd(): NodeGeometryConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the transform input component\r\n     */\r\n    public get transform(): NodeGeometryConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the rotation input component\r\n     */\r\n    public get rotation(): NodeGeometryConnectionPoint {\r\n        return this._inputs[6];\r\n    }\r\n\r\n    /**\r\n     * Gets the scaling input component\r\n     */\r\n    public get scaling(): NodeGeometryConnectionPoint {\r\n        return this._inputs[7];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            state.pushExecutionContext(this);\r\n            state.pushInstancingContext(this);\r\n\r\n            const iterationCount = this.count.getConnectedValue(state) as number;\r\n\r\n            const additionalVertexData: VertexData[] = [];\r\n\r\n            const rotMatrix = Matrix.Identity();\r\n            const radiusMatrix = Matrix.Identity();\r\n            const transformMatrix = Matrix.Identity();\r\n            const transformOffset = Vector3.Zero();\r\n            const rotationOffset = Vector3.Zero();\r\n            const scaleOffset = Vector3.Zero();\r\n\r\n            for (this._currentIndex = 0; this._currentIndex < iterationCount; this._currentIndex++) {\r\n                const instanceGeometry = this.instance.getConnectedValue(state) as VertexData;\r\n\r\n                if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {\r\n                    continue;\r\n                }\r\n                // Clone the instance\r\n                const clone = instanceGeometry.clone();\r\n\r\n                const radius = this.radius.getConnectedValue(state) as number;\r\n                const angleStart: number = this.angleStart.getConnectedValue(state) as number;\r\n                const angleEnd = this.angleEnd.getConnectedValue(state) as number;\r\n\r\n                const transform = this.transform.getConnectedValue(state) as Vector3;\r\n\r\n                const rotation = this.rotation.getConnectedValue(state) as Vector3;\r\n\r\n                const scale = state.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);\r\n\r\n                // Define arc size\r\n                const pieSlice = angleEnd - angleStart;\r\n                const rStep = pieSlice / iterationCount;\r\n\r\n                const angle = angleStart + rStep * this._currentIndex;\r\n                const angleQuat = Quaternion.FromEulerAngles(0, angle, 0);\r\n\r\n                // Get local transforms\r\n                transformOffset.copyFrom(transform.clone().scale(this._currentIndex));\r\n                rotationOffset.copyFrom(rotation.clone().scale(this._currentIndex));\r\n                scaleOffset.copyFrom(scale.clone().scale(this._currentIndex));\r\n                scaleOffset.addInPlaceFromFloats(1, 1, 1);\r\n\r\n                // Compose (rotMatrix x radius x scale x angle x user transform)\r\n                Matrix.RotationYawPitchRollToRef(rotationOffset.y, rotationOffset.x, rotationOffset.z, rotMatrix);\r\n                radiusMatrix.setTranslationFromFloats(0, 0, radius);\r\n                Matrix.ComposeToRef(scaleOffset, angleQuat, transformOffset, transformMatrix);\r\n\r\n                rotMatrix.multiplyToRef(radiusMatrix, radiusMatrix);\r\n                radiusMatrix.multiplyToRef(transformMatrix, transformMatrix);\r\n\r\n                state._instantiateWithMatrix(clone, transformMatrix, additionalVertexData);\r\n            }\r\n\r\n            // Merge\r\n            if (additionalVertexData.length) {\r\n                if (additionalVertexData.length === 1) {\r\n                    this._vertexData = additionalVertexData[0];\r\n                } else {\r\n                    // We do not merge the main one as user can use a merge node if wanted\r\n                    const main = additionalVertexData.splice(0, 1)[0];\r\n                    this._vertexData = main.merge(additionalVertexData, true, false, true, true);\r\n                }\r\n            }\r\n\r\n            // Storage\r\n            state.restoreExecutionContext();\r\n            state.restoreInstancingContext();\r\n            return this._vertexData;\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.output._storedFunction = func;\r\n        } else {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = func(state);\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.InstantiateRadialBlock\", InstantiateRadialBlock);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}