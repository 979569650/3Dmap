{"ast":null,"code":"import { Logger } from \"../../Misc/logger.js\";\nclass WebGPUBindGroupCacheNode {\n  constructor() {\n    this.values = {};\n  }\n}\n/** @internal */\nexport class WebGPUCacheBindGroups {\n  static get Statistics() {\n    return {\n      totalCreated: WebGPUCacheBindGroups.NumBindGroupsCreatedTotal,\n      lastFrameCreated: WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame,\n      lookupLastFrame: WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame,\n      noLookupLastFrame: WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame\n    };\n  }\n  constructor(device, cacheSampler, engine) {\n    this.disabled = false;\n    this._device = device;\n    this._cacheSampler = cacheSampler;\n    this._engine = engine;\n  }\n  endFrame() {\n    WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame = WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame;\n    WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame = WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame;\n    WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame = WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame;\n    WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame = 0;\n    WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame = 0;\n    WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame = 0;\n  }\n  /**\n   * Cache is currently based on the uniform/storage buffers, samplers and textures used by the binding groups.\n   * Note that all uniform buffers have an offset of 0 in Babylon and we don't have a use case where we would have the same buffer used with different capacity values:\n   * that means we don't need to factor in the offset/size of the buffer in the cache, only the id\n   * @param webgpuPipelineContext\n   * @param drawContext\n   * @param materialContext\n   */\n  getBindGroups(webgpuPipelineContext, drawContext, materialContext) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    let bindGroups = undefined;\n    let node = WebGPUCacheBindGroups._Cache;\n    const cacheIsDisabled = this.disabled || materialContext.forceBindGroupCreation;\n    if (!cacheIsDisabled) {\n      if (!drawContext.isDirty(materialContext.updateId) && !materialContext.isDirty) {\n        WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame++;\n        return drawContext.bindGroups;\n      }\n      for (const bufferName of webgpuPipelineContext.shaderProcessingContext.bufferNames) {\n        const uboId = (_b = (_a = drawContext.buffers[bufferName]) === null || _a === void 0 ? void 0 : _a.uniqueId) !== null && _b !== void 0 ? _b : 0;\n        let nextNode = node.values[uboId];\n        if (!nextNode) {\n          nextNode = new WebGPUBindGroupCacheNode();\n          node.values[uboId] = nextNode;\n        }\n        node = nextNode;\n      }\n      for (const samplerName of webgpuPipelineContext.shaderProcessingContext.samplerNames) {\n        const samplerHashCode = (_d = (_c = materialContext.samplers[samplerName]) === null || _c === void 0 ? void 0 : _c.hashCode) !== null && _d !== void 0 ? _d : 0;\n        let nextNode = node.values[samplerHashCode];\n        if (!nextNode) {\n          nextNode = new WebGPUBindGroupCacheNode();\n          node.values[samplerHashCode] = nextNode;\n        }\n        node = nextNode;\n      }\n      for (const textureName of webgpuPipelineContext.shaderProcessingContext.textureNames) {\n        const textureId = (_g = (_f = (_e = materialContext.textures[textureName]) === null || _e === void 0 ? void 0 : _e.texture) === null || _f === void 0 ? void 0 : _f.uniqueId) !== null && _g !== void 0 ? _g : 0;\n        let nextNode = node.values[textureId];\n        if (!nextNode) {\n          nextNode = new WebGPUBindGroupCacheNode();\n          node.values[textureId] = nextNode;\n        }\n        node = nextNode;\n      }\n      bindGroups = node.bindGroups;\n    }\n    drawContext.resetIsDirty(materialContext.updateId);\n    materialContext.isDirty = false;\n    if (bindGroups) {\n      drawContext.bindGroups = bindGroups;\n      WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame++;\n      return bindGroups;\n    }\n    bindGroups = [];\n    drawContext.bindGroups = bindGroups;\n    if (!cacheIsDisabled) {\n      node.bindGroups = bindGroups;\n    }\n    WebGPUCacheBindGroups.NumBindGroupsCreatedTotal++;\n    WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame++;\n    const bindGroupLayouts = webgpuPipelineContext.bindGroupLayouts[materialContext.textureState];\n    for (let i = 0; i < webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries.length; i++) {\n      const setDefinition = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries[i];\n      const entries = webgpuPipelineContext.shaderProcessingContext.bindGroupEntries[i];\n      for (let j = 0; j < setDefinition.length; j++) {\n        const entry = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries[i][j];\n        const entryInfo = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding];\n        const name = (_h = entryInfo.nameInArrayOfTexture) !== null && _h !== void 0 ? _h : entryInfo.name;\n        if (entry.sampler) {\n          const bindingInfo = materialContext.samplers[name];\n          if (bindingInfo) {\n            const sampler = bindingInfo.sampler;\n            if (!sampler) {\n              if (this._engine.dbgSanityChecks) {\n                Logger.Error(`Trying to bind a null sampler! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(bindingInfo, (key, value) => key === \"texture\" ? \"<no dump>\" : value)}, materialContext.uniqueId=${materialContext.uniqueId}`, 50);\n              }\n              continue;\n            }\n            entries[j].resource = this._cacheSampler.getSampler(sampler, false, bindingInfo.hashCode);\n          } else {\n            Logger.Error(`Sampler \"${name}\" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key, value) => key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value)}`, 50);\n          }\n        } else if (entry.texture || entry.storageTexture) {\n          const bindingInfo = materialContext.textures[name];\n          if (bindingInfo) {\n            if (this._engine.dbgSanityChecks && bindingInfo.texture === null) {\n              Logger.Error(`Trying to bind a null texture! entry=${JSON.stringify(entry)}, bindingInfo=${JSON.stringify(bindingInfo, (key, value) => key === \"texture\" ? \"<no dump>\" : value)}, materialContext.uniqueId=${materialContext.uniqueId}`, 50);\n              continue;\n            }\n            const hardwareTexture = bindingInfo.texture._hardwareTexture;\n            if (this._engine.dbgSanityChecks && (!hardwareTexture || entry.texture && !hardwareTexture.view || entry.storageTexture && !hardwareTexture.viewForWriting)) {\n              Logger.Error(`Trying to bind a null gpu texture or view! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(bindingInfo, (key, value) => key === \"texture\" ? \"<no dump>\" : value)}, isReady=${(_j = bindingInfo.texture) === null || _j === void 0 ? void 0 : _j.isReady}, materialContext.uniqueId=${materialContext.uniqueId}`, 50);\n              continue;\n            }\n            entries[j].resource = entry.storageTexture ? hardwareTexture.viewForWriting : hardwareTexture.view;\n          } else {\n            Logger.Error(`Texture \"${name}\" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key, value) => key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value)}`, 50);\n          }\n        } else if (entry.externalTexture) {\n          const bindingInfo = materialContext.textures[name];\n          if (bindingInfo) {\n            if (this._engine.dbgSanityChecks && bindingInfo.texture === null) {\n              Logger.Error(`Trying to bind a null external texture! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(bindingInfo, (key, value) => key === \"texture\" ? \"<no dump>\" : value)}, materialContext.uniqueId=${materialContext.uniqueId}`, 50);\n              continue;\n            }\n            const externalTexture = bindingInfo.texture.underlyingResource;\n            if (this._engine.dbgSanityChecks && !externalTexture) {\n              Logger.Error(`Trying to bind a null gpu external texture! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(bindingInfo, (key, value) => key === \"texture\" ? \"<no dump>\" : value)}, isReady=${(_k = bindingInfo.texture) === null || _k === void 0 ? void 0 : _k.isReady}, materialContext.uniqueId=${materialContext.uniqueId}`, 50);\n              continue;\n            }\n            entries[j].resource = this._device.importExternalTexture({\n              source: externalTexture\n            });\n          } else {\n            Logger.Error(`Texture \"${name}\" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key, value) => key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value)}`, 50);\n          }\n        } else if (entry.buffer) {\n          const dataBuffer = drawContext.buffers[name];\n          if (dataBuffer) {\n            const webgpuBuffer = dataBuffer.underlyingResource;\n            entries[j].resource.buffer = webgpuBuffer;\n            entries[j].resource.size = dataBuffer.capacity;\n          } else {\n            Logger.Error(`Can't find buffer \"${name}\". entry=${JSON.stringify(entry)}, buffers=${JSON.stringify(drawContext.buffers)}, drawContext.uniqueId=${drawContext.uniqueId}`, 50);\n          }\n        }\n      }\n      const groupLayout = bindGroupLayouts[i];\n      bindGroups[i] = this._device.createBindGroup({\n        layout: groupLayout,\n        entries\n      });\n    }\n    return bindGroups;\n  }\n}\nWebGPUCacheBindGroups.NumBindGroupsCreatedTotal = 0;\nWebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame = 0;\nWebGPUCacheBindGroups.NumBindGroupsLookupLastFrame = 0;\nWebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame = 0;\nWebGPUCacheBindGroups._Cache = new WebGPUBindGroupCacheNode();\nWebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame = 0;\nWebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame = 0;\nWebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame = 0;","map":{"version":3,"names":["Logger","WebGPUBindGroupCacheNode","constructor","values","WebGPUCacheBindGroups","Statistics","totalCreated","NumBindGroupsCreatedTotal","lastFrameCreated","NumBindGroupsCreatedLastFrame","lookupLastFrame","NumBindGroupsLookupLastFrame","noLookupLastFrame","NumBindGroupsNoLookupLastFrame","device","cacheSampler","engine","disabled","_device","_cacheSampler","_engine","endFrame","_NumBindGroupsCreatedCurrentFrame","_NumBindGroupsLookupCurrentFrame","_NumBindGroupsNoLookupCurrentFrame","getBindGroups","webgpuPipelineContext","drawContext","materialContext","bindGroups","undefined","node","_Cache","cacheIsDisabled","forceBindGroupCreation","isDirty","updateId","bufferName","shaderProcessingContext","bufferNames","uboId","_b","_a","buffers","uniqueId","nextNode","samplerName","samplerNames","samplerHashCode","_d","_c","samplers","hashCode","textureName","textureNames","textureId","_g","_f","_e","textures","texture","resetIsDirty","bindGroupLayouts","textureState","i","bindGroupLayoutEntries","length","setDefinition","entries","bindGroupEntries","j","entry","entryInfo","bindGroupLayoutEntryInfo","binding","name","_h","nameInArrayOfTexture","sampler","bindingInfo","dbgSanityChecks","Error","JSON","stringify","key","value","resource","getSampler","storageTexture","hardwareTexture","_hardwareTexture","view","viewForWriting","_j","isReady","externalTexture","underlyingResource","_k","importExternalTexture","source","buffer","dataBuffer","webgpuBuffer","size","capacity","groupLayout","createBindGroup","layout"],"sources":["../../../../../dev/core/src/Engines/WebGPU/webgpuCacheBindGroups.ts"],"sourcesContent":["import { Logger } from \"../../Misc/logger\";\r\nimport type { WebGPUCacheSampler } from \"./webgpuCacheSampler\";\r\nimport type { WebGPUMaterialContext } from \"./webgpuMaterialContext\";\r\nimport type { WebGPUPipelineContext } from \"./webgpuPipelineContext\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport type { WebGPUHardwareTexture } from \"./webgpuHardwareTexture\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { ExternalTexture } from \"../../Materials/Textures/externalTexture\";\r\nimport type { WebGPUDrawContext } from \"./webgpuDrawContext\";\r\n\r\nclass WebGPUBindGroupCacheNode {\r\n    public values: { [id: number]: WebGPUBindGroupCacheNode };\r\n    public bindGroups: GPUBindGroup[];\r\n\r\n    constructor() {\r\n        this.values = {};\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPUCacheBindGroups {\r\n    public static NumBindGroupsCreatedTotal = 0;\r\n    public static NumBindGroupsCreatedLastFrame = 0;\r\n    public static NumBindGroupsLookupLastFrame = 0;\r\n    public static NumBindGroupsNoLookupLastFrame = 0;\r\n\r\n    private static _Cache: WebGPUBindGroupCacheNode = new WebGPUBindGroupCacheNode();\r\n\r\n    private static _NumBindGroupsCreatedCurrentFrame = 0;\r\n    private static _NumBindGroupsLookupCurrentFrame = 0;\r\n    private static _NumBindGroupsNoLookupCurrentFrame = 0;\r\n\r\n    private _device: GPUDevice;\r\n    private _cacheSampler: WebGPUCacheSampler;\r\n    private _engine: WebGPUEngine;\r\n\r\n    public disabled = false;\r\n\r\n    public static get Statistics() {\r\n        return {\r\n            totalCreated: WebGPUCacheBindGroups.NumBindGroupsCreatedTotal,\r\n            lastFrameCreated: WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame,\r\n            lookupLastFrame: WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame,\r\n            noLookupLastFrame: WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame,\r\n        };\r\n    }\r\n\r\n    constructor(device: GPUDevice, cacheSampler: WebGPUCacheSampler, engine: WebGPUEngine) {\r\n        this._device = device;\r\n        this._cacheSampler = cacheSampler;\r\n        this._engine = engine;\r\n    }\r\n\r\n    public endFrame(): void {\r\n        WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame = WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame;\r\n        WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame = WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame;\r\n        WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame = WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame;\r\n        WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame = 0;\r\n        WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame = 0;\r\n        WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame = 0;\r\n    }\r\n\r\n    /**\r\n     * Cache is currently based on the uniform/storage buffers, samplers and textures used by the binding groups.\r\n     * Note that all uniform buffers have an offset of 0 in Babylon and we don't have a use case where we would have the same buffer used with different capacity values:\r\n     * that means we don't need to factor in the offset/size of the buffer in the cache, only the id\r\n     * @param webgpuPipelineContext\r\n     * @param drawContext\r\n     * @param materialContext\r\n     */\r\n    public getBindGroups(webgpuPipelineContext: WebGPUPipelineContext, drawContext: WebGPUDrawContext, materialContext: WebGPUMaterialContext): GPUBindGroup[] {\r\n        let bindGroups: GPUBindGroup[] | undefined = undefined;\r\n        let node = WebGPUCacheBindGroups._Cache;\r\n\r\n        const cacheIsDisabled = this.disabled || materialContext.forceBindGroupCreation;\r\n        if (!cacheIsDisabled) {\r\n            if (!drawContext.isDirty(materialContext.updateId) && !materialContext.isDirty) {\r\n                WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame++;\r\n                return drawContext.bindGroups!;\r\n            }\r\n\r\n            for (const bufferName of webgpuPipelineContext.shaderProcessingContext.bufferNames) {\r\n                const uboId = drawContext.buffers[bufferName]?.uniqueId ?? 0;\r\n                let nextNode = node.values[uboId];\r\n                if (!nextNode) {\r\n                    nextNode = new WebGPUBindGroupCacheNode();\r\n                    node.values[uboId] = nextNode;\r\n                }\r\n                node = nextNode;\r\n            }\r\n\r\n            for (const samplerName of webgpuPipelineContext.shaderProcessingContext.samplerNames) {\r\n                const samplerHashCode = materialContext.samplers[samplerName]?.hashCode ?? 0;\r\n                let nextNode = node.values[samplerHashCode];\r\n                if (!nextNode) {\r\n                    nextNode = new WebGPUBindGroupCacheNode();\r\n                    node.values[samplerHashCode] = nextNode;\r\n                }\r\n                node = nextNode;\r\n            }\r\n\r\n            for (const textureName of webgpuPipelineContext.shaderProcessingContext.textureNames) {\r\n                const textureId = materialContext.textures[textureName]?.texture?.uniqueId ?? 0;\r\n                let nextNode = node.values[textureId];\r\n                if (!nextNode) {\r\n                    nextNode = new WebGPUBindGroupCacheNode();\r\n                    node.values[textureId] = nextNode;\r\n                }\r\n                node = nextNode;\r\n            }\r\n\r\n            bindGroups = node.bindGroups;\r\n        }\r\n\r\n        drawContext.resetIsDirty(materialContext.updateId);\r\n        materialContext.isDirty = false;\r\n\r\n        if (bindGroups) {\r\n            drawContext.bindGroups = bindGroups;\r\n            WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame++;\r\n            return bindGroups;\r\n        }\r\n\r\n        bindGroups = [];\r\n        drawContext.bindGroups = bindGroups;\r\n\r\n        if (!cacheIsDisabled) {\r\n            node.bindGroups = bindGroups;\r\n        }\r\n\r\n        WebGPUCacheBindGroups.NumBindGroupsCreatedTotal++;\r\n        WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame++;\r\n\r\n        const bindGroupLayouts = webgpuPipelineContext.bindGroupLayouts[materialContext.textureState];\r\n        for (let i = 0; i < webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries.length; i++) {\r\n            const setDefinition = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries[i];\r\n\r\n            const entries = webgpuPipelineContext.shaderProcessingContext.bindGroupEntries[i];\r\n            for (let j = 0; j < setDefinition.length; j++) {\r\n                const entry = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries[i][j];\r\n                const entryInfo = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding];\r\n                const name = entryInfo.nameInArrayOfTexture ?? entryInfo.name;\r\n\r\n                if (entry.sampler) {\r\n                    const bindingInfo = materialContext.samplers[name];\r\n                    if (bindingInfo) {\r\n                        const sampler = bindingInfo.sampler;\r\n                        if (!sampler) {\r\n                            if (this._engine.dbgSanityChecks) {\r\n                                Logger.Error(\r\n                                    `Trying to bind a null sampler! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(\r\n                                        bindingInfo,\r\n                                        (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                    )}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                    50\r\n                                );\r\n                            }\r\n                            continue;\r\n                        }\r\n                        entries[j].resource = this._cacheSampler.getSampler(sampler, false, bindingInfo.hashCode);\r\n                    } else {\r\n                        Logger.Error(\r\n                            `Sampler \"${name}\" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key: string, value: any) =>\r\n                                key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value\r\n                            )}`,\r\n                            50\r\n                        );\r\n                    }\r\n                } else if (entry.texture || entry.storageTexture) {\r\n                    const bindingInfo = materialContext.textures[name];\r\n                    if (bindingInfo) {\r\n                        if (this._engine.dbgSanityChecks && bindingInfo.texture === null) {\r\n                            Logger.Error(\r\n                                `Trying to bind a null texture! entry=${JSON.stringify(entry)}, bindingInfo=${JSON.stringify(bindingInfo, (key: string, value: any) =>\r\n                                    key === \"texture\" ? \"<no dump>\" : value\r\n                                )}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                50\r\n                            );\r\n                            continue;\r\n                        }\r\n                        const hardwareTexture = (bindingInfo.texture as InternalTexture)._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n                        if (\r\n                            this._engine.dbgSanityChecks &&\r\n                            (!hardwareTexture || (entry.texture && !hardwareTexture.view) || (entry.storageTexture && !hardwareTexture.viewForWriting))\r\n                        ) {\r\n                            Logger.Error(\r\n                                `Trying to bind a null gpu texture or view! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(\r\n                                    bindingInfo,\r\n                                    (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                )}, isReady=${bindingInfo.texture?.isReady}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                50\r\n                            );\r\n                            continue;\r\n                        }\r\n\r\n                        entries[j].resource = entry.storageTexture ? hardwareTexture.viewForWriting! : hardwareTexture.view!;\r\n                    } else {\r\n                        Logger.Error(\r\n                            `Texture \"${name}\" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key: string, value: any) =>\r\n                                key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value\r\n                            )}`,\r\n                            50\r\n                        );\r\n                    }\r\n                } else if (entry.externalTexture) {\r\n                    const bindingInfo = materialContext.textures[name];\r\n                    if (bindingInfo) {\r\n                        if (this._engine.dbgSanityChecks && bindingInfo.texture === null) {\r\n                            Logger.Error(\r\n                                `Trying to bind a null external texture! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(\r\n                                    bindingInfo,\r\n                                    (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                )}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                50\r\n                            );\r\n                            continue;\r\n                        }\r\n                        const externalTexture = (bindingInfo.texture as ExternalTexture).underlyingResource;\r\n\r\n                        if (this._engine.dbgSanityChecks && !externalTexture) {\r\n                            Logger.Error(\r\n                                `Trying to bind a null gpu external texture! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(\r\n                                    bindingInfo,\r\n                                    (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                )}, isReady=${bindingInfo.texture?.isReady}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                50\r\n                            );\r\n                            continue;\r\n                        }\r\n\r\n                        entries[j].resource = this._device.importExternalTexture({ source: externalTexture });\r\n                    } else {\r\n                        Logger.Error(\r\n                            `Texture \"${name}\" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key: string, value: any) =>\r\n                                key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value\r\n                            )}`,\r\n                            50\r\n                        );\r\n                    }\r\n                } else if (entry.buffer) {\r\n                    const dataBuffer = drawContext.buffers[name];\r\n                    if (dataBuffer) {\r\n                        const webgpuBuffer = dataBuffer.underlyingResource as GPUBuffer;\r\n                        (entries[j].resource as GPUBufferBinding).buffer = webgpuBuffer;\r\n                        (entries[j].resource as GPUBufferBinding).size = dataBuffer.capacity;\r\n                    } else {\r\n                        Logger.Error(\r\n                            `Can't find buffer \"${name}\". entry=${JSON.stringify(entry)}, buffers=${JSON.stringify(drawContext.buffers)}, drawContext.uniqueId=${\r\n                                drawContext.uniqueId\r\n                            }`,\r\n                            50\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            const groupLayout = bindGroupLayouts[i];\r\n            bindGroups[i] = this._device.createBindGroup({\r\n                layout: groupLayout,\r\n                entries,\r\n            });\r\n        }\r\n\r\n        return bindGroups;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}