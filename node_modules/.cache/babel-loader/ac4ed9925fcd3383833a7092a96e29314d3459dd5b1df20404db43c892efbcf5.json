{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../tslib.es6.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { SerializationHelper, serialize, serializeAsColor3, expandToProperty, serializeAsTexture, serializeAsVector3, serializeAsImageProcessingConfiguration } from \"../../Misc/decorators.js\";\nimport { SmartArray } from \"../../Misc/smartArray.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { Vector3, Vector4 } from \"../../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { MaterialHelper } from \"../../Materials/materialHelper.js\";\nimport { MaterialDefines } from \"../../Materials/materialDefines.js\";\nimport { PushMaterial } from \"../../Materials/pushMaterial.js\";\nimport { ImageProcessingConfiguration } from \"../../Materials/imageProcessingConfiguration.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport { RegisterClass } from \"../../Misc/typeStore.js\";\nimport { MaterialFlags } from \"../materialFlags.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport \"../../Shaders/background.fragment.js\";\nimport \"../../Shaders/background.vertex.js\";\nimport { EffectFallbacks } from \"../effectFallbacks.js\";\nimport { addClipPlaneUniforms, bindClipPlane } from \"../clipPlaneMaterialHelper.js\";\n/**\n * Background material defines definition.\n * @internal Mainly internal Use\n */\nclass BackgroundMaterialDefines extends MaterialDefines {\n  /**\n   * Constructor of the defines.\n   */\n  constructor() {\n    super();\n    /**\n     * True if the diffuse texture is in use.\n     */\n    this.DIFFUSE = false;\n    /**\n     * The direct UV channel to use.\n     */\n    this.DIFFUSEDIRECTUV = 0;\n    /**\n     * True if the diffuse texture is in gamma space.\n     */\n    this.GAMMADIFFUSE = false;\n    /**\n     * True if the diffuse texture has opacity in the alpha channel.\n     */\n    this.DIFFUSEHASALPHA = false;\n    /**\n     * True if you want the material to fade to transparent at grazing angle.\n     */\n    this.OPACITYFRESNEL = false;\n    /**\n     * True if an extra blur needs to be added in the reflection.\n     */\n    this.REFLECTIONBLUR = false;\n    /**\n     * True if you want the material to fade to reflection at grazing angle.\n     */\n    this.REFLECTIONFRESNEL = false;\n    /**\n     * True if you want the material to falloff as far as you move away from the scene center.\n     */\n    this.REFLECTIONFALLOFF = false;\n    /**\n     * False if the current Webgl implementation does not support the texture lod extension.\n     */\n    this.TEXTURELODSUPPORT = false;\n    /**\n     * True to ensure the data are premultiplied.\n     */\n    this.PREMULTIPLYALPHA = false;\n    /**\n     * True if the texture contains cooked RGB values and not gray scaled multipliers.\n     */\n    this.USERGBCOLOR = false;\n    /**\n     * True if highlight and shadow levels have been specified. It can help ensuring the main perceived color\n     * stays aligned with the desired configuration.\n     */\n    this.USEHIGHLIGHTANDSHADOWCOLORS = false;\n    /**\n     * True if only shadows must be rendered\n     */\n    this.BACKMAT_SHADOWONLY = false;\n    /**\n     * True to add noise in order to reduce the banding effect.\n     */\n    this.NOISE = false;\n    /**\n     * is the reflection texture in BGR color scheme?\n     * Mainly used to solve a bug in ios10 video tag\n     */\n    this.REFLECTIONBGR = false;\n    this.IMAGEPROCESSING = false;\n    this.VIGNETTE = false;\n    this.VIGNETTEBLENDMODEMULTIPLY = false;\n    this.VIGNETTEBLENDMODEOPAQUE = false;\n    this.TONEMAPPING = false;\n    this.TONEMAPPING_ACES = false;\n    this.CONTRAST = false;\n    this.COLORCURVES = false;\n    this.COLORGRADING = false;\n    this.COLORGRADING3D = false;\n    this.SAMPLER3DGREENDEPTH = false;\n    this.SAMPLER3DBGRMAP = false;\n    this.DITHER = false;\n    this.IMAGEPROCESSINGPOSTPROCESS = false;\n    this.SKIPFINALCOLORCLAMP = false;\n    this.EXPOSURE = false;\n    this.MULTIVIEW = false;\n    // Reflection.\n    this.REFLECTION = false;\n    this.REFLECTIONMAP_3D = false;\n    this.REFLECTIONMAP_SPHERICAL = false;\n    this.REFLECTIONMAP_PLANAR = false;\n    this.REFLECTIONMAP_CUBIC = false;\n    this.REFLECTIONMAP_PROJECTION = false;\n    this.REFLECTIONMAP_SKYBOX = false;\n    this.REFLECTIONMAP_EXPLICIT = false;\n    this.REFLECTIONMAP_EQUIRECTANGULAR = false;\n    this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\n    this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\n    this.INVERTCUBICMAP = false;\n    this.REFLECTIONMAP_OPPOSITEZ = false;\n    this.LODINREFLECTIONALPHA = false;\n    this.GAMMAREFLECTION = false;\n    this.RGBDREFLECTION = false;\n    this.EQUIRECTANGULAR_RELFECTION_FOV = false;\n    // Default BJS.\n    this.MAINUV1 = false;\n    this.MAINUV2 = false;\n    this.UV1 = false;\n    this.UV2 = false;\n    this.CLIPPLANE = false;\n    this.CLIPPLANE2 = false;\n    this.CLIPPLANE3 = false;\n    this.CLIPPLANE4 = false;\n    this.CLIPPLANE5 = false;\n    this.CLIPPLANE6 = false;\n    this.POINTSIZE = false;\n    this.FOG = false;\n    this.NORMAL = false;\n    this.NUM_BONE_INFLUENCERS = 0;\n    this.BonesPerMesh = 0;\n    this.INSTANCES = false;\n    this.SHADOWFLOAT = false;\n    this.LOGARITHMICDEPTH = false;\n    this.NONUNIFORMSCALING = false;\n    this.ALPHATEST = false;\n    this.rebuild();\n  }\n}\n/**\n * Background material used to create an efficient environment around your scene.\n */\nexport class BackgroundMaterial extends PushMaterial {\n  /**\n   * Experimental Internal Use Only.\n   *\n   * Key light Color in \"perceptual value\" meaning the color you would like to see on screen.\n   * This acts as a helper to set the primary color to a more \"human friendly\" value.\n   * Conversion to linear space as well as exposure and tone mapping correction will be applied to keep the\n   * output color as close as possible from the chosen value.\n   * (This does not account for contrast color grading and color curves as they are considered post effect and not directly\n   * part of lighting setup.)\n   */\n  get _perceptualColor() {\n    return this.__perceptualColor;\n  }\n  set _perceptualColor(value) {\n    this.__perceptualColor = value;\n    this._computePrimaryColorFromPerceptualColor();\n    this._markAllSubMeshesAsLightsDirty();\n  }\n  /**\n   * Defines the level of the shadows (dark area of the reflection map) in order to help scaling the colors.\n   * The color opposite to the primary color is used at the level chosen to define what the black area would look.\n   */\n  get primaryColorShadowLevel() {\n    return this._primaryColorShadowLevel;\n  }\n  set primaryColorShadowLevel(value) {\n    this._primaryColorShadowLevel = value;\n    this._computePrimaryColors();\n    this._markAllSubMeshesAsLightsDirty();\n  }\n  /**\n   * Defines the level of the highlights (highlight area of the reflection map) in order to help scaling the colors.\n   * The primary color is used at the level chosen to define what the white area would look.\n   */\n  get primaryColorHighlightLevel() {\n    return this._primaryColorHighlightLevel;\n  }\n  set primaryColorHighlightLevel(value) {\n    this._primaryColorHighlightLevel = value;\n    this._computePrimaryColors();\n    this._markAllSubMeshesAsLightsDirty();\n  }\n  /**\n   * Sets the reflection reflectance fresnel values according to the default standard\n   * empirically know to work well :-)\n   */\n  set reflectionStandardFresnelWeight(value) {\n    let reflectionWeight = value;\n    if (reflectionWeight < 0.5) {\n      reflectionWeight = reflectionWeight * 2.0;\n      this.reflectionReflectance0 = BackgroundMaterial.StandardReflectance0 * reflectionWeight;\n      this.reflectionReflectance90 = BackgroundMaterial.StandardReflectance90 * reflectionWeight;\n    } else {\n      reflectionWeight = reflectionWeight * 2.0 - 1.0;\n      this.reflectionReflectance0 = BackgroundMaterial.StandardReflectance0 + (1.0 - BackgroundMaterial.StandardReflectance0) * reflectionWeight;\n      this.reflectionReflectance90 = BackgroundMaterial.StandardReflectance90 + (1.0 - BackgroundMaterial.StandardReflectance90) * reflectionWeight;\n    }\n  }\n  /**\n   * The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values \"zoom in\" and higher values \"zoom out\".\n   * Best used when trying to implement visual zoom effects like fish-eye or binoculars while not adjusting camera fov.\n   * Recommended to be keep at 1.0 except for special cases.\n   */\n  get fovMultiplier() {\n    return this._fovMultiplier;\n  }\n  set fovMultiplier(value) {\n    if (isNaN(value)) {\n      value = 1.0;\n    }\n    this._fovMultiplier = Math.max(0.0, Math.min(2.0, value));\n  }\n  /**\n   * Attaches a new image processing configuration to the PBR Material.\n   * @param configuration (if null the scene configuration will be use)\n   */\n  _attachImageProcessingConfiguration(configuration) {\n    if (configuration === this._imageProcessingConfiguration) {\n      return;\n    }\n    // Detaches observer.\n    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n    }\n    // Pick the scene configuration if needed.\n    if (!configuration) {\n      this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\n    } else {\n      this._imageProcessingConfiguration = configuration;\n    }\n    // Attaches observer.\n    if (this._imageProcessingConfiguration) {\n      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\n        this._computePrimaryColorFromPerceptualColor();\n        this._markAllSubMeshesAsImageProcessingDirty();\n      });\n    }\n  }\n  /**\n   * Gets the image processing configuration used either in this material.\n   */\n  get imageProcessingConfiguration() {\n    return this._imageProcessingConfiguration;\n  }\n  /**\n   * Sets the Default image processing configuration used either in the this material.\n   *\n   * If sets to null, the scene one is in use.\n   */\n  set imageProcessingConfiguration(value) {\n    this._attachImageProcessingConfiguration(value);\n    // Ensure the effect will be rebuilt.\n    this._markAllSubMeshesAsTexturesDirty();\n  }\n  /**\n   * Gets whether the color curves effect is enabled.\n   */\n  get cameraColorCurvesEnabled() {\n    return this.imageProcessingConfiguration.colorCurvesEnabled;\n  }\n  /**\n   * Sets whether the color curves effect is enabled.\n   */\n  set cameraColorCurvesEnabled(value) {\n    this.imageProcessingConfiguration.colorCurvesEnabled = value;\n  }\n  /**\n   * Gets whether the color grading effect is enabled.\n   */\n  get cameraColorGradingEnabled() {\n    return this.imageProcessingConfiguration.colorGradingEnabled;\n  }\n  /**\n   * Gets whether the color grading effect is enabled.\n   */\n  set cameraColorGradingEnabled(value) {\n    this.imageProcessingConfiguration.colorGradingEnabled = value;\n  }\n  /**\n   * Gets whether tonemapping is enabled or not.\n   */\n  get cameraToneMappingEnabled() {\n    return this._imageProcessingConfiguration.toneMappingEnabled;\n  }\n  /**\n   * Sets whether tonemapping is enabled or not\n   */\n  set cameraToneMappingEnabled(value) {\n    this._imageProcessingConfiguration.toneMappingEnabled = value;\n  }\n  /**\n   * The camera exposure used on this material.\n   * This property is here and not in the camera to allow controlling exposure without full screen post process.\n   * This corresponds to a photographic exposure.\n   */\n  get cameraExposure() {\n    return this._imageProcessingConfiguration.exposure;\n  }\n  /**\n   * The camera exposure used on this material.\n   * This property is here and not in the camera to allow controlling exposure without full screen post process.\n   * This corresponds to a photographic exposure.\n   */\n  set cameraExposure(value) {\n    this._imageProcessingConfiguration.exposure = value;\n  }\n  /**\n   * Gets The camera contrast used on this material.\n   */\n  get cameraContrast() {\n    return this._imageProcessingConfiguration.contrast;\n  }\n  /**\n   * Sets The camera contrast used on this material.\n   */\n  set cameraContrast(value) {\n    this._imageProcessingConfiguration.contrast = value;\n  }\n  /**\n   * Gets the Color Grading 2D Lookup Texture.\n   */\n  get cameraColorGradingTexture() {\n    return this._imageProcessingConfiguration.colorGradingTexture;\n  }\n  /**\n   * Sets the Color Grading 2D Lookup Texture.\n   */\n  set cameraColorGradingTexture(value) {\n    this.imageProcessingConfiguration.colorGradingTexture = value;\n  }\n  /**\n   * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).\n   * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\n   * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\n   * corresponding to low luminance, medium luminance, and high luminance areas respectively.\n   */\n  get cameraColorCurves() {\n    return this.imageProcessingConfiguration.colorCurves;\n  }\n  /**\n   * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).\n   * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\n   * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\n   * corresponding to low luminance, medium luminance, and high luminance areas respectively.\n   */\n  set cameraColorCurves(value) {\n    this.imageProcessingConfiguration.colorCurves = value;\n  }\n  /**\n   * Instantiates a Background Material in the given scene\n   * @param name The friendly name of the material\n   * @param scene The scene to add the material to\n   */\n  constructor(name, scene) {\n    super(name, scene);\n    /**\n     * Key light Color (multiply against the environment texture)\n     */\n    this.primaryColor = Color3.White();\n    this._primaryColorShadowLevel = 0;\n    this._primaryColorHighlightLevel = 0;\n    /**\n     * Reflection Texture used in the material.\n     * Should be author in a specific way for the best result (refer to the documentation).\n     */\n    this.reflectionTexture = null;\n    /**\n     * Reflection Texture level of blur.\n     *\n     * Can be use to reuse an existing HDR Texture and target a specific LOD to prevent authoring the\n     * texture twice.\n     */\n    this.reflectionBlur = 0;\n    /**\n     * Diffuse Texture used in the material.\n     * Should be author in a specific way for the best result (refer to the documentation).\n     */\n    this.diffuseTexture = null;\n    this._shadowLights = null;\n    /**\n     * Specify the list of lights casting shadow on the material.\n     * All scene shadow lights will be included if null.\n     */\n    this.shadowLights = null;\n    /**\n     * Helps adjusting the shadow to a softer level if required.\n     * 0 means black shadows and 1 means no shadows.\n     */\n    this.shadowLevel = 0;\n    /**\n     * In case of opacity Fresnel or reflection falloff, this is use as a scene center.\n     * It is usually zero but might be interesting to modify according to your setup.\n     */\n    this.sceneCenter = Vector3.Zero();\n    /**\n     * This helps specifying that the material is falling off to the sky box at grazing angle.\n     * This helps ensuring a nice transition when the camera goes under the ground.\n     */\n    this.opacityFresnel = true;\n    /**\n     * This helps specifying that the material is falling off from diffuse to the reflection texture at grazing angle.\n     * This helps adding a mirror texture on the ground.\n     */\n    this.reflectionFresnel = false;\n    /**\n     * This helps specifying the falloff radius off the reflection texture from the sceneCenter.\n     * This helps adding a nice falloff effect to the reflection if used as a mirror for instance.\n     */\n    this.reflectionFalloffDistance = 0.0;\n    /**\n     * This specifies the weight of the reflection against the background in case of reflection Fresnel.\n     */\n    this.reflectionAmount = 1.0;\n    /**\n     * This specifies the weight of the reflection at grazing angle.\n     */\n    this.reflectionReflectance0 = 0.05;\n    /**\n     * This specifies the weight of the reflection at a perpendicular point of view.\n     */\n    this.reflectionReflectance90 = 0.5;\n    /**\n     * Helps to directly use the maps channels instead of their level.\n     */\n    this.useRGBColor = true;\n    /**\n     * This helps reducing the banding effect that could occur on the background.\n     */\n    this.enableNoise = false;\n    this._fovMultiplier = 1.0;\n    /**\n     * Enable the FOV adjustment feature controlled by fovMultiplier.\n     */\n    this.useEquirectangularFOV = false;\n    this._maxSimultaneousLights = 4;\n    /**\n     * Number of Simultaneous lights allowed on the material.\n     */\n    this.maxSimultaneousLights = 4;\n    this._shadowOnly = false;\n    /**\n     * Make the material only render shadows\n     */\n    this.shadowOnly = false;\n    /**\n     * Keep track of the image processing observer to allow dispose and replace.\n     */\n    this._imageProcessingObserver = null;\n    /**\n     * Due to a bug in iOS10, video tags (which are using the background material) are in BGR and not RGB.\n     * Setting this flag to true (not done automatically!) will convert it back to RGB.\n     */\n    this.switchToBGR = false;\n    // Temp values kept as cache in the material.\n    this._renderTargets = new SmartArray(16);\n    this._reflectionControls = Vector4.Zero();\n    this._white = Color3.White();\n    this._primaryShadowColor = Color3.Black();\n    this._primaryHighlightColor = Color3.Black();\n    // Setup the default processing configuration to the scene.\n    this._attachImageProcessingConfiguration(null);\n    this.getRenderTargetTextures = () => {\n      this._renderTargets.reset();\n      if (this._diffuseTexture && this._diffuseTexture.isRenderTarget) {\n        this._renderTargets.push(this._diffuseTexture);\n      }\n      if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\n        this._renderTargets.push(this._reflectionTexture);\n      }\n      return this._renderTargets;\n    };\n  }\n  /**\n   * Gets a boolean indicating that current material needs to register RTT\n   */\n  get hasRenderTargetTextures() {\n    if (this._diffuseTexture && this._diffuseTexture.isRenderTarget) {\n      return true;\n    }\n    if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * The entire material has been created in order to prevent overdraw.\n   * @returns false\n   */\n  needAlphaTesting() {\n    return true;\n  }\n  /**\n   * The entire material has been created in order to prevent overdraw.\n   * @returns true if blending is enable\n   */\n  needAlphaBlending() {\n    return this.alpha < 1 || this._diffuseTexture != null && this._diffuseTexture.hasAlpha || this._shadowOnly;\n  }\n  /**\n   * Checks whether the material is ready to be rendered for a given mesh.\n   * @param mesh The mesh to render\n   * @param subMesh The submesh to check against\n   * @param useInstances Specify wether or not the material is used with instances\n   * @returns true if all the dependencies are ready (Textures, Effects...)\n   */\n  isReadyForSubMesh(mesh, subMesh, useInstances = false) {\n    if (subMesh.effect && this.isFrozen) {\n      if (subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\n        return true;\n      }\n    }\n    if (!subMesh.materialDefines) {\n      subMesh.materialDefines = new BackgroundMaterialDefines();\n    }\n    const scene = this.getScene();\n    const defines = subMesh.materialDefines;\n    if (this._isReadyForSubMesh(subMesh)) {\n      return true;\n    }\n    const engine = scene.getEngine();\n    // Lights\n    MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights);\n    defines._needNormals = true;\n    // Multiview\n    MaterialHelper.PrepareDefinesForMultiview(scene, defines);\n    // Textures\n    if (defines._areTexturesDirty) {\n      defines._needUVs = false;\n      if (scene.texturesEnabled) {\n        if (scene.getEngine().getCaps().textureLOD) {\n          defines.TEXTURELODSUPPORT = true;\n        }\n        if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\n          if (!this._diffuseTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n          MaterialHelper.PrepareDefinesForMergedUV(this._diffuseTexture, defines, \"DIFFUSE\");\n          defines.DIFFUSEHASALPHA = this._diffuseTexture.hasAlpha;\n          defines.GAMMADIFFUSE = this._diffuseTexture.gammaSpace;\n          defines.OPACITYFRESNEL = this._opacityFresnel;\n        } else {\n          defines.DIFFUSE = false;\n          defines.DIFFUSEDIRECTUV = 0;\n          defines.DIFFUSEHASALPHA = false;\n          defines.GAMMADIFFUSE = false;\n          defines.OPACITYFRESNEL = false;\n        }\n        const reflectionTexture = this._reflectionTexture;\n        if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\n          if (!reflectionTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n          defines.REFLECTION = true;\n          defines.GAMMAREFLECTION = reflectionTexture.gammaSpace;\n          defines.RGBDREFLECTION = reflectionTexture.isRGBD;\n          defines.REFLECTIONBLUR = this._reflectionBlur > 0;\n          defines.LODINREFLECTIONALPHA = reflectionTexture.lodLevelInAlpha;\n          defines.EQUIRECTANGULAR_RELFECTION_FOV = this.useEquirectangularFOV;\n          defines.REFLECTIONBGR = this.switchToBGR;\n          if (reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE) {\n            defines.INVERTCUBICMAP = true;\n          }\n          defines.REFLECTIONMAP_3D = reflectionTexture.isCube;\n          defines.REFLECTIONMAP_OPPOSITEZ = defines.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ;\n          switch (reflectionTexture.coordinatesMode) {\n            case Texture.EXPLICIT_MODE:\n              defines.REFLECTIONMAP_EXPLICIT = true;\n              break;\n            case Texture.PLANAR_MODE:\n              defines.REFLECTIONMAP_PLANAR = true;\n              break;\n            case Texture.PROJECTION_MODE:\n              defines.REFLECTIONMAP_PROJECTION = true;\n              break;\n            case Texture.SKYBOX_MODE:\n              defines.REFLECTIONMAP_SKYBOX = true;\n              break;\n            case Texture.SPHERICAL_MODE:\n              defines.REFLECTIONMAP_SPHERICAL = true;\n              break;\n            case Texture.EQUIRECTANGULAR_MODE:\n              defines.REFLECTIONMAP_EQUIRECTANGULAR = true;\n              break;\n            case Texture.FIXED_EQUIRECTANGULAR_MODE:\n              defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = true;\n              break;\n            case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:\n              defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = true;\n              break;\n            case Texture.CUBIC_MODE:\n            case Texture.INVCUBIC_MODE:\n            default:\n              defines.REFLECTIONMAP_CUBIC = true;\n              break;\n          }\n          if (this.reflectionFresnel) {\n            defines.REFLECTIONFRESNEL = true;\n            defines.REFLECTIONFALLOFF = this.reflectionFalloffDistance > 0;\n            this._reflectionControls.x = this.reflectionAmount;\n            this._reflectionControls.y = this.reflectionReflectance0;\n            this._reflectionControls.z = this.reflectionReflectance90;\n            this._reflectionControls.w = 1 / this.reflectionFalloffDistance;\n          } else {\n            defines.REFLECTIONFRESNEL = false;\n            defines.REFLECTIONFALLOFF = false;\n          }\n        } else {\n          defines.REFLECTION = false;\n          defines.REFLECTIONFRESNEL = false;\n          defines.REFLECTIONFALLOFF = false;\n          defines.REFLECTIONBLUR = false;\n          defines.REFLECTIONMAP_3D = false;\n          defines.REFLECTIONMAP_SPHERICAL = false;\n          defines.REFLECTIONMAP_PLANAR = false;\n          defines.REFLECTIONMAP_CUBIC = false;\n          defines.REFLECTIONMAP_PROJECTION = false;\n          defines.REFLECTIONMAP_SKYBOX = false;\n          defines.REFLECTIONMAP_EXPLICIT = false;\n          defines.REFLECTIONMAP_EQUIRECTANGULAR = false;\n          defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\n          defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\n          defines.INVERTCUBICMAP = false;\n          defines.REFLECTIONMAP_OPPOSITEZ = false;\n          defines.LODINREFLECTIONALPHA = false;\n          defines.GAMMAREFLECTION = false;\n          defines.RGBDREFLECTION = false;\n        }\n      }\n      defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;\n      defines.USERGBCOLOR = this._useRGBColor;\n      defines.NOISE = this._enableNoise;\n    }\n    if (defines._areLightsDirty) {\n      defines.USEHIGHLIGHTANDSHADOWCOLORS = !this._useRGBColor && (this._primaryColorShadowLevel !== 0 || this._primaryColorHighlightLevel !== 0);\n      defines.BACKMAT_SHADOWONLY = this._shadowOnly;\n    }\n    if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\n      if (!this._imageProcessingConfiguration.isReady()) {\n        return false;\n      }\n      this._imageProcessingConfiguration.prepareDefines(defines);\n    }\n    // Misc.\n    MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\n    // Values that need to be evaluated on every frame\n    MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);\n    // Attribs\n    if (MaterialHelper.PrepareDefinesForAttributes(mesh, defines, false, true, false)) {\n      if (mesh) {\n        if (!scene.getEngine().getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n          mesh.createNormals(true);\n          Logger.Warn(\"BackgroundMaterial: Normals have been created for the mesh: \" + mesh.name);\n        }\n      }\n    }\n    // Get correct effect\n    if (defines.isDirty) {\n      defines.markAsProcessed();\n      scene.resetCachedMaterial();\n      // Fallbacks\n      const fallbacks = new EffectFallbacks();\n      if (defines.FOG) {\n        fallbacks.addFallback(0, \"FOG\");\n      }\n      if (defines.POINTSIZE) {\n        fallbacks.addFallback(1, \"POINTSIZE\");\n      }\n      if (defines.MULTIVIEW) {\n        fallbacks.addFallback(0, \"MULTIVIEW\");\n      }\n      MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights);\n      //Attributes\n      const attribs = [VertexBuffer.PositionKind];\n      if (defines.NORMAL) {\n        attribs.push(VertexBuffer.NormalKind);\n      }\n      if (defines.UV1) {\n        attribs.push(VertexBuffer.UVKind);\n      }\n      if (defines.UV2) {\n        attribs.push(VertexBuffer.UV2Kind);\n      }\n      MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\n      MaterialHelper.PrepareAttributesForInstances(attribs, defines);\n      const uniforms = [\"world\", \"view\", \"viewProjection\", \"vEyePosition\", \"vLightsType\", \"vFogInfos\", \"vFogColor\", \"pointSize\", \"mBones\", \"vPrimaryColor\", \"vPrimaryColorShadow\", \"vReflectionInfos\", \"reflectionMatrix\", \"vReflectionMicrosurfaceInfos\", \"fFovMultiplier\", \"shadowLevel\", \"alpha\", \"vBackgroundCenter\", \"vReflectionControl\", \"vDiffuseInfos\", \"diffuseMatrix\"];\n      addClipPlaneUniforms(uniforms);\n      const samplers = [\"diffuseSampler\", \"reflectionSampler\", \"reflectionSamplerLow\", \"reflectionSamplerHigh\"];\n      const uniformBuffers = [\"Material\", \"Scene\"];\n      if (ImageProcessingConfiguration) {\n        ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);\n        ImageProcessingConfiguration.PrepareSamplers(samplers, defines);\n      }\n      MaterialHelper.PrepareUniformsAndSamplersList({\n        uniformsNames: uniforms,\n        uniformBuffersNames: uniformBuffers,\n        samplers: samplers,\n        defines: defines,\n        maxSimultaneousLights: this._maxSimultaneousLights\n      });\n      const join = defines.toString();\n      const effect = scene.getEngine().createEffect(\"background\", {\n        attributes: attribs,\n        uniformsNames: uniforms,\n        uniformBuffersNames: uniformBuffers,\n        samplers: samplers,\n        defines: join,\n        fallbacks: fallbacks,\n        onCompiled: this.onCompiled,\n        onError: this.onError,\n        indexParameters: {\n          maxSimultaneousLights: this._maxSimultaneousLights\n        }\n      }, engine);\n      subMesh.setEffect(effect, defines, this._materialContext);\n      this.buildUniformLayout();\n    }\n    if (!subMesh.effect || !subMesh.effect.isReady()) {\n      return false;\n    }\n    defines._renderId = scene.getRenderId();\n    subMesh.effect._wasPreviouslyReady = true;\n    subMesh.effect._wasPreviouslyUsingInstances = useInstances;\n    this._checkScenePerformancePriority();\n    return true;\n  }\n  /**\n   * Compute the primary color according to the chosen perceptual color.\n   */\n  _computePrimaryColorFromPerceptualColor() {\n    if (!this.__perceptualColor) {\n      return;\n    }\n    this._primaryColor.copyFrom(this.__perceptualColor);\n    // Revert gamma space.\n    this._primaryColor.toLinearSpaceToRef(this._primaryColor, this.getScene().getEngine().useExactSrgbConversions);\n    // Revert image processing configuration.\n    if (this._imageProcessingConfiguration) {\n      // Revert Exposure.\n      this._primaryColor.scaleToRef(1 / this._imageProcessingConfiguration.exposure, this._primaryColor);\n    }\n    this._computePrimaryColors();\n  }\n  /**\n   * Compute the highlights and shadow colors according to their chosen levels.\n   */\n  _computePrimaryColors() {\n    if (this._primaryColorShadowLevel === 0 && this._primaryColorHighlightLevel === 0) {\n      return;\n    }\n    // Find the highlight color based on the configuration.\n    this._primaryColor.scaleToRef(this._primaryColorShadowLevel, this._primaryShadowColor);\n    this._primaryColor.subtractToRef(this._primaryShadowColor, this._primaryShadowColor);\n    // Find the shadow color based on the configuration.\n    this._white.subtractToRef(this._primaryColor, this._primaryHighlightColor);\n    this._primaryHighlightColor.scaleToRef(this._primaryColorHighlightLevel, this._primaryHighlightColor);\n    this._primaryColor.addToRef(this._primaryHighlightColor, this._primaryHighlightColor);\n  }\n  /**\n   * Build the uniform buffer used in the material.\n   */\n  buildUniformLayout() {\n    // Order is important !\n    this._uniformBuffer.addUniform(\"vPrimaryColor\", 4);\n    this._uniformBuffer.addUniform(\"vPrimaryColorShadow\", 4);\n    this._uniformBuffer.addUniform(\"vDiffuseInfos\", 2);\n    this._uniformBuffer.addUniform(\"vReflectionInfos\", 2);\n    this._uniformBuffer.addUniform(\"diffuseMatrix\", 16);\n    this._uniformBuffer.addUniform(\"reflectionMatrix\", 16);\n    this._uniformBuffer.addUniform(\"vReflectionMicrosurfaceInfos\", 3);\n    this._uniformBuffer.addUniform(\"fFovMultiplier\", 1);\n    this._uniformBuffer.addUniform(\"pointSize\", 1);\n    this._uniformBuffer.addUniform(\"shadowLevel\", 1);\n    this._uniformBuffer.addUniform(\"alpha\", 1);\n    this._uniformBuffer.addUniform(\"vBackgroundCenter\", 3);\n    this._uniformBuffer.addUniform(\"vReflectionControl\", 4);\n    this._uniformBuffer.create();\n  }\n  /**\n   * Unbind the material.\n   */\n  unbind() {\n    if (this._diffuseTexture && this._diffuseTexture.isRenderTarget) {\n      this._uniformBuffer.setTexture(\"diffuseSampler\", null);\n    }\n    if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\n      this._uniformBuffer.setTexture(\"reflectionSampler\", null);\n    }\n    super.unbind();\n  }\n  /**\n   * Bind only the world matrix to the material.\n   * @param world The world matrix to bind.\n   */\n  bindOnlyWorldMatrix(world) {\n    this._activeEffect.setMatrix(\"world\", world);\n  }\n  /**\n   * Bind the material for a dedicated submeh (every used meshes will be considered opaque).\n   * @param world The world matrix to bind.\n   * @param mesh\n   * @param subMesh The submesh to bind for.\n   */\n  bindForSubMesh(world, mesh, subMesh) {\n    const scene = this.getScene();\n    const defines = subMesh.materialDefines;\n    if (!defines) {\n      return;\n    }\n    const effect = subMesh.effect;\n    if (!effect) {\n      return;\n    }\n    this._activeEffect = effect;\n    // Matrices\n    this.bindOnlyWorldMatrix(world);\n    // Bones\n    MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\n    const mustRebind = this._mustRebind(scene, effect, mesh.visibility);\n    if (mustRebind) {\n      this._uniformBuffer.bindToEffect(effect, \"Material\");\n      this.bindViewProjection(effect);\n      const reflectionTexture = this._reflectionTexture;\n      if (!this._uniformBuffer.useUbo || !this.isFrozen || !this._uniformBuffer.isSync) {\n        // Texture uniforms\n        if (scene.texturesEnabled) {\n          if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\n            this._uniformBuffer.updateFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\n            MaterialHelper.BindTextureMatrix(this._diffuseTexture, this._uniformBuffer, \"diffuse\");\n          }\n          if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\n            this._uniformBuffer.updateMatrix(\"reflectionMatrix\", reflectionTexture.getReflectionTextureMatrix());\n            this._uniformBuffer.updateFloat2(\"vReflectionInfos\", reflectionTexture.level, this._reflectionBlur);\n            this._uniformBuffer.updateFloat3(\"vReflectionMicrosurfaceInfos\", reflectionTexture.getSize().width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);\n          }\n        }\n        if (this.shadowLevel > 0) {\n          this._uniformBuffer.updateFloat(\"shadowLevel\", this.shadowLevel);\n        }\n        this._uniformBuffer.updateFloat(\"alpha\", this.alpha);\n        // Point size\n        if (this.pointsCloud) {\n          this._uniformBuffer.updateFloat(\"pointSize\", this.pointSize);\n        }\n        if (defines.USEHIGHLIGHTANDSHADOWCOLORS) {\n          this._uniformBuffer.updateColor4(\"vPrimaryColor\", this._primaryHighlightColor, 1.0);\n          this._uniformBuffer.updateColor4(\"vPrimaryColorShadow\", this._primaryShadowColor, 1.0);\n        } else {\n          this._uniformBuffer.updateColor4(\"vPrimaryColor\", this._primaryColor, 1.0);\n        }\n      }\n      this._uniformBuffer.updateFloat(\"fFovMultiplier\", this._fovMultiplier);\n      // Textures\n      if (scene.texturesEnabled) {\n        if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\n          this._uniformBuffer.setTexture(\"diffuseSampler\", this._diffuseTexture);\n        }\n        if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\n          if (defines.REFLECTIONBLUR && defines.TEXTURELODSUPPORT) {\n            this._uniformBuffer.setTexture(\"reflectionSampler\", reflectionTexture);\n          } else if (!defines.REFLECTIONBLUR) {\n            this._uniformBuffer.setTexture(\"reflectionSampler\", reflectionTexture);\n          } else {\n            this._uniformBuffer.setTexture(\"reflectionSampler\", reflectionTexture._lodTextureMid || reflectionTexture);\n            this._uniformBuffer.setTexture(\"reflectionSamplerLow\", reflectionTexture._lodTextureLow || reflectionTexture);\n            this._uniformBuffer.setTexture(\"reflectionSamplerHigh\", reflectionTexture._lodTextureHigh || reflectionTexture);\n          }\n          if (defines.REFLECTIONFRESNEL) {\n            this._uniformBuffer.updateFloat3(\"vBackgroundCenter\", this.sceneCenter.x, this.sceneCenter.y, this.sceneCenter.z);\n            this._uniformBuffer.updateFloat4(\"vReflectionControl\", this._reflectionControls.x, this._reflectionControls.y, this._reflectionControls.z, this._reflectionControls.w);\n          }\n        }\n      }\n      // Clip plane\n      bindClipPlane(this._activeEffect, this, scene);\n      scene.bindEyePosition(effect);\n    } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {\n      this._uniformBuffer.bindToEffect(effect, \"Material\");\n      this._needToBindSceneUbo = true;\n    }\n    if (mustRebind || !this.isFrozen) {\n      if (scene.lightsEnabled) {\n        MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);\n      }\n      // View\n      this.bindView(effect);\n      // Fog\n      MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect, true);\n      // image processing\n      if (this._imageProcessingConfiguration) {\n        this._imageProcessingConfiguration.bind(this._activeEffect);\n      }\n    }\n    this._afterBind(mesh, this._activeEffect);\n    this._uniformBuffer.update();\n  }\n  /**\n   * Checks to see if a texture is used in the material.\n   * @param texture - Base texture to use.\n   * @returns - Boolean specifying if a texture is used in the material.\n   */\n  hasTexture(texture) {\n    if (super.hasTexture(texture)) {\n      return true;\n    }\n    if (this._reflectionTexture === texture) {\n      return true;\n    }\n    if (this._diffuseTexture === texture) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Dispose the material.\n   * @param forceDisposeEffect Force disposal of the associated effect.\n   * @param forceDisposeTextures Force disposal of the associated textures.\n   */\n  dispose(forceDisposeEffect = false, forceDisposeTextures = false) {\n    if (forceDisposeTextures) {\n      if (this.diffuseTexture) {\n        this.diffuseTexture.dispose();\n      }\n      if (this.reflectionTexture) {\n        this.reflectionTexture.dispose();\n      }\n    }\n    this._renderTargets.dispose();\n    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n    }\n    super.dispose(forceDisposeEffect);\n  }\n  /**\n   * Clones the material.\n   * @param name The cloned name.\n   * @returns The cloned material.\n   */\n  clone(name) {\n    return SerializationHelper.Clone(() => new BackgroundMaterial(name, this.getScene()), this);\n  }\n  /**\n   * Serializes the current material to its JSON representation.\n   * @returns The JSON representation.\n   */\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.customType = \"BABYLON.BackgroundMaterial\";\n    return serializationObject;\n  }\n  /**\n   * Gets the class name of the material\n   * @returns \"BackgroundMaterial\"\n   */\n  getClassName() {\n    return \"BackgroundMaterial\";\n  }\n  /**\n   * Parse a JSON input to create back a background material.\n   * @param source The JSON data to parse\n   * @param scene The scene to create the parsed material in\n   * @param rootUrl The root url of the assets the material depends upon\n   * @returns the instantiated BackgroundMaterial.\n   */\n  static Parse(source, scene, rootUrl) {\n    return SerializationHelper.Parse(() => new BackgroundMaterial(source.name, scene), source, scene, rootUrl);\n  }\n}\n/**\n * Standard reflectance value at parallel view angle.\n */\nBackgroundMaterial.StandardReflectance0 = 0.05;\n/**\n * Standard reflectance value at grazing angle.\n */\nBackgroundMaterial.StandardReflectance90 = 0.5;\n__decorate([serializeAsColor3()], BackgroundMaterial.prototype, \"_primaryColor\", void 0);\n__decorate([expandToProperty(\"_markAllSubMeshesAsLightsDirty\")], BackgroundMaterial.prototype, \"primaryColor\", void 0);\n__decorate([serializeAsColor3()], BackgroundMaterial.prototype, \"__perceptualColor\", void 0);\n__decorate([serialize()], BackgroundMaterial.prototype, \"_primaryColorShadowLevel\", void 0);\n__decorate([serialize()], BackgroundMaterial.prototype, \"_primaryColorHighlightLevel\", void 0);\n__decorate([expandToProperty(\"_markAllSubMeshesAsLightsDirty\")], BackgroundMaterial.prototype, \"primaryColorHighlightLevel\", null);\n__decorate([serializeAsTexture()], BackgroundMaterial.prototype, \"_reflectionTexture\", void 0);\n__decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], BackgroundMaterial.prototype, \"reflectionTexture\", void 0);\n__decorate([serialize()], BackgroundMaterial.prototype, \"_reflectionBlur\", void 0);\n__decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], BackgroundMaterial.prototype, \"reflectionBlur\", void 0);\n__decorate([serializeAsTexture()], BackgroundMaterial.prototype, \"_diffuseTexture\", void 0);\n__decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], BackgroundMaterial.prototype, \"diffuseTexture\", void 0);\n__decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], BackgroundMaterial.prototype, \"shadowLights\", void 0);\n__decorate([serialize()], BackgroundMaterial.prototype, \"_shadowLevel\", void 0);\n__decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], BackgroundMaterial.prototype, \"shadowLevel\", void 0);\n__decorate([serializeAsVector3()], BackgroundMaterial.prototype, \"_sceneCenter\", void 0);\n__decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], BackgroundMaterial.prototype, \"sceneCenter\", void 0);\n__decorate([serialize()], BackgroundMaterial.prototype, \"_opacityFresnel\", void 0);\n__decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], BackgroundMaterial.prototype, \"opacityFresnel\", void 0);\n__decorate([serialize()], BackgroundMaterial.prototype, \"_reflectionFresnel\", void 0);\n__decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], BackgroundMaterial.prototype, \"reflectionFresnel\", void 0);\n__decorate([serialize()], BackgroundMaterial.prototype, \"_reflectionFalloffDistance\", void 0);\n__decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], BackgroundMaterial.prototype, \"reflectionFalloffDistance\", void 0);\n__decorate([serialize()], BackgroundMaterial.prototype, \"_reflectionAmount\", void 0);\n__decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], BackgroundMaterial.prototype, \"reflectionAmount\", void 0);\n__decorate([serialize()], BackgroundMaterial.prototype, \"_reflectionReflectance0\", void 0);\n__decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], BackgroundMaterial.prototype, \"reflectionReflectance0\", void 0);\n__decorate([serialize()], BackgroundMaterial.prototype, \"_reflectionReflectance90\", void 0);\n__decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], BackgroundMaterial.prototype, \"reflectionReflectance90\", void 0);\n__decorate([serialize()], BackgroundMaterial.prototype, \"_useRGBColor\", void 0);\n__decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], BackgroundMaterial.prototype, \"useRGBColor\", void 0);\n__decorate([serialize()], BackgroundMaterial.prototype, \"_enableNoise\", void 0);\n__decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], BackgroundMaterial.prototype, \"enableNoise\", void 0);\n__decorate([serialize()], BackgroundMaterial.prototype, \"_maxSimultaneousLights\", void 0);\n__decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], BackgroundMaterial.prototype, \"maxSimultaneousLights\", void 0);\n__decorate([serialize()], BackgroundMaterial.prototype, \"_shadowOnly\", void 0);\n__decorate([expandToProperty(\"_markAllSubMeshesAsLightsDirty\")], BackgroundMaterial.prototype, \"shadowOnly\", void 0);\n__decorate([serializeAsImageProcessingConfiguration()], BackgroundMaterial.prototype, \"_imageProcessingConfiguration\", void 0);\nRegisterClass(\"BABYLON.BackgroundMaterial\", BackgroundMaterial);","map":{"version":3,"names":["SerializationHelper","serialize","serializeAsColor3","expandToProperty","serializeAsTexture","serializeAsVector3","serializeAsImageProcessingConfiguration","SmartArray","Logger","Vector3","Vector4","VertexBuffer","MaterialHelper","MaterialDefines","PushMaterial","ImageProcessingConfiguration","Texture","RegisterClass","MaterialFlags","Color3","EffectFallbacks","addClipPlaneUniforms","bindClipPlane","BackgroundMaterialDefines","constructor","DIFFUSE","DIFFUSEDIRECTUV","GAMMADIFFUSE","DIFFUSEHASALPHA","OPACITYFRESNEL","REFLECTIONBLUR","REFLECTIONFRESNEL","REFLECTIONFALLOFF","TEXTURELODSUPPORT","PREMULTIPLYALPHA","USERGBCOLOR","USEHIGHLIGHTANDSHADOWCOLORS","BACKMAT_SHADOWONLY","NOISE","REFLECTIONBGR","IMAGEPROCESSING","VIGNETTE","VIGNETTEBLENDMODEMULTIPLY","VIGNETTEBLENDMODEOPAQUE","TONEMAPPING","TONEMAPPING_ACES","CONTRAST","COLORCURVES","COLORGRADING","COLORGRADING3D","SAMPLER3DGREENDEPTH","SAMPLER3DBGRMAP","DITHER","IMAGEPROCESSINGPOSTPROCESS","SKIPFINALCOLORCLAMP","EXPOSURE","MULTIVIEW","REFLECTION","REFLECTIONMAP_3D","REFLECTIONMAP_SPHERICAL","REFLECTIONMAP_PLANAR","REFLECTIONMAP_CUBIC","REFLECTIONMAP_PROJECTION","REFLECTIONMAP_SKYBOX","REFLECTIONMAP_EXPLICIT","REFLECTIONMAP_EQUIRECTANGULAR","REFLECTIONMAP_EQUIRECTANGULAR_FIXED","REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED","INVERTCUBICMAP","REFLECTIONMAP_OPPOSITEZ","LODINREFLECTIONALPHA","GAMMAREFLECTION","RGBDREFLECTION","EQUIRECTANGULAR_RELFECTION_FOV","MAINUV1","MAINUV2","UV1","UV2","CLIPPLANE","CLIPPLANE2","CLIPPLANE3","CLIPPLANE4","CLIPPLANE5","CLIPPLANE6","POINTSIZE","FOG","NORMAL","NUM_BONE_INFLUENCERS","BonesPerMesh","INSTANCES","SHADOWFLOAT","LOGARITHMICDEPTH","NONUNIFORMSCALING","ALPHATEST","rebuild","BackgroundMaterial","_perceptualColor","__perceptualColor","value","_computePrimaryColorFromPerceptualColor","_markAllSubMeshesAsLightsDirty","primaryColorShadowLevel","_primaryColorShadowLevel","_computePrimaryColors","primaryColorHighlightLevel","_primaryColorHighlightLevel","reflectionStandardFresnelWeight","reflectionWeight","reflectionReflectance0","StandardReflectance0","reflectionReflectance90","StandardReflectance90","fovMultiplier","_fovMultiplier","isNaN","Math","max","min","_attachImageProcessingConfiguration","configuration","_imageProcessingConfiguration","_imageProcessingObserver","onUpdateParameters","remove","getScene","imageProcessingConfiguration","add","_markAllSubMeshesAsImageProcessingDirty","_markAllSubMeshesAsTexturesDirty","cameraColorCurvesEnabled","colorCurvesEnabled","cameraColorGradingEnabled","colorGradingEnabled","cameraToneMappingEnabled","toneMappingEnabled","cameraExposure","exposure","cameraContrast","contrast","cameraColorGradingTexture","colorGradingTexture","cameraColorCurves","colorCurves","name","scene","primaryColor","White","reflectionTexture","reflectionBlur","diffuseTexture","_shadowLights","shadowLights","shadowLevel","sceneCenter","Zero","opacityFresnel","reflectionFresnel","reflectionFalloffDistance","reflectionAmount","useRGBColor","enableNoise","useEquirectangularFOV","_maxSimultaneousLights","maxSimultaneousLights","_shadowOnly","shadowOnly","switchToBGR","_renderTargets","_reflectionControls","_white","_primaryShadowColor","Black","_primaryHighlightColor","getRenderTargetTextures","reset","_diffuseTexture","isRenderTarget","push","_reflectionTexture","hasRenderTargetTextures","needAlphaTesting","needAlphaBlending","alpha","hasAlpha","isReadyForSubMesh","mesh","subMesh","useInstances","effect","isFrozen","_wasPreviouslyReady","_wasPreviouslyUsingInstances","materialDefines","defines","_isReadyForSubMesh","engine","getEngine","PrepareDefinesForLights","_needNormals","PrepareDefinesForMultiview","_areTexturesDirty","_needUVs","texturesEnabled","getCaps","textureLOD","DiffuseTextureEnabled","isReadyOrNotBlocking","PrepareDefinesForMergedUV","gammaSpace","_opacityFresnel","ReflectionTextureEnabled","isRGBD","_reflectionBlur","lodLevelInAlpha","coordinatesMode","INVCUBIC_MODE","isCube","useRightHandedSystem","invertZ","EXPLICIT_MODE","PLANAR_MODE","PROJECTION_MODE","SKYBOX_MODE","SPHERICAL_MODE","EQUIRECTANGULAR_MODE","FIXED_EQUIRECTANGULAR_MODE","FIXED_EQUIRECTANGULAR_MIRRORED_MODE","CUBIC_MODE","x","y","z","w","alphaMode","_useRGBColor","_enableNoise","_areLightsDirty","_areImageProcessingDirty","isReady","prepareDefines","PrepareDefinesForMisc","pointsCloud","fogEnabled","_shouldTurnAlphaTestOn","PrepareDefinesForFrameBoundValues","getRenderingMesh","hasThinInstances","PrepareDefinesForAttributes","standardDerivatives","isVerticesDataPresent","NormalKind","createNormals","Warn","isDirty","markAsProcessed","resetCachedMaterial","fallbacks","addFallback","HandleFallbacksForShadows","attribs","PositionKind","UVKind","UV2Kind","PrepareAttributesForBones","PrepareAttributesForInstances","uniforms","samplers","uniformBuffers","PrepareUniforms","PrepareSamplers","PrepareUniformsAndSamplersList","uniformsNames","uniformBuffersNames","join","toString","createEffect","attributes","onCompiled","onError","indexParameters","setEffect","_materialContext","buildUniformLayout","_renderId","getRenderId","_checkScenePerformancePriority","_primaryColor","copyFrom","toLinearSpaceToRef","useExactSrgbConversions","scaleToRef","subtractToRef","addToRef","_uniformBuffer","addUniform","create","unbind","setTexture","bindOnlyWorldMatrix","world","_activeEffect","setMatrix","bindForSubMesh","BindBonesParameters","mustRebind","_mustRebind","visibility","bindToEffect","bindViewProjection","useUbo","isSync","updateFloat2","coordinatesIndex","level","BindTextureMatrix","updateMatrix","getReflectionTextureMatrix","updateFloat3","getSize","width","lodGenerationScale","lodGenerationOffset","updateFloat","pointSize","updateColor4","_lodTextureMid","_lodTextureLow","_lodTextureHigh","updateFloat4","bindEyePosition","_features","needToAlwaysBindUniformBuffers","_needToBindSceneUbo","lightsEnabled","BindLights","bindView","BindFogParameters","bind","_afterBind","update","hasTexture","texture","dispose","forceDisposeEffect","forceDisposeTextures","clone","Clone","serializationObject","customType","getClassName","Parse","source","rootUrl","__decorate"],"sources":["../../../../../dev/core/src/Materials/Background/backgroundMaterial.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport {\r\n    SerializationHelper,\r\n    serialize,\r\n    serializeAsColor3,\r\n    expandToProperty,\r\n    serializeAsTexture,\r\n    serializeAsVector3,\r\n    serializeAsImageProcessingConfiguration,\r\n} from \"../../Misc/decorators\";\r\nimport { SmartArray } from \"../../Misc/smartArray\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable, int, float } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3, Vector4 } from \"../../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { IEffectCreationOptions } from \"../../Materials/effect\";\r\nimport { MaterialHelper } from \"../../Materials/materialHelper\";\r\nimport { MaterialDefines } from \"../../Materials/materialDefines\";\r\nimport { PushMaterial } from \"../../Materials/pushMaterial\";\r\nimport type { ColorCurves } from \"../../Materials/colorCurves\";\r\nimport type { IImageProcessingConfigurationDefines } from \"../../Materials/imageProcessingConfiguration\";\r\nimport { ImageProcessingConfiguration } from \"../../Materials/imageProcessingConfiguration\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport type { IShadowLight } from \"../../Lights/shadowLight\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { RegisterClass } from \"../../Misc/typeStore\";\r\nimport { MaterialFlags } from \"../materialFlags\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\n\r\nimport \"../../Shaders/background.fragment\";\r\nimport \"../../Shaders/background.vertex\";\r\nimport { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"../clipPlaneMaterialHelper\";\r\n\r\n/**\r\n * Background material defines definition.\r\n * @internal Mainly internal Use\r\n */\r\nclass BackgroundMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines {\r\n    /**\r\n     * True if the diffuse texture is in use.\r\n     */\r\n    public DIFFUSE = false;\r\n\r\n    /**\r\n     * The direct UV channel to use.\r\n     */\r\n    public DIFFUSEDIRECTUV = 0;\r\n\r\n    /**\r\n     * True if the diffuse texture is in gamma space.\r\n     */\r\n    public GAMMADIFFUSE = false;\r\n\r\n    /**\r\n     * True if the diffuse texture has opacity in the alpha channel.\r\n     */\r\n    public DIFFUSEHASALPHA = false;\r\n\r\n    /**\r\n     * True if you want the material to fade to transparent at grazing angle.\r\n     */\r\n    public OPACITYFRESNEL = false;\r\n\r\n    /**\r\n     * True if an extra blur needs to be added in the reflection.\r\n     */\r\n    public REFLECTIONBLUR = false;\r\n\r\n    /**\r\n     * True if you want the material to fade to reflection at grazing angle.\r\n     */\r\n    public REFLECTIONFRESNEL = false;\r\n\r\n    /**\r\n     * True if you want the material to falloff as far as you move away from the scene center.\r\n     */\r\n    public REFLECTIONFALLOFF = false;\r\n\r\n    /**\r\n     * False if the current Webgl implementation does not support the texture lod extension.\r\n     */\r\n    public TEXTURELODSUPPORT = false;\r\n\r\n    /**\r\n     * True to ensure the data are premultiplied.\r\n     */\r\n    public PREMULTIPLYALPHA = false;\r\n\r\n    /**\r\n     * True if the texture contains cooked RGB values and not gray scaled multipliers.\r\n     */\r\n    public USERGBCOLOR = false;\r\n\r\n    /**\r\n     * True if highlight and shadow levels have been specified. It can help ensuring the main perceived color\r\n     * stays aligned with the desired configuration.\r\n     */\r\n    public USEHIGHLIGHTANDSHADOWCOLORS = false;\r\n\r\n    /**\r\n     * True if only shadows must be rendered\r\n     */\r\n    public BACKMAT_SHADOWONLY = false;\r\n\r\n    /**\r\n     * True to add noise in order to reduce the banding effect.\r\n     */\r\n    public NOISE = false;\r\n\r\n    /**\r\n     * is the reflection texture in BGR color scheme?\r\n     * Mainly used to solve a bug in ios10 video tag\r\n     */\r\n    public REFLECTIONBGR = false;\r\n\r\n    public IMAGEPROCESSING = false;\r\n    public VIGNETTE = false;\r\n    public VIGNETTEBLENDMODEMULTIPLY = false;\r\n    public VIGNETTEBLENDMODEOPAQUE = false;\r\n    public TONEMAPPING = false;\r\n    public TONEMAPPING_ACES = false;\r\n    public CONTRAST = false;\r\n    public COLORCURVES = false;\r\n    public COLORGRADING = false;\r\n    public COLORGRADING3D = false;\r\n    public SAMPLER3DGREENDEPTH = false;\r\n    public SAMPLER3DBGRMAP = false;\r\n    public DITHER = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public EXPOSURE = false;\r\n    public MULTIVIEW = false;\r\n\r\n    // Reflection.\r\n    public REFLECTION = false;\r\n    public REFLECTIONMAP_3D = false;\r\n    public REFLECTIONMAP_SPHERICAL = false;\r\n    public REFLECTIONMAP_PLANAR = false;\r\n    public REFLECTIONMAP_CUBIC = false;\r\n    public REFLECTIONMAP_PROJECTION = false;\r\n    public REFLECTIONMAP_SKYBOX = false;\r\n    public REFLECTIONMAP_EXPLICIT = false;\r\n    public REFLECTIONMAP_EQUIRECTANGULAR = false;\r\n    public REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\r\n    public REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\r\n    public INVERTCUBICMAP = false;\r\n    public REFLECTIONMAP_OPPOSITEZ = false;\r\n    public LODINREFLECTIONALPHA = false;\r\n    public GAMMAREFLECTION = false;\r\n    public RGBDREFLECTION = false;\r\n    public EQUIRECTANGULAR_RELFECTION_FOV = false;\r\n\r\n    // Default BJS.\r\n    public MAINUV1 = false;\r\n    public MAINUV2 = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public SHADOWFLOAT = false;\r\n    public LOGARITHMICDEPTH = false;\r\n    public NONUNIFORMSCALING = false;\r\n    public ALPHATEST = false;\r\n\r\n    /**\r\n     * Constructor of the defines.\r\n     */\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\n/**\r\n * Background material used to create an efficient environment around your scene.\r\n */\r\nexport class BackgroundMaterial extends PushMaterial {\r\n    /**\r\n     * Standard reflectance value at parallel view angle.\r\n     */\r\n    public static StandardReflectance0 = 0.05;\r\n\r\n    /**\r\n     * Standard reflectance value at grazing angle.\r\n     */\r\n    public static StandardReflectance90 = 0.5;\r\n\r\n    @serializeAsColor3()\r\n    protected _primaryColor: Color3;\r\n    /**\r\n     * Key light Color (multiply against the environment texture)\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public primaryColor = Color3.White();\r\n\r\n    @serializeAsColor3()\r\n    protected __perceptualColor: Nullable<Color3>;\r\n    /**\r\n     * Experimental Internal Use Only.\r\n     *\r\n     * Key light Color in \"perceptual value\" meaning the color you would like to see on screen.\r\n     * This acts as a helper to set the primary color to a more \"human friendly\" value.\r\n     * Conversion to linear space as well as exposure and tone mapping correction will be applied to keep the\r\n     * output color as close as possible from the chosen value.\r\n     * (This does not account for contrast color grading and color curves as they are considered post effect and not directly\r\n     * part of lighting setup.)\r\n     */\r\n    public get _perceptualColor(): Nullable<Color3> {\r\n        return this.__perceptualColor;\r\n    }\r\n    public set _perceptualColor(value: Nullable<Color3>) {\r\n        this.__perceptualColor = value;\r\n        this._computePrimaryColorFromPerceptualColor();\r\n        this._markAllSubMeshesAsLightsDirty();\r\n    }\r\n\r\n    @serialize()\r\n    protected _primaryColorShadowLevel: float = 0;\r\n    /**\r\n     * Defines the level of the shadows (dark area of the reflection map) in order to help scaling the colors.\r\n     * The color opposite to the primary color is used at the level chosen to define what the black area would look.\r\n     */\r\n    public get primaryColorShadowLevel(): float {\r\n        return this._primaryColorShadowLevel;\r\n    }\r\n    public set primaryColorShadowLevel(value: float) {\r\n        this._primaryColorShadowLevel = value;\r\n        this._computePrimaryColors();\r\n        this._markAllSubMeshesAsLightsDirty();\r\n    }\r\n\r\n    @serialize()\r\n    protected _primaryColorHighlightLevel: float = 0;\r\n    /**\r\n     * Defines the level of the highlights (highlight area of the reflection map) in order to help scaling the colors.\r\n     * The primary color is used at the level chosen to define what the white area would look.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public get primaryColorHighlightLevel(): float {\r\n        return this._primaryColorHighlightLevel;\r\n    }\r\n    public set primaryColorHighlightLevel(value: float) {\r\n        this._primaryColorHighlightLevel = value;\r\n        this._computePrimaryColors();\r\n        this._markAllSubMeshesAsLightsDirty();\r\n    }\r\n\r\n    @serializeAsTexture()\r\n    protected _reflectionTexture: Nullable<BaseTexture>;\r\n    /**\r\n     * Reflection Texture used in the material.\r\n     * Should be author in a specific way for the best result (refer to the documentation).\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectionTexture: Nullable<BaseTexture> = null;\r\n\r\n    @serialize()\r\n    protected _reflectionBlur: float;\r\n    /**\r\n     * Reflection Texture level of blur.\r\n     *\r\n     * Can be use to reuse an existing HDR Texture and target a specific LOD to prevent authoring the\r\n     * texture twice.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectionBlur: float = 0;\r\n\r\n    @serializeAsTexture()\r\n    protected _diffuseTexture: Nullable<BaseTexture>;\r\n    /**\r\n     * Diffuse Texture used in the material.\r\n     * Should be author in a specific way for the best result (refer to the documentation).\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture: Nullable<BaseTexture> = null;\r\n\r\n    protected _shadowLights: Nullable<IShadowLight[]> = null;\r\n    /**\r\n     * Specify the list of lights casting shadow on the material.\r\n     * All scene shadow lights will be included if null.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public shadowLights: Nullable<IShadowLight[]> = null;\r\n\r\n    @serialize()\r\n    protected _shadowLevel: float;\r\n    /**\r\n     * Helps adjusting the shadow to a softer level if required.\r\n     * 0 means black shadows and 1 means no shadows.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public shadowLevel: float = 0;\r\n\r\n    @serializeAsVector3()\r\n    protected _sceneCenter: Vector3;\r\n    /**\r\n     * In case of opacity Fresnel or reflection falloff, this is use as a scene center.\r\n     * It is usually zero but might be interesting to modify according to your setup.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public sceneCenter: Vector3 = Vector3.Zero();\r\n\r\n    @serialize()\r\n    protected _opacityFresnel: boolean;\r\n    /**\r\n     * This helps specifying that the material is falling off to the sky box at grazing angle.\r\n     * This helps ensuring a nice transition when the camera goes under the ground.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public opacityFresnel: boolean = true;\r\n\r\n    @serialize()\r\n    protected _reflectionFresnel: boolean;\r\n    /**\r\n     * This helps specifying that the material is falling off from diffuse to the reflection texture at grazing angle.\r\n     * This helps adding a mirror texture on the ground.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectionFresnel: boolean = false;\r\n\r\n    @serialize()\r\n    protected _reflectionFalloffDistance: number;\r\n    /**\r\n     * This helps specifying the falloff radius off the reflection texture from the sceneCenter.\r\n     * This helps adding a nice falloff effect to the reflection if used as a mirror for instance.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectionFalloffDistance: number = 0.0;\r\n\r\n    @serialize()\r\n    protected _reflectionAmount: number;\r\n    /**\r\n     * This specifies the weight of the reflection against the background in case of reflection Fresnel.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectionAmount: number = 1.0;\r\n\r\n    @serialize()\r\n    protected _reflectionReflectance0: number;\r\n    /**\r\n     * This specifies the weight of the reflection at grazing angle.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectionReflectance0: number = 0.05;\r\n\r\n    @serialize()\r\n    protected _reflectionReflectance90: number;\r\n    /**\r\n     * This specifies the weight of the reflection at a perpendicular point of view.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectionReflectance90: number = 0.5;\r\n\r\n    /**\r\n     * Sets the reflection reflectance fresnel values according to the default standard\r\n     * empirically know to work well :-)\r\n     */\r\n    public set reflectionStandardFresnelWeight(value: number) {\r\n        let reflectionWeight = value;\r\n\r\n        if (reflectionWeight < 0.5) {\r\n            reflectionWeight = reflectionWeight * 2.0;\r\n            this.reflectionReflectance0 = BackgroundMaterial.StandardReflectance0 * reflectionWeight;\r\n            this.reflectionReflectance90 = BackgroundMaterial.StandardReflectance90 * reflectionWeight;\r\n        } else {\r\n            reflectionWeight = reflectionWeight * 2.0 - 1.0;\r\n            this.reflectionReflectance0 = BackgroundMaterial.StandardReflectance0 + (1.0 - BackgroundMaterial.StandardReflectance0) * reflectionWeight;\r\n            this.reflectionReflectance90 = BackgroundMaterial.StandardReflectance90 + (1.0 - BackgroundMaterial.StandardReflectance90) * reflectionWeight;\r\n        }\r\n    }\r\n\r\n    @serialize()\r\n    protected _useRGBColor: boolean;\r\n    /**\r\n     * Helps to directly use the maps channels instead of their level.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useRGBColor: boolean = true;\r\n\r\n    @serialize()\r\n    protected _enableNoise: boolean;\r\n    /**\r\n     * This helps reducing the banding effect that could occur on the background.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public enableNoise: boolean = false;\r\n\r\n    /**\r\n     * The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values \"zoom in\" and higher values \"zoom out\".\r\n     * Best used when trying to implement visual zoom effects like fish-eye or binoculars while not adjusting camera fov.\r\n     * Recommended to be keep at 1.0 except for special cases.\r\n     */\r\n    public get fovMultiplier(): number {\r\n        return this._fovMultiplier;\r\n    }\r\n    public set fovMultiplier(value: number) {\r\n        if (isNaN(value)) {\r\n            value = 1.0;\r\n        }\r\n        this._fovMultiplier = Math.max(0.0, Math.min(2.0, value));\r\n    }\r\n    private _fovMultiplier: float = 1.0;\r\n\r\n    /**\r\n     * Enable the FOV adjustment feature controlled by fovMultiplier.\r\n     */\r\n    public useEquirectangularFOV: boolean = false;\r\n\r\n    @serialize()\r\n    private _maxSimultaneousLights: int = 4;\r\n    /**\r\n     * Number of Simultaneous lights allowed on the material.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public maxSimultaneousLights: int = 4;\r\n\r\n    @serialize()\r\n    private _shadowOnly: boolean = false;\r\n    /**\r\n     * Make the material only render shadows\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public shadowOnly: boolean = false;\r\n\r\n    /**\r\n     * Default configuration related to image processing available in the Background Material.\r\n     */\r\n    @serializeAsImageProcessingConfiguration()\r\n    protected _imageProcessingConfiguration: ImageProcessingConfiguration;\r\n\r\n    /**\r\n     * Keep track of the image processing observer to allow dispose and replace.\r\n     */\r\n    private _imageProcessingObserver: Nullable<Observer<ImageProcessingConfiguration>> = null;\r\n\r\n    /**\r\n     * Attaches a new image processing configuration to the PBR Material.\r\n     * @param configuration (if null the scene configuration will be use)\r\n     */\r\n    protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void {\r\n        if (configuration === this._imageProcessingConfiguration) {\r\n            return;\r\n        }\r\n\r\n        // Detaches observer.\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        // Pick the scene configuration if needed.\r\n        if (!configuration) {\r\n            this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\r\n        } else {\r\n            this._imageProcessingConfiguration = configuration;\r\n        }\r\n\r\n        // Attaches observer.\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\r\n                this._computePrimaryColorFromPerceptualColor();\r\n                this._markAllSubMeshesAsImageProcessingDirty();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\r\n    public get imageProcessingConfiguration(): Nullable<ImageProcessingConfiguration> {\r\n        return this._imageProcessingConfiguration;\r\n    }\r\n\r\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\r\n    public set imageProcessingConfiguration(value: Nullable<ImageProcessingConfiguration>) {\r\n        this._attachImageProcessingConfiguration(value);\r\n\r\n        // Ensure the effect will be rebuilt.\r\n        this._markAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets whether the color curves effect is enabled.\r\n     */\r\n    public get cameraColorCurvesEnabled(): boolean {\r\n        return (<ImageProcessingConfiguration>this.imageProcessingConfiguration).colorCurvesEnabled;\r\n    }\r\n    /**\r\n     * Sets whether the color curves effect is enabled.\r\n     */\r\n    public set cameraColorCurvesEnabled(value: boolean) {\r\n        (<ImageProcessingConfiguration>this.imageProcessingConfiguration).colorCurvesEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the color grading effect is enabled.\r\n     */\r\n    public get cameraColorGradingEnabled(): boolean {\r\n        return (<ImageProcessingConfiguration>this.imageProcessingConfiguration).colorGradingEnabled;\r\n    }\r\n    /**\r\n     * Gets whether the color grading effect is enabled.\r\n     */\r\n    public set cameraColorGradingEnabled(value: boolean) {\r\n        (<ImageProcessingConfiguration>this.imageProcessingConfiguration).colorGradingEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether tonemapping is enabled or not.\r\n     */\r\n    public get cameraToneMappingEnabled(): boolean {\r\n        return this._imageProcessingConfiguration.toneMappingEnabled;\r\n    }\r\n    /**\r\n     * Sets whether tonemapping is enabled or not\r\n     */\r\n    public set cameraToneMappingEnabled(value: boolean) {\r\n        this._imageProcessingConfiguration.toneMappingEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * The camera exposure used on this material.\r\n     * This property is here and not in the camera to allow controlling exposure without full screen post process.\r\n     * This corresponds to a photographic exposure.\r\n     */\r\n    public get cameraExposure(): float {\r\n        return this._imageProcessingConfiguration.exposure;\r\n    }\r\n    /**\r\n     * The camera exposure used on this material.\r\n     * This property is here and not in the camera to allow controlling exposure without full screen post process.\r\n     * This corresponds to a photographic exposure.\r\n     */\r\n    public set cameraExposure(value: float) {\r\n        this._imageProcessingConfiguration.exposure = value;\r\n    }\r\n\r\n    /**\r\n     * Gets The camera contrast used on this material.\r\n     */\r\n    public get cameraContrast(): float {\r\n        return this._imageProcessingConfiguration.contrast;\r\n    }\r\n\r\n    /**\r\n     * Sets The camera contrast used on this material.\r\n     */\r\n    public set cameraContrast(value: float) {\r\n        this._imageProcessingConfiguration.contrast = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the Color Grading 2D Lookup Texture.\r\n     */\r\n    public get cameraColorGradingTexture(): Nullable<BaseTexture> {\r\n        return this._imageProcessingConfiguration.colorGradingTexture;\r\n    }\r\n    /**\r\n     * Sets the Color Grading 2D Lookup Texture.\r\n     */\r\n    public set cameraColorGradingTexture(value: Nullable<BaseTexture>) {\r\n        (<ImageProcessingConfiguration>this.imageProcessingConfiguration).colorGradingTexture = value;\r\n    }\r\n\r\n    /**\r\n     * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).\r\n     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\r\n     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\r\n     * corresponding to low luminance, medium luminance, and high luminance areas respectively.\r\n     */\r\n    public get cameraColorCurves(): Nullable<ColorCurves> {\r\n        return (<ImageProcessingConfiguration>this.imageProcessingConfiguration).colorCurves;\r\n    }\r\n    /**\r\n     * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).\r\n     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\r\n     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\r\n     * corresponding to low luminance, medium luminance, and high luminance areas respectively.\r\n     */\r\n    public set cameraColorCurves(value: Nullable<ColorCurves>) {\r\n        (<ImageProcessingConfiguration>this.imageProcessingConfiguration).colorCurves = value;\r\n    }\r\n\r\n    /**\r\n     * Due to a bug in iOS10, video tags (which are using the background material) are in BGR and not RGB.\r\n     * Setting this flag to true (not done automatically!) will convert it back to RGB.\r\n     */\r\n    public switchToBGR: boolean = false;\r\n\r\n    // Temp values kept as cache in the material.\r\n    private _renderTargets = new SmartArray<RenderTargetTexture>(16);\r\n    private _reflectionControls = Vector4.Zero();\r\n    private _white = Color3.White();\r\n    private _primaryShadowColor = Color3.Black();\r\n    private _primaryHighlightColor = Color3.Black();\r\n\r\n    /**\r\n     * Instantiates a Background Material in the given scene\r\n     * @param name The friendly name of the material\r\n     * @param scene The scene to add the material to\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n\r\n        // Setup the default processing configuration to the scene.\r\n        this._attachImageProcessingConfiguration(null);\r\n\r\n        this.getRenderTargetTextures = (): SmartArray<RenderTargetTexture> => {\r\n            this._renderTargets.reset();\r\n\r\n            if (this._diffuseTexture && this._diffuseTexture.isRenderTarget) {\r\n                this._renderTargets.push(this._diffuseTexture as RenderTargetTexture);\r\n            }\r\n\r\n            if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\r\n                this._renderTargets.push(this._reflectionTexture as RenderTargetTexture);\r\n            }\r\n\r\n            return this._renderTargets;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\r\n    public get hasRenderTargetTextures(): boolean {\r\n        if (this._diffuseTexture && this._diffuseTexture.isRenderTarget) {\r\n            return true;\r\n        }\r\n\r\n        if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * The entire material has been created in order to prevent overdraw.\r\n     * @returns false\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * The entire material has been created in order to prevent overdraw.\r\n     * @returns true if blending is enable\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1 || (this._diffuseTexture != null && this._diffuseTexture.hasAlpha) || this._shadowOnly;\r\n    }\r\n\r\n    /**\r\n     * Checks whether the material is ready to be rendered for a given mesh.\r\n     * @param mesh The mesh to render\r\n     * @param subMesh The submesh to check against\r\n     * @param useInstances Specify wether or not the material is used with instances\r\n     * @returns true if all the dependencies are ready (Textures, Effects...)\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances: boolean = false): boolean {\r\n        if (subMesh.effect && this.isFrozen) {\r\n            if (subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new BackgroundMaterialDefines();\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const defines = <BackgroundMaterialDefines>subMesh.materialDefines;\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Lights\r\n        MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights);\r\n        defines._needNormals = true;\r\n\r\n        // Multiview\r\n        MaterialHelper.PrepareDefinesForMultiview(scene, defines);\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (scene.getEngine().getCaps().textureLOD) {\r\n                    defines.TEXTURELODSUPPORT = true;\r\n                }\r\n\r\n                if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (!this._diffuseTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n\r\n                    MaterialHelper.PrepareDefinesForMergedUV(this._diffuseTexture, defines, \"DIFFUSE\");\r\n                    defines.DIFFUSEHASALPHA = this._diffuseTexture.hasAlpha;\r\n                    defines.GAMMADIFFUSE = this._diffuseTexture.gammaSpace;\r\n                    defines.OPACITYFRESNEL = this._opacityFresnel;\r\n                } else {\r\n                    defines.DIFFUSE = false;\r\n                    defines.DIFFUSEDIRECTUV = 0;\r\n                    defines.DIFFUSEHASALPHA = false;\r\n                    defines.GAMMADIFFUSE = false;\r\n                    defines.OPACITYFRESNEL = false;\r\n                }\r\n\r\n                const reflectionTexture = this._reflectionTexture;\r\n                if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n                    if (!reflectionTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n\r\n                    defines.REFLECTION = true;\r\n                    defines.GAMMAREFLECTION = reflectionTexture.gammaSpace;\r\n                    defines.RGBDREFLECTION = reflectionTexture.isRGBD;\r\n                    defines.REFLECTIONBLUR = this._reflectionBlur > 0;\r\n                    defines.LODINREFLECTIONALPHA = reflectionTexture.lodLevelInAlpha;\r\n                    defines.EQUIRECTANGULAR_RELFECTION_FOV = this.useEquirectangularFOV;\r\n                    defines.REFLECTIONBGR = this.switchToBGR;\r\n\r\n                    if (reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE) {\r\n                        defines.INVERTCUBICMAP = true;\r\n                    }\r\n\r\n                    defines.REFLECTIONMAP_3D = reflectionTexture.isCube;\r\n                    defines.REFLECTIONMAP_OPPOSITEZ = defines.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ;\r\n\r\n                    switch (reflectionTexture.coordinatesMode) {\r\n                        case Texture.EXPLICIT_MODE:\r\n                            defines.REFLECTIONMAP_EXPLICIT = true;\r\n                            break;\r\n                        case Texture.PLANAR_MODE:\r\n                            defines.REFLECTIONMAP_PLANAR = true;\r\n                            break;\r\n                        case Texture.PROJECTION_MODE:\r\n                            defines.REFLECTIONMAP_PROJECTION = true;\r\n                            break;\r\n                        case Texture.SKYBOX_MODE:\r\n                            defines.REFLECTIONMAP_SKYBOX = true;\r\n                            break;\r\n                        case Texture.SPHERICAL_MODE:\r\n                            defines.REFLECTIONMAP_SPHERICAL = true;\r\n                            break;\r\n                        case Texture.EQUIRECTANGULAR_MODE:\r\n                            defines.REFLECTIONMAP_EQUIRECTANGULAR = true;\r\n                            break;\r\n                        case Texture.FIXED_EQUIRECTANGULAR_MODE:\r\n                            defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = true;\r\n                            break;\r\n                        case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:\r\n                            defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = true;\r\n                            break;\r\n                        case Texture.CUBIC_MODE:\r\n                        case Texture.INVCUBIC_MODE:\r\n                        default:\r\n                            defines.REFLECTIONMAP_CUBIC = true;\r\n                            break;\r\n                    }\r\n\r\n                    if (this.reflectionFresnel) {\r\n                        defines.REFLECTIONFRESNEL = true;\r\n                        defines.REFLECTIONFALLOFF = this.reflectionFalloffDistance > 0;\r\n\r\n                        this._reflectionControls.x = this.reflectionAmount;\r\n                        this._reflectionControls.y = this.reflectionReflectance0;\r\n                        this._reflectionControls.z = this.reflectionReflectance90;\r\n                        this._reflectionControls.w = 1 / this.reflectionFalloffDistance;\r\n                    } else {\r\n                        defines.REFLECTIONFRESNEL = false;\r\n                        defines.REFLECTIONFALLOFF = false;\r\n                    }\r\n                } else {\r\n                    defines.REFLECTION = false;\r\n                    defines.REFLECTIONFRESNEL = false;\r\n                    defines.REFLECTIONFALLOFF = false;\r\n                    defines.REFLECTIONBLUR = false;\r\n                    defines.REFLECTIONMAP_3D = false;\r\n                    defines.REFLECTIONMAP_SPHERICAL = false;\r\n                    defines.REFLECTIONMAP_PLANAR = false;\r\n                    defines.REFLECTIONMAP_CUBIC = false;\r\n                    defines.REFLECTIONMAP_PROJECTION = false;\r\n                    defines.REFLECTIONMAP_SKYBOX = false;\r\n                    defines.REFLECTIONMAP_EXPLICIT = false;\r\n                    defines.REFLECTIONMAP_EQUIRECTANGULAR = false;\r\n                    defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\r\n                    defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\r\n                    defines.INVERTCUBICMAP = false;\r\n                    defines.REFLECTIONMAP_OPPOSITEZ = false;\r\n                    defines.LODINREFLECTIONALPHA = false;\r\n                    defines.GAMMAREFLECTION = false;\r\n                    defines.RGBDREFLECTION = false;\r\n                }\r\n            }\r\n\r\n            defines.PREMULTIPLYALPHA = this.alphaMode === Constants.ALPHA_PREMULTIPLIED || this.alphaMode === Constants.ALPHA_PREMULTIPLIED_PORTERDUFF;\r\n            defines.USERGBCOLOR = this._useRGBColor;\r\n            defines.NOISE = this._enableNoise;\r\n        }\r\n\r\n        if (defines._areLightsDirty) {\r\n            defines.USEHIGHLIGHTANDSHADOWCOLORS = !this._useRGBColor && (this._primaryColorShadowLevel !== 0 || this._primaryColorHighlightLevel !== 0);\r\n            defines.BACKMAT_SHADOWONLY = this._shadowOnly;\r\n        }\r\n\r\n        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\r\n            if (!this._imageProcessingConfiguration.isReady()) {\r\n                return false;\r\n            }\r\n\r\n            this._imageProcessingConfiguration.prepareDefines(defines);\r\n        }\r\n\r\n        // Misc.\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);\r\n\r\n        // Attribs\r\n        if (MaterialHelper.PrepareDefinesForAttributes(mesh, defines, false, true, false)) {\r\n            if (mesh) {\r\n                if (!scene.getEngine().getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n                    mesh.createNormals(true);\r\n                    Logger.Warn(\"BackgroundMaterial: Normals have been created for the mesh: \" + mesh.name);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(0, \"FOG\");\r\n            }\r\n\r\n            if (defines.POINTSIZE) {\r\n                fallbacks.addFallback(1, \"POINTSIZE\");\r\n            }\r\n\r\n            if (defines.MULTIVIEW) {\r\n                fallbacks.addFallback(0, \"MULTIVIEW\");\r\n            }\r\n\r\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights);\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"mBones\",\r\n\r\n                \"vPrimaryColor\",\r\n                \"vPrimaryColorShadow\",\r\n                \"vReflectionInfos\",\r\n                \"reflectionMatrix\",\r\n                \"vReflectionMicrosurfaceInfos\",\r\n                \"fFovMultiplier\",\r\n\r\n                \"shadowLevel\",\r\n                \"alpha\",\r\n\r\n                \"vBackgroundCenter\",\r\n                \"vReflectionControl\",\r\n\r\n                \"vDiffuseInfos\",\r\n                \"diffuseMatrix\",\r\n            ];\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n            const samplers = [\"diffuseSampler\", \"reflectionSampler\", \"reflectionSamplerLow\", \"reflectionSamplerHigh\"];\r\n            const uniformBuffers = [\"Material\", \"Scene\"];\r\n\r\n            if (ImageProcessingConfiguration) {\r\n                ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);\r\n                ImageProcessingConfiguration.PrepareSamplers(samplers, defines);\r\n            }\r\n\r\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this._maxSimultaneousLights,\r\n            });\r\n\r\n            const join = defines.toString();\r\n            const effect = scene.getEngine().createEffect(\r\n                \"background\",\r\n                <IEffectCreationOptions>{\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: uniformBuffers,\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    fallbacks: fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights },\r\n                },\r\n                engine\r\n            );\r\n            subMesh.setEffect(effect, defines, this._materialContext);\r\n\r\n            this.buildUniformLayout();\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n        subMesh.effect._wasPreviouslyUsingInstances = useInstances;\r\n\r\n        this._checkScenePerformancePriority();\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Compute the primary color according to the chosen perceptual color.\r\n     */\r\n    private _computePrimaryColorFromPerceptualColor(): void {\r\n        if (!this.__perceptualColor) {\r\n            return;\r\n        }\r\n\r\n        this._primaryColor.copyFrom(this.__perceptualColor);\r\n\r\n        // Revert gamma space.\r\n        this._primaryColor.toLinearSpaceToRef(this._primaryColor, this.getScene().getEngine().useExactSrgbConversions);\r\n\r\n        // Revert image processing configuration.\r\n        if (this._imageProcessingConfiguration) {\r\n            // Revert Exposure.\r\n            this._primaryColor.scaleToRef(1 / this._imageProcessingConfiguration.exposure, this._primaryColor);\r\n        }\r\n\r\n        this._computePrimaryColors();\r\n    }\r\n\r\n    /**\r\n     * Compute the highlights and shadow colors according to their chosen levels.\r\n     */\r\n    private _computePrimaryColors(): void {\r\n        if (this._primaryColorShadowLevel === 0 && this._primaryColorHighlightLevel === 0) {\r\n            return;\r\n        }\r\n\r\n        // Find the highlight color based on the configuration.\r\n        this._primaryColor.scaleToRef(this._primaryColorShadowLevel, this._primaryShadowColor);\r\n        this._primaryColor.subtractToRef(this._primaryShadowColor, this._primaryShadowColor);\r\n\r\n        // Find the shadow color based on the configuration.\r\n        this._white.subtractToRef(this._primaryColor, this._primaryHighlightColor);\r\n        this._primaryHighlightColor.scaleToRef(this._primaryColorHighlightLevel, this._primaryHighlightColor);\r\n        this._primaryColor.addToRef(this._primaryHighlightColor, this._primaryHighlightColor);\r\n    }\r\n\r\n    /**\r\n     * Build the uniform buffer used in the material.\r\n     */\r\n    public buildUniformLayout(): void {\r\n        // Order is important !\r\n        this._uniformBuffer.addUniform(\"vPrimaryColor\", 4);\r\n        this._uniformBuffer.addUniform(\"vPrimaryColorShadow\", 4);\r\n        this._uniformBuffer.addUniform(\"vDiffuseInfos\", 2);\r\n        this._uniformBuffer.addUniform(\"vReflectionInfos\", 2);\r\n        this._uniformBuffer.addUniform(\"diffuseMatrix\", 16);\r\n        this._uniformBuffer.addUniform(\"reflectionMatrix\", 16);\r\n        this._uniformBuffer.addUniform(\"vReflectionMicrosurfaceInfos\", 3);\r\n        this._uniformBuffer.addUniform(\"fFovMultiplier\", 1);\r\n        this._uniformBuffer.addUniform(\"pointSize\", 1);\r\n        this._uniformBuffer.addUniform(\"shadowLevel\", 1);\r\n        this._uniformBuffer.addUniform(\"alpha\", 1);\r\n        this._uniformBuffer.addUniform(\"vBackgroundCenter\", 3);\r\n        this._uniformBuffer.addUniform(\"vReflectionControl\", 4);\r\n\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Unbind the material.\r\n     */\r\n    public unbind(): void {\r\n        if (this._diffuseTexture && this._diffuseTexture.isRenderTarget) {\r\n            this._uniformBuffer.setTexture(\"diffuseSampler\", null);\r\n        }\r\n\r\n        if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\r\n            this._uniformBuffer.setTexture(\"reflectionSampler\", null);\r\n        }\r\n\r\n        super.unbind();\r\n    }\r\n\r\n    /**\r\n     * Bind only the world matrix to the material.\r\n     * @param world The world matrix to bind.\r\n     */\r\n    public bindOnlyWorldMatrix(world: Matrix): void {\r\n        this._activeEffect!.setMatrix(\"world\", world);\r\n    }\r\n\r\n    /**\r\n     * Bind the material for a dedicated submeh (every used meshes will be considered opaque).\r\n     * @param world The world matrix to bind.\r\n     * @param mesh\r\n     * @param subMesh The submesh to bind for.\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <BackgroundMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        const mustRebind = this._mustRebind(scene, effect, mesh.visibility);\r\n        if (mustRebind) {\r\n            this._uniformBuffer.bindToEffect(effect, \"Material\");\r\n\r\n            this.bindViewProjection(effect);\r\n\r\n            const reflectionTexture = this._reflectionTexture;\r\n            if (!this._uniformBuffer.useUbo || !this.isFrozen || !this._uniformBuffer.isSync) {\r\n                // Texture uniforms\r\n                if (scene.texturesEnabled) {\r\n                    if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                        this._uniformBuffer.updateFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\r\n                        MaterialHelper.BindTextureMatrix(this._diffuseTexture, this._uniformBuffer, \"diffuse\");\r\n                    }\r\n\r\n                    if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n                        this._uniformBuffer.updateMatrix(\"reflectionMatrix\", reflectionTexture.getReflectionTextureMatrix());\r\n                        this._uniformBuffer.updateFloat2(\"vReflectionInfos\", reflectionTexture.level, this._reflectionBlur);\r\n\r\n                        this._uniformBuffer.updateFloat3(\r\n                            \"vReflectionMicrosurfaceInfos\",\r\n                            reflectionTexture.getSize().width,\r\n                            reflectionTexture.lodGenerationScale,\r\n                            reflectionTexture.lodGenerationOffset\r\n                        );\r\n                    }\r\n                }\r\n\r\n                if (this.shadowLevel > 0) {\r\n                    this._uniformBuffer.updateFloat(\"shadowLevel\", this.shadowLevel);\r\n                }\r\n                this._uniformBuffer.updateFloat(\"alpha\", this.alpha);\r\n\r\n                // Point size\r\n                if (this.pointsCloud) {\r\n                    this._uniformBuffer.updateFloat(\"pointSize\", this.pointSize);\r\n                }\r\n\r\n                if (defines.USEHIGHLIGHTANDSHADOWCOLORS) {\r\n                    this._uniformBuffer.updateColor4(\"vPrimaryColor\", this._primaryHighlightColor, 1.0);\r\n                    this._uniformBuffer.updateColor4(\"vPrimaryColorShadow\", this._primaryShadowColor, 1.0);\r\n                } else {\r\n                    this._uniformBuffer.updateColor4(\"vPrimaryColor\", this._primaryColor, 1.0);\r\n                }\r\n            }\r\n\r\n            this._uniformBuffer.updateFloat(\"fFovMultiplier\", this._fovMultiplier);\r\n\r\n            // Textures\r\n            if (scene.texturesEnabled) {\r\n                if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    this._uniformBuffer.setTexture(\"diffuseSampler\", this._diffuseTexture);\r\n                }\r\n\r\n                if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n                    if (defines.REFLECTIONBLUR && defines.TEXTURELODSUPPORT) {\r\n                        this._uniformBuffer.setTexture(\"reflectionSampler\", reflectionTexture);\r\n                    } else if (!defines.REFLECTIONBLUR) {\r\n                        this._uniformBuffer.setTexture(\"reflectionSampler\", reflectionTexture);\r\n                    } else {\r\n                        this._uniformBuffer.setTexture(\"reflectionSampler\", reflectionTexture._lodTextureMid || reflectionTexture);\r\n                        this._uniformBuffer.setTexture(\"reflectionSamplerLow\", reflectionTexture._lodTextureLow || reflectionTexture);\r\n                        this._uniformBuffer.setTexture(\"reflectionSamplerHigh\", reflectionTexture._lodTextureHigh || reflectionTexture);\r\n                    }\r\n\r\n                    if (defines.REFLECTIONFRESNEL) {\r\n                        this._uniformBuffer.updateFloat3(\"vBackgroundCenter\", this.sceneCenter.x, this.sceneCenter.y, this.sceneCenter.z);\r\n                        this._uniformBuffer.updateFloat4(\r\n                            \"vReflectionControl\",\r\n                            this._reflectionControls.x,\r\n                            this._reflectionControls.y,\r\n                            this._reflectionControls.z,\r\n                            this._reflectionControls.w\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Clip plane\r\n            bindClipPlane(this._activeEffect, this, scene);\r\n\r\n            scene.bindEyePosition(effect);\r\n        } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {\r\n            this._uniformBuffer.bindToEffect(effect, \"Material\");\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n\r\n        if (mustRebind || !this.isFrozen) {\r\n            if (scene.lightsEnabled) {\r\n                MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);\r\n            }\r\n\r\n            // View\r\n            this.bindView(effect);\r\n\r\n            // Fog\r\n            MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect, true);\r\n\r\n            // image processing\r\n            if (this._imageProcessingConfiguration) {\r\n                this._imageProcessingConfiguration.bind(this._activeEffect);\r\n            }\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n\r\n        this._uniformBuffer.update();\r\n    }\r\n\r\n    /**\r\n     * Checks to see if a texture is used in the material.\r\n     * @param texture - Base texture to use.\r\n     * @returns - Boolean specifying if a texture is used in the material.\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this._reflectionTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Dispose the material.\r\n     * @param forceDisposeEffect Force disposal of the associated effect.\r\n     * @param forceDisposeTextures Force disposal of the associated textures.\r\n     */\r\n    public dispose(forceDisposeEffect: boolean = false, forceDisposeTextures: boolean = false): void {\r\n        if (forceDisposeTextures) {\r\n            if (this.diffuseTexture) {\r\n                this.diffuseTexture.dispose();\r\n            }\r\n            if (this.reflectionTexture) {\r\n                this.reflectionTexture.dispose();\r\n            }\r\n        }\r\n\r\n        this._renderTargets.dispose();\r\n\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    /**\r\n     * Clones the material.\r\n     * @param name The cloned name.\r\n     * @returns The cloned material.\r\n     */\r\n    public clone(name: string): BackgroundMaterial {\r\n        return SerializationHelper.Clone(() => new BackgroundMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    /**\r\n     * Serializes the current material to its JSON representation.\r\n     * @returns The JSON representation.\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.BackgroundMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the material\r\n     * @returns \"BackgroundMaterial\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"BackgroundMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Parse a JSON input to create back a background material.\r\n     * @param source The JSON data to parse\r\n     * @param scene The scene to create the parsed material in\r\n     * @param rootUrl The root url of the assets the material depends upon\r\n     * @returns the instantiated BackgroundMaterial.\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): BackgroundMaterial {\r\n        return SerializationHelper.Parse(() => new BackgroundMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.BackgroundMaterial\", BackgroundMaterial);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}