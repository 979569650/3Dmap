{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Quaternion, Matrix, Vector3, Vector2 } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { SubMesh } from \"../Meshes/subMesh.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { VertexData } from \"./mesh.vertexData.js\";\n/**\n * Unique ID when we import meshes from Babylon to CSG\n */\nlet currentCSGMeshId = 0;\n/**\n * Represents a vertex of a polygon. Use your own vertex class instead of this\n * one to provide additional features like texture coordinates and vertex\n * colors. Custom vertex classes need to provide a `pos` property and `clone()`,\n * `flip()`, and `interpolate()` methods that behave analogous to the ones\n * defined by `BABYLON.CSG.Vertex`. This class provides `normal` so convenience\n * functions like `BABYLON.CSG.sphere()` can return a smooth vertex normal, but `normal`\n * is not used anywhere else.\n * Same goes for uv, it allows to keep the original vertex uv coordinates of the 2 meshes\n */\nclass Vertex {\n  /**\n   * Initializes the vertex\n   * @param pos The position of the vertex\n   * @param normal The normal of the vertex\n   * @param uv The texture coordinate of the vertex\n   * @param vertColor The RGBA color of the vertex\n   */\n  constructor(\n  /**\n   * The position of the vertex\n   */\n  pos,\n  /**\n   * The normal of the vertex\n   */\n  normal,\n  /**\n   * The texture coordinate of the vertex\n   */\n  uv,\n  /**\n   * The texture coordinate of the vertex\n   */\n  vertColor) {\n    this.pos = pos;\n    this.normal = normal;\n    this.uv = uv;\n    this.vertColor = vertColor;\n  }\n  /**\n   * Make a clone, or deep copy, of the vertex\n   * @returns A new Vertex\n   */\n  clone() {\n    var _a, _b;\n    return new Vertex(this.pos.clone(), this.normal.clone(), (_a = this.uv) === null || _a === void 0 ? void 0 : _a.clone(), (_b = this.vertColor) === null || _b === void 0 ? void 0 : _b.clone());\n  }\n  /**\n   * Invert all orientation-specific data (e.g. vertex normal). Called when the\n   * orientation of a polygon is flipped.\n   */\n  flip() {\n    this.normal = this.normal.scale(-1);\n  }\n  /**\n   * Create a new vertex between this vertex and `other` by linearly\n   * interpolating all properties using a parameter of `t`. Subclasses should\n   * override this to interpolate additional properties.\n   * @param other the vertex to interpolate against\n   * @param t The factor used to linearly interpolate between the vertices\n   */\n  interpolate(other, t) {\n    return new Vertex(Vector3.Lerp(this.pos, other.pos, t), Vector3.Lerp(this.normal, other.normal, t), this.uv && other.uv ? Vector2.Lerp(this.uv, other.uv, t) : undefined, this.vertColor && other.vertColor ? Color4.Lerp(this.vertColor, other.vertColor, t) : undefined);\n  }\n}\n/**\n * Represents a plane in 3D space.\n */\nclass Plane {\n  /**\n   * Initializes the plane\n   * @param normal The normal for the plane\n   * @param w\n   */\n  constructor(normal, w) {\n    this.normal = normal;\n    this.w = w;\n  }\n  /**\n   * Construct a plane from three points\n   * @param a Point a\n   * @param b Point b\n   * @param c Point c\n   */\n  static FromPoints(a, b, c) {\n    const v0 = c.subtract(a);\n    const v1 = b.subtract(a);\n    if (v0.lengthSquared() === 0 || v1.lengthSquared() === 0) {\n      return null;\n    }\n    const n = Vector3.Normalize(Vector3.Cross(v0, v1));\n    return new Plane(n, Vector3.Dot(n, a));\n  }\n  /**\n   * Clone, or make a deep copy of the plane\n   * @returns a new Plane\n   */\n  clone() {\n    return new Plane(this.normal.clone(), this.w);\n  }\n  /**\n   * Flip the face of the plane\n   */\n  flip() {\n    this.normal.scaleInPlace(-1);\n    this.w = -this.w;\n  }\n  /**\n   * Split `polygon` by this plane if needed, then put the polygon or polygon\n   * fragments in the appropriate lists. Coplanar polygons go into either\n  `* coplanarFront` or `coplanarBack` depending on their orientation with\n   * respect to this plane. Polygons in front or in back of this plane go into\n   * either `front` or `back`\n   * @param polygon The polygon to be split\n   * @param coplanarFront Will contain polygons coplanar with the plane that are oriented to the front of the plane\n   * @param coplanarBack Will contain polygons coplanar with the plane that are oriented to the back of the plane\n   * @param front Will contain the polygons in front of the plane\n   * @param back Will contain the polygons begind the plane\n   */\n  splitPolygon(polygon, coplanarFront, coplanarBack, front, back) {\n    const COPLANAR = 0;\n    const FRONT = 1;\n    const BACK = 2;\n    const SPANNING = 3;\n    // Classify each point as well as the entire polygon into one of the above\n    // four classes.\n    let polygonType = 0;\n    const types = [];\n    let i;\n    let t;\n    for (i = 0; i < polygon.vertices.length; i++) {\n      t = Vector3.Dot(this.normal, polygon.vertices[i].pos) - this.w;\n      const type = t < -Plane.EPSILON ? BACK : t > Plane.EPSILON ? FRONT : COPLANAR;\n      polygonType |= type;\n      types.push(type);\n    }\n    // Put the polygon in the correct list, splitting it when necessary\n    switch (polygonType) {\n      case COPLANAR:\n        (Vector3.Dot(this.normal, polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);\n        break;\n      case FRONT:\n        front.push(polygon);\n        break;\n      case BACK:\n        back.push(polygon);\n        break;\n      case SPANNING:\n        {\n          const f = [],\n            b = [];\n          for (i = 0; i < polygon.vertices.length; i++) {\n            const j = (i + 1) % polygon.vertices.length;\n            const ti = types[i],\n              tj = types[j];\n            const vi = polygon.vertices[i],\n              vj = polygon.vertices[j];\n            if (ti !== BACK) {\n              f.push(vi);\n            }\n            if (ti !== FRONT) {\n              b.push(ti !== BACK ? vi.clone() : vi);\n            }\n            if ((ti | tj) === SPANNING) {\n              t = (this.w - Vector3.Dot(this.normal, vi.pos)) / Vector3.Dot(this.normal, vj.pos.subtract(vi.pos));\n              const v = vi.interpolate(vj, t);\n              f.push(v);\n              b.push(v.clone());\n            }\n          }\n          let poly;\n          if (f.length >= 3) {\n            poly = new Polygon(f, polygon.shared);\n            if (poly.plane) {\n              front.push(poly);\n            }\n          }\n          if (b.length >= 3) {\n            poly = new Polygon(b, polygon.shared);\n            if (poly.plane) {\n              back.push(poly);\n            }\n          }\n          break;\n        }\n    }\n  }\n}\n/**\n * `CSG.Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a\n * point is on the plane\n */\nPlane.EPSILON = 1e-5;\n/**\n * Represents a convex polygon. The vertices used to initialize a polygon must\n * be coplanar and form a convex loop.\n *\n * Each convex polygon has a `shared` property, which is shared between all\n * polygons that are clones of each other or were split from the same polygon.\n * This can be used to define per-polygon properties (such as surface color)\n */\nclass Polygon {\n  /**\n   * Initializes the polygon\n   * @param vertices The vertices of the polygon\n   * @param shared The properties shared across all polygons\n   */\n  constructor(vertices, shared) {\n    this.vertices = vertices;\n    this.shared = shared;\n    this.plane = Plane.FromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);\n  }\n  /**\n   * Clones, or makes a deep copy, or the polygon\n   */\n  clone() {\n    const vertices = this.vertices.map(v => v.clone());\n    return new Polygon(vertices, this.shared);\n  }\n  /**\n   * Flips the faces of the polygon\n   */\n  flip() {\n    this.vertices.reverse().map(v => {\n      v.flip();\n    });\n    this.plane.flip();\n  }\n}\n/**\n * Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\n * by picking a polygon to split along. That polygon (and all other coplanar\n * polygons) are added directly to that node and the other polygons are added to\n * the front and/or back subtrees. This is not a leafy BSP tree since there is\n * no distinction between internal and leaf nodes\n */\nclass Node {\n  /**\n   * Initializes the node\n   * @param polygons A collection of polygons held in the node\n   */\n  constructor(polygons) {\n    this._plane = null;\n    this._front = null;\n    this._back = null;\n    this._polygons = new Array();\n    if (polygons) {\n      this.build(polygons);\n    }\n  }\n  /**\n   * Clones, or makes a deep copy, of the node\n   * @returns The cloned node\n   */\n  clone() {\n    const node = new Node();\n    node._plane = this._plane && this._plane.clone();\n    node._front = this._front && this._front.clone();\n    node._back = this._back && this._back.clone();\n    node._polygons = this._polygons.map(p => p.clone());\n    return node;\n  }\n  /**\n   * Convert solid space to empty space and empty space to solid space\n   */\n  invert() {\n    for (let i = 0; i < this._polygons.length; i++) {\n      this._polygons[i].flip();\n    }\n    if (this._plane) {\n      this._plane.flip();\n    }\n    if (this._front) {\n      this._front.invert();\n    }\n    if (this._back) {\n      this._back.invert();\n    }\n    const temp = this._front;\n    this._front = this._back;\n    this._back = temp;\n  }\n  /**\n   * Recursively remove all polygons in `polygons` that are inside this BSP\n   * tree.\n   * @param polygons Polygons to remove from the BSP\n   * @returns Polygons clipped from the BSP\n   */\n  clipPolygons(polygons) {\n    if (!this._plane) {\n      return polygons.slice();\n    }\n    let front = new Array(),\n      back = new Array();\n    for (let i = 0; i < polygons.length; i++) {\n      this._plane.splitPolygon(polygons[i], front, back, front, back);\n    }\n    if (this._front) {\n      front = this._front.clipPolygons(front);\n    }\n    if (this._back) {\n      back = this._back.clipPolygons(back);\n    } else {\n      back = [];\n    }\n    return front.concat(back);\n  }\n  /**\n   * Remove all polygons in this BSP tree that are inside the other BSP tree\n   * `bsp`.\n   * @param bsp BSP containing polygons to remove from this BSP\n   */\n  clipTo(bsp) {\n    this._polygons = bsp.clipPolygons(this._polygons);\n    if (this._front) {\n      this._front.clipTo(bsp);\n    }\n    if (this._back) {\n      this._back.clipTo(bsp);\n    }\n  }\n  /**\n   * Return a list of all polygons in this BSP tree\n   * @returns List of all polygons in this BSP tree\n   */\n  allPolygons() {\n    let polygons = this._polygons.slice();\n    if (this._front) {\n      polygons = polygons.concat(this._front.allPolygons());\n    }\n    if (this._back) {\n      polygons = polygons.concat(this._back.allPolygons());\n    }\n    return polygons;\n  }\n  /**\n   * Build a BSP tree out of `polygons`. When called on an existing tree, the\n   * new polygons are filtered down to the bottom of the tree and become new\n   * nodes there. Each set of polygons is partitioned using the first polygon\n   * (no heuristic is used to pick a good split)\n   * @param polygons Polygons used to construct the BSP tree\n   */\n  build(polygons) {\n    if (!polygons.length) {\n      return;\n    }\n    if (!this._plane) {\n      this._plane = polygons[0].plane.clone();\n    }\n    const front = new Array(),\n      back = new Array();\n    for (let i = 0; i < polygons.length; i++) {\n      this._plane.splitPolygon(polygons[i], this._polygons, this._polygons, front, back);\n    }\n    if (front.length) {\n      if (!this._front) {\n        this._front = new Node();\n      }\n      this._front.build(front);\n    }\n    if (back.length) {\n      if (!this._back) {\n        this._back = new Node();\n      }\n      this._back.build(back);\n    }\n  }\n}\n/**\n * Class for building Constructive Solid Geometry\n */\nexport class CSG {\n  constructor() {\n    this._polygons = new Array();\n  }\n  /**\n   * Convert a VertexData to CSG\n   * @param mesh defines the VertexData to convert to CSG\n   * @returns the new CSG\n   */\n  static FromVertexData(data) {\n    let vertex, polygon, vertices;\n    const polygons = new Array();\n    const indices = data.indices;\n    const positions = data.positions;\n    const normals = data.normals;\n    const uvs = data.uvs;\n    const vertColors = data.colors;\n    if (!indices || !positions) {\n      throw \"BABYLON.CSG: VertexData must at least contain positions and indices\";\n    }\n    for (let i = 0; i < indices.length; i += 3) {\n      vertices = [];\n      for (let j = 0; j < 3; j++) {\n        const indexIndices = i + j;\n        const offset = indices[indexIndices];\n        const normal = normals ? Vector3.FromArray(normals, offset * 3) : Vector3.Zero();\n        const uv = uvs ? Vector2.FromArray(uvs, offset * 2) : undefined;\n        const vertColor = vertColors ? Color4.FromArray(vertColors, offset * 4) : undefined;\n        const position = Vector3.FromArray(positions, offset * 3);\n        vertex = new Vertex(position, normal, uv, vertColor);\n        vertices.push(vertex);\n      }\n      polygon = new Polygon(vertices, {\n        subMeshId: 0,\n        meshId: currentCSGMeshId,\n        materialIndex: 0\n      });\n      // To handle the case of degenerated triangle\n      // polygon.plane == null <=> the polygon does not represent 1 single plane <=> the triangle is degenerated\n      if (polygon.plane) {\n        polygons.push(polygon);\n      }\n    }\n    const csg = CSG._FromPolygons(polygons);\n    csg.matrix = Matrix.Identity();\n    csg.position = Vector3.Zero();\n    csg.rotation = Vector3.Zero();\n    csg.scaling = Vector3.One();\n    csg.rotationQuaternion = Quaternion.Identity();\n    currentCSGMeshId++;\n    return csg;\n  }\n  /**\n   * Convert the Mesh to CSG\n   * @param mesh The Mesh to convert to CSG\n   * @param absolute If true, the final (local) matrix transformation is set to the identity and not to that of `mesh`. It can help when dealing with right-handed meshes (default: false)\n   * @returns A new CSG from the Mesh\n   */\n  static FromMesh(mesh, absolute = false) {\n    let vertex,\n      normal,\n      uv = undefined,\n      position,\n      vertColor = undefined,\n      polygon,\n      vertices;\n    const polygons = new Array();\n    let matrix,\n      meshPosition,\n      meshRotation,\n      meshRotationQuaternion = null,\n      meshScaling;\n    let invertWinding = false;\n    if (mesh instanceof Mesh) {\n      mesh.computeWorldMatrix(true);\n      matrix = mesh.getWorldMatrix();\n      meshPosition = mesh.position.clone();\n      meshRotation = mesh.rotation.clone();\n      if (mesh.rotationQuaternion) {\n        meshRotationQuaternion = mesh.rotationQuaternion.clone();\n      }\n      meshScaling = mesh.scaling.clone();\n      if (mesh.material && absolute) {\n        invertWinding = mesh.material.sideOrientation === 0;\n      }\n    } else {\n      throw \"BABYLON.CSG: Wrong Mesh type, must be BABYLON.Mesh\";\n    }\n    const indices = mesh.getIndices(),\n      positions = mesh.getVerticesData(VertexBuffer.PositionKind),\n      normals = mesh.getVerticesData(VertexBuffer.NormalKind),\n      uvs = mesh.getVerticesData(VertexBuffer.UVKind),\n      vertColors = mesh.getVerticesData(VertexBuffer.ColorKind);\n    const subMeshes = mesh.subMeshes;\n    for (let sm = 0, sml = subMeshes.length; sm < sml; sm++) {\n      for (let i = subMeshes[sm].indexStart, il = subMeshes[sm].indexCount + subMeshes[sm].indexStart; i < il; i += 3) {\n        vertices = [];\n        for (let j = 0; j < 3; j++) {\n          const indexIndices = j === 0 ? i + j : invertWinding ? i + 3 - j : i + j;\n          const sourceNormal = new Vector3(normals[indices[indexIndices] * 3], normals[indices[indexIndices] * 3 + 1], normals[indices[indexIndices] * 3 + 2]);\n          if (uvs) {\n            uv = new Vector2(uvs[indices[indexIndices] * 2], uvs[indices[indexIndices] * 2 + 1]);\n          }\n          if (vertColors) {\n            vertColor = new Color4(vertColors[indices[indexIndices] * 4], vertColors[indices[indexIndices] * 4 + 1], vertColors[indices[indexIndices] * 4 + 2], vertColors[indices[indexIndices] * 4 + 3]);\n          }\n          const sourcePosition = new Vector3(positions[indices[indexIndices] * 3], positions[indices[indexIndices] * 3 + 1], positions[indices[indexIndices] * 3 + 2]);\n          position = Vector3.TransformCoordinates(sourcePosition, matrix);\n          normal = Vector3.TransformNormal(sourceNormal, matrix);\n          vertex = new Vertex(position, normal, uv, vertColor);\n          vertices.push(vertex);\n        }\n        polygon = new Polygon(vertices, {\n          subMeshId: sm,\n          meshId: currentCSGMeshId,\n          materialIndex: subMeshes[sm].materialIndex\n        });\n        // To handle the case of degenerated triangle\n        // polygon.plane == null <=> the polygon does not represent 1 single plane <=> the triangle is degenerated\n        if (polygon.plane) {\n          polygons.push(polygon);\n        }\n      }\n    }\n    const csg = CSG._FromPolygons(polygons);\n    csg.matrix = absolute ? Matrix.Identity() : matrix;\n    csg.position = absolute ? Vector3.Zero() : meshPosition;\n    csg.rotation = absolute ? Vector3.Zero() : meshRotation;\n    csg.scaling = absolute ? Vector3.One() : meshScaling;\n    csg.rotationQuaternion = absolute && meshRotationQuaternion ? Quaternion.Identity() : meshRotationQuaternion;\n    currentCSGMeshId++;\n    return csg;\n  }\n  /**\n   * Construct a CSG solid from a list of `CSG.Polygon` instances.\n   * @param polygons Polygons used to construct a CSG solid\n   */\n  static _FromPolygons(polygons) {\n    const csg = new CSG();\n    csg._polygons = polygons;\n    return csg;\n  }\n  /**\n   * Clones, or makes a deep copy, of the CSG\n   * @returns A new CSG\n   */\n  clone() {\n    const csg = new CSG();\n    csg._polygons = this._polygons.map(p => p.clone());\n    csg.copyTransformAttributes(this);\n    return csg;\n  }\n  /**\n   * Unions this CSG with another CSG\n   * @param csg The CSG to union against this CSG\n   * @returns The unioned CSG\n   */\n  union(csg) {\n    const a = new Node(this.clone()._polygons);\n    const b = new Node(csg.clone()._polygons);\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\n  }\n  /**\n   * Unions this CSG with another CSG in place\n   * @param csg The CSG to union against this CSG\n   */\n  unionInPlace(csg) {\n    const a = new Node(this._polygons);\n    const b = new Node(csg._polygons);\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    this._polygons = a.allPolygons();\n  }\n  /**\n   * Subtracts this CSG with another CSG\n   * @param csg The CSG to subtract against this CSG\n   * @returns A new CSG\n   */\n  subtract(csg) {\n    const a = new Node(this.clone()._polygons);\n    const b = new Node(csg.clone()._polygons);\n    a.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    a.invert();\n    return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\n  }\n  /**\n   * Subtracts this CSG with another CSG in place\n   * @param csg The CSG to subtract against this CSG\n   */\n  subtractInPlace(csg) {\n    const a = new Node(this._polygons);\n    const b = new Node(csg._polygons);\n    a.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    a.invert();\n    this._polygons = a.allPolygons();\n  }\n  /**\n   * Intersect this CSG with another CSG\n   * @param csg The CSG to intersect against this CSG\n   * @returns A new CSG\n   */\n  intersect(csg) {\n    const a = new Node(this.clone()._polygons);\n    const b = new Node(csg.clone()._polygons);\n    a.invert();\n    b.clipTo(a);\n    b.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    a.build(b.allPolygons());\n    a.invert();\n    return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\n  }\n  /**\n   * Intersects this CSG with another CSG in place\n   * @param csg The CSG to intersect against this CSG\n   */\n  intersectInPlace(csg) {\n    const a = new Node(this._polygons);\n    const b = new Node(csg._polygons);\n    a.invert();\n    b.clipTo(a);\n    b.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    a.build(b.allPolygons());\n    a.invert();\n    this._polygons = a.allPolygons();\n  }\n  /**\n   * Return a new CSG solid with solid and empty space switched. This solid is\n   * not modified.\n   * @returns A new CSG solid with solid and empty space switched\n   */\n  inverse() {\n    const csg = this.clone();\n    csg.inverseInPlace();\n    return csg;\n  }\n  /**\n   * Inverses the CSG in place\n   */\n  inverseInPlace() {\n    this._polygons.map(p => {\n      p.flip();\n    });\n  }\n  /**\n   * This is used to keep meshes transformations so they can be restored\n   * when we build back a Babylon Mesh\n   * NB : All CSG operations are performed in world coordinates\n   * @param csg The CSG to copy the transform attributes from\n   * @returns This CSG\n   */\n  copyTransformAttributes(csg) {\n    this.matrix = csg.matrix;\n    this.position = csg.position;\n    this.rotation = csg.rotation;\n    this.scaling = csg.scaling;\n    this.rotationQuaternion = csg.rotationQuaternion;\n    return this;\n  }\n  /**\n   * Build vertex data from CSG\n   * Coordinates here are in world space\n   * @returns the final vertex data\n   */\n  toVertexData(onBeforePolygonProcessing = null, onAfterPolygonProcessing = null) {\n    const matrix = this.matrix.clone();\n    matrix.invert();\n    const polygons = this._polygons;\n    const vertices = [];\n    const indices = [];\n    const normals = [];\n    let uvs = null;\n    let vertColors = null;\n    const vertex = Vector3.Zero();\n    const normal = Vector3.Zero();\n    const uv = Vector2.Zero();\n    const vertColor = new Color4(0, 0, 0, 0);\n    const polygonIndices = [0, 0, 0];\n    const vertice_dict = {};\n    let vertex_idx;\n    for (let i = 0, il = polygons.length; i < il; i++) {\n      const polygon = polygons[i];\n      if (onBeforePolygonProcessing) {\n        onBeforePolygonProcessing(polygon);\n      }\n      for (let j = 2, jl = polygon.vertices.length; j < jl; j++) {\n        polygonIndices[0] = 0;\n        polygonIndices[1] = j - 1;\n        polygonIndices[2] = j;\n        for (let k = 0; k < 3; k++) {\n          vertex.copyFrom(polygon.vertices[polygonIndices[k]].pos);\n          normal.copyFrom(polygon.vertices[polygonIndices[k]].normal);\n          if (polygon.vertices[polygonIndices[k]].uv) {\n            if (!uvs) {\n              uvs = [];\n            }\n            uv.copyFrom(polygon.vertices[polygonIndices[k]].uv);\n          }\n          if (polygon.vertices[polygonIndices[k]].vertColor) {\n            if (!vertColors) {\n              vertColors = [];\n            }\n            vertColor.copyFrom(polygon.vertices[polygonIndices[k]].vertColor);\n          }\n          const localVertex = Vector3.TransformCoordinates(vertex, matrix);\n          const localNormal = Vector3.TransformNormal(normal, matrix);\n          vertex_idx = vertice_dict[localVertex.x + \",\" + localVertex.y + \",\" + localVertex.z];\n          let areUvsDifferent = false;\n          if (uvs && !(uvs[vertex_idx * 2] === uv.x || uvs[vertex_idx * 2 + 1] === uv.y)) {\n            areUvsDifferent = true;\n          }\n          let areColorsDifferent = false;\n          if (vertColors && !(vertColors[vertex_idx * 4] === vertColor.r || vertColors[vertex_idx * 4 + 1] === vertColor.g || vertColors[vertex_idx * 4 + 2] === vertColor.b || vertColors[vertex_idx * 4 + 3] === vertColor.a)) {\n            areColorsDifferent = true;\n          }\n          // Check if 2 points can be merged\n          if (!(typeof vertex_idx !== \"undefined\" && normals[vertex_idx * 3] === localNormal.x && normals[vertex_idx * 3 + 1] === localNormal.y && normals[vertex_idx * 3 + 2] === localNormal.z) || areUvsDifferent || areColorsDifferent) {\n            vertices.push(localVertex.x, localVertex.y, localVertex.z);\n            if (uvs) {\n              uvs.push(uv.x, uv.y);\n            }\n            normals.push(normal.x, normal.y, normal.z);\n            if (vertColors) {\n              vertColors.push(vertColor.r, vertColor.g, vertColor.b, vertColor.a);\n            }\n            vertex_idx = vertice_dict[localVertex.x + \",\" + localVertex.y + \",\" + localVertex.z] = vertices.length / 3 - 1;\n          }\n          indices.push(vertex_idx);\n          if (onAfterPolygonProcessing) {\n            onAfterPolygonProcessing();\n          }\n        }\n      }\n    }\n    const result = new VertexData();\n    result.positions = vertices;\n    result.normals = normals;\n    if (uvs) {\n      result.uvs = uvs;\n    }\n    if (vertColors) {\n      result.colors = vertColors;\n    }\n    result.indices = indices;\n    return result;\n  }\n  /**\n   * Build Raw mesh from CSG\n   * Coordinates here are in world space\n   * @param name The name of the mesh geometry\n   * @param scene The Scene\n   * @param keepSubMeshes Specifies if the submeshes should be kept\n   * @returns A new Mesh\n   */\n  buildMeshGeometry(name, scene, keepSubMeshes) {\n    const mesh = new Mesh(name, scene);\n    const polygons = this._polygons;\n    let currentIndex = 0;\n    const subMeshDict = {};\n    let subMeshObj;\n    if (keepSubMeshes) {\n      // Sort Polygons, since subMeshes are indices range\n      polygons.sort((a, b) => {\n        if (a.shared.meshId === b.shared.meshId) {\n          return a.shared.subMeshId - b.shared.subMeshId;\n        } else {\n          return a.shared.meshId - b.shared.meshId;\n        }\n      });\n    }\n    const vertexData = this.toVertexData(polygon => {\n      // Building SubMeshes\n      if (!subMeshDict[polygon.shared.meshId]) {\n        subMeshDict[polygon.shared.meshId] = {};\n      }\n      if (!subMeshDict[polygon.shared.meshId][polygon.shared.subMeshId]) {\n        subMeshDict[polygon.shared.meshId][polygon.shared.subMeshId] = {\n          indexStart: +Infinity,\n          indexEnd: -Infinity,\n          materialIndex: polygon.shared.materialIndex\n        };\n      }\n      subMeshObj = subMeshDict[polygon.shared.meshId][polygon.shared.subMeshId];\n    }, () => {\n      subMeshObj.indexStart = Math.min(currentIndex, subMeshObj.indexStart);\n      subMeshObj.indexEnd = Math.max(currentIndex, subMeshObj.indexEnd);\n      currentIndex++;\n    });\n    vertexData.applyToMesh(mesh);\n    if (keepSubMeshes) {\n      // We offset the materialIndex by the previous number of materials in the CSG mixed meshes\n      let materialIndexOffset = 0,\n        materialMaxIndex;\n      mesh.subMeshes = new Array();\n      for (const m in subMeshDict) {\n        materialMaxIndex = -1;\n        for (const sm in subMeshDict[m]) {\n          subMeshObj = subMeshDict[m][sm];\n          SubMesh.CreateFromIndices(subMeshObj.materialIndex + materialIndexOffset, subMeshObj.indexStart, subMeshObj.indexEnd - subMeshObj.indexStart + 1, mesh);\n          materialMaxIndex = Math.max(subMeshObj.materialIndex, materialMaxIndex);\n        }\n        materialIndexOffset += ++materialMaxIndex;\n      }\n    }\n    return mesh;\n  }\n  /**\n   * Build Mesh from CSG taking material and transforms into account\n   * @param name The name of the Mesh\n   * @param material The material of the Mesh\n   * @param scene The Scene\n   * @param keepSubMeshes Specifies if submeshes should be kept\n   * @returns The new Mesh\n   */\n  toMesh(name, material = null, scene, keepSubMeshes) {\n    const mesh = this.buildMeshGeometry(name, scene, keepSubMeshes);\n    mesh.material = material;\n    mesh.position.copyFrom(this.position);\n    mesh.rotation.copyFrom(this.rotation);\n    if (this.rotationQuaternion) {\n      mesh.rotationQuaternion = this.rotationQuaternion.clone();\n    }\n    mesh.scaling.copyFrom(this.scaling);\n    mesh.computeWorldMatrix(true);\n    return mesh;\n  }\n}","map":{"version":3,"names":["Quaternion","Matrix","Vector3","Vector2","VertexBuffer","SubMesh","Mesh","Color4","VertexData","currentCSGMeshId","Vertex","constructor","pos","normal","uv","vertColor","clone","_a","_b","flip","scale","interpolate","other","t","Lerp","undefined","Plane","w","FromPoints","a","b","c","v0","subtract","v1","lengthSquared","n","Normalize","Cross","Dot","scaleInPlace","splitPolygon","polygon","coplanarFront","coplanarBack","front","back","COPLANAR","FRONT","BACK","SPANNING","polygonType","types","i","vertices","length","type","EPSILON","push","plane","f","j","ti","tj","vi","vj","v","poly","Polygon","shared","map","reverse","Node","polygons","_plane","_front","_back","_polygons","Array","build","node","p","invert","temp","clipPolygons","slice","concat","clipTo","bsp","allPolygons","CSG","FromVertexData","data","vertex","indices","positions","normals","uvs","vertColors","colors","indexIndices","offset","FromArray","Zero","position","subMeshId","meshId","materialIndex","csg","_FromPolygons","matrix","Identity","rotation","scaling","One","rotationQuaternion","FromMesh","mesh","absolute","meshPosition","meshRotation","meshRotationQuaternion","meshScaling","invertWinding","computeWorldMatrix","getWorldMatrix","material","sideOrientation","getIndices","getVerticesData","PositionKind","NormalKind","UVKind","ColorKind","subMeshes","sm","sml","indexStart","il","indexCount","sourceNormal","sourcePosition","TransformCoordinates","TransformNormal","copyTransformAttributes","union","unionInPlace","subtractInPlace","intersect","intersectInPlace","inverse","inverseInPlace","toVertexData","onBeforePolygonProcessing","onAfterPolygonProcessing","polygonIndices","vertice_dict","vertex_idx","jl","k","copyFrom","localVertex","localNormal","x","y","z","areUvsDifferent","areColorsDifferent","r","g","result","buildMeshGeometry","name","scene","keepSubMeshes","currentIndex","subMeshDict","subMeshObj","sort","vertexData","Infinity","indexEnd","Math","min","max","applyToMesh","materialIndexOffset","materialMaxIndex","m","CreateFromIndices","toMesh"],"sources":["../../../../dev/core/src/Meshes/csg.ts"],"sourcesContent":["import type { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { VertexData } from \"./mesh.vertexData\";\r\n/**\r\n * Unique ID when we import meshes from Babylon to CSG\r\n */\r\nlet currentCSGMeshId = 0;\r\n\r\n/**\r\n * Represents a vertex of a polygon. Use your own vertex class instead of this\r\n * one to provide additional features like texture coordinates and vertex\r\n * colors. Custom vertex classes need to provide a `pos` property and `clone()`,\r\n * `flip()`, and `interpolate()` methods that behave analogous to the ones\r\n * defined by `BABYLON.CSG.Vertex`. This class provides `normal` so convenience\r\n * functions like `BABYLON.CSG.sphere()` can return a smooth vertex normal, but `normal`\r\n * is not used anywhere else.\r\n * Same goes for uv, it allows to keep the original vertex uv coordinates of the 2 meshes\r\n */\r\nclass Vertex {\r\n    /**\r\n     * Initializes the vertex\r\n     * @param pos The position of the vertex\r\n     * @param normal The normal of the vertex\r\n     * @param uv The texture coordinate of the vertex\r\n     * @param vertColor The RGBA color of the vertex\r\n     */\r\n    constructor(\r\n        /**\r\n         * The position of the vertex\r\n         */\r\n        public pos: Vector3,\r\n        /**\r\n         * The normal of the vertex\r\n         */\r\n        public normal: Vector3,\r\n        /**\r\n         * The texture coordinate of the vertex\r\n         */\r\n        public uv?: Vector2,\r\n        /**\r\n         * The texture coordinate of the vertex\r\n         */\r\n        public vertColor?: Color4\r\n    ) {}\r\n\r\n    /**\r\n     * Make a clone, or deep copy, of the vertex\r\n     * @returns A new Vertex\r\n     */\r\n    public clone(): Vertex {\r\n        return new Vertex(this.pos.clone(), this.normal.clone(), this.uv?.clone(), this.vertColor?.clone());\r\n    }\r\n\r\n    /**\r\n     * Invert all orientation-specific data (e.g. vertex normal). Called when the\r\n     * orientation of a polygon is flipped.\r\n     */\r\n    public flip(): void {\r\n        this.normal = this.normal.scale(-1);\r\n    }\r\n\r\n    /**\r\n     * Create a new vertex between this vertex and `other` by linearly\r\n     * interpolating all properties using a parameter of `t`. Subclasses should\r\n     * override this to interpolate additional properties.\r\n     * @param other the vertex to interpolate against\r\n     * @param t The factor used to linearly interpolate between the vertices\r\n     */\r\n    public interpolate(other: Vertex, t: number): Vertex {\r\n        return new Vertex(\r\n            Vector3.Lerp(this.pos, other.pos, t),\r\n            Vector3.Lerp(this.normal, other.normal, t),\r\n            this.uv && other.uv ? Vector2.Lerp(this.uv, other.uv, t) : undefined,\r\n            this.vertColor && other.vertColor ? Color4.Lerp(this.vertColor, other.vertColor, t) : undefined\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a plane in 3D space.\r\n */\r\nclass Plane {\r\n    /**\r\n     * Initializes the plane\r\n     * @param normal The normal for the plane\r\n     * @param w\r\n     */\r\n    constructor(public normal: Vector3, public w: number) {}\r\n\r\n    /**\r\n     * `CSG.Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a\r\n     * point is on the plane\r\n     */\r\n    static EPSILON = 1e-5;\r\n\r\n    /**\r\n     * Construct a plane from three points\r\n     * @param a Point a\r\n     * @param b Point b\r\n     * @param c Point c\r\n     */\r\n    public static FromPoints(a: Vector3, b: Vector3, c: Vector3): Nullable<Plane> {\r\n        const v0 = c.subtract(a);\r\n        const v1 = b.subtract(a);\r\n\r\n        if (v0.lengthSquared() === 0 || v1.lengthSquared() === 0) {\r\n            return null;\r\n        }\r\n\r\n        const n = Vector3.Normalize(Vector3.Cross(v0, v1));\r\n        return new Plane(n, Vector3.Dot(n, a));\r\n    }\r\n\r\n    /**\r\n     * Clone, or make a deep copy of the plane\r\n     * @returns a new Plane\r\n     */\r\n    public clone(): Plane {\r\n        return new Plane(this.normal.clone(), this.w);\r\n    }\r\n\r\n    /**\r\n     * Flip the face of the plane\r\n     */\r\n    public flip() {\r\n        this.normal.scaleInPlace(-1);\r\n        this.w = -this.w;\r\n    }\r\n\r\n    /**\r\n     * Split `polygon` by this plane if needed, then put the polygon or polygon\r\n     * fragments in the appropriate lists. Coplanar polygons go into either\r\n    `* coplanarFront` or `coplanarBack` depending on their orientation with\r\n     * respect to this plane. Polygons in front or in back of this plane go into\r\n     * either `front` or `back`\r\n     * @param polygon The polygon to be split\r\n     * @param coplanarFront Will contain polygons coplanar with the plane that are oriented to the front of the plane\r\n     * @param coplanarBack Will contain polygons coplanar with the plane that are oriented to the back of the plane\r\n     * @param front Will contain the polygons in front of the plane\r\n     * @param back Will contain the polygons begind the plane\r\n     */\r\n    public splitPolygon(polygon: Polygon, coplanarFront: Polygon[], coplanarBack: Polygon[], front: Polygon[], back: Polygon[]): void {\r\n        const COPLANAR = 0;\r\n        const FRONT = 1;\r\n        const BACK = 2;\r\n        const SPANNING = 3;\r\n\r\n        // Classify each point as well as the entire polygon into one of the above\r\n        // four classes.\r\n        let polygonType = 0;\r\n        const types = [];\r\n        let i: number;\r\n        let t: number;\r\n        for (i = 0; i < polygon.vertices.length; i++) {\r\n            t = Vector3.Dot(this.normal, polygon.vertices[i].pos) - this.w;\r\n            const type = t < -Plane.EPSILON ? BACK : t > Plane.EPSILON ? FRONT : COPLANAR;\r\n            polygonType |= type;\r\n            types.push(type);\r\n        }\r\n\r\n        // Put the polygon in the correct list, splitting it when necessary\r\n        switch (polygonType) {\r\n            case COPLANAR:\r\n                (Vector3.Dot(this.normal, polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);\r\n                break;\r\n            case FRONT:\r\n                front.push(polygon);\r\n                break;\r\n            case BACK:\r\n                back.push(polygon);\r\n                break;\r\n            case SPANNING: {\r\n                const f = [],\r\n                    b = [];\r\n                for (i = 0; i < polygon.vertices.length; i++) {\r\n                    const j = (i + 1) % polygon.vertices.length;\r\n                    const ti = types[i],\r\n                        tj = types[j];\r\n                    const vi = polygon.vertices[i],\r\n                        vj = polygon.vertices[j];\r\n                    if (ti !== BACK) {\r\n                        f.push(vi);\r\n                    }\r\n                    if (ti !== FRONT) {\r\n                        b.push(ti !== BACK ? vi.clone() : vi);\r\n                    }\r\n                    if ((ti | tj) === SPANNING) {\r\n                        t = (this.w - Vector3.Dot(this.normal, vi.pos)) / Vector3.Dot(this.normal, vj.pos.subtract(vi.pos));\r\n                        const v = vi.interpolate(vj, t);\r\n                        f.push(v);\r\n                        b.push(v.clone());\r\n                    }\r\n                }\r\n                let poly: Polygon;\r\n                if (f.length >= 3) {\r\n                    poly = new Polygon(f, polygon.shared);\r\n                    if (poly.plane) {\r\n                        front.push(poly);\r\n                    }\r\n                }\r\n\r\n                if (b.length >= 3) {\r\n                    poly = new Polygon(b, polygon.shared);\r\n\r\n                    if (poly.plane) {\r\n                        back.push(poly);\r\n                    }\r\n                }\r\n\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a convex polygon. The vertices used to initialize a polygon must\r\n * be coplanar and form a convex loop.\r\n *\r\n * Each convex polygon has a `shared` property, which is shared between all\r\n * polygons that are clones of each other or were split from the same polygon.\r\n * This can be used to define per-polygon properties (such as surface color)\r\n */\r\nclass Polygon {\r\n    /**\r\n     * Vertices of the polygon\r\n     */\r\n    public vertices: Vertex[];\r\n    /**\r\n     * Properties that are shared across all polygons\r\n     */\r\n    public shared: any;\r\n    /**\r\n     * A plane formed from the vertices of the polygon\r\n     */\r\n    public plane: Plane;\r\n\r\n    /**\r\n     * Initializes the polygon\r\n     * @param vertices The vertices of the polygon\r\n     * @param shared The properties shared across all polygons\r\n     */\r\n    constructor(vertices: Vertex[], shared: any) {\r\n        this.vertices = vertices;\r\n        this.shared = shared;\r\n        this.plane = <Plane>Plane.FromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);\r\n    }\r\n\r\n    /**\r\n     * Clones, or makes a deep copy, or the polygon\r\n     */\r\n    public clone(): Polygon {\r\n        const vertices = this.vertices.map((v) => v.clone());\r\n        return new Polygon(vertices, this.shared);\r\n    }\r\n\r\n    /**\r\n     * Flips the faces of the polygon\r\n     */\r\n    public flip() {\r\n        this.vertices.reverse().map((v) => {\r\n            v.flip();\r\n        });\r\n        this.plane.flip();\r\n    }\r\n}\r\n\r\n/**\r\n * Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\r\n * by picking a polygon to split along. That polygon (and all other coplanar\r\n * polygons) are added directly to that node and the other polygons are added to\r\n * the front and/or back subtrees. This is not a leafy BSP tree since there is\r\n * no distinction between internal and leaf nodes\r\n */\r\nclass Node {\r\n    private _plane: Nullable<Plane> = null;\r\n    private _front: Nullable<Node> = null;\r\n    private _back: Nullable<Node> = null;\r\n    private _polygons = new Array<Polygon>();\r\n\r\n    /**\r\n     * Initializes the node\r\n     * @param polygons A collection of polygons held in the node\r\n     */\r\n    constructor(polygons?: Array<Polygon>) {\r\n        if (polygons) {\r\n            this.build(polygons);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones, or makes a deep copy, of the node\r\n     * @returns The cloned node\r\n     */\r\n    public clone(): Node {\r\n        const node = new Node();\r\n        node._plane = this._plane && this._plane.clone();\r\n        node._front = this._front && this._front.clone();\r\n        node._back = this._back && this._back.clone();\r\n        node._polygons = this._polygons.map((p) => p.clone());\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * Convert solid space to empty space and empty space to solid space\r\n     */\r\n    public invert(): void {\r\n        for (let i = 0; i < this._polygons.length; i++) {\r\n            this._polygons[i].flip();\r\n        }\r\n        if (this._plane) {\r\n            this._plane.flip();\r\n        }\r\n        if (this._front) {\r\n            this._front.invert();\r\n        }\r\n        if (this._back) {\r\n            this._back.invert();\r\n        }\r\n        const temp = this._front;\r\n        this._front = this._back;\r\n        this._back = temp;\r\n    }\r\n\r\n    /**\r\n     * Recursively remove all polygons in `polygons` that are inside this BSP\r\n     * tree.\r\n     * @param polygons Polygons to remove from the BSP\r\n     * @returns Polygons clipped from the BSP\r\n     */\r\n    clipPolygons(polygons: Polygon[]): Polygon[] {\r\n        if (!this._plane) {\r\n            return polygons.slice();\r\n        }\r\n        let front = new Array<Polygon>(),\r\n            back = new Array<Polygon>();\r\n        for (let i = 0; i < polygons.length; i++) {\r\n            this._plane.splitPolygon(polygons[i], front, back, front, back);\r\n        }\r\n        if (this._front) {\r\n            front = this._front.clipPolygons(front);\r\n        }\r\n        if (this._back) {\r\n            back = this._back.clipPolygons(back);\r\n        } else {\r\n            back = [];\r\n        }\r\n        return front.concat(back);\r\n    }\r\n\r\n    /**\r\n     * Remove all polygons in this BSP tree that are inside the other BSP tree\r\n     * `bsp`.\r\n     * @param bsp BSP containing polygons to remove from this BSP\r\n     */\r\n    clipTo(bsp: Node): void {\r\n        this._polygons = bsp.clipPolygons(this._polygons);\r\n        if (this._front) {\r\n            this._front.clipTo(bsp);\r\n        }\r\n        if (this._back) {\r\n            this._back.clipTo(bsp);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return a list of all polygons in this BSP tree\r\n     * @returns List of all polygons in this BSP tree\r\n     */\r\n    allPolygons(): Polygon[] {\r\n        let polygons = this._polygons.slice();\r\n        if (this._front) {\r\n            polygons = polygons.concat(this._front.allPolygons());\r\n        }\r\n        if (this._back) {\r\n            polygons = polygons.concat(this._back.allPolygons());\r\n        }\r\n        return polygons;\r\n    }\r\n\r\n    /**\r\n     * Build a BSP tree out of `polygons`. When called on an existing tree, the\r\n     * new polygons are filtered down to the bottom of the tree and become new\r\n     * nodes there. Each set of polygons is partitioned using the first polygon\r\n     * (no heuristic is used to pick a good split)\r\n     * @param polygons Polygons used to construct the BSP tree\r\n     */\r\n    build(polygons: Polygon[]): void {\r\n        if (!polygons.length) {\r\n            return;\r\n        }\r\n        if (!this._plane) {\r\n            this._plane = polygons[0].plane.clone();\r\n        }\r\n        const front = new Array<Polygon>(),\r\n            back = new Array<Polygon>();\r\n        for (let i = 0; i < polygons.length; i++) {\r\n            this._plane.splitPolygon(polygons[i], this._polygons, this._polygons, front, back);\r\n        }\r\n        if (front.length) {\r\n            if (!this._front) {\r\n                this._front = new Node();\r\n            }\r\n            this._front.build(front);\r\n        }\r\n        if (back.length) {\r\n            if (!this._back) {\r\n                this._back = new Node();\r\n            }\r\n            this._back.build(back);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Class for building Constructive Solid Geometry\r\n */\r\nexport class CSG {\r\n    private _polygons = new Array<Polygon>();\r\n    /**\r\n     * The world matrix\r\n     */\r\n    public matrix: Matrix;\r\n    /**\r\n     * Stores the position\r\n     */\r\n    public position: Vector3;\r\n    /**\r\n     * Stores the rotation\r\n     */\r\n    public rotation: Vector3;\r\n    /**\r\n     * Stores the rotation quaternion\r\n     */\r\n    public rotationQuaternion: Nullable<Quaternion>;\r\n    /**\r\n     * Stores the scaling vector\r\n     */\r\n    public scaling: Vector3;\r\n\r\n    /**\r\n     * Convert a VertexData to CSG\r\n     * @param mesh defines the VertexData to convert to CSG\r\n     * @returns the new CSG\r\n     */\r\n    public static FromVertexData(data: VertexData): CSG {\r\n        let vertex: Vertex, polygon: Polygon, vertices: Vertex[];\r\n        const polygons = new Array<Polygon>();\r\n\r\n        const indices = data.indices;\r\n        const positions = data.positions;\r\n        const normals = data.normals;\r\n        const uvs = data.uvs;\r\n        const vertColors = data.colors;\r\n\r\n        if (!indices || !positions) {\r\n            throw \"BABYLON.CSG: VertexData must at least contain positions and indices\";\r\n        }\r\n\r\n        for (let i = 0; i < indices.length; i += 3) {\r\n            vertices = [];\r\n            for (let j = 0; j < 3; j++) {\r\n                const indexIndices = i + j;\r\n                const offset = indices[indexIndices];\r\n\r\n                const normal = normals ? Vector3.FromArray(normals, offset * 3) : Vector3.Zero();\r\n                const uv = uvs ? Vector2.FromArray(uvs, offset * 2) : undefined;\r\n                const vertColor = vertColors ? Color4.FromArray(vertColors, offset * 4) : undefined;\r\n\r\n                const position = Vector3.FromArray(positions, offset * 3);\r\n\r\n                vertex = new Vertex(position, normal, uv, vertColor);\r\n                vertices.push(vertex);\r\n            }\r\n\r\n            polygon = new Polygon(vertices, { subMeshId: 0, meshId: currentCSGMeshId, materialIndex: 0 });\r\n\r\n            // To handle the case of degenerated triangle\r\n            // polygon.plane == null <=> the polygon does not represent 1 single plane <=> the triangle is degenerated\r\n            if (polygon.plane) {\r\n                polygons.push(polygon);\r\n            }\r\n        }\r\n\r\n        const csg = CSG._FromPolygons(polygons);\r\n        csg.matrix = Matrix.Identity();\r\n        csg.position = Vector3.Zero();\r\n        csg.rotation = Vector3.Zero();\r\n        csg.scaling = Vector3.One();\r\n        csg.rotationQuaternion = Quaternion.Identity();\r\n        currentCSGMeshId++;\r\n\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Convert the Mesh to CSG\r\n     * @param mesh The Mesh to convert to CSG\r\n     * @param absolute If true, the final (local) matrix transformation is set to the identity and not to that of `mesh`. It can help when dealing with right-handed meshes (default: false)\r\n     * @returns A new CSG from the Mesh\r\n     */\r\n    public static FromMesh(mesh: Mesh, absolute = false): CSG {\r\n        let vertex: Vertex,\r\n            normal: Vector3,\r\n            uv: Vector2 | undefined = undefined,\r\n            position: Vector3,\r\n            vertColor: Color4 | undefined = undefined,\r\n            polygon: Polygon,\r\n            vertices: Vertex[];\r\n        const polygons = new Array<Polygon>();\r\n        let matrix: Matrix,\r\n            meshPosition: Vector3,\r\n            meshRotation: Vector3,\r\n            meshRotationQuaternion: Nullable<Quaternion> = null,\r\n            meshScaling: Vector3;\r\n\r\n        let invertWinding = false;\r\n        if (mesh instanceof Mesh) {\r\n            mesh.computeWorldMatrix(true);\r\n            matrix = mesh.getWorldMatrix();\r\n            meshPosition = mesh.position.clone();\r\n            meshRotation = mesh.rotation.clone();\r\n            if (mesh.rotationQuaternion) {\r\n                meshRotationQuaternion = mesh.rotationQuaternion.clone();\r\n            }\r\n            meshScaling = mesh.scaling.clone();\r\n            if (mesh.material && absolute) {\r\n                invertWinding = mesh.material.sideOrientation === Constants.MATERIAL_ClockWiseSideOrientation;\r\n            }\r\n        } else {\r\n            throw \"BABYLON.CSG: Wrong Mesh type, must be BABYLON.Mesh\";\r\n        }\r\n\r\n        const indices = <IndicesArray>mesh.getIndices(),\r\n            positions = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind),\r\n            normals = <FloatArray>mesh.getVerticesData(VertexBuffer.NormalKind),\r\n            uvs = <FloatArray>mesh.getVerticesData(VertexBuffer.UVKind),\r\n            vertColors = <FloatArray>mesh.getVerticesData(VertexBuffer.ColorKind);\r\n\r\n        const subMeshes = mesh.subMeshes;\r\n\r\n        for (let sm = 0, sml = subMeshes.length; sm < sml; sm++) {\r\n            for (let i = subMeshes[sm].indexStart, il = subMeshes[sm].indexCount + subMeshes[sm].indexStart; i < il; i += 3) {\r\n                vertices = [];\r\n                for (let j = 0; j < 3; j++) {\r\n                    const indexIndices = j === 0 ? i + j : invertWinding ? i + 3 - j : i + j;\r\n                    const sourceNormal = new Vector3(normals[indices[indexIndices] * 3], normals[indices[indexIndices] * 3 + 1], normals[indices[indexIndices] * 3 + 2]);\r\n                    if (uvs) {\r\n                        uv = new Vector2(uvs[indices[indexIndices] * 2], uvs[indices[indexIndices] * 2 + 1]);\r\n                    }\r\n                    if (vertColors) {\r\n                        vertColor = new Color4(\r\n                            vertColors[indices[indexIndices] * 4],\r\n                            vertColors[indices[indexIndices] * 4 + 1],\r\n                            vertColors[indices[indexIndices] * 4 + 2],\r\n                            vertColors[indices[indexIndices] * 4 + 3]\r\n                        );\r\n                    }\r\n                    const sourcePosition = new Vector3(positions[indices[indexIndices] * 3], positions[indices[indexIndices] * 3 + 1], positions[indices[indexIndices] * 3 + 2]);\r\n                    position = Vector3.TransformCoordinates(sourcePosition, matrix);\r\n                    normal = Vector3.TransformNormal(sourceNormal, matrix);\r\n\r\n                    vertex = new Vertex(position, normal, uv, vertColor);\r\n                    vertices.push(vertex);\r\n                }\r\n\r\n                polygon = new Polygon(vertices, { subMeshId: sm, meshId: currentCSGMeshId, materialIndex: subMeshes[sm].materialIndex });\r\n\r\n                // To handle the case of degenerated triangle\r\n                // polygon.plane == null <=> the polygon does not represent 1 single plane <=> the triangle is degenerated\r\n                if (polygon.plane) {\r\n                    polygons.push(polygon);\r\n                }\r\n            }\r\n        }\r\n\r\n        const csg = CSG._FromPolygons(polygons);\r\n        csg.matrix = absolute ? Matrix.Identity() : matrix;\r\n        csg.position = absolute ? Vector3.Zero() : meshPosition;\r\n        csg.rotation = absolute ? Vector3.Zero() : meshRotation;\r\n        csg.scaling = absolute ? Vector3.One() : meshScaling;\r\n        csg.rotationQuaternion = absolute && meshRotationQuaternion ? Quaternion.Identity() : meshRotationQuaternion;\r\n        currentCSGMeshId++;\r\n\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Construct a CSG solid from a list of `CSG.Polygon` instances.\r\n     * @param polygons Polygons used to construct a CSG solid\r\n     */\r\n    private static _FromPolygons(polygons: Polygon[]): CSG {\r\n        const csg = new CSG();\r\n        csg._polygons = polygons;\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Clones, or makes a deep copy, of the CSG\r\n     * @returns A new CSG\r\n     */\r\n    public clone(): CSG {\r\n        const csg = new CSG();\r\n        csg._polygons = this._polygons.map((p) => p.clone());\r\n        csg.copyTransformAttributes(this);\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Unions this CSG with another CSG\r\n     * @param csg The CSG to union against this CSG\r\n     * @returns The unioned CSG\r\n     */\r\n    public union(csg: CSG): CSG {\r\n        const a = new Node(this.clone()._polygons);\r\n        const b = new Node(csg.clone()._polygons);\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\r\n    }\r\n\r\n    /**\r\n     * Unions this CSG with another CSG in place\r\n     * @param csg The CSG to union against this CSG\r\n     */\r\n    public unionInPlace(csg: CSG): void {\r\n        const a = new Node(this._polygons);\r\n        const b = new Node(csg._polygons);\r\n\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n\r\n        this._polygons = a.allPolygons();\r\n    }\r\n\r\n    /**\r\n     * Subtracts this CSG with another CSG\r\n     * @param csg The CSG to subtract against this CSG\r\n     * @returns A new CSG\r\n     */\r\n    public subtract(csg: CSG): CSG {\r\n        const a = new Node(this.clone()._polygons);\r\n        const b = new Node(csg.clone()._polygons);\r\n        a.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n        return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\r\n    }\r\n\r\n    /**\r\n     * Subtracts this CSG with another CSG in place\r\n     * @param csg The CSG to subtract against this CSG\r\n     */\r\n    public subtractInPlace(csg: CSG): void {\r\n        const a = new Node(this._polygons);\r\n        const b = new Node(csg._polygons);\r\n\r\n        a.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n\r\n        this._polygons = a.allPolygons();\r\n    }\r\n\r\n    /**\r\n     * Intersect this CSG with another CSG\r\n     * @param csg The CSG to intersect against this CSG\r\n     * @returns A new CSG\r\n     */\r\n    public intersect(csg: CSG): CSG {\r\n        const a = new Node(this.clone()._polygons);\r\n        const b = new Node(csg.clone()._polygons);\r\n        a.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n        return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\r\n    }\r\n\r\n    /**\r\n     * Intersects this CSG with another CSG in place\r\n     * @param csg The CSG to intersect against this CSG\r\n     */\r\n    public intersectInPlace(csg: CSG): void {\r\n        const a = new Node(this._polygons);\r\n        const b = new Node(csg._polygons);\r\n\r\n        a.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n\r\n        this._polygons = a.allPolygons();\r\n    }\r\n\r\n    /**\r\n     * Return a new CSG solid with solid and empty space switched. This solid is\r\n     * not modified.\r\n     * @returns A new CSG solid with solid and empty space switched\r\n     */\r\n    public inverse(): CSG {\r\n        const csg = this.clone();\r\n        csg.inverseInPlace();\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Inverses the CSG in place\r\n     */\r\n    public inverseInPlace(): void {\r\n        this._polygons.map((p) => {\r\n            p.flip();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * This is used to keep meshes transformations so they can be restored\r\n     * when we build back a Babylon Mesh\r\n     * NB : All CSG operations are performed in world coordinates\r\n     * @param csg The CSG to copy the transform attributes from\r\n     * @returns This CSG\r\n     */\r\n    public copyTransformAttributes(csg: CSG): CSG {\r\n        this.matrix = csg.matrix;\r\n        this.position = csg.position;\r\n        this.rotation = csg.rotation;\r\n        this.scaling = csg.scaling;\r\n        this.rotationQuaternion = csg.rotationQuaternion;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Build vertex data from CSG\r\n     * Coordinates here are in world space\r\n     * @returns the final vertex data\r\n     */\r\n    public toVertexData(onBeforePolygonProcessing: Nullable<(polygon: Polygon) => void> = null, onAfterPolygonProcessing: Nullable<() => void> = null): VertexData {\r\n        const matrix = this.matrix.clone();\r\n        matrix.invert();\r\n\r\n        const polygons = this._polygons;\r\n        const vertices = [];\r\n        const indices = [];\r\n        const normals = [];\r\n        let uvs: Nullable<number[]> = null;\r\n        let vertColors: Nullable<number[]> = null;\r\n        const vertex = Vector3.Zero();\r\n        const normal = Vector3.Zero();\r\n        const uv = Vector2.Zero();\r\n        const vertColor = new Color4(0, 0, 0, 0);\r\n        const polygonIndices = [0, 0, 0];\r\n        const vertice_dict = {};\r\n        let vertex_idx;\r\n\r\n        for (let i = 0, il = polygons.length; i < il; i++) {\r\n            const polygon = polygons[i];\r\n\r\n            if (onBeforePolygonProcessing) {\r\n                onBeforePolygonProcessing(polygon);\r\n            }\r\n\r\n            for (let j = 2, jl = polygon.vertices.length; j < jl; j++) {\r\n                polygonIndices[0] = 0;\r\n                polygonIndices[1] = j - 1;\r\n                polygonIndices[2] = j;\r\n\r\n                for (let k = 0; k < 3; k++) {\r\n                    vertex.copyFrom(polygon.vertices[polygonIndices[k]].pos);\r\n                    normal.copyFrom(polygon.vertices[polygonIndices[k]].normal);\r\n                    if (polygon.vertices[polygonIndices[k]].uv) {\r\n                        if (!uvs) {\r\n                            uvs = [];\r\n                        }\r\n                        uv.copyFrom(polygon.vertices[polygonIndices[k]].uv!);\r\n                    }\r\n\r\n                    if (polygon.vertices[polygonIndices[k]].vertColor) {\r\n                        if (!vertColors) {\r\n                            vertColors = [];\r\n                        }\r\n                        vertColor.copyFrom(polygon.vertices[polygonIndices[k]].vertColor!);\r\n                    }\r\n                    const localVertex = Vector3.TransformCoordinates(vertex, matrix);\r\n                    const localNormal = Vector3.TransformNormal(normal, matrix);\r\n\r\n                    vertex_idx = (<any>vertice_dict)[localVertex.x + \",\" + localVertex.y + \",\" + localVertex.z];\r\n\r\n                    let areUvsDifferent = false;\r\n\r\n                    if (uvs && !(uvs[vertex_idx * 2] === uv.x || uvs[vertex_idx * 2 + 1] === uv.y)) {\r\n                        areUvsDifferent = true;\r\n                    }\r\n\r\n                    let areColorsDifferent = false;\r\n\r\n                    if (\r\n                        vertColors &&\r\n                        !(\r\n                            vertColors[vertex_idx * 4] === vertColor.r ||\r\n                            vertColors[vertex_idx * 4 + 1] === vertColor.g ||\r\n                            vertColors[vertex_idx * 4 + 2] === vertColor.b ||\r\n                            vertColors[vertex_idx * 4 + 3] === vertColor.a\r\n                        )\r\n                    ) {\r\n                        areColorsDifferent = true;\r\n                    }\r\n\r\n                    // Check if 2 points can be merged\r\n                    if (\r\n                        !(\r\n                            typeof vertex_idx !== \"undefined\" &&\r\n                            normals[vertex_idx * 3] === localNormal.x &&\r\n                            normals[vertex_idx * 3 + 1] === localNormal.y &&\r\n                            normals[vertex_idx * 3 + 2] === localNormal.z\r\n                        ) ||\r\n                        areUvsDifferent ||\r\n                        areColorsDifferent\r\n                    ) {\r\n                        vertices.push(localVertex.x, localVertex.y, localVertex.z);\r\n                        if (uvs) {\r\n                            uvs.push(uv.x, uv.y);\r\n                        }\r\n                        normals.push(normal.x, normal.y, normal.z);\r\n                        if (vertColors) {\r\n                            vertColors.push(vertColor.r, vertColor.g, vertColor.b, vertColor.a);\r\n                        }\r\n                        vertex_idx = (<any>vertice_dict)[localVertex.x + \",\" + localVertex.y + \",\" + localVertex.z] = vertices.length / 3 - 1;\r\n                    }\r\n\r\n                    indices.push(vertex_idx);\r\n\r\n                    if (onAfterPolygonProcessing) {\r\n                        onAfterPolygonProcessing();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const result = new VertexData();\r\n        result.positions = vertices;\r\n        result.normals = normals;\r\n        if (uvs) {\r\n            result.uvs = uvs;\r\n        }\r\n        if (vertColors) {\r\n            result.colors = vertColors;\r\n        }\r\n        result.indices = indices;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Build Raw mesh from CSG\r\n     * Coordinates here are in world space\r\n     * @param name The name of the mesh geometry\r\n     * @param scene The Scene\r\n     * @param keepSubMeshes Specifies if the submeshes should be kept\r\n     * @returns A new Mesh\r\n     */\r\n    public buildMeshGeometry(name: string, scene?: Scene, keepSubMeshes?: boolean): Mesh {\r\n        const mesh = new Mesh(name, scene);\r\n        const polygons = this._polygons;\r\n        let currentIndex = 0;\r\n        const subMeshDict = {};\r\n        let subMeshObj: {\r\n            materialIndex: number;\r\n            indexStart: number;\r\n            indexEnd: number;\r\n        };\r\n\r\n        if (keepSubMeshes) {\r\n            // Sort Polygons, since subMeshes are indices range\r\n            polygons.sort((a, b) => {\r\n                if (a.shared.meshId === b.shared.meshId) {\r\n                    return a.shared.subMeshId - b.shared.subMeshId;\r\n                } else {\r\n                    return a.shared.meshId - b.shared.meshId;\r\n                }\r\n            });\r\n        }\r\n\r\n        const vertexData = this.toVertexData(\r\n            (polygon) => {\r\n                // Building SubMeshes\r\n                if (!(<any>subMeshDict)[polygon.shared.meshId]) {\r\n                    (<any>subMeshDict)[polygon.shared.meshId] = {};\r\n                }\r\n                if (!(<any>subMeshDict)[polygon.shared.meshId][polygon.shared.subMeshId]) {\r\n                    (<any>subMeshDict)[polygon.shared.meshId][polygon.shared.subMeshId] = {\r\n                        indexStart: +Infinity,\r\n                        indexEnd: -Infinity,\r\n                        materialIndex: polygon.shared.materialIndex,\r\n                    };\r\n                }\r\n                subMeshObj = (<any>subMeshDict)[polygon.shared.meshId][polygon.shared.subMeshId];\r\n            },\r\n            () => {\r\n                subMeshObj.indexStart = Math.min(currentIndex, subMeshObj.indexStart);\r\n                subMeshObj.indexEnd = Math.max(currentIndex, subMeshObj.indexEnd);\r\n                currentIndex++;\r\n            }\r\n        );\r\n\r\n        vertexData.applyToMesh(mesh);\r\n\r\n        if (keepSubMeshes) {\r\n            // We offset the materialIndex by the previous number of materials in the CSG mixed meshes\r\n            let materialIndexOffset = 0,\r\n                materialMaxIndex;\r\n\r\n            mesh.subMeshes = new Array<SubMesh>();\r\n\r\n            for (const m in subMeshDict) {\r\n                materialMaxIndex = -1;\r\n                for (const sm in (<any>subMeshDict)[m]) {\r\n                    subMeshObj = (<any>subMeshDict)[m][sm];\r\n                    SubMesh.CreateFromIndices(\r\n                        subMeshObj.materialIndex + materialIndexOffset,\r\n                        subMeshObj.indexStart,\r\n                        subMeshObj.indexEnd - subMeshObj.indexStart + 1,\r\n                        <AbstractMesh>mesh\r\n                    );\r\n                    materialMaxIndex = Math.max(subMeshObj.materialIndex, materialMaxIndex);\r\n                }\r\n                materialIndexOffset += ++materialMaxIndex;\r\n            }\r\n        }\r\n\r\n        return mesh;\r\n    }\r\n\r\n    /**\r\n     * Build Mesh from CSG taking material and transforms into account\r\n     * @param name The name of the Mesh\r\n     * @param material The material of the Mesh\r\n     * @param scene The Scene\r\n     * @param keepSubMeshes Specifies if submeshes should be kept\r\n     * @returns The new Mesh\r\n     */\r\n    public toMesh(name: string, material: Nullable<Material> = null, scene?: Scene, keepSubMeshes?: boolean): Mesh {\r\n        const mesh = this.buildMeshGeometry(name, scene, keepSubMeshes);\r\n\r\n        mesh.material = material;\r\n\r\n        mesh.position.copyFrom(this.position);\r\n        mesh.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            mesh.rotationQuaternion = this.rotationQuaternion.clone();\r\n        }\r\n        mesh.scaling.copyFrom(this.scaling);\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        return mesh;\r\n    }\r\n}\r\n"],"mappings":";AAEA,SAASA,UAAU,EAAEC,MAAM,EAAEC,OAAO,EAAEC,OAAO,QAAQ,yBAAuB;AAC5E,SAASC,YAAY,QAAQ,sBAAoB;AAEjD,SAASC,OAAO,QAAQ,sBAAoB;AAC5C,SAASC,IAAI,QAAQ,mBAAiB;AAEtC,SAASC,MAAM,QAAQ,wBAAsB;AAE7C,SAASC,UAAU,QAAQ,sBAAoB;AAC/C;;;AAGA,IAAIC,gBAAgB,GAAG,CAAC;AAExB;;;;;;;;;;AAUA,MAAMC,MAAM;EACR;;;;;;;EAOAC;EACI;;;EAGOC,GAAY;EACnB;;;EAGOC,MAAe;EACtB;;;EAGOC,EAAY;EACnB;;;EAGOC,SAAkB;IAZlB,KAAAH,GAAG,GAAHA,GAAG;IAIH,KAAAC,MAAM,GAANA,MAAM;IAIN,KAAAC,EAAE,GAAFA,EAAE;IAIF,KAAAC,SAAS,GAATA,SAAS;EACjB;EAEH;;;;EAIOC,KAAKA,CAAA;;IACR,OAAO,IAAIN,MAAM,CAAC,IAAI,CAACE,GAAG,CAACI,KAAK,EAAE,EAAE,IAAI,CAACH,MAAM,CAACG,KAAK,EAAE,EAAE,CAAAC,EAAA,OAAI,CAACH,EAAE,cAAAG,EAAA,uBAAAA,EAAA,CAAED,KAAK,EAAE,EAAE,CAAAE,EAAA,OAAI,CAACH,SAAS,cAAAG,EAAA,uBAAAA,EAAA,CAAEF,KAAK,EAAE,CAAC;EACvG;EAEA;;;;EAIOG,IAAIA,CAAA;IACP,IAAI,CAACN,MAAM,GAAG,IAAI,CAACA,MAAM,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC;EACvC;EAEA;;;;;;;EAOOC,WAAWA,CAACC,KAAa,EAAEC,CAAS;IACvC,OAAO,IAAIb,MAAM,CACbR,OAAO,CAACsB,IAAI,CAAC,IAAI,CAACZ,GAAG,EAAEU,KAAK,CAACV,GAAG,EAAEW,CAAC,CAAC,EACpCrB,OAAO,CAACsB,IAAI,CAAC,IAAI,CAACX,MAAM,EAAES,KAAK,CAACT,MAAM,EAAEU,CAAC,CAAC,EAC1C,IAAI,CAACT,EAAE,IAAIQ,KAAK,CAACR,EAAE,GAAGX,OAAO,CAACqB,IAAI,CAAC,IAAI,CAACV,EAAE,EAAEQ,KAAK,CAACR,EAAE,EAAES,CAAC,CAAC,GAAGE,SAAS,EACpE,IAAI,CAACV,SAAS,IAAIO,KAAK,CAACP,SAAS,GAAGR,MAAM,CAACiB,IAAI,CAAC,IAAI,CAACT,SAAS,EAAEO,KAAK,CAACP,SAAS,EAAEQ,CAAC,CAAC,GAAGE,SAAS,CAClG;EACL;;AAGJ;;;AAGA,MAAMC,KAAK;EACP;;;;;EAKAf,YAAmBE,MAAe,EAASc,CAAS;IAAjC,KAAAd,MAAM,GAANA,MAAM;IAAkB,KAAAc,CAAC,GAADA,CAAC;EAAW;EAQvD;;;;;;EAMO,OAAOC,UAAUA,CAACC,CAAU,EAAEC,CAAU,EAAEC,CAAU;IACvD,MAAMC,EAAE,GAAGD,CAAC,CAACE,QAAQ,CAACJ,CAAC,CAAC;IACxB,MAAMK,EAAE,GAAGJ,CAAC,CAACG,QAAQ,CAACJ,CAAC,CAAC;IAExB,IAAIG,EAAE,CAACG,aAAa,EAAE,KAAK,CAAC,IAAID,EAAE,CAACC,aAAa,EAAE,KAAK,CAAC,EAAE;MACtD,OAAO,IAAI;;IAGf,MAAMC,CAAC,GAAGlC,OAAO,CAACmC,SAAS,CAACnC,OAAO,CAACoC,KAAK,CAACN,EAAE,EAAEE,EAAE,CAAC,CAAC;IAClD,OAAO,IAAIR,KAAK,CAACU,CAAC,EAAElC,OAAO,CAACqC,GAAG,CAACH,CAAC,EAAEP,CAAC,CAAC,CAAC;EAC1C;EAEA;;;;EAIOb,KAAKA,CAAA;IACR,OAAO,IAAIU,KAAK,CAAC,IAAI,CAACb,MAAM,CAACG,KAAK,EAAE,EAAE,IAAI,CAACW,CAAC,CAAC;EACjD;EAEA;;;EAGOR,IAAIA,CAAA;IACP,IAAI,CAACN,MAAM,CAAC2B,YAAY,CAAC,CAAC,CAAC,CAAC;IAC5B,IAAI,CAACb,CAAC,GAAG,CAAC,IAAI,CAACA,CAAC;EACpB;EAEA;;;;;;;;;;;;EAYOc,YAAYA,CAACC,OAAgB,EAAEC,aAAwB,EAAEC,YAAuB,EAAEC,KAAgB,EAAEC,IAAe;IACtH,MAAMC,QAAQ,GAAG,CAAC;IAClB,MAAMC,KAAK,GAAG,CAAC;IACf,MAAMC,IAAI,GAAG,CAAC;IACd,MAAMC,QAAQ,GAAG,CAAC;IAElB;IACA;IACA,IAAIC,WAAW,GAAG,CAAC;IACnB,MAAMC,KAAK,GAAG,EAAE;IAChB,IAAIC,CAAS;IACb,IAAI9B,CAAS;IACb,KAAK8B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,OAAO,CAACY,QAAQ,CAACC,MAAM,EAAEF,CAAC,EAAE,EAAE;MAC1C9B,CAAC,GAAGrB,OAAO,CAACqC,GAAG,CAAC,IAAI,CAAC1B,MAAM,EAAE6B,OAAO,CAACY,QAAQ,CAACD,CAAC,CAAC,CAACzC,GAAG,CAAC,GAAG,IAAI,CAACe,CAAC;MAC9D,MAAM6B,IAAI,GAAGjC,CAAC,GAAG,CAACG,KAAK,CAAC+B,OAAO,GAAGR,IAAI,GAAG1B,CAAC,GAAGG,KAAK,CAAC+B,OAAO,GAAGT,KAAK,GAAGD,QAAQ;MAC7EI,WAAW,IAAIK,IAAI;MACnBJ,KAAK,CAACM,IAAI,CAACF,IAAI,CAAC;;IAGpB;IACA,QAAQL,WAAW;MACf,KAAKJ,QAAQ;QACT,CAAC7C,OAAO,CAACqC,GAAG,CAAC,IAAI,CAAC1B,MAAM,EAAE6B,OAAO,CAACiB,KAAK,CAAC9C,MAAM,CAAC,GAAG,CAAC,GAAG8B,aAAa,GAAGC,YAAY,EAAEc,IAAI,CAAChB,OAAO,CAAC;QACjG;MACJ,KAAKM,KAAK;QACNH,KAAK,CAACa,IAAI,CAAChB,OAAO,CAAC;QACnB;MACJ,KAAKO,IAAI;QACLH,IAAI,CAACY,IAAI,CAAChB,OAAO,CAAC;QAClB;MACJ,KAAKQ,QAAQ;QAAE;UACX,MAAMU,CAAC,GAAG,EAAE;YACR9B,CAAC,GAAG,EAAE;UACV,KAAKuB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,OAAO,CAACY,QAAQ,CAACC,MAAM,EAAEF,CAAC,EAAE,EAAE;YAC1C,MAAMQ,CAAC,GAAG,CAACR,CAAC,GAAG,CAAC,IAAIX,OAAO,CAACY,QAAQ,CAACC,MAAM;YAC3C,MAAMO,EAAE,GAAGV,KAAK,CAACC,CAAC,CAAC;cACfU,EAAE,GAAGX,KAAK,CAACS,CAAC,CAAC;YACjB,MAAMG,EAAE,GAAGtB,OAAO,CAACY,QAAQ,CAACD,CAAC,CAAC;cAC1BY,EAAE,GAAGvB,OAAO,CAACY,QAAQ,CAACO,CAAC,CAAC;YAC5B,IAAIC,EAAE,KAAKb,IAAI,EAAE;cACbW,CAAC,CAACF,IAAI,CAACM,EAAE,CAAC;;YAEd,IAAIF,EAAE,KAAKd,KAAK,EAAE;cACdlB,CAAC,CAAC4B,IAAI,CAACI,EAAE,KAAKb,IAAI,GAAGe,EAAE,CAAChD,KAAK,EAAE,GAAGgD,EAAE,CAAC;;YAEzC,IAAI,CAACF,EAAE,GAAGC,EAAE,MAAMb,QAAQ,EAAE;cACxB3B,CAAC,GAAG,CAAC,IAAI,CAACI,CAAC,GAAGzB,OAAO,CAACqC,GAAG,CAAC,IAAI,CAAC1B,MAAM,EAAEmD,EAAE,CAACpD,GAAG,CAAC,IAAIV,OAAO,CAACqC,GAAG,CAAC,IAAI,CAAC1B,MAAM,EAAEoD,EAAE,CAACrD,GAAG,CAACqB,QAAQ,CAAC+B,EAAE,CAACpD,GAAG,CAAC,CAAC;cACnG,MAAMsD,CAAC,GAAGF,EAAE,CAAC3C,WAAW,CAAC4C,EAAE,EAAE1C,CAAC,CAAC;cAC/BqC,CAAC,CAACF,IAAI,CAACQ,CAAC,CAAC;cACTpC,CAAC,CAAC4B,IAAI,CAACQ,CAAC,CAAClD,KAAK,EAAE,CAAC;;;UAGzB,IAAImD,IAAa;UACjB,IAAIP,CAAC,CAACL,MAAM,IAAI,CAAC,EAAE;YACfY,IAAI,GAAG,IAAIC,OAAO,CAACR,CAAC,EAAElB,OAAO,CAAC2B,MAAM,CAAC;YACrC,IAAIF,IAAI,CAACR,KAAK,EAAE;cACZd,KAAK,CAACa,IAAI,CAACS,IAAI,CAAC;;;UAIxB,IAAIrC,CAAC,CAACyB,MAAM,IAAI,CAAC,EAAE;YACfY,IAAI,GAAG,IAAIC,OAAO,CAACtC,CAAC,EAAEY,OAAO,CAAC2B,MAAM,CAAC;YAErC,IAAIF,IAAI,CAACR,KAAK,EAAE;cACZb,IAAI,CAACY,IAAI,CAACS,IAAI,CAAC;;;UAIvB;;;EAGZ;;AA3HA;;;;AAIOzC,KAAA,CAAA+B,OAAO,GAAG,IAAI;AA0HzB;;;;;;;;AAQA,MAAMW,OAAO;EAcT;;;;;EAKAzD,YAAY2C,QAAkB,EAAEe,MAAW;IACvC,IAAI,CAACf,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACe,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACV,KAAK,GAAUjC,KAAK,CAACE,UAAU,CAAC0B,QAAQ,CAAC,CAAC,CAAC,CAAC1C,GAAG,EAAE0C,QAAQ,CAAC,CAAC,CAAC,CAAC1C,GAAG,EAAE0C,QAAQ,CAAC,CAAC,CAAC,CAAC1C,GAAG,CAAC;EAC3F;EAEA;;;EAGOI,KAAKA,CAAA;IACR,MAAMsC,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAACgB,GAAG,CAAEJ,CAAC,IAAKA,CAAC,CAAClD,KAAK,EAAE,CAAC;IACpD,OAAO,IAAIoD,OAAO,CAACd,QAAQ,EAAE,IAAI,CAACe,MAAM,CAAC;EAC7C;EAEA;;;EAGOlD,IAAIA,CAAA;IACP,IAAI,CAACmC,QAAQ,CAACiB,OAAO,EAAE,CAACD,GAAG,CAAEJ,CAAC,IAAI;MAC9BA,CAAC,CAAC/C,IAAI,EAAE;IACZ,CAAC,CAAC;IACF,IAAI,CAACwC,KAAK,CAACxC,IAAI,EAAE;EACrB;;AAGJ;;;;;;;AAOA,MAAMqD,IAAI;EAMN;;;;EAIA7D,YAAY8D,QAAyB;IAT7B,KAAAC,MAAM,GAAoB,IAAI;IAC9B,KAAAC,MAAM,GAAmB,IAAI;IAC7B,KAAAC,KAAK,GAAmB,IAAI;IAC5B,KAAAC,SAAS,GAAG,IAAIC,KAAK,EAAW;IAOpC,IAAIL,QAAQ,EAAE;MACV,IAAI,CAACM,KAAK,CAACN,QAAQ,CAAC;;EAE5B;EAEA;;;;EAIOzD,KAAKA,CAAA;IACR,MAAMgE,IAAI,GAAG,IAAIR,IAAI,EAAE;IACvBQ,IAAI,CAACN,MAAM,GAAG,IAAI,CAACA,MAAM,IAAI,IAAI,CAACA,MAAM,CAAC1D,KAAK,EAAE;IAChDgE,IAAI,CAACL,MAAM,GAAG,IAAI,CAACA,MAAM,IAAI,IAAI,CAACA,MAAM,CAAC3D,KAAK,EAAE;IAChDgE,IAAI,CAACJ,KAAK,GAAG,IAAI,CAACA,KAAK,IAAI,IAAI,CAACA,KAAK,CAAC5D,KAAK,EAAE;IAC7CgE,IAAI,CAACH,SAAS,GAAG,IAAI,CAACA,SAAS,CAACP,GAAG,CAAEW,CAAC,IAAKA,CAAC,CAACjE,KAAK,EAAE,CAAC;IACrD,OAAOgE,IAAI;EACf;EAEA;;;EAGOE,MAAMA,CAAA;IACT,KAAK,IAAI7B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACwB,SAAS,CAACtB,MAAM,EAAEF,CAAC,EAAE,EAAE;MAC5C,IAAI,CAACwB,SAAS,CAACxB,CAAC,CAAC,CAAClC,IAAI,EAAE;;IAE5B,IAAI,IAAI,CAACuD,MAAM,EAAE;MACb,IAAI,CAACA,MAAM,CAACvD,IAAI,EAAE;;IAEtB,IAAI,IAAI,CAACwD,MAAM,EAAE;MACb,IAAI,CAACA,MAAM,CAACO,MAAM,EAAE;;IAExB,IAAI,IAAI,CAACN,KAAK,EAAE;MACZ,IAAI,CAACA,KAAK,CAACM,MAAM,EAAE;;IAEvB,MAAMC,IAAI,GAAG,IAAI,CAACR,MAAM;IACxB,IAAI,CAACA,MAAM,GAAG,IAAI,CAACC,KAAK;IACxB,IAAI,CAACA,KAAK,GAAGO,IAAI;EACrB;EAEA;;;;;;EAMAC,YAAYA,CAACX,QAAmB;IAC5B,IAAI,CAAC,IAAI,CAACC,MAAM,EAAE;MACd,OAAOD,QAAQ,CAACY,KAAK,EAAE;;IAE3B,IAAIxC,KAAK,GAAG,IAAIiC,KAAK,EAAW;MAC5BhC,IAAI,GAAG,IAAIgC,KAAK,EAAW;IAC/B,KAAK,IAAIzB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoB,QAAQ,CAAClB,MAAM,EAAEF,CAAC,EAAE,EAAE;MACtC,IAAI,CAACqB,MAAM,CAACjC,YAAY,CAACgC,QAAQ,CAACpB,CAAC,CAAC,EAAER,KAAK,EAAEC,IAAI,EAAED,KAAK,EAAEC,IAAI,CAAC;;IAEnE,IAAI,IAAI,CAAC6B,MAAM,EAAE;MACb9B,KAAK,GAAG,IAAI,CAAC8B,MAAM,CAACS,YAAY,CAACvC,KAAK,CAAC;;IAE3C,IAAI,IAAI,CAAC+B,KAAK,EAAE;MACZ9B,IAAI,GAAG,IAAI,CAAC8B,KAAK,CAACQ,YAAY,CAACtC,IAAI,CAAC;KACvC,MAAM;MACHA,IAAI,GAAG,EAAE;;IAEb,OAAOD,KAAK,CAACyC,MAAM,CAACxC,IAAI,CAAC;EAC7B;EAEA;;;;;EAKAyC,MAAMA,CAACC,GAAS;IACZ,IAAI,CAACX,SAAS,GAAGW,GAAG,CAACJ,YAAY,CAAC,IAAI,CAACP,SAAS,CAAC;IACjD,IAAI,IAAI,CAACF,MAAM,EAAE;MACb,IAAI,CAACA,MAAM,CAACY,MAAM,CAACC,GAAG,CAAC;;IAE3B,IAAI,IAAI,CAACZ,KAAK,EAAE;MACZ,IAAI,CAACA,KAAK,CAACW,MAAM,CAACC,GAAG,CAAC;;EAE9B;EAEA;;;;EAIAC,WAAWA,CAAA;IACP,IAAIhB,QAAQ,GAAG,IAAI,CAACI,SAAS,CAACQ,KAAK,EAAE;IACrC,IAAI,IAAI,CAACV,MAAM,EAAE;MACbF,QAAQ,GAAGA,QAAQ,CAACa,MAAM,CAAC,IAAI,CAACX,MAAM,CAACc,WAAW,EAAE,CAAC;;IAEzD,IAAI,IAAI,CAACb,KAAK,EAAE;MACZH,QAAQ,GAAGA,QAAQ,CAACa,MAAM,CAAC,IAAI,CAACV,KAAK,CAACa,WAAW,EAAE,CAAC;;IAExD,OAAOhB,QAAQ;EACnB;EAEA;;;;;;;EAOAM,KAAKA,CAACN,QAAmB;IACrB,IAAI,CAACA,QAAQ,CAAClB,MAAM,EAAE;MAClB;;IAEJ,IAAI,CAAC,IAAI,CAACmB,MAAM,EAAE;MACd,IAAI,CAACA,MAAM,GAAGD,QAAQ,CAAC,CAAC,CAAC,CAACd,KAAK,CAAC3C,KAAK,EAAE;;IAE3C,MAAM6B,KAAK,GAAG,IAAIiC,KAAK,EAAW;MAC9BhC,IAAI,GAAG,IAAIgC,KAAK,EAAW;IAC/B,KAAK,IAAIzB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoB,QAAQ,CAAClB,MAAM,EAAEF,CAAC,EAAE,EAAE;MACtC,IAAI,CAACqB,MAAM,CAACjC,YAAY,CAACgC,QAAQ,CAACpB,CAAC,CAAC,EAAE,IAAI,CAACwB,SAAS,EAAE,IAAI,CAACA,SAAS,EAAEhC,KAAK,EAAEC,IAAI,CAAC;;IAEtF,IAAID,KAAK,CAACU,MAAM,EAAE;MACd,IAAI,CAAC,IAAI,CAACoB,MAAM,EAAE;QACd,IAAI,CAACA,MAAM,GAAG,IAAIH,IAAI,EAAE;;MAE5B,IAAI,CAACG,MAAM,CAACI,KAAK,CAAClC,KAAK,CAAC;;IAE5B,IAAIC,IAAI,CAACS,MAAM,EAAE;MACb,IAAI,CAAC,IAAI,CAACqB,KAAK,EAAE;QACb,IAAI,CAACA,KAAK,GAAG,IAAIJ,IAAI,EAAE;;MAE3B,IAAI,CAACI,KAAK,CAACG,KAAK,CAACjC,IAAI,CAAC;;EAE9B;;AAGJ;;;AAGA,OAAM,MAAO4C,GAAG;EAAhB/E,YAAA;IACY,KAAAkE,SAAS,GAAG,IAAIC,KAAK,EAAW;EAkjB5C;EA5hBI;;;;;EAKO,OAAOa,cAAcA,CAACC,IAAgB;IACzC,IAAIC,MAAc,EAAEnD,OAAgB,EAAEY,QAAkB;IACxD,MAAMmB,QAAQ,GAAG,IAAIK,KAAK,EAAW;IAErC,MAAMgB,OAAO,GAAGF,IAAI,CAACE,OAAO;IAC5B,MAAMC,SAAS,GAAGH,IAAI,CAACG,SAAS;IAChC,MAAMC,OAAO,GAAGJ,IAAI,CAACI,OAAO;IAC5B,MAAMC,GAAG,GAAGL,IAAI,CAACK,GAAG;IACpB,MAAMC,UAAU,GAAGN,IAAI,CAACO,MAAM;IAE9B,IAAI,CAACL,OAAO,IAAI,CAACC,SAAS,EAAE;MACxB,MAAM,qEAAqE;;IAG/E,KAAK,IAAI1C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyC,OAAO,CAACvC,MAAM,EAAEF,CAAC,IAAI,CAAC,EAAE;MACxCC,QAAQ,GAAG,EAAE;MACb,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QACxB,MAAMuC,YAAY,GAAG/C,CAAC,GAAGQ,CAAC;QAC1B,MAAMwC,MAAM,GAAGP,OAAO,CAACM,YAAY,CAAC;QAEpC,MAAMvF,MAAM,GAAGmF,OAAO,GAAG9F,OAAO,CAACoG,SAAS,CAACN,OAAO,EAAEK,MAAM,GAAG,CAAC,CAAC,GAAGnG,OAAO,CAACqG,IAAI,EAAE;QAChF,MAAMzF,EAAE,GAAGmF,GAAG,GAAG9F,OAAO,CAACmG,SAAS,CAACL,GAAG,EAAEI,MAAM,GAAG,CAAC,CAAC,GAAG5E,SAAS;QAC/D,MAAMV,SAAS,GAAGmF,UAAU,GAAG3F,MAAM,CAAC+F,SAAS,CAACJ,UAAU,EAAEG,MAAM,GAAG,CAAC,CAAC,GAAG5E,SAAS;QAEnF,MAAM+E,QAAQ,GAAGtG,OAAO,CAACoG,SAAS,CAACP,SAAS,EAAEM,MAAM,GAAG,CAAC,CAAC;QAEzDR,MAAM,GAAG,IAAInF,MAAM,CAAC8F,QAAQ,EAAE3F,MAAM,EAAEC,EAAE,EAAEC,SAAS,CAAC;QACpDuC,QAAQ,CAACI,IAAI,CAACmC,MAAM,CAAC;;MAGzBnD,OAAO,GAAG,IAAI0B,OAAO,CAACd,QAAQ,EAAE;QAAEmD,SAAS,EAAE,CAAC;QAAEC,MAAM,EAAEjG,gBAAgB;QAAEkG,aAAa,EAAE;MAAC,CAAE,CAAC;MAE7F;MACA;MACA,IAAIjE,OAAO,CAACiB,KAAK,EAAE;QACfc,QAAQ,CAACf,IAAI,CAAChB,OAAO,CAAC;;;IAI9B,MAAMkE,GAAG,GAAGlB,GAAG,CAACmB,aAAa,CAACpC,QAAQ,CAAC;IACvCmC,GAAG,CAACE,MAAM,GAAG7G,MAAM,CAAC8G,QAAQ,EAAE;IAC9BH,GAAG,CAACJ,QAAQ,GAAGtG,OAAO,CAACqG,IAAI,EAAE;IAC7BK,GAAG,CAACI,QAAQ,GAAG9G,OAAO,CAACqG,IAAI,EAAE;IAC7BK,GAAG,CAACK,OAAO,GAAG/G,OAAO,CAACgH,GAAG,EAAE;IAC3BN,GAAG,CAACO,kBAAkB,GAAGnH,UAAU,CAAC+G,QAAQ,EAAE;IAC9CtG,gBAAgB,EAAE;IAElB,OAAOmG,GAAG;EACd;EAEA;;;;;;EAMO,OAAOQ,QAAQA,CAACC,IAAU,EAAEC,QAAQ,GAAG,KAAK;IAC/C,IAAIzB,MAAc;MACdhF,MAAe;MACfC,EAAE,GAAwBW,SAAS;MACnC+E,QAAiB;MACjBzF,SAAS,GAAuBU,SAAS;MACzCiB,OAAgB;MAChBY,QAAkB;IACtB,MAAMmB,QAAQ,GAAG,IAAIK,KAAK,EAAW;IACrC,IAAIgC,MAAc;MACdS,YAAqB;MACrBC,YAAqB;MACrBC,sBAAsB,GAAyB,IAAI;MACnDC,WAAoB;IAExB,IAAIC,aAAa,GAAG,KAAK;IACzB,IAAIN,IAAI,YAAY/G,IAAI,EAAE;MACtB+G,IAAI,CAACO,kBAAkB,CAAC,IAAI,CAAC;MAC7Bd,MAAM,GAAGO,IAAI,CAACQ,cAAc,EAAE;MAC9BN,YAAY,GAAGF,IAAI,CAACb,QAAQ,CAACxF,KAAK,EAAE;MACpCwG,YAAY,GAAGH,IAAI,CAACL,QAAQ,CAAChG,KAAK,EAAE;MACpC,IAAIqG,IAAI,CAACF,kBAAkB,EAAE;QACzBM,sBAAsB,GAAGJ,IAAI,CAACF,kBAAkB,CAACnG,KAAK,EAAE;;MAE5D0G,WAAW,GAAGL,IAAI,CAACJ,OAAO,CAACjG,KAAK,EAAE;MAClC,IAAIqG,IAAI,CAACS,QAAQ,IAAIR,QAAQ,EAAE;QAC3BK,aAAa,GAAGN,IAAI,CAACS,QAAQ,CAACC,eAAe,KAAK;;KAEzD,MAAM;MACH,MAAM,oDAAoD;;IAG9D,MAAMjC,OAAO,GAAiBuB,IAAI,CAACW,UAAU,EAAE;MAC3CjC,SAAS,GAAesB,IAAI,CAACY,eAAe,CAAC7H,YAAY,CAAC8H,YAAY,CAAC;MACvElC,OAAO,GAAeqB,IAAI,CAACY,eAAe,CAAC7H,YAAY,CAAC+H,UAAU,CAAC;MACnElC,GAAG,GAAeoB,IAAI,CAACY,eAAe,CAAC7H,YAAY,CAACgI,MAAM,CAAC;MAC3DlC,UAAU,GAAemB,IAAI,CAACY,eAAe,CAAC7H,YAAY,CAACiI,SAAS,CAAC;IAEzE,MAAMC,SAAS,GAAGjB,IAAI,CAACiB,SAAS;IAEhC,KAAK,IAAIC,EAAE,GAAG,CAAC,EAAEC,GAAG,GAAGF,SAAS,CAAC/E,MAAM,EAAEgF,EAAE,GAAGC,GAAG,EAAED,EAAE,EAAE,EAAE;MACrD,KAAK,IAAIlF,CAAC,GAAGiF,SAAS,CAACC,EAAE,CAAC,CAACE,UAAU,EAAEC,EAAE,GAAGJ,SAAS,CAACC,EAAE,CAAC,CAACI,UAAU,GAAGL,SAAS,CAACC,EAAE,CAAC,CAACE,UAAU,EAAEpF,CAAC,GAAGqF,EAAE,EAAErF,CAAC,IAAI,CAAC,EAAE;QAC7GC,QAAQ,GAAG,EAAE;QACb,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;UACxB,MAAMuC,YAAY,GAAGvC,CAAC,KAAK,CAAC,GAAGR,CAAC,GAAGQ,CAAC,GAAG8D,aAAa,GAAGtE,CAAC,GAAG,CAAC,GAAGQ,CAAC,GAAGR,CAAC,GAAGQ,CAAC;UACxE,MAAM+E,YAAY,GAAG,IAAI1I,OAAO,CAAC8F,OAAO,CAACF,OAAO,CAACM,YAAY,CAAC,GAAG,CAAC,CAAC,EAAEJ,OAAO,CAACF,OAAO,CAACM,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAEJ,OAAO,CAACF,OAAO,CAACM,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;UACpJ,IAAIH,GAAG,EAAE;YACLnF,EAAE,GAAG,IAAIX,OAAO,CAAC8F,GAAG,CAACH,OAAO,CAACM,YAAY,CAAC,GAAG,CAAC,CAAC,EAAEH,GAAG,CAACH,OAAO,CAACM,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;;UAExF,IAAIF,UAAU,EAAE;YACZnF,SAAS,GAAG,IAAIR,MAAM,CAClB2F,UAAU,CAACJ,OAAO,CAACM,YAAY,CAAC,GAAG,CAAC,CAAC,EACrCF,UAAU,CAACJ,OAAO,CAACM,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EACzCF,UAAU,CAACJ,OAAO,CAACM,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EACzCF,UAAU,CAACJ,OAAO,CAACM,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAC5C;;UAEL,MAAMyC,cAAc,GAAG,IAAI3I,OAAO,CAAC6F,SAAS,CAACD,OAAO,CAACM,YAAY,CAAC,GAAG,CAAC,CAAC,EAAEL,SAAS,CAACD,OAAO,CAACM,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAEL,SAAS,CAACD,OAAO,CAACM,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;UAC5JI,QAAQ,GAAGtG,OAAO,CAAC4I,oBAAoB,CAACD,cAAc,EAAE/B,MAAM,CAAC;UAC/DjG,MAAM,GAAGX,OAAO,CAAC6I,eAAe,CAACH,YAAY,EAAE9B,MAAM,CAAC;UAEtDjB,MAAM,GAAG,IAAInF,MAAM,CAAC8F,QAAQ,EAAE3F,MAAM,EAAEC,EAAE,EAAEC,SAAS,CAAC;UACpDuC,QAAQ,CAACI,IAAI,CAACmC,MAAM,CAAC;;QAGzBnD,OAAO,GAAG,IAAI0B,OAAO,CAACd,QAAQ,EAAE;UAAEmD,SAAS,EAAE8B,EAAE;UAAE7B,MAAM,EAAEjG,gBAAgB;UAAEkG,aAAa,EAAE2B,SAAS,CAACC,EAAE,CAAC,CAAC5B;QAAa,CAAE,CAAC;QAExH;QACA;QACA,IAAIjE,OAAO,CAACiB,KAAK,EAAE;UACfc,QAAQ,CAACf,IAAI,CAAChB,OAAO,CAAC;;;;IAKlC,MAAMkE,GAAG,GAAGlB,GAAG,CAACmB,aAAa,CAACpC,QAAQ,CAAC;IACvCmC,GAAG,CAACE,MAAM,GAAGQ,QAAQ,GAAGrH,MAAM,CAAC8G,QAAQ,EAAE,GAAGD,MAAM;IAClDF,GAAG,CAACJ,QAAQ,GAAGc,QAAQ,GAAGpH,OAAO,CAACqG,IAAI,EAAE,GAAGgB,YAAY;IACvDX,GAAG,CAACI,QAAQ,GAAGM,QAAQ,GAAGpH,OAAO,CAACqG,IAAI,EAAE,GAAGiB,YAAY;IACvDZ,GAAG,CAACK,OAAO,GAAGK,QAAQ,GAAGpH,OAAO,CAACgH,GAAG,EAAE,GAAGQ,WAAW;IACpDd,GAAG,CAACO,kBAAkB,GAAGG,QAAQ,IAAIG,sBAAsB,GAAGzH,UAAU,CAAC+G,QAAQ,EAAE,GAAGU,sBAAsB;IAC5GhH,gBAAgB,EAAE;IAElB,OAAOmG,GAAG;EACd;EAEA;;;;EAIQ,OAAOC,aAAaA,CAACpC,QAAmB;IAC5C,MAAMmC,GAAG,GAAG,IAAIlB,GAAG,EAAE;IACrBkB,GAAG,CAAC/B,SAAS,GAAGJ,QAAQ;IACxB,OAAOmC,GAAG;EACd;EAEA;;;;EAIO5F,KAAKA,CAAA;IACR,MAAM4F,GAAG,GAAG,IAAIlB,GAAG,EAAE;IACrBkB,GAAG,CAAC/B,SAAS,GAAG,IAAI,CAACA,SAAS,CAACP,GAAG,CAAEW,CAAC,IAAKA,CAAC,CAACjE,KAAK,EAAE,CAAC;IACpD4F,GAAG,CAACoC,uBAAuB,CAAC,IAAI,CAAC;IACjC,OAAOpC,GAAG;EACd;EAEA;;;;;EAKOqC,KAAKA,CAACrC,GAAQ;IACjB,MAAM/E,CAAC,GAAG,IAAI2C,IAAI,CAAC,IAAI,CAACxD,KAAK,EAAE,CAAC6D,SAAS,CAAC;IAC1C,MAAM/C,CAAC,GAAG,IAAI0C,IAAI,CAACoC,GAAG,CAAC5F,KAAK,EAAE,CAAC6D,SAAS,CAAC;IACzChD,CAAC,CAAC0D,MAAM,CAACzD,CAAC,CAAC;IACXA,CAAC,CAACyD,MAAM,CAAC1D,CAAC,CAAC;IACXC,CAAC,CAACoD,MAAM,EAAE;IACVpD,CAAC,CAACyD,MAAM,CAAC1D,CAAC,CAAC;IACXC,CAAC,CAACoD,MAAM,EAAE;IACVrD,CAAC,CAACkD,KAAK,CAACjD,CAAC,CAAC2D,WAAW,EAAE,CAAC;IACxB,OAAOC,GAAG,CAACmB,aAAa,CAAChF,CAAC,CAAC4D,WAAW,EAAE,CAAC,CAACuD,uBAAuB,CAAC,IAAI,CAAC;EAC3E;EAEA;;;;EAIOE,YAAYA,CAACtC,GAAQ;IACxB,MAAM/E,CAAC,GAAG,IAAI2C,IAAI,CAAC,IAAI,CAACK,SAAS,CAAC;IAClC,MAAM/C,CAAC,GAAG,IAAI0C,IAAI,CAACoC,GAAG,CAAC/B,SAAS,CAAC;IAEjChD,CAAC,CAAC0D,MAAM,CAACzD,CAAC,CAAC;IACXA,CAAC,CAACyD,MAAM,CAAC1D,CAAC,CAAC;IACXC,CAAC,CAACoD,MAAM,EAAE;IACVpD,CAAC,CAACyD,MAAM,CAAC1D,CAAC,CAAC;IACXC,CAAC,CAACoD,MAAM,EAAE;IACVrD,CAAC,CAACkD,KAAK,CAACjD,CAAC,CAAC2D,WAAW,EAAE,CAAC;IAExB,IAAI,CAACZ,SAAS,GAAGhD,CAAC,CAAC4D,WAAW,EAAE;EACpC;EAEA;;;;;EAKOxD,QAAQA,CAAC2E,GAAQ;IACpB,MAAM/E,CAAC,GAAG,IAAI2C,IAAI,CAAC,IAAI,CAACxD,KAAK,EAAE,CAAC6D,SAAS,CAAC;IAC1C,MAAM/C,CAAC,GAAG,IAAI0C,IAAI,CAACoC,GAAG,CAAC5F,KAAK,EAAE,CAAC6D,SAAS,CAAC;IACzChD,CAAC,CAACqD,MAAM,EAAE;IACVrD,CAAC,CAAC0D,MAAM,CAACzD,CAAC,CAAC;IACXA,CAAC,CAACyD,MAAM,CAAC1D,CAAC,CAAC;IACXC,CAAC,CAACoD,MAAM,EAAE;IACVpD,CAAC,CAACyD,MAAM,CAAC1D,CAAC,CAAC;IACXC,CAAC,CAACoD,MAAM,EAAE;IACVrD,CAAC,CAACkD,KAAK,CAACjD,CAAC,CAAC2D,WAAW,EAAE,CAAC;IACxB5D,CAAC,CAACqD,MAAM,EAAE;IACV,OAAOQ,GAAG,CAACmB,aAAa,CAAChF,CAAC,CAAC4D,WAAW,EAAE,CAAC,CAACuD,uBAAuB,CAAC,IAAI,CAAC;EAC3E;EAEA;;;;EAIOG,eAAeA,CAACvC,GAAQ;IAC3B,MAAM/E,CAAC,GAAG,IAAI2C,IAAI,CAAC,IAAI,CAACK,SAAS,CAAC;IAClC,MAAM/C,CAAC,GAAG,IAAI0C,IAAI,CAACoC,GAAG,CAAC/B,SAAS,CAAC;IAEjChD,CAAC,CAACqD,MAAM,EAAE;IACVrD,CAAC,CAAC0D,MAAM,CAACzD,CAAC,CAAC;IACXA,CAAC,CAACyD,MAAM,CAAC1D,CAAC,CAAC;IACXC,CAAC,CAACoD,MAAM,EAAE;IACVpD,CAAC,CAACyD,MAAM,CAAC1D,CAAC,CAAC;IACXC,CAAC,CAACoD,MAAM,EAAE;IACVrD,CAAC,CAACkD,KAAK,CAACjD,CAAC,CAAC2D,WAAW,EAAE,CAAC;IACxB5D,CAAC,CAACqD,MAAM,EAAE;IAEV,IAAI,CAACL,SAAS,GAAGhD,CAAC,CAAC4D,WAAW,EAAE;EACpC;EAEA;;;;;EAKO2D,SAASA,CAACxC,GAAQ;IACrB,MAAM/E,CAAC,GAAG,IAAI2C,IAAI,CAAC,IAAI,CAACxD,KAAK,EAAE,CAAC6D,SAAS,CAAC;IAC1C,MAAM/C,CAAC,GAAG,IAAI0C,IAAI,CAACoC,GAAG,CAAC5F,KAAK,EAAE,CAAC6D,SAAS,CAAC;IACzChD,CAAC,CAACqD,MAAM,EAAE;IACVpD,CAAC,CAACyD,MAAM,CAAC1D,CAAC,CAAC;IACXC,CAAC,CAACoD,MAAM,EAAE;IACVrD,CAAC,CAAC0D,MAAM,CAACzD,CAAC,CAAC;IACXA,CAAC,CAACyD,MAAM,CAAC1D,CAAC,CAAC;IACXA,CAAC,CAACkD,KAAK,CAACjD,CAAC,CAAC2D,WAAW,EAAE,CAAC;IACxB5D,CAAC,CAACqD,MAAM,EAAE;IACV,OAAOQ,GAAG,CAACmB,aAAa,CAAChF,CAAC,CAAC4D,WAAW,EAAE,CAAC,CAACuD,uBAAuB,CAAC,IAAI,CAAC;EAC3E;EAEA;;;;EAIOK,gBAAgBA,CAACzC,GAAQ;IAC5B,MAAM/E,CAAC,GAAG,IAAI2C,IAAI,CAAC,IAAI,CAACK,SAAS,CAAC;IAClC,MAAM/C,CAAC,GAAG,IAAI0C,IAAI,CAACoC,GAAG,CAAC/B,SAAS,CAAC;IAEjChD,CAAC,CAACqD,MAAM,EAAE;IACVpD,CAAC,CAACyD,MAAM,CAAC1D,CAAC,CAAC;IACXC,CAAC,CAACoD,MAAM,EAAE;IACVrD,CAAC,CAAC0D,MAAM,CAACzD,CAAC,CAAC;IACXA,CAAC,CAACyD,MAAM,CAAC1D,CAAC,CAAC;IACXA,CAAC,CAACkD,KAAK,CAACjD,CAAC,CAAC2D,WAAW,EAAE,CAAC;IACxB5D,CAAC,CAACqD,MAAM,EAAE;IAEV,IAAI,CAACL,SAAS,GAAGhD,CAAC,CAAC4D,WAAW,EAAE;EACpC;EAEA;;;;;EAKO6D,OAAOA,CAAA;IACV,MAAM1C,GAAG,GAAG,IAAI,CAAC5F,KAAK,EAAE;IACxB4F,GAAG,CAAC2C,cAAc,EAAE;IACpB,OAAO3C,GAAG;EACd;EAEA;;;EAGO2C,cAAcA,CAAA;IACjB,IAAI,CAAC1E,SAAS,CAACP,GAAG,CAAEW,CAAC,IAAI;MACrBA,CAAC,CAAC9D,IAAI,EAAE;IACZ,CAAC,CAAC;EACN;EAEA;;;;;;;EAOO6H,uBAAuBA,CAACpC,GAAQ;IACnC,IAAI,CAACE,MAAM,GAAGF,GAAG,CAACE,MAAM;IACxB,IAAI,CAACN,QAAQ,GAAGI,GAAG,CAACJ,QAAQ;IAC5B,IAAI,CAACQ,QAAQ,GAAGJ,GAAG,CAACI,QAAQ;IAC5B,IAAI,CAACC,OAAO,GAAGL,GAAG,CAACK,OAAO;IAC1B,IAAI,CAACE,kBAAkB,GAAGP,GAAG,CAACO,kBAAkB;IAEhD,OAAO,IAAI;EACf;EAEA;;;;;EAKOqC,YAAYA,CAACC,yBAAA,GAAkE,IAAI,EAAEC,wBAAA,GAAiD,IAAI;IAC7I,MAAM5C,MAAM,GAAG,IAAI,CAACA,MAAM,CAAC9F,KAAK,EAAE;IAClC8F,MAAM,CAAC5B,MAAM,EAAE;IAEf,MAAMT,QAAQ,GAAG,IAAI,CAACI,SAAS;IAC/B,MAAMvB,QAAQ,GAAG,EAAE;IACnB,MAAMwC,OAAO,GAAG,EAAE;IAClB,MAAME,OAAO,GAAG,EAAE;IAClB,IAAIC,GAAG,GAAuB,IAAI;IAClC,IAAIC,UAAU,GAAuB,IAAI;IACzC,MAAML,MAAM,GAAG3F,OAAO,CAACqG,IAAI,EAAE;IAC7B,MAAM1F,MAAM,GAAGX,OAAO,CAACqG,IAAI,EAAE;IAC7B,MAAMzF,EAAE,GAAGX,OAAO,CAACoG,IAAI,EAAE;IACzB,MAAMxF,SAAS,GAAG,IAAIR,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACxC,MAAMoJ,cAAc,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAChC,MAAMC,YAAY,GAAG,EAAE;IACvB,IAAIC,UAAU;IAEd,KAAK,IAAIxG,CAAC,GAAG,CAAC,EAAEqF,EAAE,GAAGjE,QAAQ,CAAClB,MAAM,EAAEF,CAAC,GAAGqF,EAAE,EAAErF,CAAC,EAAE,EAAE;MAC/C,MAAMX,OAAO,GAAG+B,QAAQ,CAACpB,CAAC,CAAC;MAE3B,IAAIoG,yBAAyB,EAAE;QAC3BA,yBAAyB,CAAC/G,OAAO,CAAC;;MAGtC,KAAK,IAAImB,CAAC,GAAG,CAAC,EAAEiG,EAAE,GAAGpH,OAAO,CAACY,QAAQ,CAACC,MAAM,EAAEM,CAAC,GAAGiG,EAAE,EAAEjG,CAAC,EAAE,EAAE;QACvD8F,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC;QACrBA,cAAc,CAAC,CAAC,CAAC,GAAG9F,CAAC,GAAG,CAAC;QACzB8F,cAAc,CAAC,CAAC,CAAC,GAAG9F,CAAC;QAErB,KAAK,IAAIkG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;UACxBlE,MAAM,CAACmE,QAAQ,CAACtH,OAAO,CAACY,QAAQ,CAACqG,cAAc,CAACI,CAAC,CAAC,CAAC,CAACnJ,GAAG,CAAC;UACxDC,MAAM,CAACmJ,QAAQ,CAACtH,OAAO,CAACY,QAAQ,CAACqG,cAAc,CAACI,CAAC,CAAC,CAAC,CAAClJ,MAAM,CAAC;UAC3D,IAAI6B,OAAO,CAACY,QAAQ,CAACqG,cAAc,CAACI,CAAC,CAAC,CAAC,CAACjJ,EAAE,EAAE;YACxC,IAAI,CAACmF,GAAG,EAAE;cACNA,GAAG,GAAG,EAAE;;YAEZnF,EAAE,CAACkJ,QAAQ,CAACtH,OAAO,CAACY,QAAQ,CAACqG,cAAc,CAACI,CAAC,CAAC,CAAC,CAACjJ,EAAG,CAAC;;UAGxD,IAAI4B,OAAO,CAACY,QAAQ,CAACqG,cAAc,CAACI,CAAC,CAAC,CAAC,CAAChJ,SAAS,EAAE;YAC/C,IAAI,CAACmF,UAAU,EAAE;cACbA,UAAU,GAAG,EAAE;;YAEnBnF,SAAS,CAACiJ,QAAQ,CAACtH,OAAO,CAACY,QAAQ,CAACqG,cAAc,CAACI,CAAC,CAAC,CAAC,CAAChJ,SAAU,CAAC;;UAEtE,MAAMkJ,WAAW,GAAG/J,OAAO,CAAC4I,oBAAoB,CAACjD,MAAM,EAAEiB,MAAM,CAAC;UAChE,MAAMoD,WAAW,GAAGhK,OAAO,CAAC6I,eAAe,CAAClI,MAAM,EAAEiG,MAAM,CAAC;UAE3D+C,UAAU,GAASD,YAAa,CAACK,WAAW,CAACE,CAAC,GAAG,GAAG,GAAGF,WAAW,CAACG,CAAC,GAAG,GAAG,GAAGH,WAAW,CAACI,CAAC,CAAC;UAE3F,IAAIC,eAAe,GAAG,KAAK;UAE3B,IAAIrE,GAAG,IAAI,EAAEA,GAAG,CAAC4D,UAAU,GAAG,CAAC,CAAC,KAAK/I,EAAE,CAACqJ,CAAC,IAAIlE,GAAG,CAAC4D,UAAU,GAAG,CAAC,GAAG,CAAC,CAAC,KAAK/I,EAAE,CAACsJ,CAAC,CAAC,EAAE;YAC5EE,eAAe,GAAG,IAAI;;UAG1B,IAAIC,kBAAkB,GAAG,KAAK;UAE9B,IACIrE,UAAU,IACV,EACIA,UAAU,CAAC2D,UAAU,GAAG,CAAC,CAAC,KAAK9I,SAAS,CAACyJ,CAAC,IAC1CtE,UAAU,CAAC2D,UAAU,GAAG,CAAC,GAAG,CAAC,CAAC,KAAK9I,SAAS,CAAC0J,CAAC,IAC9CvE,UAAU,CAAC2D,UAAU,GAAG,CAAC,GAAG,CAAC,CAAC,KAAK9I,SAAS,CAACe,CAAC,IAC9CoE,UAAU,CAAC2D,UAAU,GAAG,CAAC,GAAG,CAAC,CAAC,KAAK9I,SAAS,CAACc,CAAC,CACjD,EACH;YACE0I,kBAAkB,GAAG,IAAI;;UAG7B;UACA,IACI,EACI,OAAOV,UAAU,KAAK,WAAW,IACjC7D,OAAO,CAAC6D,UAAU,GAAG,CAAC,CAAC,KAAKK,WAAW,CAACC,CAAC,IACzCnE,OAAO,CAAC6D,UAAU,GAAG,CAAC,GAAG,CAAC,CAAC,KAAKK,WAAW,CAACE,CAAC,IAC7CpE,OAAO,CAAC6D,UAAU,GAAG,CAAC,GAAG,CAAC,CAAC,KAAKK,WAAW,CAACG,CAAC,CAChD,IACDC,eAAe,IACfC,kBAAkB,EACpB;YACEjH,QAAQ,CAACI,IAAI,CAACuG,WAAW,CAACE,CAAC,EAAEF,WAAW,CAACG,CAAC,EAAEH,WAAW,CAACI,CAAC,CAAC;YAC1D,IAAIpE,GAAG,EAAE;cACLA,GAAG,CAACvC,IAAI,CAAC5C,EAAE,CAACqJ,CAAC,EAAErJ,EAAE,CAACsJ,CAAC,CAAC;;YAExBpE,OAAO,CAACtC,IAAI,CAAC7C,MAAM,CAACsJ,CAAC,EAAEtJ,MAAM,CAACuJ,CAAC,EAAEvJ,MAAM,CAACwJ,CAAC,CAAC;YAC1C,IAAInE,UAAU,EAAE;cACZA,UAAU,CAACxC,IAAI,CAAC3C,SAAS,CAACyJ,CAAC,EAAEzJ,SAAS,CAAC0J,CAAC,EAAE1J,SAAS,CAACe,CAAC,EAAEf,SAAS,CAACc,CAAC,CAAC;;YAEvEgI,UAAU,GAASD,YAAa,CAACK,WAAW,CAACE,CAAC,GAAG,GAAG,GAAGF,WAAW,CAACG,CAAC,GAAG,GAAG,GAAGH,WAAW,CAACI,CAAC,CAAC,GAAG/G,QAAQ,CAACC,MAAM,GAAG,CAAC,GAAG,CAAC;;UAGzHuC,OAAO,CAACpC,IAAI,CAACmG,UAAU,CAAC;UAExB,IAAIH,wBAAwB,EAAE;YAC1BA,wBAAwB,EAAE;;;;;IAM1C,MAAMgB,MAAM,GAAG,IAAIlK,UAAU,EAAE;IAC/BkK,MAAM,CAAC3E,SAAS,GAAGzC,QAAQ;IAC3BoH,MAAM,CAAC1E,OAAO,GAAGA,OAAO;IACxB,IAAIC,GAAG,EAAE;MACLyE,MAAM,CAACzE,GAAG,GAAGA,GAAG;;IAEpB,IAAIC,UAAU,EAAE;MACZwE,MAAM,CAACvE,MAAM,GAAGD,UAAU;;IAE9BwE,MAAM,CAAC5E,OAAO,GAAGA,OAAO;IAExB,OAAO4E,MAAM;EACjB;EAEA;;;;;;;;EAQOC,iBAAiBA,CAACC,IAAY,EAAEC,KAAa,EAAEC,aAAuB;IACzE,MAAMzD,IAAI,GAAG,IAAI/G,IAAI,CAACsK,IAAI,EAAEC,KAAK,CAAC;IAClC,MAAMpG,QAAQ,GAAG,IAAI,CAACI,SAAS;IAC/B,IAAIkG,YAAY,GAAG,CAAC;IACpB,MAAMC,WAAW,GAAG,EAAE;IACtB,IAAIC,UAIH;IAED,IAAIH,aAAa,EAAE;MACf;MACArG,QAAQ,CAACyG,IAAI,CAAC,CAACrJ,CAAC,EAAEC,CAAC,KAAI;QACnB,IAAID,CAAC,CAACwC,MAAM,CAACqC,MAAM,KAAK5E,CAAC,CAACuC,MAAM,CAACqC,MAAM,EAAE;UACrC,OAAO7E,CAAC,CAACwC,MAAM,CAACoC,SAAS,GAAG3E,CAAC,CAACuC,MAAM,CAACoC,SAAS;SACjD,MAAM;UACH,OAAO5E,CAAC,CAACwC,MAAM,CAACqC,MAAM,GAAG5E,CAAC,CAACuC,MAAM,CAACqC,MAAM;;MAEhD,CAAC,CAAC;;IAGN,MAAMyE,UAAU,GAAG,IAAI,CAAC3B,YAAY,CAC/B9G,OAAO,IAAI;MACR;MACA,IAAI,CAAOsI,WAAY,CAACtI,OAAO,CAAC2B,MAAM,CAACqC,MAAM,CAAC,EAAE;QACtCsE,WAAY,CAACtI,OAAO,CAAC2B,MAAM,CAACqC,MAAM,CAAC,GAAG,EAAE;;MAElD,IAAI,CAAOsE,WAAY,CAACtI,OAAO,CAAC2B,MAAM,CAACqC,MAAM,CAAC,CAAChE,OAAO,CAAC2B,MAAM,CAACoC,SAAS,CAAC,EAAE;QAChEuE,WAAY,CAACtI,OAAO,CAAC2B,MAAM,CAACqC,MAAM,CAAC,CAAChE,OAAO,CAAC2B,MAAM,CAACoC,SAAS,CAAC,GAAG;UAClEgC,UAAU,EAAE,CAAC2C,QAAQ;UACrBC,QAAQ,EAAE,CAACD,QAAQ;UACnBzE,aAAa,EAAEjE,OAAO,CAAC2B,MAAM,CAACsC;SACjC;;MAELsE,UAAU,GAASD,WAAY,CAACtI,OAAO,CAAC2B,MAAM,CAACqC,MAAM,CAAC,CAAChE,OAAO,CAAC2B,MAAM,CAACoC,SAAS,CAAC;IACpF,CAAC,EACD,MAAK;MACDwE,UAAU,CAACxC,UAAU,GAAG6C,IAAI,CAACC,GAAG,CAACR,YAAY,EAAEE,UAAU,CAACxC,UAAU,CAAC;MACrEwC,UAAU,CAACI,QAAQ,GAAGC,IAAI,CAACE,GAAG,CAACT,YAAY,EAAEE,UAAU,CAACI,QAAQ,CAAC;MACjEN,YAAY,EAAE;IAClB,CAAC,CACJ;IAEDI,UAAU,CAACM,WAAW,CAACpE,IAAI,CAAC;IAE5B,IAAIyD,aAAa,EAAE;MACf;MACA,IAAIY,mBAAmB,GAAG,CAAC;QACvBC,gBAAgB;MAEpBtE,IAAI,CAACiB,SAAS,GAAG,IAAIxD,KAAK,EAAW;MAErC,KAAK,MAAM8G,CAAC,IAAIZ,WAAW,EAAE;QACzBW,gBAAgB,GAAG,CAAC,CAAC;QACrB,KAAK,MAAMpD,EAAE,IAAUyC,WAAY,CAACY,CAAC,CAAC,EAAE;UACpCX,UAAU,GAASD,WAAY,CAACY,CAAC,CAAC,CAACrD,EAAE,CAAC;UACtClI,OAAO,CAACwL,iBAAiB,CACrBZ,UAAU,CAACtE,aAAa,GAAG+E,mBAAmB,EAC9CT,UAAU,CAACxC,UAAU,EACrBwC,UAAU,CAACI,QAAQ,GAAGJ,UAAU,CAACxC,UAAU,GAAG,CAAC,EACjCpB,IAAI,CACrB;UACDsE,gBAAgB,GAAGL,IAAI,CAACE,GAAG,CAACP,UAAU,CAACtE,aAAa,EAAEgF,gBAAgB,CAAC;;QAE3ED,mBAAmB,IAAI,EAAEC,gBAAgB;;;IAIjD,OAAOtE,IAAI;EACf;EAEA;;;;;;;;EAQOyE,MAAMA,CAAClB,IAAY,EAAE9C,QAAA,GAA+B,IAAI,EAAE+C,KAAa,EAAEC,aAAuB;IACnG,MAAMzD,IAAI,GAAG,IAAI,CAACsD,iBAAiB,CAACC,IAAI,EAAEC,KAAK,EAAEC,aAAa,CAAC;IAE/DzD,IAAI,CAACS,QAAQ,GAAGA,QAAQ;IAExBT,IAAI,CAACb,QAAQ,CAACwD,QAAQ,CAAC,IAAI,CAACxD,QAAQ,CAAC;IACrCa,IAAI,CAACL,QAAQ,CAACgD,QAAQ,CAAC,IAAI,CAAChD,QAAQ,CAAC;IACrC,IAAI,IAAI,CAACG,kBAAkB,EAAE;MACzBE,IAAI,CAACF,kBAAkB,GAAG,IAAI,CAACA,kBAAkB,CAACnG,KAAK,EAAE;;IAE7DqG,IAAI,CAACJ,OAAO,CAAC+C,QAAQ,CAAC,IAAI,CAAC/C,OAAO,CAAC;IACnCI,IAAI,CAACO,kBAAkB,CAAC,IAAI,CAAC;IAE7B,OAAOP,IAAI;EACf"},"metadata":{},"sourceType":"module","externalDependencies":[]}