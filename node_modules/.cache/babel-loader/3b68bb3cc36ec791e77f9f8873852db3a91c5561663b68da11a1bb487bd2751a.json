{"ast":null,"code":"import { Vector3 } from \"../Maths/math.vector.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\n/**\n * Type of sub emitter\n */\nexport var SubEmitterType;\n(function (SubEmitterType) {\n  /**\n   * Attached to the particle over it's lifetime\n   */\n  SubEmitterType[SubEmitterType[\"ATTACHED\"] = 0] = \"ATTACHED\";\n  /**\n   * Created when the particle dies\n   */\n  SubEmitterType[SubEmitterType[\"END\"] = 1] = \"END\";\n})(SubEmitterType || (SubEmitterType = {}));\n/**\n * Sub emitter class used to emit particles from an existing particle\n */\nexport class SubEmitter {\n  /**\n   * Creates a sub emitter\n   * @param particleSystem the particle system to be used by the sub emitter\n   */\n  constructor(\n  /**\n   * the particle system to be used by the sub emitter\n   */\n  particleSystem) {\n    this.particleSystem = particleSystem;\n    /**\n     * Type of the submitter (Default: END)\n     */\n    this.type = SubEmitterType.END;\n    /**\n     * If the particle should inherit the direction from the particle it's attached to. (+Y will face the direction the particle is moving) (Default: false)\n     * Note: This only is supported when using an emitter of type Mesh\n     */\n    this.inheritDirection = false;\n    /**\n     * How much of the attached particles speed should be added to the sub emitted particle (default: 0)\n     */\n    this.inheritedVelocityAmount = 0;\n    // Create mesh as emitter to support rotation\n    if (!particleSystem.emitter || !particleSystem.emitter.dispose) {\n      const internalClass = GetClass(\"BABYLON.AbstractMesh\");\n      particleSystem.emitter = new internalClass(\"SubemitterSystemEmitter\", particleSystem.getScene());\n      particleSystem._disposeEmitterOnDispose = true;\n    }\n  }\n  /**\n   * Clones the sub emitter\n   * @returns the cloned sub emitter\n   */\n  clone() {\n    // Clone particle system\n    let emitter = this.particleSystem.emitter;\n    if (!emitter) {\n      emitter = new Vector3();\n    } else if (emitter instanceof Vector3) {\n      emitter = emitter.clone();\n    } else if (emitter.getClassName().indexOf(\"Mesh\") !== -1) {\n      const internalClass = GetClass(\"BABYLON.Mesh\");\n      emitter = new internalClass(\"\", emitter.getScene());\n      emitter.isVisible = false;\n    }\n    const clone = new SubEmitter(this.particleSystem.clone(this.particleSystem.name, emitter));\n    // Clone properties\n    clone.particleSystem.name += \"Clone\";\n    clone.type = this.type;\n    clone.inheritDirection = this.inheritDirection;\n    clone.inheritedVelocityAmount = this.inheritedVelocityAmount;\n    clone.particleSystem._disposeEmitterOnDispose = true;\n    clone.particleSystem.disposeOnStop = true;\n    return clone;\n  }\n  /**\n   * Serialize current object to a JSON object\n   * @param serializeTexture defines if the texture must be serialized as well\n   * @returns the serialized object\n   */\n  serialize(serializeTexture = false) {\n    const serializationObject = {};\n    serializationObject.type = this.type;\n    serializationObject.inheritDirection = this.inheritDirection;\n    serializationObject.inheritedVelocityAmount = this.inheritedVelocityAmount;\n    serializationObject.particleSystem = this.particleSystem.serialize(serializeTexture);\n    return serializationObject;\n  }\n  /**\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  static _ParseParticleSystem(system, sceneOrEngine, rootUrl, doNotStart = false) {\n    throw _WarnImport(\"ParseParticle\");\n  }\n  /**\n   * Creates a new SubEmitter from a serialized JSON version\n   * @param serializationObject defines the JSON object to read from\n   * @param sceneOrEngine defines the hosting scene or the hosting engine\n   * @param rootUrl defines the rootUrl for data loading\n   * @returns a new SubEmitter\n   */\n  static Parse(serializationObject, sceneOrEngine, rootUrl) {\n    const system = serializationObject.particleSystem;\n    const subEmitter = new SubEmitter(SubEmitter._ParseParticleSystem(system, sceneOrEngine, rootUrl, true));\n    subEmitter.type = serializationObject.type;\n    subEmitter.inheritDirection = serializationObject.inheritDirection;\n    subEmitter.inheritedVelocityAmount = serializationObject.inheritedVelocityAmount;\n    subEmitter.particleSystem._isSubEmitter = true;\n    return subEmitter;\n  }\n  /** Release associated resources */\n  dispose() {\n    this.particleSystem.dispose();\n  }\n}","map":{"version":3,"names":["Vector3","_WarnImport","GetClass","SubEmitterType","SubEmitter","constructor","particleSystem","type","END","inheritDirection","inheritedVelocityAmount","emitter","dispose","internalClass","getScene","_disposeEmitterOnDispose","clone","getClassName","indexOf","isVisible","name","disposeOnStop","serialize","serializeTexture","serializationObject","_ParseParticleSystem","system","sceneOrEngine","rootUrl","doNotStart","Parse","subEmitter","_isSubEmitter"],"sources":["../../../../dev/core/src/Particles/subEmitter.ts"],"sourcesContent":["import { Vector3 } from \"../Maths/math.vector\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { ParticleSystem } from \"../Particles/particleSystem\";\r\n\r\n/**\r\n * Type of sub emitter\r\n */\r\nexport enum SubEmitterType {\r\n    /**\r\n     * Attached to the particle over it's lifetime\r\n     */\r\n    ATTACHED,\r\n    /**\r\n     * Created when the particle dies\r\n     */\r\n    END,\r\n}\r\n\r\n/**\r\n * Sub emitter class used to emit particles from an existing particle\r\n */\r\nexport class SubEmitter {\r\n    /**\r\n     * Type of the submitter (Default: END)\r\n     */\r\n    public type = SubEmitterType.END;\r\n    /**\r\n     * If the particle should inherit the direction from the particle it's attached to. (+Y will face the direction the particle is moving) (Default: false)\r\n     * Note: This only is supported when using an emitter of type Mesh\r\n     */\r\n    public inheritDirection = false;\r\n    /**\r\n     * How much of the attached particles speed should be added to the sub emitted particle (default: 0)\r\n     */\r\n    public inheritedVelocityAmount = 0;\r\n\r\n    /**\r\n     * Creates a sub emitter\r\n     * @param particleSystem the particle system to be used by the sub emitter\r\n     */\r\n    constructor(\r\n        /**\r\n         * the particle system to be used by the sub emitter\r\n         */\r\n        public particleSystem: ParticleSystem\r\n    ) {\r\n        // Create mesh as emitter to support rotation\r\n        if (!particleSystem.emitter || !(<AbstractMesh>particleSystem.emitter).dispose) {\r\n            const internalClass = GetClass(\"BABYLON.AbstractMesh\");\r\n            particleSystem.emitter = new internalClass(\"SubemitterSystemEmitter\", particleSystem.getScene());\r\n            particleSystem._disposeEmitterOnDispose = true;\r\n        }\r\n    }\r\n    /**\r\n     * Clones the sub emitter\r\n     * @returns the cloned sub emitter\r\n     */\r\n    public clone(): SubEmitter {\r\n        // Clone particle system\r\n        let emitter = this.particleSystem.emitter;\r\n        if (!emitter) {\r\n            emitter = new Vector3();\r\n        } else if (emitter instanceof Vector3) {\r\n            emitter = emitter.clone();\r\n        } else if (emitter.getClassName().indexOf(\"Mesh\") !== -1) {\r\n            const internalClass = GetClass(\"BABYLON.Mesh\");\r\n            emitter = new internalClass(\"\", emitter.getScene());\r\n            (emitter! as any).isVisible = false;\r\n        }\r\n        const clone = new SubEmitter(this.particleSystem.clone(this.particleSystem.name, emitter));\r\n\r\n        // Clone properties\r\n        clone.particleSystem.name += \"Clone\";\r\n        clone.type = this.type;\r\n        clone.inheritDirection = this.inheritDirection;\r\n        clone.inheritedVelocityAmount = this.inheritedVelocityAmount;\r\n\r\n        clone.particleSystem._disposeEmitterOnDispose = true;\r\n        clone.particleSystem.disposeOnStop = true;\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Serialize current object to a JSON object\r\n     * @param serializeTexture defines if the texture must be serialized as well\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(serializeTexture: boolean = false): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.type = this.type;\r\n        serializationObject.inheritDirection = this.inheritDirection;\r\n        serializationObject.inheritedVelocityAmount = this.inheritedVelocityAmount;\r\n        serializationObject.particleSystem = this.particleSystem.serialize(serializeTexture);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static _ParseParticleSystem(system: any, sceneOrEngine: Scene | ThinEngine, rootUrl: string, doNotStart = false): ParticleSystem {\r\n        throw _WarnImport(\"ParseParticle\");\r\n    }\r\n\r\n    /**\r\n     * Creates a new SubEmitter from a serialized JSON version\r\n     * @param serializationObject defines the JSON object to read from\r\n     * @param sceneOrEngine defines the hosting scene or the hosting engine\r\n     * @param rootUrl defines the rootUrl for data loading\r\n     * @returns a new SubEmitter\r\n     */\r\n    public static Parse(serializationObject: any, sceneOrEngine: Scene | ThinEngine, rootUrl: string): SubEmitter {\r\n        const system = serializationObject.particleSystem;\r\n        const subEmitter = new SubEmitter(SubEmitter._ParseParticleSystem(system, sceneOrEngine, rootUrl, true));\r\n        subEmitter.type = serializationObject.type;\r\n        subEmitter.inheritDirection = serializationObject.inheritDirection;\r\n        subEmitter.inheritedVelocityAmount = serializationObject.inheritedVelocityAmount;\r\n        subEmitter.particleSystem._isSubEmitter = true;\r\n\r\n        return subEmitter;\r\n    }\r\n\r\n    /** Release associated resources */\r\n    public dispose() {\r\n        this.particleSystem.dispose();\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}