{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../tslib.es6.js\";\nimport { serializeAsVector3, serialize, serializeAsMeshReference } from \"../Misc/decorators.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Vector2, Vector3, Matrix } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { MaterialHelper } from \"../Materials/materialHelper.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { PostProcess } from \"./postProcess.js\";\nimport { CreatePlane } from \"../Meshes/Builders/planeBuilder.js\";\nimport \"../Shaders/depth.vertex.js\";\nimport \"../Shaders/volumetricLightScattering.fragment.js\";\nimport \"../Shaders/volumetricLightScatteringPass.vertex.js\";\nimport \"../Shaders/volumetricLightScatteringPass.fragment.js\";\nimport { Color4, Color3 } from \"../Maths/math.color.js\";\nimport { Viewport } from \"../Maths/math.viewport.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\n/**\n *  Inspired by https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-13-volumetric-light-scattering-post-process\n */\nexport class VolumetricLightScatteringPostProcess extends PostProcess {\n  /**\n   * @internal\n   * VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\n   */\n  get useDiffuseColor() {\n    Logger.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\");\n    return false;\n  }\n  set useDiffuseColor(useDiffuseColor) {\n    Logger.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\");\n  }\n  /**\n   * @constructor\n   * @param name The post-process name\n   * @param ratio The size of the post-process and/or internal pass (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)\n   * @param camera The camera that the post-process will be attached to\n   * @param mesh The mesh used to create the light scattering\n   * @param samples The post-process quality, default 100\n   * @param samplingMode The post-process filtering mode\n   * @param engine The babylon engine\n   * @param reusable If the post-process is reusable\n   * @param scene The constructor needs a scene reference to initialize internal components. If \"camera\" is null a \"scene\" must be provided\n   */\n  constructor(name, ratio, camera, mesh, samples = 100, samplingMode = Texture.BILINEAR_SAMPLINGMODE, engine, reusable, scene) {\n    var _a, _b;\n    super(name, \"volumetricLightScattering\", [\"decay\", \"exposure\", \"weight\", \"meshPositionOnScreen\", \"density\"], [\"lightScatteringSampler\"], ratio.postProcessRatio || ratio, camera, samplingMode, engine, reusable, \"#define NUM_SAMPLES \" + samples);\n    this._screenCoordinates = Vector2.Zero();\n    /**\n     * Custom position of the mesh. Used if \"useCustomMeshPosition\" is set to \"true\"\n     */\n    this.customMeshPosition = Vector3.Zero();\n    /**\n     * Set if the post-process should use a custom position for the light source (true) or the internal mesh position (false)\n     */\n    this.useCustomMeshPosition = false;\n    /**\n     * If the post-process should inverse the light scattering direction\n     */\n    this.invert = true;\n    /**\n     * Array containing the excluded meshes not rendered in the internal pass\n     */\n    this.excludedMeshes = new Array();\n    /**\n     * Array containing the only meshes rendered in the internal pass.\n     * If this array is not empty, only the meshes from this array are rendered in the internal pass\n     */\n    this.includedMeshes = new Array();\n    /**\n     * Controls the overall intensity of the post-process\n     */\n    this.exposure = 0.3;\n    /**\n     * Dissipates each sample's contribution in range [0, 1]\n     */\n    this.decay = 0.96815;\n    /**\n     * Controls the overall intensity of each sample\n     */\n    this.weight = 0.58767;\n    /**\n     * Controls the density of each sample\n     */\n    this.density = 0.926;\n    scene = (_b = (_a = camera === null || camera === void 0 ? void 0 : camera.getScene()) !== null && _a !== void 0 ? _a : scene) !== null && _b !== void 0 ? _b : this._scene; // parameter \"scene\" can be null.\n    engine = scene.getEngine();\n    this._viewPort = new Viewport(0, 0, 1, 1).toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\n    // Configure mesh\n    this.mesh = mesh !== null && mesh !== void 0 ? mesh : VolumetricLightScatteringPostProcess.CreateDefaultMesh(\"VolumetricLightScatteringMesh\", scene);\n    // Configure\n    this._createPass(scene, ratio.passRatio || ratio);\n    this.onActivate = camera => {\n      if (!this.isSupported) {\n        this.dispose(camera);\n      }\n      this.onActivate = null;\n    };\n    this.onApplyObservable.add(effect => {\n      this._updateMeshScreenCoordinates(scene);\n      effect.setTexture(\"lightScatteringSampler\", this._volumetricLightScatteringRTT);\n      effect.setFloat(\"exposure\", this.exposure);\n      effect.setFloat(\"decay\", this.decay);\n      effect.setFloat(\"weight\", this.weight);\n      effect.setFloat(\"density\", this.density);\n      effect.setVector2(\"meshPositionOnScreen\", this._screenCoordinates);\n    });\n  }\n  /**\n   * Returns the string \"VolumetricLightScatteringPostProcess\"\n   * @returns \"VolumetricLightScatteringPostProcess\"\n   */\n  getClassName() {\n    return \"VolumetricLightScatteringPostProcess\";\n  }\n  _isReady(subMesh, useInstances) {\n    var _a;\n    const mesh = subMesh.getMesh();\n    // Render this.mesh as default\n    if (mesh === this.mesh && mesh.material) {\n      return mesh.material.isReady(mesh);\n    }\n    const renderingMaterial = (_a = mesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a === void 0 ? void 0 : _a[this._scene.getEngine().currentRenderPassId];\n    if (renderingMaterial) {\n      return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\n    }\n    const defines = [];\n    const attribs = [VertexBuffer.PositionKind];\n    const material = subMesh.getMaterial();\n    // Alpha test\n    if (material) {\n      if (material.needAlphaTesting()) {\n        defines.push(\"#define ALPHATEST\");\n      }\n      if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n        attribs.push(VertexBuffer.UVKind);\n        defines.push(\"#define UV1\");\n      }\n      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n        attribs.push(VertexBuffer.UV2Kind);\n        defines.push(\"#define UV2\");\n      }\n    }\n    // Bones\n    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    }\n    // Instances\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      MaterialHelper.PushAttributesForInstances(attribs);\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    }\n    // Get correct effect\n    const drawWrapper = subMesh._getDrawWrapper(undefined, true);\n    const cachedDefines = drawWrapper.defines;\n    const join = defines.join(\"\\n\");\n    if (cachedDefines !== join) {\n      drawWrapper.setEffect(mesh.getScene().getEngine().createEffect(\"volumetricLightScatteringPass\", attribs, [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\"], [\"diffuseSampler\"], join, undefined, undefined, undefined, {\n        maxSimultaneousMorphTargets: mesh.numBoneInfluencers\n      }), join);\n    }\n    return drawWrapper.effect.isReady();\n  }\n  /**\n   * Sets the new light position for light scattering effect\n   * @param position The new custom light position\n   */\n  setCustomMeshPosition(position) {\n    this.customMeshPosition = position;\n  }\n  /**\n   * Returns the light position for light scattering effect\n   * @returns Vector3 The custom light position\n   */\n  getCustomMeshPosition() {\n    return this.customMeshPosition;\n  }\n  /**\n   * Disposes the internal assets and detaches the post-process from the camera\n   * @param camera\n   */\n  dispose(camera) {\n    const rttIndex = camera.getScene().customRenderTargets.indexOf(this._volumetricLightScatteringRTT);\n    if (rttIndex !== -1) {\n      camera.getScene().customRenderTargets.splice(rttIndex, 1);\n    }\n    this._volumetricLightScatteringRTT.dispose();\n    super.dispose(camera);\n  }\n  /**\n   * Returns the render target texture used by the post-process\n   * @returns the render target texture used by the post-process\n   */\n  getPass() {\n    return this._volumetricLightScatteringRTT;\n  }\n  // Private methods\n  _meshExcluded(mesh) {\n    if (this.includedMeshes.length > 0 && this.includedMeshes.indexOf(mesh) === -1 || this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\n      return true;\n    }\n    return false;\n  }\n  _createPass(scene, ratio) {\n    const engine = scene.getEngine();\n    this._volumetricLightScatteringRTT = new RenderTargetTexture(\"volumetricLightScatteringMap\", {\n      width: engine.getRenderWidth() * ratio,\n      height: engine.getRenderHeight() * ratio\n    }, scene, false, true, 0);\n    this._volumetricLightScatteringRTT.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._volumetricLightScatteringRTT.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._volumetricLightScatteringRTT.renderList = null;\n    this._volumetricLightScatteringRTT.renderParticles = false;\n    this._volumetricLightScatteringRTT.ignoreCameraViewport = true;\n    const camera = this.getCamera();\n    if (camera) {\n      camera.customRenderTargets.push(this._volumetricLightScatteringRTT);\n    } else {\n      scene.customRenderTargets.push(this._volumetricLightScatteringRTT);\n    }\n    // Custom render function for submeshes\n    const renderSubMesh = subMesh => {\n      var _a;\n      const renderingMesh = subMesh.getRenderingMesh();\n      const effectiveMesh = subMesh.getEffectiveMesh();\n      if (this._meshExcluded(renderingMesh)) {\n        return;\n      }\n      effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n      const material = subMesh.getMaterial();\n      if (!material) {\n        return;\n      }\n      const scene = renderingMesh.getScene();\n      const engine = scene.getEngine();\n      // Culling\n      engine.setState(material.backFaceCulling, undefined, undefined, undefined, material.cullBackFaces);\n      // Managing instances\n      const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n      if (batch.mustReturn) {\n        return;\n      }\n      const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\n      if (this._isReady(subMesh, hardwareInstancedRendering)) {\n        const renderingMaterial = (_a = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a === void 0 ? void 0 : _a[engine.currentRenderPassId];\n        let drawWrapper = subMesh._getDrawWrapper();\n        if (renderingMesh === this.mesh && !drawWrapper) {\n          drawWrapper = material._getDrawWrapper();\n        }\n        if (!drawWrapper) {\n          return;\n        }\n        const effect = drawWrapper.effect;\n        engine.enableEffect(drawWrapper);\n        if (!hardwareInstancedRendering) {\n          renderingMesh._bind(subMesh, effect, material.fillMode);\n        }\n        if (renderingMesh === this.mesh) {\n          material.bind(effectiveMesh.getWorldMatrix(), renderingMesh);\n        } else if (renderingMaterial) {\n          renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh, subMesh);\n        } else {\n          effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n          // Alpha test\n          if (material && material.needAlphaTesting()) {\n            const alphaTexture = material.getAlphaTestTexture();\n            effect.setTexture(\"diffuseSampler\", alphaTexture);\n            if (alphaTexture) {\n              effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n            }\n          }\n          // Bones\n          if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n            effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\n          }\n        }\n        if (hardwareInstancedRendering && renderingMesh.hasThinInstances) {\n          effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\n        }\n        // Draw\n        renderingMesh._processRendering(effectiveMesh, subMesh, effect, Material.TriangleFillMode, batch, hardwareInstancedRendering, (isInstance, world) => {\n          if (!isInstance) {\n            effect.setMatrix(\"world\", world);\n          }\n        });\n      }\n    };\n    // Render target texture callbacks\n    let savedSceneClearColor;\n    const sceneClearColor = new Color4(0.0, 0.0, 0.0, 1.0);\n    this._volumetricLightScatteringRTT.onBeforeRenderObservable.add(() => {\n      savedSceneClearColor = scene.clearColor;\n      scene.clearColor = sceneClearColor;\n    });\n    this._volumetricLightScatteringRTT.onAfterRenderObservable.add(() => {\n      scene.clearColor = savedSceneClearColor;\n    });\n    this._volumetricLightScatteringRTT.customIsReadyFunction = (mesh, refreshRate, preWarm) => {\n      if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\n        for (let i = 0; i < mesh.subMeshes.length; ++i) {\n          const subMesh = mesh.subMeshes[i];\n          const material = subMesh.getMaterial();\n          const renderingMesh = subMesh.getRenderingMesh();\n          if (!material) {\n            continue;\n          }\n          const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n          const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\n          if (!this._isReady(subMesh, hardwareInstancedRendering)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    };\n    this._volumetricLightScatteringRTT.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => {\n      const engine = scene.getEngine();\n      let index;\n      if (depthOnlySubMeshes.length) {\n        engine.setColorWrite(false);\n        for (index = 0; index < depthOnlySubMeshes.length; index++) {\n          renderSubMesh(depthOnlySubMeshes.data[index]);\n        }\n        engine.setColorWrite(true);\n      }\n      for (index = 0; index < opaqueSubMeshes.length; index++) {\n        renderSubMesh(opaqueSubMeshes.data[index]);\n      }\n      for (index = 0; index < alphaTestSubMeshes.length; index++) {\n        renderSubMesh(alphaTestSubMeshes.data[index]);\n      }\n      if (transparentSubMeshes.length) {\n        // Sort sub meshes\n        for (index = 0; index < transparentSubMeshes.length; index++) {\n          const submesh = transparentSubMeshes.data[index];\n          const boundingInfo = submesh.getBoundingInfo();\n          if (boundingInfo && scene.activeCamera) {\n            submesh._alphaIndex = submesh.getMesh().alphaIndex;\n            submesh._distanceToCamera = boundingInfo.boundingSphere.centerWorld.subtract(scene.activeCamera.position).length();\n          }\n        }\n        const sortedArray = transparentSubMeshes.data.slice(0, transparentSubMeshes.length);\n        sortedArray.sort((a, b) => {\n          // Alpha index first\n          if (a._alphaIndex > b._alphaIndex) {\n            return 1;\n          }\n          if (a._alphaIndex < b._alphaIndex) {\n            return -1;\n          }\n          // Then distance to camera\n          if (a._distanceToCamera < b._distanceToCamera) {\n            return 1;\n          }\n          if (a._distanceToCamera > b._distanceToCamera) {\n            return -1;\n          }\n          return 0;\n        });\n        // Render sub meshes\n        engine.setAlphaMode(2);\n        for (index = 0; index < sortedArray.length; index++) {\n          renderSubMesh(sortedArray[index]);\n        }\n        engine.setAlphaMode(0);\n      }\n    };\n  }\n  _updateMeshScreenCoordinates(scene) {\n    const transform = scene.getTransformMatrix();\n    let meshPosition;\n    if (this.useCustomMeshPosition) {\n      meshPosition = this.customMeshPosition;\n    } else if (this.attachedNode) {\n      meshPosition = this.attachedNode.position;\n    } else {\n      meshPosition = this.mesh.parent ? this.mesh.getAbsolutePosition() : this.mesh.position;\n    }\n    const pos = Vector3.Project(meshPosition, Matrix.Identity(), transform, this._viewPort);\n    this._screenCoordinates.x = pos.x / this._viewPort.width;\n    this._screenCoordinates.y = pos.y / this._viewPort.height;\n    if (this.invert) {\n      this._screenCoordinates.y = 1.0 - this._screenCoordinates.y;\n    }\n  }\n  // Static methods\n  /**\n   * Creates a default mesh for the Volumeric Light Scattering post-process\n   * @param name The mesh name\n   * @param scene The scene where to create the mesh\n   * @returns the default mesh\n   */\n  static CreateDefaultMesh(name, scene) {\n    const mesh = CreatePlane(name, {\n      size: 1\n    }, scene);\n    mesh.billboardMode = AbstractMesh.BILLBOARDMODE_ALL;\n    const material = new StandardMaterial(name + \"Material\", scene);\n    material.emissiveColor = new Color3(1, 1, 1);\n    mesh.material = material;\n    return mesh;\n  }\n}\n__decorate([serializeAsVector3()], VolumetricLightScatteringPostProcess.prototype, \"customMeshPosition\", void 0);\n__decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"useCustomMeshPosition\", void 0);\n__decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"invert\", void 0);\n__decorate([serializeAsMeshReference()], VolumetricLightScatteringPostProcess.prototype, \"mesh\", void 0);\n__decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"excludedMeshes\", void 0);\n__decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"includedMeshes\", void 0);\n__decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"exposure\", void 0);\n__decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"decay\", void 0);\n__decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"weight\", void 0);\n__decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"density\", void 0);\nRegisterClass(\"BABYLON.VolumetricLightScatteringPostProcess\", VolumetricLightScatteringPostProcess);","map":{"version":3,"names":["serializeAsVector3","serialize","serializeAsMeshReference","Logger","Vector2","Vector3","Matrix","VertexBuffer","AbstractMesh","Material","MaterialHelper","StandardMaterial","Texture","RenderTargetTexture","PostProcess","CreatePlane","Color4","Color3","Viewport","RegisterClass","VolumetricLightScatteringPostProcess","useDiffuseColor","Warn","constructor","name","ratio","camera","mesh","samples","samplingMode","BILINEAR_SAMPLINGMODE","engine","reusable","scene","postProcessRatio","_screenCoordinates","Zero","customMeshPosition","useCustomMeshPosition","invert","excludedMeshes","Array","includedMeshes","exposure","decay","weight","density","_b","_a","getScene","_scene","getEngine","_viewPort","toGlobal","getRenderWidth","getRenderHeight","CreateDefaultMesh","_createPass","passRatio","onActivate","isSupported","dispose","onApplyObservable","add","effect","_updateMeshScreenCoordinates","setTexture","_volumetricLightScatteringRTT","setFloat","setVector2","getClassName","_isReady","subMesh","useInstances","getMesh","material","isReady","renderingMaterial","_internalAbstractMeshDataInfo","_materialForRenderPass","currentRenderPassId","isReadyForSubMesh","defines","attribs","PositionKind","getMaterial","needAlphaTesting","push","isVerticesDataPresent","UVKind","UV2Kind","useBones","computeBonesUsingShaders","MatricesIndicesKind","MatricesWeightsKind","numBoneInfluencers","skeleton","bones","length","PushAttributesForInstances","getRenderingMesh","hasThinInstances","drawWrapper","_getDrawWrapper","undefined","cachedDefines","join","setEffect","createEffect","maxSimultaneousMorphTargets","setCustomMeshPosition","position","getCustomMeshPosition","rttIndex","customRenderTargets","indexOf","splice","getPass","_meshExcluded","width","height","wrapU","CLAMP_ADDRESSMODE","wrapV","renderList","renderParticles","ignoreCameraViewport","getCamera","renderSubMesh","renderingMesh","effectiveMesh","getEffectiveMesh","_isActiveIntermediate","setState","backFaceCulling","cullBackFaces","batch","_getInstancesRenderList","_id","getReplacementMesh","mustReturn","hardwareInstancedRendering","getCaps","instancedArrays","visibleInstances","enableEffect","_bind","fillMode","bind","getWorldMatrix","bindForSubMesh","setMatrix","getTransformMatrix","alphaTexture","getAlphaTestTexture","getTextureMatrix","setMatrices","getTransformMatrices","_processRendering","TriangleFillMode","isInstance","world","savedSceneClearColor","sceneClearColor","onBeforeRenderObservable","clearColor","onAfterRenderObservable","customIsReadyFunction","refreshRate","preWarm","subMeshes","i","customRenderFunction","opaqueSubMeshes","alphaTestSubMeshes","transparentSubMeshes","depthOnlySubMeshes","index","setColorWrite","data","submesh","boundingInfo","getBoundingInfo","activeCamera","_alphaIndex","alphaIndex","_distanceToCamera","boundingSphere","centerWorld","subtract","sortedArray","slice","sort","a","b","setAlphaMode","transform","meshPosition","attachedNode","parent","getAbsolutePosition","pos","Project","Identity","x","y","size","billboardMode","BILLBOARDMODE_ALL","emissiveColor","__decorate"],"sources":["../../../../dev/core/src/PostProcesses/volumetricLightScatteringPostProcess.ts"],"sourcesContent":["import { serializeAsVector3, serialize, serializeAsMeshReference } from \"../Misc/decorators\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Vector2, Vector3, Matrix } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Scene } from \"../scene\";\r\n\r\nimport { CreatePlane } from \"../Meshes/Builders/planeBuilder\";\r\n\r\nimport \"../Shaders/depth.vertex\";\r\nimport \"../Shaders/volumetricLightScattering.fragment\";\r\nimport \"../Shaders/volumetricLightScatteringPass.vertex\";\r\nimport \"../Shaders/volumetricLightScatteringPass.fragment\";\r\nimport { Color4, Color3 } from \"../Maths/math.color\";\r\nimport { Viewport } from \"../Maths/math.viewport\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { Nullable } from \"../types\";\r\n\r\nimport type { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n *  Inspired by https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-13-volumetric-light-scattering-post-process\r\n */\r\nexport class VolumetricLightScatteringPostProcess extends PostProcess {\r\n    // Members\r\n    private _volumetricLightScatteringRTT: RenderTargetTexture;\r\n    private _viewPort: Viewport;\r\n    private _screenCoordinates: Vector2 = Vector2.Zero();\r\n\r\n    /**\r\n     * If not undefined, the mesh position is computed from the attached node position\r\n     */\r\n    public attachedNode: { position: Vector3 };\r\n\r\n    /**\r\n     * Custom position of the mesh. Used if \"useCustomMeshPosition\" is set to \"true\"\r\n     */\r\n    @serializeAsVector3()\r\n    public customMeshPosition: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Set if the post-process should use a custom position for the light source (true) or the internal mesh position (false)\r\n     */\r\n    @serialize()\r\n    public useCustomMeshPosition: boolean = false;\r\n\r\n    /**\r\n     * If the post-process should inverse the light scattering direction\r\n     */\r\n    @serialize()\r\n    public invert: boolean = true;\r\n\r\n    /**\r\n     * The internal mesh used by the post-process\r\n     */\r\n    @serializeAsMeshReference()\r\n    public mesh: Mesh;\r\n\r\n    /**\r\n     * @internal\r\n     * VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\r\n     */\r\n    public get useDiffuseColor(): boolean {\r\n        Logger.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\");\r\n        return false;\r\n    }\r\n\r\n    public set useDiffuseColor(useDiffuseColor: boolean) {\r\n        Logger.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\");\r\n    }\r\n\r\n    /**\r\n     * Array containing the excluded meshes not rendered in the internal pass\r\n     */\r\n    @serialize()\r\n    public excludedMeshes = new Array<AbstractMesh>();\r\n\r\n    /**\r\n     * Array containing the only meshes rendered in the internal pass.\r\n     * If this array is not empty, only the meshes from this array are rendered in the internal pass\r\n     */\r\n    @serialize()\r\n    public includedMeshes = new Array<AbstractMesh>();\r\n\r\n    /**\r\n     * Controls the overall intensity of the post-process\r\n     */\r\n    @serialize()\r\n    public exposure = 0.3;\r\n\r\n    /**\r\n     * Dissipates each sample's contribution in range [0, 1]\r\n     */\r\n    @serialize()\r\n    public decay = 0.96815;\r\n\r\n    /**\r\n     * Controls the overall intensity of each sample\r\n     */\r\n    @serialize()\r\n    public weight = 0.58767;\r\n\r\n    /**\r\n     * Controls the density of each sample\r\n     */\r\n    @serialize()\r\n    public density = 0.926;\r\n\r\n    /**\r\n     * @constructor\r\n     * @param name The post-process name\r\n     * @param ratio The size of the post-process and/or internal pass (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)\r\n     * @param camera The camera that the post-process will be attached to\r\n     * @param mesh The mesh used to create the light scattering\r\n     * @param samples The post-process quality, default 100\r\n     * @param samplingMode The post-process filtering mode\r\n     * @param engine The babylon engine\r\n     * @param reusable If the post-process is reusable\r\n     * @param scene The constructor needs a scene reference to initialize internal components. If \"camera\" is null a \"scene\" must be provided\r\n     */\r\n    constructor(\r\n        name: string,\r\n        ratio: any,\r\n        camera: Nullable<Camera>,\r\n        mesh?: Mesh,\r\n        samples: number = 100,\r\n        samplingMode: number = Texture.BILINEAR_SAMPLINGMODE,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        scene?: Scene\r\n    ) {\r\n        super(\r\n            name,\r\n            \"volumetricLightScattering\",\r\n            [\"decay\", \"exposure\", \"weight\", \"meshPositionOnScreen\", \"density\"],\r\n            [\"lightScatteringSampler\"],\r\n            ratio.postProcessRatio || ratio,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            \"#define NUM_SAMPLES \" + samples\r\n        );\r\n        scene = camera?.getScene() ?? scene ?? this._scene; // parameter \"scene\" can be null.\r\n\r\n        engine = scene.getEngine();\r\n        this._viewPort = new Viewport(0, 0, 1, 1).toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\r\n\r\n        // Configure mesh\r\n        this.mesh = mesh ?? VolumetricLightScatteringPostProcess.CreateDefaultMesh(\"VolumetricLightScatteringMesh\", scene);\r\n\r\n        // Configure\r\n        this._createPass(scene, ratio.passRatio || ratio);\r\n\r\n        this.onActivate = (camera: Camera) => {\r\n            if (!this.isSupported) {\r\n                this.dispose(camera);\r\n            }\r\n\r\n            this.onActivate = null;\r\n        };\r\n\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            this._updateMeshScreenCoordinates(<Scene>scene);\r\n\r\n            effect.setTexture(\"lightScatteringSampler\", this._volumetricLightScatteringRTT);\r\n            effect.setFloat(\"exposure\", this.exposure);\r\n            effect.setFloat(\"decay\", this.decay);\r\n            effect.setFloat(\"weight\", this.weight);\r\n            effect.setFloat(\"density\", this.density);\r\n            effect.setVector2(\"meshPositionOnScreen\", this._screenCoordinates);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"VolumetricLightScatteringPostProcess\"\r\n     * @returns \"VolumetricLightScatteringPostProcess\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"VolumetricLightScatteringPostProcess\";\r\n    }\r\n\r\n    private _isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        const mesh = subMesh.getMesh();\r\n\r\n        // Render this.mesh as default\r\n        if (mesh === this.mesh && mesh.material) {\r\n            return mesh.material.isReady(mesh);\r\n        }\r\n\r\n        const renderingMaterial = mesh._internalAbstractMeshDataInfo._materialForRenderPass?.[this._scene.getEngine().currentRenderPassId];\r\n\r\n        if (renderingMaterial) {\r\n            return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\r\n        }\r\n\r\n        const defines = [];\r\n        const attribs = [VertexBuffer.PositionKind];\r\n        const material: any = subMesh.getMaterial();\r\n\r\n        // Alpha test\r\n        if (material) {\r\n            if (material.needAlphaTesting()) {\r\n                defines.push(\"#define ALPHATEST\");\r\n            }\r\n\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n                defines.push(\"#define UV1\");\r\n            }\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n                defines.push(\"#define UV2\");\r\n            }\r\n        }\r\n\r\n        // Bones\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs);\r\n            if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        // Get correct effect\r\n        const drawWrapper = subMesh._getDrawWrapper(undefined, true)!;\r\n        const cachedDefines = drawWrapper.defines;\r\n        const join = defines.join(\"\\n\");\r\n        if (cachedDefines !== join) {\r\n            drawWrapper.setEffect(\r\n                mesh\r\n                    .getScene()\r\n                    .getEngine()\r\n                    .createEffect(\r\n                        \"volumetricLightScatteringPass\",\r\n                        attribs,\r\n                        [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\"],\r\n                        [\"diffuseSampler\"],\r\n                        join,\r\n                        undefined,\r\n                        undefined,\r\n                        undefined,\r\n                        { maxSimultaneousMorphTargets: mesh.numBoneInfluencers }\r\n                    ),\r\n                join\r\n            );\r\n        }\r\n\r\n        return drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    /**\r\n     * Sets the new light position for light scattering effect\r\n     * @param position The new custom light position\r\n     */\r\n    public setCustomMeshPosition(position: Vector3): void {\r\n        this.customMeshPosition = position;\r\n    }\r\n\r\n    /**\r\n     * Returns the light position for light scattering effect\r\n     * @returns Vector3 The custom light position\r\n     */\r\n    public getCustomMeshPosition(): Vector3 {\r\n        return this.customMeshPosition;\r\n    }\r\n\r\n    /**\r\n     * Disposes the internal assets and detaches the post-process from the camera\r\n     * @param camera\r\n     */\r\n    public dispose(camera: Camera): void {\r\n        const rttIndex = camera.getScene().customRenderTargets.indexOf(this._volumetricLightScatteringRTT);\r\n        if (rttIndex !== -1) {\r\n            camera.getScene().customRenderTargets.splice(rttIndex, 1);\r\n        }\r\n\r\n        this._volumetricLightScatteringRTT.dispose();\r\n        super.dispose(camera);\r\n    }\r\n\r\n    /**\r\n     * Returns the render target texture used by the post-process\r\n     * @returns the render target texture used by the post-process\r\n     */\r\n    public getPass(): RenderTargetTexture {\r\n        return this._volumetricLightScatteringRTT;\r\n    }\r\n\r\n    // Private methods\r\n    private _meshExcluded(mesh: AbstractMesh) {\r\n        if ((this.includedMeshes.length > 0 && this.includedMeshes.indexOf(mesh) === -1) || (this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private _createPass(scene: Scene, ratio: number): void {\r\n        const engine = scene.getEngine();\r\n\r\n        this._volumetricLightScatteringRTT = new RenderTargetTexture(\r\n            \"volumetricLightScatteringMap\",\r\n            { width: engine.getRenderWidth() * ratio, height: engine.getRenderHeight() * ratio },\r\n            scene,\r\n            false,\r\n            true,\r\n            Constants.TEXTURETYPE_UNSIGNED_INT\r\n        );\r\n        this._volumetricLightScatteringRTT.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._volumetricLightScatteringRTT.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._volumetricLightScatteringRTT.renderList = null;\r\n        this._volumetricLightScatteringRTT.renderParticles = false;\r\n        this._volumetricLightScatteringRTT.ignoreCameraViewport = true;\r\n\r\n        const camera = this.getCamera();\r\n        if (camera) {\r\n            camera.customRenderTargets.push(this._volumetricLightScatteringRTT);\r\n        } else {\r\n            scene.customRenderTargets.push(this._volumetricLightScatteringRTT);\r\n        }\r\n\r\n        // Custom render function for submeshes\r\n        const renderSubMesh = (subMesh: SubMesh): void => {\r\n            const renderingMesh = subMesh.getRenderingMesh();\r\n            const effectiveMesh = subMesh.getEffectiveMesh();\r\n            if (this._meshExcluded(renderingMesh)) {\r\n                return;\r\n            }\r\n\r\n            effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n\r\n            const material = subMesh.getMaterial();\r\n\r\n            if (!material) {\r\n                return;\r\n            }\r\n\r\n            const scene = renderingMesh.getScene();\r\n            const engine = scene.getEngine();\r\n\r\n            // Culling\r\n            engine.setState(material.backFaceCulling, undefined, undefined, undefined, material.cullBackFaces);\r\n\r\n            // Managing instances\r\n            const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n\r\n            if (batch.mustReturn) {\r\n                return;\r\n            }\r\n\r\n            const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\r\n\r\n            if (this._isReady(subMesh, hardwareInstancedRendering)) {\r\n                const renderingMaterial = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n                let drawWrapper = subMesh._getDrawWrapper();\r\n                if (renderingMesh === this.mesh && !drawWrapper) {\r\n                    drawWrapper = material._getDrawWrapper();\r\n                }\r\n\r\n                if (!drawWrapper) {\r\n                    return;\r\n                }\r\n\r\n                const effect = drawWrapper.effect!;\r\n\r\n                engine.enableEffect(drawWrapper);\r\n                if (!hardwareInstancedRendering) {\r\n                    renderingMesh._bind(subMesh, effect, material.fillMode);\r\n                }\r\n\r\n                if (renderingMesh === this.mesh) {\r\n                    material.bind(effectiveMesh.getWorldMatrix(), renderingMesh);\r\n                } else if (renderingMaterial) {\r\n                    renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh as Mesh, subMesh);\r\n                } else {\r\n                    effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n                    // Alpha test\r\n                    if (material && material.needAlphaTesting()) {\r\n                        const alphaTexture = material.getAlphaTestTexture();\r\n\r\n                        effect.setTexture(\"diffuseSampler\", alphaTexture);\r\n\r\n                        if (alphaTexture) {\r\n                            effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\r\n                        }\r\n                    }\r\n\r\n                    // Bones\r\n                    if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\r\n                        effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\r\n                    }\r\n                }\r\n\r\n                if (hardwareInstancedRendering && renderingMesh.hasThinInstances) {\r\n                    effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\r\n                }\r\n\r\n                // Draw\r\n                renderingMesh._processRendering(effectiveMesh, subMesh, effect, Material.TriangleFillMode, batch, hardwareInstancedRendering, (isInstance, world) => {\r\n                    if (!isInstance) {\r\n                        effect.setMatrix(\"world\", world);\r\n                    }\r\n                });\r\n            }\r\n        };\r\n\r\n        // Render target texture callbacks\r\n        let savedSceneClearColor: Color4;\r\n        const sceneClearColor = new Color4(0.0, 0.0, 0.0, 1.0);\r\n\r\n        this._volumetricLightScatteringRTT.onBeforeRenderObservable.add((): void => {\r\n            savedSceneClearColor = scene.clearColor;\r\n            scene.clearColor = sceneClearColor;\r\n        });\r\n\r\n        this._volumetricLightScatteringRTT.onAfterRenderObservable.add((): void => {\r\n            scene.clearColor = savedSceneClearColor;\r\n        });\r\n\r\n        this._volumetricLightScatteringRTT.customIsReadyFunction = (mesh: AbstractMesh, refreshRate: number, preWarm?: boolean) => {\r\n            if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\r\n                for (let i = 0; i < mesh.subMeshes.length; ++i) {\r\n                    const subMesh = mesh.subMeshes[i];\r\n                    const material = subMesh.getMaterial();\r\n                    const renderingMesh = subMesh.getRenderingMesh();\r\n\r\n                    if (!material) {\r\n                        continue;\r\n                    }\r\n\r\n                    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n                    const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\r\n\r\n                    if (!this._isReady(subMesh, hardwareInstancedRendering)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        };\r\n\r\n        this._volumetricLightScatteringRTT.customRenderFunction = (\r\n            opaqueSubMeshes: SmartArray<SubMesh>,\r\n            alphaTestSubMeshes: SmartArray<SubMesh>,\r\n            transparentSubMeshes: SmartArray<SubMesh>,\r\n            depthOnlySubMeshes: SmartArray<SubMesh>\r\n        ): void => {\r\n            const engine = scene.getEngine();\r\n            let index: number;\r\n\r\n            if (depthOnlySubMeshes.length) {\r\n                engine.setColorWrite(false);\r\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\r\n                    renderSubMesh(depthOnlySubMeshes.data[index]);\r\n                }\r\n                engine.setColorWrite(true);\r\n            }\r\n\r\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\r\n                renderSubMesh(opaqueSubMeshes.data[index]);\r\n            }\r\n\r\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\r\n                renderSubMesh(alphaTestSubMeshes.data[index]);\r\n            }\r\n\r\n            if (transparentSubMeshes.length) {\r\n                // Sort sub meshes\r\n                for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                    const submesh = transparentSubMeshes.data[index];\r\n                    const boundingInfo = submesh.getBoundingInfo();\r\n\r\n                    if (boundingInfo && scene.activeCamera) {\r\n                        submesh._alphaIndex = submesh.getMesh().alphaIndex;\r\n                        submesh._distanceToCamera = boundingInfo.boundingSphere.centerWorld.subtract(scene.activeCamera.position).length();\r\n                    }\r\n                }\r\n\r\n                const sortedArray = transparentSubMeshes.data.slice(0, transparentSubMeshes.length);\r\n                sortedArray.sort((a, b) => {\r\n                    // Alpha index first\r\n                    if (a._alphaIndex > b._alphaIndex) {\r\n                        return 1;\r\n                    }\r\n                    if (a._alphaIndex < b._alphaIndex) {\r\n                        return -1;\r\n                    }\r\n\r\n                    // Then distance to camera\r\n                    if (a._distanceToCamera < b._distanceToCamera) {\r\n                        return 1;\r\n                    }\r\n                    if (a._distanceToCamera > b._distanceToCamera) {\r\n                        return -1;\r\n                    }\r\n\r\n                    return 0;\r\n                });\r\n\r\n                // Render sub meshes\r\n                engine.setAlphaMode(Constants.ALPHA_COMBINE);\r\n                for (index = 0; index < sortedArray.length; index++) {\r\n                    renderSubMesh(sortedArray[index]);\r\n                }\r\n                engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n            }\r\n        };\r\n    }\r\n\r\n    private _updateMeshScreenCoordinates(scene: Scene): void {\r\n        const transform = scene.getTransformMatrix();\r\n        let meshPosition: Vector3;\r\n\r\n        if (this.useCustomMeshPosition) {\r\n            meshPosition = this.customMeshPosition;\r\n        } else if (this.attachedNode) {\r\n            meshPosition = this.attachedNode.position;\r\n        } else {\r\n            meshPosition = this.mesh.parent ? this.mesh.getAbsolutePosition() : this.mesh.position;\r\n        }\r\n\r\n        const pos = Vector3.Project(meshPosition, Matrix.Identity(), transform, this._viewPort);\r\n\r\n        this._screenCoordinates.x = pos.x / this._viewPort.width;\r\n        this._screenCoordinates.y = pos.y / this._viewPort.height;\r\n\r\n        if (this.invert) {\r\n            this._screenCoordinates.y = 1.0 - this._screenCoordinates.y;\r\n        }\r\n    }\r\n\r\n    // Static methods\r\n    /**\r\n     * Creates a default mesh for the Volumeric Light Scattering post-process\r\n     * @param name The mesh name\r\n     * @param scene The scene where to create the mesh\r\n     * @returns the default mesh\r\n     */\r\n    public static CreateDefaultMesh(name: string, scene: Scene): Mesh {\r\n        const mesh = CreatePlane(name, { size: 1 }, scene);\r\n        mesh.billboardMode = AbstractMesh.BILLBOARDMODE_ALL;\r\n\r\n        const material = new StandardMaterial(name + \"Material\", scene);\r\n        material.emissiveColor = new Color3(1, 1, 1);\r\n\r\n        mesh.material = material;\r\n\r\n        return mesh;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.VolumetricLightScatteringPostProcess\", VolumetricLightScatteringPostProcess);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}