{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Material } from \"./material.js\";\nimport { MaterialPluginEvent } from \"./materialPluginEvent.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor.js\";\nimport { ShaderLanguage } from \"./shaderLanguage.js\";\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst rxOption = new RegExp(\"^([gimus]+)!\");\n/**\n * Class that manages the plugins of a material\n * @since 5.0\n */\nexport class MaterialPluginManager {\n  /**\n   * Creates a new instance of the plugin manager\n   * @param material material that this manager will manage the plugins for\n   */\n  constructor(material) {\n    /** @internal */\n    this._plugins = [];\n    this._activePlugins = [];\n    this._activePluginsForExtraEvents = [];\n    this._material = material;\n    this._scene = material.getScene();\n    this._engine = this._scene.getEngine();\n  }\n  /**\n   * @internal\n   */\n  _addPlugin(plugin) {\n    for (let i = 0; i < this._plugins.length; ++i) {\n      if (this._plugins[i].name === plugin.name) {\n        return false;\n      }\n    }\n    if (this._material._uniformBufferLayoutBuilt) {\n      throw `The plugin \"${plugin.name}\" can't be added to the material \"${this._material.name}\" because this material has already been used for rendering! Please add plugins to materials before any rendering with this material occurs.`;\n    }\n    const pluginClassName = plugin.getClassName();\n    if (!MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]) {\n      MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName] = \"MATERIALPLUGIN_\" + ++MaterialPluginManager._MaterialPluginCounter;\n    }\n    this._material._callbackPluginEventGeneric = this._handlePluginEvent.bind(this);\n    this._plugins.push(plugin);\n    this._plugins.sort((a, b) => a.priority - b.priority);\n    this._codeInjectionPoints = {};\n    const defineNamesFromPlugins = {};\n    defineNamesFromPlugins[MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]] = {\n      type: \"boolean\",\n      default: true\n    };\n    for (const plugin of this._plugins) {\n      plugin.collectDefines(defineNamesFromPlugins);\n      this._collectPointNames(\"vertex\", plugin.getCustomCode(\"vertex\"));\n      this._collectPointNames(\"fragment\", plugin.getCustomCode(\"fragment\"));\n    }\n    this._defineNamesFromPlugins = defineNamesFromPlugins;\n    return true;\n  }\n  /**\n   * @internal\n   */\n  _activatePlugin(plugin) {\n    if (this._activePlugins.indexOf(plugin) === -1) {\n      this._activePlugins.push(plugin);\n      this._activePlugins.sort((a, b) => a.priority - b.priority);\n      this._material._callbackPluginEventIsReadyForSubMesh = this._handlePluginEventIsReadyForSubMesh.bind(this);\n      this._material._callbackPluginEventPrepareDefinesBeforeAttributes = this._handlePluginEventPrepareDefinesBeforeAttributes.bind(this);\n      this._material._callbackPluginEventPrepareDefines = this._handlePluginEventPrepareDefines.bind(this);\n      this._material._callbackPluginEventBindForSubMesh = this._handlePluginEventBindForSubMesh.bind(this);\n      if (plugin.registerForExtraEvents) {\n        this._activePluginsForExtraEvents.push(plugin);\n        this._activePluginsForExtraEvents.sort((a, b) => a.priority - b.priority);\n        this._material._callbackPluginEventHasRenderTargetTextures = this._handlePluginEventHasRenderTargetTextures.bind(this);\n        this._material._callbackPluginEventFillRenderTargetTextures = this._handlePluginEventFillRenderTargetTextures.bind(this);\n        this._material._callbackPluginEventHardBindForSubMesh = this._handlePluginEventHardBindForSubMesh.bind(this);\n      }\n    }\n  }\n  /**\n   * Gets a plugin from the list of plugins managed by this manager\n   * @param name name of the plugin\n   * @returns the plugin if found, else null\n   */\n  getPlugin(name) {\n    for (let i = 0; i < this._plugins.length; ++i) {\n      if (this._plugins[i].name === name) {\n        return this._plugins[i];\n      }\n    }\n    return null;\n  }\n  _handlePluginEventIsReadyForSubMesh(eventData) {\n    let isReady = true;\n    for (const plugin of this._activePlugins) {\n      isReady = isReady && plugin.isReadyForSubMesh(eventData.defines, this._scene, this._engine, eventData.subMesh);\n    }\n    eventData.isReadyForSubMesh = isReady;\n  }\n  _handlePluginEventPrepareDefinesBeforeAttributes(eventData) {\n    for (const plugin of this._activePlugins) {\n      plugin.prepareDefinesBeforeAttributes(eventData.defines, this._scene, eventData.mesh);\n    }\n  }\n  _handlePluginEventPrepareDefines(eventData) {\n    for (const plugin of this._activePlugins) {\n      plugin.prepareDefines(eventData.defines, this._scene, eventData.mesh);\n    }\n  }\n  _handlePluginEventHardBindForSubMesh(eventData) {\n    for (const plugin of this._activePluginsForExtraEvents) {\n      plugin.hardBindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);\n    }\n  }\n  _handlePluginEventBindForSubMesh(eventData) {\n    for (const plugin of this._activePlugins) {\n      plugin.bindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);\n    }\n  }\n  _handlePluginEventHasRenderTargetTextures(eventData) {\n    let hasRenderTargetTextures = false;\n    for (const plugin of this._activePluginsForExtraEvents) {\n      hasRenderTargetTextures = plugin.hasRenderTargetTextures();\n      if (hasRenderTargetTextures) {\n        break;\n      }\n    }\n    eventData.hasRenderTargetTextures = hasRenderTargetTextures;\n  }\n  _handlePluginEventFillRenderTargetTextures(eventData) {\n    for (const plugin of this._activePluginsForExtraEvents) {\n      plugin.fillRenderTargetTextures(eventData.renderTargets);\n    }\n  }\n  _handlePluginEvent(id, info) {\n    var _a;\n    switch (id) {\n      case MaterialPluginEvent.GetActiveTextures:\n        {\n          const eventData = info;\n          for (const plugin of this._activePlugins) {\n            plugin.getActiveTextures(eventData.activeTextures);\n          }\n          break;\n        }\n      case MaterialPluginEvent.GetAnimatables:\n        {\n          const eventData = info;\n          for (const plugin of this._activePlugins) {\n            plugin.getAnimatables(eventData.animatables);\n          }\n          break;\n        }\n      case MaterialPluginEvent.HasTexture:\n        {\n          const eventData = info;\n          let hasTexture = false;\n          for (const plugin of this._activePlugins) {\n            hasTexture = plugin.hasTexture(eventData.texture);\n            if (hasTexture) {\n              break;\n            }\n          }\n          eventData.hasTexture = hasTexture;\n          break;\n        }\n      case MaterialPluginEvent.Disposed:\n        {\n          const eventData = info;\n          for (const plugin of this._plugins) {\n            plugin.dispose(eventData.forceDisposeTextures);\n          }\n          break;\n        }\n      case MaterialPluginEvent.GetDefineNames:\n        {\n          const eventData = info;\n          eventData.defineNames = this._defineNamesFromPlugins;\n          break;\n        }\n      case MaterialPluginEvent.PrepareEffect:\n        {\n          const eventData = info;\n          for (const plugin of this._activePlugins) {\n            eventData.fallbackRank = plugin.addFallbacks(eventData.defines, eventData.fallbacks, eventData.fallbackRank);\n            plugin.getAttributes(eventData.attributes, this._scene, eventData.mesh);\n          }\n          if (this._uniformList.length > 0) {\n            eventData.uniforms.push(...this._uniformList);\n          }\n          if (this._samplerList.length > 0) {\n            eventData.samplers.push(...this._samplerList);\n          }\n          if (this._uboList.length > 0) {\n            eventData.uniformBuffersNames.push(...this._uboList);\n          }\n          eventData.customCode = this._injectCustomCode(eventData, eventData.customCode);\n          break;\n        }\n      case MaterialPluginEvent.PrepareUniformBuffer:\n        {\n          const eventData = info;\n          this._uboDeclaration = \"\";\n          this._vertexDeclaration = \"\";\n          this._fragmentDeclaration = \"\";\n          this._uniformList = [];\n          this._samplerList = [];\n          this._uboList = [];\n          for (const plugin of this._plugins) {\n            const uniforms = plugin.getUniforms();\n            if (uniforms) {\n              if (uniforms.ubo) {\n                for (const uniform of uniforms.ubo) {\n                  if (uniform.size && uniform.type) {\n                    const arraySize = (_a = uniform.arraySize) !== null && _a !== void 0 ? _a : 0;\n                    eventData.ubo.addUniform(uniform.name, uniform.size, arraySize);\n                    this._uboDeclaration += `${uniform.type} ${uniform.name}${arraySize > 0 ? `[${arraySize}]` : \"\"};\\n`;\n                  }\n                  this._uniformList.push(uniform.name);\n                }\n              }\n              if (uniforms.vertex) {\n                this._vertexDeclaration += uniforms.vertex + \"\\n\";\n              }\n              if (uniforms.fragment) {\n                this._fragmentDeclaration += uniforms.fragment + \"\\n\";\n              }\n            }\n            plugin.getSamplers(this._samplerList);\n            plugin.getUniformBuffersNames(this._uboList);\n          }\n          break;\n        }\n    }\n  }\n  _collectPointNames(shaderType, customCode) {\n    if (!customCode) {\n      return;\n    }\n    for (const pointName in customCode) {\n      if (!this._codeInjectionPoints[shaderType]) {\n        this._codeInjectionPoints[shaderType] = {};\n      }\n      this._codeInjectionPoints[shaderType][pointName] = true;\n    }\n  }\n  _injectCustomCode(eventData, existingCallback) {\n    return (shaderType, code) => {\n      var _a, _b;\n      if (existingCallback) {\n        code = existingCallback(shaderType, code);\n      }\n      if (this._uboDeclaration) {\n        code = code.replace(\"#define ADDITIONAL_UBO_DECLARATION\", this._uboDeclaration);\n      }\n      if (this._vertexDeclaration) {\n        code = code.replace(\"#define ADDITIONAL_VERTEX_DECLARATION\", this._vertexDeclaration);\n      }\n      if (this._fragmentDeclaration) {\n        code = code.replace(\"#define ADDITIONAL_FRAGMENT_DECLARATION\", this._fragmentDeclaration);\n      }\n      const points = (_a = this._codeInjectionPoints) === null || _a === void 0 ? void 0 : _a[shaderType];\n      if (!points) {\n        return code;\n      }\n      let processorOptions = null;\n      for (let pointName in points) {\n        let injectedCode = \"\";\n        for (const plugin of this._activePlugins) {\n          let customCode = (_b = plugin.getCustomCode(shaderType)) === null || _b === void 0 ? void 0 : _b[pointName];\n          if (!customCode) {\n            continue;\n          }\n          if (plugin.resolveIncludes) {\n            if (processorOptions === null) {\n              const shaderLanguage = ShaderLanguage.GLSL;\n              processorOptions = {\n                defines: [],\n                indexParameters: eventData.indexParameters,\n                isFragment: false,\n                shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,\n                processor: undefined,\n                supportsUniformBuffers: this._engine.supportsUniformBuffers,\n                shadersRepository: ShaderStore.GetShadersRepository(shaderLanguage),\n                includesShadersStore: ShaderStore.GetIncludesShadersStore(shaderLanguage),\n                version: undefined,\n                platformName: this._engine.shaderPlatformName,\n                processingContext: undefined,\n                isNDCHalfZRange: this._engine.isNDCHalfZRange,\n                useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\n                processCodeAfterIncludes: undefined // not used by _ProcessIncludes\n              };\n            }\n\n            processorOptions.isFragment = shaderType === \"fragment\";\n            ShaderProcessor._ProcessIncludes(customCode, processorOptions, code => customCode = code);\n          }\n          injectedCode += customCode + \"\\n\";\n        }\n        if (injectedCode.length > 0) {\n          if (pointName.charAt(0) === \"!\") {\n            // pointName is a regular expression\n            pointName = pointName.substring(1);\n            let regexFlags = \"g\";\n            if (pointName.charAt(0) === \"!\") {\n              // no flags\n              regexFlags = \"\";\n              pointName = pointName.substring(1);\n            } else {\n              // get the flag(s)\n              const matchOption = rxOption.exec(pointName);\n              if (matchOption && matchOption.length >= 2) {\n                regexFlags = matchOption[1];\n                pointName = pointName.substring(regexFlags.length + 1);\n              }\n            }\n            if (regexFlags.indexOf(\"g\") < 0) {\n              // we force the \"g\" flag so that the regexp object is stateful!\n              regexFlags += \"g\";\n            }\n            const sourceCode = code;\n            const rx = new RegExp(pointName, regexFlags);\n            let match = rx.exec(sourceCode);\n            while (match !== null) {\n              let newCode = injectedCode;\n              for (let i = 0; i < match.length; ++i) {\n                newCode = newCode.replace(\"$\" + i, match[i]);\n              }\n              code = code.replace(match[0], newCode);\n              match = rx.exec(sourceCode);\n            }\n          } else {\n            const fullPointName = \"#define \" + pointName;\n            code = code.replace(fullPointName, \"\\n\" + injectedCode + \"\\n\" + fullPointName);\n          }\n        }\n      }\n      return code;\n    };\n  }\n}\n/** Map a plugin class name to a #define name (used in the vertex/fragment shaders as a marker of the plugin usage) */\nMaterialPluginManager._MaterialPluginClassToMainDefine = {};\nMaterialPluginManager._MaterialPluginCounter = 0;\n(() => {\n  EngineStore.OnEnginesDisposedObservable.add(() => {\n    UnregisterAllMaterialPlugins();\n  });\n})();\nconst plugins = [];\nlet inited = false;\nlet observer = null;\n/**\n * Registers a new material plugin through a factory, or updates it. This makes the plugin available to all materials instantiated after its registration.\n * @param pluginName The plugin name\n * @param factory The factory function which allows to create the plugin\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function RegisterMaterialPlugin(pluginName, factory) {\n  if (!inited) {\n    observer = Material.OnEventObservable.add(material => {\n      for (const [, factory] of plugins) {\n        factory(material);\n      }\n    }, MaterialPluginEvent.Created);\n    inited = true;\n  }\n  const existing = plugins.filter(([name, _factory]) => name === pluginName);\n  if (existing.length > 0) {\n    existing[0][1] = factory;\n  } else {\n    plugins.push([pluginName, factory]);\n  }\n}\n/**\n * Removes a material plugin from the list of global plugins.\n * @param pluginName The plugin name\n * @returns true if the plugin has been removed, else false\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function UnregisterMaterialPlugin(pluginName) {\n  for (let i = 0; i < plugins.length; ++i) {\n    if (plugins[i][0] === pluginName) {\n      plugins.splice(i, 1);\n      if (plugins.length === 0) {\n        UnregisterAllMaterialPlugins();\n      }\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * Clear the list of global material plugins\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function UnregisterAllMaterialPlugins() {\n  plugins.length = 0;\n  inited = false;\n  Material.OnEventObservable.remove(observer);\n  observer = null;\n}","map":{"version":3,"names":["Material","MaterialPluginEvent","EngineStore","ShaderProcessor","ShaderLanguage","ShaderStore","rxOption","RegExp","MaterialPluginManager","constructor","material","_plugins","_activePlugins","_activePluginsForExtraEvents","_material","_scene","getScene","_engine","getEngine","_addPlugin","plugin","i","length","name","_uniformBufferLayoutBuilt","pluginClassName","getClassName","_MaterialPluginClassToMainDefine","_MaterialPluginCounter","_callbackPluginEventGeneric","_handlePluginEvent","bind","push","sort","a","b","priority","_codeInjectionPoints","defineNamesFromPlugins","type","default","collectDefines","_collectPointNames","getCustomCode","_defineNamesFromPlugins","_activatePlugin","indexOf","_callbackPluginEventIsReadyForSubMesh","_handlePluginEventIsReadyForSubMesh","_callbackPluginEventPrepareDefinesBeforeAttributes","_handlePluginEventPrepareDefinesBeforeAttributes","_callbackPluginEventPrepareDefines","_handlePluginEventPrepareDefines","_callbackPluginEventBindForSubMesh","_handlePluginEventBindForSubMesh","registerForExtraEvents","_callbackPluginEventHasRenderTargetTextures","_handlePluginEventHasRenderTargetTextures","_callbackPluginEventFillRenderTargetTextures","_handlePluginEventFillRenderTargetTextures","_callbackPluginEventHardBindForSubMesh","_handlePluginEventHardBindForSubMesh","getPlugin","eventData","isReady","isReadyForSubMesh","defines","subMesh","prepareDefinesBeforeAttributes","mesh","prepareDefines","hardBindForSubMesh","_uniformBuffer","bindForSubMesh","hasRenderTargetTextures","fillRenderTargetTextures","renderTargets","id","info","GetActiveTextures","getActiveTextures","activeTextures","GetAnimatables","getAnimatables","animatables","HasTexture","hasTexture","texture","Disposed","dispose","forceDisposeTextures","GetDefineNames","defineNames","PrepareEffect","fallbackRank","addFallbacks","fallbacks","getAttributes","attributes","_uniformList","uniforms","_samplerList","samplers","_uboList","uniformBuffersNames","customCode","_injectCustomCode","PrepareUniformBuffer","_uboDeclaration","_vertexDeclaration","_fragmentDeclaration","getUniforms","ubo","uniform","size","arraySize","_a","addUniform","vertex","fragment","getSamplers","getUniformBuffersNames","shaderType","pointName","existingCallback","code","replace","points","processorOptions","injectedCode","_b","resolveIncludes","shaderLanguage","GLSL","indexParameters","isFragment","shouldUseHighPrecisionShader","_shouldUseHighPrecisionShader","processor","undefined","supportsUniformBuffers","shadersRepository","GetShadersRepository","includesShadersStore","GetIncludesShadersStore","version","platformName","shaderPlatformName","processingContext","isNDCHalfZRange","useReverseDepthBuffer","processCodeAfterIncludes","_ProcessIncludes","charAt","substring","regexFlags","matchOption","exec","sourceCode","rx","match","newCode","fullPointName","OnEnginesDisposedObservable","add","UnregisterAllMaterialPlugins","plugins","inited","observer","RegisterMaterialPlugin","pluginName","factory","OnEventObservable","Created","existing","filter","_factory","UnregisterMaterialPlugin","splice","remove"],"sources":["../../../../dev/core/src/Materials/materialPluginManager.ts"],"sourcesContent":["import type { ProcessingOptions, ShaderCustomProcessingFunction } from \"../Engines/Processors/shaderProcessingOptions\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Material } from \"./material\";\r\nimport type {\r\n    MaterialPluginPrepareEffect,\r\n    MaterialPluginBindForSubMesh,\r\n    MaterialPluginDisposed,\r\n    MaterialPluginGetActiveTextures,\r\n    MaterialPluginGetAnimatables,\r\n    MaterialPluginGetDefineNames,\r\n    MaterialPluginHasTexture,\r\n    MaterialPluginIsReadyForSubMesh,\r\n    MaterialPluginPrepareDefines,\r\n    MaterialPluginPrepareUniformBuffer,\r\n    MaterialPluginHardBindForSubMesh,\r\n    MaterialPluginHasRenderTargetTextures,\r\n    MaterialPluginFillRenderTargetTextures,\r\n} from \"./materialPluginEvent\";\r\nimport { MaterialPluginEvent } from \"./materialPluginEvent\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { MaterialPluginBase } from \"./materialPluginBase\";\r\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor\";\r\nimport { ShaderLanguage } from \"./shaderLanguage\";\r\nimport { ShaderStore } from \"../Engines/shaderStore\";\r\n\r\ndeclare module \"./material\" {\r\n    export interface Material {\r\n        /**\r\n         * Plugin manager for this material\r\n         */\r\n        pluginManager?: MaterialPluginManager;\r\n    }\r\n}\r\n\r\nconst rxOption = new RegExp(\"^([gimus]+)!\");\r\n\r\n/**\r\n * Class that manages the plugins of a material\r\n * @since 5.0\r\n */\r\nexport class MaterialPluginManager {\r\n    /** Map a plugin class name to a #define name (used in the vertex/fragment shaders as a marker of the plugin usage) */\r\n    private static _MaterialPluginClassToMainDefine: { [name: string]: string } = {};\r\n    private static _MaterialPluginCounter: number = 0;\r\n\r\n    protected _material: Material;\r\n    protected _scene: Scene;\r\n    protected _engine: Engine;\r\n    /** @internal */\r\n    public _plugins: MaterialPluginBase[] = [];\r\n    protected _activePlugins: MaterialPluginBase[] = [];\r\n    protected _activePluginsForExtraEvents: MaterialPluginBase[] = [];\r\n    protected _codeInjectionPoints: { [shaderType: string]: { [codeName: string]: boolean } };\r\n    protected _defineNamesFromPlugins?: { [name: string]: { type: string; default: any } };\r\n    protected _uboDeclaration: string;\r\n    protected _vertexDeclaration: string;\r\n    protected _fragmentDeclaration: string;\r\n    protected _uniformList: string[];\r\n    protected _samplerList: string[];\r\n    protected _uboList: string[];\r\n\r\n    static {\r\n        EngineStore.OnEnginesDisposedObservable.add(() => {\r\n            UnregisterAllMaterialPlugins();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of the plugin manager\r\n     * @param material material that this manager will manage the plugins for\r\n     */\r\n    constructor(material: Material) {\r\n        this._material = material;\r\n        this._scene = material.getScene();\r\n        this._engine = this._scene.getEngine();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _addPlugin(plugin: MaterialPluginBase): boolean {\r\n        for (let i = 0; i < this._plugins.length; ++i) {\r\n            if (this._plugins[i].name === plugin.name) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (this._material._uniformBufferLayoutBuilt) {\r\n            throw `The plugin \"${plugin.name}\" can't be added to the material \"${this._material.name}\" because this material has already been used for rendering! Please add plugins to materials before any rendering with this material occurs.`;\r\n        }\r\n\r\n        const pluginClassName = plugin.getClassName();\r\n        if (!MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]) {\r\n            MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName] = \"MATERIALPLUGIN_\" + ++MaterialPluginManager._MaterialPluginCounter;\r\n        }\r\n\r\n        this._material._callbackPluginEventGeneric = this._handlePluginEvent.bind(this);\r\n\r\n        this._plugins.push(plugin);\r\n        this._plugins.sort((a, b) => a.priority - b.priority);\r\n\r\n        this._codeInjectionPoints = {};\r\n\r\n        const defineNamesFromPlugins: { [name: string]: { type: string; default: any } } = {};\r\n        defineNamesFromPlugins[MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]] = {\r\n            type: \"boolean\",\r\n            default: true,\r\n        };\r\n\r\n        for (const plugin of this._plugins) {\r\n            plugin.collectDefines(defineNamesFromPlugins);\r\n            this._collectPointNames(\"vertex\", plugin.getCustomCode(\"vertex\"));\r\n            this._collectPointNames(\"fragment\", plugin.getCustomCode(\"fragment\"));\r\n        }\r\n\r\n        this._defineNamesFromPlugins = defineNamesFromPlugins;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _activatePlugin(plugin: MaterialPluginBase): void {\r\n        if (this._activePlugins.indexOf(plugin) === -1) {\r\n            this._activePlugins.push(plugin);\r\n            this._activePlugins.sort((a, b) => a.priority - b.priority);\r\n\r\n            this._material._callbackPluginEventIsReadyForSubMesh = this._handlePluginEventIsReadyForSubMesh.bind(this);\r\n            this._material._callbackPluginEventPrepareDefinesBeforeAttributes = this._handlePluginEventPrepareDefinesBeforeAttributes.bind(this);\r\n            this._material._callbackPluginEventPrepareDefines = this._handlePluginEventPrepareDefines.bind(this);\r\n            this._material._callbackPluginEventBindForSubMesh = this._handlePluginEventBindForSubMesh.bind(this);\r\n\r\n            if (plugin.registerForExtraEvents) {\r\n                this._activePluginsForExtraEvents.push(plugin);\r\n                this._activePluginsForExtraEvents.sort((a, b) => a.priority - b.priority);\r\n                this._material._callbackPluginEventHasRenderTargetTextures = this._handlePluginEventHasRenderTargetTextures.bind(this);\r\n                this._material._callbackPluginEventFillRenderTargetTextures = this._handlePluginEventFillRenderTargetTextures.bind(this);\r\n                this._material._callbackPluginEventHardBindForSubMesh = this._handlePluginEventHardBindForSubMesh.bind(this);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a plugin from the list of plugins managed by this manager\r\n     * @param name name of the plugin\r\n     * @returns the plugin if found, else null\r\n     */\r\n    public getPlugin(name: string): Nullable<MaterialPluginBase> {\r\n        for (let i = 0; i < this._plugins.length; ++i) {\r\n            if (this._plugins[i].name === name) {\r\n                return this._plugins[i];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    protected _handlePluginEventIsReadyForSubMesh(eventData: MaterialPluginIsReadyForSubMesh): void {\r\n        let isReady = true;\r\n        for (const plugin of this._activePlugins) {\r\n            isReady = isReady && plugin.isReadyForSubMesh(eventData.defines, this._scene, this._engine, eventData.subMesh);\r\n        }\r\n        eventData.isReadyForSubMesh = isReady;\r\n    }\r\n\r\n    protected _handlePluginEventPrepareDefinesBeforeAttributes(eventData: MaterialPluginPrepareDefines): void {\r\n        for (const plugin of this._activePlugins) {\r\n            plugin.prepareDefinesBeforeAttributes(eventData.defines, this._scene, eventData.mesh);\r\n        }\r\n    }\r\n\r\n    protected _handlePluginEventPrepareDefines(eventData: MaterialPluginPrepareDefines): void {\r\n        for (const plugin of this._activePlugins) {\r\n            plugin.prepareDefines(eventData.defines, this._scene, eventData.mesh);\r\n        }\r\n    }\r\n\r\n    protected _handlePluginEventHardBindForSubMesh(eventData: MaterialPluginHardBindForSubMesh): void {\r\n        for (const plugin of this._activePluginsForExtraEvents) {\r\n            plugin.hardBindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);\r\n        }\r\n    }\r\n\r\n    protected _handlePluginEventBindForSubMesh(eventData: MaterialPluginBindForSubMesh): void {\r\n        for (const plugin of this._activePlugins) {\r\n            plugin.bindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);\r\n        }\r\n    }\r\n\r\n    protected _handlePluginEventHasRenderTargetTextures(eventData: MaterialPluginHasRenderTargetTextures): void {\r\n        let hasRenderTargetTextures = false;\r\n        for (const plugin of this._activePluginsForExtraEvents) {\r\n            hasRenderTargetTextures = plugin.hasRenderTargetTextures();\r\n            if (hasRenderTargetTextures) {\r\n                break;\r\n            }\r\n        }\r\n        eventData.hasRenderTargetTextures = hasRenderTargetTextures;\r\n    }\r\n\r\n    protected _handlePluginEventFillRenderTargetTextures(eventData: MaterialPluginFillRenderTargetTextures): void {\r\n        for (const plugin of this._activePluginsForExtraEvents) {\r\n            plugin.fillRenderTargetTextures(eventData.renderTargets);\r\n        }\r\n    }\r\n\r\n    protected _handlePluginEvent(\r\n        id: number,\r\n        info:\r\n            | MaterialPluginGetActiveTextures\r\n            | MaterialPluginGetAnimatables\r\n            | MaterialPluginHasTexture\r\n            | MaterialPluginDisposed\r\n            | MaterialPluginGetDefineNames\r\n            | MaterialPluginPrepareEffect\r\n            | MaterialPluginPrepareUniformBuffer\r\n    ): void {\r\n        switch (id) {\r\n            case MaterialPluginEvent.GetActiveTextures: {\r\n                const eventData = info as MaterialPluginGetActiveTextures;\r\n                for (const plugin of this._activePlugins) {\r\n                    plugin.getActiveTextures(eventData.activeTextures);\r\n                }\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.GetAnimatables: {\r\n                const eventData = info as MaterialPluginGetAnimatables;\r\n                for (const plugin of this._activePlugins) {\r\n                    plugin.getAnimatables(eventData.animatables);\r\n                }\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.HasTexture: {\r\n                const eventData = info as MaterialPluginHasTexture;\r\n                let hasTexture = false;\r\n                for (const plugin of this._activePlugins) {\r\n                    hasTexture = plugin.hasTexture(eventData.texture);\r\n                    if (hasTexture) {\r\n                        break;\r\n                    }\r\n                }\r\n                eventData.hasTexture = hasTexture;\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.Disposed: {\r\n                const eventData = info as MaterialPluginDisposed;\r\n                for (const plugin of this._plugins) {\r\n                    plugin.dispose(eventData.forceDisposeTextures);\r\n                }\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.GetDefineNames: {\r\n                const eventData = info as MaterialPluginGetDefineNames;\r\n                eventData.defineNames = this._defineNamesFromPlugins;\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.PrepareEffect: {\r\n                const eventData = info as MaterialPluginPrepareEffect;\r\n                for (const plugin of this._activePlugins) {\r\n                    eventData.fallbackRank = plugin.addFallbacks(eventData.defines, eventData.fallbacks, eventData.fallbackRank);\r\n                    plugin.getAttributes(eventData.attributes, this._scene, eventData.mesh);\r\n                }\r\n                if (this._uniformList.length > 0) {\r\n                    eventData.uniforms.push(...this._uniformList);\r\n                }\r\n                if (this._samplerList.length > 0) {\r\n                    eventData.samplers.push(...this._samplerList);\r\n                }\r\n                if (this._uboList.length > 0) {\r\n                    eventData.uniformBuffersNames.push(...this._uboList);\r\n                }\r\n                eventData.customCode = this._injectCustomCode(eventData, eventData.customCode);\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.PrepareUniformBuffer: {\r\n                const eventData = info as MaterialPluginPrepareUniformBuffer;\r\n                this._uboDeclaration = \"\";\r\n                this._vertexDeclaration = \"\";\r\n                this._fragmentDeclaration = \"\";\r\n                this._uniformList = [];\r\n                this._samplerList = [];\r\n                this._uboList = [];\r\n                for (const plugin of this._plugins) {\r\n                    const uniforms = plugin.getUniforms();\r\n                    if (uniforms) {\r\n                        if (uniforms.ubo) {\r\n                            for (const uniform of uniforms.ubo) {\r\n                                if (uniform.size && uniform.type) {\r\n                                    const arraySize = uniform.arraySize ?? 0;\r\n                                    eventData.ubo.addUniform(uniform.name, uniform.size, arraySize);\r\n                                    this._uboDeclaration += `${uniform.type} ${uniform.name}${arraySize > 0 ? `[${arraySize}]` : \"\"};\\n`;\r\n                                }\r\n                                this._uniformList.push(uniform.name);\r\n                            }\r\n                        }\r\n                        if (uniforms.vertex) {\r\n                            this._vertexDeclaration += uniforms.vertex + \"\\n\";\r\n                        }\r\n                        if (uniforms.fragment) {\r\n                            this._fragmentDeclaration += uniforms.fragment + \"\\n\";\r\n                        }\r\n                    }\r\n                    plugin.getSamplers(this._samplerList);\r\n                    plugin.getUniformBuffersNames(this._uboList);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _collectPointNames(shaderType: string, customCode: Nullable<{ [pointName: string]: string }> | undefined): void {\r\n        if (!customCode) {\r\n            return;\r\n        }\r\n        for (const pointName in customCode) {\r\n            if (!this._codeInjectionPoints[shaderType]) {\r\n                this._codeInjectionPoints[shaderType] = {};\r\n            }\r\n            this._codeInjectionPoints[shaderType][pointName] = true;\r\n        }\r\n    }\r\n\r\n    protected _injectCustomCode(eventData: MaterialPluginPrepareEffect, existingCallback?: (shaderType: string, code: string) => string): ShaderCustomProcessingFunction {\r\n        return (shaderType: string, code: string) => {\r\n            if (existingCallback) {\r\n                code = existingCallback(shaderType, code);\r\n            }\r\n            if (this._uboDeclaration) {\r\n                code = code.replace(\"#define ADDITIONAL_UBO_DECLARATION\", this._uboDeclaration);\r\n            }\r\n            if (this._vertexDeclaration) {\r\n                code = code.replace(\"#define ADDITIONAL_VERTEX_DECLARATION\", this._vertexDeclaration);\r\n            }\r\n            if (this._fragmentDeclaration) {\r\n                code = code.replace(\"#define ADDITIONAL_FRAGMENT_DECLARATION\", this._fragmentDeclaration);\r\n            }\r\n            const points = this._codeInjectionPoints?.[shaderType];\r\n            if (!points) {\r\n                return code;\r\n            }\r\n            let processorOptions: Nullable<ProcessingOptions> = null;\r\n            for (let pointName in points) {\r\n                let injectedCode = \"\";\r\n                for (const plugin of this._activePlugins) {\r\n                    let customCode = plugin.getCustomCode(shaderType)?.[pointName];\r\n                    if (!customCode) {\r\n                        continue;\r\n                    }\r\n                    if (plugin.resolveIncludes) {\r\n                        if (processorOptions === null) {\r\n                            const shaderLanguage = ShaderLanguage.GLSL;\r\n                            processorOptions = {\r\n                                defines: [], // not used by _ProcessIncludes\r\n                                indexParameters: eventData.indexParameters,\r\n                                isFragment: false,\r\n                                shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,\r\n                                processor: undefined as any, // not used by _ProcessIncludes\r\n                                supportsUniformBuffers: this._engine.supportsUniformBuffers,\r\n                                shadersRepository: ShaderStore.GetShadersRepository(shaderLanguage),\r\n                                includesShadersStore: ShaderStore.GetIncludesShadersStore(shaderLanguage),\r\n                                version: undefined as any, // not used by _ProcessIncludes\r\n                                platformName: this._engine.shaderPlatformName,\r\n                                processingContext: undefined as any, // not used by _ProcessIncludes\r\n                                isNDCHalfZRange: this._engine.isNDCHalfZRange,\r\n                                useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\r\n                                processCodeAfterIncludes: undefined as any, // not used by _ProcessIncludes\r\n                            };\r\n                        }\r\n                        processorOptions.isFragment = shaderType === \"fragment\";\r\n                        ShaderProcessor._ProcessIncludes(customCode, processorOptions, (code) => (customCode = code));\r\n                    }\r\n                    injectedCode += customCode + \"\\n\";\r\n                }\r\n                if (injectedCode.length > 0) {\r\n                    if (pointName.charAt(0) === \"!\") {\r\n                        // pointName is a regular expression\r\n                        pointName = pointName.substring(1);\r\n\r\n                        let regexFlags = \"g\";\r\n                        if (pointName.charAt(0) === \"!\") {\r\n                            // no flags\r\n                            regexFlags = \"\";\r\n                            pointName = pointName.substring(1);\r\n                        } else {\r\n                            // get the flag(s)\r\n                            const matchOption = rxOption.exec(pointName);\r\n                            if (matchOption && matchOption.length >= 2) {\r\n                                regexFlags = matchOption[1];\r\n                                pointName = pointName.substring(regexFlags.length + 1);\r\n                            }\r\n                        }\r\n\r\n                        if (regexFlags.indexOf(\"g\") < 0) {\r\n                            // we force the \"g\" flag so that the regexp object is stateful!\r\n                            regexFlags += \"g\";\r\n                        }\r\n\r\n                        const sourceCode = code;\r\n                        const rx = new RegExp(pointName, regexFlags);\r\n                        let match = rx.exec(sourceCode);\r\n                        while (match !== null) {\r\n                            let newCode = injectedCode;\r\n                            for (let i = 0; i < match.length; ++i) {\r\n                                newCode = newCode.replace(\"$\" + i, match[i]);\r\n                            }\r\n                            code = code.replace(match[0], newCode);\r\n                            match = rx.exec(sourceCode);\r\n                        }\r\n                    } else {\r\n                        const fullPointName = \"#define \" + pointName;\r\n                        code = code.replace(fullPointName, \"\\n\" + injectedCode + \"\\n\" + fullPointName);\r\n                    }\r\n                }\r\n            }\r\n            return code;\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Type for plugin material factories.\r\n */\r\nexport type PluginMaterialFactory = (material: Material) => Nullable<MaterialPluginBase>;\r\n\r\nconst plugins: Array<[string, PluginMaterialFactory]> = [];\r\nlet inited = false;\r\nlet observer: Nullable<Observer<Material>> = null;\r\n\r\n/**\r\n * Registers a new material plugin through a factory, or updates it. This makes the plugin available to all materials instantiated after its registration.\r\n * @param pluginName The plugin name\r\n * @param factory The factory function which allows to create the plugin\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function RegisterMaterialPlugin(pluginName: string, factory: PluginMaterialFactory): void {\r\n    if (!inited) {\r\n        observer = Material.OnEventObservable.add((material: Material) => {\r\n            for (const [, factory] of plugins) {\r\n                factory(material);\r\n            }\r\n        }, MaterialPluginEvent.Created);\r\n        inited = true;\r\n    }\r\n    const existing = plugins.filter(([name, _factory]) => name === pluginName);\r\n    if (existing.length > 0) {\r\n        existing[0][1] = factory;\r\n    } else {\r\n        plugins.push([pluginName, factory]);\r\n    }\r\n}\r\n\r\n/**\r\n * Removes a material plugin from the list of global plugins.\r\n * @param pluginName The plugin name\r\n * @returns true if the plugin has been removed, else false\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function UnregisterMaterialPlugin(pluginName: string): boolean {\r\n    for (let i = 0; i < plugins.length; ++i) {\r\n        if (plugins[i][0] === pluginName) {\r\n            plugins.splice(i, 1);\r\n            if (plugins.length === 0) {\r\n                UnregisterAllMaterialPlugins();\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Clear the list of global material plugins\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function UnregisterAllMaterialPlugins(): void {\r\n    plugins.length = 0;\r\n    inited = false;\r\n    Material.OnEventObservable.remove(observer);\r\n    observer = null;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}