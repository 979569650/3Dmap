{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Color4 } from \"../Maths/math.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { Effect } from \"../Materials/effect.js\";\nimport * as WebGPUConstants from \"./WebGPU/webgpuConstants.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { WebGPUPipelineContext } from \"./WebGPU/webgpuPipelineContext.js\";\nimport { WebGPUShaderProcessorGLSL } from \"./WebGPU/webgpuShaderProcessorsGLSL.js\";\nimport { WebGPUShaderProcessorWGSL } from \"./WebGPU/webgpuShaderProcessorsWGSL.js\";\nimport { WebGPUShaderProcessingContext } from \"./WebGPU/webgpuShaderProcessingContext.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { WebGPUTextureHelper } from \"./WebGPU/webgpuTextureHelper.js\";\nimport { WebGPUBufferManager } from \"./WebGPU/webgpuBufferManager.js\";\nimport { WebGPUHardwareTexture } from \"./WebGPU/webgpuHardwareTexture.js\";\nimport { UniformBuffer } from \"../Materials/uniformBuffer.js\";\nimport { WebGPURenderPassWrapper } from \"./WebGPU/webgpuRenderPassWrapper.js\";\nimport { WebGPUCacheSampler } from \"./WebGPU/webgpuCacheSampler.js\";\nimport { WebGPUCacheRenderPipelineTree } from \"./WebGPU/webgpuCacheRenderPipelineTree.js\";\nimport { WebGPUStencilStateComposer } from \"./WebGPU/webgpuStencilStateComposer.js\";\nimport { WebGPUDepthCullingState } from \"./WebGPU/webgpuDepthCullingState.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport { WebGPUMaterialContext } from \"./WebGPU/webgpuMaterialContext.js\";\nimport { WebGPUDrawContext } from \"./WebGPU/webgpuDrawContext.js\";\nimport { WebGPUCacheBindGroups } from \"./WebGPU/webgpuCacheBindGroups.js\";\nimport { WebGPUClearQuad } from \"./WebGPU/webgpuClearQuad.js\";\nimport { WebGPURenderItemBlendColor, WebGPURenderItemScissor, WebGPURenderItemStencilRef, WebGPURenderItemViewport, WebGPUBundleList } from \"./WebGPU/webgpuBundleList.js\";\nimport { WebGPUTimestampQuery } from \"./WebGPU/webgpuTimestampQuery.js\";\nimport { WebGPUOcclusionQuery } from \"./WebGPU/webgpuOcclusionQuery.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { ShaderCodeInliner } from \"./Processors/shaderCodeInliner.js\";\nimport { WebGPUTintWASM } from \"./WebGPU/webgpuTintWASM.js\";\nimport { WebGPUShaderProcessor } from \"./WebGPU/webgpuShaderProcessor.js\";\nimport { ShaderLanguage } from \"../Materials/shaderLanguage.js\";\nimport { WebGPUSnapshotRendering } from \"./WebGPU/webgpuSnapshotRendering.js\";\nimport \"../Buffers/buffer.align.js\";\nimport \"../ShadersWGSL/postprocess.vertex.js\";\nconst viewDescriptorSwapChainAntialiasing = {\n  label: `TextureView_SwapChain_ResolveTarget`,\n  dimension: WebGPUConstants.TextureDimension.E2d,\n  format: undefined,\n  mipLevelCount: 1,\n  arrayLayerCount: 1\n};\nconst viewDescriptorSwapChain = {\n  label: `TextureView_SwapChain`,\n  dimension: WebGPUConstants.TextureDimension.E2d,\n  format: undefined,\n  mipLevelCount: 1,\n  arrayLayerCount: 1\n};\nconst disableUniformityAnalysisMarker = \"/* disable_uniformity_analysis */\";\nconst tempColor4 = new Color4();\n/**\n * The web GPU engine class provides support for WebGPU version of babylon.js.\n * @since 5.0.0\n */\nexport class WebGPUEngine extends Engine {\n  /**\n   * Gets or sets the snapshot rendering mode\n   */\n  get snapshotRenderingMode() {\n    return this._snapshotRendering.mode;\n  }\n  set snapshotRenderingMode(mode) {\n    this._snapshotRendering.mode = mode;\n  }\n  /**\n   * Creates a new snapshot at the next frame using the current snapshotRenderingMode\n   */\n  snapshotRenderingReset() {\n    this._snapshotRendering.reset();\n  }\n  /**\n   * Enables or disables the snapshot rendering mode\n   * Note that the WebGL engine does not support snapshot rendering so setting the value won't have any effect for this engine\n   */\n  get snapshotRendering() {\n    return this._snapshotRendering.enabled;\n  }\n  set snapshotRendering(activate) {\n    this._snapshotRendering.enabled = activate;\n  }\n  /**\n   * Sets this to true to disable the cache for the samplers. You should do it only for testing purpose!\n   */\n  get disableCacheSamplers() {\n    return this._cacheSampler ? this._cacheSampler.disabled : false;\n  }\n  set disableCacheSamplers(disable) {\n    if (this._cacheSampler) {\n      this._cacheSampler.disabled = disable;\n    }\n  }\n  /**\n   * Sets this to true to disable the cache for the render pipelines. You should do it only for testing purpose!\n   */\n  get disableCacheRenderPipelines() {\n    return this._cacheRenderPipeline ? this._cacheRenderPipeline.disabled : false;\n  }\n  set disableCacheRenderPipelines(disable) {\n    if (this._cacheRenderPipeline) {\n      this._cacheRenderPipeline.disabled = disable;\n    }\n  }\n  /**\n   * Sets this to true to disable the cache for the bind groups. You should do it only for testing purpose!\n   */\n  get disableCacheBindGroups() {\n    return this._cacheBindGroups ? this._cacheBindGroups.disabled : false;\n  }\n  set disableCacheBindGroups(disable) {\n    if (this._cacheBindGroups) {\n      this._cacheBindGroups.disabled = disable;\n    }\n  }\n  /**\n   * Gets a Promise<boolean> indicating if the engine can be instantiated (ie. if a WebGPU context can be found)\n   */\n  static get IsSupportedAsync() {\n    return !navigator.gpu ? Promise.resolve(false) : navigator.gpu.requestAdapter().then(adapter => !!adapter, () => false).catch(() => false);\n  }\n  /**\n   * Not supported by WebGPU, you should call IsSupportedAsync instead!\n   */\n  static get IsSupported() {\n    Logger.Warn(\"You must call IsSupportedAsync for WebGPU!\");\n    return false;\n  }\n  /**\n   * Gets a boolean indicating that the engine supports uniform buffers\n   */\n  get supportsUniformBuffers() {\n    return true;\n  }\n  /** Gets the supported extensions by the WebGPU adapter */\n  get supportedExtensions() {\n    return this._adapterSupportedExtensions;\n  }\n  /** Gets the currently enabled extensions on the WebGPU device */\n  get enabledExtensions() {\n    return this._deviceEnabledExtensions;\n  }\n  /** Gets the supported limits by the WebGPU adapter */\n  get supportedLimits() {\n    return this._adapterSupportedLimits;\n  }\n  /** Gets the current limits of the WebGPU device */\n  get currentLimits() {\n    return this._deviceLimits;\n  }\n  /**\n   * Returns a string describing the current engine\n   */\n  get description() {\n    const description = this.name + this.version;\n    return description;\n  }\n  /**\n   * Returns the version of the engine\n   */\n  get version() {\n    return 1;\n  }\n  /**\n   * Gets an object containing information about the current engine context\n   * @returns an object containing the vendor, the renderer and the version of the current engine context\n   */\n  getInfo() {\n    return {\n      vendor: this._adapterInfo.vendor || \"unknown vendor\",\n      renderer: this._adapterInfo.architecture || \"unknown renderer\",\n      version: this._adapterInfo.description || \"unknown version\"\n    };\n  }\n  /**\n   * (WebGPU only) True (default) to be in compatibility mode, meaning rendering all existing scenes without artifacts (same rendering than WebGL).\n   * Setting the property to false will improve performances but may not work in some scenes if some precautions are not taken.\n   * See https://doc.babylonjs.com/setup/support/webGPU/webGPUOptimization/webGPUNonCompatibilityMode for more details\n   */\n  get compatibilityMode() {\n    return this._compatibilityMode;\n  }\n  set compatibilityMode(mode) {\n    this._compatibilityMode = mode;\n  }\n  /** @internal */\n  get currentSampleCount() {\n    return this._currentRenderTarget ? this._currentRenderTarget.samples : this._mainPassSampleCount;\n  }\n  /**\n   * Create a new instance of the gpu engine asynchronously\n   * @param canvas Defines the canvas to use to display the result\n   * @param options Defines the options passed to the engine to create the GPU context dependencies\n   * @returns a promise that resolves with the created engine\n   */\n  static CreateAsync(canvas, options = {}) {\n    const engine = new WebGPUEngine(canvas, options);\n    return new Promise(resolve => {\n      engine.initAsync(options.glslangOptions, options.twgslOptions).then(() => resolve(engine));\n    });\n  }\n  /**\n   * Create a new instance of the gpu engine.\n   * @param canvas Defines the canvas to use to display the result\n   * @param options Defines the options passed to the engine to create the GPU context dependencies\n   */\n  constructor(canvas, options = {}) {\n    var _a, _b;\n    super(null, (_a = options.antialias) !== null && _a !== void 0 ? _a : true, options);\n    // Page Life cycle and constants\n    this._uploadEncoderDescriptor = {\n      label: \"upload\"\n    };\n    this._renderEncoderDescriptor = {\n      label: \"render\"\n    };\n    this._renderTargetEncoderDescriptor = {\n      label: \"renderTarget\"\n    };\n    /** @internal */\n    this._clearDepthValue = 1;\n    /** @internal */\n    this._clearReverseDepthValue = 0;\n    /** @internal */\n    this._clearStencilValue = 0;\n    this._defaultSampleCount = 4; // Only supported value for now.\n    this._glslang = null;\n    this._tintWASM = null;\n    this._adapterInfo = {\n      vendor: \"\",\n      architecture: \"\",\n      device: \"\",\n      description: \"\"\n    };\n    /** @internal */\n    this._compiledComputeEffects = {};\n    /** @internal */\n    this._counters = {\n      numEnableEffects: 0,\n      numEnableDrawWrapper: 0,\n      numBundleCreationNonCompatMode: 0,\n      numBundleReuseNonCompatMode: 0\n    };\n    /**\n     * Counters from last frame\n     */\n    this.countersLastFrame = {\n      numEnableEffects: 0,\n      numEnableDrawWrapper: 0,\n      numBundleCreationNonCompatMode: 0,\n      numBundleReuseNonCompatMode: 0\n    };\n    /**\n     * Max number of uncaptured error messages to log\n     */\n    this.numMaxUncapturedErrors = 20;\n    this._commandBuffers = [null, null, null];\n    // Frame Buffer Life Cycle (recreated for each render target pass)\n    /** @internal */\n    this._currentRenderPass = null;\n    /** @internal */\n    this._mainRenderPassWrapper = new WebGPURenderPassWrapper();\n    /** @internal */\n    this._rttRenderPassWrapper = new WebGPURenderPassWrapper();\n    /** @internal */\n    this._pendingDebugCommands = [];\n    /** @internal */\n    this._onAfterUnbindFrameBufferObservable = new Observable();\n    this._currentOverrideVertexBuffers = null;\n    this._currentIndexBuffer = null;\n    this._colorWriteLocal = true;\n    this._forceEnableEffect = false;\n    // TODO WEBGPU remove those variables when code stabilized\n    /** @internal */\n    this.dbgShowShaderCode = false;\n    /** @internal */\n    this.dbgSanityChecks = true;\n    /** @internal */\n    this.dbgVerboseLogsForFirstFrames = false;\n    /** @internal */\n    this.dbgVerboseLogsNumFrames = 10;\n    /** @internal */\n    this.dbgLogIfNotDrawWrapper = true;\n    /** @internal */\n    this.dbgShowEmptyEnableEffectCalls = true;\n    /**\n     * Indicates if the z range in NDC space is 0..1 (value: true) or -1..1 (value: false)\n     */\n    this.isNDCHalfZRange = true;\n    /**\n     * Indicates that the origin of the texture/framebuffer space is the bottom left corner. If false, the origin is top left\n     */\n    this.hasOriginBottomLeft = false;\n    //------------------------------------------------------------------------------\n    //                              Dynamic WebGPU States\n    //------------------------------------------------------------------------------\n    // index 0 is for main render pass, 1 for RTT render pass\n    this._viewportsCurrent = [{\n      x: 0,\n      y: 0,\n      w: 0,\n      h: 0\n    }, {\n      x: 0,\n      y: 0,\n      w: 0,\n      h: 0\n    }];\n    this._scissorsCurrent = [{\n      x: 0,\n      y: 0,\n      w: 0,\n      h: 0\n    }, {\n      x: 0,\n      y: 0,\n      w: 0,\n      h: 0\n    }];\n    this._scissorCached = {\n      x: 0,\n      y: 0,\n      z: 0,\n      w: 0\n    };\n    this._stencilRefsCurrent = [-1, -1];\n    this._blendColorsCurrent = [[null, null, null, null], [null, null, null, null]];\n    this._name = \"WebGPU\";\n    options.deviceDescriptor = options.deviceDescriptor || {};\n    options.enableGPUDebugMarkers = (_b = options.enableGPUDebugMarkers) !== null && _b !== void 0 ? _b : false;\n    Logger.Log(`Babylon.js v${Engine.Version} - ${this.description} engine`);\n    if (!navigator.gpu) {\n      Logger.Error(\"WebGPU is not supported by your browser.\");\n      return;\n    }\n    options.swapChainFormat = options.swapChainFormat || navigator.gpu.getPreferredCanvasFormat();\n    this._isWebGPU = true;\n    this._shaderPlatformName = \"WEBGPU\";\n    this._renderingCanvas = canvas;\n    this._options = options;\n    this._mainPassSampleCount = options.antialias ? this._defaultSampleCount : 1;\n    this._setupMobileChecks();\n    this._sharedInit(canvas);\n    this._shaderProcessor = new WebGPUShaderProcessorGLSL();\n    this._shaderProcessorWGSL = new WebGPUShaderProcessorWGSL();\n  }\n  //------------------------------------------------------------------------------\n  //                              Initialization\n  //------------------------------------------------------------------------------\n  /**\n   * Initializes the WebGPU context and dependencies.\n   * @param glslangOptions Defines the GLSLang compiler options if necessary\n   * @param twgslOptions Defines the Twgsl compiler options if necessary\n   * @returns a promise notifying the readiness of the engine.\n   */\n  initAsync(glslangOptions, twgslOptions) {\n    var _a;\n    return this._initGlslang(glslangOptions !== null && glslangOptions !== void 0 ? glslangOptions : (_a = this._options) === null || _a === void 0 ? void 0 : _a.glslangOptions).then(glslang => {\n      var _a;\n      this._glslang = glslang;\n      this._tintWASM = WebGPUEngine.UseTWGSL ? new WebGPUTintWASM() : null;\n      return this._tintWASM ? this._tintWASM.initTwgsl(twgslOptions !== null && twgslOptions !== void 0 ? twgslOptions : (_a = this._options) === null || _a === void 0 ? void 0 : _a.twgslOptions).then(() => {\n        return navigator.gpu.requestAdapter(this._options);\n      }, msg => {\n        Logger.Error(\"Can not initialize twgsl!\");\n        Logger.Error(msg);\n        throw Error(\"WebGPU initializations stopped.\");\n      }) : navigator.gpu.requestAdapter(this._options);\n    }, msg => {\n      Logger.Error(\"Can not initialize glslang!\");\n      Logger.Error(msg);\n      throw Error(\"WebGPU initializations stopped.\");\n    }).then(adapter => {\n      var _a, _b, _c;\n      if (!adapter) {\n        throw \"Could not retrieve a WebGPU adapter (adapter is null).\";\n      } else {\n        this._adapter = adapter;\n        this._adapterSupportedExtensions = [];\n        (_a = this._adapter.features) === null || _a === void 0 ? void 0 : _a.forEach(feature => this._adapterSupportedExtensions.push(feature));\n        this._adapterSupportedLimits = this._adapter.limits;\n        this._adapter.requestAdapterInfo().then(adapterInfo => {\n          this._adapterInfo = adapterInfo;\n        });\n        const deviceDescriptor = (_b = this._options.deviceDescriptor) !== null && _b !== void 0 ? _b : {};\n        const requiredFeatures = (_c = deviceDescriptor === null || deviceDescriptor === void 0 ? void 0 : deviceDescriptor.requiredFeatures) !== null && _c !== void 0 ? _c : this._options.enableAllFeatures ? this._adapterSupportedExtensions : undefined;\n        if (requiredFeatures) {\n          const requestedExtensions = requiredFeatures;\n          const validExtensions = [];\n          for (const extension of requestedExtensions) {\n            if (this._adapterSupportedExtensions.indexOf(extension) !== -1) {\n              validExtensions.push(extension);\n            }\n          }\n          deviceDescriptor.requiredFeatures = validExtensions;\n        }\n        if (this._options.setMaximumLimits && !deviceDescriptor.requiredLimits) {\n          deviceDescriptor.requiredLimits = {};\n          for (const name in this._adapterSupportedLimits) {\n            deviceDescriptor.requiredLimits[name] = this._adapterSupportedLimits[name];\n          }\n        }\n        return this._adapter.requestDevice(deviceDescriptor);\n      }\n    }).then(device => {\n      var _a, _b;\n      this._device = device;\n      this._deviceEnabledExtensions = [];\n      (_a = this._device.features) === null || _a === void 0 ? void 0 : _a.forEach(feature => this._deviceEnabledExtensions.push(feature));\n      this._deviceLimits = device.limits;\n      let numUncapturedErrors = -1;\n      this._device.addEventListener(\"uncapturederror\", event => {\n        if (++numUncapturedErrors < this.numMaxUncapturedErrors) {\n          Logger.Warn(`WebGPU uncaptured error (${numUncapturedErrors + 1}): ${event.error} - ${event.error.message}`);\n        } else if (numUncapturedErrors++ === this.numMaxUncapturedErrors) {\n          Logger.Warn(`WebGPU uncaptured error: too many warnings (${this.numMaxUncapturedErrors}), no more warnings will be reported to the console for this engine.`);\n        }\n      });\n      if (!this._doNotHandleContextLost) {\n        (_b = this._device.lost) === null || _b === void 0 ? void 0 : _b.then(info => {\n          if (this._isDisposed) {\n            return;\n          }\n          this._contextWasLost = true;\n          Logger.Warn(\"WebGPU context lost. \" + info);\n          this.onContextLostObservable.notifyObservers(this);\n          this._restoreEngineAfterContextLost(() => this.initAsync());\n        });\n      }\n    }, e => {\n      Logger.Error(\"Could not retrieve a WebGPU device.\");\n      Logger.Error(e);\n    }).then(() => {\n      this._bufferManager = new WebGPUBufferManager(this._device);\n      this._textureHelper = new WebGPUTextureHelper(this._device, this._glslang, this._tintWASM, this._bufferManager, this._deviceEnabledExtensions);\n      this._cacheSampler = new WebGPUCacheSampler(this._device);\n      this._cacheBindGroups = new WebGPUCacheBindGroups(this._device, this._cacheSampler, this);\n      this._timestampQuery = new WebGPUTimestampQuery(this._device, this._bufferManager);\n      this._occlusionQuery = this._device.createQuerySet ? new WebGPUOcclusionQuery(this, this._device, this._bufferManager) : undefined;\n      this._bundleList = new WebGPUBundleList(this._device);\n      this._bundleListRenderTarget = new WebGPUBundleList(this._device);\n      this._snapshotRendering = new WebGPUSnapshotRendering(this, this._snapshotRenderingMode, this._bundleList, this._bundleListRenderTarget);\n      this._ubInvertY = this._bufferManager.createBuffer(new Float32Array([-1, 0]), WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst, \"UBInvertY\");\n      this._ubDontInvertY = this._bufferManager.createBuffer(new Float32Array([1, 0]), WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst, \"UBDontInvertY\");\n      if (this.dbgVerboseLogsForFirstFrames) {\n        if (this._count === undefined) {\n          this._count = 0;\n          console.log(\"%c frame #\" + this._count + \" - begin\", \"background: #ffff00\");\n        }\n      }\n      this._uploadEncoder = this._device.createCommandEncoder(this._uploadEncoderDescriptor);\n      this._renderEncoder = this._device.createCommandEncoder(this._renderEncoderDescriptor);\n      this._renderTargetEncoder = this._device.createCommandEncoder(this._renderTargetEncoderDescriptor);\n      this._initializeLimits();\n      this._emptyVertexBuffer = new VertexBuffer(this, [0], \"\", false, false, 1, false, 0, 1);\n      this._cacheRenderPipeline = new WebGPUCacheRenderPipelineTree(this._device, this._emptyVertexBuffer, !this._caps.textureFloatLinearFiltering);\n      this._depthCullingState = new WebGPUDepthCullingState(this._cacheRenderPipeline);\n      this._stencilStateComposer = new WebGPUStencilStateComposer(this._cacheRenderPipeline);\n      this._stencilStateComposer.stencilGlobal = this._stencilState;\n      this._depthCullingState.depthTest = true;\n      this._depthCullingState.depthFunc = 515;\n      this._depthCullingState.depthMask = true;\n      this._textureHelper.setCommandEncoder(this._uploadEncoder);\n      this._clearQuad = new WebGPUClearQuad(this._device, this, this._emptyVertexBuffer);\n      this._defaultDrawContext = this.createDrawContext();\n      this._currentDrawContext = this._defaultDrawContext;\n      this._defaultMaterialContext = this.createMaterialContext();\n      this._currentMaterialContext = this._defaultMaterialContext;\n      this._initializeContextAndSwapChain();\n      this._initializeMainAttachments();\n      this.resize();\n    }).catch(e => {\n      Logger.Error(\"Can not create WebGPU Device and/or context.\");\n      Logger.Error(e);\n      if (console.trace) {\n        console.trace();\n      }\n    });\n  }\n  _initGlslang(glslangOptions) {\n    glslangOptions = glslangOptions || {};\n    glslangOptions = Object.assign(Object.assign({}, WebGPUEngine._GLSLslangDefaultOptions), glslangOptions);\n    if (glslangOptions.glslang) {\n      return Promise.resolve(glslangOptions.glslang);\n    }\n    if (self.glslang) {\n      return self.glslang(glslangOptions.wasmPath);\n    }\n    if (glslangOptions.jsPath && glslangOptions.wasmPath) {\n      return Tools.LoadBabylonScriptAsync(glslangOptions.jsPath).then(() => {\n        return self.glslang(Tools.GetBabylonScriptURL(glslangOptions.wasmPath));\n      });\n    }\n    return Promise.reject(\"gslang is not available.\");\n  }\n  _initializeLimits() {\n    // Init caps\n    // TODO WEBGPU Real Capability check once limits will be working.\n    this._caps = {\n      maxTexturesImageUnits: this._deviceLimits.maxSampledTexturesPerShaderStage,\n      maxVertexTextureImageUnits: this._deviceLimits.maxSampledTexturesPerShaderStage,\n      maxCombinedTexturesImageUnits: this._deviceLimits.maxSampledTexturesPerShaderStage * 2,\n      maxTextureSize: this._deviceLimits.maxTextureDimension2D,\n      maxCubemapTextureSize: this._deviceLimits.maxTextureDimension2D,\n      maxRenderTextureSize: this._deviceLimits.maxTextureDimension2D,\n      maxVertexAttribs: this._deviceLimits.maxVertexAttributes,\n      maxVaryingVectors: this._deviceLimits.maxInterStageShaderVariables,\n      maxFragmentUniformVectors: Math.floor(this._deviceLimits.maxUniformBufferBindingSize / 4),\n      maxVertexUniformVectors: Math.floor(this._deviceLimits.maxUniformBufferBindingSize / 4),\n      standardDerivatives: true,\n      astc: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionASTC) >= 0 ? true : undefined,\n      s3tc: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionBC) >= 0 ? true : undefined,\n      pvrtc: null,\n      etc1: null,\n      etc2: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionETC2) >= 0 ? true : undefined,\n      bptc: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionBC) >= 0 ? true : undefined,\n      maxAnisotropy: 16,\n      uintIndices: true,\n      fragmentDepthSupported: true,\n      highPrecisionShaderSupported: true,\n      colorBufferFloat: true,\n      textureFloat: true,\n      textureFloatLinearFiltering: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.Float32Filterable) >= 0,\n      textureFloatRender: true,\n      textureHalfFloat: true,\n      textureHalfFloatLinearFiltering: true,\n      textureHalfFloatRender: true,\n      textureLOD: true,\n      texelFetch: true,\n      drawBuffersExtension: true,\n      depthTextureExtension: true,\n      vertexArrayObject: false,\n      instancedArrays: true,\n      timerQuery: typeof BigUint64Array !== \"undefined\" && this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TimestampQuery) !== -1 ? true : undefined,\n      supportOcclusionQuery: typeof BigUint64Array !== \"undefined\",\n      canUseTimestampForTimerQuery: true,\n      multiview: false,\n      oculusMultiview: false,\n      parallelShaderCompile: undefined,\n      blendMinMax: true,\n      maxMSAASamples: 4,\n      canUseGLInstanceID: true,\n      canUseGLVertexID: true,\n      supportComputeShaders: true,\n      supportSRGBBuffers: true,\n      supportTransformFeedbacks: false,\n      textureMaxLevel: true,\n      texture2DArrayMaxLayerCount: this._deviceLimits.maxTextureArrayLayers,\n      disableMorphTargetTexture: false\n    };\n    this._caps.parallelShaderCompile = null;\n    this._features = {\n      forceBitmapOverHTMLImageElement: true,\n      supportRenderAndCopyToLodForFloatTextures: true,\n      supportDepthStencilTexture: true,\n      supportShadowSamplers: true,\n      uniformBufferHardCheckMatrix: false,\n      allowTexturePrefiltering: true,\n      trackUbosInFrame: true,\n      checkUbosContentBeforeUpload: true,\n      supportCSM: true,\n      basisNeedsPOT: false,\n      support3DTextures: true,\n      needTypeSuffixInShaderConstants: true,\n      supportMSAA: true,\n      supportSSAO2: true,\n      supportExtendedTextureFormats: true,\n      supportSwitchCaseInShader: true,\n      supportSyncTextureRead: false,\n      needsInvertingBitmap: false,\n      useUBOBindingCache: false,\n      needShaderCodeInlining: true,\n      needToAlwaysBindUniformBuffers: true,\n      supportRenderPasses: true,\n      supportSpriteInstancing: true,\n      forceVertexBufferStrideMultiple4Bytes: true,\n      _collectUbosUpdatedInFrame: false\n    };\n  }\n  _initializeContextAndSwapChain() {\n    if (!this._renderingCanvas) {\n      throw \"The rendering canvas has not been set!\";\n    }\n    this._context = this._renderingCanvas.getContext(\"webgpu\");\n    this._configureContext();\n    this._colorFormat = this._options.swapChainFormat;\n    this._mainRenderPassWrapper.colorAttachmentGPUTextures = [new WebGPUHardwareTexture()];\n    this._mainRenderPassWrapper.colorAttachmentGPUTextures[0].format = this._colorFormat;\n  }\n  // Set default values as WebGL with depth and stencil attachment for the broadest Compat.\n  _initializeMainAttachments() {\n    if (!this._bufferManager) {\n      return;\n    }\n    this.flushFramebuffer(false);\n    this._mainTextureExtends = {\n      width: this.getRenderWidth(true),\n      height: this.getRenderHeight(true),\n      depthOrArrayLayers: 1\n    };\n    const bufferDataUpdate = new Float32Array([this.getRenderHeight(true)]);\n    this._bufferManager.setSubData(this._ubInvertY, 4, bufferDataUpdate);\n    this._bufferManager.setSubData(this._ubDontInvertY, 4, bufferDataUpdate);\n    let mainColorAttachments;\n    if (this._options.antialias) {\n      const mainTextureDescriptor = {\n        label: `Texture_MainColor_${this._mainTextureExtends.width}x${this._mainTextureExtends.height}_antialiasing`,\n        size: this._mainTextureExtends,\n        mipLevelCount: 1,\n        sampleCount: this._mainPassSampleCount,\n        dimension: WebGPUConstants.TextureDimension.E2d,\n        format: this._options.swapChainFormat,\n        usage: WebGPUConstants.TextureUsage.RenderAttachment\n      };\n      if (this._mainTexture) {\n        this._textureHelper.releaseTexture(this._mainTexture);\n      }\n      this._mainTexture = this._device.createTexture(mainTextureDescriptor);\n      mainColorAttachments = [{\n        view: this._mainTexture.createView({\n          label: \"TextureView_MainColor_antialiasing\",\n          dimension: WebGPUConstants.TextureDimension.E2d,\n          format: this._options.swapChainFormat,\n          mipLevelCount: 1,\n          arrayLayerCount: 1\n        }),\n        clearValue: new Color4(0, 0, 0, 1),\n        loadOp: WebGPUConstants.LoadOp.Clear,\n        storeOp: WebGPUConstants.StoreOp.Store // don't use StoreOp.Discard, else using several cameras with different viewports or using scissors will fail because we call beginRenderPass / endPass several times for the same color attachment!\n      }];\n    } else {\n      mainColorAttachments = [{\n        view: undefined,\n        clearValue: new Color4(0, 0, 0, 1),\n        loadOp: WebGPUConstants.LoadOp.Clear,\n        storeOp: WebGPUConstants.StoreOp.Store\n      }];\n    }\n    this._mainRenderPassWrapper.depthTextureFormat = this.isStencilEnable ? WebGPUConstants.TextureFormat.Depth24PlusStencil8 : WebGPUConstants.TextureFormat.Depth32Float;\n    this._setDepthTextureFormat(this._mainRenderPassWrapper);\n    const depthTextureDescriptor = {\n      label: `Texture_MainDepthStencil_${this._mainTextureExtends.width}x${this._mainTextureExtends.height}`,\n      size: this._mainTextureExtends,\n      mipLevelCount: 1,\n      sampleCount: this._mainPassSampleCount,\n      dimension: WebGPUConstants.TextureDimension.E2d,\n      format: this._mainRenderPassWrapper.depthTextureFormat,\n      usage: WebGPUConstants.TextureUsage.RenderAttachment\n    };\n    if (this._depthTexture) {\n      this._textureHelper.releaseTexture(this._depthTexture);\n    }\n    this._depthTexture = this._device.createTexture(depthTextureDescriptor);\n    const mainDepthAttachment = {\n      view: this._depthTexture.createView({\n        label: `TextureView_MainDepthStencil_${this._mainTextureExtends.width}x${this._mainTextureExtends.height}`,\n        dimension: WebGPUConstants.TextureDimension.E2d,\n        format: this._depthTexture.format,\n        mipLevelCount: 1,\n        arrayLayerCount: 1\n      }),\n      depthClearValue: this._clearDepthValue,\n      depthLoadOp: WebGPUConstants.LoadOp.Clear,\n      depthStoreOp: WebGPUConstants.StoreOp.Store,\n      stencilClearValue: this._clearStencilValue,\n      stencilLoadOp: !this.isStencilEnable ? undefined : WebGPUConstants.LoadOp.Clear,\n      stencilStoreOp: !this.isStencilEnable ? undefined : WebGPUConstants.StoreOp.Store\n    };\n    this._mainRenderPassWrapper.renderPassDescriptor = {\n      label: \"MainRenderPass\",\n      colorAttachments: mainColorAttachments,\n      depthStencilAttachment: mainDepthAttachment\n    };\n  }\n  _configureContext() {\n    this._context.configure({\n      device: this._device,\n      format: this._options.swapChainFormat,\n      usage: WebGPUConstants.TextureUsage.RenderAttachment | WebGPUConstants.TextureUsage.CopySrc,\n      alphaMode: this.premultipliedAlpha ? WebGPUConstants.CanvasAlphaMode.Premultiplied : WebGPUConstants.CanvasAlphaMode.Opaque\n    });\n  }\n  /**\n   * Force a specific size of the canvas\n   * @param width defines the new canvas' width\n   * @param height defines the new canvas' height\n   * @param forceSetSize true to force setting the sizes of the underlying canvas\n   * @returns true if the size was changed\n   */\n  setSize(width, height, forceSetSize = false) {\n    if (!super.setSize(width, height, forceSetSize)) {\n      return false;\n    }\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - setSize called -\", width, height);\n      }\n    }\n    this._initializeMainAttachments();\n    if (this.snapshotRendering) {\n      // reset snapshot rendering so that the next frame will record a new list of bundles\n      this.snapshotRenderingReset();\n    }\n    return true;\n  }\n  /**\n   * @internal\n   */\n  _getShaderProcessor(shaderLanguage) {\n    if (shaderLanguage === ShaderLanguage.WGSL) {\n      return this._shaderProcessorWGSL;\n    }\n    return this._shaderProcessor;\n  }\n  /**\n   * @internal\n   */\n  _getShaderProcessingContext(shaderLanguage) {\n    return new WebGPUShaderProcessingContext(shaderLanguage);\n  }\n  //------------------------------------------------------------------------------\n  //                          Static Pipeline WebGPU States\n  //------------------------------------------------------------------------------\n  /** @internal */\n  applyStates() {\n    this._stencilStateComposer.apply();\n    this._cacheRenderPipeline.setAlphaBlendEnabled(this._alphaState.alphaBlend);\n  }\n  /**\n   * Force the entire cache to be cleared\n   * You should not have to use this function unless your engine needs to share the WebGPU context with another engine\n   * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)\n   */\n  wipeCaches(bruteForce) {\n    if (this.preventCacheWipeBetweenFrames && !bruteForce) {\n      return;\n    }\n    //this._currentEffect = null; // can't reset _currentEffect, else some crashes can occur (for eg in ProceduralTexture which calls bindFrameBuffer (which calls wipeCaches) after having called enableEffect and before drawing into the texture)\n    // _forceEnableEffect = true assumes the role of _currentEffect = null\n    this._forceEnableEffect = true;\n    this._currentIndexBuffer = null;\n    this._currentOverrideVertexBuffers = null;\n    this._cacheRenderPipeline.setBuffers(null, null, null);\n    if (bruteForce) {\n      this._stencilStateComposer.reset();\n      this._depthCullingState.reset();\n      this._depthCullingState.depthFunc = 515;\n      this._alphaState.reset();\n      this._alphaMode = 1;\n      this._alphaEquation = 0;\n      this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters, this._alphaState._blendEquationParameters);\n      this._cacheRenderPipeline.setAlphaBlendEnabled(false);\n      this.setColorWrite(true);\n    }\n    this._cachedVertexBuffers = null;\n    this._cachedIndexBuffer = null;\n    this._cachedEffectForVertexBuffers = null;\n  }\n  /**\n   * Enable or disable color writing\n   * @param enable defines the state to set\n   */\n  setColorWrite(enable) {\n    this._colorWriteLocal = enable;\n    this._cacheRenderPipeline.setWriteMask(enable ? 0xf : 0);\n  }\n  /**\n   * Gets a boolean indicating if color writing is enabled\n   * @returns the current color writing state\n   */\n  getColorWrite() {\n    return this._colorWriteLocal;\n  }\n  _resetCurrentViewport(index) {\n    this._viewportsCurrent[index].x = 0;\n    this._viewportsCurrent[index].y = 0;\n    this._viewportsCurrent[index].w = 0;\n    this._viewportsCurrent[index].h = 0;\n  }\n  _mustUpdateViewport(renderPass) {\n    const index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\n    const x = this._viewportCached.x,\n      y = this._viewportCached.y,\n      w = this._viewportCached.z,\n      h = this._viewportCached.w;\n    const update = this._viewportsCurrent[index].x !== x || this._viewportsCurrent[index].y !== y || this._viewportsCurrent[index].w !== w || this._viewportsCurrent[index].h !== h;\n    if (update) {\n      this._viewportsCurrent[index].x = this._viewportCached.x;\n      this._viewportsCurrent[index].y = this._viewportCached.y;\n      this._viewportsCurrent[index].w = this._viewportCached.z;\n      this._viewportsCurrent[index].h = this._viewportCached.w;\n    }\n    return update;\n  }\n  _applyViewport(renderPass) {\n    let y = Math.floor(this._viewportCached.y);\n    const h = Math.floor(this._viewportCached.w);\n    if (!this._currentRenderTarget) {\n      y = this.getRenderHeight(true) - y - h;\n    }\n    renderPass.setViewport(Math.floor(this._viewportCached.x), y, Math.floor(this._viewportCached.z), h, 0, 1);\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - viewport applied - (\", this._viewportCached.x, this._viewportCached.y, this._viewportCached.z, this._viewportCached.w, \") current pass is main pass=\" + (renderPass === this._mainRenderPassWrapper.renderPass));\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _viewport(x, y, width, height) {\n    this._viewportCached.x = x;\n    this._viewportCached.y = y;\n    this._viewportCached.z = width;\n    this._viewportCached.w = height;\n  }\n  _resetCurrentScissor(index) {\n    this._scissorsCurrent[index].x = 0;\n    this._scissorsCurrent[index].y = 0;\n    this._scissorsCurrent[index].w = 0;\n    this._scissorsCurrent[index].h = 0;\n  }\n  _mustUpdateScissor(renderPass) {\n    const index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\n    const x = this._scissorCached.x,\n      y = this._scissorCached.y,\n      w = this._scissorCached.z,\n      h = this._scissorCached.w;\n    const update = this._scissorsCurrent[index].x !== x || this._scissorsCurrent[index].y !== y || this._scissorsCurrent[index].w !== w || this._scissorsCurrent[index].h !== h;\n    if (update) {\n      this._scissorsCurrent[index].x = this._scissorCached.x;\n      this._scissorsCurrent[index].y = this._scissorCached.y;\n      this._scissorsCurrent[index].w = this._scissorCached.z;\n      this._scissorsCurrent[index].h = this._scissorCached.w;\n    }\n    return update;\n  }\n  _applyScissor(renderPass) {\n    renderPass.setScissorRect(this._scissorCached.x, this._currentRenderTarget ? this._scissorCached.y : this.getRenderHeight() - this._scissorCached.w - this._scissorCached.y, this._scissorCached.z, this._scissorCached.w);\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - scissor applied - (\", this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w, \") current pass is main pass=\" + (renderPass === this._mainRenderPassWrapper.renderPass));\n      }\n    }\n  }\n  _scissorIsActive() {\n    return this._scissorCached.x !== 0 || this._scissorCached.y !== 0 || this._scissorCached.z !== 0 || this._scissorCached.w !== 0;\n  }\n  enableScissor(x, y, width, height) {\n    this._scissorCached.x = x;\n    this._scissorCached.y = y;\n    this._scissorCached.z = width;\n    this._scissorCached.w = height;\n  }\n  disableScissor() {\n    this._scissorCached.x = 0;\n    this._scissorCached.y = 0;\n    this._scissorCached.z = 0;\n    this._scissorCached.w = 0;\n    this._resetCurrentScissor(0);\n    this._resetCurrentScissor(1);\n  }\n  _resetCurrentStencilRef(index) {\n    this._stencilRefsCurrent[index] = -1;\n  }\n  _mustUpdateStencilRef(renderPass) {\n    const index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\n    const update = this._stencilStateComposer.funcRef !== this._stencilRefsCurrent[index];\n    if (update) {\n      this._stencilRefsCurrent[index] = this._stencilStateComposer.funcRef;\n    }\n    return update;\n  }\n  /**\n   * @internal\n   */\n  _applyStencilRef(renderPass) {\n    var _a;\n    renderPass.setStencilReference((_a = this._stencilStateComposer.funcRef) !== null && _a !== void 0 ? _a : 0);\n  }\n  _resetCurrentColorBlend(index) {\n    this._blendColorsCurrent[index][0] = this._blendColorsCurrent[index][1] = this._blendColorsCurrent[index][2] = this._blendColorsCurrent[index][3] = null;\n  }\n  _mustUpdateBlendColor(renderPass) {\n    const index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\n    const colorBlend = this._alphaState._blendConstants;\n    const update = colorBlend[0] !== this._blendColorsCurrent[index][0] || colorBlend[1] !== this._blendColorsCurrent[index][1] || colorBlend[2] !== this._blendColorsCurrent[index][2] || colorBlend[3] !== this._blendColorsCurrent[index][3];\n    if (update) {\n      this._blendColorsCurrent[index][0] = colorBlend[0];\n      this._blendColorsCurrent[index][1] = colorBlend[1];\n      this._blendColorsCurrent[index][2] = colorBlend[2];\n      this._blendColorsCurrent[index][3] = colorBlend[3];\n    }\n    return update;\n  }\n  _applyBlendColor(renderPass) {\n    renderPass.setBlendConstant(this._alphaState._blendConstants);\n  }\n  /**\n   * Clear the current render buffer or the current render target (if any is set up)\n   * @param color defines the color to use\n   * @param backBuffer defines if the back buffer must be cleared\n   * @param depth defines if the depth buffer must be cleared\n   * @param stencil defines if the stencil buffer must be cleared\n   */\n  clear(color, backBuffer, depth, stencil = false) {\n    // Some PGs are using color3...\n    if (color && color.a === undefined) {\n      color.a = 1;\n    }\n    const hasScissor = this._scissorIsActive();\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - clear called - backBuffer=\", backBuffer, \" depth=\", depth, \" stencil=\", stencil, \" scissor is active=\", hasScissor);\n      }\n    }\n    // We need to recreate the render pass so that the new parameters for clear color / depth / stencil are taken into account\n    if (this._currentRenderTarget) {\n      if (hasScissor) {\n        if (!this._rttRenderPassWrapper.renderPass) {\n          this._startRenderTargetRenderPass(this._currentRenderTarget, false, backBuffer ? color : null, depth, stencil);\n        }\n        if (!this.compatibilityMode) {\n          this._bundleListRenderTarget.addItem(new WebGPURenderItemScissor(this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w));\n        } else {\n          this._applyScissor(this._currentRenderPass);\n        }\n        this._clearFullQuad(backBuffer ? color : null, depth, stencil);\n      } else {\n        if (this._currentRenderPass) {\n          this._endRenderTargetRenderPass();\n        }\n        this._startRenderTargetRenderPass(this._currentRenderTarget, true, backBuffer ? color : null, depth, stencil);\n      }\n    } else {\n      if (!this._mainRenderPassWrapper.renderPass || !hasScissor) {\n        this._startMainRenderPass(!hasScissor, backBuffer ? color : null, depth, stencil);\n      }\n      if (hasScissor) {\n        if (!this.compatibilityMode) {\n          this._bundleList.addItem(new WebGPURenderItemScissor(this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w));\n        } else {\n          this._applyScissor(this._currentRenderPass);\n        }\n        this._clearFullQuad(backBuffer ? color : null, depth, stencil);\n      }\n    }\n  }\n  _clearFullQuad(clearColor, clearDepth, clearStencil) {\n    var _a, _b, _c;\n    const renderPass = !this.compatibilityMode ? null : this._getCurrentRenderPass();\n    const renderPassIndex = this._getCurrentRenderPassIndex();\n    const bundleList = renderPassIndex === 0 ? this._bundleList : this._bundleListRenderTarget;\n    this._clearQuad.setColorFormat(this._colorFormat);\n    this._clearQuad.setDepthStencilFormat(this._depthTextureFormat);\n    this._clearQuad.setMRTAttachments((_a = this._cacheRenderPipeline.mrtAttachments) !== null && _a !== void 0 ? _a : [], (_b = this._cacheRenderPipeline.mrtTextureArray) !== null && _b !== void 0 ? _b : [], this._cacheRenderPipeline.mrtTextureCount);\n    if (!this.compatibilityMode) {\n      bundleList.addItem(new WebGPURenderItemStencilRef(this._clearStencilValue));\n    } else {\n      renderPass.setStencilReference(this._clearStencilValue);\n    }\n    const bundle = this._clearQuad.clear(renderPass, clearColor, clearDepth, clearStencil, this.currentSampleCount);\n    if (!this.compatibilityMode) {\n      bundleList.addBundle(bundle);\n      bundleList.addItem(new WebGPURenderItemStencilRef((_c = this._stencilStateComposer.funcRef) !== null && _c !== void 0 ? _c : 0));\n      this._reportDrawCall();\n    } else {\n      this._applyStencilRef(renderPass);\n    }\n  }\n  //------------------------------------------------------------------------------\n  //                              Vertex/Index/Storage Buffers\n  //------------------------------------------------------------------------------\n  /**\n   * Creates a vertex buffer\n   * @param data the data for the vertex buffer\n   * @param _updatable whether the buffer should be created as updatable\n   * @param label defines the label of the buffer (for debug purpose)\n   * @returns the new buffer\n   */\n  createVertexBuffer(data, _updatable, label) {\n    let view;\n    if (data instanceof Array) {\n      view = new Float32Array(data);\n    } else if (data instanceof ArrayBuffer) {\n      view = new Uint8Array(data);\n    } else {\n      view = data;\n    }\n    const dataBuffer = this._bufferManager.createBuffer(view, WebGPUConstants.BufferUsage.Vertex | WebGPUConstants.BufferUsage.CopyDst, label);\n    return dataBuffer;\n  }\n  /**\n   * Creates a vertex buffer\n   * @param data the data for the dynamic vertex buffer\n   * @param label defines the label of the buffer (for debug purpose)\n   * @returns the new buffer\n   */\n  createDynamicVertexBuffer(data, label) {\n    return this.createVertexBuffer(data, undefined, label);\n  }\n  /**\n   * Creates a new index buffer\n   * @param indices defines the content of the index buffer\n   * @param updatable defines if the index buffer must be updatable\n   * @param label defines the label of the buffer (for debug purpose)\n   * @returns a new buffer\n   */\n  createIndexBuffer(indices, _updatable, label) {\n    let is32Bits = true;\n    let view;\n    if (indices instanceof Uint32Array || indices instanceof Int32Array) {\n      view = indices;\n    } else if (indices instanceof Uint16Array) {\n      view = indices;\n      is32Bits = false;\n    } else {\n      if (indices.length > 65535) {\n        view = new Uint32Array(indices);\n      } else {\n        view = new Uint16Array(indices);\n        is32Bits = false;\n      }\n    }\n    const dataBuffer = this._bufferManager.createBuffer(view, WebGPUConstants.BufferUsage.Index | WebGPUConstants.BufferUsage.CopyDst, label);\n    dataBuffer.is32Bits = is32Bits;\n    return dataBuffer;\n  }\n  /**\n   * @internal\n   */\n  _createBuffer(data, creationFlags, label) {\n    let view;\n    if (data instanceof Array) {\n      view = new Float32Array(data);\n    } else if (data instanceof ArrayBuffer) {\n      view = new Uint8Array(data);\n    } else {\n      view = data;\n    }\n    let flags = 0;\n    if (creationFlags & 1) {\n      flags |= WebGPUConstants.BufferUsage.CopySrc;\n    }\n    if (creationFlags & 2) {\n      flags |= WebGPUConstants.BufferUsage.CopyDst;\n    }\n    if (creationFlags & 4) {\n      flags |= WebGPUConstants.BufferUsage.Uniform;\n    }\n    if (creationFlags & 8) {\n      flags |= WebGPUConstants.BufferUsage.Vertex;\n    }\n    if (creationFlags & 16) {\n      flags |= WebGPUConstants.BufferUsage.Index;\n    }\n    if (creationFlags & 32) {\n      flags |= WebGPUConstants.BufferUsage.Storage;\n    }\n    return this._bufferManager.createBuffer(view, flags, label);\n  }\n  /**\n   * @internal\n   */\n  bindBuffersDirectly() {\n    throw \"Not implemented on WebGPU\";\n  }\n  /**\n   * @internal\n   */\n  updateAndBindInstancesBuffer() {\n    throw \"Not implemented on WebGPU\";\n  }\n  /**\n   * Bind a list of vertex buffers with the engine\n   * @param vertexBuffers defines the list of vertex buffers to bind\n   * @param indexBuffer defines the index buffer to bind\n   * @param effect defines the effect associated with the vertex buffers\n   * @param overrideVertexBuffers defines optional list of avertex buffers that overrides the entries in vertexBuffers\n   */\n  bindBuffers(vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {\n    this._currentIndexBuffer = indexBuffer;\n    this._currentOverrideVertexBuffers = overrideVertexBuffers !== null && overrideVertexBuffers !== void 0 ? overrideVertexBuffers : null;\n    this._cacheRenderPipeline.setBuffers(vertexBuffers, indexBuffer, this._currentOverrideVertexBuffers);\n  }\n  /**\n   * @internal\n   */\n  _releaseBuffer(buffer) {\n    return this._bufferManager.releaseBuffer(buffer);\n  }\n  //------------------------------------------------------------------------------\n  //                              Effects\n  //------------------------------------------------------------------------------\n  /**\n   * Create a new effect (used to store vertex/fragment shaders)\n   * @param baseName defines the base name of the effect (The name of file without .fragment.fx or .vertex.fx)\n   * @param attributesNamesOrOptions defines either a list of attribute names or an IEffectCreationOptions object\n   * @param uniformsNamesOrEngine defines either a list of uniform names or the engine to use\n   * @param samplers defines an array of string used to represent textures\n   * @param defines defines the string containing the defines to use to compile the shaders\n   * @param fallbacks defines the list of potential fallbacks to use if shader compilation fails\n   * @param onCompiled defines a function to call when the effect creation is successful\n   * @param onError defines a function to call when the effect creation has failed\n   * @param indexParameters defines an object containing the index values to use to compile shaders (like the maximum number of simultaneous lights)\n   * @param shaderLanguage the language the shader is written in (default: GLSL)\n   * @returns the new Effect\n   */\n  createEffect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, defines, fallbacks, onCompiled, onError, indexParameters, shaderLanguage = ShaderLanguage.GLSL) {\n    var _a;\n    const vertex = baseName.vertexElement || baseName.vertex || baseName.vertexToken || baseName.vertexSource || baseName;\n    const fragment = baseName.fragmentElement || baseName.fragment || baseName.fragmentToken || baseName.fragmentSource || baseName;\n    const globalDefines = this._getGlobalDefines();\n    let fullDefines = (_a = defines !== null && defines !== void 0 ? defines : attributesNamesOrOptions.defines) !== null && _a !== void 0 ? _a : \"\";\n    if (globalDefines) {\n      fullDefines += \"\\n\" + globalDefines;\n    }\n    const name = vertex + \"+\" + fragment + \"@\" + fullDefines;\n    if (this._compiledEffects[name]) {\n      const compiledEffect = this._compiledEffects[name];\n      if (onCompiled && compiledEffect.isReady()) {\n        onCompiled(compiledEffect);\n      }\n      return compiledEffect;\n    }\n    const effect = new Effect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, this, defines, fallbacks, onCompiled, onError, indexParameters, name, shaderLanguage);\n    this._compiledEffects[name] = effect;\n    return effect;\n  }\n  _compileRawShaderToSpirV(source, type) {\n    return this._glslang.compileGLSL(source, type);\n  }\n  _compileShaderToSpirV(source, type, defines, shaderVersion) {\n    return this._compileRawShaderToSpirV(shaderVersion + (defines ? defines + \"\\n\" : \"\") + source, type);\n  }\n  _getWGSLShader(source, type, defines) {\n    if (defines) {\n      defines = \"//\" + defines.split(\"\\n\").join(\"\\n//\") + \"\\n\";\n    } else {\n      defines = \"\";\n    }\n    return defines + source;\n  }\n  _createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage, disableUniformityAnalysisInVertex, disableUniformityAnalysisInFragment) {\n    if (this._tintWASM && shaderLanguage === ShaderLanguage.GLSL) {\n      vertexShader = this._tintWASM.convertSpirV2WGSL(vertexShader, disableUniformityAnalysisInVertex);\n      fragmentShader = this._tintWASM.convertSpirV2WGSL(fragmentShader, disableUniformityAnalysisInFragment);\n    }\n    return {\n      vertexStage: {\n        module: this._device.createShaderModule({\n          code: vertexShader\n        }),\n        entryPoint: \"main\"\n      },\n      fragmentStage: {\n        module: this._device.createShaderModule({\n          code: fragmentShader\n        }),\n        entryPoint: \"main\"\n      }\n    };\n  }\n  _compileRawPipelineStageDescriptor(vertexCode, fragmentCode, shaderLanguage) {\n    const disableUniformityAnalysisInVertex = vertexCode.indexOf(disableUniformityAnalysisMarker) >= 0;\n    const disableUniformityAnalysisInFragment = fragmentCode.indexOf(disableUniformityAnalysisMarker) >= 0;\n    const vertexShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileRawShaderToSpirV(vertexCode, \"vertex\") : vertexCode;\n    const fragmentShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileRawShaderToSpirV(fragmentCode, \"fragment\") : fragmentCode;\n    return this._createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage, disableUniformityAnalysisInVertex, disableUniformityAnalysisInFragment);\n  }\n  _compilePipelineStageDescriptor(vertexCode, fragmentCode, defines, shaderLanguage) {\n    this.onBeforeShaderCompilationObservable.notifyObservers(this);\n    const disableUniformityAnalysisInVertex = vertexCode.indexOf(disableUniformityAnalysisMarker) >= 0;\n    const disableUniformityAnalysisInFragment = fragmentCode.indexOf(disableUniformityAnalysisMarker) >= 0;\n    const shaderVersion = \"#version 450\\n\";\n    const vertexShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileShaderToSpirV(vertexCode, \"vertex\", defines, shaderVersion) : this._getWGSLShader(vertexCode, \"vertex\", defines);\n    const fragmentShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileShaderToSpirV(fragmentCode, \"fragment\", defines, shaderVersion) : this._getWGSLShader(fragmentCode, \"fragment\", defines);\n    const program = this._createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage, disableUniformityAnalysisInVertex, disableUniformityAnalysisInFragment);\n    this.onAfterShaderCompilationObservable.notifyObservers(this);\n    return program;\n  }\n  /**\n   * @internal\n   */\n  createRawShaderProgram() {\n    throw \"Not available on WebGPU\";\n  }\n  /**\n   * @internal\n   */\n  createShaderProgram() {\n    throw \"Not available on WebGPU\";\n  }\n  /**\n   * Inline functions in shader code that are marked to be inlined\n   * @param code code to inline\n   * @returns inlined code\n   */\n  inlineShaderCode(code) {\n    const sci = new ShaderCodeInliner(code);\n    sci.debug = false;\n    sci.processCode();\n    return sci.code;\n  }\n  /**\n   * Creates a new pipeline context\n   * @param shaderProcessingContext defines the shader processing context used during the processing if available\n   * @returns the new pipeline\n   */\n  createPipelineContext(shaderProcessingContext) {\n    return new WebGPUPipelineContext(shaderProcessingContext, this);\n  }\n  /**\n   * Creates a new material context\n   * @returns the new context\n   */\n  createMaterialContext() {\n    return new WebGPUMaterialContext();\n  }\n  /**\n   * Creates a new draw context\n   * @returns the new context\n   */\n  createDrawContext() {\n    return new WebGPUDrawContext(this._bufferManager);\n  }\n  /**\n   * @internal\n   */\n  _preparePipelineContext(pipelineContext, vertexSourceCode, fragmentSourceCode, createAsRaw, rawVertexSourceCode, rawFragmentSourceCode, rebuildRebind, defines) {\n    const webGpuContext = pipelineContext;\n    const shaderLanguage = webGpuContext.shaderProcessingContext.shaderLanguage;\n    if (this.dbgShowShaderCode) {\n      console.log(defines);\n      console.log(vertexSourceCode);\n      console.log(fragmentSourceCode);\n      console.log(\"***********************************************\");\n    }\n    webGpuContext.sources = {\n      fragment: fragmentSourceCode,\n      vertex: vertexSourceCode,\n      rawVertex: rawVertexSourceCode,\n      rawFragment: rawFragmentSourceCode\n    };\n    if (createAsRaw) {\n      webGpuContext.stages = this._compileRawPipelineStageDescriptor(vertexSourceCode, fragmentSourceCode, shaderLanguage);\n    } else {\n      webGpuContext.stages = this._compilePipelineStageDescriptor(vertexSourceCode, fragmentSourceCode, defines, shaderLanguage);\n    }\n  }\n  /**\n   * Gets the list of active attributes for a given WebGPU program\n   * @param pipelineContext defines the pipeline context to use\n   * @param attributesNames defines the list of attribute names to get\n   * @returns an array of indices indicating the offset of each attribute\n   */\n  getAttributes(pipelineContext, attributesNames) {\n    const results = new Array(attributesNames.length);\n    const gpuPipelineContext = pipelineContext;\n    for (let i = 0; i < attributesNames.length; i++) {\n      const attributeName = attributesNames[i];\n      const attributeLocation = gpuPipelineContext.shaderProcessingContext.availableAttributes[attributeName];\n      if (attributeLocation === undefined) {\n        continue;\n      }\n      results[i] = attributeLocation;\n    }\n    return results;\n  }\n  /**\n   * Activates an effect, making it the current one (ie. the one used for rendering)\n   * @param effect defines the effect to activate\n   */\n  enableEffect(effect) {\n    if (!effect) {\n      return;\n    }\n    let isNewEffect = true;\n    if (!DrawWrapper.IsWrapper(effect)) {\n      isNewEffect = effect !== this._currentEffect;\n      this._currentEffect = effect;\n      this._currentMaterialContext = this._defaultMaterialContext;\n      this._currentDrawContext = this._defaultDrawContext;\n      this._counters.numEnableEffects++;\n      if (this.dbgLogIfNotDrawWrapper) {\n        Logger.Warn(`enableEffect has been called with an Effect and not a Wrapper! effect.uniqueId=${effect.uniqueId}, effect.name=${effect.name}, effect.name.vertex=${effect.name.vertex}, effect.name.fragment=${effect.name.fragment}`, 10);\n      }\n    } else if (!effect.effect || effect.effect === this._currentEffect && effect.materialContext === this._currentMaterialContext && effect.drawContext === this._currentDrawContext && !this._forceEnableEffect) {\n      if (!effect.effect && this.dbgShowEmptyEnableEffectCalls) {\n        console.error(\"drawWrapper=\", effect);\n        throw \"Invalid call to enableEffect: the effect property is empty!\";\n      }\n      return;\n    } else {\n      isNewEffect = effect.effect !== this._currentEffect;\n      this._currentEffect = effect.effect;\n      this._currentMaterialContext = effect.materialContext;\n      this._currentDrawContext = effect.drawContext;\n      this._counters.numEnableDrawWrapper++;\n      if (!this._currentMaterialContext) {\n        console.error(\"drawWrapper=\", effect);\n        throw `Invalid call to enableEffect: the materialContext property is empty!`;\n      }\n    }\n    this._stencilStateComposer.stencilMaterial = undefined;\n    this._forceEnableEffect = isNewEffect || this._forceEnableEffect ? false : this._forceEnableEffect;\n    if (isNewEffect) {\n      if (this._currentEffect.onBind) {\n        this._currentEffect.onBind(this._currentEffect);\n      }\n      if (this._currentEffect._onBindObservable) {\n        this._currentEffect._onBindObservable.notifyObservers(this._currentEffect);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _releaseEffect(effect) {\n    if (this._compiledEffects[effect._key]) {\n      delete this._compiledEffects[effect._key];\n      this._deletePipelineContext(effect.getPipelineContext());\n    }\n  }\n  /**\n   * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled\n   */\n  releaseEffects() {\n    for (const name in this._compiledEffects) {\n      const webGPUPipelineContext = this._compiledEffects[name].getPipelineContext();\n      this._deletePipelineContext(webGPUPipelineContext);\n    }\n    this._compiledEffects = {};\n  }\n  _deletePipelineContext(pipelineContext) {\n    const webgpuPipelineContext = pipelineContext;\n    if (webgpuPipelineContext) {\n      pipelineContext.dispose();\n    }\n  }\n  //------------------------------------------------------------------------------\n  //                              Textures\n  //------------------------------------------------------------------------------\n  /**\n   * Gets a boolean indicating that only power of 2 textures are supported\n   * Please note that you can still use non power of 2 textures but in this case the engine will forcefully convert them\n   */\n  get needPOTTextures() {\n    return false;\n  }\n  /** @internal */\n  _createHardwareTexture() {\n    return new WebGPUHardwareTexture();\n  }\n  /**\n   * @internal\n   */\n  _releaseTexture(texture) {\n    const index = this._internalTexturesCache.indexOf(texture);\n    if (index !== -1) {\n      this._internalTexturesCache.splice(index, 1);\n    }\n    this._textureHelper.releaseTexture(texture);\n  }\n  /**\n   * @internal\n   */\n  _getRGBABufferInternalSizedFormat() {\n    return 5;\n  }\n  updateTextureComparisonFunction(texture, comparisonFunction) {\n    texture._comparisonFunction = comparisonFunction;\n  }\n  /**\n   * Creates an internal texture without binding it to a framebuffer\n   * @internal\n   * @param size defines the size of the texture\n   * @param options defines the options used to create the texture\n   * @param delayGPUTextureCreation true to delay the texture creation the first time it is really needed. false to create it right away\n   * @param source source type of the texture\n   * @returns a new internal texture\n   */\n  _createInternalTexture(size, options, delayGPUTextureCreation = true, source = InternalTextureSource.Unknown) {\n    var _a, _b, _c;\n    const fullOptions = {};\n    if (options !== undefined && typeof options === \"object\") {\n      fullOptions.generateMipMaps = options.generateMipMaps;\n      fullOptions.type = options.type === undefined ? 0 : options.type;\n      fullOptions.samplingMode = options.samplingMode === undefined ? 3 : options.samplingMode;\n      fullOptions.format = options.format === undefined ? 5 : options.format;\n      fullOptions.samples = (_a = options.samples) !== null && _a !== void 0 ? _a : 1;\n      fullOptions.creationFlags = (_b = options.creationFlags) !== null && _b !== void 0 ? _b : 0;\n      fullOptions.useSRGBBuffer = (_c = options.useSRGBBuffer) !== null && _c !== void 0 ? _c : false;\n      fullOptions.label = options.label;\n    } else {\n      fullOptions.generateMipMaps = options;\n      fullOptions.type = 0;\n      fullOptions.samplingMode = 3;\n      fullOptions.format = 5;\n      fullOptions.samples = 1;\n      fullOptions.creationFlags = 0;\n      fullOptions.useSRGBBuffer = false;\n    }\n    if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {\n      fullOptions.samplingMode = 1;\n    } else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\n      fullOptions.samplingMode = 1;\n    }\n    if (fullOptions.type === 1 && !this._caps.textureFloat) {\n      fullOptions.type = 0;\n      Logger.Warn(\"Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE\");\n    }\n    const texture = new InternalTexture(this, source);\n    const width = size.width || size;\n    const height = size.height || size;\n    const layers = size.layers || 0;\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = width;\n    texture.height = height;\n    texture.depth = layers;\n    texture.isReady = true;\n    texture.samples = fullOptions.samples;\n    texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;\n    texture.samplingMode = fullOptions.samplingMode;\n    texture.type = fullOptions.type;\n    texture.format = fullOptions.format;\n    texture.is2DArray = layers > 0;\n    texture._cachedWrapU = 0;\n    texture._cachedWrapV = 0;\n    texture._useSRGBBuffer = fullOptions.useSRGBBuffer;\n    texture.label = fullOptions.label;\n    this._internalTexturesCache.push(texture);\n    if (!delayGPUTextureCreation) {\n      this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, layers || 1, fullOptions.creationFlags);\n    }\n    return texture;\n  }\n  /**\n   * Usually called from Texture.ts.\n   * Passed information to create a hardware texture\n   * @param url defines a value which contains one of the following:\n   * * A conventional http URL, e.g. 'http://...' or 'file://...'\n   * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\n   * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\n   * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\n   * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\n   * @param scene needed for loading to the correct scene\n   * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\n   * @param onLoad optional callback to be called upon successful completion\n   * @param onError optional callback to be called upon failure\n   * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\n   * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\n   * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\n   * @param forcedExtension defines the extension to use to pick the right loader\n   * @param mimeType defines an optional mime type\n   * @param loaderOptions options to be passed to the loader\n   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n   * @returns a InternalTexture for assignment back into BABYLON.Texture\n   */\n  createTexture(url, noMipmap, invertY, scene, samplingMode = 3, onLoad = null, onError = null, buffer = null, fallback = null, format = null, forcedExtension = null, mimeType, loaderOptions, creationFlags, useSRGBBuffer) {\n    return this._createTextureBase(url, noMipmap, invertY, scene, samplingMode, onLoad, onError, (texture, extension, scene, img, invertY, noMipmap, isCompressed, processFunction) => {\n      var _a;\n      const imageBitmap = img; // we will never get an HTMLImageElement in WebGPU\n      texture.baseWidth = imageBitmap.width;\n      texture.baseHeight = imageBitmap.height;\n      texture.width = imageBitmap.width;\n      texture.height = imageBitmap.height;\n      texture.format = texture.format !== -1 ? texture.format : format !== null && format !== void 0 ? format : 5;\n      texture.type = texture.type !== -1 ? texture.type : 0;\n      processFunction(texture.width, texture.height, imageBitmap, extension, texture, () => {});\n      if (!((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource)) {\n        // the texture could have been created before reaching this point so don't recreate it if already existing\n        const gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, imageBitmap.width, imageBitmap.height, undefined, creationFlags);\n        if (WebGPUTextureHelper.IsImageBitmap(imageBitmap)) {\n          this._textureHelper.updateTexture(imageBitmap, texture, imageBitmap.width, imageBitmap.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\n          if (!noMipmap && !isCompressed) {\n            this._generateMipmaps(texture, this._uploadEncoder);\n          }\n        }\n      } else if (!noMipmap && !isCompressed) {\n        this._generateMipmaps(texture, this._uploadEncoder);\n      }\n      if (scene) {\n        scene.removePendingData(texture);\n      }\n      texture.isReady = true;\n      texture.onLoadedObservable.notifyObservers(texture);\n      texture.onLoadedObservable.clear();\n    }, () => false, buffer, fallback, format, forcedExtension, mimeType, loaderOptions, useSRGBBuffer);\n  }\n  /**\n   * Wraps an external web gpu texture in a Babylon texture.\n   * @param texture defines the external texture\n   * @returns the babylon internal texture\n   */\n  wrapWebGPUTexture(texture) {\n    const hardwareTexture = new WebGPUHardwareTexture(texture);\n    const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);\n    internalTexture._hardwareTexture = hardwareTexture;\n    internalTexture.isReady = true;\n    return internalTexture;\n  }\n  /**\n   * Wraps an external web gl texture in a Babylon texture.\n   * @returns the babylon internal texture\n   */\n  wrapWebGLTexture() {\n    throw new Error(\"wrapWebGLTexture is not supported, use wrapWebGPUTexture instead.\");\n  }\n  generateMipMapsForCubemap(texture) {\n    var _a;\n    if (texture.generateMipMaps) {\n      const gpuTexture = (_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource;\n      if (!gpuTexture) {\n        this._textureHelper.createGPUTextureForInternalTexture(texture);\n      }\n      this._generateMipmaps(texture, texture.source === InternalTextureSource.RenderTarget || texture.source === InternalTextureSource.MultiRenderTarget ? this._renderTargetEncoder : undefined);\n    }\n  }\n  /**\n   * Update the sampling mode of a given texture\n   * @param samplingMode defines the required sampling mode\n   * @param texture defines the texture to update\n   * @param generateMipMaps defines whether to generate mipmaps for the texture\n   */\n  updateTextureSamplingMode(samplingMode, texture, generateMipMaps = false) {\n    if (generateMipMaps) {\n      texture.generateMipMaps = true;\n      this._generateMipmaps(texture);\n    }\n    texture.samplingMode = samplingMode;\n  }\n  /**\n   * Update the sampling mode of a given texture\n   * @param texture defines the texture to update\n   * @param wrapU defines the texture wrap mode of the u coordinates\n   * @param wrapV defines the texture wrap mode of the v coordinates\n   * @param wrapR defines the texture wrap mode of the r coordinates\n   */\n  updateTextureWrappingMode(texture, wrapU, wrapV = null, wrapR = null) {\n    if (wrapU !== null) {\n      texture._cachedWrapU = wrapU;\n    }\n    if (wrapV !== null) {\n      texture._cachedWrapV = wrapV;\n    }\n    if ((texture.is2DArray || texture.is3D) && wrapR !== null) {\n      texture._cachedWrapR = wrapR;\n    }\n  }\n  /**\n   * Update the dimensions of a texture\n   * @param texture texture to update\n   * @param width new width of the texture\n   * @param height new height of the texture\n   * @param depth new depth of the texture\n   */\n  updateTextureDimensions(texture, width, height, depth = 1) {\n    if (!texture._hardwareTexture) {\n      // the gpu texture is not created yet, so when it is it will be created with the right dimensions\n      return;\n    }\n    if (texture.width === width && texture.height === height && texture.depth === depth) {\n      return;\n    }\n    const additionalUsages = texture._hardwareTexture.textureAdditionalUsages;\n    texture._hardwareTexture.release(); // don't defer the releasing! Else we will release at the end of this frame the gpu texture we are about to create in the next line...\n    this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, depth, additionalUsages);\n  }\n  /**\n   * @internal\n   */\n  _setInternalTexture(name, texture, baseName) {\n    baseName = baseName !== null && baseName !== void 0 ? baseName : name;\n    if (this._currentEffect) {\n      const webgpuPipelineContext = this._currentEffect._pipelineContext;\n      const availableTexture = webgpuPipelineContext.shaderProcessingContext.availableTextures[baseName];\n      this._currentMaterialContext.setTexture(name, texture);\n      if (availableTexture && availableTexture.autoBindSampler) {\n        const samplerName = baseName + WebGPUShaderProcessor.AutoSamplerSuffix;\n        this._currentMaterialContext.setSampler(samplerName, texture); // we can safely cast to InternalTexture because ExternalTexture always has autoBindSampler = false\n      }\n    }\n  }\n  /**\n   * Sets a texture to the according uniform.\n   * @param channel The texture channel\n   * @param unused unused parameter\n   * @param texture The texture to apply\n   * @param name The name of the uniform in the effect\n   */\n  setTexture(channel, unused, texture, name) {\n    this._setTexture(channel, texture, false, false, name, name);\n  }\n  /**\n   * Sets an array of texture to the WebGPU context\n   * @param channel defines the channel where the texture array must be set\n   * @param unused unused parameter\n   * @param textures defines the array of textures to bind\n   * @param name name of the channel\n   */\n  setTextureArray(channel, unused, textures, name) {\n    for (let index = 0; index < textures.length; index++) {\n      this._setTexture(-1, textures[index], true, false, name + index.toString(), name);\n    }\n  }\n  _setTexture(channel, texture,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  isPartOfTextureArray = false, depthStencilTexture = false, name = \"\", baseName) {\n    // name == baseName for a texture that is not part of a texture array\n    // Else, name is something like 'myTexture0' / 'myTexture1' / ... and baseName is 'myTexture'\n    // baseName is used to look up the texture in the shaderProcessingContext.availableTextures map\n    // name is used to look up the texture in the _currentMaterialContext.textures map\n    baseName = baseName !== null && baseName !== void 0 ? baseName : name;\n    if (this._currentEffect) {\n      if (!texture) {\n        this._currentMaterialContext.setTexture(name, null);\n        return false;\n      }\n      // Video\n      if (texture.video) {\n        texture.update();\n      } else if (texture.delayLoadState === 4) {\n        // Delay loading\n        texture.delayLoad();\n        return false;\n      }\n      let internalTexture = null;\n      if (depthStencilTexture) {\n        internalTexture = texture.depthStencilTexture;\n      } else if (texture.isReady()) {\n        internalTexture = texture.getInternalTexture();\n      } else if (texture.isCube) {\n        internalTexture = this.emptyCubeTexture;\n      } else if (texture.is3D) {\n        internalTexture = this.emptyTexture3D;\n      } else if (texture.is2DArray) {\n        internalTexture = this.emptyTexture2DArray;\n      } else {\n        internalTexture = this.emptyTexture;\n      }\n      if (internalTexture && !internalTexture.isMultiview) {\n        // CUBIC_MODE and SKYBOX_MODE both require CLAMP_TO_EDGE.  All other modes use REPEAT.\n        if (internalTexture.isCube && internalTexture._cachedCoordinatesMode !== texture.coordinatesMode) {\n          internalTexture._cachedCoordinatesMode = texture.coordinatesMode;\n          const textureWrapMode = texture.coordinatesMode !== 3 && texture.coordinatesMode !== 5 ? 1 : 0;\n          texture.wrapU = textureWrapMode;\n          texture.wrapV = textureWrapMode;\n        }\n        internalTexture._cachedWrapU = texture.wrapU;\n        internalTexture._cachedWrapV = texture.wrapV;\n        if (internalTexture.is3D) {\n          internalTexture._cachedWrapR = texture.wrapR;\n        }\n        this._setAnisotropicLevel(0, internalTexture, texture.anisotropicFilteringLevel);\n      }\n      this._setInternalTexture(name, internalTexture, baseName);\n    } else {\n      if (this.dbgVerboseLogsForFirstFrames) {\n        if (this._count === undefined) {\n          this._count = 0;\n        }\n        if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n          console.log(\"frame #\" + this._count + \" - _setTexture called with a null _currentEffect! texture=\", texture);\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * @internal\n   */\n  _setAnisotropicLevel(target, internalTexture, anisotropicFilteringLevel) {\n    if (internalTexture._cachedAnisotropicFilteringLevel !== anisotropicFilteringLevel) {\n      internalTexture._cachedAnisotropicFilteringLevel = Math.min(anisotropicFilteringLevel, this._caps.maxAnisotropy);\n    }\n  }\n  /**\n   * @internal\n   */\n  _bindTexture(channel, texture, name) {\n    if (channel === undefined) {\n      return;\n    }\n    this._setInternalTexture(name, texture);\n  }\n  /**\n   * Generates the mipmaps for a texture\n   * @param texture texture to generate the mipmaps for\n   */\n  generateMipmaps(texture) {\n    this._generateMipmaps(texture, this._renderTargetEncoder);\n  }\n  /**\n   * @internal\n   */\n  _generateMipmaps(texture, commandEncoder) {\n    const gpuHardwareTexture = texture._hardwareTexture;\n    if (!gpuHardwareTexture) {\n      return;\n    }\n    // try as much as possible to use the command encoder corresponding to the current pass.\n    // If not possible (because the pass is started - generateMipmaps itself creates a pass and it's not allowed to have a pass inside a pass), use _uploadEncoder\n    commandEncoder = commandEncoder !== null && commandEncoder !== void 0 ? commandEncoder : this._currentRenderTarget && !this._currentRenderPass ? this._renderTargetEncoder : !this._currentRenderPass ? this._renderEncoder : this._uploadEncoder;\n    const format = texture._hardwareTexture.format;\n    const mipmapCount = WebGPUTextureHelper.ComputeNumMipmapLevels(texture.width, texture.height);\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - generate mipmaps called - width=\", texture.width, \"height=\", texture.height, \"isCube=\", texture.isCube);\n      }\n    }\n    if (texture.isCube) {\n      this._textureHelper.generateCubeMipmaps(gpuHardwareTexture, format, mipmapCount, commandEncoder);\n    } else {\n      this._textureHelper.generateMipmaps(gpuHardwareTexture, format, mipmapCount, 0, commandEncoder);\n    }\n  }\n  /**\n   * Update a portion of an internal texture\n   * @param texture defines the texture to update\n   * @param imageData defines the data to store into the texture\n   * @param xOffset defines the x coordinates of the update rectangle\n   * @param yOffset defines the y coordinates of the update rectangle\n   * @param width defines the width of the update rectangle\n   * @param height defines the height of the update rectangle\n   * @param faceIndex defines the face index if texture is a cube (0 by default)\n   * @param lod defines the lod level to update (0 by default)\n   * @param generateMipMaps defines whether to generate mipmaps or not\n   */\n  updateTextureData(texture, imageData, xOffset, yOffset, width, height, faceIndex = 0, lod = 0, generateMipMaps = false) {\n    var _a;\n    let gpuTextureWrapper = texture._hardwareTexture;\n    if (!((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource)) {\n      gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);\n    }\n    const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\n    this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, xOffset, yOffset);\n    if (generateMipMaps) {\n      this._generateMipmaps(texture, this._renderTargetEncoder);\n    }\n  }\n  /**\n   * @internal\n   */\n  _uploadCompressedDataToTextureDirectly(texture, internalFormat, width, height, imageData, faceIndex = 0, lod = 0) {\n    var _a;\n    let gpuTextureWrapper = texture._hardwareTexture;\n    if (!((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource)) {\n      texture.format = internalFormat;\n      gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\n    }\n    const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\n    this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, false, false, 0, 0);\n  }\n  /**\n   * @internal\n   */\n  _uploadDataToTextureDirectly(texture, imageData, faceIndex = 0, lod = 0, babylonInternalFormat, useTextureWidthAndHeight = false) {\n    var _a;\n    const lodMaxWidth = Math.round(Math.log(texture.width) * Math.LOG2E);\n    const lodMaxHeight = Math.round(Math.log(texture.height) * Math.LOG2E);\n    const width = useTextureWidthAndHeight ? texture.width : Math.pow(2, Math.max(lodMaxWidth - lod, 0));\n    const height = useTextureWidthAndHeight ? texture.height : Math.pow(2, Math.max(lodMaxHeight - lod, 0));\n    let gpuTextureWrapper = texture._hardwareTexture;\n    if (!((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource)) {\n      gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\n    }\n    const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\n    this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, 0, 0);\n  }\n  /**\n   * @internal\n   */\n  _uploadArrayBufferViewToTexture(texture, imageData, faceIndex = 0, lod = 0) {\n    this._uploadDataToTextureDirectly(texture, imageData, faceIndex, lod);\n  }\n  /**\n   * @internal\n   */\n  _uploadImageToTexture(texture, image, faceIndex = 0, lod = 0) {\n    var _a;\n    let gpuTextureWrapper = texture._hardwareTexture;\n    if (!((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource)) {\n      gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);\n    }\n    if (image instanceof HTMLImageElement) {\n      throw \"WebGPU engine: HTMLImageElement not supported in _uploadImageToTexture!\";\n    }\n    const bitmap = image; // in WebGPU we will always get an ImageBitmap, not an HTMLImageElement\n    const width = Math.ceil(texture.width / (1 << lod));\n    const height = Math.ceil(texture.height / (1 << lod));\n    this._textureHelper.updateTexture(bitmap, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, 0, 0);\n  }\n  /**\n   * Reads pixels from the current frame buffer. Please note that this function can be slow\n   * @param x defines the x coordinate of the rectangle where pixels must be read\n   * @param y defines the y coordinate of the rectangle where pixels must be read\n   * @param width defines the width of the rectangle where pixels must be read\n   * @param height defines the height of the rectangle where pixels must be read\n   * @param hasAlpha defines whether the output should have alpha or not (defaults to true)\n   * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\n   * @returns a ArrayBufferView promise (Uint8Array) containing RGBA colors\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  readPixels(x, y, width, height, hasAlpha = true, flushRenderer = true) {\n    const renderPassWrapper = this._rttRenderPassWrapper.renderPass ? this._rttRenderPassWrapper : this._mainRenderPassWrapper;\n    const hardwareTexture = renderPassWrapper.colorAttachmentGPUTextures[0];\n    if (!hardwareTexture) {\n      // we are calling readPixels for a render pass with no color texture bound\n      return Promise.resolve(new Uint8Array(0));\n    }\n    const gpuTexture = hardwareTexture.underlyingResource;\n    const gpuTextureFormat = hardwareTexture.format;\n    if (!gpuTexture) {\n      // we are calling readPixels before startMainRenderPass has been called and no RTT is bound, so swapChainTexture is not setup yet!\n      return Promise.resolve(new Uint8Array(0));\n    }\n    if (flushRenderer) {\n      this.flushFramebuffer();\n    }\n    return this._textureHelper.readPixels(gpuTexture, x, y, width, height, gpuTextureFormat);\n  }\n  //------------------------------------------------------------------------------\n  //                              Frame management\n  //------------------------------------------------------------------------------\n  /**\n   * Begin a new frame\n   */\n  beginFrame() {\n    super.beginFrame();\n  }\n  /**\n   * End the current frame\n   */\n  endFrame() {\n    this._snapshotRendering.endFrame(this._mainRenderPassWrapper.renderPass);\n    this._endMainRenderPass();\n    this._timestampQuery.endFrame(this._renderEncoder);\n    this.flushFramebuffer(false);\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - counters\");\n      }\n    }\n    this._textureHelper.destroyDeferredTextures();\n    this._bufferManager.destroyDeferredBuffers();\n    if (this._features._collectUbosUpdatedInFrame) {\n      if (this.dbgVerboseLogsForFirstFrames) {\n        if (this._count === undefined) {\n          this._count = 0;\n        }\n        if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n          const list = [];\n          for (const name in UniformBuffer._UpdatedUbosInFrame) {\n            list.push(name + \":\" + UniformBuffer._UpdatedUbosInFrame[name]);\n          }\n          console.log(\"frame #\" + this._count + \" - updated ubos -\", list.join(\", \"));\n        }\n      }\n      UniformBuffer._UpdatedUbosInFrame = {};\n    }\n    this.countersLastFrame.numEnableEffects = this._counters.numEnableEffects;\n    this.countersLastFrame.numEnableDrawWrapper = this._counters.numEnableDrawWrapper;\n    this.countersLastFrame.numBundleCreationNonCompatMode = this._counters.numBundleCreationNonCompatMode;\n    this.countersLastFrame.numBundleReuseNonCompatMode = this._counters.numBundleReuseNonCompatMode;\n    this._counters.numEnableEffects = 0;\n    this._counters.numEnableDrawWrapper = 0;\n    this._counters.numBundleCreationNonCompatMode = 0;\n    this._counters.numBundleReuseNonCompatMode = 0;\n    this._cacheRenderPipeline.endFrame();\n    this._cacheBindGroups.endFrame();\n    this._pendingDebugCommands.length = 0;\n    super.endFrame();\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"%c frame #\" + this._count + \" - end\", \"background: #ffff00\");\n      }\n      if (this._count < this.dbgVerboseLogsNumFrames) {\n        this._count++;\n        if (this._count !== this.dbgVerboseLogsNumFrames) {\n          console.log(\"%c frame #\" + this._count + \" - begin\", \"background: #ffff00\");\n        }\n      }\n    }\n  }\n  /**\n   * Force a WebGPU flush (ie. a flush of all waiting commands)\n   * @param reopenPass true to reopen at the end of the function the pass that was active when entering the function\n   */\n  flushFramebuffer(reopenPass = true) {\n    // we need to end the current render pass (main or rtt) if any as we are not allowed to submit the command buffers when being in a pass\n    const currentRenderPassIsNULL = !this._currentRenderPass;\n    let currentPasses = 0; // 0 if no pass, 1 for rtt, 2 for main pass\n    if (this._currentRenderPass && this._currentRenderTarget) {\n      currentPasses |= 1;\n      this._endRenderTargetRenderPass();\n    }\n    if (this._mainRenderPassWrapper.renderPass) {\n      currentPasses |= 2;\n      this._endMainRenderPass();\n    }\n    this._commandBuffers[0] = this._uploadEncoder.finish();\n    this._commandBuffers[1] = this._renderTargetEncoder.finish();\n    this._commandBuffers[2] = this._renderEncoder.finish();\n    this._device.queue.submit(this._commandBuffers);\n    this._uploadEncoder = this._device.createCommandEncoder(this._uploadEncoderDescriptor);\n    this._renderEncoder = this._device.createCommandEncoder(this._renderEncoderDescriptor);\n    this._renderTargetEncoder = this._device.createCommandEncoder(this._renderTargetEncoderDescriptor);\n    this._timestampQuery.startFrame(this._uploadEncoder);\n    this._textureHelper.setCommandEncoder(this._uploadEncoder);\n    this._bundleList.reset();\n    this._bundleListRenderTarget.reset();\n    // restart the render pass\n    if (reopenPass) {\n      if (currentPasses & 2) {\n        this._startMainRenderPass(false);\n      }\n      if (currentPasses & 1) {\n        this._startRenderTargetRenderPass(this._currentRenderTarget, false, null, false, false);\n      }\n      if (currentRenderPassIsNULL && this._currentRenderTarget) {\n        this._currentRenderPass = null;\n      }\n    }\n  }\n  /** @internal */\n  _currentFrameBufferIsDefaultFrameBuffer() {\n    return this._currentRenderTarget === null;\n  }\n  //------------------------------------------------------------------------------\n  //                              Render Pass\n  //------------------------------------------------------------------------------\n  _startRenderTargetRenderPass(renderTargetWrapper, setClearStates, clearColor, clearDepth, clearStencil) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const rtWrapper = renderTargetWrapper;\n    const depthStencilTexture = rtWrapper._depthStencilTexture;\n    const gpuDepthStencilWrapper = depthStencilTexture === null || depthStencilTexture === void 0 ? void 0 : depthStencilTexture._hardwareTexture;\n    const gpuDepthStencilTexture = gpuDepthStencilWrapper === null || gpuDepthStencilWrapper === void 0 ? void 0 : gpuDepthStencilWrapper.underlyingResource;\n    const gpuDepthStencilMSAATexture = gpuDepthStencilWrapper === null || gpuDepthStencilWrapper === void 0 ? void 0 : gpuDepthStencilWrapper.getMSAATexture();\n    const depthTextureView = gpuDepthStencilTexture === null || gpuDepthStencilTexture === void 0 ? void 0 : gpuDepthStencilTexture.createView(this._rttRenderPassWrapper.depthAttachmentViewDescriptor);\n    const depthMSAATextureView = gpuDepthStencilMSAATexture === null || gpuDepthStencilMSAATexture === void 0 ? void 0 : gpuDepthStencilMSAATexture.createView(this._rttRenderPassWrapper.depthAttachmentViewDescriptor);\n    const depthTextureHasStencil = gpuDepthStencilWrapper ? WebGPUTextureHelper.HasStencilAspect(gpuDepthStencilWrapper.format) : false;\n    const colorAttachments = [];\n    if (this.useReverseDepthBuffer) {\n      this.setDepthFunctionToGreaterOrEqual();\n    }\n    const clearColorForIntegerRT = tempColor4;\n    if (clearColor) {\n      clearColorForIntegerRT.r = clearColor.r * 255;\n      clearColorForIntegerRT.g = clearColor.g * 255;\n      clearColorForIntegerRT.b = clearColor.b * 255;\n      clearColorForIntegerRT.a = clearColor.a * 255;\n    }\n    const mustClearColor = setClearStates && clearColor;\n    const mustClearDepth = setClearStates && clearDepth;\n    const mustClearStencil = setClearStates && clearStencil;\n    if (rtWrapper._attachments && rtWrapper.isMulti) {\n      // multi render targets\n      if (!this._mrtAttachments || this._mrtAttachments.length === 0) {\n        this._mrtAttachments = rtWrapper._defaultAttachments;\n      }\n      for (let i = 0; i < this._mrtAttachments.length; ++i) {\n        const index = this._mrtAttachments[i]; // if index == 0 it means the texture should not be written to => at render pass creation time, it means we should not clear it\n        const mrtTexture = rtWrapper.textures[i];\n        const gpuMRTWrapper = mrtTexture === null || mrtTexture === void 0 ? void 0 : mrtTexture._hardwareTexture;\n        const gpuMRTTexture = gpuMRTWrapper === null || gpuMRTWrapper === void 0 ? void 0 : gpuMRTWrapper.underlyingResource;\n        if (gpuMRTWrapper && gpuMRTTexture) {\n          const gpuMSAATexture = gpuMRTWrapper.getMSAATexture(i);\n          const layerIndex = (_b = (_a = rtWrapper.layerIndices) === null || _a === void 0 ? void 0 : _a[i]) !== null && _b !== void 0 ? _b : 0;\n          const faceIndex = (_d = (_c = rtWrapper.faceIndices) === null || _c === void 0 ? void 0 : _c[i]) !== null && _d !== void 0 ? _d : 0;\n          const viewDescriptor = Object.assign(Object.assign({}, this._rttRenderPassWrapper.colorAttachmentViewDescriptor), {\n            format: gpuMRTWrapper.format,\n            baseArrayLayer: mrtTexture.isCube ? layerIndex * 6 + faceIndex : layerIndex\n          });\n          const msaaViewDescriptor = Object.assign(Object.assign({}, this._rttRenderPassWrapper.colorAttachmentViewDescriptor), {\n            format: gpuMRTWrapper.format,\n            baseArrayLayer: 0\n          });\n          const isRTInteger = mrtTexture.type === 7 || mrtTexture.type === 5;\n          const colorTextureView = gpuMRTTexture.createView(viewDescriptor);\n          const colorMSAATextureView = gpuMSAATexture === null || gpuMSAATexture === void 0 ? void 0 : gpuMSAATexture.createView(msaaViewDescriptor);\n          colorAttachments.push({\n            view: colorMSAATextureView ? colorMSAATextureView : colorTextureView,\n            resolveTarget: gpuMSAATexture ? colorTextureView : undefined,\n            clearValue: index !== 0 && mustClearColor ? isRTInteger ? clearColorForIntegerRT : clearColor : undefined,\n            loadOp: index !== 0 && mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\n            storeOp: WebGPUConstants.StoreOp.Store\n          });\n        }\n      }\n      this._cacheRenderPipeline.setMRT(rtWrapper.textures, this._mrtAttachments.length);\n      this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\n    } else {\n      // single render target\n      const internalTexture = rtWrapper.texture;\n      if (internalTexture) {\n        const gpuWrapper = internalTexture._hardwareTexture;\n        const gpuTexture = gpuWrapper.underlyingResource;\n        const gpuMSAATexture = gpuWrapper.getMSAATexture();\n        const colorTextureView = gpuTexture.createView(this._rttRenderPassWrapper.colorAttachmentViewDescriptor);\n        const colorMSAATextureView = gpuMSAATexture === null || gpuMSAATexture === void 0 ? void 0 : gpuMSAATexture.createView(this._rttRenderPassWrapper.colorAttachmentViewDescriptor);\n        const isRTInteger = internalTexture.type === 7 || internalTexture.type === 5;\n        colorAttachments.push({\n          view: colorMSAATextureView ? colorMSAATextureView : colorTextureView,\n          resolveTarget: gpuMSAATexture ? colorTextureView : undefined,\n          clearValue: mustClearColor ? isRTInteger ? clearColorForIntegerRT : clearColor : undefined,\n          loadOp: mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\n          storeOp: WebGPUConstants.StoreOp.Store\n        });\n      } else {\n        colorAttachments.push(null);\n      }\n    }\n    (_e = this._debugPushGroup) === null || _e === void 0 ? void 0 : _e.call(this, \"render target pass\", 1);\n    this._rttRenderPassWrapper.renderPassDescriptor = {\n      label: ((_f = renderTargetWrapper.label) !== null && _f !== void 0 ? _f : \"RTT\") + \"RenderPass\",\n      colorAttachments,\n      depthStencilAttachment: depthStencilTexture && gpuDepthStencilTexture ? {\n        view: depthMSAATextureView ? depthMSAATextureView : depthTextureView,\n        depthClearValue: mustClearDepth ? this.useReverseDepthBuffer ? this._clearReverseDepthValue : this._clearDepthValue : undefined,\n        depthLoadOp: mustClearDepth ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\n        depthStoreOp: WebGPUConstants.StoreOp.Store,\n        stencilClearValue: rtWrapper._depthStencilTextureWithStencil && mustClearStencil ? this._clearStencilValue : undefined,\n        stencilLoadOp: !depthTextureHasStencil ? undefined : rtWrapper._depthStencilTextureWithStencil && mustClearStencil ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\n        stencilStoreOp: !depthTextureHasStencil ? undefined : WebGPUConstants.StoreOp.Store\n      } : undefined,\n      occlusionQuerySet: ((_g = this._occlusionQuery) === null || _g === void 0 ? void 0 : _g.hasQueries) ? this._occlusionQuery.querySet : undefined\n    };\n    this._rttRenderPassWrapper.renderPass = this._renderTargetEncoder.beginRenderPass(this._rttRenderPassWrapper.renderPassDescriptor);\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        const internalTexture = rtWrapper.texture;\n        console.log(\"frame #\" + this._count + \" - render target begin pass - internalTexture.uniqueId=\", internalTexture.uniqueId, \"width=\", internalTexture.width, \"height=\", internalTexture.height, this._rttRenderPassWrapper.renderPassDescriptor);\n      }\n    }\n    this._currentRenderPass = this._rttRenderPassWrapper.renderPass;\n    (_h = this._debugFlushPendingCommands) === null || _h === void 0 ? void 0 : _h.call(this);\n    this._resetCurrentViewport(1);\n    this._resetCurrentScissor(1);\n    this._resetCurrentStencilRef(1);\n    this._resetCurrentColorBlend(1);\n    if (!gpuDepthStencilWrapper || !WebGPUTextureHelper.HasStencilAspect(gpuDepthStencilWrapper.format)) {\n      this._stencilStateComposer.enabled = false;\n    }\n  }\n  /** @internal */\n  _endRenderTargetRenderPass() {\n    var _a, _b, _c, _d;\n    if (this._currentRenderPass) {\n      const gpuWrapper = (_a = this._currentRenderTarget.texture) === null || _a === void 0 ? void 0 : _a._hardwareTexture;\n      if (gpuWrapper && !this._snapshotRendering.endRenderTargetPass(this._currentRenderPass, gpuWrapper) && !this.compatibilityMode) {\n        this._bundleListRenderTarget.run(this._currentRenderPass);\n        this._bundleListRenderTarget.reset();\n      }\n      this._currentRenderPass.end();\n      if (this.dbgVerboseLogsForFirstFrames) {\n        if (this._count === undefined) {\n          this._count = 0;\n        }\n        if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n          console.log(\"frame #\" + this._count + \" - render target end pass - internalTexture.uniqueId=\", (_c = (_b = this._currentRenderTarget) === null || _b === void 0 ? void 0 : _b.texture) === null || _c === void 0 ? void 0 : _c.uniqueId);\n        }\n      }\n      (_d = this._debugPopGroup) === null || _d === void 0 ? void 0 : _d.call(this, 1);\n      this._resetCurrentViewport(1);\n      this._viewport(0, 0, 0, 0);\n      this._resetCurrentScissor(1);\n      this._resetCurrentStencilRef(1);\n      this._resetCurrentColorBlend(1);\n      this._currentRenderPass = null;\n      this._rttRenderPassWrapper.reset();\n    }\n  }\n  _getCurrentRenderPass() {\n    if (this._currentRenderTarget && !this._currentRenderPass) {\n      // delayed creation of the render target pass, but we now need to create it as we are requested the render pass\n      this._startRenderTargetRenderPass(this._currentRenderTarget, false, null, false, false);\n    } else if (!this._currentRenderPass) {\n      this._startMainRenderPass(false);\n    }\n    return this._currentRenderPass;\n  }\n  /** @internal */\n  _getCurrentRenderPassIndex() {\n    return this._currentRenderPass === null ? -1 : this._currentRenderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\n  }\n  _startMainRenderPass(setClearStates, clearColor, clearDepth, clearStencil) {\n    var _a, _b, _c;\n    if (this._mainRenderPassWrapper.renderPass) {\n      this.flushFramebuffer(false);\n    }\n    if (this.useReverseDepthBuffer) {\n      this.setDepthFunctionToGreaterOrEqual();\n    }\n    const mustClearColor = setClearStates && clearColor;\n    const mustClearDepth = setClearStates && clearDepth;\n    const mustClearStencil = setClearStates && clearStencil;\n    this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].clearValue = mustClearColor ? clearColor : undefined;\n    this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].loadOp = mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load;\n    this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.depthClearValue = mustClearDepth ? this.useReverseDepthBuffer ? this._clearReverseDepthValue : this._clearDepthValue : undefined;\n    this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.depthLoadOp = mustClearDepth ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load;\n    this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.stencilClearValue = mustClearStencil ? this._clearStencilValue : undefined;\n    this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.stencilLoadOp = !this.isStencilEnable ? undefined : mustClearStencil ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load;\n    this._mainRenderPassWrapper.renderPassDescriptor.occlusionQuerySet = ((_a = this._occlusionQuery) === null || _a === void 0 ? void 0 : _a.hasQueries) ? this._occlusionQuery.querySet : undefined;\n    const swapChainTexture = this._context.getCurrentTexture();\n    this._mainRenderPassWrapper.colorAttachmentGPUTextures[0].set(swapChainTexture);\n    // Resolve in case of MSAA\n    if (this._options.antialias) {\n      viewDescriptorSwapChainAntialiasing.format = swapChainTexture.format;\n      this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].resolveTarget = swapChainTexture.createView(viewDescriptorSwapChainAntialiasing);\n    } else {\n      viewDescriptorSwapChain.format = swapChainTexture.format;\n      this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].view = swapChainTexture.createView(viewDescriptorSwapChain);\n    }\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - main begin pass - texture width=\" + this._mainTextureExtends.width, \" height=\" + this._mainTextureExtends.height, this._mainRenderPassWrapper.renderPassDescriptor);\n      }\n    }\n    (_b = this._debugPushGroup) === null || _b === void 0 ? void 0 : _b.call(this, \"main pass\", 0);\n    this._currentRenderPass = this._renderEncoder.beginRenderPass(this._mainRenderPassWrapper.renderPassDescriptor);\n    this._mainRenderPassWrapper.renderPass = this._currentRenderPass;\n    (_c = this._debugFlushPendingCommands) === null || _c === void 0 ? void 0 : _c.call(this);\n    this._resetCurrentViewport(0);\n    this._resetCurrentScissor(0);\n    this._resetCurrentStencilRef(0);\n    this._resetCurrentColorBlend(0);\n    if (!this._isStencilEnable) {\n      this._stencilStateComposer.enabled = false;\n    }\n  }\n  _endMainRenderPass() {\n    var _a;\n    if (this._mainRenderPassWrapper.renderPass !== null) {\n      this._snapshotRendering.endMainRenderPass();\n      if (!this.compatibilityMode && !this._snapshotRendering.play) {\n        this._bundleList.run(this._mainRenderPassWrapper.renderPass);\n        this._bundleList.reset();\n      }\n      this._mainRenderPassWrapper.renderPass.end();\n      if (this.dbgVerboseLogsForFirstFrames) {\n        if (this._count === undefined) {\n          this._count = 0;\n        }\n        if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n          console.log(\"frame #\" + this._count + \" - main end pass\");\n        }\n      }\n      (_a = this._debugPopGroup) === null || _a === void 0 ? void 0 : _a.call(this, 0);\n      this._resetCurrentViewport(0);\n      this._resetCurrentScissor(0);\n      this._resetCurrentStencilRef(0);\n      this._resetCurrentColorBlend(0);\n      if (this._mainRenderPassWrapper.renderPass === this._currentRenderPass) {\n        this._currentRenderPass = null;\n      }\n      this._mainRenderPassWrapper.reset(false);\n    }\n  }\n  /**\n   * Binds the frame buffer to the specified texture.\n   * @param texture The render target wrapper to render to\n   * @param faceIndex The face of the texture to render to in case of cube texture\n   * @param requiredWidth The width of the target to render to\n   * @param requiredHeight The height of the target to render to\n   * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true\n   * @param lodLevel defines the lod level to bind to the frame buffer\n   * @param layer defines the 2d array index to bind to frame buffer to\n   */\n  bindFramebuffer(texture, faceIndex = 0, requiredWidth, requiredHeight, forceFullscreenViewport, lodLevel = 0, layer = 0) {\n    var _a, _b;\n    const hardwareTexture = (_a = texture.texture) === null || _a === void 0 ? void 0 : _a._hardwareTexture;\n    if (this._currentRenderTarget) {\n      this.unBindFramebuffer(this._currentRenderTarget);\n    }\n    this._currentRenderTarget = texture;\n    if (hardwareTexture) {\n      hardwareTexture._currentLayer = texture.isCube ? layer * 6 + faceIndex : layer;\n    }\n    this._rttRenderPassWrapper.colorAttachmentGPUTextures[0] = hardwareTexture;\n    this._rttRenderPassWrapper.depthTextureFormat = this._currentRenderTarget._depthStencilTexture ? WebGPUTextureHelper.GetWebGPUTextureFormat(-1, this._currentRenderTarget._depthStencilTexture.format) : undefined;\n    this._setDepthTextureFormat(this._rttRenderPassWrapper);\n    this._setColorFormat(this._rttRenderPassWrapper);\n    this._rttRenderPassWrapper.colorAttachmentViewDescriptor = {\n      format: this._colorFormat,\n      dimension: WebGPUConstants.TextureViewDimension.E2d,\n      mipLevelCount: 1,\n      baseArrayLayer: texture.isCube ? layer * 6 + faceIndex : layer,\n      baseMipLevel: lodLevel,\n      arrayLayerCount: 1,\n      aspect: WebGPUConstants.TextureAspect.All\n    };\n    this._rttRenderPassWrapper.depthAttachmentViewDescriptor = {\n      format: this._depthTextureFormat,\n      dimension: WebGPUConstants.TextureViewDimension.E2d,\n      mipLevelCount: 1,\n      baseArrayLayer: texture.isCube ? layer * 6 + faceIndex : layer,\n      baseMipLevel: 0,\n      arrayLayerCount: 1,\n      aspect: WebGPUConstants.TextureAspect.All\n    };\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - bindFramebuffer called - internalTexture.uniqueId=\", (_b = texture.texture) === null || _b === void 0 ? void 0 : _b.uniqueId, \"face=\", faceIndex, \"lodLevel=\", lodLevel, \"layer=\", layer, this._rttRenderPassWrapper.colorAttachmentViewDescriptor, this._rttRenderPassWrapper.depthAttachmentViewDescriptor);\n      }\n    }\n    this._currentRenderPass = null; // lazy creation of the render pass, hoping the render pass will be created by a call to clear()...\n    if (this.snapshotRendering && this.snapshotRenderingMode === 1) {\n      // force the creation of the render pass as we know in fast snapshot rendering mode clear() won't be called\n      this._getCurrentRenderPass();\n    }\n    if (this._cachedViewport && !forceFullscreenViewport) {\n      this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);\n    } else {\n      if (!requiredWidth) {\n        requiredWidth = texture.width;\n        if (lodLevel) {\n          requiredWidth = requiredWidth / Math.pow(2, lodLevel);\n        }\n      }\n      if (!requiredHeight) {\n        requiredHeight = texture.height;\n        if (lodLevel) {\n          requiredHeight = requiredHeight / Math.pow(2, lodLevel);\n        }\n      }\n      this._viewport(0, 0, requiredWidth, requiredHeight);\n    }\n    this.wipeCaches();\n  }\n  /**\n   * Unbind the current render target texture from the WebGPU context\n   * @param texture defines the render target wrapper to unbind\n   * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\n   * @param onBeforeUnbind defines a function which will be called before the effective unbind\n   */\n  unBindFramebuffer(texture, disableGenerateMipMaps = false, onBeforeUnbind) {\n    var _a, _b;\n    const saveCRT = this._currentRenderTarget;\n    this._currentRenderTarget = null; // to be iso with thinEngine, this._currentRenderTarget must be null when onBeforeUnbind is called\n    if (onBeforeUnbind) {\n      onBeforeUnbind();\n    }\n    this._currentRenderTarget = saveCRT;\n    if (this._currentRenderPass && this._currentRenderPass !== this._mainRenderPassWrapper.renderPass) {\n      this._endRenderTargetRenderPass();\n    }\n    if (((_a = texture.texture) === null || _a === void 0 ? void 0 : _a.generateMipMaps) && !disableGenerateMipMaps && !texture.isCube) {\n      this._generateMipmaps(texture.texture);\n    }\n    this._currentRenderTarget = null;\n    this._onAfterUnbindFrameBufferObservable.notifyObservers(this);\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - unBindFramebuffer called - internalTexture.uniqueId=\", (_b = texture.texture) === null || _b === void 0 ? void 0 : _b.uniqueId);\n      }\n    }\n    this._mrtAttachments = [];\n    this._cacheRenderPipeline.setMRT([]);\n    this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\n    this._currentRenderPass = this._mainRenderPassWrapper.renderPass;\n    this._setDepthTextureFormat(this._mainRenderPassWrapper);\n    this._setColorFormat(this._mainRenderPassWrapper);\n  }\n  /**\n   * Unbind the current render target and bind the default framebuffer\n   */\n  restoreDefaultFramebuffer() {\n    if (this._currentRenderTarget) {\n      this.unBindFramebuffer(this._currentRenderTarget);\n    } else {\n      this._currentRenderPass = this._mainRenderPassWrapper.renderPass;\n      this._setDepthTextureFormat(this._mainRenderPassWrapper);\n      this._setColorFormat(this._mainRenderPassWrapper);\n    }\n    if (this._currentRenderPass) {\n      if (this._cachedViewport) {\n        this.setViewport(this._cachedViewport);\n      }\n    }\n    this.wipeCaches();\n  }\n  //------------------------------------------------------------------------------\n  //                              Render\n  //------------------------------------------------------------------------------\n  /**\n   * @internal\n   */\n  _setColorFormat(wrapper) {\n    var _a, _b;\n    const format = (_b = (_a = wrapper.colorAttachmentGPUTextures[0]) === null || _a === void 0 ? void 0 : _a.format) !== null && _b !== void 0 ? _b : null;\n    this._cacheRenderPipeline.setColorFormat(format);\n    if (this._colorFormat === format) {\n      return;\n    }\n    this._colorFormat = format;\n  }\n  /**\n   * @internal\n   */\n  _setDepthTextureFormat(wrapper) {\n    this._cacheRenderPipeline.setDepthStencilFormat(wrapper.depthTextureFormat);\n    if (this._depthTextureFormat === wrapper.depthTextureFormat) {\n      return;\n    }\n    this._depthTextureFormat = wrapper.depthTextureFormat;\n  }\n  setDitheringState() {\n    // Does not exist in WebGPU\n  }\n  setRasterizerState() {\n    // Does not exist in WebGPU\n  }\n  /**\n   * Set various states to the webGL context\n   * @param culling defines culling state: true to enable culling, false to disable it\n   * @param zOffset defines the value to apply to zOffset (0 by default)\n   * @param force defines if states must be applied even if cache is up to date\n   * @param reverseSide defines if culling must be reversed (CCW if false, CW if true)\n   * @param cullBackFaces true to cull back faces, false to cull front faces (if culling is enabled)\n   * @param stencil stencil states to set\n   * @param zOffsetUnits defines the value to apply to zOffsetUnits (0 by default)\n   */\n  setState(culling, zOffset = 0, force, reverseSide = false, cullBackFaces, stencil, zOffsetUnits = 0) {\n    var _a, _b;\n    // Culling\n    if (this._depthCullingState.cull !== culling || force) {\n      this._depthCullingState.cull = culling;\n    }\n    // Cull face\n    const cullFace = ((_b = (_a = this.cullBackFaces) !== null && _a !== void 0 ? _a : cullBackFaces) !== null && _b !== void 0 ? _b : true) ? 1 : 2;\n    if (this._depthCullingState.cullFace !== cullFace || force) {\n      this._depthCullingState.cullFace = cullFace;\n    }\n    // Z offset\n    this.setZOffset(zOffset);\n    this.setZOffsetUnits(zOffsetUnits);\n    // Front face\n    const frontFace = reverseSide ? this._currentRenderTarget ? 1 : 2 : this._currentRenderTarget ? 2 : 1;\n    if (this._depthCullingState.frontFace !== frontFace || force) {\n      this._depthCullingState.frontFace = frontFace;\n    }\n    this._stencilStateComposer.stencilMaterial = stencil;\n  }\n  _applyRenderPassChanges(renderPass, bundleList) {\n    var _a;\n    const mustUpdateViewport = this._mustUpdateViewport(renderPass);\n    const mustUpdateScissor = this._mustUpdateScissor(renderPass);\n    const mustUpdateStencilRef = !this._stencilStateComposer.enabled ? false : this._mustUpdateStencilRef(renderPass);\n    const mustUpdateBlendColor = !this._alphaState.alphaBlend ? false : this._mustUpdateBlendColor(renderPass);\n    if (bundleList) {\n      if (mustUpdateViewport) {\n        bundleList.addItem(new WebGPURenderItemViewport(this._viewportCached.x, this._viewportCached.y, this._viewportCached.z, this._viewportCached.w));\n      }\n      if (mustUpdateScissor) {\n        bundleList.addItem(new WebGPURenderItemScissor(this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w));\n      }\n      if (mustUpdateStencilRef) {\n        bundleList.addItem(new WebGPURenderItemStencilRef((_a = this._stencilStateComposer.funcRef) !== null && _a !== void 0 ? _a : 0));\n      }\n      if (mustUpdateBlendColor) {\n        bundleList.addItem(new WebGPURenderItemBlendColor(this._alphaState._blendConstants.slice()));\n      }\n    } else {\n      if (mustUpdateViewport) {\n        this._applyViewport(renderPass);\n      }\n      if (mustUpdateScissor) {\n        this._applyScissor(renderPass);\n      }\n      if (mustUpdateStencilRef) {\n        this._applyStencilRef(renderPass);\n      }\n      if (mustUpdateBlendColor) {\n        this._applyBlendColor(renderPass);\n      }\n    }\n  }\n  _draw(drawType, fillMode, start, count, instancesCount) {\n    var _a;\n    const renderPass = this._getCurrentRenderPass();\n    const renderPassIndex = this._getCurrentRenderPassIndex();\n    const bundleList = renderPassIndex === 0 ? this._bundleList : this._bundleListRenderTarget;\n    this.applyStates();\n    const webgpuPipelineContext = this._currentEffect._pipelineContext;\n    this.bindUniformBufferBase(this._currentRenderTarget ? this._ubInvertY : this._ubDontInvertY, 0, WebGPUShaderProcessor.InternalsUBOName);\n    if (webgpuPipelineContext.uniformBuffer) {\n      webgpuPipelineContext.uniformBuffer.update();\n      this.bindUniformBufferBase(webgpuPipelineContext.uniformBuffer.getBuffer(), 0, WebGPUShaderProcessor.LeftOvertUBOName);\n    }\n    if (this._snapshotRendering.play) {\n      this._reportDrawCall();\n      return;\n    }\n    if (!this.compatibilityMode && (this._currentDrawContext.isDirty(this._currentMaterialContext.updateId) || this._currentMaterialContext.isDirty || this._currentMaterialContext.forceBindGroupCreation)) {\n      this._currentDrawContext.fastBundle = undefined;\n    }\n    const useFastPath = !this.compatibilityMode && this._currentDrawContext.fastBundle;\n    let renderPass2 = renderPass;\n    if (useFastPath || this._snapshotRendering.record) {\n      this._applyRenderPassChanges(renderPass, bundleList);\n      if (!this._snapshotRendering.record) {\n        this._counters.numBundleReuseNonCompatMode++;\n        if (this._currentDrawContext.indirectDrawBuffer) {\n          this._currentDrawContext.setIndirectData(count, instancesCount || 1, start);\n        }\n        bundleList.addBundle(this._currentDrawContext.fastBundle);\n        this._reportDrawCall();\n        return;\n      }\n      renderPass2 = bundleList.getBundleEncoder(this._cacheRenderPipeline.colorFormats, this._depthTextureFormat, this.currentSampleCount); // for snapshot recording mode\n      bundleList.numDrawCalls++;\n    }\n    let textureState = 0;\n    if (!this._caps.textureFloatLinearFiltering && this._currentMaterialContext.hasFloatTextures) {\n      let bitVal = 1;\n      for (let i = 0; i < webgpuPipelineContext.shaderProcessingContext.textureNames.length; ++i) {\n        const textureName = webgpuPipelineContext.shaderProcessingContext.textureNames[i];\n        const texture = (_a = this._currentMaterialContext.textures[textureName]) === null || _a === void 0 ? void 0 : _a.texture;\n        if ((texture === null || texture === void 0 ? void 0 : texture.type) === 1) {\n          textureState |= bitVal;\n        }\n        bitVal = bitVal << 1;\n      }\n    }\n    this._currentMaterialContext.textureState = textureState;\n    const pipeline = this._cacheRenderPipeline.getRenderPipeline(fillMode, this._currentEffect, this.currentSampleCount, textureState);\n    const bindGroups = this._cacheBindGroups.getBindGroups(webgpuPipelineContext, this._currentDrawContext, this._currentMaterialContext);\n    if (!this._snapshotRendering.record) {\n      this._applyRenderPassChanges(renderPass, !this.compatibilityMode ? bundleList : null);\n      if (!this.compatibilityMode) {\n        this._counters.numBundleCreationNonCompatMode++;\n        renderPass2 = this._device.createRenderBundleEncoder({\n          colorFormats: this._cacheRenderPipeline.colorFormats,\n          depthStencilFormat: this._depthTextureFormat,\n          sampleCount: this.currentSampleCount\n        });\n      }\n    }\n    // bind pipeline\n    renderPass2.setPipeline(pipeline);\n    // bind index/vertex buffers\n    if (this._currentIndexBuffer) {\n      renderPass2.setIndexBuffer(this._currentIndexBuffer.underlyingResource, this._currentIndexBuffer.is32Bits ? WebGPUConstants.IndexFormat.Uint32 : WebGPUConstants.IndexFormat.Uint16, 0);\n    }\n    const vertexBuffers = this._cacheRenderPipeline.vertexBuffers;\n    for (let index = 0; index < vertexBuffers.length; index++) {\n      const vertexBuffer = vertexBuffers[index];\n      const buffer = vertexBuffer.effectiveBuffer;\n      if (buffer) {\n        renderPass2.setVertexBuffer(index, buffer.underlyingResource, vertexBuffer._validOffsetRange ? 0 : vertexBuffer.byteOffset);\n      }\n    }\n    // bind bind groups\n    for (let i = 0; i < bindGroups.length; i++) {\n      renderPass2.setBindGroup(i, bindGroups[i]);\n    }\n    // draw\n    const nonCompatMode = !this.compatibilityMode && !this._snapshotRendering.record;\n    if (nonCompatMode && this._currentDrawContext.indirectDrawBuffer) {\n      this._currentDrawContext.setIndirectData(count, instancesCount || 1, start);\n      if (drawType === 0) {\n        renderPass2.drawIndexedIndirect(this._currentDrawContext.indirectDrawBuffer, 0);\n      } else {\n        renderPass2.drawIndirect(this._currentDrawContext.indirectDrawBuffer, 0);\n      }\n    } else if (drawType === 0) {\n      renderPass2.drawIndexed(count, instancesCount || 1, start, 0, 0);\n    } else {\n      renderPass2.draw(count, instancesCount || 1, start, 0);\n    }\n    if (nonCompatMode) {\n      this._currentDrawContext.fastBundle = renderPass2.finish();\n      bundleList.addBundle(this._currentDrawContext.fastBundle);\n    }\n    this._reportDrawCall();\n  }\n  /**\n   * Draw a list of indexed primitives\n   * @param fillMode defines the primitive to use\n   * @param indexStart defines the starting index\n   * @param indexCount defines the number of index to draw\n   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n   */\n  drawElementsType(fillMode, indexStart, indexCount, instancesCount = 1) {\n    this._draw(0, fillMode, indexStart, indexCount, instancesCount);\n  }\n  /**\n   * Draw a list of unindexed primitives\n   * @param fillMode defines the primitive to use\n   * @param verticesStart defines the index of first vertex to draw\n   * @param verticesCount defines the count of vertices to draw\n   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n   */\n  drawArraysType(fillMode, verticesStart, verticesCount, instancesCount = 1) {\n    this._currentIndexBuffer = null;\n    this._draw(1, fillMode, verticesStart, verticesCount, instancesCount);\n  }\n  //------------------------------------------------------------------------------\n  //                              Dispose\n  //------------------------------------------------------------------------------\n  /**\n   * Dispose and release all associated resources\n   */\n  dispose() {\n    var _a, _b;\n    this._isDisposed = true;\n    (_a = this._mainTexture) === null || _a === void 0 ? void 0 : _a.destroy();\n    (_b = this._depthTexture) === null || _b === void 0 ? void 0 : _b.destroy();\n    this._device.destroy();\n    super.dispose();\n  }\n  //------------------------------------------------------------------------------\n  //                              Misc\n  //------------------------------------------------------------------------------\n  /**\n   * Gets the current render width\n   * @param useScreen defines if screen size must be used (or the current render target if any)\n   * @returns a number defining the current render width\n   */\n  getRenderWidth(useScreen = false) {\n    var _a, _b;\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.width;\n    }\n    return (_b = (_a = this._renderingCanvas) === null || _a === void 0 ? void 0 : _a.width) !== null && _b !== void 0 ? _b : 0;\n  }\n  /**\n   * Gets the current render height\n   * @param useScreen defines if screen size must be used (or the current render target if any)\n   * @returns a number defining the current render height\n   */\n  getRenderHeight(useScreen = false) {\n    var _a, _b;\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.height;\n    }\n    return (_b = (_a = this._renderingCanvas) === null || _a === void 0 ? void 0 : _a.height) !== null && _b !== void 0 ? _b : 0;\n  }\n  //------------------------------------------------------------------------------\n  //                              Errors\n  //------------------------------------------------------------------------------\n  /**\n   * Get the current error code of the WebGPU context\n   * @returns the error code\n   */\n  getError() {\n    // TODO WEBGPU. from the webgpu errors.\n    return 0;\n  }\n  //------------------------------------------------------------------------------\n  //                              Unused WebGPU\n  //------------------------------------------------------------------------------\n  /**\n   * @internal\n   */\n  bindSamplers() {}\n  /**\n   * @internal\n   */\n  _bindTextureDirectly() {\n    return false;\n  }\n  /**\n   * Gets a boolean indicating if all created effects are ready\n   * @returns always true - No parallel shader compilation\n   */\n  areAllEffectsReady() {\n    return true;\n  }\n  /**\n   * @internal\n   */\n  _executeWhenRenderingStateIsCompiled(pipelineContext, action) {\n    // No parallel shader compilation.\n    // No Async, so direct launch\n    action();\n  }\n  /**\n   * @internal\n   */\n  _isRenderingStateCompiled() {\n    // No parallel shader compilation.\n    return true;\n  }\n  /** @internal */\n  _getUnpackAlignement() {\n    return 1;\n  }\n  /**\n   * @internal\n   */\n  _unpackFlipY() {}\n  /**\n   * @internal\n   */\n  _bindUnboundFramebuffer() {\n    throw \"_bindUnboundFramebuffer is not implementedin WebGPU! You probably want to use restoreDefaultFramebuffer or unBindFramebuffer instead\";\n  }\n  // TODO WEBGPU. All of the below should go once engine split with baseEngine.\n  /**\n   * @internal\n   */\n  _getSamplingParameters() {\n    throw \"_getSamplingParameters is not available in WebGPU\";\n  }\n  /**\n   * @internal\n   */\n  getUniforms() {\n    return [];\n  }\n  /**\n   * @internal\n   */\n  setIntArray() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setIntArray2() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setIntArray3() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setIntArray4() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setArray() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setArray2() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setArray3() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setArray4() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setMatrices() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setMatrix3x3() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setMatrix2x2() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setFloat() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setFloat2() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setFloat3() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setFloat4() {\n    return false;\n  }\n}\n// Default glslang options.\nWebGPUEngine._GLSLslangDefaultOptions = {\n  jsPath: \"glslang/glslang.js\",\n  wasmPath: \"glslang/glslang.wasm\"\n};\n/** true to enable using TintWASM to convert Spir-V to WGSL */\nWebGPUEngine.UseTWGSL = true;","map":{"version":3,"names":["Logger","Color4","Engine","InternalTexture","InternalTextureSource","Effect","WebGPUConstants","VertexBuffer","WebGPUPipelineContext","WebGPUShaderProcessorGLSL","WebGPUShaderProcessorWGSL","WebGPUShaderProcessingContext","Tools","WebGPUTextureHelper","WebGPUBufferManager","WebGPUHardwareTexture","UniformBuffer","WebGPURenderPassWrapper","WebGPUCacheSampler","WebGPUCacheRenderPipelineTree","WebGPUStencilStateComposer","WebGPUDepthCullingState","DrawWrapper","WebGPUMaterialContext","WebGPUDrawContext","WebGPUCacheBindGroups","WebGPUClearQuad","WebGPURenderItemBlendColor","WebGPURenderItemScissor","WebGPURenderItemStencilRef","WebGPURenderItemViewport","WebGPUBundleList","WebGPUTimestampQuery","WebGPUOcclusionQuery","Observable","ShaderCodeInliner","WebGPUTintWASM","WebGPUShaderProcessor","ShaderLanguage","WebGPUSnapshotRendering","viewDescriptorSwapChainAntialiasing","label","dimension","TextureDimension","E2d","format","undefined","mipLevelCount","arrayLayerCount","viewDescriptorSwapChain","disableUniformityAnalysisMarker","tempColor4","WebGPUEngine","snapshotRenderingMode","_snapshotRendering","mode","snapshotRenderingReset","reset","snapshotRendering","enabled","activate","disableCacheSamplers","_cacheSampler","disabled","disable","disableCacheRenderPipelines","_cacheRenderPipeline","disableCacheBindGroups","_cacheBindGroups","IsSupportedAsync","navigator","gpu","Promise","resolve","requestAdapter","then","adapter","catch","IsSupported","Warn","supportsUniformBuffers","supportedExtensions","_adapterSupportedExtensions","enabledExtensions","_deviceEnabledExtensions","supportedLimits","_adapterSupportedLimits","currentLimits","_deviceLimits","description","name","version","getInfo","vendor","_adapterInfo","renderer","architecture","compatibilityMode","_compatibilityMode","currentSampleCount","_currentRenderTarget","samples","_mainPassSampleCount","CreateAsync","canvas","options","engine","initAsync","glslangOptions","twgslOptions","constructor","_a","antialias","_uploadEncoderDescriptor","_renderEncoderDescriptor","_renderTargetEncoderDescriptor","_clearDepthValue","_clearReverseDepthValue","_clearStencilValue","_defaultSampleCount","_glslang","_tintWASM","device","_compiledComputeEffects","_counters","numEnableEffects","numEnableDrawWrapper","numBundleCreationNonCompatMode","numBundleReuseNonCompatMode","countersLastFrame","numMaxUncapturedErrors","_commandBuffers","_currentRenderPass","_mainRenderPassWrapper","_rttRenderPassWrapper","_pendingDebugCommands","_onAfterUnbindFrameBufferObservable","_currentOverrideVertexBuffers","_currentIndexBuffer","_colorWriteLocal","_forceEnableEffect","dbgShowShaderCode","dbgSanityChecks","dbgVerboseLogsForFirstFrames","dbgVerboseLogsNumFrames","dbgLogIfNotDrawWrapper","dbgShowEmptyEnableEffectCalls","isNDCHalfZRange","hasOriginBottomLeft","_viewportsCurrent","x","y","w","h","_scissorsCurrent","_scissorCached","z","_stencilRefsCurrent","_blendColorsCurrent","_name","deviceDescriptor","enableGPUDebugMarkers","_b","Log","Version","Error","swapChainFormat","getPreferredCanvasFormat","_isWebGPU","_shaderPlatformName","_renderingCanvas","_options","_setupMobileChecks","_sharedInit","_shaderProcessor","_shaderProcessorWGSL","_initGlslang","glslang","UseTWGSL","initTwgsl","msg","_adapter","features","forEach","feature","push","limits","requestAdapterInfo","adapterInfo","requiredFeatures","_c","enableAllFeatures","requestedExtensions","validExtensions","extension","indexOf","setMaximumLimits","requiredLimits","requestDevice","_device","numUncapturedErrors","addEventListener","event","error","message","_doNotHandleContextLost","lost","info","_isDisposed","_contextWasLost","onContextLostObservable","notifyObservers","_restoreEngineAfterContextLost","e","_bufferManager","_textureHelper","_timestampQuery","_occlusionQuery","createQuerySet","_bundleList","_bundleListRenderTarget","_snapshotRenderingMode","_ubInvertY","createBuffer","Float32Array","BufferUsage","Uniform","CopyDst","_ubDontInvertY","_count","console","log","_uploadEncoder","createCommandEncoder","_renderEncoder","_renderTargetEncoder","_initializeLimits","_emptyVertexBuffer","_caps","textureFloatLinearFiltering","_depthCullingState","_stencilStateComposer","stencilGlobal","_stencilState","depthTest","depthFunc","depthMask","setCommandEncoder","_clearQuad","_defaultDrawContext","createDrawContext","_currentDrawContext","_defaultMaterialContext","createMaterialContext","_currentMaterialContext","_initializeContextAndSwapChain","_initializeMainAttachments","resize","trace","Object","assign","_GLSLslangDefaultOptions","self","wasmPath","jsPath","LoadBabylonScriptAsync","GetBabylonScriptURL","reject","maxTexturesImageUnits","maxSampledTexturesPerShaderStage","maxVertexTextureImageUnits","maxCombinedTexturesImageUnits","maxTextureSize","maxTextureDimension2D","maxCubemapTextureSize","maxRenderTextureSize","maxVertexAttribs","maxVertexAttributes","maxVaryingVectors","maxInterStageShaderVariables","maxFragmentUniformVectors","Math","floor","maxUniformBufferBindingSize","maxVertexUniformVectors","standardDerivatives","astc","FeatureName","TextureCompressionASTC","s3tc","TextureCompressionBC","pvrtc","etc1","etc2","TextureCompressionETC2","bptc","maxAnisotropy","uintIndices","fragmentDepthSupported","highPrecisionShaderSupported","colorBufferFloat","textureFloat","Float32Filterable","textureFloatRender","textureHalfFloat","textureHalfFloatLinearFiltering","textureHalfFloatRender","textureLOD","texelFetch","drawBuffersExtension","depthTextureExtension","vertexArrayObject","instancedArrays","timerQuery","BigUint64Array","TimestampQuery","supportOcclusionQuery","canUseTimestampForTimerQuery","multiview","oculusMultiview","parallelShaderCompile","blendMinMax","maxMSAASamples","canUseGLInstanceID","canUseGLVertexID","supportComputeShaders","supportSRGBBuffers","supportTransformFeedbacks","textureMaxLevel","texture2DArrayMaxLayerCount","maxTextureArrayLayers","disableMorphTargetTexture","_features","forceBitmapOverHTMLImageElement","supportRenderAndCopyToLodForFloatTextures","supportDepthStencilTexture","supportShadowSamplers","uniformBufferHardCheckMatrix","allowTexturePrefiltering","trackUbosInFrame","checkUbosContentBeforeUpload","supportCSM","basisNeedsPOT","support3DTextures","needTypeSuffixInShaderConstants","supportMSAA","supportSSAO2","supportExtendedTextureFormats","supportSwitchCaseInShader","supportSyncTextureRead","needsInvertingBitmap","useUBOBindingCache","needShaderCodeInlining","needToAlwaysBindUniformBuffers","supportRenderPasses","supportSpriteInstancing","forceVertexBufferStrideMultiple4Bytes","_collectUbosUpdatedInFrame","_context","getContext","_configureContext","_colorFormat","colorAttachmentGPUTextures","flushFramebuffer","_mainTextureExtends","width","getRenderWidth","height","getRenderHeight","depthOrArrayLayers","bufferDataUpdate","setSubData","mainColorAttachments","mainTextureDescriptor","size","sampleCount","usage","TextureUsage","RenderAttachment","_mainTexture","releaseTexture","createTexture","view","createView","clearValue","loadOp","LoadOp","Clear","storeOp","StoreOp","Store","depthTextureFormat","isStencilEnable","TextureFormat","Depth24PlusStencil8","Depth32Float","_setDepthTextureFormat","depthTextureDescriptor","_depthTexture","mainDepthAttachment","depthClearValue","depthLoadOp","depthStoreOp","stencilClearValue","stencilLoadOp","stencilStoreOp","renderPassDescriptor","colorAttachments","depthStencilAttachment","configure","CopySrc","alphaMode","premultipliedAlpha","CanvasAlphaMode","Premultiplied","Opaque","setSize","forceSetSize","_getShaderProcessor","shaderLanguage","WGSL","_getShaderProcessingContext","applyStates","apply","setAlphaBlendEnabled","_alphaState","alphaBlend","wipeCaches","bruteForce","preventCacheWipeBetweenFrames","setBuffers","_alphaMode","_alphaEquation","setAlphaBlendFactors","_blendFunctionParameters","_blendEquationParameters","setColorWrite","_cachedVertexBuffers","_cachedIndexBuffer","_cachedEffectForVertexBuffers","enable","setWriteMask","getColorWrite","_resetCurrentViewport","index","_mustUpdateViewport","renderPass","_viewportCached","update","_applyViewport","setViewport","_viewport","_resetCurrentScissor","_mustUpdateScissor","_applyScissor","setScissorRect","_scissorIsActive","enableScissor","disableScissor","_resetCurrentStencilRef","_mustUpdateStencilRef","funcRef","_applyStencilRef","setStencilReference","_resetCurrentColorBlend","_mustUpdateBlendColor","colorBlend","_blendConstants","_applyBlendColor","setBlendConstant","clear","color","backBuffer","depth","stencil","a","hasScissor","_startRenderTargetRenderPass","addItem","_clearFullQuad","_endRenderTargetRenderPass","_startMainRenderPass","clearColor","clearDepth","clearStencil","_getCurrentRenderPass","renderPassIndex","_getCurrentRenderPassIndex","bundleList","setColorFormat","setDepthStencilFormat","_depthTextureFormat","setMRTAttachments","mrtAttachments","mrtTextureArray","mrtTextureCount","bundle","addBundle","_reportDrawCall","createVertexBuffer","data","_updatable","Array","ArrayBuffer","Uint8Array","dataBuffer","Vertex","createDynamicVertexBuffer","createIndexBuffer","indices","is32Bits","Uint32Array","Int32Array","Uint16Array","length","Index","_createBuffer","creationFlags","flags","Storage","bindBuffersDirectly","updateAndBindInstancesBuffer","bindBuffers","vertexBuffers","indexBuffer","effect","overrideVertexBuffers","_releaseBuffer","buffer","releaseBuffer","createEffect","baseName","attributesNamesOrOptions","uniformsNamesOrEngine","samplers","defines","fallbacks","onCompiled","onError","indexParameters","GLSL","vertex","vertexElement","vertexToken","vertexSource","fragment","fragmentElement","fragmentToken","fragmentSource","globalDefines","_getGlobalDefines","fullDefines","_compiledEffects","compiledEffect","isReady","_compileRawShaderToSpirV","source","type","compileGLSL","_compileShaderToSpirV","shaderVersion","_getWGSLShader","split","join","_createPipelineStageDescriptor","vertexShader","fragmentShader","disableUniformityAnalysisInVertex","disableUniformityAnalysisInFragment","convertSpirV2WGSL","vertexStage","module","createShaderModule","code","entryPoint","fragmentStage","_compileRawPipelineStageDescriptor","vertexCode","fragmentCode","_compilePipelineStageDescriptor","onBeforeShaderCompilationObservable","program","onAfterShaderCompilationObservable","createRawShaderProgram","createShaderProgram","inlineShaderCode","sci","debug","processCode","createPipelineContext","shaderProcessingContext","_preparePipelineContext","pipelineContext","vertexSourceCode","fragmentSourceCode","createAsRaw","rawVertexSourceCode","rawFragmentSourceCode","rebuildRebind","webGpuContext","sources","rawVertex","rawFragment","stages","getAttributes","attributesNames","results","gpuPipelineContext","i","attributeName","attributeLocation","availableAttributes","enableEffect","isNewEffect","IsWrapper","_currentEffect","uniqueId","materialContext","drawContext","stencilMaterial","onBind","_onBindObservable","_releaseEffect","_key","_deletePipelineContext","getPipelineContext","releaseEffects","webGPUPipelineContext","webgpuPipelineContext","dispose","needPOTTextures","_createHardwareTexture","_releaseTexture","texture","_internalTexturesCache","splice","_getRGBABufferInternalSizedFormat","updateTextureComparisonFunction","comparisonFunction","_comparisonFunction","_createInternalTexture","delayGPUTextureCreation","Unknown","fullOptions","generateMipMaps","samplingMode","useSRGBBuffer","layers","baseWidth","baseHeight","is2DArray","_cachedWrapU","_cachedWrapV","_useSRGBBuffer","createGPUTextureForInternalTexture","url","noMipmap","invertY","scene","onLoad","fallback","forcedExtension","mimeType","loaderOptions","_createTextureBase","img","isCompressed","processFunction","imageBitmap","_hardwareTexture","underlyingResource","gpuTextureWrapper","IsImageBitmap","updateTexture","_generateMipmaps","removePendingData","onLoadedObservable","wrapWebGPUTexture","hardwareTexture","internalTexture","wrapWebGLTexture","generateMipMapsForCubemap","gpuTexture","RenderTarget","MultiRenderTarget","updateTextureSamplingMode","updateTextureWrappingMode","wrapU","wrapV","wrapR","is3D","_cachedWrapR","updateTextureDimensions","additionalUsages","textureAdditionalUsages","release","_setInternalTexture","_pipelineContext","availableTexture","availableTextures","setTexture","autoBindSampler","samplerName","AutoSamplerSuffix","setSampler","channel","unused","_setTexture","setTextureArray","textures","toString","isPartOfTextureArray","depthStencilTexture","video","delayLoadState","delayLoad","getInternalTexture","isCube","emptyCubeTexture","emptyTexture3D","emptyTexture2DArray","emptyTexture","isMultiview","_cachedCoordinatesMode","coordinatesMode","textureWrapMode","_setAnisotropicLevel","anisotropicFilteringLevel","target","_cachedAnisotropicFilteringLevel","min","_bindTexture","generateMipmaps","commandEncoder","gpuHardwareTexture","mipmapCount","ComputeNumMipmapLevels","generateCubeMipmaps","updateTextureData","imageData","xOffset","yOffset","faceIndex","lod","byteOffset","byteLength","_uploadCompressedDataToTextureDirectly","internalFormat","_uploadDataToTextureDirectly","babylonInternalFormat","useTextureWidthAndHeight","lodMaxWidth","round","LOG2E","lodMaxHeight","pow","max","_uploadArrayBufferViewToTexture","_uploadImageToTexture","image","HTMLImageElement","bitmap","ceil","readPixels","hasAlpha","flushRenderer","renderPassWrapper","gpuTextureFormat","beginFrame","endFrame","_endMainRenderPass","destroyDeferredTextures","destroyDeferredBuffers","list","_UpdatedUbosInFrame","reopenPass","currentRenderPassIsNULL","currentPasses","finish","queue","submit","startFrame","_currentFrameBufferIsDefaultFrameBuffer","renderTargetWrapper","setClearStates","rtWrapper","_depthStencilTexture","gpuDepthStencilWrapper","gpuDepthStencilTexture","gpuDepthStencilMSAATexture","getMSAATexture","depthTextureView","depthAttachmentViewDescriptor","depthMSAATextureView","depthTextureHasStencil","HasStencilAspect","useReverseDepthBuffer","setDepthFunctionToGreaterOrEqual","clearColorForIntegerRT","r","g","b","mustClearColor","mustClearDepth","mustClearStencil","_attachments","isMulti","_mrtAttachments","_defaultAttachments","mrtTexture","gpuMRTWrapper","gpuMRTTexture","gpuMSAATexture","layerIndex","layerIndices","_d","faceIndices","viewDescriptor","colorAttachmentViewDescriptor","baseArrayLayer","msaaViewDescriptor","isRTInteger","colorTextureView","colorMSAATextureView","resolveTarget","Load","setMRT","gpuWrapper","_e","_debugPushGroup","call","_f","_depthStencilTextureWithStencil","occlusionQuerySet","_g","hasQueries","querySet","beginRenderPass","_h","_debugFlushPendingCommands","endRenderTargetPass","run","end","_debugPopGroup","swapChainTexture","getCurrentTexture","set","_isStencilEnable","endMainRenderPass","play","bindFramebuffer","requiredWidth","requiredHeight","forceFullscreenViewport","lodLevel","layer","unBindFramebuffer","_currentLayer","GetWebGPUTextureFormat","_setColorFormat","TextureViewDimension","baseMipLevel","aspect","TextureAspect","All","_cachedViewport","disableGenerateMipMaps","onBeforeUnbind","saveCRT","restoreDefaultFramebuffer","wrapper","setDitheringState","setRasterizerState","setState","culling","zOffset","force","reverseSide","cullBackFaces","zOffsetUnits","cull","cullFace","setZOffset","setZOffsetUnits","frontFace","_applyRenderPassChanges","mustUpdateViewport","mustUpdateScissor","mustUpdateStencilRef","mustUpdateBlendColor","slice","_draw","drawType","fillMode","start","count","instancesCount","bindUniformBufferBase","InternalsUBOName","uniformBuffer","getBuffer","LeftOvertUBOName","isDirty","updateId","forceBindGroupCreation","fastBundle","useFastPath","renderPass2","record","indirectDrawBuffer","setIndirectData","getBundleEncoder","colorFormats","numDrawCalls","textureState","hasFloatTextures","bitVal","textureNames","textureName","pipeline","getRenderPipeline","bindGroups","getBindGroups","createRenderBundleEncoder","depthStencilFormat","setPipeline","setIndexBuffer","IndexFormat","Uint32","Uint16","vertexBuffer","effectiveBuffer","setVertexBuffer","_validOffsetRange","setBindGroup","nonCompatMode","drawIndexedIndirect","drawIndirect","drawIndexed","draw","drawElementsType","indexStart","indexCount","drawArraysType","verticesStart","verticesCount","destroy","useScreen","getError","bindSamplers","_bindTextureDirectly","areAllEffectsReady","_executeWhenRenderingStateIsCompiled","action","_isRenderingStateCompiled","_getUnpackAlignement","_unpackFlipY","_bindUnboundFramebuffer","_getSamplingParameters","getUniforms","setIntArray","setIntArray2","setIntArray3","setIntArray4","setArray","setArray2","setArray3","setArray4","setMatrices","setMatrix3x3","setMatrix2x2","setFloat","setFloat2","setFloat3","setFloat4"],"sources":["../../../../dev/core/src/Engines/webgpuEngine.ts"],"sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport type { Nullable, DataArray, IndicesArray, Immutable } from \"../types\";\r\nimport { Color4 } from \"../Maths/math\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport type { IEffectCreationOptions } from \"../Materials/effect\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport type { EffectFallbacks } from \"../Materials/effectFallbacks\";\r\nimport { Constants } from \"./constants\";\r\nimport * as WebGPUConstants from \"./WebGPU/webgpuConstants\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { IWebGPURenderPipelineStageDescriptor } from \"./WebGPU/webgpuPipelineContext\";\r\nimport { WebGPUPipelineContext } from \"./WebGPU/webgpuPipelineContext\";\r\nimport type { IPipelineContext } from \"./IPipelineContext\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { IShaderProcessor } from \"./Processors/iShaderProcessor\";\r\nimport { WebGPUShaderProcessorGLSL } from \"./WebGPU/webgpuShaderProcessorsGLSL\";\r\nimport { WebGPUShaderProcessorWGSL } from \"./WebGPU/webgpuShaderProcessorsWGSL\";\r\nimport type { ShaderProcessingContext } from \"./Processors/shaderProcessingOptions\";\r\nimport { WebGPUShaderProcessingContext } from \"./WebGPU/webgpuShaderProcessingContext\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { WebGPUTextureHelper } from \"./WebGPU/webgpuTextureHelper\";\r\nimport type { ISceneLike, ThinEngineOptions } from \"./thinEngine\";\r\nimport { WebGPUBufferManager } from \"./WebGPU/webgpuBufferManager\";\r\nimport type { HardwareTextureWrapper } from \"../Materials/Textures/hardwareTextureWrapper\";\r\nimport { WebGPUHardwareTexture } from \"./WebGPU/webgpuHardwareTexture\";\r\nimport type { IColor4Like } from \"../Maths/math.like\";\r\nimport { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport { WebGPURenderPassWrapper } from \"./WebGPU/webgpuRenderPassWrapper\";\r\nimport { WebGPUCacheSampler } from \"./WebGPU/webgpuCacheSampler\";\r\nimport type { WebGPUCacheRenderPipeline } from \"./WebGPU/webgpuCacheRenderPipeline\";\r\nimport { WebGPUCacheRenderPipelineTree } from \"./WebGPU/webgpuCacheRenderPipelineTree\";\r\nimport { WebGPUStencilStateComposer } from \"./WebGPU/webgpuStencilStateComposer\";\r\nimport { WebGPUDepthCullingState } from \"./WebGPU/webgpuDepthCullingState\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport { WebGPUMaterialContext } from \"./WebGPU/webgpuMaterialContext\";\r\nimport { WebGPUDrawContext } from \"./WebGPU/webgpuDrawContext\";\r\nimport { WebGPUCacheBindGroups } from \"./WebGPU/webgpuCacheBindGroups\";\r\nimport { WebGPUClearQuad } from \"./WebGPU/webgpuClearQuad\";\r\nimport type { IStencilState } from \"../States/IStencilState\";\r\nimport { WebGPURenderItemBlendColor, WebGPURenderItemScissor, WebGPURenderItemStencilRef, WebGPURenderItemViewport, WebGPUBundleList } from \"./WebGPU/webgpuBundleList\";\r\nimport { WebGPUTimestampQuery } from \"./WebGPU/webgpuTimestampQuery\";\r\nimport type { ComputeEffect } from \"../Compute/computeEffect\";\r\nimport { WebGPUOcclusionQuery } from \"./WebGPU/webgpuOcclusionQuery\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { ShaderCodeInliner } from \"./Processors/shaderCodeInliner\";\r\nimport type { TwgslOptions } from \"./WebGPU/webgpuTintWASM\";\r\nimport { WebGPUTintWASM } from \"./WebGPU/webgpuTintWASM\";\r\nimport type { ExternalTexture } from \"../Materials/Textures/externalTexture\";\r\nimport { WebGPUShaderProcessor } from \"./WebGPU/webgpuShaderProcessor\";\r\nimport { ShaderLanguage } from \"../Materials/shaderLanguage\";\r\nimport type { InternalTextureCreationOptions, TextureSize } from \"../Materials/Textures/textureCreationOptions\";\r\nimport { WebGPUSnapshotRendering } from \"./WebGPU/webgpuSnapshotRendering\";\r\nimport type { WebGPUDataBuffer } from \"../Meshes/WebGPU/webgpuDataBuffer\";\r\nimport type { WebGPURenderTargetWrapper } from \"./WebGPU/webgpuRenderTargetWrapper\";\r\n\r\nimport \"../Buffers/buffer.align\";\r\n\r\nimport \"../ShadersWGSL/postprocess.vertex\";\r\n\r\ndeclare function importScripts(...urls: string[]): void;\r\n\r\nimport type { VideoTexture } from \"../Materials/Textures/videoTexture\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { RenderTargetWrapper } from \"./renderTargetWrapper\";\r\n\r\nconst viewDescriptorSwapChainAntialiasing: GPUTextureViewDescriptor = {\r\n    label: `TextureView_SwapChain_ResolveTarget`,\r\n    dimension: WebGPUConstants.TextureDimension.E2d,\r\n    format: undefined as any, // will be updated with the right value\r\n    mipLevelCount: 1,\r\n    arrayLayerCount: 1,\r\n};\r\n\r\nconst viewDescriptorSwapChain: GPUTextureViewDescriptor = {\r\n    label: `TextureView_SwapChain`,\r\n    dimension: WebGPUConstants.TextureDimension.E2d,\r\n    format: undefined as any, // will be updated with the right value\r\n    mipLevelCount: 1,\r\n    arrayLayerCount: 1,\r\n};\r\n\r\nconst disableUniformityAnalysisMarker = \"/* disable_uniformity_analysis */\";\r\n\r\nconst tempColor4 = new Color4();\r\n\r\n/**\r\n * Options to load the associated Glslang library\r\n */\r\nexport interface GlslangOptions {\r\n    /**\r\n     * Defines an existing instance of Glslang (useful in modules who do not access the global instance).\r\n     */\r\n    glslang?: any;\r\n    /**\r\n     * Defines the URL of the glslang JS File.\r\n     */\r\n    jsPath?: string;\r\n    /**\r\n     * Defines the URL of the glslang WASM File.\r\n     */\r\n    wasmPath?: string;\r\n}\r\n\r\n/**\r\n * Options to create the WebGPU engine\r\n */\r\nexport interface WebGPUEngineOptions extends ThinEngineOptions, GPURequestAdapterOptions {\r\n    /**\r\n     * Defines the category of adapter to use.\r\n     * Is it the discrete or integrated device.\r\n     */\r\n    powerPreference?: GPUPowerPreference;\r\n\r\n    /**\r\n     * When set to true, indicates that only a fallback adapter may be returned when requesting an adapter.\r\n     * If the user agent does not support a fallback adapter, will cause requestAdapter() to resolve to null.\r\n     * Default: false\r\n     */\r\n    forceFallbackAdapter?: boolean;\r\n\r\n    /**\r\n     * Defines the device descriptor used to create a device once we have retrieved an appropriate adapter\r\n     */\r\n    deviceDescriptor?: GPUDeviceDescriptor;\r\n\r\n    /**\r\n     * When requesting the device, enable all the features supported by the adapter. Default: false\r\n     * Note that this setting is ignored if you explicitely set deviceDescriptor.requiredFeatures\r\n     */\r\n    enableAllFeatures?: boolean;\r\n\r\n    /**\r\n     * When requesting the device, set the required limits to the maximum possible values (the ones from adapter.limits). Default: false\r\n     * Note that this setting is ignored if you explicitely set deviceDescriptor.requiredLimits\r\n     */\r\n    setMaximumLimits?: boolean;\r\n\r\n    /**\r\n     * Defines the requested Swap Chain Format.\r\n     */\r\n    swapChainFormat?: GPUTextureFormat;\r\n\r\n    /**\r\n     * Defines whether we should generate debug markers in the gpu command lists (can be seen with PIX for eg). Default: false\r\n     */\r\n    enableGPUDebugMarkers?: boolean;\r\n\r\n    /**\r\n     * Options to load the associated Glslang library\r\n     */\r\n    glslangOptions?: GlslangOptions;\r\n\r\n    /**\r\n     * Options to load the associated Twgsl library\r\n     */\r\n    twgslOptions?: TwgslOptions;\r\n}\r\n\r\n/**\r\n * The web GPU engine class provides support for WebGPU version of babylon.js.\r\n * @since 5.0.0\r\n */\r\nexport class WebGPUEngine extends Engine {\r\n    // Default glslang options.\r\n    private static readonly _GLSLslangDefaultOptions: GlslangOptions = {\r\n        jsPath: \"glslang/glslang.js\",\r\n        wasmPath: \"glslang/glslang.wasm\",\r\n    };\r\n\r\n    /** true to enable using TintWASM to convert Spir-V to WGSL */\r\n    public static UseTWGSL = true;\r\n\r\n    // Page Life cycle and constants\r\n    private readonly _uploadEncoderDescriptor = { label: \"upload\" };\r\n    private readonly _renderEncoderDescriptor = { label: \"render\" };\r\n    private readonly _renderTargetEncoderDescriptor = { label: \"renderTarget\" };\r\n    /** @internal */\r\n    public readonly _clearDepthValue = 1;\r\n    /** @internal */\r\n    public readonly _clearReverseDepthValue = 0;\r\n    /** @internal */\r\n    public readonly _clearStencilValue = 0;\r\n    private readonly _defaultSampleCount = 4; // Only supported value for now.\r\n\r\n    // Engine Life Cycle\r\n    /** @internal */\r\n    public _options: WebGPUEngineOptions;\r\n    private _glslang: any = null;\r\n    private _tintWASM: Nullable<WebGPUTintWASM> = null;\r\n    private _adapter: GPUAdapter;\r\n    private _adapterSupportedExtensions: GPUFeatureName[];\r\n    private _adapterInfo: GPUAdapterInfo = {\r\n        vendor: \"\",\r\n        architecture: \"\",\r\n        device: \"\",\r\n        description: \"\",\r\n    };\r\n    private _adapterSupportedLimits: GPUSupportedLimits;\r\n    /** @internal */\r\n    public _device: GPUDevice;\r\n    private _deviceEnabledExtensions: GPUFeatureName[];\r\n    private _deviceLimits: GPUSupportedLimits;\r\n    private _context: GPUCanvasContext;\r\n    private _mainPassSampleCount: number;\r\n    /** @internal */\r\n    public _textureHelper: WebGPUTextureHelper;\r\n    /** @internal */\r\n    public _bufferManager: WebGPUBufferManager;\r\n    private _clearQuad: WebGPUClearQuad;\r\n    /** @internal */\r\n    public _cacheSampler: WebGPUCacheSampler;\r\n    /** @internal */\r\n    public _cacheRenderPipeline: WebGPUCacheRenderPipeline;\r\n    private _cacheBindGroups: WebGPUCacheBindGroups;\r\n    private _emptyVertexBuffer: VertexBuffer;\r\n    /** @internal */\r\n    public _mrtAttachments: number[];\r\n    /** @internal */\r\n    public _timestampQuery: WebGPUTimestampQuery;\r\n    /** @internal */\r\n    public _occlusionQuery: WebGPUOcclusionQuery;\r\n    /** @internal */\r\n    public _compiledComputeEffects: { [key: string]: ComputeEffect } = {};\r\n    /** @internal */\r\n    public _counters: {\r\n        numEnableEffects: number;\r\n        numEnableDrawWrapper: number;\r\n        numBundleCreationNonCompatMode: number;\r\n        numBundleReuseNonCompatMode: number;\r\n    } = {\r\n        numEnableEffects: 0,\r\n        numEnableDrawWrapper: 0,\r\n        numBundleCreationNonCompatMode: 0,\r\n        numBundleReuseNonCompatMode: 0,\r\n    };\r\n    /**\r\n     * Counters from last frame\r\n     */\r\n    public readonly countersLastFrame: {\r\n        numEnableEffects: number;\r\n        numEnableDrawWrapper: number;\r\n        numBundleCreationNonCompatMode: number;\r\n        numBundleReuseNonCompatMode: number;\r\n    } = {\r\n        numEnableEffects: 0,\r\n        numEnableDrawWrapper: 0,\r\n        numBundleCreationNonCompatMode: 0,\r\n        numBundleReuseNonCompatMode: 0,\r\n    };\r\n    /**\r\n     * Max number of uncaptured error messages to log\r\n     */\r\n    public numMaxUncapturedErrors = 20;\r\n\r\n    // Some of the internal state might change during the render pass.\r\n    // This happens mainly during clear for the state\r\n    // And when the frame starts to swap the target texture from the swap chain\r\n    private _mainTexture: GPUTexture;\r\n    private _depthTexture: GPUTexture;\r\n    private _mainTextureExtends: GPUExtent3D;\r\n    private _depthTextureFormat: GPUTextureFormat | undefined;\r\n    private _colorFormat: GPUTextureFormat | null;\r\n    /** @internal */\r\n    public _ubInvertY: WebGPUDataBuffer;\r\n    /** @internal */\r\n    public _ubDontInvertY: WebGPUDataBuffer;\r\n\r\n    // Frame Life Cycle (recreated each frame)\r\n    /** @internal */\r\n    public _uploadEncoder: GPUCommandEncoder;\r\n    /** @internal */\r\n    public _renderEncoder: GPUCommandEncoder;\r\n    /** @internal */\r\n    public _renderTargetEncoder: GPUCommandEncoder;\r\n\r\n    private _commandBuffers: GPUCommandBuffer[] = [null as any, null as any, null as any];\r\n\r\n    // Frame Buffer Life Cycle (recreated for each render target pass)\r\n    /** @internal */\r\n    public _currentRenderPass: Nullable<GPURenderPassEncoder> = null;\r\n    /** @internal */\r\n    public _mainRenderPassWrapper: WebGPURenderPassWrapper = new WebGPURenderPassWrapper();\r\n    /** @internal */\r\n    public _rttRenderPassWrapper: WebGPURenderPassWrapper = new WebGPURenderPassWrapper();\r\n    /** @internal */\r\n    public _pendingDebugCommands: Array<[string, Nullable<string>]> = [];\r\n    /** @internal */\r\n    public _bundleList: WebGPUBundleList;\r\n    /** @internal */\r\n    public _bundleListRenderTarget: WebGPUBundleList;\r\n    /** @internal */\r\n    public _onAfterUnbindFrameBufferObservable = new Observable<WebGPUEngine>();\r\n\r\n    // DrawCall Life Cycle\r\n    // Effect is on the parent class\r\n    // protected _currentEffect: Nullable<Effect> = null;\r\n    private _defaultDrawContext: WebGPUDrawContext;\r\n    private _defaultMaterialContext: WebGPUMaterialContext;\r\n    /** @internal */\r\n    public _currentDrawContext: WebGPUDrawContext;\r\n    /** @internal */\r\n    public _currentMaterialContext: WebGPUMaterialContext;\r\n    private _currentOverrideVertexBuffers: Nullable<{ [key: string]: Nullable<VertexBuffer> }> = null;\r\n    private _currentIndexBuffer: Nullable<DataBuffer> = null;\r\n    private _colorWriteLocal = true;\r\n    private _forceEnableEffect = false;\r\n\r\n    // TODO WEBGPU remove those variables when code stabilized\r\n    /** @internal */\r\n    public dbgShowShaderCode = false;\r\n    /** @internal */\r\n    public dbgSanityChecks = true;\r\n    /** @internal */\r\n    public dbgVerboseLogsForFirstFrames = false;\r\n    /** @internal */\r\n    public dbgVerboseLogsNumFrames = 10;\r\n    /** @internal */\r\n    public dbgLogIfNotDrawWrapper = true;\r\n    /** @internal */\r\n    public dbgShowEmptyEnableEffectCalls = true;\r\n\r\n    private _snapshotRendering: WebGPUSnapshotRendering;\r\n\r\n    /**\r\n     * Gets or sets the snapshot rendering mode\r\n     */\r\n    public get snapshotRenderingMode(): number {\r\n        return this._snapshotRendering.mode;\r\n    }\r\n\r\n    public set snapshotRenderingMode(mode: number) {\r\n        this._snapshotRendering.mode = mode;\r\n    }\r\n\r\n    /**\r\n     * Creates a new snapshot at the next frame using the current snapshotRenderingMode\r\n     */\r\n    public snapshotRenderingReset(): void {\r\n        this._snapshotRendering.reset();\r\n    }\r\n\r\n    /**\r\n     * Enables or disables the snapshot rendering mode\r\n     * Note that the WebGL engine does not support snapshot rendering so setting the value won't have any effect for this engine\r\n     */\r\n    public get snapshotRendering(): boolean {\r\n        return this._snapshotRendering.enabled;\r\n    }\r\n\r\n    public set snapshotRendering(activate) {\r\n        this._snapshotRendering.enabled = activate;\r\n    }\r\n\r\n    /**\r\n     * Sets this to true to disable the cache for the samplers. You should do it only for testing purpose!\r\n     */\r\n    public get disableCacheSamplers(): boolean {\r\n        return this._cacheSampler ? this._cacheSampler.disabled : false;\r\n    }\r\n\r\n    public set disableCacheSamplers(disable: boolean) {\r\n        if (this._cacheSampler) {\r\n            this._cacheSampler.disabled = disable;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets this to true to disable the cache for the render pipelines. You should do it only for testing purpose!\r\n     */\r\n    public get disableCacheRenderPipelines(): boolean {\r\n        return this._cacheRenderPipeline ? this._cacheRenderPipeline.disabled : false;\r\n    }\r\n\r\n    public set disableCacheRenderPipelines(disable: boolean) {\r\n        if (this._cacheRenderPipeline) {\r\n            this._cacheRenderPipeline.disabled = disable;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets this to true to disable the cache for the bind groups. You should do it only for testing purpose!\r\n     */\r\n    public get disableCacheBindGroups(): boolean {\r\n        return this._cacheBindGroups ? this._cacheBindGroups.disabled : false;\r\n    }\r\n\r\n    public set disableCacheBindGroups(disable: boolean) {\r\n        if (this._cacheBindGroups) {\r\n            this._cacheBindGroups.disabled = disable;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a Promise<boolean> indicating if the engine can be instantiated (ie. if a WebGPU context can be found)\r\n     */\r\n    public static get IsSupportedAsync(): Promise<boolean> {\r\n        return !navigator.gpu\r\n            ? Promise.resolve(false)\r\n            : navigator.gpu\r\n                  .requestAdapter()\r\n                  .then(\r\n                      (adapter: GPUAdapter | undefined) => !!adapter,\r\n                      () => false\r\n                  )\r\n                  .catch(() => false);\r\n    }\r\n\r\n    /**\r\n     * Not supported by WebGPU, you should call IsSupportedAsync instead!\r\n     */\r\n    public static get IsSupported(): boolean {\r\n        Logger.Warn(\"You must call IsSupportedAsync for WebGPU!\");\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the engine supports uniform buffers\r\n     */\r\n    public get supportsUniformBuffers(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /** Gets the supported extensions by the WebGPU adapter */\r\n    public get supportedExtensions(): Immutable<GPUFeatureName[]> {\r\n        return this._adapterSupportedExtensions;\r\n    }\r\n\r\n    /** Gets the currently enabled extensions on the WebGPU device */\r\n    public get enabledExtensions(): Immutable<GPUFeatureName[]> {\r\n        return this._deviceEnabledExtensions;\r\n    }\r\n\r\n    /** Gets the supported limits by the WebGPU adapter */\r\n    public get supportedLimits(): GPUSupportedLimits {\r\n        return this._adapterSupportedLimits;\r\n    }\r\n\r\n    /** Gets the current limits of the WebGPU device */\r\n    public get currentLimits() {\r\n        return this._deviceLimits;\r\n    }\r\n\r\n    /**\r\n     * Returns a string describing the current engine\r\n     */\r\n    public get description(): string {\r\n        const description = this.name + this.version;\r\n\r\n        return description;\r\n    }\r\n\r\n    /**\r\n     * Returns the version of the engine\r\n     */\r\n    public get version(): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Gets an object containing information about the current engine context\r\n     * @returns an object containing the vendor, the renderer and the version of the current engine context\r\n     */\r\n    public getInfo() {\r\n        return {\r\n            vendor: this._adapterInfo.vendor || \"unknown vendor\",\r\n            renderer: this._adapterInfo.architecture || \"unknown renderer\",\r\n            version: this._adapterInfo.description || \"unknown version\",\r\n        };\r\n    }\r\n\r\n    /**\r\n     * (WebGPU only) True (default) to be in compatibility mode, meaning rendering all existing scenes without artifacts (same rendering than WebGL).\r\n     * Setting the property to false will improve performances but may not work in some scenes if some precautions are not taken.\r\n     * See https://doc.babylonjs.com/setup/support/webGPU/webGPUOptimization/webGPUNonCompatibilityMode for more details\r\n     */\r\n    public get compatibilityMode() {\r\n        return this._compatibilityMode;\r\n    }\r\n\r\n    public set compatibilityMode(mode: boolean) {\r\n        this._compatibilityMode = mode;\r\n    }\r\n\r\n    /** @internal */\r\n    public get currentSampleCount(): number {\r\n        return this._currentRenderTarget ? this._currentRenderTarget.samples : this._mainPassSampleCount;\r\n    }\r\n\r\n    /**\r\n     * Create a new instance of the gpu engine asynchronously\r\n     * @param canvas Defines the canvas to use to display the result\r\n     * @param options Defines the options passed to the engine to create the GPU context dependencies\r\n     * @returns a promise that resolves with the created engine\r\n     */\r\n    public static CreateAsync(canvas: HTMLCanvasElement, options: WebGPUEngineOptions = {}): Promise<WebGPUEngine> {\r\n        const engine = new WebGPUEngine(canvas, options);\r\n\r\n        return new Promise((resolve) => {\r\n            engine.initAsync(options.glslangOptions, options.twgslOptions).then(() => resolve(engine));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Indicates if the z range in NDC space is 0..1 (value: true) or -1..1 (value: false)\r\n     */\r\n    public readonly isNDCHalfZRange: boolean = true;\r\n\r\n    /**\r\n     * Indicates that the origin of the texture/framebuffer space is the bottom left corner. If false, the origin is top left\r\n     */\r\n    public readonly hasOriginBottomLeft: boolean = false;\r\n\r\n    /**\r\n     * Create a new instance of the gpu engine.\r\n     * @param canvas Defines the canvas to use to display the result\r\n     * @param options Defines the options passed to the engine to create the GPU context dependencies\r\n     */\r\n    public constructor(canvas: HTMLCanvasElement, options: WebGPUEngineOptions = {}) {\r\n        super(null, options.antialias ?? true, options);\r\n        this._name = \"WebGPU\";\r\n\r\n        options.deviceDescriptor = options.deviceDescriptor || {};\r\n        options.enableGPUDebugMarkers = options.enableGPUDebugMarkers ?? false;\r\n\r\n        Logger.Log(`Babylon.js v${Engine.Version} - ${this.description} engine`);\r\n        if (!navigator.gpu) {\r\n            Logger.Error(\"WebGPU is not supported by your browser.\");\r\n            return;\r\n        }\r\n\r\n        options.swapChainFormat = options.swapChainFormat || navigator.gpu.getPreferredCanvasFormat();\r\n\r\n        this._isWebGPU = true;\r\n        this._shaderPlatformName = \"WEBGPU\";\r\n\r\n        this._renderingCanvas = canvas;\r\n        this._options = options;\r\n\r\n        this._mainPassSampleCount = options.antialias ? this._defaultSampleCount : 1;\r\n\r\n        this._setupMobileChecks();\r\n\r\n        this._sharedInit(canvas);\r\n\r\n        this._shaderProcessor = new WebGPUShaderProcessorGLSL();\r\n        this._shaderProcessorWGSL = new WebGPUShaderProcessorWGSL();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Initialization\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Initializes the WebGPU context and dependencies.\r\n     * @param glslangOptions Defines the GLSLang compiler options if necessary\r\n     * @param twgslOptions Defines the Twgsl compiler options if necessary\r\n     * @returns a promise notifying the readiness of the engine.\r\n     */\r\n    public initAsync(glslangOptions?: GlslangOptions, twgslOptions?: TwgslOptions): Promise<void> {\r\n        return this._initGlslang(glslangOptions ?? this._options?.glslangOptions)\r\n            .then(\r\n                (glslang: any) => {\r\n                    this._glslang = glslang;\r\n                    this._tintWASM = WebGPUEngine.UseTWGSL ? new WebGPUTintWASM() : null;\r\n                    return this._tintWASM\r\n                        ? this._tintWASM.initTwgsl(twgslOptions ?? this._options?.twgslOptions).then(\r\n                              () => {\r\n                                  return navigator.gpu!.requestAdapter(this._options);\r\n                              },\r\n                              (msg: string) => {\r\n                                  Logger.Error(\"Can not initialize twgsl!\");\r\n                                  Logger.Error(msg);\r\n                                  throw Error(\"WebGPU initializations stopped.\");\r\n                              }\r\n                          )\r\n                        : navigator.gpu!.requestAdapter(this._options);\r\n                },\r\n                (msg: string) => {\r\n                    Logger.Error(\"Can not initialize glslang!\");\r\n                    Logger.Error(msg);\r\n                    throw Error(\"WebGPU initializations stopped.\");\r\n                }\r\n            )\r\n            .then((adapter: GPUAdapter | undefined) => {\r\n                if (!adapter) {\r\n                    throw \"Could not retrieve a WebGPU adapter (adapter is null).\";\r\n                } else {\r\n                    this._adapter = adapter!;\r\n                    this._adapterSupportedExtensions = [];\r\n                    this._adapter.features?.forEach((feature) => this._adapterSupportedExtensions.push(feature as WebGPUConstants.FeatureName));\r\n                    this._adapterSupportedLimits = this._adapter.limits;\r\n\r\n                    this._adapter.requestAdapterInfo().then((adapterInfo) => {\r\n                        this._adapterInfo = adapterInfo;\r\n                    });\r\n\r\n                    const deviceDescriptor = this._options.deviceDescriptor ?? {};\r\n                    const requiredFeatures = deviceDescriptor?.requiredFeatures ?? (this._options.enableAllFeatures ? this._adapterSupportedExtensions : undefined);\r\n\r\n                    if (requiredFeatures) {\r\n                        const requestedExtensions = requiredFeatures;\r\n                        const validExtensions: GPUFeatureName[] = [];\r\n\r\n                        for (const extension of requestedExtensions) {\r\n                            if (this._adapterSupportedExtensions.indexOf(extension) !== -1) {\r\n                                validExtensions.push(extension);\r\n                            }\r\n                        }\r\n\r\n                        deviceDescriptor.requiredFeatures = validExtensions;\r\n                    }\r\n\r\n                    if (this._options.setMaximumLimits && !deviceDescriptor.requiredLimits) {\r\n                        deviceDescriptor.requiredLimits = {};\r\n                        for (const name in this._adapterSupportedLimits) {\r\n                            deviceDescriptor.requiredLimits[name] = this._adapterSupportedLimits[name];\r\n                        }\r\n                    }\r\n\r\n                    return this._adapter.requestDevice(deviceDescriptor);\r\n                }\r\n            })\r\n            .then(\r\n                (device: GPUDevice) => {\r\n                    this._device = device;\r\n                    this._deviceEnabledExtensions = [];\r\n                    this._device.features?.forEach((feature) => this._deviceEnabledExtensions.push(feature as WebGPUConstants.FeatureName));\r\n                    this._deviceLimits = device.limits;\r\n\r\n                    let numUncapturedErrors = -1;\r\n                    this._device.addEventListener(\"uncapturederror\", (event) => {\r\n                        if (++numUncapturedErrors < this.numMaxUncapturedErrors) {\r\n                            Logger.Warn(`WebGPU uncaptured error (${numUncapturedErrors + 1}): ${(<GPUUncapturedErrorEvent>event).error} - ${(<any>event).error.message}`);\r\n                        } else if (numUncapturedErrors++ === this.numMaxUncapturedErrors) {\r\n                            Logger.Warn(\r\n                                `WebGPU uncaptured error: too many warnings (${this.numMaxUncapturedErrors}), no more warnings will be reported to the console for this engine.`\r\n                            );\r\n                        }\r\n                    });\r\n\r\n                    if (!this._doNotHandleContextLost) {\r\n                        this._device.lost?.then((info) => {\r\n                            if (this._isDisposed) {\r\n                                return;\r\n                            }\r\n                            this._contextWasLost = true;\r\n                            Logger.Warn(\"WebGPU context lost. \" + info);\r\n                            this.onContextLostObservable.notifyObservers(this);\r\n                            this._restoreEngineAfterContextLost(() => this.initAsync());\r\n                        });\r\n                    }\r\n                },\r\n                (e: any) => {\r\n                    Logger.Error(\"Could not retrieve a WebGPU device.\");\r\n                    Logger.Error(e);\r\n                }\r\n            )\r\n            .then(() => {\r\n                this._bufferManager = new WebGPUBufferManager(this._device);\r\n                this._textureHelper = new WebGPUTextureHelper(this._device, this._glslang, this._tintWASM, this._bufferManager, this._deviceEnabledExtensions);\r\n                this._cacheSampler = new WebGPUCacheSampler(this._device);\r\n                this._cacheBindGroups = new WebGPUCacheBindGroups(this._device, this._cacheSampler, this);\r\n                this._timestampQuery = new WebGPUTimestampQuery(this._device, this._bufferManager);\r\n                this._occlusionQuery = (this._device as any).createQuerySet ? new WebGPUOcclusionQuery(this, this._device, this._bufferManager) : (undefined as any);\r\n                this._bundleList = new WebGPUBundleList(this._device);\r\n                this._bundleListRenderTarget = new WebGPUBundleList(this._device);\r\n                this._snapshotRendering = new WebGPUSnapshotRendering(this, this._snapshotRenderingMode, this._bundleList, this._bundleListRenderTarget);\r\n\r\n                this._ubInvertY = this._bufferManager.createBuffer(\r\n                    new Float32Array([-1, 0]),\r\n                    WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst,\r\n                    \"UBInvertY\"\r\n                );\r\n                this._ubDontInvertY = this._bufferManager.createBuffer(\r\n                    new Float32Array([1, 0]),\r\n                    WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst,\r\n                    \"UBDontInvertY\"\r\n                );\r\n\r\n                if (this.dbgVerboseLogsForFirstFrames) {\r\n                    if ((this as any)._count === undefined) {\r\n                        (this as any)._count = 0;\r\n                        console.log(\"%c frame #\" + (this as any)._count + \" - begin\", \"background: #ffff00\");\r\n                    }\r\n                }\r\n\r\n                this._uploadEncoder = this._device.createCommandEncoder(this._uploadEncoderDescriptor);\r\n                this._renderEncoder = this._device.createCommandEncoder(this._renderEncoderDescriptor);\r\n                this._renderTargetEncoder = this._device.createCommandEncoder(this._renderTargetEncoderDescriptor);\r\n\r\n                this._initializeLimits();\r\n\r\n                this._emptyVertexBuffer = new VertexBuffer(this, [0], \"\", false, false, 1, false, 0, 1);\r\n\r\n                this._cacheRenderPipeline = new WebGPUCacheRenderPipelineTree(this._device, this._emptyVertexBuffer, !this._caps.textureFloatLinearFiltering);\r\n\r\n                this._depthCullingState = new WebGPUDepthCullingState(this._cacheRenderPipeline);\r\n                this._stencilStateComposer = new WebGPUStencilStateComposer(this._cacheRenderPipeline);\r\n                this._stencilStateComposer.stencilGlobal = this._stencilState;\r\n\r\n                this._depthCullingState.depthTest = true;\r\n                this._depthCullingState.depthFunc = Constants.LEQUAL;\r\n                this._depthCullingState.depthMask = true;\r\n\r\n                this._textureHelper.setCommandEncoder(this._uploadEncoder);\r\n\r\n                this._clearQuad = new WebGPUClearQuad(this._device, this, this._emptyVertexBuffer);\r\n                this._defaultDrawContext = this.createDrawContext()!;\r\n                this._currentDrawContext = this._defaultDrawContext;\r\n                this._defaultMaterialContext = this.createMaterialContext()!;\r\n                this._currentMaterialContext = this._defaultMaterialContext;\r\n\r\n                this._initializeContextAndSwapChain();\r\n                this._initializeMainAttachments();\r\n                this.resize();\r\n            })\r\n            .catch((e: any) => {\r\n                Logger.Error(\"Can not create WebGPU Device and/or context.\");\r\n                Logger.Error(e);\r\n                if (console.trace) {\r\n                    console.trace();\r\n                }\r\n            });\r\n    }\r\n\r\n    private _initGlslang(glslangOptions?: GlslangOptions): Promise<any> {\r\n        glslangOptions = glslangOptions || {};\r\n        glslangOptions = {\r\n            ...WebGPUEngine._GLSLslangDefaultOptions,\r\n            ...glslangOptions,\r\n        };\r\n\r\n        if (glslangOptions.glslang) {\r\n            return Promise.resolve(glslangOptions.glslang);\r\n        }\r\n\r\n        if ((self as any).glslang) {\r\n            return (self as any).glslang(glslangOptions!.wasmPath);\r\n        }\r\n\r\n        if (glslangOptions.jsPath && glslangOptions.wasmPath) {\r\n            return Tools.LoadBabylonScriptAsync(glslangOptions.jsPath).then(() => {\r\n                return (self as any).glslang(Tools.GetBabylonScriptURL(glslangOptions!.wasmPath!));\r\n            });\r\n        }\r\n\r\n        return Promise.reject(\"gslang is not available.\");\r\n    }\r\n\r\n    private _initializeLimits(): void {\r\n        // Init caps\r\n        // TODO WEBGPU Real Capability check once limits will be working.\r\n\r\n        this._caps = {\r\n            maxTexturesImageUnits: this._deviceLimits.maxSampledTexturesPerShaderStage,\r\n            maxVertexTextureImageUnits: this._deviceLimits.maxSampledTexturesPerShaderStage,\r\n            maxCombinedTexturesImageUnits: this._deviceLimits.maxSampledTexturesPerShaderStage * 2,\r\n            maxTextureSize: this._deviceLimits.maxTextureDimension2D,\r\n            maxCubemapTextureSize: this._deviceLimits.maxTextureDimension2D,\r\n            maxRenderTextureSize: this._deviceLimits.maxTextureDimension2D,\r\n            maxVertexAttribs: this._deviceLimits.maxVertexAttributes,\r\n            maxVaryingVectors: this._deviceLimits.maxInterStageShaderVariables,\r\n            maxFragmentUniformVectors: Math.floor(this._deviceLimits.maxUniformBufferBindingSize / 4),\r\n            maxVertexUniformVectors: Math.floor(this._deviceLimits.maxUniformBufferBindingSize / 4),\r\n            standardDerivatives: true,\r\n            astc: (this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionASTC) >= 0 ? true : undefined) as any,\r\n            s3tc: (this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionBC) >= 0 ? true : undefined) as any,\r\n            pvrtc: null,\r\n            etc1: null,\r\n            etc2: (this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionETC2) >= 0 ? true : undefined) as any,\r\n            bptc: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionBC) >= 0 ? true : undefined,\r\n            maxAnisotropy: 16, // Most implementations support maxAnisotropy values in range between 1 and 16, inclusive. The used value of maxAnisotropy will be clamped to the maximum value that the platform supports.\r\n            uintIndices: true,\r\n            fragmentDepthSupported: true,\r\n            highPrecisionShaderSupported: true,\r\n            colorBufferFloat: true,\r\n            textureFloat: true,\r\n            textureFloatLinearFiltering: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.Float32Filterable) >= 0,\r\n            textureFloatRender: true,\r\n            textureHalfFloat: true,\r\n            textureHalfFloatLinearFiltering: true,\r\n            textureHalfFloatRender: true,\r\n            textureLOD: true,\r\n            texelFetch: true,\r\n            drawBuffersExtension: true,\r\n            depthTextureExtension: true,\r\n            vertexArrayObject: false,\r\n            instancedArrays: true,\r\n            timerQuery:\r\n                typeof BigUint64Array !== \"undefined\" && this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TimestampQuery) !== -1 ? (true as any) : undefined,\r\n            supportOcclusionQuery: typeof BigUint64Array !== \"undefined\",\r\n            canUseTimestampForTimerQuery: true,\r\n            multiview: false,\r\n            oculusMultiview: false,\r\n            parallelShaderCompile: undefined,\r\n            blendMinMax: true,\r\n            maxMSAASamples: 4, // the spec only supports values of 1 and 4\r\n            canUseGLInstanceID: true,\r\n            canUseGLVertexID: true,\r\n            supportComputeShaders: true,\r\n            supportSRGBBuffers: true,\r\n            supportTransformFeedbacks: false,\r\n            textureMaxLevel: true,\r\n            texture2DArrayMaxLayerCount: this._deviceLimits.maxTextureArrayLayers,\r\n            disableMorphTargetTexture: false,\r\n        };\r\n\r\n        this._caps.parallelShaderCompile = null as any;\r\n\r\n        this._features = {\r\n            forceBitmapOverHTMLImageElement: true,\r\n            supportRenderAndCopyToLodForFloatTextures: true,\r\n            supportDepthStencilTexture: true,\r\n            supportShadowSamplers: true,\r\n            uniformBufferHardCheckMatrix: false,\r\n            allowTexturePrefiltering: true,\r\n            trackUbosInFrame: true,\r\n            checkUbosContentBeforeUpload: true,\r\n            supportCSM: true,\r\n            basisNeedsPOT: false,\r\n            support3DTextures: true,\r\n            needTypeSuffixInShaderConstants: true,\r\n            supportMSAA: true,\r\n            supportSSAO2: true,\r\n            supportExtendedTextureFormats: true,\r\n            supportSwitchCaseInShader: true,\r\n            supportSyncTextureRead: false,\r\n            needsInvertingBitmap: false,\r\n            useUBOBindingCache: false,\r\n            needShaderCodeInlining: true,\r\n            needToAlwaysBindUniformBuffers: true,\r\n            supportRenderPasses: true,\r\n            supportSpriteInstancing: true,\r\n            forceVertexBufferStrideMultiple4Bytes: true,\r\n            _collectUbosUpdatedInFrame: false,\r\n        };\r\n    }\r\n\r\n    private _initializeContextAndSwapChain(): void {\r\n        if (!this._renderingCanvas) {\r\n            throw \"The rendering canvas has not been set!\";\r\n        }\r\n        this._context = this._renderingCanvas.getContext(\"webgpu\") as unknown as GPUCanvasContext;\r\n        this._configureContext();\r\n        this._colorFormat = this._options.swapChainFormat!;\r\n        this._mainRenderPassWrapper.colorAttachmentGPUTextures = [new WebGPUHardwareTexture()];\r\n        this._mainRenderPassWrapper.colorAttachmentGPUTextures[0]!.format = this._colorFormat;\r\n    }\r\n\r\n    // Set default values as WebGL with depth and stencil attachment for the broadest Compat.\r\n    private _initializeMainAttachments(): void {\r\n        if (!this._bufferManager) {\r\n            return;\r\n        }\r\n\r\n        this.flushFramebuffer(false);\r\n\r\n        this._mainTextureExtends = {\r\n            width: this.getRenderWidth(true),\r\n            height: this.getRenderHeight(true),\r\n            depthOrArrayLayers: 1,\r\n        };\r\n\r\n        const bufferDataUpdate = new Float32Array([this.getRenderHeight(true)]);\r\n\r\n        this._bufferManager.setSubData(this._ubInvertY, 4, bufferDataUpdate);\r\n        this._bufferManager.setSubData(this._ubDontInvertY, 4, bufferDataUpdate);\r\n\r\n        let mainColorAttachments: GPURenderPassColorAttachment[];\r\n\r\n        if (this._options.antialias) {\r\n            const mainTextureDescriptor: GPUTextureDescriptor = {\r\n                label: `Texture_MainColor_${this._mainTextureExtends.width}x${this._mainTextureExtends.height}_antialiasing`,\r\n                size: this._mainTextureExtends,\r\n                mipLevelCount: 1,\r\n                sampleCount: this._mainPassSampleCount,\r\n                dimension: WebGPUConstants.TextureDimension.E2d,\r\n                format: this._options.swapChainFormat!,\r\n                usage: WebGPUConstants.TextureUsage.RenderAttachment,\r\n            };\r\n\r\n            if (this._mainTexture) {\r\n                this._textureHelper.releaseTexture(this._mainTexture);\r\n            }\r\n            this._mainTexture = this._device.createTexture(mainTextureDescriptor);\r\n            mainColorAttachments = [\r\n                {\r\n                    view: this._mainTexture.createView({\r\n                        label: \"TextureView_MainColor_antialiasing\",\r\n                        dimension: WebGPUConstants.TextureDimension.E2d,\r\n                        format: this._options.swapChainFormat!,\r\n                        mipLevelCount: 1,\r\n                        arrayLayerCount: 1,\r\n                    }),\r\n                    clearValue: new Color4(0, 0, 0, 1),\r\n                    loadOp: WebGPUConstants.LoadOp.Clear,\r\n                    storeOp: WebGPUConstants.StoreOp.Store, // don't use StoreOp.Discard, else using several cameras with different viewports or using scissors will fail because we call beginRenderPass / endPass several times for the same color attachment!\r\n                },\r\n            ];\r\n        } else {\r\n            mainColorAttachments = [\r\n                {\r\n                    view: undefined as any,\r\n                    clearValue: new Color4(0, 0, 0, 1),\r\n                    loadOp: WebGPUConstants.LoadOp.Clear,\r\n                    storeOp: WebGPUConstants.StoreOp.Store,\r\n                },\r\n            ];\r\n        }\r\n\r\n        this._mainRenderPassWrapper.depthTextureFormat = this.isStencilEnable ? WebGPUConstants.TextureFormat.Depth24PlusStencil8 : WebGPUConstants.TextureFormat.Depth32Float;\r\n\r\n        this._setDepthTextureFormat(this._mainRenderPassWrapper);\r\n\r\n        const depthTextureDescriptor: GPUTextureDescriptor = {\r\n            label: `Texture_MainDepthStencil_${this._mainTextureExtends.width}x${this._mainTextureExtends.height}`,\r\n            size: this._mainTextureExtends,\r\n            mipLevelCount: 1,\r\n            sampleCount: this._mainPassSampleCount,\r\n            dimension: WebGPUConstants.TextureDimension.E2d,\r\n            format: this._mainRenderPassWrapper.depthTextureFormat,\r\n            usage: WebGPUConstants.TextureUsage.RenderAttachment,\r\n        };\r\n\r\n        if (this._depthTexture) {\r\n            this._textureHelper.releaseTexture(this._depthTexture);\r\n        }\r\n        this._depthTexture = this._device.createTexture(depthTextureDescriptor);\r\n        const mainDepthAttachment: GPURenderPassDepthStencilAttachment = {\r\n            view: this._depthTexture.createView({\r\n                label: `TextureView_MainDepthStencil_${this._mainTextureExtends.width}x${this._mainTextureExtends.height}`,\r\n                dimension: WebGPUConstants.TextureDimension.E2d,\r\n                format: this._depthTexture.format,\r\n                mipLevelCount: 1,\r\n                arrayLayerCount: 1,\r\n            }),\r\n\r\n            depthClearValue: this._clearDepthValue,\r\n            depthLoadOp: WebGPUConstants.LoadOp.Clear,\r\n            depthStoreOp: WebGPUConstants.StoreOp.Store,\r\n            stencilClearValue: this._clearStencilValue,\r\n            stencilLoadOp: !this.isStencilEnable ? undefined : WebGPUConstants.LoadOp.Clear,\r\n            stencilStoreOp: !this.isStencilEnable ? undefined : WebGPUConstants.StoreOp.Store,\r\n        };\r\n\r\n        this._mainRenderPassWrapper.renderPassDescriptor = {\r\n            label: \"MainRenderPass\",\r\n            colorAttachments: mainColorAttachments,\r\n            depthStencilAttachment: mainDepthAttachment,\r\n        };\r\n    }\r\n\r\n    private _configureContext(): void {\r\n        this._context.configure({\r\n            device: this._device,\r\n            format: this._options.swapChainFormat!,\r\n            usage: WebGPUConstants.TextureUsage.RenderAttachment | WebGPUConstants.TextureUsage.CopySrc,\r\n            alphaMode: this.premultipliedAlpha ? WebGPUConstants.CanvasAlphaMode.Premultiplied : WebGPUConstants.CanvasAlphaMode.Opaque,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Force a specific size of the canvas\r\n     * @param width defines the new canvas' width\r\n     * @param height defines the new canvas' height\r\n     * @param forceSetSize true to force setting the sizes of the underlying canvas\r\n     * @returns true if the size was changed\r\n     */\r\n    public setSize(width: number, height: number, forceSetSize = false): boolean {\r\n        if (!super.setSize(width, height, forceSetSize)) {\r\n            return false;\r\n        }\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\"frame #\" + (this as any)._count + \" - setSize called -\", width, height);\r\n            }\r\n        }\r\n\r\n        this._initializeMainAttachments();\r\n\r\n        if (this.snapshotRendering) {\r\n            // reset snapshot rendering so that the next frame will record a new list of bundles\r\n            this.snapshotRenderingReset();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _shaderProcessorWGSL: Nullable<IShaderProcessor>;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getShaderProcessor(shaderLanguage: ShaderLanguage): Nullable<IShaderProcessor> {\r\n        if (shaderLanguage === ShaderLanguage.WGSL) {\r\n            return this._shaderProcessorWGSL;\r\n        }\r\n        return this._shaderProcessor;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getShaderProcessingContext(shaderLanguage: ShaderLanguage): Nullable<ShaderProcessingContext> {\r\n        return new WebGPUShaderProcessingContext(shaderLanguage);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                          Static Pipeline WebGPU States\r\n    //------------------------------------------------------------------------------\r\n\r\n    /** @internal */\r\n    public applyStates() {\r\n        this._stencilStateComposer.apply();\r\n        this._cacheRenderPipeline.setAlphaBlendEnabled(this._alphaState.alphaBlend);\r\n    }\r\n\r\n    /**\r\n     * Force the entire cache to be cleared\r\n     * You should not have to use this function unless your engine needs to share the WebGPU context with another engine\r\n     * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)\r\n     */\r\n    public wipeCaches(bruteForce?: boolean): void {\r\n        if (this.preventCacheWipeBetweenFrames && !bruteForce) {\r\n            return;\r\n        }\r\n\r\n        //this._currentEffect = null; // can't reset _currentEffect, else some crashes can occur (for eg in ProceduralTexture which calls bindFrameBuffer (which calls wipeCaches) after having called enableEffect and before drawing into the texture)\r\n        // _forceEnableEffect = true assumes the role of _currentEffect = null\r\n        this._forceEnableEffect = true;\r\n        this._currentIndexBuffer = null;\r\n        this._currentOverrideVertexBuffers = null;\r\n        this._cacheRenderPipeline.setBuffers(null, null, null);\r\n\r\n        if (bruteForce) {\r\n            this._stencilStateComposer.reset();\r\n\r\n            this._depthCullingState.reset();\r\n            this._depthCullingState.depthFunc = Constants.LEQUAL;\r\n\r\n            this._alphaState.reset();\r\n            this._alphaMode = Constants.ALPHA_ADD;\r\n            this._alphaEquation = Constants.ALPHA_DISABLE;\r\n            this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters, this._alphaState._blendEquationParameters);\r\n            this._cacheRenderPipeline.setAlphaBlendEnabled(false);\r\n\r\n            this.setColorWrite(true);\r\n        }\r\n\r\n        this._cachedVertexBuffers = null;\r\n        this._cachedIndexBuffer = null;\r\n        this._cachedEffectForVertexBuffers = null;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable color writing\r\n     * @param enable defines the state to set\r\n     */\r\n    public setColorWrite(enable: boolean): void {\r\n        this._colorWriteLocal = enable;\r\n        this._cacheRenderPipeline.setWriteMask(enable ? 0xf : 0);\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if color writing is enabled\r\n     * @returns the current color writing state\r\n     */\r\n    public getColorWrite(): boolean {\r\n        return this._colorWriteLocal;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Dynamic WebGPU States\r\n    //------------------------------------------------------------------------------\r\n\r\n    // index 0 is for main render pass, 1 for RTT render pass\r\n    private _viewportsCurrent: Array<{ x: number; y: number; w: number; h: number }> = [\r\n        { x: 0, y: 0, w: 0, h: 0 },\r\n        { x: 0, y: 0, w: 0, h: 0 },\r\n    ];\r\n\r\n    private _resetCurrentViewport(index: number) {\r\n        this._viewportsCurrent[index].x = 0;\r\n        this._viewportsCurrent[index].y = 0;\r\n        this._viewportsCurrent[index].w = 0;\r\n        this._viewportsCurrent[index].h = 0;\r\n    }\r\n\r\n    private _mustUpdateViewport(renderPass: GPURenderPassEncoder): boolean {\r\n        const index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\r\n\r\n        const x = this._viewportCached.x,\r\n            y = this._viewportCached.y,\r\n            w = this._viewportCached.z,\r\n            h = this._viewportCached.w;\r\n\r\n        const update =\r\n            this._viewportsCurrent[index].x !== x || this._viewportsCurrent[index].y !== y || this._viewportsCurrent[index].w !== w || this._viewportsCurrent[index].h !== h;\r\n\r\n        if (update) {\r\n            this._viewportsCurrent[index].x = this._viewportCached.x;\r\n            this._viewportsCurrent[index].y = this._viewportCached.y;\r\n            this._viewportsCurrent[index].w = this._viewportCached.z;\r\n            this._viewportsCurrent[index].h = this._viewportCached.w;\r\n        }\r\n\r\n        return update;\r\n    }\r\n\r\n    private _applyViewport(renderPass: GPURenderPassEncoder): void {\r\n        let y = Math.floor(this._viewportCached.y);\r\n        const h = Math.floor(this._viewportCached.w);\r\n\r\n        if (!this._currentRenderTarget) {\r\n            y = this.getRenderHeight(true) - y - h;\r\n        }\r\n\r\n        renderPass.setViewport(Math.floor(this._viewportCached.x), y, Math.floor(this._viewportCached.z), h, 0, 1);\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\r\n                    \"frame #\" + (this as any)._count + \" - viewport applied - (\",\r\n                    this._viewportCached.x,\r\n                    this._viewportCached.y,\r\n                    this._viewportCached.z,\r\n                    this._viewportCached.w,\r\n                    \") current pass is main pass=\" + (renderPass === this._mainRenderPassWrapper.renderPass)\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _viewport(x: number, y: number, width: number, height: number): void {\r\n        this._viewportCached.x = x;\r\n        this._viewportCached.y = y;\r\n        this._viewportCached.z = width;\r\n        this._viewportCached.w = height;\r\n    }\r\n\r\n    private _scissorsCurrent: Array<{ x: number; y: number; w: number; h: number }> = [\r\n        { x: 0, y: 0, w: 0, h: 0 },\r\n        { x: 0, y: 0, w: 0, h: 0 },\r\n    ];\r\n    protected _scissorCached = { x: 0, y: 0, z: 0, w: 0 };\r\n\r\n    private _resetCurrentScissor(index: number) {\r\n        this._scissorsCurrent[index].x = 0;\r\n        this._scissorsCurrent[index].y = 0;\r\n        this._scissorsCurrent[index].w = 0;\r\n        this._scissorsCurrent[index].h = 0;\r\n    }\r\n\r\n    private _mustUpdateScissor(renderPass: GPURenderPassEncoder): boolean {\r\n        const index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\r\n\r\n        const x = this._scissorCached.x,\r\n            y = this._scissorCached.y,\r\n            w = this._scissorCached.z,\r\n            h = this._scissorCached.w;\r\n\r\n        const update = this._scissorsCurrent[index].x !== x || this._scissorsCurrent[index].y !== y || this._scissorsCurrent[index].w !== w || this._scissorsCurrent[index].h !== h;\r\n\r\n        if (update) {\r\n            this._scissorsCurrent[index].x = this._scissorCached.x;\r\n            this._scissorsCurrent[index].y = this._scissorCached.y;\r\n            this._scissorsCurrent[index].w = this._scissorCached.z;\r\n            this._scissorsCurrent[index].h = this._scissorCached.w;\r\n        }\r\n\r\n        return update;\r\n    }\r\n\r\n    private _applyScissor(renderPass: GPURenderPassEncoder): void {\r\n        renderPass.setScissorRect(\r\n            this._scissorCached.x,\r\n            this._currentRenderTarget ? this._scissorCached.y : this.getRenderHeight() - this._scissorCached.w - this._scissorCached.y,\r\n            this._scissorCached.z,\r\n            this._scissorCached.w\r\n        );\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\r\n                    \"frame #\" + (this as any)._count + \" - scissor applied - (\",\r\n                    this._scissorCached.x,\r\n                    this._scissorCached.y,\r\n                    this._scissorCached.z,\r\n                    this._scissorCached.w,\r\n                    \") current pass is main pass=\" + (renderPass === this._mainRenderPassWrapper.renderPass)\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    private _scissorIsActive() {\r\n        return this._scissorCached.x !== 0 || this._scissorCached.y !== 0 || this._scissorCached.z !== 0 || this._scissorCached.w !== 0;\r\n    }\r\n\r\n    public enableScissor(x: number, y: number, width: number, height: number): void {\r\n        this._scissorCached.x = x;\r\n        this._scissorCached.y = y;\r\n        this._scissorCached.z = width;\r\n        this._scissorCached.w = height;\r\n    }\r\n\r\n    public disableScissor() {\r\n        this._scissorCached.x = 0;\r\n        this._scissorCached.y = 0;\r\n        this._scissorCached.z = 0;\r\n        this._scissorCached.w = 0;\r\n\r\n        this._resetCurrentScissor(0);\r\n        this._resetCurrentScissor(1);\r\n    }\r\n\r\n    private _stencilRefsCurrent: Array<number> = [-1, -1];\r\n\r\n    private _resetCurrentStencilRef(index: number): void {\r\n        this._stencilRefsCurrent[index] = -1;\r\n    }\r\n\r\n    private _mustUpdateStencilRef(renderPass: GPURenderPassEncoder): boolean {\r\n        const index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\r\n        const update = this._stencilStateComposer.funcRef !== this._stencilRefsCurrent[index];\r\n        if (update) {\r\n            this._stencilRefsCurrent[index] = this._stencilStateComposer.funcRef;\r\n        }\r\n        return update;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _applyStencilRef(renderPass: GPURenderPassEncoder): void {\r\n        renderPass.setStencilReference(this._stencilStateComposer.funcRef ?? 0);\r\n    }\r\n\r\n    private _blendColorsCurrent: Array<Array<Nullable<number>>> = [\r\n        [null, null, null, null],\r\n        [null, null, null, null],\r\n    ];\r\n\r\n    private _resetCurrentColorBlend(index: number): void {\r\n        this._blendColorsCurrent[index][0] = this._blendColorsCurrent[index][1] = this._blendColorsCurrent[index][2] = this._blendColorsCurrent[index][3] = null;\r\n    }\r\n\r\n    private _mustUpdateBlendColor(renderPass: GPURenderPassEncoder): boolean {\r\n        const index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\r\n        const colorBlend = this._alphaState._blendConstants;\r\n\r\n        const update =\r\n            colorBlend[0] !== this._blendColorsCurrent[index][0] ||\r\n            colorBlend[1] !== this._blendColorsCurrent[index][1] ||\r\n            colorBlend[2] !== this._blendColorsCurrent[index][2] ||\r\n            colorBlend[3] !== this._blendColorsCurrent[index][3];\r\n\r\n        if (update) {\r\n            this._blendColorsCurrent[index][0] = colorBlend[0];\r\n            this._blendColorsCurrent[index][1] = colorBlend[1];\r\n            this._blendColorsCurrent[index][2] = colorBlend[2];\r\n            this._blendColorsCurrent[index][3] = colorBlend[3];\r\n        }\r\n\r\n        return update;\r\n    }\r\n\r\n    private _applyBlendColor(renderPass: GPURenderPassEncoder): void {\r\n        renderPass.setBlendConstant(this._alphaState._blendConstants as GPUColor);\r\n    }\r\n\r\n    /**\r\n     * Clear the current render buffer or the current render target (if any is set up)\r\n     * @param color defines the color to use\r\n     * @param backBuffer defines if the back buffer must be cleared\r\n     * @param depth defines if the depth buffer must be cleared\r\n     * @param stencil defines if the stencil buffer must be cleared\r\n     */\r\n    public clear(color: Nullable<IColor4Like>, backBuffer: boolean, depth: boolean, stencil: boolean = false): void {\r\n        // Some PGs are using color3...\r\n        if (color && color.a === undefined) {\r\n            color.a = 1;\r\n        }\r\n\r\n        const hasScissor = this._scissorIsActive();\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\r\n                    \"frame #\" + (this as any)._count + \" - clear called - backBuffer=\",\r\n                    backBuffer,\r\n                    \" depth=\",\r\n                    depth,\r\n                    \" stencil=\",\r\n                    stencil,\r\n                    \" scissor is active=\",\r\n                    hasScissor\r\n                );\r\n            }\r\n        }\r\n\r\n        // We need to recreate the render pass so that the new parameters for clear color / depth / stencil are taken into account\r\n        if (this._currentRenderTarget) {\r\n            if (hasScissor) {\r\n                if (!this._rttRenderPassWrapper.renderPass) {\r\n                    this._startRenderTargetRenderPass(this._currentRenderTarget!, false, backBuffer ? color : null, depth, stencil);\r\n                }\r\n                if (!this.compatibilityMode) {\r\n                    this._bundleListRenderTarget.addItem(new WebGPURenderItemScissor(this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w));\r\n                } else {\r\n                    this._applyScissor(this._currentRenderPass!);\r\n                }\r\n                this._clearFullQuad(backBuffer ? color : null, depth, stencil);\r\n            } else {\r\n                if (this._currentRenderPass) {\r\n                    this._endRenderTargetRenderPass();\r\n                }\r\n                this._startRenderTargetRenderPass(this._currentRenderTarget!, true, backBuffer ? color : null, depth, stencil);\r\n            }\r\n        } else {\r\n            if (!this._mainRenderPassWrapper.renderPass || !hasScissor) {\r\n                this._startMainRenderPass(!hasScissor, backBuffer ? color : null, depth, stencil);\r\n            }\r\n            if (hasScissor) {\r\n                if (!this.compatibilityMode) {\r\n                    this._bundleList.addItem(new WebGPURenderItemScissor(this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w));\r\n                } else {\r\n                    this._applyScissor(this._currentRenderPass!);\r\n                }\r\n                this._clearFullQuad(backBuffer ? color : null, depth, stencil);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _clearFullQuad(clearColor?: Nullable<IColor4Like>, clearDepth?: boolean, clearStencil?: boolean): void {\r\n        const renderPass = !this.compatibilityMode ? null : this._getCurrentRenderPass();\r\n        const renderPassIndex = this._getCurrentRenderPassIndex();\r\n        const bundleList = renderPassIndex === 0 ? this._bundleList : this._bundleListRenderTarget;\r\n\r\n        this._clearQuad.setColorFormat(this._colorFormat);\r\n        this._clearQuad.setDepthStencilFormat(this._depthTextureFormat);\r\n        this._clearQuad.setMRTAttachments(\r\n            this._cacheRenderPipeline.mrtAttachments ?? [],\r\n            this._cacheRenderPipeline.mrtTextureArray ?? [],\r\n            this._cacheRenderPipeline.mrtTextureCount\r\n        );\r\n\r\n        if (!this.compatibilityMode) {\r\n            bundleList.addItem(new WebGPURenderItemStencilRef(this._clearStencilValue));\r\n        } else {\r\n            renderPass!.setStencilReference(this._clearStencilValue);\r\n        }\r\n\r\n        const bundle = this._clearQuad.clear(renderPass, clearColor, clearDepth, clearStencil, this.currentSampleCount);\r\n\r\n        if (!this.compatibilityMode) {\r\n            bundleList.addBundle(bundle!);\r\n            bundleList.addItem(new WebGPURenderItemStencilRef(this._stencilStateComposer.funcRef ?? 0));\r\n            this._reportDrawCall();\r\n        } else {\r\n            this._applyStencilRef(renderPass!);\r\n        }\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Vertex/Index/Storage Buffers\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates a vertex buffer\r\n     * @param data the data for the vertex buffer\r\n     * @param _updatable whether the buffer should be created as updatable\r\n     * @param label defines the label of the buffer (for debug purpose)\r\n     * @returns the new buffer\r\n     */\r\n    public createVertexBuffer(data: DataArray, _updatable?: boolean, label?: string): DataBuffer {\r\n        let view: ArrayBufferView;\r\n\r\n        if (data instanceof Array) {\r\n            view = new Float32Array(data);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            view = new Uint8Array(data);\r\n        } else {\r\n            view = data;\r\n        }\r\n\r\n        const dataBuffer = this._bufferManager.createBuffer(view, WebGPUConstants.BufferUsage.Vertex | WebGPUConstants.BufferUsage.CopyDst, label);\r\n        return dataBuffer;\r\n    }\r\n\r\n    /**\r\n     * Creates a vertex buffer\r\n     * @param data the data for the dynamic vertex buffer\r\n     * @param label defines the label of the buffer (for debug purpose)\r\n     * @returns the new buffer\r\n     */\r\n    public createDynamicVertexBuffer(data: DataArray, label?: string): DataBuffer {\r\n        return this.createVertexBuffer(data, undefined, label);\r\n    }\r\n\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the content of the index buffer\r\n     * @param updatable defines if the index buffer must be updatable\r\n     * @param label defines the label of the buffer (for debug purpose)\r\n     * @returns a new buffer\r\n     */\r\n    public createIndexBuffer(indices: IndicesArray, _updatable?: boolean, label?: string): DataBuffer {\r\n        let is32Bits = true;\r\n        let view: ArrayBufferView;\r\n\r\n        if (indices instanceof Uint32Array || indices instanceof Int32Array) {\r\n            view = indices;\r\n        } else if (indices instanceof Uint16Array) {\r\n            view = indices;\r\n            is32Bits = false;\r\n        } else {\r\n            if (indices.length > 65535) {\r\n                view = new Uint32Array(indices);\r\n            } else {\r\n                view = new Uint16Array(indices);\r\n                is32Bits = false;\r\n            }\r\n        }\r\n\r\n        const dataBuffer = this._bufferManager.createBuffer(view, WebGPUConstants.BufferUsage.Index | WebGPUConstants.BufferUsage.CopyDst, label);\r\n        dataBuffer.is32Bits = is32Bits;\r\n        return dataBuffer;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _createBuffer(data: DataArray | number, creationFlags: number, label?: string): DataBuffer {\r\n        let view: ArrayBufferView | number;\r\n\r\n        if (data instanceof Array) {\r\n            view = new Float32Array(data);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            view = new Uint8Array(data);\r\n        } else {\r\n            view = data;\r\n        }\r\n\r\n        let flags = 0;\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_READ) {\r\n            flags |= WebGPUConstants.BufferUsage.CopySrc;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_WRITE) {\r\n            flags |= WebGPUConstants.BufferUsage.CopyDst;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_UNIFORM) {\r\n            flags |= WebGPUConstants.BufferUsage.Uniform;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_VERTEX) {\r\n            flags |= WebGPUConstants.BufferUsage.Vertex;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_INDEX) {\r\n            flags |= WebGPUConstants.BufferUsage.Index;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_STORAGE) {\r\n            flags |= WebGPUConstants.BufferUsage.Storage;\r\n        }\r\n\r\n        return this._bufferManager.createBuffer(view, flags, label);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public bindBuffersDirectly(): void {\r\n        throw \"Not implemented on WebGPU\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public updateAndBindInstancesBuffer(): void {\r\n        throw \"Not implemented on WebGPU\";\r\n    }\r\n\r\n    /**\r\n     * Bind a list of vertex buffers with the engine\r\n     * @param vertexBuffers defines the list of vertex buffers to bind\r\n     * @param indexBuffer defines the index buffer to bind\r\n     * @param effect defines the effect associated with the vertex buffers\r\n     * @param overrideVertexBuffers defines optional list of avertex buffers that overrides the entries in vertexBuffers\r\n     */\r\n    public bindBuffers(\r\n        vertexBuffers: { [key: string]: Nullable<VertexBuffer> },\r\n        indexBuffer: Nullable<DataBuffer>,\r\n        effect: Effect,\r\n        overrideVertexBuffers?: { [kind: string]: Nullable<VertexBuffer> }\r\n    ): void {\r\n        this._currentIndexBuffer = indexBuffer;\r\n        this._currentOverrideVertexBuffers = overrideVertexBuffers ?? null;\r\n        this._cacheRenderPipeline.setBuffers(vertexBuffers, indexBuffer, this._currentOverrideVertexBuffers);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _releaseBuffer(buffer: DataBuffer): boolean {\r\n        return this._bufferManager.releaseBuffer(buffer);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Effects\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Create a new effect (used to store vertex/fragment shaders)\r\n     * @param baseName defines the base name of the effect (The name of file without .fragment.fx or .vertex.fx)\r\n     * @param attributesNamesOrOptions defines either a list of attribute names or an IEffectCreationOptions object\r\n     * @param uniformsNamesOrEngine defines either a list of uniform names or the engine to use\r\n     * @param samplers defines an array of string used to represent textures\r\n     * @param defines defines the string containing the defines to use to compile the shaders\r\n     * @param fallbacks defines the list of potential fallbacks to use if shader compilation fails\r\n     * @param onCompiled defines a function to call when the effect creation is successful\r\n     * @param onError defines a function to call when the effect creation has failed\r\n     * @param indexParameters defines an object containing the index values to use to compile shaders (like the maximum number of simultaneous lights)\r\n     * @param shaderLanguage the language the shader is written in (default: GLSL)\r\n     * @returns the new Effect\r\n     */\r\n    public createEffect(\r\n        baseName: any,\r\n        attributesNamesOrOptions: string[] | IEffectCreationOptions,\r\n        uniformsNamesOrEngine: string[] | Engine,\r\n        samplers?: string[],\r\n        defines?: string,\r\n        fallbacks?: EffectFallbacks,\r\n        onCompiled?: Nullable<(effect: Effect) => void>,\r\n        onError?: Nullable<(effect: Effect, errors: string) => void>,\r\n        indexParameters?: any,\r\n        shaderLanguage = ShaderLanguage.GLSL\r\n    ): Effect {\r\n        const vertex = baseName.vertexElement || baseName.vertex || baseName.vertexToken || baseName.vertexSource || baseName;\r\n        const fragment = baseName.fragmentElement || baseName.fragment || baseName.fragmentToken || baseName.fragmentSource || baseName;\r\n        const globalDefines = this._getGlobalDefines()!;\r\n\r\n        let fullDefines = defines ?? (<IEffectCreationOptions>attributesNamesOrOptions).defines ?? \"\";\r\n\r\n        if (globalDefines) {\r\n            fullDefines += \"\\n\" + globalDefines;\r\n        }\r\n\r\n        const name = vertex + \"+\" + fragment + \"@\" + fullDefines;\r\n        if (this._compiledEffects[name]) {\r\n            const compiledEffect = <Effect>this._compiledEffects[name];\r\n            if (onCompiled && compiledEffect.isReady()) {\r\n                onCompiled(compiledEffect);\r\n            }\r\n\r\n            return compiledEffect;\r\n        }\r\n        const effect = new Effect(\r\n            baseName,\r\n            attributesNamesOrOptions,\r\n            uniformsNamesOrEngine,\r\n            samplers,\r\n            this,\r\n            defines,\r\n            fallbacks,\r\n            onCompiled,\r\n            onError,\r\n            indexParameters,\r\n            name,\r\n            shaderLanguage\r\n        );\r\n        this._compiledEffects[name] = effect;\r\n\r\n        return effect;\r\n    }\r\n\r\n    private _compileRawShaderToSpirV(source: string, type: string): Uint32Array {\r\n        return this._glslang.compileGLSL(source, type);\r\n    }\r\n\r\n    private _compileShaderToSpirV(source: string, type: string, defines: Nullable<string>, shaderVersion: string): Uint32Array {\r\n        return this._compileRawShaderToSpirV(shaderVersion + (defines ? defines + \"\\n\" : \"\") + source, type);\r\n    }\r\n\r\n    private _getWGSLShader(source: string, type: string, defines: Nullable<string>): string {\r\n        if (defines) {\r\n            defines = \"//\" + defines.split(\"\\n\").join(\"\\n//\") + \"\\n\";\r\n        } else {\r\n            defines = \"\";\r\n        }\r\n        return defines + source;\r\n    }\r\n\r\n    private _createPipelineStageDescriptor(\r\n        vertexShader: Uint32Array | string,\r\n        fragmentShader: Uint32Array | string,\r\n        shaderLanguage: ShaderLanguage,\r\n        disableUniformityAnalysisInVertex: boolean,\r\n        disableUniformityAnalysisInFragment: boolean\r\n    ): IWebGPURenderPipelineStageDescriptor {\r\n        if (this._tintWASM && shaderLanguage === ShaderLanguage.GLSL) {\r\n            vertexShader = this._tintWASM.convertSpirV2WGSL(vertexShader as Uint32Array, disableUniformityAnalysisInVertex);\r\n            fragmentShader = this._tintWASM.convertSpirV2WGSL(fragmentShader as Uint32Array, disableUniformityAnalysisInFragment);\r\n        }\r\n\r\n        return {\r\n            vertexStage: {\r\n                module: this._device.createShaderModule({\r\n                    code: vertexShader,\r\n                }),\r\n                entryPoint: \"main\",\r\n            },\r\n            fragmentStage: {\r\n                module: this._device.createShaderModule({\r\n                    code: fragmentShader,\r\n                }),\r\n                entryPoint: \"main\",\r\n            },\r\n        };\r\n    }\r\n\r\n    private _compileRawPipelineStageDescriptor(vertexCode: string, fragmentCode: string, shaderLanguage: ShaderLanguage): IWebGPURenderPipelineStageDescriptor {\r\n        const disableUniformityAnalysisInVertex = vertexCode.indexOf(disableUniformityAnalysisMarker) >= 0;\r\n        const disableUniformityAnalysisInFragment = fragmentCode.indexOf(disableUniformityAnalysisMarker) >= 0;\r\n\r\n        const vertexShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileRawShaderToSpirV(vertexCode, \"vertex\") : vertexCode;\r\n        const fragmentShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileRawShaderToSpirV(fragmentCode, \"fragment\") : fragmentCode;\r\n\r\n        return this._createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage, disableUniformityAnalysisInVertex, disableUniformityAnalysisInFragment);\r\n    }\r\n\r\n    private _compilePipelineStageDescriptor(\r\n        vertexCode: string,\r\n        fragmentCode: string,\r\n        defines: Nullable<string>,\r\n        shaderLanguage: ShaderLanguage\r\n    ): IWebGPURenderPipelineStageDescriptor {\r\n        this.onBeforeShaderCompilationObservable.notifyObservers(this);\r\n\r\n        const disableUniformityAnalysisInVertex = vertexCode.indexOf(disableUniformityAnalysisMarker) >= 0;\r\n        const disableUniformityAnalysisInFragment = fragmentCode.indexOf(disableUniformityAnalysisMarker) >= 0;\r\n\r\n        const shaderVersion = \"#version 450\\n\";\r\n        const vertexShader =\r\n            shaderLanguage === ShaderLanguage.GLSL ? this._compileShaderToSpirV(vertexCode, \"vertex\", defines, shaderVersion) : this._getWGSLShader(vertexCode, \"vertex\", defines);\r\n        const fragmentShader =\r\n            shaderLanguage === ShaderLanguage.GLSL\r\n                ? this._compileShaderToSpirV(fragmentCode, \"fragment\", defines, shaderVersion)\r\n                : this._getWGSLShader(fragmentCode, \"fragment\", defines);\r\n\r\n        const program = this._createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage, disableUniformityAnalysisInVertex, disableUniformityAnalysisInFragment);\r\n\r\n        this.onAfterShaderCompilationObservable.notifyObservers(this);\r\n\r\n        return program;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public createRawShaderProgram(): WebGLProgram {\r\n        throw \"Not available on WebGPU\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public createShaderProgram(): WebGLProgram {\r\n        throw \"Not available on WebGPU\";\r\n    }\r\n\r\n    /**\r\n     * Inline functions in shader code that are marked to be inlined\r\n     * @param code code to inline\r\n     * @returns inlined code\r\n     */\r\n    public inlineShaderCode(code: string): string {\r\n        const sci = new ShaderCodeInliner(code);\r\n        sci.debug = false;\r\n        sci.processCode();\r\n        return sci.code;\r\n    }\r\n\r\n    /**\r\n     * Creates a new pipeline context\r\n     * @param shaderProcessingContext defines the shader processing context used during the processing if available\r\n     * @returns the new pipeline\r\n     */\r\n    public createPipelineContext(shaderProcessingContext: Nullable<ShaderProcessingContext>): IPipelineContext {\r\n        return new WebGPUPipelineContext(shaderProcessingContext! as WebGPUShaderProcessingContext, this);\r\n    }\r\n\r\n    /**\r\n     * Creates a new material context\r\n     * @returns the new context\r\n     */\r\n    public createMaterialContext(): WebGPUMaterialContext | undefined {\r\n        return new WebGPUMaterialContext();\r\n    }\r\n\r\n    /**\r\n     * Creates a new draw context\r\n     * @returns the new context\r\n     */\r\n    public createDrawContext(): WebGPUDrawContext | undefined {\r\n        return new WebGPUDrawContext(this._bufferManager);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _preparePipelineContext(\r\n        pipelineContext: IPipelineContext,\r\n        vertexSourceCode: string,\r\n        fragmentSourceCode: string,\r\n        createAsRaw: boolean,\r\n        rawVertexSourceCode: string,\r\n        rawFragmentSourceCode: string,\r\n        rebuildRebind: any,\r\n        defines: Nullable<string>\r\n    ) {\r\n        const webGpuContext = pipelineContext as WebGPUPipelineContext;\r\n        const shaderLanguage = webGpuContext.shaderProcessingContext.shaderLanguage;\r\n\r\n        if (this.dbgShowShaderCode) {\r\n            console.log(defines);\r\n            console.log(vertexSourceCode);\r\n            console.log(fragmentSourceCode);\r\n            console.log(\"***********************************************\");\r\n        }\r\n\r\n        webGpuContext.sources = {\r\n            fragment: fragmentSourceCode,\r\n            vertex: vertexSourceCode,\r\n            rawVertex: rawVertexSourceCode,\r\n            rawFragment: rawFragmentSourceCode,\r\n        };\r\n\r\n        if (createAsRaw) {\r\n            webGpuContext.stages = this._compileRawPipelineStageDescriptor(vertexSourceCode, fragmentSourceCode, shaderLanguage);\r\n        } else {\r\n            webGpuContext.stages = this._compilePipelineStageDescriptor(vertexSourceCode, fragmentSourceCode, defines, shaderLanguage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the list of active attributes for a given WebGPU program\r\n     * @param pipelineContext defines the pipeline context to use\r\n     * @param attributesNames defines the list of attribute names to get\r\n     * @returns an array of indices indicating the offset of each attribute\r\n     */\r\n    public getAttributes(pipelineContext: IPipelineContext, attributesNames: string[]): number[] {\r\n        const results = new Array(attributesNames.length);\r\n        const gpuPipelineContext = pipelineContext as WebGPUPipelineContext;\r\n\r\n        for (let i = 0; i < attributesNames.length; i++) {\r\n            const attributeName = attributesNames[i];\r\n            const attributeLocation = gpuPipelineContext.shaderProcessingContext.availableAttributes[attributeName];\r\n            if (attributeLocation === undefined) {\r\n                continue;\r\n            }\r\n\r\n            results[i] = attributeLocation;\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Activates an effect, making it the current one (ie. the one used for rendering)\r\n     * @param effect defines the effect to activate\r\n     */\r\n    public enableEffect(effect: Nullable<Effect | DrawWrapper>): void {\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        let isNewEffect = true;\r\n\r\n        if (!DrawWrapper.IsWrapper(effect)) {\r\n            isNewEffect = effect !== this._currentEffect;\r\n            this._currentEffect = effect;\r\n            this._currentMaterialContext = this._defaultMaterialContext;\r\n            this._currentDrawContext = this._defaultDrawContext;\r\n            this._counters.numEnableEffects++;\r\n            if (this.dbgLogIfNotDrawWrapper) {\r\n                Logger.Warn(\r\n                    `enableEffect has been called with an Effect and not a Wrapper! effect.uniqueId=${effect.uniqueId}, effect.name=${effect.name}, effect.name.vertex=${effect.name.vertex}, effect.name.fragment=${effect.name.fragment}`,\r\n                    10\r\n                );\r\n            }\r\n        } else if (\r\n            !effect.effect ||\r\n            (effect.effect === this._currentEffect &&\r\n                effect.materialContext === this._currentMaterialContext &&\r\n                effect.drawContext === this._currentDrawContext &&\r\n                !this._forceEnableEffect)\r\n        ) {\r\n            if (!effect.effect && this.dbgShowEmptyEnableEffectCalls) {\r\n                console.error(\"drawWrapper=\", effect);\r\n                throw \"Invalid call to enableEffect: the effect property is empty!\";\r\n            }\r\n            return;\r\n        } else {\r\n            isNewEffect = effect.effect !== this._currentEffect;\r\n            this._currentEffect = effect.effect;\r\n            this._currentMaterialContext = effect.materialContext as WebGPUMaterialContext;\r\n            this._currentDrawContext = effect.drawContext as WebGPUDrawContext;\r\n            this._counters.numEnableDrawWrapper++;\r\n            if (!this._currentMaterialContext) {\r\n                console.error(\"drawWrapper=\", effect);\r\n                throw `Invalid call to enableEffect: the materialContext property is empty!`;\r\n            }\r\n        }\r\n\r\n        this._stencilStateComposer.stencilMaterial = undefined;\r\n\r\n        this._forceEnableEffect = isNewEffect || this._forceEnableEffect ? false : this._forceEnableEffect;\r\n\r\n        if (isNewEffect) {\r\n            if (this._currentEffect!.onBind) {\r\n                this._currentEffect!.onBind(this._currentEffect!);\r\n            }\r\n            if (this._currentEffect!._onBindObservable) {\r\n                this._currentEffect!._onBindObservable.notifyObservers(this._currentEffect!);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _releaseEffect(effect: Effect): void {\r\n        if (this._compiledEffects[effect._key]) {\r\n            delete this._compiledEffects[effect._key];\r\n\r\n            this._deletePipelineContext(effect.getPipelineContext() as WebGPUPipelineContext);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled\r\n     */\r\n    public releaseEffects() {\r\n        for (const name in this._compiledEffects) {\r\n            const webGPUPipelineContext = this._compiledEffects[name].getPipelineContext() as WebGPUPipelineContext;\r\n            this._deletePipelineContext(webGPUPipelineContext);\r\n        }\r\n\r\n        this._compiledEffects = {};\r\n    }\r\n\r\n    public _deletePipelineContext(pipelineContext: IPipelineContext): void {\r\n        const webgpuPipelineContext = pipelineContext as WebGPUPipelineContext;\r\n        if (webgpuPipelineContext) {\r\n            pipelineContext.dispose();\r\n        }\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Textures\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Gets a boolean indicating that only power of 2 textures are supported\r\n     * Please note that you can still use non power of 2 textures but in this case the engine will forcefully convert them\r\n     */\r\n    public get needPOTTextures(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _createHardwareTexture(): HardwareTextureWrapper {\r\n        return new WebGPUHardwareTexture();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _releaseTexture(texture: InternalTexture): void {\r\n        const index = this._internalTexturesCache.indexOf(texture);\r\n        if (index !== -1) {\r\n            this._internalTexturesCache.splice(index, 1);\r\n        }\r\n\r\n        this._textureHelper.releaseTexture(texture);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getRGBABufferInternalSizedFormat(): number {\r\n        return Constants.TEXTUREFORMAT_RGBA;\r\n    }\r\n\r\n    public updateTextureComparisonFunction(texture: InternalTexture, comparisonFunction: number): void {\r\n        texture._comparisonFunction = comparisonFunction;\r\n    }\r\n\r\n    /**\r\n     * Creates an internal texture without binding it to a framebuffer\r\n     * @internal\r\n     * @param size defines the size of the texture\r\n     * @param options defines the options used to create the texture\r\n     * @param delayGPUTextureCreation true to delay the texture creation the first time it is really needed. false to create it right away\r\n     * @param source source type of the texture\r\n     * @returns a new internal texture\r\n     */\r\n    public _createInternalTexture(\r\n        size: TextureSize,\r\n        options: boolean | InternalTextureCreationOptions,\r\n        delayGPUTextureCreation = true,\r\n        source = InternalTextureSource.Unknown\r\n    ): InternalTexture {\r\n        const fullOptions: InternalTextureCreationOptions = {};\r\n\r\n        if (options !== undefined && typeof options === \"object\") {\r\n            fullOptions.generateMipMaps = options.generateMipMaps;\r\n            fullOptions.type = options.type === undefined ? Constants.TEXTURETYPE_UNSIGNED_INT : options.type;\r\n            fullOptions.samplingMode = options.samplingMode === undefined ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : options.samplingMode;\r\n            fullOptions.format = options.format === undefined ? Constants.TEXTUREFORMAT_RGBA : options.format;\r\n            fullOptions.samples = options.samples ?? 1;\r\n            fullOptions.creationFlags = options.creationFlags ?? 0;\r\n            fullOptions.useSRGBBuffer = options.useSRGBBuffer ?? false;\r\n            fullOptions.label = options.label;\r\n        } else {\r\n            fullOptions.generateMipMaps = <boolean>options;\r\n            fullOptions.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n            fullOptions.samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n            fullOptions.format = Constants.TEXTUREFORMAT_RGBA;\r\n            fullOptions.samples = 1;\r\n            fullOptions.creationFlags = 0;\r\n            fullOptions.useSRGBBuffer = false;\r\n        }\r\n\r\n        if (fullOptions.type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n            fullOptions.samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        } else if (fullOptions.type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n            fullOptions.samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n        if (fullOptions.type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\r\n            fullOptions.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n            Logger.Warn(\"Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE\");\r\n        }\r\n\r\n        const texture = new InternalTexture(this, source);\r\n\r\n        const width = (<{ width: number; height: number; layers?: number }>size).width || <number>size;\r\n        const height = (<{ width: number; height: number; layers?: number }>size).height || <number>size;\r\n        const layers = (<{ width: number; height: number; layers?: number }>size).layers || 0;\r\n\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.depth = layers;\r\n        texture.isReady = true;\r\n        texture.samples = fullOptions.samples;\r\n        texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;\r\n        texture.samplingMode = fullOptions.samplingMode;\r\n        texture.type = fullOptions.type;\r\n        texture.format = fullOptions.format;\r\n        texture.is2DArray = layers > 0;\r\n        texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        texture._useSRGBBuffer = fullOptions.useSRGBBuffer;\r\n        texture.label = fullOptions.label;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        if (!delayGPUTextureCreation) {\r\n            this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, layers || 1, fullOptions.creationFlags);\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Usually called from Texture.ts.\r\n     * Passed information to create a hardware texture\r\n     * @param url defines a value which contains one of the following:\r\n     * * A conventional http URL, e.g. 'http://...' or 'file://...'\r\n     * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\r\n     * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\r\n     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\r\n     * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\r\n     * @param scene needed for loading to the correct scene\r\n     * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param onLoad optional callback to be called upon successful completion\r\n     * @param onError optional callback to be called upon failure\r\n     * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\r\n     * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\r\n     * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @param mimeType defines an optional mime type\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns a InternalTexture for assignment back into BABYLON.Texture\r\n     */\r\n    public createTexture(\r\n        url: Nullable<string>,\r\n        noMipmap: boolean,\r\n        invertY: boolean,\r\n        scene: Nullable<ISceneLike>,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<(texture: InternalTexture) => void> = null,\r\n        onError: Nullable<(message: string, exception: any) => void> = null,\r\n        buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null,\r\n        fallback: Nullable<InternalTexture> = null,\r\n        format: Nullable<number> = null,\r\n        forcedExtension: Nullable<string> = null,\r\n        mimeType?: string,\r\n        loaderOptions?: any,\r\n        creationFlags?: number,\r\n        useSRGBBuffer?: boolean\r\n    ): InternalTexture {\r\n        return this._createTextureBase(\r\n            url,\r\n            noMipmap,\r\n            invertY,\r\n            scene,\r\n            samplingMode,\r\n            onLoad,\r\n            onError,\r\n            (\r\n                texture: InternalTexture,\r\n                extension: string,\r\n                scene: Nullable<ISceneLike>,\r\n                img: HTMLImageElement | ImageBitmap | { width: number; height: number },\r\n                invertY: boolean,\r\n                noMipmap: boolean,\r\n                isCompressed: boolean,\r\n                processFunction: (\r\n                    width: number,\r\n                    height: number,\r\n                    img: HTMLImageElement | ImageBitmap | { width: number; height: number },\r\n                    extension: string,\r\n                    texture: InternalTexture,\r\n                    continuationCallback: () => void\r\n                ) => boolean\r\n            ) => {\r\n                const imageBitmap = img as ImageBitmap | { width: number; height: number }; // we will never get an HTMLImageElement in WebGPU\r\n\r\n                texture.baseWidth = imageBitmap.width;\r\n                texture.baseHeight = imageBitmap.height;\r\n                texture.width = imageBitmap.width;\r\n                texture.height = imageBitmap.height;\r\n                texture.format = texture.format !== -1 ? texture.format : format ?? Constants.TEXTUREFORMAT_RGBA;\r\n                texture.type = texture.type !== -1 ? texture.type : Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n\r\n                processFunction(texture.width, texture.height, imageBitmap, extension, texture, () => {});\r\n\r\n                if (!texture._hardwareTexture?.underlyingResource) {\r\n                    // the texture could have been created before reaching this point so don't recreate it if already existing\r\n                    const gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, imageBitmap.width, imageBitmap.height, undefined, creationFlags);\r\n\r\n                    if (WebGPUTextureHelper.IsImageBitmap(imageBitmap)) {\r\n                        this._textureHelper.updateTexture(\r\n                            imageBitmap,\r\n                            texture,\r\n                            imageBitmap.width,\r\n                            imageBitmap.height,\r\n                            texture.depth,\r\n                            gpuTextureWrapper.format,\r\n                            0,\r\n                            0,\r\n                            invertY,\r\n                            false,\r\n                            0,\r\n                            0\r\n                        );\r\n                        if (!noMipmap && !isCompressed) {\r\n                            this._generateMipmaps(texture, this._uploadEncoder);\r\n                        }\r\n                    }\r\n                } else if (!noMipmap && !isCompressed) {\r\n                    this._generateMipmaps(texture, this._uploadEncoder);\r\n                }\r\n\r\n                if (scene) {\r\n                    scene.removePendingData(texture);\r\n                }\r\n\r\n                texture.isReady = true;\r\n\r\n                texture.onLoadedObservable.notifyObservers(texture);\r\n                texture.onLoadedObservable.clear();\r\n            },\r\n            () => false,\r\n            buffer,\r\n            fallback,\r\n            format,\r\n            forcedExtension,\r\n            mimeType,\r\n            loaderOptions,\r\n            useSRGBBuffer\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Wraps an external web gpu texture in a Babylon texture.\r\n     * @param texture defines the external texture\r\n     * @returns the babylon internal texture\r\n     */\r\n    public wrapWebGPUTexture(texture: GPUTexture): InternalTexture {\r\n        const hardwareTexture = new WebGPUHardwareTexture(texture);\r\n        const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);\r\n        internalTexture._hardwareTexture = hardwareTexture;\r\n        internalTexture.isReady = true;\r\n        return internalTexture;\r\n    }\r\n\r\n    /**\r\n     * Wraps an external web gl texture in a Babylon texture.\r\n     * @returns the babylon internal texture\r\n     */\r\n    public wrapWebGLTexture(): InternalTexture {\r\n        throw new Error(\"wrapWebGLTexture is not supported, use wrapWebGPUTexture instead.\");\r\n    }\r\n\r\n    public generateMipMapsForCubemap(texture: InternalTexture) {\r\n        if (texture.generateMipMaps) {\r\n            const gpuTexture = texture._hardwareTexture?.underlyingResource;\r\n\r\n            if (!gpuTexture) {\r\n                this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n            }\r\n\r\n            this._generateMipmaps(\r\n                texture,\r\n                texture.source === InternalTextureSource.RenderTarget || texture.source === InternalTextureSource.MultiRenderTarget ? this._renderTargetEncoder : undefined\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the sampling mode of a given texture\r\n     * @param samplingMode defines the required sampling mode\r\n     * @param texture defines the texture to update\r\n     * @param generateMipMaps defines whether to generate mipmaps for the texture\r\n     */\r\n    public updateTextureSamplingMode(samplingMode: number, texture: InternalTexture, generateMipMaps: boolean = false): void {\r\n        if (generateMipMaps) {\r\n            texture.generateMipMaps = true;\r\n            this._generateMipmaps(texture);\r\n        }\r\n\r\n        texture.samplingMode = samplingMode;\r\n    }\r\n\r\n    /**\r\n     * Update the sampling mode of a given texture\r\n     * @param texture defines the texture to update\r\n     * @param wrapU defines the texture wrap mode of the u coordinates\r\n     * @param wrapV defines the texture wrap mode of the v coordinates\r\n     * @param wrapR defines the texture wrap mode of the r coordinates\r\n     */\r\n    public updateTextureWrappingMode(texture: InternalTexture, wrapU: Nullable<number>, wrapV: Nullable<number> = null, wrapR: Nullable<number> = null): void {\r\n        if (wrapU !== null) {\r\n            texture._cachedWrapU = wrapU;\r\n        }\r\n        if (wrapV !== null) {\r\n            texture._cachedWrapV = wrapV;\r\n        }\r\n        if ((texture.is2DArray || texture.is3D) && wrapR !== null) {\r\n            texture._cachedWrapR = wrapR;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the dimensions of a texture\r\n     * @param texture texture to update\r\n     * @param width new width of the texture\r\n     * @param height new height of the texture\r\n     * @param depth new depth of the texture\r\n     */\r\n    public updateTextureDimensions(texture: InternalTexture, width: number, height: number, depth: number = 1): void {\r\n        if (!texture._hardwareTexture) {\r\n            // the gpu texture is not created yet, so when it is it will be created with the right dimensions\r\n            return;\r\n        }\r\n\r\n        if (texture.width === width && texture.height === height && texture.depth === depth) {\r\n            return;\r\n        }\r\n\r\n        const additionalUsages = (texture._hardwareTexture as WebGPUHardwareTexture).textureAdditionalUsages;\r\n\r\n        texture._hardwareTexture.release(); // don't defer the releasing! Else we will release at the end of this frame the gpu texture we are about to create in the next line...\r\n\r\n        this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, depth, additionalUsages);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setInternalTexture(name: string, texture: Nullable<InternalTexture | ExternalTexture>, baseName?: string): void {\r\n        baseName = baseName ?? name;\r\n        if (this._currentEffect) {\r\n            const webgpuPipelineContext = this._currentEffect._pipelineContext as WebGPUPipelineContext;\r\n            const availableTexture = webgpuPipelineContext.shaderProcessingContext.availableTextures[baseName];\r\n\r\n            this._currentMaterialContext.setTexture(name, texture);\r\n\r\n            if (availableTexture && availableTexture.autoBindSampler) {\r\n                const samplerName = baseName + WebGPUShaderProcessor.AutoSamplerSuffix;\r\n                this._currentMaterialContext.setSampler(samplerName, texture as InternalTexture); // we can safely cast to InternalTexture because ExternalTexture always has autoBindSampler = false\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a texture to the according uniform.\r\n     * @param channel The texture channel\r\n     * @param unused unused parameter\r\n     * @param texture The texture to apply\r\n     * @param name The name of the uniform in the effect\r\n     */\r\n    public setTexture(channel: number, unused: Nullable<WebGLUniformLocation>, texture: Nullable<BaseTexture>, name: string): void {\r\n        this._setTexture(channel, texture, false, false, name, name);\r\n    }\r\n\r\n    /**\r\n     * Sets an array of texture to the WebGPU context\r\n     * @param channel defines the channel where the texture array must be set\r\n     * @param unused unused parameter\r\n     * @param textures defines the array of textures to bind\r\n     * @param name name of the channel\r\n     */\r\n    public setTextureArray(channel: number, unused: Nullable<WebGLUniformLocation>, textures: BaseTexture[], name: string): void {\r\n        for (let index = 0; index < textures.length; index++) {\r\n            this._setTexture(-1, textures[index], true, false, name + index.toString(), name);\r\n        }\r\n    }\r\n\r\n    protected _setTexture(\r\n        channel: number,\r\n        texture: Nullable<BaseTexture>,\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        isPartOfTextureArray = false,\r\n        depthStencilTexture = false,\r\n        name = \"\",\r\n        baseName?: string\r\n    ): boolean {\r\n        // name == baseName for a texture that is not part of a texture array\r\n        // Else, name is something like 'myTexture0' / 'myTexture1' / ... and baseName is 'myTexture'\r\n        // baseName is used to look up the texture in the shaderProcessingContext.availableTextures map\r\n        // name is used to look up the texture in the _currentMaterialContext.textures map\r\n        baseName = baseName ?? name;\r\n        if (this._currentEffect) {\r\n            if (!texture) {\r\n                this._currentMaterialContext.setTexture(name, null);\r\n                return false;\r\n            }\r\n\r\n            // Video\r\n            if ((<VideoTexture>texture).video) {\r\n                (<VideoTexture>texture).update();\r\n            } else if (texture.delayLoadState === Constants.DELAYLOADSTATE_NOTLOADED) {\r\n                // Delay loading\r\n                texture.delayLoad();\r\n                return false;\r\n            }\r\n\r\n            let internalTexture: Nullable<InternalTexture> = null;\r\n            if (depthStencilTexture) {\r\n                internalTexture = (<RenderTargetTexture>texture).depthStencilTexture!;\r\n            } else if (texture.isReady()) {\r\n                internalTexture = <InternalTexture>texture.getInternalTexture();\r\n            } else if (texture.isCube) {\r\n                internalTexture = this.emptyCubeTexture;\r\n            } else if (texture.is3D) {\r\n                internalTexture = this.emptyTexture3D;\r\n            } else if (texture.is2DArray) {\r\n                internalTexture = this.emptyTexture2DArray;\r\n            } else {\r\n                internalTexture = this.emptyTexture;\r\n            }\r\n\r\n            if (internalTexture && !internalTexture.isMultiview) {\r\n                // CUBIC_MODE and SKYBOX_MODE both require CLAMP_TO_EDGE.  All other modes use REPEAT.\r\n                if (internalTexture.isCube && internalTexture._cachedCoordinatesMode !== texture.coordinatesMode) {\r\n                    internalTexture._cachedCoordinatesMode = texture.coordinatesMode;\r\n\r\n                    const textureWrapMode =\r\n                        texture.coordinatesMode !== Constants.TEXTURE_CUBIC_MODE && texture.coordinatesMode !== Constants.TEXTURE_SKYBOX_MODE\r\n                            ? Constants.TEXTURE_WRAP_ADDRESSMODE\r\n                            : Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n                    texture.wrapU = textureWrapMode;\r\n                    texture.wrapV = textureWrapMode;\r\n                }\r\n\r\n                internalTexture._cachedWrapU = texture.wrapU;\r\n                internalTexture._cachedWrapV = texture.wrapV;\r\n                if (internalTexture.is3D) {\r\n                    internalTexture._cachedWrapR = texture.wrapR;\r\n                }\r\n\r\n                this._setAnisotropicLevel(0, internalTexture, texture.anisotropicFilteringLevel);\r\n            }\r\n\r\n            this._setInternalTexture(name, internalTexture, baseName);\r\n        } else {\r\n            if (this.dbgVerboseLogsForFirstFrames) {\r\n                if ((this as any)._count === undefined) {\r\n                    (this as any)._count = 0;\r\n                }\r\n                if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                    console.log(\"frame #\" + (this as any)._count + \" - _setTexture called with a null _currentEffect! texture=\", texture);\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setAnisotropicLevel(target: number, internalTexture: InternalTexture, anisotropicFilteringLevel: number) {\r\n        if (internalTexture._cachedAnisotropicFilteringLevel !== anisotropicFilteringLevel) {\r\n            internalTexture._cachedAnisotropicFilteringLevel = Math.min(anisotropicFilteringLevel, this._caps.maxAnisotropy);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bindTexture(channel: number, texture: InternalTexture, name: string): void {\r\n        if (channel === undefined) {\r\n            return;\r\n        }\r\n\r\n        this._setInternalTexture(name, texture);\r\n    }\r\n\r\n    /**\r\n     * Generates the mipmaps for a texture\r\n     * @param texture texture to generate the mipmaps for\r\n     */\r\n    public generateMipmaps(texture: InternalTexture): void {\r\n        this._generateMipmaps(texture, this._renderTargetEncoder);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _generateMipmaps(texture: InternalTexture, commandEncoder?: GPUCommandEncoder) {\r\n        const gpuHardwareTexture = texture._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        if (!gpuHardwareTexture) {\r\n            return;\r\n        }\r\n\r\n        // try as much as possible to use the command encoder corresponding to the current pass.\r\n        // If not possible (because the pass is started - generateMipmaps itself creates a pass and it's not allowed to have a pass inside a pass), use _uploadEncoder\r\n        commandEncoder =\r\n            commandEncoder ??\r\n            (this._currentRenderTarget && !this._currentRenderPass ? this._renderTargetEncoder : !this._currentRenderPass ? this._renderEncoder : this._uploadEncoder);\r\n\r\n        const format = (texture._hardwareTexture as WebGPUHardwareTexture).format;\r\n        const mipmapCount = WebGPUTextureHelper.ComputeNumMipmapLevels(texture.width, texture.height);\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\"frame #\" + (this as any)._count + \" - generate mipmaps called - width=\", texture.width, \"height=\", texture.height, \"isCube=\", texture.isCube);\r\n            }\r\n        }\r\n\r\n        if (texture.isCube) {\r\n            this._textureHelper.generateCubeMipmaps(gpuHardwareTexture, format, mipmapCount, commandEncoder);\r\n        } else {\r\n            this._textureHelper.generateMipmaps(gpuHardwareTexture, format, mipmapCount, 0, commandEncoder);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update a portion of an internal texture\r\n     * @param texture defines the texture to update\r\n     * @param imageData defines the data to store into the texture\r\n     * @param xOffset defines the x coordinates of the update rectangle\r\n     * @param yOffset defines the y coordinates of the update rectangle\r\n     * @param width defines the width of the update rectangle\r\n     * @param height defines the height of the update rectangle\r\n     * @param faceIndex defines the face index if texture is a cube (0 by default)\r\n     * @param lod defines the lod level to update (0 by default)\r\n     * @param generateMipMaps defines whether to generate mipmaps or not\r\n     */\r\n    public updateTextureData(\r\n        texture: InternalTexture,\r\n        imageData: ArrayBufferView,\r\n        xOffset: number,\r\n        yOffset: number,\r\n        width: number,\r\n        height: number,\r\n        faceIndex: number = 0,\r\n        lod: number = 0,\r\n        generateMipMaps = false\r\n    ): void {\r\n        let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n        if (!texture._hardwareTexture?.underlyingResource) {\r\n            gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n        }\r\n\r\n        const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, xOffset, yOffset);\r\n\r\n        if (generateMipMaps) {\r\n            this._generateMipmaps(texture, this._renderTargetEncoder);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadCompressedDataToTextureDirectly(\r\n        texture: InternalTexture,\r\n        internalFormat: number,\r\n        width: number,\r\n        height: number,\r\n        imageData: ArrayBufferView,\r\n        faceIndex: number = 0,\r\n        lod: number = 0\r\n    ) {\r\n        let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n        if (!texture._hardwareTexture?.underlyingResource) {\r\n            texture.format = internalFormat;\r\n            gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\r\n        }\r\n\r\n        const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, false, false, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadDataToTextureDirectly(\r\n        texture: InternalTexture,\r\n        imageData: ArrayBufferView,\r\n        faceIndex: number = 0,\r\n        lod: number = 0,\r\n        babylonInternalFormat?: number,\r\n        useTextureWidthAndHeight = false\r\n    ): void {\r\n        const lodMaxWidth = Math.round(Math.log(texture.width) * Math.LOG2E);\r\n        const lodMaxHeight = Math.round(Math.log(texture.height) * Math.LOG2E);\r\n\r\n        const width = useTextureWidthAndHeight ? texture.width : Math.pow(2, Math.max(lodMaxWidth - lod, 0));\r\n        const height = useTextureWidthAndHeight ? texture.height : Math.pow(2, Math.max(lodMaxHeight - lod, 0));\r\n\r\n        let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n        if (!texture._hardwareTexture?.underlyingResource) {\r\n            gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\r\n        }\r\n\r\n        const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadArrayBufferViewToTexture(texture: InternalTexture, imageData: ArrayBufferView, faceIndex: number = 0, lod: number = 0): void {\r\n        this._uploadDataToTextureDirectly(texture, imageData, faceIndex, lod);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadImageToTexture(texture: InternalTexture, image: HTMLImageElement | ImageBitmap, faceIndex: number = 0, lod: number = 0) {\r\n        let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n        if (!texture._hardwareTexture?.underlyingResource) {\r\n            gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n        }\r\n\r\n        if (image instanceof HTMLImageElement) {\r\n            throw \"WebGPU engine: HTMLImageElement not supported in _uploadImageToTexture!\";\r\n        }\r\n\r\n        const bitmap = image as ImageBitmap; // in WebGPU we will always get an ImageBitmap, not an HTMLImageElement\r\n\r\n        const width = Math.ceil(texture.width / (1 << lod));\r\n        const height = Math.ceil(texture.height / (1 << lod));\r\n\r\n        this._textureHelper.updateTexture(bitmap, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Reads pixels from the current frame buffer. Please note that this function can be slow\r\n     * @param x defines the x coordinate of the rectangle where pixels must be read\r\n     * @param y defines the y coordinate of the rectangle where pixels must be read\r\n     * @param width defines the width of the rectangle where pixels must be read\r\n     * @param height defines the height of the rectangle where pixels must be read\r\n     * @param hasAlpha defines whether the output should have alpha or not (defaults to true)\r\n     * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\r\n     * @returns a ArrayBufferView promise (Uint8Array) containing RGBA colors\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public readPixels(x: number, y: number, width: number, height: number, hasAlpha = true, flushRenderer = true): Promise<ArrayBufferView> {\r\n        const renderPassWrapper = this._rttRenderPassWrapper.renderPass ? this._rttRenderPassWrapper : this._mainRenderPassWrapper;\r\n        const hardwareTexture = renderPassWrapper.colorAttachmentGPUTextures[0];\r\n        if (!hardwareTexture) {\r\n            // we are calling readPixels for a render pass with no color texture bound\r\n            return Promise.resolve(new Uint8Array(0));\r\n        }\r\n        const gpuTexture = hardwareTexture.underlyingResource;\r\n        const gpuTextureFormat = hardwareTexture.format;\r\n        if (!gpuTexture) {\r\n            // we are calling readPixels before startMainRenderPass has been called and no RTT is bound, so swapChainTexture is not setup yet!\r\n            return Promise.resolve(new Uint8Array(0));\r\n        }\r\n        if (flushRenderer) {\r\n            this.flushFramebuffer();\r\n        }\r\n        return this._textureHelper.readPixels(gpuTexture, x, y, width, height, gpuTextureFormat);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Frame management\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Begin a new frame\r\n     */\r\n    public beginFrame(): void {\r\n        super.beginFrame();\r\n    }\r\n\r\n    /**\r\n     * End the current frame\r\n     */\r\n    public endFrame() {\r\n        this._snapshotRendering.endFrame(this._mainRenderPassWrapper.renderPass);\r\n\r\n        this._endMainRenderPass();\r\n\r\n        this._timestampQuery.endFrame(this._renderEncoder);\r\n\r\n        this.flushFramebuffer(false);\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\"frame #\" + (this as any)._count + \" - counters\");\r\n            }\r\n        }\r\n\r\n        this._textureHelper.destroyDeferredTextures();\r\n        this._bufferManager.destroyDeferredBuffers();\r\n\r\n        if (this._features._collectUbosUpdatedInFrame) {\r\n            if (this.dbgVerboseLogsForFirstFrames) {\r\n                if ((this as any)._count === undefined) {\r\n                    (this as any)._count = 0;\r\n                }\r\n                if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                    const list: Array<string> = [];\r\n                    for (const name in UniformBuffer._UpdatedUbosInFrame) {\r\n                        list.push(name + \":\" + UniformBuffer._UpdatedUbosInFrame[name]);\r\n                    }\r\n                    console.log(\"frame #\" + (this as any)._count + \" - updated ubos -\", list.join(\", \"));\r\n                }\r\n            }\r\n            UniformBuffer._UpdatedUbosInFrame = {};\r\n        }\r\n\r\n        this.countersLastFrame.numEnableEffects = this._counters.numEnableEffects;\r\n        this.countersLastFrame.numEnableDrawWrapper = this._counters.numEnableDrawWrapper;\r\n        this.countersLastFrame.numBundleCreationNonCompatMode = this._counters.numBundleCreationNonCompatMode;\r\n        this.countersLastFrame.numBundleReuseNonCompatMode = this._counters.numBundleReuseNonCompatMode;\r\n        this._counters.numEnableEffects = 0;\r\n        this._counters.numEnableDrawWrapper = 0;\r\n        this._counters.numBundleCreationNonCompatMode = 0;\r\n        this._counters.numBundleReuseNonCompatMode = 0;\r\n\r\n        this._cacheRenderPipeline.endFrame();\r\n        this._cacheBindGroups.endFrame();\r\n\r\n        this._pendingDebugCommands.length = 0;\r\n\r\n        super.endFrame();\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if ((this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\"%c frame #\" + (this as any)._count + \" - end\", \"background: #ffff00\");\r\n            }\r\n            if ((this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                (this as any)._count++;\r\n                if ((this as any)._count !== this.dbgVerboseLogsNumFrames) {\r\n                    console.log(\"%c frame #\" + (this as any)._count + \" - begin\", \"background: #ffff00\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force a WebGPU flush (ie. a flush of all waiting commands)\r\n     * @param reopenPass true to reopen at the end of the function the pass that was active when entering the function\r\n     */\r\n    public flushFramebuffer(reopenPass = true): void {\r\n        // we need to end the current render pass (main or rtt) if any as we are not allowed to submit the command buffers when being in a pass\r\n        const currentRenderPassIsNULL = !this._currentRenderPass;\r\n        let currentPasses = 0; // 0 if no pass, 1 for rtt, 2 for main pass\r\n        if (this._currentRenderPass && this._currentRenderTarget) {\r\n            currentPasses |= 1;\r\n            this._endRenderTargetRenderPass();\r\n        }\r\n        if (this._mainRenderPassWrapper.renderPass) {\r\n            currentPasses |= 2;\r\n            this._endMainRenderPass();\r\n        }\r\n\r\n        this._commandBuffers[0] = this._uploadEncoder.finish();\r\n        this._commandBuffers[1] = this._renderTargetEncoder.finish();\r\n        this._commandBuffers[2] = this._renderEncoder.finish();\r\n\r\n        this._device.queue.submit(this._commandBuffers);\r\n\r\n        this._uploadEncoder = this._device.createCommandEncoder(this._uploadEncoderDescriptor);\r\n        this._renderEncoder = this._device.createCommandEncoder(this._renderEncoderDescriptor);\r\n        this._renderTargetEncoder = this._device.createCommandEncoder(this._renderTargetEncoderDescriptor);\r\n\r\n        this._timestampQuery.startFrame(this._uploadEncoder);\r\n\r\n        this._textureHelper.setCommandEncoder(this._uploadEncoder);\r\n\r\n        this._bundleList.reset();\r\n        this._bundleListRenderTarget.reset();\r\n\r\n        // restart the render pass\r\n        if (reopenPass) {\r\n            if (currentPasses & 2) {\r\n                this._startMainRenderPass(false);\r\n            }\r\n            if (currentPasses & 1) {\r\n                this._startRenderTargetRenderPass(this._currentRenderTarget!, false, null, false, false);\r\n            }\r\n            if (currentRenderPassIsNULL && this._currentRenderTarget) {\r\n                this._currentRenderPass = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _currentFrameBufferIsDefaultFrameBuffer() {\r\n        return this._currentRenderTarget === null;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Render Pass\r\n    //------------------------------------------------------------------------------\r\n\r\n    private _startRenderTargetRenderPass(\r\n        renderTargetWrapper: RenderTargetWrapper,\r\n        setClearStates: boolean,\r\n        clearColor: Nullable<IColor4Like>,\r\n        clearDepth: boolean,\r\n        clearStencil: boolean\r\n    ) {\r\n        const rtWrapper = renderTargetWrapper as WebGPURenderTargetWrapper;\r\n\r\n        const depthStencilTexture = rtWrapper._depthStencilTexture;\r\n        const gpuDepthStencilWrapper = depthStencilTexture?._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n        const gpuDepthStencilTexture = gpuDepthStencilWrapper?.underlyingResource as Nullable<GPUTexture>;\r\n        const gpuDepthStencilMSAATexture = gpuDepthStencilWrapper?.getMSAATexture();\r\n\r\n        const depthTextureView = gpuDepthStencilTexture?.createView(this._rttRenderPassWrapper.depthAttachmentViewDescriptor!);\r\n        const depthMSAATextureView = gpuDepthStencilMSAATexture?.createView(this._rttRenderPassWrapper.depthAttachmentViewDescriptor!);\r\n        const depthTextureHasStencil = gpuDepthStencilWrapper ? WebGPUTextureHelper.HasStencilAspect(gpuDepthStencilWrapper.format) : false;\r\n\r\n        const colorAttachments: (GPURenderPassColorAttachment | null)[] = [];\r\n\r\n        if (this.useReverseDepthBuffer) {\r\n            this.setDepthFunctionToGreaterOrEqual();\r\n        }\r\n\r\n        const clearColorForIntegerRT = tempColor4;\r\n        if (clearColor) {\r\n            clearColorForIntegerRT.r = clearColor.r * 255;\r\n            clearColorForIntegerRT.g = clearColor.g * 255;\r\n            clearColorForIntegerRT.b = clearColor.b * 255;\r\n            clearColorForIntegerRT.a = clearColor.a * 255;\r\n        }\r\n\r\n        const mustClearColor = setClearStates && clearColor;\r\n        const mustClearDepth = setClearStates && clearDepth;\r\n        const mustClearStencil = setClearStates && clearStencil;\r\n\r\n        if (rtWrapper._attachments && rtWrapper.isMulti) {\r\n            // multi render targets\r\n            if (!this._mrtAttachments || this._mrtAttachments.length === 0) {\r\n                this._mrtAttachments = rtWrapper._defaultAttachments;\r\n            }\r\n            for (let i = 0; i < this._mrtAttachments.length; ++i) {\r\n                const index = this._mrtAttachments[i]; // if index == 0 it means the texture should not be written to => at render pass creation time, it means we should not clear it\r\n                const mrtTexture = rtWrapper.textures![i];\r\n                const gpuMRTWrapper = mrtTexture?._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n                const gpuMRTTexture = gpuMRTWrapper?.underlyingResource;\r\n                if (gpuMRTWrapper && gpuMRTTexture) {\r\n                    const gpuMSAATexture = gpuMRTWrapper.getMSAATexture(i);\r\n\r\n                    const layerIndex = rtWrapper.layerIndices?.[i] ?? 0;\r\n                    const faceIndex = rtWrapper.faceIndices?.[i] ?? 0;\r\n                    const viewDescriptor = {\r\n                        ...this._rttRenderPassWrapper.colorAttachmentViewDescriptor!,\r\n                        format: gpuMRTWrapper.format,\r\n                        baseArrayLayer: mrtTexture.isCube ? layerIndex * 6 + faceIndex : layerIndex,\r\n                    };\r\n                    const msaaViewDescriptor = {\r\n                        ...this._rttRenderPassWrapper.colorAttachmentViewDescriptor!,\r\n                        format: gpuMRTWrapper.format,\r\n                        baseArrayLayer: 0,\r\n                    };\r\n                    const isRTInteger = mrtTexture.type === Constants.TEXTURETYPE_UNSIGNED_INTEGER || mrtTexture.type === Constants.TEXTURETYPE_UNSIGNED_SHORT;\r\n\r\n                    const colorTextureView = gpuMRTTexture.createView(viewDescriptor);\r\n                    const colorMSAATextureView = gpuMSAATexture?.createView(msaaViewDescriptor);\r\n\r\n                    colorAttachments.push({\r\n                        view: colorMSAATextureView ? colorMSAATextureView : colorTextureView,\r\n                        resolveTarget: gpuMSAATexture ? colorTextureView : undefined,\r\n                        clearValue: index !== 0 && mustClearColor ? (isRTInteger ? clearColorForIntegerRT : clearColor) : undefined,\r\n                        loadOp: index !== 0 && mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\r\n                        storeOp: WebGPUConstants.StoreOp.Store,\r\n                    });\r\n                }\r\n            }\r\n            this._cacheRenderPipeline.setMRT(rtWrapper.textures!, this._mrtAttachments.length);\r\n            this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\r\n        } else {\r\n            // single render target\r\n            const internalTexture = rtWrapper.texture;\r\n            if (internalTexture) {\r\n                const gpuWrapper = internalTexture._hardwareTexture as WebGPUHardwareTexture;\r\n                const gpuTexture = gpuWrapper.underlyingResource!;\r\n\r\n                const gpuMSAATexture = gpuWrapper.getMSAATexture();\r\n                const colorTextureView = gpuTexture.createView(this._rttRenderPassWrapper.colorAttachmentViewDescriptor!);\r\n                const colorMSAATextureView = gpuMSAATexture?.createView(this._rttRenderPassWrapper.colorAttachmentViewDescriptor!);\r\n                const isRTInteger = internalTexture.type === Constants.TEXTURETYPE_UNSIGNED_INTEGER || internalTexture.type === Constants.TEXTURETYPE_UNSIGNED_SHORT;\r\n\r\n                colorAttachments.push({\r\n                    view: colorMSAATextureView ? colorMSAATextureView : colorTextureView,\r\n                    resolveTarget: gpuMSAATexture ? colorTextureView : undefined,\r\n                    clearValue: mustClearColor ? (isRTInteger ? clearColorForIntegerRT : clearColor) : undefined,\r\n                    loadOp: mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\r\n                    storeOp: WebGPUConstants.StoreOp.Store,\r\n                });\r\n            } else {\r\n                colorAttachments.push(null);\r\n            }\r\n        }\r\n\r\n        this._debugPushGroup?.(\"render target pass\", 1);\r\n\r\n        this._rttRenderPassWrapper.renderPassDescriptor = {\r\n            label: (renderTargetWrapper.label ?? \"RTT\") + \"RenderPass\",\r\n            colorAttachments,\r\n            depthStencilAttachment:\r\n                depthStencilTexture && gpuDepthStencilTexture\r\n                    ? {\r\n                          view: depthMSAATextureView ? depthMSAATextureView : depthTextureView!,\r\n                          depthClearValue: mustClearDepth ? (this.useReverseDepthBuffer ? this._clearReverseDepthValue : this._clearDepthValue) : undefined,\r\n                          depthLoadOp: mustClearDepth ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\r\n                          depthStoreOp: WebGPUConstants.StoreOp.Store,\r\n                          stencilClearValue: rtWrapper._depthStencilTextureWithStencil && mustClearStencil ? this._clearStencilValue : undefined,\r\n                          stencilLoadOp: !depthTextureHasStencil\r\n                              ? undefined\r\n                              : rtWrapper._depthStencilTextureWithStencil && mustClearStencil\r\n                              ? WebGPUConstants.LoadOp.Clear\r\n                              : WebGPUConstants.LoadOp.Load,\r\n                          stencilStoreOp: !depthTextureHasStencil ? undefined : WebGPUConstants.StoreOp.Store,\r\n                      }\r\n                    : undefined,\r\n            occlusionQuerySet: this._occlusionQuery?.hasQueries ? this._occlusionQuery.querySet : undefined,\r\n        };\r\n        this._rttRenderPassWrapper.renderPass = this._renderTargetEncoder.beginRenderPass(this._rttRenderPassWrapper.renderPassDescriptor);\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                const internalTexture = rtWrapper.texture!;\r\n                console.log(\r\n                    \"frame #\" + (this as any)._count + \" - render target begin pass - internalTexture.uniqueId=\",\r\n                    internalTexture.uniqueId,\r\n                    \"width=\",\r\n                    internalTexture.width,\r\n                    \"height=\",\r\n                    internalTexture.height,\r\n                    this._rttRenderPassWrapper.renderPassDescriptor\r\n                );\r\n            }\r\n        }\r\n\r\n        this._currentRenderPass = this._rttRenderPassWrapper.renderPass;\r\n\r\n        this._debugFlushPendingCommands?.();\r\n\r\n        this._resetCurrentViewport(1);\r\n        this._resetCurrentScissor(1);\r\n        this._resetCurrentStencilRef(1);\r\n        this._resetCurrentColorBlend(1);\r\n\r\n        if (!gpuDepthStencilWrapper || !WebGPUTextureHelper.HasStencilAspect(gpuDepthStencilWrapper.format)) {\r\n            this._stencilStateComposer.enabled = false;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _endRenderTargetRenderPass() {\r\n        if (this._currentRenderPass) {\r\n            const gpuWrapper = this._currentRenderTarget!.texture?._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n            if (gpuWrapper && !this._snapshotRendering.endRenderTargetPass(this._currentRenderPass, gpuWrapper) && !this.compatibilityMode) {\r\n                this._bundleListRenderTarget.run(this._currentRenderPass);\r\n                this._bundleListRenderTarget.reset();\r\n            }\r\n            this._currentRenderPass.end();\r\n            if (this.dbgVerboseLogsForFirstFrames) {\r\n                if ((this as any)._count === undefined) {\r\n                    (this as any)._count = 0;\r\n                }\r\n                if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                    console.log(\"frame #\" + (this as any)._count + \" - render target end pass - internalTexture.uniqueId=\", this._currentRenderTarget?.texture?.uniqueId);\r\n                }\r\n            }\r\n            this._debugPopGroup?.(1);\r\n            this._resetCurrentViewport(1);\r\n            this._viewport(0, 0, 0, 0);\r\n            this._resetCurrentScissor(1);\r\n            this._resetCurrentStencilRef(1);\r\n            this._resetCurrentColorBlend(1);\r\n            this._currentRenderPass = null;\r\n            this._rttRenderPassWrapper.reset();\r\n        }\r\n    }\r\n\r\n    private _getCurrentRenderPass(): GPURenderPassEncoder {\r\n        if (this._currentRenderTarget && !this._currentRenderPass) {\r\n            // delayed creation of the render target pass, but we now need to create it as we are requested the render pass\r\n            this._startRenderTargetRenderPass(this._currentRenderTarget, false, null, false, false);\r\n        } else if (!this._currentRenderPass) {\r\n            this._startMainRenderPass(false);\r\n        }\r\n\r\n        return this._currentRenderPass!;\r\n    }\r\n\r\n    /** @internal */\r\n    public _getCurrentRenderPassIndex(): number {\r\n        return this._currentRenderPass === null ? -1 : this._currentRenderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\r\n    }\r\n\r\n    private _startMainRenderPass(setClearStates: boolean, clearColor?: Nullable<IColor4Like>, clearDepth?: boolean, clearStencil?: boolean): void {\r\n        if (this._mainRenderPassWrapper.renderPass) {\r\n            this.flushFramebuffer(false);\r\n        }\r\n\r\n        if (this.useReverseDepthBuffer) {\r\n            this.setDepthFunctionToGreaterOrEqual();\r\n        }\r\n\r\n        const mustClearColor = setClearStates && clearColor;\r\n        const mustClearDepth = setClearStates && clearDepth;\r\n        const mustClearStencil = setClearStates && clearStencil;\r\n\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.colorAttachments[0]!.clearValue = mustClearColor ? clearColor : undefined;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.colorAttachments[0]!.loadOp = mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.depthStencilAttachment!.depthClearValue = mustClearDepth\r\n            ? this.useReverseDepthBuffer\r\n                ? this._clearReverseDepthValue\r\n                : this._clearDepthValue\r\n            : undefined;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.depthStencilAttachment!.depthLoadOp = mustClearDepth ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.depthStencilAttachment!.stencilClearValue = mustClearStencil ? this._clearStencilValue : undefined;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.depthStencilAttachment!.stencilLoadOp = !this.isStencilEnable\r\n            ? undefined\r\n            : mustClearStencil\r\n            ? WebGPUConstants.LoadOp.Clear\r\n            : WebGPUConstants.LoadOp.Load;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.occlusionQuerySet = this._occlusionQuery?.hasQueries ? this._occlusionQuery.querySet : undefined;\r\n\r\n        const swapChainTexture = this._context.getCurrentTexture();\r\n        this._mainRenderPassWrapper.colorAttachmentGPUTextures[0]!.set(swapChainTexture);\r\n\r\n        // Resolve in case of MSAA\r\n        if (this._options.antialias) {\r\n            viewDescriptorSwapChainAntialiasing.format = swapChainTexture.format;\r\n            this._mainRenderPassWrapper.renderPassDescriptor!.colorAttachments[0]!.resolveTarget = swapChainTexture.createView(viewDescriptorSwapChainAntialiasing);\r\n        } else {\r\n            viewDescriptorSwapChain.format = swapChainTexture.format;\r\n            this._mainRenderPassWrapper.renderPassDescriptor!.colorAttachments[0]!.view = swapChainTexture.createView(viewDescriptorSwapChain);\r\n        }\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\r\n                    \"frame #\" + (this as any)._count + \" - main begin pass - texture width=\" + (this._mainTextureExtends as any).width,\r\n                    \" height=\" + (this._mainTextureExtends as any).height,\r\n                    this._mainRenderPassWrapper.renderPassDescriptor\r\n                );\r\n            }\r\n        }\r\n\r\n        this._debugPushGroup?.(\"main pass\", 0);\r\n\r\n        this._currentRenderPass = this._renderEncoder.beginRenderPass(this._mainRenderPassWrapper.renderPassDescriptor!);\r\n\r\n        this._mainRenderPassWrapper.renderPass = this._currentRenderPass;\r\n\r\n        this._debugFlushPendingCommands?.();\r\n\r\n        this._resetCurrentViewport(0);\r\n        this._resetCurrentScissor(0);\r\n        this._resetCurrentStencilRef(0);\r\n        this._resetCurrentColorBlend(0);\r\n\r\n        if (!this._isStencilEnable) {\r\n            this._stencilStateComposer.enabled = false;\r\n        }\r\n    }\r\n\r\n    private _endMainRenderPass(): void {\r\n        if (this._mainRenderPassWrapper.renderPass !== null) {\r\n            this._snapshotRendering.endMainRenderPass();\r\n            if (!this.compatibilityMode && !this._snapshotRendering.play) {\r\n                this._bundleList.run(this._mainRenderPassWrapper.renderPass);\r\n                this._bundleList.reset();\r\n            }\r\n            this._mainRenderPassWrapper.renderPass.end();\r\n            if (this.dbgVerboseLogsForFirstFrames) {\r\n                if ((this as any)._count === undefined) {\r\n                    (this as any)._count = 0;\r\n                }\r\n                if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                    console.log(\"frame #\" + (this as any)._count + \" - main end pass\");\r\n                }\r\n            }\r\n            this._debugPopGroup?.(0);\r\n            this._resetCurrentViewport(0);\r\n            this._resetCurrentScissor(0);\r\n            this._resetCurrentStencilRef(0);\r\n            this._resetCurrentColorBlend(0);\r\n            if (this._mainRenderPassWrapper.renderPass === this._currentRenderPass) {\r\n                this._currentRenderPass = null;\r\n            }\r\n            this._mainRenderPassWrapper.reset(false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the frame buffer to the specified texture.\r\n     * @param texture The render target wrapper to render to\r\n     * @param faceIndex The face of the texture to render to in case of cube texture\r\n     * @param requiredWidth The width of the target to render to\r\n     * @param requiredHeight The height of the target to render to\r\n     * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true\r\n     * @param lodLevel defines the lod level to bind to the frame buffer\r\n     * @param layer defines the 2d array index to bind to frame buffer to\r\n     */\r\n    public bindFramebuffer(\r\n        texture: RenderTargetWrapper,\r\n        faceIndex: number = 0,\r\n        requiredWidth?: number,\r\n        requiredHeight?: number,\r\n        forceFullscreenViewport?: boolean,\r\n        lodLevel = 0,\r\n        layer = 0\r\n    ): void {\r\n        const hardwareTexture = texture.texture?._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        if (this._currentRenderTarget) {\r\n            this.unBindFramebuffer(this._currentRenderTarget);\r\n        }\r\n        this._currentRenderTarget = texture;\r\n        if (hardwareTexture) {\r\n            hardwareTexture._currentLayer = texture.isCube ? layer * 6 + faceIndex : layer;\r\n        }\r\n\r\n        this._rttRenderPassWrapper.colorAttachmentGPUTextures[0] = hardwareTexture;\r\n        this._rttRenderPassWrapper.depthTextureFormat = this._currentRenderTarget._depthStencilTexture\r\n            ? WebGPUTextureHelper.GetWebGPUTextureFormat(-1, this._currentRenderTarget._depthStencilTexture.format)\r\n            : undefined;\r\n\r\n        this._setDepthTextureFormat(this._rttRenderPassWrapper);\r\n        this._setColorFormat(this._rttRenderPassWrapper);\r\n\r\n        this._rttRenderPassWrapper.colorAttachmentViewDescriptor = {\r\n            format: this._colorFormat as GPUTextureFormat,\r\n            dimension: WebGPUConstants.TextureViewDimension.E2d,\r\n            mipLevelCount: 1,\r\n            baseArrayLayer: texture.isCube ? layer * 6 + faceIndex : layer,\r\n            baseMipLevel: lodLevel,\r\n            arrayLayerCount: 1,\r\n            aspect: WebGPUConstants.TextureAspect.All,\r\n        };\r\n\r\n        this._rttRenderPassWrapper.depthAttachmentViewDescriptor = {\r\n            format: this._depthTextureFormat!,\r\n            dimension: WebGPUConstants.TextureViewDimension.E2d,\r\n            mipLevelCount: 1,\r\n            baseArrayLayer: texture.isCube ? layer * 6 + faceIndex : layer,\r\n            baseMipLevel: 0,\r\n            arrayLayerCount: 1,\r\n            aspect: WebGPUConstants.TextureAspect.All,\r\n        };\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\r\n                    \"frame #\" + (this as any)._count + \" - bindFramebuffer called - internalTexture.uniqueId=\",\r\n                    texture.texture?.uniqueId,\r\n                    \"face=\",\r\n                    faceIndex,\r\n                    \"lodLevel=\",\r\n                    lodLevel,\r\n                    \"layer=\",\r\n                    layer,\r\n                    this._rttRenderPassWrapper.colorAttachmentViewDescriptor,\r\n                    this._rttRenderPassWrapper.depthAttachmentViewDescriptor\r\n                );\r\n            }\r\n        }\r\n\r\n        this._currentRenderPass = null; // lazy creation of the render pass, hoping the render pass will be created by a call to clear()...\r\n\r\n        if (this.snapshotRendering && this.snapshotRenderingMode === Constants.SNAPSHOTRENDERING_FAST) {\r\n            // force the creation of the render pass as we know in fast snapshot rendering mode clear() won't be called\r\n            this._getCurrentRenderPass();\r\n        }\r\n\r\n        if (this._cachedViewport && !forceFullscreenViewport) {\r\n            this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);\r\n        } else {\r\n            if (!requiredWidth) {\r\n                requiredWidth = texture.width;\r\n                if (lodLevel) {\r\n                    requiredWidth = requiredWidth / Math.pow(2, lodLevel);\r\n                }\r\n            }\r\n            if (!requiredHeight) {\r\n                requiredHeight = texture.height;\r\n                if (lodLevel) {\r\n                    requiredHeight = requiredHeight / Math.pow(2, lodLevel);\r\n                }\r\n            }\r\n\r\n            this._viewport(0, 0, requiredWidth, requiredHeight);\r\n        }\r\n\r\n        this.wipeCaches();\r\n    }\r\n\r\n    /**\r\n     * Unbind the current render target texture from the WebGPU context\r\n     * @param texture defines the render target wrapper to unbind\r\n     * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\r\n     * @param onBeforeUnbind defines a function which will be called before the effective unbind\r\n     */\r\n    public unBindFramebuffer(texture: RenderTargetWrapper, disableGenerateMipMaps = false, onBeforeUnbind?: () => void): void {\r\n        const saveCRT = this._currentRenderTarget;\r\n\r\n        this._currentRenderTarget = null; // to be iso with thinEngine, this._currentRenderTarget must be null when onBeforeUnbind is called\r\n\r\n        if (onBeforeUnbind) {\r\n            onBeforeUnbind();\r\n        }\r\n\r\n        this._currentRenderTarget = saveCRT;\r\n\r\n        if (this._currentRenderPass && this._currentRenderPass !== this._mainRenderPassWrapper.renderPass) {\r\n            this._endRenderTargetRenderPass();\r\n        }\r\n\r\n        if (texture.texture?.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\r\n            this._generateMipmaps(texture.texture);\r\n        }\r\n\r\n        this._currentRenderTarget = null;\r\n\r\n        this._onAfterUnbindFrameBufferObservable.notifyObservers(this);\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\"frame #\" + (this as any)._count + \" - unBindFramebuffer called - internalTexture.uniqueId=\", texture.texture?.uniqueId);\r\n            }\r\n        }\r\n\r\n        this._mrtAttachments = [];\r\n        this._cacheRenderPipeline.setMRT([]);\r\n        this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\r\n        this._currentRenderPass = this._mainRenderPassWrapper.renderPass;\r\n        this._setDepthTextureFormat(this._mainRenderPassWrapper);\r\n        this._setColorFormat(this._mainRenderPassWrapper);\r\n    }\r\n\r\n    /**\r\n     * Unbind the current render target and bind the default framebuffer\r\n     */\r\n    public restoreDefaultFramebuffer(): void {\r\n        if (this._currentRenderTarget) {\r\n            this.unBindFramebuffer(this._currentRenderTarget);\r\n        } else {\r\n            this._currentRenderPass = this._mainRenderPassWrapper.renderPass;\r\n            this._setDepthTextureFormat(this._mainRenderPassWrapper);\r\n            this._setColorFormat(this._mainRenderPassWrapper);\r\n        }\r\n        if (this._currentRenderPass) {\r\n            if (this._cachedViewport) {\r\n                this.setViewport(this._cachedViewport);\r\n            }\r\n        }\r\n\r\n        this.wipeCaches();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Render\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setColorFormat(wrapper: WebGPURenderPassWrapper): void {\r\n        const format = wrapper.colorAttachmentGPUTextures[0]?.format ?? null;\r\n        this._cacheRenderPipeline.setColorFormat(format);\r\n        if (this._colorFormat === format) {\r\n            return;\r\n        }\r\n        this._colorFormat = format;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setDepthTextureFormat(wrapper: WebGPURenderPassWrapper): void {\r\n        this._cacheRenderPipeline.setDepthStencilFormat(wrapper.depthTextureFormat);\r\n        if (this._depthTextureFormat === wrapper.depthTextureFormat) {\r\n            return;\r\n        }\r\n        this._depthTextureFormat = wrapper.depthTextureFormat;\r\n    }\r\n\r\n    public setDitheringState(): void {\r\n        // Does not exist in WebGPU\r\n    }\r\n\r\n    public setRasterizerState(): void {\r\n        // Does not exist in WebGPU\r\n    }\r\n\r\n    /**\r\n     * Set various states to the webGL context\r\n     * @param culling defines culling state: true to enable culling, false to disable it\r\n     * @param zOffset defines the value to apply to zOffset (0 by default)\r\n     * @param force defines if states must be applied even if cache is up to date\r\n     * @param reverseSide defines if culling must be reversed (CCW if false, CW if true)\r\n     * @param cullBackFaces true to cull back faces, false to cull front faces (if culling is enabled)\r\n     * @param stencil stencil states to set\r\n     * @param zOffsetUnits defines the value to apply to zOffsetUnits (0 by default)\r\n     */\r\n    public setState(culling: boolean, zOffset: number = 0, force?: boolean, reverseSide = false, cullBackFaces?: boolean, stencil?: IStencilState, zOffsetUnits: number = 0): void {\r\n        // Culling\r\n        if (this._depthCullingState.cull !== culling || force) {\r\n            this._depthCullingState.cull = culling;\r\n        }\r\n\r\n        // Cull face\r\n        const cullFace = this.cullBackFaces ?? cullBackFaces ?? true ? 1 : 2;\r\n        if (this._depthCullingState.cullFace !== cullFace || force) {\r\n            this._depthCullingState.cullFace = cullFace;\r\n        }\r\n\r\n        // Z offset\r\n        this.setZOffset(zOffset);\r\n        this.setZOffsetUnits(zOffsetUnits);\r\n\r\n        // Front face\r\n        const frontFace = reverseSide ? (this._currentRenderTarget ? 1 : 2) : this._currentRenderTarget ? 2 : 1;\r\n        if (this._depthCullingState.frontFace !== frontFace || force) {\r\n            this._depthCullingState.frontFace = frontFace;\r\n        }\r\n\r\n        this._stencilStateComposer.stencilMaterial = stencil;\r\n    }\r\n\r\n    private _applyRenderPassChanges(renderPass: GPURenderPassEncoder, bundleList: Nullable<WebGPUBundleList>): void {\r\n        const mustUpdateViewport = this._mustUpdateViewport(renderPass);\r\n        const mustUpdateScissor = this._mustUpdateScissor(renderPass);\r\n        const mustUpdateStencilRef = !this._stencilStateComposer.enabled ? false : this._mustUpdateStencilRef(renderPass);\r\n        const mustUpdateBlendColor = !this._alphaState.alphaBlend ? false : this._mustUpdateBlendColor(renderPass);\r\n\r\n        if (bundleList) {\r\n            if (mustUpdateViewport) {\r\n                bundleList.addItem(new WebGPURenderItemViewport(this._viewportCached.x, this._viewportCached.y, this._viewportCached.z, this._viewportCached.w));\r\n            }\r\n            if (mustUpdateScissor) {\r\n                bundleList.addItem(new WebGPURenderItemScissor(this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w));\r\n            }\r\n            if (mustUpdateStencilRef) {\r\n                bundleList.addItem(new WebGPURenderItemStencilRef(this._stencilStateComposer.funcRef ?? 0));\r\n            }\r\n            if (mustUpdateBlendColor) {\r\n                bundleList.addItem(new WebGPURenderItemBlendColor(this._alphaState._blendConstants.slice()));\r\n            }\r\n        } else {\r\n            if (mustUpdateViewport) {\r\n                this._applyViewport(renderPass as GPURenderPassEncoder);\r\n            }\r\n            if (mustUpdateScissor) {\r\n                this._applyScissor(renderPass as GPURenderPassEncoder);\r\n            }\r\n            if (mustUpdateStencilRef) {\r\n                this._applyStencilRef(renderPass as GPURenderPassEncoder);\r\n            }\r\n            if (mustUpdateBlendColor) {\r\n                this._applyBlendColor(renderPass as GPURenderPassEncoder);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _draw(drawType: number, fillMode: number, start: number, count: number, instancesCount: number): void {\r\n        const renderPass = this._getCurrentRenderPass();\r\n        const renderPassIndex = this._getCurrentRenderPassIndex();\r\n        const bundleList = renderPassIndex === 0 ? this._bundleList : this._bundleListRenderTarget;\r\n\r\n        this.applyStates();\r\n\r\n        const webgpuPipelineContext = this._currentEffect!._pipelineContext as WebGPUPipelineContext;\r\n\r\n        this.bindUniformBufferBase(this._currentRenderTarget ? this._ubInvertY : this._ubDontInvertY, 0, WebGPUShaderProcessor.InternalsUBOName);\r\n\r\n        if (webgpuPipelineContext.uniformBuffer) {\r\n            webgpuPipelineContext.uniformBuffer.update();\r\n            this.bindUniformBufferBase(webgpuPipelineContext.uniformBuffer.getBuffer()!, 0, WebGPUShaderProcessor.LeftOvertUBOName);\r\n        }\r\n\r\n        if (this._snapshotRendering.play) {\r\n            this._reportDrawCall();\r\n            return;\r\n        }\r\n\r\n        if (\r\n            !this.compatibilityMode &&\r\n            (this._currentDrawContext.isDirty(this._currentMaterialContext.updateId) || this._currentMaterialContext.isDirty || this._currentMaterialContext.forceBindGroupCreation)\r\n        ) {\r\n            this._currentDrawContext.fastBundle = undefined;\r\n        }\r\n\r\n        const useFastPath = !this.compatibilityMode && this._currentDrawContext.fastBundle;\r\n        let renderPass2: GPURenderPassEncoder | GPURenderBundleEncoder = renderPass;\r\n\r\n        if (useFastPath || this._snapshotRendering.record) {\r\n            this._applyRenderPassChanges(renderPass, bundleList);\r\n            if (!this._snapshotRendering.record) {\r\n                this._counters.numBundleReuseNonCompatMode++;\r\n                if (this._currentDrawContext.indirectDrawBuffer) {\r\n                    this._currentDrawContext.setIndirectData(count, instancesCount || 1, start);\r\n                }\r\n                bundleList.addBundle(this._currentDrawContext.fastBundle);\r\n                this._reportDrawCall();\r\n                return;\r\n            }\r\n\r\n            renderPass2 = bundleList.getBundleEncoder(this._cacheRenderPipeline.colorFormats, this._depthTextureFormat, this.currentSampleCount); // for snapshot recording mode\r\n            bundleList.numDrawCalls++;\r\n        }\r\n\r\n        let textureState = 0;\r\n        if (!this._caps.textureFloatLinearFiltering && this._currentMaterialContext.hasFloatTextures) {\r\n            let bitVal = 1;\r\n            for (let i = 0; i < webgpuPipelineContext.shaderProcessingContext.textureNames.length; ++i) {\r\n                const textureName = webgpuPipelineContext.shaderProcessingContext.textureNames[i];\r\n                const texture = this._currentMaterialContext.textures[textureName]?.texture;\r\n                if (texture?.type === Constants.TEXTURETYPE_FLOAT) {\r\n                    textureState |= bitVal;\r\n                }\r\n                bitVal = bitVal << 1;\r\n            }\r\n        }\r\n\r\n        this._currentMaterialContext.textureState = textureState;\r\n\r\n        const pipeline = this._cacheRenderPipeline.getRenderPipeline(fillMode, this._currentEffect!, this.currentSampleCount, textureState);\r\n        const bindGroups = this._cacheBindGroups.getBindGroups(webgpuPipelineContext, this._currentDrawContext, this._currentMaterialContext);\r\n\r\n        if (!this._snapshotRendering.record) {\r\n            this._applyRenderPassChanges(renderPass, !this.compatibilityMode ? bundleList : null);\r\n            if (!this.compatibilityMode) {\r\n                this._counters.numBundleCreationNonCompatMode++;\r\n                renderPass2 = this._device.createRenderBundleEncoder({\r\n                    colorFormats: this._cacheRenderPipeline.colorFormats,\r\n                    depthStencilFormat: this._depthTextureFormat,\r\n                    sampleCount: this.currentSampleCount,\r\n                });\r\n            }\r\n        }\r\n\r\n        // bind pipeline\r\n        renderPass2.setPipeline(pipeline);\r\n\r\n        // bind index/vertex buffers\r\n        if (this._currentIndexBuffer) {\r\n            renderPass2.setIndexBuffer(\r\n                this._currentIndexBuffer.underlyingResource,\r\n                this._currentIndexBuffer!.is32Bits ? WebGPUConstants.IndexFormat.Uint32 : WebGPUConstants.IndexFormat.Uint16,\r\n                0\r\n            );\r\n        }\r\n\r\n        const vertexBuffers = this._cacheRenderPipeline.vertexBuffers;\r\n        for (let index = 0; index < vertexBuffers.length; index++) {\r\n            const vertexBuffer = vertexBuffers[index];\r\n\r\n            const buffer = vertexBuffer.effectiveBuffer;\r\n            if (buffer) {\r\n                renderPass2.setVertexBuffer(index, buffer.underlyingResource, vertexBuffer._validOffsetRange ? 0 : vertexBuffer.byteOffset);\r\n            }\r\n        }\r\n\r\n        // bind bind groups\r\n        for (let i = 0; i < bindGroups.length; i++) {\r\n            renderPass2.setBindGroup(i, bindGroups[i]);\r\n        }\r\n\r\n        // draw\r\n        const nonCompatMode = !this.compatibilityMode && !this._snapshotRendering.record;\r\n\r\n        if (nonCompatMode && this._currentDrawContext.indirectDrawBuffer) {\r\n            this._currentDrawContext.setIndirectData(count, instancesCount || 1, start);\r\n            if (drawType === 0) {\r\n                renderPass2.drawIndexedIndirect(this._currentDrawContext.indirectDrawBuffer, 0);\r\n            } else {\r\n                renderPass2.drawIndirect(this._currentDrawContext.indirectDrawBuffer, 0);\r\n            }\r\n        } else if (drawType === 0) {\r\n            renderPass2.drawIndexed(count, instancesCount || 1, start, 0, 0);\r\n        } else {\r\n            renderPass2.draw(count, instancesCount || 1, start, 0);\r\n        }\r\n\r\n        if (nonCompatMode) {\r\n            this._currentDrawContext.fastBundle = (renderPass2 as GPURenderBundleEncoder).finish();\r\n            bundleList.addBundle(this._currentDrawContext.fastBundle);\r\n        }\r\n\r\n        this._reportDrawCall();\r\n    }\r\n\r\n    /**\r\n     * Draw a list of indexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param indexStart defines the starting index\r\n     * @param indexCount defines the number of index to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public drawElementsType(fillMode: number, indexStart: number, indexCount: number, instancesCount: number = 1): void {\r\n        this._draw(0, fillMode, indexStart, indexCount, instancesCount);\r\n    }\r\n\r\n    /**\r\n     * Draw a list of unindexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param verticesStart defines the index of first vertex to draw\r\n     * @param verticesCount defines the count of vertices to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public drawArraysType(fillMode: number, verticesStart: number, verticesCount: number, instancesCount: number = 1): void {\r\n        this._currentIndexBuffer = null;\r\n        this._draw(1, fillMode, verticesStart, verticesCount, instancesCount);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Dispose\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Dispose and release all associated resources\r\n     */\r\n    public dispose(): void {\r\n        this._isDisposed = true;\r\n        this._mainTexture?.destroy();\r\n        this._depthTexture?.destroy();\r\n        this._device.destroy();\r\n        super.dispose();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Misc\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Gets the current render width\r\n     * @param useScreen defines if screen size must be used (or the current render target if any)\r\n     * @returns a number defining the current render width\r\n     */\r\n    public getRenderWidth(useScreen = false): number {\r\n        if (!useScreen && this._currentRenderTarget) {\r\n            return this._currentRenderTarget.width;\r\n        }\r\n\r\n        return this._renderingCanvas?.width ?? 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current render height\r\n     * @param useScreen defines if screen size must be used (or the current render target if any)\r\n     * @returns a number defining the current render height\r\n     */\r\n    public getRenderHeight(useScreen = false): number {\r\n        if (!useScreen && this._currentRenderTarget) {\r\n            return this._currentRenderTarget.height;\r\n        }\r\n\r\n        return this._renderingCanvas?.height ?? 0;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Errors\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Get the current error code of the WebGPU context\r\n     * @returns the error code\r\n     */\r\n    public getError(): number {\r\n        // TODO WEBGPU. from the webgpu errors.\r\n        return 0;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Unused WebGPU\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public bindSamplers(): void {}\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bindTextureDirectly(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if all created effects are ready\r\n     * @returns always true - No parallel shader compilation\r\n     */\r\n    public areAllEffectsReady(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _executeWhenRenderingStateIsCompiled(pipelineContext: IPipelineContext, action: () => void) {\r\n        // No parallel shader compilation.\r\n        // No Async, so direct launch\r\n        action();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _isRenderingStateCompiled(): boolean {\r\n        // No parallel shader compilation.\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _getUnpackAlignement(): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _unpackFlipY() {}\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bindUnboundFramebuffer() {\r\n        throw \"_bindUnboundFramebuffer is not implementedin WebGPU! You probably want to use restoreDefaultFramebuffer or unBindFramebuffer instead\";\r\n    }\r\n\r\n    // TODO WEBGPU. All of the below should go once engine split with baseEngine.\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getSamplingParameters(): { min: number; mag: number } {\r\n        throw \"_getSamplingParameters is not available in WebGPU\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public getUniforms(): Nullable<WebGLUniformLocation>[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setIntArray(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setIntArray2(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setIntArray3(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setIntArray4(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setArray(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setArray2(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setArray3(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setArray4(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setMatrices(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setMatrix3x3(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setMatrix2x2(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setFloat(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setFloat2(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setFloat3(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setFloat4(): boolean {\r\n        return false;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}