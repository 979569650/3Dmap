{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { serialize, serializeAsVector3, serializeAsMeshReference } from \"../Misc/decorators.js\";\nimport { Camera } from \"./camera.js\";\nimport { Quaternion, Matrix, Vector3, Vector2, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\nimport { Axis } from \"../Maths/math.axis.js\";\n/**\n * A target camera takes a mesh or position as a target and continues to look at it while it moves.\n * This is the base of the follow, arc rotate cameras and Free camera\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\n */\nexport class TargetCamera extends Camera {\n  /**\n   * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.\n   * This is the base of the follow, arc rotate cameras and Free camera\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\n   * @param name Defines the name of the camera in the scene\n   * @param position Defines the start position of the camera in the scene\n   * @param scene Defines the scene the camera belongs to\n   * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\n   */\n  constructor(name, position, scene, setActiveOnSceneIfNoneActive = true) {\n    super(name, position, scene, setActiveOnSceneIfNoneActive);\n    this._tmpUpVector = Vector3.Zero();\n    this._tmpTargetVector = Vector3.Zero();\n    /**\n     * Define the current direction the camera is moving to\n     */\n    this.cameraDirection = new Vector3(0, 0, 0);\n    /**\n     * Define the current rotation the camera is rotating to\n     */\n    this.cameraRotation = new Vector2(0, 0);\n    /** Gets or sets a boolean indicating that the scaling of the parent hierarchy will not be taken in account by the camera */\n    this.ignoreParentScaling = false;\n    /**\n     * When set, the up vector of the camera will be updated by the rotation of the camera\n     */\n    this.updateUpVectorFromRotation = false;\n    this._tmpQuaternion = new Quaternion();\n    /**\n     * Define the current rotation of the camera\n     */\n    this.rotation = new Vector3(0, 0, 0);\n    /**\n     * Define the current speed of the camera\n     */\n    this.speed = 2.0;\n    /**\n     * Add constraint to the camera to prevent it to move freely in all directions and\n     * around all axis.\n     */\n    this.noRotationConstraint = false;\n    /**\n     * Reverses mouselook direction to 'natural' panning as opposed to traditional direct\n     * panning\n     */\n    this.invertRotation = false;\n    /**\n     * Speed multiplier for inverse camera panning\n     */\n    this.inverseRotationSpeed = 0.2;\n    /**\n     * Define the current target of the camera as an object or a position.\n     * Please note that locking a target will disable panning.\n     */\n    this.lockedTarget = null;\n    /** @internal */\n    this._currentTarget = Vector3.Zero();\n    /** @internal */\n    this._initialFocalDistance = 1;\n    /** @internal */\n    this._viewMatrix = Matrix.Zero();\n    /** @internal */\n    this._camMatrix = Matrix.Zero();\n    /** @internal */\n    this._cameraTransformMatrix = Matrix.Zero();\n    /** @internal */\n    this._cameraRotationMatrix = Matrix.Zero();\n    /** @internal */\n    this._referencePoint = new Vector3(0, 0, 1);\n    /** @internal */\n    this._transformedReferencePoint = Vector3.Zero();\n    this._deferredPositionUpdate = new Vector3();\n    this._deferredRotationQuaternionUpdate = new Quaternion();\n    this._deferredRotationUpdate = new Vector3();\n    this._deferredUpdated = false;\n    this._deferOnly = false;\n    this._defaultUp = Vector3.Up();\n    this._cachedRotationZ = 0;\n    this._cachedQuaternionRotationZ = 0;\n  }\n  /**\n   * Gets the position in front of the camera at a given distance.\n   * @param distance The distance from the camera we want the position to be\n   * @returns the position\n   */\n  getFrontPosition(distance) {\n    this.getWorldMatrix();\n    const direction = this.getTarget().subtract(this.position);\n    direction.normalize();\n    direction.scaleInPlace(distance);\n    return this.globalPosition.add(direction);\n  }\n  /** @internal */\n  _getLockedTargetPosition() {\n    if (!this.lockedTarget) {\n      return null;\n    }\n    if (this.lockedTarget.absolutePosition) {\n      const lockedTarget = this.lockedTarget;\n      const m = lockedTarget.computeWorldMatrix();\n      // in some cases the absolute position resets externally, but doesn't update since the matrix is cached.\n      m.getTranslationToRef(lockedTarget.absolutePosition);\n    }\n    return this.lockedTarget.absolutePosition || this.lockedTarget;\n  }\n  /**\n   * Store current camera state of the camera (fov, position, rotation, etc..)\n   * @returns the camera\n   */\n  storeState() {\n    this._storedPosition = this.position.clone();\n    this._storedRotation = this.rotation.clone();\n    if (this.rotationQuaternion) {\n      this._storedRotationQuaternion = this.rotationQuaternion.clone();\n    }\n    return super.storeState();\n  }\n  /**\n   * Restored camera state. You must call storeState() first\n   * @returns whether it was successful or not\n   * @internal\n   */\n  _restoreStateValues() {\n    if (!super._restoreStateValues()) {\n      return false;\n    }\n    this.position = this._storedPosition.clone();\n    this.rotation = this._storedRotation.clone();\n    if (this.rotationQuaternion) {\n      this.rotationQuaternion = this._storedRotationQuaternion.clone();\n    }\n    this.cameraDirection.copyFromFloats(0, 0, 0);\n    this.cameraRotation.copyFromFloats(0, 0);\n    return true;\n  }\n  /** @internal */\n  _initCache() {\n    super._initCache();\n    this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n  }\n  /**\n   * @internal\n   */\n  _updateCache(ignoreParentClass) {\n    if (!ignoreParentClass) {\n      super._updateCache();\n    }\n    const lockedTargetPosition = this._getLockedTargetPosition();\n    if (!lockedTargetPosition) {\n      this._cache.lockedTarget = null;\n    } else {\n      if (!this._cache.lockedTarget) {\n        this._cache.lockedTarget = lockedTargetPosition.clone();\n      } else {\n        this._cache.lockedTarget.copyFrom(lockedTargetPosition);\n      }\n    }\n    this._cache.rotation.copyFrom(this.rotation);\n    if (this.rotationQuaternion) {\n      this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\n    }\n  }\n  // Synchronized\n  /** @internal */\n  _isSynchronizedViewMatrix() {\n    if (!super._isSynchronizedViewMatrix()) {\n      return false;\n    }\n    const lockedTargetPosition = this._getLockedTargetPosition();\n    return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) && (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation));\n  }\n  // Methods\n  /** @internal */\n  _computeLocalCameraSpeed() {\n    const engine = this.getEngine();\n    return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100.0));\n  }\n  // Target\n  /**\n   * Defines the target the camera should look at.\n   * @param target Defines the new target as a Vector\n   */\n  setTarget(target) {\n    this.upVector.normalize();\n    this._initialFocalDistance = target.subtract(this.position).length();\n    if (this.position.z === target.z) {\n      this.position.z += Epsilon;\n    }\n    this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);\n    Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);\n    this._camMatrix.invert();\n    this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);\n    const vDir = target.subtract(this.position);\n    if (vDir.x >= 0.0) {\n      this.rotation.y = -Math.atan(vDir.z / vDir.x) + Math.PI / 2.0;\n    } else {\n      this.rotation.y = -Math.atan(vDir.z / vDir.x) - Math.PI / 2.0;\n    }\n    this.rotation.z = 0;\n    if (isNaN(this.rotation.x)) {\n      this.rotation.x = 0;\n    }\n    if (isNaN(this.rotation.y)) {\n      this.rotation.y = 0;\n    }\n    if (isNaN(this.rotation.z)) {\n      this.rotation.z = 0;\n    }\n    if (this.rotationQuaternion) {\n      Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\n    }\n  }\n  /**\n   * Defines the target point of the camera.\n   * The camera looks towards it form the radius distance.\n   */\n  get target() {\n    return this.getTarget();\n  }\n  set target(value) {\n    this.setTarget(value);\n  }\n  /**\n   * Return the current target position of the camera. This value is expressed in local space.\n   * @returns the target position\n   */\n  getTarget() {\n    return this._currentTarget;\n  }\n  /** @internal */\n  _decideIfNeedsToMove() {\n    return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\n  }\n  /** @internal */\n  _updatePosition() {\n    if (this.parent) {\n      this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\n      Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\n      this._deferredPositionUpdate.addInPlace(TmpVectors.Vector3[0]);\n      if (!this._deferOnly) {\n        this.position.copyFrom(this._deferredPositionUpdate);\n      } else {\n        this._deferredUpdated = true;\n      }\n      return;\n    }\n    this._deferredPositionUpdate.addInPlace(this.cameraDirection);\n    if (!this._deferOnly) {\n      this.position.copyFrom(this._deferredPositionUpdate);\n    } else {\n      this._deferredUpdated = true;\n    }\n  }\n  /** @internal */\n  _checkInputs() {\n    const directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1.0;\n    const needToMove = this._decideIfNeedsToMove();\n    const needToRotate = this.cameraRotation.x || this.cameraRotation.y;\n    this._deferredUpdated = false;\n    this._deferredRotationUpdate.copyFrom(this.rotation);\n    this._deferredPositionUpdate.copyFrom(this.position);\n    if (this.rotationQuaternion) {\n      this._deferredRotationQuaternionUpdate.copyFrom(this.rotationQuaternion);\n    }\n    // Move\n    if (needToMove) {\n      this._updatePosition();\n    }\n    // Rotate\n    if (needToRotate) {\n      //rotate, if quaternion is set and rotation was used\n      if (this.rotationQuaternion) {\n        this.rotationQuaternion.toEulerAnglesToRef(this._deferredRotationUpdate);\n      }\n      this._deferredRotationUpdate.x += this.cameraRotation.x * directionMultiplier;\n      this._deferredRotationUpdate.y += this.cameraRotation.y * directionMultiplier;\n      // Apply constraints\n      if (!this.noRotationConstraint) {\n        const limit = 1.570796;\n        if (this._deferredRotationUpdate.x > limit) {\n          this._deferredRotationUpdate.x = limit;\n        }\n        if (this._deferredRotationUpdate.x < -limit) {\n          this._deferredRotationUpdate.x = -limit;\n        }\n      }\n      if (!this._deferOnly) {\n        this.rotation.copyFrom(this._deferredRotationUpdate);\n      } else {\n        this._deferredUpdated = true;\n      }\n      //rotate, if quaternion is set and rotation was used\n      if (this.rotationQuaternion) {\n        const len = this._deferredRotationUpdate.lengthSquared();\n        if (len) {\n          Quaternion.RotationYawPitchRollToRef(this._deferredRotationUpdate.y, this._deferredRotationUpdate.x, this._deferredRotationUpdate.z, this._deferredRotationQuaternionUpdate);\n          if (!this._deferOnly) {\n            this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate);\n          } else {\n            this._deferredUpdated = true;\n          }\n        }\n      }\n    }\n    // Inertia\n    if (needToMove) {\n      if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {\n        this.cameraDirection.x = 0;\n      }\n      if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {\n        this.cameraDirection.y = 0;\n      }\n      if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {\n        this.cameraDirection.z = 0;\n      }\n      this.cameraDirection.scaleInPlace(this.inertia);\n    }\n    if (needToRotate) {\n      if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {\n        this.cameraRotation.x = 0;\n      }\n      if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {\n        this.cameraRotation.y = 0;\n      }\n      this.cameraRotation.scaleInPlace(this.inertia);\n    }\n    super._checkInputs();\n  }\n  _updateCameraRotationMatrix() {\n    if (this.rotationQuaternion) {\n      this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);\n    } else {\n      Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);\n    }\n  }\n  /**\n   * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)\n   * @returns the current camera\n   */\n  _rotateUpVectorWithCameraRotationMatrix() {\n    Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);\n    return this;\n  }\n  /** @internal */\n  _getViewMatrix() {\n    if (this.lockedTarget) {\n      this.setTarget(this._getLockedTargetPosition());\n    }\n    // Compute\n    this._updateCameraRotationMatrix();\n    // Apply the changed rotation to the upVector\n    if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {\n      this._rotateUpVectorWithCameraRotationMatrix();\n      this._cachedQuaternionRotationZ = this.rotationQuaternion.z;\n    } else if (this._cachedRotationZ !== this.rotation.z) {\n      this._rotateUpVectorWithCameraRotationMatrix();\n      this._cachedRotationZ = this.rotation.z;\n    }\n    Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\n    // Computing target and final matrix\n    this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\n    if (this.updateUpVectorFromRotation) {\n      if (this.rotationQuaternion) {\n        Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);\n      } else {\n        Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);\n        Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);\n      }\n    }\n    this._computeViewMatrix(this.position, this._currentTarget, this.upVector);\n    return this._viewMatrix;\n  }\n  _computeViewMatrix(position, target, up) {\n    if (this.ignoreParentScaling) {\n      if (this.parent) {\n        const parentWorldMatrix = this.parent.getWorldMatrix();\n        Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);\n        Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);\n        Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);\n        this._markSyncedWithParent();\n      } else {\n        this._globalPosition.copyFrom(position);\n        this._tmpTargetVector.copyFrom(target);\n        this._tmpUpVector.copyFrom(up);\n      }\n      if (this.getScene().useRightHandedSystem) {\n        Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\n      } else {\n        Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\n      }\n      return;\n    }\n    if (this.getScene().useRightHandedSystem) {\n      Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);\n    } else {\n      Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);\n    }\n    if (this.parent) {\n      const parentWorldMatrix = this.parent.getWorldMatrix();\n      this._viewMatrix.invert();\n      this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);\n      this._viewMatrix.getTranslationToRef(this._globalPosition);\n      this._viewMatrix.invert();\n      this._markSyncedWithParent();\n    } else {\n      this._globalPosition.copyFrom(position);\n    }\n  }\n  /**\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  createRigCamera(name, cameraIndex) {\n    if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\n      const rigCamera = new TargetCamera(name, this.position.clone(), this.getScene());\n      rigCamera.isRigCamera = true;\n      rigCamera.rigParent = this;\n      if (this.cameraRigMode === Camera.RIG_MODE_VR) {\n        if (!this.rotationQuaternion) {\n          this.rotationQuaternion = new Quaternion();\n        }\n        rigCamera._cameraRigParams = {};\n        rigCamera.rotationQuaternion = new Quaternion();\n      }\n      rigCamera.mode = this.mode;\n      rigCamera.orthoLeft = this.orthoLeft;\n      rigCamera.orthoRight = this.orthoRight;\n      rigCamera.orthoTop = this.orthoTop;\n      rigCamera.orthoBottom = this.orthoBottom;\n      return rigCamera;\n    }\n    return null;\n  }\n  /**\n   * @internal\n   */\n  _updateRigCameras() {\n    const camLeft = this._rigCameras[0];\n    const camRight = this._rigCameras[1];\n    this.computeWorldMatrix();\n    switch (this.cameraRigMode) {\n      case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\n      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\n      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\n      case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\n      case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:\n        {\n          //provisionnaly using _cameraRigParams.stereoHalfAngle instead of calculations based on _cameraRigParams.interaxialDistance:\n          const leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;\n          const rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;\n          this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);\n          this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);\n          break;\n        }\n      case Camera.RIG_MODE_VR:\n        if (camLeft.rotationQuaternion) {\n          camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);\n          camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);\n        } else {\n          camLeft.rotation.copyFrom(this.rotation);\n          camRight.rotation.copyFrom(this.rotation);\n        }\n        camLeft.position.copyFrom(this.position);\n        camRight.position.copyFrom(this.position);\n        break;\n    }\n    super._updateRigCameras();\n  }\n  _getRigCamPositionAndTarget(halfSpace, rigCamera) {\n    const target = this.getTarget();\n    target.subtractToRef(this.position, TargetCamera._TargetFocalPoint);\n    TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);\n    const newFocalTarget = TargetCamera._TargetFocalPoint.addInPlace(this.position);\n    Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera._TargetTransformMatrix);\n    TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera._RigCamTransformMatrix);\n    Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera._TargetTransformMatrix);\n    TargetCamera._RigCamTransformMatrix.multiplyToRef(TargetCamera._TargetTransformMatrix, TargetCamera._RigCamTransformMatrix);\n    Vector3.TransformCoordinatesToRef(this.position, TargetCamera._RigCamTransformMatrix, rigCamera.position);\n    rigCamera.setTarget(newFocalTarget);\n  }\n  /**\n   * Gets the current object class name.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"TargetCamera\";\n  }\n}\nTargetCamera._RigCamTransformMatrix = new Matrix();\nTargetCamera._TargetTransformMatrix = new Matrix();\nTargetCamera._TargetFocalPoint = new Vector3();\n__decorate([serializeAsVector3()], TargetCamera.prototype, \"rotation\", void 0);\n__decorate([serialize()], TargetCamera.prototype, \"speed\", void 0);\n__decorate([serializeAsMeshReference(\"lockedTargetId\")], TargetCamera.prototype, \"lockedTarget\", void 0);","map":{"version":3,"names":["serialize","serializeAsVector3","serializeAsMeshReference","Camera","Quaternion","Matrix","Vector3","Vector2","TmpVectors","Epsilon","Axis","TargetCamera","constructor","name","position","scene","setActiveOnSceneIfNoneActive","_tmpUpVector","Zero","_tmpTargetVector","cameraDirection","cameraRotation","ignoreParentScaling","updateUpVectorFromRotation","_tmpQuaternion","rotation","speed","noRotationConstraint","invertRotation","inverseRotationSpeed","lockedTarget","_currentTarget","_initialFocalDistance","_viewMatrix","_camMatrix","_cameraTransformMatrix","_cameraRotationMatrix","_referencePoint","_transformedReferencePoint","_deferredPositionUpdate","_deferredRotationQuaternionUpdate","_deferredRotationUpdate","_deferredUpdated","_deferOnly","_defaultUp","Up","_cachedRotationZ","_cachedQuaternionRotationZ","getFrontPosition","distance","getWorldMatrix","direction","getTarget","subtract","normalize","scaleInPlace","globalPosition","add","_getLockedTargetPosition","absolutePosition","m","computeWorldMatrix","getTranslationToRef","storeState","_storedPosition","clone","_storedRotation","rotationQuaternion","_storedRotationQuaternion","_restoreStateValues","copyFromFloats","_initCache","_cache","Number","MAX_VALUE","_updateCache","ignoreParentClass","lockedTargetPosition","copyFrom","_isSynchronizedViewMatrix","equals","_computeLocalCameraSpeed","engine","getEngine","Math","sqrt","getDeltaTime","getFps","setTarget","target","upVector","length","z","LookAtLHToRef","invert","x","atan","vDir","y","PI","isNaN","RotationYawPitchRollToRef","value","_decideIfNeedsToMove","abs","_updatePosition","parent","invertToRef","TransformNormalToRef","addInPlace","_checkInputs","directionMultiplier","needToMove","needToRotate","toEulerAnglesToRef","limit","len","lengthSquared","inertia","_updateCameraRotationMatrix","toRotationMatrix","_rotateUpVectorWithCameraRotationMatrix","_getViewMatrix","TransformCoordinatesToRef","addToRef","Y","rotateByQuaternionToRef","FromEulerVectorToRef","_computeViewMatrix","up","parentWorldMatrix","_globalPosition","_markSyncedWithParent","getScene","useRightHandedSystem","LookAtRHToRef","multiplyToRef","createRigCamera","cameraIndex","cameraRigMode","RIG_MODE_NONE","rigCamera","isRigCamera","rigParent","RIG_MODE_VR","_cameraRigParams","mode","orthoLeft","orthoRight","orthoTop","orthoBottom","_updateRigCameras","camLeft","_rigCameras","camRight","RIG_MODE_STEREOSCOPIC_ANAGLYPH","RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL","RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED","RIG_MODE_STEREOSCOPIC_OVERUNDER","RIG_MODE_STEREOSCOPIC_INTERLACED","leftSign","rightSign","_getRigCamPositionAndTarget","stereoHalfAngle","halfSpace","subtractToRef","_TargetFocalPoint","newFocalTarget","TranslationToRef","_TargetTransformMatrix","RotationAxis","_RigCamTransformMatrix","getClassName","__decorate"],"sources":["../../../../dev/core/src/Cameras/targetCamera.ts"],"sourcesContent":["import { serialize, serializeAsVector3, serializeAsMeshReference } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, Vector2, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { Axis } from \"../Maths/math.axis\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\n/**\r\n * A target camera takes a mesh or position as a target and continues to look at it while it moves.\r\n * This is the base of the follow, arc rotate cameras and Free camera\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n */\r\nexport class TargetCamera extends Camera {\r\n    private static _RigCamTransformMatrix = new Matrix();\r\n    private static _TargetTransformMatrix = new Matrix();\r\n    private static _TargetFocalPoint = new Vector3();\r\n\r\n    private _tmpUpVector = Vector3.Zero();\r\n    private _tmpTargetVector = Vector3.Zero();\r\n\r\n    /**\r\n     * Define the current direction the camera is moving to\r\n     */\r\n    public cameraDirection = new Vector3(0, 0, 0);\r\n    /**\r\n     * Define the current rotation the camera is rotating to\r\n     */\r\n    public cameraRotation = new Vector2(0, 0);\r\n\r\n    /** Gets or sets a boolean indicating that the scaling of the parent hierarchy will not be taken in account by the camera */\r\n    public ignoreParentScaling = false;\r\n\r\n    /**\r\n     * When set, the up vector of the camera will be updated by the rotation of the camera\r\n     */\r\n    public updateUpVectorFromRotation = false;\r\n    private _tmpQuaternion = new Quaternion();\r\n\r\n    /**\r\n     * Define the current rotation of the camera\r\n     */\r\n    @serializeAsVector3()\r\n    public rotation = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Define the current rotation of the camera as a quaternion to prevent Gimbal lock\r\n     */\r\n    public rotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Define the current speed of the camera\r\n     */\r\n    @serialize()\r\n    public speed = 2.0;\r\n\r\n    /**\r\n     * Add constraint to the camera to prevent it to move freely in all directions and\r\n     * around all axis.\r\n     */\r\n    public noRotationConstraint = false;\r\n\r\n    /**\r\n     * Reverses mouselook direction to 'natural' panning as opposed to traditional direct\r\n     * panning\r\n     */\r\n    public invertRotation = false;\r\n\r\n    /**\r\n     * Speed multiplier for inverse camera panning\r\n     */\r\n    public inverseRotationSpeed = 0.2;\r\n\r\n    /**\r\n     * Define the current target of the camera as an object or a position.\r\n     * Please note that locking a target will disable panning.\r\n     */\r\n    @serializeAsMeshReference(\"lockedTargetId\")\r\n    public lockedTarget: any = null;\r\n\r\n    /** @internal */\r\n    public _currentTarget = Vector3.Zero();\r\n    /** @internal */\r\n    public _initialFocalDistance = 1;\r\n    /** @internal */\r\n    public _viewMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _camMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _cameraTransformMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _cameraRotationMatrix = Matrix.Zero();\r\n\r\n    /** @internal */\r\n    public _referencePoint = new Vector3(0, 0, 1);\r\n    /** @internal */\r\n    public _transformedReferencePoint = Vector3.Zero();\r\n\r\n    protected _deferredPositionUpdate = new Vector3();\r\n    protected _deferredRotationQuaternionUpdate = new Quaternion();\r\n    protected _deferredRotationUpdate = new Vector3();\r\n    protected _deferredUpdated = false;\r\n    protected _deferOnly: boolean = false;\r\n\r\n    /** @internal */\r\n    public _reset: () => void;\r\n\r\n    private _defaultUp = Vector3.Up();\r\n\r\n    /**\r\n     * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.\r\n     * This is the base of the follow, arc rotate cameras and Free camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n     * @param name Defines the name of the camera in the scene\r\n     * @param position Defines the start position of the camera in the scene\r\n     * @param scene Defines the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n    }\r\n\r\n    /**\r\n     * Gets the position in front of the camera at a given distance.\r\n     * @param distance The distance from the camera we want the position to be\r\n     * @returns the position\r\n     */\r\n    public getFrontPosition(distance: number): Vector3 {\r\n        this.getWorldMatrix();\r\n        const direction = this.getTarget().subtract(this.position);\r\n        direction.normalize();\r\n        direction.scaleInPlace(distance);\r\n        return this.globalPosition.add(direction);\r\n    }\r\n\r\n    /** @internal */\r\n    public _getLockedTargetPosition(): Nullable<Vector3> {\r\n        if (!this.lockedTarget) {\r\n            return null;\r\n        }\r\n\r\n        if (this.lockedTarget.absolutePosition) {\r\n            const lockedTarget = this.lockedTarget as AbstractMesh;\r\n            const m = lockedTarget.computeWorldMatrix();\r\n            // in some cases the absolute position resets externally, but doesn't update since the matrix is cached.\r\n            m.getTranslationToRef(lockedTarget.absolutePosition);\r\n        }\r\n\r\n        return this.lockedTarget.absolutePosition || this.lockedTarget;\r\n    }\r\n\r\n    private _storedPosition: Vector3;\r\n    private _storedRotation: Vector3;\r\n    private _storedRotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Store current camera state of the camera (fov, position, rotation, etc..)\r\n     * @returns the camera\r\n     */\r\n    public storeState(): Camera {\r\n        this._storedPosition = this.position.clone();\r\n        this._storedRotation = this.rotation.clone();\r\n        if (this.rotationQuaternion) {\r\n            this._storedRotationQuaternion = this.rotationQuaternion.clone();\r\n        }\r\n\r\n        return super.storeState();\r\n    }\r\n\r\n    /**\r\n     * Restored camera state. You must call storeState() first\r\n     * @returns whether it was successful or not\r\n     * @internal\r\n     */\r\n    public _restoreStateValues(): boolean {\r\n        if (!super._restoreStateValues()) {\r\n            return false;\r\n        }\r\n\r\n        this.position = this._storedPosition.clone();\r\n        this.rotation = this._storedRotation.clone();\r\n\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion = this._storedRotationQuaternion.clone();\r\n        }\r\n\r\n        this.cameraDirection.copyFromFloats(0, 0, 0);\r\n        this.cameraRotation.copyFromFloats(0, 0);\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _initCache() {\r\n        super._initCache();\r\n        this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateCache(ignoreParentClass?: boolean): void {\r\n        if (!ignoreParentClass) {\r\n            super._updateCache();\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n        if (!lockedTargetPosition) {\r\n            this._cache.lockedTarget = null;\r\n        } else {\r\n            if (!this._cache.lockedTarget) {\r\n                this._cache.lockedTarget = lockedTargetPosition.clone();\r\n            } else {\r\n                this._cache.lockedTarget.copyFrom(lockedTargetPosition);\r\n            }\r\n        }\r\n\r\n        this._cache.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    // Synchronized\r\n    /** @internal */\r\n    public _isSynchronizedViewMatrix(): boolean {\r\n        if (!super._isSynchronizedViewMatrix()) {\r\n            return false;\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n\r\n        return (\r\n            (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) &&\r\n            (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation))\r\n        );\r\n    }\r\n\r\n    // Methods\r\n    /** @internal */\r\n    public _computeLocalCameraSpeed(): number {\r\n        const engine = this.getEngine();\r\n        return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100.0));\r\n    }\r\n\r\n    // Target\r\n\r\n    /**\r\n     * Defines the target the camera should look at.\r\n     * @param target Defines the new target as a Vector\r\n     */\r\n    public setTarget(target: Vector3): void {\r\n        this.upVector.normalize();\r\n\r\n        this._initialFocalDistance = target.subtract(this.position).length();\r\n\r\n        if (this.position.z === target.z) {\r\n            this.position.z += Epsilon;\r\n        }\r\n\r\n        this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n\r\n        Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);\r\n        this._camMatrix.invert();\r\n\r\n        this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);\r\n\r\n        const vDir = target.subtract(this.position);\r\n\r\n        if (vDir.x >= 0.0) {\r\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) + Math.PI / 2.0;\r\n        } else {\r\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) - Math.PI / 2.0;\r\n        }\r\n\r\n        this.rotation.z = 0;\r\n\r\n        if (isNaN(this.rotation.x)) {\r\n            this.rotation.x = 0;\r\n        }\r\n\r\n        if (isNaN(this.rotation.y)) {\r\n            this.rotation.y = 0;\r\n        }\r\n\r\n        if (isNaN(this.rotation.z)) {\r\n            this.rotation.z = 0;\r\n        }\r\n\r\n        if (this.rotationQuaternion) {\r\n            Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the target point of the camera.\r\n     * The camera looks towards it form the radius distance.\r\n     */\r\n    public get target(): Vector3 {\r\n        return this.getTarget();\r\n    }\r\n    public set target(value: Vector3) {\r\n        this.setTarget(value);\r\n    }\r\n\r\n    /**\r\n     * Return the current target position of the camera. This value is expressed in local space.\r\n     * @returns the target position\r\n     */\r\n    public getTarget(): Vector3 {\r\n        return this._currentTarget;\r\n    }\r\n\r\n    /** @internal */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public _updatePosition(): void {\r\n        if (this.parent) {\r\n            this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\r\n            Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\r\n            this._deferredPositionUpdate.addInPlace(TmpVectors.Vector3[0]);\r\n            if (!this._deferOnly) {\r\n                this.position.copyFrom(this._deferredPositionUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n            return;\r\n        }\r\n        this._deferredPositionUpdate.addInPlace(this.cameraDirection);\r\n        if (!this._deferOnly) {\r\n            this.position.copyFrom(this._deferredPositionUpdate);\r\n        } else {\r\n            this._deferredUpdated = true;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        const directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1.0;\r\n        const needToMove = this._decideIfNeedsToMove();\r\n        const needToRotate = this.cameraRotation.x || this.cameraRotation.y;\r\n\r\n        this._deferredUpdated = false;\r\n        this._deferredRotationUpdate.copyFrom(this.rotation);\r\n        this._deferredPositionUpdate.copyFrom(this.position);\r\n        if (this.rotationQuaternion) {\r\n            this._deferredRotationQuaternionUpdate.copyFrom(this.rotationQuaternion);\r\n        }\r\n\r\n        // Move\r\n        if (needToMove) {\r\n            this._updatePosition();\r\n        }\r\n\r\n        // Rotate\r\n        if (needToRotate) {\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                this.rotationQuaternion.toEulerAnglesToRef(this._deferredRotationUpdate);\r\n            }\r\n\r\n            this._deferredRotationUpdate.x += this.cameraRotation.x * directionMultiplier;\r\n            this._deferredRotationUpdate.y += this.cameraRotation.y * directionMultiplier;\r\n\r\n            // Apply constraints\r\n            if (!this.noRotationConstraint) {\r\n                const limit = 1.570796;\r\n\r\n                if (this._deferredRotationUpdate.x > limit) {\r\n                    this._deferredRotationUpdate.x = limit;\r\n                }\r\n                if (this._deferredRotationUpdate.x < -limit) {\r\n                    this._deferredRotationUpdate.x = -limit;\r\n                }\r\n            }\r\n\r\n            if (!this._deferOnly) {\r\n                this.rotation.copyFrom(this._deferredRotationUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                const len = this._deferredRotationUpdate.lengthSquared();\r\n                if (len) {\r\n                    Quaternion.RotationYawPitchRollToRef(\r\n                        this._deferredRotationUpdate.y,\r\n                        this._deferredRotationUpdate.x,\r\n                        this._deferredRotationUpdate.z,\r\n                        this._deferredRotationQuaternionUpdate\r\n                    );\r\n                    if (!this._deferOnly) {\r\n                        this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate);\r\n                    } else {\r\n                        this._deferredUpdated = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Inertia\r\n        if (needToMove) {\r\n            if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {\r\n                this.cameraDirection.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {\r\n                this.cameraDirection.y = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {\r\n                this.cameraDirection.z = 0;\r\n            }\r\n\r\n            this.cameraDirection.scaleInPlace(this.inertia);\r\n        }\r\n        if (needToRotate) {\r\n            if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {\r\n                this.cameraRotation.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {\r\n                this.cameraRotation.y = 0;\r\n            }\r\n            this.cameraRotation.scaleInPlace(this.inertia);\r\n        }\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    protected _updateCameraRotationMatrix() {\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);\r\n        } else {\r\n            Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)\r\n     * @returns the current camera\r\n     */\r\n    private _rotateUpVectorWithCameraRotationMatrix(): TargetCamera {\r\n        Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);\r\n        return this;\r\n    }\r\n\r\n    private _cachedRotationZ = 0;\r\n    private _cachedQuaternionRotationZ = 0;\r\n    /** @internal */\r\n    public _getViewMatrix(): Matrix {\r\n        if (this.lockedTarget) {\r\n            this.setTarget(this._getLockedTargetPosition()!);\r\n        }\r\n\r\n        // Compute\r\n        this._updateCameraRotationMatrix();\r\n\r\n        // Apply the changed rotation to the upVector\r\n        if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedQuaternionRotationZ = this.rotationQuaternion.z;\r\n        } else if (this._cachedRotationZ !== this.rotation.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedRotationZ = this.rotation.z;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\r\n\r\n        // Computing target and final matrix\r\n        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\r\n        if (this.updateUpVectorFromRotation) {\r\n            if (this.rotationQuaternion) {\r\n                Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);\r\n            } else {\r\n                Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);\r\n                Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);\r\n            }\r\n        }\r\n        this._computeViewMatrix(this.position, this._currentTarget, this.upVector);\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    protected _computeViewMatrix(position: Vector3, target: Vector3, up: Vector3): void {\r\n        if (this.ignoreParentScaling) {\r\n            if (this.parent) {\r\n                const parentWorldMatrix = this.parent.getWorldMatrix();\r\n                Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);\r\n                Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);\r\n                Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);\r\n                this._markSyncedWithParent();\r\n            } else {\r\n                this._globalPosition.copyFrom(position);\r\n                this._tmpTargetVector.copyFrom(target);\r\n                this._tmpUpVector.copyFrom(up);\r\n            }\r\n\r\n            if (this.getScene().useRightHandedSystem) {\r\n                Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            } else {\r\n                Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (this.getScene().useRightHandedSystem) {\r\n            Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);\r\n        } else {\r\n            Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);\r\n        }\r\n\r\n        if (this.parent) {\r\n            const parentWorldMatrix = this.parent.getWorldMatrix();\r\n            this._viewMatrix.invert();\r\n            this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);\r\n            this._viewMatrix.getTranslationToRef(this._globalPosition);\r\n            this._viewMatrix.invert();\r\n            this._markSyncedWithParent();\r\n        } else {\r\n            this._globalPosition.copyFrom(position);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public createRigCamera(name: string, cameraIndex: number): Nullable<Camera> {\r\n        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\r\n            const rigCamera = new TargetCamera(name, this.position.clone(), this.getScene());\r\n            rigCamera.isRigCamera = true;\r\n            rigCamera.rigParent = this;\r\n            if (this.cameraRigMode === Camera.RIG_MODE_VR) {\r\n                if (!this.rotationQuaternion) {\r\n                    this.rotationQuaternion = new Quaternion();\r\n                }\r\n                rigCamera._cameraRigParams = {};\r\n                rigCamera.rotationQuaternion = new Quaternion();\r\n            }\r\n\r\n            rigCamera.mode = this.mode;\r\n            rigCamera.orthoLeft = this.orthoLeft;\r\n            rigCamera.orthoRight = this.orthoRight;\r\n            rigCamera.orthoTop = this.orthoTop;\r\n            rigCamera.orthoBottom = this.orthoBottom;\r\n\r\n            return rigCamera;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateRigCameras() {\r\n        const camLeft = <TargetCamera>this._rigCameras[0];\r\n        const camRight = <TargetCamera>this._rigCameras[1];\r\n\r\n        this.computeWorldMatrix();\r\n\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED: {\r\n                //provisionnaly using _cameraRigParams.stereoHalfAngle instead of calculations based on _cameraRigParams.interaxialDistance:\r\n                const leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;\r\n                const rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);\r\n                break;\r\n            }\r\n            case Camera.RIG_MODE_VR:\r\n                if (camLeft.rotationQuaternion) {\r\n                    camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                    camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                } else {\r\n                    camLeft.rotation.copyFrom(this.rotation);\r\n                    camRight.rotation.copyFrom(this.rotation);\r\n                }\r\n                camLeft.position.copyFrom(this.position);\r\n                camRight.position.copyFrom(this.position);\r\n\r\n                break;\r\n        }\r\n        super._updateRigCameras();\r\n    }\r\n\r\n    private _getRigCamPositionAndTarget(halfSpace: number, rigCamera: TargetCamera) {\r\n        const target = this.getTarget();\r\n        target.subtractToRef(this.position, TargetCamera._TargetFocalPoint);\r\n\r\n        TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n        const newFocalTarget = TargetCamera._TargetFocalPoint.addInPlace(this.position);\r\n\r\n        Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n        TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera._RigCamTransformMatrix);\r\n        Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n\r\n        TargetCamera._RigCamTransformMatrix.multiplyToRef(TargetCamera._TargetTransformMatrix, TargetCamera._RigCamTransformMatrix);\r\n\r\n        Vector3.TransformCoordinatesToRef(this.position, TargetCamera._RigCamTransformMatrix, rigCamera.position);\r\n        rigCamera.setTarget(newFocalTarget);\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"TargetCamera\";\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}