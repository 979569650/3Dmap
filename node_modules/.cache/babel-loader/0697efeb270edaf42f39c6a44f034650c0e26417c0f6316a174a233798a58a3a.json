{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { MaterialHelper } from \"../../../materialHelper.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator.js\";\nimport \"../../../../Shaders/ShadersInclude/lightFragmentDeclaration.js\";\nimport \"../../../../Shaders/ShadersInclude/lightVxFragmentDeclaration.js\";\nimport \"../../../../Shaders/ShadersInclude/lightUboDeclaration.js\";\nimport \"../../../../Shaders/ShadersInclude/lightVxUboDeclaration.js\";\nimport \"../../../../Shaders/ShadersInclude/lightFragment.js\";\nimport \"../../../../Shaders/ShadersInclude/helperFunctions.js\";\nimport \"../../../../Shaders/ShadersInclude/lightsFragmentFunctions.js\";\nimport \"../../../../Shaders/ShadersInclude/shadowsFragmentFunctions.js\";\nimport \"../../../../Shaders/ShadersInclude/shadowsVertex.js\";\n/**\n * Block used to add light in the fragment shader\n */\nexport class LightBlock extends NodeMaterialBlock {\n  static _OnGenerateOnlyFragmentCodeChanged(block, _propertyName) {\n    const that = block;\n    if (that.worldPosition.isConnected) {\n      that.generateOnlyFragmentCode = !that.generateOnlyFragmentCode;\n      console.error(\"The worldPosition input must not be connected to be able to switch!\");\n      return false;\n    }\n    that._setTarget();\n    return true;\n  }\n  _setTarget() {\n    this._setInitialTarget(this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);\n    this.getInputByName(\"worldPosition\").target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;\n  }\n  /**\n   * Create a new LightBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.VertexAndFragment);\n    this._lightId = 0;\n    /** Indicates that no code should be generated in the vertex shader. Can be useful in some specific circumstances (like when doing ray marching for eg) */\n    this.generateOnlyFragmentCode = false;\n    this._isUnique = true;\n    this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);\n    this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"cameraPosition\", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"glossiness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"glossPower\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"diffuseColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"specularColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"view\", NodeMaterialBlockConnectionPointTypes.Matrix, true);\n    this.registerOutput(\"diffuseOutput\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"specularOutput\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"shadow\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"LightBlock\";\n  }\n  /**\n   * Gets the world position input component\n   */\n  get worldPosition() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the world normal input component\n   */\n  get worldNormal() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the camera (or eye) position component\n   */\n  get cameraPosition() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the glossiness component\n   */\n  get glossiness() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the glossiness power component\n   */\n  get glossPower() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the diffuse color component\n   */\n  get diffuseColor() {\n    return this._inputs[5];\n  }\n  /**\n   * Gets the specular color component\n   */\n  get specularColor() {\n    return this._inputs[6];\n  }\n  /**\n   * Gets the view matrix component\n   */\n  get view() {\n    return this._inputs[7];\n  }\n  /**\n   * Gets the diffuse output component\n   */\n  get diffuseOutput() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the specular output component\n   */\n  get specularOutput() {\n    return this._outputs[1];\n  }\n  /**\n   * Gets the shadow output component\n   */\n  get shadow() {\n    return this._outputs[2];\n  }\n  autoConfigure(material, additionalFilteringInfo = () => true) {\n    if (!this.cameraPosition.isConnected) {\n      let cameraPositionInput = material.getInputBlockByPredicate(b => b.systemValue === NodeMaterialSystemValues.CameraPosition && additionalFilteringInfo(b));\n      if (!cameraPositionInput) {\n        cameraPositionInput = new InputBlock(\"cameraPosition\");\n        cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);\n      }\n      cameraPositionInput.output.connectTo(this.cameraPosition);\n    }\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    if (!defines._areLightsDirty) {\n      return;\n    }\n    const scene = mesh.getScene();\n    if (!this.light) {\n      MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, nodeMaterial.maxSimultaneousLights);\n    } else {\n      const state = {\n        needNormals: false,\n        needRebuild: false,\n        lightmapMode: false,\n        shadowEnabled: false,\n        specularEnabled: false\n      };\n      MaterialHelper.PrepareDefinesForLight(scene, mesh, this.light, this._lightId, defines, true, state);\n      if (state.needRebuild) {\n        defines.rebuild();\n      }\n    }\n  }\n  updateUniformsAndSamples(state, nodeMaterial, defines, uniformBuffers) {\n    for (let lightIndex = 0; lightIndex < nodeMaterial.maxSimultaneousLights; lightIndex++) {\n      if (!defines[\"LIGHT\" + lightIndex]) {\n        break;\n      }\n      const onlyUpdateBuffersList = state.uniforms.indexOf(\"vLightData\" + lightIndex) >= 0;\n      MaterialHelper.PrepareUniformsAndSamplersForLight(lightIndex, state.uniforms, state.samplers, defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex], uniformBuffers, onlyUpdateBuffersList);\n    }\n  }\n  bind(effect, nodeMaterial, mesh) {\n    if (!mesh) {\n      return;\n    }\n    const scene = mesh.getScene();\n    if (!this.light) {\n      MaterialHelper.BindLights(scene, mesh, effect, true, nodeMaterial.maxSimultaneousLights);\n    } else {\n      MaterialHelper.BindLight(this.light, this._lightId, scene, effect, true);\n    }\n  }\n  _injectVertexCode(state) {\n    const worldPos = this.worldPosition;\n    const comments = `//${this.name}`;\n    // Declaration\n    if (!this.light) {\n      // Emit for all lights\n      state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightVxUboDeclaration\" : \"lightVxFragmentDeclaration\", comments, {\n        repeatKey: \"maxSimultaneousLights\"\n      });\n      this._lightId = 0;\n      state.sharedData.dynamicUniformBlocks.push(this);\n    } else {\n      this._lightId = (state.counters[\"lightCounter\"] !== undefined ? state.counters[\"lightCounter\"] : -1) + 1;\n      state.counters[\"lightCounter\"] = this._lightId;\n      state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightVxUboDeclaration\" : \"lightVxFragmentDeclaration\", comments, {\n        replaceStrings: [{\n          search: /{X}/g,\n          replace: this._lightId.toString()\n        }]\n      }, this._lightId.toString());\n    }\n    // Inject code in vertex\n    const worldPosVaryingName = \"v_\" + worldPos.associatedVariableName;\n    if (state._emitVaryingFromString(worldPosVaryingName, \"vec4\")) {\n      state.compilationString += `${worldPosVaryingName} = ${worldPos.associatedVariableName};\\n`;\n    }\n    if (this.light) {\n      state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\n        replaceStrings: [{\n          search: /{X}/g,\n          replace: this._lightId.toString()\n        }, {\n          search: /worldPos/g,\n          replace: worldPos.associatedVariableName\n        }]\n      });\n    } else {\n      state.compilationString += `vec4 worldPos = ${worldPos.associatedVariableName};\\n`;\n      if (this.view.isConnected) {\n        state.compilationString += `mat4 view = ${this.view.associatedVariableName};\\n`;\n      }\n      state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\n        repeatKey: \"maxSimultaneousLights\"\n      });\n    }\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    if (state.target !== NodeMaterialBlockTargets.Fragment) {\n      // Vertex\n      this._injectVertexCode(state);\n      return;\n    }\n    if (this.generateOnlyFragmentCode) {\n      state.sharedData.dynamicUniformBlocks.push(this);\n    }\n    // Fragment\n    state.sharedData.forcedBindableBlocks.push(this);\n    state.sharedData.blocksWithDefines.push(this);\n    const comments = `//${this.name}`;\n    const worldPos = this.worldPosition;\n    let worldPosVariableName = worldPos.associatedVariableName;\n    if (this.generateOnlyFragmentCode) {\n      worldPosVariableName = state._getFreeVariableName(\"globalWorldPos\");\n      state._emitFunction(\"light_globalworldpos\", `vec3 ${worldPosVariableName};\\n`, comments);\n      state.compilationString += `${worldPosVariableName} = ${worldPos.associatedVariableName}.xyz;\\n`;\n      state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\n        repeatKey: \"maxSimultaneousLights\",\n        substitutionVars: this.generateOnlyFragmentCode ? `worldPos,${worldPos.associatedVariableName}` : undefined\n      });\n    } else {\n      worldPosVariableName = \"v_\" + worldPosVariableName + \".xyz\";\n    }\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n    state._emitFunctionFromInclude(\"lightsFragmentFunctions\", comments, {\n      replaceStrings: [{\n        search: /vPositionW/g,\n        replace: worldPosVariableName\n      }]\n    });\n    state._emitFunctionFromInclude(\"shadowsFragmentFunctions\", comments, {\n      replaceStrings: [{\n        search: /vPositionW/g,\n        replace: worldPosVariableName\n      }]\n    });\n    if (!this.light) {\n      // Emit for all lights\n      state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\n        repeatKey: \"maxSimultaneousLights\",\n        substitutionVars: this.generateOnlyFragmentCode ? \"varying,\" : undefined\n      });\n    } else {\n      state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\n        replaceStrings: [{\n          search: /{X}/g,\n          replace: this._lightId.toString()\n        }]\n      }, this._lightId.toString());\n    }\n    // Code\n    if (this._lightId === 0) {\n      if (state._registerTempVariable(\"viewDirectionW\")) {\n        state.compilationString += `vec3 viewDirectionW = normalize(${this.cameraPosition.associatedVariableName} - ${worldPosVariableName});\\n`;\n      }\n      state.compilationString += `lightingInfo info;\\n`;\n      state.compilationString += `float shadow = 1.;\\n`;\n      state.compilationString += `float aggShadow = 0.;\\n`;\n      state.compilationString += `float numLights = 0.;\\n`;\n      state.compilationString += `float glossiness = ${this.glossiness.isConnected ? this.glossiness.associatedVariableName : \"1.0\"} * ${this.glossPower.isConnected ? this.glossPower.associatedVariableName : \"1024.0\"};\\n`;\n      state.compilationString += `vec3 diffuseBase = vec3(0., 0., 0.);\\n`;\n      state.compilationString += `vec3 specularBase = vec3(0., 0., 0.);\\n`;\n      state.compilationString += `vec3 normalW = ${this.worldNormal.associatedVariableName}.xyz;\\n`;\n    }\n    if (this.light) {\n      state.compilationString += state._emitCodeFromInclude(\"lightFragment\", comments, {\n        replaceStrings: [{\n          search: /{X}/g,\n          replace: this._lightId.toString()\n        }]\n      });\n    } else {\n      state.compilationString += state._emitCodeFromInclude(\"lightFragment\", comments, {\n        repeatKey: \"maxSimultaneousLights\"\n      });\n    }\n    if (this._lightId === 0) {\n      state.compilationString += `aggShadow = aggShadow / numLights;\\n`;\n    }\n    const diffuseOutput = this.diffuseOutput;\n    const specularOutput = this.specularOutput;\n    state.compilationString += this._declareOutput(diffuseOutput, state) + ` = diffuseBase${this.diffuseColor.isConnected ? \" * \" + this.diffuseColor.associatedVariableName : \"\"};\\n`;\n    if (specularOutput.hasEndpoints) {\n      state.compilationString += this._declareOutput(specularOutput, state) + ` = specularBase${this.specularColor.isConnected ? \" * \" + this.specularColor.associatedVariableName : \"\"};\\n`;\n    }\n    if (this.shadow.hasEndpoints) {\n      state.compilationString += this._declareOutput(this.shadow, state) + ` = aggShadow;\\n`;\n    }\n    return this;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.generateOnlyFragmentCode = this.generateOnlyFragmentCode;\n    if (this.light) {\n      serializationObject.lightId = this.light.id;\n    }\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    if (serializationObject.lightId) {\n      this.light = scene.getLightById(serializationObject.lightId);\n    }\n    this.generateOnlyFragmentCode = serializationObject.generateOnlyFragmentCode;\n    this._setTarget();\n  }\n}\n__decorate([editableInPropertyPage(\"Generate only fragment code\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    rebuild: true,\n    update: true,\n    onValidation: LightBlock._OnGenerateOnlyFragmentCodeChanged\n  }\n})], LightBlock.prototype, \"generateOnlyFragmentCode\", void 0);\nRegisterClass(\"BABYLON.LightBlock\", LightBlock);","map":{"version":3,"names":["NodeMaterialBlock","NodeMaterialBlockTargets","NodeMaterialBlockConnectionPointTypes","MaterialHelper","NodeMaterialSystemValues","InputBlock","RegisterClass","editableInPropertyPage","PropertyTypeForEdition","LightBlock","_OnGenerateOnlyFragmentCodeChanged","block","_propertyName","that","worldPosition","isConnected","generateOnlyFragmentCode","console","error","_setTarget","_setInitialTarget","Fragment","VertexAndFragment","getInputByName","target","Vertex","constructor","name","_lightId","_isUnique","registerInput","Vector4","Vector3","Float","Color3","Matrix","registerOutput","getClassName","_inputs","worldNormal","cameraPosition","glossiness","glossPower","diffuseColor","specularColor","view","diffuseOutput","_outputs","specularOutput","shadow","autoConfigure","material","additionalFilteringInfo","cameraPositionInput","getInputBlockByPredicate","b","systemValue","CameraPosition","setAsSystemValue","output","connectTo","prepareDefines","mesh","nodeMaterial","defines","_areLightsDirty","scene","getScene","light","PrepareDefinesForLights","maxSimultaneousLights","state","needNormals","needRebuild","lightmapMode","shadowEnabled","specularEnabled","PrepareDefinesForLight","rebuild","updateUniformsAndSamples","uniformBuffers","lightIndex","onlyUpdateBuffersList","uniforms","indexOf","PrepareUniformsAndSamplersForLight","samplers","bind","effect","BindLights","BindLight","_injectVertexCode","worldPos","comments","_emitFunctionFromInclude","supportUniformBuffers","repeatKey","sharedData","dynamicUniformBlocks","push","counters","undefined","replaceStrings","search","replace","toString","worldPosVaryingName","associatedVariableName","_emitVaryingFromString","compilationString","_emitCodeFromInclude","_buildBlock","forcedBindableBlocks","blocksWithDefines","worldPosVariableName","_getFreeVariableName","_emitFunction","substitutionVars","_registerTempVariable","_declareOutput","hasEndpoints","serialize","serializationObject","lightId","id","_deserialize","rootUrl","getLightById","__decorate","Boolean","notifiers","update","onValidation"],"sources":["../../../../../../../dev/core/src/Materials/Node/Blocks/Dual/lightBlock.ts"],"sourcesContent":["import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { MaterialHelper } from \"../../../materialHelper\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport type { Light } from \"../../../../Lights/light\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\n\r\nimport \"../../../../Shaders/ShadersInclude/lightFragmentDeclaration\";\r\nimport \"../../../../Shaders/ShadersInclude/lightVxFragmentDeclaration\";\r\nimport \"../../../../Shaders/ShadersInclude/lightUboDeclaration\";\r\nimport \"../../../../Shaders/ShadersInclude/lightVxUboDeclaration\";\r\nimport \"../../../../Shaders/ShadersInclude/lightFragment\";\r\nimport \"../../../../Shaders/ShadersInclude/helperFunctions\";\r\nimport \"../../../../Shaders/ShadersInclude/lightsFragmentFunctions\";\r\nimport \"../../../../Shaders/ShadersInclude/shadowsFragmentFunctions\";\r\nimport \"../../../../Shaders/ShadersInclude/shadowsVertex\";\r\n\r\n/**\r\n * Block used to add light in the fragment shader\r\n */\r\nexport class LightBlock extends NodeMaterialBlock {\r\n    private _lightId: number = 0;\r\n\r\n    /**\r\n     * Gets or sets the light associated with this block\r\n     */\r\n    public light: Nullable<Light>;\r\n\r\n    /** Indicates that no code should be generated in the vertex shader. Can be useful in some specific circumstances (like when doing ray marching for eg) */\r\n    @editableInPropertyPage(\"Generate only fragment code\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\r\n        notifiers: { rebuild: true, update: true, onValidation: LightBlock._OnGenerateOnlyFragmentCodeChanged },\r\n    })\r\n    public generateOnlyFragmentCode = false;\r\n\r\n    private static _OnGenerateOnlyFragmentCodeChanged(block: NodeMaterialBlock, _propertyName: string): boolean {\r\n        const that = block as LightBlock;\r\n\r\n        if (that.worldPosition.isConnected) {\r\n            that.generateOnlyFragmentCode = !that.generateOnlyFragmentCode;\r\n            console.error(\"The worldPosition input must not be connected to be able to switch!\");\r\n            return false;\r\n        }\r\n\r\n        that._setTarget();\r\n\r\n        return true;\r\n    }\r\n\r\n    private _setTarget(): void {\r\n        this._setInitialTarget(this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);\r\n        this.getInputByName(\"worldPosition\")!.target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;\r\n    }\r\n\r\n    /**\r\n     * Create a new LightBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);\r\n        this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"cameraPosition\", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"glossiness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"glossPower\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"diffuseColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"specularColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"view\", NodeMaterialBlockConnectionPointTypes.Matrix, true);\r\n\r\n        this.registerOutput(\"diffuseOutput\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"specularOutput\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"shadow\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"LightBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public get worldPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the world normal input component\r\n     */\r\n    public get worldNormal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the camera (or eye) position component\r\n     */\r\n    public get cameraPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the glossiness component\r\n     */\r\n    public get glossiness(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the glossiness power component\r\n     */\r\n    public get glossPower(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the diffuse color component\r\n     */\r\n    public get diffuseColor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the specular color component\r\n     */\r\n    public get specularColor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[6];\r\n    }\r\n\r\n    /**\r\n     * Gets the view matrix component\r\n     */\r\n    public get view(): NodeMaterialConnectionPoint {\r\n        return this._inputs[7];\r\n    }\r\n\r\n    /**\r\n     * Gets the diffuse output component\r\n     */\r\n    public get diffuseOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the specular output component\r\n     */\r\n    public get specularOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the shadow output component\r\n     */\r\n    public get shadow(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    public autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        if (!this.cameraPosition.isConnected) {\r\n            let cameraPositionInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.CameraPosition && additionalFilteringInfo(b));\r\n\r\n            if (!cameraPositionInput) {\r\n                cameraPositionInput = new InputBlock(\"cameraPosition\");\r\n                cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);\r\n            }\r\n            cameraPositionInput.output.connectTo(this.cameraPosition);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        if (!defines._areLightsDirty) {\r\n            return;\r\n        }\r\n\r\n        const scene = mesh.getScene();\r\n\r\n        if (!this.light) {\r\n            MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, nodeMaterial.maxSimultaneousLights);\r\n        } else {\r\n            const state = {\r\n                needNormals: false,\r\n                needRebuild: false,\r\n                lightmapMode: false,\r\n                shadowEnabled: false,\r\n                specularEnabled: false,\r\n            };\r\n\r\n            MaterialHelper.PrepareDefinesForLight(scene, mesh, this.light, this._lightId, defines, true, state);\r\n\r\n            if (state.needRebuild) {\r\n                defines.rebuild();\r\n            }\r\n        }\r\n    }\r\n\r\n    public updateUniformsAndSamples(state: NodeMaterialBuildState, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, uniformBuffers: string[]) {\r\n        for (let lightIndex = 0; lightIndex < nodeMaterial.maxSimultaneousLights; lightIndex++) {\r\n            if (!defines[\"LIGHT\" + lightIndex]) {\r\n                break;\r\n            }\r\n            const onlyUpdateBuffersList = state.uniforms.indexOf(\"vLightData\" + lightIndex) >= 0;\r\n            MaterialHelper.PrepareUniformsAndSamplersForLight(\r\n                lightIndex,\r\n                state.uniforms,\r\n                state.samplers,\r\n                defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex],\r\n                uniformBuffers,\r\n                onlyUpdateBuffersList\r\n            );\r\n        }\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        const scene = mesh.getScene();\r\n\r\n        if (!this.light) {\r\n            MaterialHelper.BindLights(scene, mesh, effect, true, nodeMaterial.maxSimultaneousLights);\r\n        } else {\r\n            MaterialHelper.BindLight(this.light, this._lightId, scene, effect, true);\r\n        }\r\n    }\r\n\r\n    private _injectVertexCode(state: NodeMaterialBuildState) {\r\n        const worldPos = this.worldPosition;\r\n        const comments = `//${this.name}`;\r\n\r\n        // Declaration\r\n        if (!this.light) {\r\n            // Emit for all lights\r\n            state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightVxUboDeclaration\" : \"lightVxFragmentDeclaration\", comments, {\r\n                repeatKey: \"maxSimultaneousLights\",\r\n            });\r\n            this._lightId = 0;\r\n\r\n            state.sharedData.dynamicUniformBlocks.push(this);\r\n        } else {\r\n            this._lightId = (state.counters[\"lightCounter\"] !== undefined ? state.counters[\"lightCounter\"] : -1) + 1;\r\n            state.counters[\"lightCounter\"] = this._lightId;\r\n\r\n            state._emitFunctionFromInclude(\r\n                state.supportUniformBuffers ? \"lightVxUboDeclaration\" : \"lightVxFragmentDeclaration\",\r\n                comments,\r\n                {\r\n                    replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }],\r\n                },\r\n                this._lightId.toString()\r\n            );\r\n        }\r\n\r\n        // Inject code in vertex\r\n        const worldPosVaryingName = \"v_\" + worldPos.associatedVariableName;\r\n        if (state._emitVaryingFromString(worldPosVaryingName, \"vec4\")) {\r\n            state.compilationString += `${worldPosVaryingName} = ${worldPos.associatedVariableName};\\n`;\r\n        }\r\n\r\n        if (this.light) {\r\n            state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\r\n                replaceStrings: [\r\n                    { search: /{X}/g, replace: this._lightId.toString() },\r\n                    { search: /worldPos/g, replace: worldPos.associatedVariableName },\r\n                ],\r\n            });\r\n        } else {\r\n            state.compilationString += `vec4 worldPos = ${worldPos.associatedVariableName};\\n`;\r\n            if (this.view.isConnected) {\r\n                state.compilationString += `mat4 view = ${this.view.associatedVariableName};\\n`;\r\n            }\r\n            state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\r\n                repeatKey: \"maxSimultaneousLights\",\r\n            });\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\r\n            // Vertex\r\n            this._injectVertexCode(state);\r\n\r\n            return;\r\n        }\r\n\r\n        if (this.generateOnlyFragmentCode) {\r\n            state.sharedData.dynamicUniformBlocks.push(this);\r\n        }\r\n\r\n        // Fragment\r\n        state.sharedData.forcedBindableBlocks.push(this);\r\n        state.sharedData.blocksWithDefines.push(this);\r\n\r\n        const comments = `//${this.name}`;\r\n        const worldPos = this.worldPosition;\r\n\r\n        let worldPosVariableName = worldPos.associatedVariableName;\r\n        if (this.generateOnlyFragmentCode) {\r\n            worldPosVariableName = state._getFreeVariableName(\"globalWorldPos\");\r\n            state._emitFunction(\"light_globalworldpos\", `vec3 ${worldPosVariableName};\\n`, comments);\r\n            state.compilationString += `${worldPosVariableName} = ${worldPos.associatedVariableName}.xyz;\\n`;\r\n\r\n            state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\r\n                repeatKey: \"maxSimultaneousLights\",\r\n                substitutionVars: this.generateOnlyFragmentCode ? `worldPos,${worldPos.associatedVariableName}` : undefined,\r\n            });\r\n        } else {\r\n            worldPosVariableName = \"v_\" + worldPosVariableName + \".xyz\";\r\n        }\r\n\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        state._emitFunctionFromInclude(\"lightsFragmentFunctions\", comments, {\r\n            replaceStrings: [{ search: /vPositionW/g, replace: worldPosVariableName }],\r\n        });\r\n\r\n        state._emitFunctionFromInclude(\"shadowsFragmentFunctions\", comments, {\r\n            replaceStrings: [{ search: /vPositionW/g, replace: worldPosVariableName }],\r\n        });\r\n\r\n        if (!this.light) {\r\n            // Emit for all lights\r\n            state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\r\n                repeatKey: \"maxSimultaneousLights\",\r\n                substitutionVars: this.generateOnlyFragmentCode ? \"varying,\" : undefined,\r\n            });\r\n        } else {\r\n            state._emitFunctionFromInclude(\r\n                state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\",\r\n                comments,\r\n                {\r\n                    replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }],\r\n                },\r\n                this._lightId.toString()\r\n            );\r\n        }\r\n\r\n        // Code\r\n        if (this._lightId === 0) {\r\n            if (state._registerTempVariable(\"viewDirectionW\")) {\r\n                state.compilationString += `vec3 viewDirectionW = normalize(${this.cameraPosition.associatedVariableName} - ${worldPosVariableName});\\n`;\r\n            }\r\n            state.compilationString += `lightingInfo info;\\n`;\r\n            state.compilationString += `float shadow = 1.;\\n`;\r\n            state.compilationString += `float aggShadow = 0.;\\n`;\r\n            state.compilationString += `float numLights = 0.;\\n`;\r\n            state.compilationString += `float glossiness = ${this.glossiness.isConnected ? this.glossiness.associatedVariableName : \"1.0\"} * ${\r\n                this.glossPower.isConnected ? this.glossPower.associatedVariableName : \"1024.0\"\r\n            };\\n`;\r\n            state.compilationString += `vec3 diffuseBase = vec3(0., 0., 0.);\\n`;\r\n            state.compilationString += `vec3 specularBase = vec3(0., 0., 0.);\\n`;\r\n            state.compilationString += `vec3 normalW = ${this.worldNormal.associatedVariableName}.xyz;\\n`;\r\n        }\r\n\r\n        if (this.light) {\r\n            state.compilationString += state._emitCodeFromInclude(\"lightFragment\", comments, {\r\n                replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }],\r\n            });\r\n        } else {\r\n            state.compilationString += state._emitCodeFromInclude(\"lightFragment\", comments, {\r\n                repeatKey: \"maxSimultaneousLights\",\r\n            });\r\n        }\r\n\r\n        if (this._lightId === 0) {\r\n            state.compilationString += `aggShadow = aggShadow / numLights;\\n`;\r\n        }\r\n\r\n        const diffuseOutput = this.diffuseOutput;\r\n        const specularOutput = this.specularOutput;\r\n\r\n        state.compilationString +=\r\n            this._declareOutput(diffuseOutput, state) + ` = diffuseBase${this.diffuseColor.isConnected ? \" * \" + this.diffuseColor.associatedVariableName : \"\"};\\n`;\r\n        if (specularOutput.hasEndpoints) {\r\n            state.compilationString +=\r\n                this._declareOutput(specularOutput, state) + ` = specularBase${this.specularColor.isConnected ? \" * \" + this.specularColor.associatedVariableName : \"\"};\\n`;\r\n        }\r\n\r\n        if (this.shadow.hasEndpoints) {\r\n            state.compilationString += this._declareOutput(this.shadow, state) + ` = aggShadow;\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.generateOnlyFragmentCode = this.generateOnlyFragmentCode;\r\n\r\n        if (this.light) {\r\n            serializationObject.lightId = this.light.id;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        if (serializationObject.lightId) {\r\n            this.light = scene.getLightById(serializationObject.lightId);\r\n        }\r\n\r\n        this.generateOnlyFragmentCode = serializationObject.generateOnlyFragmentCode;\r\n\r\n        this._setTarget();\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.LightBlock\", LightBlock);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}