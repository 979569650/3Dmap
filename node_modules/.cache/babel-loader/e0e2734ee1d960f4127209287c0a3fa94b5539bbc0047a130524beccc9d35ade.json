{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { GPUParticleSystem } from \"./gpuParticleSystem.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { ParticleSystem } from \"../Particles/particleSystem.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\n/** Internal class used to store shapes for emitters */\nclass ParticleSystemSetEmitterCreationOptions {}\n/**\n * Represents a set of particle systems working together to create a specific effect\n */\nexport class ParticleSystemSet {\n  constructor() {\n    this._emitterNodeIsOwned = true;\n    /**\n     * Gets the particle system list\n     */\n    this.systems = new Array();\n  }\n  /**\n   * Gets or sets the emitter node used with this set\n   */\n  get emitterNode() {\n    return this._emitterNode;\n  }\n  set emitterNode(value) {\n    if (this._emitterNodeIsOwned && this._emitterNode) {\n      if (this._emitterNode.dispose) {\n        this._emitterNode.dispose();\n      }\n      this._emitterNodeIsOwned = false;\n    }\n    for (const system of this.systems) {\n      system.emitter = value;\n    }\n    this._emitterNode = value;\n  }\n  /**\n   * Creates a new emitter mesh as a sphere\n   * @param options defines the options used to create the sphere\n   * @param options.diameter\n   * @param options.segments\n   * @param options.color\n   * @param renderingGroupId defines the renderingGroupId to use for the sphere\n   * @param scene defines the hosting scene\n   */\n  setEmitterAsSphere(options, renderingGroupId, scene) {\n    if (this._emitterNodeIsOwned && this._emitterNode) {\n      if (this._emitterNode.dispose) {\n        this._emitterNode.dispose();\n      }\n    }\n    this._emitterNodeIsOwned = true;\n    this._emitterCreationOptions = {\n      kind: \"Sphere\",\n      options: options,\n      renderingGroupId: renderingGroupId\n    };\n    const emitterMesh = CreateSphere(\"emitterSphere\", {\n      diameter: options.diameter,\n      segments: options.segments\n    }, scene);\n    emitterMesh.renderingGroupId = renderingGroupId;\n    const material = new StandardMaterial(\"emitterSphereMaterial\", scene);\n    material.emissiveColor = options.color;\n    emitterMesh.material = material;\n    for (const system of this.systems) {\n      system.emitter = emitterMesh;\n    }\n    this._emitterNode = emitterMesh;\n  }\n  /**\n   * Starts all particle systems of the set\n   * @param emitter defines an optional mesh to use as emitter for the particle systems\n   */\n  start(emitter) {\n    for (const system of this.systems) {\n      if (emitter) {\n        system.emitter = emitter;\n      }\n      system.start();\n    }\n  }\n  /**\n   * Release all associated resources\n   */\n  dispose() {\n    for (const system of this.systems) {\n      system.dispose();\n    }\n    this.systems.length = 0;\n    if (this._emitterNode) {\n      if (this._emitterNode.dispose) {\n        this._emitterNode.dispose();\n      }\n      this._emitterNode = null;\n    }\n  }\n  /**\n   * Serialize the set into a JSON compatible object\n   * @param serializeTexture defines if the texture must be serialized as well\n   * @returns a JSON compatible representation of the set\n   */\n  serialize(serializeTexture = false) {\n    const result = {};\n    result.systems = [];\n    for (const system of this.systems) {\n      result.systems.push(system.serialize(serializeTexture));\n    }\n    if (this._emitterNode) {\n      result.emitter = this._emitterCreationOptions;\n    }\n    return result;\n  }\n  /**\n   * Parse a new ParticleSystemSet from a serialized source\n   * @param data defines a JSON compatible representation of the set\n   * @param scene defines the hosting scene\n   * @param gpu defines if we want GPU particles or CPU particles\n   * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n   * @returns a new ParticleSystemSet\n   */\n  static Parse(data, scene, gpu = false, capacity) {\n    const result = new ParticleSystemSet();\n    const rootUrl = this.BaseAssetsUrl + \"/textures/\";\n    scene = scene || EngineStore.LastCreatedScene;\n    for (const system of data.systems) {\n      result.systems.push(gpu ? GPUParticleSystem.Parse(system, scene, rootUrl, true, capacity) : ParticleSystem.Parse(system, scene, rootUrl, true, capacity));\n    }\n    if (data.emitter) {\n      const options = data.emitter.options;\n      switch (data.emitter.kind) {\n        case \"Sphere\":\n          result.setEmitterAsSphere({\n            diameter: options.diameter,\n            segments: options.segments,\n            color: Color3.FromArray(options.color)\n          }, data.emitter.renderingGroupId, scene);\n          break;\n      }\n    }\n    return result;\n  }\n}\n/**\n * Gets or sets base Assets URL\n */\nParticleSystemSet.BaseAssetsUrl = \"https://assets.babylonjs.com/particles\";","map":{"version":3,"names":["Color3","CreateSphere","GPUParticleSystem","EngineStore","ParticleSystem","StandardMaterial","ParticleSystemSetEmitterCreationOptions","ParticleSystemSet","constructor","_emitterNodeIsOwned","systems","Array","emitterNode","_emitterNode","value","dispose","system","emitter","setEmitterAsSphere","options","renderingGroupId","scene","_emitterCreationOptions","kind","emitterMesh","diameter","segments","material","emissiveColor","color","start","length","serialize","serializeTexture","result","push","Parse","data","gpu","capacity","rootUrl","BaseAssetsUrl","LastCreatedScene","FromArray"],"sources":["../../../../dev/core/src/Particles/particleSystemSet.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder\";\r\nimport type { IParticleSystem } from \"./IParticleSystem\";\r\nimport { GPUParticleSystem } from \"./gpuParticleSystem\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { ParticleSystem } from \"../Particles/particleSystem\";\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\n\r\n/** Internal class used to store shapes for emitters */\r\nclass ParticleSystemSetEmitterCreationOptions {\r\n    public kind: string;\r\n    public options: any;\r\n    public renderingGroupId: number;\r\n}\r\n\r\n/**\r\n * Represents a set of particle systems working together to create a specific effect\r\n */\r\nexport class ParticleSystemSet implements IDisposable {\r\n    /**\r\n     * Gets or sets base Assets URL\r\n     */\r\n    public static BaseAssetsUrl = \"https://assets.babylonjs.com/particles\";\r\n\r\n    private _emitterCreationOptions: ParticleSystemSetEmitterCreationOptions;\r\n    private _emitterNode: Nullable<AbstractMesh | Vector3>;\r\n    private _emitterNodeIsOwned = true;\r\n\r\n    /**\r\n     * Gets the particle system list\r\n     */\r\n    public systems = new Array<IParticleSystem>();\r\n\r\n    /**\r\n     * Gets or sets the emitter node used with this set\r\n     */\r\n    public get emitterNode(): Nullable<AbstractMesh | Vector3> {\r\n        return this._emitterNode;\r\n    }\r\n\r\n    public set emitterNode(value: Nullable<AbstractMesh | Vector3>) {\r\n        if (this._emitterNodeIsOwned && this._emitterNode) {\r\n            if ((this._emitterNode as AbstractMesh).dispose) {\r\n                (this._emitterNode as AbstractMesh).dispose();\r\n            }\r\n            this._emitterNodeIsOwned = false;\r\n        }\r\n\r\n        for (const system of this.systems) {\r\n            system.emitter = value;\r\n        }\r\n\r\n        this._emitterNode = value;\r\n    }\r\n\r\n    /**\r\n     * Creates a new emitter mesh as a sphere\r\n     * @param options defines the options used to create the sphere\r\n     * @param options.diameter\r\n     * @param options.segments\r\n     * @param options.color\r\n     * @param renderingGroupId defines the renderingGroupId to use for the sphere\r\n     * @param scene defines the hosting scene\r\n     */\r\n    public setEmitterAsSphere(options: { diameter: number; segments: number; color: Color3 }, renderingGroupId: number, scene: Scene) {\r\n        if (this._emitterNodeIsOwned && this._emitterNode) {\r\n            if ((this._emitterNode as AbstractMesh).dispose) {\r\n                (this._emitterNode as AbstractMesh).dispose();\r\n            }\r\n        }\r\n\r\n        this._emitterNodeIsOwned = true;\r\n\r\n        this._emitterCreationOptions = {\r\n            kind: \"Sphere\",\r\n            options: options,\r\n            renderingGroupId: renderingGroupId,\r\n        };\r\n\r\n        const emitterMesh = CreateSphere(\"emitterSphere\", { diameter: options.diameter, segments: options.segments }, scene);\r\n        emitterMesh.renderingGroupId = renderingGroupId;\r\n\r\n        const material = new StandardMaterial(\"emitterSphereMaterial\", scene);\r\n        material.emissiveColor = options.color;\r\n        emitterMesh.material = material;\r\n\r\n        for (const system of this.systems) {\r\n            system.emitter = emitterMesh;\r\n        }\r\n\r\n        this._emitterNode = emitterMesh;\r\n    }\r\n\r\n    /**\r\n     * Starts all particle systems of the set\r\n     * @param emitter defines an optional mesh to use as emitter for the particle systems\r\n     */\r\n    public start(emitter?: AbstractMesh): void {\r\n        for (const system of this.systems) {\r\n            if (emitter) {\r\n                system.emitter = emitter;\r\n            }\r\n            system.start();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources\r\n     */\r\n    public dispose(): void {\r\n        for (const system of this.systems) {\r\n            system.dispose();\r\n        }\r\n\r\n        this.systems.length = 0;\r\n\r\n        if (this._emitterNode) {\r\n            if ((this._emitterNode as AbstractMesh).dispose) {\r\n                (this._emitterNode as AbstractMesh).dispose();\r\n            }\r\n            this._emitterNode = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serialize the set into a JSON compatible object\r\n     * @param serializeTexture defines if the texture must be serialized as well\r\n     * @returns a JSON compatible representation of the set\r\n     */\r\n    public serialize(serializeTexture = false): any {\r\n        const result: any = {};\r\n\r\n        result.systems = [];\r\n        for (const system of this.systems) {\r\n            result.systems.push(system.serialize(serializeTexture));\r\n        }\r\n\r\n        if (this._emitterNode) {\r\n            result.emitter = this._emitterCreationOptions;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Parse a new ParticleSystemSet from a serialized source\r\n     * @param data defines a JSON compatible representation of the set\r\n     * @param scene defines the hosting scene\r\n     * @param gpu defines if we want GPU particles or CPU particles\r\n     * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\r\n     * @returns a new ParticleSystemSet\r\n     */\r\n    public static Parse(data: any, scene: Scene, gpu = false, capacity?: number): ParticleSystemSet {\r\n        const result = new ParticleSystemSet();\r\n        const rootUrl = this.BaseAssetsUrl + \"/textures/\";\r\n\r\n        scene = scene || EngineStore.LastCreatedScene;\r\n\r\n        for (const system of data.systems) {\r\n            result.systems.push(gpu ? GPUParticleSystem.Parse(system, scene, rootUrl, true, capacity) : ParticleSystem.Parse(system, scene, rootUrl, true, capacity));\r\n        }\r\n\r\n        if (data.emitter) {\r\n            const options = data.emitter.options;\r\n            switch (data.emitter.kind) {\r\n                case \"Sphere\":\r\n                    result.setEmitterAsSphere(\r\n                        {\r\n                            diameter: options.diameter,\r\n                            segments: options.segments,\r\n                            color: Color3.FromArray(options.color),\r\n                        },\r\n                        data.emitter.renderingGroupId,\r\n                        scene\r\n                    );\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n"],"mappings":";AACA,SAASA,MAAM,QAAQ,wBAAsB;AAE7C,SAASC,YAAY,QAAQ,qCAAmC;AAEhE,SAASC,iBAAiB,QAAQ,wBAAsB;AACxD,SAASC,WAAW,QAAQ,2BAAyB;AACrD,SAASC,cAAc,QAAQ,gCAA8B;AAE7D,SAASC,gBAAgB,QAAQ,kCAAgC;AAGjE;AACA,MAAMC,uCAAuC;AAM7C;;;AAGA,OAAM,MAAOC,iBAAiB;EAA9BC,YAAA;IAQY,KAAAC,mBAAmB,GAAG,IAAI;IAElC;;;IAGO,KAAAC,OAAO,GAAG,IAAIC,KAAK,EAAmB;EAsJjD;EApJI;;;EAGA,IAAWC,WAAWA,CAAA;IAClB,OAAO,IAAI,CAACC,YAAY;EAC5B;EAEA,IAAWD,WAAWA,CAACE,KAAuC;IAC1D,IAAI,IAAI,CAACL,mBAAmB,IAAI,IAAI,CAACI,YAAY,EAAE;MAC/C,IAAK,IAAI,CAACA,YAA6B,CAACE,OAAO,EAAE;QAC5C,IAAI,CAACF,YAA6B,CAACE,OAAO,EAAE;;MAEjD,IAAI,CAACN,mBAAmB,GAAG,KAAK;;IAGpC,KAAK,MAAMO,MAAM,IAAI,IAAI,CAACN,OAAO,EAAE;MAC/BM,MAAM,CAACC,OAAO,GAAGH,KAAK;;IAG1B,IAAI,CAACD,YAAY,GAAGC,KAAK;EAC7B;EAEA;;;;;;;;;EASOI,kBAAkBA,CAACC,OAA8D,EAAEC,gBAAwB,EAAEC,KAAY;IAC5H,IAAI,IAAI,CAACZ,mBAAmB,IAAI,IAAI,CAACI,YAAY,EAAE;MAC/C,IAAK,IAAI,CAACA,YAA6B,CAACE,OAAO,EAAE;QAC5C,IAAI,CAACF,YAA6B,CAACE,OAAO,EAAE;;;IAIrD,IAAI,CAACN,mBAAmB,GAAG,IAAI;IAE/B,IAAI,CAACa,uBAAuB,GAAG;MAC3BC,IAAI,EAAE,QAAQ;MACdJ,OAAO,EAAEA,OAAO;MAChBC,gBAAgB,EAAEA;KACrB;IAED,MAAMI,WAAW,GAAGvB,YAAY,CAAC,eAAe,EAAE;MAAEwB,QAAQ,EAAEN,OAAO,CAACM,QAAQ;MAAEC,QAAQ,EAAEP,OAAO,CAACO;IAAQ,CAAE,EAAEL,KAAK,CAAC;IACpHG,WAAW,CAACJ,gBAAgB,GAAGA,gBAAgB;IAE/C,MAAMO,QAAQ,GAAG,IAAItB,gBAAgB,CAAC,uBAAuB,EAAEgB,KAAK,CAAC;IACrEM,QAAQ,CAACC,aAAa,GAAGT,OAAO,CAACU,KAAK;IACtCL,WAAW,CAACG,QAAQ,GAAGA,QAAQ;IAE/B,KAAK,MAAMX,MAAM,IAAI,IAAI,CAACN,OAAO,EAAE;MAC/BM,MAAM,CAACC,OAAO,GAAGO,WAAW;;IAGhC,IAAI,CAACX,YAAY,GAAGW,WAAW;EACnC;EAEA;;;;EAIOM,KAAKA,CAACb,OAAsB;IAC/B,KAAK,MAAMD,MAAM,IAAI,IAAI,CAACN,OAAO,EAAE;MAC/B,IAAIO,OAAO,EAAE;QACTD,MAAM,CAACC,OAAO,GAAGA,OAAO;;MAE5BD,MAAM,CAACc,KAAK,EAAE;;EAEtB;EAEA;;;EAGOf,OAAOA,CAAA;IACV,KAAK,MAAMC,MAAM,IAAI,IAAI,CAACN,OAAO,EAAE;MAC/BM,MAAM,CAACD,OAAO,EAAE;;IAGpB,IAAI,CAACL,OAAO,CAACqB,MAAM,GAAG,CAAC;IAEvB,IAAI,IAAI,CAAClB,YAAY,EAAE;MACnB,IAAK,IAAI,CAACA,YAA6B,CAACE,OAAO,EAAE;QAC5C,IAAI,CAACF,YAA6B,CAACE,OAAO,EAAE;;MAEjD,IAAI,CAACF,YAAY,GAAG,IAAI;;EAEhC;EAEA;;;;;EAKOmB,SAASA,CAACC,gBAAgB,GAAG,KAAK;IACrC,MAAMC,MAAM,GAAQ,EAAE;IAEtBA,MAAM,CAACxB,OAAO,GAAG,EAAE;IACnB,KAAK,MAAMM,MAAM,IAAI,IAAI,CAACN,OAAO,EAAE;MAC/BwB,MAAM,CAACxB,OAAO,CAACyB,IAAI,CAACnB,MAAM,CAACgB,SAAS,CAACC,gBAAgB,CAAC,CAAC;;IAG3D,IAAI,IAAI,CAACpB,YAAY,EAAE;MACnBqB,MAAM,CAACjB,OAAO,GAAG,IAAI,CAACK,uBAAuB;;IAGjD,OAAOY,MAAM;EACjB;EAEA;;;;;;;;EAQO,OAAOE,KAAKA,CAACC,IAAS,EAAEhB,KAAY,EAAEiB,GAAG,GAAG,KAAK,EAAEC,QAAiB;IACvE,MAAML,MAAM,GAAG,IAAI3B,iBAAiB,EAAE;IACtC,MAAMiC,OAAO,GAAG,IAAI,CAACC,aAAa,GAAG,YAAY;IAEjDpB,KAAK,GAAGA,KAAK,IAAIlB,WAAW,CAACuC,gBAAgB;IAE7C,KAAK,MAAM1B,MAAM,IAAIqB,IAAI,CAAC3B,OAAO,EAAE;MAC/BwB,MAAM,CAACxB,OAAO,CAACyB,IAAI,CAACG,GAAG,GAAGpC,iBAAiB,CAACkC,KAAK,CAACpB,MAAM,EAAEK,KAAK,EAAEmB,OAAO,EAAE,IAAI,EAAED,QAAQ,CAAC,GAAGnC,cAAc,CAACgC,KAAK,CAACpB,MAAM,EAAEK,KAAK,EAAEmB,OAAO,EAAE,IAAI,EAAED,QAAQ,CAAC,CAAC;;IAG7J,IAAIF,IAAI,CAACpB,OAAO,EAAE;MACd,MAAME,OAAO,GAAGkB,IAAI,CAACpB,OAAO,CAACE,OAAO;MACpC,QAAQkB,IAAI,CAACpB,OAAO,CAACM,IAAI;QACrB,KAAK,QAAQ;UACTW,MAAM,CAAChB,kBAAkB,CACrB;YACIO,QAAQ,EAAEN,OAAO,CAACM,QAAQ;YAC1BC,QAAQ,EAAEP,OAAO,CAACO,QAAQ;YAC1BG,KAAK,EAAE7B,MAAM,CAAC2C,SAAS,CAACxB,OAAO,CAACU,KAAK;WACxC,EACDQ,IAAI,CAACpB,OAAO,CAACG,gBAAgB,EAC7BC,KAAK,CACR;UACD;;;IAIZ,OAAOa,MAAM;EACjB;;AAjKA;;;AAGc3B,iBAAA,CAAAkC,aAAa,GAAG,wCAAwC"},"metadata":{},"sourceType":"module","externalDependencies":[]}