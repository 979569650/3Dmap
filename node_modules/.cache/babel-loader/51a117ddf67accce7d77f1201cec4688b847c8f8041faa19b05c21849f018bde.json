{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { __decorate } from \"../../../tslib.es6.js\";\nimport { serialize, serializeAsTexture, SerializationHelper } from \"../../../Misc/decorators.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nimport { Vector2, Vector3, Matrix, Vector4 } from \"../../../Maths/math.vector.js\";\nimport { Scalar } from \"../../../Maths/math.scalar.js\";\nimport { Texture } from \"../../../Materials/Textures/texture.js\";\nimport { PostProcess } from \"../../../PostProcesses/postProcess.js\";\nimport { PostProcessRenderPipeline } from \"../../../PostProcesses/RenderPipeline/postProcessRenderPipeline.js\";\nimport { PostProcessRenderEffect } from \"../../../PostProcesses/RenderPipeline/postProcessRenderEffect.js\";\nimport { BlurPostProcess } from \"../../../PostProcesses/blurPostProcess.js\";\nimport { FxaaPostProcess } from \"../../../PostProcesses/fxaaPostProcess.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { MotionBlurPostProcess } from \"../../motionBlurPostProcess.js\";\nimport { ScreenSpaceReflectionPostProcess } from \"../../screenSpaceReflectionPostProcess.js\";\nimport \"../../../PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent.js\";\nimport \"../../../Shaders/standard.fragment.js\";\n/**\n * Standard rendering pipeline\n * Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/standardRenderingPipeline\n */\nexport class StandardRenderingPipeline extends PostProcessRenderPipeline {\n  /**\n   * Gets the overall exposure used by the pipeline\n   */\n  get exposure() {\n    return this._fixedExposure;\n  }\n  /**\n   * Sets the overall exposure used by the pipeline\n   */\n  set exposure(value) {\n    this._fixedExposure = value;\n    this._currentExposure = value;\n  }\n  /**\n   * Gets whether or not the exposure of the overall pipeline should be automatically adjusted by the HDR post-process\n   */\n  get hdrAutoExposure() {\n    return this._hdrAutoExposure;\n  }\n  /**\n   * Sets whether or not the exposure of the overall pipeline should be automatically adjusted by the HDR post-process\n   */\n  set hdrAutoExposure(value) {\n    this._hdrAutoExposure = value;\n    if (this.hdrPostProcess) {\n      const defines = [\"#define HDR\"];\n      if (value) {\n        defines.push(\"#define AUTO_EXPOSURE\");\n      }\n      this.hdrPostProcess.updateEffect(defines.join(\"\\n\"));\n    }\n  }\n  /**\n   * Gets how much the image is blurred by the movement while using the motion blur post-process\n   */\n  get motionStrength() {\n    return this._motionStrength;\n  }\n  /**\n   * Sets how much the image is blurred by the movement while using the motion blur post-process\n   */\n  set motionStrength(strength) {\n    this._motionStrength = strength;\n    if (this._isObjectBasedMotionBlur && this.motionBlurPostProcess) {\n      this.motionBlurPostProcess.motionStrength = strength;\n    }\n  }\n  /**\n   * Gets whether or not the motion blur post-process is object based or screen based.\n   */\n  get objectBasedMotionBlur() {\n    return this._isObjectBasedMotionBlur;\n  }\n  /**\n   * Sets whether or not the motion blur post-process should be object based or screen based\n   */\n  set objectBasedMotionBlur(value) {\n    const shouldRebuild = this._isObjectBasedMotionBlur !== value;\n    this._isObjectBasedMotionBlur = value;\n    if (shouldRebuild) {\n      this._buildPipeline();\n    }\n  }\n  /**\n   * @ignore\n   * Specifies if the bloom pipeline is enabled\n   */\n  get BloomEnabled() {\n    return this._bloomEnabled;\n  }\n  set BloomEnabled(enabled) {\n    if (this._bloomEnabled === enabled) {\n      return;\n    }\n    this._bloomEnabled = enabled;\n    this._buildPipeline();\n  }\n  /**\n   * @ignore\n   * Specifies if the depth of field pipeline is enabled\n   */\n  get DepthOfFieldEnabled() {\n    return this._depthOfFieldEnabled;\n  }\n  set DepthOfFieldEnabled(enabled) {\n    if (this._depthOfFieldEnabled === enabled) {\n      return;\n    }\n    this._depthOfFieldEnabled = enabled;\n    this._buildPipeline();\n  }\n  /**\n   * @ignore\n   * Specifies if the lens flare pipeline is enabled\n   */\n  get LensFlareEnabled() {\n    return this._lensFlareEnabled;\n  }\n  set LensFlareEnabled(enabled) {\n    if (this._lensFlareEnabled === enabled) {\n      return;\n    }\n    this._lensFlareEnabled = enabled;\n    this._buildPipeline();\n  }\n  /**\n   * @ignore\n   * Specifies if the HDR pipeline is enabled\n   */\n  get HDREnabled() {\n    return this._hdrEnabled;\n  }\n  set HDREnabled(enabled) {\n    if (this._hdrEnabled === enabled) {\n      return;\n    }\n    this._hdrEnabled = enabled;\n    this._buildPipeline();\n  }\n  /**\n   * @ignore\n   * Specifies if the volumetric lights scattering effect is enabled\n   */\n  get VLSEnabled() {\n    return this._vlsEnabled;\n  }\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  set VLSEnabled(enabled) {\n    if (this._vlsEnabled === enabled) {\n      return;\n    }\n    if (enabled) {\n      const geometry = this._scene.enableGeometryBufferRenderer();\n      if (!geometry) {\n        Logger.Warn(\"Geometry renderer is not supported, cannot create volumetric lights in Standard Rendering Pipeline\");\n        return;\n      }\n    }\n    this._vlsEnabled = enabled;\n    this._buildPipeline();\n  }\n  /**\n   * @ignore\n   * Specifies if the motion blur effect is enabled\n   */\n  get MotionBlurEnabled() {\n    return this._motionBlurEnabled;\n  }\n  set MotionBlurEnabled(enabled) {\n    if (this._motionBlurEnabled === enabled) {\n      return;\n    }\n    this._motionBlurEnabled = enabled;\n    this._buildPipeline();\n  }\n  /**\n   * Specifies if anti-aliasing is enabled\n   */\n  get fxaaEnabled() {\n    return this._fxaaEnabled;\n  }\n  set fxaaEnabled(enabled) {\n    if (this._fxaaEnabled === enabled) {\n      return;\n    }\n    this._fxaaEnabled = enabled;\n    this._buildPipeline();\n  }\n  /**\n   * Specifies if screen space reflections are enabled.\n   */\n  get screenSpaceReflectionsEnabled() {\n    return this._screenSpaceReflectionsEnabled;\n  }\n  set screenSpaceReflectionsEnabled(enabled) {\n    if (this._screenSpaceReflectionsEnabled === enabled) {\n      return;\n    }\n    this._screenSpaceReflectionsEnabled = enabled;\n    this._buildPipeline();\n  }\n  /**\n   * Specifies the number of steps used to calculate the volumetric lights\n   * Typically in interval [50, 200]\n   */\n  get volumetricLightStepsCount() {\n    return this._volumetricLightStepsCount;\n  }\n  set volumetricLightStepsCount(count) {\n    if (this.volumetricLightPostProcess) {\n      this.volumetricLightPostProcess.updateEffect(\"#define VLS\\n#define NB_STEPS \" + count.toFixed(1));\n    }\n    this._volumetricLightStepsCount = count;\n  }\n  /**\n   * Specifies the number of samples used for the motion blur effect\n   * Typically in interval [16, 64]\n   */\n  get motionBlurSamples() {\n    return this._motionBlurSamples;\n  }\n  set motionBlurSamples(samples) {\n    if (this.motionBlurPostProcess) {\n      if (this._isObjectBasedMotionBlur) {\n        this.motionBlurPostProcess.motionBlurSamples = samples;\n      } else {\n        this.motionBlurPostProcess.updateEffect(\"#define MOTION_BLUR\\n#define MAX_MOTION_SAMPLES \" + samples.toFixed(1));\n      }\n    }\n    this._motionBlurSamples = samples;\n  }\n  /**\n   * Specifies MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)\n   */\n  get samples() {\n    return this._samples;\n  }\n  set samples(sampleCount) {\n    if (this._samples === sampleCount) {\n      return;\n    }\n    this._samples = sampleCount;\n    this._buildPipeline();\n  }\n  /**\n   * Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.\n   * @constructor\n   * @param name The rendering pipeline name\n   * @param scene The scene linked to this pipeline\n   * @param ratio The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)\n   * @param originalPostProcess the custom original color post-process. Must be \"reusable\". Can be null.\n   * @param cameras The array of cameras that the rendering pipeline will be attached to\n   */\n  constructor(name, scene, ratio, originalPostProcess = null, cameras) {\n    super(scene.getEngine(), name);\n    /**\n     * Post-process used to down scale an image x4\n     */\n    this.downSampleX4PostProcess = null;\n    /**\n     * Post-process used to calculate the illuminated surfaces controlled by a threshold\n     */\n    this.brightPassPostProcess = null;\n    /**\n     * Post-process array storing all the horizontal blur post-processes used by the pipeline\n     */\n    this.blurHPostProcesses = [];\n    /**\n     * Post-process array storing all the vertical blur post-processes used by the pipeline\n     */\n    this.blurVPostProcesses = [];\n    /**\n     * Post-process used to add colors of 2 textures (typically brightness + real scene color)\n     */\n    this.textureAdderPostProcess = null;\n    /**\n     * Post-process used to create volumetric lighting effect\n     */\n    this.volumetricLightPostProcess = null;\n    /**\n     * Post-process used to smooth the previous volumetric light post-process on the X axis\n     */\n    this.volumetricLightSmoothXPostProcess = null;\n    /**\n     * Post-process used to smooth the previous volumetric light post-process on the Y axis\n     */\n    this.volumetricLightSmoothYPostProcess = null;\n    /**\n     * Post-process used to merge the volumetric light effect and the real scene color\n     */\n    this.volumetricLightMergePostProces = null;\n    /**\n     * Post-process used to store the final volumetric light post-process (attach/detach for debug purpose)\n     */\n    this.volumetricLightFinalPostProcess = null;\n    /**\n     * Base post-process used to calculate the average luminance of the final image for HDR\n     */\n    this.luminancePostProcess = null;\n    /**\n     * Post-processes used to create down sample post-processes in order to get\n     * the average luminance of the final image for HDR\n     * Array of length \"StandardRenderingPipeline.LuminanceSteps\"\n     */\n    this.luminanceDownSamplePostProcesses = [];\n    /**\n     * Post-process used to create a HDR effect (light adaptation)\n     */\n    this.hdrPostProcess = null;\n    /**\n     * Post-process used to store the final texture adder post-process (attach/detach for debug purpose)\n     */\n    this.textureAdderFinalPostProcess = null;\n    /**\n     * Post-process used to store the final lens flare post-process (attach/detach for debug purpose)\n     */\n    this.lensFlareFinalPostProcess = null;\n    /**\n     * Post-process used to merge the final HDR post-process and the real scene color\n     */\n    this.hdrFinalPostProcess = null;\n    /**\n     * Post-process used to create a lens flare effect\n     */\n    this.lensFlarePostProcess = null;\n    /**\n     * Post-process that merges the result of the lens flare post-process and the real scene color\n     */\n    this.lensFlareComposePostProcess = null;\n    /**\n     * Post-process used to create a motion blur effect\n     */\n    this.motionBlurPostProcess = null;\n    /**\n     * Post-process used to create a depth of field effect\n     */\n    this.depthOfFieldPostProcess = null;\n    /**\n     * The Fast Approximate Anti-Aliasing post process which attempts to remove aliasing from an image.\n     */\n    this.fxaaPostProcess = null;\n    /**\n     * Post-process used to simulate realtime reflections using the screen space and geometry renderer.\n     */\n    this.screenSpaceReflectionPostProcess = null;\n    // Values\n    /**\n     * Represents the brightness threshold in order to configure the illuminated surfaces\n     */\n    this.brightThreshold = 1.0;\n    /**\n     * Configures the blur intensity used for surexposed surfaces are highlighted surfaces (light halo)\n     */\n    this.blurWidth = 512.0;\n    /**\n     * Sets if the blur for highlighted surfaces must be only horizontal\n     */\n    this.horizontalBlur = false;\n    /**\n     * Texture used typically to simulate \"dirty\" on camera lens\n     */\n    this.lensTexture = null;\n    /**\n     * Represents the offset coefficient based on Rayleigh principle. Typically in interval [-0.2, 0.2]\n     */\n    this.volumetricLightCoefficient = 0.2;\n    /**\n     * The overall power of volumetric lights, typically in interval [0, 10] maximum\n     */\n    this.volumetricLightPower = 4.0;\n    /**\n     * Used the set the blur intensity to smooth the volumetric lights\n     */\n    this.volumetricLightBlurScale = 64.0;\n    /**\n     * Light (spot or directional) used to generate the volumetric lights rays\n     * The source light must have a shadow generate so the pipeline can get its\n     * depth map\n     */\n    this.sourceLight = null;\n    /**\n     * For eye adaptation, represents the minimum luminance the eye can see\n     */\n    this.hdrMinimumLuminance = 1.0;\n    /**\n     * For eye adaptation, represents the decrease luminance speed\n     */\n    this.hdrDecreaseRate = 0.5;\n    /**\n     * For eye adaptation, represents the increase luminance speed\n     */\n    this.hdrIncreaseRate = 0.5;\n    /**\n     * Lens color texture used by the lens flare effect. Mandatory if lens flare effect enabled\n     */\n    this.lensColorTexture = null;\n    /**\n     * The overall strength for the lens flare effect\n     */\n    this.lensFlareStrength = 20.0;\n    /**\n     * Dispersion coefficient for lens flare ghosts\n     */\n    this.lensFlareGhostDispersal = 1.4;\n    /**\n     * Main lens flare halo width\n     */\n    this.lensFlareHaloWidth = 0.7;\n    /**\n     * Based on the lens distortion effect, defines how much the lens flare result\n     * is distorted\n     */\n    this.lensFlareDistortionStrength = 16.0;\n    /**\n     * Configures the blur intensity used for for lens flare (halo)\n     */\n    this.lensFlareBlurWidth = 512.0;\n    /**\n     * Lens star texture must be used to simulate rays on the flares and is available\n     * in the documentation\n     */\n    this.lensStarTexture = null;\n    /**\n     * As the \"lensTexture\" (can be the same texture or different), it is used to apply the lens\n     * flare effect by taking account of the dirt texture\n     */\n    this.lensFlareDirtTexture = null;\n    /**\n     * Represents the focal length for the depth of field effect\n     */\n    this.depthOfFieldDistance = 10.0;\n    /**\n     * Represents the blur intensity for the blurred part of the depth of field effect\n     */\n    this.depthOfFieldBlurWidth = 64.0;\n    /**\n     * List of animations for the pipeline (IAnimatable implementation)\n     */\n    this.animations = [];\n    this._currentDepthOfFieldSource = null;\n    this._fixedExposure = 1.0;\n    this._currentExposure = 1.0;\n    this._hdrAutoExposure = false;\n    this._hdrCurrentLuminance = 1.0;\n    this._motionStrength = 1.0;\n    this._isObjectBasedMotionBlur = false;\n    this._camerasToBeAttached = [];\n    // Getters and setters\n    this._bloomEnabled = false;\n    this._depthOfFieldEnabled = false;\n    this._vlsEnabled = false;\n    this._lensFlareEnabled = false;\n    this._hdrEnabled = false;\n    this._motionBlurEnabled = false;\n    this._fxaaEnabled = false;\n    this._screenSpaceReflectionsEnabled = false;\n    this._motionBlurSamples = 64.0;\n    this._volumetricLightStepsCount = 50.0;\n    this._samples = 1;\n    this._cameras = cameras || scene.cameras;\n    this._cameras = this._cameras.slice();\n    this._camerasToBeAttached = this._cameras.slice();\n    // Initialize\n    this._scene = scene;\n    this._basePostProcess = originalPostProcess;\n    this._ratio = ratio;\n    // Misc\n    this._floatTextureType = scene.getEngine().getCaps().textureFloatRender ? 1 : 2;\n    // Finish\n    scene.postProcessRenderPipelineManager.addPipeline(this);\n    this._buildPipeline();\n  }\n  _buildPipeline() {\n    const ratio = this._ratio;\n    const scene = this._scene;\n    this._disposePostProcesses();\n    if (this._cameras !== null) {\n      this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\n      // get back cameras to be used to reattach pipeline\n      this._cameras = this._camerasToBeAttached.slice();\n    }\n    this._reset();\n    // Create pass post-process\n    if (this._screenSpaceReflectionsEnabled) {\n      this.screenSpaceReflectionPostProcess = new ScreenSpaceReflectionPostProcess(\"HDRPass\", scene, ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, this._floatTextureType);\n      this.screenSpaceReflectionPostProcess.onApplyObservable.add(() => {\n        this._currentDepthOfFieldSource = this.screenSpaceReflectionPostProcess;\n      });\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRScreenSpaceReflections\", () => this.screenSpaceReflectionPostProcess, true));\n    }\n    if (!this._basePostProcess) {\n      this.originalPostProcess = new PostProcess(\"HDRPass\", \"standard\", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", this._floatTextureType);\n    } else {\n      this.originalPostProcess = this._basePostProcess;\n    }\n    this.originalPostProcess.autoClear = !this.screenSpaceReflectionPostProcess;\n    this.originalPostProcess.onApplyObservable.add(() => {\n      this._currentDepthOfFieldSource = this.originalPostProcess;\n    });\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRPassPostProcess\", () => this.originalPostProcess, true));\n    if (this._bloomEnabled) {\n      // Create down sample X4 post-process\n      this._createDownSampleX4PostProcess(scene, ratio / 4);\n      // Create bright pass post-process\n      this._createBrightPassPostProcess(scene, ratio / 4);\n      // Create gaussian blur post-processes (down sampling blurs)\n      this._createBlurPostProcesses(scene, ratio / 4, 1);\n      // Create texture adder post-process\n      this._createTextureAdderPostProcess(scene, ratio);\n      // Create depth-of-field source post-process\n      this.textureAdderFinalPostProcess = new PostProcess(\"HDRDepthOfFieldSource\", \"standard\", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", 0);\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRBaseDepthOfFieldSource\", () => {\n        return this.textureAdderFinalPostProcess;\n      }, true));\n    }\n    if (this._vlsEnabled) {\n      // Create volumetric light\n      this._createVolumetricLightPostProcess(scene, ratio);\n      // Create volumetric light final post-process\n      this.volumetricLightFinalPostProcess = new PostProcess(\"HDRVLSFinal\", \"standard\", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", 0);\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRVLSFinal\", () => {\n        return this.volumetricLightFinalPostProcess;\n      }, true));\n    }\n    if (this._lensFlareEnabled) {\n      // Create lens flare post-process\n      this._createLensFlarePostProcess(scene, ratio);\n      // Create depth-of-field source post-process post lens-flare and disable it now\n      this.lensFlareFinalPostProcess = new PostProcess(\"HDRPostLensFlareDepthOfFieldSource\", \"standard\", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", 0);\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRPostLensFlareDepthOfFieldSource\", () => {\n        return this.lensFlareFinalPostProcess;\n      }, true));\n    }\n    if (this._hdrEnabled) {\n      // Create luminance\n      this._createLuminancePostProcesses(scene, this._floatTextureType);\n      // Create HDR\n      this._createHdrPostProcess(scene, ratio);\n      // Create depth-of-field source post-process post hdr and disable it now\n      this.hdrFinalPostProcess = new PostProcess(\"HDRPostHDReDepthOfFieldSource\", \"standard\", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", 0);\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRPostHDReDepthOfFieldSource\", () => {\n        return this.hdrFinalPostProcess;\n      }, true));\n    }\n    if (this._depthOfFieldEnabled) {\n      // Create gaussian blur used by depth-of-field\n      this._createBlurPostProcesses(scene, ratio / 2, 3, \"depthOfFieldBlurWidth\");\n      // Create depth-of-field post-process\n      this._createDepthOfFieldPostProcess(scene, ratio);\n    }\n    if (this._motionBlurEnabled) {\n      // Create motion blur post-process\n      this._createMotionBlurPostProcess(scene, ratio);\n    }\n    if (this._fxaaEnabled) {\n      // Create fxaa post-process\n      this.fxaaPostProcess = new FxaaPostProcess(\"fxaa\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, 0);\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRFxaa\", () => {\n        return this.fxaaPostProcess;\n      }, true));\n    }\n    if (this._cameras !== null) {\n      this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);\n    }\n    if (!this._enableMSAAOnFirstPostProcess(this._samples) && this._samples > 1) {\n      Logger.Warn(\"MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0\");\n    }\n  }\n  // Down Sample X4 Post-Process\n  _createDownSampleX4PostProcess(scene, ratio) {\n    const downSampleX4Offsets = new Array(32);\n    this.downSampleX4PostProcess = new PostProcess(\"HDRDownSampleX4\", \"standard\", [\"dsOffsets\"], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define DOWN_SAMPLE_X4\", this._floatTextureType);\n    this.downSampleX4PostProcess.onApply = effect => {\n      let id = 0;\n      const width = this.downSampleX4PostProcess.width;\n      const height = this.downSampleX4PostProcess.height;\n      for (let i = -2; i < 2; i++) {\n        for (let j = -2; j < 2; j++) {\n          downSampleX4Offsets[id] = (i + 0.5) * (1.0 / width);\n          downSampleX4Offsets[id + 1] = (j + 0.5) * (1.0 / height);\n          id += 2;\n        }\n      }\n      effect.setArray2(\"dsOffsets\", downSampleX4Offsets);\n    };\n    // Add to pipeline\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRDownSampleX4\", () => {\n      return this.downSampleX4PostProcess;\n    }, true));\n  }\n  // Brightpass Post-Process\n  _createBrightPassPostProcess(scene, ratio) {\n    const brightOffsets = new Array(8);\n    this.brightPassPostProcess = new PostProcess(\"HDRBrightPass\", \"standard\", [\"dsOffsets\", \"brightThreshold\"], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define BRIGHT_PASS\", this._floatTextureType);\n    this.brightPassPostProcess.onApply = effect => {\n      const sU = 1.0 / this.brightPassPostProcess.width;\n      const sV = 1.0 / this.brightPassPostProcess.height;\n      brightOffsets[0] = -0.5 * sU;\n      brightOffsets[1] = 0.5 * sV;\n      brightOffsets[2] = 0.5 * sU;\n      brightOffsets[3] = 0.5 * sV;\n      brightOffsets[4] = -0.5 * sU;\n      brightOffsets[5] = -0.5 * sV;\n      brightOffsets[6] = 0.5 * sU;\n      brightOffsets[7] = -0.5 * sV;\n      effect.setArray2(\"dsOffsets\", brightOffsets);\n      effect.setFloat(\"brightThreshold\", this.brightThreshold);\n    };\n    // Add to pipeline\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRBrightPass\", () => {\n      return this.brightPassPostProcess;\n    }, true));\n  }\n  // Create blur H&V post-processes\n  _createBlurPostProcesses(scene, ratio, indice, blurWidthKey = \"blurWidth\") {\n    const engine = scene.getEngine();\n    const blurX = new BlurPostProcess(\"HDRBlurH\" + \"_\" + indice, new Vector2(1, 0), this[blurWidthKey], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, this._floatTextureType);\n    const blurY = new BlurPostProcess(\"HDRBlurV\" + \"_\" + indice, new Vector2(0, 1), this[blurWidthKey], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, this._floatTextureType);\n    blurX.onActivateObservable.add(() => {\n      const dw = blurX.width / engine.getRenderWidth();\n      blurX.kernel = this[blurWidthKey] * dw;\n    });\n    blurY.onActivateObservable.add(() => {\n      const dw = blurY.height / engine.getRenderHeight();\n      blurY.kernel = this.horizontalBlur ? 64 * dw : this[blurWidthKey] * dw;\n    });\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRBlurH\" + indice, () => {\n      return blurX;\n    }, true));\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRBlurV\" + indice, () => {\n      return blurY;\n    }, true));\n    this.blurHPostProcesses.push(blurX);\n    this.blurVPostProcesses.push(blurY);\n  }\n  // Create texture adder post-process\n  _createTextureAdderPostProcess(scene, ratio) {\n    this.textureAdderPostProcess = new PostProcess(\"HDRTextureAdder\", \"standard\", [\"exposure\"], [\"otherSampler\", \"lensSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define TEXTURE_ADDER\", this._floatTextureType);\n    this.textureAdderPostProcess.onApply = effect => {\n      effect.setTextureFromPostProcess(\"otherSampler\", this._vlsEnabled ? this._currentDepthOfFieldSource : this.originalPostProcess);\n      effect.setTexture(\"lensSampler\", this.lensTexture);\n      effect.setFloat(\"exposure\", this._currentExposure);\n      this._currentDepthOfFieldSource = this.textureAdderFinalPostProcess;\n    };\n    // Add to pipeline\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRTextureAdder\", () => {\n      return this.textureAdderPostProcess;\n    }, true));\n  }\n  _createVolumetricLightPostProcess(scene, ratio) {\n    const geometryRenderer = scene.enableGeometryBufferRenderer();\n    geometryRenderer.enablePosition = true;\n    const geometry = geometryRenderer.getGBuffer();\n    // Base post-process\n    this.volumetricLightPostProcess = new PostProcess(\"HDRVLS\", \"standard\", [\"shadowViewProjection\", \"cameraPosition\", \"sunDirection\", \"sunColor\", \"scatteringCoefficient\", \"scatteringPower\", \"depthValues\"], [\"shadowMapSampler\", \"positionSampler\"], ratio / 8, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define VLS\\n#define NB_STEPS \" + this._volumetricLightStepsCount.toFixed(1));\n    const depthValues = Vector2.Zero();\n    this.volumetricLightPostProcess.onApply = effect => {\n      if (this.sourceLight && this.sourceLight.getShadowGenerator() && this._scene.activeCamera) {\n        const generator = this.sourceLight.getShadowGenerator();\n        effect.setTexture(\"shadowMapSampler\", generator.getShadowMap());\n        effect.setTexture(\"positionSampler\", geometry.textures[2]);\n        effect.setColor3(\"sunColor\", this.sourceLight.diffuse);\n        effect.setVector3(\"sunDirection\", this.sourceLight.getShadowDirection());\n        effect.setVector3(\"cameraPosition\", this._scene.activeCamera.globalPosition);\n        effect.setMatrix(\"shadowViewProjection\", generator.getTransformMatrix());\n        effect.setFloat(\"scatteringCoefficient\", this.volumetricLightCoefficient);\n        effect.setFloat(\"scatteringPower\", this.volumetricLightPower);\n        depthValues.x = this.sourceLight.getDepthMinZ(this._scene.activeCamera);\n        depthValues.y = this.sourceLight.getDepthMaxZ(this._scene.activeCamera);\n        effect.setVector2(\"depthValues\", depthValues);\n      }\n    };\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRVLS\", () => {\n      return this.volumetricLightPostProcess;\n    }, true));\n    // Smooth\n    this._createBlurPostProcesses(scene, ratio / 4, 0, \"volumetricLightBlurScale\");\n    // Merge\n    this.volumetricLightMergePostProces = new PostProcess(\"HDRVLSMerge\", \"standard\", [], [\"originalSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define VLSMERGE\");\n    this.volumetricLightMergePostProces.onApply = effect => {\n      effect.setTextureFromPostProcess(\"originalSampler\", this._bloomEnabled ? this.textureAdderFinalPostProcess : this.originalPostProcess);\n      this._currentDepthOfFieldSource = this.volumetricLightFinalPostProcess;\n    };\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRVLSMerge\", () => {\n      return this.volumetricLightMergePostProces;\n    }, true));\n  }\n  // Create luminance\n  _createLuminancePostProcesses(scene, textureType) {\n    // Create luminance\n    let size = Math.pow(3, StandardRenderingPipeline.LuminanceSteps);\n    this.luminancePostProcess = new PostProcess(\"HDRLuminance\", \"standard\", [\"lumOffsets\"], [], {\n      width: size,\n      height: size\n    }, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define LUMINANCE\", textureType);\n    const offsets = [];\n    this.luminancePostProcess.onApply = effect => {\n      const sU = 1.0 / this.luminancePostProcess.width;\n      const sV = 1.0 / this.luminancePostProcess.height;\n      offsets[0] = -0.5 * sU;\n      offsets[1] = 0.5 * sV;\n      offsets[2] = 0.5 * sU;\n      offsets[3] = 0.5 * sV;\n      offsets[4] = -0.5 * sU;\n      offsets[5] = -0.5 * sV;\n      offsets[6] = 0.5 * sU;\n      offsets[7] = -0.5 * sV;\n      effect.setArray2(\"lumOffsets\", offsets);\n    };\n    // Add to pipeline\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRLuminance\", () => {\n      return this.luminancePostProcess;\n    }, true));\n    // Create down sample luminance\n    for (let i = StandardRenderingPipeline.LuminanceSteps - 1; i >= 0; i--) {\n      size = Math.pow(3, i);\n      let defines = \"#define LUMINANCE_DOWN_SAMPLE\\n\";\n      if (i === 0) {\n        defines += \"#define FINAL_DOWN_SAMPLER\";\n      }\n      const postProcess = new PostProcess(\"HDRLuminanceDownSample\" + i, \"standard\", [\"dsOffsets\", \"halfDestPixelSize\"], [], {\n        width: size,\n        height: size\n      }, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, defines, textureType);\n      this.luminanceDownSamplePostProcesses.push(postProcess);\n    }\n    // Create callbacks and add effects\n    let lastLuminance = this.luminancePostProcess;\n    this.luminanceDownSamplePostProcesses.forEach((pp, index) => {\n      const downSampleOffsets = new Array(18);\n      pp.onApply = effect => {\n        if (!lastLuminance) {\n          return;\n        }\n        let id = 0;\n        for (let x = -1; x < 2; x++) {\n          for (let y = -1; y < 2; y++) {\n            downSampleOffsets[id] = x / lastLuminance.width;\n            downSampleOffsets[id + 1] = y / lastLuminance.height;\n            id += 2;\n          }\n        }\n        effect.setArray2(\"dsOffsets\", downSampleOffsets);\n        effect.setFloat(\"halfDestPixelSize\", 0.5 / lastLuminance.width);\n        if (index === this.luminanceDownSamplePostProcesses.length - 1) {\n          lastLuminance = this.luminancePostProcess;\n        } else {\n          lastLuminance = pp;\n        }\n      };\n      if (index === this.luminanceDownSamplePostProcesses.length - 1) {\n        pp.onAfterRender = () => {\n          const pixel = scene.getEngine().readPixels(0, 0, 1, 1);\n          const bit_shift = new Vector4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\n          pixel.then(pixel => {\n            const data = new Uint8Array(pixel.buffer);\n            this._hdrCurrentLuminance = (data[0] * bit_shift.x + data[1] * bit_shift.y + data[2] * bit_shift.z + data[3] * bit_shift.w) / 100.0;\n          });\n        };\n      }\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRLuminanceDownSample\" + index, () => {\n        return pp;\n      }, true));\n    });\n  }\n  // Create HDR post-process\n  _createHdrPostProcess(scene, ratio) {\n    const defines = [\"#define HDR\"];\n    if (this._hdrAutoExposure) {\n      defines.push(\"#define AUTO_EXPOSURE\");\n    }\n    this.hdrPostProcess = new PostProcess(\"HDR\", \"standard\", [\"averageLuminance\"], [\"textureAdderSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, defines.join(\"\\n\"), 0);\n    let outputLiminance = 1;\n    let time = 0;\n    let lastTime = 0;\n    this.hdrPostProcess.onApply = effect => {\n      effect.setTextureFromPostProcess(\"textureAdderSampler\", this._currentDepthOfFieldSource);\n      time += scene.getEngine().getDeltaTime();\n      if (outputLiminance < 0) {\n        outputLiminance = this._hdrCurrentLuminance;\n      } else {\n        const dt = (lastTime - time) / 1000.0;\n        if (this._hdrCurrentLuminance < outputLiminance + this.hdrDecreaseRate * dt) {\n          outputLiminance += this.hdrDecreaseRate * dt;\n        } else if (this._hdrCurrentLuminance > outputLiminance - this.hdrIncreaseRate * dt) {\n          outputLiminance -= this.hdrIncreaseRate * dt;\n        } else {\n          outputLiminance = this._hdrCurrentLuminance;\n        }\n      }\n      if (this.hdrAutoExposure) {\n        this._currentExposure = this._fixedExposure / outputLiminance;\n      } else {\n        outputLiminance = Scalar.Clamp(outputLiminance, this.hdrMinimumLuminance, 1e20);\n        effect.setFloat(\"averageLuminance\", outputLiminance);\n      }\n      lastTime = time;\n      this._currentDepthOfFieldSource = this.hdrFinalPostProcess;\n    };\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDR\", () => {\n      return this.hdrPostProcess;\n    }, true));\n  }\n  // Create lens flare post-process\n  _createLensFlarePostProcess(scene, ratio) {\n    this.lensFlarePostProcess = new PostProcess(\"HDRLensFlare\", \"standard\", [\"strength\", \"ghostDispersal\", \"haloWidth\", \"resolution\", \"distortionStrength\"], [\"lensColorSampler\"], ratio / 2, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define LENS_FLARE\", 0);\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRLensFlare\", () => {\n      return this.lensFlarePostProcess;\n    }, true));\n    this._createBlurPostProcesses(scene, ratio / 4, 2, \"lensFlareBlurWidth\");\n    this.lensFlareComposePostProcess = new PostProcess(\"HDRLensFlareCompose\", \"standard\", [\"lensStarMatrix\"], [\"otherSampler\", \"lensDirtSampler\", \"lensStarSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define LENS_FLARE_COMPOSE\", 0);\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRLensFlareCompose\", () => {\n      return this.lensFlareComposePostProcess;\n    }, true));\n    const resolution = new Vector2(0, 0);\n    // Lens flare\n    this.lensFlarePostProcess.externalTextureSamplerBinding = true;\n    this.lensFlarePostProcess.onApply = effect => {\n      effect.setTextureFromPostProcess(\"textureSampler\", this._bloomEnabled ? this.blurHPostProcesses[0] : this.originalPostProcess);\n      effect.setTexture(\"lensColorSampler\", this.lensColorTexture);\n      effect.setFloat(\"strength\", this.lensFlareStrength);\n      effect.setFloat(\"ghostDispersal\", this.lensFlareGhostDispersal);\n      effect.setFloat(\"haloWidth\", this.lensFlareHaloWidth);\n      // Shift\n      resolution.x = this.lensFlarePostProcess.width;\n      resolution.y = this.lensFlarePostProcess.height;\n      effect.setVector2(\"resolution\", resolution);\n      effect.setFloat(\"distortionStrength\", this.lensFlareDistortionStrength);\n    };\n    // Compose\n    const scaleBias1 = Matrix.FromValues(2.0, 0.0, -1.0, 0.0, 0.0, 2.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n    const scaleBias2 = Matrix.FromValues(0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n    this.lensFlareComposePostProcess.onApply = effect => {\n      if (!this._scene.activeCamera) {\n        return;\n      }\n      effect.setTextureFromPostProcess(\"otherSampler\", this.lensFlarePostProcess);\n      effect.setTexture(\"lensDirtSampler\", this.lensFlareDirtTexture);\n      effect.setTexture(\"lensStarSampler\", this.lensStarTexture);\n      // Lens start rotation matrix\n      const camerax = this._scene.activeCamera.getViewMatrix().getRow(0);\n      const cameraz = this._scene.activeCamera.getViewMatrix().getRow(2);\n      let camRot = Vector3.Dot(camerax.toVector3(), new Vector3(1.0, 0.0, 0.0)) + Vector3.Dot(cameraz.toVector3(), new Vector3(0.0, 0.0, 1.0));\n      camRot *= 4.0;\n      const starRotation = Matrix.FromValues(Math.cos(camRot) * 0.5, -Math.sin(camRot), 0.0, 0.0, Math.sin(camRot), Math.cos(camRot) * 0.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n      const lensStarMatrix = scaleBias2.multiply(starRotation).multiply(scaleBias1);\n      effect.setMatrix(\"lensStarMatrix\", lensStarMatrix);\n      this._currentDepthOfFieldSource = this.lensFlareFinalPostProcess;\n    };\n  }\n  // Create depth-of-field post-process\n  _createDepthOfFieldPostProcess(scene, ratio) {\n    this.depthOfFieldPostProcess = new PostProcess(\"HDRDepthOfField\", \"standard\", [\"distance\"], [\"otherSampler\", \"depthSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define DEPTH_OF_FIELD\", 0);\n    this.depthOfFieldPostProcess.onApply = effect => {\n      effect.setTextureFromPostProcess(\"otherSampler\", this._currentDepthOfFieldSource);\n      effect.setTexture(\"depthSampler\", this._getDepthTexture());\n      effect.setFloat(\"distance\", this.depthOfFieldDistance);\n    };\n    // Add to pipeline\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRDepthOfField\", () => {\n      return this.depthOfFieldPostProcess;\n    }, true));\n  }\n  // Create motion blur post-process\n  _createMotionBlurPostProcess(scene, ratio) {\n    if (this._isObjectBasedMotionBlur) {\n      const mb = new MotionBlurPostProcess(\"HDRMotionBlur\", scene, ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, 0);\n      mb.motionStrength = this.motionStrength;\n      mb.motionBlurSamples = this.motionBlurSamples;\n      this.motionBlurPostProcess = mb;\n    } else {\n      this.motionBlurPostProcess = new PostProcess(\"HDRMotionBlur\", \"standard\", [\"inverseViewProjection\", \"prevViewProjection\", \"screenSize\", \"motionScale\", \"motionStrength\"], [\"depthSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define MOTION_BLUR\\n#define MAX_MOTION_SAMPLES \" + this.motionBlurSamples.toFixed(1), 0);\n      let motionScale = 0;\n      let prevViewProjection = Matrix.Identity();\n      const invViewProjection = Matrix.Identity();\n      let viewProjection = Matrix.Identity();\n      const screenSize = Vector2.Zero();\n      this.motionBlurPostProcess.onApply = effect => {\n        viewProjection = scene.getProjectionMatrix().multiply(scene.getViewMatrix());\n        viewProjection.invertToRef(invViewProjection);\n        effect.setMatrix(\"inverseViewProjection\", invViewProjection);\n        effect.setMatrix(\"prevViewProjection\", prevViewProjection);\n        prevViewProjection = viewProjection;\n        screenSize.x = this.motionBlurPostProcess.width;\n        screenSize.y = this.motionBlurPostProcess.height;\n        effect.setVector2(\"screenSize\", screenSize);\n        motionScale = scene.getEngine().getFps() / 60.0;\n        effect.setFloat(\"motionScale\", motionScale);\n        effect.setFloat(\"motionStrength\", this.motionStrength);\n        effect.setTexture(\"depthSampler\", this._getDepthTexture());\n      };\n    }\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRMotionBlur\", () => {\n      return this.motionBlurPostProcess;\n    }, true));\n  }\n  _getDepthTexture() {\n    if (this._scene.getEngine().getCaps().drawBuffersExtension) {\n      const renderer = this._scene.enableGeometryBufferRenderer();\n      return renderer.getGBuffer().textures[0];\n    }\n    return this._scene.enableDepthRenderer().getDepthMap();\n  }\n  _disposePostProcesses() {\n    for (let i = 0; i < this._cameras.length; i++) {\n      const camera = this._cameras[i];\n      if (this.originalPostProcess) {\n        this.originalPostProcess.dispose(camera);\n      }\n      if (this.screenSpaceReflectionPostProcess) {\n        this.screenSpaceReflectionPostProcess.dispose(camera);\n      }\n      if (this.downSampleX4PostProcess) {\n        this.downSampleX4PostProcess.dispose(camera);\n      }\n      if (this.brightPassPostProcess) {\n        this.brightPassPostProcess.dispose(camera);\n      }\n      if (this.textureAdderPostProcess) {\n        this.textureAdderPostProcess.dispose(camera);\n      }\n      if (this.volumetricLightPostProcess) {\n        this.volumetricLightPostProcess.dispose(camera);\n      }\n      if (this.volumetricLightSmoothXPostProcess) {\n        this.volumetricLightSmoothXPostProcess.dispose(camera);\n      }\n      if (this.volumetricLightSmoothYPostProcess) {\n        this.volumetricLightSmoothYPostProcess.dispose(camera);\n      }\n      if (this.volumetricLightMergePostProces) {\n        this.volumetricLightMergePostProces.dispose(camera);\n      }\n      if (this.volumetricLightFinalPostProcess) {\n        this.volumetricLightFinalPostProcess.dispose(camera);\n      }\n      if (this.lensFlarePostProcess) {\n        this.lensFlarePostProcess.dispose(camera);\n      }\n      if (this.lensFlareComposePostProcess) {\n        this.lensFlareComposePostProcess.dispose(camera);\n      }\n      for (let j = 0; j < this.luminanceDownSamplePostProcesses.length; j++) {\n        this.luminanceDownSamplePostProcesses[j].dispose(camera);\n      }\n      if (this.luminancePostProcess) {\n        this.luminancePostProcess.dispose(camera);\n      }\n      if (this.hdrPostProcess) {\n        this.hdrPostProcess.dispose(camera);\n      }\n      if (this.hdrFinalPostProcess) {\n        this.hdrFinalPostProcess.dispose(camera);\n      }\n      if (this.depthOfFieldPostProcess) {\n        this.depthOfFieldPostProcess.dispose(camera);\n      }\n      if (this.motionBlurPostProcess) {\n        this.motionBlurPostProcess.dispose(camera);\n      }\n      if (this.fxaaPostProcess) {\n        this.fxaaPostProcess.dispose(camera);\n      }\n      for (let j = 0; j < this.blurHPostProcesses.length; j++) {\n        this.blurHPostProcesses[j].dispose(camera);\n      }\n      for (let j = 0; j < this.blurVPostProcesses.length; j++) {\n        this.blurVPostProcesses[j].dispose(camera);\n      }\n    }\n    this.originalPostProcess = null;\n    this.downSampleX4PostProcess = null;\n    this.brightPassPostProcess = null;\n    this.textureAdderPostProcess = null;\n    this.textureAdderFinalPostProcess = null;\n    this.volumetricLightPostProcess = null;\n    this.volumetricLightSmoothXPostProcess = null;\n    this.volumetricLightSmoothYPostProcess = null;\n    this.volumetricLightMergePostProces = null;\n    this.volumetricLightFinalPostProcess = null;\n    this.lensFlarePostProcess = null;\n    this.lensFlareComposePostProcess = null;\n    this.luminancePostProcess = null;\n    this.hdrPostProcess = null;\n    this.hdrFinalPostProcess = null;\n    this.depthOfFieldPostProcess = null;\n    this.motionBlurPostProcess = null;\n    this.fxaaPostProcess = null;\n    this.screenSpaceReflectionPostProcess = null;\n    this.luminanceDownSamplePostProcesses.length = 0;\n    this.blurHPostProcesses.length = 0;\n    this.blurVPostProcesses.length = 0;\n  }\n  /**\n   * Dispose of the pipeline and stop all post processes\n   */\n  dispose() {\n    this._disposePostProcesses();\n    this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\n    super.dispose();\n  }\n  /**\n   * Serialize the rendering pipeline (Used when exporting)\n   * @returns the serialized object\n   */\n  serialize() {\n    const serializationObject = SerializationHelper.Serialize(this);\n    if (this.sourceLight) {\n      serializationObject.sourceLightId = this.sourceLight.id;\n    }\n    if (this.screenSpaceReflectionPostProcess) {\n      serializationObject.screenSpaceReflectionPostProcess = SerializationHelper.Serialize(this.screenSpaceReflectionPostProcess);\n    }\n    serializationObject.customType = \"StandardRenderingPipeline\";\n    return serializationObject;\n  }\n  /**\n   * Parse the serialized pipeline\n   * @param source Source pipeline.\n   * @param scene The scene to load the pipeline to.\n   * @param rootUrl The URL of the serialized pipeline.\n   * @returns An instantiated pipeline from the serialized object.\n   */\n  static Parse(source, scene, rootUrl) {\n    const p = SerializationHelper.Parse(() => new StandardRenderingPipeline(source._name, scene, source._ratio), source, scene, rootUrl);\n    if (source.sourceLightId) {\n      p.sourceLight = scene.getLightById(source.sourceLightId);\n    }\n    if (source.screenSpaceReflectionPostProcess) {\n      SerializationHelper.Parse(() => p.screenSpaceReflectionPostProcess, source.screenSpaceReflectionPostProcess, scene, rootUrl);\n    }\n    return p;\n  }\n}\n/**\n * Luminance steps\n */\nStandardRenderingPipeline.LuminanceSteps = 6;\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"brightThreshold\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"blurWidth\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"horizontalBlur\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"exposure\", null);\n__decorate([serializeAsTexture(\"lensTexture\")], StandardRenderingPipeline.prototype, \"lensTexture\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"volumetricLightCoefficient\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"volumetricLightPower\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"volumetricLightBlurScale\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"hdrMinimumLuminance\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"hdrDecreaseRate\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"hdrIncreaseRate\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"hdrAutoExposure\", null);\n__decorate([serializeAsTexture(\"lensColorTexture\")], StandardRenderingPipeline.prototype, \"lensColorTexture\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"lensFlareStrength\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"lensFlareGhostDispersal\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"lensFlareHaloWidth\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"lensFlareDistortionStrength\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"lensFlareBlurWidth\", void 0);\n__decorate([serializeAsTexture(\"lensStarTexture\")], StandardRenderingPipeline.prototype, \"lensStarTexture\", void 0);\n__decorate([serializeAsTexture(\"lensFlareDirtTexture\")], StandardRenderingPipeline.prototype, \"lensFlareDirtTexture\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"depthOfFieldDistance\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"depthOfFieldBlurWidth\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"motionStrength\", null);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"objectBasedMotionBlur\", null);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"_ratio\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"BloomEnabled\", null);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"DepthOfFieldEnabled\", null);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"LensFlareEnabled\", null);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"HDREnabled\", null);\n__decorate([serialize()\n// eslint-disable-next-line @typescript-eslint/naming-convention\n], StandardRenderingPipeline.prototype, \"VLSEnabled\", null);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"MotionBlurEnabled\", null);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"fxaaEnabled\", null);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"screenSpaceReflectionsEnabled\", null);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"volumetricLightStepsCount\", null);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"motionBlurSamples\", null);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"samples\", null);\nRegisterClass(\"BABYLON.StandardRenderingPipeline\", StandardRenderingPipeline);","map":{"version":3,"names":["serialize","serializeAsTexture","SerializationHelper","Logger","Vector2","Vector3","Matrix","Vector4","Scalar","Texture","PostProcess","PostProcessRenderPipeline","PostProcessRenderEffect","BlurPostProcess","FxaaPostProcess","RegisterClass","MotionBlurPostProcess","ScreenSpaceReflectionPostProcess","StandardRenderingPipeline","exposure","_fixedExposure","value","_currentExposure","hdrAutoExposure","_hdrAutoExposure","hdrPostProcess","defines","push","updateEffect","join","motionStrength","_motionStrength","strength","_isObjectBasedMotionBlur","motionBlurPostProcess","objectBasedMotionBlur","shouldRebuild","_buildPipeline","BloomEnabled","_bloomEnabled","enabled","DepthOfFieldEnabled","_depthOfFieldEnabled","LensFlareEnabled","_lensFlareEnabled","HDREnabled","_hdrEnabled","VLSEnabled","_vlsEnabled","geometry","_scene","enableGeometryBufferRenderer","Warn","MotionBlurEnabled","_motionBlurEnabled","fxaaEnabled","_fxaaEnabled","screenSpaceReflectionsEnabled","_screenSpaceReflectionsEnabled","volumetricLightStepsCount","_volumetricLightStepsCount","count","volumetricLightPostProcess","toFixed","motionBlurSamples","_motionBlurSamples","samples","_samples","sampleCount","constructor","name","scene","ratio","originalPostProcess","cameras","getEngine","downSampleX4PostProcess","brightPassPostProcess","blurHPostProcesses","blurVPostProcesses","textureAdderPostProcess","volumetricLightSmoothXPostProcess","volumetricLightSmoothYPostProcess","volumetricLightMergePostProces","volumetricLightFinalPostProcess","luminancePostProcess","luminanceDownSamplePostProcesses","textureAdderFinalPostProcess","lensFlareFinalPostProcess","hdrFinalPostProcess","lensFlarePostProcess","lensFlareComposePostProcess","depthOfFieldPostProcess","fxaaPostProcess","screenSpaceReflectionPostProcess","brightThreshold","blurWidth","horizontalBlur","lensTexture","volumetricLightCoefficient","volumetricLightPower","volumetricLightBlurScale","sourceLight","hdrMinimumLuminance","hdrDecreaseRate","hdrIncreaseRate","lensColorTexture","lensFlareStrength","lensFlareGhostDispersal","lensFlareHaloWidth","lensFlareDistortionStrength","lensFlareBlurWidth","lensStarTexture","lensFlareDirtTexture","depthOfFieldDistance","depthOfFieldBlurWidth","animations","_currentDepthOfFieldSource","_hdrCurrentLuminance","_camerasToBeAttached","_cameras","slice","_basePostProcess","_ratio","_floatTextureType","getCaps","textureFloatRender","postProcessRenderPipelineManager","addPipeline","_disposePostProcesses","detachCamerasFromRenderPipeline","_name","_reset","BILINEAR_SAMPLINGMODE","onApplyObservable","add","addEffect","autoClear","_createDownSampleX4PostProcess","_createBrightPassPostProcess","_createBlurPostProcesses","_createTextureAdderPostProcess","_createVolumetricLightPostProcess","_createLensFlarePostProcess","_createLuminancePostProcesses","_createHdrPostProcess","_createDepthOfFieldPostProcess","_createMotionBlurPostProcess","attachCamerasToRenderPipeline","_enableMSAAOnFirstPostProcess","downSampleX4Offsets","Array","onApply","effect","id","width","height","i","j","setArray2","brightOffsets","sU","sV","setFloat","indice","blurWidthKey","engine","blurX","blurY","onActivateObservable","dw","getRenderWidth","kernel","getRenderHeight","setTextureFromPostProcess","setTexture","geometryRenderer","enablePosition","getGBuffer","depthValues","Zero","getShadowGenerator","activeCamera","generator","getShadowMap","textures","setColor3","diffuse","setVector3","getShadowDirection","globalPosition","setMatrix","getTransformMatrix","x","getDepthMinZ","y","getDepthMaxZ","setVector2","textureType","size","Math","pow","LuminanceSteps","offsets","postProcess","lastLuminance","forEach","pp","index","downSampleOffsets","length","onAfterRender","pixel","readPixels","bit_shift","then","data","Uint8Array","buffer","z","w","outputLiminance","time","lastTime","getDeltaTime","dt","Clamp","resolution","externalTextureSamplerBinding","scaleBias1","FromValues","scaleBias2","camerax","getViewMatrix","getRow","cameraz","camRot","Dot","toVector3","starRotation","cos","sin","lensStarMatrix","multiply","_getDepthTexture","mb","motionScale","prevViewProjection","Identity","invViewProjection","viewProjection","screenSize","getProjectionMatrix","invertToRef","getFps","drawBuffersExtension","renderer","enableDepthRenderer","getDepthMap","camera","dispose","serializationObject","Serialize","sourceLightId","customType","Parse","source","rootUrl","p","getLightById","__decorate"],"sources":["../../../../../../dev/core/src/PostProcesses/RenderPipeline/Pipelines/standardRenderingPipeline.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../../types\";\r\nimport { serialize, serializeAsTexture, SerializationHelper } from \"../../../Misc/decorators\";\r\nimport type { IAnimatable } from \"../../../Animations/animatable.interface\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport { Vector2, Vector3, Matrix, Vector4 } from \"../../../Maths/math.vector\";\r\nimport { Scalar } from \"../../../Maths/math.scalar\";\r\nimport type { Camera } from \"../../../Cameras/camera\";\r\nimport type { Effect } from \"../../../Materials/effect\";\r\nimport { Texture } from \"../../../Materials/Textures/texture\";\r\nimport { PostProcess } from \"../../../PostProcesses/postProcess\";\r\nimport { PostProcessRenderPipeline } from \"../../../PostProcesses/RenderPipeline/postProcessRenderPipeline\";\r\nimport { PostProcessRenderEffect } from \"../../../PostProcesses/RenderPipeline/postProcessRenderEffect\";\r\nimport { BlurPostProcess } from \"../../../PostProcesses/blurPostProcess\";\r\nimport { FxaaPostProcess } from \"../../../PostProcesses/fxaaPostProcess\";\r\nimport type { IDisposable, Scene } from \"../../../scene\";\r\nimport type { SpotLight } from \"../../../Lights/spotLight\";\r\nimport type { DirectionalLight } from \"../../../Lights/directionalLight\";\r\nimport type { GeometryBufferRenderer } from \"../../../Rendering/geometryBufferRenderer\";\r\n\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { MotionBlurPostProcess } from \"../../motionBlurPostProcess\";\r\nimport { ScreenSpaceReflectionPostProcess } from \"../../screenSpaceReflectionPostProcess\";\r\n\r\nimport type { Animation } from \"../../../Animations/animation\";\r\n\r\nimport \"../../../PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent\";\r\n\r\nimport \"../../../Shaders/standard.fragment\";\r\n/**\r\n * Standard rendering pipeline\r\n * Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/standardRenderingPipeline\r\n */\r\nexport class StandardRenderingPipeline extends PostProcessRenderPipeline implements IDisposable, IAnimatable {\r\n    /**\r\n     * Public members\r\n     */\r\n    // Post-processes\r\n    /**\r\n     * Post-process which contains the original scene color before the pipeline applies all the effects\r\n     */\r\n    public originalPostProcess: Nullable<PostProcess>;\r\n    /**\r\n     * Post-process used to down scale an image x4\r\n     */\r\n    public downSampleX4PostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to calculate the illuminated surfaces controlled by a threshold\r\n     */\r\n    public brightPassPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process array storing all the horizontal blur post-processes used by the pipeline\r\n     */\r\n    public blurHPostProcesses: PostProcess[] = [];\r\n    /**\r\n     * Post-process array storing all the vertical blur post-processes used by the pipeline\r\n     */\r\n    public blurVPostProcesses: PostProcess[] = [];\r\n    /**\r\n     * Post-process used to add colors of 2 textures (typically brightness + real scene color)\r\n     */\r\n    public textureAdderPostProcess: Nullable<PostProcess> = null;\r\n\r\n    /**\r\n     * Post-process used to create volumetric lighting effect\r\n     */\r\n    public volumetricLightPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to smooth the previous volumetric light post-process on the X axis\r\n     */\r\n    public volumetricLightSmoothXPostProcess: Nullable<BlurPostProcess> = null;\r\n    /**\r\n     * Post-process used to smooth the previous volumetric light post-process on the Y axis\r\n     */\r\n    public volumetricLightSmoothYPostProcess: Nullable<BlurPostProcess> = null;\r\n    /**\r\n     * Post-process used to merge the volumetric light effect and the real scene color\r\n     */\r\n    public volumetricLightMergePostProces: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to store the final volumetric light post-process (attach/detach for debug purpose)\r\n     */\r\n    public volumetricLightFinalPostProcess: Nullable<PostProcess> = null;\r\n\r\n    /**\r\n     * Base post-process used to calculate the average luminance of the final image for HDR\r\n     */\r\n    public luminancePostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-processes used to create down sample post-processes in order to get\r\n     * the average luminance of the final image for HDR\r\n     * Array of length \"StandardRenderingPipeline.LuminanceSteps\"\r\n     */\r\n    public luminanceDownSamplePostProcesses: PostProcess[] = [];\r\n    /**\r\n     * Post-process used to create a HDR effect (light adaptation)\r\n     */\r\n    public hdrPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to store the final texture adder post-process (attach/detach for debug purpose)\r\n     */\r\n    public textureAdderFinalPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to store the final lens flare post-process (attach/detach for debug purpose)\r\n     */\r\n    public lensFlareFinalPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to merge the final HDR post-process and the real scene color\r\n     */\r\n    public hdrFinalPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to create a lens flare effect\r\n     */\r\n    public lensFlarePostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process that merges the result of the lens flare post-process and the real scene color\r\n     */\r\n    public lensFlareComposePostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to create a motion blur effect\r\n     */\r\n    public motionBlurPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to create a depth of field effect\r\n     */\r\n    public depthOfFieldPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * The Fast Approximate Anti-Aliasing post process which attempts to remove aliasing from an image.\r\n     */\r\n    public fxaaPostProcess: Nullable<FxaaPostProcess> = null;\r\n    /**\r\n     * Post-process used to simulate realtime reflections using the screen space and geometry renderer.\r\n     */\r\n    public screenSpaceReflectionPostProcess: Nullable<ScreenSpaceReflectionPostProcess> = null;\r\n\r\n    // Values\r\n\r\n    /**\r\n     * Represents the brightness threshold in order to configure the illuminated surfaces\r\n     */\r\n    @serialize()\r\n    public brightThreshold: number = 1.0;\r\n\r\n    /**\r\n     * Configures the blur intensity used for surexposed surfaces are highlighted surfaces (light halo)\r\n     */\r\n    @serialize()\r\n    public blurWidth: number = 512.0;\r\n    /**\r\n     * Sets if the blur for highlighted surfaces must be only horizontal\r\n     */\r\n    @serialize()\r\n    public horizontalBlur: boolean = false;\r\n\r\n    /**\r\n     * Gets the overall exposure used by the pipeline\r\n     */\r\n    @serialize()\r\n    public get exposure(): number {\r\n        return this._fixedExposure;\r\n    }\r\n    /**\r\n     * Sets the overall exposure used by the pipeline\r\n     */\r\n    public set exposure(value: number) {\r\n        this._fixedExposure = value;\r\n        this._currentExposure = value;\r\n    }\r\n\r\n    /**\r\n     * Texture used typically to simulate \"dirty\" on camera lens\r\n     */\r\n    @serializeAsTexture(\"lensTexture\")\r\n    public lensTexture: Nullable<Texture> = null;\r\n\r\n    /**\r\n     * Represents the offset coefficient based on Rayleigh principle. Typically in interval [-0.2, 0.2]\r\n     */\r\n    @serialize()\r\n    public volumetricLightCoefficient: number = 0.2;\r\n    /**\r\n     * The overall power of volumetric lights, typically in interval [0, 10] maximum\r\n     */\r\n    @serialize()\r\n    public volumetricLightPower: number = 4.0;\r\n    /**\r\n     * Used the set the blur intensity to smooth the volumetric lights\r\n     */\r\n    @serialize()\r\n    public volumetricLightBlurScale: number = 64.0;\r\n    /**\r\n     * Light (spot or directional) used to generate the volumetric lights rays\r\n     * The source light must have a shadow generate so the pipeline can get its\r\n     * depth map\r\n     */\r\n    public sourceLight: Nullable<SpotLight | DirectionalLight> = null;\r\n\r\n    /**\r\n     * For eye adaptation, represents the minimum luminance the eye can see\r\n     */\r\n    @serialize()\r\n    public hdrMinimumLuminance: number = 1.0;\r\n    /**\r\n     * For eye adaptation, represents the decrease luminance speed\r\n     */\r\n    @serialize()\r\n    public hdrDecreaseRate: number = 0.5;\r\n    /**\r\n     * For eye adaptation, represents the increase luminance speed\r\n     */\r\n    @serialize()\r\n    public hdrIncreaseRate: number = 0.5;\r\n    /**\r\n     * Gets whether or not the exposure of the overall pipeline should be automatically adjusted by the HDR post-process\r\n     */\r\n    @serialize()\r\n    public get hdrAutoExposure(): boolean {\r\n        return this._hdrAutoExposure;\r\n    }\r\n    /**\r\n     * Sets whether or not the exposure of the overall pipeline should be automatically adjusted by the HDR post-process\r\n     */\r\n    public set hdrAutoExposure(value: boolean) {\r\n        this._hdrAutoExposure = value;\r\n        if (this.hdrPostProcess) {\r\n            const defines = [\"#define HDR\"];\r\n            if (value) {\r\n                defines.push(\"#define AUTO_EXPOSURE\");\r\n            }\r\n            this.hdrPostProcess.updateEffect(defines.join(\"\\n\"));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Lens color texture used by the lens flare effect. Mandatory if lens flare effect enabled\r\n     */\r\n    @serializeAsTexture(\"lensColorTexture\")\r\n    public lensColorTexture: Nullable<Texture> = null;\r\n    /**\r\n     * The overall strength for the lens flare effect\r\n     */\r\n    @serialize()\r\n    public lensFlareStrength: number = 20.0;\r\n    /**\r\n     * Dispersion coefficient for lens flare ghosts\r\n     */\r\n    @serialize()\r\n    public lensFlareGhostDispersal: number = 1.4;\r\n    /**\r\n     * Main lens flare halo width\r\n     */\r\n    @serialize()\r\n    public lensFlareHaloWidth: number = 0.7;\r\n    /**\r\n     * Based on the lens distortion effect, defines how much the lens flare result\r\n     * is distorted\r\n     */\r\n    @serialize()\r\n    public lensFlareDistortionStrength: number = 16.0;\r\n    /**\r\n     * Configures the blur intensity used for for lens flare (halo)\r\n     */\r\n    @serialize()\r\n    public lensFlareBlurWidth: number = 512.0;\r\n    /**\r\n     * Lens star texture must be used to simulate rays on the flares and is available\r\n     * in the documentation\r\n     */\r\n    @serializeAsTexture(\"lensStarTexture\")\r\n    public lensStarTexture: Nullable<Texture> = null;\r\n    /**\r\n     * As the \"lensTexture\" (can be the same texture or different), it is used to apply the lens\r\n     * flare effect by taking account of the dirt texture\r\n     */\r\n    @serializeAsTexture(\"lensFlareDirtTexture\")\r\n    public lensFlareDirtTexture: Nullable<Texture> = null;\r\n\r\n    /**\r\n     * Represents the focal length for the depth of field effect\r\n     */\r\n    @serialize()\r\n    public depthOfFieldDistance: number = 10.0;\r\n    /**\r\n     * Represents the blur intensity for the blurred part of the depth of field effect\r\n     */\r\n    @serialize()\r\n    public depthOfFieldBlurWidth: number = 64.0;\r\n\r\n    /**\r\n     * Gets how much the image is blurred by the movement while using the motion blur post-process\r\n     */\r\n    @serialize()\r\n    public get motionStrength(): number {\r\n        return this._motionStrength;\r\n    }\r\n    /**\r\n     * Sets how much the image is blurred by the movement while using the motion blur post-process\r\n     */\r\n    public set motionStrength(strength: number) {\r\n        this._motionStrength = strength;\r\n\r\n        if (this._isObjectBasedMotionBlur && this.motionBlurPostProcess) {\r\n            (this.motionBlurPostProcess as MotionBlurPostProcess).motionStrength = strength;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets whether or not the motion blur post-process is object based or screen based.\r\n     */\r\n    @serialize()\r\n    public get objectBasedMotionBlur(): boolean {\r\n        return this._isObjectBasedMotionBlur;\r\n    }\r\n    /**\r\n     * Sets whether or not the motion blur post-process should be object based or screen based\r\n     */\r\n    public set objectBasedMotionBlur(value: boolean) {\r\n        const shouldRebuild = this._isObjectBasedMotionBlur !== value;\r\n        this._isObjectBasedMotionBlur = value;\r\n\r\n        if (shouldRebuild) {\r\n            this._buildPipeline();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * List of animations for the pipeline (IAnimatable implementation)\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    /**\r\n     * Private members\r\n     */\r\n    private _scene: Scene;\r\n    private _currentDepthOfFieldSource: Nullable<PostProcess> = null;\r\n    private _basePostProcess: Nullable<PostProcess>;\r\n\r\n    private _fixedExposure: number = 1.0;\r\n    private _currentExposure: number = 1.0;\r\n    private _hdrAutoExposure: boolean = false;\r\n    private _hdrCurrentLuminance: number = 1.0;\r\n    private _motionStrength: number = 1.0;\r\n    private _isObjectBasedMotionBlur: boolean = false;\r\n\r\n    private _floatTextureType: number;\r\n\r\n    private _camerasToBeAttached: Array<Camera> = [];\r\n\r\n    @serialize()\r\n    private _ratio: number;\r\n\r\n    // Getters and setters\r\n    private _bloomEnabled: boolean = false;\r\n    private _depthOfFieldEnabled: boolean = false;\r\n    private _vlsEnabled: boolean = false;\r\n    private _lensFlareEnabled: boolean = false;\r\n    private _hdrEnabled: boolean = false;\r\n    private _motionBlurEnabled: boolean = false;\r\n    private _fxaaEnabled: boolean = false;\r\n    private _screenSpaceReflectionsEnabled: boolean = false;\r\n\r\n    private _motionBlurSamples: number = 64.0;\r\n    private _volumetricLightStepsCount: number = 50.0;\r\n    private _samples: number = 1;\r\n\r\n    /**\r\n     * @ignore\r\n     * Specifies if the bloom pipeline is enabled\r\n     */\r\n    @serialize()\r\n    public get BloomEnabled(): boolean {\r\n        return this._bloomEnabled;\r\n    }\r\n\r\n    public set BloomEnabled(enabled: boolean) {\r\n        if (this._bloomEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._bloomEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Specifies if the depth of field pipeline is enabled\r\n     */\r\n    @serialize()\r\n    public get DepthOfFieldEnabled(): boolean {\r\n        return this._depthOfFieldEnabled;\r\n    }\r\n\r\n    public set DepthOfFieldEnabled(enabled: boolean) {\r\n        if (this._depthOfFieldEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._depthOfFieldEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Specifies if the lens flare pipeline is enabled\r\n     */\r\n    @serialize()\r\n    public get LensFlareEnabled(): boolean {\r\n        return this._lensFlareEnabled;\r\n    }\r\n\r\n    public set LensFlareEnabled(enabled: boolean) {\r\n        if (this._lensFlareEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._lensFlareEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Specifies if the HDR pipeline is enabled\r\n     */\r\n    @serialize()\r\n    public get HDREnabled(): boolean {\r\n        return this._hdrEnabled;\r\n    }\r\n\r\n    public set HDREnabled(enabled: boolean) {\r\n        if (this._hdrEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._hdrEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Specifies if the volumetric lights scattering effect is enabled\r\n     */\r\n    @serialize()\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get VLSEnabled(): boolean {\r\n        return this._vlsEnabled;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public set VLSEnabled(enabled) {\r\n        if (this._vlsEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        if (enabled) {\r\n            const geometry = this._scene.enableGeometryBufferRenderer();\r\n            if (!geometry) {\r\n                Logger.Warn(\"Geometry renderer is not supported, cannot create volumetric lights in Standard Rendering Pipeline\");\r\n                return;\r\n            }\r\n        }\r\n\r\n        this._vlsEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Specifies if the motion blur effect is enabled\r\n     */\r\n    @serialize()\r\n    public get MotionBlurEnabled(): boolean {\r\n        return this._motionBlurEnabled;\r\n    }\r\n\r\n    public set MotionBlurEnabled(enabled: boolean) {\r\n        if (this._motionBlurEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._motionBlurEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Specifies if anti-aliasing is enabled\r\n     */\r\n    @serialize()\r\n    public get fxaaEnabled(): boolean {\r\n        return this._fxaaEnabled;\r\n    }\r\n\r\n    public set fxaaEnabled(enabled: boolean) {\r\n        if (this._fxaaEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._fxaaEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Specifies if screen space reflections are enabled.\r\n     */\r\n    @serialize()\r\n    public get screenSpaceReflectionsEnabled(): boolean {\r\n        return this._screenSpaceReflectionsEnabled;\r\n    }\r\n\r\n    public set screenSpaceReflectionsEnabled(enabled: boolean) {\r\n        if (this._screenSpaceReflectionsEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._screenSpaceReflectionsEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Specifies the number of steps used to calculate the volumetric lights\r\n     * Typically in interval [50, 200]\r\n     */\r\n    @serialize()\r\n    public get volumetricLightStepsCount(): number {\r\n        return this._volumetricLightStepsCount;\r\n    }\r\n\r\n    public set volumetricLightStepsCount(count: number) {\r\n        if (this.volumetricLightPostProcess) {\r\n            this.volumetricLightPostProcess.updateEffect(\"#define VLS\\n#define NB_STEPS \" + count.toFixed(1));\r\n        }\r\n\r\n        this._volumetricLightStepsCount = count;\r\n    }\r\n\r\n    /**\r\n     * Specifies the number of samples used for the motion blur effect\r\n     * Typically in interval [16, 64]\r\n     */\r\n    @serialize()\r\n    public get motionBlurSamples(): number {\r\n        return this._motionBlurSamples;\r\n    }\r\n\r\n    public set motionBlurSamples(samples: number) {\r\n        if (this.motionBlurPostProcess) {\r\n            if (this._isObjectBasedMotionBlur) {\r\n                (this.motionBlurPostProcess as MotionBlurPostProcess).motionBlurSamples = samples;\r\n            } else {\r\n                this.motionBlurPostProcess.updateEffect(\"#define MOTION_BLUR\\n#define MAX_MOTION_SAMPLES \" + samples.toFixed(1));\r\n            }\r\n        }\r\n\r\n        this._motionBlurSamples = samples;\r\n    }\r\n\r\n    /**\r\n     * Specifies MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)\r\n     */\r\n    @serialize()\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    public set samples(sampleCount: number) {\r\n        if (this._samples === sampleCount) {\r\n            return;\r\n        }\r\n\r\n        this._samples = sampleCount;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.\r\n     * @constructor\r\n     * @param name The rendering pipeline name\r\n     * @param scene The scene linked to this pipeline\r\n     * @param ratio The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)\r\n     * @param originalPostProcess the custom original color post-process. Must be \"reusable\". Can be null.\r\n     * @param cameras The array of cameras that the rendering pipeline will be attached to\r\n     */\r\n    constructor(name: string, scene: Scene, ratio: number, originalPostProcess: Nullable<PostProcess> = null, cameras?: Camera[]) {\r\n        super(scene.getEngine(), name);\r\n        this._cameras = cameras || scene.cameras;\r\n        this._cameras = this._cameras.slice();\r\n        this._camerasToBeAttached = this._cameras.slice();\r\n\r\n        // Initialize\r\n        this._scene = scene;\r\n        this._basePostProcess = originalPostProcess;\r\n        this._ratio = ratio;\r\n\r\n        // Misc\r\n        this._floatTextureType = scene.getEngine().getCaps().textureFloatRender ? Constants.TEXTURETYPE_FLOAT : Constants.TEXTURETYPE_HALF_FLOAT;\r\n\r\n        // Finish\r\n        scene.postProcessRenderPipelineManager.addPipeline(this);\r\n        this._buildPipeline();\r\n    }\r\n\r\n    private _buildPipeline(): void {\r\n        const ratio = this._ratio;\r\n        const scene = this._scene;\r\n\r\n        this._disposePostProcesses();\r\n        if (this._cameras !== null) {\r\n            this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\r\n            // get back cameras to be used to reattach pipeline\r\n            this._cameras = this._camerasToBeAttached.slice();\r\n        }\r\n        this._reset();\r\n\r\n        // Create pass post-process\r\n        if (this._screenSpaceReflectionsEnabled) {\r\n            this.screenSpaceReflectionPostProcess = new ScreenSpaceReflectionPostProcess(\r\n                \"HDRPass\",\r\n                scene,\r\n                ratio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                scene.getEngine(),\r\n                false,\r\n                this._floatTextureType\r\n            );\r\n            this.screenSpaceReflectionPostProcess.onApplyObservable.add(() => {\r\n                this._currentDepthOfFieldSource = this.screenSpaceReflectionPostProcess;\r\n            });\r\n            this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRScreenSpaceReflections\", () => this.screenSpaceReflectionPostProcess, true));\r\n        }\r\n\r\n        if (!this._basePostProcess) {\r\n            this.originalPostProcess = new PostProcess(\r\n                \"HDRPass\",\r\n                \"standard\",\r\n                [],\r\n                [],\r\n                ratio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                scene.getEngine(),\r\n                false,\r\n                \"#define PASS_POST_PROCESS\",\r\n                this._floatTextureType\r\n            );\r\n        } else {\r\n            this.originalPostProcess = this._basePostProcess;\r\n        }\r\n\r\n        this.originalPostProcess.autoClear = !this.screenSpaceReflectionPostProcess;\r\n        this.originalPostProcess.onApplyObservable.add(() => {\r\n            this._currentDepthOfFieldSource = this.originalPostProcess;\r\n        });\r\n\r\n        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRPassPostProcess\", () => this.originalPostProcess, true));\r\n\r\n        if (this._bloomEnabled) {\r\n            // Create down sample X4 post-process\r\n            this._createDownSampleX4PostProcess(scene, ratio / 4);\r\n\r\n            // Create bright pass post-process\r\n            this._createBrightPassPostProcess(scene, ratio / 4);\r\n\r\n            // Create gaussian blur post-processes (down sampling blurs)\r\n            this._createBlurPostProcesses(scene, ratio / 4, 1);\r\n\r\n            // Create texture adder post-process\r\n            this._createTextureAdderPostProcess(scene, ratio);\r\n\r\n            // Create depth-of-field source post-process\r\n            this.textureAdderFinalPostProcess = new PostProcess(\r\n                \"HDRDepthOfFieldSource\",\r\n                \"standard\",\r\n                [],\r\n                [],\r\n                ratio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                scene.getEngine(),\r\n                false,\r\n                \"#define PASS_POST_PROCESS\",\r\n                Constants.TEXTURETYPE_UNSIGNED_INT\r\n            );\r\n            this.addEffect(\r\n                new PostProcessRenderEffect(\r\n                    scene.getEngine(),\r\n                    \"HDRBaseDepthOfFieldSource\",\r\n                    () => {\r\n                        return this.textureAdderFinalPostProcess;\r\n                    },\r\n                    true\r\n                )\r\n            );\r\n        }\r\n\r\n        if (this._vlsEnabled) {\r\n            // Create volumetric light\r\n            this._createVolumetricLightPostProcess(scene, ratio);\r\n\r\n            // Create volumetric light final post-process\r\n            this.volumetricLightFinalPostProcess = new PostProcess(\r\n                \"HDRVLSFinal\",\r\n                \"standard\",\r\n                [],\r\n                [],\r\n                ratio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                scene.getEngine(),\r\n                false,\r\n                \"#define PASS_POST_PROCESS\",\r\n                Constants.TEXTURETYPE_UNSIGNED_INT\r\n            );\r\n            this.addEffect(\r\n                new PostProcessRenderEffect(\r\n                    scene.getEngine(),\r\n                    \"HDRVLSFinal\",\r\n                    () => {\r\n                        return this.volumetricLightFinalPostProcess;\r\n                    },\r\n                    true\r\n                )\r\n            );\r\n        }\r\n\r\n        if (this._lensFlareEnabled) {\r\n            // Create lens flare post-process\r\n            this._createLensFlarePostProcess(scene, ratio);\r\n\r\n            // Create depth-of-field source post-process post lens-flare and disable it now\r\n            this.lensFlareFinalPostProcess = new PostProcess(\r\n                \"HDRPostLensFlareDepthOfFieldSource\",\r\n                \"standard\",\r\n                [],\r\n                [],\r\n                ratio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                scene.getEngine(),\r\n                false,\r\n                \"#define PASS_POST_PROCESS\",\r\n                Constants.TEXTURETYPE_UNSIGNED_INT\r\n            );\r\n            this.addEffect(\r\n                new PostProcessRenderEffect(\r\n                    scene.getEngine(),\r\n                    \"HDRPostLensFlareDepthOfFieldSource\",\r\n                    () => {\r\n                        return this.lensFlareFinalPostProcess;\r\n                    },\r\n                    true\r\n                )\r\n            );\r\n        }\r\n\r\n        if (this._hdrEnabled) {\r\n            // Create luminance\r\n            this._createLuminancePostProcesses(scene, this._floatTextureType);\r\n\r\n            // Create HDR\r\n            this._createHdrPostProcess(scene, ratio);\r\n\r\n            // Create depth-of-field source post-process post hdr and disable it now\r\n            this.hdrFinalPostProcess = new PostProcess(\r\n                \"HDRPostHDReDepthOfFieldSource\",\r\n                \"standard\",\r\n                [],\r\n                [],\r\n                ratio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                scene.getEngine(),\r\n                false,\r\n                \"#define PASS_POST_PROCESS\",\r\n                Constants.TEXTURETYPE_UNSIGNED_INT\r\n            );\r\n            this.addEffect(\r\n                new PostProcessRenderEffect(\r\n                    scene.getEngine(),\r\n                    \"HDRPostHDReDepthOfFieldSource\",\r\n                    () => {\r\n                        return this.hdrFinalPostProcess;\r\n                    },\r\n                    true\r\n                )\r\n            );\r\n        }\r\n\r\n        if (this._depthOfFieldEnabled) {\r\n            // Create gaussian blur used by depth-of-field\r\n            this._createBlurPostProcesses(scene, ratio / 2, 3, \"depthOfFieldBlurWidth\");\r\n\r\n            // Create depth-of-field post-process\r\n            this._createDepthOfFieldPostProcess(scene, ratio);\r\n        }\r\n\r\n        if (this._motionBlurEnabled) {\r\n            // Create motion blur post-process\r\n            this._createMotionBlurPostProcess(scene, ratio);\r\n        }\r\n\r\n        if (this._fxaaEnabled) {\r\n            // Create fxaa post-process\r\n            this.fxaaPostProcess = new FxaaPostProcess(\"fxaa\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, Constants.TEXTURETYPE_UNSIGNED_INT);\r\n            this.addEffect(\r\n                new PostProcessRenderEffect(\r\n                    scene.getEngine(),\r\n                    \"HDRFxaa\",\r\n                    () => {\r\n                        return this.fxaaPostProcess;\r\n                    },\r\n                    true\r\n                )\r\n            );\r\n        }\r\n\r\n        if (this._cameras !== null) {\r\n            this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);\r\n        }\r\n\r\n        if (!this._enableMSAAOnFirstPostProcess(this._samples) && this._samples > 1) {\r\n            Logger.Warn(\"MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0\");\r\n        }\r\n    }\r\n\r\n    // Down Sample X4 Post-Process\r\n    private _createDownSampleX4PostProcess(scene: Scene, ratio: number): void {\r\n        const downSampleX4Offsets = new Array<number>(32);\r\n        this.downSampleX4PostProcess = new PostProcess(\r\n            \"HDRDownSampleX4\",\r\n            \"standard\",\r\n            [\"dsOffsets\"],\r\n            [],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define DOWN_SAMPLE_X4\",\r\n            this._floatTextureType\r\n        );\r\n\r\n        this.downSampleX4PostProcess.onApply = (effect: Effect) => {\r\n            let id = 0;\r\n            const width = (<PostProcess>this.downSampleX4PostProcess).width;\r\n            const height = (<PostProcess>this.downSampleX4PostProcess).height;\r\n\r\n            for (let i = -2; i < 2; i++) {\r\n                for (let j = -2; j < 2; j++) {\r\n                    downSampleX4Offsets[id] = (i + 0.5) * (1.0 / width);\r\n                    downSampleX4Offsets[id + 1] = (j + 0.5) * (1.0 / height);\r\n                    id += 2;\r\n                }\r\n            }\r\n\r\n            effect.setArray2(\"dsOffsets\", downSampleX4Offsets);\r\n        };\r\n\r\n        // Add to pipeline\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRDownSampleX4\",\r\n                () => {\r\n                    return this.downSampleX4PostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n    }\r\n\r\n    // Brightpass Post-Process\r\n    private _createBrightPassPostProcess(scene: Scene, ratio: number): void {\r\n        const brightOffsets = new Array<number>(8);\r\n        this.brightPassPostProcess = new PostProcess(\r\n            \"HDRBrightPass\",\r\n            \"standard\",\r\n            [\"dsOffsets\", \"brightThreshold\"],\r\n            [],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define BRIGHT_PASS\",\r\n            this._floatTextureType\r\n        );\r\n\r\n        this.brightPassPostProcess.onApply = (effect: Effect) => {\r\n            const sU = 1.0 / (<PostProcess>this.brightPassPostProcess).width;\r\n            const sV = 1.0 / (<PostProcess>this.brightPassPostProcess).height;\r\n\r\n            brightOffsets[0] = -0.5 * sU;\r\n            brightOffsets[1] = 0.5 * sV;\r\n            brightOffsets[2] = 0.5 * sU;\r\n            brightOffsets[3] = 0.5 * sV;\r\n            brightOffsets[4] = -0.5 * sU;\r\n            brightOffsets[5] = -0.5 * sV;\r\n            brightOffsets[6] = 0.5 * sU;\r\n            brightOffsets[7] = -0.5 * sV;\r\n\r\n            effect.setArray2(\"dsOffsets\", brightOffsets);\r\n            effect.setFloat(\"brightThreshold\", this.brightThreshold);\r\n        };\r\n\r\n        // Add to pipeline\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRBrightPass\",\r\n                () => {\r\n                    return this.brightPassPostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n    }\r\n\r\n    // Create blur H&V post-processes\r\n    private _createBlurPostProcesses(scene: Scene, ratio: number, indice: number, blurWidthKey: string = \"blurWidth\"): void {\r\n        const engine = scene.getEngine();\r\n\r\n        const blurX = new BlurPostProcess(\r\n            \"HDRBlurH\" + \"_\" + indice,\r\n            new Vector2(1, 0),\r\n            (<any>this)[blurWidthKey],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            this._floatTextureType\r\n        );\r\n        const blurY = new BlurPostProcess(\r\n            \"HDRBlurV\" + \"_\" + indice,\r\n            new Vector2(0, 1),\r\n            (<any>this)[blurWidthKey],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            this._floatTextureType\r\n        );\r\n\r\n        blurX.onActivateObservable.add(() => {\r\n            const dw = blurX.width / engine.getRenderWidth();\r\n            blurX.kernel = (<any>this)[blurWidthKey] * dw;\r\n        });\r\n\r\n        blurY.onActivateObservable.add(() => {\r\n            const dw = blurY.height / engine.getRenderHeight();\r\n            blurY.kernel = this.horizontalBlur ? 64 * dw : (<any>this)[blurWidthKey] * dw;\r\n        });\r\n\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRBlurH\" + indice,\r\n                () => {\r\n                    return blurX;\r\n                },\r\n                true\r\n            )\r\n        );\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRBlurV\" + indice,\r\n                () => {\r\n                    return blurY;\r\n                },\r\n                true\r\n            )\r\n        );\r\n\r\n        this.blurHPostProcesses.push(blurX);\r\n        this.blurVPostProcesses.push(blurY);\r\n    }\r\n\r\n    // Create texture adder post-process\r\n    private _createTextureAdderPostProcess(scene: Scene, ratio: number): void {\r\n        this.textureAdderPostProcess = new PostProcess(\r\n            \"HDRTextureAdder\",\r\n            \"standard\",\r\n            [\"exposure\"],\r\n            [\"otherSampler\", \"lensSampler\"],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define TEXTURE_ADDER\",\r\n            this._floatTextureType\r\n        );\r\n        this.textureAdderPostProcess.onApply = (effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"otherSampler\", this._vlsEnabled ? this._currentDepthOfFieldSource : this.originalPostProcess);\r\n            effect.setTexture(\"lensSampler\", this.lensTexture);\r\n\r\n            effect.setFloat(\"exposure\", this._currentExposure);\r\n\r\n            this._currentDepthOfFieldSource = this.textureAdderFinalPostProcess;\r\n        };\r\n\r\n        // Add to pipeline\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRTextureAdder\",\r\n                () => {\r\n                    return this.textureAdderPostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n    }\r\n\r\n    private _createVolumetricLightPostProcess(scene: Scene, ratio: number): void {\r\n        const geometryRenderer = <GeometryBufferRenderer>scene.enableGeometryBufferRenderer();\r\n        geometryRenderer.enablePosition = true;\r\n\r\n        const geometry = geometryRenderer.getGBuffer();\r\n\r\n        // Base post-process\r\n        this.volumetricLightPostProcess = new PostProcess(\r\n            \"HDRVLS\",\r\n            \"standard\",\r\n            [\"shadowViewProjection\", \"cameraPosition\", \"sunDirection\", \"sunColor\", \"scatteringCoefficient\", \"scatteringPower\", \"depthValues\"],\r\n            [\"shadowMapSampler\", \"positionSampler\"],\r\n            ratio / 8,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define VLS\\n#define NB_STEPS \" + this._volumetricLightStepsCount.toFixed(1)\r\n        );\r\n\r\n        const depthValues = Vector2.Zero();\r\n\r\n        this.volumetricLightPostProcess.onApply = (effect: Effect) => {\r\n            if (this.sourceLight && this.sourceLight.getShadowGenerator() && this._scene.activeCamera) {\r\n                const generator = this.sourceLight.getShadowGenerator()!;\r\n\r\n                effect.setTexture(\"shadowMapSampler\", generator.getShadowMap());\r\n                effect.setTexture(\"positionSampler\", geometry.textures[2]);\r\n\r\n                effect.setColor3(\"sunColor\", this.sourceLight.diffuse);\r\n                effect.setVector3(\"sunDirection\", this.sourceLight.getShadowDirection());\r\n\r\n                effect.setVector3(\"cameraPosition\", this._scene.activeCamera.globalPosition);\r\n                effect.setMatrix(\"shadowViewProjection\", generator.getTransformMatrix());\r\n\r\n                effect.setFloat(\"scatteringCoefficient\", this.volumetricLightCoefficient);\r\n                effect.setFloat(\"scatteringPower\", this.volumetricLightPower);\r\n\r\n                depthValues.x = this.sourceLight.getDepthMinZ(this._scene.activeCamera);\r\n                depthValues.y = this.sourceLight.getDepthMaxZ(this._scene.activeCamera);\r\n                effect.setVector2(\"depthValues\", depthValues);\r\n            }\r\n        };\r\n\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRVLS\",\r\n                () => {\r\n                    return this.volumetricLightPostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n\r\n        // Smooth\r\n        this._createBlurPostProcesses(scene, ratio / 4, 0, \"volumetricLightBlurScale\");\r\n\r\n        // Merge\r\n        this.volumetricLightMergePostProces = new PostProcess(\r\n            \"HDRVLSMerge\",\r\n            \"standard\",\r\n            [],\r\n            [\"originalSampler\"],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define VLSMERGE\"\r\n        );\r\n\r\n        this.volumetricLightMergePostProces.onApply = (effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"originalSampler\", this._bloomEnabled ? this.textureAdderFinalPostProcess : this.originalPostProcess);\r\n\r\n            this._currentDepthOfFieldSource = this.volumetricLightFinalPostProcess;\r\n        };\r\n\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRVLSMerge\",\r\n                () => {\r\n                    return this.volumetricLightMergePostProces;\r\n                },\r\n                true\r\n            )\r\n        );\r\n    }\r\n\r\n    // Create luminance\r\n    private _createLuminancePostProcesses(scene: Scene, textureType: number): void {\r\n        // Create luminance\r\n        let size = Math.pow(3, StandardRenderingPipeline.LuminanceSteps);\r\n        this.luminancePostProcess = new PostProcess(\r\n            \"HDRLuminance\",\r\n            \"standard\",\r\n            [\"lumOffsets\"],\r\n            [],\r\n            { width: size, height: size },\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define LUMINANCE\",\r\n            textureType\r\n        );\r\n\r\n        const offsets: number[] = [];\r\n        this.luminancePostProcess.onApply = (effect: Effect) => {\r\n            const sU = 1.0 / (<PostProcess>this.luminancePostProcess).width;\r\n            const sV = 1.0 / (<PostProcess>this.luminancePostProcess).height;\r\n\r\n            offsets[0] = -0.5 * sU;\r\n            offsets[1] = 0.5 * sV;\r\n            offsets[2] = 0.5 * sU;\r\n            offsets[3] = 0.5 * sV;\r\n            offsets[4] = -0.5 * sU;\r\n            offsets[5] = -0.5 * sV;\r\n            offsets[6] = 0.5 * sU;\r\n            offsets[7] = -0.5 * sV;\r\n\r\n            effect.setArray2(\"lumOffsets\", offsets);\r\n        };\r\n\r\n        // Add to pipeline\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRLuminance\",\r\n                () => {\r\n                    return this.luminancePostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n\r\n        // Create down sample luminance\r\n        for (let i = StandardRenderingPipeline.LuminanceSteps - 1; i >= 0; i--) {\r\n            size = Math.pow(3, i);\r\n\r\n            let defines = \"#define LUMINANCE_DOWN_SAMPLE\\n\";\r\n            if (i === 0) {\r\n                defines += \"#define FINAL_DOWN_SAMPLER\";\r\n            }\r\n\r\n            const postProcess = new PostProcess(\r\n                \"HDRLuminanceDownSample\" + i,\r\n                \"standard\",\r\n                [\"dsOffsets\", \"halfDestPixelSize\"],\r\n                [],\r\n                { width: size, height: size },\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                scene.getEngine(),\r\n                false,\r\n                defines,\r\n                textureType\r\n            );\r\n            this.luminanceDownSamplePostProcesses.push(postProcess);\r\n        }\r\n\r\n        // Create callbacks and add effects\r\n        let lastLuminance: Nullable<PostProcess> = this.luminancePostProcess;\r\n\r\n        this.luminanceDownSamplePostProcesses.forEach((pp, index) => {\r\n            const downSampleOffsets = new Array<number>(18);\r\n\r\n            pp.onApply = (effect: Effect) => {\r\n                if (!lastLuminance) {\r\n                    return;\r\n                }\r\n\r\n                let id = 0;\r\n                for (let x = -1; x < 2; x++) {\r\n                    for (let y = -1; y < 2; y++) {\r\n                        downSampleOffsets[id] = x / lastLuminance.width;\r\n                        downSampleOffsets[id + 1] = y / lastLuminance.height;\r\n                        id += 2;\r\n                    }\r\n                }\r\n\r\n                effect.setArray2(\"dsOffsets\", downSampleOffsets);\r\n                effect.setFloat(\"halfDestPixelSize\", 0.5 / lastLuminance.width);\r\n\r\n                if (index === this.luminanceDownSamplePostProcesses.length - 1) {\r\n                    lastLuminance = this.luminancePostProcess;\r\n                } else {\r\n                    lastLuminance = pp;\r\n                }\r\n            };\r\n\r\n            if (index === this.luminanceDownSamplePostProcesses.length - 1) {\r\n                pp.onAfterRender = () => {\r\n                    const pixel = scene.getEngine().readPixels(0, 0, 1, 1);\r\n                    const bit_shift = new Vector4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\r\n                    pixel.then((pixel) => {\r\n                        const data = new Uint8Array(pixel.buffer);\r\n                        this._hdrCurrentLuminance = (data[0] * bit_shift.x + data[1] * bit_shift.y + data[2] * bit_shift.z + data[3] * bit_shift.w) / 100.0;\r\n                    });\r\n                };\r\n            }\r\n\r\n            this.addEffect(\r\n                new PostProcessRenderEffect(\r\n                    scene.getEngine(),\r\n                    \"HDRLuminanceDownSample\" + index,\r\n                    () => {\r\n                        return pp;\r\n                    },\r\n                    true\r\n                )\r\n            );\r\n        });\r\n    }\r\n\r\n    // Create HDR post-process\r\n    private _createHdrPostProcess(scene: Scene, ratio: number): void {\r\n        const defines = [\"#define HDR\"];\r\n        if (this._hdrAutoExposure) {\r\n            defines.push(\"#define AUTO_EXPOSURE\");\r\n        }\r\n        this.hdrPostProcess = new PostProcess(\r\n            \"HDR\",\r\n            \"standard\",\r\n            [\"averageLuminance\"],\r\n            [\"textureAdderSampler\"],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            defines.join(\"\\n\"),\r\n            Constants.TEXTURETYPE_UNSIGNED_INT\r\n        );\r\n\r\n        let outputLiminance = 1;\r\n        let time = 0;\r\n        let lastTime = 0;\r\n\r\n        this.hdrPostProcess.onApply = (effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"textureAdderSampler\", this._currentDepthOfFieldSource);\r\n\r\n            time += scene.getEngine().getDeltaTime();\r\n\r\n            if (outputLiminance < 0) {\r\n                outputLiminance = this._hdrCurrentLuminance;\r\n            } else {\r\n                const dt = (lastTime - time) / 1000.0;\r\n\r\n                if (this._hdrCurrentLuminance < outputLiminance + this.hdrDecreaseRate * dt) {\r\n                    outputLiminance += this.hdrDecreaseRate * dt;\r\n                } else if (this._hdrCurrentLuminance > outputLiminance - this.hdrIncreaseRate * dt) {\r\n                    outputLiminance -= this.hdrIncreaseRate * dt;\r\n                } else {\r\n                    outputLiminance = this._hdrCurrentLuminance;\r\n                }\r\n            }\r\n\r\n            if (this.hdrAutoExposure) {\r\n                this._currentExposure = this._fixedExposure / outputLiminance;\r\n            } else {\r\n                outputLiminance = Scalar.Clamp(outputLiminance, this.hdrMinimumLuminance, 1e20);\r\n                effect.setFloat(\"averageLuminance\", outputLiminance);\r\n            }\r\n\r\n            lastTime = time;\r\n\r\n            this._currentDepthOfFieldSource = this.hdrFinalPostProcess;\r\n        };\r\n\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDR\",\r\n                () => {\r\n                    return this.hdrPostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n    }\r\n\r\n    // Create lens flare post-process\r\n    private _createLensFlarePostProcess(scene: Scene, ratio: number): void {\r\n        this.lensFlarePostProcess = new PostProcess(\r\n            \"HDRLensFlare\",\r\n            \"standard\",\r\n            [\"strength\", \"ghostDispersal\", \"haloWidth\", \"resolution\", \"distortionStrength\"],\r\n            [\"lensColorSampler\"],\r\n            ratio / 2,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define LENS_FLARE\",\r\n            Constants.TEXTURETYPE_UNSIGNED_INT\r\n        );\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRLensFlare\",\r\n                () => {\r\n                    return this.lensFlarePostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n\r\n        this._createBlurPostProcesses(scene, ratio / 4, 2, \"lensFlareBlurWidth\");\r\n\r\n        this.lensFlareComposePostProcess = new PostProcess(\r\n            \"HDRLensFlareCompose\",\r\n            \"standard\",\r\n            [\"lensStarMatrix\"],\r\n            [\"otherSampler\", \"lensDirtSampler\", \"lensStarSampler\"],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define LENS_FLARE_COMPOSE\",\r\n            Constants.TEXTURETYPE_UNSIGNED_INT\r\n        );\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRLensFlareCompose\",\r\n                () => {\r\n                    return this.lensFlareComposePostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n\r\n        const resolution = new Vector2(0, 0);\r\n\r\n        // Lens flare\r\n        this.lensFlarePostProcess.externalTextureSamplerBinding = true;\r\n        this.lensFlarePostProcess.onApply = (effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"textureSampler\", this._bloomEnabled ? this.blurHPostProcesses[0] : this.originalPostProcess);\r\n            effect.setTexture(\"lensColorSampler\", this.lensColorTexture);\r\n            effect.setFloat(\"strength\", this.lensFlareStrength);\r\n            effect.setFloat(\"ghostDispersal\", this.lensFlareGhostDispersal);\r\n            effect.setFloat(\"haloWidth\", this.lensFlareHaloWidth);\r\n\r\n            // Shift\r\n            resolution.x = (<PostProcess>this.lensFlarePostProcess).width;\r\n            resolution.y = (<PostProcess>this.lensFlarePostProcess).height;\r\n            effect.setVector2(\"resolution\", resolution);\r\n\r\n            effect.setFloat(\"distortionStrength\", this.lensFlareDistortionStrength);\r\n        };\r\n\r\n        // Compose\r\n        const scaleBias1 = Matrix.FromValues(2.0, 0.0, -1.0, 0.0, 0.0, 2.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\r\n\r\n        const scaleBias2 = Matrix.FromValues(0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\r\n\r\n        this.lensFlareComposePostProcess.onApply = (effect: Effect) => {\r\n            if (!this._scene.activeCamera) {\r\n                return;\r\n            }\r\n\r\n            effect.setTextureFromPostProcess(\"otherSampler\", this.lensFlarePostProcess);\r\n            effect.setTexture(\"lensDirtSampler\", this.lensFlareDirtTexture);\r\n            effect.setTexture(\"lensStarSampler\", this.lensStarTexture);\r\n\r\n            // Lens start rotation matrix\r\n            const camerax = <Vector4>this._scene.activeCamera.getViewMatrix().getRow(0);\r\n            const cameraz = <Vector4>this._scene.activeCamera.getViewMatrix().getRow(2);\r\n            let camRot = Vector3.Dot(camerax.toVector3(), new Vector3(1.0, 0.0, 0.0)) + Vector3.Dot(cameraz.toVector3(), new Vector3(0.0, 0.0, 1.0));\r\n            camRot *= 4.0;\r\n\r\n            const starRotation = Matrix.FromValues(\r\n                Math.cos(camRot) * 0.5,\r\n                -Math.sin(camRot),\r\n                0.0,\r\n                0.0,\r\n                Math.sin(camRot),\r\n                Math.cos(camRot) * 0.5,\r\n                0.0,\r\n                0.0,\r\n                0.0,\r\n                0.0,\r\n                1.0,\r\n                0.0,\r\n                0.0,\r\n                0.0,\r\n                0.0,\r\n                1.0\r\n            );\r\n\r\n            const lensStarMatrix = scaleBias2.multiply(starRotation).multiply(scaleBias1);\r\n\r\n            effect.setMatrix(\"lensStarMatrix\", lensStarMatrix);\r\n\r\n            this._currentDepthOfFieldSource = this.lensFlareFinalPostProcess;\r\n        };\r\n    }\r\n\r\n    // Create depth-of-field post-process\r\n    private _createDepthOfFieldPostProcess(scene: Scene, ratio: number): void {\r\n        this.depthOfFieldPostProcess = new PostProcess(\r\n            \"HDRDepthOfField\",\r\n            \"standard\",\r\n            [\"distance\"],\r\n            [\"otherSampler\", \"depthSampler\"],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define DEPTH_OF_FIELD\",\r\n            Constants.TEXTURETYPE_UNSIGNED_INT\r\n        );\r\n        this.depthOfFieldPostProcess.onApply = (effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"otherSampler\", this._currentDepthOfFieldSource);\r\n            effect.setTexture(\"depthSampler\", this._getDepthTexture());\r\n\r\n            effect.setFloat(\"distance\", this.depthOfFieldDistance);\r\n        };\r\n\r\n        // Add to pipeline\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRDepthOfField\",\r\n                () => {\r\n                    return this.depthOfFieldPostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n    }\r\n\r\n    // Create motion blur post-process\r\n    private _createMotionBlurPostProcess(scene: Scene, ratio: number): void {\r\n        if (this._isObjectBasedMotionBlur) {\r\n            const mb = new MotionBlurPostProcess(\"HDRMotionBlur\", scene, ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, Constants.TEXTURETYPE_UNSIGNED_INT);\r\n            mb.motionStrength = this.motionStrength;\r\n            mb.motionBlurSamples = this.motionBlurSamples;\r\n            this.motionBlurPostProcess = mb;\r\n        } else {\r\n            this.motionBlurPostProcess = new PostProcess(\r\n                \"HDRMotionBlur\",\r\n                \"standard\",\r\n                [\"inverseViewProjection\", \"prevViewProjection\", \"screenSize\", \"motionScale\", \"motionStrength\"],\r\n                [\"depthSampler\"],\r\n                ratio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                scene.getEngine(),\r\n                false,\r\n                \"#define MOTION_BLUR\\n#define MAX_MOTION_SAMPLES \" + this.motionBlurSamples.toFixed(1),\r\n                Constants.TEXTURETYPE_UNSIGNED_INT\r\n            );\r\n\r\n            let motionScale: number = 0;\r\n            let prevViewProjection = Matrix.Identity();\r\n            const invViewProjection = Matrix.Identity();\r\n            let viewProjection = Matrix.Identity();\r\n            const screenSize = Vector2.Zero();\r\n\r\n            this.motionBlurPostProcess.onApply = (effect: Effect) => {\r\n                viewProjection = scene.getProjectionMatrix().multiply(scene.getViewMatrix());\r\n\r\n                viewProjection.invertToRef(invViewProjection);\r\n                effect.setMatrix(\"inverseViewProjection\", invViewProjection);\r\n\r\n                effect.setMatrix(\"prevViewProjection\", prevViewProjection);\r\n                prevViewProjection = viewProjection;\r\n\r\n                screenSize.x = (<PostProcess>this.motionBlurPostProcess).width;\r\n                screenSize.y = (<PostProcess>this.motionBlurPostProcess).height;\r\n                effect.setVector2(\"screenSize\", screenSize);\r\n\r\n                motionScale = scene.getEngine().getFps() / 60.0;\r\n                effect.setFloat(\"motionScale\", motionScale);\r\n                effect.setFloat(\"motionStrength\", this.motionStrength);\r\n\r\n                effect.setTexture(\"depthSampler\", this._getDepthTexture());\r\n            };\r\n        }\r\n\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRMotionBlur\",\r\n                () => {\r\n                    return this.motionBlurPostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n    }\r\n\r\n    private _getDepthTexture(): Texture {\r\n        if (this._scene.getEngine().getCaps().drawBuffersExtension) {\r\n            const renderer = <GeometryBufferRenderer>this._scene.enableGeometryBufferRenderer();\r\n            return renderer.getGBuffer().textures[0];\r\n        }\r\n\r\n        return this._scene.enableDepthRenderer().getDepthMap();\r\n    }\r\n\r\n    private _disposePostProcesses(): void {\r\n        for (let i = 0; i < this._cameras.length; i++) {\r\n            const camera = this._cameras[i];\r\n\r\n            if (this.originalPostProcess) {\r\n                this.originalPostProcess.dispose(camera);\r\n            }\r\n            if (this.screenSpaceReflectionPostProcess) {\r\n                this.screenSpaceReflectionPostProcess.dispose(camera);\r\n            }\r\n\r\n            if (this.downSampleX4PostProcess) {\r\n                this.downSampleX4PostProcess.dispose(camera);\r\n            }\r\n            if (this.brightPassPostProcess) {\r\n                this.brightPassPostProcess.dispose(camera);\r\n            }\r\n            if (this.textureAdderPostProcess) {\r\n                this.textureAdderPostProcess.dispose(camera);\r\n            }\r\n\r\n            if (this.volumetricLightPostProcess) {\r\n                this.volumetricLightPostProcess.dispose(camera);\r\n            }\r\n            if (this.volumetricLightSmoothXPostProcess) {\r\n                this.volumetricLightSmoothXPostProcess.dispose(camera);\r\n            }\r\n            if (this.volumetricLightSmoothYPostProcess) {\r\n                this.volumetricLightSmoothYPostProcess.dispose(camera);\r\n            }\r\n            if (this.volumetricLightMergePostProces) {\r\n                this.volumetricLightMergePostProces.dispose(camera);\r\n            }\r\n            if (this.volumetricLightFinalPostProcess) {\r\n                this.volumetricLightFinalPostProcess.dispose(camera);\r\n            }\r\n\r\n            if (this.lensFlarePostProcess) {\r\n                this.lensFlarePostProcess.dispose(camera);\r\n            }\r\n            if (this.lensFlareComposePostProcess) {\r\n                this.lensFlareComposePostProcess.dispose(camera);\r\n            }\r\n\r\n            for (let j = 0; j < this.luminanceDownSamplePostProcesses.length; j++) {\r\n                this.luminanceDownSamplePostProcesses[j].dispose(camera);\r\n            }\r\n\r\n            if (this.luminancePostProcess) {\r\n                this.luminancePostProcess.dispose(camera);\r\n            }\r\n            if (this.hdrPostProcess) {\r\n                this.hdrPostProcess.dispose(camera);\r\n            }\r\n            if (this.hdrFinalPostProcess) {\r\n                this.hdrFinalPostProcess.dispose(camera);\r\n            }\r\n\r\n            if (this.depthOfFieldPostProcess) {\r\n                this.depthOfFieldPostProcess.dispose(camera);\r\n            }\r\n\r\n            if (this.motionBlurPostProcess) {\r\n                this.motionBlurPostProcess.dispose(camera);\r\n            }\r\n\r\n            if (this.fxaaPostProcess) {\r\n                this.fxaaPostProcess.dispose(camera);\r\n            }\r\n\r\n            for (let j = 0; j < this.blurHPostProcesses.length; j++) {\r\n                this.blurHPostProcesses[j].dispose(camera);\r\n            }\r\n\r\n            for (let j = 0; j < this.blurVPostProcesses.length; j++) {\r\n                this.blurVPostProcesses[j].dispose(camera);\r\n            }\r\n        }\r\n\r\n        this.originalPostProcess = null;\r\n        this.downSampleX4PostProcess = null;\r\n        this.brightPassPostProcess = null;\r\n        this.textureAdderPostProcess = null;\r\n        this.textureAdderFinalPostProcess = null;\r\n        this.volumetricLightPostProcess = null;\r\n        this.volumetricLightSmoothXPostProcess = null;\r\n        this.volumetricLightSmoothYPostProcess = null;\r\n        this.volumetricLightMergePostProces = null;\r\n        this.volumetricLightFinalPostProcess = null;\r\n        this.lensFlarePostProcess = null;\r\n        this.lensFlareComposePostProcess = null;\r\n        this.luminancePostProcess = null;\r\n        this.hdrPostProcess = null;\r\n        this.hdrFinalPostProcess = null;\r\n        this.depthOfFieldPostProcess = null;\r\n        this.motionBlurPostProcess = null;\r\n        this.fxaaPostProcess = null;\r\n        this.screenSpaceReflectionPostProcess = null;\r\n\r\n        this.luminanceDownSamplePostProcesses.length = 0;\r\n        this.blurHPostProcesses.length = 0;\r\n        this.blurVPostProcesses.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Dispose of the pipeline and stop all post processes\r\n     */\r\n    public dispose(): void {\r\n        this._disposePostProcesses();\r\n\r\n        this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Serialize the rendering pipeline (Used when exporting)\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        if (this.sourceLight) {\r\n            serializationObject.sourceLightId = this.sourceLight.id;\r\n        }\r\n\r\n        if (this.screenSpaceReflectionPostProcess) {\r\n            serializationObject.screenSpaceReflectionPostProcess = SerializationHelper.Serialize(this.screenSpaceReflectionPostProcess);\r\n        }\r\n\r\n        serializationObject.customType = \"StandardRenderingPipeline\";\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse the serialized pipeline\r\n     * @param source Source pipeline.\r\n     * @param scene The scene to load the pipeline to.\r\n     * @param rootUrl The URL of the serialized pipeline.\r\n     * @returns An instantiated pipeline from the serialized object.\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): StandardRenderingPipeline {\r\n        const p = SerializationHelper.Parse(() => new StandardRenderingPipeline(source._name, scene, source._ratio), source, scene, rootUrl);\r\n\r\n        if (source.sourceLightId) {\r\n            p.sourceLight = <SpotLight | DirectionalLight>scene.getLightById(source.sourceLightId);\r\n        }\r\n\r\n        if (source.screenSpaceReflectionPostProcess) {\r\n            SerializationHelper.Parse(() => p.screenSpaceReflectionPostProcess, source.screenSpaceReflectionPostProcess, scene, rootUrl);\r\n        }\r\n\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Luminance steps\r\n     */\r\n    public static LuminanceSteps: number = 6;\r\n}\r\n\r\nRegisterClass(\"BABYLON.StandardRenderingPipeline\", StandardRenderingPipeline);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}