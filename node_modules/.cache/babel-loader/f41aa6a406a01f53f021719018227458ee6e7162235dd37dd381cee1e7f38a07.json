{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder.js\";\nimport { Ray } from \"../Culling/ray.js\";\nimport { PhysicsMotionType } from \"./v2/IPhysicsEnginePlugin.js\";\nclass HelperTools {\n  /*\n   * Gets the hit contact point between a mesh and a ray. The method varies between\n   * the different plugin versions; V1 uses a mesh intersection, V2 uses the physics body instance/object center (to avoid a raycast and improve perf).\n   */\n  static GetContactPointToRef(mesh, origin, direction, result, instanceIndex) {\n    const engine = mesh.getScene().getPhysicsEngine();\n    const pluginVersion = engine === null || engine === void 0 ? void 0 : engine.getPluginVersion();\n    if (pluginVersion === 1) {\n      const ray = new Ray(origin, direction);\n      const hit = ray.intersectsMesh(mesh);\n      if (hit.hit && hit.pickedPoint) {\n        result.copyFrom(hit.pickedPoint);\n        return true;\n      }\n    } else if (pluginVersion === 2) {\n      mesh.physicsBody.getObjectCenterWorldToRef(result, instanceIndex);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Checks if a body will be affected by forces\n   * @param body the body to check\n   * @param instanceIndex for instanced bodies, the index of the instance to check\n   * @returns\n   */\n  static HasAppliedForces(body, instanceIndex) {\n    var _a, _b, _c;\n    return body.getMotionType(instanceIndex) === PhysicsMotionType.STATIC || ((_b = (_a = body.getMassProperties(instanceIndex)) === null || _a === void 0 ? void 0 : _a.mass) !== null && _b !== void 0 ? _b : 0) === 0 || ((_c = body.transformNode) === null || _c === void 0 ? void 0 : _c.getTotalVertices()) === 0;\n  }\n  /**\n   * Checks if a point is inside a cylinder\n   * @param point point to check\n   * @param origin cylinder origin on the bottom\n   * @param radius cylinder radius\n   * @param height cylinder height\n   * @returns\n   */\n  static IsInsideCylinder(point, origin, radius, height) {\n    const distance = TmpVectors.Vector3[0];\n    point.subtractToRef(origin, distance);\n    return Math.abs(distance.x) <= radius && Math.abs(distance.z) <= radius && distance.y >= 0 && distance.y <= height;\n  }\n}\n/**\n * A helper for physics simulations\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\n */\nexport class PhysicsHelper {\n  /**\n   * Initializes the Physics helper\n   * @param scene Babylon.js scene\n   */\n  constructor(scene) {\n    this._hitData = {\n      force: new Vector3(),\n      contactPoint: new Vector3(),\n      distanceFromOrigin: 0\n    };\n    this._scene = scene;\n    this._physicsEngine = this._scene.getPhysicsEngine();\n    if (!this._physicsEngine) {\n      Logger.Warn(\"Physics engine not enabled. Please enable the physics before you can use the methods.\");\n      return;\n    }\n  }\n  /**\n   * Applies a radial explosion impulse\n   * @param origin the origin of the explosion\n   * @param radiusOrEventOptions the radius or the options of radial explosion\n   * @param strength the explosion strength\n   * @param falloff possible options: Constant & Linear. Defaults to Constant\n   * @returns A physics radial explosion event, or null\n   */\n  applyRadialExplosionImpulse(origin, radiusOrEventOptions, strength, falloff) {\n    if (!this._physicsEngine) {\n      Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call this method.\");\n      return null;\n    }\n    if (this._physicsEngine.getPluginVersion() === 1 && this._physicsEngine.getImpostors().length === 0) {\n      return null;\n    }\n    if (this._physicsEngine.getPluginVersion() === 2 && this._physicsEngine.getBodies().length === 0) {\n      return null;\n    }\n    let useCallback = false;\n    if (typeof radiusOrEventOptions === \"number\") {\n      const r = radiusOrEventOptions;\n      radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\n      radiusOrEventOptions.radius = r;\n      radiusOrEventOptions.strength = strength !== null && strength !== void 0 ? strength : radiusOrEventOptions.strength;\n      radiusOrEventOptions.falloff = falloff !== null && falloff !== void 0 ? falloff : radiusOrEventOptions.falloff;\n    } else {\n      useCallback = !!(radiusOrEventOptions.affectedImpostorsCallback || radiusOrEventOptions.affectedBodiesCallback);\n    }\n    const event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);\n    const hitData = this._hitData;\n    if (this._physicsEngine.getPluginVersion() === 1) {\n      const affectedImpostorsWithData = Array();\n      const impostors = this._physicsEngine.getImpostors();\n      impostors.forEach(impostor => {\n        if (!event.getImpostorHitData(impostor, origin, hitData)) {\n          return;\n        }\n        impostor.applyImpulse(hitData.force, hitData.contactPoint);\n        if (useCallback) {\n          affectedImpostorsWithData.push({\n            impostor: impostor,\n            hitData: this._copyPhysicsHitData(hitData)\n          });\n        }\n      });\n      event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);\n    } else {\n      this._applicationForBodies(event, origin, hitData, useCallback, (body, hitData) => {\n        body.applyImpulse(hitData.force, hitData.contactPoint, hitData.instanceIndex);\n      });\n    }\n    event.dispose(false);\n    return event;\n  }\n  /**\n   * Applies a radial explosion force\n   * @param origin the origin of the explosion\n   * @param radiusOrEventOptions the radius or the options of radial explosion\n   * @param strength the explosion strength\n   * @param falloff possible options: Constant & Linear. Defaults to Constant\n   * @returns A physics radial explosion event, or null\n   */\n  applyRadialExplosionForce(origin, radiusOrEventOptions, strength, falloff) {\n    if (!this._physicsEngine) {\n      Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\n      return null;\n    }\n    if (this._physicsEngine.getPluginVersion() === 1 && this._physicsEngine.getImpostors().length === 0) {\n      return null;\n    }\n    if (this._physicsEngine.getPluginVersion() === 2 && this._physicsEngine.getBodies().length === 0) {\n      return null;\n    }\n    let useCallback = false;\n    if (typeof radiusOrEventOptions === \"number\") {\n      const r = radiusOrEventOptions;\n      radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\n      radiusOrEventOptions.radius = r;\n      radiusOrEventOptions.strength = strength !== null && strength !== void 0 ? strength : radiusOrEventOptions.strength;\n      radiusOrEventOptions.falloff = falloff !== null && falloff !== void 0 ? falloff : radiusOrEventOptions.falloff;\n    } else {\n      useCallback = !!(radiusOrEventOptions.affectedImpostorsCallback || radiusOrEventOptions.affectedBodiesCallback);\n    }\n    const event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);\n    const hitData = this._hitData;\n    if (this._physicsEngine.getPluginVersion() === 1) {\n      const affectedImpostorsWithData = Array();\n      const impostors = this._physicsEngine.getImpostors();\n      impostors.forEach(impostor => {\n        if (!event.getImpostorHitData(impostor, origin, hitData)) {\n          return;\n        }\n        impostor.applyForce(hitData.force, hitData.contactPoint);\n        if (useCallback) {\n          affectedImpostorsWithData.push({\n            impostor: impostor,\n            hitData: this._copyPhysicsHitData(hitData)\n          });\n        }\n      });\n      event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);\n    } else {\n      this._applicationForBodies(event, origin, hitData, useCallback, (body, hitData) => {\n        body.applyForce(hitData.force, hitData.contactPoint, hitData.instanceIndex);\n      });\n    }\n    event.dispose(false);\n    return event;\n  }\n  _applicationForBodies(event, origin, hitData, useCallback, fnApplication) {\n    const affectedBodiesWithData = Array();\n    const bodies = this._physicsEngine.getBodies();\n    for (const body of bodies) {\n      body.iterateOverAllInstances((body, instanceIndex) => {\n        if (!event.getBodyHitData(body, origin, hitData, instanceIndex)) {\n          return;\n        }\n        fnApplication(body, hitData);\n        if (useCallback) {\n          affectedBodiesWithData.push({\n            body: body,\n            hitData: this._copyPhysicsHitData(hitData)\n          });\n        }\n      });\n    }\n    event.triggerAffectedBodiesCallback(affectedBodiesWithData);\n  }\n  /**\n   * Creates a gravitational field\n   * @param origin the origin of the gravitational field\n   * @param radiusOrEventOptions the radius or the options of radial gravitational field\n   * @param strength the gravitational field strength\n   * @param falloff possible options: Constant & Linear. Defaults to Constant\n   * @returns A physics gravitational field event, or null\n   */\n  gravitationalField(origin, radiusOrEventOptions, strength, falloff) {\n    if (!this._physicsEngine) {\n      Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\n      return null;\n    }\n    if (this._physicsEngine.getPluginVersion() === 1 && this._physicsEngine.getImpostors().length === 0) {\n      return null;\n    }\n    if (this._physicsEngine.getPluginVersion() === 2 && this._physicsEngine.getBodies().length === 0) {\n      return null;\n    }\n    if (typeof radiusOrEventOptions === \"number\") {\n      const r = radiusOrEventOptions;\n      radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\n      radiusOrEventOptions.radius = r;\n      radiusOrEventOptions.strength = strength !== null && strength !== void 0 ? strength : radiusOrEventOptions.strength;\n      radiusOrEventOptions.falloff = falloff !== null && falloff !== void 0 ? falloff : radiusOrEventOptions.falloff;\n    }\n    const event = new PhysicsGravitationalFieldEvent(this, this._scene, origin, radiusOrEventOptions);\n    event.dispose(false);\n    return event;\n  }\n  /**\n   * Creates a physics updraft event\n   * @param origin the origin of the updraft\n   * @param radiusOrEventOptions the radius or the options of the updraft\n   * @param strength the strength of the updraft\n   * @param height the height of the updraft\n   * @param updraftMode possible options: Center & Perpendicular. Defaults to Center\n   * @returns A physics updraft event, or null\n   */\n  updraft(origin, radiusOrEventOptions, strength, height, updraftMode) {\n    if (!this._physicsEngine) {\n      Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\n      return null;\n    }\n    if (this._physicsEngine.getPluginVersion() === 1 && this._physicsEngine.getImpostors().length === 0) {\n      return null;\n    }\n    if (this._physicsEngine.getPluginVersion() === 2 && this._physicsEngine.getBodies().length === 0) {\n      return null;\n    }\n    if (typeof radiusOrEventOptions === \"number\") {\n      const r = radiusOrEventOptions;\n      radiusOrEventOptions = new PhysicsUpdraftEventOptions();\n      radiusOrEventOptions.radius = r;\n      radiusOrEventOptions.strength = strength !== null && strength !== void 0 ? strength : radiusOrEventOptions.strength;\n      radiusOrEventOptions.height = height !== null && height !== void 0 ? height : radiusOrEventOptions.height;\n      radiusOrEventOptions.updraftMode = updraftMode !== null && updraftMode !== void 0 ? updraftMode : radiusOrEventOptions.updraftMode;\n    }\n    const event = new PhysicsUpdraftEvent(this._scene, origin, radiusOrEventOptions);\n    event.dispose(false);\n    return event;\n  }\n  /**\n   * Creates a physics vortex event\n   * @param origin the of the vortex\n   * @param radiusOrEventOptions the radius or the options of the vortex\n   * @param strength the strength of the vortex\n   * @param height   the height of the vortex\n   * @returns a Physics vortex event, or null\n   * A physics vortex event or null\n   */\n  vortex(origin, radiusOrEventOptions, strength, height) {\n    if (!this._physicsEngine) {\n      Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\n      return null;\n    }\n    if (this._physicsEngine.getPluginVersion() === 1 && this._physicsEngine.getImpostors().length === 0) {\n      return null;\n    }\n    if (this._physicsEngine.getPluginVersion() === 2 && this._physicsEngine.getBodies().length === 0) {\n      return null;\n    }\n    if (typeof radiusOrEventOptions === \"number\") {\n      const r = radiusOrEventOptions;\n      radiusOrEventOptions = new PhysicsVortexEventOptions();\n      radiusOrEventOptions.radius = r;\n      radiusOrEventOptions.strength = strength !== null && strength !== void 0 ? strength : radiusOrEventOptions.strength;\n      radiusOrEventOptions.height = height !== null && height !== void 0 ? height : radiusOrEventOptions.height;\n    }\n    const event = new PhysicsVortexEvent(this._scene, origin, radiusOrEventOptions);\n    event.dispose(false);\n    return event;\n  }\n  _copyPhysicsHitData(data) {\n    return {\n      force: data.force.clone(),\n      contactPoint: data.contactPoint.clone(),\n      distanceFromOrigin: data.distanceFromOrigin,\n      instanceIndex: data.instanceIndex\n    };\n  }\n}\n/**\n * Represents a physics radial explosion event\n */\nclass PhysicsRadialExplosionEvent {\n  /**\n   * Initializes a radial explosion event\n   * @param _scene BabylonJS scene\n   * @param _options The options for the vortex event\n   */\n  constructor(_scene, _options) {\n    this._scene = _scene;\n    this._options = _options;\n    this._dataFetched = false; // check if the data has been fetched. If not, do cleanup\n    this._options = Object.assign(Object.assign({}, new PhysicsRadialExplosionEventOptions()), this._options);\n  }\n  /**\n   * Returns the data related to the radial explosion event (sphere).\n   * @returns The radial explosion event data\n   */\n  getData() {\n    this._dataFetched = true;\n    return {\n      sphere: this._sphere\n    };\n  }\n  _getHitData(mesh, center, origin, data) {\n    const direction = TmpVectors.Vector3[0];\n    direction.copyFrom(center).subtractInPlace(origin);\n    const contactPoint = TmpVectors.Vector3[1];\n    const hasContactPoint = HelperTools.GetContactPointToRef(mesh, origin, direction, contactPoint, data.instanceIndex);\n    if (!hasContactPoint) {\n      return false;\n    }\n    const distanceFromOrigin = Vector3.Distance(origin, contactPoint);\n    if (distanceFromOrigin > this._options.radius) {\n      return false;\n    }\n    const multiplier = this._options.falloff === PhysicsRadialImpulseFalloff.Constant ? this._options.strength : this._options.strength * (1 - distanceFromOrigin / this._options.radius);\n    // Direction x multiplier equals force\n    direction.scaleInPlace(multiplier);\n    data.force.copyFrom(direction);\n    data.contactPoint.copyFrom(contactPoint);\n    data.distanceFromOrigin = distanceFromOrigin;\n    return true;\n  }\n  /**\n   * Returns the force and contact point of the body or false, if the body is not affected by the force/impulse.\n   * @param body A physics body where the transform node is an AbstractMesh\n   * @param origin the origin of the explosion\n   * @param data the data of the hit\n   * @param instanceIndex the instance index of the body\n   * @returns if there was a hit\n   */\n  getBodyHitData(body, origin, data, instanceIndex) {\n    // No force will be applied in these cases, so we skip calculation\n    if (HelperTools.HasAppliedForces(body, instanceIndex)) {\n      return false;\n    }\n    const mesh = body.transformNode;\n    const bodyObjectCenter = body.getObjectCenterWorld(instanceIndex);\n    data.instanceIndex = instanceIndex;\n    return this._getHitData(mesh, bodyObjectCenter, origin, data);\n  }\n  /**\n   * Returns the force and contact point of the impostor or false, if the impostor is not affected by the force/impulse.\n   * @param impostor A physics imposter\n   * @param origin the origin of the explosion\n   * @returns A physics force and contact point, or null\n   */\n  getImpostorHitData(impostor, origin, data) {\n    if (impostor.mass === 0) {\n      return false;\n    }\n    if (impostor.object.getClassName() !== \"Mesh\" && impostor.object.getClassName() !== \"InstancedMesh\") {\n      return false;\n    }\n    const mesh = impostor.object;\n    if (!this._intersectsWithSphere(mesh, origin, this._options.radius)) {\n      return false;\n    }\n    const impostorObjectCenter = impostor.getObjectCenter();\n    this._getHitData(mesh, impostorObjectCenter, origin, data);\n    return true;\n  }\n  /**\n   * Triggers affected impostors callbacks\n   * @param affectedImpostorsWithData defines the list of affected impostors (including associated data)\n   */\n  triggerAffectedImpostorsCallback(affectedImpostorsWithData) {\n    if (this._options.affectedImpostorsCallback) {\n      this._options.affectedImpostorsCallback(affectedImpostorsWithData);\n    }\n  }\n  /**\n   * Triggers affected bodies callbacks\n   * @param affectedBodiesWithData defines the list of affected bodies (including associated data)\n   */\n  triggerAffectedBodiesCallback(affectedBodiesWithData) {\n    if (this._options.affectedBodiesCallback) {\n      this._options.affectedBodiesCallback(affectedBodiesWithData);\n    }\n  }\n  /**\n   * Disposes the sphere.\n   * @param force Specifies if the sphere should be disposed by force\n   */\n  dispose(force = true) {\n    if (this._sphere) {\n      if (force) {\n        this._sphere.dispose();\n      } else {\n        setTimeout(() => {\n          if (!this._dataFetched) {\n            this._sphere.dispose();\n          }\n        }, 0);\n      }\n    }\n  }\n  /*** Helpers ***/\n  _prepareSphere() {\n    if (!this._sphere) {\n      this._sphere = CreateSphere(\"radialExplosionEventSphere\", this._options.sphere, this._scene);\n      this._sphere.isVisible = false;\n    }\n  }\n  _intersectsWithSphere(mesh, origin, radius) {\n    this._prepareSphere();\n    this._sphere.position = origin;\n    this._sphere.scaling.setAll(radius * 2);\n    this._sphere._updateBoundingInfo();\n    this._sphere.computeWorldMatrix(true);\n    return this._sphere.intersectsMesh(mesh, true);\n  }\n}\n/**\n * Represents a gravitational field event\n */\nclass PhysicsGravitationalFieldEvent {\n  /**\n   * Initializes the physics gravitational field event\n   * @param _physicsHelper A physics helper\n   * @param _scene BabylonJS scene\n   * @param _origin The origin position of the gravitational field event\n   * @param _options The options for the vortex event\n   */\n  constructor(_physicsHelper, _scene, _origin, _options) {\n    this._physicsHelper = _physicsHelper;\n    this._scene = _scene;\n    this._origin = _origin;\n    this._options = _options;\n    this._dataFetched = false; // check if the has been fetched the data. If not, do cleanup\n    this._options = Object.assign(Object.assign({}, new PhysicsRadialExplosionEventOptions()), this._options);\n    this._tickCallback = () => this._tick();\n    this._options.strength = this._options.strength * -1;\n  }\n  /**\n   * Returns the data related to the gravitational field event (sphere).\n   * @returns A gravitational field event\n   */\n  getData() {\n    this._dataFetched = true;\n    return {\n      sphere: this._sphere\n    };\n  }\n  /**\n   * Enables the gravitational field.\n   */\n  enable() {\n    this._tickCallback.call(this);\n    this._scene.registerBeforeRender(this._tickCallback);\n  }\n  /**\n   * Disables the gravitational field.\n   */\n  disable() {\n    this._scene.unregisterBeforeRender(this._tickCallback);\n  }\n  /**\n   * Disposes the sphere.\n   * @param force The force to dispose from the gravitational field event\n   */\n  dispose(force = true) {\n    if (!this._sphere) {\n      return;\n    }\n    if (force) {\n      this._sphere.dispose();\n    } else {\n      setTimeout(() => {\n        if (!this._dataFetched) {\n          this._sphere.dispose();\n        }\n      }, 0);\n    }\n  }\n  _tick() {\n    var _a;\n    // Since the params won't change, we fetch the event only once\n    if (this._sphere) {\n      this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);\n    } else {\n      const radialExplosionEvent = this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);\n      if (radialExplosionEvent) {\n        this._sphere = (_a = radialExplosionEvent.getData().sphere) === null || _a === void 0 ? void 0 : _a.clone(\"radialExplosionEventSphereClone\");\n      }\n    }\n  }\n}\n/**\n * Represents a physics updraft event\n */\nclass PhysicsUpdraftEvent {\n  /**\n   * Initializes the physics updraft event\n   * @param _scene BabylonJS scene\n   * @param _origin The origin position of the updraft\n   * @param _options The options for the updraft event\n   */\n  constructor(_scene, _origin, _options) {\n    this._scene = _scene;\n    this._origin = _origin;\n    this._options = _options;\n    this._originTop = Vector3.Zero(); // the most upper part of the cylinder\n    this._originDirection = Vector3.Zero(); // used if the updraftMode is perpendicular\n    this._cylinderPosition = Vector3.Zero(); // to keep the cylinders position, because normally the origin is in the center and not on the bottom\n    this._dataFetched = false; // check if the has been fetched the data. If not, do cleanup\n    this._physicsEngine = this._scene.getPhysicsEngine();\n    this._options = Object.assign(Object.assign({}, new PhysicsUpdraftEventOptions()), this._options);\n    this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);\n    this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);\n    if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {\n      this._originDirection = this._origin.subtract(this._originTop).normalize();\n    }\n    this._tickCallback = () => this._tick();\n    if (this._physicsEngine.getPluginVersion() === 1) {\n      this._prepareCylinder();\n    }\n  }\n  /**\n   * Returns the data related to the updraft event (cylinder).\n   * @returns A physics updraft event\n   */\n  getData() {\n    this._dataFetched = true;\n    return {\n      cylinder: this._cylinder\n    };\n  }\n  /**\n   * Enables the updraft.\n   */\n  enable() {\n    this._tickCallback.call(this);\n    this._scene.registerBeforeRender(this._tickCallback);\n  }\n  /**\n   * Disables the updraft.\n   */\n  disable() {\n    this._scene.unregisterBeforeRender(this._tickCallback);\n  }\n  /**\n   * Disposes the cylinder.\n   * @param force Specifies if the updraft should be disposed by force\n   */\n  dispose(force = true) {\n    if (!this._cylinder) {\n      return;\n    }\n    if (force) {\n      this._cylinder.dispose();\n      this._cylinder = undefined;\n    } else {\n      setTimeout(() => {\n        if (!this._dataFetched && this._cylinder) {\n          this._cylinder.dispose();\n          this._cylinder = undefined;\n        }\n      }, 0);\n    }\n  }\n  _getHitData(center, data) {\n    let direction;\n    if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {\n      direction = this._originDirection;\n    } else {\n      direction = center.subtract(this._originTop);\n    }\n    const distanceFromOrigin = Vector3.Distance(this._origin, center);\n    const multiplier = this._options.strength * -1;\n    const force = direction.multiplyByFloats(multiplier, multiplier, multiplier);\n    data.force.copyFrom(force);\n    data.contactPoint.copyFrom(center);\n    data.distanceFromOrigin = distanceFromOrigin;\n  }\n  _getBodyHitData(body, data, instanceIndex) {\n    if (HelperTools.HasAppliedForces(body)) {\n      return false;\n    }\n    const center = body.getObjectCenterWorld(instanceIndex);\n    if (!HelperTools.IsInsideCylinder(center, this._origin, this._options.radius, this._options.height)) {\n      return false;\n    }\n    data.instanceIndex = instanceIndex;\n    this._getHitData(center, data);\n    return true;\n  }\n  _getImpostorHitData(impostor, data) {\n    if (impostor.mass === 0) {\n      return false;\n    }\n    const impostorObject = impostor.object;\n    if (!this._intersectsWithCylinder(impostorObject)) {\n      return false;\n    }\n    const center = impostor.getObjectCenter();\n    this._getHitData(center, data);\n    return true;\n  }\n  _tick() {\n    const hitData = PhysicsUpdraftEvent._HitData;\n    if (this._physicsEngine.getPluginVersion() === 1) {\n      this._physicsEngine.getImpostors().forEach(impostor => {\n        if (!this._getImpostorHitData(impostor, hitData)) {\n          return;\n        }\n        impostor.applyForce(hitData.force, hitData.contactPoint);\n      });\n    } else {\n      // V2\n      this._physicsEngine.getBodies().forEach(body => {\n        body.iterateOverAllInstances((body, instanceIndex) => {\n          if (!this._getBodyHitData(body, hitData, instanceIndex)) {\n            return;\n          }\n          body.applyForce(hitData.force, hitData.contactPoint, hitData.instanceIndex);\n        });\n      });\n    }\n  }\n  /*** Helpers ***/\n  _prepareCylinder() {\n    if (!this._cylinder) {\n      this._cylinder = CreateCylinder(\"updraftEventCylinder\", {\n        height: this._options.height,\n        diameter: this._options.radius * 2\n      }, this._scene);\n      this._cylinder.isVisible = false;\n    }\n  }\n  _intersectsWithCylinder(mesh) {\n    if (!this._cylinder) {\n      return false;\n    }\n    this._cylinder.position = this._cylinderPosition;\n    return this._cylinder.intersectsMesh(mesh, true);\n  }\n}\nPhysicsUpdraftEvent._HitData = {\n  force: new Vector3(),\n  contactPoint: new Vector3(),\n  distanceFromOrigin: 0\n};\n/**\n * Represents a physics vortex event\n */\nclass PhysicsVortexEvent {\n  /**\n   * Initializes the physics vortex event\n   * @param _scene The BabylonJS scene\n   * @param _origin The origin position of the vortex\n   * @param _options The options for the vortex event\n   */\n  constructor(_scene, _origin, _options) {\n    this._scene = _scene;\n    this._origin = _origin;\n    this._options = _options;\n    this._originTop = Vector3.Zero(); // the most upper part of the cylinder\n    this._cylinderPosition = Vector3.Zero(); // to keep the cylinders position, because normally the origin is in the center and not on the bottom\n    this._dataFetched = false; // check if the has been fetched the data. If not, do cleanup\n    this._physicsEngine = this._scene.getPhysicsEngine();\n    this._options = Object.assign(Object.assign({}, new PhysicsVortexEventOptions()), this._options);\n    this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);\n    this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);\n    this._tickCallback = () => this._tick();\n    if (this._physicsEngine.getPluginVersion() === 1) {\n      this._prepareCylinder();\n    }\n  }\n  /**\n   * Returns the data related to the vortex event (cylinder).\n   * @returns The physics vortex event data\n   */\n  getData() {\n    this._dataFetched = true;\n    return {\n      cylinder: this._cylinder\n    };\n  }\n  /**\n   * Enables the vortex.\n   */\n  enable() {\n    this._tickCallback.call(this);\n    this._scene.registerBeforeRender(this._tickCallback);\n  }\n  /**\n   * Disables the cortex.\n   */\n  disable() {\n    this._scene.unregisterBeforeRender(this._tickCallback);\n  }\n  /**\n   * Disposes the sphere.\n   * @param force\n   */\n  dispose(force = true) {\n    if (!this._cylinder) {\n      return;\n    }\n    if (force) {\n      this._cylinder.dispose();\n    } else {\n      setTimeout(() => {\n        if (!this._dataFetched) {\n          this._cylinder.dispose();\n        }\n      }, 0);\n    }\n  }\n  _getHitData(mesh, center, data) {\n    const originOnPlane = PhysicsVortexEvent.originOnPlane;\n    originOnPlane.set(this._origin.x, center.y, this._origin.z); // the distance to the origin as if both objects were on a plane (Y-axis)\n    const originToImpostorDirection = TmpVectors.Vector3[0];\n    center.subtractToRef(originOnPlane, originToImpostorDirection);\n    const contactPoint = TmpVectors.Vector3[1];\n    const hasContactPoint = HelperTools.GetContactPointToRef(mesh, originOnPlane, originToImpostorDirection, contactPoint, data.instanceIndex);\n    if (!hasContactPoint) {\n      return false;\n    }\n    const distance = Vector3.Distance(contactPoint, originOnPlane);\n    const absoluteDistanceFromOrigin = distance / this._options.radius;\n    const directionToOrigin = TmpVectors.Vector3[2];\n    contactPoint.normalizeToRef(directionToOrigin);\n    if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {\n      directionToOrigin.negateInPlace();\n    }\n    let forceX;\n    let forceY;\n    let forceZ;\n    if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {\n      forceX = directionToOrigin.x * this._options.centripetalForceMultiplier;\n      forceY = directionToOrigin.y * this._options.updraftForceMultiplier;\n      forceZ = directionToOrigin.z * this._options.centripetalForceMultiplier;\n    } else {\n      const perpendicularDirection = Vector3.Cross(originOnPlane, center).normalize();\n      forceX = (perpendicularDirection.x + directionToOrigin.x) * this._options.centrifugalForceMultiplier;\n      forceY = this._originTop.y * this._options.updraftForceMultiplier;\n      forceZ = (perpendicularDirection.z + directionToOrigin.z) * this._options.centrifugalForceMultiplier;\n    }\n    const force = TmpVectors.Vector3[3];\n    force.set(forceX, forceY, forceZ);\n    force.scaleInPlace(this._options.strength);\n    data.force.copyFrom(force);\n    data.contactPoint.copyFrom(center);\n    data.distanceFromOrigin = absoluteDistanceFromOrigin;\n    return true;\n  }\n  _getBodyHitData(body, data, instanceIndex) {\n    if (HelperTools.HasAppliedForces(body, instanceIndex)) {\n      return false;\n    }\n    const bodyObject = body.transformNode;\n    const bodyCenter = body.getObjectCenterWorld(instanceIndex);\n    if (!HelperTools.IsInsideCylinder(bodyCenter, this._origin, this._options.radius, this._options.height)) {\n      return false;\n    }\n    data.instanceIndex = instanceIndex;\n    return this._getHitData(bodyObject, bodyCenter, data);\n  }\n  _getImpostorHitData(impostor, data) {\n    if (impostor.mass === 0) {\n      return false;\n    }\n    if (impostor.object.getClassName() !== \"Mesh\" && impostor.object.getClassName() !== \"InstancedMesh\") {\n      return false;\n    }\n    const impostorObject = impostor.object;\n    if (!this._intersectsWithCylinder(impostorObject)) {\n      return false;\n    }\n    const impostorObjectCenter = impostor.getObjectCenter();\n    this._getHitData(impostorObject, impostorObjectCenter, data);\n    return true;\n  }\n  _tick() {\n    const hitData = PhysicsVortexEvent.hitData;\n    if (this._physicsEngine.getPluginVersion() === 1) {\n      this._physicsEngine.getImpostors().forEach(impostor => {\n        if (!this._getImpostorHitData(impostor, hitData)) {\n          return;\n        }\n        impostor.applyForce(hitData.force, hitData.contactPoint);\n      });\n    } else {\n      this._physicsEngine.getBodies().forEach(body => {\n        body.iterateOverAllInstances((body, instanceIndex) => {\n          if (!this._getBodyHitData(body, hitData, instanceIndex)) {\n            return;\n          }\n          body.applyForce(hitData.force, hitData.contactPoint, hitData.instanceIndex);\n        });\n      });\n    }\n  }\n  /*** Helpers ***/\n  _prepareCylinder() {\n    if (!this._cylinder) {\n      this._cylinder = CreateCylinder(\"vortexEventCylinder\", {\n        height: this._options.height,\n        diameter: this._options.radius * 2\n      }, this._scene);\n      this._cylinder.isVisible = false;\n    }\n  }\n  _intersectsWithCylinder(mesh) {\n    this._cylinder.position = this._cylinderPosition;\n    return this._cylinder.intersectsMesh(mesh, true);\n  }\n}\nPhysicsVortexEvent.originOnPlane = Vector3.Zero();\nPhysicsVortexEvent.hitData = {\n  force: new Vector3(),\n  contactPoint: new Vector3(),\n  distanceFromOrigin: 0\n};\n/**\n * Options fot the radial explosion event\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\n */\nexport class PhysicsRadialExplosionEventOptions {\n  constructor() {\n    /**\n     * The radius of the sphere for the radial explosion.\n     */\n    this.radius = 5;\n    /**\n     * The strength of the explosion.\n     */\n    this.strength = 10;\n    /**\n     * The strength of the force in correspondence to the distance of the affected object\n     */\n    this.falloff = PhysicsRadialImpulseFalloff.Constant;\n    /**\n     * Sphere options for the radial explosion.\n     */\n    this.sphere = {\n      segments: 32,\n      diameter: 1\n    };\n  }\n}\n/**\n * Options fot the updraft event\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\n */\nexport class PhysicsUpdraftEventOptions {\n  constructor() {\n    /**\n     * The radius of the cylinder for the vortex\n     */\n    this.radius = 5;\n    /**\n     * The strength of the updraft.\n     */\n    this.strength = 10;\n    /**\n     * The height of the cylinder for the updraft.\n     */\n    this.height = 10;\n    /**\n     * The mode for the the updraft.\n     */\n    this.updraftMode = PhysicsUpdraftMode.Center;\n  }\n}\n/**\n * Options fot the vortex event\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\n */\nexport class PhysicsVortexEventOptions {\n  constructor() {\n    /**\n     * The radius of the cylinder for the vortex\n     */\n    this.radius = 5;\n    /**\n     * The strength of the vortex.\n     */\n    this.strength = 10;\n    /**\n     * The height of the cylinder for the vortex.\n     */\n    this.height = 10;\n    /**\n     * At which distance, relative to the radius the centripetal forces should kick in? Range: 0-1\n     */\n    this.centripetalForceThreshold = 0.7;\n    /**\n     * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when below the threshold.\n     */\n    this.centripetalForceMultiplier = 5;\n    /**\n     * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when above the threshold.\n     */\n    this.centrifugalForceMultiplier = 0.5;\n    /**\n     * This multiplier determines with how much force the objects will be pushed upwards, when in the vortex.\n     */\n    this.updraftForceMultiplier = 0.02;\n  }\n}\n/**\n * The strength of the force in correspondence to the distance of the affected object\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\n */\nexport var PhysicsRadialImpulseFalloff;\n(function (PhysicsRadialImpulseFalloff) {\n  /** Defines that impulse is constant in strength across it's whole radius */\n  PhysicsRadialImpulseFalloff[PhysicsRadialImpulseFalloff[\"Constant\"] = 0] = \"Constant\";\n  /** Defines that impulse gets weaker if it's further from the origin */\n  PhysicsRadialImpulseFalloff[PhysicsRadialImpulseFalloff[\"Linear\"] = 1] = \"Linear\";\n})(PhysicsRadialImpulseFalloff || (PhysicsRadialImpulseFalloff = {}));\n/**\n * The strength of the force in correspondence to the distance of the affected object\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\n */\nexport var PhysicsUpdraftMode;\n(function (PhysicsUpdraftMode) {\n  /** Defines that the upstream forces will pull towards the top center of the cylinder */\n  PhysicsUpdraftMode[PhysicsUpdraftMode[\"Center\"] = 0] = \"Center\";\n  /** Defines that once a impostor is inside the cylinder, it will shoot out perpendicular from the ground of the cylinder */\n  PhysicsUpdraftMode[PhysicsUpdraftMode[\"Perpendicular\"] = 1] = \"Perpendicular\";\n})(PhysicsUpdraftMode || (PhysicsUpdraftMode = {}));","map":{"version":3,"names":["Logger","TmpVectors","Vector3","CreateSphere","CreateCylinder","Ray","PhysicsMotionType","HelperTools","GetContactPointToRef","mesh","origin","direction","result","instanceIndex","engine","getScene","getPhysicsEngine","pluginVersion","getPluginVersion","ray","hit","intersectsMesh","pickedPoint","copyFrom","physicsBody","getObjectCenterWorldToRef","HasAppliedForces","body","getMotionType","STATIC","_b","_a","getMassProperties","mass","_c","transformNode","getTotalVertices","IsInsideCylinder","point","radius","height","distance","subtractToRef","Math","abs","x","z","y","PhysicsHelper","constructor","scene","_hitData","force","contactPoint","distanceFromOrigin","_scene","_physicsEngine","Warn","applyRadialExplosionImpulse","radiusOrEventOptions","strength","falloff","getImpostors","length","getBodies","useCallback","r","PhysicsRadialExplosionEventOptions","affectedImpostorsCallback","affectedBodiesCallback","event","PhysicsRadialExplosionEvent","hitData","affectedImpostorsWithData","Array","impostors","forEach","impostor","getImpostorHitData","applyImpulse","push","_copyPhysicsHitData","triggerAffectedImpostorsCallback","_applicationForBodies","dispose","applyRadialExplosionForce","applyForce","fnApplication","affectedBodiesWithData","bodies","iterateOverAllInstances","getBodyHitData","triggerAffectedBodiesCallback","gravitationalField","PhysicsGravitationalFieldEvent","updraft","updraftMode","PhysicsUpdraftEventOptions","PhysicsUpdraftEvent","vortex","PhysicsVortexEventOptions","PhysicsVortexEvent","data","clone","_options","_dataFetched","Object","assign","getData","sphere","_sphere","_getHitData","center","subtractInPlace","hasContactPoint","Distance","multiplier","PhysicsRadialImpulseFalloff","Constant","scaleInPlace","bodyObjectCenter","getObjectCenterWorld","object","getClassName","_intersectsWithSphere","impostorObjectCenter","getObjectCenter","setTimeout","_prepareSphere","isVisible","position","scaling","setAll","_updateBoundingInfo","computeWorldMatrix","_physicsHelper","_origin","_tickCallback","_tick","enable","call","registerBeforeRender","disable","unregisterBeforeRender","radialExplosionEvent","_originTop","Zero","_originDirection","_cylinderPosition","addToRef","PhysicsUpdraftMode","Perpendicular","subtract","normalize","_prepareCylinder","cylinder","_cylinder","undefined","multiplyByFloats","_getBodyHitData","_getImpostorHitData","impostorObject","_intersectsWithCylinder","_HitData","diameter","originOnPlane","set","originToImpostorDirection","absoluteDistanceFromOrigin","directionToOrigin","normalizeToRef","centripetalForceThreshold","negateInPlace","forceX","forceY","forceZ","centripetalForceMultiplier","updraftForceMultiplier","perpendicularDirection","Cross","centrifugalForceMultiplier","bodyObject","bodyCenter","segments","Center"],"sources":["../../../../dev/core/src/Physics/physicsHelper.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder\";\r\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder\";\r\nimport { Ray } from \"../Culling/ray\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { PhysicsEngine as PhysicsEngineV1 } from \"./physicsEngine\";\r\nimport type { PhysicsEngine as PhysicsEngineV2 } from \"./v2/physicsEngine\";\r\nimport type { IPhysicsEngine } from \"./IPhysicsEngine\";\r\nimport type { PhysicsImpostor } from \"./v1/physicsImpostor\";\r\nimport type { PhysicsBody } from \"./v2/physicsBody\";\r\nimport { PhysicsMotionType } from \"./v2/IPhysicsEnginePlugin\";\r\n\r\nclass HelperTools {\r\n    /*\r\n     * Gets the hit contact point between a mesh and a ray. The method varies between\r\n     * the different plugin versions; V1 uses a mesh intersection, V2 uses the physics body instance/object center (to avoid a raycast and improve perf).\r\n     */\r\n    static GetContactPointToRef(mesh: AbstractMesh, origin: Vector3, direction: Vector3, result: Vector3, instanceIndex?: number): boolean {\r\n        const engine = mesh.getScene().getPhysicsEngine();\r\n        const pluginVersion = engine?.getPluginVersion();\r\n        if (pluginVersion === 1) {\r\n            const ray = new Ray(origin, direction);\r\n            const hit = ray.intersectsMesh(mesh);\r\n            if (hit.hit && hit.pickedPoint) {\r\n                result.copyFrom(hit.pickedPoint);\r\n                return true;\r\n            }\r\n        } else if (pluginVersion === 2) {\r\n            mesh.physicsBody!.getObjectCenterWorldToRef(result, instanceIndex);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if a body will be affected by forces\r\n     * @param body the body to check\r\n     * @param instanceIndex for instanced bodies, the index of the instance to check\r\n     * @returns\r\n     */\r\n    static HasAppliedForces(body: PhysicsBody, instanceIndex?: number) {\r\n        return (\r\n            body.getMotionType(instanceIndex) === PhysicsMotionType.STATIC ||\r\n            (body.getMassProperties(instanceIndex)?.mass ?? 0) === 0 ||\r\n            (body.transformNode as Mesh)?.getTotalVertices() === 0\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if a point is inside a cylinder\r\n     * @param point point to check\r\n     * @param origin cylinder origin on the bottom\r\n     * @param radius cylinder radius\r\n     * @param height cylinder height\r\n     * @returns\r\n     */\r\n    static IsInsideCylinder(point: Vector3, origin: Vector3, radius: number, height: number): boolean {\r\n        const distance = TmpVectors.Vector3[0];\r\n        point.subtractToRef(origin, distance);\r\n        return Math.abs(distance.x) <= radius && Math.abs(distance.z) <= radius && distance.y >= 0 && distance.y <= height;\r\n    }\r\n}\r\n\r\n/**\r\n * A helper for physics simulations\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\r\n */\r\nexport class PhysicsHelper {\r\n    private _scene: Scene;\r\n    private _physicsEngine: Nullable<IPhysicsEngine>;\r\n    private _hitData: PhysicsHitData = { force: new Vector3(), contactPoint: new Vector3(), distanceFromOrigin: 0 };\r\n\r\n    /**\r\n     * Initializes the Physics helper\r\n     * @param scene Babylon.js scene\r\n     */\r\n    constructor(scene: Scene) {\r\n        this._scene = scene;\r\n        this._physicsEngine = this._scene.getPhysicsEngine();\r\n\r\n        if (!this._physicsEngine) {\r\n            Logger.Warn(\"Physics engine not enabled. Please enable the physics before you can use the methods.\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Applies a radial explosion impulse\r\n     * @param origin the origin of the explosion\r\n     * @param radiusOrEventOptions the radius or the options of radial explosion\r\n     * @param strength the explosion strength\r\n     * @param falloff possible options: Constant & Linear. Defaults to Constant\r\n     * @returns A physics radial explosion event, or null\r\n     */\r\n    public applyRadialExplosionImpulse(\r\n        origin: Vector3,\r\n        radiusOrEventOptions: number | PhysicsRadialExplosionEventOptions,\r\n        strength?: number,\r\n        falloff?: PhysicsRadialImpulseFalloff\r\n    ): Nullable<PhysicsRadialExplosionEvent> {\r\n        if (!this._physicsEngine) {\r\n            Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call this method.\");\r\n            return null;\r\n        }\r\n\r\n        if (this._physicsEngine.getPluginVersion() === 1 && (<PhysicsEngineV1>this._physicsEngine).getImpostors().length === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (this._physicsEngine.getPluginVersion() === 2 && (<PhysicsEngineV2>this._physicsEngine).getBodies().length === 0) {\r\n            return null;\r\n        }\r\n\r\n        let useCallback = false;\r\n        if (typeof radiusOrEventOptions === \"number\") {\r\n            const r = radiusOrEventOptions;\r\n            radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\r\n            radiusOrEventOptions.radius = r;\r\n            radiusOrEventOptions.strength = strength ?? radiusOrEventOptions.strength;\r\n            radiusOrEventOptions.falloff = falloff ?? radiusOrEventOptions.falloff;\r\n        } else {\r\n            useCallback = !!(radiusOrEventOptions.affectedImpostorsCallback || radiusOrEventOptions.affectedBodiesCallback);\r\n        }\r\n\r\n        const event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);\r\n\r\n        const hitData = this._hitData;\r\n        if (this._physicsEngine.getPluginVersion() === 1) {\r\n            const affectedImpostorsWithData = Array<PhysicsAffectedImpostorWithData>();\r\n            const impostors = (<PhysicsEngineV1>this._physicsEngine).getImpostors();\r\n            impostors.forEach((impostor: PhysicsImpostor) => {\r\n                if (!event.getImpostorHitData(impostor, origin, hitData)) {\r\n                    return;\r\n                }\r\n\r\n                impostor.applyImpulse(hitData.force, hitData.contactPoint);\r\n\r\n                if (useCallback) {\r\n                    affectedImpostorsWithData.push({\r\n                        impostor: impostor,\r\n                        hitData: this._copyPhysicsHitData(hitData),\r\n                    });\r\n                }\r\n            });\r\n\r\n            event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);\r\n        } else {\r\n            this._applicationForBodies(event, origin, hitData, useCallback, (body: PhysicsBody, hitData: PhysicsHitData) => {\r\n                body.applyImpulse(hitData.force, hitData.contactPoint, hitData.instanceIndex);\r\n            });\r\n        }\r\n\r\n        event.dispose(false);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Applies a radial explosion force\r\n     * @param origin the origin of the explosion\r\n     * @param radiusOrEventOptions the radius or the options of radial explosion\r\n     * @param strength the explosion strength\r\n     * @param falloff possible options: Constant & Linear. Defaults to Constant\r\n     * @returns A physics radial explosion event, or null\r\n     */\r\n    public applyRadialExplosionForce(\r\n        origin: Vector3,\r\n        radiusOrEventOptions: number | PhysicsRadialExplosionEventOptions,\r\n        strength?: number,\r\n        falloff?: PhysicsRadialImpulseFalloff\r\n    ): Nullable<PhysicsRadialExplosionEvent> {\r\n        if (!this._physicsEngine) {\r\n            Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\r\n            return null;\r\n        }\r\n\r\n        if (this._physicsEngine.getPluginVersion() === 1 && (<PhysicsEngineV1>this._physicsEngine).getImpostors().length === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (this._physicsEngine.getPluginVersion() === 2 && (<PhysicsEngineV2>this._physicsEngine).getBodies().length === 0) {\r\n            return null;\r\n        }\r\n\r\n        let useCallback = false;\r\n        if (typeof radiusOrEventOptions === \"number\") {\r\n            const r = radiusOrEventOptions;\r\n            radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\r\n            radiusOrEventOptions.radius = r;\r\n            radiusOrEventOptions.strength = strength ?? radiusOrEventOptions.strength;\r\n            radiusOrEventOptions.falloff = falloff ?? radiusOrEventOptions.falloff;\r\n        } else {\r\n            useCallback = !!(radiusOrEventOptions.affectedImpostorsCallback || radiusOrEventOptions.affectedBodiesCallback);\r\n        }\r\n\r\n        const event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);\r\n\r\n        const hitData = this._hitData;\r\n        if (this._physicsEngine.getPluginVersion() === 1) {\r\n            const affectedImpostorsWithData = Array<PhysicsAffectedImpostorWithData>();\r\n            const impostors = (<PhysicsEngineV1>this._physicsEngine).getImpostors();\r\n            impostors.forEach((impostor: PhysicsImpostor) => {\r\n                if (!event.getImpostorHitData(impostor, origin, hitData)) {\r\n                    return;\r\n                }\r\n\r\n                impostor.applyForce(hitData.force, hitData.contactPoint);\r\n\r\n                if (useCallback) {\r\n                    affectedImpostorsWithData.push({\r\n                        impostor: impostor,\r\n                        hitData: this._copyPhysicsHitData(hitData),\r\n                    });\r\n                }\r\n            });\r\n\r\n            event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);\r\n        } else {\r\n            this._applicationForBodies(event, origin, hitData, useCallback, (body: PhysicsBody, hitData: PhysicsHitData) => {\r\n                body.applyForce(hitData.force, hitData.contactPoint, hitData.instanceIndex);\r\n            });\r\n        }\r\n\r\n        event.dispose(false);\r\n\r\n        return event;\r\n    }\r\n\r\n    private _applicationForBodies(\r\n        event: PhysicsRadialExplosionEvent,\r\n        origin: Vector3,\r\n        hitData: PhysicsHitData,\r\n        useCallback: boolean,\r\n        fnApplication: (body: PhysicsBody, hitData: PhysicsHitData, instanceIndex?: number) => void\r\n    ) {\r\n        const affectedBodiesWithData = Array<PhysicsAffectedBodyWithData>();\r\n        const bodies = (<PhysicsEngineV2>this._physicsEngine).getBodies();\r\n        for (const body of bodies) {\r\n            body.iterateOverAllInstances((body, instanceIndex) => {\r\n                if (!event.getBodyHitData(body, origin, hitData, instanceIndex)) {\r\n                    return;\r\n                }\r\n                fnApplication(body, hitData);\r\n\r\n                if (useCallback) {\r\n                    affectedBodiesWithData.push({\r\n                        body: body,\r\n                        hitData: this._copyPhysicsHitData(hitData),\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n        event.triggerAffectedBodiesCallback(affectedBodiesWithData);\r\n    }\r\n\r\n    /**\r\n     * Creates a gravitational field\r\n     * @param origin the origin of the gravitational field\r\n     * @param radiusOrEventOptions the radius or the options of radial gravitational field\r\n     * @param strength the gravitational field strength\r\n     * @param falloff possible options: Constant & Linear. Defaults to Constant\r\n     * @returns A physics gravitational field event, or null\r\n     */\r\n    public gravitationalField(\r\n        origin: Vector3,\r\n        radiusOrEventOptions: number | PhysicsRadialExplosionEventOptions,\r\n        strength?: number,\r\n        falloff?: PhysicsRadialImpulseFalloff\r\n    ): Nullable<PhysicsGravitationalFieldEvent> {\r\n        if (!this._physicsEngine) {\r\n            Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\r\n            return null;\r\n        }\r\n\r\n        if (this._physicsEngine.getPluginVersion() === 1 && (<PhysicsEngineV1>this._physicsEngine).getImpostors().length === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (this._physicsEngine.getPluginVersion() === 2 && (<PhysicsEngineV2>this._physicsEngine).getBodies().length === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (typeof radiusOrEventOptions === \"number\") {\r\n            const r = radiusOrEventOptions;\r\n            radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\r\n            radiusOrEventOptions.radius = r;\r\n            radiusOrEventOptions.strength = strength ?? radiusOrEventOptions.strength;\r\n            radiusOrEventOptions.falloff = falloff ?? radiusOrEventOptions.falloff;\r\n        }\r\n\r\n        const event = new PhysicsGravitationalFieldEvent(this, this._scene, origin, radiusOrEventOptions);\r\n\r\n        event.dispose(false);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Creates a physics updraft event\r\n     * @param origin the origin of the updraft\r\n     * @param radiusOrEventOptions the radius or the options of the updraft\r\n     * @param strength the strength of the updraft\r\n     * @param height the height of the updraft\r\n     * @param updraftMode possible options: Center & Perpendicular. Defaults to Center\r\n     * @returns A physics updraft event, or null\r\n     */\r\n    public updraft(\r\n        origin: Vector3,\r\n        radiusOrEventOptions: number | PhysicsUpdraftEventOptions,\r\n        strength?: number,\r\n        height?: number,\r\n        updraftMode?: PhysicsUpdraftMode\r\n    ): Nullable<PhysicsUpdraftEvent> {\r\n        if (!this._physicsEngine) {\r\n            Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\r\n            return null;\r\n        }\r\n\r\n        if (this._physicsEngine.getPluginVersion() === 1 && (<PhysicsEngineV1>this._physicsEngine).getImpostors().length === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (this._physicsEngine.getPluginVersion() === 2 && (<PhysicsEngineV2>this._physicsEngine).getBodies().length === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (typeof radiusOrEventOptions === \"number\") {\r\n            const r = radiusOrEventOptions;\r\n            radiusOrEventOptions = new PhysicsUpdraftEventOptions();\r\n            radiusOrEventOptions.radius = r;\r\n            radiusOrEventOptions.strength = strength ?? radiusOrEventOptions.strength;\r\n            radiusOrEventOptions.height = height ?? radiusOrEventOptions.height;\r\n            radiusOrEventOptions.updraftMode = updraftMode ?? radiusOrEventOptions.updraftMode;\r\n        }\r\n\r\n        const event = new PhysicsUpdraftEvent(this._scene, origin, radiusOrEventOptions);\r\n\r\n        event.dispose(false);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Creates a physics vortex event\r\n     * @param origin the of the vortex\r\n     * @param radiusOrEventOptions the radius or the options of the vortex\r\n     * @param strength the strength of the vortex\r\n     * @param height   the height of the vortex\r\n     * @returns a Physics vortex event, or null\r\n     * A physics vortex event or null\r\n     */\r\n    public vortex(origin: Vector3, radiusOrEventOptions: number | PhysicsVortexEventOptions, strength?: number, height?: number): Nullable<PhysicsVortexEvent> {\r\n        if (!this._physicsEngine) {\r\n            Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\r\n            return null;\r\n        }\r\n\r\n        if (this._physicsEngine.getPluginVersion() === 1 && (<PhysicsEngineV1>this._physicsEngine).getImpostors().length === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (this._physicsEngine.getPluginVersion() === 2 && (<PhysicsEngineV2>this._physicsEngine).getBodies().length === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (typeof radiusOrEventOptions === \"number\") {\r\n            const r = radiusOrEventOptions;\r\n            radiusOrEventOptions = new PhysicsVortexEventOptions();\r\n            radiusOrEventOptions.radius = r;\r\n            radiusOrEventOptions.strength = strength ?? radiusOrEventOptions.strength;\r\n            radiusOrEventOptions.height = height ?? radiusOrEventOptions.height;\r\n        }\r\n\r\n        const event = new PhysicsVortexEvent(this._scene, origin, radiusOrEventOptions);\r\n\r\n        event.dispose(false);\r\n\r\n        return event;\r\n    }\r\n\r\n    private _copyPhysicsHitData(data: PhysicsHitData): PhysicsHitData {\r\n        return { force: data.force.clone(), contactPoint: data.contactPoint.clone(), distanceFromOrigin: data.distanceFromOrigin, instanceIndex: data.instanceIndex };\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a physics radial explosion event\r\n */\r\nclass PhysicsRadialExplosionEvent {\r\n    private _sphere: Mesh; // create a sphere, so we can get the intersecting meshes inside\r\n    private _dataFetched: boolean = false; // check if the data has been fetched. If not, do cleanup\r\n\r\n    /**\r\n     * Initializes a radial explosion event\r\n     * @param _scene BabylonJS scene\r\n     * @param _options The options for the vortex event\r\n     */\r\n    constructor(private _scene: Scene, private _options: PhysicsRadialExplosionEventOptions) {\r\n        this._options = { ...new PhysicsRadialExplosionEventOptions(), ...this._options };\r\n    }\r\n\r\n    /**\r\n     * Returns the data related to the radial explosion event (sphere).\r\n     * @returns The radial explosion event data\r\n     */\r\n    public getData(): PhysicsRadialExplosionEventData {\r\n        this._dataFetched = true;\r\n\r\n        return {\r\n            sphere: this._sphere,\r\n        };\r\n    }\r\n\r\n    private _getHitData(mesh: AbstractMesh, center: Vector3, origin: Vector3, data: PhysicsHitData): boolean {\r\n        const direction = TmpVectors.Vector3[0];\r\n        direction.copyFrom(center).subtractInPlace(origin);\r\n\r\n        const contactPoint = TmpVectors.Vector3[1];\r\n        const hasContactPoint = HelperTools.GetContactPointToRef(mesh, origin, direction, contactPoint, data.instanceIndex);\r\n\r\n        if (!hasContactPoint) {\r\n            return false;\r\n        }\r\n\r\n        const distanceFromOrigin = Vector3.Distance(origin, contactPoint);\r\n        if (distanceFromOrigin > this._options.radius) {\r\n            return false;\r\n        }\r\n\r\n        const multiplier =\r\n            this._options.falloff === PhysicsRadialImpulseFalloff.Constant ? this._options.strength : this._options.strength * (1 - distanceFromOrigin / this._options.radius);\r\n\r\n        // Direction x multiplier equals force\r\n        direction.scaleInPlace(multiplier);\r\n\r\n        data.force.copyFrom(direction);\r\n        data.contactPoint.copyFrom(contactPoint);\r\n        data.distanceFromOrigin = distanceFromOrigin;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns the force and contact point of the body or false, if the body is not affected by the force/impulse.\r\n     * @param body A physics body where the transform node is an AbstractMesh\r\n     * @param origin the origin of the explosion\r\n     * @param data the data of the hit\r\n     * @param instanceIndex the instance index of the body\r\n     * @returns if there was a hit\r\n     */\r\n    public getBodyHitData(body: PhysicsBody, origin: Vector3, data: PhysicsHitData, instanceIndex?: number): boolean {\r\n        // No force will be applied in these cases, so we skip calculation\r\n        if (HelperTools.HasAppliedForces(body, instanceIndex)) {\r\n            return false;\r\n        }\r\n\r\n        const mesh = body.transformNode as AbstractMesh;\r\n        const bodyObjectCenter = body.getObjectCenterWorld(instanceIndex);\r\n        data.instanceIndex = instanceIndex;\r\n        return this._getHitData(mesh, bodyObjectCenter, origin, data);\r\n    }\r\n    /**\r\n     * Returns the force and contact point of the impostor or false, if the impostor is not affected by the force/impulse.\r\n     * @param impostor A physics imposter\r\n     * @param origin the origin of the explosion\r\n     * @returns A physics force and contact point, or null\r\n     */\r\n    public getImpostorHitData(impostor: PhysicsImpostor, origin: Vector3, data: PhysicsHitData): boolean {\r\n        if (impostor.mass === 0) {\r\n            return false;\r\n        }\r\n\r\n        if (impostor.object.getClassName() !== \"Mesh\" && impostor.object.getClassName() !== \"InstancedMesh\") {\r\n            return false;\r\n        }\r\n\r\n        const mesh = impostor.object as AbstractMesh;\r\n        if (!this._intersectsWithSphere(mesh, origin, this._options.radius)) {\r\n            return false;\r\n        }\r\n\r\n        const impostorObjectCenter = impostor.getObjectCenter();\r\n\r\n        this._getHitData(mesh, impostorObjectCenter, origin, data);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Triggers affected impostors callbacks\r\n     * @param affectedImpostorsWithData defines the list of affected impostors (including associated data)\r\n     */\r\n    public triggerAffectedImpostorsCallback(affectedImpostorsWithData: Array<PhysicsAffectedImpostorWithData>) {\r\n        if (this._options.affectedImpostorsCallback) {\r\n            this._options.affectedImpostorsCallback(affectedImpostorsWithData);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Triggers affected bodies callbacks\r\n     * @param affectedBodiesWithData defines the list of affected bodies (including associated data)\r\n     */\r\n    public triggerAffectedBodiesCallback(affectedBodiesWithData: Array<PhysicsAffectedBodyWithData>) {\r\n        if (this._options.affectedBodiesCallback) {\r\n            this._options.affectedBodiesCallback(affectedBodiesWithData);\r\n        }\r\n    }\r\n    /**\r\n     * Disposes the sphere.\r\n     * @param force Specifies if the sphere should be disposed by force\r\n     */\r\n    public dispose(force: boolean = true) {\r\n        if (this._sphere) {\r\n            if (force) {\r\n                this._sphere.dispose();\r\n            } else {\r\n                setTimeout(() => {\r\n                    if (!this._dataFetched) {\r\n                        this._sphere.dispose();\r\n                    }\r\n                }, 0);\r\n            }\r\n        }\r\n    }\r\n\r\n    /*** Helpers ***/\r\n\r\n    private _prepareSphere(): void {\r\n        if (!this._sphere) {\r\n            this._sphere = CreateSphere(\"radialExplosionEventSphere\", this._options.sphere, this._scene);\r\n            this._sphere.isVisible = false;\r\n        }\r\n    }\r\n\r\n    private _intersectsWithSphere(mesh: AbstractMesh, origin: Vector3, radius: number): boolean {\r\n        this._prepareSphere();\r\n\r\n        this._sphere.position = origin;\r\n        this._sphere.scaling.setAll(radius * 2);\r\n        this._sphere._updateBoundingInfo();\r\n        this._sphere.computeWorldMatrix(true);\r\n\r\n        return this._sphere.intersectsMesh(mesh, true);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a gravitational field event\r\n */\r\nclass PhysicsGravitationalFieldEvent {\r\n    private _tickCallback: any;\r\n    private _sphere: Mesh;\r\n    private _dataFetched: boolean = false; // check if the has been fetched the data. If not, do cleanup\r\n\r\n    /**\r\n     * Initializes the physics gravitational field event\r\n     * @param _physicsHelper A physics helper\r\n     * @param _scene BabylonJS scene\r\n     * @param _origin The origin position of the gravitational field event\r\n     * @param _options The options for the vortex event\r\n     */\r\n    constructor(private _physicsHelper: PhysicsHelper, private _scene: Scene, private _origin: Vector3, private _options: PhysicsRadialExplosionEventOptions) {\r\n        this._options = { ...new PhysicsRadialExplosionEventOptions(), ...this._options };\r\n\r\n        this._tickCallback = () => this._tick();\r\n\r\n        this._options.strength = this._options.strength * -1;\r\n    }\r\n\r\n    /**\r\n     * Returns the data related to the gravitational field event (sphere).\r\n     * @returns A gravitational field event\r\n     */\r\n    public getData(): PhysicsGravitationalFieldEventData {\r\n        this._dataFetched = true;\r\n\r\n        return {\r\n            sphere: this._sphere,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Enables the gravitational field.\r\n     */\r\n    public enable() {\r\n        this._tickCallback.call(this);\r\n        this._scene.registerBeforeRender(this._tickCallback);\r\n    }\r\n\r\n    /**\r\n     * Disables the gravitational field.\r\n     */\r\n    public disable() {\r\n        this._scene.unregisterBeforeRender(this._tickCallback);\r\n    }\r\n\r\n    /**\r\n     * Disposes the sphere.\r\n     * @param force The force to dispose from the gravitational field event\r\n     */\r\n    public dispose(force: boolean = true) {\r\n        if (!this._sphere) {\r\n            return;\r\n        }\r\n        if (force) {\r\n            this._sphere.dispose();\r\n        } else {\r\n            setTimeout(() => {\r\n                if (!this._dataFetched) {\r\n                    this._sphere.dispose();\r\n                }\r\n            }, 0);\r\n        }\r\n    }\r\n\r\n    private _tick() {\r\n        // Since the params won't change, we fetch the event only once\r\n        if (this._sphere) {\r\n            this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);\r\n        } else {\r\n            const radialExplosionEvent = this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);\r\n            if (radialExplosionEvent) {\r\n                this._sphere = <Mesh>radialExplosionEvent.getData().sphere?.clone(\"radialExplosionEventSphereClone\");\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a physics updraft event\r\n */\r\nclass PhysicsUpdraftEvent {\r\n    private _physicsEngine: PhysicsEngineV1 | PhysicsEngineV2;\r\n    private _originTop: Vector3 = Vector3.Zero(); // the most upper part of the cylinder\r\n    private _originDirection: Vector3 = Vector3.Zero(); // used if the updraftMode is perpendicular\r\n    private _tickCallback: any;\r\n    private _cylinder: Mesh | undefined;\r\n    private _cylinderPosition: Vector3 = Vector3.Zero(); // to keep the cylinders position, because normally the origin is in the center and not on the bottom\r\n    private _dataFetched: boolean = false; // check if the has been fetched the data. If not, do cleanup\r\n    private static _HitData: PhysicsHitData = { force: new Vector3(), contactPoint: new Vector3(), distanceFromOrigin: 0 };\r\n    /**\r\n     * Initializes the physics updraft event\r\n     * @param _scene BabylonJS scene\r\n     * @param _origin The origin position of the updraft\r\n     * @param _options The options for the updraft event\r\n     */\r\n    constructor(private _scene: Scene, private _origin: Vector3, private _options: PhysicsUpdraftEventOptions) {\r\n        this._physicsEngine = this._scene.getPhysicsEngine() as PhysicsEngineV1 | PhysicsEngineV2;\r\n        this._options = { ...new PhysicsUpdraftEventOptions(), ...this._options };\r\n\r\n        this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);\r\n        this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);\r\n\r\n        if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {\r\n            this._originDirection = this._origin.subtract(this._originTop).normalize();\r\n        }\r\n\r\n        this._tickCallback = () => this._tick();\r\n\r\n        if (this._physicsEngine.getPluginVersion() === 1) {\r\n            this._prepareCylinder();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the data related to the updraft event (cylinder).\r\n     * @returns A physics updraft event\r\n     */\r\n    public getData(): PhysicsUpdraftEventData {\r\n        this._dataFetched = true;\r\n\r\n        return {\r\n            cylinder: this._cylinder,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Enables the updraft.\r\n     */\r\n    public enable() {\r\n        this._tickCallback.call(this);\r\n        this._scene.registerBeforeRender(this._tickCallback);\r\n    }\r\n\r\n    /**\r\n     * Disables the updraft.\r\n     */\r\n    public disable() {\r\n        this._scene.unregisterBeforeRender(this._tickCallback);\r\n    }\r\n\r\n    /**\r\n     * Disposes the cylinder.\r\n     * @param force Specifies if the updraft should be disposed by force\r\n     */\r\n    public dispose(force: boolean = true) {\r\n        if (!this._cylinder) {\r\n            return;\r\n        }\r\n        if (force) {\r\n            this._cylinder.dispose();\r\n            this._cylinder = undefined;\r\n        } else {\r\n            setTimeout(() => {\r\n                if (!this._dataFetched && this._cylinder) {\r\n                    this._cylinder.dispose();\r\n                    this._cylinder = undefined;\r\n                }\r\n            }, 0);\r\n        }\r\n    }\r\n\r\n    private _getHitData(center: Vector3, data: PhysicsHitData): void {\r\n        let direction: Vector3;\r\n        if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {\r\n            direction = this._originDirection;\r\n        } else {\r\n            direction = center.subtract(this._originTop);\r\n        }\r\n\r\n        const distanceFromOrigin = Vector3.Distance(this._origin, center);\r\n\r\n        const multiplier = this._options.strength * -1;\r\n\r\n        const force = direction.multiplyByFloats(multiplier, multiplier, multiplier);\r\n\r\n        data.force.copyFrom(force);\r\n        data.contactPoint.copyFrom(center);\r\n        data.distanceFromOrigin = distanceFromOrigin;\r\n    }\r\n\r\n    private _getBodyHitData(body: PhysicsBody, data: PhysicsHitData, instanceIndex?: number): boolean {\r\n        if (HelperTools.HasAppliedForces(body)) {\r\n            return false;\r\n        }\r\n\r\n        const center = body.getObjectCenterWorld(instanceIndex);\r\n\r\n        if (!HelperTools.IsInsideCylinder(center, this._origin, this._options.radius, this._options.height)) {\r\n            return false;\r\n        }\r\n\r\n        data.instanceIndex = instanceIndex;\r\n        this._getHitData(center, data);\r\n        return true;\r\n    }\r\n\r\n    private _getImpostorHitData(impostor: PhysicsImpostor, data: PhysicsHitData): boolean {\r\n        if (impostor.mass === 0) {\r\n            return false;\r\n        }\r\n\r\n        const impostorObject = <AbstractMesh>impostor.object;\r\n        if (!this._intersectsWithCylinder(impostorObject)) {\r\n            return false;\r\n        }\r\n\r\n        const center = impostor.getObjectCenter();\r\n        this._getHitData(center, data);\r\n        return true;\r\n    }\r\n\r\n    private _tick() {\r\n        const hitData = PhysicsUpdraftEvent._HitData;\r\n        if (this._physicsEngine.getPluginVersion() === 1) {\r\n            (<PhysicsEngineV1>this._physicsEngine).getImpostors().forEach((impostor: PhysicsImpostor) => {\r\n                if (!this._getImpostorHitData(impostor, hitData)) {\r\n                    return;\r\n                }\r\n\r\n                impostor.applyForce(hitData.force, hitData.contactPoint);\r\n            });\r\n        } else {\r\n            // V2\r\n            (<PhysicsEngineV2>this._physicsEngine).getBodies().forEach((body: PhysicsBody) => {\r\n                body.iterateOverAllInstances((body, instanceIndex) => {\r\n                    if (!this._getBodyHitData(body, hitData, instanceIndex)) {\r\n                        return;\r\n                    }\r\n\r\n                    body.applyForce(hitData.force, hitData.contactPoint, hitData.instanceIndex);\r\n                });\r\n            });\r\n        }\r\n    }\r\n\r\n    /*** Helpers ***/\r\n\r\n    private _prepareCylinder(): void {\r\n        if (!this._cylinder) {\r\n            this._cylinder = CreateCylinder(\r\n                \"updraftEventCylinder\",\r\n                {\r\n                    height: this._options.height,\r\n                    diameter: this._options.radius * 2,\r\n                },\r\n                this._scene\r\n            );\r\n            this._cylinder.isVisible = false;\r\n        }\r\n    }\r\n\r\n    private _intersectsWithCylinder(mesh: AbstractMesh): boolean {\r\n        if (!this._cylinder) {\r\n            return false;\r\n        }\r\n        this._cylinder.position = this._cylinderPosition;\r\n        return this._cylinder.intersectsMesh(mesh, true);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a physics vortex event\r\n */\r\nclass PhysicsVortexEvent {\r\n    private _physicsEngine: PhysicsEngineV1 | PhysicsEngineV2;\r\n    private _originTop: Vector3 = Vector3.Zero(); // the most upper part of the cylinder\r\n    private _tickCallback: any;\r\n    private _cylinder: Mesh;\r\n    private _cylinderPosition: Vector3 = Vector3.Zero(); // to keep the cylinders position, because normally the origin is in the center and not on the bottom\r\n    private _dataFetched: boolean = false; // check if the has been fetched the data. If not, do cleanup\r\n    private static originOnPlane: Vector3 = Vector3.Zero();\r\n    private static hitData: PhysicsHitData = { force: new Vector3(), contactPoint: new Vector3(), distanceFromOrigin: 0 };\r\n\r\n    /**\r\n     * Initializes the physics vortex event\r\n     * @param _scene The BabylonJS scene\r\n     * @param _origin The origin position of the vortex\r\n     * @param _options The options for the vortex event\r\n     */\r\n    constructor(private _scene: Scene, private _origin: Vector3, private _options: PhysicsVortexEventOptions) {\r\n        this._physicsEngine = this._scene.getPhysicsEngine() as PhysicsEngineV1 | PhysicsEngineV2;\r\n        this._options = { ...new PhysicsVortexEventOptions(), ...this._options };\r\n\r\n        this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);\r\n        this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);\r\n\r\n        this._tickCallback = () => this._tick();\r\n\r\n        if (this._physicsEngine.getPluginVersion() === 1) {\r\n            this._prepareCylinder();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the data related to the vortex event (cylinder).\r\n     * @returns The physics vortex event data\r\n     */\r\n    public getData(): PhysicsVortexEventData {\r\n        this._dataFetched = true;\r\n\r\n        return {\r\n            cylinder: this._cylinder,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Enables the vortex.\r\n     */\r\n    public enable() {\r\n        this._tickCallback.call(this);\r\n        this._scene.registerBeforeRender(this._tickCallback);\r\n    }\r\n\r\n    /**\r\n     * Disables the cortex.\r\n     */\r\n    public disable() {\r\n        this._scene.unregisterBeforeRender(this._tickCallback);\r\n    }\r\n\r\n    /**\r\n     * Disposes the sphere.\r\n     * @param force\r\n     */\r\n    public dispose(force: boolean = true) {\r\n        if (!this._cylinder) {\r\n            return;\r\n        }\r\n        if (force) {\r\n            this._cylinder.dispose();\r\n        } else {\r\n            setTimeout(() => {\r\n                if (!this._dataFetched) {\r\n                    this._cylinder.dispose();\r\n                }\r\n            }, 0);\r\n        }\r\n    }\r\n\r\n    private _getHitData(mesh: AbstractMesh, center: Vector3, data: PhysicsHitData): boolean {\r\n        const originOnPlane = PhysicsVortexEvent.originOnPlane;\r\n        originOnPlane.set(this._origin.x, center.y, this._origin.z); // the distance to the origin as if both objects were on a plane (Y-axis)\r\n        const originToImpostorDirection = TmpVectors.Vector3[0];\r\n        center.subtractToRef(originOnPlane, originToImpostorDirection);\r\n\r\n        const contactPoint = TmpVectors.Vector3[1];\r\n        const hasContactPoint = HelperTools.GetContactPointToRef(mesh, originOnPlane, originToImpostorDirection, contactPoint, data.instanceIndex);\r\n        if (!hasContactPoint) {\r\n            return false;\r\n        }\r\n        const distance = Vector3.Distance(contactPoint, originOnPlane);\r\n        const absoluteDistanceFromOrigin = distance / this._options.radius;\r\n\r\n        const directionToOrigin = TmpVectors.Vector3[2];\r\n        contactPoint.normalizeToRef(directionToOrigin);\r\n        if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {\r\n            directionToOrigin.negateInPlace();\r\n        }\r\n\r\n        let forceX: number;\r\n        let forceY: number;\r\n        let forceZ: number;\r\n\r\n        if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {\r\n            forceX = directionToOrigin.x * this._options.centripetalForceMultiplier;\r\n            forceY = directionToOrigin.y * this._options.updraftForceMultiplier;\r\n            forceZ = directionToOrigin.z * this._options.centripetalForceMultiplier;\r\n        } else {\r\n            const perpendicularDirection = Vector3.Cross(originOnPlane, center).normalize();\r\n\r\n            forceX = (perpendicularDirection.x + directionToOrigin.x) * this._options.centrifugalForceMultiplier;\r\n            forceY = this._originTop.y * this._options.updraftForceMultiplier;\r\n            forceZ = (perpendicularDirection.z + directionToOrigin.z) * this._options.centrifugalForceMultiplier;\r\n        }\r\n\r\n        const force = TmpVectors.Vector3[3];\r\n        force.set(forceX, forceY, forceZ);\r\n        force.scaleInPlace(this._options.strength);\r\n\r\n        data.force.copyFrom(force);\r\n        data.contactPoint.copyFrom(center);\r\n        data.distanceFromOrigin = absoluteDistanceFromOrigin;\r\n        return true;\r\n    }\r\n\r\n    private _getBodyHitData(body: PhysicsBody, data: PhysicsHitData, instanceIndex?: number): boolean {\r\n        if (HelperTools.HasAppliedForces(body, instanceIndex)) {\r\n            return false;\r\n        }\r\n\r\n        const bodyObject = body.transformNode as AbstractMesh;\r\n        const bodyCenter = body.getObjectCenterWorld(instanceIndex);\r\n\r\n        if (!HelperTools.IsInsideCylinder(bodyCenter, this._origin, this._options.radius, this._options.height)) {\r\n            return false;\r\n        }\r\n\r\n        data.instanceIndex = instanceIndex;\r\n        return this._getHitData(bodyObject, bodyCenter, data);\r\n    }\r\n\r\n    private _getImpostorHitData(impostor: PhysicsImpostor, data: PhysicsHitData): boolean {\r\n        if (impostor.mass === 0) {\r\n            return false;\r\n        }\r\n\r\n        if (impostor.object.getClassName() !== \"Mesh\" && impostor.object.getClassName() !== \"InstancedMesh\") {\r\n            return false;\r\n        }\r\n\r\n        const impostorObject = impostor.object as AbstractMesh;\r\n        if (!this._intersectsWithCylinder(impostorObject)) {\r\n            return false;\r\n        }\r\n\r\n        const impostorObjectCenter = impostor.getObjectCenter();\r\n        this._getHitData(impostorObject, impostorObjectCenter, data);\r\n        return true;\r\n    }\r\n\r\n    private _tick() {\r\n        const hitData = PhysicsVortexEvent.hitData;\r\n        if (this._physicsEngine.getPluginVersion() === 1) {\r\n            (<PhysicsEngineV1>this._physicsEngine).getImpostors().forEach((impostor: PhysicsImpostor) => {\r\n                if (!this._getImpostorHitData(impostor, hitData)) {\r\n                    return;\r\n                }\r\n\r\n                impostor.applyForce(hitData.force, hitData.contactPoint);\r\n            });\r\n        } else {\r\n            (<PhysicsEngineV2>this._physicsEngine).getBodies().forEach((body: PhysicsBody) => {\r\n                body.iterateOverAllInstances((body: PhysicsBody, instanceIndex?: number) => {\r\n                    if (!this._getBodyHitData(body, hitData, instanceIndex)) {\r\n                        return;\r\n                    }\r\n\r\n                    body.applyForce(hitData.force, hitData.contactPoint, hitData.instanceIndex);\r\n                });\r\n            });\r\n        }\r\n    }\r\n\r\n    /*** Helpers ***/\r\n\r\n    private _prepareCylinder(): void {\r\n        if (!this._cylinder) {\r\n            this._cylinder = CreateCylinder(\r\n                \"vortexEventCylinder\",\r\n                {\r\n                    height: this._options.height,\r\n                    diameter: this._options.radius * 2,\r\n                },\r\n                this._scene\r\n            );\r\n            this._cylinder.isVisible = false;\r\n        }\r\n    }\r\n\r\n    private _intersectsWithCylinder(mesh: AbstractMesh): boolean {\r\n        this._cylinder.position = this._cylinderPosition;\r\n\r\n        return this._cylinder.intersectsMesh(mesh, true);\r\n    }\r\n}\r\n\r\n/**\r\n * Options fot the radial explosion event\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\r\n */\r\nexport class PhysicsRadialExplosionEventOptions {\r\n    /**\r\n     * The radius of the sphere for the radial explosion.\r\n     */\r\n    radius: number = 5;\r\n\r\n    /**\r\n     * The strength of the explosion.\r\n     */\r\n    strength: number = 10;\r\n\r\n    /**\r\n     * The strength of the force in correspondence to the distance of the affected object\r\n     */\r\n    falloff: PhysicsRadialImpulseFalloff = PhysicsRadialImpulseFalloff.Constant;\r\n\r\n    /**\r\n     * Sphere options for the radial explosion.\r\n     */\r\n    sphere: { segments: number; diameter: number } = { segments: 32, diameter: 1 };\r\n\r\n    /**\r\n     * Sphere options for the radial explosion.\r\n     */\r\n    affectedImpostorsCallback: (affectedImpostorsWithData: Array<PhysicsAffectedImpostorWithData>) => void;\r\n\r\n    /**\r\n     * Sphere options for the radial explosion.\r\n     */\r\n    affectedBodiesCallback: (affectedBodiesWithData: Array<PhysicsAffectedBodyWithData>) => void;\r\n}\r\n\r\n/**\r\n * Options fot the updraft event\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\r\n */\r\nexport class PhysicsUpdraftEventOptions {\r\n    /**\r\n     * The radius of the cylinder for the vortex\r\n     */\r\n    radius: number = 5;\r\n\r\n    /**\r\n     * The strength of the updraft.\r\n     */\r\n    strength: number = 10;\r\n\r\n    /**\r\n     * The height of the cylinder for the updraft.\r\n     */\r\n    height: number = 10;\r\n\r\n    /**\r\n     * The mode for the the updraft.\r\n     */\r\n    updraftMode: PhysicsUpdraftMode = PhysicsUpdraftMode.Center;\r\n}\r\n\r\n/**\r\n * Options fot the vortex event\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\r\n */\r\nexport class PhysicsVortexEventOptions {\r\n    /**\r\n     * The radius of the cylinder for the vortex\r\n     */\r\n    radius: number = 5;\r\n\r\n    /**\r\n     * The strength of the vortex.\r\n     */\r\n    strength: number = 10;\r\n\r\n    /**\r\n     * The height of the cylinder for the vortex.\r\n     */\r\n    height: number = 10;\r\n\r\n    /**\r\n     * At which distance, relative to the radius the centripetal forces should kick in? Range: 0-1\r\n     */\r\n    centripetalForceThreshold: number = 0.7;\r\n\r\n    /**\r\n     * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when below the threshold.\r\n     */\r\n    centripetalForceMultiplier: number = 5;\r\n\r\n    /**\r\n     * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when above the threshold.\r\n     */\r\n    centrifugalForceMultiplier: number = 0.5;\r\n\r\n    /**\r\n     * This multiplier determines with how much force the objects will be pushed upwards, when in the vortex.\r\n     */\r\n    updraftForceMultiplier: number = 0.02;\r\n}\r\n\r\n/**\r\n * The strength of the force in correspondence to the distance of the affected object\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\r\n */\r\nexport enum PhysicsRadialImpulseFalloff {\r\n    /** Defines that impulse is constant in strength across it's whole radius */\r\n    Constant,\r\n    /** Defines that impulse gets weaker if it's further from the origin */\r\n    Linear,\r\n}\r\n\r\n/**\r\n * The strength of the force in correspondence to the distance of the affected object\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\r\n */\r\nexport enum PhysicsUpdraftMode {\r\n    /** Defines that the upstream forces will pull towards the top center of the cylinder */\r\n    Center,\r\n    /** Defines that once a impostor is inside the cylinder, it will shoot out perpendicular from the ground of the cylinder */\r\n    Perpendicular,\r\n}\r\n\r\n/**\r\n * Interface for a physics hit data\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\r\n */\r\nexport interface PhysicsHitData {\r\n    /**\r\n     * The force applied at the contact point\r\n     */\r\n    force: Vector3;\r\n    /**\r\n     * The contact point\r\n     */\r\n    contactPoint: Vector3;\r\n    /**\r\n     * The distance from the origin to the contact point\r\n     */\r\n    distanceFromOrigin: number;\r\n    /**\r\n     * For an instanced physics body (mesh with thin instances), the index of the thin instance the hit applies to\r\n     */\r\n    instanceIndex?: number;\r\n}\r\n\r\n/**\r\n * Interface for radial explosion event data\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\r\n */\r\nexport interface PhysicsRadialExplosionEventData {\r\n    /**\r\n     * A sphere used for the radial explosion event\r\n     */\r\n    sphere: Mesh;\r\n}\r\n\r\n/**\r\n * Interface for gravitational field event data\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\r\n */\r\nexport interface PhysicsGravitationalFieldEventData {\r\n    /**\r\n     * A sphere mesh used for the gravitational field event\r\n     */\r\n    sphere: Mesh;\r\n}\r\n\r\n/**\r\n * Interface for updraft event data\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\r\n */\r\nexport interface PhysicsUpdraftEventData {\r\n    /**\r\n     * A cylinder used for the updraft event\r\n     */\r\n    cylinder?: Mesh;\r\n}\r\n\r\n/**\r\n * Interface for vortex event data\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\r\n */\r\nexport interface PhysicsVortexEventData {\r\n    /**\r\n     * A cylinder used for the vortex event\r\n     */\r\n    cylinder: Mesh;\r\n}\r\n\r\n/**\r\n * Interface for an affected physics impostor\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\r\n */\r\nexport interface PhysicsAffectedImpostorWithData {\r\n    /**\r\n     * The impostor affected by the effect\r\n     */\r\n    impostor: PhysicsImpostor;\r\n\r\n    /**\r\n     * The data about the hit/force from the explosion\r\n     */\r\n    hitData: PhysicsHitData;\r\n}\r\n\r\n/**\r\n * Interface for an affected physics body\r\n * @see\r\n */\r\nexport interface PhysicsAffectedBodyWithData {\r\n    /**\r\n     * The impostor affected by the effect\r\n     */\r\n    body: PhysicsBody;\r\n\r\n    /**\r\n     * The data about the hit/force from the explosion\r\n     */\r\n    hitData: PhysicsHitData;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}