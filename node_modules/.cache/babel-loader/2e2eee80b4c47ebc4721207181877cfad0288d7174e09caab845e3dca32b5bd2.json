{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Quaternion, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { Buffer } from \"../../Buffers/buffer.js\";\nimport { DeepCopier } from \"../../Misc/deepCopier.js\";\nimport { GreasedLineTools } from \"../../Misc/greasedLineTools.js\";\nimport { GreasedLineBaseMesh, GreasedLineRibbonAutoDirectionMode, GreasedLineRibbonFacesMode, GreasedLineRibbonPointsMode } from \"./greasedLineBaseMesh.js\";\nMesh._GreasedLineRibbonMeshParser = (parsedMesh, scene) => {\n  return GreasedLineRibbonMesh.Parse(parsedMesh, scene);\n};\n/**\n * GreasedLineRibbonMesh\n * Use the GreasedLineBuilder.CreateGreasedLine function to create an instance of this class.\n */\nexport class GreasedLineRibbonMesh extends GreasedLineBaseMesh {\n  /**\n   * GreasedLineRibbonMesh\n   * @param name name of the mesh\n   * @param scene the scene\n   * @param _options mesh options\n   * @param _pathOptions used internaly when parsing a serialized GreasedLineRibbonMesh\n   */\n  constructor(name, scene, _options, _pathOptions) {\n    var _a;\n    super(name, scene, _options);\n    this.name = name;\n    if (!_options.ribbonOptions) {\n      throw \"'GreasedLineMeshOptions.ribbonOptions' is not set.\";\n    }\n    this._paths = [];\n    this._counters = [];\n    this._slopes = [];\n    this._widths = (_a = _options.widths) !== null && _a !== void 0 ? _a : [];\n    this._ribbonWidths = [];\n    this._pathsOptions = _pathOptions !== null && _pathOptions !== void 0 ? _pathOptions : [];\n    if (_options.points) {\n      this.addPoints(GreasedLineTools.ConvertPoints(_options.points), _options, !!_pathOptions);\n    }\n  }\n  /**\n   * Adds new points to the line. It doesn't rerenders the line if in lazy mode.\n   * @param points points table\n   */\n  addPoints(points, options, hasPathOptions = false) {\n    if (!options.ribbonOptions) {\n      throw \"addPoints() on GreasedLineRibbonMesh instance requires 'GreasedLineMeshOptions.ribbonOptions'.\";\n    }\n    if (!hasPathOptions) {\n      this._pathsOptions.push({\n        options,\n        pathCount: points.length\n      });\n    }\n    super.addPoints(points, options);\n  }\n  /**\n   * \"GreasedLineRibbonMesh\"\n   * @returns \"GreasedLineRibbonMesh\"\n   */\n  getClassName() {\n    return \"GreasedLineRibbonMesh\";\n  }\n  /**\n   * Return true if the line was created from two edge paths or one points path.\n   * In this case the line is always flat.\n   */\n  get isFlatLine() {\n    return this._paths.length < 3;\n  }\n  /**\n   * Returns the slopes of the line at each point relative to the center of the line\n   */\n  get slopes() {\n    return this._slopes;\n  }\n  /**\n   * Set the slopes of the line at each point relative to the center of the line\n   */\n  set slopes(slopes) {\n    this._slopes = slopes;\n  }\n  _updateColorPointers() {\n    if (this._options.colorPointers) {\n      return;\n    }\n    let colorPointer = 0;\n    this._colorPointers = [];\n    for (let i = 0; i < this._pathsOptions.length; i++) {\n      const {\n        options: pathOptions,\n        pathCount\n      } = this._pathsOptions[i];\n      const points = this._points[i];\n      if (pathOptions.ribbonOptions.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_POINTS) {\n        for (let k = 0; k < pathCount; k++) {\n          for (let j = 0; j < points.length; j += 3) {\n            this._colorPointers.push(colorPointer);\n            this._colorPointers.push(colorPointer++);\n          }\n        }\n      } else {\n        for (let j = 0; j < points.length; j += 3) {\n          for (let k = 0; k < pathCount; k++) {\n            this._colorPointers.push(colorPointer);\n          }\n          colorPointer++;\n        }\n      }\n    }\n  }\n  _updateWidths() {\n    super._updateWidthsWithValue(1);\n  }\n  _setPoints(points, _options) {\n    var _a, _b;\n    if (!this._options.ribbonOptions) {\n      throw \"No 'GreasedLineMeshOptions.ribbonOptions' provided.\";\n    }\n    this._points = points;\n    this._options.points = points;\n    this._initGreasedLine();\n    let indiceOffset = 0;\n    let directionPlanes;\n    for (let i = 0, c = 0; i < this._pathsOptions.length; i++) {\n      const {\n        options: pathOptions,\n        pathCount\n      } = this._pathsOptions[i];\n      const subPoints = points.slice(c, c + pathCount);\n      c += pathCount;\n      if (((_a = pathOptions.ribbonOptions) === null || _a === void 0 ? void 0 : _a.pointsMode) === GreasedLineRibbonPointsMode.POINTS_MODE_PATHS) {\n        indiceOffset = this._preprocess(GreasedLineTools.ToVector3Array(subPoints), indiceOffset, pathOptions);\n      } else {\n        if (((_b = pathOptions.ribbonOptions) === null || _b === void 0 ? void 0 : _b.directionsAutoMode) === GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_NONE) {\n          if (!pathOptions.ribbonOptions.directions) {\n            throw \"In GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_NONE 'GreasedLineMeshOptions.ribbonOptions.directions' must be defined.\";\n          }\n          directionPlanes = GreasedLineRibbonMesh._GetDirectionPlanesFromDirectionsOption(subPoints.length, pathOptions.ribbonOptions.directions);\n        }\n        subPoints.forEach((p, idx) => {\n          const pathArray = GreasedLineRibbonMesh._ConvertToRibbonPath(p, pathOptions.ribbonOptions, this._scene.useRightHandedSystem, directionPlanes ? directionPlanes[idx] : directionPlanes);\n          indiceOffset = this._preprocess(pathArray, indiceOffset, pathOptions);\n        });\n      }\n    }\n    if (!this._lazy) {\n      this._createVertexBuffers();\n      this.refreshBoundingInfo();\n    }\n  }\n  static _GetDirectionPlanesFromDirectionsOption(count, directions) {\n    if (Array.isArray(directions)) {\n      return directions;\n    }\n    return new Array(count).fill(directions);\n  }\n  static _CreateRibbonVertexData(pathArray, options) {\n    var _a, _b, _c;\n    const numOfPaths = pathArray.length;\n    if (numOfPaths < 2) {\n      throw \"Minimum of two paths are required to create a GreasedLineRibbonMesh.\";\n    }\n    const positions = [];\n    const indices = [];\n    const path = pathArray[0];\n    for (let i = 0; i < path.length; i++) {\n      for (let pi = 0; pi < pathArray.length; pi++) {\n        const v = pathArray[pi][i];\n        positions.push(v.x, v.y, v.z);\n      }\n    }\n    const v = [1, 0, numOfPaths];\n    const doubleSided = (_b = ((_a = options.ribbonOptions) === null || _a === void 0 ? void 0 : _a.facesMode) === GreasedLineRibbonFacesMode.FACES_MODE_DOUBLE_SIDED) !== null && _b !== void 0 ? _b : false;\n    const closePath = ((_c = options.ribbonOptions) === null || _c === void 0 ? void 0 : _c.pointsMode) === GreasedLineRibbonPointsMode.POINTS_MODE_PATHS && options.ribbonOptions.closePath;\n    if (numOfPaths > 2) {\n      for (let i = 0; i < path.length - 1; i++) {\n        v[0] = 1 + numOfPaths * i;\n        v[1] = numOfPaths * i;\n        v[2] = (i + 1) * numOfPaths;\n        for (let pi = 0; pi < (numOfPaths - 1) * 2; pi++) {\n          if (pi % 2 !== 0) {\n            v[2] += 1;\n          }\n          if (pi % 2 === 0 && pi > 0) {\n            v[0] += 1;\n            v[1] += 1;\n          }\n          indices.push(v[1] + (pi % 2 !== 0 ? numOfPaths : 0), v[0], v[2]);\n          if (doubleSided) {\n            indices.push(v[0], v[1] + (pi % 2 !== 0 ? numOfPaths : 0), v[2]);\n          }\n        }\n      }\n    } else {\n      for (let i = 0; i < positions.length / 3 - 3; i += 2) {\n        indices.push(i, i + 1, i + 2);\n        indices.push(i + 2, i + 1, i + 3);\n        if (doubleSided) {\n          indices.push(i + 1, i, i + 2);\n          indices.push(i + 1, i + 2, i + 3);\n        }\n      }\n    }\n    if (closePath) {\n      let lastIndice = numOfPaths * (path.length - 1);\n      for (let pi = 0; pi < numOfPaths - 1; pi++) {\n        indices.push(lastIndice, pi + 1, pi);\n        indices.push(lastIndice + 1, pi + 1, lastIndice);\n        if (doubleSided) {\n          indices.push(pi, pi + 1, lastIndice);\n          indices.push(lastIndice, pi + 1, lastIndice + 1);\n        }\n        lastIndice++;\n      }\n    }\n    return {\n      positions,\n      indices\n    };\n  }\n  _preprocess(pathArray, indiceOffset, options) {\n    var _a, _b, _c, _d;\n    this._paths = pathArray;\n    const ribbonVertexData = GreasedLineRibbonMesh._CreateRibbonVertexData(pathArray, options);\n    const positions = ribbonVertexData.positions;\n    if (!this._options.widths) {\n      throw \"No 'GreasedLineMeshOptions.widths' table is specified.\";\n    }\n    for (const p of positions) {\n      this._vertexPositions.push(p);\n    }\n    let pathArrayCopy = pathArray;\n    if (((_a = options.ribbonOptions) === null || _a === void 0 ? void 0 : _a.pointsMode) === GreasedLineRibbonPointsMode.POINTS_MODE_PATHS && options.ribbonOptions.closePath) {\n      pathArrayCopy = [];\n      for (let i = 0; i < pathArray.length; i++) {\n        const pathCopy = pathArray[i].slice();\n        pathCopy.push(pathArray[i][0].clone());\n        pathArrayCopy.push(pathCopy);\n      }\n    }\n    this._calculateSegmentLengths(pathArrayCopy);\n    const pathArrayLength = pathArrayCopy.length;\n    const previousCounters = new Array(pathArrayLength).fill(0);\n    for (let i = 0; i < pathArrayCopy[0].length; i++) {\n      let v = 0;\n      for (let pi = 0; pi < pathArrayLength; pi++) {\n        const counter = previousCounters[pi] + this._vSegmentLengths[pi][i] / this._vTotalLengths[pi];\n        this._counters.push(counter);\n        this._uvs.push(counter, v);\n        previousCounters[pi] = counter;\n        v += this._uSegmentLengths[i][pi] / this._uTotalLengths[i];\n      }\n    }\n    for (let i = 0, c = 0; i < pathArrayCopy[0].length; i++) {\n      const widthLower = this._uSegmentLengths[i][0] / 2;\n      const widthUpper = this._uSegmentLengths[i][pathArrayLength - 1] / 2;\n      this._ribbonWidths.push((((_b = this._widths[c++]) !== null && _b !== void 0 ? _b : 1) - 1) * widthLower);\n      for (let pi = 0; pi < pathArrayLength - 2; pi++) {\n        this._ribbonWidths.push(0);\n      }\n      this._ribbonWidths.push((((_c = this._widths[c++]) !== null && _c !== void 0 ? _c : 1) - 1) * widthUpper);\n    }\n    const slopes = ((_d = options.ribbonOptions) === null || _d === void 0 ? void 0 : _d.pointsMode) === GreasedLineRibbonPointsMode.POINTS_MODE_PATHS ? new Array(pathArrayCopy[0].length * pathArrayCopy.length * 6).fill(0) : GreasedLineRibbonMesh._CalculateSlopes(pathArrayCopy);\n    for (const s of slopes) {\n      this._slopes.push(s);\n    }\n    if (ribbonVertexData.indices) {\n      for (let i = 0; i < ribbonVertexData.indices.length; i++) {\n        this._indices.push(ribbonVertexData.indices[i] + indiceOffset);\n      }\n    }\n    indiceOffset += positions.length / 3;\n    return indiceOffset;\n  }\n  static _ConvertToRibbonPath(points, ribbonInfo, rightHandedSystem, directionPlane) {\n    if (ribbonInfo.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_POINTS && !ribbonInfo.width) {\n      throw \"'GreasedLineMeshOptions.ribbonOptiosn.width' must be specified in GreasedLineRibbonPointsMode.POINTS_MODE_POINTS.\";\n    }\n    const path1 = [];\n    const path2 = [];\n    if (ribbonInfo.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_POINTS) {\n      const width = ribbonInfo.width / 2;\n      const pointVectors = GreasedLineTools.ToVector3Array(points);\n      let direction = null;\n      let fatDirection = null;\n      if (ribbonInfo.directionsAutoMode === GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT) {\n        // set the direction plane from the first line segment for the whole line\n        directionPlane = GreasedLineRibbonMesh._GetDirectionFromPoints(pointVectors[0], pointVectors[1], null);\n      }\n      for (let i = 0; i < pointVectors.length - (directionPlane ? 0 : 1); i++) {\n        const p1 = pointVectors[i];\n        const p2 = pointVectors[i + 1];\n        if (directionPlane) {\n          direction = directionPlane;\n        } else if (ribbonInfo.directionsAutoMode === GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS) {\n          direction = GreasedLineRibbonMesh._GetDirectionFromPoints(p1, p2, direction);\n        } else {\n          // GreasedLineRibbonAutoDirectionMode.DIRECTION_ENHANCED\n          const directionTemp = p2.subtract(p1);\n          directionTemp.applyRotationQuaternionInPlace(directionTemp.x > directionTemp.y && directionTemp.x > directionTemp.z ? rightHandedSystem ? GreasedLineRibbonMesh._RightHandedForwardReadOnlyQuaternion : GreasedLineRibbonMesh._LeftHandedForwardReadOnlyQuaternion : GreasedLineRibbonMesh._LeftReadOnlyQuaternion);\n          direction = directionTemp.normalize();\n        }\n        fatDirection = direction.multiplyByFloats(width, width, width);\n        path1.push(p1.add(fatDirection));\n        path2.push(p1.subtract(fatDirection));\n      }\n      if (!directionPlane) {\n        path1.push(pointVectors[pointVectors.length - 1].add(fatDirection));\n        path2.push(pointVectors[pointVectors.length - 1].subtract(fatDirection));\n      }\n    }\n    return [path1, path2];\n  }\n  static _GetDirectionFromPoints(p1, p2, previousDirection) {\n    // handle straight lines\n    if (p1.x === p2.x && (!previousDirection || (previousDirection === null || previousDirection === void 0 ? void 0 : previousDirection.x) === 1)) {\n      return GreasedLineRibbonMesh.DIRECTION_YZ;\n    }\n    if (p1.y === p2.y) {\n      return GreasedLineRibbonMesh.DIRECTION_XZ;\n    }\n    if (p1.z === p2.z) {\n      return GreasedLineRibbonMesh.DIRECTION_XY;\n    }\n    return GreasedLineRibbonMesh.DIRECTION_XZ;\n  }\n  /**\n   * Clones the GreasedLineRibbonMesh.\n   * @param name new line name\n   * @param newParent new parent node\n   * @returns cloned line\n   */\n  clone(name = `${this.name}-cloned`, newParent) {\n    const lineOptions = this._createLineOptions();\n    const deepCopiedLineOptions = {};\n    const pathOptionsCloned = [];\n    DeepCopier.DeepCopy(this._pathsOptions, pathOptionsCloned);\n    DeepCopier.DeepCopy(lineOptions, deepCopiedLineOptions, [\"instance\"]);\n    const cloned = new GreasedLineRibbonMesh(name, this._scene, deepCopiedLineOptions, pathOptionsCloned);\n    if (newParent) {\n      cloned.parent = newParent;\n    }\n    cloned.material = this.material;\n    return cloned;\n  }\n  /**\n   * Serializes this GreasedLineRibbonMesh\n   * @param serializationObject object to write serialization to\n   */\n  serialize(serializationObject) {\n    super.serialize(serializationObject);\n    serializationObject.type = this.getClassName();\n    serializationObject.lineOptions = this._createLineOptions();\n    serializationObject.pathsOptions = this._pathsOptions;\n  }\n  /**\n   * Parses a serialized GreasedLineRibbonMesh\n   * @param parsedMesh the serialized GreasedLineRibbonMesh\n   * @param scene the scene to create the GreasedLineRibbonMesh in\n   * @returns the created GreasedLineRibbonMesh\n   */\n  static Parse(parsedMesh, scene) {\n    const lineOptions = parsedMesh.lineOptions;\n    const name = parsedMesh.name;\n    const pathOptions = parsedMesh.pathOptions;\n    const result = new GreasedLineRibbonMesh(name, scene, lineOptions, pathOptions);\n    return result;\n  }\n  _initGreasedLine() {\n    super._initGreasedLine();\n    this._paths = [];\n    this._counters = [];\n    this._slopes = [];\n    this._ribbonWidths = [];\n  }\n  _calculateSegmentLengths(pathArray) {\n    const pathArrayLength = pathArray.length;\n    this._vSegmentLengths = new Array(pathArrayLength);\n    this._vTotalLengths = new Array(pathArrayLength);\n    let length = 0;\n    for (let pi = 0; pi < pathArrayLength; pi++) {\n      const points = pathArray[pi];\n      this._vSegmentLengths[pi] = [0]; // first point has 0 distance\n      length = 0;\n      for (let i = 0; i < points.length - 1; i++) {\n        const l = Math.abs(points[i].subtract(points[i + 1]).lengthSquared()); // it's ok to have lengthSquared() here\n        length += l;\n        this._vSegmentLengths[pi].push(l);\n      }\n      this._vTotalLengths[pi] = length;\n    }\n    const positionsLength = pathArray[0].length;\n    this._uSegmentLengths = new Array(positionsLength).fill([]);\n    this._uTotalLengths = new Array(positionsLength).fill([]);\n    const uLength = new Vector3();\n    for (let i = 0; i < positionsLength; i++) {\n      length = 0;\n      for (let pi = 1; pi < pathArrayLength; pi++) {\n        pathArray[pi][i].subtractToRef(pathArray[pi - 1][i], uLength);\n        const l = uLength.length(); // must be length()\n        length += l;\n        this._uSegmentLengths[i].push(l);\n      }\n      this._uTotalLengths[i] = length;\n    }\n  }\n  static _CalculateSlopes(paths) {\n    const points1 = paths[0];\n    const points2 = paths.length === 2 ? paths[1] : paths[paths.length - 1];\n    const slopes = [];\n    const slope = new Vector3();\n    for (let i = 0; i < points1.length; i++) {\n      for (let pi = 0; pi < paths.length; pi++) {\n        if (pi === 0 || pi === paths.length - 1) {\n          points1[i].subtract(points2[i]).normalizeToRef(slope);\n          slopes.push(slope.x, slope.y, slope.z);\n          slopes.push(-slope.x, -slope.y, -slope.z);\n        } else {\n          slopes.push(0, 0, 0, 0, 0, 0);\n        }\n      }\n    }\n    return slopes;\n  }\n  _createVertexBuffers() {\n    var _a, _b;\n    this._uvs = (_a = this._options.uvs) !== null && _a !== void 0 ? _a : this._uvs;\n    const vertexData = super._createVertexBuffers((_b = this._options.ribbonOptions) === null || _b === void 0 ? void 0 : _b.smoothShading);\n    const countersBuffer = new Buffer(this._engine, this._counters, this._updatable, 1);\n    this.setVerticesBuffer(countersBuffer.createVertexBuffer(\"grl_counters\", 0, 1));\n    const colorPointersBuffer = new Buffer(this._engine, this._colorPointers, this._updatable, 1);\n    this.setVerticesBuffer(colorPointersBuffer.createVertexBuffer(\"grl_colorPointers\", 0, 1));\n    const slopesBuffer = new Buffer(this._engine, this._slopes, this._updatable, 3);\n    this.setVerticesBuffer(slopesBuffer.createVertexBuffer(\"grl_slopes\", 0, 3));\n    const widthsBuffer = new Buffer(this._engine, this._ribbonWidths, this._updatable, 1);\n    this.setVerticesBuffer(widthsBuffer.createVertexBuffer(\"grl_widths\", 0, 1));\n    this._widthsBuffer = widthsBuffer;\n    return vertexData;\n  }\n}\n/**\n * Default line width\n */\nGreasedLineRibbonMesh.DEFAULT_WIDTH = 0.1;\nGreasedLineRibbonMesh._RightHandedForwardReadOnlyQuaternion = Quaternion.RotationAxis(Vector3.RightHandedForwardReadOnly, Math.PI / 2);\nGreasedLineRibbonMesh._LeftHandedForwardReadOnlyQuaternion = Quaternion.RotationAxis(Vector3.LeftHandedForwardReadOnly, Math.PI / 2);\nGreasedLineRibbonMesh._LeftReadOnlyQuaternion = Quaternion.RotationAxis(Vector3.LeftReadOnly, Math.PI / 2);\n/**\n * Direction which the line segment will be thickened if drawn on the XY plane\n */\nGreasedLineRibbonMesh.DIRECTION_XY = Vector3.LeftHandedForwardReadOnly; // doesn't matter in which handed system the scene operates\n/**\n * Direction which the line segment will be thickened if drawn on the XZ plane\n */\nGreasedLineRibbonMesh.DIRECTION_XZ = Vector3.UpReadOnly;\n/**\n * Direction which the line segment will be thickened if drawn on the YZ plane\n */\nGreasedLineRibbonMesh.DIRECTION_YZ = Vector3.LeftReadOnly;","map":{"version":3,"names":["Quaternion","Vector3","Mesh","Buffer","DeepCopier","GreasedLineTools","GreasedLineBaseMesh","GreasedLineRibbonAutoDirectionMode","GreasedLineRibbonFacesMode","GreasedLineRibbonPointsMode","_GreasedLineRibbonMeshParser","parsedMesh","scene","GreasedLineRibbonMesh","Parse","constructor","name","_options","_pathOptions","ribbonOptions","_paths","_counters","_slopes","_widths","_a","widths","_ribbonWidths","_pathsOptions","points","addPoints","ConvertPoints","options","hasPathOptions","push","pathCount","length","getClassName","isFlatLine","slopes","_updateColorPointers","colorPointers","colorPointer","_colorPointers","i","pathOptions","_points","pointsMode","POINTS_MODE_POINTS","k","j","_updateWidths","_updateWidthsWithValue","_setPoints","_initGreasedLine","indiceOffset","directionPlanes","c","subPoints","slice","POINTS_MODE_PATHS","_preprocess","ToVector3Array","_b","directionsAutoMode","AUTO_DIRECTIONS_NONE","directions","_GetDirectionPlanesFromDirectionsOption","forEach","p","idx","pathArray","_ConvertToRibbonPath","_scene","useRightHandedSystem","_lazy","_createVertexBuffers","refreshBoundingInfo","count","Array","isArray","fill","_CreateRibbonVertexData","numOfPaths","positions","indices","path","pi","v","x","y","z","doubleSided","facesMode","FACES_MODE_DOUBLE_SIDED","closePath","_c","lastIndice","ribbonVertexData","_vertexPositions","pathArrayCopy","pathCopy","clone","_calculateSegmentLengths","pathArrayLength","previousCounters","counter","_vSegmentLengths","_vTotalLengths","_uvs","_uSegmentLengths","_uTotalLengths","widthLower","widthUpper","_d","_CalculateSlopes","s","_indices","ribbonInfo","rightHandedSystem","directionPlane","width","path1","path2","pointVectors","direction","fatDirection","AUTO_DIRECTIONS_FROM_FIRST_SEGMENT","_GetDirectionFromPoints","p1","p2","AUTO_DIRECTIONS_FROM_ALL_SEGMENTS","directionTemp","subtract","applyRotationQuaternionInPlace","_RightHandedForwardReadOnlyQuaternion","_LeftHandedForwardReadOnlyQuaternion","_LeftReadOnlyQuaternion","normalize","multiplyByFloats","add","previousDirection","DIRECTION_YZ","DIRECTION_XZ","DIRECTION_XY","newParent","lineOptions","_createLineOptions","deepCopiedLineOptions","pathOptionsCloned","DeepCopy","cloned","parent","material","serialize","serializationObject","type","pathsOptions","result","l","Math","abs","lengthSquared","positionsLength","uLength","subtractToRef","paths","points1","points2","slope","normalizeToRef","uvs","vertexData","smoothShading","countersBuffer","_engine","_updatable","setVerticesBuffer","createVertexBuffer","colorPointersBuffer","slopesBuffer","widthsBuffer","_widthsBuffer","DEFAULT_WIDTH","RotationAxis","RightHandedForwardReadOnly","PI","LeftHandedForwardReadOnly","LeftReadOnly","UpReadOnly"],"sources":["../../../../../dev/core/src/Meshes/GreasedLine/greasedLineRibbonMesh.ts"],"sourcesContent":["import type { Scene } from \"../../scene\";\r\nimport { Quaternion, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { Buffer } from \"../../Buffers/buffer\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Node } from \"../../node\";\r\nimport { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport { GreasedLineTools } from \"../../Misc/greasedLineTools\";\r\nimport type { GreasedLineMeshOptions, GreasedLineRibbonOptions } from \"./greasedLineBaseMesh\";\r\nimport { GreasedLineBaseMesh, GreasedLineRibbonAutoDirectionMode, GreasedLineRibbonFacesMode, GreasedLineRibbonPointsMode } from \"./greasedLineBaseMesh\";\r\n\r\nMesh._GreasedLineRibbonMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return GreasedLineRibbonMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * GreasedLineRibbonMesh\r\n * Use the GreasedLineBuilder.CreateGreasedLine function to create an instance of this class.\r\n */\r\nexport class GreasedLineRibbonMesh extends GreasedLineBaseMesh {\r\n    /**\r\n     * Default line width\r\n     */\r\n    public static DEFAULT_WIDTH = 0.1;\r\n\r\n    private static _RightHandedForwardReadOnlyQuaternion = Quaternion.RotationAxis(Vector3.RightHandedForwardReadOnly, Math.PI / 2);\r\n    private static _LeftHandedForwardReadOnlyQuaternion = Quaternion.RotationAxis(Vector3.LeftHandedForwardReadOnly, Math.PI / 2);\r\n    private static _LeftReadOnlyQuaternion = Quaternion.RotationAxis(Vector3.LeftReadOnly, Math.PI / 2);\r\n\r\n    /**\r\n     * Direction which the line segment will be thickened if drawn on the XY plane\r\n     */\r\n    public static DIRECTION_XY = Vector3.LeftHandedForwardReadOnly; // doesn't matter in which handed system the scene operates\r\n    /**\r\n     * Direction which the line segment will be thickened if drawn on the XZ plane\r\n     */\r\n    public static DIRECTION_XZ = Vector3.UpReadOnly;\r\n    /**\r\n     * Direction which the line segment will be thickened if drawn on the YZ plane\r\n     */\r\n    public static DIRECTION_YZ = Vector3.LeftReadOnly;\r\n\r\n    private _paths: Vector3[][];\r\n    private _pathsOptions: { options: GreasedLineMeshOptions; pathCount: number }[];\r\n    private _vSegmentLengths: number[][];\r\n    private _uSegmentLengths: number[][];\r\n    private _vTotalLengths: number[];\r\n    private _uTotalLengths: number[];\r\n\r\n    private _counters: number[];\r\n    private _slopes: number[];\r\n    private _ribbonWidths: number[];\r\n\r\n    /**\r\n     * GreasedLineRibbonMesh\r\n     * @param name name of the mesh\r\n     * @param scene the scene\r\n     * @param _options mesh options\r\n     * @param _pathOptions used internaly when parsing a serialized GreasedLineRibbonMesh\r\n     */\r\n    constructor(public readonly name: string, scene: Scene, _options: GreasedLineMeshOptions, _pathOptions?: { options: GreasedLineMeshOptions; pathCount: number }[]) {\r\n        super(name, scene, _options);\r\n\r\n        if (!_options.ribbonOptions) {\r\n            throw \"'GreasedLineMeshOptions.ribbonOptions' is not set.\";\r\n        }\r\n\r\n        this._paths = [];\r\n        this._counters = [];\r\n        this._slopes = [];\r\n        this._widths = _options.widths ?? [];\r\n        this._ribbonWidths = [];\r\n        this._pathsOptions = _pathOptions ?? [];\r\n\r\n        if (_options.points) {\r\n            this.addPoints(GreasedLineTools.ConvertPoints(_options.points), _options, !!_pathOptions);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds new points to the line. It doesn't rerenders the line if in lazy mode.\r\n     * @param points points table\r\n     */\r\n    public override addPoints(points: number[][], options: GreasedLineMeshOptions, hasPathOptions = false) {\r\n        if (!options.ribbonOptions) {\r\n            throw \"addPoints() on GreasedLineRibbonMesh instance requires 'GreasedLineMeshOptions.ribbonOptions'.\";\r\n        }\r\n\r\n        if (!hasPathOptions) {\r\n            this._pathsOptions.push({ options, pathCount: points.length });\r\n        }\r\n\r\n        super.addPoints(points, options);\r\n    }\r\n\r\n    /**\r\n     * \"GreasedLineRibbonMesh\"\r\n     * @returns \"GreasedLineRibbonMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"GreasedLineRibbonMesh\";\r\n    }\r\n\r\n    /**\r\n     * Return true if the line was created from two edge paths or one points path.\r\n     * In this case the line is always flat.\r\n     */\r\n    public get isFlatLine() {\r\n        return this._paths.length < 3;\r\n    }\r\n\r\n    /**\r\n     * Returns the slopes of the line at each point relative to the center of the line\r\n     */\r\n    get slopes() {\r\n        return this._slopes;\r\n    }\r\n\r\n    /**\r\n     * Set the slopes of the line at each point relative to the center of the line\r\n     */\r\n    set slopes(slopes: number[]) {\r\n        this._slopes = slopes;\r\n    }\r\n\r\n    protected _updateColorPointers() {\r\n        if (this._options.colorPointers) {\r\n            return;\r\n        }\r\n\r\n        let colorPointer = 0;\r\n        this._colorPointers = [];\r\n        for (let i = 0; i < this._pathsOptions.length; i++) {\r\n            const { options: pathOptions, pathCount } = this._pathsOptions[i];\r\n            const points = this._points[i];\r\n\r\n            if (pathOptions.ribbonOptions!.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_POINTS) {\r\n                for (let k = 0; k < pathCount; k++) {\r\n                    for (let j = 0; j < points.length; j += 3) {\r\n                        this._colorPointers.push(colorPointer);\r\n                        this._colorPointers.push(colorPointer++);\r\n                    }\r\n                }\r\n            } else {\r\n                for (let j = 0; j < points.length; j += 3) {\r\n                    for (let k = 0; k < pathCount; k++) {\r\n                        this._colorPointers.push(colorPointer);\r\n                    }\r\n                    colorPointer++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _updateWidths(): void {\r\n        super._updateWidthsWithValue(1);\r\n    }\r\n\r\n    protected _setPoints(points: number[][], _options: GreasedLineMeshOptions) {\r\n        if (!this._options.ribbonOptions) {\r\n            throw \"No 'GreasedLineMeshOptions.ribbonOptions' provided.\";\r\n        }\r\n        this._points = points;\r\n        this._options.points = points;\r\n\r\n        this._initGreasedLine();\r\n\r\n        let indiceOffset = 0;\r\n        let directionPlanes: Vector3[];\r\n        for (let i = 0, c = 0; i < this._pathsOptions.length; i++) {\r\n            const { options: pathOptions, pathCount } = this._pathsOptions[i];\r\n            const subPoints = points.slice(c, c + pathCount);\r\n            c += pathCount;\r\n            if (pathOptions.ribbonOptions?.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_PATHS) {\r\n                indiceOffset = this._preprocess(GreasedLineTools.ToVector3Array(subPoints) as Vector3[][], indiceOffset, pathOptions);\r\n            } else {\r\n                if (pathOptions.ribbonOptions?.directionsAutoMode === GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_NONE) {\r\n                    if (!pathOptions.ribbonOptions!.directions) {\r\n                        throw \"In GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_NONE 'GreasedLineMeshOptions.ribbonOptions.directions' must be defined.\";\r\n                    }\r\n                    directionPlanes = GreasedLineRibbonMesh._GetDirectionPlanesFromDirectionsOption(subPoints.length, pathOptions.ribbonOptions!.directions);\r\n                }\r\n                subPoints.forEach((p, idx) => {\r\n                    const pathArray = GreasedLineRibbonMesh._ConvertToRibbonPath(\r\n                        p,\r\n                        pathOptions.ribbonOptions!,\r\n                        this._scene.useRightHandedSystem,\r\n                        directionPlanes ? directionPlanes[idx] : directionPlanes\r\n                    );\r\n                    indiceOffset = this._preprocess(pathArray, indiceOffset, pathOptions);\r\n                });\r\n            }\r\n        }\r\n\r\n        if (!this._lazy) {\r\n            this._createVertexBuffers();\r\n            this.refreshBoundingInfo();\r\n        }\r\n    }\r\n\r\n    private static _GetDirectionPlanesFromDirectionsOption(count: number, directions: Vector3 | Vector3[]) {\r\n        if (Array.isArray(directions)) {\r\n            return directions;\r\n        }\r\n\r\n        return new Array(count).fill(directions) as Vector3[];\r\n    }\r\n\r\n    private static _CreateRibbonVertexData(pathArray: Vector3[][], options: GreasedLineMeshOptions) {\r\n        const numOfPaths = pathArray.length;\r\n        if (numOfPaths < 2) {\r\n            throw \"Minimum of two paths are required to create a GreasedLineRibbonMesh.\";\r\n        }\r\n\r\n        const positions = [];\r\n        const indices = [];\r\n\r\n        const path = pathArray[0];\r\n        for (let i = 0; i < path.length; i++) {\r\n            for (let pi = 0; pi < pathArray.length; pi++) {\r\n                const v = pathArray[pi][i];\r\n                positions.push(v.x, v.y, v.z);\r\n            }\r\n        }\r\n\r\n        const v: number[] = [1, 0, numOfPaths];\r\n        const doubleSided = options.ribbonOptions?.facesMode === GreasedLineRibbonFacesMode.FACES_MODE_DOUBLE_SIDED ?? false;\r\n\r\n        const closePath = options.ribbonOptions?.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_PATHS && options.ribbonOptions.closePath;\r\n        if (numOfPaths > 2) {\r\n            for (let i = 0; i < path.length - 1; i++) {\r\n                v[0] = 1 + numOfPaths * i;\r\n                v[1] = numOfPaths * i;\r\n                v[2] = (i + 1) * numOfPaths;\r\n                for (let pi = 0; pi < (numOfPaths - 1) * 2; pi++) {\r\n                    if (pi % 2 !== 0) {\r\n                        v[2] += 1;\r\n                    }\r\n                    if (pi % 2 === 0 && pi > 0) {\r\n                        v[0] += 1;\r\n                        v[1] += 1;\r\n                    }\r\n                    indices.push(v[1] + (pi % 2 !== 0 ? numOfPaths : 0), v[0], v[2]);\r\n                    if (doubleSided) {\r\n                        indices.push(v[0], v[1] + (pi % 2 !== 0 ? numOfPaths : 0), v[2]);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            for (let i = 0; i < positions.length / 3 - 3; i += 2) {\r\n                indices.push(i, i + 1, i + 2);\r\n                indices.push(i + 2, i + 1, i + 3);\r\n                if (doubleSided) {\r\n                    indices.push(i + 1, i, i + 2);\r\n                    indices.push(i + 1, i + 2, i + 3);\r\n                }\r\n            }\r\n        }\r\n        if (closePath) {\r\n            let lastIndice = numOfPaths * (path.length - 1);\r\n            for (let pi = 0; pi < numOfPaths - 1; pi++) {\r\n                indices.push(lastIndice, pi + 1, pi);\r\n                indices.push(lastIndice + 1, pi + 1, lastIndice);\r\n                if (doubleSided) {\r\n                    indices.push(pi, pi + 1, lastIndice);\r\n                    indices.push(lastIndice, pi + 1, lastIndice + 1);\r\n                }\r\n                lastIndice++;\r\n            }\r\n        }\r\n\r\n        return {\r\n            positions,\r\n            indices,\r\n        };\r\n    }\r\n\r\n    private _preprocess(pathArray: Vector3[][], indiceOffset: number, options: GreasedLineMeshOptions) {\r\n        this._paths = pathArray;\r\n\r\n        const ribbonVertexData = GreasedLineRibbonMesh._CreateRibbonVertexData(pathArray, options);\r\n\r\n        const positions = ribbonVertexData.positions;\r\n\r\n        if (!this._options.widths) {\r\n            throw \"No 'GreasedLineMeshOptions.widths' table is specified.\";\r\n        }\r\n\r\n        for (const p of positions) {\r\n            this._vertexPositions.push(p);\r\n        }\r\n\r\n        let pathArrayCopy = pathArray;\r\n        if (options.ribbonOptions?.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_PATHS && options.ribbonOptions.closePath) {\r\n            pathArrayCopy = [];\r\n            for (let i = 0; i < pathArray.length; i++) {\r\n                const pathCopy = pathArray[i].slice();\r\n                pathCopy.push(pathArray[i][0].clone());\r\n                pathArrayCopy.push(pathCopy);\r\n            }\r\n        }\r\n\r\n        this._calculateSegmentLengths(pathArrayCopy);\r\n\r\n        const pathArrayLength = pathArrayCopy.length;\r\n        const previousCounters = new Array(pathArrayLength).fill(0);\r\n        for (let i = 0; i < pathArrayCopy[0].length; i++) {\r\n            let v = 0;\r\n            for (let pi = 0; pi < pathArrayLength; pi++) {\r\n                const counter = previousCounters[pi] + this._vSegmentLengths[pi][i] / this._vTotalLengths[pi];\r\n                this._counters.push(counter);\r\n                this._uvs.push(counter, v);\r\n\r\n                previousCounters[pi] = counter;\r\n                v += this._uSegmentLengths[i][pi] / this._uTotalLengths[i];\r\n            }\r\n        }\r\n\r\n        for (let i = 0, c = 0; i < pathArrayCopy[0].length; i++) {\r\n            const widthLower = this._uSegmentLengths[i][0] / 2;\r\n            const widthUpper = this._uSegmentLengths[i][pathArrayLength - 1] / 2;\r\n            this._ribbonWidths.push(((this._widths[c++] ?? 1) - 1) * widthLower);\r\n            for (let pi = 0; pi < pathArrayLength - 2; pi++) {\r\n                this._ribbonWidths.push(0);\r\n            }\r\n            this._ribbonWidths.push(((this._widths[c++] ?? 1) - 1) * widthUpper);\r\n        }\r\n\r\n        const slopes =\r\n            options.ribbonOptions?.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_PATHS\r\n                ? new Array(pathArrayCopy[0].length * pathArrayCopy.length * 6).fill(0)\r\n                : GreasedLineRibbonMesh._CalculateSlopes(pathArrayCopy);\r\n        for (const s of slopes) {\r\n            this._slopes.push(s);\r\n        }\r\n\r\n        if (ribbonVertexData.indices) {\r\n            for (let i = 0; i < ribbonVertexData.indices.length; i++) {\r\n                this._indices.push(ribbonVertexData.indices[i] + indiceOffset);\r\n            }\r\n        }\r\n        indiceOffset += positions.length / 3;\r\n\r\n        return indiceOffset;\r\n    }\r\n\r\n    private static _ConvertToRibbonPath(points: number[], ribbonInfo: GreasedLineRibbonOptions, rightHandedSystem: boolean, directionPlane?: Vector3) {\r\n        if (ribbonInfo.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_POINTS && !ribbonInfo.width) {\r\n            throw \"'GreasedLineMeshOptions.ribbonOptiosn.width' must be specified in GreasedLineRibbonPointsMode.POINTS_MODE_POINTS.\";\r\n        }\r\n        const path1 = [];\r\n        const path2 = [];\r\n        if (ribbonInfo.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_POINTS) {\r\n            const width = ribbonInfo.width! / 2;\r\n            const pointVectors = GreasedLineTools.ToVector3Array(points) as Vector3[];\r\n            let direction: Nullable<Vector3> = null;\r\n            let fatDirection: Nullable<Vector3> = null;\r\n\r\n            if (ribbonInfo.directionsAutoMode === GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT) {\r\n                // set the direction plane from the first line segment for the whole line\r\n                directionPlane = GreasedLineRibbonMesh._GetDirectionFromPoints(pointVectors[0], pointVectors[1], null);\r\n            }\r\n\r\n            for (let i = 0; i < pointVectors.length - (directionPlane ? 0 : 1); i++) {\r\n                const p1 = pointVectors[i];\r\n                const p2 = pointVectors[i + 1];\r\n\r\n                if (directionPlane) {\r\n                    direction = <Vector3>directionPlane;\r\n                } else if (ribbonInfo.directionsAutoMode === GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS) {\r\n                    direction = GreasedLineRibbonMesh._GetDirectionFromPoints(p1, p2, direction);\r\n                } else {\r\n                    // GreasedLineRibbonAutoDirectionMode.DIRECTION_ENHANCED\r\n                    const directionTemp = p2.subtract(p1);\r\n                    directionTemp.applyRotationQuaternionInPlace(\r\n                        directionTemp.x > directionTemp.y && directionTemp.x > directionTemp.z\r\n                            ? rightHandedSystem\r\n                                ? GreasedLineRibbonMesh._RightHandedForwardReadOnlyQuaternion\r\n                                : GreasedLineRibbonMesh._LeftHandedForwardReadOnlyQuaternion\r\n                            : GreasedLineRibbonMesh._LeftReadOnlyQuaternion\r\n                    );\r\n                    direction = directionTemp.normalize();\r\n                }\r\n\r\n                fatDirection = direction.multiplyByFloats(width, width, width);\r\n                path1.push(p1.add(fatDirection));\r\n                path2.push(p1.subtract(fatDirection));\r\n            }\r\n            if (!directionPlane) {\r\n                path1.push(pointVectors[pointVectors.length - 1].add(fatDirection!));\r\n                path2.push(pointVectors[pointVectors.length - 1].subtract(fatDirection!));\r\n            }\r\n        }\r\n        return [path1, path2];\r\n    }\r\n\r\n    private static _GetDirectionFromPoints(p1: Vector3, p2: Vector3, previousDirection: Nullable<Vector3>) {\r\n        // handle straight lines\r\n        if (p1.x === p2.x && (!previousDirection || previousDirection?.x === 1)) {\r\n            return GreasedLineRibbonMesh.DIRECTION_YZ;\r\n        }\r\n\r\n        if (p1.y === p2.y) {\r\n            return GreasedLineRibbonMesh.DIRECTION_XZ;\r\n        }\r\n\r\n        if (p1.z === p2.z) {\r\n            return GreasedLineRibbonMesh.DIRECTION_XY;\r\n        }\r\n\r\n        return GreasedLineRibbonMesh.DIRECTION_XZ;\r\n    }\r\n\r\n    /**\r\n     * Clones the GreasedLineRibbonMesh.\r\n     * @param name new line name\r\n     * @param newParent new parent node\r\n     * @returns cloned line\r\n     */\r\n    public clone(name: string = `${this.name}-cloned`, newParent?: Nullable<Node>) {\r\n        const lineOptions = this._createLineOptions();\r\n        const deepCopiedLineOptions: any = {};\r\n        const pathOptionsCloned: any = [];\r\n        DeepCopier.DeepCopy(this._pathsOptions, pathOptionsCloned);\r\n        DeepCopier.DeepCopy(lineOptions, deepCopiedLineOptions, [\"instance\"]);\r\n\r\n        const cloned = new GreasedLineRibbonMesh(name, this._scene, <GreasedLineMeshOptions>deepCopiedLineOptions, pathOptionsCloned);\r\n        if (newParent) {\r\n            cloned.parent = newParent;\r\n        }\r\n\r\n        cloned.material = this.material;\r\n\r\n        return cloned;\r\n    }\r\n\r\n    /**\r\n     * Serializes this GreasedLineRibbonMesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.type = this.getClassName();\r\n\r\n        serializationObject.lineOptions = this._createLineOptions();\r\n        serializationObject.pathsOptions = this._pathsOptions;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized GreasedLineRibbonMesh\r\n     * @param parsedMesh the serialized GreasedLineRibbonMesh\r\n     * @param scene the scene to create the GreasedLineRibbonMesh in\r\n     * @returns the created GreasedLineRibbonMesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): Mesh {\r\n        const lineOptions = <GreasedLineMeshOptions>parsedMesh.lineOptions;\r\n        const name = <string>parsedMesh.name;\r\n        const pathOptions = parsedMesh.pathOptions;\r\n        const result = new GreasedLineRibbonMesh(name, scene, lineOptions, pathOptions);\r\n        return result;\r\n    }\r\n\r\n    protected _initGreasedLine() {\r\n        super._initGreasedLine();\r\n\r\n        this._paths = [];\r\n        this._counters = [];\r\n        this._slopes = [];\r\n        this._ribbonWidths = [];\r\n    }\r\n\r\n    private _calculateSegmentLengths(pathArray: Vector3[][]) {\r\n        const pathArrayLength = pathArray.length;\r\n        this._vSegmentLengths = new Array(pathArrayLength);\r\n        this._vTotalLengths = new Array(pathArrayLength);\r\n        let length = 0;\r\n        for (let pi = 0; pi < pathArrayLength; pi++) {\r\n            const points = pathArray[pi];\r\n            this._vSegmentLengths[pi] = [0]; // first point has 0 distance\r\n            length = 0;\r\n            for (let i = 0; i < points.length - 1; i++) {\r\n                const l = Math.abs(points[i].subtract(points[i + 1]).lengthSquared()); // it's ok to have lengthSquared() here\r\n                length += l;\r\n                this._vSegmentLengths[pi].push(l);\r\n            }\r\n            this._vTotalLengths[pi] = length;\r\n        }\r\n\r\n        const positionsLength = pathArray[0].length;\r\n        this._uSegmentLengths = new Array(positionsLength).fill([]);\r\n        this._uTotalLengths = new Array(positionsLength).fill([]);\r\n        const uLength = new Vector3();\r\n        for (let i = 0; i < positionsLength; i++) {\r\n            length = 0;\r\n            for (let pi = 1; pi < pathArrayLength; pi++) {\r\n                pathArray[pi][i].subtractToRef(pathArray[pi - 1][i], uLength);\r\n                const l = uLength.length(); // must be length()\r\n                length += l;\r\n                this._uSegmentLengths[i].push(l);\r\n            }\r\n            this._uTotalLengths[i] = length;\r\n        }\r\n    }\r\n\r\n    private static _CalculateSlopes(paths: Vector3[][]) {\r\n        const points1 = paths[0];\r\n        const points2 = paths.length === 2 ? paths[1] : paths[paths.length - 1];\r\n        const slopes: number[] = [];\r\n\r\n        const slope = new Vector3();\r\n        for (let i = 0; i < points1.length; i++) {\r\n            for (let pi = 0; pi < paths.length; pi++) {\r\n                if (pi === 0 || pi === paths.length - 1) {\r\n                    points1[i].subtract(points2[i]).normalizeToRef(slope);\r\n                    slopes.push(slope.x, slope.y, slope.z);\r\n                    slopes.push(-slope.x, -slope.y, -slope.z);\r\n                } else {\r\n                    slopes.push(0, 0, 0, 0, 0, 0);\r\n                }\r\n            }\r\n        }\r\n\r\n        return slopes;\r\n    }\r\n\r\n    protected _createVertexBuffers() {\r\n        this._uvs = this._options.uvs ?? this._uvs;\r\n        const vertexData = super._createVertexBuffers(this._options.ribbonOptions?.smoothShading);\r\n\r\n        const countersBuffer = new Buffer(this._engine, this._counters, this._updatable, 1);\r\n        this.setVerticesBuffer(countersBuffer.createVertexBuffer(\"grl_counters\", 0, 1));\r\n\r\n        const colorPointersBuffer = new Buffer(this._engine, this._colorPointers, this._updatable, 1);\r\n        this.setVerticesBuffer(colorPointersBuffer.createVertexBuffer(\"grl_colorPointers\", 0, 1));\r\n\r\n        const slopesBuffer = new Buffer(this._engine, this._slopes, this._updatable, 3);\r\n        this.setVerticesBuffer(slopesBuffer.createVertexBuffer(\"grl_slopes\", 0, 3));\r\n\r\n        const widthsBuffer = new Buffer(this._engine, this._ribbonWidths, this._updatable, 1);\r\n        this.setVerticesBuffer(widthsBuffer.createVertexBuffer(\"grl_widths\", 0, 1));\r\n        this._widthsBuffer = widthsBuffer;\r\n\r\n        return vertexData;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}