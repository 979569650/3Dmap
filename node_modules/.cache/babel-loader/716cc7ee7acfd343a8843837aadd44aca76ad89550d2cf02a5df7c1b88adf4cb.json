{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\n// This implementation was based on the original MIT-licensed TRACE repository\n// from https://github.com/septagon/TRACE.\n/**\n * Generic implementation of Levenshtein distance.\n */\nvar Levenshtein;\n(function (Levenshtein) {\n  /**\n   * Alphabet from which to construct sequences to be compared using Levenshtein\n   * distance.\n   */\n  class Alphabet {\n    /**\n     * Serialize the Alphabet to JSON string.\n     * @returns JSON serialization\n     */\n    serialize() {\n      const jsonObject = {};\n      const characters = new Array(this._characterToIdx.size);\n      this._characterToIdx.forEach((v, k) => {\n        characters[v] = k;\n      });\n      jsonObject[\"characters\"] = characters;\n      jsonObject[\"insertionCosts\"] = this._insertionCosts;\n      jsonObject[\"deletionCosts\"] = this._deletionCosts;\n      jsonObject[\"substitutionCosts\"] = this._substitutionCosts;\n      return JSON.stringify(jsonObject);\n    }\n    /**\n     * Parse an Alphabet from a JSON serialization.\n     * @param json JSON string to deserialize\n     * @returns deserialized Alphabet\n     */\n    static Deserialize(json) {\n      const jsonObject = JSON.parse(json);\n      const alphabet = new Alphabet(jsonObject[\"characters\"]);\n      alphabet._insertionCosts = jsonObject[\"insertionCosts\"];\n      alphabet._deletionCosts = jsonObject[\"deletionCosts\"];\n      alphabet._substitutionCosts = jsonObject[\"substitutionCosts\"];\n      return alphabet;\n    }\n    /**\n     * Create a new Alphabet.\n     * @param characters characters of the alphabet\n     * @param charToInsertionCost function mapping characters to insertion costs\n     * @param charToDeletionCost function mapping characters to deletion costs\n     * @param charsToSubstitutionCost function mapping character pairs to substitution costs\n     */\n    constructor(characters, charToInsertionCost = null, charToDeletionCost = null, charsToSubstitutionCost = null) {\n      charToInsertionCost = charToInsertionCost !== null && charToInsertionCost !== void 0 ? charToInsertionCost : () => 1;\n      charToDeletionCost = charToDeletionCost !== null && charToDeletionCost !== void 0 ? charToDeletionCost : () => 1;\n      charsToSubstitutionCost = charsToSubstitutionCost !== null && charsToSubstitutionCost !== void 0 ? charsToSubstitutionCost : (a, b) => a === b ? 0 : 1;\n      this._characterToIdx = new Map();\n      this._insertionCosts = new Array(characters.length);\n      this._deletionCosts = new Array(characters.length);\n      this._substitutionCosts = new Array(characters.length);\n      let c;\n      for (let outerIdx = 0; outerIdx < characters.length; ++outerIdx) {\n        c = characters[outerIdx];\n        this._characterToIdx.set(c, outerIdx);\n        this._insertionCosts[outerIdx] = charToInsertionCost(c);\n        this._deletionCosts[outerIdx] = charToDeletionCost(c);\n        this._substitutionCosts[outerIdx] = new Array(characters.length);\n        for (let innerIdx = outerIdx; innerIdx < characters.length; ++innerIdx) {\n          this._substitutionCosts[outerIdx][innerIdx] = charsToSubstitutionCost(c, characters[innerIdx]);\n        }\n      }\n    }\n    /**\n     * Get the index (internally-assigned number) for a character.\n     * @param char character\n     * @returns index\n     */\n    getCharacterIdx(char) {\n      return this._characterToIdx.get(char);\n    }\n    /**\n     * Get the insertion cost of a character from its index.\n     * @param idx character index\n     * @returns insertion cost\n     */\n    getInsertionCost(idx) {\n      return this._insertionCosts[idx];\n    }\n    /**\n     * Get the deletion cost of a character from its index.\n     * @param idx character index\n     * @returns deletion cost\n     */\n    getDeletionCost(idx) {\n      return this._deletionCosts[idx];\n    }\n    /**\n     * Gets the cost to substitute two characters. NOTE: this cost is\n     * required to be bi-directional, meaning it cannot matter which of\n     * the provided characters is being removed and which is being inserted.\n     * @param idx1 the first character index\n     * @param idx2 the second character index\n     * @returns substitution cost\n     */\n    getSubstitutionCost(idx1, idx2) {\n      const min = Math.min(idx1, idx2);\n      const max = Math.max(idx1, idx2);\n      return this._substitutionCosts[min][max];\n    }\n  }\n  Levenshtein.Alphabet = Alphabet;\n  /**\n   * Character sequence intended to be compared against other Sequences created\n   * with the same Alphabet in order to compute Levenshtein distance.\n   */\n  class Sequence {\n    /**\n     * Serialize to JSON string. JSON representation does NOT include the Alphabet\n     * from which this Sequence was created; Alphabet must be independently\n     * serialized.\n     * @returns JSON string\n     */\n    serialize() {\n      return JSON.stringify(this._characters);\n    }\n    /**\n     * Deserialize from JSON string and Alphabet. This should be the same Alphabet\n     * from which the Sequence was originally created, which must be serialized and\n     * deserialized independently so that it can be passed in here.\n     * @param json JSON string representation of Sequence\n     * @param alphabet Alphabet from which Sequence was originally created\n     * @returns Sequence\n     */\n    static Deserialize(json, alphabet) {\n      const sequence = new Sequence([], alphabet);\n      sequence._characters = JSON.parse(json);\n      return sequence;\n    }\n    /**\n     * Create a new Sequence.\n     * @param characters characters in the new Sequence\n     * @param alphabet Alphabet, which must include all used characters\n     */\n    constructor(characters, alphabet) {\n      if (characters.length > Sequence._MAX_SEQUENCE_LENGTH) {\n        throw new Error(\"Sequences longer than \" + Sequence._MAX_SEQUENCE_LENGTH + \" not supported.\");\n      }\n      this._alphabet = alphabet;\n      this._characters = characters.map(c => this._alphabet.getCharacterIdx(c));\n    }\n    /**\n     * Get the distance between this Sequence and another.\n     * @param other sequence to compare to\n     * @returns Levenshtein distance\n     */\n    distance(other) {\n      return Sequence._Distance(this, other);\n    }\n    /**\n     * Compute the Levenshtein distance between two Sequences.\n     * @param a first Sequence\n     * @param b second Sequence\n     * @returns Levenshtein distance\n     */\n    static _Distance(a, b) {\n      const alphabet = a._alphabet;\n      if (alphabet !== b._alphabet) {\n        throw new Error(\"Cannot Levenshtein compare Sequences built from different alphabets.\");\n      }\n      const aChars = a._characters;\n      const bChars = b._characters;\n      const aLength = aChars.length;\n      const bLength = bChars.length;\n      const costMatrix = Sequence._CostMatrix;\n      costMatrix[0][0] = 0;\n      for (let idx = 0; idx < aLength; ++idx) {\n        costMatrix[idx + 1][0] = costMatrix[idx][0] + alphabet.getInsertionCost(aChars[idx]);\n      }\n      for (let idx = 0; idx < bLength; ++idx) {\n        costMatrix[0][idx + 1] = costMatrix[0][idx] + alphabet.getInsertionCost(bChars[idx]);\n      }\n      for (let aIdx = 0; aIdx < aLength; ++aIdx) {\n        for (let bIdx = 0; bIdx < bLength; ++bIdx) {\n          Sequence._InsertionCost = costMatrix[aIdx + 1][bIdx] + alphabet.getInsertionCost(bChars[bIdx]);\n          Sequence._DeletionCost = costMatrix[aIdx][bIdx + 1] + alphabet.getDeletionCost(aChars[aIdx]);\n          Sequence._SubstitutionCost = costMatrix[aIdx][bIdx] + alphabet.getSubstitutionCost(aChars[aIdx], bChars[bIdx]);\n          costMatrix[aIdx + 1][bIdx + 1] = Math.min(Sequence._InsertionCost, Sequence._DeletionCost, Sequence._SubstitutionCost);\n        }\n      }\n      return costMatrix[aLength][bLength];\n    }\n  }\n  // Scratch values\n  Sequence._MAX_SEQUENCE_LENGTH = 256;\n  Sequence._CostMatrix = [...Array(Sequence._MAX_SEQUENCE_LENGTH + 1)].map(() => new Array(Sequence._MAX_SEQUENCE_LENGTH + 1));\n  Levenshtein.Sequence = Sequence;\n})(Levenshtein || (Levenshtein = {}));\n/**\n * A 3D trajectory consisting of an order list of vectors describing a\n * path of motion through 3D space.\n */\nexport class Trajectory {\n  /**\n   * Serialize to JSON.\n   * @returns serialized JSON string\n   */\n  serialize() {\n    return JSON.stringify(this);\n  }\n  /**\n   * Deserialize from JSON.\n   * @param json serialized JSON string\n   * @returns deserialized Trajectory\n   */\n  static Deserialize(json) {\n    const jsonObject = JSON.parse(json);\n    const trajectory = new Trajectory(jsonObject[\"_segmentLength\"]);\n    trajectory._points = jsonObject[\"_points\"].map(pt => {\n      return new Vector3(pt[\"_x\"], pt[\"_y\"], pt[\"_z\"]);\n    });\n    return trajectory;\n  }\n  /**\n   * Create a new empty Trajectory.\n   * @param segmentLength radius of discretization for Trajectory points\n   */\n  constructor(segmentLength = 0.01) {\n    this._points = [];\n    this._segmentLength = segmentLength;\n  }\n  /**\n   * Get the length of the Trajectory.\n   * @returns length of the Trajectory\n   */\n  getLength() {\n    return this._points.length * this._segmentLength;\n  }\n  /**\n   * Append a new point to the Trajectory.\n   * NOTE: This implementation has many allocations.\n   * @param point point to append to the Trajectory\n   */\n  add(point) {\n    let numPoints = this._points.length;\n    if (numPoints === 0) {\n      this._points.push(point.clone());\n    } else {\n      const getT = () => this._segmentLength / Vector3.Distance(this._points[numPoints - 1], point);\n      for (let t = getT(); t <= 1.0; t = getT()) {\n        const newPoint = this._points[numPoints - 1].scale(1.0 - t);\n        point.scaleAndAddToRef(t, newPoint);\n        this._points.push(newPoint);\n        ++numPoints;\n      }\n    }\n  }\n  /**\n   * Create a new Trajectory with a segment length chosen to make it\n   * probable that the new Trajectory will have a specified number of\n   * segments. This operation is imprecise.\n   * @param targetResolution number of segments desired\n   * @returns new Trajectory with approximately the requested number of segments\n   */\n  resampleAtTargetResolution(targetResolution) {\n    const resampled = new Trajectory(this.getLength() / targetResolution);\n    this._points.forEach(pt => {\n      resampled.add(pt);\n    });\n    return resampled;\n  }\n  /**\n   * Convert Trajectory segments into tokenized representation. This\n   * representation is an array of numbers where each nth number is the\n   * index of the token which is most similar to the nth segment of the\n   * Trajectory.\n   * @param tokens list of vectors which serve as discrete tokens\n   * @returns list of indices of most similar token per segment\n   */\n  tokenize(tokens) {\n    const tokenization = [];\n    const segmentDir = new Vector3();\n    for (let idx = 2; idx < this._points.length; ++idx) {\n      if (Trajectory._TransformSegmentDirToRef(this._points[idx - 2], this._points[idx - 1], this._points[idx], segmentDir)) {\n        tokenization.push(Trajectory._TokenizeSegment(segmentDir, tokens));\n      }\n    }\n    return tokenization;\n  }\n  /**\n   * Transform the rotation (i.e., direction) of a segment to isolate\n   * the relative transformation represented by the segment. This operation\n   * may or may not succeed due to singularities in the equations that define\n   * motion relativity in this context.\n   * @param priorVec the origin of the prior segment\n   * @param fromVec the origin of the current segment\n   * @param toVec the destination of the current segment\n   * @param result reference to output variable\n   * @returns whether or not transformation was successful\n   */\n  static _TransformSegmentDirToRef(priorVec, fromVec, toVec, result) {\n    const DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD = 0.98;\n    fromVec.subtractToRef(priorVec, Trajectory._ForwardDir);\n    Trajectory._ForwardDir.normalize();\n    fromVec.scaleToRef(-1, Trajectory._InverseFromVec);\n    Trajectory._InverseFromVec.normalize();\n    if (Math.abs(Vector3.Dot(Trajectory._ForwardDir, Trajectory._InverseFromVec)) > DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD) {\n      return false;\n    }\n    Vector3.CrossToRef(Trajectory._ForwardDir, Trajectory._InverseFromVec, Trajectory._UpDir);\n    Trajectory._UpDir.normalize();\n    Matrix.LookAtLHToRef(priorVec, fromVec, Trajectory._UpDir, Trajectory._LookMatrix);\n    toVec.subtractToRef(fromVec, Trajectory._FromToVec);\n    Trajectory._FromToVec.normalize();\n    Vector3.TransformNormalToRef(Trajectory._FromToVec, Trajectory._LookMatrix, result);\n    return true;\n  }\n  /**\n   * Determine which token vector is most similar to the\n   * segment vector.\n   * @param segment segment vector\n   * @param tokens token vector list\n   * @returns index of the most similar token to the segment\n   */\n  static _TokenizeSegment(segment, tokens) {\n    Trajectory._BestMatch = 0;\n    Trajectory._Score = Vector3.Dot(segment, tokens[0]);\n    Trajectory._BestScore = Trajectory._Score;\n    for (let idx = 1; idx < tokens.length; ++idx) {\n      Trajectory._Score = Vector3.Dot(segment, tokens[idx]);\n      if (Trajectory._Score > Trajectory._BestScore) {\n        Trajectory._BestMatch = idx;\n        Trajectory._BestScore = Trajectory._Score;\n      }\n    }\n    return Trajectory._BestMatch;\n  }\n}\nTrajectory._ForwardDir = new Vector3();\nTrajectory._InverseFromVec = new Vector3();\nTrajectory._UpDir = new Vector3();\nTrajectory._FromToVec = new Vector3();\nTrajectory._LookMatrix = new Matrix();\n/**\n * Collection of vectors intended to be used as the basis of Trajectory\n * tokenization for Levenshtein distance comparison. Canonically, a\n * Vector3Alphabet will resemble a \"spikeball\" of vectors distributed\n * roughly evenly over the surface of the unit sphere.\n */\nclass Vector3Alphabet {\n  /**\n   * Helper method to create new \"spikeball\" Vector3Alphabets. Uses a naive\n   * optimize-from-random strategy to space points around the unit sphere\n   * surface as a simple alternative to really doing the math to tile the\n   * sphere.\n   * @param alphabetSize size of the desired alphabet\n   * @param iterations number of iterations over which to optimize the \"spikeball\"\n   * @param startingStepSize distance factor to move points in early optimization iterations\n   * @param endingStepSize distance factor to move points in late optimization iterations\n   * @param fixedValues alphabet \"characters\" that are required and cannot be moved by optimization\n   * @returns a new randomly generated and optimized Vector3Alphabet of the specified size\n   */\n  static Generate(alphabetSize = 64, iterations = 256, startingStepSize = 0.1, endingStepSize = 0.001, fixedValues = []) {\n    const EPSILON = 0.001;\n    const EPSILON_SQUARED = EPSILON * EPSILON;\n    const alphabet = new Vector3Alphabet(alphabetSize);\n    for (let idx = 0; idx < alphabetSize; ++idx) {\n      alphabet.chars[idx] = new Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);\n      alphabet.chars[idx].normalize();\n    }\n    for (let idx = 0; idx < fixedValues.length; ++idx) {\n      alphabet.chars[idx].copyFrom(fixedValues[idx]);\n    }\n    let stepSize;\n    let distSq;\n    const force = new Vector3();\n    const scratch = new Vector3();\n    const lerp = (l, r, t) => (1.0 - t) * l + t * r;\n    for (let iteration = 0; iteration < iterations; ++iteration) {\n      stepSize = lerp(startingStepSize, endingStepSize, iteration / (iterations - 1));\n      for (let idx = fixedValues.length; idx < alphabet.chars.length; ++idx) {\n        force.copyFromFloats(0, 0, 0);\n        alphabet.chars.forEach(pt => {\n          alphabet.chars[idx].subtractToRef(pt, scratch);\n          distSq = scratch.lengthSquared();\n          if (distSq > EPSILON_SQUARED) {\n            scratch.scaleAndAddToRef(1 / (scratch.lengthSquared() * distSq), force);\n          }\n        });\n        force.scaleInPlace(stepSize);\n        alphabet.chars[idx].addInPlace(force);\n        alphabet.chars[idx].normalize();\n      }\n    }\n    return alphabet;\n  }\n  /**\n   * Serialize to JSON.\n   * @returns JSON serialization\n   */\n  serialize() {\n    return JSON.stringify(this.chars);\n  }\n  /**\n   * Deserialize from JSON.\n   * @param json JSON serialization\n   * @returns deserialized Vector3Alphabet\n   */\n  static Deserialize(json) {\n    const jsonObject = JSON.parse(json);\n    const alphabet = new Vector3Alphabet(jsonObject.length);\n    for (let idx = 0; idx < jsonObject.length; ++idx) {\n      alphabet.chars[idx] = new Vector3(jsonObject[idx][\"_x\"], jsonObject[idx][\"_y\"], jsonObject[idx][\"_z\"]);\n    }\n    return alphabet;\n  }\n  constructor(size) {\n    this.chars = new Array(size);\n  }\n}\n/**\n * Class which formalizes the manner in which a Vector3Alphabet is used to tokenize and\n * describe a Trajectory. This class houses the functionality which determines what\n * attributes of Trajectories are and are not considered important, such as scale.\n */\nclass TrajectoryDescriptor {\n  /**\n   * Serialize to JSON.\n   * @returns JSON serialization\n   */\n  serialize() {\n    return JSON.stringify(this._sequences.map(sequence => sequence.serialize()));\n  }\n  /**\n   * Deserialize from JSON string and Alphabet. This should be the same Alphabet\n   * from which the descriptor was originally created, which must be serialized and\n   * deserialized independently so that it can be passed in here.\n   * @param json JSON serialization\n   * @param alphabet Alphabet from which descriptor was originally created\n   * @returns deserialized TrajectoryDescriptor\n   */\n  static Deserialize(json, alphabet) {\n    const descriptor = new TrajectoryDescriptor();\n    descriptor._sequences = JSON.parse(json).map(s => Levenshtein.Sequence.Deserialize(s, alphabet));\n    return descriptor;\n  }\n  /**\n   * Create a new TrajectoryDescriptor to describe a provided Trajectory according\n   * to the provided alphabets.\n   * @param trajectory Trajectory to be described\n   * @param vector3Alphabet Vector3Alphabet to be used to tokenize the Trajectory\n   * @param levenshteinAlphabet Levenshtein.Alphabet to be used as basis for comparison with other descriptors\n   * @returns TrajectoryDescriptor describing provided Trajectory\n   */\n  static CreateFromTrajectory(trajectory, vector3Alphabet, levenshteinAlphabet) {\n    return TrajectoryDescriptor.CreateFromTokenizationPyramid(TrajectoryDescriptor._GetTokenizationPyramid(trajectory, vector3Alphabet), levenshteinAlphabet);\n  }\n  /**\n   * Create a new TrajectoryDescriptor from a pre-existing pyramid of tokens.\n   * NOTE: This function exists to support an outdated serialization mechanism and should\n   * be deleted if it is no longer useful.\n   * @param pyramid tokenization pyramid\n   * @param levenshteinAlphabet Levenshtein.Alphabet to be uses as basis for comparison with other descriptors\n   * @returns TrajectoryDescriptor describing the Trajectory from which the pyramid was built\n   */\n  static CreateFromTokenizationPyramid(pyramid, levenshteinAlphabet) {\n    const descriptor = new TrajectoryDescriptor();\n    descriptor._sequences = pyramid.map(tokens => new Levenshtein.Sequence(tokens, levenshteinAlphabet));\n    return descriptor;\n  }\n  constructor() {\n    this._sequences = [];\n  }\n  /**\n   * Create the tokenization pyramid for the provided Trajectory according to the given\n   * Vector3Alphabet.\n   * @param trajectory Trajectory to be tokenized\n   * @param alphabet Vector3Alphabet containing tokens\n   * @param targetResolution finest resolution of descriptor\n   * @returns tokenization pyramid for Trajectory\n   */\n  static _GetTokenizationPyramid(trajectory, alphabet, targetResolution = TrajectoryDescriptor._FINEST_DESCRIPTOR_RESOLUTION) {\n    const pyramid = [];\n    for (let res = targetResolution; res > 4; res = Math.floor(res / 2)) {\n      pyramid.push(trajectory.resampleAtTargetResolution(res).tokenize(alphabet.chars));\n    }\n    return pyramid;\n  }\n  /**\n   * Calculate a distance metric between this TrajectoryDescriptor and another. This is\n   * essentially a similarity score and does not directly represent Euclidean distance,\n   * edit distance, or any other formal distance metric.\n   * @param other TrajectoryDescriptor from which to determine distance\n   * @returns distance, a nonnegative similarity score where larger values indicate dissimilarity\n   */\n  distance(other) {\n    let totalDistance = 0;\n    let weight;\n    for (let idx = 0; idx < this._sequences.length; ++idx) {\n      weight = Math.pow(2, idx);\n      totalDistance += weight * this._sequences[idx].distance(other._sequences[idx]);\n    }\n    return totalDistance;\n  }\n}\nTrajectoryDescriptor._FINEST_DESCRIPTOR_RESOLUTION = 32;\n/**\n * A set of TrajectoryDescriptors defined to be \"the same.\" This is essentially a helper\n * class to facilitate methods of Trajectory clustering.\n */\nclass TrajectoryClass {\n  /**\n   * Serialize to JSON.\n   * @returns JSON serialization\n   */\n  serialize() {\n    const jsonObject = {};\n    jsonObject.descriptors = this._descriptors.map(desc => desc.serialize());\n    jsonObject.centroidIdx = this._centroidIdx;\n    jsonObject.averageDistance = this._averageDistance;\n    return JSON.stringify(jsonObject);\n  }\n  /**\n   * Deserialize from JSON string and Alphabet. This should be the same Alphabet\n   * from which the descriptors were originally created, which must be serialized and\n   * deserialized independently so that it can be passed in here.\n   * @param json JSON string representation\n   * @param alphabet Alphabet from which TrajectoryDescriptors were originally created\n   * @returns deserialized TrajectoryDescriptor\n   */\n  static Deserialize(json, alphabet) {\n    const jsonObject = JSON.parse(json);\n    const described = new TrajectoryClass();\n    described._descriptors = jsonObject.descriptors.map(s => TrajectoryDescriptor.Deserialize(s, alphabet));\n    described._centroidIdx = jsonObject.centroidIdx;\n    described._averageDistance = jsonObject.averageDistance;\n    return described;\n  }\n  /**\n   * Create a new DescribedTrajectory.\n   * @param descriptors currently-known TrajectoryDescriptors, if any\n   */\n  constructor(descriptors = []) {\n    this._descriptors = descriptors;\n    this._centroidIdx = -1;\n    this._averageDistance = 0;\n    this._refreshDescription();\n  }\n  /**\n   * Add a new TrajectoryDescriptor to the list of descriptors known to describe\n   * this same DescribedTrajectory.\n   * @param descriptor descriptor to be added\n   */\n  add(descriptor) {\n    this._descriptors.push(descriptor);\n    this._refreshDescription();\n  }\n  /**\n   * Compute the cost, which is inversely related to the likelihood that the provided\n   * TrajectoryDescriptor describes a Trajectory that is considered to be the same as\n   * the class represented by this DescribedTrajectory.\n   * @param descriptor the descriptor to be costed\n   * @returns cost of the match, which is a nonnegative similarity metric where larger values indicate dissimilarity\n   */\n  getMatchCost(descriptor) {\n    return descriptor.distance(this._descriptors[this._centroidIdx]) / this._averageDistance;\n  }\n  /**\n   * Compute the minimum distance between the queried TrajectoryDescriptor and a\n   * descriptor which is a member of this collection. This is an alternative way of\n   * conceptualizing match cost from getMatchCost(), and it serves a different function.\n   * @param descriptor the descriptor to find the minimum distance to\n   * @returns minimum descriptor distance to a member descriptor of this DescribedTrajectory\n   */\n  getMatchMinimumDistance(descriptor) {\n    return Math.min(...this._descriptors.map(desc => desc.distance(descriptor)));\n  }\n  /**\n   * Refreshes the internal representation of this DescribedTrajectory.\n   */\n  _refreshDescription() {\n    this._centroidIdx = -1;\n    let sum;\n    const distances = this._descriptors.map(a => {\n      sum = 0;\n      this._descriptors.forEach(b => {\n        sum += a.distance(b);\n      });\n      return sum;\n    });\n    for (let idx = 0; idx < distances.length; ++idx) {\n      if (this._centroidIdx < 0 || distances[idx] < distances[this._centroidIdx]) {\n        this._centroidIdx = idx;\n      }\n    }\n    this._averageDistance = 0;\n    this._descriptors.forEach(desc => {\n      this._averageDistance += desc.distance(this._descriptors[this._centroidIdx]);\n    });\n    if (this._descriptors.length > 0) {\n      this._averageDistance = Math.max(this._averageDistance / this._descriptors.length, TrajectoryClass._MIN_AVERAGE_DISTANCE);\n    }\n  }\n}\nTrajectoryClass._MIN_AVERAGE_DISTANCE = 1;\n/**\n * Class representing a set of known, named trajectories to which Trajectories can be\n * added and using which Trajectories can be recognized.\n */\nexport class TrajectoryClassifier {\n  /**\n   * Serialize to JSON.\n   * @returns JSON serialization\n   */\n  serialize() {\n    const jsonObject = {};\n    jsonObject.maximumAllowableMatchCost = this._maximumAllowableMatchCost;\n    jsonObject.vector3Alphabet = this._vector3Alphabet.serialize();\n    jsonObject.levenshteinAlphabet = this._levenshteinAlphabet.serialize();\n    jsonObject.nameToDescribedTrajectory = [];\n    this._nameToDescribedTrajectory.forEach((described, name) => {\n      jsonObject.nameToDescribedTrajectory.push(name);\n      jsonObject.nameToDescribedTrajectory.push(described.serialize());\n    });\n    return JSON.stringify(jsonObject);\n  }\n  /**\n   * Deserialize from JSON.\n   * @param json JSON serialization\n   * @returns deserialized TrajectorySet\n   */\n  static Deserialize(json) {\n    const jsonObject = JSON.parse(json);\n    const classifier = new TrajectoryClassifier();\n    classifier._maximumAllowableMatchCost = jsonObject.maximumAllowableMatchCost;\n    classifier._vector3Alphabet = Vector3Alphabet.Deserialize(jsonObject.vector3Alphabet);\n    classifier._levenshteinAlphabet = Levenshtein.Alphabet.Deserialize(jsonObject.levenshteinAlphabet);\n    for (let idx = 0; idx < jsonObject.nameToDescribedTrajectory.length; idx += 2) {\n      classifier._nameToDescribedTrajectory.set(jsonObject.nameToDescribedTrajectory[idx], TrajectoryClass.Deserialize(jsonObject.nameToDescribedTrajectory[idx + 1], classifier._levenshteinAlphabet));\n    }\n    return classifier;\n  }\n  /**\n   * Initialize a new empty TrajectorySet with auto-generated Alphabets.\n   * VERY naive, need to be generating these things from known\n   * sets. Better version later, probably eliminating this one.\n   * @returns auto-generated TrajectorySet\n   */\n  static Generate() {\n    const vecs = Vector3Alphabet.Generate(64, 256, 0.1, 0.001, [Vector3.Forward()]);\n    const charIdxs = new Array(vecs.chars.length);\n    for (let idx = 0; idx < charIdxs.length; ++idx) {\n      charIdxs[idx] = idx;\n    }\n    const alphabet = new Levenshtein.Alphabet(charIdxs, idx => idx === 0 ? 0 : 1, idx => idx === 0 ? 0 : 1, (a, b) => Math.min(1 - Vector3.Dot(vecs.chars[a], vecs.chars[b]), 1));\n    const trajectorySet = new TrajectoryClassifier();\n    trajectorySet._vector3Alphabet = vecs;\n    trajectorySet._levenshteinAlphabet = alphabet;\n    return trajectorySet;\n  }\n  constructor() {\n    this._maximumAllowableMatchCost = 4;\n    this._nameToDescribedTrajectory = new Map();\n  }\n  /**\n   * Add a new Trajectory to the set with a given name.\n   * @param trajectory new Trajectory to be added\n   * @param classification name to which to add the Trajectory\n   */\n  addTrajectoryToClassification(trajectory, classification) {\n    if (!this._nameToDescribedTrajectory.has(classification)) {\n      this._nameToDescribedTrajectory.set(classification, new TrajectoryClass());\n    }\n    this._nameToDescribedTrajectory.get(classification).add(TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet));\n  }\n  /**\n   * Remove a known named trajectory and all Trajectories associated with it.\n   * @param classification name to remove\n   * @returns whether anything was removed\n   */\n  deleteClassification(classification) {\n    return this._nameToDescribedTrajectory.delete(classification);\n  }\n  /**\n   * Attempt to recognize a Trajectory from among all the classifications\n   * already known to the classifier.\n   * @param trajectory Trajectory to be recognized\n   * @returns classification of Trajectory if recognized, null otherwise\n   */\n  classifyTrajectory(trajectory) {\n    const descriptor = TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet);\n    const allowableMatches = [];\n    this._nameToDescribedTrajectory.forEach((trajectoryClass, classification) => {\n      if (trajectoryClass.getMatchCost(descriptor) < this._maximumAllowableMatchCost) {\n        allowableMatches.push(classification);\n      }\n    });\n    if (allowableMatches.length === 0) {\n      return null;\n    }\n    let bestIdx = 0;\n    let bestMatch = this._nameToDescribedTrajectory.get(allowableMatches[bestIdx]).getMatchMinimumDistance(descriptor);\n    let match;\n    for (let idx = 0; idx < allowableMatches.length; ++idx) {\n      match = this._nameToDescribedTrajectory.get(allowableMatches[idx]).getMatchMinimumDistance(descriptor);\n      if (match < bestMatch) {\n        bestMatch = match;\n        bestIdx = idx;\n      }\n    }\n    return allowableMatches[bestIdx];\n  }\n}","map":{"version":3,"names":["Matrix","Vector3","Levenshtein","Alphabet","serialize","jsonObject","characters","Array","_characterToIdx","size","forEach","v","k","_insertionCosts","_deletionCosts","_substitutionCosts","JSON","stringify","Deserialize","json","parse","alphabet","constructor","charToInsertionCost","charToDeletionCost","charsToSubstitutionCost","a","b","Map","length","c","outerIdx","set","innerIdx","getCharacterIdx","char","get","getInsertionCost","idx","getDeletionCost","getSubstitutionCost","idx1","idx2","min","Math","max","Sequence","_characters","sequence","_MAX_SEQUENCE_LENGTH","Error","_alphabet","map","distance","other","_Distance","aChars","bChars","aLength","bLength","costMatrix","_CostMatrix","aIdx","bIdx","_InsertionCost","_DeletionCost","_SubstitutionCost","Trajectory","trajectory","_points","pt","segmentLength","_segmentLength","getLength","add","point","numPoints","push","clone","getT","Distance","t","newPoint","scale","scaleAndAddToRef","resampleAtTargetResolution","targetResolution","resampled","tokenize","tokens","tokenization","segmentDir","_TransformSegmentDirToRef","_TokenizeSegment","priorVec","fromVec","toVec","result","DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD","subtractToRef","_ForwardDir","normalize","scaleToRef","_InverseFromVec","abs","Dot","CrossToRef","_UpDir","LookAtLHToRef","_LookMatrix","_FromToVec","TransformNormalToRef","segment","_BestMatch","_Score","_BestScore","Vector3Alphabet","Generate","alphabetSize","iterations","startingStepSize","endingStepSize","fixedValues","EPSILON","EPSILON_SQUARED","chars","random","copyFrom","stepSize","distSq","force","scratch","lerp","l","r","iteration","copyFromFloats","lengthSquared","scaleInPlace","addInPlace","TrajectoryDescriptor","_sequences","descriptor","s","CreateFromTrajectory","vector3Alphabet","levenshteinAlphabet","CreateFromTokenizationPyramid","_GetTokenizationPyramid","pyramid","_FINEST_DESCRIPTOR_RESOLUTION","res","floor","totalDistance","weight","pow","TrajectoryClass","descriptors","_descriptors","desc","centroidIdx","_centroidIdx","averageDistance","_averageDistance","described","_refreshDescription","getMatchCost","getMatchMinimumDistance","sum","distances","_MIN_AVERAGE_DISTANCE","TrajectoryClassifier","maximumAllowableMatchCost","_maximumAllowableMatchCost","_vector3Alphabet","_levenshteinAlphabet","nameToDescribedTrajectory","_nameToDescribedTrajectory","name","classifier","vecs","Forward","charIdxs","trajectorySet","addTrajectoryToClassification","classification","has","deleteClassification","delete","classifyTrajectory","allowableMatches","trajectoryClass","bestIdx","bestMatch","match"],"sources":["../../../../dev/core/src/Misc/trajectoryClassifier.ts"],"sourcesContent":["import type { DeepImmutable, Nullable } from \"../types\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\n\r\n// This implementation was based on the original MIT-licensed TRACE repository\r\n// from https://github.com/septagon/TRACE.\r\n\r\n/**\r\n * Generic implementation of Levenshtein distance.\r\n */\r\nnamespace Levenshtein {\r\n    /**\r\n     * Alphabet from which to construct sequences to be compared using Levenshtein\r\n     * distance.\r\n     */\r\n    export class Alphabet<T> {\r\n        private _characterToIdx: Map<T, number>;\r\n        private _insertionCosts: number[];\r\n        private _deletionCosts: number[];\r\n        private _substitutionCosts: number[][];\r\n\r\n        /**\r\n         * Serialize the Alphabet to JSON string.\r\n         * @returns JSON serialization\r\n         */\r\n        public serialize(): string {\r\n            const jsonObject: any = {};\r\n\r\n            const characters = new Array<T>(this._characterToIdx.size);\r\n            this._characterToIdx.forEach((v, k) => {\r\n                characters[v] = k;\r\n            });\r\n            jsonObject[\"characters\"] = characters;\r\n\r\n            jsonObject[\"insertionCosts\"] = this._insertionCosts;\r\n            jsonObject[\"deletionCosts\"] = this._deletionCosts;\r\n            jsonObject[\"substitutionCosts\"] = this._substitutionCosts;\r\n\r\n            return JSON.stringify(jsonObject);\r\n        }\r\n\r\n        /**\r\n         * Parse an Alphabet from a JSON serialization.\r\n         * @param json JSON string to deserialize\r\n         * @returns deserialized Alphabet\r\n         */\r\n        public static Deserialize<T>(json: string): Alphabet<T> {\r\n            const jsonObject = JSON.parse(json);\r\n            const alphabet = new Alphabet(jsonObject[\"characters\"] as T[]);\r\n            alphabet._insertionCosts = jsonObject[\"insertionCosts\"];\r\n            alphabet._deletionCosts = jsonObject[\"deletionCosts\"];\r\n            alphabet._substitutionCosts = jsonObject[\"substitutionCosts\"];\r\n            return alphabet;\r\n        }\r\n\r\n        /**\r\n         * Create a new Alphabet.\r\n         * @param characters characters of the alphabet\r\n         * @param charToInsertionCost function mapping characters to insertion costs\r\n         * @param charToDeletionCost function mapping characters to deletion costs\r\n         * @param charsToSubstitutionCost function mapping character pairs to substitution costs\r\n         */\r\n        public constructor(\r\n            characters: Array<T>,\r\n            charToInsertionCost: Nullable<(char: T) => number> = null,\r\n            charToDeletionCost: Nullable<(char: T) => number> = null,\r\n            charsToSubstitutionCost: Nullable<(outChar: T, inChar: T) => number> = null\r\n        ) {\r\n            charToInsertionCost = charToInsertionCost ?? (() => 1);\r\n            charToDeletionCost = charToDeletionCost ?? (() => 1);\r\n            charsToSubstitutionCost = charsToSubstitutionCost ?? ((a: T, b: T) => (a === b ? 0 : 1));\r\n\r\n            this._characterToIdx = new Map<T, number>();\r\n            this._insertionCosts = new Array<number>(characters.length);\r\n            this._deletionCosts = new Array<number>(characters.length);\r\n            this._substitutionCosts = new Array<Array<number>>(characters.length);\r\n\r\n            let c: T;\r\n            for (let outerIdx = 0; outerIdx < characters.length; ++outerIdx) {\r\n                c = characters[outerIdx];\r\n                this._characterToIdx.set(c, outerIdx);\r\n                this._insertionCosts[outerIdx] = charToInsertionCost(c);\r\n                this._deletionCosts[outerIdx] = charToDeletionCost(c);\r\n\r\n                this._substitutionCosts[outerIdx] = new Array<number>(characters.length);\r\n                for (let innerIdx = outerIdx; innerIdx < characters.length; ++innerIdx) {\r\n                    this._substitutionCosts[outerIdx][innerIdx] = charsToSubstitutionCost(c, characters[innerIdx]);\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Get the index (internally-assigned number) for a character.\r\n         * @param char character\r\n         * @returns index\r\n         */\r\n        public getCharacterIdx(char: T): number {\r\n            return this._characterToIdx.get(char)!;\r\n        }\r\n\r\n        /**\r\n         * Get the insertion cost of a character from its index.\r\n         * @param idx character index\r\n         * @returns insertion cost\r\n         */\r\n        public getInsertionCost(idx: number): number {\r\n            return this._insertionCosts[idx];\r\n        }\r\n\r\n        /**\r\n         * Get the deletion cost of a character from its index.\r\n         * @param idx character index\r\n         * @returns deletion cost\r\n         */\r\n        public getDeletionCost(idx: number): number {\r\n            return this._deletionCosts[idx];\r\n        }\r\n\r\n        /**\r\n         * Gets the cost to substitute two characters. NOTE: this cost is\r\n         * required to be bi-directional, meaning it cannot matter which of\r\n         * the provided characters is being removed and which is being inserted.\r\n         * @param idx1 the first character index\r\n         * @param idx2 the second character index\r\n         * @returns substitution cost\r\n         */\r\n        public getSubstitutionCost(idx1: number, idx2: number): number {\r\n            const min = Math.min(idx1, idx2);\r\n            const max = Math.max(idx1, idx2);\r\n\r\n            return this._substitutionCosts[min][max];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Character sequence intended to be compared against other Sequences created\r\n     * with the same Alphabet in order to compute Levenshtein distance.\r\n     */\r\n    export class Sequence<T> {\r\n        private _alphabet: Alphabet<T>;\r\n        private _characters: number[];\r\n\r\n        // Scratch values\r\n        private static readonly _MAX_SEQUENCE_LENGTH = 256;\r\n        private static _CostMatrix = [...Array(Sequence._MAX_SEQUENCE_LENGTH + 1)].map(() => new Array<number>(Sequence._MAX_SEQUENCE_LENGTH + 1));\r\n        private static _InsertionCost: number;\r\n        private static _DeletionCost: number;\r\n        private static _SubstitutionCost: number;\r\n\r\n        /**\r\n         * Serialize to JSON string. JSON representation does NOT include the Alphabet\r\n         * from which this Sequence was created; Alphabet must be independently\r\n         * serialized.\r\n         * @returns JSON string\r\n         */\r\n        public serialize(): string {\r\n            return JSON.stringify(this._characters);\r\n        }\r\n\r\n        /**\r\n         * Deserialize from JSON string and Alphabet. This should be the same Alphabet\r\n         * from which the Sequence was originally created, which must be serialized and\r\n         * deserialized independently so that it can be passed in here.\r\n         * @param json JSON string representation of Sequence\r\n         * @param alphabet Alphabet from which Sequence was originally created\r\n         * @returns Sequence\r\n         */\r\n        public static Deserialize<T>(json: string, alphabet: Alphabet<T>): Sequence<T> {\r\n            const sequence = new Sequence([], alphabet);\r\n            sequence._characters = JSON.parse(json);\r\n            return sequence;\r\n        }\r\n\r\n        /**\r\n         * Create a new Sequence.\r\n         * @param characters characters in the new Sequence\r\n         * @param alphabet Alphabet, which must include all used characters\r\n         */\r\n        public constructor(characters: T[], alphabet: Alphabet<T>) {\r\n            if (characters.length > Sequence._MAX_SEQUENCE_LENGTH) {\r\n                throw new Error(\"Sequences longer than \" + Sequence._MAX_SEQUENCE_LENGTH + \" not supported.\");\r\n            }\r\n            this._alphabet = alphabet;\r\n            this._characters = characters.map((c) => this._alphabet.getCharacterIdx(c));\r\n        }\r\n\r\n        /**\r\n         * Get the distance between this Sequence and another.\r\n         * @param other sequence to compare to\r\n         * @returns Levenshtein distance\r\n         */\r\n        public distance(other: Sequence<T>): number {\r\n            return Sequence._Distance<T>(this, other);\r\n        }\r\n\r\n        /**\r\n         * Compute the Levenshtein distance between two Sequences.\r\n         * @param a first Sequence\r\n         * @param b second Sequence\r\n         * @returns Levenshtein distance\r\n         */\r\n        private static _Distance<T>(a: Sequence<T>, b: Sequence<T>): number {\r\n            const alphabet = a._alphabet;\r\n            if (alphabet !== b._alphabet) {\r\n                throw new Error(\"Cannot Levenshtein compare Sequences built from different alphabets.\");\r\n            }\r\n            const aChars = a._characters;\r\n            const bChars = b._characters;\r\n            const aLength = aChars.length;\r\n            const bLength = bChars.length;\r\n\r\n            const costMatrix = Sequence._CostMatrix;\r\n            costMatrix[0][0] = 0;\r\n            for (let idx = 0; idx < aLength; ++idx) {\r\n                costMatrix[idx + 1][0] = costMatrix[idx][0] + alphabet.getInsertionCost(aChars[idx]);\r\n            }\r\n            for (let idx = 0; idx < bLength; ++idx) {\r\n                costMatrix[0][idx + 1] = costMatrix[0][idx] + alphabet.getInsertionCost(bChars[idx]);\r\n            }\r\n\r\n            for (let aIdx = 0; aIdx < aLength; ++aIdx) {\r\n                for (let bIdx = 0; bIdx < bLength; ++bIdx) {\r\n                    Sequence._InsertionCost = costMatrix[aIdx + 1][bIdx] + alphabet.getInsertionCost(bChars[bIdx]);\r\n                    Sequence._DeletionCost = costMatrix[aIdx][bIdx + 1] + alphabet.getDeletionCost(aChars[aIdx]);\r\n                    Sequence._SubstitutionCost = costMatrix[aIdx][bIdx] + alphabet.getSubstitutionCost(aChars[aIdx], bChars[bIdx]);\r\n\r\n                    costMatrix[aIdx + 1][bIdx + 1] = Math.min(Sequence._InsertionCost, Sequence._DeletionCost, Sequence._SubstitutionCost);\r\n                }\r\n            }\r\n\r\n            return costMatrix[aLength][bLength];\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * A 3D trajectory consisting of an order list of vectors describing a\r\n * path of motion through 3D space.\r\n */\r\nexport class Trajectory {\r\n    private _points: Vector3[];\r\n    private readonly _segmentLength: number;\r\n\r\n    /**\r\n     * Serialize to JSON.\r\n     * @returns serialized JSON string\r\n     */\r\n    public serialize(): string {\r\n        return JSON.stringify(this);\r\n    }\r\n\r\n    /**\r\n     * Deserialize from JSON.\r\n     * @param json serialized JSON string\r\n     * @returns deserialized Trajectory\r\n     */\r\n    public static Deserialize(json: string): Trajectory {\r\n        const jsonObject = JSON.parse(json);\r\n        const trajectory = new Trajectory(jsonObject[\"_segmentLength\"]);\r\n        trajectory._points = jsonObject[\"_points\"].map((pt: any) => {\r\n            return new Vector3(pt[\"_x\"], pt[\"_y\"], pt[\"_z\"]);\r\n        });\r\n        return trajectory;\r\n    }\r\n\r\n    /**\r\n     * Create a new empty Trajectory.\r\n     * @param segmentLength radius of discretization for Trajectory points\r\n     */\r\n    public constructor(segmentLength: number = 0.01) {\r\n        this._points = [];\r\n        this._segmentLength = segmentLength;\r\n    }\r\n\r\n    /**\r\n     * Get the length of the Trajectory.\r\n     * @returns length of the Trajectory\r\n     */\r\n    public getLength(): number {\r\n        return this._points.length * this._segmentLength;\r\n    }\r\n\r\n    /**\r\n     * Append a new point to the Trajectory.\r\n     * NOTE: This implementation has many allocations.\r\n     * @param point point to append to the Trajectory\r\n     */\r\n    public add(point: DeepImmutable<Vector3>): void {\r\n        let numPoints = this._points.length;\r\n        if (numPoints === 0) {\r\n            this._points.push(point.clone());\r\n        } else {\r\n            const getT = () => this._segmentLength / Vector3.Distance(this._points[numPoints - 1], point);\r\n            for (let t = getT(); t <= 1.0; t = getT()) {\r\n                const newPoint = this._points[numPoints - 1].scale(1.0 - t);\r\n                point.scaleAndAddToRef(t, newPoint);\r\n                this._points.push(newPoint);\r\n                ++numPoints;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new Trajectory with a segment length chosen to make it\r\n     * probable that the new Trajectory will have a specified number of\r\n     * segments. This operation is imprecise.\r\n     * @param targetResolution number of segments desired\r\n     * @returns new Trajectory with approximately the requested number of segments\r\n     */\r\n    public resampleAtTargetResolution(targetResolution: number): Trajectory {\r\n        const resampled = new Trajectory(this.getLength() / targetResolution);\r\n        this._points.forEach((pt) => {\r\n            resampled.add(pt);\r\n        });\r\n        return resampled;\r\n    }\r\n\r\n    /**\r\n     * Convert Trajectory segments into tokenized representation. This\r\n     * representation is an array of numbers where each nth number is the\r\n     * index of the token which is most similar to the nth segment of the\r\n     * Trajectory.\r\n     * @param tokens list of vectors which serve as discrete tokens\r\n     * @returns list of indices of most similar token per segment\r\n     */\r\n    public tokenize(tokens: DeepImmutable<Vector3[]>): number[] {\r\n        const tokenization: number[] = [];\r\n\r\n        const segmentDir = new Vector3();\r\n        for (let idx = 2; idx < this._points.length; ++idx) {\r\n            if (Trajectory._TransformSegmentDirToRef(this._points[idx - 2], this._points[idx - 1], this._points[idx], segmentDir)) {\r\n                tokenization.push(Trajectory._TokenizeSegment(segmentDir, tokens));\r\n            }\r\n        }\r\n\r\n        return tokenization;\r\n    }\r\n\r\n    private static _ForwardDir = new Vector3();\r\n    private static _InverseFromVec = new Vector3();\r\n    private static _UpDir = new Vector3();\r\n    private static _FromToVec = new Vector3();\r\n    private static _LookMatrix = new Matrix();\r\n\r\n    /**\r\n     * Transform the rotation (i.e., direction) of a segment to isolate\r\n     * the relative transformation represented by the segment. This operation\r\n     * may or may not succeed due to singularities in the equations that define\r\n     * motion relativity in this context.\r\n     * @param priorVec the origin of the prior segment\r\n     * @param fromVec the origin of the current segment\r\n     * @param toVec the destination of the current segment\r\n     * @param result reference to output variable\r\n     * @returns whether or not transformation was successful\r\n     */\r\n    private static _TransformSegmentDirToRef(priorVec: DeepImmutable<Vector3>, fromVec: DeepImmutable<Vector3>, toVec: DeepImmutable<Vector3>, result: Vector3): boolean {\r\n        const DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD = 0.98;\r\n\r\n        fromVec.subtractToRef(priorVec, Trajectory._ForwardDir);\r\n        Trajectory._ForwardDir.normalize();\r\n        fromVec.scaleToRef(-1, Trajectory._InverseFromVec);\r\n        Trajectory._InverseFromVec.normalize();\r\n\r\n        if (Math.abs(Vector3.Dot(Trajectory._ForwardDir, Trajectory._InverseFromVec)) > DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD) {\r\n            return false;\r\n        }\r\n\r\n        Vector3.CrossToRef(Trajectory._ForwardDir, Trajectory._InverseFromVec, Trajectory._UpDir);\r\n        Trajectory._UpDir.normalize();\r\n        Matrix.LookAtLHToRef(priorVec, fromVec, Trajectory._UpDir, Trajectory._LookMatrix);\r\n        toVec.subtractToRef(fromVec, Trajectory._FromToVec);\r\n        Trajectory._FromToVec.normalize();\r\n        Vector3.TransformNormalToRef(Trajectory._FromToVec, Trajectory._LookMatrix, result);\r\n        return true;\r\n    }\r\n\r\n    private static _BestMatch: number;\r\n    private static _Score: number;\r\n    private static _BestScore: number;\r\n\r\n    /**\r\n     * Determine which token vector is most similar to the\r\n     * segment vector.\r\n     * @param segment segment vector\r\n     * @param tokens token vector list\r\n     * @returns index of the most similar token to the segment\r\n     */\r\n    private static _TokenizeSegment(segment: DeepImmutable<Vector3>, tokens: DeepImmutable<Vector3[]>): number {\r\n        Trajectory._BestMatch = 0;\r\n        Trajectory._Score = Vector3.Dot(segment, tokens[0]);\r\n        Trajectory._BestScore = Trajectory._Score;\r\n        for (let idx = 1; idx < tokens.length; ++idx) {\r\n            Trajectory._Score = Vector3.Dot(segment, tokens[idx]);\r\n            if (Trajectory._Score > Trajectory._BestScore) {\r\n                Trajectory._BestMatch = idx;\r\n                Trajectory._BestScore = Trajectory._Score;\r\n            }\r\n        }\r\n\r\n        return Trajectory._BestMatch;\r\n    }\r\n}\r\n\r\n/**\r\n * Collection of vectors intended to be used as the basis of Trajectory\r\n * tokenization for Levenshtein distance comparison. Canonically, a\r\n * Vector3Alphabet will resemble a \"spikeball\" of vectors distributed\r\n * roughly evenly over the surface of the unit sphere.\r\n */\r\nclass Vector3Alphabet {\r\n    /**\r\n     * Characters in the alphabet.\r\n     * NOTE: There is no reason for this property to exist and this class should just extend\r\n     * Array<Vector3>, except that doing so produces bizarre build-time errors indicating that\r\n     * the ES5 library itself fails its own TypeDoc validation.\r\n     */\r\n    public chars: Vector3[];\r\n\r\n    /**\r\n     * Helper method to create new \"spikeball\" Vector3Alphabets. Uses a naive\r\n     * optimize-from-random strategy to space points around the unit sphere\r\n     * surface as a simple alternative to really doing the math to tile the\r\n     * sphere.\r\n     * @param alphabetSize size of the desired alphabet\r\n     * @param iterations number of iterations over which to optimize the \"spikeball\"\r\n     * @param startingStepSize distance factor to move points in early optimization iterations\r\n     * @param endingStepSize distance factor to move points in late optimization iterations\r\n     * @param fixedValues alphabet \"characters\" that are required and cannot be moved by optimization\r\n     * @returns a new randomly generated and optimized Vector3Alphabet of the specified size\r\n     */\r\n    public static Generate(\r\n        alphabetSize: number = 64,\r\n        iterations: number = 256,\r\n        startingStepSize: number = 0.1,\r\n        endingStepSize: number = 0.001,\r\n        fixedValues: DeepImmutable<Vector3[]> = []\r\n    ): Vector3Alphabet {\r\n        const EPSILON = 0.001;\r\n        const EPSILON_SQUARED = EPSILON * EPSILON;\r\n\r\n        const alphabet = new Vector3Alphabet(alphabetSize);\r\n        for (let idx = 0; idx < alphabetSize; ++idx) {\r\n            alphabet.chars[idx] = new Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);\r\n            alphabet.chars[idx].normalize();\r\n        }\r\n\r\n        for (let idx = 0; idx < fixedValues.length; ++idx) {\r\n            alphabet.chars[idx].copyFrom(fixedValues[idx]);\r\n        }\r\n\r\n        let stepSize: number;\r\n        let distSq: number;\r\n        const force = new Vector3();\r\n        const scratch = new Vector3();\r\n        const lerp = (l: number, r: number, t: number) => (1.0 - t) * l + t * r;\r\n        for (let iteration = 0; iteration < iterations; ++iteration) {\r\n            stepSize = lerp(startingStepSize, endingStepSize, iteration / (iterations - 1));\r\n            for (let idx = fixedValues.length; idx < alphabet.chars.length; ++idx) {\r\n                force.copyFromFloats(0, 0, 0);\r\n                alphabet.chars.forEach((pt) => {\r\n                    alphabet.chars[idx].subtractToRef(pt, scratch);\r\n                    distSq = scratch.lengthSquared();\r\n                    if (distSq > EPSILON_SQUARED) {\r\n                        scratch.scaleAndAddToRef(1 / (scratch.lengthSquared() * distSq), force);\r\n                    }\r\n                });\r\n                force.scaleInPlace(stepSize);\r\n                alphabet.chars[idx].addInPlace(force);\r\n                alphabet.chars[idx].normalize();\r\n            }\r\n        }\r\n\r\n        return alphabet;\r\n    }\r\n\r\n    /**\r\n     * Serialize to JSON.\r\n     * @returns JSON serialization\r\n     */\r\n    public serialize(): string {\r\n        return JSON.stringify(this.chars);\r\n    }\r\n\r\n    /**\r\n     * Deserialize from JSON.\r\n     * @param json JSON serialization\r\n     * @returns deserialized Vector3Alphabet\r\n     */\r\n    public static Deserialize(json: string): Vector3Alphabet {\r\n        const jsonObject = JSON.parse(json);\r\n        const alphabet = new Vector3Alphabet(jsonObject.length);\r\n        for (let idx = 0; idx < jsonObject.length; ++idx) {\r\n            alphabet.chars[idx] = new Vector3(jsonObject[idx][\"_x\"], jsonObject[idx][\"_y\"], jsonObject[idx][\"_z\"]);\r\n        }\r\n        return alphabet;\r\n    }\r\n\r\n    private constructor(size: number) {\r\n        this.chars = new Array(size);\r\n    }\r\n}\r\n\r\n/**\r\n * Class which formalizes the manner in which a Vector3Alphabet is used to tokenize and\r\n * describe a Trajectory. This class houses the functionality which determines what\r\n * attributes of Trajectories are and are not considered important, such as scale.\r\n */\r\nclass TrajectoryDescriptor {\r\n    private static readonly _FINEST_DESCRIPTOR_RESOLUTION = 32;\r\n\r\n    private _sequences: Levenshtein.Sequence<number>[];\r\n\r\n    /**\r\n     * Serialize to JSON.\r\n     * @returns JSON serialization\r\n     */\r\n    public serialize(): string {\r\n        return JSON.stringify(this._sequences.map((sequence) => sequence.serialize()));\r\n    }\r\n\r\n    /**\r\n     * Deserialize from JSON string and Alphabet. This should be the same Alphabet\r\n     * from which the descriptor was originally created, which must be serialized and\r\n     * deserialized independently so that it can be passed in here.\r\n     * @param json JSON serialization\r\n     * @param alphabet Alphabet from which descriptor was originally created\r\n     * @returns deserialized TrajectoryDescriptor\r\n     */\r\n    public static Deserialize(json: string, alphabet: Levenshtein.Alphabet<number>): TrajectoryDescriptor {\r\n        const descriptor = new TrajectoryDescriptor();\r\n        descriptor._sequences = (JSON.parse(json) as string[]).map((s) => Levenshtein.Sequence.Deserialize(s, alphabet));\r\n        return descriptor;\r\n    }\r\n\r\n    /**\r\n     * Create a new TrajectoryDescriptor to describe a provided Trajectory according\r\n     * to the provided alphabets.\r\n     * @param trajectory Trajectory to be described\r\n     * @param vector3Alphabet Vector3Alphabet to be used to tokenize the Trajectory\r\n     * @param levenshteinAlphabet Levenshtein.Alphabet to be used as basis for comparison with other descriptors\r\n     * @returns TrajectoryDescriptor describing provided Trajectory\r\n     */\r\n    public static CreateFromTrajectory(trajectory: Trajectory, vector3Alphabet: Vector3Alphabet, levenshteinAlphabet: Levenshtein.Alphabet<number>): TrajectoryDescriptor {\r\n        return TrajectoryDescriptor.CreateFromTokenizationPyramid(TrajectoryDescriptor._GetTokenizationPyramid(trajectory, vector3Alphabet), levenshteinAlphabet);\r\n    }\r\n\r\n    /**\r\n     * Create a new TrajectoryDescriptor from a pre-existing pyramid of tokens.\r\n     * NOTE: This function exists to support an outdated serialization mechanism and should\r\n     * be deleted if it is no longer useful.\r\n     * @param pyramid tokenization pyramid\r\n     * @param levenshteinAlphabet Levenshtein.Alphabet to be uses as basis for comparison with other descriptors\r\n     * @returns TrajectoryDescriptor describing the Trajectory from which the pyramid was built\r\n     */\r\n    public static CreateFromTokenizationPyramid(pyramid: number[][], levenshteinAlphabet: Levenshtein.Alphabet<number>): TrajectoryDescriptor {\r\n        const descriptor = new TrajectoryDescriptor();\r\n        descriptor._sequences = pyramid.map((tokens) => new Levenshtein.Sequence<number>(tokens, levenshteinAlphabet));\r\n        return descriptor;\r\n    }\r\n\r\n    private constructor() {\r\n        this._sequences = [];\r\n    }\r\n\r\n    /**\r\n     * Create the tokenization pyramid for the provided Trajectory according to the given\r\n     * Vector3Alphabet.\r\n     * @param trajectory Trajectory to be tokenized\r\n     * @param alphabet Vector3Alphabet containing tokens\r\n     * @param targetResolution finest resolution of descriptor\r\n     * @returns tokenization pyramid for Trajectory\r\n     */\r\n    private static _GetTokenizationPyramid(\r\n        trajectory: Trajectory,\r\n        alphabet: Vector3Alphabet,\r\n        targetResolution: number = TrajectoryDescriptor._FINEST_DESCRIPTOR_RESOLUTION\r\n    ): number[][] {\r\n        const pyramid: number[][] = [];\r\n        for (let res = targetResolution; res > 4; res = Math.floor(res / 2)) {\r\n            pyramid.push(trajectory.resampleAtTargetResolution(res).tokenize(alphabet.chars));\r\n        }\r\n        return pyramid;\r\n    }\r\n\r\n    /**\r\n     * Calculate a distance metric between this TrajectoryDescriptor and another. This is\r\n     * essentially a similarity score and does not directly represent Euclidean distance,\r\n     * edit distance, or any other formal distance metric.\r\n     * @param other TrajectoryDescriptor from which to determine distance\r\n     * @returns distance, a nonnegative similarity score where larger values indicate dissimilarity\r\n     */\r\n    public distance(other: TrajectoryDescriptor): number {\r\n        let totalDistance = 0;\r\n        let weight: number;\r\n        for (let idx = 0; idx < this._sequences.length; ++idx) {\r\n            weight = Math.pow(2, idx);\r\n            totalDistance += weight * this._sequences[idx].distance(other._sequences[idx]);\r\n        }\r\n        return totalDistance;\r\n    }\r\n}\r\n\r\n/**\r\n * A set of TrajectoryDescriptors defined to be \"the same.\" This is essentially a helper\r\n * class to facilitate methods of Trajectory clustering.\r\n */\r\nclass TrajectoryClass {\r\n    private static readonly _MIN_AVERAGE_DISTANCE = 1;\r\n\r\n    private _descriptors: TrajectoryDescriptor[];\r\n    private _centroidIdx: number;\r\n    private _averageDistance: number;\r\n\r\n    /**\r\n     * Serialize to JSON.\r\n     * @returns JSON serialization\r\n     */\r\n    public serialize(): string {\r\n        const jsonObject: any = {};\r\n        jsonObject.descriptors = this._descriptors.map((desc) => desc.serialize());\r\n        jsonObject.centroidIdx = this._centroidIdx;\r\n        jsonObject.averageDistance = this._averageDistance;\r\n        return JSON.stringify(jsonObject);\r\n    }\r\n\r\n    /**\r\n     * Deserialize from JSON string and Alphabet. This should be the same Alphabet\r\n     * from which the descriptors were originally created, which must be serialized and\r\n     * deserialized independently so that it can be passed in here.\r\n     * @param json JSON string representation\r\n     * @param alphabet Alphabet from which TrajectoryDescriptors were originally created\r\n     * @returns deserialized TrajectoryDescriptor\r\n     */\r\n    public static Deserialize(json: string, alphabet: Levenshtein.Alphabet<number>): TrajectoryClass {\r\n        const jsonObject = JSON.parse(json);\r\n        const described = new TrajectoryClass();\r\n        described._descriptors = jsonObject.descriptors.map((s: string) => TrajectoryDescriptor.Deserialize(s, alphabet));\r\n        described._centroidIdx = jsonObject.centroidIdx;\r\n        described._averageDistance = jsonObject.averageDistance;\r\n        return described;\r\n    }\r\n\r\n    /**\r\n     * Create a new DescribedTrajectory.\r\n     * @param descriptors currently-known TrajectoryDescriptors, if any\r\n     */\r\n    public constructor(descriptors: TrajectoryDescriptor[] = []) {\r\n        this._descriptors = descriptors;\r\n        this._centroidIdx = -1;\r\n        this._averageDistance = 0;\r\n\r\n        this._refreshDescription();\r\n    }\r\n\r\n    /**\r\n     * Add a new TrajectoryDescriptor to the list of descriptors known to describe\r\n     * this same DescribedTrajectory.\r\n     * @param descriptor descriptor to be added\r\n     */\r\n    public add(descriptor: TrajectoryDescriptor): void {\r\n        this._descriptors.push(descriptor);\r\n        this._refreshDescription();\r\n    }\r\n\r\n    /**\r\n     * Compute the cost, which is inversely related to the likelihood that the provided\r\n     * TrajectoryDescriptor describes a Trajectory that is considered to be the same as\r\n     * the class represented by this DescribedTrajectory.\r\n     * @param descriptor the descriptor to be costed\r\n     * @returns cost of the match, which is a nonnegative similarity metric where larger values indicate dissimilarity\r\n     */\r\n    public getMatchCost(descriptor: TrajectoryDescriptor): number {\r\n        return descriptor.distance(this._descriptors[this._centroidIdx]) / this._averageDistance;\r\n    }\r\n\r\n    /**\r\n     * Compute the minimum distance between the queried TrajectoryDescriptor and a\r\n     * descriptor which is a member of this collection. This is an alternative way of\r\n     * conceptualizing match cost from getMatchCost(), and it serves a different function.\r\n     * @param descriptor the descriptor to find the minimum distance to\r\n     * @returns minimum descriptor distance to a member descriptor of this DescribedTrajectory\r\n     */\r\n    public getMatchMinimumDistance(descriptor: TrajectoryDescriptor): number {\r\n        return Math.min(...this._descriptors.map((desc) => desc.distance(descriptor)));\r\n    }\r\n\r\n    /**\r\n     * Refreshes the internal representation of this DescribedTrajectory.\r\n     */\r\n    private _refreshDescription(): void {\r\n        this._centroidIdx = -1;\r\n        let sum: number;\r\n        const distances = this._descriptors.map((a) => {\r\n            sum = 0;\r\n            this._descriptors.forEach((b) => {\r\n                sum += a.distance(b);\r\n            });\r\n            return sum;\r\n        });\r\n        for (let idx = 0; idx < distances.length; ++idx) {\r\n            if (this._centroidIdx < 0 || distances[idx] < distances[this._centroidIdx]) {\r\n                this._centroidIdx = idx;\r\n            }\r\n        }\r\n\r\n        this._averageDistance = 0;\r\n        this._descriptors.forEach((desc) => {\r\n            this._averageDistance += desc.distance(this._descriptors[this._centroidIdx]);\r\n        });\r\n        if (this._descriptors.length > 0) {\r\n            this._averageDistance = Math.max(this._averageDistance / this._descriptors.length, TrajectoryClass._MIN_AVERAGE_DISTANCE);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Class representing a set of known, named trajectories to which Trajectories can be\r\n * added and using which Trajectories can be recognized.\r\n */\r\nexport class TrajectoryClassifier {\r\n    private _maximumAllowableMatchCost: number = 4;\r\n    private _vector3Alphabet: Vector3Alphabet;\r\n    private _levenshteinAlphabet: Levenshtein.Alphabet<number>;\r\n    private _nameToDescribedTrajectory: Map<string, TrajectoryClass>;\r\n\r\n    /**\r\n     * Serialize to JSON.\r\n     * @returns JSON serialization\r\n     */\r\n    public serialize(): string {\r\n        const jsonObject: any = {};\r\n        jsonObject.maximumAllowableMatchCost = this._maximumAllowableMatchCost;\r\n        jsonObject.vector3Alphabet = this._vector3Alphabet.serialize();\r\n        jsonObject.levenshteinAlphabet = this._levenshteinAlphabet.serialize();\r\n        jsonObject.nameToDescribedTrajectory = [];\r\n        this._nameToDescribedTrajectory.forEach((described, name) => {\r\n            jsonObject.nameToDescribedTrajectory.push(name);\r\n            jsonObject.nameToDescribedTrajectory.push(described.serialize());\r\n        });\r\n        return JSON.stringify(jsonObject);\r\n    }\r\n\r\n    /**\r\n     * Deserialize from JSON.\r\n     * @param json JSON serialization\r\n     * @returns deserialized TrajectorySet\r\n     */\r\n    public static Deserialize(json: string): TrajectoryClassifier {\r\n        const jsonObject = JSON.parse(json);\r\n        const classifier = new TrajectoryClassifier();\r\n        classifier._maximumAllowableMatchCost = jsonObject.maximumAllowableMatchCost;\r\n        classifier._vector3Alphabet = Vector3Alphabet.Deserialize(jsonObject.vector3Alphabet);\r\n        classifier._levenshteinAlphabet = Levenshtein.Alphabet.Deserialize<number>(jsonObject.levenshteinAlphabet);\r\n        for (let idx = 0; idx < jsonObject.nameToDescribedTrajectory.length; idx += 2) {\r\n            classifier._nameToDescribedTrajectory.set(\r\n                jsonObject.nameToDescribedTrajectory[idx],\r\n                TrajectoryClass.Deserialize(jsonObject.nameToDescribedTrajectory[idx + 1], classifier._levenshteinAlphabet)\r\n            );\r\n        }\r\n        return classifier;\r\n    }\r\n\r\n    /**\r\n     * Initialize a new empty TrajectorySet with auto-generated Alphabets.\r\n     * VERY naive, need to be generating these things from known\r\n     * sets. Better version later, probably eliminating this one.\r\n     * @returns auto-generated TrajectorySet\r\n     */\r\n    public static Generate(): TrajectoryClassifier {\r\n        const vecs = Vector3Alphabet.Generate(64, 256, 0.1, 0.001, [Vector3.Forward()]);\r\n\r\n        const charIdxs = new Array(vecs.chars.length);\r\n        for (let idx = 0; idx < charIdxs.length; ++idx) {\r\n            charIdxs[idx] = idx;\r\n        }\r\n\r\n        const alphabet = new Levenshtein.Alphabet<number>(\r\n            charIdxs,\r\n            (idx) => (idx === 0 ? 0 : 1),\r\n            (idx) => (idx === 0 ? 0 : 1),\r\n            (a, b) => Math.min(1 - Vector3.Dot(vecs.chars[a], vecs.chars[b]), 1)\r\n        );\r\n\r\n        const trajectorySet = new TrajectoryClassifier();\r\n        trajectorySet._vector3Alphabet = vecs;\r\n        trajectorySet._levenshteinAlphabet = alphabet;\r\n        return trajectorySet;\r\n    }\r\n\r\n    private constructor() {\r\n        this._nameToDescribedTrajectory = new Map<string, TrajectoryClass>();\r\n    }\r\n\r\n    /**\r\n     * Add a new Trajectory to the set with a given name.\r\n     * @param trajectory new Trajectory to be added\r\n     * @param classification name to which to add the Trajectory\r\n     */\r\n    public addTrajectoryToClassification(trajectory: Trajectory, classification: string): void {\r\n        if (!this._nameToDescribedTrajectory.has(classification)) {\r\n            this._nameToDescribedTrajectory.set(classification, new TrajectoryClass());\r\n        }\r\n\r\n        this._nameToDescribedTrajectory.get(classification)!.add(TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet));\r\n    }\r\n\r\n    /**\r\n     * Remove a known named trajectory and all Trajectories associated with it.\r\n     * @param classification name to remove\r\n     * @returns whether anything was removed\r\n     */\r\n    public deleteClassification(classification: string): boolean {\r\n        return this._nameToDescribedTrajectory.delete(classification);\r\n    }\r\n\r\n    /**\r\n     * Attempt to recognize a Trajectory from among all the classifications\r\n     * already known to the classifier.\r\n     * @param trajectory Trajectory to be recognized\r\n     * @returns classification of Trajectory if recognized, null otherwise\r\n     */\r\n    public classifyTrajectory(trajectory: Trajectory): Nullable<string> {\r\n        const descriptor = TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet);\r\n\r\n        const allowableMatches: string[] = [];\r\n        this._nameToDescribedTrajectory.forEach((trajectoryClass, classification) => {\r\n            if (trajectoryClass.getMatchCost(descriptor) < this._maximumAllowableMatchCost) {\r\n                allowableMatches.push(classification);\r\n            }\r\n        });\r\n\r\n        if (allowableMatches.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        let bestIdx = 0;\r\n        let bestMatch = this._nameToDescribedTrajectory.get(allowableMatches[bestIdx])!.getMatchMinimumDistance(descriptor);\r\n        let match: number;\r\n        for (let idx = 0; idx < allowableMatches.length; ++idx) {\r\n            match = this._nameToDescribedTrajectory.get(allowableMatches[idx])!.getMatchMinimumDistance(descriptor);\r\n            if (match < bestMatch) {\r\n                bestMatch = match;\r\n                bestIdx = idx;\r\n            }\r\n        }\r\n        return allowableMatches[bestIdx];\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}