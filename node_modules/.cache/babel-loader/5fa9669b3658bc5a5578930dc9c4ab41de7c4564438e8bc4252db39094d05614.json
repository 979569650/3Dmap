{"ast":null,"code":"import { NodeGeometryBlock } from \"../../nodeGeometryBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { GeometryInputBlock } from \"../geometryInputBlock.js\";\nimport { Matrix, Vector3 } from \"../../../../Maths/math.vector.js\";\n/**\n * Block used to get a translation matrix\n */\nexport class TranslationBlock extends NodeGeometryBlock {\n  /**\n   * Create a new TranslationBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    this.registerInput(\"translation\", NodeGeometryBlockConnectionPointTypes.Vector3, false, Vector3.Zero());\n    this.registerOutput(\"matrix\", NodeGeometryBlockConnectionPointTypes.Matrix);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"TranslationBlock\";\n  }\n  /**\n   * Gets the translation input component\n   */\n  get translation() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the matrix output component\n   */\n  get matrix() {\n    return this._outputs[0];\n  }\n  autoConfigure() {\n    if (!this.translation.isConnected) {\n      const translationInput = new GeometryInputBlock(\"Translation\");\n      translationInput.value = new Vector3(0, 0, 0);\n      translationInput.output.connectTo(this.translation);\n    }\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    this.matrix._storedFunction = state => {\n      const value = this.translation.getConnectedValue(state);\n      return Matrix.Translation(value.x, value.y, value.z);\n    };\n  }\n}\nRegisterClass(\"BABYLON.TranslationBlock\", TranslationBlock);","map":{"version":3,"names":["NodeGeometryBlock","RegisterClass","NodeGeometryBlockConnectionPointTypes","GeometryInputBlock","Matrix","Vector3","TranslationBlock","constructor","name","registerInput","Zero","registerOutput","getClassName","translation","_inputs","matrix","_outputs","autoConfigure","isConnected","translationInput","value","output","connectTo","_buildBlock","state","_storedFunction","getConnectedValue","Translation","x","y","z"],"sources":["../../../../../../../dev/core/src/Meshes/Node/Blocks/Matrices/translationBlock.ts"],"sourcesContent":["import { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport { GeometryInputBlock } from \"../geometryInputBlock\";\r\nimport { Matrix, Vector3 } from \"../../../../Maths/math.vector\";\r\n\r\n/**\r\n * Block used to get a translation matrix\r\n */\r\nexport class TranslationBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Create a new TranslationBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"translation\", NodeGeometryBlockConnectionPointTypes.Vector3, false, Vector3.Zero());\r\n        this.registerOutput(\"matrix\", NodeGeometryBlockConnectionPointTypes.Matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"TranslationBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the translation input component\r\n     */\r\n    public get translation(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix output component\r\n     */\r\n    public get matrix(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public autoConfigure() {\r\n        if (!this.translation.isConnected) {\r\n            const translationInput = new GeometryInputBlock(\"Translation\");\r\n            translationInput.value = new Vector3(0, 0, 0);\r\n            translationInput.output.connectTo(this.translation);\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        this.matrix._storedFunction = (state) => {\r\n            const value = this.translation.getConnectedValue(state) as Vector3;\r\n            return Matrix.Translation(value.x, value.y, value.z);\r\n        };\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TranslationBlock\", TranslationBlock);\r\n"],"mappings":"AAAA,SAASA,iBAAiB,QAAQ,4BAA0B;AAE5D,SAASC,aAAa,QAAQ,+BAA6B;AAC3D,SAASC,qCAAqC,QAAQ,iDAA+C;AAErG,SAASC,kBAAkB,QAAQ,0BAAwB;AAC3D,SAASC,MAAM,EAAEC,OAAO,QAAQ,kCAAgC;AAEhE;;;AAGA,OAAM,MAAOC,gBAAiB,SAAQN,iBAAiB;EACnD;;;;EAIAO,YAAmBC,IAAY;IAC3B,KAAK,CAACA,IAAI,CAAC;IAEX,IAAI,CAACC,aAAa,CAAC,aAAa,EAAEP,qCAAqC,CAACG,OAAO,EAAE,KAAK,EAAEA,OAAO,CAACK,IAAI,EAAE,CAAC;IACvG,IAAI,CAACC,cAAc,CAAC,QAAQ,EAAET,qCAAqC,CAACE,MAAM,CAAC;EAC/E;EAEA;;;;EAIOQ,YAAYA,CAAA;IACf,OAAO,kBAAkB;EAC7B;EAEA;;;EAGA,IAAWC,WAAWA,CAAA;IAClB,OAAO,IAAI,CAACC,OAAO,CAAC,CAAC,CAAC;EAC1B;EAEA;;;EAGA,IAAWC,MAAMA,CAAA;IACb,OAAO,IAAI,CAACC,QAAQ,CAAC,CAAC,CAAC;EAC3B;EAEOC,aAAaA,CAAA;IAChB,IAAI,CAAC,IAAI,CAACJ,WAAW,CAACK,WAAW,EAAE;MAC/B,MAAMC,gBAAgB,GAAG,IAAIhB,kBAAkB,CAAC,aAAa,CAAC;MAC9DgB,gBAAgB,CAACC,KAAK,GAAG,IAAIf,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MAC7Cc,gBAAgB,CAACE,MAAM,CAACC,SAAS,CAAC,IAAI,CAACT,WAAW,CAAC;;EAE3D;EAEUU,WAAWA,CAACC,KAA6B;IAC/C,KAAK,CAACD,WAAW,CAACC,KAAK,CAAC;IAExB,IAAI,CAACT,MAAM,CAACU,eAAe,GAAID,KAAK,IAAI;MACpC,MAAMJ,KAAK,GAAG,IAAI,CAACP,WAAW,CAACa,iBAAiB,CAACF,KAAK,CAAY;MAClE,OAAOpB,MAAM,CAACuB,WAAW,CAACP,KAAK,CAACQ,CAAC,EAAER,KAAK,CAACS,CAAC,EAAET,KAAK,CAACU,CAAC,CAAC;IACxD,CAAC;EACL;;AAGJ7B,aAAa,CAAC,0BAA0B,EAAEK,gBAAgB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}