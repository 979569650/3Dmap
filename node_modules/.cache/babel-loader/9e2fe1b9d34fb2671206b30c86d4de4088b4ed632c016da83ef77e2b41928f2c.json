{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3, Quaternion, Vector2, Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { SerializationHelper } from \"../Misc/decorators.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { AnimationKeyInterpolation } from \"./animationKey.js\";\nimport { AnimationRange } from \"./animationRange.js\";\nimport { Node } from \"../node.js\";\nimport { Size } from \"../Maths/math.size.js\";\nimport { WebRequest } from \"../Misc/webRequest.js\";\n\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class _IAnimationState {}\nconst evaluateAnimationState = {\n  key: 0,\n  repeatCount: 0,\n  loopMode: 2 /*Animation.ANIMATIONLOOPMODE_CONSTANT*/\n};\n/**\n * Class used to store any kind of animation\n */\nexport class Animation {\n  /**\n   * @internal Internal use\n   */\n  static _PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction) {\n    let dataType = undefined;\n    if (!isNaN(parseFloat(from)) && isFinite(from)) {\n      dataType = Animation.ANIMATIONTYPE_FLOAT;\n    } else if (from instanceof Quaternion) {\n      dataType = Animation.ANIMATIONTYPE_QUATERNION;\n    } else if (from instanceof Vector3) {\n      dataType = Animation.ANIMATIONTYPE_VECTOR3;\n    } else if (from instanceof Vector2) {\n      dataType = Animation.ANIMATIONTYPE_VECTOR2;\n    } else if (from instanceof Color3) {\n      dataType = Animation.ANIMATIONTYPE_COLOR3;\n    } else if (from instanceof Color4) {\n      dataType = Animation.ANIMATIONTYPE_COLOR4;\n    } else if (from instanceof Size) {\n      dataType = Animation.ANIMATIONTYPE_SIZE;\n    }\n    if (dataType == undefined) {\n      return null;\n    }\n    const animation = new Animation(name, targetProperty, framePerSecond, dataType, loopMode);\n    const keys = [{\n      frame: 0,\n      value: from\n    }, {\n      frame: totalFrame,\n      value: to\n    }];\n    animation.setKeys(keys);\n    if (easingFunction !== undefined) {\n      animation.setEasingFunction(easingFunction);\n    }\n    return animation;\n  }\n  /**\n   * Sets up an animation\n   * @param property The property to animate\n   * @param animationType The animation type to apply\n   * @param framePerSecond The frames per second of the animation\n   * @param easingFunction The easing function used in the animation\n   * @returns The created animation\n   */\n  static CreateAnimation(property, animationType, framePerSecond, easingFunction) {\n    const animation = new Animation(property + \"Animation\", property, framePerSecond, animationType, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    animation.setEasingFunction(easingFunction);\n    return animation;\n  }\n  /**\n   * Create and start an animation on a node\n   * @param name defines the name of the global animation that will be run on all nodes\n   * @param target defines the target where the animation will take place\n   * @param targetProperty defines property to animate\n   * @param framePerSecond defines the number of frame per second yo use\n   * @param totalFrame defines the number of frames in total\n   * @param from defines the initial value\n   * @param to defines the final value\n   * @param loopMode defines which loop mode you want to use (off by default)\n   * @param easingFunction defines the easing function to use (linear by default)\n   * @param onAnimationEnd defines the callback to call when animation end\n   * @param scene defines the hosting scene\n   * @returns the animatable created for this animation\n   */\n  static CreateAndStartAnimation(name, target, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd, scene) {\n    const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\n    if (!animation) {\n      return null;\n    }\n    if (target.getScene) {\n      scene = target.getScene();\n    }\n    if (!scene) {\n      return null;\n    }\n    return scene.beginDirectAnimation(target, [animation], 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\n  }\n  /**\n   * Create and start an animation on a node and its descendants\n   * @param name defines the name of the global animation that will be run on all nodes\n   * @param node defines the root node where the animation will take place\n   * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used\n   * @param targetProperty defines property to animate\n   * @param framePerSecond defines the number of frame per second to use\n   * @param totalFrame defines the number of frames in total\n   * @param from defines the initial value\n   * @param to defines the final value\n   * @param loopMode defines which loop mode you want to use (off by default)\n   * @param easingFunction defines the easing function to use (linear by default)\n   * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\n   * @returns the list of animatables created for all nodes\n   * @example https://www.babylonjs-playground.com/#MH0VLI\n   */\n  static CreateAndStartHierarchyAnimation(name, node, directDescendantsOnly, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {\n    const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\n    if (!animation) {\n      return null;\n    }\n    const scene = node.getScene();\n    return scene.beginDirectHierarchyAnimation(node, directDescendantsOnly, [animation], 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\n  }\n  /**\n   * Creates a new animation, merges it with the existing animations and starts it\n   * @param name Name of the animation\n   * @param node Node which contains the scene that begins the animations\n   * @param targetProperty Specifies which property to animate\n   * @param framePerSecond The frames per second of the animation\n   * @param totalFrame The total number of frames\n   * @param from The frame at the beginning of the animation\n   * @param to The frame at the end of the animation\n   * @param loopMode Specifies the loop mode of the animation\n   * @param easingFunction (Optional) The easing function of the animation, which allow custom mathematical formulas for animations\n   * @param onAnimationEnd Callback to run once the animation is complete\n   * @returns Nullable animation\n   */\n  static CreateMergeAndStartAnimation(name, node, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {\n    const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\n    if (!animation) {\n      return null;\n    }\n    node.animations.push(animation);\n    return node.getScene().beginAnimation(node, 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\n  }\n  /** @internal */\n  static MakeAnimationAdditive(sourceAnimation, referenceFrameOrOptions, range, cloneOriginal = false, clonedName) {\n    var _a, _b;\n    let options;\n    if (typeof referenceFrameOrOptions === \"object\") {\n      options = referenceFrameOrOptions;\n    } else {\n      options = {\n        referenceFrame: referenceFrameOrOptions !== null && referenceFrameOrOptions !== void 0 ? referenceFrameOrOptions : 0,\n        range: range,\n        cloneOriginalAnimation: cloneOriginal,\n        clonedAnimationName: clonedName\n      };\n    }\n    let animation = sourceAnimation;\n    if (options.cloneOriginalAnimation) {\n      animation = sourceAnimation.clone();\n      animation.name = options.clonedAnimationName || animation.name;\n    }\n    if (!animation._keys.length) {\n      return animation;\n    }\n    const referenceFrame = options.referenceFrame && options.referenceFrame >= 0 ? options.referenceFrame : 0;\n    let startIndex = 0;\n    const firstKey = animation._keys[0];\n    let endIndex = animation._keys.length - 1;\n    const lastKey = animation._keys[endIndex];\n    const valueStore = {\n      referenceValue: firstKey.value,\n      referencePosition: TmpVectors.Vector3[0],\n      referenceQuaternion: TmpVectors.Quaternion[0],\n      referenceScaling: TmpVectors.Vector3[1],\n      keyPosition: TmpVectors.Vector3[2],\n      keyQuaternion: TmpVectors.Quaternion[1],\n      keyScaling: TmpVectors.Vector3[3]\n    };\n    let from = firstKey.frame;\n    let to = lastKey.frame;\n    if (options.range) {\n      const rangeValue = animation.getRange(options.range);\n      if (rangeValue) {\n        from = rangeValue.from;\n        to = rangeValue.to;\n      }\n    } else {\n      from = (_a = options.fromFrame) !== null && _a !== void 0 ? _a : from;\n      to = (_b = options.toFrame) !== null && _b !== void 0 ? _b : to;\n    }\n    if (from !== firstKey.frame) {\n      startIndex = animation.createKeyForFrame(from);\n    }\n    if (to !== lastKey.frame) {\n      endIndex = animation.createKeyForFrame(to);\n    }\n    // There's only one key, so use it\n    if (animation._keys.length === 1) {\n      const value = animation._getKeyValue(animation._keys[0]);\n      valueStore.referenceValue = value.clone ? value.clone() : value;\n    }\n    // Reference frame is before the first frame, so just use the first frame\n    else if (referenceFrame <= firstKey.frame) {\n      const value = animation._getKeyValue(firstKey.value);\n      valueStore.referenceValue = value.clone ? value.clone() : value;\n    }\n    // Reference frame is after the last frame, so just use the last frame\n    else if (referenceFrame >= lastKey.frame) {\n      const value = animation._getKeyValue(lastKey.value);\n      valueStore.referenceValue = value.clone ? value.clone() : value;\n    }\n    // Interpolate the reference value from the animation\n    else {\n      evaluateAnimationState.key = 0;\n      const value = animation._interpolate(referenceFrame, evaluateAnimationState);\n      valueStore.referenceValue = value.clone ? value.clone() : value;\n    }\n    // Conjugate the quaternion\n    if (animation.dataType === Animation.ANIMATIONTYPE_QUATERNION) {\n      valueStore.referenceValue.normalize().conjugateInPlace();\n    }\n    // Decompose matrix and conjugate the quaternion\n    else if (animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\n      valueStore.referenceValue.decompose(valueStore.referenceScaling, valueStore.referenceQuaternion, valueStore.referencePosition);\n      valueStore.referenceQuaternion.normalize().conjugateInPlace();\n    }\n    let startFrame = Number.MAX_VALUE;\n    const clippedKeys = options.clipKeys ? [] : null;\n    // Subtract the reference value from all of the key values\n    for (let index = startIndex; index <= endIndex; index++) {\n      let key = animation._keys[index];\n      if (clippedKeys) {\n        key = {\n          frame: key.frame,\n          value: key.value.clone ? key.value.clone() : key.value,\n          inTangent: key.inTangent,\n          outTangent: key.outTangent,\n          interpolation: key.interpolation,\n          lockedTangent: key.lockedTangent\n        };\n        if (startFrame === Number.MAX_VALUE) {\n          startFrame = key.frame;\n        }\n        key.frame -= startFrame;\n        clippedKeys.push(key);\n      }\n      // If this key was duplicated to create a frame 0 key, skip it because its value has already been updated\n      if (index && animation.dataType !== Animation.ANIMATIONTYPE_FLOAT && key.value === firstKey.value) {\n        continue;\n      }\n      switch (animation.dataType) {\n        case Animation.ANIMATIONTYPE_MATRIX:\n          key.value.decompose(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition);\n          valueStore.keyPosition.subtractInPlace(valueStore.referencePosition);\n          valueStore.keyScaling.divideInPlace(valueStore.referenceScaling);\n          valueStore.referenceQuaternion.multiplyToRef(valueStore.keyQuaternion, valueStore.keyQuaternion);\n          Matrix.ComposeToRef(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition, key.value);\n          break;\n        case Animation.ANIMATIONTYPE_QUATERNION:\n          valueStore.referenceValue.multiplyToRef(key.value, key.value);\n          break;\n        case Animation.ANIMATIONTYPE_VECTOR2:\n        case Animation.ANIMATIONTYPE_VECTOR3:\n        case Animation.ANIMATIONTYPE_COLOR3:\n        case Animation.ANIMATIONTYPE_COLOR4:\n          key.value.subtractToRef(valueStore.referenceValue, key.value);\n          break;\n        case Animation.ANIMATIONTYPE_SIZE:\n          key.value.width -= valueStore.referenceValue.width;\n          key.value.height -= valueStore.referenceValue.height;\n          break;\n        default:\n          key.value -= valueStore.referenceValue;\n      }\n    }\n    if (clippedKeys) {\n      animation.setKeys(clippedKeys, true);\n    }\n    return animation;\n  }\n  /**\n   * Transition property of an host to the target Value\n   * @param property The property to transition\n   * @param targetValue The target Value of the property\n   * @param host The object where the property to animate belongs\n   * @param scene Scene used to run the animation\n   * @param frameRate Framerate (in frame/s) to use\n   * @param transition The transition type we want to use\n   * @param duration The duration of the animation, in milliseconds\n   * @param onAnimationEnd Callback trigger at the end of the animation\n   * @returns Nullable animation\n   */\n  static TransitionTo(property, targetValue, host, scene, frameRate, transition, duration, onAnimationEnd = null) {\n    if (duration <= 0) {\n      host[property] = targetValue;\n      if (onAnimationEnd) {\n        onAnimationEnd();\n      }\n      return null;\n    }\n    const endFrame = frameRate * (duration / 1000);\n    transition.setKeys([{\n      frame: 0,\n      value: host[property].clone ? host[property].clone() : host[property]\n    }, {\n      frame: endFrame,\n      value: targetValue\n    }]);\n    if (!host.animations) {\n      host.animations = [];\n    }\n    host.animations.push(transition);\n    const animation = scene.beginAnimation(host, 0, endFrame, false);\n    animation.onAnimationEnd = onAnimationEnd;\n    return animation;\n  }\n  /**\n   * Return the array of runtime animations currently using this animation\n   */\n  get runtimeAnimations() {\n    return this._runtimeAnimations;\n  }\n  /**\n   * Specifies if any of the runtime animations are currently running\n   */\n  get hasRunningRuntimeAnimations() {\n    for (const runtimeAnimation of this._runtimeAnimations) {\n      if (!runtimeAnimation.isStopped()) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Initializes the animation\n   * @param name Name of the animation\n   * @param targetProperty Property to animate\n   * @param framePerSecond The frames per second of the animation\n   * @param dataType The data type of the animation\n   * @param loopMode The loop mode of the animation\n   * @param enableBlending Specifies if blending should be enabled\n   */\n  constructor( /**Name of the animation */\n  name, /**Property to animate */\n  targetProperty, /**The frames per second of the animation */\n  framePerSecond, /**The data type of the animation */\n  dataType, /**The loop mode of the animation */\n  loopMode, /**Specifies if blending should be enabled */\n  enableBlending) {\n    this.name = name;\n    this.targetProperty = targetProperty;\n    this.framePerSecond = framePerSecond;\n    this.dataType = dataType;\n    this.loopMode = loopMode;\n    this.enableBlending = enableBlending;\n    /**\n     * Stores the easing function of the animation\n     */\n    this._easingFunction = null;\n    /**\n     * @internal Internal use only\n     */\n    this._runtimeAnimations = new Array();\n    /**\n     * The set of event that will be linked to this animation\n     */\n    this._events = new Array();\n    /**\n     * Stores the blending speed of the animation\n     */\n    this.blendingSpeed = 0.01;\n    /**\n     * Stores the animation ranges for the animation\n     */\n    this._ranges = {};\n    this.targetPropertyPath = targetProperty.split(\".\");\n    this.dataType = dataType;\n    this.loopMode = loopMode === undefined ? Animation.ANIMATIONLOOPMODE_CYCLE : loopMode;\n    this.uniqueId = Animation._UniqueIdGenerator++;\n  }\n  // Methods\n  /**\n   * Converts the animation to a string\n   * @param fullDetails support for multiple levels of logging within scene loading\n   * @returns String form of the animation\n   */\n  toString(fullDetails) {\n    let ret = \"Name: \" + this.name + \", property: \" + this.targetProperty;\n    ret += \", datatype: \" + [\"Float\", \"Vector3\", \"Quaternion\", \"Matrix\", \"Color3\", \"Vector2\"][this.dataType];\n    ret += \", nKeys: \" + (this._keys ? this._keys.length : \"none\");\n    ret += \", nRanges: \" + (this._ranges ? Object.keys(this._ranges).length : \"none\");\n    if (fullDetails) {\n      ret += \", Ranges: {\";\n      let first = true;\n      for (const name in this._ranges) {\n        if (first) {\n          ret += \", \";\n          first = false;\n        }\n        ret += name;\n      }\n      ret += \"}\";\n    }\n    return ret;\n  }\n  /**\n   * Add an event to this animation\n   * @param event Event to add\n   */\n  addEvent(event) {\n    this._events.push(event);\n    this._events.sort((a, b) => a.frame - b.frame);\n  }\n  /**\n   * Remove all events found at the given frame\n   * @param frame The frame to remove events from\n   */\n  removeEvents(frame) {\n    for (let index = 0; index < this._events.length; index++) {\n      if (this._events[index].frame === frame) {\n        this._events.splice(index, 1);\n        index--;\n      }\n    }\n  }\n  /**\n   * Retrieves all the events from the animation\n   * @returns Events from the animation\n   */\n  getEvents() {\n    return this._events;\n  }\n  /**\n   * Creates an animation range\n   * @param name Name of the animation range\n   * @param from Starting frame of the animation range\n   * @param to Ending frame of the animation\n   */\n  createRange(name, from, to) {\n    // check name not already in use; could happen for bones after serialized\n    if (!this._ranges[name]) {\n      this._ranges[name] = new AnimationRange(name, from, to);\n    }\n  }\n  /**\n   * Deletes an animation range by name\n   * @param name Name of the animation range to delete\n   * @param deleteFrames Specifies if the key frames for the range should also be deleted (true) or not (false)\n   */\n  deleteRange(name, deleteFrames = true) {\n    const range = this._ranges[name];\n    if (!range) {\n      return;\n    }\n    if (deleteFrames) {\n      const from = range.from;\n      const to = range.to;\n      // this loop MUST go high to low for multiple splices to work\n      for (let key = this._keys.length - 1; key >= 0; key--) {\n        if (this._keys[key].frame >= from && this._keys[key].frame <= to) {\n          this._keys.splice(key, 1);\n        }\n      }\n    }\n    this._ranges[name] = null; // said much faster than 'delete this._range[name]'\n  }\n  /**\n   * Gets the animation range by name, or null if not defined\n   * @param name Name of the animation range\n   * @returns Nullable animation range\n   */\n  getRange(name) {\n    return this._ranges[name];\n  }\n  /**\n   * Gets the key frames from the animation\n   * @returns The key frames of the animation\n   */\n  getKeys() {\n    return this._keys;\n  }\n  /**\n   * Gets the highest frame rate of the animation\n   * @returns Highest frame rate of the animation\n   */\n  getHighestFrame() {\n    let ret = 0;\n    for (let key = 0, nKeys = this._keys.length; key < nKeys; key++) {\n      if (ret < this._keys[key].frame) {\n        ret = this._keys[key].frame;\n      }\n    }\n    return ret;\n  }\n  /**\n   * Gets the easing function of the animation\n   * @returns Easing function of the animation\n   */\n  getEasingFunction() {\n    return this._easingFunction;\n  }\n  /**\n   * Sets the easing function of the animation\n   * @param easingFunction A custom mathematical formula for animation\n   */\n  setEasingFunction(easingFunction) {\n    this._easingFunction = easingFunction;\n  }\n  /**\n   * Interpolates a scalar linearly\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated scalar value\n   */\n  floatInterpolateFunction(startValue, endValue, gradient) {\n    return Scalar.Lerp(startValue, endValue, gradient);\n  }\n  /**\n   * Interpolates a scalar cubically\n   * @param startValue Start value of the animation curve\n   * @param outTangent End tangent of the animation\n   * @param endValue End value of the animation curve\n   * @param inTangent Start tangent of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated scalar value\n   */\n  floatInterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {\n    return Scalar.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  }\n  /**\n   * Interpolates a quaternion using a spherical linear interpolation\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated quaternion value\n   */\n  quaternionInterpolateFunction(startValue, endValue, gradient) {\n    return Quaternion.Slerp(startValue, endValue, gradient);\n  }\n  /**\n   * Interpolates a quaternion cubically\n   * @param startValue Start value of the animation curve\n   * @param outTangent End tangent of the animation curve\n   * @param endValue End value of the animation curve\n   * @param inTangent Start tangent of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated quaternion value\n   */\n  quaternionInterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {\n    return Quaternion.Hermite(startValue, outTangent, endValue, inTangent, gradient).normalize();\n  }\n  /**\n   * Interpolates a Vector3 linearly\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate (value between 0 and 1)\n   * @returns Interpolated scalar value\n   */\n  vector3InterpolateFunction(startValue, endValue, gradient) {\n    return Vector3.Lerp(startValue, endValue, gradient);\n  }\n  /**\n   * Interpolates a Vector3 cubically\n   * @param startValue Start value of the animation curve\n   * @param outTangent End tangent of the animation\n   * @param endValue End value of the animation curve\n   * @param inTangent Start tangent of the animation curve\n   * @param gradient Scalar amount to interpolate (value between 0 and 1)\n   * @returns InterpolatedVector3 value\n   */\n  vector3InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {\n    return Vector3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  }\n  /**\n   * Interpolates a Vector2 linearly\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate (value between 0 and 1)\n   * @returns Interpolated Vector2 value\n   */\n  vector2InterpolateFunction(startValue, endValue, gradient) {\n    return Vector2.Lerp(startValue, endValue, gradient);\n  }\n  /**\n   * Interpolates a Vector2 cubically\n   * @param startValue Start value of the animation curve\n   * @param outTangent End tangent of the animation\n   * @param endValue End value of the animation curve\n   * @param inTangent Start tangent of the animation curve\n   * @param gradient Scalar amount to interpolate (value between 0 and 1)\n   * @returns Interpolated Vector2 value\n   */\n  vector2InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {\n    return Vector2.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  }\n  /**\n   * Interpolates a size linearly\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated Size value\n   */\n  sizeInterpolateFunction(startValue, endValue, gradient) {\n    return Size.Lerp(startValue, endValue, gradient);\n  }\n  /**\n   * Interpolates a Color3 linearly\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated Color3 value\n   */\n  color3InterpolateFunction(startValue, endValue, gradient) {\n    return Color3.Lerp(startValue, endValue, gradient);\n  }\n  /**\n   * Interpolates a Color3 cubically\n   * @param startValue Start value of the animation curve\n   * @param outTangent End tangent of the animation\n   * @param endValue End value of the animation curve\n   * @param inTangent Start tangent of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns interpolated value\n   */\n  color3InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {\n    return Color3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  }\n  /**\n   * Interpolates a Color4 linearly\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated Color3 value\n   */\n  color4InterpolateFunction(startValue, endValue, gradient) {\n    return Color4.Lerp(startValue, endValue, gradient);\n  }\n  /**\n   * Interpolates a Color4 cubically\n   * @param startValue Start value of the animation curve\n   * @param outTangent End tangent of the animation\n   * @param endValue End value of the animation curve\n   * @param inTangent Start tangent of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns interpolated value\n   */\n  color4InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {\n    return Color4.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  }\n  /**\n   * @internal Internal use only\n   */\n  _getKeyValue(value) {\n    if (typeof value === \"function\") {\n      return value();\n    }\n    return value;\n  }\n  /**\n   * Evaluate the animation value at a given frame\n   * @param currentFrame defines the frame where we want to evaluate the animation\n   * @returns the animation value\n   */\n  evaluate(currentFrame) {\n    evaluateAnimationState.key = 0;\n    return this._interpolate(currentFrame, evaluateAnimationState);\n  }\n  /**\n   * @internal Internal use only\n   */\n  _interpolate(currentFrame, state, searchClosestKeyOnly = false) {\n    if (state.loopMode === Animation.ANIMATIONLOOPMODE_CONSTANT && state.repeatCount > 0) {\n      return state.highLimitValue.clone ? state.highLimitValue.clone() : state.highLimitValue;\n    }\n    const keys = this._keys;\n    const keysLength = keys.length;\n    let key = state.key;\n    while (key >= 0 && currentFrame < keys[key].frame) {\n      --key;\n    }\n    while (key + 1 <= keysLength - 1 && currentFrame >= keys[key + 1].frame) {\n      ++key;\n    }\n    state.key = key;\n    if (key < 0) {\n      return searchClosestKeyOnly ? undefined : this._getKeyValue(keys[0].value);\n    } else if (key + 1 > keysLength - 1) {\n      return searchClosestKeyOnly ? undefined : this._getKeyValue(keys[keysLength - 1].value);\n    }\n    const startKey = keys[key];\n    const endKey = keys[key + 1];\n    if (searchClosestKeyOnly && (currentFrame === startKey.frame || currentFrame === endKey.frame)) {\n      return undefined;\n    }\n    const startValue = this._getKeyValue(startKey.value);\n    const endValue = this._getKeyValue(endKey.value);\n    if (startKey.interpolation === AnimationKeyInterpolation.STEP) {\n      if (endKey.frame > currentFrame) {\n        return startValue;\n      } else {\n        return endValue;\n      }\n    }\n    const useTangent = startKey.outTangent !== undefined && endKey.inTangent !== undefined;\n    const frameDelta = endKey.frame - startKey.frame;\n    // gradient : percent of currentFrame between the frame inf and the frame sup\n    let gradient = (currentFrame - startKey.frame) / frameDelta;\n    // check for easingFunction and correction of gradient\n    const easingFunction = this.getEasingFunction();\n    if (easingFunction !== null) {\n      gradient = easingFunction.ease(gradient);\n    }\n    switch (this.dataType) {\n      // Float\n      case Animation.ANIMATIONTYPE_FLOAT:\n        {\n          const floatValue = useTangent ? this.floatInterpolateFunctionWithTangents(startValue, startKey.outTangent * frameDelta, endValue, endKey.inTangent * frameDelta, gradient) : this.floatInterpolateFunction(startValue, endValue, gradient);\n          switch (state.loopMode) {\n            case Animation.ANIMATIONLOOPMODE_CYCLE:\n            case Animation.ANIMATIONLOOPMODE_CONSTANT:\n            case Animation.ANIMATIONLOOPMODE_YOYO:\n              return floatValue;\n            case Animation.ANIMATIONLOOPMODE_RELATIVE:\n              return state.offsetValue * state.repeatCount + floatValue;\n          }\n          break;\n        }\n      // Quaternion\n      case Animation.ANIMATIONTYPE_QUATERNION:\n        {\n          const quatValue = useTangent ? this.quaternionInterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.quaternionInterpolateFunction(startValue, endValue, gradient);\n          switch (state.loopMode) {\n            case Animation.ANIMATIONLOOPMODE_CYCLE:\n            case Animation.ANIMATIONLOOPMODE_CONSTANT:\n            case Animation.ANIMATIONLOOPMODE_YOYO:\n              return quatValue;\n            case Animation.ANIMATIONLOOPMODE_RELATIVE:\n              return quatValue.addInPlace(state.offsetValue.scale(state.repeatCount));\n          }\n          return quatValue;\n        }\n      // Vector3\n      case Animation.ANIMATIONTYPE_VECTOR3:\n        {\n          const vec3Value = useTangent ? this.vector3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector3InterpolateFunction(startValue, endValue, gradient);\n          switch (state.loopMode) {\n            case Animation.ANIMATIONLOOPMODE_CYCLE:\n            case Animation.ANIMATIONLOOPMODE_CONSTANT:\n            case Animation.ANIMATIONLOOPMODE_YOYO:\n              return vec3Value;\n            case Animation.ANIMATIONLOOPMODE_RELATIVE:\n              return vec3Value.add(state.offsetValue.scale(state.repeatCount));\n          }\n          break;\n        }\n      // Vector2\n      case Animation.ANIMATIONTYPE_VECTOR2:\n        {\n          const vec2Value = useTangent ? this.vector2InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector2InterpolateFunction(startValue, endValue, gradient);\n          switch (state.loopMode) {\n            case Animation.ANIMATIONLOOPMODE_CYCLE:\n            case Animation.ANIMATIONLOOPMODE_CONSTANT:\n            case Animation.ANIMATIONLOOPMODE_YOYO:\n              return vec2Value;\n            case Animation.ANIMATIONLOOPMODE_RELATIVE:\n              return vec2Value.add(state.offsetValue.scale(state.repeatCount));\n          }\n          break;\n        }\n      // Size\n      case Animation.ANIMATIONTYPE_SIZE:\n        {\n          switch (state.loopMode) {\n            case Animation.ANIMATIONLOOPMODE_CYCLE:\n            case Animation.ANIMATIONLOOPMODE_CONSTANT:\n            case Animation.ANIMATIONLOOPMODE_YOYO:\n              return this.sizeInterpolateFunction(startValue, endValue, gradient);\n            case Animation.ANIMATIONLOOPMODE_RELATIVE:\n              return this.sizeInterpolateFunction(startValue, endValue, gradient).add(state.offsetValue.scale(state.repeatCount));\n          }\n          break;\n        }\n      // Color3\n      case Animation.ANIMATIONTYPE_COLOR3:\n        {\n          const color3Value = useTangent ? this.color3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.color3InterpolateFunction(startValue, endValue, gradient);\n          switch (state.loopMode) {\n            case Animation.ANIMATIONLOOPMODE_CYCLE:\n            case Animation.ANIMATIONLOOPMODE_CONSTANT:\n            case Animation.ANIMATIONLOOPMODE_YOYO:\n              return color3Value;\n            case Animation.ANIMATIONLOOPMODE_RELATIVE:\n              return color3Value.add(state.offsetValue.scale(state.repeatCount));\n          }\n          break;\n        }\n      // Color4\n      case Animation.ANIMATIONTYPE_COLOR4:\n        {\n          const color4Value = useTangent ? this.color4InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.color4InterpolateFunction(startValue, endValue, gradient);\n          switch (state.loopMode) {\n            case Animation.ANIMATIONLOOPMODE_CYCLE:\n            case Animation.ANIMATIONLOOPMODE_CONSTANT:\n            case Animation.ANIMATIONLOOPMODE_YOYO:\n              return color4Value;\n            case Animation.ANIMATIONLOOPMODE_RELATIVE:\n              return color4Value.add(state.offsetValue.scale(state.repeatCount));\n          }\n          break;\n        }\n      // Matrix\n      case Animation.ANIMATIONTYPE_MATRIX:\n        {\n          switch (state.loopMode) {\n            case Animation.ANIMATIONLOOPMODE_CYCLE:\n            case Animation.ANIMATIONLOOPMODE_CONSTANT:\n            case Animation.ANIMATIONLOOPMODE_YOYO:\n              {\n                if (Animation.AllowMatricesInterpolation) {\n                  return this.matrixInterpolateFunction(startValue, endValue, gradient, state.workValue);\n                }\n                return startValue;\n              }\n            case Animation.ANIMATIONLOOPMODE_RELATIVE:\n              {\n                return startValue;\n              }\n          }\n          break;\n        }\n    }\n    return 0;\n  }\n  /**\n   * Defines the function to use to interpolate matrices\n   * @param startValue defines the start matrix\n   * @param endValue defines the end matrix\n   * @param gradient defines the gradient between both matrices\n   * @param result defines an optional target matrix where to store the interpolation\n   * @returns the interpolated matrix\n   */\n  matrixInterpolateFunction(startValue, endValue, gradient, result) {\n    if (Animation.AllowMatrixDecomposeForInterpolation) {\n      if (result) {\n        Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);\n        return result;\n      }\n      return Matrix.DecomposeLerp(startValue, endValue, gradient);\n    }\n    if (result) {\n      Matrix.LerpToRef(startValue, endValue, gradient, result);\n      return result;\n    }\n    return Matrix.Lerp(startValue, endValue, gradient);\n  }\n  /**\n   * Makes a copy of the animation\n   * @returns Cloned animation\n   */\n  clone() {\n    const clone = new Animation(this.name, this.targetPropertyPath.join(\".\"), this.framePerSecond, this.dataType, this.loopMode);\n    clone.enableBlending = this.enableBlending;\n    clone.blendingSpeed = this.blendingSpeed;\n    if (this._keys) {\n      clone.setKeys(this._keys);\n    }\n    if (this._ranges) {\n      clone._ranges = {};\n      for (const name in this._ranges) {\n        const range = this._ranges[name];\n        if (!range) {\n          continue;\n        }\n        clone._ranges[name] = range.clone();\n      }\n    }\n    return clone;\n  }\n  /**\n   * Sets the key frames of the animation\n   * @param values The animation key frames to set\n   * @param dontClone Whether to clone the keys or not (default is false, so the array of keys is cloned)\n   */\n  setKeys(values, dontClone = false) {\n    this._keys = !dontClone ? values.slice(0) : values;\n  }\n  /**\n   * Creates a key for the frame passed as a parameter and adds it to the animation IF a key doesn't already exist for that frame\n   * @param frame Frame number\n   * @returns The key index if the key was added or the index of the pre existing key if the frame passed as parameter already has a corresponding key\n   */\n  createKeyForFrame(frame) {\n    // Find the key corresponding to frame\n    evaluateAnimationState.key = 0;\n    const value = this._interpolate(frame, evaluateAnimationState, true);\n    if (!value) {\n      // A key corresponding to this frame already exists\n      return evaluateAnimationState.key === frame ? evaluateAnimationState.key : evaluateAnimationState.key + 1;\n    }\n    // The frame is between two keys, so create a new key\n    const newKey = {\n      frame,\n      value: value.clone ? value.clone() : value\n    };\n    this._keys.splice(evaluateAnimationState.key + 1, 0, newKey);\n    return evaluateAnimationState.key + 1;\n  }\n  /**\n   * Serializes the animation to an object\n   * @returns Serialized object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.property = this.targetProperty;\n    serializationObject.framePerSecond = this.framePerSecond;\n    serializationObject.dataType = this.dataType;\n    serializationObject.loopBehavior = this.loopMode;\n    serializationObject.enableBlending = this.enableBlending;\n    serializationObject.blendingSpeed = this.blendingSpeed;\n    const dataType = this.dataType;\n    serializationObject.keys = [];\n    const keys = this.getKeys();\n    for (let index = 0; index < keys.length; index++) {\n      const animationKey = keys[index];\n      const key = {};\n      key.frame = animationKey.frame;\n      switch (dataType) {\n        case Animation.ANIMATIONTYPE_FLOAT:\n          key.values = [animationKey.value];\n          if (animationKey.inTangent !== undefined) {\n            key.values.push(animationKey.inTangent);\n          }\n          if (animationKey.outTangent !== undefined) {\n            if (animationKey.inTangent === undefined) {\n              key.values.push(undefined);\n            }\n            key.values.push(animationKey.outTangent);\n          }\n          if (animationKey.interpolation !== undefined) {\n            if (animationKey.inTangent === undefined) {\n              key.values.push(undefined);\n            }\n            if (animationKey.outTangent === undefined) {\n              key.values.push(undefined);\n            }\n            key.values.push(animationKey.interpolation);\n          }\n          break;\n        case Animation.ANIMATIONTYPE_QUATERNION:\n        case Animation.ANIMATIONTYPE_MATRIX:\n        case Animation.ANIMATIONTYPE_VECTOR3:\n        case Animation.ANIMATIONTYPE_COLOR3:\n        case Animation.ANIMATIONTYPE_COLOR4:\n          key.values = animationKey.value.asArray();\n          if (animationKey.inTangent != undefined) {\n            key.values.push(animationKey.inTangent.asArray());\n          }\n          if (animationKey.outTangent != undefined) {\n            if (animationKey.inTangent === undefined) {\n              key.values.push(undefined);\n            }\n            key.values.push(animationKey.outTangent.asArray());\n          }\n          if (animationKey.interpolation !== undefined) {\n            if (animationKey.inTangent === undefined) {\n              key.values.push(undefined);\n            }\n            if (animationKey.outTangent === undefined) {\n              key.values.push(undefined);\n            }\n            key.values.push(animationKey.interpolation);\n          }\n          break;\n      }\n      serializationObject.keys.push(key);\n    }\n    serializationObject.ranges = [];\n    for (const name in this._ranges) {\n      const source = this._ranges[name];\n      if (!source) {\n        continue;\n      }\n      const range = {};\n      range.name = name;\n      range.from = source.from;\n      range.to = source.to;\n      serializationObject.ranges.push(range);\n    }\n    return serializationObject;\n  }\n  /**\n   * @internal\n   */\n  static _UniversalLerp(left, right, amount) {\n    const constructor = left.constructor;\n    if (constructor.Lerp) {\n      // Lerp supported\n      return constructor.Lerp(left, right, amount);\n    } else if (constructor.Slerp) {\n      // Slerp supported\n      return constructor.Slerp(left, right, amount);\n    } else if (left.toFixed) {\n      // Number\n      return left * (1.0 - amount) + amount * right;\n    } else {\n      // Blending not supported\n      return right;\n    }\n  }\n  /**\n   * Parses an animation object and creates an animation\n   * @param parsedAnimation Parsed animation object\n   * @returns Animation object\n   */\n  static Parse(parsedAnimation) {\n    const animation = new Animation(parsedAnimation.name, parsedAnimation.property, parsedAnimation.framePerSecond, parsedAnimation.dataType, parsedAnimation.loopBehavior);\n    const dataType = parsedAnimation.dataType;\n    const keys = [];\n    let data;\n    let index;\n    if (parsedAnimation.enableBlending) {\n      animation.enableBlending = parsedAnimation.enableBlending;\n    }\n    if (parsedAnimation.blendingSpeed) {\n      animation.blendingSpeed = parsedAnimation.blendingSpeed;\n    }\n    for (index = 0; index < parsedAnimation.keys.length; index++) {\n      const key = parsedAnimation.keys[index];\n      let inTangent = undefined;\n      let outTangent = undefined;\n      let interpolation = undefined;\n      switch (dataType) {\n        case Animation.ANIMATIONTYPE_FLOAT:\n          data = key.values[0];\n          if (key.values.length >= 2) {\n            inTangent = key.values[1];\n          }\n          if (key.values.length >= 3) {\n            outTangent = key.values[2];\n          }\n          if (key.values.length >= 4) {\n            interpolation = key.values[3];\n          }\n          break;\n        case Animation.ANIMATIONTYPE_QUATERNION:\n          data = Quaternion.FromArray(key.values);\n          if (key.values.length >= 8) {\n            const _inTangent = Quaternion.FromArray(key.values.slice(4, 8));\n            if (!_inTangent.equals(Quaternion.Zero())) {\n              inTangent = _inTangent;\n            }\n          }\n          if (key.values.length >= 12) {\n            const _outTangent = Quaternion.FromArray(key.values.slice(8, 12));\n            if (!_outTangent.equals(Quaternion.Zero())) {\n              outTangent = _outTangent;\n            }\n          }\n          if (key.values.length >= 13) {\n            interpolation = key.values[12];\n          }\n          break;\n        case Animation.ANIMATIONTYPE_MATRIX:\n          data = Matrix.FromArray(key.values);\n          if (key.values.length >= 17) {\n            interpolation = key.values[16];\n          }\n          break;\n        case Animation.ANIMATIONTYPE_COLOR3:\n          data = Color3.FromArray(key.values);\n          if (key.values[3]) {\n            inTangent = Color3.FromArray(key.values[3]);\n          }\n          if (key.values[4]) {\n            outTangent = Color3.FromArray(key.values[4]);\n          }\n          if (key.values[5]) {\n            interpolation = key.values[5];\n          }\n          break;\n        case Animation.ANIMATIONTYPE_COLOR4:\n          data = Color4.FromArray(key.values);\n          if (key.values[4]) {\n            inTangent = Color4.FromArray(key.values[4]);\n          }\n          if (key.values[5]) {\n            outTangent = Color4.FromArray(key.values[5]);\n          }\n          if (key.values[6]) {\n            interpolation = Color4.FromArray(key.values[6]);\n          }\n          break;\n        case Animation.ANIMATIONTYPE_VECTOR3:\n        default:\n          data = Vector3.FromArray(key.values);\n          if (key.values[3]) {\n            inTangent = Vector3.FromArray(key.values[3]);\n          }\n          if (key.values[4]) {\n            outTangent = Vector3.FromArray(key.values[4]);\n          }\n          if (key.values[5]) {\n            interpolation = key.values[5];\n          }\n          break;\n      }\n      const keyData = {};\n      keyData.frame = key.frame;\n      keyData.value = data;\n      if (inTangent != undefined) {\n        keyData.inTangent = inTangent;\n      }\n      if (outTangent != undefined) {\n        keyData.outTangent = outTangent;\n      }\n      if (interpolation != undefined) {\n        keyData.interpolation = interpolation;\n      }\n      keys.push(keyData);\n    }\n    animation.setKeys(keys);\n    if (parsedAnimation.ranges) {\n      for (index = 0; index < parsedAnimation.ranges.length; index++) {\n        data = parsedAnimation.ranges[index];\n        animation.createRange(data.name, data.from, data.to);\n      }\n    }\n    return animation;\n  }\n  /**\n   * Appends the serialized animations from the source animations\n   * @param source Source containing the animations\n   * @param destination Target to store the animations\n   */\n  static AppendSerializedAnimations(source, destination) {\n    SerializationHelper.AppendSerializedAnimations(source, destination);\n  }\n  /**\n   * Creates a new animation or an array of animations from a snippet saved in a remote file\n   * @param name defines the name of the animation to create (can be null or empty to use the one from the json data)\n   * @param url defines the url to load from\n   * @returns a promise that will resolve to the new animation or an array of animations\n   */\n  static ParseFromFileAsync(name, url) {\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            let serializationObject = JSON.parse(request.responseText);\n            if (serializationObject.animations) {\n              serializationObject = serializationObject.animations;\n            }\n            if (serializationObject.length) {\n              const output = new Array();\n              for (const serializedAnimation of serializationObject) {\n                output.push(this.Parse(serializedAnimation));\n              }\n              resolve(output);\n            } else {\n              const output = this.Parse(serializationObject);\n              if (name) {\n                output.name = name;\n              }\n              resolve(output);\n            }\n          } else {\n            reject(\"Unable to load the animation\");\n          }\n        }\n      });\n      request.open(\"GET\", url);\n      request.send();\n    });\n  }\n  /**\n   * Creates an animation or an array of animations from a snippet saved by the Inspector\n   * @param snippetId defines the snippet to load\n   * @returns a promise that will resolve to the new animation or a new array of animations\n   */\n  static ParseFromSnippetAsync(snippetId) {\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n            if (snippet.animations) {\n              const serializationObject = JSON.parse(snippet.animations);\n              const outputs = new Array();\n              for (const serializedAnimation of serializationObject.animations) {\n                const output = this.Parse(serializedAnimation);\n                output.snippetId = snippetId;\n                outputs.push(output);\n              }\n              resolve(outputs);\n            } else {\n              const serializationObject = JSON.parse(snippet.animation);\n              const output = this.Parse(serializationObject);\n              output.snippetId = snippetId;\n              resolve(output);\n            }\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  }\n}\nAnimation._UniqueIdGenerator = 0;\n/**\n * Use matrix interpolation instead of using direct key value when animating matrices\n */\nAnimation.AllowMatricesInterpolation = false;\n/**\n * When matrix interpolation is enabled, this boolean forces the system to use Matrix.DecomposeLerp instead of Matrix.Lerp. Interpolation is more precise but slower\n */\nAnimation.AllowMatrixDecomposeForInterpolation = true;\n/** Define the Url to load snippets */\nAnimation.SnippetUrl = `https://snippet.babylonjs.com`;\n// Statics\n/**\n * Float animation type\n */\nAnimation.ANIMATIONTYPE_FLOAT = 0;\n/**\n * Vector3 animation type\n */\nAnimation.ANIMATIONTYPE_VECTOR3 = 1;\n/**\n * Quaternion animation type\n */\nAnimation.ANIMATIONTYPE_QUATERNION = 2;\n/**\n * Matrix animation type\n */\nAnimation.ANIMATIONTYPE_MATRIX = 3;\n/**\n * Color3 animation type\n */\nAnimation.ANIMATIONTYPE_COLOR3 = 4;\n/**\n * Color3 animation type\n */\nAnimation.ANIMATIONTYPE_COLOR4 = 7;\n/**\n * Vector2 animation type\n */\nAnimation.ANIMATIONTYPE_VECTOR2 = 5;\n/**\n * Size animation type\n */\nAnimation.ANIMATIONTYPE_SIZE = 6;\n/**\n * Relative Loop Mode\n */\nAnimation.ANIMATIONLOOPMODE_RELATIVE = 0;\n/**\n * Cycle Loop Mode\n */\nAnimation.ANIMATIONLOOPMODE_CYCLE = 1;\n/**\n * Constant Loop Mode\n */\nAnimation.ANIMATIONLOOPMODE_CONSTANT = 2;\n/**\n * Yoyo Loop Mode\n */\nAnimation.ANIMATIONLOOPMODE_YOYO = 4;\n/**\n * Creates an animation or an array of animations from a snippet saved by the Inspector\n * @deprecated Please use ParseFromSnippetAsync instead\n * @param snippetId defines the snippet to load\n * @returns a promise that will resolve to the new animation or a new array of animations\n */\nAnimation.CreateFromSnippetAsync = Animation.ParseFromSnippetAsync;\nRegisterClass(\"BABYLON.Animation\", Animation);\nNode._AnimationRangeFactory = (name, from, to) => new AnimationRange(name, from, to);","map":{"version":3,"names":["Vector3","Quaternion","Vector2","Matrix","TmpVectors","Color3","Color4","Scalar","SerializationHelper","RegisterClass","AnimationKeyInterpolation","AnimationRange","Node","Size","WebRequest","_IAnimationState","evaluateAnimationState","key","repeatCount","loopMode","Animation","_PrepareAnimation","name","targetProperty","framePerSecond","totalFrame","from","to","easingFunction","dataType","undefined","isNaN","parseFloat","isFinite","ANIMATIONTYPE_FLOAT","ANIMATIONTYPE_QUATERNION","ANIMATIONTYPE_VECTOR3","ANIMATIONTYPE_VECTOR2","ANIMATIONTYPE_COLOR3","ANIMATIONTYPE_COLOR4","ANIMATIONTYPE_SIZE","animation","keys","frame","value","setKeys","setEasingFunction","CreateAnimation","property","animationType","ANIMATIONLOOPMODE_CONSTANT","CreateAndStartAnimation","target","onAnimationEnd","scene","getScene","beginDirectAnimation","CreateAndStartHierarchyAnimation","node","directDescendantsOnly","beginDirectHierarchyAnimation","CreateMergeAndStartAnimation","animations","push","beginAnimation","MakeAnimationAdditive","sourceAnimation","referenceFrameOrOptions","range","cloneOriginal","clonedName","options","referenceFrame","cloneOriginalAnimation","clonedAnimationName","clone","_keys","length","startIndex","firstKey","endIndex","lastKey","valueStore","referenceValue","referencePosition","referenceQuaternion","referenceScaling","keyPosition","keyQuaternion","keyScaling","rangeValue","getRange","_a","fromFrame","_b","toFrame","createKeyForFrame","_getKeyValue","_interpolate","normalize","conjugateInPlace","ANIMATIONTYPE_MATRIX","decompose","startFrame","Number","MAX_VALUE","clippedKeys","clipKeys","index","inTangent","outTangent","interpolation","lockedTangent","subtractInPlace","divideInPlace","multiplyToRef","ComposeToRef","subtractToRef","width","height","TransitionTo","targetValue","host","frameRate","transition","duration","endFrame","runtimeAnimations","_runtimeAnimations","hasRunningRuntimeAnimations","runtimeAnimation","isStopped","constructor","enableBlending","_easingFunction","Array","_events","blendingSpeed","_ranges","targetPropertyPath","split","ANIMATIONLOOPMODE_CYCLE","uniqueId","_UniqueIdGenerator","toString","fullDetails","ret","Object","first","addEvent","event","sort","a","b","removeEvents","splice","getEvents","createRange","deleteRange","deleteFrames","getKeys","getHighestFrame","nKeys","getEasingFunction","floatInterpolateFunction","startValue","endValue","gradient","Lerp","floatInterpolateFunctionWithTangents","Hermite","quaternionInterpolateFunction","Slerp","quaternionInterpolateFunctionWithTangents","vector3InterpolateFunction","vector3InterpolateFunctionWithTangents","vector2InterpolateFunction","vector2InterpolateFunctionWithTangents","sizeInterpolateFunction","color3InterpolateFunction","color3InterpolateFunctionWithTangents","color4InterpolateFunction","color4InterpolateFunctionWithTangents","evaluate","currentFrame","state","searchClosestKeyOnly","highLimitValue","keysLength","startKey","endKey","STEP","useTangent","frameDelta","ease","floatValue","ANIMATIONLOOPMODE_YOYO","ANIMATIONLOOPMODE_RELATIVE","offsetValue","quatValue","scale","addInPlace","vec3Value","add","vec2Value","color3Value","color4Value","AllowMatricesInterpolation","matrixInterpolateFunction","workValue","result","AllowMatrixDecomposeForInterpolation","DecomposeLerpToRef","DecomposeLerp","LerpToRef","join","values","dontClone","slice","newKey","serialize","serializationObject","loopBehavior","animationKey","asArray","ranges","source","_UniversalLerp","left","right","amount","toFixed","Parse","parsedAnimation","data","FromArray","_inTangent","equals","Zero","_outTangent","keyData","AppendSerializedAnimations","destination","ParseFromFileAsync","url","Promise","resolve","reject","request","addEventListener","readyState","status","JSON","parse","responseText","output","serializedAnimation","open","send","ParseFromSnippetAsync","snippetId","snippet","jsonPayload","outputs","SnippetUrl","replace","CreateFromSnippetAsync","_AnimationRangeFactory"],"sources":["../../../../dev/core/src/Animations/animation.ts"],"sourcesContent":["import type { IEasingFunction, EasingFunction } from \"./easing\";\r\nimport { Vector3, Quaternion, Vector2, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\n\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { SerializationHelper } from \"../Misc/decorators\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { IAnimationKey } from \"./animationKey\";\r\nimport { AnimationKeyInterpolation } from \"./animationKey\";\r\nimport { AnimationRange } from \"./animationRange\";\r\nimport type { AnimationEvent } from \"./animationEvent\";\r\nimport { Node } from \"../node\";\r\nimport type { IAnimatable } from \"./animatable.interface\";\r\nimport { Size } from \"../Maths/math.size\";\r\nimport { WebRequest } from \"../Misc/webRequest\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport type { Animatable } from \"./animatable\";\r\nimport type { RuntimeAnimation } from \"./runtimeAnimation\";\r\n\r\n/**\r\n * Options to be used when creating an additive animation\r\n */\r\nexport interface IMakeAnimationAdditiveOptions {\r\n    /**\r\n     * The frame that the animation should be relative to (if not provided, 0 will be used)\r\n     */\r\n    referenceFrame?: number;\r\n    /**\r\n     * The name of the animation range to convert to additive. If not provided, fromFrame / toFrame will be used\r\n     * If fromFrame / toFrame are not provided either, the whole animation will be converted to additive\r\n     */\r\n    range?: string;\r\n    /**\r\n     * If true, the original animation will be cloned and converted to additive. If false, the original animation will be converted to additive (default is false)\r\n     */\r\n    cloneOriginalAnimation?: boolean;\r\n    /**\r\n     * The name of the cloned animation if cloneOriginalAnimation is true. If not provided, use the original animation name\r\n     */\r\n    clonedAnimationName?: string;\r\n    /**\r\n     * Together with toFrame, defines the range of the animation to convert to additive. Will only be used if range is not provided\r\n     * If range and fromFrame / toFrame are not provided, the whole animation will be converted to additive\r\n     */\r\n    fromFrame?: number;\r\n    /**\r\n     * Together with fromFrame, defines the range of the animation to convert to additive.\r\n     */\r\n    toFrame?: number;\r\n    /**\r\n     * If true, the key frames will be clipped to the range specified by range or fromFrame / toFrame (default is false)\r\n     */\r\n    clipKeys?: boolean;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _IAnimationState {\r\n    key: number;\r\n    repeatCount: number;\r\n    workValue?: any;\r\n    loopMode?: number;\r\n    offsetValue?: any;\r\n    highLimitValue?: any;\r\n}\r\n\r\nconst evaluateAnimationState: _IAnimationState = {\r\n    key: 0,\r\n    repeatCount: 0,\r\n    loopMode: 2 /*Animation.ANIMATIONLOOPMODE_CONSTANT*/,\r\n};\r\n\r\n/**\r\n * Class used to store any kind of animation\r\n */\r\nexport class Animation {\r\n    private static _UniqueIdGenerator = 0;\r\n\r\n    /**\r\n     * Use matrix interpolation instead of using direct key value when animating matrices\r\n     */\r\n    public static AllowMatricesInterpolation = false;\r\n\r\n    /**\r\n     * When matrix interpolation is enabled, this boolean forces the system to use Matrix.DecomposeLerp instead of Matrix.Lerp. Interpolation is more precise but slower\r\n     */\r\n    public static AllowMatrixDecomposeForInterpolation = true;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the animation (the uniqueness is solely among other animations)\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Snippet ID if the animation was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Stores the key frames of the animation\r\n     */\r\n    private _keys: Array<IAnimationKey>;\r\n\r\n    /**\r\n     * Stores the easing function of the animation\r\n     */\r\n    private _easingFunction: Nullable<IEasingFunction> = null;\r\n\r\n    /**\r\n     * @internal Internal use only\r\n     */\r\n    public _runtimeAnimations = new Array<RuntimeAnimation>();\r\n\r\n    /**\r\n     * The set of event that will be linked to this animation\r\n     */\r\n    private _events = new Array<AnimationEvent>();\r\n\r\n    /**\r\n     * Stores an array of target property paths\r\n     */\r\n    public targetPropertyPath: string[];\r\n\r\n    /**\r\n     * Stores the blending speed of the animation\r\n     */\r\n    public blendingSpeed = 0.01;\r\n\r\n    /**\r\n     * Stores the animation ranges for the animation\r\n     */\r\n    private _ranges: { [name: string]: Nullable<AnimationRange> } = {};\r\n\r\n    /**\r\n     * @internal Internal use\r\n     */\r\n    public static _PrepareAnimation(\r\n        name: string,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction\r\n    ): Nullable<Animation> {\r\n        let dataType = undefined;\r\n\r\n        if (!isNaN(parseFloat(from)) && isFinite(from)) {\r\n            dataType = Animation.ANIMATIONTYPE_FLOAT;\r\n        } else if (from instanceof Quaternion) {\r\n            dataType = Animation.ANIMATIONTYPE_QUATERNION;\r\n        } else if (from instanceof Vector3) {\r\n            dataType = Animation.ANIMATIONTYPE_VECTOR3;\r\n        } else if (from instanceof Vector2) {\r\n            dataType = Animation.ANIMATIONTYPE_VECTOR2;\r\n        } else if (from instanceof Color3) {\r\n            dataType = Animation.ANIMATIONTYPE_COLOR3;\r\n        } else if (from instanceof Color4) {\r\n            dataType = Animation.ANIMATIONTYPE_COLOR4;\r\n        } else if (from instanceof Size) {\r\n            dataType = Animation.ANIMATIONTYPE_SIZE;\r\n        }\r\n\r\n        if (dataType == undefined) {\r\n            return null;\r\n        }\r\n\r\n        const animation = new Animation(name, targetProperty, framePerSecond, dataType, loopMode);\r\n\r\n        const keys: Array<IAnimationKey> = [\r\n            { frame: 0, value: from },\r\n            { frame: totalFrame, value: to },\r\n        ];\r\n        animation.setKeys(keys);\r\n\r\n        if (easingFunction !== undefined) {\r\n            animation.setEasingFunction(easingFunction);\r\n        }\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Sets up an animation\r\n     * @param property The property to animate\r\n     * @param animationType The animation type to apply\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param easingFunction The easing function used in the animation\r\n     * @returns The created animation\r\n     */\r\n    public static CreateAnimation(property: string, animationType: number, framePerSecond: number, easingFunction: EasingFunction): Animation {\r\n        const animation: Animation = new Animation(property + \"Animation\", property, framePerSecond, animationType, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n        animation.setEasingFunction(easingFunction);\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Create and start an animation on a node\r\n     * @param name defines the name of the global animation that will be run on all nodes\r\n     * @param target defines the target where the animation will take place\r\n     * @param targetProperty defines property to animate\r\n     * @param framePerSecond defines the number of frame per second yo use\r\n     * @param totalFrame defines the number of frames in total\r\n     * @param from defines the initial value\r\n     * @param to defines the final value\r\n     * @param loopMode defines which loop mode you want to use (off by default)\r\n     * @param easingFunction defines the easing function to use (linear by default)\r\n     * @param onAnimationEnd defines the callback to call when animation end\r\n     * @param scene defines the hosting scene\r\n     * @returns the animatable created for this animation\r\n     */\r\n    public static CreateAndStartAnimation(\r\n        name: string,\r\n        target: any,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction,\r\n        onAnimationEnd?: () => void,\r\n        scene?: Scene\r\n    ): Nullable<Animatable> {\r\n        const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n\r\n        if (target.getScene) {\r\n            scene = target.getScene();\r\n        }\r\n\r\n        if (!scene) {\r\n            return null;\r\n        }\r\n\r\n        return scene.beginDirectAnimation(target, [animation], 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Create and start an animation on a node and its descendants\r\n     * @param name defines the name of the global animation that will be run on all nodes\r\n     * @param node defines the root node where the animation will take place\r\n     * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used\r\n     * @param targetProperty defines property to animate\r\n     * @param framePerSecond defines the number of frame per second to use\r\n     * @param totalFrame defines the number of frames in total\r\n     * @param from defines the initial value\r\n     * @param to defines the final value\r\n     * @param loopMode defines which loop mode you want to use (off by default)\r\n     * @param easingFunction defines the easing function to use (linear by default)\r\n     * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n     * @returns the list of animatables created for all nodes\r\n     * @example https://www.babylonjs-playground.com/#MH0VLI\r\n     */\r\n    public static CreateAndStartHierarchyAnimation(\r\n        name: string,\r\n        node: Node,\r\n        directDescendantsOnly: boolean,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction,\r\n        onAnimationEnd?: () => void\r\n    ): Nullable<Animatable[]> {\r\n        const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n\r\n        const scene = node.getScene();\r\n        return scene.beginDirectHierarchyAnimation(node, directDescendantsOnly, [animation], 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Creates a new animation, merges it with the existing animations and starts it\r\n     * @param name Name of the animation\r\n     * @param node Node which contains the scene that begins the animations\r\n     * @param targetProperty Specifies which property to animate\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param totalFrame The total number of frames\r\n     * @param from The frame at the beginning of the animation\r\n     * @param to The frame at the end of the animation\r\n     * @param loopMode Specifies the loop mode of the animation\r\n     * @param easingFunction (Optional) The easing function of the animation, which allow custom mathematical formulas for animations\r\n     * @param onAnimationEnd Callback to run once the animation is complete\r\n     * @returns Nullable animation\r\n     */\r\n    public static CreateMergeAndStartAnimation(\r\n        name: string,\r\n        node: Node,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction,\r\n        onAnimationEnd?: () => void\r\n    ): Nullable<Animatable> {\r\n        const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n\r\n        node.animations.push(animation);\r\n\r\n        return node.getScene().beginAnimation(node, 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Convert the keyframes of an animation to be relative to a given reference frame.\r\n     * @param sourceAnimation defines the Animation containing keyframes to convert\r\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to (default: 0)\r\n     * @param range defines the name of the AnimationRange belonging to the Animation to convert\r\n     * @param cloneOriginal defines whether or not to clone the animation and convert the clone or convert the original animation (default is false)\r\n     * @param clonedName defines the name of the resulting cloned Animation if cloneOriginal is true\r\n     * @returns a new Animation if cloneOriginal is true or the original Animation if cloneOriginal is false\r\n     */\r\n    public static MakeAnimationAdditive(sourceAnimation: Animation, referenceFrame?: number, range?: string, cloneOriginal?: boolean, clonedName?: string): Animation;\r\n\r\n    /**\r\n     * Convert the keyframes of an animation to be relative to a given reference frame.\r\n     * @param sourceAnimation defines the Animation containing keyframes to convert\r\n     * @param options defines the options to use when converting ey keyframes\r\n     * @returns a new Animation if options.cloneOriginalAnimation is true or the original Animation if options.cloneOriginalAnimation is false\r\n     */\r\n    public static MakeAnimationAdditive(sourceAnimation: Animation, options?: IMakeAnimationAdditiveOptions): Animation;\r\n\r\n    /** @internal */\r\n    public static MakeAnimationAdditive(\r\n        sourceAnimation: Animation,\r\n        referenceFrameOrOptions?: number | IMakeAnimationAdditiveOptions,\r\n        range?: string,\r\n        cloneOriginal = false,\r\n        clonedName?: string\r\n    ): Animation {\r\n        let options: IMakeAnimationAdditiveOptions;\r\n\r\n        if (typeof referenceFrameOrOptions === \"object\") {\r\n            options = referenceFrameOrOptions;\r\n        } else {\r\n            options = {\r\n                referenceFrame: referenceFrameOrOptions ?? 0,\r\n                range: range,\r\n                cloneOriginalAnimation: cloneOriginal,\r\n                clonedAnimationName: clonedName,\r\n            };\r\n        }\r\n\r\n        let animation = sourceAnimation;\r\n\r\n        if (options.cloneOriginalAnimation) {\r\n            animation = sourceAnimation.clone();\r\n            animation.name = options.clonedAnimationName || animation.name;\r\n        }\r\n\r\n        if (!animation._keys.length) {\r\n            return animation;\r\n        }\r\n\r\n        const referenceFrame = options.referenceFrame && options.referenceFrame >= 0 ? options.referenceFrame : 0;\r\n        let startIndex = 0;\r\n        const firstKey = animation._keys[0];\r\n        let endIndex = animation._keys.length - 1;\r\n        const lastKey = animation._keys[endIndex];\r\n        const valueStore = {\r\n            referenceValue: firstKey.value,\r\n            referencePosition: TmpVectors.Vector3[0],\r\n            referenceQuaternion: TmpVectors.Quaternion[0],\r\n            referenceScaling: TmpVectors.Vector3[1],\r\n            keyPosition: TmpVectors.Vector3[2],\r\n            keyQuaternion: TmpVectors.Quaternion[1],\r\n            keyScaling: TmpVectors.Vector3[3],\r\n        };\r\n        let from = firstKey.frame;\r\n        let to = lastKey.frame;\r\n        if (options.range) {\r\n            const rangeValue = animation.getRange(options.range);\r\n\r\n            if (rangeValue) {\r\n                from = rangeValue.from;\r\n                to = rangeValue.to;\r\n            }\r\n        } else {\r\n            from = options.fromFrame ?? from;\r\n            to = options.toFrame ?? to;\r\n        }\r\n\r\n        if (from !== firstKey.frame) {\r\n            startIndex = animation.createKeyForFrame(from);\r\n        }\r\n\r\n        if (to !== lastKey.frame) {\r\n            endIndex = animation.createKeyForFrame(to);\r\n        }\r\n\r\n        // There's only one key, so use it\r\n        if (animation._keys.length === 1) {\r\n            const value = animation._getKeyValue(animation._keys[0]);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n        }\r\n\r\n        // Reference frame is before the first frame, so just use the first frame\r\n        else if (referenceFrame <= firstKey.frame) {\r\n            const value = animation._getKeyValue(firstKey.value);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n        }\r\n\r\n        // Reference frame is after the last frame, so just use the last frame\r\n        else if (referenceFrame >= lastKey.frame) {\r\n            const value = animation._getKeyValue(lastKey.value);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n        }\r\n\r\n        // Interpolate the reference value from the animation\r\n        else {\r\n            evaluateAnimationState.key = 0;\r\n            const value = animation._interpolate(referenceFrame, evaluateAnimationState);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n        }\r\n\r\n        // Conjugate the quaternion\r\n        if (animation.dataType === Animation.ANIMATIONTYPE_QUATERNION) {\r\n            valueStore.referenceValue.normalize().conjugateInPlace();\r\n        }\r\n\r\n        // Decompose matrix and conjugate the quaternion\r\n        else if (animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\r\n            valueStore.referenceValue.decompose(valueStore.referenceScaling, valueStore.referenceQuaternion, valueStore.referencePosition);\r\n            valueStore.referenceQuaternion.normalize().conjugateInPlace();\r\n        }\r\n\r\n        let startFrame = Number.MAX_VALUE;\r\n        const clippedKeys: Nullable<IAnimationKey[]> = options.clipKeys ? [] : null;\r\n\r\n        // Subtract the reference value from all of the key values\r\n        for (let index = startIndex; index <= endIndex; index++) {\r\n            let key = animation._keys[index];\r\n\r\n            if (clippedKeys) {\r\n                key = {\r\n                    frame: key.frame,\r\n                    value: key.value.clone ? key.value.clone() : key.value,\r\n                    inTangent: key.inTangent,\r\n                    outTangent: key.outTangent,\r\n                    interpolation: key.interpolation,\r\n                    lockedTangent: key.lockedTangent,\r\n                };\r\n                if (startFrame === Number.MAX_VALUE) {\r\n                    startFrame = key.frame;\r\n                }\r\n                key.frame -= startFrame;\r\n                clippedKeys.push(key);\r\n            }\r\n\r\n            // If this key was duplicated to create a frame 0 key, skip it because its value has already been updated\r\n            if (index && animation.dataType !== Animation.ANIMATIONTYPE_FLOAT && key.value === firstKey.value) {\r\n                continue;\r\n            }\r\n\r\n            switch (animation.dataType) {\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                    key.value.decompose(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition);\r\n                    valueStore.keyPosition.subtractInPlace(valueStore.referencePosition);\r\n                    valueStore.keyScaling.divideInPlace(valueStore.referenceScaling);\r\n                    valueStore.referenceQuaternion.multiplyToRef(valueStore.keyQuaternion, valueStore.keyQuaternion);\r\n                    Matrix.ComposeToRef(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition, key.value);\r\n                    break;\r\n\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    valueStore.referenceValue.multiplyToRef(key.value, key.value);\r\n                    break;\r\n\r\n                case Animation.ANIMATIONTYPE_VECTOR2:\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    key.value.subtractToRef(valueStore.referenceValue, key.value);\r\n                    break;\r\n\r\n                case Animation.ANIMATIONTYPE_SIZE:\r\n                    key.value.width -= valueStore.referenceValue.width;\r\n                    key.value.height -= valueStore.referenceValue.height;\r\n                    break;\r\n\r\n                default:\r\n                    key.value -= valueStore.referenceValue;\r\n            }\r\n        }\r\n\r\n        if (clippedKeys) {\r\n            animation.setKeys(clippedKeys, true);\r\n        }\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Transition property of an host to the target Value\r\n     * @param property The property to transition\r\n     * @param targetValue The target Value of the property\r\n     * @param host The object where the property to animate belongs\r\n     * @param scene Scene used to run the animation\r\n     * @param frameRate Framerate (in frame/s) to use\r\n     * @param transition The transition type we want to use\r\n     * @param duration The duration of the animation, in milliseconds\r\n     * @param onAnimationEnd Callback trigger at the end of the animation\r\n     * @returns Nullable animation\r\n     */\r\n    public static TransitionTo(\r\n        property: string,\r\n        targetValue: any,\r\n        host: any,\r\n        scene: Scene,\r\n        frameRate: number,\r\n        transition: Animation,\r\n        duration: number,\r\n        onAnimationEnd: Nullable<() => void> = null\r\n    ): Nullable<Animatable> {\r\n        if (duration <= 0) {\r\n            host[property] = targetValue;\r\n            if (onAnimationEnd) {\r\n                onAnimationEnd();\r\n            }\r\n            return null;\r\n        }\r\n\r\n        const endFrame: number = frameRate * (duration / 1000);\r\n\r\n        transition.setKeys([\r\n            {\r\n                frame: 0,\r\n                value: host[property].clone ? host[property].clone() : host[property],\r\n            },\r\n            {\r\n                frame: endFrame,\r\n                value: targetValue,\r\n            },\r\n        ]);\r\n\r\n        if (!host.animations) {\r\n            host.animations = [];\r\n        }\r\n\r\n        host.animations.push(transition);\r\n\r\n        const animation: Animatable = scene.beginAnimation(host, 0, endFrame, false);\r\n        animation.onAnimationEnd = onAnimationEnd;\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Return the array of runtime animations currently using this animation\r\n     */\r\n    public get runtimeAnimations(): RuntimeAnimation[] {\r\n        return this._runtimeAnimations;\r\n    }\r\n\r\n    /**\r\n     * Specifies if any of the runtime animations are currently running\r\n     */\r\n    public get hasRunningRuntimeAnimations(): boolean {\r\n        for (const runtimeAnimation of this._runtimeAnimations) {\r\n            if (!runtimeAnimation.isStopped()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Initializes the animation\r\n     * @param name Name of the animation\r\n     * @param targetProperty Property to animate\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param dataType The data type of the animation\r\n     * @param loopMode The loop mode of the animation\r\n     * @param enableBlending Specifies if blending should be enabled\r\n     */\r\n    constructor(\r\n        /**Name of the animation */\r\n        public name: string,\r\n        /**Property to animate */\r\n        public targetProperty: string,\r\n        /**The frames per second of the animation */\r\n        public framePerSecond: number,\r\n        /**The data type of the animation */\r\n        public dataType: number,\r\n        /**The loop mode of the animation */\r\n        public loopMode?: number,\r\n        /**Specifies if blending should be enabled */\r\n        public enableBlending?: boolean\r\n    ) {\r\n        this.targetPropertyPath = targetProperty.split(\".\");\r\n        this.dataType = dataType;\r\n        this.loopMode = loopMode === undefined ? Animation.ANIMATIONLOOPMODE_CYCLE : loopMode;\r\n        this.uniqueId = Animation._UniqueIdGenerator++;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Converts the animation to a string\r\n     * @param fullDetails support for multiple levels of logging within scene loading\r\n     * @returns String form of the animation\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name + \", property: \" + this.targetProperty;\r\n        ret += \", datatype: \" + [\"Float\", \"Vector3\", \"Quaternion\", \"Matrix\", \"Color3\", \"Vector2\"][this.dataType];\r\n        ret += \", nKeys: \" + (this._keys ? this._keys.length : \"none\");\r\n        ret += \", nRanges: \" + (this._ranges ? Object.keys(this._ranges).length : \"none\");\r\n        if (fullDetails) {\r\n            ret += \", Ranges: {\";\r\n            let first = true;\r\n            for (const name in this._ranges) {\r\n                if (first) {\r\n                    ret += \", \";\r\n                    first = false;\r\n                }\r\n                ret += name;\r\n            }\r\n            ret += \"}\";\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Add an event to this animation\r\n     * @param event Event to add\r\n     */\r\n    public addEvent(event: AnimationEvent): void {\r\n        this._events.push(event);\r\n        this._events.sort((a, b) => a.frame - b.frame);\r\n    }\r\n\r\n    /**\r\n     * Remove all events found at the given frame\r\n     * @param frame The frame to remove events from\r\n     */\r\n    public removeEvents(frame: number): void {\r\n        for (let index = 0; index < this._events.length; index++) {\r\n            if (this._events[index].frame === frame) {\r\n                this._events.splice(index, 1);\r\n                index--;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieves all the events from the animation\r\n     * @returns Events from the animation\r\n     */\r\n    public getEvents(): AnimationEvent[] {\r\n        return this._events;\r\n    }\r\n\r\n    /**\r\n     * Creates an animation range\r\n     * @param name Name of the animation range\r\n     * @param from Starting frame of the animation range\r\n     * @param to Ending frame of the animation\r\n     */\r\n    public createRange(name: string, from: number, to: number): void {\r\n        // check name not already in use; could happen for bones after serialized\r\n        if (!this._ranges[name]) {\r\n            this._ranges[name] = new AnimationRange(name, from, to);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes an animation range by name\r\n     * @param name Name of the animation range to delete\r\n     * @param deleteFrames Specifies if the key frames for the range should also be deleted (true) or not (false)\r\n     */\r\n    public deleteRange(name: string, deleteFrames = true): void {\r\n        const range = this._ranges[name];\r\n        if (!range) {\r\n            return;\r\n        }\r\n        if (deleteFrames) {\r\n            const from = range.from;\r\n            const to = range.to;\r\n\r\n            // this loop MUST go high to low for multiple splices to work\r\n            for (let key = this._keys.length - 1; key >= 0; key--) {\r\n                if (this._keys[key].frame >= from && this._keys[key].frame <= to) {\r\n                    this._keys.splice(key, 1);\r\n                }\r\n            }\r\n        }\r\n        this._ranges[name] = null; // said much faster than 'delete this._range[name]'\r\n    }\r\n\r\n    /**\r\n     * Gets the animation range by name, or null if not defined\r\n     * @param name Name of the animation range\r\n     * @returns Nullable animation range\r\n     */\r\n    public getRange(name: string): Nullable<AnimationRange> {\r\n        return this._ranges[name];\r\n    }\r\n\r\n    /**\r\n     * Gets the key frames from the animation\r\n     * @returns The key frames of the animation\r\n     */\r\n    public getKeys(): Array<IAnimationKey> {\r\n        return this._keys;\r\n    }\r\n\r\n    /**\r\n     * Gets the highest frame rate of the animation\r\n     * @returns Highest frame rate of the animation\r\n     */\r\n    public getHighestFrame(): number {\r\n        let ret = 0;\r\n\r\n        for (let key = 0, nKeys = this._keys.length; key < nKeys; key++) {\r\n            if (ret < this._keys[key].frame) {\r\n                ret = this._keys[key].frame;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Gets the easing function of the animation\r\n     * @returns Easing function of the animation\r\n     */\r\n    public getEasingFunction(): Nullable<IEasingFunction> {\r\n        return this._easingFunction;\r\n    }\r\n\r\n    /**\r\n     * Sets the easing function of the animation\r\n     * @param easingFunction A custom mathematical formula for animation\r\n     */\r\n    public setEasingFunction(easingFunction: Nullable<IEasingFunction>): void {\r\n        this._easingFunction = easingFunction;\r\n    }\r\n\r\n    /**\r\n     * Interpolates a scalar linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated scalar value\r\n     */\r\n    public floatInterpolateFunction(startValue: number, endValue: number, gradient: number): number {\r\n        return Scalar.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a scalar cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated scalar value\r\n     */\r\n    public floatInterpolateFunctionWithTangents(startValue: number, outTangent: number, endValue: number, inTangent: number, gradient: number): number {\r\n        return Scalar.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a quaternion using a spherical linear interpolation\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated quaternion value\r\n     */\r\n    public quaternionInterpolateFunction(startValue: Quaternion, endValue: Quaternion, gradient: number): Quaternion {\r\n        return Quaternion.Slerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a quaternion cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated quaternion value\r\n     */\r\n    public quaternionInterpolateFunctionWithTangents(startValue: Quaternion, outTangent: Quaternion, endValue: Quaternion, inTangent: Quaternion, gradient: number): Quaternion {\r\n        return Quaternion.Hermite(startValue, outTangent, endValue, inTangent, gradient).normalize();\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector3 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns Interpolated scalar value\r\n     */\r\n    public vector3InterpolateFunction(startValue: Vector3, endValue: Vector3, gradient: number): Vector3 {\r\n        return Vector3.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector3 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns InterpolatedVector3 value\r\n     */\r\n    public vector3InterpolateFunctionWithTangents(startValue: Vector3, outTangent: Vector3, endValue: Vector3, inTangent: Vector3, gradient: number): Vector3 {\r\n        return Vector3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector2 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns Interpolated Vector2 value\r\n     */\r\n    public vector2InterpolateFunction(startValue: Vector2, endValue: Vector2, gradient: number): Vector2 {\r\n        return Vector2.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector2 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns Interpolated Vector2 value\r\n     */\r\n    public vector2InterpolateFunctionWithTangents(startValue: Vector2, outTangent: Vector2, endValue: Vector2, inTangent: Vector2, gradient: number): Vector2 {\r\n        return Vector2.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a size linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Size value\r\n     */\r\n    public sizeInterpolateFunction(startValue: Size, endValue: Size, gradient: number): Size {\r\n        return Size.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color3 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Color3 value\r\n     */\r\n    public color3InterpolateFunction(startValue: Color3, endValue: Color3, gradient: number): Color3 {\r\n        return Color3.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color3 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns interpolated value\r\n     */\r\n    public color3InterpolateFunctionWithTangents(startValue: Color3, outTangent: Color3, endValue: Color3, inTangent: Color3, gradient: number): Color3 {\r\n        return Color3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color4 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Color3 value\r\n     */\r\n    public color4InterpolateFunction(startValue: Color4, endValue: Color4, gradient: number): Color4 {\r\n        return Color4.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color4 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns interpolated value\r\n     */\r\n    public color4InterpolateFunctionWithTangents(startValue: Color4, outTangent: Color4, endValue: Color4, inTangent: Color4, gradient: number): Color4 {\r\n        return Color4.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * @internal Internal use only\r\n     */\r\n    public _getKeyValue(value: any): any {\r\n        if (typeof value === \"function\") {\r\n            return value();\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Evaluate the animation value at a given frame\r\n     * @param currentFrame defines the frame where we want to evaluate the animation\r\n     * @returns the animation value\r\n     */\r\n    public evaluate(currentFrame: number) {\r\n        evaluateAnimationState.key = 0;\r\n        return this._interpolate(currentFrame, evaluateAnimationState);\r\n    }\r\n\r\n    /**\r\n     * @internal Internal use only\r\n     */\r\n    public _interpolate(currentFrame: number, state: _IAnimationState, searchClosestKeyOnly = false): any {\r\n        if (state.loopMode === Animation.ANIMATIONLOOPMODE_CONSTANT && state.repeatCount > 0) {\r\n            return state.highLimitValue.clone ? state.highLimitValue.clone() : state.highLimitValue;\r\n        }\r\n\r\n        const keys = this._keys;\r\n        const keysLength = keys.length;\r\n\r\n        let key = state.key;\r\n\r\n        while (key >= 0 && currentFrame < keys[key].frame) {\r\n            --key;\r\n        }\r\n\r\n        while (key + 1 <= keysLength - 1 && currentFrame >= keys[key + 1].frame) {\r\n            ++key;\r\n        }\r\n\r\n        state.key = key;\r\n\r\n        if (key < 0) {\r\n            return searchClosestKeyOnly ? undefined : this._getKeyValue(keys[0].value);\r\n        } else if (key + 1 > keysLength - 1) {\r\n            return searchClosestKeyOnly ? undefined : this._getKeyValue(keys[keysLength - 1].value);\r\n        }\r\n\r\n        const startKey = keys[key];\r\n        const endKey = keys[key + 1];\r\n\r\n        if (searchClosestKeyOnly && (currentFrame === startKey.frame || currentFrame === endKey.frame)) {\r\n            return undefined;\r\n        }\r\n\r\n        const startValue = this._getKeyValue(startKey.value);\r\n        const endValue = this._getKeyValue(endKey.value);\r\n        if (startKey.interpolation === AnimationKeyInterpolation.STEP) {\r\n            if (endKey.frame > currentFrame) {\r\n                return startValue;\r\n            } else {\r\n                return endValue;\r\n            }\r\n        }\r\n\r\n        const useTangent = startKey.outTangent !== undefined && endKey.inTangent !== undefined;\r\n        const frameDelta = endKey.frame - startKey.frame;\r\n\r\n        // gradient : percent of currentFrame between the frame inf and the frame sup\r\n        let gradient = (currentFrame - startKey.frame) / frameDelta;\r\n\r\n        // check for easingFunction and correction of gradient\r\n        const easingFunction = this.getEasingFunction();\r\n        if (easingFunction !== null) {\r\n            gradient = easingFunction.ease(gradient);\r\n        }\r\n\r\n        switch (this.dataType) {\r\n            // Float\r\n            case Animation.ANIMATIONTYPE_FLOAT: {\r\n                const floatValue = useTangent\r\n                    ? this.floatInterpolateFunctionWithTangents(startValue, startKey.outTangent * frameDelta, endValue, endKey.inTangent * frameDelta, gradient)\r\n                    : this.floatInterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return floatValue;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                        return state.offsetValue * state.repeatCount + floatValue;\r\n                }\r\n                break;\r\n            }\r\n            // Quaternion\r\n            case Animation.ANIMATIONTYPE_QUATERNION: {\r\n                const quatValue = useTangent\r\n                    ? this.quaternionInterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.quaternionInterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return quatValue;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                        return quatValue.addInPlace(state.offsetValue.scale(state.repeatCount));\r\n                }\r\n\r\n                return quatValue;\r\n            }\r\n            // Vector3\r\n            case Animation.ANIMATIONTYPE_VECTOR3: {\r\n                const vec3Value = useTangent\r\n                    ? this.vector3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.vector3InterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return vec3Value;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                        return vec3Value.add(state.offsetValue.scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Vector2\r\n            case Animation.ANIMATIONTYPE_VECTOR2: {\r\n                const vec2Value = useTangent\r\n                    ? this.vector2InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.vector2InterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return vec2Value;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                        return vec2Value.add(state.offsetValue.scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Size\r\n            case Animation.ANIMATIONTYPE_SIZE: {\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return this.sizeInterpolateFunction(startValue, endValue, gradient);\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                        return this.sizeInterpolateFunction(startValue, endValue, gradient).add(state.offsetValue.scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Color3\r\n            case Animation.ANIMATIONTYPE_COLOR3: {\r\n                const color3Value = useTangent\r\n                    ? this.color3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.color3InterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return color3Value;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                        return color3Value.add(state.offsetValue.scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Color4\r\n            case Animation.ANIMATIONTYPE_COLOR4: {\r\n                const color4Value = useTangent\r\n                    ? this.color4InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.color4InterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return color4Value;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                        return color4Value.add(state.offsetValue.scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Matrix\r\n            case Animation.ANIMATIONTYPE_MATRIX: {\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO: {\r\n                        if (Animation.AllowMatricesInterpolation) {\r\n                            return this.matrixInterpolateFunction(startValue, endValue, gradient, state.workValue);\r\n                        }\r\n                        return startValue;\r\n                    }\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE: {\r\n                        return startValue;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Defines the function to use to interpolate matrices\r\n     * @param startValue defines the start matrix\r\n     * @param endValue defines the end matrix\r\n     * @param gradient defines the gradient between both matrices\r\n     * @param result defines an optional target matrix where to store the interpolation\r\n     * @returns the interpolated matrix\r\n     */\r\n    public matrixInterpolateFunction(startValue: Matrix, endValue: Matrix, gradient: number, result?: Matrix): Matrix {\r\n        if (Animation.AllowMatrixDecomposeForInterpolation) {\r\n            if (result) {\r\n                Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);\r\n                return result;\r\n            }\r\n            return Matrix.DecomposeLerp(startValue, endValue, gradient);\r\n        }\r\n\r\n        if (result) {\r\n            Matrix.LerpToRef(startValue, endValue, gradient, result);\r\n            return result;\r\n        }\r\n        return Matrix.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Makes a copy of the animation\r\n     * @returns Cloned animation\r\n     */\r\n    public clone(): Animation {\r\n        const clone = new Animation(this.name, this.targetPropertyPath.join(\".\"), this.framePerSecond, this.dataType, this.loopMode);\r\n\r\n        clone.enableBlending = this.enableBlending;\r\n        clone.blendingSpeed = this.blendingSpeed;\r\n\r\n        if (this._keys) {\r\n            clone.setKeys(this._keys);\r\n        }\r\n\r\n        if (this._ranges) {\r\n            clone._ranges = {};\r\n            for (const name in this._ranges) {\r\n                const range = this._ranges[name];\r\n                if (!range) {\r\n                    continue;\r\n                }\r\n                clone._ranges[name] = range.clone();\r\n            }\r\n        }\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Sets the key frames of the animation\r\n     * @param values The animation key frames to set\r\n     * @param dontClone Whether to clone the keys or not (default is false, so the array of keys is cloned)\r\n     */\r\n    public setKeys(values: Array<IAnimationKey>, dontClone = false): void {\r\n        this._keys = !dontClone ? values.slice(0) : values;\r\n    }\r\n\r\n    /**\r\n     * Creates a key for the frame passed as a parameter and adds it to the animation IF a key doesn't already exist for that frame\r\n     * @param frame Frame number\r\n     * @returns The key index if the key was added or the index of the pre existing key if the frame passed as parameter already has a corresponding key\r\n     */\r\n    public createKeyForFrame(frame: number) {\r\n        // Find the key corresponding to frame\r\n        evaluateAnimationState.key = 0;\r\n        const value = this._interpolate(frame, evaluateAnimationState, true);\r\n\r\n        if (!value) {\r\n            // A key corresponding to this frame already exists\r\n            return evaluateAnimationState.key === frame ? evaluateAnimationState.key : evaluateAnimationState.key + 1;\r\n        }\r\n\r\n        // The frame is between two keys, so create a new key\r\n        const newKey: IAnimationKey = {\r\n            frame,\r\n            value: value.clone ? value.clone() : value,\r\n        };\r\n\r\n        this._keys.splice(evaluateAnimationState.key + 1, 0, newKey);\r\n\r\n        return evaluateAnimationState.key + 1;\r\n    }\r\n\r\n    /**\r\n     * Serializes the animation to an object\r\n     * @returns Serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.property = this.targetProperty;\r\n        serializationObject.framePerSecond = this.framePerSecond;\r\n        serializationObject.dataType = this.dataType;\r\n        serializationObject.loopBehavior = this.loopMode;\r\n        serializationObject.enableBlending = this.enableBlending;\r\n        serializationObject.blendingSpeed = this.blendingSpeed;\r\n\r\n        const dataType = this.dataType;\r\n        serializationObject.keys = [];\r\n        const keys = this.getKeys();\r\n        for (let index = 0; index < keys.length; index++) {\r\n            const animationKey = keys[index];\r\n\r\n            const key: any = {};\r\n            key.frame = animationKey.frame;\r\n\r\n            switch (dataType) {\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    key.values = [animationKey.value];\r\n                    if (animationKey.inTangent !== undefined) {\r\n                        key.values.push(animationKey.inTangent);\r\n                    }\r\n                    if (animationKey.outTangent !== undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.outTangent);\r\n                    }\r\n                    if (animationKey.interpolation !== undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        if (animationKey.outTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.interpolation);\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    key.values = animationKey.value.asArray();\r\n                    if (animationKey.inTangent != undefined) {\r\n                        key.values.push(animationKey.inTangent.asArray());\r\n                    }\r\n                    if (animationKey.outTangent != undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.outTangent.asArray());\r\n                    }\r\n                    if (animationKey.interpolation !== undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        if (animationKey.outTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.interpolation);\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            serializationObject.keys.push(key);\r\n        }\r\n\r\n        serializationObject.ranges = [];\r\n        for (const name in this._ranges) {\r\n            const source = this._ranges[name];\r\n\r\n            if (!source) {\r\n                continue;\r\n            }\r\n            const range: any = {};\r\n            range.name = name;\r\n            range.from = source.from;\r\n            range.to = source.to;\r\n            serializationObject.ranges.push(range);\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Float animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_FLOAT = 0;\r\n    /**\r\n     * Vector3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_VECTOR3 = 1;\r\n    /**\r\n     * Quaternion animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_QUATERNION = 2;\r\n    /**\r\n     * Matrix animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_MATRIX = 3;\r\n    /**\r\n     * Color3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_COLOR3 = 4;\r\n    /**\r\n     * Color3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_COLOR4 = 7;\r\n    /**\r\n     * Vector2 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_VECTOR2 = 5;\r\n    /**\r\n     * Size animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_SIZE = 6;\r\n    /**\r\n     * Relative Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_RELATIVE = 0;\r\n    /**\r\n     * Cycle Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_CYCLE = 1;\r\n    /**\r\n     * Constant Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_CONSTANT = 2;\r\n    /**\r\n     * Yoyo Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_YOYO = 4;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _UniversalLerp(left: any, right: any, amount: number): any {\r\n        const constructor = left.constructor;\r\n        if (constructor.Lerp) {\r\n            // Lerp supported\r\n            return constructor.Lerp(left, right, amount);\r\n        } else if (constructor.Slerp) {\r\n            // Slerp supported\r\n            return constructor.Slerp(left, right, amount);\r\n        } else if (left.toFixed) {\r\n            // Number\r\n            return left * (1.0 - amount) + amount * right;\r\n        } else {\r\n            // Blending not supported\r\n            return right;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses an animation object and creates an animation\r\n     * @param parsedAnimation Parsed animation object\r\n     * @returns Animation object\r\n     */\r\n    public static Parse(parsedAnimation: any): Animation {\r\n        const animation = new Animation(parsedAnimation.name, parsedAnimation.property, parsedAnimation.framePerSecond, parsedAnimation.dataType, parsedAnimation.loopBehavior);\r\n\r\n        const dataType = parsedAnimation.dataType;\r\n        const keys: Array<IAnimationKey> = [];\r\n        let data;\r\n        let index: number;\r\n\r\n        if (parsedAnimation.enableBlending) {\r\n            animation.enableBlending = parsedAnimation.enableBlending;\r\n        }\r\n\r\n        if (parsedAnimation.blendingSpeed) {\r\n            animation.blendingSpeed = parsedAnimation.blendingSpeed;\r\n        }\r\n\r\n        for (index = 0; index < parsedAnimation.keys.length; index++) {\r\n            const key = parsedAnimation.keys[index];\r\n            let inTangent: any = undefined;\r\n            let outTangent: any = undefined;\r\n            let interpolation: any = undefined;\r\n\r\n            switch (dataType) {\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    data = key.values[0];\r\n                    if (key.values.length >= 2) {\r\n                        inTangent = key.values[1];\r\n                    }\r\n                    if (key.values.length >= 3) {\r\n                        outTangent = key.values[2];\r\n                    }\r\n                    if (key.values.length >= 4) {\r\n                        interpolation = key.values[3];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    data = Quaternion.FromArray(key.values);\r\n                    if (key.values.length >= 8) {\r\n                        const _inTangent = Quaternion.FromArray(key.values.slice(4, 8));\r\n                        if (!_inTangent.equals(Quaternion.Zero())) {\r\n                            inTangent = _inTangent;\r\n                        }\r\n                    }\r\n                    if (key.values.length >= 12) {\r\n                        const _outTangent = Quaternion.FromArray(key.values.slice(8, 12));\r\n                        if (!_outTangent.equals(Quaternion.Zero())) {\r\n                            outTangent = _outTangent;\r\n                        }\r\n                    }\r\n                    if (key.values.length >= 13) {\r\n                        interpolation = key.values[12];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                    data = Matrix.FromArray(key.values);\r\n                    if (key.values.length >= 17) {\r\n                        interpolation = key.values[16];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                    data = Color3.FromArray(key.values);\r\n                    if (key.values[3]) {\r\n                        inTangent = Color3.FromArray(key.values[3]);\r\n                    }\r\n                    if (key.values[4]) {\r\n                        outTangent = Color3.FromArray(key.values[4]);\r\n                    }\r\n                    if (key.values[5]) {\r\n                        interpolation = key.values[5];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    data = Color4.FromArray(key.values);\r\n                    if (key.values[4]) {\r\n                        inTangent = Color4.FromArray(key.values[4]);\r\n                    }\r\n                    if (key.values[5]) {\r\n                        outTangent = Color4.FromArray(key.values[5]);\r\n                    }\r\n                    if (key.values[6]) {\r\n                        interpolation = Color4.FromArray(key.values[6]);\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                default:\r\n                    data = Vector3.FromArray(key.values);\r\n                    if (key.values[3]) {\r\n                        inTangent = Vector3.FromArray(key.values[3]);\r\n                    }\r\n                    if (key.values[4]) {\r\n                        outTangent = Vector3.FromArray(key.values[4]);\r\n                    }\r\n                    if (key.values[5]) {\r\n                        interpolation = key.values[5];\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            const keyData: any = {};\r\n            keyData.frame = key.frame;\r\n            keyData.value = data;\r\n\r\n            if (inTangent != undefined) {\r\n                keyData.inTangent = inTangent;\r\n            }\r\n            if (outTangent != undefined) {\r\n                keyData.outTangent = outTangent;\r\n            }\r\n            if (interpolation != undefined) {\r\n                keyData.interpolation = interpolation;\r\n            }\r\n            keys.push(keyData);\r\n        }\r\n\r\n        animation.setKeys(keys);\r\n\r\n        if (parsedAnimation.ranges) {\r\n            for (index = 0; index < parsedAnimation.ranges.length; index++) {\r\n                data = parsedAnimation.ranges[index];\r\n                animation.createRange(data.name, data.from, data.to);\r\n            }\r\n        }\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Appends the serialized animations from the source animations\r\n     * @param source Source containing the animations\r\n     * @param destination Target to store the animations\r\n     */\r\n    public static AppendSerializedAnimations(source: IAnimatable, destination: any): void {\r\n        SerializationHelper.AppendSerializedAnimations(source, destination);\r\n    }\r\n\r\n    /**\r\n     * Creates a new animation or an array of animations from a snippet saved in a remote file\r\n     * @param name defines the name of the animation to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @returns a promise that will resolve to the new animation or an array of animations\r\n     */\r\n    public static ParseFromFileAsync(name: Nullable<string>, url: string): Promise<Animation | Array<Animation>> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        let serializationObject = JSON.parse(request.responseText);\r\n                        if (serializationObject.animations) {\r\n                            serializationObject = serializationObject.animations;\r\n                        }\r\n\r\n                        if (serializationObject.length) {\r\n                            const output = new Array<Animation>();\r\n                            for (const serializedAnimation of serializationObject) {\r\n                                output.push(this.Parse(serializedAnimation));\r\n                            }\r\n\r\n                            resolve(output);\r\n                        } else {\r\n                            const output = this.Parse(serializationObject);\r\n\r\n                            if (name) {\r\n                                output.name = name;\r\n                            }\r\n\r\n                            resolve(output);\r\n                        }\r\n                    } else {\r\n                        reject(\"Unable to load the animation\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an animation or an array of animations from a snippet saved by the Inspector\r\n     * @param snippetId defines the snippet to load\r\n     * @returns a promise that will resolve to the new animation or a new array of animations\r\n     */\r\n    public static ParseFromSnippetAsync(snippetId: string): Promise<Animation | Array<Animation>> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n\r\n                        if (snippet.animations) {\r\n                            const serializationObject = JSON.parse(snippet.animations);\r\n                            const outputs = new Array<Animation>();\r\n                            for (const serializedAnimation of serializationObject.animations) {\r\n                                const output = this.Parse(serializedAnimation);\r\n                                output.snippetId = snippetId;\r\n                                outputs.push(output);\r\n                            }\r\n\r\n                            resolve(outputs);\r\n                        } else {\r\n                            const serializationObject = JSON.parse(snippet.animation);\r\n                            const output = this.Parse(serializationObject);\r\n\r\n                            output.snippetId = snippetId;\r\n\r\n                            resolve(output);\r\n                        }\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an animation or an array of animations from a snippet saved by the Inspector\r\n     * @deprecated Please use ParseFromSnippetAsync instead\r\n     * @param snippetId defines the snippet to load\r\n     * @returns a promise that will resolve to the new animation or a new array of animations\r\n     */\r\n    public static CreateFromSnippetAsync = Animation.ParseFromSnippetAsync;\r\n}\r\n\r\nRegisterClass(\"BABYLON.Animation\", Animation);\r\nNode._AnimationRangeFactory = (name: string, from: number, to: number) => new AnimationRange(name, from, to);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}