{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { FactorGradient, ColorGradient, GradientHelper } from \"../Misc/gradients.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Color4, TmpColors } from \"../Maths/math.color.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer.js\";\nimport { BaseParticleSystem } from \"./baseParticleSystem.js\";\nimport { ParticleSystem } from \"./particleSystem.js\";\nimport { BoxParticleEmitter } from \"../Particles/EmitterTypes/boxParticleEmitter.js\";\nimport { MaterialHelper } from \"../Materials/materialHelper.js\";\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration.js\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { CustomParticleEmitter } from \"./EmitterTypes/customParticleEmitter.js\";\nimport { ThinEngine } from \"../Engines/thinEngine.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper.js\";\nimport \"../Engines/Extensions/engine.transformFeedback.js\";\nimport \"../Shaders/gpuRenderParticles.fragment.js\";\nimport \"../Shaders/gpuRenderParticles.vertex.js\";\n/**\n * This represents a GPU particle system in Babylon\n * This is the fastest particle system in Babylon as it uses the GPU to update the individual particle data\n * @see https://www.babylonjs-playground.com/#PU4WYI#4\n */\nexport class GPUParticleSystem extends BaseParticleSystem {\n  /**\n   * Gets a boolean indicating if the GPU particles can be rendered on current browser\n   */\n  static get IsSupported() {\n    if (!EngineStore.LastCreatedEngine) {\n      return false;\n    }\n    const caps = EngineStore.LastCreatedEngine.getCaps();\n    return caps.supportTransformFeedbacks || caps.supportComputeShaders;\n  }\n  _createIndexBuffer() {\n    this._linesIndexBufferUseInstancing = this._engine.createIndexBuffer(new Uint32Array([0, 1, 1, 3, 3, 2, 2, 0, 0, 3]));\n  }\n  /**\n   * Gets the maximum number of particles active at the same time.\n   * @returns The max number of active particles.\n   */\n  getCapacity() {\n    return this._capacity;\n  }\n  /**\n   * Gets or set the number of active particles\n   * The value cannot be greater than \"capacity\" (if it is, it will be limited to \"capacity\").\n   */\n  get maxActiveParticleCount() {\n    return this._maxActiveParticleCount;\n  }\n  set maxActiveParticleCount(value) {\n    this._maxActiveParticleCount = Math.min(value, this._capacity);\n  }\n  /**\n   * Gets or set the number of active particles\n   * @deprecated Please use maxActiveParticleCount instead.\n   */\n  get activeParticleCount() {\n    return this.maxActiveParticleCount;\n  }\n  set activeParticleCount(value) {\n    this.maxActiveParticleCount = value;\n  }\n  /**\n   * Is this system ready to be used/rendered\n   * @returns true if the system is ready\n   */\n  isReady() {\n    if (!this.emitter || this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady() || !this.particleTexture || !this.particleTexture.isReady()) {\n      return false;\n    }\n    if (this.blendMode !== ParticleSystem.BLENDMODE_MULTIPLYADD) {\n      if (!this._getWrapper(this.blendMode).effect.isReady()) {\n        return false;\n      }\n    } else {\n      if (!this._getWrapper(ParticleSystem.BLENDMODE_MULTIPLY).effect.isReady()) {\n        return false;\n      }\n      if (!this._getWrapper(ParticleSystem.BLENDMODE_ADD).effect.isReady()) {\n        return false;\n      }\n    }\n    if (!this._platform.isUpdateBufferCreated()) {\n      this._recreateUpdateEffect();\n      return false;\n    }\n    return this._platform.isUpdateBufferReady();\n  }\n  /**\n   * Gets if the system has been started. (Note: this will still be true after stop is called)\n   * @returns True if it has been started, otherwise false.\n   */\n  isStarted() {\n    return this._started;\n  }\n  /**\n   * Gets if the system has been stopped. (Note: rendering is still happening but the system is frozen)\n   * @returns True if it has been stopped, otherwise false.\n   */\n  isStopped() {\n    return this._stopped;\n  }\n  /**\n   * Gets a boolean indicating that the system is stopping\n   * @returns true if the system is currently stopping\n   */\n  isStopping() {\n    return false; // Stop is immediate on GPU\n  }\n  /**\n   * Gets the number of particles active at the same time.\n   * @returns The number of active particles.\n   */\n  getActiveCount() {\n    return this._currentActiveCount;\n  }\n  /**\n   * Starts the particle system and begins to emit\n   * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)\n   */\n  start(delay = this.startDelay) {\n    if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {\n      throw \"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set\";\n    }\n    if (delay) {\n      setTimeout(() => {\n        this.start(0);\n      }, delay);\n      return;\n    }\n    this._started = true;\n    this._stopped = false;\n    this._preWarmDone = false;\n    // Animations\n    if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {\n      this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);\n    }\n  }\n  /**\n   * Stops the particle system.\n   */\n  stop() {\n    if (this._stopped) {\n      return;\n    }\n    this._stopped = true;\n  }\n  /**\n   * Remove all active particles\n   */\n  reset() {\n    this._releaseBuffers();\n    this._platform.releaseVertexBuffers();\n    this._currentActiveCount = 0;\n    this._targetIndex = 0;\n  }\n  /**\n   * Returns the string \"GPUParticleSystem\"\n   * @returns a string containing the class name\n   */\n  getClassName() {\n    return \"GPUParticleSystem\";\n  }\n  /**\n   * Gets the custom effect used to render the particles\n   * @param blendMode Blend mode for which the effect should be retrieved\n   * @returns The effect\n   */\n  getCustomEffect(blendMode = 0) {\n    var _a, _b;\n    return (_b = (_a = this._customWrappers[blendMode]) === null || _a === void 0 ? void 0 : _a.effect) !== null && _b !== void 0 ? _b : this._customWrappers[0].effect;\n  }\n  _getCustomDrawWrapper(blendMode = 0) {\n    var _a;\n    return (_a = this._customWrappers[blendMode]) !== null && _a !== void 0 ? _a : this._customWrappers[0];\n  }\n  /**\n   * Sets the custom effect used to render the particles\n   * @param effect The effect to set\n   * @param blendMode Blend mode for which the effect should be set\n   */\n  setCustomEffect(effect, blendMode = 0) {\n    this._customWrappers[blendMode] = new DrawWrapper(this._engine);\n    this._customWrappers[blendMode].effect = effect;\n  }\n  /**\n   * Observable that will be called just before the particles are drawn\n   */\n  get onBeforeDrawParticlesObservable() {\n    if (!this._onBeforeDrawParticlesObservable) {\n      this._onBeforeDrawParticlesObservable = new Observable();\n    }\n    return this._onBeforeDrawParticlesObservable;\n  }\n  /**\n   * Gets the name of the particle vertex shader\n   */\n  get vertexShaderName() {\n    return \"gpuRenderParticles\";\n  }\n  /**\n   * Gets the vertex buffers used by the particle system\n   * Should be called after render() has been called for the current frame so that the buffers returned are the ones that have been updated\n   * in the current frame (there's a ping-pong between two sets of buffers - for a given frame, one set is used as the source and the other as the destination)\n   */\n  get vertexBuffers() {\n    // We return the other buffers than those corresponding to this._targetIndex because it is assumed vertexBuffers will be called in the current frame\n    // after render() has been called, meaning that the buffers have already been swapped and this._targetIndex points to the buffers that will be updated\n    // in the next frame (and which are the sources in this frame) and (this._targetIndex ^ 1) points to the buffers that have been updated this frame\n    // (and that will be the source buffers in the next frame)\n    return this._renderVertexBuffers[this._targetIndex ^ 1];\n  }\n  /**\n   * Gets the index buffer used by the particle system (null for GPU particle systems)\n   */\n  get indexBuffer() {\n    return null;\n  }\n  _removeGradientAndTexture(gradient, gradients, texture) {\n    super._removeGradientAndTexture(gradient, gradients, texture);\n    this._releaseBuffers();\n    return this;\n  }\n  /**\n   * Adds a new color gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param color1 defines the color to affect to the specified gradient\n   * @returns the current particle system\n   */\n  addColorGradient(gradient, color1) {\n    if (!this._colorGradients) {\n      this._colorGradients = [];\n    }\n    const colorGradient = new ColorGradient(gradient, color1);\n    this._colorGradients.push(colorGradient);\n    this._refreshColorGradient(true);\n    this._releaseBuffers();\n    return this;\n  }\n  _refreshColorGradient(reorder = false) {\n    if (this._colorGradients) {\n      if (reorder) {\n        this._colorGradients.sort((a, b) => {\n          if (a.gradient < b.gradient) {\n            return -1;\n          } else if (a.gradient > b.gradient) {\n            return 1;\n          }\n          return 0;\n        });\n      }\n      if (this._colorGradientsTexture) {\n        this._colorGradientsTexture.dispose();\n        this._colorGradientsTexture = null;\n      }\n    }\n  }\n  /** Force the system to rebuild all gradients that need to be resync */\n  forceRefreshGradients() {\n    this._refreshColorGradient();\n    this._refreshFactorGradient(this._sizeGradients, \"_sizeGradientsTexture\");\n    this._refreshFactorGradient(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\");\n    this._refreshFactorGradient(this._velocityGradients, \"_velocityGradientsTexture\");\n    this._refreshFactorGradient(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\");\n    this._refreshFactorGradient(this._dragGradients, \"_dragGradientsTexture\");\n    this.reset();\n  }\n  /**\n   * Remove a specific color gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeColorGradient(gradient) {\n    this._removeGradientAndTexture(gradient, this._colorGradients, this._colorGradientsTexture);\n    this._colorGradientsTexture = null;\n    return this;\n  }\n  /**\n   * Resets the draw wrappers cache\n   */\n  resetDrawCache() {\n    var _a;\n    for (const blendMode in this._drawWrappers) {\n      const drawWrapper = this._drawWrappers[blendMode];\n      (_a = drawWrapper.drawContext) === null || _a === void 0 ? void 0 : _a.reset();\n    }\n  }\n  _addFactorGradient(factorGradients, gradient, factor) {\n    const valueGradient = new FactorGradient(gradient, factor);\n    factorGradients.push(valueGradient);\n    this._releaseBuffers();\n  }\n  /**\n   * Adds a new size gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the size factor to affect to the specified gradient\n   * @returns the current particle system\n   */\n  addSizeGradient(gradient, factor) {\n    if (!this._sizeGradients) {\n      this._sizeGradients = [];\n    }\n    this._addFactorGradient(this._sizeGradients, gradient, factor);\n    this._refreshFactorGradient(this._sizeGradients, \"_sizeGradientsTexture\", true);\n    this._releaseBuffers();\n    return this;\n  }\n  /**\n   * Remove a specific size gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeSizeGradient(gradient) {\n    this._removeGradientAndTexture(gradient, this._sizeGradients, this._sizeGradientsTexture);\n    this._sizeGradientsTexture = null;\n    return this;\n  }\n  _refreshFactorGradient(factorGradients, textureName, reorder = false) {\n    if (!factorGradients) {\n      return;\n    }\n    if (reorder) {\n      factorGradients.sort((a, b) => {\n        if (a.gradient < b.gradient) {\n          return -1;\n        } else if (a.gradient > b.gradient) {\n          return 1;\n        }\n        return 0;\n      });\n    }\n    const that = this;\n    if (that[textureName]) {\n      that[textureName].dispose();\n      that[textureName] = null;\n    }\n  }\n  /**\n   * Adds a new angular speed gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the angular speed to affect to the specified gradient\n   * @returns the current particle system\n   */\n  addAngularSpeedGradient(gradient, factor) {\n    if (!this._angularSpeedGradients) {\n      this._angularSpeedGradients = [];\n    }\n    this._addFactorGradient(this._angularSpeedGradients, gradient, factor);\n    this._refreshFactorGradient(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\", true);\n    this._releaseBuffers();\n    return this;\n  }\n  /**\n   * Remove a specific angular speed gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeAngularSpeedGradient(gradient) {\n    this._removeGradientAndTexture(gradient, this._angularSpeedGradients, this._angularSpeedGradientsTexture);\n    this._angularSpeedGradientsTexture = null;\n    return this;\n  }\n  /**\n   * Adds a new velocity gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the velocity to affect to the specified gradient\n   * @returns the current particle system\n   */\n  addVelocityGradient(gradient, factor) {\n    if (!this._velocityGradients) {\n      this._velocityGradients = [];\n    }\n    this._addFactorGradient(this._velocityGradients, gradient, factor);\n    this._refreshFactorGradient(this._velocityGradients, \"_velocityGradientsTexture\", true);\n    this._releaseBuffers();\n    return this;\n  }\n  /**\n   * Remove a specific velocity gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeVelocityGradient(gradient) {\n    this._removeGradientAndTexture(gradient, this._velocityGradients, this._velocityGradientsTexture);\n    this._velocityGradientsTexture = null;\n    return this;\n  }\n  /**\n   * Adds a new limit velocity gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the limit velocity value to affect to the specified gradient\n   * @returns the current particle system\n   */\n  addLimitVelocityGradient(gradient, factor) {\n    if (!this._limitVelocityGradients) {\n      this._limitVelocityGradients = [];\n    }\n    this._addFactorGradient(this._limitVelocityGradients, gradient, factor);\n    this._refreshFactorGradient(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\", true);\n    this._releaseBuffers();\n    return this;\n  }\n  /**\n   * Remove a specific limit velocity gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeLimitVelocityGradient(gradient) {\n    this._removeGradientAndTexture(gradient, this._limitVelocityGradients, this._limitVelocityGradientsTexture);\n    this._limitVelocityGradientsTexture = null;\n    return this;\n  }\n  /**\n   * Adds a new drag gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the drag value to affect to the specified gradient\n   * @returns the current particle system\n   */\n  addDragGradient(gradient, factor) {\n    if (!this._dragGradients) {\n      this._dragGradients = [];\n    }\n    this._addFactorGradient(this._dragGradients, gradient, factor);\n    this._refreshFactorGradient(this._dragGradients, \"_dragGradientsTexture\", true);\n    this._releaseBuffers();\n    return this;\n  }\n  /**\n   * Remove a specific drag gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeDragGradient(gradient) {\n    this._removeGradientAndTexture(gradient, this._dragGradients, this._dragGradientsTexture);\n    this._dragGradientsTexture = null;\n    return this;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n  addEmitRateGradient() {\n    // Do nothing as emit rate is not supported by GPUParticleSystem\n    return this;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n  removeEmitRateGradient() {\n    // Do nothing as emit rate is not supported by GPUParticleSystem\n    return this;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n  addStartSizeGradient() {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n  removeStartSizeGradient() {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n  addColorRemapGradient() {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n  removeColorRemapGradient() {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n  addAlphaRemapGradient() {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n  removeAlphaRemapGradient() {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n  addRampGradient() {\n    //Not supported by GPUParticleSystem\n    return this;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n  removeRampGradient() {\n    //Not supported by GPUParticleSystem\n    return this;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the list of ramp gradients\n   */\n  getRampGradients() {\n    return null;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * Gets or sets a boolean indicating that ramp gradients must be used\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro#ramp-gradients\n   */\n  get useRampGradients() {\n    //Not supported by GPUParticleSystem\n    return false;\n  }\n  set useRampGradients(value) {\n    //Not supported by GPUParticleSystem\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n  addLifeTimeGradient() {\n    //Not supported by GPUParticleSystem\n    return this;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n  removeLifeTimeGradient() {\n    //Not supported by GPUParticleSystem\n    return this;\n  }\n  /**\n   * Instantiates a GPU particle system.\n   * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\n   * @param name The name of the particle system\n   * @param options The options used to create the system\n   * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene\n   * @param customEffect a custom effect used to change the way particles are rendered by default\n   * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture\n   */\n  constructor(name, options, sceneOrEngine, customEffect = null, isAnimationSheetEnabled = false) {\n    super(name);\n    /**\n     * The layer mask we are rendering the particles through.\n     */\n    this.layerMask = 0x0fffffff;\n    this._accumulatedCount = 0;\n    this._renderVertexBuffers = [];\n    this._targetIndex = 0;\n    this._currentRenderId = -1;\n    this._currentRenderingCameraUniqueId = -1;\n    this._started = false;\n    this._stopped = false;\n    this._timeDelta = 0;\n    /** Indicates that the update of particles is done in the animate function (and not in render). Default: false */\n    this.updateInAnimate = false;\n    this._actualFrame = 0;\n    this._rawTextureWidth = 256;\n    /**\n     * An event triggered when the system is disposed.\n     */\n    this.onDisposeObservable = new Observable();\n    /**\n     * An event triggered when the system is stopped\n     */\n    this.onStoppedObservable = new Observable();\n    /**\n     * Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls\n     * to override the particles.\n     */\n    this.forceDepthWrite = false;\n    this._preWarmDone = false;\n    /**\n     * Specifies if the particles are updated in emitter local space or world space.\n     */\n    this.isLocal = false;\n    /** Indicates that the particle system is GPU based */\n    this.isGPU = true;\n    /** @internal */\n    this._onBeforeDrawParticlesObservable = null;\n    if (!sceneOrEngine || sceneOrEngine.getClassName() === \"Scene\") {\n      this._scene = sceneOrEngine || EngineStore.LastCreatedScene;\n      this._engine = this._scene.getEngine();\n      this.uniqueId = this._scene.getUniqueId();\n      this._scene.particleSystems.push(this);\n    } else {\n      this._engine = sceneOrEngine;\n      this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100, this._engine.isNDCHalfZRange);\n    }\n    if (this._engine.getCaps().supportComputeShaders) {\n      if (!GetClass(\"BABYLON.ComputeShaderParticleSystem\")) {\n        throw new Error(\"The ComputeShaderParticleSystem class is not available! Make sure you have imported it.\");\n      }\n      this._platform = new (GetClass(\"BABYLON.ComputeShaderParticleSystem\"))(this, this._engine);\n    } else {\n      if (!GetClass(\"BABYLON.WebGL2ParticleSystem\")) {\n        throw new Error(\"The WebGL2ParticleSystem class is not available! Make sure you have imported it.\");\n      }\n      this._platform = new (GetClass(\"BABYLON.WebGL2ParticleSystem\"))(this, this._engine);\n    }\n    this._customWrappers = {\n      0: new DrawWrapper(this._engine)\n    };\n    this._customWrappers[0].effect = customEffect;\n    this._drawWrappers = {\n      0: new DrawWrapper(this._engine)\n    };\n    if (this._drawWrappers[0].drawContext) {\n      this._drawWrappers[0].drawContext.useInstancing = true;\n    }\n    this._createIndexBuffer();\n    // Setup the default processing configuration to the scene.\n    this._attachImageProcessingConfiguration(null);\n    options = options !== null && options !== void 0 ? options : {};\n    if (!options.randomTextureSize) {\n      delete options.randomTextureSize;\n    }\n    const fullOptions = Object.assign({\n      capacity: 50000,\n      randomTextureSize: this._engine.getCaps().maxTextureSize\n    }, options);\n    const optionsAsNumber = options;\n    if (isFinite(optionsAsNumber)) {\n      fullOptions.capacity = optionsAsNumber;\n    }\n    this._capacity = fullOptions.capacity;\n    this._maxActiveParticleCount = fullOptions.capacity;\n    this._currentActiveCount = 0;\n    this._isAnimationSheetEnabled = isAnimationSheetEnabled;\n    this.particleEmitterType = new BoxParticleEmitter();\n    // Random data\n    const maxTextureSize = Math.min(this._engine.getCaps().maxTextureSize, fullOptions.randomTextureSize);\n    let d = [];\n    for (let i = 0; i < maxTextureSize; ++i) {\n      d.push(Math.random());\n      d.push(Math.random());\n      d.push(Math.random());\n      d.push(Math.random());\n    }\n    this._randomTexture = new RawTexture(new Float32Array(d), maxTextureSize, 1, 5, sceneOrEngine, false, false, 1, 1);\n    this._randomTexture.name = \"GPUParticleSystem_random1\";\n    this._randomTexture.wrapU = 1;\n    this._randomTexture.wrapV = 1;\n    d = [];\n    for (let i = 0; i < maxTextureSize; ++i) {\n      d.push(Math.random());\n      d.push(Math.random());\n      d.push(Math.random());\n      d.push(Math.random());\n    }\n    this._randomTexture2 = new RawTexture(new Float32Array(d), maxTextureSize, 1, 5, sceneOrEngine, false, false, 1, 1);\n    this._randomTexture2.name = \"GPUParticleSystem_random2\";\n    this._randomTexture2.wrapU = 1;\n    this._randomTexture2.wrapV = 1;\n    this._randomTextureSize = maxTextureSize;\n  }\n  _reset() {\n    this._releaseBuffers();\n  }\n  _createVertexBuffers(updateBuffer, renderBuffer, spriteSource) {\n    const renderVertexBuffers = {};\n    renderVertexBuffers[\"position\"] = renderBuffer.createVertexBuffer(\"position\", 0, 3, this._attributesStrideSize, true);\n    let offset = 3;\n    renderVertexBuffers[\"age\"] = renderBuffer.createVertexBuffer(\"age\", offset, 1, this._attributesStrideSize, true);\n    offset += 1;\n    renderVertexBuffers[\"size\"] = renderBuffer.createVertexBuffer(\"size\", offset, 3, this._attributesStrideSize, true);\n    offset += 3;\n    renderVertexBuffers[\"life\"] = renderBuffer.createVertexBuffer(\"life\", offset, 1, this._attributesStrideSize, true);\n    offset += 1;\n    offset += 4; // seed\n    if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\n      renderVertexBuffers[\"direction\"] = renderBuffer.createVertexBuffer(\"direction\", offset, 3, this._attributesStrideSize, true);\n    }\n    offset += 3; // direction\n    if (this._platform.alignDataInBuffer) {\n      offset += 1;\n    }\n    if (this.particleEmitterType instanceof CustomParticleEmitter) {\n      offset += 3;\n      if (this._platform.alignDataInBuffer) {\n        offset += 1;\n      }\n    }\n    if (!this._colorGradientsTexture) {\n      renderVertexBuffers[\"color\"] = renderBuffer.createVertexBuffer(\"color\", offset, 4, this._attributesStrideSize, true);\n      offset += 4;\n    }\n    if (!this._isBillboardBased) {\n      renderVertexBuffers[\"initialDirection\"] = renderBuffer.createVertexBuffer(\"initialDirection\", offset, 3, this._attributesStrideSize, true);\n      offset += 3;\n      if (this._platform.alignDataInBuffer) {\n        offset += 1;\n      }\n    }\n    if (this.noiseTexture) {\n      renderVertexBuffers[\"noiseCoordinates1\"] = renderBuffer.createVertexBuffer(\"noiseCoordinates1\", offset, 3, this._attributesStrideSize, true);\n      offset += 3;\n      if (this._platform.alignDataInBuffer) {\n        offset += 1;\n      }\n      renderVertexBuffers[\"noiseCoordinates2\"] = renderBuffer.createVertexBuffer(\"noiseCoordinates2\", offset, 3, this._attributesStrideSize, true);\n      offset += 3;\n      if (this._platform.alignDataInBuffer) {\n        offset += 1;\n      }\n    }\n    renderVertexBuffers[\"angle\"] = renderBuffer.createVertexBuffer(\"angle\", offset, 1, this._attributesStrideSize, true);\n    if (this._angularSpeedGradientsTexture) {\n      offset++;\n    } else {\n      offset += 2;\n    }\n    if (this._isAnimationSheetEnabled) {\n      renderVertexBuffers[\"cellIndex\"] = renderBuffer.createVertexBuffer(\"cellIndex\", offset, 1, this._attributesStrideSize, true);\n      offset += 1;\n      if (this.spriteRandomStartCell) {\n        renderVertexBuffers[\"cellStartOffset\"] = renderBuffer.createVertexBuffer(\"cellStartOffset\", offset, 1, this._attributesStrideSize, true);\n        offset += 1;\n      }\n    }\n    renderVertexBuffers[\"offset\"] = spriteSource.createVertexBuffer(\"offset\", 0, 2);\n    renderVertexBuffers[\"uv\"] = spriteSource.createVertexBuffer(\"uv\", 2, 2);\n    this._renderVertexBuffers.push(renderVertexBuffers);\n    this._platform.createVertexBuffers(updateBuffer, renderVertexBuffers);\n    this.resetDrawCache();\n  }\n  _initialize(force = false) {\n    if (this._buffer0 && !force) {\n      return;\n    }\n    const engine = this._engine;\n    const data = new Array();\n    this._attributesStrideSize = 21;\n    this._targetIndex = 0;\n    if (this._platform.alignDataInBuffer) {\n      this._attributesStrideSize += 1;\n    }\n    if (this.particleEmitterType instanceof CustomParticleEmitter) {\n      this._attributesStrideSize += 3;\n      if (this._platform.alignDataInBuffer) {\n        this._attributesStrideSize += 1;\n      }\n    }\n    if (!this.isBillboardBased) {\n      this._attributesStrideSize += 3;\n      if (this._platform.alignDataInBuffer) {\n        this._attributesStrideSize += 1;\n      }\n    }\n    if (this._colorGradientsTexture) {\n      this._attributesStrideSize -= 4;\n    }\n    if (this._angularSpeedGradientsTexture) {\n      this._attributesStrideSize -= 1;\n    }\n    if (this._isAnimationSheetEnabled) {\n      this._attributesStrideSize += 1;\n      if (this.spriteRandomStartCell) {\n        this._attributesStrideSize += 1;\n      }\n    }\n    if (this.noiseTexture) {\n      this._attributesStrideSize += 6;\n      if (this._platform.alignDataInBuffer) {\n        this._attributesStrideSize += 2;\n      }\n    }\n    if (this._platform.alignDataInBuffer) {\n      this._attributesStrideSize += 3 - (this._attributesStrideSize + 3 & 3); // round to multiple of 4\n    }\n\n    const usingCustomEmitter = this.particleEmitterType instanceof CustomParticleEmitter;\n    const tmpVector = TmpVectors.Vector3[0];\n    let offset = 0;\n    for (let particleIndex = 0; particleIndex < this._capacity; particleIndex++) {\n      // position\n      data.push(0.0);\n      data.push(0.0);\n      data.push(0.0);\n      // Age\n      data.push(0.0); // create the particle as a dead one to create a new one at start\n      // Size\n      data.push(0.0);\n      data.push(0.0);\n      data.push(0.0);\n      // life\n      data.push(0.0);\n      // Seed\n      data.push(Math.random());\n      data.push(Math.random());\n      data.push(Math.random());\n      data.push(Math.random());\n      // direction\n      if (usingCustomEmitter) {\n        this.particleEmitterType.particleDestinationGenerator(particleIndex, null, tmpVector);\n        data.push(tmpVector.x);\n        data.push(tmpVector.y);\n        data.push(tmpVector.z);\n      } else {\n        data.push(0.0);\n        data.push(0.0);\n        data.push(0.0);\n      }\n      if (this._platform.alignDataInBuffer) {\n        data.push(0.0); // dummy0\n      }\n\n      offset += 16; // position, age, size, life, seed, direction, dummy0\n      if (usingCustomEmitter) {\n        this.particleEmitterType.particlePositionGenerator(particleIndex, null, tmpVector);\n        data.push(tmpVector.x);\n        data.push(tmpVector.y);\n        data.push(tmpVector.z);\n        if (this._platform.alignDataInBuffer) {\n          data.push(0.0); // dummy1\n        }\n\n        offset += 4;\n      }\n      if (!this._colorGradientsTexture) {\n        // color\n        data.push(0.0);\n        data.push(0.0);\n        data.push(0.0);\n        data.push(0.0);\n        offset += 4;\n      }\n      if (!this.isBillboardBased) {\n        // initialDirection\n        data.push(0.0);\n        data.push(0.0);\n        data.push(0.0);\n        if (this._platform.alignDataInBuffer) {\n          data.push(0.0); // dummy2\n        }\n\n        offset += 4;\n      }\n      if (this.noiseTexture) {\n        // Random coordinates for reading into noise texture\n        data.push(Math.random());\n        data.push(Math.random());\n        data.push(Math.random());\n        if (this._platform.alignDataInBuffer) {\n          data.push(0.0); // dummy3\n        }\n\n        data.push(Math.random());\n        data.push(Math.random());\n        data.push(Math.random());\n        if (this._platform.alignDataInBuffer) {\n          data.push(0.0); // dummy4\n        }\n\n        offset += 8;\n      }\n      // angle\n      data.push(0.0);\n      offset += 1;\n      if (!this._angularSpeedGradientsTexture) {\n        data.push(0.0);\n        offset += 1;\n      }\n      if (this._isAnimationSheetEnabled) {\n        data.push(0.0);\n        offset += 1;\n        if (this.spriteRandomStartCell) {\n          data.push(0.0);\n          offset += 1;\n        }\n      }\n      if (this._platform.alignDataInBuffer) {\n        let numDummies = 3 - (offset + 3 & 3);\n        offset += numDummies;\n        while (numDummies-- > 0) {\n          data.push(0.0);\n        }\n      }\n    }\n    // Sprite data\n    const spriteData = new Float32Array([0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1, 0.5, -0.5, 1, 0, -0.5, -0.5, 0, 0]);\n    const bufferData1 = this._platform.createParticleBuffer(data);\n    const bufferData2 = this._platform.createParticleBuffer(data);\n    // Buffers\n    this._buffer0 = new Buffer(engine, bufferData1, false, this._attributesStrideSize);\n    this._buffer1 = new Buffer(engine, bufferData2, false, this._attributesStrideSize);\n    this._spriteBuffer = new Buffer(engine, spriteData, false, 4);\n    // Update & Render vertex buffers\n    this._renderVertexBuffers = [];\n    this._createVertexBuffers(this._buffer0, this._buffer1, this._spriteBuffer);\n    this._createVertexBuffers(this._buffer1, this._buffer0, this._spriteBuffer);\n    // Links\n    this._sourceBuffer = this._buffer0;\n    this._targetBuffer = this._buffer1;\n  }\n  /** @internal */\n  _recreateUpdateEffect() {\n    this._createColorGradientTexture();\n    this._createSizeGradientTexture();\n    this._createAngularSpeedGradientTexture();\n    this._createVelocityGradientTexture();\n    this._createLimitVelocityGradientTexture();\n    this._createDragGradientTexture();\n    let defines = this.particleEmitterType ? this.particleEmitterType.getEffectDefines() : \"\";\n    if (this._isBillboardBased) {\n      defines += \"\\n#define BILLBOARD\";\n    }\n    if (this._colorGradientsTexture) {\n      defines += \"\\n#define COLORGRADIENTS\";\n    }\n    if (this._sizeGradientsTexture) {\n      defines += \"\\n#define SIZEGRADIENTS\";\n    }\n    if (this._angularSpeedGradientsTexture) {\n      defines += \"\\n#define ANGULARSPEEDGRADIENTS\";\n    }\n    if (this._velocityGradientsTexture) {\n      defines += \"\\n#define VELOCITYGRADIENTS\";\n    }\n    if (this._limitVelocityGradientsTexture) {\n      defines += \"\\n#define LIMITVELOCITYGRADIENTS\";\n    }\n    if (this._dragGradientsTexture) {\n      defines += \"\\n#define DRAGGRADIENTS\";\n    }\n    if (this.isAnimationSheetEnabled) {\n      defines += \"\\n#define ANIMATESHEET\";\n      if (this.spriteRandomStartCell) {\n        defines += \"\\n#define ANIMATESHEETRANDOMSTART\";\n      }\n    }\n    if (this.noiseTexture) {\n      defines += \"\\n#define NOISE\";\n    }\n    if (this.isLocal) {\n      defines += \"\\n#define LOCAL\";\n    }\n    if (this._platform.isUpdateBufferCreated() && this._cachedUpdateDefines === defines) {\n      return true;\n    }\n    this._cachedUpdateDefines = defines;\n    this._updateBuffer = this._platform.createUpdateBuffer(defines);\n    return this._platform.isUpdateBufferReady();\n  }\n  /**\n   * @internal\n   */\n  _getWrapper(blendMode) {\n    const customWrapper = this._getCustomDrawWrapper(blendMode);\n    if (customWrapper === null || customWrapper === void 0 ? void 0 : customWrapper.effect) {\n      return customWrapper;\n    }\n    const defines = [];\n    this.fillDefines(defines, blendMode);\n    // Effect\n    let drawWrapper = this._drawWrappers[blendMode];\n    if (!drawWrapper) {\n      drawWrapper = new DrawWrapper(this._engine);\n      if (drawWrapper.drawContext) {\n        drawWrapper.drawContext.useInstancing = true;\n      }\n      this._drawWrappers[blendMode] = drawWrapper;\n    }\n    const join = defines.join(\"\\n\");\n    if (drawWrapper.defines !== join) {\n      const attributes = [];\n      const uniforms = [];\n      const samplers = [];\n      this.fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers);\n      drawWrapper.setEffect(this._engine.createEffect(\"gpuRenderParticles\", attributes, uniforms, samplers, join), join);\n    }\n    return drawWrapper;\n  }\n  /**\n   * @internal\n   */\n  static _GetAttributeNamesOrOptions(hasColorGradients = false, isAnimationSheetEnabled = false, isBillboardBased = false, isBillboardStretched = false) {\n    const attributeNamesOrOptions = [VertexBuffer.PositionKind, \"age\", \"life\", \"size\", \"angle\"];\n    if (!hasColorGradients) {\n      attributeNamesOrOptions.push(VertexBuffer.ColorKind);\n    }\n    if (isAnimationSheetEnabled) {\n      attributeNamesOrOptions.push(\"cellIndex\");\n    }\n    if (!isBillboardBased) {\n      attributeNamesOrOptions.push(\"initialDirection\");\n    }\n    if (isBillboardStretched) {\n      attributeNamesOrOptions.push(\"direction\");\n    }\n    attributeNamesOrOptions.push(\"offset\", VertexBuffer.UVKind);\n    return attributeNamesOrOptions;\n  }\n  /**\n   * @internal\n   */\n  static _GetEffectCreationOptions(isAnimationSheetEnabled = false, useLogarithmicDepth = false) {\n    const effectCreationOption = [\"emitterWM\", \"worldOffset\", \"view\", \"projection\", \"colorDead\", \"invView\", \"translationPivot\", \"eyePosition\"];\n    addClipPlaneUniforms(effectCreationOption);\n    if (isAnimationSheetEnabled) {\n      effectCreationOption.push(\"sheetInfos\");\n    }\n    if (useLogarithmicDepth) {\n      effectCreationOption.push(\"logarithmicDepthConstant\");\n    }\n    return effectCreationOption;\n  }\n  /**\n   * Fill the defines array according to the current settings of the particle system\n   * @param defines Array to be updated\n   * @param blendMode blend mode to take into account when updating the array\n   */\n  fillDefines(defines, blendMode = 0) {\n    if (this._scene) {\n      prepareStringDefinesForClipPlanes(this, this._scene, defines);\n    }\n    if (blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {\n      defines.push(\"#define BLENDMULTIPLYMODE\");\n    }\n    if (this.isLocal) {\n      defines.push(\"#define LOCAL\");\n    }\n    if (this.useLogarithmicDepth) {\n      defines.push(\"#define LOGARITHMICDEPTH\");\n    }\n    if (this._isBillboardBased) {\n      defines.push(\"#define BILLBOARD\");\n      switch (this.billboardMode) {\n        case ParticleSystem.BILLBOARDMODE_Y:\n          defines.push(\"#define BILLBOARDY\");\n          break;\n        case ParticleSystem.BILLBOARDMODE_STRETCHED:\n          defines.push(\"#define BILLBOARDSTRETCHED\");\n          break;\n        case ParticleSystem.BILLBOARDMODE_ALL:\n          defines.push(\"#define BILLBOARDMODE_ALL\");\n          break;\n        default:\n          break;\n      }\n    }\n    if (this._colorGradientsTexture) {\n      defines.push(\"#define COLORGRADIENTS\");\n    }\n    if (this.isAnimationSheetEnabled) {\n      defines.push(\"#define ANIMATESHEET\");\n    }\n    if (this._imageProcessingConfiguration) {\n      this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);\n      defines.push(\"\" + this._imageProcessingConfigurationDefines.toString());\n    }\n  }\n  /**\n   * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system\n   * @param uniforms Uniforms array to fill\n   * @param attributes Attributes array to fill\n   * @param samplers Samplers array to fill\n   */\n  fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers) {\n    attributes.push(...GPUParticleSystem._GetAttributeNamesOrOptions(!!this._colorGradientsTexture, this._isAnimationSheetEnabled, this._isBillboardBased, this._isBillboardBased && this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED));\n    uniforms.push(...GPUParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled, this.useLogarithmicDepth));\n    samplers.push(\"diffuseSampler\", \"colorGradientSampler\");\n    if (this._imageProcessingConfiguration) {\n      ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);\n      ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);\n    }\n  }\n  /**\n   * Animates the particle system for the current frame by emitting new particles and or animating the living ones.\n   * @param preWarm defines if we are in the pre-warmimg phase\n   */\n  animate(preWarm = false) {\n    var _a;\n    this._timeDelta = this.updateSpeed * (preWarm ? this.preWarmStepOffset : ((_a = this._scene) === null || _a === void 0 ? void 0 : _a.getAnimationRatio()) || 1);\n    this._actualFrame += this._timeDelta;\n    if (!this._stopped) {\n      if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {\n        this.stop();\n      }\n    }\n    if (this.updateInAnimate) {\n      this._update();\n    }\n  }\n  _createFactorGradientTexture(factorGradients, textureName) {\n    const texture = this[textureName];\n    if (!factorGradients || !factorGradients.length || texture) {\n      return;\n    }\n    const data = new Float32Array(this._rawTextureWidth);\n    for (let x = 0; x < this._rawTextureWidth; x++) {\n      const ratio = x / this._rawTextureWidth;\n      GradientHelper.GetCurrentGradient(ratio, factorGradients, (currentGradient, nextGradient, scale) => {\n        data[x] = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);\n      });\n    }\n    this[textureName] = RawTexture.CreateRTexture(data, this._rawTextureWidth, 1, this._scene || this._engine, false, false, 1);\n    this[textureName].name = textureName.substring(1);\n  }\n  _createSizeGradientTexture() {\n    this._createFactorGradientTexture(this._sizeGradients, \"_sizeGradientsTexture\");\n  }\n  _createAngularSpeedGradientTexture() {\n    this._createFactorGradientTexture(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\");\n  }\n  _createVelocityGradientTexture() {\n    this._createFactorGradientTexture(this._velocityGradients, \"_velocityGradientsTexture\");\n  }\n  _createLimitVelocityGradientTexture() {\n    this._createFactorGradientTexture(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\");\n  }\n  _createDragGradientTexture() {\n    this._createFactorGradientTexture(this._dragGradients, \"_dragGradientsTexture\");\n  }\n  _createColorGradientTexture() {\n    if (!this._colorGradients || !this._colorGradients.length || this._colorGradientsTexture) {\n      return;\n    }\n    const data = new Uint8Array(this._rawTextureWidth * 4);\n    const tmpColor = TmpColors.Color4[0];\n    for (let x = 0; x < this._rawTextureWidth; x++) {\n      const ratio = x / this._rawTextureWidth;\n      GradientHelper.GetCurrentGradient(ratio, this._colorGradients, (currentGradient, nextGradient, scale) => {\n        Color4.LerpToRef(currentGradient.color1, nextGradient.color1, scale, tmpColor);\n        data[x * 4] = tmpColor.r * 255;\n        data[x * 4 + 1] = tmpColor.g * 255;\n        data[x * 4 + 2] = tmpColor.b * 255;\n        data[x * 4 + 3] = tmpColor.a * 255;\n      });\n    }\n    this._colorGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, 1);\n    this._colorGradientsTexture.name = \"colorGradients\";\n  }\n  _render(blendMode, emitterWM) {\n    var _a, _b, _c, _d, _e;\n    // Enable render effect\n    const drawWrapper = this._getWrapper(blendMode);\n    const effect = drawWrapper.effect;\n    this._engine.enableEffect(drawWrapper);\n    const viewMatrix = ((_a = this._scene) === null || _a === void 0 ? void 0 : _a.getViewMatrix()) || Matrix.IdentityReadOnly;\n    effect.setMatrix(\"view\", viewMatrix);\n    effect.setMatrix(\"projection\", (_b = this.defaultProjectionMatrix) !== null && _b !== void 0 ? _b : this._scene.getProjectionMatrix());\n    effect.setTexture(\"diffuseSampler\", this.particleTexture);\n    effect.setVector2(\"translationPivot\", this.translationPivot);\n    effect.setVector3(\"worldOffset\", this.worldOffset);\n    if (this.isLocal) {\n      effect.setMatrix(\"emitterWM\", emitterWM);\n    }\n    if (this._colorGradientsTexture) {\n      effect.setTexture(\"colorGradientSampler\", this._colorGradientsTexture);\n    } else {\n      effect.setDirectColor4(\"colorDead\", this.colorDead);\n    }\n    if (this._isAnimationSheetEnabled && this.particleTexture) {\n      const baseSize = this.particleTexture.getBaseSize();\n      effect.setFloat3(\"sheetInfos\", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, baseSize.width / this.spriteCellWidth);\n    }\n    if (this._isBillboardBased && this._scene) {\n      const camera = this._scene.activeCamera;\n      effect.setVector3(\"eyePosition\", camera.globalPosition);\n    }\n    const defines = effect.defines;\n    if (this._scene) {\n      bindClipPlane(effect, this, this._scene);\n    }\n    if (defines.indexOf(\"#define BILLBOARDMODE_ALL\") >= 0) {\n      const invView = viewMatrix.clone();\n      invView.invert();\n      effect.setMatrix(\"invView\", invView);\n    }\n    // Log. depth\n    if (this.useLogarithmicDepth && this._scene) {\n      MaterialHelper.BindLogDepth(defines, effect, this._scene);\n    }\n    // image processing\n    if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\n      this._imageProcessingConfiguration.bind(effect);\n    }\n    // Draw order\n    switch (blendMode) {\n      case ParticleSystem.BLENDMODE_ADD:\n        this._engine.setAlphaMode(1);\n        break;\n      case ParticleSystem.BLENDMODE_ONEONE:\n        this._engine.setAlphaMode(6);\n        break;\n      case ParticleSystem.BLENDMODE_STANDARD:\n        this._engine.setAlphaMode(2);\n        break;\n      case ParticleSystem.BLENDMODE_MULTIPLY:\n        this._engine.setAlphaMode(4);\n        break;\n    }\n    // Bind source VAO\n    this._platform.bindDrawBuffers(this._targetIndex, effect, ((_c = this._scene) === null || _c === void 0 ? void 0 : _c.forceWireframe) ? this._linesIndexBufferUseInstancing : null);\n    if (this._onBeforeDrawParticlesObservable) {\n      this._onBeforeDrawParticlesObservable.notifyObservers(effect);\n    }\n    // Render\n    if ((_d = this._scene) === null || _d === void 0 ? void 0 : _d.forceWireframe) {\n      this._engine.drawElementsType(6, 0, 10, this._currentActiveCount);\n    } else {\n      this._engine.drawArraysType(7, 0, 4, this._currentActiveCount);\n    }\n    this._engine.setAlphaMode(0);\n    if ((_e = this._scene) === null || _e === void 0 ? void 0 : _e.forceWireframe) {\n      this._engine.unbindInstanceAttributes();\n    }\n    return this._currentActiveCount;\n  }\n  /** @internal */\n  _update(emitterWM) {\n    if (!this.emitter || !this._targetBuffer) {\n      return;\n    }\n    if (!this._recreateUpdateEffect()) {\n      return;\n    }\n    if (!emitterWM) {\n      if (this.emitter.position) {\n        const emitterMesh = this.emitter;\n        emitterWM = emitterMesh.getWorldMatrix();\n      } else {\n        const emitterPosition = this.emitter;\n        emitterWM = TmpVectors.Matrix[0];\n        Matrix.TranslationToRef(emitterPosition.x, emitterPosition.y, emitterPosition.z, emitterWM);\n      }\n    }\n    this._platform.preUpdateParticleBuffer();\n    this._updateBuffer.setFloat(\"currentCount\", this._currentActiveCount);\n    this._updateBuffer.setFloat(\"timeDelta\", this._timeDelta);\n    this._updateBuffer.setFloat(\"stopFactor\", this._stopped ? 0 : 1);\n    this._updateBuffer.setInt(\"randomTextureSize\", this._randomTextureSize);\n    this._updateBuffer.setFloat2(\"lifeTime\", this.minLifeTime, this.maxLifeTime);\n    this._updateBuffer.setFloat2(\"emitPower\", this.minEmitPower, this.maxEmitPower);\n    if (!this._colorGradientsTexture) {\n      this._updateBuffer.setDirectColor4(\"color1\", this.color1);\n      this._updateBuffer.setDirectColor4(\"color2\", this.color2);\n    }\n    this._updateBuffer.setFloat2(\"sizeRange\", this.minSize, this.maxSize);\n    this._updateBuffer.setFloat4(\"scaleRange\", this.minScaleX, this.maxScaleX, this.minScaleY, this.maxScaleY);\n    this._updateBuffer.setFloat4(\"angleRange\", this.minAngularSpeed, this.maxAngularSpeed, this.minInitialRotation, this.maxInitialRotation);\n    this._updateBuffer.setVector3(\"gravity\", this.gravity);\n    if (this._limitVelocityGradientsTexture) {\n      this._updateBuffer.setFloat(\"limitVelocityDamping\", this.limitVelocityDamping);\n    }\n    if (this.particleEmitterType) {\n      this.particleEmitterType.applyToShader(this._updateBuffer);\n    }\n    if (this._isAnimationSheetEnabled) {\n      this._updateBuffer.setFloat4(\"cellInfos\", this.startSpriteCellID, this.endSpriteCellID, this.spriteCellChangeSpeed, this.spriteCellLoop ? 1 : 0);\n    }\n    if (this.noiseTexture) {\n      this._updateBuffer.setVector3(\"noiseStrength\", this.noiseStrength);\n    }\n    if (!this.isLocal) {\n      this._updateBuffer.setMatrix(\"emitterWM\", emitterWM);\n    }\n    this._platform.updateParticleBuffer(this._targetIndex, this._targetBuffer, this._currentActiveCount);\n    // Switch VAOs\n    this._targetIndex++;\n    if (this._targetIndex === 2) {\n      this._targetIndex = 0;\n    }\n    // Switch buffers\n    const tmpBuffer = this._sourceBuffer;\n    this._sourceBuffer = this._targetBuffer;\n    this._targetBuffer = tmpBuffer;\n  }\n  /**\n   * Renders the particle system in its current state\n   * @param preWarm defines if the system should only update the particles but not render them\n   * @param forceUpdateOnly if true, force to only update the particles and never display them (meaning, even if preWarm=false, when forceUpdateOnly=true the particles won't be displayed)\n   * @returns the current number of particles\n   */\n  render(preWarm = false, forceUpdateOnly = false) {\n    if (!this._started) {\n      return 0;\n    }\n    if (!this.isReady()) {\n      return 0;\n    }\n    if (!preWarm && this._scene) {\n      if (!this._preWarmDone && this.preWarmCycles) {\n        for (let index = 0; index < this.preWarmCycles; index++) {\n          this.animate(true);\n          this.render(true, true);\n        }\n        this._preWarmDone = true;\n      }\n      if (this._currentRenderId === this._scene.getRenderId() && (!this._scene.activeCamera || this._scene.activeCamera && this._currentRenderingCameraUniqueId === this._scene.activeCamera.uniqueId)) {\n        return 0;\n      }\n      this._currentRenderId = this._scene.getRenderId();\n      if (this._scene.activeCamera) {\n        this._currentRenderingCameraUniqueId = this._scene.activeCamera.uniqueId;\n      }\n    }\n    // Get everything ready to render\n    this._initialize();\n    this._accumulatedCount += this.emitRate * this._timeDelta;\n    if (this._accumulatedCount > 1) {\n      const intPart = this._accumulatedCount | 0;\n      this._accumulatedCount -= intPart;\n      this._currentActiveCount += intPart;\n    }\n    this._currentActiveCount = Math.min(this._maxActiveParticleCount, this._currentActiveCount);\n    if (!this._currentActiveCount) {\n      return 0;\n    }\n    // Enable update effect\n    let emitterWM;\n    if (this.emitter.position) {\n      const emitterMesh = this.emitter;\n      emitterWM = emitterMesh.getWorldMatrix();\n    } else {\n      const emitterPosition = this.emitter;\n      emitterWM = TmpVectors.Matrix[0];\n      Matrix.TranslationToRef(emitterPosition.x, emitterPosition.y, emitterPosition.z, emitterWM);\n    }\n    const engine = this._engine;\n    if (!this.updateInAnimate) {\n      this._update(emitterWM);\n    }\n    let outparticles = 0;\n    if (!preWarm && !forceUpdateOnly) {\n      engine.setState(false);\n      if (this.forceDepthWrite) {\n        engine.setDepthWrite(true);\n      }\n      if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLYADD) {\n        outparticles = this._render(ParticleSystem.BLENDMODE_MULTIPLY, emitterWM) + this._render(ParticleSystem.BLENDMODE_ADD, emitterWM);\n      } else {\n        outparticles = this._render(this.blendMode, emitterWM);\n      }\n      this._engine.setAlphaMode(0);\n    }\n    return outparticles;\n  }\n  /**\n   * Rebuilds the particle system\n   */\n  rebuild() {\n    const checkUpdateEffect = () => {\n      if (!this._recreateUpdateEffect() || !this._platform.isUpdateBufferReady()) {\n        setTimeout(checkUpdateEffect, 10);\n      } else {\n        this._initialize(true);\n      }\n    };\n    this._createIndexBuffer();\n    this._cachedUpdateDefines = \"\";\n    this._platform.contextLost();\n    checkUpdateEffect();\n  }\n  _releaseBuffers() {\n    if (this._buffer0) {\n      this._buffer0.dispose();\n      this._buffer0 = null;\n    }\n    if (this._buffer1) {\n      this._buffer1.dispose();\n      this._buffer1 = null;\n    }\n    if (this._spriteBuffer) {\n      this._spriteBuffer.dispose();\n      this._spriteBuffer = null;\n    }\n    this._platform.releaseBuffers();\n  }\n  /**\n   * Disposes the particle system and free the associated resources\n   * @param disposeTexture defines if the particule texture must be disposed as well (true by default)\n   */\n  dispose(disposeTexture = true) {\n    for (const blendMode in this._drawWrappers) {\n      const drawWrapper = this._drawWrappers[blendMode];\n      drawWrapper.dispose();\n    }\n    this._drawWrappers = {};\n    if (this._scene) {\n      const index = this._scene.particleSystems.indexOf(this);\n      if (index > -1) {\n        this._scene.particleSystems.splice(index, 1);\n      }\n    }\n    this._releaseBuffers();\n    this._platform.releaseVertexBuffers();\n    for (let i = 0; i < this._renderVertexBuffers.length; ++i) {\n      const rvb = this._renderVertexBuffers[i];\n      for (const key in rvb) {\n        rvb[key].dispose();\n      }\n    }\n    this._renderVertexBuffers = [];\n    if (this._colorGradientsTexture) {\n      this._colorGradientsTexture.dispose();\n      this._colorGradientsTexture = null;\n    }\n    if (this._sizeGradientsTexture) {\n      this._sizeGradientsTexture.dispose();\n      this._sizeGradientsTexture = null;\n    }\n    if (this._angularSpeedGradientsTexture) {\n      this._angularSpeedGradientsTexture.dispose();\n      this._angularSpeedGradientsTexture = null;\n    }\n    if (this._velocityGradientsTexture) {\n      this._velocityGradientsTexture.dispose();\n      this._velocityGradientsTexture = null;\n    }\n    if (this._limitVelocityGradientsTexture) {\n      this._limitVelocityGradientsTexture.dispose();\n      this._limitVelocityGradientsTexture = null;\n    }\n    if (this._dragGradientsTexture) {\n      this._dragGradientsTexture.dispose();\n      this._dragGradientsTexture = null;\n    }\n    if (this._randomTexture) {\n      this._randomTexture.dispose();\n      this._randomTexture = null;\n    }\n    if (this._randomTexture2) {\n      this._randomTexture2.dispose();\n      this._randomTexture2 = null;\n    }\n    if (disposeTexture && this.particleTexture) {\n      this.particleTexture.dispose();\n      this.particleTexture = null;\n    }\n    if (disposeTexture && this.noiseTexture) {\n      this.noiseTexture.dispose();\n      this.noiseTexture = null;\n    }\n    // Callback\n    this.onStoppedObservable.clear();\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n  }\n  /**\n   * Clones the particle system.\n   * @param name The name of the cloned object\n   * @param newEmitter The new emitter to use\n   * @param cloneTexture Also clone the textures if true\n   * @returns the cloned particle system\n   */\n  clone(name, newEmitter, cloneTexture = false) {\n    const custom = Object.assign({}, this._customWrappers);\n    let program = null;\n    const engine = this._engine;\n    if (engine.createEffectForParticles) {\n      if (this.customShader != null) {\n        program = this.customShader;\n        const defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n        custom[0] = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines, undefined, undefined, undefined, this);\n      }\n    }\n    const serialization = this.serialize(cloneTexture);\n    const result = GPUParticleSystem.Parse(serialization, this._scene || this._engine, this._rootUrl);\n    result.name = name;\n    result.customShader = program;\n    result._customWrappers = custom;\n    if (newEmitter === undefined) {\n      newEmitter = this.emitter;\n    }\n    if (this.noiseTexture) {\n      result.noiseTexture = this.noiseTexture.clone();\n    }\n    result.emitter = newEmitter;\n    return result;\n  }\n  /**\n   * Serializes the particle system to a JSON object\n   * @param serializeTexture defines if the texture must be serialized as well\n   * @returns the JSON object\n   */\n  serialize(serializeTexture = false) {\n    const serializationObject = {};\n    ParticleSystem._Serialize(serializationObject, this, serializeTexture);\n    serializationObject.activeParticleCount = this.activeParticleCount;\n    serializationObject.randomTextureSize = this._randomTextureSize;\n    serializationObject.customShader = this.customShader;\n    return serializationObject;\n  }\n  /**\n   * Parses a JSON object to create a GPU particle system.\n   * @param parsedParticleSystem The JSON object to parse\n   * @param sceneOrEngine The scene or the engine to create the particle system in\n   * @param rootUrl The root url to use to load external dependencies like texture\n   * @param doNotStart Ignore the preventAutoStart attribute and does not start\n   * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n   * @returns the parsed GPU particle system\n   */\n  static Parse(parsedParticleSystem, sceneOrEngine, rootUrl, doNotStart = false, capacity) {\n    const name = parsedParticleSystem.name;\n    let engine;\n    let scene;\n    if (sceneOrEngine instanceof ThinEngine) {\n      engine = sceneOrEngine;\n    } else {\n      scene = sceneOrEngine;\n      engine = scene.getEngine();\n    }\n    const particleSystem = new GPUParticleSystem(name, {\n      capacity: capacity || parsedParticleSystem.capacity,\n      randomTextureSize: parsedParticleSystem.randomTextureSize\n    }, sceneOrEngine, null, parsedParticleSystem.isAnimationSheetEnabled);\n    particleSystem._rootUrl = rootUrl;\n    if (parsedParticleSystem.customShader && engine.createEffectForParticles) {\n      const program = parsedParticleSystem.customShader;\n      const defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n      const custom = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines, undefined, undefined, undefined, particleSystem);\n      particleSystem.setCustomEffect(custom, 0);\n      particleSystem.customShader = program;\n    }\n    if (parsedParticleSystem.id) {\n      particleSystem.id = parsedParticleSystem.id;\n    }\n    if (parsedParticleSystem.activeParticleCount) {\n      particleSystem.activeParticleCount = parsedParticleSystem.activeParticleCount;\n    }\n    ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);\n    // Auto start\n    if (parsedParticleSystem.preventAutoStart) {\n      particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;\n    }\n    if (!doNotStart && !particleSystem.preventAutoStart) {\n      particleSystem.start();\n    }\n    return particleSystem;\n  }\n}","map":{"version":3,"names":["FactorGradient","ColorGradient","GradientHelper","Observable","Matrix","TmpVectors","Color4","TmpColors","Scalar","VertexBuffer","Buffer","BaseParticleSystem","ParticleSystem","BoxParticleEmitter","MaterialHelper","ImageProcessingConfiguration","RawTexture","EngineStore","CustomParticleEmitter","ThinEngine","DrawWrapper","GetClass","addClipPlaneUniforms","bindClipPlane","prepareStringDefinesForClipPlanes","GPUParticleSystem","IsSupported","LastCreatedEngine","caps","getCaps","supportTransformFeedbacks","supportComputeShaders","_createIndexBuffer","_linesIndexBufferUseInstancing","_engine","createIndexBuffer","Uint32Array","getCapacity","_capacity","maxActiveParticleCount","_maxActiveParticleCount","value","Math","min","activeParticleCount","isReady","emitter","_imageProcessingConfiguration","particleTexture","blendMode","BLENDMODE_MULTIPLYADD","_getWrapper","effect","BLENDMODE_MULTIPLY","BLENDMODE_ADD","_platform","isUpdateBufferCreated","_recreateUpdateEffect","isUpdateBufferReady","isStarted","_started","isStopped","_stopped","isStopping","getActiveCount","_currentActiveCount","start","delay","startDelay","targetStopDuration","_hasTargetStopDurationDependantGradient","setTimeout","_preWarmDone","beginAnimationOnStart","animations","length","_scene","beginAnimation","beginAnimationFrom","beginAnimationTo","beginAnimationLoop","stop","reset","_releaseBuffers","releaseVertexBuffers","_targetIndex","getClassName","getCustomEffect","_b","_a","_customWrappers","_getCustomDrawWrapper","setCustomEffect","onBeforeDrawParticlesObservable","_onBeforeDrawParticlesObservable","vertexShaderName","vertexBuffers","_renderVertexBuffers","indexBuffer","_removeGradientAndTexture","gradient","gradients","texture","addColorGradient","color1","_colorGradients","colorGradient","push","_refreshColorGradient","reorder","sort","a","b","_colorGradientsTexture","dispose","forceRefreshGradients","_refreshFactorGradient","_sizeGradients","_angularSpeedGradients","_velocityGradients","_limitVelocityGradients","_dragGradients","removeColorGradient","resetDrawCache","_drawWrappers","drawWrapper","drawContext","_addFactorGradient","factorGradients","factor","valueGradient","addSizeGradient","removeSizeGradient","_sizeGradientsTexture","textureName","that","addAngularSpeedGradient","removeAngularSpeedGradient","_angularSpeedGradientsTexture","addVelocityGradient","removeVelocityGradient","_velocityGradientsTexture","addLimitVelocityGradient","removeLimitVelocityGradient","_limitVelocityGradientsTexture","addDragGradient","removeDragGradient","_dragGradientsTexture","addEmitRateGradient","removeEmitRateGradient","addStartSizeGradient","removeStartSizeGradient","addColorRemapGradient","removeColorRemapGradient","addAlphaRemapGradient","removeAlphaRemapGradient","addRampGradient","removeRampGradient","getRampGradients","useRampGradients","addLifeTimeGradient","removeLifeTimeGradient","constructor","name","options","sceneOrEngine","customEffect","isAnimationSheetEnabled","layerMask","_accumulatedCount","_currentRenderId","_currentRenderingCameraUniqueId","_timeDelta","updateInAnimate","_actualFrame","_rawTextureWidth","onDisposeObservable","onStoppedObservable","forceDepthWrite","isLocal","isGPU","LastCreatedScene","getEngine","uniqueId","getUniqueId","particleSystems","defaultProjectionMatrix","PerspectiveFovLH","isNDCHalfZRange","Error","useInstancing","_attachImageProcessingConfiguration","randomTextureSize","fullOptions","Object","assign","capacity","maxTextureSize","optionsAsNumber","isFinite","_isAnimationSheetEnabled","particleEmitterType","d","i","random","_randomTexture","Float32Array","wrapU","wrapV","_randomTexture2","_randomTextureSize","_reset","_createVertexBuffers","updateBuffer","renderBuffer","spriteSource","renderVertexBuffers","createVertexBuffer","_attributesStrideSize","offset","billboardMode","BILLBOARDMODE_STRETCHED","alignDataInBuffer","_isBillboardBased","noiseTexture","spriteRandomStartCell","createVertexBuffers","_initialize","force","_buffer0","engine","data","Array","isBillboardBased","usingCustomEmitter","tmpVector","Vector3","particleIndex","particleDestinationGenerator","x","y","z","particlePositionGenerator","numDummies","spriteData","bufferData1","createParticleBuffer","bufferData2","_buffer1","_spriteBuffer","_sourceBuffer","_targetBuffer","_createColorGradientTexture","_createSizeGradientTexture","_createAngularSpeedGradientTexture","_createVelocityGradientTexture","_createLimitVelocityGradientTexture","_createDragGradientTexture","defines","getEffectDefines","_cachedUpdateDefines","_updateBuffer","createUpdateBuffer","customWrapper","fillDefines","join","attributes","uniforms","samplers","fillUniformsAttributesAndSamplerNames","setEffect","createEffect","_GetAttributeNamesOrOptions","hasColorGradients","isBillboardStretched","attributeNamesOrOptions","PositionKind","ColorKind","UVKind","_GetEffectCreationOptions","useLogarithmicDepth","effectCreationOption","BILLBOARDMODE_Y","BILLBOARDMODE_ALL","prepareDefines","_imageProcessingConfigurationDefines","toString","PrepareUniforms","PrepareSamplers","animate","preWarm","updateSpeed","preWarmStepOffset","getAnimationRatio","_update","_createFactorGradientTexture","ratio","GetCurrentGradient","currentGradient","nextGradient","scale","Lerp","factor1","CreateRTexture","substring","Uint8Array","tmpColor","LerpToRef","r","g","CreateRGBATexture","_render","emitterWM","enableEffect","viewMatrix","getViewMatrix","IdentityReadOnly","setMatrix","getProjectionMatrix","setTexture","setVector2","translationPivot","setVector3","worldOffset","setDirectColor4","colorDead","baseSize","getBaseSize","setFloat3","spriteCellWidth","width","spriteCellHeight","height","camera","activeCamera","globalPosition","indexOf","invView","clone","invert","BindLogDepth","applyByPostProcess","bind","setAlphaMode","BLENDMODE_ONEONE","BLENDMODE_STANDARD","bindDrawBuffers","_c","forceWireframe","notifyObservers","_d","drawElementsType","drawArraysType","_e","unbindInstanceAttributes","position","emitterMesh","getWorldMatrix","emitterPosition","TranslationToRef","preUpdateParticleBuffer","setFloat","setInt","setFloat2","minLifeTime","maxLifeTime","minEmitPower","maxEmitPower","color2","minSize","maxSize","setFloat4","minScaleX","maxScaleX","minScaleY","maxScaleY","minAngularSpeed","maxAngularSpeed","minInitialRotation","maxInitialRotation","gravity","limitVelocityDamping","applyToShader","startSpriteCellID","endSpriteCellID","spriteCellChangeSpeed","spriteCellLoop","noiseStrength","updateParticleBuffer","tmpBuffer","render","forceUpdateOnly","preWarmCycles","index","getRenderId","emitRate","intPart","outparticles","setState","setDepthWrite","rebuild","checkUpdateEffect","contextLost","releaseBuffers","disposeTexture","splice","rvb","key","clear","newEmitter","cloneTexture","custom","program","createEffectForParticles","customShader","shaderOptions","shaderPath","fragmentElement","undefined","serialization","serialize","result","Parse","_rootUrl","serializeTexture","serializationObject","_Serialize","parsedParticleSystem","rootUrl","doNotStart","scene","particleSystem","id","_Parse","preventAutoStart"],"sources":["../../../../dev/core/src/Particles/gpuParticleSystem.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Immutable, Nullable, float, DataArray } from \"../types\";\r\nimport type { Color3Gradient, IValueGradient } from \"../Misc/gradients\";\r\nimport { FactorGradient, ColorGradient, GradientHelper } from \"../Misc/gradients\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport { Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Color4, TmpColors } from \"../Maths/math.color\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer\";\r\n\r\nimport type { IParticleSystem } from \"./IParticleSystem\";\r\nimport { BaseParticleSystem } from \"./baseParticleSystem\";\r\nimport { ParticleSystem } from \"./particleSystem\";\r\nimport { BoxParticleEmitter } from \"../Particles/EmitterTypes/boxParticleEmitter\";\r\nimport type { IDisposable } from \"../scene\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { CustomParticleEmitter } from \"./EmitterTypes/customParticleEmitter\";\r\nimport { ThinEngine } from \"../Engines/thinEngine\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { IGPUParticleSystemPlatform } from \"./IGPUParticleSystemPlatform\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\n\r\nimport \"../Engines/Extensions/engine.transformFeedback\";\r\n\r\nimport \"../Shaders/gpuRenderParticles.fragment\";\r\nimport \"../Shaders/gpuRenderParticles.vertex\";\r\n\r\n/**\r\n * This represents a GPU particle system in Babylon\r\n * This is the fastest particle system in Babylon as it uses the GPU to update the individual particle data\r\n * @see https://www.babylonjs-playground.com/#PU4WYI#4\r\n */\r\nexport class GPUParticleSystem extends BaseParticleSystem implements IDisposable, IParticleSystem, IAnimatable {\r\n    /**\r\n     * The layer mask we are rendering the particles through.\r\n     */\r\n    public layerMask: number = 0x0fffffff;\r\n\r\n    private _capacity: number;\r\n    private _maxActiveParticleCount: number;\r\n    private _currentActiveCount: number;\r\n    private _accumulatedCount = 0;\r\n    private _updateBuffer: UniformBufferEffectCommonAccessor;\r\n\r\n    private _buffer0: Buffer;\r\n    private _buffer1: Buffer;\r\n    private _spriteBuffer: Buffer;\r\n    private _renderVertexBuffers: Array<{ [key: string]: VertexBuffer }> = [];\r\n    private _linesIndexBufferUseInstancing: Nullable<DataBuffer>;\r\n\r\n    private _targetIndex = 0;\r\n    private _sourceBuffer: Buffer;\r\n    private _targetBuffer: Buffer;\r\n\r\n    private _currentRenderId = -1;\r\n    private _currentRenderingCameraUniqueId = -1;\r\n    private _started = false;\r\n    private _stopped = false;\r\n\r\n    private _timeDelta = 0;\r\n\r\n    /** @internal */\r\n    public _randomTexture: RawTexture;\r\n    /** @internal */\r\n    public _randomTexture2: RawTexture;\r\n\r\n    /** Indicates that the update of particles is done in the animate function (and not in render). Default: false */\r\n    public updateInAnimate = false;\r\n\r\n    private _attributesStrideSize: number;\r\n    private _cachedUpdateDefines: string;\r\n\r\n    private _randomTextureSize: number;\r\n    private _actualFrame = 0;\r\n    private _drawWrappers: { [blendMode: number]: DrawWrapper };\r\n    private _customWrappers: { [blendMode: number]: Nullable<DrawWrapper> };\r\n\r\n    private readonly _rawTextureWidth = 256;\r\n\r\n    private _platform: IGPUParticleSystemPlatform;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the GPU particles can be rendered on current browser\r\n     */\r\n    public static get IsSupported(): boolean {\r\n        if (!EngineStore.LastCreatedEngine) {\r\n            return false;\r\n        }\r\n        const caps = EngineStore.LastCreatedEngine.getCaps();\r\n\r\n        return caps.supportTransformFeedbacks || caps.supportComputeShaders;\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the system is disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<IParticleSystem>();\r\n    /**\r\n     * An event triggered when the system is stopped\r\n     */\r\n    public onStoppedObservable = new Observable<IParticleSystem>();\r\n\r\n    private _createIndexBuffer() {\r\n        this._linesIndexBufferUseInstancing = this._engine.createIndexBuffer(new Uint32Array([0, 1, 1, 3, 3, 2, 2, 0, 0, 3]));\r\n    }\r\n\r\n    /**\r\n     * Gets the maximum number of particles active at the same time.\r\n     * @returns The max number of active particles.\r\n     */\r\n    public getCapacity(): number {\r\n        return this._capacity;\r\n    }\r\n\r\n    /**\r\n     * Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls\r\n     * to override the particles.\r\n     */\r\n    public forceDepthWrite = false;\r\n\r\n    /**\r\n     * Gets or set the number of active particles\r\n     * The value cannot be greater than \"capacity\" (if it is, it will be limited to \"capacity\").\r\n     */\r\n    public get maxActiveParticleCount(): number {\r\n        return this._maxActiveParticleCount;\r\n    }\r\n\r\n    public set maxActiveParticleCount(value: number) {\r\n        this._maxActiveParticleCount = Math.min(value, this._capacity);\r\n    }\r\n\r\n    /**\r\n     * Gets or set the number of active particles\r\n     * @deprecated Please use maxActiveParticleCount instead.\r\n     */\r\n    public get activeParticleCount(): number {\r\n        return this.maxActiveParticleCount;\r\n    }\r\n\r\n    public set activeParticleCount(value: number) {\r\n        this.maxActiveParticleCount = value;\r\n    }\r\n\r\n    private _preWarmDone = false;\r\n\r\n    /**\r\n     * Specifies if the particles are updated in emitter local space or world space.\r\n     */\r\n    public isLocal = false;\r\n\r\n    /** Indicates that the particle system is GPU based */\r\n    public readonly isGPU = true;\r\n\r\n    /** Gets or sets a matrix to use to compute projection */\r\n    public defaultProjectionMatrix: Matrix;\r\n\r\n    /**\r\n     * Is this system ready to be used/rendered\r\n     * @returns true if the system is ready\r\n     */\r\n    public isReady(): boolean {\r\n        if (!this.emitter || (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady()) || !this.particleTexture || !this.particleTexture.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        if (this.blendMode !== ParticleSystem.BLENDMODE_MULTIPLYADD) {\r\n            if (!this._getWrapper(this.blendMode).effect!.isReady()) {\r\n                return false;\r\n            }\r\n        } else {\r\n            if (!this._getWrapper(ParticleSystem.BLENDMODE_MULTIPLY).effect!.isReady()) {\r\n                return false;\r\n            }\r\n            if (!this._getWrapper(ParticleSystem.BLENDMODE_ADD).effect!.isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (!this._platform.isUpdateBufferCreated()) {\r\n            this._recreateUpdateEffect();\r\n            return false;\r\n        }\r\n\r\n        return this._platform.isUpdateBufferReady();\r\n    }\r\n\r\n    /**\r\n     * Gets if the system has been started. (Note: this will still be true after stop is called)\r\n     * @returns True if it has been started, otherwise false.\r\n     */\r\n    public isStarted(): boolean {\r\n        return this._started;\r\n    }\r\n\r\n    /**\r\n     * Gets if the system has been stopped. (Note: rendering is still happening but the system is frozen)\r\n     * @returns True if it has been stopped, otherwise false.\r\n     */\r\n    public isStopped(): boolean {\r\n        return this._stopped;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the system is stopping\r\n     * @returns true if the system is currently stopping\r\n     */\r\n    public isStopping() {\r\n        return false; // Stop is immediate on GPU\r\n    }\r\n\r\n    /**\r\n     * Gets the number of particles active at the same time.\r\n     * @returns The number of active particles.\r\n     */\r\n    public getActiveCount() {\r\n        return this._currentActiveCount;\r\n    }\r\n\r\n    /**\r\n     * Starts the particle system and begins to emit\r\n     * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)\r\n     */\r\n    public start(delay = this.startDelay): void {\r\n        if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {\r\n            throw \"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set\";\r\n        }\r\n        if (delay) {\r\n            setTimeout(() => {\r\n                this.start(0);\r\n            }, delay);\r\n            return;\r\n        }\r\n        this._started = true;\r\n        this._stopped = false;\r\n        this._preWarmDone = false;\r\n\r\n        // Animations\r\n        if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {\r\n            this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops the particle system.\r\n     */\r\n    public stop(): void {\r\n        if (this._stopped) {\r\n            return;\r\n        }\r\n        this._stopped = true;\r\n    }\r\n\r\n    /**\r\n     * Remove all active particles\r\n     */\r\n    public reset(): void {\r\n        this._releaseBuffers();\r\n        this._platform.releaseVertexBuffers();\r\n        this._currentActiveCount = 0;\r\n        this._targetIndex = 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"GPUParticleSystem\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"GPUParticleSystem\";\r\n    }\r\n\r\n    /**\r\n     * Gets the custom effect used to render the particles\r\n     * @param blendMode Blend mode for which the effect should be retrieved\r\n     * @returns The effect\r\n     */\r\n    public getCustomEffect(blendMode: number = 0): Nullable<Effect> {\r\n        return this._customWrappers[blendMode]?.effect ?? this._customWrappers[0]!.effect;\r\n    }\r\n\r\n    private _getCustomDrawWrapper(blendMode: number = 0): Nullable<DrawWrapper> {\r\n        return this._customWrappers[blendMode] ?? this._customWrappers[0];\r\n    }\r\n\r\n    /**\r\n     * Sets the custom effect used to render the particles\r\n     * @param effect The effect to set\r\n     * @param blendMode Blend mode for which the effect should be set\r\n     */\r\n    public setCustomEffect(effect: Nullable<Effect>, blendMode: number = 0) {\r\n        this._customWrappers[blendMode] = new DrawWrapper(this._engine);\r\n        this._customWrappers[blendMode]!.effect = effect;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _onBeforeDrawParticlesObservable: Nullable<Observable<Nullable<Effect>>> = null;\r\n\r\n    /**\r\n     * Observable that will be called just before the particles are drawn\r\n     */\r\n    public get onBeforeDrawParticlesObservable(): Observable<Nullable<Effect>> {\r\n        if (!this._onBeforeDrawParticlesObservable) {\r\n            this._onBeforeDrawParticlesObservable = new Observable<Nullable<Effect>>();\r\n        }\r\n\r\n        return this._onBeforeDrawParticlesObservable;\r\n    }\r\n\r\n    /**\r\n     * Gets the name of the particle vertex shader\r\n     */\r\n    public get vertexShaderName(): string {\r\n        return \"gpuRenderParticles\";\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex buffers used by the particle system\r\n     * Should be called after render() has been called for the current frame so that the buffers returned are the ones that have been updated\r\n     * in the current frame (there's a ping-pong between two sets of buffers - for a given frame, one set is used as the source and the other as the destination)\r\n     */\r\n    public get vertexBuffers(): Immutable<{ [key: string]: VertexBuffer }> {\r\n        // We return the other buffers than those corresponding to this._targetIndex because it is assumed vertexBuffers will be called in the current frame\r\n        // after render() has been called, meaning that the buffers have already been swapped and this._targetIndex points to the buffers that will be updated\r\n        // in the next frame (and which are the sources in this frame) and (this._targetIndex ^ 1) points to the buffers that have been updated this frame\r\n        // (and that will be the source buffers in the next frame)\r\n        return this._renderVertexBuffers[this._targetIndex ^ 1];\r\n    }\r\n\r\n    /**\r\n     * Gets the index buffer used by the particle system (null for GPU particle systems)\r\n     */\r\n    public get indexBuffer(): Nullable<DataBuffer> {\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public _colorGradientsTexture: RawTexture;\r\n\r\n    protected _removeGradientAndTexture(gradient: number, gradients: Nullable<IValueGradient[]>, texture: RawTexture): BaseParticleSystem {\r\n        super._removeGradientAndTexture(gradient, gradients, texture);\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new color gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param color1 defines the color to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addColorGradient(gradient: number, color1: Color4): GPUParticleSystem {\r\n        if (!this._colorGradients) {\r\n            this._colorGradients = [];\r\n        }\r\n\r\n        const colorGradient = new ColorGradient(gradient, color1);\r\n        this._colorGradients.push(colorGradient);\r\n\r\n        this._refreshColorGradient(true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    private _refreshColorGradient(reorder = false) {\r\n        if (this._colorGradients) {\r\n            if (reorder) {\r\n                this._colorGradients.sort((a, b) => {\r\n                    if (a.gradient < b.gradient) {\r\n                        return -1;\r\n                    } else if (a.gradient > b.gradient) {\r\n                        return 1;\r\n                    }\r\n\r\n                    return 0;\r\n                });\r\n            }\r\n\r\n            if (this._colorGradientsTexture) {\r\n                this._colorGradientsTexture.dispose();\r\n                (<any>this._colorGradientsTexture) = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Force the system to rebuild all gradients that need to be resync */\r\n    public forceRefreshGradients() {\r\n        this._refreshColorGradient();\r\n        this._refreshFactorGradient(this._sizeGradients, \"_sizeGradientsTexture\");\r\n        this._refreshFactorGradient(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\");\r\n        this._refreshFactorGradient(this._velocityGradients, \"_velocityGradientsTexture\");\r\n        this._refreshFactorGradient(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\");\r\n        this._refreshFactorGradient(this._dragGradients, \"_dragGradientsTexture\");\r\n\r\n        this.reset();\r\n    }\r\n\r\n    /**\r\n     * Remove a specific color gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeColorGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._colorGradients, this._colorGradientsTexture);\r\n        (<any>this._colorGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache\r\n     */\r\n    public resetDrawCache(): void {\r\n        for (const blendMode in this._drawWrappers) {\r\n            const drawWrapper = this._drawWrappers[blendMode];\r\n            drawWrapper.drawContext?.reset();\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _angularSpeedGradientsTexture: RawTexture;\r\n    /** @internal */\r\n    public _sizeGradientsTexture: RawTexture;\r\n    /** @internal */\r\n    public _velocityGradientsTexture: RawTexture;\r\n    /** @internal */\r\n    public _limitVelocityGradientsTexture: RawTexture;\r\n    /** @internal */\r\n    public _dragGradientsTexture: RawTexture;\r\n\r\n    private _addFactorGradient(factorGradients: FactorGradient[], gradient: number, factor: number) {\r\n        const valueGradient = new FactorGradient(gradient, factor);\r\n        factorGradients.push(valueGradient);\r\n\r\n        this._releaseBuffers();\r\n    }\r\n\r\n    /**\r\n     * Adds a new size gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the size factor to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addSizeGradient(gradient: number, factor: number): GPUParticleSystem {\r\n        if (!this._sizeGradients) {\r\n            this._sizeGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._sizeGradients, gradient, factor);\r\n\r\n        this._refreshFactorGradient(this._sizeGradients, \"_sizeGradientsTexture\", true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific size gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeSizeGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._sizeGradients, this._sizeGradientsTexture);\r\n        (<any>this._sizeGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    private _refreshFactorGradient(factorGradients: Nullable<FactorGradient[]>, textureName: string, reorder = false) {\r\n        if (!factorGradients) {\r\n            return;\r\n        }\r\n\r\n        if (reorder) {\r\n            factorGradients.sort((a, b) => {\r\n                if (a.gradient < b.gradient) {\r\n                    return -1;\r\n                } else if (a.gradient > b.gradient) {\r\n                    return 1;\r\n                }\r\n\r\n                return 0;\r\n            });\r\n        }\r\n\r\n        const that = this as any;\r\n        if (that[textureName]) {\r\n            that[textureName].dispose();\r\n            that[textureName] = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a new angular speed gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the angular speed to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addAngularSpeedGradient(gradient: number, factor: number): GPUParticleSystem {\r\n        if (!this._angularSpeedGradients) {\r\n            this._angularSpeedGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._angularSpeedGradients, gradient, factor);\r\n        this._refreshFactorGradient(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\", true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific angular speed gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeAngularSpeedGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._angularSpeedGradients, this._angularSpeedGradientsTexture);\r\n        (<any>this._angularSpeedGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new velocity gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the velocity to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addVelocityGradient(gradient: number, factor: number): GPUParticleSystem {\r\n        if (!this._velocityGradients) {\r\n            this._velocityGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._velocityGradients, gradient, factor);\r\n        this._refreshFactorGradient(this._velocityGradients, \"_velocityGradientsTexture\", true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific velocity gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeVelocityGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._velocityGradients, this._velocityGradientsTexture);\r\n        (<any>this._velocityGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new limit velocity gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the limit velocity value to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addLimitVelocityGradient(gradient: number, factor: number): GPUParticleSystem {\r\n        if (!this._limitVelocityGradients) {\r\n            this._limitVelocityGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._limitVelocityGradients, gradient, factor);\r\n        this._refreshFactorGradient(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\", true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific limit velocity gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeLimitVelocityGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._limitVelocityGradients, this._limitVelocityGradientsTexture);\r\n        (<any>this._limitVelocityGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new drag gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the drag value to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addDragGradient(gradient: number, factor: number): GPUParticleSystem {\r\n        if (!this._dragGradients) {\r\n            this._dragGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._dragGradients, gradient, factor);\r\n        this._refreshFactorGradient(this._dragGradients, \"_dragGradientsTexture\", true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific drag gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeDragGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._dragGradients, this._dragGradientsTexture);\r\n        (<any>this._dragGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public addEmitRateGradient(): IParticleSystem {\r\n        // Do nothing as emit rate is not supported by GPUParticleSystem\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public removeEmitRateGradient(): IParticleSystem {\r\n        // Do nothing as emit rate is not supported by GPUParticleSystem\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public addStartSizeGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public removeStartSizeGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public addColorRemapGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public removeColorRemapGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public addAlphaRemapGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public removeAlphaRemapGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public addRampGradient(): IParticleSystem {\r\n        //Not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public removeRampGradient(): IParticleSystem {\r\n        //Not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the list of ramp gradients\r\n     */\r\n    public getRampGradients(): Nullable<Array<Color3Gradient>> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * Gets or sets a boolean indicating that ramp gradients must be used\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro#ramp-gradients\r\n     */\r\n    public get useRampGradients(): boolean {\r\n        //Not supported by GPUParticleSystem\r\n        return false;\r\n    }\r\n\r\n    public set useRampGradients(value: boolean) {\r\n        //Not supported by GPUParticleSystem\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public addLifeTimeGradient(): IParticleSystem {\r\n        //Not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public removeLifeTimeGradient(): IParticleSystem {\r\n        //Not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a GPU particle system.\r\n     * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n     * @param name The name of the particle system\r\n     * @param options The options used to create the system\r\n     * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene\r\n     * @param customEffect a custom effect used to change the way particles are rendered by default\r\n     * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture\r\n     */\r\n    constructor(\r\n        name: string,\r\n        options: Partial<{\r\n            capacity: number;\r\n            randomTextureSize: number;\r\n        }>,\r\n        sceneOrEngine: Scene | ThinEngine,\r\n        customEffect: Nullable<Effect> = null,\r\n        isAnimationSheetEnabled: boolean = false\r\n    ) {\r\n        super(name);\r\n\r\n        if (!sceneOrEngine || sceneOrEngine.getClassName() === \"Scene\") {\r\n            this._scene = (sceneOrEngine as Scene) || EngineStore.LastCreatedScene;\r\n            this._engine = this._scene.getEngine();\r\n            this.uniqueId = this._scene.getUniqueId();\r\n            this._scene.particleSystems.push(this);\r\n        } else {\r\n            this._engine = sceneOrEngine as ThinEngine;\r\n            this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100, this._engine.isNDCHalfZRange);\r\n        }\r\n\r\n        if (this._engine.getCaps().supportComputeShaders) {\r\n            if (!GetClass(\"BABYLON.ComputeShaderParticleSystem\")) {\r\n                throw new Error(\"The ComputeShaderParticleSystem class is not available! Make sure you have imported it.\");\r\n            }\r\n            this._platform = new (GetClass(\"BABYLON.ComputeShaderParticleSystem\") as any)(this, this._engine);\r\n        } else {\r\n            if (!GetClass(\"BABYLON.WebGL2ParticleSystem\")) {\r\n                throw new Error(\"The WebGL2ParticleSystem class is not available! Make sure you have imported it.\");\r\n            }\r\n            this._platform = new (GetClass(\"BABYLON.WebGL2ParticleSystem\") as any)(this, this._engine);\r\n        }\r\n\r\n        this._customWrappers = { 0: new DrawWrapper(this._engine) };\r\n        this._customWrappers[0]!.effect = customEffect;\r\n\r\n        this._drawWrappers = { 0: new DrawWrapper(this._engine) };\r\n        if (this._drawWrappers[0].drawContext) {\r\n            this._drawWrappers[0].drawContext.useInstancing = true;\r\n        }\r\n\r\n        this._createIndexBuffer();\r\n\r\n        // Setup the default processing configuration to the scene.\r\n        this._attachImageProcessingConfiguration(null);\r\n\r\n        options = options ?? {};\r\n\r\n        if (!options.randomTextureSize) {\r\n            delete options.randomTextureSize;\r\n        }\r\n\r\n        const fullOptions = {\r\n            capacity: 50000,\r\n            randomTextureSize: this._engine.getCaps().maxTextureSize,\r\n            ...options,\r\n        };\r\n\r\n        const optionsAsNumber = <number>options;\r\n        if (isFinite(optionsAsNumber)) {\r\n            fullOptions.capacity = optionsAsNumber;\r\n        }\r\n\r\n        this._capacity = fullOptions.capacity;\r\n        this._maxActiveParticleCount = fullOptions.capacity;\r\n        this._currentActiveCount = 0;\r\n        this._isAnimationSheetEnabled = isAnimationSheetEnabled;\r\n\r\n        this.particleEmitterType = new BoxParticleEmitter();\r\n\r\n        // Random data\r\n        const maxTextureSize = Math.min(this._engine.getCaps().maxTextureSize, fullOptions.randomTextureSize);\r\n        let d = [];\r\n        for (let i = 0; i < maxTextureSize; ++i) {\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n        }\r\n        this._randomTexture = new RawTexture(\r\n            new Float32Array(d),\r\n            maxTextureSize,\r\n            1,\r\n            Constants.TEXTUREFORMAT_RGBA,\r\n            sceneOrEngine,\r\n            false,\r\n            false,\r\n            Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n            Constants.TEXTURETYPE_FLOAT\r\n        );\r\n        this._randomTexture.name = \"GPUParticleSystem_random1\";\r\n        this._randomTexture.wrapU = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n        this._randomTexture.wrapV = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n        d = [];\r\n        for (let i = 0; i < maxTextureSize; ++i) {\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n        }\r\n        this._randomTexture2 = new RawTexture(\r\n            new Float32Array(d),\r\n            maxTextureSize,\r\n            1,\r\n            Constants.TEXTUREFORMAT_RGBA,\r\n            sceneOrEngine,\r\n            false,\r\n            false,\r\n            Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n            Constants.TEXTURETYPE_FLOAT\r\n        );\r\n        this._randomTexture2.name = \"GPUParticleSystem_random2\";\r\n        this._randomTexture2.wrapU = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n        this._randomTexture2.wrapV = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n        this._randomTextureSize = maxTextureSize;\r\n    }\r\n\r\n    protected _reset() {\r\n        this._releaseBuffers();\r\n    }\r\n\r\n    private _createVertexBuffers(updateBuffer: Buffer, renderBuffer: Buffer, spriteSource: Buffer): void {\r\n        const renderVertexBuffers: { [key: string]: VertexBuffer } = {};\r\n        renderVertexBuffers[\"position\"] = renderBuffer.createVertexBuffer(\"position\", 0, 3, this._attributesStrideSize, true);\r\n        let offset = 3;\r\n        renderVertexBuffers[\"age\"] = renderBuffer.createVertexBuffer(\"age\", offset, 1, this._attributesStrideSize, true);\r\n        offset += 1;\r\n        renderVertexBuffers[\"size\"] = renderBuffer.createVertexBuffer(\"size\", offset, 3, this._attributesStrideSize, true);\r\n        offset += 3;\r\n        renderVertexBuffers[\"life\"] = renderBuffer.createVertexBuffer(\"life\", offset, 1, this._attributesStrideSize, true);\r\n        offset += 1;\r\n        offset += 4; // seed\r\n        if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\r\n            renderVertexBuffers[\"direction\"] = renderBuffer.createVertexBuffer(\"direction\", offset, 3, this._attributesStrideSize, true);\r\n        }\r\n        offset += 3; // direction\r\n        if (this._platform.alignDataInBuffer) {\r\n            offset += 1;\r\n        }\r\n\r\n        if (this.particleEmitterType instanceof CustomParticleEmitter) {\r\n            offset += 3;\r\n            if (this._platform.alignDataInBuffer) {\r\n                offset += 1;\r\n            }\r\n        }\r\n\r\n        if (!this._colorGradientsTexture) {\r\n            renderVertexBuffers[\"color\"] = renderBuffer.createVertexBuffer(\"color\", offset, 4, this._attributesStrideSize, true);\r\n            offset += 4;\r\n        }\r\n\r\n        if (!this._isBillboardBased) {\r\n            renderVertexBuffers[\"initialDirection\"] = renderBuffer.createVertexBuffer(\"initialDirection\", offset, 3, this._attributesStrideSize, true);\r\n            offset += 3;\r\n            if (this._platform.alignDataInBuffer) {\r\n                offset += 1;\r\n            }\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            renderVertexBuffers[\"noiseCoordinates1\"] = renderBuffer.createVertexBuffer(\"noiseCoordinates1\", offset, 3, this._attributesStrideSize, true);\r\n            offset += 3;\r\n            if (this._platform.alignDataInBuffer) {\r\n                offset += 1;\r\n            }\r\n            renderVertexBuffers[\"noiseCoordinates2\"] = renderBuffer.createVertexBuffer(\"noiseCoordinates2\", offset, 3, this._attributesStrideSize, true);\r\n            offset += 3;\r\n            if (this._platform.alignDataInBuffer) {\r\n                offset += 1;\r\n            }\r\n        }\r\n\r\n        renderVertexBuffers[\"angle\"] = renderBuffer.createVertexBuffer(\"angle\", offset, 1, this._attributesStrideSize, true);\r\n        if (this._angularSpeedGradientsTexture) {\r\n            offset++;\r\n        } else {\r\n            offset += 2;\r\n        }\r\n\r\n        if (this._isAnimationSheetEnabled) {\r\n            renderVertexBuffers[\"cellIndex\"] = renderBuffer.createVertexBuffer(\"cellIndex\", offset, 1, this._attributesStrideSize, true);\r\n            offset += 1;\r\n            if (this.spriteRandomStartCell) {\r\n                renderVertexBuffers[\"cellStartOffset\"] = renderBuffer.createVertexBuffer(\"cellStartOffset\", offset, 1, this._attributesStrideSize, true);\r\n                offset += 1;\r\n            }\r\n        }\r\n\r\n        renderVertexBuffers[\"offset\"] = spriteSource.createVertexBuffer(\"offset\", 0, 2);\r\n        renderVertexBuffers[\"uv\"] = spriteSource.createVertexBuffer(\"uv\", 2, 2);\r\n\r\n        this._renderVertexBuffers.push(renderVertexBuffers);\r\n\r\n        this._platform.createVertexBuffers(updateBuffer, renderVertexBuffers);\r\n\r\n        this.resetDrawCache();\r\n    }\r\n\r\n    private _initialize(force = false): void {\r\n        if (this._buffer0 && !force) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._engine;\r\n        const data = new Array<float>();\r\n\r\n        this._attributesStrideSize = 21;\r\n        this._targetIndex = 0;\r\n\r\n        if (this._platform.alignDataInBuffer) {\r\n            this._attributesStrideSize += 1;\r\n        }\r\n\r\n        if (this.particleEmitterType instanceof CustomParticleEmitter) {\r\n            this._attributesStrideSize += 3;\r\n            if (this._platform.alignDataInBuffer) {\r\n                this._attributesStrideSize += 1;\r\n            }\r\n        }\r\n\r\n        if (!this.isBillboardBased) {\r\n            this._attributesStrideSize += 3;\r\n            if (this._platform.alignDataInBuffer) {\r\n                this._attributesStrideSize += 1;\r\n            }\r\n        }\r\n\r\n        if (this._colorGradientsTexture) {\r\n            this._attributesStrideSize -= 4;\r\n        }\r\n\r\n        if (this._angularSpeedGradientsTexture) {\r\n            this._attributesStrideSize -= 1;\r\n        }\r\n\r\n        if (this._isAnimationSheetEnabled) {\r\n            this._attributesStrideSize += 1;\r\n            if (this.spriteRandomStartCell) {\r\n                this._attributesStrideSize += 1;\r\n            }\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            this._attributesStrideSize += 6;\r\n            if (this._platform.alignDataInBuffer) {\r\n                this._attributesStrideSize += 2;\r\n            }\r\n        }\r\n\r\n        if (this._platform.alignDataInBuffer) {\r\n            this._attributesStrideSize += 3 - ((this._attributesStrideSize + 3) & 3); // round to multiple of 4\r\n        }\r\n\r\n        const usingCustomEmitter = this.particleEmitterType instanceof CustomParticleEmitter;\r\n        const tmpVector = TmpVectors.Vector3[0];\r\n\r\n        let offset = 0;\r\n        for (let particleIndex = 0; particleIndex < this._capacity; particleIndex++) {\r\n            // position\r\n            data.push(0.0);\r\n            data.push(0.0);\r\n            data.push(0.0);\r\n\r\n            // Age\r\n            data.push(0.0); // create the particle as a dead one to create a new one at start\r\n\r\n            // Size\r\n            data.push(0.0);\r\n            data.push(0.0);\r\n            data.push(0.0);\r\n\r\n            // life\r\n            data.push(0.0);\r\n\r\n            // Seed\r\n            data.push(Math.random());\r\n            data.push(Math.random());\r\n            data.push(Math.random());\r\n            data.push(Math.random());\r\n\r\n            // direction\r\n            if (usingCustomEmitter) {\r\n                (this.particleEmitterType as CustomParticleEmitter).particleDestinationGenerator(particleIndex, null, tmpVector);\r\n                data.push(tmpVector.x);\r\n                data.push(tmpVector.y);\r\n                data.push(tmpVector.z);\r\n            } else {\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n            }\r\n\r\n            if (this._platform.alignDataInBuffer) {\r\n                data.push(0.0); // dummy0\r\n            }\r\n\r\n            offset += 16; // position, age, size, life, seed, direction, dummy0\r\n\r\n            if (usingCustomEmitter) {\r\n                (this.particleEmitterType as CustomParticleEmitter).particlePositionGenerator(particleIndex, null, tmpVector);\r\n                data.push(tmpVector.x);\r\n                data.push(tmpVector.y);\r\n                data.push(tmpVector.z);\r\n                if (this._platform.alignDataInBuffer) {\r\n                    data.push(0.0); // dummy1\r\n                }\r\n                offset += 4;\r\n            }\r\n\r\n            if (!this._colorGradientsTexture) {\r\n                // color\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                offset += 4;\r\n            }\r\n\r\n            if (!this.isBillboardBased) {\r\n                // initialDirection\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                if (this._platform.alignDataInBuffer) {\r\n                    data.push(0.0); // dummy2\r\n                }\r\n                offset += 4;\r\n            }\r\n\r\n            if (this.noiseTexture) {\r\n                // Random coordinates for reading into noise texture\r\n                data.push(Math.random());\r\n                data.push(Math.random());\r\n                data.push(Math.random());\r\n                if (this._platform.alignDataInBuffer) {\r\n                    data.push(0.0); // dummy3\r\n                }\r\n                data.push(Math.random());\r\n                data.push(Math.random());\r\n                data.push(Math.random());\r\n                if (this._platform.alignDataInBuffer) {\r\n                    data.push(0.0); // dummy4\r\n                }\r\n                offset += 8;\r\n            }\r\n\r\n            // angle\r\n            data.push(0.0);\r\n            offset += 1;\r\n\r\n            if (!this._angularSpeedGradientsTexture) {\r\n                data.push(0.0);\r\n                offset += 1;\r\n            }\r\n\r\n            if (this._isAnimationSheetEnabled) {\r\n                data.push(0.0);\r\n                offset += 1;\r\n                if (this.spriteRandomStartCell) {\r\n                    data.push(0.0);\r\n                    offset += 1;\r\n                }\r\n            }\r\n\r\n            if (this._platform.alignDataInBuffer) {\r\n                let numDummies = 3 - ((offset + 3) & 3);\r\n                offset += numDummies;\r\n                while (numDummies-- > 0) {\r\n                    data.push(0.0);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Sprite data\r\n        const spriteData = new Float32Array([0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1, 0.5, -0.5, 1, 0, -0.5, -0.5, 0, 0]);\r\n\r\n        const bufferData1: DataArray | DataBuffer = this._platform.createParticleBuffer(data);\r\n        const bufferData2: DataArray | DataBuffer = this._platform.createParticleBuffer(data);\r\n\r\n        // Buffers\r\n        this._buffer0 = new Buffer(engine, bufferData1, false, this._attributesStrideSize);\r\n        this._buffer1 = new Buffer(engine, bufferData2, false, this._attributesStrideSize);\r\n        this._spriteBuffer = new Buffer(engine, spriteData, false, 4);\r\n\r\n        // Update & Render vertex buffers\r\n        this._renderVertexBuffers = [];\r\n        this._createVertexBuffers(this._buffer0, this._buffer1, this._spriteBuffer);\r\n        this._createVertexBuffers(this._buffer1, this._buffer0, this._spriteBuffer);\r\n\r\n        // Links\r\n        this._sourceBuffer = this._buffer0;\r\n        this._targetBuffer = this._buffer1;\r\n    }\r\n\r\n    /** @internal */\r\n    public _recreateUpdateEffect() {\r\n        this._createColorGradientTexture();\r\n        this._createSizeGradientTexture();\r\n        this._createAngularSpeedGradientTexture();\r\n        this._createVelocityGradientTexture();\r\n        this._createLimitVelocityGradientTexture();\r\n        this._createDragGradientTexture();\r\n\r\n        let defines = this.particleEmitterType ? this.particleEmitterType.getEffectDefines() : \"\";\r\n\r\n        if (this._isBillboardBased) {\r\n            defines += \"\\n#define BILLBOARD\";\r\n        }\r\n\r\n        if (this._colorGradientsTexture) {\r\n            defines += \"\\n#define COLORGRADIENTS\";\r\n        }\r\n\r\n        if (this._sizeGradientsTexture) {\r\n            defines += \"\\n#define SIZEGRADIENTS\";\r\n        }\r\n\r\n        if (this._angularSpeedGradientsTexture) {\r\n            defines += \"\\n#define ANGULARSPEEDGRADIENTS\";\r\n        }\r\n\r\n        if (this._velocityGradientsTexture) {\r\n            defines += \"\\n#define VELOCITYGRADIENTS\";\r\n        }\r\n\r\n        if (this._limitVelocityGradientsTexture) {\r\n            defines += \"\\n#define LIMITVELOCITYGRADIENTS\";\r\n        }\r\n\r\n        if (this._dragGradientsTexture) {\r\n            defines += \"\\n#define DRAGGRADIENTS\";\r\n        }\r\n\r\n        if (this.isAnimationSheetEnabled) {\r\n            defines += \"\\n#define ANIMATESHEET\";\r\n            if (this.spriteRandomStartCell) {\r\n                defines += \"\\n#define ANIMATESHEETRANDOMSTART\";\r\n            }\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            defines += \"\\n#define NOISE\";\r\n        }\r\n\r\n        if (this.isLocal) {\r\n            defines += \"\\n#define LOCAL\";\r\n        }\r\n\r\n        if (this._platform.isUpdateBufferCreated() && this._cachedUpdateDefines === defines) {\r\n            return true;\r\n        }\r\n\r\n        this._cachedUpdateDefines = defines;\r\n        this._updateBuffer = this._platform.createUpdateBuffer(defines);\r\n\r\n        return this._platform.isUpdateBufferReady();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getWrapper(blendMode: number): DrawWrapper {\r\n        const customWrapper = this._getCustomDrawWrapper(blendMode);\r\n\r\n        if (customWrapper?.effect) {\r\n            return customWrapper;\r\n        }\r\n\r\n        const defines: Array<string> = [];\r\n\r\n        this.fillDefines(defines, blendMode);\r\n\r\n        // Effect\r\n        let drawWrapper = this._drawWrappers[blendMode];\r\n        if (!drawWrapper) {\r\n            drawWrapper = new DrawWrapper(this._engine);\r\n            if (drawWrapper.drawContext) {\r\n                drawWrapper.drawContext.useInstancing = true;\r\n            }\r\n            this._drawWrappers[blendMode] = drawWrapper;\r\n        }\r\n\r\n        const join = defines.join(\"\\n\");\r\n        if (drawWrapper.defines !== join) {\r\n            const attributes: Array<string> = [];\r\n            const uniforms: Array<string> = [];\r\n            const samplers: Array<string> = [];\r\n\r\n            this.fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers);\r\n\r\n            drawWrapper.setEffect(this._engine.createEffect(\"gpuRenderParticles\", attributes, uniforms, samplers, join), join);\r\n        }\r\n\r\n        return drawWrapper;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _GetAttributeNamesOrOptions(hasColorGradients = false, isAnimationSheetEnabled = false, isBillboardBased = false, isBillboardStretched = false): string[] {\r\n        const attributeNamesOrOptions = [VertexBuffer.PositionKind, \"age\", \"life\", \"size\", \"angle\"];\r\n\r\n        if (!hasColorGradients) {\r\n            attributeNamesOrOptions.push(VertexBuffer.ColorKind);\r\n        }\r\n\r\n        if (isAnimationSheetEnabled) {\r\n            attributeNamesOrOptions.push(\"cellIndex\");\r\n        }\r\n\r\n        if (!isBillboardBased) {\r\n            attributeNamesOrOptions.push(\"initialDirection\");\r\n        }\r\n\r\n        if (isBillboardStretched) {\r\n            attributeNamesOrOptions.push(\"direction\");\r\n        }\r\n\r\n        attributeNamesOrOptions.push(\"offset\", VertexBuffer.UVKind);\r\n\r\n        return attributeNamesOrOptions;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _GetEffectCreationOptions(isAnimationSheetEnabled = false, useLogarithmicDepth = false): string[] {\r\n        const effectCreationOption = [\"emitterWM\", \"worldOffset\", \"view\", \"projection\", \"colorDead\", \"invView\", \"translationPivot\", \"eyePosition\"];\r\n        addClipPlaneUniforms(effectCreationOption);\r\n\r\n        if (isAnimationSheetEnabled) {\r\n            effectCreationOption.push(\"sheetInfos\");\r\n        }\r\n        if (useLogarithmicDepth) {\r\n            effectCreationOption.push(\"logarithmicDepthConstant\");\r\n        }\r\n\r\n        return effectCreationOption;\r\n    }\r\n\r\n    /**\r\n     * Fill the defines array according to the current settings of the particle system\r\n     * @param defines Array to be updated\r\n     * @param blendMode blend mode to take into account when updating the array\r\n     */\r\n    public fillDefines(defines: Array<string>, blendMode: number = 0) {\r\n        if (this._scene) {\r\n            prepareStringDefinesForClipPlanes(this, this._scene, defines);\r\n        }\r\n\r\n        if (blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {\r\n            defines.push(\"#define BLENDMULTIPLYMODE\");\r\n        }\r\n\r\n        if (this.isLocal) {\r\n            defines.push(\"#define LOCAL\");\r\n        }\r\n\r\n        if (this.useLogarithmicDepth) {\r\n            defines.push(\"#define LOGARITHMICDEPTH\");\r\n        }\r\n\r\n        if (this._isBillboardBased) {\r\n            defines.push(\"#define BILLBOARD\");\r\n\r\n            switch (this.billboardMode) {\r\n                case ParticleSystem.BILLBOARDMODE_Y:\r\n                    defines.push(\"#define BILLBOARDY\");\r\n                    break;\r\n                case ParticleSystem.BILLBOARDMODE_STRETCHED:\r\n                    defines.push(\"#define BILLBOARDSTRETCHED\");\r\n                    break;\r\n                case ParticleSystem.BILLBOARDMODE_ALL:\r\n                    defines.push(\"#define BILLBOARDMODE_ALL\");\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n\r\n        if (this._colorGradientsTexture) {\r\n            defines.push(\"#define COLORGRADIENTS\");\r\n        }\r\n\r\n        if (this.isAnimationSheetEnabled) {\r\n            defines.push(\"#define ANIMATESHEET\");\r\n        }\r\n\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);\r\n            defines.push(\"\" + this._imageProcessingConfigurationDefines.toString());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system\r\n     * @param uniforms Uniforms array to fill\r\n     * @param attributes Attributes array to fill\r\n     * @param samplers Samplers array to fill\r\n     */\r\n    public fillUniformsAttributesAndSamplerNames(uniforms: Array<string>, attributes: Array<string>, samplers: Array<string>) {\r\n        attributes.push(\r\n            ...GPUParticleSystem._GetAttributeNamesOrOptions(\r\n                !!this._colorGradientsTexture,\r\n                this._isAnimationSheetEnabled,\r\n                this._isBillboardBased,\r\n                this._isBillboardBased && this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED\r\n            )\r\n        );\r\n\r\n        uniforms.push(...GPUParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled, this.useLogarithmicDepth));\r\n\r\n        samplers.push(\"diffuseSampler\", \"colorGradientSampler\");\r\n\r\n        if (this._imageProcessingConfiguration) {\r\n            ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);\r\n            ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Animates the particle system for the current frame by emitting new particles and or animating the living ones.\r\n     * @param preWarm defines if we are in the pre-warmimg phase\r\n     */\r\n    public animate(preWarm = false): void {\r\n        this._timeDelta = this.updateSpeed * (preWarm ? this.preWarmStepOffset : this._scene?.getAnimationRatio() || 1);\r\n        this._actualFrame += this._timeDelta;\r\n\r\n        if (!this._stopped) {\r\n            if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {\r\n                this.stop();\r\n            }\r\n        }\r\n\r\n        if (this.updateInAnimate) {\r\n            this._update();\r\n        }\r\n    }\r\n\r\n    private _createFactorGradientTexture(factorGradients: Nullable<IValueGradient[]>, textureName: string) {\r\n        const texture: RawTexture = (<any>this)[textureName];\r\n\r\n        if (!factorGradients || !factorGradients.length || texture) {\r\n            return;\r\n        }\r\n\r\n        const data = new Float32Array(this._rawTextureWidth);\r\n\r\n        for (let x = 0; x < this._rawTextureWidth; x++) {\r\n            const ratio = x / this._rawTextureWidth;\r\n\r\n            GradientHelper.GetCurrentGradient(ratio, factorGradients, (currentGradient, nextGradient, scale) => {\r\n                data[x] = Scalar.Lerp((<FactorGradient>currentGradient).factor1, (<FactorGradient>nextGradient).factor1, scale);\r\n            });\r\n        }\r\n\r\n        (<any>this)[textureName] = RawTexture.CreateRTexture(data, this._rawTextureWidth, 1, this._scene || this._engine, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE);\r\n        (<any>this)[textureName].name = textureName.substring(1);\r\n    }\r\n\r\n    private _createSizeGradientTexture() {\r\n        this._createFactorGradientTexture(this._sizeGradients, \"_sizeGradientsTexture\");\r\n    }\r\n\r\n    private _createAngularSpeedGradientTexture() {\r\n        this._createFactorGradientTexture(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\");\r\n    }\r\n\r\n    private _createVelocityGradientTexture() {\r\n        this._createFactorGradientTexture(this._velocityGradients, \"_velocityGradientsTexture\");\r\n    }\r\n\r\n    private _createLimitVelocityGradientTexture() {\r\n        this._createFactorGradientTexture(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\");\r\n    }\r\n\r\n    private _createDragGradientTexture() {\r\n        this._createFactorGradientTexture(this._dragGradients, \"_dragGradientsTexture\");\r\n    }\r\n\r\n    private _createColorGradientTexture() {\r\n        if (!this._colorGradients || !this._colorGradients.length || this._colorGradientsTexture) {\r\n            return;\r\n        }\r\n\r\n        const data = new Uint8Array(this._rawTextureWidth * 4);\r\n        const tmpColor = TmpColors.Color4[0];\r\n\r\n        for (let x = 0; x < this._rawTextureWidth; x++) {\r\n            const ratio = x / this._rawTextureWidth;\r\n\r\n            GradientHelper.GetCurrentGradient(ratio, this._colorGradients, (currentGradient, nextGradient, scale) => {\r\n                Color4.LerpToRef((<ColorGradient>currentGradient).color1, (<ColorGradient>nextGradient).color1, scale, tmpColor);\r\n                data[x * 4] = tmpColor.r * 255;\r\n                data[x * 4 + 1] = tmpColor.g * 255;\r\n                data[x * 4 + 2] = tmpColor.b * 255;\r\n                data[x * 4 + 3] = tmpColor.a * 255;\r\n            });\r\n        }\r\n\r\n        this._colorGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE);\r\n        this._colorGradientsTexture.name = \"colorGradients\";\r\n    }\r\n\r\n    private _render(blendMode: number, emitterWM: Matrix): number {\r\n        // Enable render effect\r\n        const drawWrapper = this._getWrapper(blendMode);\r\n        const effect = drawWrapper.effect!;\r\n\r\n        this._engine.enableEffect(drawWrapper);\r\n        const viewMatrix = this._scene?.getViewMatrix() || Matrix.IdentityReadOnly;\r\n        effect.setMatrix(\"view\", viewMatrix);\r\n        effect.setMatrix(\"projection\", this.defaultProjectionMatrix ?? this._scene!.getProjectionMatrix());\r\n        effect.setTexture(\"diffuseSampler\", this.particleTexture);\r\n        effect.setVector2(\"translationPivot\", this.translationPivot);\r\n        effect.setVector3(\"worldOffset\", this.worldOffset);\r\n        if (this.isLocal) {\r\n            effect.setMatrix(\"emitterWM\", emitterWM);\r\n        }\r\n        if (this._colorGradientsTexture) {\r\n            effect.setTexture(\"colorGradientSampler\", this._colorGradientsTexture);\r\n        } else {\r\n            effect.setDirectColor4(\"colorDead\", this.colorDead);\r\n        }\r\n\r\n        if (this._isAnimationSheetEnabled && this.particleTexture) {\r\n            const baseSize = this.particleTexture.getBaseSize();\r\n            effect.setFloat3(\"sheetInfos\", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, baseSize.width / this.spriteCellWidth);\r\n        }\r\n\r\n        if (this._isBillboardBased && this._scene) {\r\n            const camera = this._scene.activeCamera!;\r\n            effect.setVector3(\"eyePosition\", camera.globalPosition);\r\n        }\r\n\r\n        const defines = effect.defines;\r\n\r\n        if (this._scene) {\r\n            bindClipPlane(effect, this, this._scene);\r\n        }\r\n\r\n        if (defines.indexOf(\"#define BILLBOARDMODE_ALL\") >= 0) {\r\n            const invView = viewMatrix.clone();\r\n            invView.invert();\r\n            effect.setMatrix(\"invView\", invView);\r\n        }\r\n\r\n        // Log. depth\r\n        if (this.useLogarithmicDepth && this._scene) {\r\n            MaterialHelper.BindLogDepth(defines, effect, this._scene);\r\n        }\r\n\r\n        // image processing\r\n        if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\r\n            this._imageProcessingConfiguration.bind(effect);\r\n        }\r\n\r\n        // Draw order\r\n        switch (blendMode) {\r\n            case ParticleSystem.BLENDMODE_ADD:\r\n                this._engine.setAlphaMode(Constants.ALPHA_ADD);\r\n                break;\r\n            case ParticleSystem.BLENDMODE_ONEONE:\r\n                this._engine.setAlphaMode(Constants.ALPHA_ONEONE);\r\n                break;\r\n            case ParticleSystem.BLENDMODE_STANDARD:\r\n                this._engine.setAlphaMode(Constants.ALPHA_COMBINE);\r\n                break;\r\n            case ParticleSystem.BLENDMODE_MULTIPLY:\r\n                this._engine.setAlphaMode(Constants.ALPHA_MULTIPLY);\r\n                break;\r\n        }\r\n\r\n        // Bind source VAO\r\n        this._platform.bindDrawBuffers(this._targetIndex, effect, this._scene?.forceWireframe ? this._linesIndexBufferUseInstancing : null);\r\n\r\n        if (this._onBeforeDrawParticlesObservable) {\r\n            this._onBeforeDrawParticlesObservable.notifyObservers(effect);\r\n        }\r\n\r\n        // Render\r\n        if (this._scene?.forceWireframe) {\r\n            this._engine.drawElementsType(Constants.MATERIAL_LineStripDrawMode, 0, 10, this._currentActiveCount);\r\n        } else {\r\n            this._engine.drawArraysType(Constants.MATERIAL_TriangleStripDrawMode, 0, 4, this._currentActiveCount);\r\n        }\r\n        this._engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n\r\n        if (this._scene?.forceWireframe) {\r\n            this._engine.unbindInstanceAttributes();\r\n        }\r\n\r\n        return this._currentActiveCount;\r\n    }\r\n\r\n    /** @internal */\r\n    public _update(emitterWM?: Matrix): void {\r\n        if (!this.emitter || !this._targetBuffer) {\r\n            return;\r\n        }\r\n\r\n        if (!this._recreateUpdateEffect()) {\r\n            return;\r\n        }\r\n\r\n        if (!emitterWM) {\r\n            if ((<AbstractMesh>this.emitter).position) {\r\n                const emitterMesh = <AbstractMesh>this.emitter;\r\n                emitterWM = emitterMesh.getWorldMatrix();\r\n            } else {\r\n                const emitterPosition = <Vector3>this.emitter;\r\n                emitterWM = TmpVectors.Matrix[0];\r\n                Matrix.TranslationToRef(emitterPosition.x, emitterPosition.y, emitterPosition.z, emitterWM);\r\n            }\r\n        }\r\n\r\n        this._platform.preUpdateParticleBuffer();\r\n\r\n        this._updateBuffer.setFloat(\"currentCount\", this._currentActiveCount);\r\n        this._updateBuffer.setFloat(\"timeDelta\", this._timeDelta);\r\n        this._updateBuffer.setFloat(\"stopFactor\", this._stopped ? 0 : 1);\r\n        this._updateBuffer.setInt(\"randomTextureSize\", this._randomTextureSize);\r\n        this._updateBuffer.setFloat2(\"lifeTime\", this.minLifeTime, this.maxLifeTime);\r\n        this._updateBuffer.setFloat2(\"emitPower\", this.minEmitPower, this.maxEmitPower);\r\n        if (!this._colorGradientsTexture) {\r\n            this._updateBuffer.setDirectColor4(\"color1\", this.color1);\r\n            this._updateBuffer.setDirectColor4(\"color2\", this.color2);\r\n        }\r\n        this._updateBuffer.setFloat2(\"sizeRange\", this.minSize, this.maxSize);\r\n        this._updateBuffer.setFloat4(\"scaleRange\", this.minScaleX, this.maxScaleX, this.minScaleY, this.maxScaleY);\r\n        this._updateBuffer.setFloat4(\"angleRange\", this.minAngularSpeed, this.maxAngularSpeed, this.minInitialRotation, this.maxInitialRotation);\r\n        this._updateBuffer.setVector3(\"gravity\", this.gravity);\r\n        if (this._limitVelocityGradientsTexture) {\r\n            this._updateBuffer.setFloat(\"limitVelocityDamping\", this.limitVelocityDamping);\r\n        }\r\n        if (this.particleEmitterType) {\r\n            this.particleEmitterType.applyToShader(this._updateBuffer);\r\n        }\r\n        if (this._isAnimationSheetEnabled) {\r\n            this._updateBuffer.setFloat4(\"cellInfos\", this.startSpriteCellID, this.endSpriteCellID, this.spriteCellChangeSpeed, this.spriteCellLoop ? 1 : 0);\r\n        }\r\n        if (this.noiseTexture) {\r\n            this._updateBuffer.setVector3(\"noiseStrength\", this.noiseStrength);\r\n        }\r\n        if (!this.isLocal) {\r\n            this._updateBuffer.setMatrix(\"emitterWM\", emitterWM);\r\n        }\r\n\r\n        this._platform.updateParticleBuffer(this._targetIndex, this._targetBuffer, this._currentActiveCount);\r\n\r\n        // Switch VAOs\r\n        this._targetIndex++;\r\n        if (this._targetIndex === 2) {\r\n            this._targetIndex = 0;\r\n        }\r\n\r\n        // Switch buffers\r\n        const tmpBuffer = this._sourceBuffer;\r\n        this._sourceBuffer = this._targetBuffer;\r\n        this._targetBuffer = tmpBuffer;\r\n    }\r\n\r\n    /**\r\n     * Renders the particle system in its current state\r\n     * @param preWarm defines if the system should only update the particles but not render them\r\n     * @param forceUpdateOnly if true, force to only update the particles and never display them (meaning, even if preWarm=false, when forceUpdateOnly=true the particles won't be displayed)\r\n     * @returns the current number of particles\r\n     */\r\n    public render(preWarm = false, forceUpdateOnly = false): number {\r\n        if (!this._started) {\r\n            return 0;\r\n        }\r\n\r\n        if (!this.isReady()) {\r\n            return 0;\r\n        }\r\n\r\n        if (!preWarm && this._scene) {\r\n            if (!this._preWarmDone && this.preWarmCycles) {\r\n                for (let index = 0; index < this.preWarmCycles; index++) {\r\n                    this.animate(true);\r\n                    this.render(true, true);\r\n                }\r\n\r\n                this._preWarmDone = true;\r\n            }\r\n\r\n            if (\r\n                this._currentRenderId === this._scene.getRenderId() &&\r\n                (!this._scene.activeCamera || (this._scene.activeCamera && this._currentRenderingCameraUniqueId === this._scene.activeCamera.uniqueId))\r\n            ) {\r\n                return 0;\r\n            }\r\n\r\n            this._currentRenderId = this._scene.getRenderId();\r\n            if (this._scene.activeCamera) {\r\n                this._currentRenderingCameraUniqueId = this._scene.activeCamera.uniqueId;\r\n            }\r\n        }\r\n\r\n        // Get everything ready to render\r\n        this._initialize();\r\n\r\n        this._accumulatedCount += this.emitRate * this._timeDelta;\r\n        if (this._accumulatedCount > 1) {\r\n            const intPart = this._accumulatedCount | 0;\r\n            this._accumulatedCount -= intPart;\r\n            this._currentActiveCount += intPart;\r\n        }\r\n\r\n        this._currentActiveCount = Math.min(this._maxActiveParticleCount, this._currentActiveCount);\r\n\r\n        if (!this._currentActiveCount) {\r\n            return 0;\r\n        }\r\n\r\n        // Enable update effect\r\n        let emitterWM: Matrix;\r\n        if ((<AbstractMesh>this.emitter).position) {\r\n            const emitterMesh = <AbstractMesh>this.emitter;\r\n            emitterWM = emitterMesh.getWorldMatrix();\r\n        } else {\r\n            const emitterPosition = <Vector3>this.emitter;\r\n            emitterWM = TmpVectors.Matrix[0];\r\n            Matrix.TranslationToRef(emitterPosition.x, emitterPosition.y, emitterPosition.z, emitterWM);\r\n        }\r\n\r\n        const engine = this._engine as Engine;\r\n\r\n        if (!this.updateInAnimate) {\r\n            this._update(emitterWM);\r\n        }\r\n\r\n        let outparticles = 0;\r\n        if (!preWarm && !forceUpdateOnly) {\r\n            engine.setState(false);\r\n\r\n            if (this.forceDepthWrite) {\r\n                engine.setDepthWrite(true);\r\n            }\r\n\r\n            if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLYADD) {\r\n                outparticles = this._render(ParticleSystem.BLENDMODE_MULTIPLY, emitterWM) + this._render(ParticleSystem.BLENDMODE_ADD, emitterWM);\r\n            } else {\r\n                outparticles = this._render(this.blendMode, emitterWM);\r\n            }\r\n\r\n            this._engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        }\r\n\r\n        return outparticles;\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the particle system\r\n     */\r\n    public rebuild(): void {\r\n        const checkUpdateEffect = () => {\r\n            if (!this._recreateUpdateEffect() || !this._platform.isUpdateBufferReady()) {\r\n                setTimeout(checkUpdateEffect, 10);\r\n            } else {\r\n                this._initialize(true);\r\n            }\r\n        };\r\n\r\n        this._createIndexBuffer();\r\n\r\n        this._cachedUpdateDefines = \"\";\r\n        this._platform.contextLost();\r\n\r\n        checkUpdateEffect();\r\n    }\r\n\r\n    private _releaseBuffers() {\r\n        if (this._buffer0) {\r\n            this._buffer0.dispose();\r\n            (<any>this._buffer0) = null;\r\n        }\r\n        if (this._buffer1) {\r\n            this._buffer1.dispose();\r\n            (<any>this._buffer1) = null;\r\n        }\r\n        if (this._spriteBuffer) {\r\n            this._spriteBuffer.dispose();\r\n            (<any>this._spriteBuffer) = null;\r\n        }\r\n        this._platform.releaseBuffers();\r\n    }\r\n\r\n    /**\r\n     * Disposes the particle system and free the associated resources\r\n     * @param disposeTexture defines if the particule texture must be disposed as well (true by default)\r\n     */\r\n    public dispose(disposeTexture = true): void {\r\n        for (const blendMode in this._drawWrappers) {\r\n            const drawWrapper = this._drawWrappers[blendMode];\r\n            drawWrapper.dispose();\r\n        }\r\n\r\n        this._drawWrappers = {};\r\n\r\n        if (this._scene) {\r\n            const index = this._scene.particleSystems.indexOf(this);\r\n            if (index > -1) {\r\n                this._scene.particleSystems.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        this._releaseBuffers();\r\n        this._platform.releaseVertexBuffers();\r\n\r\n        for (let i = 0; i < this._renderVertexBuffers.length; ++i) {\r\n            const rvb = this._renderVertexBuffers[i];\r\n            for (const key in rvb) {\r\n                rvb[key].dispose();\r\n            }\r\n        }\r\n\r\n        this._renderVertexBuffers = [];\r\n\r\n        if (this._colorGradientsTexture) {\r\n            this._colorGradientsTexture.dispose();\r\n            (<any>this._colorGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._sizeGradientsTexture) {\r\n            this._sizeGradientsTexture.dispose();\r\n            (<any>this._sizeGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._angularSpeedGradientsTexture) {\r\n            this._angularSpeedGradientsTexture.dispose();\r\n            (<any>this._angularSpeedGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._velocityGradientsTexture) {\r\n            this._velocityGradientsTexture.dispose();\r\n            (<any>this._velocityGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._limitVelocityGradientsTexture) {\r\n            this._limitVelocityGradientsTexture.dispose();\r\n            (<any>this._limitVelocityGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._dragGradientsTexture) {\r\n            this._dragGradientsTexture.dispose();\r\n            (<any>this._dragGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._randomTexture) {\r\n            this._randomTexture.dispose();\r\n            (<any>this._randomTexture) = null;\r\n        }\r\n\r\n        if (this._randomTexture2) {\r\n            this._randomTexture2.dispose();\r\n            (<any>this._randomTexture2) = null;\r\n        }\r\n\r\n        if (disposeTexture && this.particleTexture) {\r\n            this.particleTexture.dispose();\r\n            this.particleTexture = null;\r\n        }\r\n\r\n        if (disposeTexture && this.noiseTexture) {\r\n            this.noiseTexture.dispose();\r\n            this.noiseTexture = null;\r\n        }\r\n\r\n        // Callback\r\n        this.onStoppedObservable.clear();\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n    }\r\n    /**\r\n     * Clones the particle system.\r\n     * @param name The name of the cloned object\r\n     * @param newEmitter The new emitter to use\r\n     * @param cloneTexture Also clone the textures if true\r\n     * @returns the cloned particle system\r\n     */\r\n    public clone(name: string, newEmitter: any, cloneTexture = false): GPUParticleSystem {\r\n        const custom = { ...this._customWrappers };\r\n        let program: any = null;\r\n        const engine = this._engine as any;\r\n        if (engine.createEffectForParticles) {\r\n            if (this.customShader != null) {\r\n                program = this.customShader;\r\n                const defines: string = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\r\n                custom[0] = engine.createEffectForParticles(\r\n                    program.shaderPath.fragmentElement,\r\n                    program.shaderOptions.uniforms,\r\n                    program.shaderOptions.samplers,\r\n                    defines,\r\n                    undefined,\r\n                    undefined,\r\n                    undefined,\r\n                    this\r\n                );\r\n            }\r\n        }\r\n\r\n        const serialization = this.serialize(cloneTexture);\r\n        const result = GPUParticleSystem.Parse(serialization, this._scene || this._engine, this._rootUrl);\r\n        result.name = name;\r\n        result.customShader = program;\r\n        result._customWrappers = custom;\r\n\r\n        if (newEmitter === undefined) {\r\n            newEmitter = this.emitter;\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            result.noiseTexture = this.noiseTexture.clone();\r\n        }\r\n\r\n        result.emitter = newEmitter;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object\r\n     * @param serializeTexture defines if the texture must be serialized as well\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(serializeTexture = false): any {\r\n        const serializationObject: any = {};\r\n\r\n        ParticleSystem._Serialize(serializationObject, this, serializeTexture);\r\n\r\n        serializationObject.activeParticleCount = this.activeParticleCount;\r\n        serializationObject.randomTextureSize = this._randomTextureSize;\r\n        serializationObject.customShader = this.customShader;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parses a JSON object to create a GPU particle system.\r\n     * @param parsedParticleSystem The JSON object to parse\r\n     * @param sceneOrEngine The scene or the engine to create the particle system in\r\n     * @param rootUrl The root url to use to load external dependencies like texture\r\n     * @param doNotStart Ignore the preventAutoStart attribute and does not start\r\n     * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\r\n     * @returns the parsed GPU particle system\r\n     */\r\n    public static Parse(parsedParticleSystem: any, sceneOrEngine: Scene | ThinEngine, rootUrl: string, doNotStart = false, capacity?: number): GPUParticleSystem {\r\n        const name = parsedParticleSystem.name;\r\n        let engine: ThinEngine;\r\n        let scene: Nullable<Scene>;\r\n\r\n        if (sceneOrEngine instanceof ThinEngine) {\r\n            engine = sceneOrEngine;\r\n        } else {\r\n            scene = sceneOrEngine as Scene;\r\n            engine = scene.getEngine();\r\n        }\r\n\r\n        const particleSystem = new GPUParticleSystem(\r\n            name,\r\n            { capacity: capacity || parsedParticleSystem.capacity, randomTextureSize: parsedParticleSystem.randomTextureSize },\r\n            sceneOrEngine,\r\n            null,\r\n            parsedParticleSystem.isAnimationSheetEnabled\r\n        );\r\n        particleSystem._rootUrl = rootUrl;\r\n\r\n        if (parsedParticleSystem.customShader && (engine as any).createEffectForParticles) {\r\n            const program = parsedParticleSystem.customShader;\r\n            const defines: string = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\r\n            const custom: Nullable<Effect> = (engine as any).createEffectForParticles(\r\n                program.shaderPath.fragmentElement,\r\n                program.shaderOptions.uniforms,\r\n                program.shaderOptions.samplers,\r\n                defines,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                particleSystem\r\n            );\r\n            particleSystem.setCustomEffect(custom, 0);\r\n            particleSystem.customShader = program;\r\n        }\r\n\r\n        if (parsedParticleSystem.id) {\r\n            particleSystem.id = parsedParticleSystem.id;\r\n        }\r\n\r\n        if (parsedParticleSystem.activeParticleCount) {\r\n            particleSystem.activeParticleCount = parsedParticleSystem.activeParticleCount;\r\n        }\r\n\r\n        ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);\r\n\r\n        // Auto start\r\n        if (parsedParticleSystem.preventAutoStart) {\r\n            particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;\r\n        }\r\n\r\n        if (!doNotStart && !particleSystem.preventAutoStart) {\r\n            particleSystem.start();\r\n        }\r\n\r\n        return particleSystem;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}