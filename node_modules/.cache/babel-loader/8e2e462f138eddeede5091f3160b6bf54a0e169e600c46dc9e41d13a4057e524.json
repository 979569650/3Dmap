{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * This is the base class for all WebXR features.\n * Since most features require almost the same resources and callbacks, this class can be used to simplify the development\n * Note that since the features manager is using the `IWebXRFeature` you are in no way obligated to use this class\n */\nexport class WebXRAbstractFeature {\n  /**\n   * Construct a new (abstract) WebXR feature\n   * @param _xrSessionManager the xr session manager for this feature\n   */\n  constructor(_xrSessionManager) {\n    this._xrSessionManager = _xrSessionManager;\n    this._attached = false;\n    this._removeOnDetach = [];\n    /**\n     * Is this feature disposed?\n     */\n    this.isDisposed = false;\n    /**\n     * Should auto-attach be disabled?\n     */\n    this.disableAutoAttach = false;\n    /**\n     * The name of the native xr feature name (like anchor, hit-test, or hand-tracking)\n     */\n    this.xrNativeFeatureName = \"\";\n  }\n  /**\n   * Is this feature attached\n   */\n  get attached() {\n    return this._attached;\n  }\n  /**\n   * attach this feature\n   *\n   * @param force should attachment be forced (even when already attached)\n   * @returns true if successful, false is failed or already attached\n   */\n  attach(force) {\n    // do not attach a disposed feature\n    if (this.isDisposed) {\n      return false;\n    }\n    if (!force) {\n      if (this.attached) {\n        return false;\n      }\n    } else {\n      if (this.attached) {\n        // detach first, to be sure\n        this.detach();\n      }\n    }\n    this._attached = true;\n    this._addNewAttachObserver(this._xrSessionManager.onXRFrameObservable, frame => this._onXRFrame(frame));\n    return true;\n  }\n  /**\n   * detach this feature.\n   *\n   * @returns true if successful, false if failed or already detached\n   */\n  detach() {\n    if (!this._attached) {\n      this.disableAutoAttach = true;\n      return false;\n    }\n    this._attached = false;\n    this._removeOnDetach.forEach(toRemove => {\n      toRemove.observable.remove(toRemove.observer);\n    });\n    return true;\n  }\n  /**\n   * Dispose this feature and all of the resources attached\n   */\n  dispose() {\n    this.detach();\n    this.isDisposed = true;\n  }\n  /**\n   * This function will be executed during before enabling the feature and can be used to not-allow enabling it.\n   * Note that at this point the session has NOT started, so this is purely checking if the browser supports it\n   *\n   * @returns whether or not the feature is compatible in this environment\n   */\n  isCompatible() {\n    return true;\n  }\n  /**\n   * This is used to register callbacks that will automatically be removed when detach is called.\n   * @param observable the observable to which the observer will be attached\n   * @param callback the callback to register\n   */\n  _addNewAttachObserver(observable, callback) {\n    this._removeOnDetach.push({\n      observable,\n      observer: observable.add(callback)\n    });\n  }\n}","map":{"version":3,"names":["WebXRAbstractFeature","constructor","_xrSessionManager","_attached","_removeOnDetach","isDisposed","disableAutoAttach","xrNativeFeatureName","attached","attach","force","detach","_addNewAttachObserver","onXRFrameObservable","frame","_onXRFrame","forEach","toRemove","observable","remove","observer","dispose","isCompatible","callback","push","add"],"sources":["../../../../../dev/core/src/XR/features/WebXRAbstractFeature.ts"],"sourcesContent":["import type { IWebXRFeature } from \"../webXRFeaturesManager\";\r\nimport type { Observer, Observable, EventState } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\n\r\n/**\r\n * This is the base class for all WebXR features.\r\n * Since most features require almost the same resources and callbacks, this class can be used to simplify the development\r\n * Note that since the features manager is using the `IWebXRFeature` you are in no way obligated to use this class\r\n */\r\nexport abstract class WebXRAbstractFeature implements IWebXRFeature {\r\n    private _attached: boolean = false;\r\n    private _removeOnDetach: {\r\n        observer: Nullable<Observer<any>>;\r\n        observable: Observable<any>;\r\n    }[] = [];\r\n\r\n    /**\r\n     * Is this feature disposed?\r\n     */\r\n    public isDisposed: boolean = false;\r\n\r\n    /**\r\n     * Should auto-attach be disabled?\r\n     */\r\n    public disableAutoAttach: boolean = false;\r\n\r\n    /**\r\n     * The name of the native xr feature name (like anchor, hit-test, or hand-tracking)\r\n     */\r\n    public xrNativeFeatureName: string = \"\";\r\n\r\n    /**\r\n     * Construct a new (abstract) WebXR feature\r\n     * @param _xrSessionManager the xr session manager for this feature\r\n     */\r\n    constructor(protected _xrSessionManager: WebXRSessionManager) {}\r\n\r\n    /**\r\n     * Is this feature attached\r\n     */\r\n    public get attached() {\r\n        return this._attached;\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     *\r\n     * @param force should attachment be forced (even when already attached)\r\n     * @returns true if successful, false is failed or already attached\r\n     */\r\n    public attach(force?: boolean): boolean {\r\n        // do not attach a disposed feature\r\n        if (this.isDisposed) {\r\n            return false;\r\n        }\r\n        if (!force) {\r\n            if (this.attached) {\r\n                return false;\r\n            }\r\n        } else {\r\n            if (this.attached) {\r\n                // detach first, to be sure\r\n                this.detach();\r\n            }\r\n        }\r\n\r\n        this._attached = true;\r\n        this._addNewAttachObserver(this._xrSessionManager.onXRFrameObservable, (frame) => this._onXRFrame(frame));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     *\r\n     * @returns true if successful, false if failed or already detached\r\n     */\r\n    public detach(): boolean {\r\n        if (!this._attached) {\r\n            this.disableAutoAttach = true;\r\n            return false;\r\n        }\r\n        this._attached = false;\r\n        this._removeOnDetach.forEach((toRemove) => {\r\n            toRemove.observable.remove(toRemove.observer);\r\n        });\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        this.detach();\r\n        this.isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * This function will be executed during before enabling the feature and can be used to not-allow enabling it.\r\n     * Note that at this point the session has NOT started, so this is purely checking if the browser supports it\r\n     *\r\n     * @returns whether or not the feature is compatible in this environment\r\n     */\r\n    public isCompatible(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * This is used to register callbacks that will automatically be removed when detach is called.\r\n     * @param observable the observable to which the observer will be attached\r\n     * @param callback the callback to register\r\n     */\r\n    protected _addNewAttachObserver<T>(observable: Observable<T>, callback: (eventData: T, eventState: EventState) => void) {\r\n        this._removeOnDetach.push({\r\n            observable,\r\n            observer: observable.add(callback),\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Code in this function will be executed on each xrFrame received from the browser.\r\n     * This function will not execute after the feature is detached.\r\n     * @param _xrFrame the current frame\r\n     */\r\n    protected abstract _onXRFrame(_xrFrame: XRFrame): void;\r\n}\r\n"],"mappings":";AAKA;;;;;AAKA,OAAM,MAAgBA,oBAAoB;EAsBtC;;;;EAIAC,YAAsBC,iBAAsC;IAAtC,KAAAA,iBAAiB,GAAjBA,iBAAiB;IAzB/B,KAAAC,SAAS,GAAY,KAAK;IAC1B,KAAAC,eAAe,GAGjB,EAAE;IAER;;;IAGO,KAAAC,UAAU,GAAY,KAAK;IAElC;;;IAGO,KAAAC,iBAAiB,GAAY,KAAK;IAEzC;;;IAGO,KAAAC,mBAAmB,GAAW,EAAE;EAMwB;EAE/D;;;EAGA,IAAWC,QAAQA,CAAA;IACf,OAAO,IAAI,CAACL,SAAS;EACzB;EAEA;;;;;;EAMOM,MAAMA,CAACC,KAAe;IACzB;IACA,IAAI,IAAI,CAACL,UAAU,EAAE;MACjB,OAAO,KAAK;;IAEhB,IAAI,CAACK,KAAK,EAAE;MACR,IAAI,IAAI,CAACF,QAAQ,EAAE;QACf,OAAO,KAAK;;KAEnB,MAAM;MACH,IAAI,IAAI,CAACA,QAAQ,EAAE;QACf;QACA,IAAI,CAACG,MAAM,EAAE;;;IAIrB,IAAI,CAACR,SAAS,GAAG,IAAI;IACrB,IAAI,CAACS,qBAAqB,CAAC,IAAI,CAACV,iBAAiB,CAACW,mBAAmB,EAAGC,KAAK,IAAK,IAAI,CAACC,UAAU,CAACD,KAAK,CAAC,CAAC;IACzG,OAAO,IAAI;EACf;EAEA;;;;;EAKOH,MAAMA,CAAA;IACT,IAAI,CAAC,IAAI,CAACR,SAAS,EAAE;MACjB,IAAI,CAACG,iBAAiB,GAAG,IAAI;MAC7B,OAAO,KAAK;;IAEhB,IAAI,CAACH,SAAS,GAAG,KAAK;IACtB,IAAI,CAACC,eAAe,CAACY,OAAO,CAAEC,QAAQ,IAAI;MACtCA,QAAQ,CAACC,UAAU,CAACC,MAAM,CAACF,QAAQ,CAACG,QAAQ,CAAC;IACjD,CAAC,CAAC;IACF,OAAO,IAAI;EACf;EAEA;;;EAGOC,OAAOA,CAAA;IACV,IAAI,CAACV,MAAM,EAAE;IACb,IAAI,CAACN,UAAU,GAAG,IAAI;EAC1B;EAEA;;;;;;EAMOiB,YAAYA,CAAA;IACf,OAAO,IAAI;EACf;EAEA;;;;;EAKUV,qBAAqBA,CAAIM,UAAyB,EAAEK,QAAwD;IAClH,IAAI,CAACnB,eAAe,CAACoB,IAAI,CAAC;MACtBN,UAAU;MACVE,QAAQ,EAAEF,UAAU,CAACO,GAAG,CAACF,QAAQ;KACpC,CAAC;EACN"},"metadata":{},"sourceType":"module","externalDependencies":[]}