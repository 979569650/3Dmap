{"ast":null,"code":"/** @internal */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction createXMLHttpRequest() {\n  // If running in Babylon Native, then defer to the native XMLHttpRequest, which has the same public contract\n  if (typeof _native !== \"undefined\" && _native.XMLHttpRequest) {\n    return new _native.XMLHttpRequest();\n  } else {\n    return new XMLHttpRequest();\n  }\n}\n/**\n * Extended version of XMLHttpRequest with support for customizations (headers, ...)\n */\nexport class WebRequest {\n  constructor() {\n    this._xhr = createXMLHttpRequest();\n    this._requestURL = \"\";\n  }\n  /**\n   * This function can be called to check if there are request modifiers for network requests\n   * @returns true if there are any custom requests available\n   */\n  static get IsCustomRequestAvailable() {\n    return Object.keys(WebRequest.CustomRequestHeaders).length > 0 || WebRequest.CustomRequestModifiers.length > 0;\n  }\n  _injectCustomRequestHeaders() {\n    if (this._shouldSkipRequestModifications(this._requestURL)) {\n      return;\n    }\n    for (const key in WebRequest.CustomRequestHeaders) {\n      const val = WebRequest.CustomRequestHeaders[key];\n      if (val) {\n        this._xhr.setRequestHeader(key, val);\n      }\n    }\n  }\n  _shouldSkipRequestModifications(url) {\n    return WebRequest.SkipRequestModificationForBabylonCDN && (url.includes(\"preview.babylonjs.com\") || url.includes(\"cdn.babylonjs.com\"));\n  }\n  /**\n   * Gets or sets a function to be called when loading progress changes\n   */\n  get onprogress() {\n    return this._xhr.onprogress;\n  }\n  set onprogress(value) {\n    this._xhr.onprogress = value;\n  }\n  /**\n   * Returns client's state\n   */\n  get readyState() {\n    return this._xhr.readyState;\n  }\n  /**\n   * Returns client's status\n   */\n  get status() {\n    return this._xhr.status;\n  }\n  /**\n   * Returns client's status as a text\n   */\n  get statusText() {\n    return this._xhr.statusText;\n  }\n  /**\n   * Returns client's response\n   */\n  get response() {\n    return this._xhr.response;\n  }\n  /**\n   * Returns client's response url\n   */\n  get responseURL() {\n    return this._xhr.responseURL;\n  }\n  /**\n   * Returns client's response as text\n   */\n  get responseText() {\n    return this._xhr.responseText;\n  }\n  /**\n   * Gets or sets the expected response type\n   */\n  get responseType() {\n    return this._xhr.responseType;\n  }\n  set responseType(value) {\n    this._xhr.responseType = value;\n  }\n  /**\n   * Gets or sets the timeout value in milliseconds\n   */\n  get timeout() {\n    return this._xhr.timeout;\n  }\n  set timeout(value) {\n    this._xhr.timeout = value;\n  }\n  addEventListener(type, listener, options) {\n    this._xhr.addEventListener(type, listener, options);\n  }\n  removeEventListener(type, listener, options) {\n    this._xhr.removeEventListener(type, listener, options);\n  }\n  /**\n   * Cancels any network activity\n   */\n  abort() {\n    this._xhr.abort();\n  }\n  /**\n   * Initiates the request. The optional argument provides the request body. The argument is ignored if request method is GET or HEAD\n   * @param body defines an optional request body\n   */\n  send(body) {\n    if (WebRequest.CustomRequestHeaders) {\n      this._injectCustomRequestHeaders();\n    }\n    this._xhr.send(body);\n  }\n  /**\n   * Sets the request method, request URL\n   * @param method defines the method to use (GET, POST, etc..)\n   * @param url defines the url to connect with\n   */\n  open(method, url) {\n    for (const update of WebRequest.CustomRequestModifiers) {\n      if (this._shouldSkipRequestModifications(url)) {\n        return;\n      }\n      update(this._xhr, url);\n    }\n    // Clean url\n    url = url.replace(\"file:http:\", \"http:\");\n    url = url.replace(\"file:https:\", \"https:\");\n    this._requestURL = url;\n    return this._xhr.open(method, url, true);\n  }\n  /**\n   * Sets the value of a request header.\n   * @param name The name of the header whose value is to be set\n   * @param value The value to set as the body of the header\n   */\n  setRequestHeader(name, value) {\n    this._xhr.setRequestHeader(name, value);\n  }\n  /**\n   * Get the string containing the text of a particular header's value.\n   * @param name The name of the header\n   * @returns The string containing the text of the given header name\n   */\n  getResponseHeader(name) {\n    return this._xhr.getResponseHeader(name);\n  }\n}\n/**\n * Custom HTTP Request Headers to be sent with XMLHttpRequests\n * i.e. when loading files, where the server/service expects an Authorization header\n */\nWebRequest.CustomRequestHeaders = {};\n/**\n * Add callback functions in this array to update all the requests before they get sent to the network\n */\nWebRequest.CustomRequestModifiers = new Array();\nWebRequest.SkipRequestModificationForBabylonCDN = true;","map":{"version":3,"names":["createXMLHttpRequest","_native","XMLHttpRequest","WebRequest","constructor","_xhr","_requestURL","IsCustomRequestAvailable","Object","keys","CustomRequestHeaders","length","CustomRequestModifiers","_injectCustomRequestHeaders","_shouldSkipRequestModifications","key","val","setRequestHeader","url","SkipRequestModificationForBabylonCDN","includes","onprogress","value","readyState","status","statusText","response","responseURL","responseText","responseType","timeout","addEventListener","type","listener","options","removeEventListener","abort","send","body","open","method","update","replace","name","getResponseHeader","Array"],"sources":["../../../../dev/core/src/Misc/webRequest.ts"],"sourcesContent":["import type { IWebRequest } from \"./interfaces/iWebRequest\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { INative } from \"../Engines/Native/nativeInterfaces\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare const _native: INative;\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction createXMLHttpRequest(): XMLHttpRequest {\r\n    // If running in Babylon Native, then defer to the native XMLHttpRequest, which has the same public contract\r\n    if (typeof _native !== \"undefined\" && _native.XMLHttpRequest) {\r\n        return new _native.XMLHttpRequest();\r\n    } else {\r\n        return new XMLHttpRequest();\r\n    }\r\n}\r\n\r\n/**\r\n * Extended version of XMLHttpRequest with support for customizations (headers, ...)\r\n */\r\nexport class WebRequest implements IWebRequest {\r\n    private readonly _xhr = createXMLHttpRequest();\r\n\r\n    /**\r\n     * Custom HTTP Request Headers to be sent with XMLHttpRequests\r\n     * i.e. when loading files, where the server/service expects an Authorization header\r\n     */\r\n    public static CustomRequestHeaders: { [key: string]: string } = {};\r\n\r\n    /**\r\n     * Add callback functions in this array to update all the requests before they get sent to the network\r\n     */\r\n    public static CustomRequestModifiers = new Array<(request: XMLHttpRequest, url: string) => void>();\r\n\r\n    public static SkipRequestModificationForBabylonCDN = true;\r\n\r\n    /**\r\n     * This function can be called to check if there are request modifiers for network requests\r\n     * @returns true if there are any custom requests available\r\n     */\r\n    public static get IsCustomRequestAvailable(): boolean {\r\n        return Object.keys(WebRequest.CustomRequestHeaders).length > 0 || WebRequest.CustomRequestModifiers.length > 0;\r\n    }\r\n\r\n    private _requestURL: string = \"\";\r\n\r\n    private _injectCustomRequestHeaders(): void {\r\n        if (this._shouldSkipRequestModifications(this._requestURL)) {\r\n            return;\r\n        }\r\n        for (const key in WebRequest.CustomRequestHeaders) {\r\n            const val = WebRequest.CustomRequestHeaders[key];\r\n            if (val) {\r\n                this._xhr.setRequestHeader(key, val);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _shouldSkipRequestModifications(url: string): boolean {\r\n        return WebRequest.SkipRequestModificationForBabylonCDN && (url.includes(\"preview.babylonjs.com\") || url.includes(\"cdn.babylonjs.com\"));\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a function to be called when loading progress changes\r\n     */\r\n    public get onprogress(): ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null {\r\n        return this._xhr.onprogress;\r\n    }\r\n\r\n    public set onprogress(value: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null) {\r\n        this._xhr.onprogress = value;\r\n    }\r\n\r\n    /**\r\n     * Returns client's state\r\n     */\r\n    public get readyState(): number {\r\n        return this._xhr.readyState;\r\n    }\r\n\r\n    /**\r\n     * Returns client's status\r\n     */\r\n    public get status(): number {\r\n        return this._xhr.status;\r\n    }\r\n\r\n    /**\r\n     * Returns client's status as a text\r\n     */\r\n    public get statusText(): string {\r\n        return this._xhr.statusText;\r\n    }\r\n\r\n    /**\r\n     * Returns client's response\r\n     */\r\n    public get response(): any {\r\n        return this._xhr.response;\r\n    }\r\n\r\n    /**\r\n     * Returns client's response url\r\n     */\r\n    public get responseURL(): string {\r\n        return this._xhr.responseURL;\r\n    }\r\n\r\n    /**\r\n     * Returns client's response as text\r\n     */\r\n    public get responseText(): string {\r\n        return this._xhr.responseText;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the expected response type\r\n     */\r\n    public get responseType(): XMLHttpRequestResponseType {\r\n        return this._xhr.responseType;\r\n    }\r\n\r\n    public set responseType(value: XMLHttpRequestResponseType) {\r\n        this._xhr.responseType = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the timeout value in milliseconds\r\n     */\r\n    public get timeout(): number {\r\n        return this._xhr.timeout;\r\n    }\r\n\r\n    public set timeout(value: number) {\r\n        this._xhr.timeout = value;\r\n    }\r\n\r\n    /** @internal */\r\n    public addEventListener<K extends keyof XMLHttpRequestEventMap>(\r\n        type: K,\r\n        listener: (this: XMLHttpRequest, ev: XMLHttpRequestEventMap[K]) => any,\r\n        options?: boolean | AddEventListenerOptions\r\n    ): void;\r\n    public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void {\r\n        this._xhr.addEventListener(type, listener, options);\r\n    }\r\n\r\n    /** @internal */\r\n    public removeEventListener<K extends keyof XMLHttpRequestEventMap>(\r\n        type: K,\r\n        listener: (this: XMLHttpRequest, ev: XMLHttpRequestEventMap[K]) => any,\r\n        options?: boolean | EventListenerOptions\r\n    ): void;\r\n    public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void {\r\n        this._xhr.removeEventListener(type, listener, options);\r\n    }\r\n\r\n    /**\r\n     * Cancels any network activity\r\n     */\r\n    public abort() {\r\n        this._xhr.abort();\r\n    }\r\n\r\n    /**\r\n     * Initiates the request. The optional argument provides the request body. The argument is ignored if request method is GET or HEAD\r\n     * @param body defines an optional request body\r\n     */\r\n    public send(body?: Document | XMLHttpRequestBodyInit | null): void {\r\n        if (WebRequest.CustomRequestHeaders) {\r\n            this._injectCustomRequestHeaders();\r\n        }\r\n\r\n        this._xhr.send(body);\r\n    }\r\n\r\n    /**\r\n     * Sets the request method, request URL\r\n     * @param method defines the method to use (GET, POST, etc..)\r\n     * @param url defines the url to connect with\r\n     */\r\n    public open(method: string, url: string): void {\r\n        for (const update of WebRequest.CustomRequestModifiers) {\r\n            if (this._shouldSkipRequestModifications(url)) {\r\n                return;\r\n            }\r\n            update(this._xhr, url);\r\n        }\r\n\r\n        // Clean url\r\n        url = url.replace(\"file:http:\", \"http:\");\r\n        url = url.replace(\"file:https:\", \"https:\");\r\n\r\n        this._requestURL = url;\r\n\r\n        return this._xhr.open(method, url, true);\r\n    }\r\n\r\n    /**\r\n     * Sets the value of a request header.\r\n     * @param name The name of the header whose value is to be set\r\n     * @param value The value to set as the body of the header\r\n     */\r\n    setRequestHeader(name: string, value: string): void {\r\n        this._xhr.setRequestHeader(name, value);\r\n    }\r\n\r\n    /**\r\n     * Get the string containing the text of a particular header's value.\r\n     * @param name The name of the header\r\n     * @returns The string containing the text of the given header name\r\n     */\r\n    getResponseHeader(name: string): Nullable<string> {\r\n        return this._xhr.getResponseHeader(name);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}