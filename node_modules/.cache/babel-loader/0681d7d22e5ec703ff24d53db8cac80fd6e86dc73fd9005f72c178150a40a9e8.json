{"ast":null,"code":"import { ShaderMaterial } from \"@babylonjs/core/Materials/shaderMaterial.js\";\nimport { Color3, TmpColors } from \"@babylonjs/core/Maths/math.color.js\";\nimport { Vector3 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport \"./shaders/handle.vertex.js\";\nimport \"./shaders/handle.fragment.js\";\n/**\n * Class used to render gizmo handles with fluent design\n */\nexport class HandleMaterial extends ShaderMaterial {\n  /**\n   * Is the material indicating hovering state\n   */\n  get hover() {\n    return this._hover;\n  }\n  set hover(b) {\n    this._hover = b;\n    this._updateInterpolationTarget();\n  }\n  /**\n   * Is the material indicating drag state\n   */\n  get drag() {\n    return this._drag;\n  }\n  set drag(b) {\n    this._drag = b;\n    this._updateInterpolationTarget();\n  }\n  /**\n   * Creates a handle material\n   * @param name Name of the material\n   * @param scene Scene\n   */\n  constructor(name, scene) {\n    super(name, scene, \"handle\", {\n      attributes: [\"position\"],\n      uniforms: [\"worldViewProjection\", \"color\", \"scale\", \"positionOffset\"],\n      needAlphaBlending: false,\n      needAlphaTesting: false\n    });\n    this._hover = false;\n    this._drag = false;\n    this._color = new Color3();\n    this._scale = 1;\n    this._lastTick = -1;\n    /**\n     * Length of animation\n     */\n    this.animationLength = 100;\n    /**\n     * Color of the handle when hovered\n     */\n    this.hoverColor = new Color3(0, 0.467, 0.84);\n    /**\n     * Color of the handle when idle\n     */\n    this.baseColor = new Color3(1, 1, 1);\n    /**\n     * Scale of the handle when hovered\n     */\n    this.hoverScale = 0.75;\n    /**\n     * Scale of the handle when idle\n     */\n    this.baseScale = 0.35;\n    /**\n     * Scale of the handle when dragged\n     */\n    this.dragScale = 0.55;\n    /**\n     * @internal\n     */\n    this._positionOffset = Vector3.Zero();\n    this._updateInterpolationTarget();\n    // Register callback for scene after render\n    this._lastTick = Date.now();\n    this._onBeforeRender = this.getScene().onBeforeRenderObservable.add(() => {\n      const tick = Date.now();\n      const delta = tick - this._lastTick;\n      const scaleDiff = this._targetScale - this._scale;\n      const colorDiff = TmpColors.Color3[0].copyFrom(this._targetColor).subtractToRef(this._color, TmpColors.Color3[0]);\n      this._scale = this._scale + scaleDiff * delta / this.animationLength;\n      colorDiff.scaleToRef(delta / this.animationLength, colorDiff);\n      this._color.addToRef(colorDiff, this._color);\n      this.setColor3(\"color\", this._color);\n      this.setFloat(\"scale\", this._scale);\n      this.setVector3(\"positionOffset\", this._positionOffset);\n      this._lastTick = tick;\n    });\n  }\n  _updateInterpolationTarget() {\n    if (this.drag) {\n      this._targetColor = this.hoverColor;\n      this._targetScale = this.dragScale;\n    } else if (this.hover) {\n      this._targetColor = this.hoverColor;\n      this._targetScale = this.hoverScale;\n    } else {\n      this._targetColor = this.baseColor;\n      this._targetScale = this.baseScale;\n    }\n  }\n  /**\n   * Disposes the handle material\n   */\n  dispose() {\n    super.dispose();\n    this.getScene().onBeforeRenderObservable.remove(this._onBeforeRender);\n  }\n}","map":{"version":3,"names":["ShaderMaterial","Color3","TmpColors","Vector3","HandleMaterial","hover","_hover","b","_updateInterpolationTarget","drag","_drag","constructor","name","scene","attributes","uniforms","needAlphaBlending","needAlphaTesting","_color","_scale","_lastTick","animationLength","hoverColor","baseColor","hoverScale","baseScale","dragScale","_positionOffset","Zero","Date","now","_onBeforeRender","getScene","onBeforeRenderObservable","add","tick","delta","scaleDiff","_targetScale","colorDiff","copyFrom","_targetColor","subtractToRef","scaleToRef","addToRef","setColor3","setFloat","setVector3","dispose","remove"],"sources":["../../../../../../dev/gui/src/3D/materials/handle/handleMaterial.ts"],"sourcesContent":["import { ShaderMaterial } from \"core/Materials/shaderMaterial\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Color3, TmpColors } from \"core/Maths/math.color\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\n\r\nimport \"./shaders/handle.vertex\";\r\nimport \"./shaders/handle.fragment\";\r\n\r\n/**\r\n * Class used to render gizmo handles with fluent design\r\n */\r\nexport class HandleMaterial extends ShaderMaterial {\r\n    private _hover: boolean = false;\r\n    private _drag: boolean = false;\r\n    private _onBeforeRender: Nullable<Observer<Scene>>;\r\n    private _color: Color3 = new Color3();\r\n    private _scale: number = 1;\r\n    private _targetColor: Color3;\r\n    private _targetScale: number;\r\n    private _lastTick = -1;\r\n\r\n    /**\r\n     * Is the material indicating hovering state\r\n     */\r\n    public get hover(): boolean {\r\n        return this._hover;\r\n    }\r\n\r\n    public set hover(b: boolean) {\r\n        this._hover = b;\r\n\r\n        this._updateInterpolationTarget();\r\n    }\r\n\r\n    /**\r\n     * Is the material indicating drag state\r\n     */\r\n    public get drag(): boolean {\r\n        return this._drag;\r\n    }\r\n\r\n    public set drag(b: boolean) {\r\n        this._drag = b;\r\n\r\n        this._updateInterpolationTarget();\r\n    }\r\n\r\n    /**\r\n     * Length of animation\r\n     */\r\n    public animationLength: number = 100;\r\n\r\n    /**\r\n     * Color of the handle when hovered\r\n     */\r\n    public hoverColor: Color3 = new Color3(0, 0.467, 0.84);\r\n\r\n    /**\r\n     * Color of the handle when idle\r\n     */\r\n    public baseColor: Color3 = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * Scale of the handle when hovered\r\n     */\r\n    public hoverScale: number = 0.75;\r\n\r\n    /**\r\n     * Scale of the handle when idle\r\n     */\r\n    public baseScale: number = 0.35;\r\n\r\n    /**\r\n     * Scale of the handle when dragged\r\n     */\r\n    public dragScale: number = 0.55;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _positionOffset: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Creates a handle material\r\n     * @param name Name of the material\r\n     * @param scene Scene\r\n     */\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene, \"handle\", {\r\n            attributes: [\"position\"],\r\n            uniforms: [\"worldViewProjection\", \"color\", \"scale\", \"positionOffset\"],\r\n            needAlphaBlending: false,\r\n            needAlphaTesting: false,\r\n        });\r\n\r\n        this._updateInterpolationTarget();\r\n\r\n        // Register callback for scene after render\r\n        this._lastTick = Date.now();\r\n        this._onBeforeRender = this.getScene().onBeforeRenderObservable.add(() => {\r\n            const tick = Date.now();\r\n            const delta = tick - this._lastTick;\r\n\r\n            const scaleDiff = this._targetScale - this._scale;\r\n            const colorDiff = TmpColors.Color3[0].copyFrom(this._targetColor).subtractToRef(this._color, TmpColors.Color3[0]);\r\n\r\n            this._scale = this._scale + (scaleDiff * delta) / this.animationLength;\r\n            colorDiff.scaleToRef(delta / this.animationLength, colorDiff);\r\n            this._color.addToRef(colorDiff, this._color);\r\n\r\n            this.setColor3(\"color\", this._color);\r\n            this.setFloat(\"scale\", this._scale);\r\n            this.setVector3(\"positionOffset\", this._positionOffset);\r\n\r\n            this._lastTick = tick;\r\n        });\r\n    }\r\n\r\n    private _updateInterpolationTarget() {\r\n        if (this.drag) {\r\n            this._targetColor = this.hoverColor;\r\n            this._targetScale = this.dragScale;\r\n        } else if (this.hover) {\r\n            this._targetColor = this.hoverColor;\r\n            this._targetScale = this.hoverScale;\r\n        } else {\r\n            this._targetColor = this.baseColor;\r\n            this._targetScale = this.baseScale;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the handle material\r\n     */\r\n    public dispose() {\r\n        super.dispose();\r\n        this.getScene().onBeforeRenderObservable.remove(this._onBeforeRender);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}