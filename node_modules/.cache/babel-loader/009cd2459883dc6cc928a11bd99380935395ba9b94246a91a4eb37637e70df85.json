{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { SerializationHelper } from \"../Misc/decorators.js\";\nimport { Matrix, Vector3, Vector2, Vector4, Quaternion } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { MaterialHelper } from \"./materialHelper.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { EffectFallbacks } from \"./effectFallbacks.js\";\nimport { WebRequest } from \"../Misc/webRequest.js\";\nimport { PushMaterial } from \"./pushMaterial.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"./clipPlaneMaterialHelper.js\";\nconst onCreatedEffectParameters = {\n  effect: null,\n  subMesh: null\n};\n/**\n * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\n *\n * This returned material effects how the mesh will look based on the code in the shaders.\n *\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderMaterial\n */\nexport class ShaderMaterial extends PushMaterial {\n  /**\n   * Instantiate a new shader material.\n   * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\n   * This returned material effects how the mesh will look based on the code in the shaders.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderMaterial\n   * @param name Define the name of the material in the scene\n   * @param scene Define the scene the material belongs to\n   * @param shaderPath Defines  the route to the shader code in one of three ways:\n   *  * object: \\{ vertex: \"custom\", fragment: \"custom\" \\}, used with Effect.ShadersStore[\"customVertexShader\"] and Effect.ShadersStore[\"customFragmentShader\"]\n   *  * object: \\{ vertexElement: \"vertexShaderCode\", fragmentElement: \"fragmentShaderCode\" \\}, used with shader code in script tags\n   *  * object: \\{ vertexSource: \"vertex shader code string\", fragmentSource: \"fragment shader code string\" \\} using with strings containing the shaders code\n   *  * string: \"./COMMON_NAME\", used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in index.html folder.\n   * @param options Define the options used to create the shader\n   * @param storeEffectOnSubMeshes true to store effect on submeshes, false to store the effect directly in the material class.\n   */\n  constructor(name, scene, shaderPath, options = {}, storeEffectOnSubMeshes = true) {\n    super(name, scene, storeEffectOnSubMeshes);\n    this._textures = {};\n    this._textureArrays = {};\n    this._externalTextures = {};\n    this._floats = {};\n    this._ints = {};\n    this._uints = {};\n    this._floatsArrays = {};\n    this._colors3 = {};\n    this._colors3Arrays = {};\n    this._colors4 = {};\n    this._colors4Arrays = {};\n    this._vectors2 = {};\n    this._vectors3 = {};\n    this._vectors4 = {};\n    this._quaternions = {};\n    this._quaternionsArrays = {};\n    this._matrices = {};\n    this._matrixArrays = {};\n    this._matrices3x3 = {};\n    this._matrices2x2 = {};\n    this._vectors2Arrays = {};\n    this._vectors3Arrays = {};\n    this._vectors4Arrays = {};\n    this._uniformBuffers = {};\n    this._textureSamplers = {};\n    this._storageBuffers = {};\n    this._cachedWorldViewMatrix = new Matrix();\n    this._cachedWorldViewProjectionMatrix = new Matrix();\n    this._multiview = false;\n    /**\n     * @internal\n     */\n    this._materialHelperNeedsPreviousMatrices = false;\n    this._shaderPath = shaderPath;\n    this._options = Object.assign({\n      needAlphaBlending: false,\n      needAlphaTesting: false,\n      attributes: [\"position\", \"normal\", \"uv\"],\n      uniforms: [\"worldViewProjection\"],\n      uniformBuffers: [],\n      samplers: [],\n      externalTextures: [],\n      samplerObjects: [],\n      storageBuffers: [],\n      defines: [],\n      useClipPlane: false\n    }, options);\n  }\n  /**\n   * Gets the shader path used to define the shader code\n   * It can be modified to trigger a new compilation\n   */\n  get shaderPath() {\n    return this._shaderPath;\n  }\n  /**\n   * Sets the shader path used to define the shader code\n   * It can be modified to trigger a new compilation\n   */\n  set shaderPath(shaderPath) {\n    this._shaderPath = shaderPath;\n  }\n  /**\n   * Gets the options used to compile the shader.\n   * They can be modified to trigger a new compilation\n   */\n  get options() {\n    return this._options;\n  }\n  /**\n   * is multiview set to true?\n   */\n  get isMultiview() {\n    return this._multiview;\n  }\n  /**\n   * Gets the current class name of the material e.g. \"ShaderMaterial\"\n   * Mainly use in serialization.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ShaderMaterial\";\n  }\n  /**\n   * Specifies if the material will require alpha blending\n   * @returns a boolean specifying if alpha blending is needed\n   */\n  needAlphaBlending() {\n    return this.alpha < 1.0 || this._options.needAlphaBlending;\n  }\n  /**\n   * Specifies if this material should be rendered in alpha test mode\n   * @returns a boolean specifying if an alpha test is needed.\n   */\n  needAlphaTesting() {\n    return this._options.needAlphaTesting;\n  }\n  _checkUniform(uniformName) {\n    if (this._options.uniforms.indexOf(uniformName) === -1) {\n      this._options.uniforms.push(uniformName);\n    }\n  }\n  /**\n   * Set a texture in the shader.\n   * @param name Define the name of the uniform samplers as defined in the shader\n   * @param texture Define the texture to bind to this sampler\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setTexture(name, texture) {\n    if (this._options.samplers.indexOf(name) === -1) {\n      this._options.samplers.push(name);\n    }\n    this._textures[name] = texture;\n    return this;\n  }\n  /**\n   * Set a texture array in the shader.\n   * @param name Define the name of the uniform sampler array as defined in the shader\n   * @param textures Define the list of textures to bind to this sampler\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setTextureArray(name, textures) {\n    if (this._options.samplers.indexOf(name) === -1) {\n      this._options.samplers.push(name);\n    }\n    this._checkUniform(name);\n    this._textureArrays[name] = textures;\n    return this;\n  }\n  /**\n   * Set an internal texture in the shader.\n   * @param name Define the name of the uniform samplers as defined in the shader\n   * @param texture Define the texture to bind to this sampler\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setExternalTexture(name, texture) {\n    if (this._options.externalTextures.indexOf(name) === -1) {\n      this._options.externalTextures.push(name);\n    }\n    this._externalTextures[name] = texture;\n    return this;\n  }\n  /**\n   * Set a float in the shader.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setFloat(name, value) {\n    this._checkUniform(name);\n    this._floats[name] = value;\n    return this;\n  }\n  /**\n   * Set a int in the shader.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setInt(name, value) {\n    this._checkUniform(name);\n    this._ints[name] = value;\n    return this;\n  }\n  /**\n   * Set a unsigned int in the shader.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setUInt(name, value) {\n    this._checkUniform(name);\n    this._uints[name] = value;\n    return this;\n  }\n  /**\n   * Set an array of floats in the shader.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setFloats(name, value) {\n    this._checkUniform(name);\n    this._floatsArrays[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec3 in the shader from a Color3.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setColor3(name, value) {\n    this._checkUniform(name);\n    this._colors3[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec3 array in the shader from a Color3 array.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setColor3Array(name, value) {\n    this._checkUniform(name);\n    this._colors3Arrays[name] = value.reduce((arr, color) => {\n      color.toArray(arr, arr.length);\n      return arr;\n    }, []);\n    return this;\n  }\n  /**\n   * Set a vec4 in the shader from a Color4.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setColor4(name, value) {\n    this._checkUniform(name);\n    this._colors4[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec4 array in the shader from a Color4 array.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setColor4Array(name, value) {\n    this._checkUniform(name);\n    this._colors4Arrays[name] = value.reduce((arr, color) => {\n      color.toArray(arr, arr.length);\n      return arr;\n    }, []);\n    return this;\n  }\n  /**\n   * Set a vec2 in the shader from a Vector2.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setVector2(name, value) {\n    this._checkUniform(name);\n    this._vectors2[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec3 in the shader from a Vector3.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setVector3(name, value) {\n    this._checkUniform(name);\n    this._vectors3[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec4 in the shader from a Vector4.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setVector4(name, value) {\n    this._checkUniform(name);\n    this._vectors4[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec4 in the shader from a Quaternion.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setQuaternion(name, value) {\n    this._checkUniform(name);\n    this._quaternions[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec4 array in the shader from a Quaternion array.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setQuaternionArray(name, value) {\n    this._checkUniform(name);\n    this._quaternionsArrays[name] = value.reduce((arr, quaternion) => {\n      quaternion.toArray(arr, arr.length);\n      return arr;\n    }, []);\n    return this;\n  }\n  /**\n   * Set a mat4 in the shader from a Matrix.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setMatrix(name, value) {\n    this._checkUniform(name);\n    this._matrices[name] = value;\n    return this;\n  }\n  /**\n   * Set a float32Array in the shader from a matrix array.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setMatrices(name, value) {\n    this._checkUniform(name);\n    const float32Array = new Float32Array(value.length * 16);\n    for (let index = 0; index < value.length; index++) {\n      const matrix = value[index];\n      matrix.copyToArray(float32Array, index * 16);\n    }\n    this._matrixArrays[name] = float32Array;\n    return this;\n  }\n  /**\n   * Set a mat3 in the shader from a Float32Array.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setMatrix3x3(name, value) {\n    this._checkUniform(name);\n    this._matrices3x3[name] = value;\n    return this;\n  }\n  /**\n   * Set a mat2 in the shader from a Float32Array.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setMatrix2x2(name, value) {\n    this._checkUniform(name);\n    this._matrices2x2[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec2 array in the shader from a number array.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setArray2(name, value) {\n    this._checkUniform(name);\n    this._vectors2Arrays[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec3 array in the shader from a number array.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setArray3(name, value) {\n    this._checkUniform(name);\n    this._vectors3Arrays[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec4 array in the shader from a number array.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setArray4(name, value) {\n    this._checkUniform(name);\n    this._vectors4Arrays[name] = value;\n    return this;\n  }\n  /**\n   * Set a uniform buffer in the shader\n   * @param name Define the name of the uniform as defined in the shader\n   * @param buffer Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setUniformBuffer(name, buffer) {\n    if (this._options.uniformBuffers.indexOf(name) === -1) {\n      this._options.uniformBuffers.push(name);\n    }\n    this._uniformBuffers[name] = buffer;\n    return this;\n  }\n  /**\n   * Set a texture sampler in the shader\n   * @param name Define the name of the uniform as defined in the shader\n   * @param sampler Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setTextureSampler(name, sampler) {\n    if (this._options.samplerObjects.indexOf(name) === -1) {\n      this._options.samplerObjects.push(name);\n    }\n    this._textureSamplers[name] = sampler;\n    return this;\n  }\n  /**\n   * Set a storage buffer in the shader\n   * @param name Define the name of the storage buffer as defined in the shader\n   * @param buffer Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setStorageBuffer(name, buffer) {\n    if (this._options.storageBuffers.indexOf(name) === -1) {\n      this._options.storageBuffers.push(name);\n    }\n    this._storageBuffers[name] = buffer;\n    return this;\n  }\n  /**\n   * Adds, removes, or replaces the specified shader define and value.\n   * * setDefine(\"MY_DEFINE\", true); // enables a boolean define\n   * * setDefine(\"MY_DEFINE\", \"0.5\"); // adds \"#define MY_DEFINE 0.5\" to the shader (or sets and replaces the value of any existing define with that name)\n   * * setDefine(\"MY_DEFINE\", false); // disables and removes the define\n   * Note if the active defines do change, the shader will be recompiled and this can be expensive.\n   * @param define the define name e.g., \"OUTPUT_TO_SRGB\" or \"#define OUTPUT_TO_SRGB\". If the define was passed into the constructor already, the version used should match that, and in either case, it should not include any appended value.\n   * @param value either the value of the define (e.g. a numerical value) or for booleans, true if the define should be enabled or false if it should be disabled\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setDefine(define, value) {\n    // First remove any existing define with this name.\n    const defineName = define.trimEnd() + \" \";\n    const existingDefineIdx = this.options.defines.findIndex(x => x === define || x.startsWith(defineName));\n    if (existingDefineIdx >= 0) {\n      this.options.defines.splice(existingDefineIdx, 1);\n    }\n    // Then add the new define value. (If it's a boolean value and false, don't add it.)\n    if (typeof value !== \"boolean\" || value) {\n      this.options.defines.push(defineName + value);\n    }\n    return this;\n  }\n  /**\n   * Specifies that the submesh is ready to be used\n   * @param mesh defines the mesh to check\n   * @param subMesh defines which submesh to check\n   * @param useInstances specifies that instances should be used\n   * @returns a boolean indicating that the submesh is ready or not\n   */\n  isReadyForSubMesh(mesh, subMesh, useInstances) {\n    return this.isReady(mesh, useInstances, subMesh);\n  }\n  /**\n   * Checks if the material is ready to render the requested mesh\n   * @param mesh Define the mesh to render\n   * @param useInstances Define whether or not the material is used with instances\n   * @param subMesh defines which submesh to render\n   * @returns true if ready, otherwise false\n   */\n  isReady(mesh, useInstances, subMesh) {\n    var _a, _b, _c, _d;\n    const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;\n    if (this.isFrozen) {\n      if (storeEffectOnSubMeshes) {\n        if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {\n          return true;\n        }\n      } else {\n        const effect = this._drawWrapper.effect;\n        if (effect && effect._wasPreviouslyReady && effect._wasPreviouslyUsingInstances === useInstances) {\n          return true;\n        }\n      }\n    }\n    const scene = this.getScene();\n    const engine = scene.getEngine();\n    // Instances\n    const defines = [];\n    const attribs = [];\n    const fallbacks = new EffectFallbacks();\n    let shaderName = this._shaderPath,\n      uniforms = this._options.uniforms,\n      uniformBuffers = this._options.uniformBuffers,\n      samplers = this._options.samplers;\n    // global multiview\n    if (engine.getCaps().multiview && scene.activeCamera && scene.activeCamera.outputRenderTarget && scene.activeCamera.outputRenderTarget.getViewCount() > 1) {\n      this._multiview = true;\n      defines.push(\"#define MULTIVIEW\");\n      if (this._options.uniforms.indexOf(\"viewProjection\") !== -1 && this._options.uniforms.indexOf(\"viewProjectionR\") === -1) {\n        this._options.uniforms.push(\"viewProjectionR\");\n      }\n    }\n    for (let index = 0; index < this._options.defines.length; index++) {\n      const defineToAdd = this._options.defines[index].indexOf(\"#define\") === 0 ? this._options.defines[index] : `#define ${this._options.defines[index]}`;\n      defines.push(defineToAdd);\n    }\n    for (let index = 0; index < this._options.attributes.length; index++) {\n      attribs.push(this._options.attributes[index]);\n    }\n    if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {\n      attribs.push(VertexBuffer.ColorKind);\n      defines.push(\"#define VERTEXCOLOR\");\n    }\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      MaterialHelper.PushAttributesForInstances(attribs, this._materialHelperNeedsPreviousMatrices);\n      if (mesh === null || mesh === void 0 ? void 0 : mesh.hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n        if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind)) {\n          attribs.push(VertexBuffer.ColorInstanceKind);\n          defines.push(\"#define INSTANCESCOLOR\");\n        }\n      }\n    }\n    // Bones\n    if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n      if (mesh.numBoneInfluencers > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n      const skeleton = mesh.skeleton;\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      fallbacks.addCPUSkinningFallback(0, mesh);\n      if (skeleton.isUsingTextureForMatrices) {\n        defines.push(\"#define BONETEXTURE\");\n        if (this._options.uniforms.indexOf(\"boneTextureWidth\") === -1) {\n          this._options.uniforms.push(\"boneTextureWidth\");\n        }\n        if (this._options.samplers.indexOf(\"boneSampler\") === -1) {\n          this._options.samplers.push(\"boneSampler\");\n        }\n      } else {\n        defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\n        if (this._options.uniforms.indexOf(\"mBones\") === -1) {\n          this._options.uniforms.push(\"mBones\");\n        }\n      }\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    }\n    // Morph\n    let numInfluencers = 0;\n    const manager = mesh ? mesh.morphTargetManager : null;\n    if (manager) {\n      const uv = manager.supportsUVs && defines.indexOf(\"#define UV1\") !== -1;\n      const tangent = manager.supportsTangents && defines.indexOf(\"#define TANGENT\") !== -1;\n      const normal = manager.supportsNormals && defines.indexOf(\"#define NORMAL\") !== -1;\n      numInfluencers = manager.numInfluencers;\n      if (uv) {\n        defines.push(\"#define MORPHTARGETS_UV\");\n      }\n      if (tangent) {\n        defines.push(\"#define MORPHTARGETS_TANGENT\");\n      }\n      if (normal) {\n        defines.push(\"#define MORPHTARGETS_NORMAL\");\n      }\n      if (numInfluencers > 0) {\n        defines.push(\"#define MORPHTARGETS\");\n      }\n      if (manager.isUsingTextureForTargets) {\n        defines.push(\"#define MORPHTARGETS_TEXTURE\");\n        if (this._options.uniforms.indexOf(\"morphTargetTextureIndices\") === -1) {\n          this._options.uniforms.push(\"morphTargetTextureIndices\");\n        }\n        if (this._options.samplers.indexOf(\"morphTargets\") === -1) {\n          this._options.samplers.push(\"morphTargets\");\n        }\n      }\n      defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numInfluencers);\n      for (let index = 0; index < numInfluencers; index++) {\n        attribs.push(VertexBuffer.PositionKind + index);\n        if (normal) {\n          attribs.push(VertexBuffer.NormalKind + index);\n        }\n        if (tangent) {\n          attribs.push(VertexBuffer.TangentKind + index);\n        }\n        if (uv) {\n          attribs.push(VertexBuffer.UVKind + \"_\" + index);\n        }\n      }\n      if (numInfluencers > 0) {\n        uniforms = uniforms.slice();\n        uniforms.push(\"morphTargetInfluences\");\n        uniforms.push(\"morphTargetTextureInfo\");\n        uniforms.push(\"morphTargetTextureIndices\");\n      }\n    } else {\n      defines.push(\"#define NUM_MORPH_INFLUENCERS 0\");\n    }\n    // Baked Vertex Animation\n    if (mesh) {\n      const bvaManager = mesh.bakedVertexAnimationManager;\n      if (bvaManager && bvaManager.isEnabled) {\n        defines.push(\"#define BAKED_VERTEX_ANIMATION_TEXTURE\");\n        if (this._options.uniforms.indexOf(\"bakedVertexAnimationSettings\") === -1) {\n          this._options.uniforms.push(\"bakedVertexAnimationSettings\");\n        }\n        if (this._options.uniforms.indexOf(\"bakedVertexAnimationTextureSizeInverted\") === -1) {\n          this._options.uniforms.push(\"bakedVertexAnimationTextureSizeInverted\");\n        }\n        if (this._options.uniforms.indexOf(\"bakedVertexAnimationTime\") === -1) {\n          this._options.uniforms.push(\"bakedVertexAnimationTime\");\n        }\n        if (this._options.samplers.indexOf(\"bakedVertexAnimationTexture\") === -1) {\n          this._options.samplers.push(\"bakedVertexAnimationTexture\");\n        }\n      }\n      MaterialHelper.PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);\n    }\n    // Textures\n    for (const name in this._textures) {\n      if (!this._textures[name].isReady()) {\n        return false;\n      }\n    }\n    // Alpha test\n    if (mesh && this._shouldTurnAlphaTestOn(mesh)) {\n      defines.push(\"#define ALPHATEST\");\n    }\n    // Clip planes\n    if (this._options.useClipPlane !== false) {\n      addClipPlaneUniforms(uniforms);\n      prepareStringDefinesForClipPlanes(this, scene, defines);\n    }\n    if (this.customShaderNameResolve) {\n      uniforms = uniforms.slice();\n      uniformBuffers = uniformBuffers.slice();\n      samplers = samplers.slice();\n      shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs);\n    }\n    const drawWrapper = storeEffectOnSubMeshes ? subMesh._getDrawWrapper() : this._drawWrapper;\n    const previousEffect = (_a = drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.effect) !== null && _a !== void 0 ? _a : null;\n    const previousDefines = (_b = drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.defines) !== null && _b !== void 0 ? _b : null;\n    const join = defines.join(\"\\n\");\n    let effect = previousEffect;\n    if (previousDefines !== join) {\n      effect = engine.createEffect(shaderName, {\n        attributes: attribs,\n        uniformsNames: uniforms,\n        uniformBuffersNames: uniformBuffers,\n        samplers: samplers,\n        defines: join,\n        fallbacks: fallbacks,\n        onCompiled: this.onCompiled,\n        onError: this.onError,\n        indexParameters: {\n          maxSimultaneousMorphTargets: numInfluencers\n        },\n        shaderLanguage: this._options.shaderLanguage\n      }, engine);\n      if (storeEffectOnSubMeshes) {\n        subMesh.setEffect(effect, join, this._materialContext);\n      } else if (drawWrapper) {\n        drawWrapper.setEffect(effect, join);\n      }\n      if (this._onEffectCreatedObservable) {\n        onCreatedEffectParameters.effect = effect;\n        onCreatedEffectParameters.subMesh = (_c = subMesh !== null && subMesh !== void 0 ? subMesh : mesh === null || mesh === void 0 ? void 0 : mesh.subMeshes[0]) !== null && _c !== void 0 ? _c : null;\n        this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\n      }\n    }\n    effect._wasPreviouslyUsingInstances = !!useInstances;\n    if ((_d = !(effect === null || effect === void 0 ? void 0 : effect.isReady())) !== null && _d !== void 0 ? _d : true) {\n      return false;\n    }\n    if (previousEffect !== effect) {\n      scene.resetCachedMaterial();\n    }\n    effect._wasPreviouslyReady = true;\n    return true;\n  }\n  /**\n   * Binds the world matrix to the material\n   * @param world defines the world transformation matrix\n   * @param effectOverride - If provided, use this effect instead of internal effect\n   */\n  bindOnlyWorldMatrix(world, effectOverride) {\n    const scene = this.getScene();\n    const effect = effectOverride !== null && effectOverride !== void 0 ? effectOverride : this.getEffect();\n    if (!effect) {\n      return;\n    }\n    if (this._options.uniforms.indexOf(\"world\") !== -1) {\n      effect.setMatrix(\"world\", world);\n    }\n    if (this._options.uniforms.indexOf(\"worldView\") !== -1) {\n      world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\n      effect.setMatrix(\"worldView\", this._cachedWorldViewMatrix);\n    }\n    if (this._options.uniforms.indexOf(\"worldViewProjection\") !== -1) {\n      world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\n      effect.setMatrix(\"worldViewProjection\", this._cachedWorldViewProjectionMatrix);\n    }\n  }\n  /**\n   * Binds the submesh to this material by preparing the effect and shader to draw\n   * @param world defines the world transformation matrix\n   * @param mesh defines the mesh containing the submesh\n   * @param subMesh defines the submesh to bind the material to\n   */\n  bindForSubMesh(world, mesh, subMesh) {\n    var _a;\n    this.bind(world, mesh, (_a = subMesh._drawWrapperOverride) === null || _a === void 0 ? void 0 : _a.effect, subMesh);\n  }\n  /**\n   * Binds the material to the mesh\n   * @param world defines the world transformation matrix\n   * @param mesh defines the mesh to bind the material to\n   * @param effectOverride - If provided, use this effect instead of internal effect\n   * @param subMesh defines the submesh to bind the material to\n   */\n  bind(world, mesh, effectOverride, subMesh) {\n    var _a;\n    // Std values\n    const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;\n    const effect = effectOverride !== null && effectOverride !== void 0 ? effectOverride : storeEffectOnSubMeshes ? subMesh.effect : this.getEffect();\n    if (!effect) {\n      return;\n    }\n    this._activeEffect = effect;\n    this.bindOnlyWorldMatrix(world, effectOverride);\n    const uniformBuffers = this._options.uniformBuffers;\n    let useSceneUBO = false;\n    if (effect && uniformBuffers && uniformBuffers.length > 0 && this.getScene().getEngine().supportsUniformBuffers) {\n      for (let i = 0; i < uniformBuffers.length; ++i) {\n        const bufferName = uniformBuffers[i];\n        switch (bufferName) {\n          case \"Mesh\":\n            if (mesh) {\n              mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\n              mesh.transferToEffect(world);\n            }\n            break;\n          case \"Scene\":\n            MaterialHelper.BindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());\n            this.getScene().finalizeSceneUbo();\n            useSceneUBO = true;\n            break;\n        }\n      }\n    }\n    const mustRebind = mesh && storeEffectOnSubMeshes ? this._mustRebind(this.getScene(), effect, mesh.visibility) : this.getScene().getCachedMaterial() !== this;\n    if (effect && mustRebind) {\n      if (!useSceneUBO && this._options.uniforms.indexOf(\"view\") !== -1) {\n        effect.setMatrix(\"view\", this.getScene().getViewMatrix());\n      }\n      if (!useSceneUBO && this._options.uniforms.indexOf(\"projection\") !== -1) {\n        effect.setMatrix(\"projection\", this.getScene().getProjectionMatrix());\n      }\n      if (!useSceneUBO && this._options.uniforms.indexOf(\"viewProjection\") !== -1) {\n        effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\n        if (this._multiview) {\n          effect.setMatrix(\"viewProjectionR\", this.getScene()._transformMatrixR);\n        }\n      }\n      if (this.getScene().activeCamera && this._options.uniforms.indexOf(\"cameraPosition\") !== -1) {\n        effect.setVector3(\"cameraPosition\", this.getScene().activeCamera.globalPosition);\n      }\n      // Bones\n      MaterialHelper.BindBonesParameters(mesh, effect);\n      // Clip plane\n      bindClipPlane(effect, this, this.getScene());\n      let name;\n      // Texture\n      for (name in this._textures) {\n        effect.setTexture(name, this._textures[name]);\n      }\n      // Texture arrays\n      for (name in this._textureArrays) {\n        effect.setTextureArray(name, this._textureArrays[name]);\n      }\n      // External texture\n      for (name in this._externalTextures) {\n        effect.setExternalTexture(name, this._externalTextures[name]);\n      }\n      // Int\n      for (name in this._ints) {\n        effect.setInt(name, this._ints[name]);\n      }\n      // UInt\n      for (name in this._uints) {\n        effect.setUInt(name, this._uints[name]);\n      }\n      // Float\n      for (name in this._floats) {\n        effect.setFloat(name, this._floats[name]);\n      }\n      // Floats\n      for (name in this._floatsArrays) {\n        effect.setArray(name, this._floatsArrays[name]);\n      }\n      // Color3\n      for (name in this._colors3) {\n        effect.setColor3(name, this._colors3[name]);\n      }\n      // Color3Array\n      for (name in this._colors3Arrays) {\n        effect.setArray3(name, this._colors3Arrays[name]);\n      }\n      // Color4\n      for (name in this._colors4) {\n        const color = this._colors4[name];\n        effect.setFloat4(name, color.r, color.g, color.b, color.a);\n      }\n      // Color4Array\n      for (name in this._colors4Arrays) {\n        effect.setArray4(name, this._colors4Arrays[name]);\n      }\n      // Vector2\n      for (name in this._vectors2) {\n        effect.setVector2(name, this._vectors2[name]);\n      }\n      // Vector3\n      for (name in this._vectors3) {\n        effect.setVector3(name, this._vectors3[name]);\n      }\n      // Vector4\n      for (name in this._vectors4) {\n        effect.setVector4(name, this._vectors4[name]);\n      }\n      // Quaternion\n      for (name in this._quaternions) {\n        effect.setQuaternion(name, this._quaternions[name]);\n      }\n      // Matrix\n      for (name in this._matrices) {\n        effect.setMatrix(name, this._matrices[name]);\n      }\n      // MatrixArray\n      for (name in this._matrixArrays) {\n        effect.setMatrices(name, this._matrixArrays[name]);\n      }\n      // Matrix 3x3\n      for (name in this._matrices3x3) {\n        effect.setMatrix3x3(name, this._matrices3x3[name]);\n      }\n      // Matrix 2x2\n      for (name in this._matrices2x2) {\n        effect.setMatrix2x2(name, this._matrices2x2[name]);\n      }\n      // Vector2Array\n      for (name in this._vectors2Arrays) {\n        effect.setArray2(name, this._vectors2Arrays[name]);\n      }\n      // Vector3Array\n      for (name in this._vectors3Arrays) {\n        effect.setArray3(name, this._vectors3Arrays[name]);\n      }\n      // Vector4Array\n      for (name in this._vectors4Arrays) {\n        effect.setArray4(name, this._vectors4Arrays[name]);\n      }\n      // QuaternionArray\n      for (name in this._quaternionsArrays) {\n        effect.setArray4(name, this._quaternionsArrays[name]);\n      }\n      // Uniform buffers\n      for (name in this._uniformBuffers) {\n        const buffer = this._uniformBuffers[name].getBuffer();\n        if (buffer) {\n          effect.bindUniformBuffer(buffer, name);\n        }\n      }\n      // Samplers\n      for (name in this._textureSamplers) {\n        effect.setTextureSampler(name, this._textureSamplers[name]);\n      }\n      // Storage buffers\n      for (name in this._storageBuffers) {\n        effect.setStorageBuffer(name, this._storageBuffers[name]);\n      }\n    }\n    if (effect && mesh && (mustRebind || !this.isFrozen)) {\n      // Morph targets\n      const manager = mesh.morphTargetManager;\n      if (manager && manager.numInfluencers > 0) {\n        MaterialHelper.BindMorphTargetParameters(mesh, effect);\n      }\n      const bvaManager = mesh.bakedVertexAnimationManager;\n      if (bvaManager && bvaManager.isEnabled) {\n        (_a = mesh.bakedVertexAnimationManager) === null || _a === void 0 ? void 0 : _a.bind(effect, !!effect._wasPreviouslyUsingInstances);\n      }\n    }\n    this._afterBind(mesh, effect);\n  }\n  /**\n   * Gets the active textures from the material\n   * @returns an array of textures\n   */\n  getActiveTextures() {\n    const activeTextures = super.getActiveTextures();\n    for (const name in this._textures) {\n      activeTextures.push(this._textures[name]);\n    }\n    for (const name in this._textureArrays) {\n      const array = this._textureArrays[name];\n      for (let index = 0; index < array.length; index++) {\n        activeTextures.push(array[index]);\n      }\n    }\n    return activeTextures;\n  }\n  /**\n   * Specifies if the material uses a texture\n   * @param texture defines the texture to check against the material\n   * @returns a boolean specifying if the material uses the texture\n   */\n  hasTexture(texture) {\n    if (super.hasTexture(texture)) {\n      return true;\n    }\n    for (const name in this._textures) {\n      if (this._textures[name] === texture) {\n        return true;\n      }\n    }\n    for (const name in this._textureArrays) {\n      const array = this._textureArrays[name];\n      for (let index = 0; index < array.length; index++) {\n        if (array[index] === texture) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Makes a duplicate of the material, and gives it a new name\n   * @param name defines the new name for the duplicated material\n   * @returns the cloned material\n   */\n  clone(name) {\n    const result = SerializationHelper.Clone(() => new ShaderMaterial(name, this.getScene(), this._shaderPath, this._options, this._storeEffectOnSubMeshes), this);\n    result.name = name;\n    result.id = name;\n    // Shader code path\n    if (typeof result._shaderPath === \"object\") {\n      result._shaderPath = Object.assign({}, result._shaderPath);\n    }\n    // Options\n    this._options = Object.assign({}, this._options);\n    Object.keys(this._options).forEach(propName => {\n      const propValue = this._options[propName];\n      if (Array.isArray(propValue)) {\n        this._options[propName] = propValue.slice(0);\n      }\n    });\n    // Stencil\n    this.stencil.copyTo(result.stencil);\n    // Texture\n    for (const key in this._textures) {\n      result.setTexture(key, this._textures[key]);\n    }\n    // TextureArray\n    for (const key in this._textureArrays) {\n      result.setTextureArray(key, this._textureArrays[key]);\n    }\n    // External texture\n    for (const key in this._externalTextures) {\n      result.setExternalTexture(key, this._externalTextures[key]);\n    }\n    // Int\n    for (const key in this._ints) {\n      result.setInt(key, this._ints[key]);\n    }\n    // UInt\n    for (const key in this._uints) {\n      result.setUInt(key, this._uints[key]);\n    }\n    // Float\n    for (const key in this._floats) {\n      result.setFloat(key, this._floats[key]);\n    }\n    // Floats\n    for (const key in this._floatsArrays) {\n      result.setFloats(key, this._floatsArrays[key]);\n    }\n    // Color3\n    for (const key in this._colors3) {\n      result.setColor3(key, this._colors3[key]);\n    }\n    // Color3Array\n    for (const key in this._colors3Arrays) {\n      result._colors3Arrays[key] = this._colors3Arrays[key];\n    }\n    // Color4\n    for (const key in this._colors4) {\n      result.setColor4(key, this._colors4[key]);\n    }\n    // Color4Array\n    for (const key in this._colors4Arrays) {\n      result._colors4Arrays[key] = this._colors4Arrays[key];\n    }\n    // Vector2\n    for (const key in this._vectors2) {\n      result.setVector2(key, this._vectors2[key]);\n    }\n    // Vector3\n    for (const key in this._vectors3) {\n      result.setVector3(key, this._vectors3[key]);\n    }\n    // Vector4\n    for (const key in this._vectors4) {\n      result.setVector4(key, this._vectors4[key]);\n    }\n    // Quaternion\n    for (const key in this._quaternions) {\n      result.setQuaternion(key, this._quaternions[key]);\n    }\n    // QuaternionArray\n    for (const key in this._quaternionsArrays) {\n      result._quaternionsArrays[key] = this._quaternionsArrays[key];\n    }\n    // Matrix\n    for (const key in this._matrices) {\n      result.setMatrix(key, this._matrices[key]);\n    }\n    // MatrixArray\n    for (const key in this._matrixArrays) {\n      result._matrixArrays[key] = this._matrixArrays[key].slice();\n    }\n    // Matrix 3x3\n    for (const key in this._matrices3x3) {\n      result.setMatrix3x3(key, this._matrices3x3[key]);\n    }\n    // Matrix 2x2\n    for (const key in this._matrices2x2) {\n      result.setMatrix2x2(key, this._matrices2x2[key]);\n    }\n    // Vector2Array\n    for (const key in this._vectors2Arrays) {\n      result.setArray2(key, this._vectors2Arrays[key]);\n    }\n    // Vector3Array\n    for (const key in this._vectors3Arrays) {\n      result.setArray3(key, this._vectors3Arrays[key]);\n    }\n    // Vector4Array\n    for (const key in this._vectors4Arrays) {\n      result.setArray4(key, this._vectors4Arrays[key]);\n    }\n    // Uniform buffers\n    for (const key in this._uniformBuffers) {\n      result.setUniformBuffer(key, this._uniformBuffers[key]);\n    }\n    // Samplers\n    for (const key in this._textureSamplers) {\n      result.setTextureSampler(key, this._textureSamplers[key]);\n    }\n    // Storag buffers\n    for (const key in this._storageBuffers) {\n      result.setStorageBuffer(key, this._storageBuffers[key]);\n    }\n    return result;\n  }\n  /**\n   * Disposes the material\n   * @param forceDisposeEffect specifies if effects should be forcefully disposed\n   * @param forceDisposeTextures specifies if textures should be forcefully disposed\n   * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\n   */\n  dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {\n    if (forceDisposeTextures) {\n      let name;\n      for (name in this._textures) {\n        this._textures[name].dispose();\n      }\n      for (name in this._textureArrays) {\n        const array = this._textureArrays[name];\n        for (let index = 0; index < array.length; index++) {\n          array[index].dispose();\n        }\n      }\n    }\n    this._textures = {};\n    super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\n  }\n  /**\n   * Serializes this material in a JSON representation\n   * @returns the serialized material object\n   */\n  serialize() {\n    const serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.customType = \"BABYLON.ShaderMaterial\";\n    serializationObject.uniqueId = this.uniqueId;\n    serializationObject.options = this._options;\n    serializationObject.shaderPath = this._shaderPath;\n    serializationObject.storeEffectOnSubMeshes = this._storeEffectOnSubMeshes;\n    let name;\n    // Stencil\n    serializationObject.stencil = this.stencil.serialize();\n    // Texture\n    serializationObject.textures = {};\n    for (name in this._textures) {\n      serializationObject.textures[name] = this._textures[name].serialize();\n    }\n    // Texture arrays\n    serializationObject.textureArrays = {};\n    for (name in this._textureArrays) {\n      serializationObject.textureArrays[name] = [];\n      const array = this._textureArrays[name];\n      for (let index = 0; index < array.length; index++) {\n        serializationObject.textureArrays[name].push(array[index].serialize());\n      }\n    }\n    // Int\n    serializationObject.ints = {};\n    for (name in this._ints) {\n      serializationObject.ints[name] = this._ints[name];\n    }\n    // UInt\n    serializationObject.uints = {};\n    for (name in this._uints) {\n      serializationObject.uints[name] = this._uints[name];\n    }\n    // Float\n    serializationObject.floats = {};\n    for (name in this._floats) {\n      serializationObject.floats[name] = this._floats[name];\n    }\n    // Floats\n    serializationObject.FloatArrays = {};\n    for (name in this._floatsArrays) {\n      serializationObject.FloatArrays[name] = this._floatsArrays[name];\n    }\n    // Color3\n    serializationObject.colors3 = {};\n    for (name in this._colors3) {\n      serializationObject.colors3[name] = this._colors3[name].asArray();\n    }\n    // Color3 array\n    serializationObject.colors3Arrays = {};\n    for (name in this._colors3Arrays) {\n      serializationObject.colors3Arrays[name] = this._colors3Arrays[name];\n    }\n    // Color4\n    serializationObject.colors4 = {};\n    for (name in this._colors4) {\n      serializationObject.colors4[name] = this._colors4[name].asArray();\n    }\n    // Color4 array\n    serializationObject.colors4Arrays = {};\n    for (name in this._colors4Arrays) {\n      serializationObject.colors4Arrays[name] = this._colors4Arrays[name];\n    }\n    // Vector2\n    serializationObject.vectors2 = {};\n    for (name in this._vectors2) {\n      serializationObject.vectors2[name] = this._vectors2[name].asArray();\n    }\n    // Vector3\n    serializationObject.vectors3 = {};\n    for (name in this._vectors3) {\n      serializationObject.vectors3[name] = this._vectors3[name].asArray();\n    }\n    // Vector4\n    serializationObject.vectors4 = {};\n    for (name in this._vectors4) {\n      serializationObject.vectors4[name] = this._vectors4[name].asArray();\n    }\n    // Quaternion\n    serializationObject.quaternions = {};\n    for (name in this._quaternions) {\n      serializationObject.quaternions[name] = this._quaternions[name].asArray();\n    }\n    // Matrix\n    serializationObject.matrices = {};\n    for (name in this._matrices) {\n      serializationObject.matrices[name] = this._matrices[name].asArray();\n    }\n    // MatrixArray\n    serializationObject.matrixArray = {};\n    for (name in this._matrixArrays) {\n      serializationObject.matrixArray[name] = this._matrixArrays[name];\n    }\n    // Matrix 3x3\n    serializationObject.matrices3x3 = {};\n    for (name in this._matrices3x3) {\n      serializationObject.matrices3x3[name] = this._matrices3x3[name];\n    }\n    // Matrix 2x2\n    serializationObject.matrices2x2 = {};\n    for (name in this._matrices2x2) {\n      serializationObject.matrices2x2[name] = this._matrices2x2[name];\n    }\n    // Vector2Array\n    serializationObject.vectors2Arrays = {};\n    for (name in this._vectors2Arrays) {\n      serializationObject.vectors2Arrays[name] = this._vectors2Arrays[name];\n    }\n    // Vector3Array\n    serializationObject.vectors3Arrays = {};\n    for (name in this._vectors3Arrays) {\n      serializationObject.vectors3Arrays[name] = this._vectors3Arrays[name];\n    }\n    // Vector4Array\n    serializationObject.vectors4Arrays = {};\n    for (name in this._vectors4Arrays) {\n      serializationObject.vectors4Arrays[name] = this._vectors4Arrays[name];\n    }\n    // QuaternionArray\n    serializationObject.quaternionsArrays = {};\n    for (name in this._quaternionsArrays) {\n      serializationObject.quaternionsArrays[name] = this._quaternionsArrays[name];\n    }\n    return serializationObject;\n  }\n  /**\n   * Creates a shader material from parsed shader material data\n   * @param source defines the JSON representation of the material\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a new material\n   */\n  static Parse(source, scene, rootUrl) {\n    const material = SerializationHelper.Parse(() => new ShaderMaterial(source.name, scene, source.shaderPath, source.options, source.storeEffectOnSubMeshes), source, scene, rootUrl);\n    let name;\n    // Stencil\n    if (source.stencil) {\n      material.stencil.parse(source.stencil, scene, rootUrl);\n    }\n    // Texture\n    for (name in source.textures) {\n      material.setTexture(name, Texture.Parse(source.textures[name], scene, rootUrl));\n    }\n    // Texture arrays\n    for (name in source.textureArrays) {\n      const array = source.textureArrays[name];\n      const textureArray = new Array();\n      for (let index = 0; index < array.length; index++) {\n        textureArray.push(Texture.Parse(array[index], scene, rootUrl));\n      }\n      material.setTextureArray(name, textureArray);\n    }\n    // Int\n    for (name in source.ints) {\n      material.setInt(name, source.ints[name]);\n    }\n    // UInt\n    for (name in source.uints) {\n      material.setUInt(name, source.uints[name]);\n    }\n    // Float\n    for (name in source.floats) {\n      material.setFloat(name, source.floats[name]);\n    }\n    // Floats\n    for (name in source.floatsArrays) {\n      material.setFloats(name, source.floatsArrays[name]);\n    }\n    // Color3\n    for (name in source.colors3) {\n      material.setColor3(name, Color3.FromArray(source.colors3[name]));\n    }\n    // Color3 arrays\n    for (name in source.colors3Arrays) {\n      const colors = source.colors3Arrays[name].reduce((arr, num, i) => {\n        if (i % 3 === 0) {\n          arr.push([num]);\n        } else {\n          arr[arr.length - 1].push(num);\n        }\n        return arr;\n      }, []).map(color => Color3.FromArray(color));\n      material.setColor3Array(name, colors);\n    }\n    // Color4\n    for (name in source.colors4) {\n      material.setColor4(name, Color4.FromArray(source.colors4[name]));\n    }\n    // Color4 arrays\n    for (name in source.colors4Arrays) {\n      const colors = source.colors4Arrays[name].reduce((arr, num, i) => {\n        if (i % 4 === 0) {\n          arr.push([num]);\n        } else {\n          arr[arr.length - 1].push(num);\n        }\n        return arr;\n      }, []).map(color => Color4.FromArray(color));\n      material.setColor4Array(name, colors);\n    }\n    // Vector2\n    for (name in source.vectors2) {\n      material.setVector2(name, Vector2.FromArray(source.vectors2[name]));\n    }\n    // Vector3\n    for (name in source.vectors3) {\n      material.setVector3(name, Vector3.FromArray(source.vectors3[name]));\n    }\n    // Vector4\n    for (name in source.vectors4) {\n      material.setVector4(name, Vector4.FromArray(source.vectors4[name]));\n    }\n    // Quaternion\n    for (name in source.quaternions) {\n      material.setQuaternion(name, Quaternion.FromArray(source.quaternions[name]));\n    }\n    // Matrix\n    for (name in source.matrices) {\n      material.setMatrix(name, Matrix.FromArray(source.matrices[name]));\n    }\n    // MatrixArray\n    for (name in source.matrixArray) {\n      material._matrixArrays[name] = new Float32Array(source.matrixArray[name]);\n    }\n    // Matrix 3x3\n    for (name in source.matrices3x3) {\n      material.setMatrix3x3(name, source.matrices3x3[name]);\n    }\n    // Matrix 2x2\n    for (name in source.matrices2x2) {\n      material.setMatrix2x2(name, source.matrices2x2[name]);\n    }\n    // Vector2Array\n    for (name in source.vectors2Arrays) {\n      material.setArray2(name, source.vectors2Arrays[name]);\n    }\n    // Vector3Array\n    for (name in source.vectors3Arrays) {\n      material.setArray3(name, source.vectors3Arrays[name]);\n    }\n    // Vector4Array\n    for (name in source.vectors4Arrays) {\n      material.setArray4(name, source.vectors4Arrays[name]);\n    }\n    // QuaternionArray\n    for (name in source.quaternionsArrays) {\n      material.setArray4(name, source.quaternionsArrays[name]);\n    }\n    return material;\n  }\n  /**\n   * Creates a new ShaderMaterial from a snippet saved in a remote file\n   * @param name defines the name of the ShaderMaterial to create (can be null or empty to use the one from the json data)\n   * @param url defines the url to load from\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a promise that will resolve to the new ShaderMaterial\n   */\n  static ParseFromFileAsync(name, url, scene, rootUrl = \"\") {\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            const serializationObject = JSON.parse(request.responseText);\n            const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\n            if (name) {\n              output.name = name;\n            }\n            resolve(output);\n          } else {\n            reject(\"Unable to load the ShaderMaterial\");\n          }\n        }\n      });\n      request.open(\"GET\", url);\n      request.send();\n    });\n  }\n  /**\n   * Creates a ShaderMaterial from a snippet saved by the Inspector\n   * @param snippetId defines the snippet to load\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a promise that will resolve to the new ShaderMaterial\n   */\n  static ParseFromSnippetAsync(snippetId, scene, rootUrl = \"\") {\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n            const serializationObject = JSON.parse(snippet.shaderMaterial);\n            const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\n            output.snippetId = snippetId;\n            resolve(output);\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  }\n}\n/** Define the Url to load snippets */\nShaderMaterial.SnippetUrl = `https://snippet.babylonjs.com`;\n/**\n * Creates a ShaderMaterial from a snippet saved by the Inspector\n * @deprecated Please use ParseFromSnippetAsync instead\n * @param snippetId defines the snippet to load\n * @param scene defines the hosting scene\n * @param rootUrl defines the root URL to use to load textures and relative dependencies\n * @returns a promise that will resolve to the new ShaderMaterial\n */\nShaderMaterial.CreateFromSnippetAsync = ShaderMaterial.ParseFromSnippetAsync;\nRegisterClass(\"BABYLON.ShaderMaterial\", ShaderMaterial);","map":{"version":3,"names":["SerializationHelper","Matrix","Vector3","Vector2","Vector4","Quaternion","VertexBuffer","Texture","MaterialHelper","RegisterClass","Color3","Color4","EffectFallbacks","WebRequest","PushMaterial","EngineStore","addClipPlaneUniforms","bindClipPlane","prepareStringDefinesForClipPlanes","onCreatedEffectParameters","effect","subMesh","ShaderMaterial","constructor","name","scene","shaderPath","options","storeEffectOnSubMeshes","_textures","_textureArrays","_externalTextures","_floats","_ints","_uints","_floatsArrays","_colors3","_colors3Arrays","_colors4","_colors4Arrays","_vectors2","_vectors3","_vectors4","_quaternions","_quaternionsArrays","_matrices","_matrixArrays","_matrices3x3","_matrices2x2","_vectors2Arrays","_vectors3Arrays","_vectors4Arrays","_uniformBuffers","_textureSamplers","_storageBuffers","_cachedWorldViewMatrix","_cachedWorldViewProjectionMatrix","_multiview","_materialHelperNeedsPreviousMatrices","_shaderPath","_options","Object","assign","needAlphaBlending","needAlphaTesting","attributes","uniforms","uniformBuffers","samplers","externalTextures","samplerObjects","storageBuffers","defines","useClipPlane","isMultiview","getClassName","alpha","_checkUniform","uniformName","indexOf","push","setTexture","texture","setTextureArray","textures","setExternalTexture","setFloat","value","setInt","setUInt","setFloats","setColor3","setColor3Array","reduce","arr","color","toArray","length","setColor4","setColor4Array","setVector2","setVector3","setVector4","setQuaternion","setQuaternionArray","quaternion","setMatrix","setMatrices","float32Array","Float32Array","index","matrix","copyToArray","setMatrix3x3","setMatrix2x2","setArray2","setArray3","setArray4","setUniformBuffer","buffer","setTextureSampler","sampler","setStorageBuffer","setDefine","define","defineName","trimEnd","existingDefineIdx","findIndex","x","startsWith","splice","isReadyForSubMesh","mesh","useInstances","isReady","_storeEffectOnSubMeshes","isFrozen","_wasPreviouslyReady","_drawWrapper","_wasPreviouslyUsingInstances","getScene","engine","getEngine","attribs","fallbacks","shaderName","getCaps","multiview","activeCamera","outputRenderTarget","getViewCount","defineToAdd","isVerticesDataPresent","ColorKind","PushAttributesForInstances","hasThinInstances","ColorInstanceKind","useBones","computeBonesUsingShaders","skeleton","MatricesIndicesKind","MatricesWeightsKind","numBoneInfluencers","MatricesIndicesExtraKind","MatricesWeightsExtraKind","addCPUSkinningFallback","isUsingTextureForMatrices","bones","numInfluencers","manager","morphTargetManager","uv","supportsUVs","tangent","supportsTangents","normal","supportsNormals","isUsingTextureForTargets","PositionKind","NormalKind","TangentKind","UVKind","slice","bvaManager","bakedVertexAnimationManager","isEnabled","PrepareAttributesForBakedVertexAnimation","_shouldTurnAlphaTestOn","customShaderNameResolve","drawWrapper","_getDrawWrapper","previousEffect","_a","previousDefines","_b","join","createEffect","uniformsNames","uniformBuffersNames","onCompiled","onError","indexParameters","maxSimultaneousMorphTargets","shaderLanguage","setEffect","_materialContext","_onEffectCreatedObservable","_c","subMeshes","notifyObservers","_d","resetCachedMaterial","bindOnlyWorldMatrix","world","effectOverride","getEffect","multiplyToRef","getViewMatrix","getTransformMatrix","bindForSubMesh","bind","_drawWrapperOverride","_activeEffect","useSceneUBO","supportsUniformBuffers","i","bufferName","getMeshUniformBuffer","bindToEffect","transferToEffect","BindSceneUniformBuffer","getSceneUniformBuffer","finalizeSceneUbo","mustRebind","_mustRebind","visibility","getCachedMaterial","getProjectionMatrix","_transformMatrixR","globalPosition","BindBonesParameters","setArray","setFloat4","r","g","b","a","getBuffer","bindUniformBuffer","BindMorphTargetParameters","_afterBind","getActiveTextures","activeTextures","array","hasTexture","clone","result","Clone","id","keys","forEach","propName","propValue","Array","isArray","stencil","copyTo","key","dispose","forceDisposeEffect","forceDisposeTextures","notBoundToMesh","serialize","serializationObject","Serialize","customType","uniqueId","textureArrays","ints","uints","floats","FloatArrays","colors3","asArray","colors3Arrays","colors4","colors4Arrays","vectors2","vectors3","vectors4","quaternions","matrices","matrixArray","matrices3x3","matrices2x2","vectors2Arrays","vectors3Arrays","vectors4Arrays","quaternionsArrays","Parse","source","rootUrl","material","parse","textureArray","floatsArrays","FromArray","colors","num","map","ParseFromFileAsync","url","Promise","resolve","reject","request","addEventListener","readyState","status","JSON","responseText","output","LastCreatedScene","open","send","ParseFromSnippetAsync","snippetId","snippet","jsonPayload","shaderMaterial","SnippetUrl","replace","CreateFromSnippetAsync"],"sources":["../../../../dev/core/src/Materials/shaderMaterial.ts"],"sourcesContent":["import { SerializationHelper } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3, Vector2, Vector4, Quaternion } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { MaterialHelper } from \"./materialHelper\";\r\nimport type { Effect, IEffectCreationOptions } from \"./effect\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { EffectFallbacks } from \"./effectFallbacks\";\r\nimport { WebRequest } from \"../Misc/webRequest\";\r\nimport type { ShaderLanguage } from \"./shaderLanguage\";\r\nimport type { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { TextureSampler } from \"./Textures/textureSampler\";\r\nimport type { StorageBuffer } from \"../Buffers/storageBuffer\";\r\nimport { PushMaterial } from \"./pushMaterial\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"./clipPlaneMaterialHelper\";\r\n\r\nimport type { ExternalTexture } from \"./Textures/externalTexture\";\r\n\r\nconst onCreatedEffectParameters = { effect: null as unknown as Effect, subMesh: null as unknown as Nullable<SubMesh> };\r\n\r\n/**\r\n * Defines the options associated with the creation of a shader material.\r\n */\r\nexport interface IShaderMaterialOptions {\r\n    /**\r\n     * Does the material work in alpha blend mode\r\n     */\r\n    needAlphaBlending: boolean;\r\n\r\n    /**\r\n     * Does the material work in alpha test mode\r\n     */\r\n    needAlphaTesting: boolean;\r\n\r\n    /**\r\n     * The list of attribute names used in the shader\r\n     */\r\n    attributes: string[];\r\n\r\n    /**\r\n     * The list of uniform names used in the shader\r\n     */\r\n    uniforms: string[];\r\n\r\n    /**\r\n     * The list of UBO names used in the shader\r\n     */\r\n    uniformBuffers: string[];\r\n\r\n    /**\r\n     * The list of sampler (texture) names used in the shader\r\n     */\r\n    samplers: string[];\r\n\r\n    /**\r\n     * The list of external texture names used in the shader\r\n     */\r\n    externalTextures: string[];\r\n\r\n    /**\r\n     * The list of sampler object names used in the shader\r\n     */\r\n    samplerObjects: string[];\r\n\r\n    /**\r\n     * The list of storage buffer names used in the shader\r\n     */\r\n    storageBuffers: string[];\r\n\r\n    /**\r\n     * The list of defines used in the shader\r\n     */\r\n    defines: string[];\r\n\r\n    /**\r\n     * Defines if clip planes have to be turned on: true to turn them on, false to turn them off and null to turn them on/off depending on the scene configuration (scene.clipPlaneX)\r\n     */\r\n    useClipPlane: Nullable<boolean>;\r\n\r\n    /**\r\n     * The language the shader is written in (default: GLSL)\r\n     */\r\n    shaderLanguage?: ShaderLanguage;\r\n}\r\n\r\n/**\r\n * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n *\r\n * This returned material effects how the mesh will look based on the code in the shaders.\r\n *\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderMaterial\r\n */\r\nexport class ShaderMaterial extends PushMaterial {\r\n    private _shaderPath: any;\r\n    private _options: IShaderMaterialOptions;\r\n    private _textures: { [name: string]: BaseTexture } = {};\r\n    private _textureArrays: { [name: string]: BaseTexture[] } = {};\r\n    private _externalTextures: { [name: string]: ExternalTexture } = {};\r\n    private _floats: { [name: string]: number } = {};\r\n    private _ints: { [name: string]: number } = {};\r\n    private _uints: { [name: string]: number } = {};\r\n    private _floatsArrays: { [name: string]: number[] } = {};\r\n    private _colors3: { [name: string]: Color3 } = {};\r\n    private _colors3Arrays: { [name: string]: number[] } = {};\r\n    private _colors4: { [name: string]: Color4 } = {};\r\n    private _colors4Arrays: { [name: string]: number[] } = {};\r\n    private _vectors2: { [name: string]: Vector2 } = {};\r\n    private _vectors3: { [name: string]: Vector3 } = {};\r\n    private _vectors4: { [name: string]: Vector4 } = {};\r\n    private _quaternions: { [name: string]: Quaternion } = {};\r\n    private _quaternionsArrays: { [name: string]: number[] } = {};\r\n    private _matrices: { [name: string]: Matrix } = {};\r\n    private _matrixArrays: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _matrices3x3: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _matrices2x2: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _vectors2Arrays: { [name: string]: number[] } = {};\r\n    private _vectors3Arrays: { [name: string]: number[] } = {};\r\n    private _vectors4Arrays: { [name: string]: number[] } = {};\r\n    private _uniformBuffers: { [name: string]: UniformBuffer } = {};\r\n    private _textureSamplers: { [name: string]: TextureSampler } = {};\r\n    private _storageBuffers: { [name: string]: StorageBuffer } = {};\r\n    private _cachedWorldViewMatrix = new Matrix();\r\n    private _cachedWorldViewProjectionMatrix = new Matrix();\r\n    private _multiview = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _materialHelperNeedsPreviousMatrices = false;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Snippet ID if the material was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Instantiate a new shader material.\r\n     * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n     * This returned material effects how the mesh will look based on the code in the shaders.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderMaterial\r\n     * @param name Define the name of the material in the scene\r\n     * @param scene Define the scene the material belongs to\r\n     * @param shaderPath Defines  the route to the shader code in one of three ways:\r\n     *  * object: \\{ vertex: \"custom\", fragment: \"custom\" \\}, used with Effect.ShadersStore[\"customVertexShader\"] and Effect.ShadersStore[\"customFragmentShader\"]\r\n     *  * object: \\{ vertexElement: \"vertexShaderCode\", fragmentElement: \"fragmentShaderCode\" \\}, used with shader code in script tags\r\n     *  * object: \\{ vertexSource: \"vertex shader code string\", fragmentSource: \"fragment shader code string\" \\} using with strings containing the shaders code\r\n     *  * string: \"./COMMON_NAME\", used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in index.html folder.\r\n     * @param options Define the options used to create the shader\r\n     * @param storeEffectOnSubMeshes true to store effect on submeshes, false to store the effect directly in the material class.\r\n     */\r\n    constructor(name: string, scene: Scene, shaderPath: any, options: Partial<IShaderMaterialOptions> = {}, storeEffectOnSubMeshes = true) {\r\n        super(name, scene, storeEffectOnSubMeshes);\r\n        this._shaderPath = shaderPath;\r\n\r\n        this._options = {\r\n            needAlphaBlending: false,\r\n            needAlphaTesting: false,\r\n            attributes: [\"position\", \"normal\", \"uv\"],\r\n            uniforms: [\"worldViewProjection\"],\r\n            uniformBuffers: [],\r\n            samplers: [],\r\n            externalTextures: [],\r\n            samplerObjects: [],\r\n            storageBuffers: [],\r\n            defines: [],\r\n            useClipPlane: false,\r\n            ...options,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\r\n    public get shaderPath(): any {\r\n        return this._shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Sets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\r\n    public set shaderPath(shaderPath: any) {\r\n        this._shaderPath = shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Gets the options used to compile the shader.\r\n     * They can be modified to trigger a new compilation\r\n     */\r\n    public get options(): IShaderMaterialOptions {\r\n        return this._options;\r\n    }\r\n\r\n    /**\r\n     * is multiview set to true?\r\n     */\r\n    public get isMultiview(): boolean {\r\n        return this._multiview;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"ShaderMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ShaderMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0 || this._options.needAlphaBlending;\r\n    }\r\n\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        return this._options.needAlphaTesting;\r\n    }\r\n\r\n    private _checkUniform(uniformName: string): void {\r\n        if (this._options.uniforms.indexOf(uniformName) === -1) {\r\n            this._options.uniforms.push(uniformName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the shader.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTexture(name: string, texture: BaseTexture): ShaderMaterial {\r\n        if (this._options.samplers.indexOf(name) === -1) {\r\n            this._options.samplers.push(name);\r\n        }\r\n        this._textures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a texture array in the shader.\r\n     * @param name Define the name of the uniform sampler array as defined in the shader\r\n     * @param textures Define the list of textures to bind to this sampler\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTextureArray(name: string, textures: BaseTexture[]): ShaderMaterial {\r\n        if (this._options.samplers.indexOf(name) === -1) {\r\n            this._options.samplers.push(name);\r\n        }\r\n\r\n        this._checkUniform(name);\r\n\r\n        this._textureArrays[name] = textures;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an internal texture in the shader.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setExternalTexture(name: string, texture: ExternalTexture): ShaderMaterial {\r\n        if (this._options.externalTextures.indexOf(name) === -1) {\r\n            this._options.externalTextures.push(name);\r\n        }\r\n        this._externalTextures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloat(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._floats[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setInt(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._ints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a unsigned int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setUInt(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._uints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an array of floats in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloats(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._floatsArrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Color3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3(name: string, value: Color3): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 array in the shader from a Color3 array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3Array(name: string, value: Color3[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors3Arrays[name] = value.reduce((arr, color) => {\r\n            color.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Color4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4(name: string, value: Color4): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a Color4 array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4Array(name: string, value: Color4[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors4Arrays[name] = value.reduce((arr, color) => {\r\n            color.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 in the shader from a Vector2.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector2(name: string, value: Vector2): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Vector3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector3(name: string, value: Vector3): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Vector4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector4(name: string, value: Vector4): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Quaternion.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setQuaternion(name: string, value: Quaternion): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._quaternions[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a Quaternion array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setQuaternionArray(name: string, value: Quaternion[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._quaternionsArrays[name] = value.reduce((arr, quaternion) => {\r\n            quaternion.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat4 in the shader from a Matrix.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix(name: string, value: Matrix): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float32Array in the shader from a matrix array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrices(name: string, value: Matrix[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n\r\n        const float32Array = new Float32Array(value.length * 16);\r\n\r\n        for (let index = 0; index < value.length; index++) {\r\n            const matrix = value[index];\r\n\r\n            matrix.copyToArray(float32Array, index * 16);\r\n        }\r\n\r\n        this._matrixArrays[name] = float32Array;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat3 in the shader from a Float32Array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix3x3(name: string, value: Float32Array | Array<number>): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices3x3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat2 in the shader from a Float32Array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix2x2(name: string, value: Float32Array | Array<number>): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices2x2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray2(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors2Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray3(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors3Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray4(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors4Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a uniform buffer in the shader\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param buffer Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setUniformBuffer(name: string, buffer: UniformBuffer): ShaderMaterial {\r\n        if (this._options.uniformBuffers.indexOf(name) === -1) {\r\n            this._options.uniformBuffers.push(name);\r\n        }\r\n        this._uniformBuffers[name] = buffer;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a texture sampler in the shader\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param sampler Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTextureSampler(name: string, sampler: TextureSampler): ShaderMaterial {\r\n        if (this._options.samplerObjects.indexOf(name) === -1) {\r\n            this._options.samplerObjects.push(name);\r\n        }\r\n        this._textureSamplers[name] = sampler;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a storage buffer in the shader\r\n     * @param name Define the name of the storage buffer as defined in the shader\r\n     * @param buffer Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setStorageBuffer(name: string, buffer: StorageBuffer): ShaderMaterial {\r\n        if (this._options.storageBuffers.indexOf(name) === -1) {\r\n            this._options.storageBuffers.push(name);\r\n        }\r\n        this._storageBuffers[name] = buffer;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds, removes, or replaces the specified shader define and value.\r\n     * * setDefine(\"MY_DEFINE\", true); // enables a boolean define\r\n     * * setDefine(\"MY_DEFINE\", \"0.5\"); // adds \"#define MY_DEFINE 0.5\" to the shader (or sets and replaces the value of any existing define with that name)\r\n     * * setDefine(\"MY_DEFINE\", false); // disables and removes the define\r\n     * Note if the active defines do change, the shader will be recompiled and this can be expensive.\r\n     * @param define the define name e.g., \"OUTPUT_TO_SRGB\" or \"#define OUTPUT_TO_SRGB\". If the define was passed into the constructor already, the version used should match that, and in either case, it should not include any appended value.\r\n     * @param value either the value of the define (e.g. a numerical value) or for booleans, true if the define should be enabled or false if it should be disabled\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setDefine(define: string, value: boolean | string): ShaderMaterial {\r\n        // First remove any existing define with this name.\r\n        const defineName = define.trimEnd() + \" \";\r\n        const existingDefineIdx = this.options.defines.findIndex((x) => x === define || x.startsWith(defineName));\r\n        if (existingDefineIdx >= 0) {\r\n            this.options.defines.splice(existingDefineIdx, 1);\r\n        }\r\n\r\n        // Then add the new define value. (If it's a boolean value and false, don't add it.)\r\n        if (typeof value !== \"boolean\" || value) {\r\n            this.options.defines.push(defineName + value);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        return this.isReady(mesh, useInstances, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Checks if the material is ready to render the requested mesh\r\n     * @param mesh Define the mesh to render\r\n     * @param useInstances Define whether or not the material is used with instances\r\n     * @param subMesh defines which submesh to render\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    public isReady(mesh?: AbstractMesh, useInstances?: boolean, subMesh?: SubMesh): boolean {\r\n        const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;\r\n\r\n        if (this.isFrozen) {\r\n            if (storeEffectOnSubMeshes) {\r\n                if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {\r\n                    return true;\r\n                }\r\n            } else {\r\n                const effect = this._drawWrapper.effect;\r\n                if (effect && effect._wasPreviouslyReady && effect._wasPreviouslyUsingInstances === useInstances) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const engine = scene.getEngine();\r\n\r\n        // Instances\r\n        const defines = [];\r\n        const attribs = [];\r\n        const fallbacks = new EffectFallbacks();\r\n\r\n        let shaderName = this._shaderPath,\r\n            uniforms = this._options.uniforms,\r\n            uniformBuffers = this._options.uniformBuffers,\r\n            samplers = this._options.samplers;\r\n\r\n        // global multiview\r\n        if (engine.getCaps().multiview && scene.activeCamera && scene.activeCamera.outputRenderTarget && scene.activeCamera.outputRenderTarget.getViewCount() > 1) {\r\n            this._multiview = true;\r\n            defines.push(\"#define MULTIVIEW\");\r\n            if (this._options.uniforms.indexOf(\"viewProjection\") !== -1 && this._options.uniforms.indexOf(\"viewProjectionR\") === -1) {\r\n                this._options.uniforms.push(\"viewProjectionR\");\r\n            }\r\n        }\r\n\r\n        for (let index = 0; index < this._options.defines.length; index++) {\r\n            const defineToAdd = this._options.defines[index].indexOf(\"#define\") === 0 ? this._options.defines[index] : `#define ${this._options.defines[index]}`;\r\n            defines.push(defineToAdd);\r\n        }\r\n\r\n        for (let index = 0; index < this._options.attributes.length; index++) {\r\n            attribs.push(this._options.attributes[index]);\r\n        }\r\n\r\n        if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            attribs.push(VertexBuffer.ColorKind);\r\n            defines.push(\"#define VERTEXCOLOR\");\r\n        }\r\n\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs, this._materialHelperNeedsPreviousMatrices);\r\n            if (mesh?.hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n                if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind)) {\r\n                    attribs.push(VertexBuffer.ColorInstanceKind);\r\n                    defines.push(\"#define INSTANCESCOLOR\");\r\n                }\r\n            }\r\n        }\r\n\r\n        // Bones\r\n        if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n\r\n            const skeleton = mesh.skeleton;\r\n\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            fallbacks.addCPUSkinningFallback(0, mesh);\r\n\r\n            if (skeleton.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n\r\n                if (this._options.uniforms.indexOf(\"boneTextureWidth\") === -1) {\r\n                    this._options.uniforms.push(\"boneTextureWidth\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"boneSampler\") === -1) {\r\n                    this._options.samplers.push(\"boneSampler\");\r\n                }\r\n            } else {\r\n                defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\r\n\r\n                if (this._options.uniforms.indexOf(\"mBones\") === -1) {\r\n                    this._options.uniforms.push(\"mBones\");\r\n                }\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph\r\n        let numInfluencers = 0;\r\n        const manager = mesh ? (<Mesh>mesh).morphTargetManager : null;\r\n        if (manager) {\r\n            const uv = manager.supportsUVs && defines.indexOf(\"#define UV1\") !== -1;\r\n            const tangent = manager.supportsTangents && defines.indexOf(\"#define TANGENT\") !== -1;\r\n            const normal = manager.supportsNormals && defines.indexOf(\"#define NORMAL\") !== -1;\r\n            numInfluencers = manager.numInfluencers;\r\n            if (uv) {\r\n                defines.push(\"#define MORPHTARGETS_UV\");\r\n            }\r\n            if (tangent) {\r\n                defines.push(\"#define MORPHTARGETS_TANGENT\");\r\n            }\r\n            if (normal) {\r\n                defines.push(\"#define MORPHTARGETS_NORMAL\");\r\n            }\r\n            if (numInfluencers > 0) {\r\n                defines.push(\"#define MORPHTARGETS\");\r\n            }\r\n            if (manager.isUsingTextureForTargets) {\r\n                defines.push(\"#define MORPHTARGETS_TEXTURE\");\r\n\r\n                if (this._options.uniforms.indexOf(\"morphTargetTextureIndices\") === -1) {\r\n                    this._options.uniforms.push(\"morphTargetTextureIndices\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"morphTargets\") === -1) {\r\n                    this._options.samplers.push(\"morphTargets\");\r\n                }\r\n            }\r\n            defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numInfluencers);\r\n            for (let index = 0; index < numInfluencers; index++) {\r\n                attribs.push(VertexBuffer.PositionKind + index);\r\n\r\n                if (normal) {\r\n                    attribs.push(VertexBuffer.NormalKind + index);\r\n                }\r\n\r\n                if (tangent) {\r\n                    attribs.push(VertexBuffer.TangentKind + index);\r\n                }\r\n\r\n                if (uv) {\r\n                    attribs.push(VertexBuffer.UVKind + \"_\" + index);\r\n                }\r\n            }\r\n            if (numInfluencers > 0) {\r\n                uniforms = uniforms.slice();\r\n                uniforms.push(\"morphTargetInfluences\");\r\n                uniforms.push(\"morphTargetTextureInfo\");\r\n                uniforms.push(\"morphTargetTextureIndices\");\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_MORPH_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Baked Vertex Animation\r\n        if (mesh) {\r\n            const bvaManager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n\r\n            if (bvaManager && bvaManager.isEnabled) {\r\n                defines.push(\"#define BAKED_VERTEX_ANIMATION_TEXTURE\");\r\n                if (this._options.uniforms.indexOf(\"bakedVertexAnimationSettings\") === -1) {\r\n                    this._options.uniforms.push(\"bakedVertexAnimationSettings\");\r\n                }\r\n                if (this._options.uniforms.indexOf(\"bakedVertexAnimationTextureSizeInverted\") === -1) {\r\n                    this._options.uniforms.push(\"bakedVertexAnimationTextureSizeInverted\");\r\n                }\r\n                if (this._options.uniforms.indexOf(\"bakedVertexAnimationTime\") === -1) {\r\n                    this._options.uniforms.push(\"bakedVertexAnimationTime\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"bakedVertexAnimationTexture\") === -1) {\r\n                    this._options.samplers.push(\"bakedVertexAnimationTexture\");\r\n                }\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);\r\n        }\r\n\r\n        // Textures\r\n        for (const name in this._textures) {\r\n            if (!this._textures[name].isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Alpha test\r\n        if (mesh && this._shouldTurnAlphaTestOn(mesh)) {\r\n            defines.push(\"#define ALPHATEST\");\r\n        }\r\n\r\n        // Clip planes\r\n        if (this._options.useClipPlane !== false) {\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            prepareStringDefinesForClipPlanes(this, scene, defines);\r\n        }\r\n\r\n        if (this.customShaderNameResolve) {\r\n            uniforms = uniforms.slice();\r\n            uniformBuffers = uniformBuffers.slice();\r\n            samplers = samplers.slice();\r\n            shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs);\r\n        }\r\n\r\n        const drawWrapper = storeEffectOnSubMeshes ? subMesh._getDrawWrapper() : this._drawWrapper;\r\n        const previousEffect = drawWrapper?.effect ?? null;\r\n        const previousDefines = drawWrapper?.defines ?? null;\r\n        const join = defines.join(\"\\n\");\r\n\r\n        let effect = previousEffect;\r\n        if (previousDefines !== join) {\r\n            effect = engine.createEffect(\r\n                shaderName,\r\n                <IEffectCreationOptions>{\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: uniformBuffers,\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    fallbacks: fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: { maxSimultaneousMorphTargets: numInfluencers },\r\n                    shaderLanguage: this._options.shaderLanguage,\r\n                },\r\n                engine\r\n            );\r\n\r\n            if (storeEffectOnSubMeshes) {\r\n                subMesh.setEffect(effect, join, this._materialContext);\r\n            } else if (drawWrapper) {\r\n                drawWrapper.setEffect(effect, join);\r\n            }\r\n\r\n            if (this._onEffectCreatedObservable) {\r\n                onCreatedEffectParameters.effect = effect;\r\n                onCreatedEffectParameters.subMesh = subMesh ?? mesh?.subMeshes[0] ?? null;\r\n                this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n            }\r\n        }\r\n\r\n        effect!._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        if (!effect?.isReady() ?? true) {\r\n            return false;\r\n        }\r\n\r\n        if (previousEffect !== effect) {\r\n            scene.resetCachedMaterial();\r\n        }\r\n\r\n        effect._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     * @param effectOverride - If provided, use this effect instead of internal effect\r\n     */\r\n    public bindOnlyWorldMatrix(world: Matrix, effectOverride?: Nullable<Effect>): void {\r\n        const scene = this.getScene();\r\n\r\n        const effect = effectOverride ?? this.getEffect();\r\n\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"world\") !== -1) {\r\n            effect.setMatrix(\"world\", world);\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"worldView\") !== -1) {\r\n            world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\r\n            effect.setMatrix(\"worldView\", this._cachedWorldViewMatrix);\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"worldViewProjection\") !== -1) {\r\n            world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\r\n            effect.setMatrix(\"worldViewProjection\", this._cachedWorldViewProjectionMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        this.bind(world, mesh, subMesh._drawWrapperOverride?.effect, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Binds the material to the mesh\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh to bind the material to\r\n     * @param effectOverride - If provided, use this effect instead of internal effect\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bind(world: Matrix, mesh?: Mesh, effectOverride?: Nullable<Effect>, subMesh?: SubMesh): void {\r\n        // Std values\r\n        const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;\r\n        const effect = effectOverride ?? (storeEffectOnSubMeshes ? subMesh.effect : this.getEffect());\r\n\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        this._activeEffect = effect;\r\n\r\n        this.bindOnlyWorldMatrix(world, effectOverride);\r\n\r\n        const uniformBuffers = this._options.uniformBuffers;\r\n\r\n        let useSceneUBO = false;\r\n\r\n        if (effect && uniformBuffers && uniformBuffers.length > 0 && this.getScene().getEngine().supportsUniformBuffers) {\r\n            for (let i = 0; i < uniformBuffers.length; ++i) {\r\n                const bufferName = uniformBuffers[i];\r\n                switch (bufferName) {\r\n                    case \"Mesh\":\r\n                        if (mesh) {\r\n                            mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\r\n                            mesh.transferToEffect(world);\r\n                        }\r\n                        break;\r\n                    case \"Scene\":\r\n                        MaterialHelper.BindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());\r\n                        this.getScene().finalizeSceneUbo();\r\n                        useSceneUBO = true;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        const mustRebind = mesh && storeEffectOnSubMeshes ? this._mustRebind(this.getScene(), effect, mesh.visibility) : this.getScene().getCachedMaterial() !== this;\r\n\r\n        if (effect && mustRebind) {\r\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"view\") !== -1) {\r\n                effect.setMatrix(\"view\", this.getScene().getViewMatrix());\r\n            }\r\n\r\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"projection\") !== -1) {\r\n                effect.setMatrix(\"projection\", this.getScene().getProjectionMatrix());\r\n            }\r\n\r\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"viewProjection\") !== -1) {\r\n                effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\r\n                if (this._multiview) {\r\n                    effect.setMatrix(\"viewProjectionR\", this.getScene()._transformMatrixR);\r\n                }\r\n            }\r\n\r\n            if (this.getScene().activeCamera && this._options.uniforms.indexOf(\"cameraPosition\") !== -1) {\r\n                effect.setVector3(\"cameraPosition\", this.getScene().activeCamera!.globalPosition);\r\n            }\r\n\r\n            // Bones\r\n            MaterialHelper.BindBonesParameters(mesh, effect);\r\n\r\n            // Clip plane\r\n            bindClipPlane(effect, this, this.getScene());\r\n\r\n            let name: string;\r\n            // Texture\r\n            for (name in this._textures) {\r\n                effect.setTexture(name, this._textures[name]);\r\n            }\r\n\r\n            // Texture arrays\r\n            for (name in this._textureArrays) {\r\n                effect.setTextureArray(name, this._textureArrays[name]);\r\n            }\r\n\r\n            // External texture\r\n            for (name in this._externalTextures) {\r\n                effect.setExternalTexture(name, this._externalTextures[name]);\r\n            }\r\n\r\n            // Int\r\n            for (name in this._ints) {\r\n                effect.setInt(name, this._ints[name]);\r\n            }\r\n\r\n            // UInt\r\n            for (name in this._uints) {\r\n                effect.setUInt(name, this._uints[name]);\r\n            }\r\n\r\n            // Float\r\n            for (name in this._floats) {\r\n                effect.setFloat(name, this._floats[name]);\r\n            }\r\n\r\n            // Floats\r\n            for (name in this._floatsArrays) {\r\n                effect.setArray(name, this._floatsArrays[name]);\r\n            }\r\n\r\n            // Color3\r\n            for (name in this._colors3) {\r\n                effect.setColor3(name, this._colors3[name]);\r\n            }\r\n\r\n            // Color3Array\r\n            for (name in this._colors3Arrays) {\r\n                effect.setArray3(name, this._colors3Arrays[name]);\r\n            }\r\n\r\n            // Color4\r\n            for (name in this._colors4) {\r\n                const color = this._colors4[name];\r\n                effect.setFloat4(name, color.r, color.g, color.b, color.a);\r\n            }\r\n\r\n            // Color4Array\r\n            for (name in this._colors4Arrays) {\r\n                effect.setArray4(name, this._colors4Arrays[name]);\r\n            }\r\n\r\n            // Vector2\r\n            for (name in this._vectors2) {\r\n                effect.setVector2(name, this._vectors2[name]);\r\n            }\r\n\r\n            // Vector3\r\n            for (name in this._vectors3) {\r\n                effect.setVector3(name, this._vectors3[name]);\r\n            }\r\n\r\n            // Vector4\r\n            for (name in this._vectors4) {\r\n                effect.setVector4(name, this._vectors4[name]);\r\n            }\r\n\r\n            // Quaternion\r\n            for (name in this._quaternions) {\r\n                effect.setQuaternion(name, this._quaternions[name]);\r\n            }\r\n\r\n            // Matrix\r\n            for (name in this._matrices) {\r\n                effect.setMatrix(name, this._matrices[name]);\r\n            }\r\n\r\n            // MatrixArray\r\n            for (name in this._matrixArrays) {\r\n                effect.setMatrices(name, this._matrixArrays[name]);\r\n            }\r\n\r\n            // Matrix 3x3\r\n            for (name in this._matrices3x3) {\r\n                effect.setMatrix3x3(name, this._matrices3x3[name]);\r\n            }\r\n\r\n            // Matrix 2x2\r\n            for (name in this._matrices2x2) {\r\n                effect.setMatrix2x2(name, this._matrices2x2[name]);\r\n            }\r\n\r\n            // Vector2Array\r\n            for (name in this._vectors2Arrays) {\r\n                effect.setArray2(name, this._vectors2Arrays[name]);\r\n            }\r\n\r\n            // Vector3Array\r\n            for (name in this._vectors3Arrays) {\r\n                effect.setArray3(name, this._vectors3Arrays[name]);\r\n            }\r\n\r\n            // Vector4Array\r\n            for (name in this._vectors4Arrays) {\r\n                effect.setArray4(name, this._vectors4Arrays[name]);\r\n            }\r\n\r\n            // QuaternionArray\r\n            for (name in this._quaternionsArrays) {\r\n                effect.setArray4(name, this._quaternionsArrays[name]);\r\n            }\r\n\r\n            // Uniform buffers\r\n            for (name in this._uniformBuffers) {\r\n                const buffer = this._uniformBuffers[name].getBuffer();\r\n                if (buffer) {\r\n                    effect.bindUniformBuffer(buffer, name);\r\n                }\r\n            }\r\n\r\n            // Samplers\r\n            for (name in this._textureSamplers) {\r\n                effect.setTextureSampler(name, this._textureSamplers[name]);\r\n            }\r\n\r\n            // Storage buffers\r\n            for (name in this._storageBuffers) {\r\n                effect.setStorageBuffer(name, this._storageBuffers[name]);\r\n            }\r\n        }\r\n\r\n        if (effect && mesh && (mustRebind || !this.isFrozen)) {\r\n            // Morph targets\r\n            const manager = (<Mesh>mesh).morphTargetManager;\r\n            if (manager && manager.numInfluencers > 0) {\r\n                MaterialHelper.BindMorphTargetParameters(<Mesh>mesh, effect);\r\n            }\r\n\r\n            const bvaManager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n\r\n            if (bvaManager && bvaManager.isEnabled) {\r\n                mesh.bakedVertexAnimationManager?.bind(effect, !!effect._wasPreviouslyUsingInstances);\r\n            }\r\n        }\r\n\r\n        this._afterBind(mesh, effect);\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        for (const name in this._textures) {\r\n            activeTextures.push(this._textures[name]);\r\n        }\r\n\r\n        for (const name in this._textureArrays) {\r\n            const array = this._textureArrays[name];\r\n            for (let index = 0; index < array.length; index++) {\r\n                activeTextures.push(array[index]);\r\n            }\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        for (const name in this._textures) {\r\n            if (this._textures[name] === texture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        for (const name in this._textureArrays) {\r\n            const array = this._textureArrays[name];\r\n            for (let index = 0; index < array.length; index++) {\r\n                if (array[index] === texture) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    public clone(name: string): ShaderMaterial {\r\n        const result = SerializationHelper.Clone(() => new ShaderMaterial(name, this.getScene(), this._shaderPath, this._options, this._storeEffectOnSubMeshes), this);\r\n\r\n        result.name = name;\r\n        result.id = name;\r\n\r\n        // Shader code path\r\n        if (typeof result._shaderPath === \"object\") {\r\n            result._shaderPath = { ...result._shaderPath };\r\n        }\r\n\r\n        // Options\r\n        this._options = { ...this._options };\r\n\r\n        (Object.keys(this._options) as Array<keyof IShaderMaterialOptions>).forEach((propName) => {\r\n            const propValue = this._options[propName];\r\n            if (Array.isArray(propValue)) {\r\n                (<string[]>this._options[propName]) = propValue.slice(0);\r\n            }\r\n        });\r\n\r\n        // Stencil\r\n        this.stencil.copyTo(result.stencil);\r\n\r\n        // Texture\r\n        for (const key in this._textures) {\r\n            result.setTexture(key, this._textures[key]);\r\n        }\r\n\r\n        // TextureArray\r\n        for (const key in this._textureArrays) {\r\n            result.setTextureArray(key, this._textureArrays[key]);\r\n        }\r\n\r\n        // External texture\r\n        for (const key in this._externalTextures) {\r\n            result.setExternalTexture(key, this._externalTextures[key]);\r\n        }\r\n\r\n        // Int\r\n        for (const key in this._ints) {\r\n            result.setInt(key, this._ints[key]);\r\n        }\r\n\r\n        // UInt\r\n        for (const key in this._uints) {\r\n            result.setUInt(key, this._uints[key]);\r\n        }\r\n\r\n        // Float\r\n        for (const key in this._floats) {\r\n            result.setFloat(key, this._floats[key]);\r\n        }\r\n\r\n        // Floats\r\n        for (const key in this._floatsArrays) {\r\n            result.setFloats(key, this._floatsArrays[key]);\r\n        }\r\n\r\n        // Color3\r\n        for (const key in this._colors3) {\r\n            result.setColor3(key, this._colors3[key]);\r\n        }\r\n\r\n        // Color3Array\r\n        for (const key in this._colors3Arrays) {\r\n            result._colors3Arrays[key] = this._colors3Arrays[key];\r\n        }\r\n\r\n        // Color4\r\n        for (const key in this._colors4) {\r\n            result.setColor4(key, this._colors4[key]);\r\n        }\r\n\r\n        // Color4Array\r\n        for (const key in this._colors4Arrays) {\r\n            result._colors4Arrays[key] = this._colors4Arrays[key];\r\n        }\r\n\r\n        // Vector2\r\n        for (const key in this._vectors2) {\r\n            result.setVector2(key, this._vectors2[key]);\r\n        }\r\n\r\n        // Vector3\r\n        for (const key in this._vectors3) {\r\n            result.setVector3(key, this._vectors3[key]);\r\n        }\r\n\r\n        // Vector4\r\n        for (const key in this._vectors4) {\r\n            result.setVector4(key, this._vectors4[key]);\r\n        }\r\n\r\n        // Quaternion\r\n        for (const key in this._quaternions) {\r\n            result.setQuaternion(key, this._quaternions[key]);\r\n        }\r\n\r\n        // QuaternionArray\r\n        for (const key in this._quaternionsArrays) {\r\n            result._quaternionsArrays[key] = this._quaternionsArrays[key];\r\n        }\r\n\r\n        // Matrix\r\n        for (const key in this._matrices) {\r\n            result.setMatrix(key, this._matrices[key]);\r\n        }\r\n\r\n        // MatrixArray\r\n        for (const key in this._matrixArrays) {\r\n            result._matrixArrays[key] = this._matrixArrays[key].slice();\r\n        }\r\n\r\n        // Matrix 3x3\r\n        for (const key in this._matrices3x3) {\r\n            result.setMatrix3x3(key, this._matrices3x3[key]);\r\n        }\r\n\r\n        // Matrix 2x2\r\n        for (const key in this._matrices2x2) {\r\n            result.setMatrix2x2(key, this._matrices2x2[key]);\r\n        }\r\n\r\n        // Vector2Array\r\n        for (const key in this._vectors2Arrays) {\r\n            result.setArray2(key, this._vectors2Arrays[key]);\r\n        }\r\n\r\n        // Vector3Array\r\n        for (const key in this._vectors3Arrays) {\r\n            result.setArray3(key, this._vectors3Arrays[key]);\r\n        }\r\n\r\n        // Vector4Array\r\n        for (const key in this._vectors4Arrays) {\r\n            result.setArray4(key, this._vectors4Arrays[key]);\r\n        }\r\n\r\n        // Uniform buffers\r\n        for (const key in this._uniformBuffers) {\r\n            result.setUniformBuffer(key, this._uniformBuffers[key]);\r\n        }\r\n\r\n        // Samplers\r\n        for (const key in this._textureSamplers) {\r\n            result.setTextureSampler(key, this._textureSamplers[key]);\r\n        }\r\n\r\n        // Storag buffers\r\n        for (const key in this._storageBuffers) {\r\n            result.setStorageBuffer(key, this._storageBuffers[key]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            let name: string;\r\n            for (name in this._textures) {\r\n                this._textures[name].dispose();\r\n            }\r\n\r\n            for (name in this._textureArrays) {\r\n                const array = this._textureArrays[name];\r\n                for (let index = 0; index < array.length; index++) {\r\n                    array[index].dispose();\r\n                }\r\n            }\r\n        }\r\n\r\n        this._textures = {};\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\r\n    }\r\n\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.ShaderMaterial\";\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        serializationObject.options = this._options;\r\n        serializationObject.shaderPath = this._shaderPath;\r\n        serializationObject.storeEffectOnSubMeshes = this._storeEffectOnSubMeshes;\r\n\r\n        let name: string;\r\n\r\n        // Stencil\r\n        serializationObject.stencil = this.stencil.serialize();\r\n\r\n        // Texture\r\n        serializationObject.textures = {};\r\n        for (name in this._textures) {\r\n            serializationObject.textures[name] = this._textures[name].serialize();\r\n        }\r\n\r\n        // Texture arrays\r\n        serializationObject.textureArrays = {};\r\n        for (name in this._textureArrays) {\r\n            serializationObject.textureArrays[name] = [];\r\n            const array = this._textureArrays[name];\r\n            for (let index = 0; index < array.length; index++) {\r\n                serializationObject.textureArrays[name].push(array[index].serialize());\r\n            }\r\n        }\r\n\r\n        // Int\r\n        serializationObject.ints = {};\r\n        for (name in this._ints) {\r\n            serializationObject.ints[name] = this._ints[name];\r\n        }\r\n\r\n        // UInt\r\n        serializationObject.uints = {};\r\n        for (name in this._uints) {\r\n            serializationObject.uints[name] = this._uints[name];\r\n        }\r\n\r\n        // Float\r\n        serializationObject.floats = {};\r\n        for (name in this._floats) {\r\n            serializationObject.floats[name] = this._floats[name];\r\n        }\r\n\r\n        // Floats\r\n        serializationObject.FloatArrays = {};\r\n        for (name in this._floatsArrays) {\r\n            serializationObject.FloatArrays[name] = this._floatsArrays[name];\r\n        }\r\n\r\n        // Color3\r\n        serializationObject.colors3 = {};\r\n        for (name in this._colors3) {\r\n            serializationObject.colors3[name] = this._colors3[name].asArray();\r\n        }\r\n\r\n        // Color3 array\r\n        serializationObject.colors3Arrays = {};\r\n        for (name in this._colors3Arrays) {\r\n            serializationObject.colors3Arrays[name] = this._colors3Arrays[name];\r\n        }\r\n\r\n        // Color4\r\n        serializationObject.colors4 = {};\r\n        for (name in this._colors4) {\r\n            serializationObject.colors4[name] = this._colors4[name].asArray();\r\n        }\r\n\r\n        // Color4 array\r\n        serializationObject.colors4Arrays = {};\r\n        for (name in this._colors4Arrays) {\r\n            serializationObject.colors4Arrays[name] = this._colors4Arrays[name];\r\n        }\r\n\r\n        // Vector2\r\n        serializationObject.vectors2 = {};\r\n        for (name in this._vectors2) {\r\n            serializationObject.vectors2[name] = this._vectors2[name].asArray();\r\n        }\r\n\r\n        // Vector3\r\n        serializationObject.vectors3 = {};\r\n        for (name in this._vectors3) {\r\n            serializationObject.vectors3[name] = this._vectors3[name].asArray();\r\n        }\r\n\r\n        // Vector4\r\n        serializationObject.vectors4 = {};\r\n        for (name in this._vectors4) {\r\n            serializationObject.vectors4[name] = this._vectors4[name].asArray();\r\n        }\r\n\r\n        // Quaternion\r\n        serializationObject.quaternions = {};\r\n        for (name in this._quaternions) {\r\n            serializationObject.quaternions[name] = this._quaternions[name].asArray();\r\n        }\r\n\r\n        // Matrix\r\n        serializationObject.matrices = {};\r\n        for (name in this._matrices) {\r\n            serializationObject.matrices[name] = this._matrices[name].asArray();\r\n        }\r\n\r\n        // MatrixArray\r\n        serializationObject.matrixArray = {};\r\n        for (name in this._matrixArrays) {\r\n            serializationObject.matrixArray[name] = this._matrixArrays[name];\r\n        }\r\n\r\n        // Matrix 3x3\r\n        serializationObject.matrices3x3 = {};\r\n        for (name in this._matrices3x3) {\r\n            serializationObject.matrices3x3[name] = this._matrices3x3[name];\r\n        }\r\n\r\n        // Matrix 2x2\r\n        serializationObject.matrices2x2 = {};\r\n        for (name in this._matrices2x2) {\r\n            serializationObject.matrices2x2[name] = this._matrices2x2[name];\r\n        }\r\n\r\n        // Vector2Array\r\n        serializationObject.vectors2Arrays = {};\r\n        for (name in this._vectors2Arrays) {\r\n            serializationObject.vectors2Arrays[name] = this._vectors2Arrays[name];\r\n        }\r\n\r\n        // Vector3Array\r\n        serializationObject.vectors3Arrays = {};\r\n        for (name in this._vectors3Arrays) {\r\n            serializationObject.vectors3Arrays[name] = this._vectors3Arrays[name];\r\n        }\r\n\r\n        // Vector4Array\r\n        serializationObject.vectors4Arrays = {};\r\n        for (name in this._vectors4Arrays) {\r\n            serializationObject.vectors4Arrays[name] = this._vectors4Arrays[name];\r\n        }\r\n\r\n        // QuaternionArray\r\n        serializationObject.quaternionsArrays = {};\r\n        for (name in this._quaternionsArrays) {\r\n            serializationObject.quaternionsArrays[name] = this._quaternionsArrays[name];\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a shader material from parsed shader material data\r\n     * @param source defines the JSON representation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new material\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): ShaderMaterial {\r\n        const material = SerializationHelper.Parse(\r\n            () => new ShaderMaterial(source.name, scene, source.shaderPath, source.options, source.storeEffectOnSubMeshes),\r\n            source,\r\n            scene,\r\n            rootUrl\r\n        );\r\n\r\n        let name: string;\r\n\r\n        // Stencil\r\n        if (source.stencil) {\r\n            material.stencil.parse(source.stencil, scene, rootUrl);\r\n        }\r\n\r\n        // Texture\r\n        for (name in source.textures) {\r\n            material.setTexture(name, <Texture>Texture.Parse(source.textures[name], scene, rootUrl));\r\n        }\r\n\r\n        // Texture arrays\r\n        for (name in source.textureArrays) {\r\n            const array = source.textureArrays[name];\r\n            const textureArray = new Array<Texture>();\r\n\r\n            for (let index = 0; index < array.length; index++) {\r\n                textureArray.push(<Texture>Texture.Parse(array[index], scene, rootUrl));\r\n            }\r\n            material.setTextureArray(name, textureArray);\r\n        }\r\n\r\n        // Int\r\n        for (name in source.ints) {\r\n            material.setInt(name, source.ints[name]);\r\n        }\r\n\r\n        // UInt\r\n        for (name in source.uints) {\r\n            material.setUInt(name, source.uints[name]);\r\n        }\r\n\r\n        // Float\r\n        for (name in source.floats) {\r\n            material.setFloat(name, source.floats[name]);\r\n        }\r\n\r\n        // Floats\r\n        for (name in source.floatsArrays) {\r\n            material.setFloats(name, source.floatsArrays[name]);\r\n        }\r\n\r\n        // Color3\r\n        for (name in source.colors3) {\r\n            material.setColor3(name, Color3.FromArray(source.colors3[name]));\r\n        }\r\n\r\n        // Color3 arrays\r\n        for (name in source.colors3Arrays) {\r\n            const colors: Color3[] = source.colors3Arrays[name]\r\n                .reduce((arr: Array<Array<number>>, num: number, i: number) => {\r\n                    if (i % 3 === 0) {\r\n                        arr.push([num]);\r\n                    } else {\r\n                        arr[arr.length - 1].push(num);\r\n                    }\r\n                    return arr;\r\n                }, [])\r\n                .map((color: ArrayLike<number>) => Color3.FromArray(color));\r\n            material.setColor3Array(name, colors);\r\n        }\r\n\r\n        // Color4\r\n        for (name in source.colors4) {\r\n            material.setColor4(name, Color4.FromArray(source.colors4[name]));\r\n        }\r\n\r\n        // Color4 arrays\r\n        for (name in source.colors4Arrays) {\r\n            const colors: Color4[] = source.colors4Arrays[name]\r\n                .reduce((arr: Array<Array<number>>, num: number, i: number) => {\r\n                    if (i % 4 === 0) {\r\n                        arr.push([num]);\r\n                    } else {\r\n                        arr[arr.length - 1].push(num);\r\n                    }\r\n                    return arr;\r\n                }, [])\r\n                .map((color: ArrayLike<number>) => Color4.FromArray(color));\r\n            material.setColor4Array(name, colors);\r\n        }\r\n\r\n        // Vector2\r\n        for (name in source.vectors2) {\r\n            material.setVector2(name, Vector2.FromArray(source.vectors2[name]));\r\n        }\r\n\r\n        // Vector3\r\n        for (name in source.vectors3) {\r\n            material.setVector3(name, Vector3.FromArray(source.vectors3[name]));\r\n        }\r\n\r\n        // Vector4\r\n        for (name in source.vectors4) {\r\n            material.setVector4(name, Vector4.FromArray(source.vectors4[name]));\r\n        }\r\n\r\n        // Quaternion\r\n        for (name in source.quaternions) {\r\n            material.setQuaternion(name, Quaternion.FromArray(source.quaternions[name]));\r\n        }\r\n\r\n        // Matrix\r\n        for (name in source.matrices) {\r\n            material.setMatrix(name, Matrix.FromArray(source.matrices[name]));\r\n        }\r\n\r\n        // MatrixArray\r\n        for (name in source.matrixArray) {\r\n            material._matrixArrays[name] = new Float32Array(source.matrixArray[name]);\r\n        }\r\n\r\n        // Matrix 3x3\r\n        for (name in source.matrices3x3) {\r\n            material.setMatrix3x3(name, source.matrices3x3[name]);\r\n        }\r\n\r\n        // Matrix 2x2\r\n        for (name in source.matrices2x2) {\r\n            material.setMatrix2x2(name, source.matrices2x2[name]);\r\n        }\r\n\r\n        // Vector2Array\r\n        for (name in source.vectors2Arrays) {\r\n            material.setArray2(name, source.vectors2Arrays[name]);\r\n        }\r\n\r\n        // Vector3Array\r\n        for (name in source.vectors3Arrays) {\r\n            material.setArray3(name, source.vectors3Arrays[name]);\r\n        }\r\n\r\n        // Vector4Array\r\n        for (name in source.vectors4Arrays) {\r\n            material.setArray4(name, source.vectors4Arrays[name]);\r\n        }\r\n\r\n        // QuaternionArray\r\n        for (name in source.quaternionsArrays) {\r\n            material.setArray4(name, source.quaternionsArrays[name]);\r\n        }\r\n\r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ShaderMaterial from a snippet saved in a remote file\r\n     * @param name defines the name of the ShaderMaterial to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static ParseFromFileAsync(name: Nullable<string>, url: string, scene: Scene, rootUrl = \"\"): Promise<ShaderMaterial> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const serializationObject = JSON.parse(request.responseText);\r\n                        const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\r\n\r\n                        if (name) {\r\n                            output.name = name;\r\n                        }\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the ShaderMaterial\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a ShaderMaterial from a snippet saved by the Inspector\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static ParseFromSnippetAsync(snippetId: string, scene: Scene, rootUrl = \"\"): Promise<ShaderMaterial> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        const serializationObject = JSON.parse(snippet.shaderMaterial);\r\n                        const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\r\n\r\n                        output.snippetId = snippetId;\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a ShaderMaterial from a snippet saved by the Inspector\r\n     * @deprecated Please use ParseFromSnippetAsync instead\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static CreateFromSnippetAsync = ShaderMaterial.ParseFromSnippetAsync;\r\n}\r\n\r\nRegisterClass(\"BABYLON.ShaderMaterial\", ShaderMaterial);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}