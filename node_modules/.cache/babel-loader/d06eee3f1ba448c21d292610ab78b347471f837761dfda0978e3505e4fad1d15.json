{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nimport { Vector3, Matrix, Quaternion } from \"../../../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../../../Buffers/buffer.js\";\nimport { PhysicsImpostor } from \"../physicsImpostor.js\";\nimport { PhysicsJoint } from \"../physicsJoint.js\";\nimport { PhysicsRaycastResult } from \"../../physicsRaycastResult.js\";\nimport { PhysicsEngine } from \"../physicsEngine.js\";\nimport { Epsilon } from \"../../../Maths/math.constants.js\";\n/** @internal */\nexport class CannonJSPlugin {\n  constructor(_useDeltaForWorldStep = true, iterations = 10, cannonInjection = CANNON) {\n    this._useDeltaForWorldStep = _useDeltaForWorldStep;\n    this.name = \"CannonJSPlugin\";\n    this._physicsMaterials = new Array();\n    this._fixedTimeStep = 1 / 60;\n    this._physicsBodiesToRemoveAfterStep = new Array();\n    this._firstFrame = true;\n    this._tmpQuaternion = new Quaternion();\n    this._minus90X = new Quaternion(-0.7071067811865475, 0, 0, 0.7071067811865475);\n    this._plus90X = new Quaternion(0.7071067811865475, 0, 0, 0.7071067811865475);\n    this._tmpPosition = Vector3.Zero();\n    this._tmpDeltaPosition = Vector3.Zero();\n    this._tmpUnityRotation = new Quaternion();\n    this.BJSCANNON = cannonInjection;\n    if (!this.isSupported()) {\n      Logger.Error(\"CannonJS is not available. Please make sure you included the js file.\");\n      return;\n    }\n    this._extendNamespace();\n    this.world = new this.BJSCANNON.World();\n    this.world.broadphase = new this.BJSCANNON.NaiveBroadphase();\n    this.world.solver.iterations = iterations;\n    this._cannonRaycastResult = new this.BJSCANNON.RaycastResult();\n    this._raycastResult = new PhysicsRaycastResult();\n  }\n  /**\n   *\n   * @returns plugin version\n   */\n  getPluginVersion() {\n    return 1;\n  }\n  setGravity(gravity) {\n    const vec = gravity;\n    this.world.gravity.set(vec.x, vec.y, vec.z);\n  }\n  setTimeStep(timeStep) {\n    this._fixedTimeStep = timeStep;\n  }\n  getTimeStep() {\n    return this._fixedTimeStep;\n  }\n  executeStep(delta, impostors) {\n    // due to cannon's architecture, the first frame's before-step is skipped.\n    if (this._firstFrame) {\n      this._firstFrame = false;\n      for (const impostor of impostors) {\n        if (!(impostor.type == PhysicsImpostor.HeightmapImpostor || impostor.type === PhysicsImpostor.PlaneImpostor)) {\n          impostor.beforeStep();\n        }\n      }\n    }\n    this.world.step(this._useDeltaForWorldStep ? delta : this._fixedTimeStep);\n    this._removeMarkedPhysicsBodiesFromWorld();\n  }\n  _removeMarkedPhysicsBodiesFromWorld() {\n    if (this._physicsBodiesToRemoveAfterStep.length > 0) {\n      this._physicsBodiesToRemoveAfterStep.forEach(physicsBody => {\n        if (typeof this.world.removeBody === \"function\") {\n          this.world.removeBody(physicsBody);\n        } else {\n          this.world.remove(physicsBody);\n        }\n      });\n      this._physicsBodiesToRemoveAfterStep.length = 0;\n    }\n  }\n  applyImpulse(impostor, force, contactPoint) {\n    const worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);\n    const impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);\n    impostor.physicsBody.applyImpulse(impulse, worldPoint);\n  }\n  applyForce(impostor, force, contactPoint) {\n    const worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);\n    const impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);\n    impostor.physicsBody.applyForce(impulse, worldPoint);\n  }\n  generatePhysicsBody(impostor) {\n    // When calling forceUpdate generatePhysicsBody is called again, ensure that the updated body does not instantly collide with removed body\n    this._removeMarkedPhysicsBodiesFromWorld();\n    //parent-child relationship. Does this impostor have a parent impostor?\n    if (impostor.parent) {\n      if (impostor.physicsBody) {\n        this.removePhysicsBody(impostor);\n        //TODO is that needed?\n        impostor.forceUpdate();\n      }\n      return;\n    }\n    //should a new body be created for this impostor?\n    if (impostor.isBodyInitRequired()) {\n      const shape = this._createShape(impostor);\n      if (!shape) {\n        Logger.Warn(\"It was not possible to create a physics body for this object.\");\n        return;\n      }\n      //unregister events if body is being changed\n      const oldBody = impostor.physicsBody;\n      if (oldBody) {\n        this.removePhysicsBody(impostor);\n      }\n      //create the body and material\n      const material = this._addMaterial(\"mat-\" + impostor.uniqueId, impostor.getParam(\"friction\"), impostor.getParam(\"restitution\"));\n      const bodyCreationObject = {\n        mass: impostor.getParam(\"mass\"),\n        material: material\n      };\n      // A simple extend, in case native options were used.\n      const nativeOptions = impostor.getParam(\"nativeOptions\");\n      for (const key in nativeOptions) {\n        if (Object.prototype.hasOwnProperty.call(nativeOptions, key)) {\n          bodyCreationObject[key] = nativeOptions[key];\n        }\n      }\n      impostor.physicsBody = new this.BJSCANNON.Body(bodyCreationObject);\n      impostor.physicsBody.addEventListener(\"collide\", impostor.onCollide);\n      this.world.addEventListener(\"preStep\", impostor.beforeStep);\n      this.world.addEventListener(\"postStep\", impostor.afterStep);\n      impostor.physicsBody.addShape(shape);\n      if (typeof this.world.addBody === \"function\") {\n        this.world.addBody(impostor.physicsBody);\n      } else {\n        this.world.add(impostor.physicsBody);\n      }\n      //try to keep the body moving in the right direction by taking old properties.\n      //Should be tested!\n      if (oldBody) {\n        [\"force\", \"torque\", \"velocity\", \"angularVelocity\"].forEach(function (param) {\n          const vec = oldBody[param];\n          impostor.physicsBody[param].set(vec.x, vec.y, vec.z);\n        });\n      }\n      this._processChildMeshes(impostor);\n    }\n    //now update the body's transformation\n    this._updatePhysicsBodyTransformation(impostor);\n  }\n  _processChildMeshes(mainImpostor) {\n    const meshChildren = mainImpostor.object.getChildMeshes ? mainImpostor.object.getChildMeshes(true) : [];\n    const mainRotation = mainImpostor.object.rotationQuaternion;\n    if (mainRotation) {\n      mainRotation.conjugateToRef(this._tmpQuaternion);\n    } else {\n      this._tmpQuaternion.set(0, 0, 0, 1);\n    }\n    if (meshChildren.length) {\n      const processMesh = mesh => {\n        if (!mesh.rotationQuaternion) {\n          return;\n        }\n        const childImpostor = mesh.getPhysicsImpostor();\n        if (childImpostor) {\n          const parent = childImpostor.parent;\n          if (parent !== mainImpostor && mesh.parent) {\n            const pPosition = mesh.getAbsolutePosition().subtract(mesh.parent.getAbsolutePosition());\n            const q = mesh.rotationQuaternion.multiply(this._tmpQuaternion);\n            if (childImpostor.physicsBody) {\n              this.removePhysicsBody(childImpostor);\n              childImpostor.physicsBody = null;\n            }\n            childImpostor.parent = mainImpostor;\n            childImpostor.resetUpdateFlags();\n            mainImpostor.physicsBody.addShape(this._createShape(childImpostor), new this.BJSCANNON.Vec3(pPosition.x, pPosition.y, pPosition.z), new this.BJSCANNON.Quaternion(q.x, q.y, q.z, q.w));\n            //Add the mass of the children.\n            mainImpostor.physicsBody.mass += childImpostor.getParam(\"mass\");\n          }\n        }\n        mesh.getChildMeshes(true).filter(m => !!m.physicsImpostor).forEach(processMesh);\n      };\n      meshChildren.filter(m => !!m.physicsImpostor).forEach(processMesh);\n    }\n  }\n  removePhysicsBody(impostor) {\n    impostor.physicsBody.removeEventListener(\"collide\", impostor.onCollide);\n    this.world.removeEventListener(\"preStep\", impostor.beforeStep);\n    this.world.removeEventListener(\"postStep\", impostor.afterStep);\n    // Only remove the physics body after the physics step to avoid disrupting cannon's internal state\n    if (this._physicsBodiesToRemoveAfterStep.indexOf(impostor.physicsBody) === -1) {\n      this._physicsBodiesToRemoveAfterStep.push(impostor.physicsBody);\n    }\n  }\n  generateJoint(impostorJoint) {\n    const mainBody = impostorJoint.mainImpostor.physicsBody;\n    const connectedBody = impostorJoint.connectedImpostor.physicsBody;\n    if (!mainBody || !connectedBody) {\n      return;\n    }\n    let constraint;\n    const jointData = impostorJoint.joint.jointData;\n    //TODO - https://github.com/schteppe/this.BJSCANNON.js/blob/gh-pages/demos/collisionFilter.html\n    const constraintData = {\n      pivotA: jointData.mainPivot ? new this.BJSCANNON.Vec3().set(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z) : null,\n      pivotB: jointData.connectedPivot ? new this.BJSCANNON.Vec3().set(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z) : null,\n      axisA: jointData.mainAxis ? new this.BJSCANNON.Vec3().set(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z) : null,\n      axisB: jointData.connectedAxis ? new this.BJSCANNON.Vec3().set(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z) : null,\n      maxForce: jointData.nativeParams.maxForce,\n      collideConnected: !!jointData.collision\n    };\n    switch (impostorJoint.joint.type) {\n      case PhysicsJoint.HingeJoint:\n      case PhysicsJoint.Hinge2Joint:\n        constraint = new this.BJSCANNON.HingeConstraint(mainBody, connectedBody, constraintData);\n        break;\n      case PhysicsJoint.DistanceJoint:\n        constraint = new this.BJSCANNON.DistanceConstraint(mainBody, connectedBody, jointData.maxDistance || 2);\n        break;\n      case PhysicsJoint.SpringJoint:\n        {\n          const springData = jointData;\n          constraint = new this.BJSCANNON.Spring(mainBody, connectedBody, {\n            restLength: springData.length,\n            stiffness: springData.stiffness,\n            damping: springData.damping,\n            localAnchorA: constraintData.pivotA,\n            localAnchorB: constraintData.pivotB\n          });\n          break;\n        }\n      case PhysicsJoint.LockJoint:\n        constraint = new this.BJSCANNON.LockConstraint(mainBody, connectedBody, constraintData);\n        break;\n      case PhysicsJoint.PointToPointJoint:\n      case PhysicsJoint.BallAndSocketJoint:\n      default:\n        constraint = new this.BJSCANNON.PointToPointConstraint(mainBody, constraintData.pivotA, connectedBody, constraintData.pivotB, constraintData.maxForce);\n        break;\n    }\n    //set the collideConnected flag after the creation, since DistanceJoint ignores it.\n    constraint.collideConnected = !!jointData.collision;\n    impostorJoint.joint.physicsJoint = constraint;\n    //don't add spring as constraint, as it is not one.\n    if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {\n      this.world.addConstraint(constraint);\n    } else {\n      impostorJoint.joint.jointData.forceApplicationCallback = impostorJoint.joint.jointData.forceApplicationCallback || function () {\n        constraint.applyForce();\n      };\n      impostorJoint.mainImpostor.registerAfterPhysicsStep(impostorJoint.joint.jointData.forceApplicationCallback);\n    }\n  }\n  removeJoint(impostorJoint) {\n    if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {\n      this.world.removeConstraint(impostorJoint.joint.physicsJoint);\n    } else {\n      impostorJoint.mainImpostor.unregisterAfterPhysicsStep(impostorJoint.joint.jointData.forceApplicationCallback);\n    }\n  }\n  _addMaterial(name, friction, restitution) {\n    let index;\n    let mat;\n    for (index = 0; index < this._physicsMaterials.length; index++) {\n      mat = this._physicsMaterials[index];\n      if (mat.friction === friction && mat.restitution === restitution) {\n        return mat;\n      }\n    }\n    const currentMat = new this.BJSCANNON.Material(name);\n    currentMat.friction = friction;\n    currentMat.restitution = restitution;\n    this._physicsMaterials.push(currentMat);\n    return currentMat;\n  }\n  _checkWithEpsilon(value) {\n    return value < Epsilon ? Epsilon : value;\n  }\n  _createShape(impostor) {\n    const object = impostor.object;\n    let returnValue;\n    const impostorExtents = impostor.getObjectExtents();\n    switch (impostor.type) {\n      case PhysicsImpostor.SphereImpostor:\n        {\n          const radiusX = impostorExtents.x;\n          const radiusY = impostorExtents.y;\n          const radiusZ = impostorExtents.z;\n          returnValue = new this.BJSCANNON.Sphere(Math.max(this._checkWithEpsilon(radiusX), this._checkWithEpsilon(radiusY), this._checkWithEpsilon(radiusZ)) / 2);\n          break;\n        }\n      //TMP also for cylinder - TODO Cannon supports cylinder natively.\n      case PhysicsImpostor.CylinderImpostor:\n        {\n          let nativeParams = impostor.getParam(\"nativeOptions\");\n          if (!nativeParams) {\n            nativeParams = {};\n          }\n          const radiusTop = nativeParams.radiusTop !== undefined ? nativeParams.radiusTop : this._checkWithEpsilon(impostorExtents.x) / 2;\n          const radiusBottom = nativeParams.radiusBottom !== undefined ? nativeParams.radiusBottom : this._checkWithEpsilon(impostorExtents.x) / 2;\n          const height = nativeParams.height !== undefined ? nativeParams.height : this._checkWithEpsilon(impostorExtents.y);\n          const numSegments = nativeParams.numSegments !== undefined ? nativeParams.numSegments : 16;\n          returnValue = new this.BJSCANNON.Cylinder(radiusTop, radiusBottom, height, numSegments);\n          // Rotate 90 degrees as this shape is horizontal in cannon\n          const quat = new this.BJSCANNON.Quaternion();\n          quat.setFromAxisAngle(new this.BJSCANNON.Vec3(1, 0, 0), -Math.PI / 2);\n          const translation = new this.BJSCANNON.Vec3(0, 0, 0);\n          returnValue.transformAllPoints(translation, quat);\n          break;\n        }\n      case PhysicsImpostor.BoxImpostor:\n        {\n          const box = impostorExtents.scale(0.5);\n          returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(this._checkWithEpsilon(box.x), this._checkWithEpsilon(box.y), this._checkWithEpsilon(box.z)));\n          break;\n        }\n      case PhysicsImpostor.PlaneImpostor:\n        Logger.Warn(\"Attention, PlaneImposter might not behave as you expect. Consider using BoxImposter instead\");\n        returnValue = new this.BJSCANNON.Plane();\n        break;\n      case PhysicsImpostor.MeshImpostor:\n        {\n          // should transform the vertex data to world coordinates!!\n          const rawVerts = object.getVerticesData ? object.getVerticesData(VertexBuffer.PositionKind) : [];\n          const rawFaces = object.getIndices ? object.getIndices() : [];\n          if (!rawVerts) {\n            Logger.Warn(\"Tried to create a MeshImpostor for an object without vertices. This will fail.\");\n            return;\n          }\n          // get only scale! so the object could transform correctly.\n          const oldPosition = object.position.clone();\n          const oldRotation = object.rotation && object.rotation.clone();\n          const oldQuaternion = object.rotationQuaternion && object.rotationQuaternion.clone();\n          object.position.copyFromFloats(0, 0, 0);\n          object.rotation && object.rotation.copyFromFloats(0, 0, 0);\n          object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());\n          object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();\n          const transform = object.computeWorldMatrix(true);\n          // convert rawVerts to object space\n          const transformedVertices = new Array();\n          let index;\n          for (index = 0; index < rawVerts.length; index += 3) {\n            Vector3.TransformCoordinates(Vector3.FromArray(rawVerts, index), transform).toArray(transformedVertices, index);\n          }\n          Logger.Warn(\"MeshImpostor only collides against spheres.\");\n          returnValue = new this.BJSCANNON.Trimesh(transformedVertices, rawFaces);\n          //now set back the transformation!\n          object.position.copyFrom(oldPosition);\n          oldRotation && object.rotation && object.rotation.copyFrom(oldRotation);\n          oldQuaternion && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion);\n          break;\n        }\n      case PhysicsImpostor.HeightmapImpostor:\n        {\n          const oldPosition2 = object.position.clone();\n          const oldRotation2 = object.rotation && object.rotation.clone();\n          const oldQuaternion2 = object.rotationQuaternion && object.rotationQuaternion.clone();\n          object.position.copyFromFloats(0, 0, 0);\n          object.rotation && object.rotation.copyFromFloats(0, 0, 0);\n          object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());\n          object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();\n          object.rotationQuaternion && object.rotationQuaternion.multiplyInPlace(this._minus90X);\n          returnValue = this._createHeightmap(object);\n          object.position.copyFrom(oldPosition2);\n          oldRotation2 && object.rotation && object.rotation.copyFrom(oldRotation2);\n          oldQuaternion2 && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion2);\n          object.computeWorldMatrix(true);\n          break;\n        }\n      case PhysicsImpostor.ParticleImpostor:\n        returnValue = new this.BJSCANNON.Particle();\n        break;\n      case PhysicsImpostor.NoImpostor:\n        returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(0, 0, 0));\n        break;\n    }\n    return returnValue;\n  }\n  _createHeightmap(object, pointDepth) {\n    let pos = object.getVerticesData(VertexBuffer.PositionKind);\n    const transform = object.computeWorldMatrix(true);\n    // convert rawVerts to object space\n    const transformedVertices = new Array();\n    let index;\n    for (index = 0; index < pos.length; index += 3) {\n      Vector3.TransformCoordinates(Vector3.FromArray(pos, index), transform).toArray(transformedVertices, index);\n    }\n    pos = transformedVertices;\n    const matrix = new Array();\n    //For now pointDepth will not be used and will be automatically calculated.\n    //Future reference - try and find the best place to add a reference to the pointDepth variable.\n    const arraySize = pointDepth || ~~(Math.sqrt(pos.length / 3) - 1);\n    const boundingInfo = object.getBoundingInfo();\n    const dim = Math.min(boundingInfo.boundingBox.extendSizeWorld.x, boundingInfo.boundingBox.extendSizeWorld.y);\n    const minY = boundingInfo.boundingBox.extendSizeWorld.z;\n    const elementSize = dim * 2 / arraySize;\n    for (let i = 0; i < pos.length; i = i + 3) {\n      const x = Math.round(pos[i + 0] / elementSize + arraySize / 2);\n      const z = Math.round((pos[i + 1] / elementSize - arraySize / 2) * -1);\n      const y = -pos[i + 2] + minY;\n      if (!matrix[x]) {\n        matrix[x] = [];\n      }\n      if (!matrix[x][z]) {\n        matrix[x][z] = y;\n      }\n      matrix[x][z] = Math.max(y, matrix[x][z]);\n    }\n    for (let x = 0; x <= arraySize; ++x) {\n      if (!matrix[x]) {\n        let loc = 1;\n        while (!matrix[(x + loc) % arraySize]) {\n          loc++;\n        }\n        matrix[x] = matrix[(x + loc) % arraySize].slice();\n        //console.log(\"missing x\", x);\n      }\n\n      for (let z = 0; z <= arraySize; ++z) {\n        if (!matrix[x][z]) {\n          let loc = 1;\n          let newValue;\n          while (newValue === undefined) {\n            newValue = matrix[x][(z + loc++) % arraySize];\n          }\n          matrix[x][z] = newValue;\n        }\n      }\n    }\n    const shape = new this.BJSCANNON.Heightfield(matrix, {\n      elementSize: elementSize\n    });\n    //For future reference, needed for body transformation\n    shape.minY = minY;\n    return shape;\n  }\n  _updatePhysicsBodyTransformation(impostor) {\n    const object = impostor.object;\n    //make sure it is updated...\n    object.computeWorldMatrix && object.computeWorldMatrix(true);\n    if (!object.getBoundingInfo()) {\n      return;\n    }\n    const center = impostor.getObjectCenter();\n    //m.getAbsolutePosition().subtract(m.getBoundingInfo().boundingBox.centerWorld)\n    // The delta between the mesh position and the mesh bounding box center\n    this._tmpDeltaPosition.copyFrom(object.getAbsolutePivotPoint().subtract(center));\n    this._tmpDeltaPosition.divideInPlace(impostor.object.scaling);\n    this._tmpPosition.copyFrom(center);\n    let quaternion = object.rotationQuaternion;\n    if (!quaternion) {\n      return;\n    }\n    //is shape is a plane or a heightmap, it must be rotated 90 degs in the X axis.\n    //ideally these would be rotated at time of creation like cylinder but they dont extend ConvexPolyhedron\n    if (impostor.type === PhysicsImpostor.PlaneImpostor || impostor.type === PhysicsImpostor.HeightmapImpostor) {\n      //-90 DEG in X, precalculated\n      quaternion = quaternion.multiply(this._minus90X);\n      //Invert! (Precalculated, 90 deg in X)\n      //No need to clone. this will never change.\n      impostor.setDeltaRotation(this._plus90X);\n    }\n    //If it is a heightfield, if should be centered.\n    if (impostor.type === PhysicsImpostor.HeightmapImpostor) {\n      const mesh = object;\n      let boundingInfo = mesh.getBoundingInfo();\n      //calculate the correct body position:\n      const rotationQuaternion = mesh.rotationQuaternion;\n      mesh.rotationQuaternion = this._tmpUnityRotation;\n      mesh.computeWorldMatrix(true);\n      //get original center with no rotation\n      const c = center.clone();\n      let oldPivot = mesh.getPivotMatrix();\n      if (oldPivot) {\n        // create a copy the pivot Matrix as it is modified in place\n        oldPivot = oldPivot.clone();\n      } else {\n        oldPivot = Matrix.Identity();\n      }\n      //calculate the new center using a pivot (since this.BJSCANNON.js doesn't center height maps)\n      const p = Matrix.Translation(boundingInfo.boundingBox.extendSizeWorld.x, 0, -boundingInfo.boundingBox.extendSizeWorld.z);\n      mesh.setPreTransformMatrix(p);\n      mesh.computeWorldMatrix(true);\n      // force bounding box recomputation\n      boundingInfo = mesh.getBoundingInfo();\n      //calculate the translation\n      const translation = boundingInfo.boundingBox.centerWorld.subtract(center).subtract(mesh.position).negate();\n      this._tmpPosition.copyFromFloats(translation.x, translation.y - boundingInfo.boundingBox.extendSizeWorld.y, translation.z);\n      //add it inverted to the delta\n      this._tmpDeltaPosition.copyFrom(boundingInfo.boundingBox.centerWorld.subtract(c));\n      this._tmpDeltaPosition.y += boundingInfo.boundingBox.extendSizeWorld.y;\n      //rotation is back\n      mesh.rotationQuaternion = rotationQuaternion;\n      mesh.setPreTransformMatrix(oldPivot);\n      mesh.computeWorldMatrix(true);\n    } else if (impostor.type === PhysicsImpostor.MeshImpostor) {\n      this._tmpDeltaPosition.copyFromFloats(0, 0, 0);\n    }\n    impostor.setDeltaPosition(this._tmpDeltaPosition);\n    //Now update the impostor object\n    impostor.physicsBody.position.set(this._tmpPosition.x, this._tmpPosition.y, this._tmpPosition.z);\n    impostor.physicsBody.quaternion.set(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n  }\n  setTransformationFromPhysicsBody(impostor) {\n    impostor.object.position.set(impostor.physicsBody.position.x, impostor.physicsBody.position.y, impostor.physicsBody.position.z);\n    if (impostor.object.rotationQuaternion) {\n      const q = impostor.physicsBody.quaternion;\n      impostor.object.rotationQuaternion.set(q.x, q.y, q.z, q.w);\n    }\n  }\n  setPhysicsBodyTransformation(impostor, newPosition, newRotation) {\n    impostor.physicsBody.position.set(newPosition.x, newPosition.y, newPosition.z);\n    impostor.physicsBody.quaternion.set(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\n  }\n  isSupported() {\n    return this.BJSCANNON !== undefined;\n  }\n  setLinearVelocity(impostor, velocity) {\n    impostor.physicsBody.velocity.set(velocity.x, velocity.y, velocity.z);\n  }\n  setAngularVelocity(impostor, velocity) {\n    impostor.physicsBody.angularVelocity.set(velocity.x, velocity.y, velocity.z);\n  }\n  getLinearVelocity(impostor) {\n    const v = impostor.physicsBody.velocity;\n    if (!v) {\n      return null;\n    }\n    return new Vector3(v.x, v.y, v.z);\n  }\n  getAngularVelocity(impostor) {\n    const v = impostor.physicsBody.angularVelocity;\n    if (!v) {\n      return null;\n    }\n    return new Vector3(v.x, v.y, v.z);\n  }\n  setBodyMass(impostor, mass) {\n    impostor.physicsBody.mass = mass;\n    impostor.physicsBody.updateMassProperties();\n  }\n  getBodyMass(impostor) {\n    return impostor.physicsBody.mass;\n  }\n  getBodyFriction(impostor) {\n    return impostor.physicsBody.material.friction;\n  }\n  setBodyFriction(impostor, friction) {\n    impostor.physicsBody.material.friction = friction;\n  }\n  getBodyRestitution(impostor) {\n    return impostor.physicsBody.material.restitution;\n  }\n  setBodyRestitution(impostor, restitution) {\n    impostor.physicsBody.material.restitution = restitution;\n  }\n  sleepBody(impostor) {\n    impostor.physicsBody.sleep();\n  }\n  wakeUpBody(impostor) {\n    impostor.physicsBody.wakeUp();\n  }\n  updateDistanceJoint(joint, maxDistance) {\n    joint.physicsJoint.distance = maxDistance;\n  }\n  setMotor(joint, speed, maxForce, motorIndex) {\n    if (!motorIndex) {\n      joint.physicsJoint.enableMotor();\n      joint.physicsJoint.setMotorSpeed(speed);\n      if (maxForce) {\n        this.setLimit(joint, maxForce);\n      }\n    }\n  }\n  setLimit(joint, minForce, maxForce) {\n    joint.physicsJoint.motorEquation.maxForce = maxForce;\n    joint.physicsJoint.motorEquation.minForce = minForce === void 0 ? -minForce : minForce;\n  }\n  syncMeshWithImpostor(mesh, impostor) {\n    const body = impostor.physicsBody;\n    mesh.position.x = body.position.x;\n    mesh.position.y = body.position.y;\n    mesh.position.z = body.position.z;\n    if (mesh.rotationQuaternion) {\n      mesh.rotationQuaternion.x = body.quaternion.x;\n      mesh.rotationQuaternion.y = body.quaternion.y;\n      mesh.rotationQuaternion.z = body.quaternion.z;\n      mesh.rotationQuaternion.w = body.quaternion.w;\n    }\n  }\n  getRadius(impostor) {\n    const shape = impostor.physicsBody.shapes[0];\n    return shape.boundingSphereRadius;\n  }\n  getBoxSizeToRef(impostor, result) {\n    const shape = impostor.physicsBody.shapes[0];\n    result.x = shape.halfExtents.x * 2;\n    result.y = shape.halfExtents.y * 2;\n    result.z = shape.halfExtents.z * 2;\n  }\n  dispose() {}\n  _extendNamespace() {\n    //this will force cannon to execute at least one step when using interpolation\n    const step_tmp1 = new this.BJSCANNON.Vec3();\n    const engine = this.BJSCANNON;\n    this.BJSCANNON.World.prototype.step = function (dt, timeSinceLastCalled, maxSubSteps) {\n      maxSubSteps = maxSubSteps || 10;\n      timeSinceLastCalled = timeSinceLastCalled || 0;\n      if (timeSinceLastCalled === 0) {\n        this.internalStep(dt);\n        this.time += dt;\n      } else {\n        let internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);\n        internalSteps = Math.min(internalSteps, maxSubSteps) || 1;\n        const t0 = performance.now();\n        for (let i = 0; i !== internalSteps; i++) {\n          this.internalStep(dt);\n          if (performance.now() - t0 > dt * 1000) {\n            break;\n          }\n        }\n        this.time += timeSinceLastCalled;\n        const h = this.time % dt;\n        const h_div_dt = h / dt;\n        const interpvelo = step_tmp1;\n        const bodies = this.bodies;\n        for (let j = 0; j !== bodies.length; j++) {\n          const b = bodies[j];\n          if (b.type !== engine.Body.STATIC && b.sleepState !== engine.Body.SLEEPING) {\n            b.position.vsub(b.previousPosition, interpvelo);\n            interpvelo.scale(h_div_dt, interpvelo);\n            b.position.vadd(interpvelo, b.interpolatedPosition);\n          } else {\n            b.interpolatedPosition.set(b.position.x, b.position.y, b.position.z);\n            b.interpolatedQuaternion.set(b.quaternion.x, b.quaternion.y, b.quaternion.z, b.quaternion.w);\n          }\n        }\n      }\n    };\n  }\n  /**\n   * Does a raycast in the physics world\n   * @param from when should the ray start?\n   * @param to when should the ray end?\n   * @returns PhysicsRaycastResult\n   */\n  raycast(from, to) {\n    this._raycastResult.reset(from, to);\n    this.raycastToRef(from, to, this._raycastResult);\n    return this._raycastResult;\n  }\n  /**\n   * Does a raycast in the physics world\n   * @param from when should the ray start?\n   * @param to when should the ray end?\n   * @param result resulting PhysicsRaycastResult\n   */\n  raycastToRef(from, to, result) {\n    this._cannonRaycastResult.reset();\n    this.world.raycastClosest(from, to, {}, this._cannonRaycastResult);\n    result.reset(from, to);\n    if (this._cannonRaycastResult.hasHit) {\n      // TODO: do we also want to get the body it hit?\n      result.setHitData({\n        x: this._cannonRaycastResult.hitNormalWorld.x,\n        y: this._cannonRaycastResult.hitNormalWorld.y,\n        z: this._cannonRaycastResult.hitNormalWorld.z\n      }, {\n        x: this._cannonRaycastResult.hitPointWorld.x,\n        y: this._cannonRaycastResult.hitPointWorld.y,\n        z: this._cannonRaycastResult.hitPointWorld.z\n      });\n      result.setHitDistance(this._cannonRaycastResult.distance);\n    }\n  }\n}\nPhysicsEngine.DefaultPluginFactory = () => {\n  return new CannonJSPlugin();\n};","map":{"version":3,"names":["Logger","Vector3","Matrix","Quaternion","VertexBuffer","PhysicsImpostor","PhysicsJoint","PhysicsRaycastResult","PhysicsEngine","Epsilon","CannonJSPlugin","constructor","_useDeltaForWorldStep","iterations","cannonInjection","CANNON","name","_physicsMaterials","Array","_fixedTimeStep","_physicsBodiesToRemoveAfterStep","_firstFrame","_tmpQuaternion","_minus90X","_plus90X","_tmpPosition","Zero","_tmpDeltaPosition","_tmpUnityRotation","BJSCANNON","isSupported","Error","_extendNamespace","world","World","broadphase","NaiveBroadphase","solver","_cannonRaycastResult","RaycastResult","_raycastResult","getPluginVersion","setGravity","gravity","vec","set","x","y","z","setTimeStep","timeStep","getTimeStep","executeStep","delta","impostors","impostor","type","HeightmapImpostor","PlaneImpostor","beforeStep","step","_removeMarkedPhysicsBodiesFromWorld","length","forEach","physicsBody","removeBody","remove","applyImpulse","force","contactPoint","worldPoint","Vec3","impulse","applyForce","generatePhysicsBody","parent","removePhysicsBody","forceUpdate","isBodyInitRequired","shape","_createShape","Warn","oldBody","material","_addMaterial","uniqueId","getParam","bodyCreationObject","mass","nativeOptions","key","Object","prototype","hasOwnProperty","call","Body","addEventListener","onCollide","afterStep","addShape","addBody","add","param","_processChildMeshes","_updatePhysicsBodyTransformation","mainImpostor","meshChildren","object","getChildMeshes","mainRotation","rotationQuaternion","conjugateToRef","processMesh","mesh","childImpostor","getPhysicsImpostor","pPosition","getAbsolutePosition","subtract","q","multiply","resetUpdateFlags","w","filter","m","physicsImpostor","removeEventListener","indexOf","push","generateJoint","impostorJoint","mainBody","connectedBody","connectedImpostor","constraint","jointData","joint","constraintData","pivotA","mainPivot","pivotB","connectedPivot","axisA","mainAxis","axisB","connectedAxis","maxForce","nativeParams","collideConnected","collision","HingeJoint","Hinge2Joint","HingeConstraint","DistanceJoint","DistanceConstraint","maxDistance","SpringJoint","springData","Spring","restLength","stiffness","damping","localAnchorA","localAnchorB","LockJoint","LockConstraint","PointToPointJoint","BallAndSocketJoint","PointToPointConstraint","physicsJoint","addConstraint","forceApplicationCallback","registerAfterPhysicsStep","removeJoint","removeConstraint","unregisterAfterPhysicsStep","friction","restitution","index","mat","currentMat","Material","_checkWithEpsilon","value","returnValue","impostorExtents","getObjectExtents","SphereImpostor","radiusX","radiusY","radiusZ","Sphere","Math","max","CylinderImpostor","radiusTop","undefined","radiusBottom","height","numSegments","Cylinder","quat","setFromAxisAngle","PI","translation","transformAllPoints","BoxImpostor","box","scale","Box","Plane","MeshImpostor","rawVerts","getVerticesData","PositionKind","rawFaces","getIndices","oldPosition","position","clone","oldRotation","rotation","oldQuaternion","copyFromFloats","copyFrom","getParentsRotation","conjugateInPlace","transform","computeWorldMatrix","transformedVertices","TransformCoordinates","FromArray","toArray","Trimesh","oldPosition2","oldRotation2","oldQuaternion2","multiplyInPlace","_createHeightmap","ParticleImpostor","Particle","NoImpostor","pointDepth","pos","matrix","arraySize","sqrt","boundingInfo","getBoundingInfo","dim","min","boundingBox","extendSizeWorld","minY","elementSize","i","round","loc","slice","newValue","Heightfield","center","getObjectCenter","getAbsolutePivotPoint","divideInPlace","scaling","quaternion","setDeltaRotation","c","oldPivot","getPivotMatrix","Identity","p","Translation","setPreTransformMatrix","centerWorld","negate","setDeltaPosition","setTransformationFromPhysicsBody","setPhysicsBodyTransformation","newPosition","newRotation","setLinearVelocity","velocity","setAngularVelocity","angularVelocity","getLinearVelocity","v","getAngularVelocity","setBodyMass","updateMassProperties","getBodyMass","getBodyFriction","setBodyFriction","getBodyRestitution","setBodyRestitution","sleepBody","sleep","wakeUpBody","wakeUp","updateDistanceJoint","distance","setMotor","speed","motorIndex","enableMotor","setMotorSpeed","setLimit","minForce","motorEquation","syncMeshWithImpostor","body","getRadius","shapes","boundingSphereRadius","getBoxSizeToRef","result","halfExtents","dispose","step_tmp1","engine","dt","timeSinceLastCalled","maxSubSteps","internalStep","time","internalSteps","floor","t0","performance","now","h","h_div_dt","interpvelo","bodies","j","b","STATIC","sleepState","SLEEPING","vsub","previousPosition","vadd","interpolatedPosition","interpolatedQuaternion","raycast","from","to","reset","raycastToRef","raycastClosest","hasHit","setHitData","hitNormalWorld","hitPointWorld","setHitDistance","DefaultPluginFactory"],"sources":["../../../../../../dev/core/src/Physics/v1/Plugins/cannonJSPlugin.ts"],"sourcesContent":["import type { Nullable, FloatArray } from \"../../../types\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport { Vector3, Matrix, Quaternion } from \"../../../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../../../Buffers/buffer\";\r\nimport type { AbstractMesh } from \"../../../Meshes/abstractMesh\";\r\nimport type { IPhysicsEnginePlugin, PhysicsImpostorJoint } from \"../IPhysicsEnginePlugin\";\r\nimport type { IPhysicsEnabledObject } from \"../physicsImpostor\";\r\nimport { PhysicsImpostor } from \"../physicsImpostor\";\r\nimport type { IMotorEnabledJoint, DistanceJointData, SpringJointData } from \"../physicsJoint\";\r\nimport { PhysicsJoint } from \"../physicsJoint\";\r\nimport { PhysicsRaycastResult } from \"../../physicsRaycastResult\";\r\nimport type { TransformNode } from \"../../../Meshes/transformNode\";\r\nimport { PhysicsEngine } from \"../physicsEngine\";\r\nimport { Epsilon } from \"../../../Maths/math.constants\";\r\n\r\n//declare var require: any;\r\ndeclare let CANNON: any;\r\n\r\n/** @internal */\r\nexport class CannonJSPlugin implements IPhysicsEnginePlugin {\r\n    public world: any;\r\n    public name: string = \"CannonJSPlugin\";\r\n    private _physicsMaterials = new Array();\r\n    private _fixedTimeStep: number = 1 / 60;\r\n    private _cannonRaycastResult: any;\r\n    private _raycastResult: PhysicsRaycastResult;\r\n    private _physicsBodiesToRemoveAfterStep = new Array<any>();\r\n    private _firstFrame = true;\r\n    private _tmpQuaternion: Quaternion = new Quaternion();\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public BJSCANNON: any;\r\n\r\n    public constructor(private _useDeltaForWorldStep: boolean = true, iterations: number = 10, cannonInjection = CANNON) {\r\n        this.BJSCANNON = cannonInjection;\r\n        if (!this.isSupported()) {\r\n            Logger.Error(\"CannonJS is not available. Please make sure you included the js file.\");\r\n            return;\r\n        }\r\n\r\n        this._extendNamespace();\r\n\r\n        this.world = new this.BJSCANNON.World();\r\n        this.world.broadphase = new this.BJSCANNON.NaiveBroadphase();\r\n        this.world.solver.iterations = iterations;\r\n        this._cannonRaycastResult = new this.BJSCANNON.RaycastResult();\r\n        this._raycastResult = new PhysicsRaycastResult();\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @returns plugin version\r\n     */\r\n    public getPluginVersion(): number {\r\n        return 1;\r\n    }\r\n\r\n    public setGravity(gravity: Vector3): void {\r\n        const vec = gravity;\r\n        this.world.gravity.set(vec.x, vec.y, vec.z);\r\n    }\r\n\r\n    public setTimeStep(timeStep: number) {\r\n        this._fixedTimeStep = timeStep;\r\n    }\r\n\r\n    public getTimeStep(): number {\r\n        return this._fixedTimeStep;\r\n    }\r\n\r\n    public executeStep(delta: number, impostors: Array<PhysicsImpostor>): void {\r\n        // due to cannon's architecture, the first frame's before-step is skipped.\r\n        if (this._firstFrame) {\r\n            this._firstFrame = false;\r\n            for (const impostor of impostors) {\r\n                if (!(impostor.type == PhysicsImpostor.HeightmapImpostor || impostor.type === PhysicsImpostor.PlaneImpostor)) {\r\n                    impostor.beforeStep();\r\n                }\r\n            }\r\n        }\r\n        this.world.step(this._useDeltaForWorldStep ? delta : this._fixedTimeStep);\r\n        this._removeMarkedPhysicsBodiesFromWorld();\r\n    }\r\n\r\n    private _removeMarkedPhysicsBodiesFromWorld(): void {\r\n        if (this._physicsBodiesToRemoveAfterStep.length > 0) {\r\n            this._physicsBodiesToRemoveAfterStep.forEach((physicsBody) => {\r\n                if (typeof this.world.removeBody === \"function\") {\r\n                    this.world.removeBody(physicsBody);\r\n                } else {\r\n                    this.world.remove(physicsBody);\r\n                }\r\n            });\r\n            this._physicsBodiesToRemoveAfterStep.length = 0;\r\n        }\r\n    }\r\n\r\n    public applyImpulse(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        const worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);\r\n        const impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);\r\n\r\n        impostor.physicsBody.applyImpulse(impulse, worldPoint);\r\n    }\r\n\r\n    public applyForce(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        const worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);\r\n        const impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);\r\n\r\n        impostor.physicsBody.applyForce(impulse, worldPoint);\r\n    }\r\n\r\n    public generatePhysicsBody(impostor: PhysicsImpostor) {\r\n        // When calling forceUpdate generatePhysicsBody is called again, ensure that the updated body does not instantly collide with removed body\r\n        this._removeMarkedPhysicsBodiesFromWorld();\r\n\r\n        //parent-child relationship. Does this impostor have a parent impostor?\r\n        if (impostor.parent) {\r\n            if (impostor.physicsBody) {\r\n                this.removePhysicsBody(impostor);\r\n                //TODO is that needed?\r\n                impostor.forceUpdate();\r\n            }\r\n            return;\r\n        }\r\n\r\n        //should a new body be created for this impostor?\r\n        if (impostor.isBodyInitRequired()) {\r\n            const shape = this._createShape(impostor);\r\n            if (!shape) {\r\n                Logger.Warn(\"It was not possible to create a physics body for this object.\");\r\n                return;\r\n            }\r\n\r\n            //unregister events if body is being changed\r\n            const oldBody = impostor.physicsBody;\r\n            if (oldBody) {\r\n                this.removePhysicsBody(impostor);\r\n            }\r\n\r\n            //create the body and material\r\n            const material = this._addMaterial(\"mat-\" + impostor.uniqueId, impostor.getParam(\"friction\"), impostor.getParam(\"restitution\"));\r\n\r\n            const bodyCreationObject = {\r\n                mass: impostor.getParam(\"mass\"),\r\n                material: material,\r\n            };\r\n            // A simple extend, in case native options were used.\r\n            const nativeOptions = impostor.getParam(\"nativeOptions\");\r\n            for (const key in nativeOptions) {\r\n                if (Object.prototype.hasOwnProperty.call(nativeOptions, key)) {\r\n                    (<any>bodyCreationObject)[key] = nativeOptions[key];\r\n                }\r\n            }\r\n            impostor.physicsBody = new this.BJSCANNON.Body(bodyCreationObject);\r\n            impostor.physicsBody.addEventListener(\"collide\", impostor.onCollide);\r\n            this.world.addEventListener(\"preStep\", impostor.beforeStep);\r\n            this.world.addEventListener(\"postStep\", impostor.afterStep);\r\n            impostor.physicsBody.addShape(shape);\r\n            if (typeof this.world.addBody === \"function\") {\r\n                this.world.addBody(impostor.physicsBody);\r\n            } else {\r\n                this.world.add(impostor.physicsBody);\r\n            }\r\n\r\n            //try to keep the body moving in the right direction by taking old properties.\r\n            //Should be tested!\r\n            if (oldBody) {\r\n                [\"force\", \"torque\", \"velocity\", \"angularVelocity\"].forEach(function (param) {\r\n                    const vec = oldBody[param];\r\n                    impostor.physicsBody[param].set(vec.x, vec.y, vec.z);\r\n                });\r\n            }\r\n            this._processChildMeshes(impostor);\r\n        }\r\n\r\n        //now update the body's transformation\r\n        this._updatePhysicsBodyTransformation(impostor);\r\n    }\r\n\r\n    private _processChildMeshes(mainImpostor: PhysicsImpostor) {\r\n        const meshChildren = mainImpostor.object.getChildMeshes ? mainImpostor.object.getChildMeshes(true) : [];\r\n        const mainRotation: Nullable<Quaternion> = mainImpostor.object.rotationQuaternion;\r\n        if (mainRotation) {\r\n            mainRotation.conjugateToRef(this._tmpQuaternion);\r\n        } else {\r\n            this._tmpQuaternion.set(0, 0, 0, 1);\r\n        }\r\n\r\n        if (meshChildren.length) {\r\n            const processMesh = (mesh: AbstractMesh) => {\r\n                if (!mesh.rotationQuaternion) {\r\n                    return;\r\n                }\r\n\r\n                const childImpostor = mesh.getPhysicsImpostor();\r\n                if (childImpostor) {\r\n                    const parent = childImpostor.parent;\r\n                    if (parent !== mainImpostor && mesh.parent) {\r\n                        const pPosition = mesh.getAbsolutePosition().subtract((mesh.parent as TransformNode).getAbsolutePosition());\r\n                        const q = mesh.rotationQuaternion.multiply(this._tmpQuaternion);\r\n\r\n                        if (childImpostor.physicsBody) {\r\n                            this.removePhysicsBody(childImpostor);\r\n                            childImpostor.physicsBody = null;\r\n                        }\r\n                        childImpostor.parent = mainImpostor;\r\n                        childImpostor.resetUpdateFlags();\r\n                        mainImpostor.physicsBody.addShape(\r\n                            this._createShape(childImpostor),\r\n                            new this.BJSCANNON.Vec3(pPosition.x, pPosition.y, pPosition.z),\r\n                            new this.BJSCANNON.Quaternion(q.x, q.y, q.z, q.w)\r\n                        );\r\n                        //Add the mass of the children.\r\n                        mainImpostor.physicsBody.mass += childImpostor.getParam(\"mass\");\r\n                    }\r\n                }\r\n                mesh.getChildMeshes(true)\r\n                    .filter((m) => !!m.physicsImpostor)\r\n                    .forEach(processMesh);\r\n            };\r\n            meshChildren.filter((m) => !!m.physicsImpostor).forEach(processMesh);\r\n        }\r\n    }\r\n\r\n    public removePhysicsBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.removeEventListener(\"collide\", impostor.onCollide);\r\n        this.world.removeEventListener(\"preStep\", impostor.beforeStep);\r\n        this.world.removeEventListener(\"postStep\", impostor.afterStep);\r\n\r\n        // Only remove the physics body after the physics step to avoid disrupting cannon's internal state\r\n        if (this._physicsBodiesToRemoveAfterStep.indexOf(impostor.physicsBody) === -1) {\r\n            this._physicsBodiesToRemoveAfterStep.push(impostor.physicsBody);\r\n        }\r\n    }\r\n\r\n    public generateJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        const mainBody = impostorJoint.mainImpostor.physicsBody;\r\n        const connectedBody = impostorJoint.connectedImpostor.physicsBody;\r\n        if (!mainBody || !connectedBody) {\r\n            return;\r\n        }\r\n        let constraint: any;\r\n        const jointData = impostorJoint.joint.jointData;\r\n        //TODO - https://github.com/schteppe/this.BJSCANNON.js/blob/gh-pages/demos/collisionFilter.html\r\n        const constraintData = {\r\n            pivotA: jointData.mainPivot ? new this.BJSCANNON.Vec3().set(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z) : null,\r\n            pivotB: jointData.connectedPivot ? new this.BJSCANNON.Vec3().set(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z) : null,\r\n            axisA: jointData.mainAxis ? new this.BJSCANNON.Vec3().set(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z) : null,\r\n            axisB: jointData.connectedAxis ? new this.BJSCANNON.Vec3().set(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z) : null,\r\n            maxForce: jointData.nativeParams.maxForce,\r\n            collideConnected: !!jointData.collision,\r\n        };\r\n        switch (impostorJoint.joint.type) {\r\n            case PhysicsJoint.HingeJoint:\r\n            case PhysicsJoint.Hinge2Joint:\r\n                constraint = new this.BJSCANNON.HingeConstraint(mainBody, connectedBody, constraintData);\r\n                break;\r\n            case PhysicsJoint.DistanceJoint:\r\n                constraint = new this.BJSCANNON.DistanceConstraint(mainBody, connectedBody, (<DistanceJointData>jointData).maxDistance || 2);\r\n                break;\r\n            case PhysicsJoint.SpringJoint: {\r\n                const springData = <SpringJointData>jointData;\r\n                constraint = new this.BJSCANNON.Spring(mainBody, connectedBody, {\r\n                    restLength: springData.length,\r\n                    stiffness: springData.stiffness,\r\n                    damping: springData.damping,\r\n                    localAnchorA: constraintData.pivotA,\r\n                    localAnchorB: constraintData.pivotB,\r\n                });\r\n                break;\r\n            }\r\n            case PhysicsJoint.LockJoint:\r\n                constraint = new this.BJSCANNON.LockConstraint(mainBody, connectedBody, constraintData);\r\n                break;\r\n            case PhysicsJoint.PointToPointJoint:\r\n            case PhysicsJoint.BallAndSocketJoint:\r\n            default:\r\n                constraint = new this.BJSCANNON.PointToPointConstraint(mainBody, constraintData.pivotA, connectedBody, constraintData.pivotB, constraintData.maxForce);\r\n                break;\r\n        }\r\n        //set the collideConnected flag after the creation, since DistanceJoint ignores it.\r\n        constraint.collideConnected = !!jointData.collision;\r\n        impostorJoint.joint.physicsJoint = constraint;\r\n        //don't add spring as constraint, as it is not one.\r\n        if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {\r\n            this.world.addConstraint(constraint);\r\n        } else {\r\n            (<SpringJointData>impostorJoint.joint.jointData).forceApplicationCallback =\r\n                (<SpringJointData>impostorJoint.joint.jointData).forceApplicationCallback ||\r\n                function () {\r\n                    constraint.applyForce();\r\n                };\r\n            impostorJoint.mainImpostor.registerAfterPhysicsStep((<SpringJointData>impostorJoint.joint.jointData).forceApplicationCallback);\r\n        }\r\n    }\r\n\r\n    public removeJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {\r\n            this.world.removeConstraint(impostorJoint.joint.physicsJoint);\r\n        } else {\r\n            impostorJoint.mainImpostor.unregisterAfterPhysicsStep((<SpringJointData>impostorJoint.joint.jointData).forceApplicationCallback);\r\n        }\r\n    }\r\n\r\n    private _addMaterial(name: string, friction: number, restitution: number) {\r\n        let index;\r\n        let mat;\r\n\r\n        for (index = 0; index < this._physicsMaterials.length; index++) {\r\n            mat = this._physicsMaterials[index];\r\n\r\n            if (mat.friction === friction && mat.restitution === restitution) {\r\n                return mat;\r\n            }\r\n        }\r\n\r\n        const currentMat = new this.BJSCANNON.Material(name);\r\n        currentMat.friction = friction;\r\n        currentMat.restitution = restitution;\r\n\r\n        this._physicsMaterials.push(currentMat);\r\n        return currentMat;\r\n    }\r\n\r\n    private _checkWithEpsilon(value: number): number {\r\n        return value < Epsilon ? Epsilon : value;\r\n    }\r\n\r\n    private _createShape(impostor: PhysicsImpostor) {\r\n        const object = impostor.object;\r\n\r\n        let returnValue;\r\n        const impostorExtents = impostor.getObjectExtents();\r\n        switch (impostor.type) {\r\n            case PhysicsImpostor.SphereImpostor: {\r\n                const radiusX = impostorExtents.x;\r\n                const radiusY = impostorExtents.y;\r\n                const radiusZ = impostorExtents.z;\r\n\r\n                returnValue = new this.BJSCANNON.Sphere(Math.max(this._checkWithEpsilon(radiusX), this._checkWithEpsilon(radiusY), this._checkWithEpsilon(radiusZ)) / 2);\r\n\r\n                break;\r\n            }\r\n            //TMP also for cylinder - TODO Cannon supports cylinder natively.\r\n            case PhysicsImpostor.CylinderImpostor: {\r\n                let nativeParams = impostor.getParam(\"nativeOptions\");\r\n                if (!nativeParams) {\r\n                    nativeParams = {};\r\n                }\r\n                const radiusTop = nativeParams.radiusTop !== undefined ? nativeParams.radiusTop : this._checkWithEpsilon(impostorExtents.x) / 2;\r\n                const radiusBottom = nativeParams.radiusBottom !== undefined ? nativeParams.radiusBottom : this._checkWithEpsilon(impostorExtents.x) / 2;\r\n                const height = nativeParams.height !== undefined ? nativeParams.height : this._checkWithEpsilon(impostorExtents.y);\r\n                const numSegments = nativeParams.numSegments !== undefined ? nativeParams.numSegments : 16;\r\n                returnValue = new this.BJSCANNON.Cylinder(radiusTop, radiusBottom, height, numSegments);\r\n\r\n                // Rotate 90 degrees as this shape is horizontal in cannon\r\n                const quat = new this.BJSCANNON.Quaternion();\r\n                quat.setFromAxisAngle(new this.BJSCANNON.Vec3(1, 0, 0), -Math.PI / 2);\r\n                const translation = new this.BJSCANNON.Vec3(0, 0, 0);\r\n                returnValue.transformAllPoints(translation, quat);\r\n                break;\r\n            }\r\n            case PhysicsImpostor.BoxImpostor: {\r\n                const box = impostorExtents.scale(0.5);\r\n                returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(this._checkWithEpsilon(box.x), this._checkWithEpsilon(box.y), this._checkWithEpsilon(box.z)));\r\n                break;\r\n            }\r\n            case PhysicsImpostor.PlaneImpostor:\r\n                Logger.Warn(\"Attention, PlaneImposter might not behave as you expect. Consider using BoxImposter instead\");\r\n                returnValue = new this.BJSCANNON.Plane();\r\n                break;\r\n            case PhysicsImpostor.MeshImpostor: {\r\n                // should transform the vertex data to world coordinates!!\r\n                const rawVerts = object.getVerticesData ? object.getVerticesData(VertexBuffer.PositionKind) : [];\r\n                const rawFaces = object.getIndices ? object.getIndices() : [];\r\n                if (!rawVerts) {\r\n                    Logger.Warn(\"Tried to create a MeshImpostor for an object without vertices. This will fail.\");\r\n                    return;\r\n                }\r\n                // get only scale! so the object could transform correctly.\r\n                const oldPosition = object.position.clone();\r\n                const oldRotation = object.rotation && object.rotation.clone();\r\n                const oldQuaternion = object.rotationQuaternion && object.rotationQuaternion.clone();\r\n                object.position.copyFromFloats(0, 0, 0);\r\n                object.rotation && object.rotation.copyFromFloats(0, 0, 0);\r\n                object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());\r\n\r\n                object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();\r\n\r\n                const transform = object.computeWorldMatrix(true);\r\n                // convert rawVerts to object space\r\n                const transformedVertices = new Array<number>();\r\n                let index: number;\r\n                for (index = 0; index < rawVerts.length; index += 3) {\r\n                    Vector3.TransformCoordinates(Vector3.FromArray(rawVerts, index), transform).toArray(transformedVertices, index);\r\n                }\r\n\r\n                Logger.Warn(\"MeshImpostor only collides against spheres.\");\r\n                returnValue = new this.BJSCANNON.Trimesh(transformedVertices, <number[]>rawFaces);\r\n                //now set back the transformation!\r\n                object.position.copyFrom(oldPosition);\r\n                oldRotation && object.rotation && object.rotation.copyFrom(oldRotation);\r\n                oldQuaternion && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion);\r\n                break;\r\n            }\r\n            case PhysicsImpostor.HeightmapImpostor: {\r\n                const oldPosition2 = object.position.clone();\r\n                const oldRotation2 = object.rotation && object.rotation.clone();\r\n                const oldQuaternion2 = object.rotationQuaternion && object.rotationQuaternion.clone();\r\n                object.position.copyFromFloats(0, 0, 0);\r\n                object.rotation && object.rotation.copyFromFloats(0, 0, 0);\r\n                object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());\r\n                object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();\r\n                object.rotationQuaternion && object.rotationQuaternion.multiplyInPlace(this._minus90X);\r\n\r\n                returnValue = this._createHeightmap(object);\r\n                object.position.copyFrom(oldPosition2);\r\n                oldRotation2 && object.rotation && object.rotation.copyFrom(oldRotation2);\r\n                oldQuaternion2 && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion2);\r\n                object.computeWorldMatrix(true);\r\n                break;\r\n            }\r\n            case PhysicsImpostor.ParticleImpostor:\r\n                returnValue = new this.BJSCANNON.Particle();\r\n                break;\r\n            case PhysicsImpostor.NoImpostor:\r\n                returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(0, 0, 0));\r\n                break;\r\n        }\r\n\r\n        return returnValue;\r\n    }\r\n\r\n    private _createHeightmap(object: IPhysicsEnabledObject, pointDepth?: number) {\r\n        let pos = <FloatArray>object.getVerticesData(VertexBuffer.PositionKind);\r\n        const transform = object.computeWorldMatrix(true);\r\n        // convert rawVerts to object space\r\n        const transformedVertices = new Array<number>();\r\n        let index: number;\r\n        for (index = 0; index < pos.length; index += 3) {\r\n            Vector3.TransformCoordinates(Vector3.FromArray(pos, index), transform).toArray(transformedVertices, index);\r\n        }\r\n        pos = transformedVertices;\r\n        const matrix = new Array<Array<any>>();\r\n\r\n        //For now pointDepth will not be used and will be automatically calculated.\r\n        //Future reference - try and find the best place to add a reference to the pointDepth variable.\r\n        const arraySize = pointDepth || ~~(Math.sqrt(pos.length / 3) - 1);\r\n        const boundingInfo = object.getBoundingInfo();\r\n        const dim = Math.min(boundingInfo.boundingBox.extendSizeWorld.x, boundingInfo.boundingBox.extendSizeWorld.y);\r\n        const minY = boundingInfo.boundingBox.extendSizeWorld.z;\r\n\r\n        const elementSize = (dim * 2) / arraySize;\r\n\r\n        for (let i = 0; i < pos.length; i = i + 3) {\r\n            const x = Math.round(pos[i + 0] / elementSize + arraySize / 2);\r\n            const z = Math.round((pos[i + 1] / elementSize - arraySize / 2) * -1);\r\n            const y = -pos[i + 2] + minY;\r\n            if (!matrix[x]) {\r\n                matrix[x] = [];\r\n            }\r\n            if (!matrix[x][z]) {\r\n                matrix[x][z] = y;\r\n            }\r\n            matrix[x][z] = Math.max(y, matrix[x][z]);\r\n        }\r\n\r\n        for (let x = 0; x <= arraySize; ++x) {\r\n            if (!matrix[x]) {\r\n                let loc = 1;\r\n                while (!matrix[(x + loc) % arraySize]) {\r\n                    loc++;\r\n                }\r\n                matrix[x] = matrix[(x + loc) % arraySize].slice();\r\n                //console.log(\"missing x\", x);\r\n            }\r\n            for (let z = 0; z <= arraySize; ++z) {\r\n                if (!matrix[x][z]) {\r\n                    let loc = 1;\r\n                    let newValue;\r\n                    while (newValue === undefined) {\r\n                        newValue = matrix[x][(z + loc++) % arraySize];\r\n                    }\r\n                    matrix[x][z] = newValue;\r\n                }\r\n            }\r\n        }\r\n\r\n        const shape = new this.BJSCANNON.Heightfield(matrix, {\r\n            elementSize: elementSize,\r\n        });\r\n\r\n        //For future reference, needed for body transformation\r\n        shape.minY = minY;\r\n\r\n        return shape;\r\n    }\r\n\r\n    private _minus90X = new Quaternion(-0.7071067811865475, 0, 0, 0.7071067811865475);\r\n    private _plus90X = new Quaternion(0.7071067811865475, 0, 0, 0.7071067811865475);\r\n    private _tmpPosition: Vector3 = Vector3.Zero();\r\n    private _tmpDeltaPosition: Vector3 = Vector3.Zero();\r\n    private _tmpUnityRotation: Quaternion = new Quaternion();\r\n\r\n    private _updatePhysicsBodyTransformation(impostor: PhysicsImpostor) {\r\n        const object = impostor.object;\r\n        //make sure it is updated...\r\n        object.computeWorldMatrix && object.computeWorldMatrix(true);\r\n        if (!object.getBoundingInfo()) {\r\n            return;\r\n        }\r\n        const center = impostor.getObjectCenter();\r\n        //m.getAbsolutePosition().subtract(m.getBoundingInfo().boundingBox.centerWorld)\r\n        // The delta between the mesh position and the mesh bounding box center\r\n        this._tmpDeltaPosition.copyFrom(object.getAbsolutePivotPoint().subtract(center));\r\n        this._tmpDeltaPosition.divideInPlace(impostor.object.scaling);\r\n        this._tmpPosition.copyFrom(center);\r\n        let quaternion = object.rotationQuaternion;\r\n\r\n        if (!quaternion) {\r\n            return;\r\n        }\r\n\r\n        //is shape is a plane or a heightmap, it must be rotated 90 degs in the X axis.\r\n        //ideally these would be rotated at time of creation like cylinder but they dont extend ConvexPolyhedron\r\n        if (impostor.type === PhysicsImpostor.PlaneImpostor || impostor.type === PhysicsImpostor.HeightmapImpostor) {\r\n            //-90 DEG in X, precalculated\r\n            quaternion = quaternion.multiply(this._minus90X);\r\n            //Invert! (Precalculated, 90 deg in X)\r\n            //No need to clone. this will never change.\r\n            impostor.setDeltaRotation(this._plus90X);\r\n        }\r\n\r\n        //If it is a heightfield, if should be centered.\r\n        if (impostor.type === PhysicsImpostor.HeightmapImpostor) {\r\n            const mesh = <AbstractMesh>(<any>object);\r\n            let boundingInfo = mesh.getBoundingInfo();\r\n            //calculate the correct body position:\r\n            const rotationQuaternion = mesh.rotationQuaternion;\r\n            mesh.rotationQuaternion = this._tmpUnityRotation;\r\n            mesh.computeWorldMatrix(true);\r\n\r\n            //get original center with no rotation\r\n            const c = center.clone();\r\n\r\n            let oldPivot = mesh.getPivotMatrix();\r\n            if (oldPivot) {\r\n                // create a copy the pivot Matrix as it is modified in place\r\n                oldPivot = oldPivot.clone();\r\n            } else {\r\n                oldPivot = Matrix.Identity();\r\n            }\r\n\r\n            //calculate the new center using a pivot (since this.BJSCANNON.js doesn't center height maps)\r\n            const p = Matrix.Translation(boundingInfo.boundingBox.extendSizeWorld.x, 0, -boundingInfo.boundingBox.extendSizeWorld.z);\r\n            mesh.setPreTransformMatrix(p);\r\n            mesh.computeWorldMatrix(true);\r\n            // force bounding box recomputation\r\n            boundingInfo = mesh.getBoundingInfo();\r\n\r\n            //calculate the translation\r\n            const translation = boundingInfo.boundingBox.centerWorld.subtract(center).subtract(mesh.position).negate();\r\n\r\n            this._tmpPosition.copyFromFloats(translation.x, translation.y - boundingInfo.boundingBox.extendSizeWorld.y, translation.z);\r\n            //add it inverted to the delta\r\n            this._tmpDeltaPosition.copyFrom(boundingInfo.boundingBox.centerWorld.subtract(c));\r\n            this._tmpDeltaPosition.y += boundingInfo.boundingBox.extendSizeWorld.y;\r\n            //rotation is back\r\n            mesh.rotationQuaternion = rotationQuaternion;\r\n\r\n            mesh.setPreTransformMatrix(oldPivot);\r\n            mesh.computeWorldMatrix(true);\r\n        } else if (impostor.type === PhysicsImpostor.MeshImpostor) {\r\n            this._tmpDeltaPosition.copyFromFloats(0, 0, 0);\r\n        }\r\n\r\n        impostor.setDeltaPosition(this._tmpDeltaPosition);\r\n        //Now update the impostor object\r\n        impostor.physicsBody.position.set(this._tmpPosition.x, this._tmpPosition.y, this._tmpPosition.z);\r\n        impostor.physicsBody.quaternion.set(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\r\n    }\r\n\r\n    public setTransformationFromPhysicsBody(impostor: PhysicsImpostor) {\r\n        impostor.object.position.set(impostor.physicsBody.position.x, impostor.physicsBody.position.y, impostor.physicsBody.position.z);\r\n        if (impostor.object.rotationQuaternion) {\r\n            const q = impostor.physicsBody.quaternion;\r\n            impostor.object.rotationQuaternion.set(q.x, q.y, q.z, q.w);\r\n        }\r\n    }\r\n\r\n    public setPhysicsBodyTransformation(impostor: PhysicsImpostor, newPosition: Vector3, newRotation: Quaternion) {\r\n        impostor.physicsBody.position.set(newPosition.x, newPosition.y, newPosition.z);\r\n        impostor.physicsBody.quaternion.set(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\r\n    }\r\n\r\n    public isSupported(): boolean {\r\n        return this.BJSCANNON !== undefined;\r\n    }\r\n\r\n    public setLinearVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        impostor.physicsBody.velocity.set(velocity.x, velocity.y, velocity.z);\r\n    }\r\n\r\n    public setAngularVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        impostor.physicsBody.angularVelocity.set(velocity.x, velocity.y, velocity.z);\r\n    }\r\n\r\n    public getLinearVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        const v = impostor.physicsBody.velocity;\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        return new Vector3(v.x, v.y, v.z);\r\n    }\r\n    public getAngularVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        const v = impostor.physicsBody.angularVelocity;\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        return new Vector3(v.x, v.y, v.z);\r\n    }\r\n\r\n    public setBodyMass(impostor: PhysicsImpostor, mass: number) {\r\n        impostor.physicsBody.mass = mass;\r\n        impostor.physicsBody.updateMassProperties();\r\n    }\r\n\r\n    public getBodyMass(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.mass;\r\n    }\r\n\r\n    public getBodyFriction(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.material.friction;\r\n    }\r\n\r\n    public setBodyFriction(impostor: PhysicsImpostor, friction: number) {\r\n        impostor.physicsBody.material.friction = friction;\r\n    }\r\n\r\n    public getBodyRestitution(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.material.restitution;\r\n    }\r\n\r\n    public setBodyRestitution(impostor: PhysicsImpostor, restitution: number) {\r\n        impostor.physicsBody.material.restitution = restitution;\r\n    }\r\n\r\n    public sleepBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.sleep();\r\n    }\r\n\r\n    public wakeUpBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.wakeUp();\r\n    }\r\n\r\n    public updateDistanceJoint(joint: PhysicsJoint, maxDistance: number) {\r\n        joint.physicsJoint.distance = maxDistance;\r\n    }\r\n\r\n    public setMotor(joint: IMotorEnabledJoint, speed?: number, maxForce?: number, motorIndex?: number) {\r\n        if (!motorIndex) {\r\n            joint.physicsJoint.enableMotor();\r\n            joint.physicsJoint.setMotorSpeed(speed);\r\n            if (maxForce) {\r\n                this.setLimit(joint, maxForce);\r\n            }\r\n        }\r\n    }\r\n\r\n    public setLimit(joint: IMotorEnabledJoint, minForce: number, maxForce?: number) {\r\n        joint.physicsJoint.motorEquation.maxForce = maxForce;\r\n        joint.physicsJoint.motorEquation.minForce = minForce === void 0 ? -minForce : minForce;\r\n    }\r\n\r\n    public syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor) {\r\n        const body = impostor.physicsBody;\r\n\r\n        mesh.position.x = body.position.x;\r\n        mesh.position.y = body.position.y;\r\n        mesh.position.z = body.position.z;\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            mesh.rotationQuaternion.x = body.quaternion.x;\r\n            mesh.rotationQuaternion.y = body.quaternion.y;\r\n            mesh.rotationQuaternion.z = body.quaternion.z;\r\n            mesh.rotationQuaternion.w = body.quaternion.w;\r\n        }\r\n    }\r\n\r\n    public getRadius(impostor: PhysicsImpostor): number {\r\n        const shape = impostor.physicsBody.shapes[0];\r\n        return shape.boundingSphereRadius;\r\n    }\r\n\r\n    public getBoxSizeToRef(impostor: PhysicsImpostor, result: Vector3): void {\r\n        const shape = impostor.physicsBody.shapes[0];\r\n        result.x = shape.halfExtents.x * 2;\r\n        result.y = shape.halfExtents.y * 2;\r\n        result.z = shape.halfExtents.z * 2;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    private _extendNamespace() {\r\n        //this will force cannon to execute at least one step when using interpolation\r\n        const step_tmp1 = new this.BJSCANNON.Vec3();\r\n        const engine = this.BJSCANNON;\r\n        this.BJSCANNON.World.prototype.step = function (dt: number, timeSinceLastCalled: number, maxSubSteps: number) {\r\n            maxSubSteps = maxSubSteps || 10;\r\n            timeSinceLastCalled = timeSinceLastCalled || 0;\r\n            if (timeSinceLastCalled === 0) {\r\n                this.internalStep(dt);\r\n                this.time += dt;\r\n            } else {\r\n                let internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);\r\n                internalSteps = Math.min(internalSteps, maxSubSteps) || 1;\r\n                const t0 = performance.now();\r\n                for (let i = 0; i !== internalSteps; i++) {\r\n                    this.internalStep(dt);\r\n                    if (performance.now() - t0 > dt * 1000) {\r\n                        break;\r\n                    }\r\n                }\r\n                this.time += timeSinceLastCalled;\r\n                const h = this.time % dt;\r\n                const h_div_dt = h / dt;\r\n                const interpvelo = step_tmp1;\r\n                const bodies = this.bodies;\r\n                for (let j = 0; j !== bodies.length; j++) {\r\n                    const b = bodies[j];\r\n                    if (b.type !== engine.Body.STATIC && b.sleepState !== engine.Body.SLEEPING) {\r\n                        b.position.vsub(b.previousPosition, interpvelo);\r\n                        interpvelo.scale(h_div_dt, interpvelo);\r\n                        b.position.vadd(interpvelo, b.interpolatedPosition);\r\n                    } else {\r\n                        b.interpolatedPosition.set(b.position.x, b.position.y, b.position.z);\r\n                        b.interpolatedQuaternion.set(b.quaternion.x, b.quaternion.y, b.quaternion.z, b.quaternion.w);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @returns PhysicsRaycastResult\r\n     */\r\n    public raycast(from: Vector3, to: Vector3): PhysicsRaycastResult {\r\n        this._raycastResult.reset(from, to);\r\n        this.raycastToRef(from, to, this._raycastResult);\r\n        return this._raycastResult;\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @param result resulting PhysicsRaycastResult\r\n     */\r\n    public raycastToRef(from: Vector3, to: Vector3, result: PhysicsRaycastResult): void {\r\n        this._cannonRaycastResult.reset();\r\n        this.world.raycastClosest(from, to, {}, this._cannonRaycastResult);\r\n\r\n        result.reset(from, to);\r\n        if (this._cannonRaycastResult.hasHit) {\r\n            // TODO: do we also want to get the body it hit?\r\n            result.setHitData(\r\n                {\r\n                    x: this._cannonRaycastResult.hitNormalWorld.x,\r\n                    y: this._cannonRaycastResult.hitNormalWorld.y,\r\n                    z: this._cannonRaycastResult.hitNormalWorld.z,\r\n                },\r\n                {\r\n                    x: this._cannonRaycastResult.hitPointWorld.x,\r\n                    y: this._cannonRaycastResult.hitPointWorld.y,\r\n                    z: this._cannonRaycastResult.hitPointWorld.z,\r\n                }\r\n            );\r\n            result.setHitDistance(this._cannonRaycastResult.distance);\r\n        }\r\n    }\r\n}\r\n\r\nPhysicsEngine.DefaultPluginFactory = () => {\r\n    return new CannonJSPlugin();\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}