{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3, TmpVectors, Matrix } from \"../Maths/math.vector.js\";\nimport { Sprite } from \"./sprite.js\";\nimport { SpriteSceneComponent } from \"./spriteSceneComponent.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { WebRequest } from \"../Misc/webRequest.js\";\nimport { SpriteRenderer } from \"./spriteRenderer.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n\n/**\n * Class used to manage multiple sprites on the same spritesheet\n * @see https://doc.babylonjs.com/features/featuresDeepDive/sprites\n */\nexport class SpriteManager {\n  /**\n   * Callback called when the manager is disposed\n   */\n  set onDispose(callback) {\n    if (this._onDisposeObserver) {\n      this.onDisposeObservable.remove(this._onDisposeObserver);\n    }\n    this._onDisposeObserver = this.onDisposeObservable.add(callback);\n  }\n  /**\n   * Gets the array of sprites\n   */\n  get children() {\n    return this.sprites;\n  }\n  /**\n   * Gets the hosting scene\n   */\n  get scene() {\n    return this._scene;\n  }\n  /**\n   * Gets the capacity of the manager\n   */\n  get capacity() {\n    return this._spriteRenderer.capacity;\n  }\n  /**\n   * Gets or sets the spritesheet texture\n   */\n  get texture() {\n    return this._spriteRenderer.texture;\n  }\n  set texture(value) {\n    value.wrapU = Texture.CLAMP_ADDRESSMODE;\n    value.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._spriteRenderer.texture = value;\n    this._textureContent = null;\n  }\n  /** Defines the default width of a cell in the spritesheet */\n  get cellWidth() {\n    return this._spriteRenderer.cellWidth;\n  }\n  set cellWidth(value) {\n    this._spriteRenderer.cellWidth = value;\n  }\n  /** Defines the default height of a cell in the spritesheet */\n  get cellHeight() {\n    return this._spriteRenderer.cellHeight;\n  }\n  set cellHeight(value) {\n    this._spriteRenderer.cellHeight = value;\n  }\n  /** Gets or sets a boolean indicating if the manager must consider scene fog when rendering */\n  get fogEnabled() {\n    return this._spriteRenderer.fogEnabled;\n  }\n  set fogEnabled(value) {\n    this._spriteRenderer.fogEnabled = value;\n  }\n  /**\n   * Blend mode use to render the particle, it can be any of\n   * the static undefined properties provided in this class.\n   * Default value is 2\n   */\n  get blendMode() {\n    return this._spriteRenderer.blendMode;\n  }\n  set blendMode(blendMode) {\n    this._spriteRenderer.blendMode = blendMode;\n  }\n  /** Disables writing to the depth buffer when rendering the sprites.\n   *  It can be handy to disable depth writing when using textures without alpha channel\n   *  and setting some specific blend modes.\n   */\n  get disableDepthWrite() {\n    return this._disableDepthWrite;\n  }\n  set disableDepthWrite(value) {\n    this._disableDepthWrite = value;\n    this._spriteRenderer.disableDepthWrite = value;\n  }\n  /**\n   * Gets or sets a boolean indicating if the renderer must render sprites with pixel perfect rendering\n   * In this mode, sprites are rendered as \"pixel art\", which means that they appear as pixelated but remain stable when moving or when rotated or scaled.\n   * Note that for this mode to work as expected, the sprite texture must use the BILINEAR sampling mode, not NEAREST!\n   */\n  get pixelPerfect() {\n    return this._spriteRenderer.pixelPerfect;\n  }\n  set pixelPerfect(value) {\n    this._spriteRenderer.pixelPerfect = value;\n    if (value && this.texture.samplingMode !== 3) {\n      this.texture.updateSamplingMode(3);\n    }\n  }\n  /**\n   * Creates a new sprite manager\n   * @param name defines the manager's name\n   * @param imgUrl defines the sprite sheet url\n   * @param capacity defines the maximum allowed number of sprites\n   * @param cellSize defines the size of a sprite cell\n   * @param scene defines the hosting scene\n   * @param epsilon defines the epsilon value to align texture (0.01 by default)\n   * @param samplingMode defines the sampling mode to use with spritesheet\n   * @param fromPacked set to false; do not alter\n   * @param spriteJSON null otherwise a JSON object defining sprite sheet data; do not alter\n   */\n  constructor( /** defines the manager's name */\n  name, imgUrl, capacity, cellSize, scene, epsilon = 0.01, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, fromPacked = false, spriteJSON = null) {\n    this.name = name;\n    /** Gets the list of sprites */\n    this.sprites = new Array();\n    /** Gets or sets the rendering group id (0 by default) */\n    this.renderingGroupId = 0;\n    /** Gets or sets camera layer mask */\n    this.layerMask = 0x0fffffff;\n    /** Gets or sets a boolean indicating if the sprites are pickable */\n    this.isPickable = false;\n    /**\n     * Gets or sets an object used to store user defined information for the sprite manager\n     */\n    this.metadata = null;\n    /** @internal */\n    this._wasDispatched = false;\n    /**\n     * An event triggered when the manager is disposed.\n     */\n    this.onDisposeObservable = new Observable();\n    this._disableDepthWrite = false;\n    /** True when packed cell data from JSON file is ready*/\n    this._packedAndReady = false;\n    this._customUpdate = (sprite, baseSize) => {\n      if (!sprite.cellRef) {\n        sprite.cellIndex = 0;\n      }\n      const num = sprite.cellIndex;\n      if (typeof num === \"number\" && isFinite(num) && Math.floor(num) === num) {\n        sprite.cellRef = this._spriteMap[sprite.cellIndex];\n      }\n      sprite._xOffset = this._cellData[sprite.cellRef].frame.x / baseSize.width;\n      sprite._yOffset = this._cellData[sprite.cellRef].frame.y / baseSize.height;\n      sprite._xSize = this._cellData[sprite.cellRef].frame.w;\n      sprite._ySize = this._cellData[sprite.cellRef].frame.h;\n    };\n    if (!scene) {\n      scene = EngineStore.LastCreatedScene;\n    }\n    if (!scene._getComponent(SceneComponentConstants.NAME_SPRITE)) {\n      scene._addComponent(new SpriteSceneComponent(scene));\n    }\n    this._fromPacked = fromPacked;\n    this._scene = scene;\n    const engine = this._scene.getEngine();\n    this._spriteRenderer = new SpriteRenderer(engine, capacity, epsilon, scene);\n    if (cellSize.width && cellSize.height) {\n      this.cellWidth = cellSize.width;\n      this.cellHeight = cellSize.height;\n    } else if (cellSize !== undefined) {\n      this.cellWidth = cellSize;\n      this.cellHeight = cellSize;\n    } else {\n      this._spriteRenderer = null;\n      return;\n    }\n    this._scene.spriteManagers && this._scene.spriteManagers.push(this);\n    this.uniqueId = this.scene.getUniqueId();\n    if (imgUrl) {\n      this.texture = new Texture(imgUrl, scene, true, false, samplingMode);\n    }\n    if (this._fromPacked) {\n      this._makePacked(imgUrl, spriteJSON);\n    }\n  }\n  /**\n   * Returns the string \"SpriteManager\"\n   * @returns \"SpriteManager\"\n   */\n  getClassName() {\n    return \"SpriteManager\";\n  }\n  _makePacked(imgUrl, spriteJSON) {\n    if (spriteJSON !== null) {\n      try {\n        //Get the JSON and Check its structure.  If its an array parse it if its a JSON string etc...\n        let celldata;\n        if (typeof spriteJSON === \"string\") {\n          celldata = JSON.parse(spriteJSON);\n        } else {\n          celldata = spriteJSON;\n        }\n        if (celldata.frames.length) {\n          const frametemp = {};\n          for (let i = 0; i < celldata.frames.length; i++) {\n            const _f = celldata.frames[i];\n            if (typeof Object.keys(_f)[0] !== \"string\") {\n              throw new Error(\"Invalid JSON Format.  Check the frame values and make sure the name is the first parameter.\");\n            }\n            const name = _f[Object.keys(_f)[0]];\n            frametemp[name] = _f;\n          }\n          celldata.frames = frametemp;\n        }\n        const spritemap = Reflect.ownKeys(celldata.frames);\n        this._spriteMap = spritemap;\n        this._packedAndReady = true;\n        this._cellData = celldata.frames;\n      } catch (e) {\n        this._fromPacked = false;\n        this._packedAndReady = false;\n        throw new Error(\"Invalid JSON from string. Spritesheet managed with constant cell size.\");\n      }\n    } else {\n      const re = /\\./g;\n      let li;\n      do {\n        li = re.lastIndex;\n        re.test(imgUrl);\n      } while (re.lastIndex > 0);\n      const jsonUrl = imgUrl.substring(0, li - 1) + \".json\";\n      const onerror = () => {\n        Logger.Error(\"JSON ERROR: Unable to load JSON file.\");\n        this._fromPacked = false;\n        this._packedAndReady = false;\n      };\n      const onload = data => {\n        try {\n          const celldata = JSON.parse(data);\n          const spritemap = Reflect.ownKeys(celldata.frames);\n          this._spriteMap = spritemap;\n          this._packedAndReady = true;\n          this._cellData = celldata.frames;\n        } catch (e) {\n          this._fromPacked = false;\n          this._packedAndReady = false;\n          throw new Error(\"Invalid JSON format. Please check documentation for format specifications.\");\n        }\n      };\n      Tools.LoadFile(jsonUrl, onload, undefined, undefined, false, onerror);\n    }\n  }\n  _checkTextureAlpha(sprite, ray, distance, min, max) {\n    if (!sprite.useAlphaForPicking || !this.texture) {\n      return true;\n    }\n    const textureSize = this.texture.getSize();\n    if (!this._textureContent) {\n      this._textureContent = new Uint8Array(textureSize.width * textureSize.height * 4);\n      this.texture.readPixels(0, 0, this._textureContent);\n    }\n    const contactPoint = TmpVectors.Vector3[0];\n    contactPoint.copyFrom(ray.direction);\n    contactPoint.normalize();\n    contactPoint.scaleInPlace(distance);\n    contactPoint.addInPlace(ray.origin);\n    const contactPointU = (contactPoint.x - min.x) / (max.x - min.x);\n    const contactPointV = 1.0 - (contactPoint.y - min.y) / (max.y - min.y);\n    const u = sprite._xOffset * textureSize.width + contactPointU * sprite._xSize | 0;\n    const v = sprite._yOffset * textureSize.height + contactPointV * sprite._ySize | 0;\n    const alpha = this._textureContent[(u + v * textureSize.width) * 4 + 3];\n    return alpha > 0.5;\n  }\n  /**\n   * Intersects the sprites with a ray\n   * @param ray defines the ray to intersect with\n   * @param camera defines the current active camera\n   * @param predicate defines a predicate used to select candidate sprites\n   * @param fastCheck defines if a fast check only must be done (the first potential sprite is will be used and not the closer)\n   * @returns null if no hit or a PickingInfo\n   */\n  intersects(ray, camera, predicate, fastCheck) {\n    const count = Math.min(this.capacity, this.sprites.length);\n    const min = Vector3.Zero();\n    const max = Vector3.Zero();\n    let distance = Number.MAX_VALUE;\n    let currentSprite = null;\n    const pickedPoint = TmpVectors.Vector3[0];\n    const cameraSpacePosition = TmpVectors.Vector3[1];\n    const cameraView = camera.getViewMatrix();\n    let activeRay = ray;\n    let pickedRay = ray;\n    for (let index = 0; index < count; index++) {\n      const sprite = this.sprites[index];\n      if (!sprite) {\n        continue;\n      }\n      if (predicate) {\n        if (!predicate(sprite)) {\n          continue;\n        }\n      } else if (!sprite.isPickable) {\n        continue;\n      }\n      Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\n      if (sprite.angle) {\n        // Create a rotation matrix to rotate the ray to the sprite's rotation\n        Matrix.TranslationToRef(-cameraSpacePosition.x, -cameraSpacePosition.y, 0, TmpVectors.Matrix[1]);\n        Matrix.TranslationToRef(cameraSpacePosition.x, cameraSpacePosition.y, 0, TmpVectors.Matrix[2]);\n        Matrix.RotationZToRef(-sprite.angle, TmpVectors.Matrix[3]);\n        // inv translation x rotation x translation\n        TmpVectors.Matrix[1].multiplyToRef(TmpVectors.Matrix[3], TmpVectors.Matrix[4]);\n        TmpVectors.Matrix[4].multiplyToRef(TmpVectors.Matrix[2], TmpVectors.Matrix[0]);\n        activeRay = ray.clone();\n        Vector3.TransformCoordinatesToRef(ray.origin, TmpVectors.Matrix[0], activeRay.origin);\n        Vector3.TransformNormalToRef(ray.direction, TmpVectors.Matrix[0], activeRay.direction);\n      } else {\n        activeRay = ray;\n      }\n      min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\n      max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\n      if (activeRay.intersectsBoxMinMax(min, max)) {\n        const currentDistance = Vector3.Distance(cameraSpacePosition, activeRay.origin);\n        if (distance > currentDistance) {\n          if (!this._checkTextureAlpha(sprite, activeRay, currentDistance, min, max)) {\n            continue;\n          }\n          pickedRay = activeRay;\n          distance = currentDistance;\n          currentSprite = sprite;\n          if (fastCheck) {\n            break;\n          }\n        }\n      }\n    }\n    if (currentSprite) {\n      const result = new PickingInfo();\n      cameraView.invertToRef(TmpVectors.Matrix[0]);\n      result.hit = true;\n      result.pickedSprite = currentSprite;\n      result.distance = distance;\n      // Get picked point\n      const direction = TmpVectors.Vector3[2];\n      direction.copyFrom(pickedRay.direction);\n      direction.normalize();\n      direction.scaleInPlace(distance);\n      pickedRay.origin.addToRef(direction, pickedPoint);\n      result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\n      return result;\n    }\n    return null;\n  }\n  /**\n   * Intersects the sprites with a ray\n   * @param ray defines the ray to intersect with\n   * @param camera defines the current active camera\n   * @param predicate defines a predicate used to select candidate sprites\n   * @returns null if no hit or a PickingInfo array\n   */\n  multiIntersects(ray, camera, predicate) {\n    const count = Math.min(this.capacity, this.sprites.length);\n    const min = Vector3.Zero();\n    const max = Vector3.Zero();\n    let distance;\n    const results = [];\n    const pickedPoint = TmpVectors.Vector3[0].copyFromFloats(0, 0, 0);\n    const cameraSpacePosition = TmpVectors.Vector3[1].copyFromFloats(0, 0, 0);\n    const cameraView = camera.getViewMatrix();\n    for (let index = 0; index < count; index++) {\n      const sprite = this.sprites[index];\n      if (!sprite) {\n        continue;\n      }\n      if (predicate) {\n        if (!predicate(sprite)) {\n          continue;\n        }\n      } else if (!sprite.isPickable) {\n        continue;\n      }\n      Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\n      min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\n      max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\n      if (ray.intersectsBoxMinMax(min, max)) {\n        distance = Vector3.Distance(cameraSpacePosition, ray.origin);\n        if (!this._checkTextureAlpha(sprite, ray, distance, min, max)) {\n          continue;\n        }\n        const result = new PickingInfo();\n        results.push(result);\n        cameraView.invertToRef(TmpVectors.Matrix[0]);\n        result.hit = true;\n        result.pickedSprite = sprite;\n        result.distance = distance;\n        // Get picked point\n        const direction = TmpVectors.Vector3[2];\n        direction.copyFrom(ray.direction);\n        direction.normalize();\n        direction.scaleInPlace(distance);\n        ray.origin.addToRef(direction, pickedPoint);\n        result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\n      }\n    }\n    return results;\n  }\n  /**\n   * Render all child sprites\n   */\n  render() {\n    // Check\n    if (this._fromPacked && (!this._packedAndReady || !this._spriteMap || !this._cellData)) {\n      return;\n    }\n    const engine = this._scene.getEngine();\n    const deltaTime = engine.getDeltaTime();\n    if (this._packedAndReady) {\n      this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix(), this._customUpdate);\n    } else {\n      this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix());\n    }\n  }\n  /**\n   * Rebuilds the manager (after a context lost, for eg)\n   */\n  rebuild() {\n    var _a;\n    (_a = this._spriteRenderer) === null || _a === void 0 ? void 0 : _a.rebuild();\n  }\n  /**\n   * Release associated resources\n   */\n  dispose() {\n    if (this._spriteRenderer) {\n      this._spriteRenderer.dispose();\n      this._spriteRenderer = null;\n    }\n    this._textureContent = null;\n    // Remove from scene\n    if (this._scene.spriteManagers) {\n      const index = this._scene.spriteManagers.indexOf(this);\n      this._scene.spriteManagers.splice(index, 1);\n    }\n    // Callback\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.metadata = null;\n  }\n  /**\n   * Serializes the sprite manager to a JSON object\n   * @param serializeTexture defines if the texture must be serialized as well\n   * @returns the JSON object\n   */\n  serialize(serializeTexture = false) {\n    const serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.capacity = this.capacity;\n    serializationObject.cellWidth = this.cellWidth;\n    serializationObject.cellHeight = this.cellHeight;\n    serializationObject.fogEnabled = this.fogEnabled;\n    serializationObject.blendMode = this.blendMode;\n    serializationObject.disableDepthWrite = this.disableDepthWrite;\n    serializationObject.pixelPerfect = this.pixelPerfect;\n    if (this.texture) {\n      if (serializeTexture) {\n        serializationObject.texture = this.texture.serialize();\n      } else {\n        serializationObject.textureUrl = this.texture.name;\n        serializationObject.invertY = this.texture._invertY;\n      }\n    }\n    serializationObject.sprites = [];\n    for (const sprite of this.sprites) {\n      serializationObject.sprites.push(sprite.serialize());\n    }\n    serializationObject.metadata = this.metadata;\n    return serializationObject;\n  }\n  /**\n   * Parses a JSON object to create a new sprite manager.\n   * @param parsedManager The JSON object to parse\n   * @param scene The scene to create the sprite manager\n   * @param rootUrl The root url to use to load external dependencies like texture\n   * @returns the new sprite manager\n   */\n  static Parse(parsedManager, scene, rootUrl) {\n    const manager = new SpriteManager(parsedManager.name, \"\", parsedManager.capacity, {\n      width: parsedManager.cellWidth,\n      height: parsedManager.cellHeight\n    }, scene);\n    if (parsedManager.fogEnabled !== undefined) {\n      manager.fogEnabled = parsedManager.fogEnabled;\n    }\n    if (parsedManager.blendMode !== undefined) {\n      manager.blendMode = parsedManager.blendMode;\n    }\n    if (parsedManager.disableDepthWrite !== undefined) {\n      manager.disableDepthWrite = parsedManager.disableDepthWrite;\n    }\n    if (parsedManager.pixelPerfect !== undefined) {\n      manager.pixelPerfect = parsedManager.pixelPerfect;\n    }\n    if (parsedManager.metadata !== undefined) {\n      manager.metadata = parsedManager.metadata;\n    }\n    if (parsedManager.texture) {\n      manager.texture = Texture.Parse(parsedManager.texture, scene, rootUrl);\n    } else if (parsedManager.textureName) {\n      manager.texture = new Texture(rootUrl + parsedManager.textureUrl, scene, false, parsedManager.invertY !== undefined ? parsedManager.invertY : true);\n    }\n    for (const parsedSprite of parsedManager.sprites) {\n      Sprite.Parse(parsedSprite, manager);\n    }\n    return manager;\n  }\n  /**\n   * Creates a sprite manager from a snippet saved in a remote file\n   * @param name defines the name of the sprite manager to create (can be null or empty to use the one from the json data)\n   * @param url defines the url to load from\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a promise that will resolve to the new sprite manager\n   */\n  static ParseFromFileAsync(name, url, scene, rootUrl = \"\") {\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            const serializationObject = JSON.parse(request.responseText);\n            const output = SpriteManager.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\n            if (name) {\n              output.name = name;\n            }\n            resolve(output);\n          } else {\n            reject(\"Unable to load the sprite manager\");\n          }\n        }\n      });\n      request.open(\"GET\", url);\n      request.send();\n    });\n  }\n  /**\n   * Creates a sprite manager from a snippet saved by the sprite editor\n   * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a promise that will resolve to the new sprite manager\n   */\n  static ParseFromSnippetAsync(snippetId, scene, rootUrl = \"\") {\n    if (snippetId === \"_BLANK\") {\n      return Promise.resolve(new SpriteManager(\"Default sprite manager\", \"//playground.babylonjs.com/textures/player.png\", 500, 64, scene));\n    }\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n            const serializationObject = JSON.parse(snippet.spriteManager);\n            const output = SpriteManager.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\n            output.snippetId = snippetId;\n            resolve(output);\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  }\n}\n/** Define the Url to load snippets */\nSpriteManager.SnippetUrl = `https://snippet.babylonjs.com`;\n/**\n * Creates a sprite manager from a snippet saved by the sprite editor\n * @deprecated Please use ParseFromSnippetAsync instead\n * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\n * @param scene defines the hosting scene\n * @param rootUrl defines the root URL to use to load textures and relative dependencies\n * @returns a promise that will resolve to the new sprite manager\n */\nSpriteManager.CreateFromSnippetAsync = SpriteManager.ParseFromSnippetAsync;","map":{"version":3,"names":["Observable","Vector3","TmpVectors","Matrix","Sprite","SpriteSceneComponent","PickingInfo","Texture","SceneComponentConstants","Logger","Tools","WebRequest","SpriteRenderer","EngineStore","SpriteManager","onDispose","callback","_onDisposeObserver","onDisposeObservable","remove","add","children","sprites","scene","_scene","capacity","_spriteRenderer","texture","value","wrapU","CLAMP_ADDRESSMODE","wrapV","_textureContent","cellWidth","cellHeight","fogEnabled","blendMode","disableDepthWrite","_disableDepthWrite","pixelPerfect","samplingMode","updateSamplingMode","constructor","name","imgUrl","cellSize","epsilon","TRILINEAR_SAMPLINGMODE","fromPacked","spriteJSON","Array","renderingGroupId","layerMask","isPickable","metadata","_wasDispatched","_packedAndReady","_customUpdate","sprite","baseSize","cellRef","cellIndex","num","isFinite","Math","floor","_spriteMap","_xOffset","_cellData","frame","x","width","_yOffset","y","height","_xSize","w","_ySize","h","LastCreatedScene","_getComponent","NAME_SPRITE","_addComponent","_fromPacked","engine","getEngine","undefined","spriteManagers","push","uniqueId","getUniqueId","_makePacked","getClassName","celldata","JSON","parse","frames","length","frametemp","i","_f","Object","keys","Error","spritemap","Reflect","ownKeys","e","re","li","lastIndex","test","jsonUrl","substring","onerror","onload","data","LoadFile","_checkTextureAlpha","ray","distance","min","max","useAlphaForPicking","textureSize","getSize","Uint8Array","readPixels","contactPoint","copyFrom","direction","normalize","scaleInPlace","addInPlace","origin","contactPointU","contactPointV","u","v","alpha","intersects","camera","predicate","fastCheck","count","Zero","Number","MAX_VALUE","currentSprite","pickedPoint","cameraSpacePosition","cameraView","getViewMatrix","activeRay","pickedRay","index","TransformCoordinatesToRef","position","angle","TranslationToRef","RotationZToRef","multiplyToRef","clone","TransformNormalToRef","copyFromFloats","z","intersectsBoxMinMax","currentDistance","Distance","result","invertToRef","hit","pickedSprite","addToRef","TransformCoordinates","multiIntersects","results","render","deltaTime","getDeltaTime","getProjectionMatrix","rebuild","_a","dispose","indexOf","splice","notifyObservers","clear","serialize","serializeTexture","serializationObject","textureUrl","invertY","_invertY","Parse","parsedManager","rootUrl","manager","textureName","parsedSprite","ParseFromFileAsync","url","Promise","resolve","reject","request","addEventListener","readyState","status","responseText","output","open","send","ParseFromSnippetAsync","snippetId","snippet","jsonPayload","spriteManager","SnippetUrl","replace","CreateFromSnippetAsync"],"sources":["../../../../dev/core/src/Sprites/spriteManager.ts"],"sourcesContent":["import type { IDisposable, Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3, TmpVectors, Matrix } from \"../Maths/math.vector\";\r\nimport { Sprite } from \"./sprite\";\r\nimport { SpriteSceneComponent } from \"./spriteSceneComponent\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { WebRequest } from \"../Misc/webRequest\";\r\nimport { SpriteRenderer } from \"./spriteRenderer\";\r\nimport type { ThinSprite } from \"./thinSprite\";\r\nimport type { ISize } from \"../Maths/math.size\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport type { Ray } from \"../Culling/ray\";\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect\r\ndeclare const Reflect: any;\r\n\r\n/**\r\n * Defines the minimum interface to fulfill in order to be a sprite manager.\r\n */\r\nexport interface ISpriteManager extends IDisposable {\r\n    /**\r\n     * Gets manager's name\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * Restricts the camera to viewing objects with the same layerMask.\r\n     * A camera with a layerMask of 1 will render spriteManager.layerMask & camera.layerMask!== 0\r\n     */\r\n    layerMask: number;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the mesh can be picked (by scene.pick for instance or through actions). Default is true\r\n     */\r\n    isPickable: boolean;\r\n\r\n    /**\r\n     * Gets the hosting scene\r\n     */\r\n    scene: Scene;\r\n\r\n    /**\r\n     * Specifies the rendering group id for this mesh (0 by default)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering#rendering-groups\r\n     */\r\n    renderingGroupId: number;\r\n\r\n    /**\r\n     * Defines the list of sprites managed by the manager.\r\n     */\r\n    sprites: Array<Sprite>;\r\n\r\n    /**\r\n     * Gets or sets the spritesheet texture\r\n     */\r\n    texture: Texture;\r\n\r\n    /** Defines the default width of a cell in the spritesheet */\r\n    cellWidth: number;\r\n    /** Defines the default height of a cell in the spritesheet */\r\n    cellHeight: number;\r\n\r\n    /** @internal */\r\n    _wasDispatched: boolean;\r\n\r\n    /**\r\n     * Tests the intersection of a sprite with a specific ray.\r\n     * @param ray The ray we are sending to test the collision\r\n     * @param camera The camera space we are sending rays in\r\n     * @param predicate A predicate allowing excluding sprites from the list of object to test\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @returns picking info or null.\r\n     */\r\n    intersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean): Nullable<PickingInfo>;\r\n\r\n    /**\r\n     * Intersects the sprites with a ray\r\n     * @param ray defines the ray to intersect with\r\n     * @param camera defines the current active camera\r\n     * @param predicate defines a predicate used to select candidate sprites\r\n     * @returns null if no hit or a PickingInfo array\r\n     */\r\n    multiIntersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean): Nullable<PickingInfo[]>;\r\n\r\n    /**\r\n     * Renders the list of sprites on screen.\r\n     */\r\n    render(): void;\r\n\r\n    /**\r\n     * Rebuilds the manager (after a context lost, for eg)\r\n     */\r\n    rebuild(): void;\r\n}\r\n\r\n/**\r\n * Class used to manage multiple sprites on the same spritesheet\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/sprites\r\n */\r\nexport class SpriteManager implements ISpriteManager {\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Snippet ID if the manager was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /** Gets the list of sprites */\r\n    public sprites = new Array<Sprite>();\r\n    /** Gets or sets the rendering group id (0 by default) */\r\n    public renderingGroupId = 0;\r\n    /** Gets or sets camera layer mask */\r\n    public layerMask: number = 0x0fffffff;\r\n    /** Gets or sets a boolean indicating if the sprites are pickable */\r\n    public isPickable = false;\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the sprite manager\r\n     */\r\n    public metadata: any = null;\r\n\r\n    /** @internal */\r\n    public _wasDispatched = false;\r\n\r\n    /**\r\n     * An event triggered when the manager is disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<SpriteManager>();\r\n\r\n    /**\r\n     * Callback called when the manager is disposed\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the unique id of the sprite\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Gets the array of sprites\r\n     */\r\n    public get children() {\r\n        return this.sprites;\r\n    }\r\n\r\n    /**\r\n     * Gets the hosting scene\r\n     */\r\n    public get scene() {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Gets the capacity of the manager\r\n     */\r\n    public get capacity() {\r\n        return this._spriteRenderer.capacity;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the spritesheet texture\r\n     */\r\n    public get texture(): Texture {\r\n        return this._spriteRenderer.texture as Texture;\r\n    }\r\n    public set texture(value: Texture) {\r\n        value.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        value.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._spriteRenderer.texture = value;\r\n        this._textureContent = null;\r\n    }\r\n\r\n    /** Defines the default width of a cell in the spritesheet */\r\n    public get cellWidth(): number {\r\n        return this._spriteRenderer.cellWidth;\r\n    }\r\n    public set cellWidth(value: number) {\r\n        this._spriteRenderer.cellWidth = value;\r\n    }\r\n\r\n    /** Defines the default height of a cell in the spritesheet */\r\n    public get cellHeight(): number {\r\n        return this._spriteRenderer.cellHeight;\r\n    }\r\n    public set cellHeight(value: number) {\r\n        this._spriteRenderer.cellHeight = value;\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if the manager must consider scene fog when rendering */\r\n    public get fogEnabled(): boolean {\r\n        return this._spriteRenderer.fogEnabled;\r\n    }\r\n    public set fogEnabled(value: boolean) {\r\n        this._spriteRenderer.fogEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Blend mode use to render the particle, it can be any of\r\n     * the static Constants.ALPHA_x properties provided in this class.\r\n     * Default value is Constants.ALPHA_COMBINE\r\n     */\r\n    public get blendMode() {\r\n        return this._spriteRenderer.blendMode;\r\n    }\r\n    public set blendMode(blendMode: number) {\r\n        this._spriteRenderer.blendMode = blendMode;\r\n    }\r\n\r\n    private _disableDepthWrite: boolean = false;\r\n    /** Disables writing to the depth buffer when rendering the sprites.\r\n     *  It can be handy to disable depth writing when using textures without alpha channel\r\n     *  and setting some specific blend modes.\r\n     */\r\n    public get disableDepthWrite() {\r\n        return this._disableDepthWrite;\r\n    }\r\n\r\n    public set disableDepthWrite(value: boolean) {\r\n        this._disableDepthWrite = value;\r\n        this._spriteRenderer.disableDepthWrite = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the renderer must render sprites with pixel perfect rendering\r\n     * In this mode, sprites are rendered as \"pixel art\", which means that they appear as pixelated but remain stable when moving or when rotated or scaled.\r\n     * Note that for this mode to work as expected, the sprite texture must use the BILINEAR sampling mode, not NEAREST!\r\n     */\r\n    public get pixelPerfect() {\r\n        return this._spriteRenderer.pixelPerfect;\r\n    }\r\n\r\n    public set pixelPerfect(value: boolean) {\r\n        this._spriteRenderer.pixelPerfect = value;\r\n        if (value && this.texture.samplingMode !== Constants.TEXTURE_TRILINEAR_SAMPLINGMODE) {\r\n            this.texture.updateSamplingMode(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE);\r\n        }\r\n    }\r\n\r\n    private _spriteRenderer: SpriteRenderer;\r\n    /** Associative array from JSON sprite data file */\r\n    private _cellData: any;\r\n    /** Array of sprite names from JSON sprite data file */\r\n    private _spriteMap: Array<string>;\r\n    /** True when packed cell data from JSON file is ready*/\r\n    private _packedAndReady: boolean = false;\r\n    private _textureContent: Nullable<Uint8Array>;\r\n    private _onDisposeObserver: Nullable<Observer<SpriteManager>>;\r\n    private _fromPacked: boolean;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Creates a new sprite manager\r\n     * @param name defines the manager's name\r\n     * @param imgUrl defines the sprite sheet url\r\n     * @param capacity defines the maximum allowed number of sprites\r\n     * @param cellSize defines the size of a sprite cell\r\n     * @param scene defines the hosting scene\r\n     * @param epsilon defines the epsilon value to align texture (0.01 by default)\r\n     * @param samplingMode defines the sampling mode to use with spritesheet\r\n     * @param fromPacked set to false; do not alter\r\n     * @param spriteJSON null otherwise a JSON object defining sprite sheet data; do not alter\r\n     */\r\n    constructor(\r\n        /** defines the manager's name */\r\n        public name: string,\r\n        imgUrl: string,\r\n        capacity: number,\r\n        cellSize: any,\r\n        scene: Scene,\r\n        epsilon: number = 0.01,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        fromPacked: boolean = false,\r\n        spriteJSON: any | null = null\r\n    ) {\r\n        if (!scene) {\r\n            scene = EngineStore.LastCreatedScene!;\r\n        }\r\n\r\n        if (!scene._getComponent(SceneComponentConstants.NAME_SPRITE)) {\r\n            scene._addComponent(new SpriteSceneComponent(scene));\r\n        }\r\n        this._fromPacked = fromPacked;\r\n\r\n        this._scene = scene;\r\n        const engine = this._scene.getEngine();\r\n        this._spriteRenderer = new SpriteRenderer(engine, capacity, epsilon, scene);\r\n\r\n        if (cellSize.width && cellSize.height) {\r\n            this.cellWidth = cellSize.width;\r\n            this.cellHeight = cellSize.height;\r\n        } else if (cellSize !== undefined) {\r\n            this.cellWidth = cellSize;\r\n            this.cellHeight = cellSize;\r\n        } else {\r\n            this._spriteRenderer = <any>null;\r\n            return;\r\n        }\r\n\r\n        this._scene.spriteManagers && this._scene.spriteManagers.push(this);\r\n        this.uniqueId = this.scene.getUniqueId();\r\n\r\n        if (imgUrl) {\r\n            this.texture = new Texture(imgUrl, scene, true, false, samplingMode);\r\n        }\r\n\r\n        if (this._fromPacked) {\r\n            this._makePacked(imgUrl, spriteJSON);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"SpriteManager\"\r\n     * @returns \"SpriteManager\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"SpriteManager\";\r\n    }\r\n\r\n    private _makePacked(imgUrl: string, spriteJSON: any) {\r\n        if (spriteJSON !== null) {\r\n            try {\r\n                //Get the JSON and Check its structure.  If its an array parse it if its a JSON string etc...\r\n                let celldata: any;\r\n                if (typeof spriteJSON === \"string\") {\r\n                    celldata = JSON.parse(spriteJSON);\r\n                } else {\r\n                    celldata = spriteJSON;\r\n                }\r\n\r\n                if (celldata.frames.length) {\r\n                    const frametemp: any = {};\r\n                    for (let i = 0; i < celldata.frames.length; i++) {\r\n                        const _f = celldata.frames[i];\r\n                        if (typeof Object.keys(_f)[0] !== \"string\") {\r\n                            throw new Error(\"Invalid JSON Format.  Check the frame values and make sure the name is the first parameter.\");\r\n                        }\r\n\r\n                        const name: string = _f[Object.keys(_f)[0]];\r\n                        frametemp[name] = _f;\r\n                    }\r\n                    celldata.frames = frametemp;\r\n                }\r\n\r\n                const spritemap = <string[]>Reflect.ownKeys(celldata.frames);\r\n\r\n                this._spriteMap = spritemap;\r\n                this._packedAndReady = true;\r\n                this._cellData = celldata.frames;\r\n            } catch (e) {\r\n                this._fromPacked = false;\r\n                this._packedAndReady = false;\r\n                throw new Error(\"Invalid JSON from string. Spritesheet managed with constant cell size.\");\r\n            }\r\n        } else {\r\n            const re = /\\./g;\r\n            let li: number;\r\n            do {\r\n                li = re.lastIndex;\r\n                re.test(imgUrl);\r\n            } while (re.lastIndex > 0);\r\n            const jsonUrl = imgUrl.substring(0, li - 1) + \".json\";\r\n            const onerror = () => {\r\n                Logger.Error(\"JSON ERROR: Unable to load JSON file.\");\r\n                this._fromPacked = false;\r\n                this._packedAndReady = false;\r\n            };\r\n            const onload = (data: string | ArrayBuffer) => {\r\n                try {\r\n                    const celldata = JSON.parse(data as string);\r\n                    const spritemap = <string[]>Reflect.ownKeys(celldata.frames);\r\n                    this._spriteMap = spritemap;\r\n                    this._packedAndReady = true;\r\n                    this._cellData = celldata.frames;\r\n                } catch (e) {\r\n                    this._fromPacked = false;\r\n                    this._packedAndReady = false;\r\n                    throw new Error(\"Invalid JSON format. Please check documentation for format specifications.\");\r\n                }\r\n            };\r\n            Tools.LoadFile(jsonUrl, onload, undefined, undefined, false, onerror);\r\n        }\r\n    }\r\n\r\n    private _checkTextureAlpha(sprite: Sprite, ray: Ray, distance: number, min: Vector3, max: Vector3) {\r\n        if (!sprite.useAlphaForPicking || !this.texture) {\r\n            return true;\r\n        }\r\n\r\n        const textureSize = this.texture.getSize();\r\n        if (!this._textureContent) {\r\n            this._textureContent = new Uint8Array(textureSize.width * textureSize.height * 4);\r\n            this.texture.readPixels(0, 0, this._textureContent);\r\n        }\r\n\r\n        const contactPoint = TmpVectors.Vector3[0];\r\n\r\n        contactPoint.copyFrom(ray.direction);\r\n\r\n        contactPoint.normalize();\r\n        contactPoint.scaleInPlace(distance);\r\n        contactPoint.addInPlace(ray.origin);\r\n\r\n        const contactPointU = (contactPoint.x - min.x) / (max.x - min.x);\r\n        const contactPointV = 1.0 - (contactPoint.y - min.y) / (max.y - min.y);\r\n\r\n        const u = (sprite._xOffset * textureSize.width + contactPointU * sprite._xSize) | 0;\r\n        const v = (sprite._yOffset * textureSize.height + contactPointV * sprite._ySize) | 0;\r\n\r\n        const alpha = this._textureContent![(u + v * textureSize.width) * 4 + 3];\r\n\r\n        return alpha > 0.5;\r\n    }\r\n\r\n    /**\r\n     * Intersects the sprites with a ray\r\n     * @param ray defines the ray to intersect with\r\n     * @param camera defines the current active camera\r\n     * @param predicate defines a predicate used to select candidate sprites\r\n     * @param fastCheck defines if a fast check only must be done (the first potential sprite is will be used and not the closer)\r\n     * @returns null if no hit or a PickingInfo\r\n     */\r\n    public intersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean): Nullable<PickingInfo> {\r\n        const count = Math.min(this.capacity, this.sprites.length);\r\n        const min = Vector3.Zero();\r\n        const max = Vector3.Zero();\r\n        let distance = Number.MAX_VALUE;\r\n        let currentSprite: Nullable<Sprite> = null;\r\n        const pickedPoint = TmpVectors.Vector3[0];\r\n        const cameraSpacePosition = TmpVectors.Vector3[1];\r\n        const cameraView = camera.getViewMatrix();\r\n        let activeRay: Ray = ray;\r\n        let pickedRay: Ray = ray;\r\n\r\n        for (let index = 0; index < count; index++) {\r\n            const sprite = this.sprites[index];\r\n            if (!sprite) {\r\n                continue;\r\n            }\r\n\r\n            if (predicate) {\r\n                if (!predicate(sprite)) {\r\n                    continue;\r\n                }\r\n            } else if (!sprite.isPickable) {\r\n                continue;\r\n            }\r\n\r\n            Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\r\n\r\n            if (sprite.angle) {\r\n                // Create a rotation matrix to rotate the ray to the sprite's rotation\r\n                Matrix.TranslationToRef(-cameraSpacePosition.x, -cameraSpacePosition.y, 0, TmpVectors.Matrix[1]);\r\n                Matrix.TranslationToRef(cameraSpacePosition.x, cameraSpacePosition.y, 0, TmpVectors.Matrix[2]);\r\n                Matrix.RotationZToRef(-sprite.angle, TmpVectors.Matrix[3]);\r\n\r\n                // inv translation x rotation x translation\r\n                TmpVectors.Matrix[1].multiplyToRef(TmpVectors.Matrix[3], TmpVectors.Matrix[4]);\r\n                TmpVectors.Matrix[4].multiplyToRef(TmpVectors.Matrix[2], TmpVectors.Matrix[0]);\r\n\r\n                activeRay = ray.clone();\r\n                Vector3.TransformCoordinatesToRef(ray.origin, TmpVectors.Matrix[0], activeRay.origin);\r\n                Vector3.TransformNormalToRef(ray.direction, TmpVectors.Matrix[0], activeRay.direction);\r\n            } else {\r\n                activeRay = ray;\r\n            }\r\n\r\n            min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\r\n            max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\r\n\r\n            if (activeRay.intersectsBoxMinMax(min, max)) {\r\n                const currentDistance = Vector3.Distance(cameraSpacePosition, activeRay.origin);\r\n\r\n                if (distance > currentDistance) {\r\n                    if (!this._checkTextureAlpha(sprite, activeRay, currentDistance, min, max)) {\r\n                        continue;\r\n                    }\r\n\r\n                    pickedRay = activeRay;\r\n                    distance = currentDistance;\r\n                    currentSprite = sprite;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (currentSprite) {\r\n            const result = new PickingInfo();\r\n\r\n            cameraView.invertToRef(TmpVectors.Matrix[0]);\r\n            result.hit = true;\r\n            result.pickedSprite = currentSprite;\r\n            result.distance = distance;\r\n\r\n            // Get picked point\r\n            const direction = TmpVectors.Vector3[2];\r\n            direction.copyFrom(pickedRay.direction);\r\n            direction.normalize();\r\n            direction.scaleInPlace(distance);\r\n\r\n            pickedRay.origin.addToRef(direction, pickedPoint);\r\n            result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\r\n\r\n            return result;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Intersects the sprites with a ray\r\n     * @param ray defines the ray to intersect with\r\n     * @param camera defines the current active camera\r\n     * @param predicate defines a predicate used to select candidate sprites\r\n     * @returns null if no hit or a PickingInfo array\r\n     */\r\n    public multiIntersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean): Nullable<PickingInfo[]> {\r\n        const count = Math.min(this.capacity, this.sprites.length);\r\n        const min = Vector3.Zero();\r\n        const max = Vector3.Zero();\r\n        let distance: number;\r\n        const results: Nullable<PickingInfo[]> = [];\r\n        const pickedPoint = TmpVectors.Vector3[0].copyFromFloats(0, 0, 0);\r\n        const cameraSpacePosition = TmpVectors.Vector3[1].copyFromFloats(0, 0, 0);\r\n        const cameraView = camera.getViewMatrix();\r\n\r\n        for (let index = 0; index < count; index++) {\r\n            const sprite = this.sprites[index];\r\n            if (!sprite) {\r\n                continue;\r\n            }\r\n\r\n            if (predicate) {\r\n                if (!predicate(sprite)) {\r\n                    continue;\r\n                }\r\n            } else if (!sprite.isPickable) {\r\n                continue;\r\n            }\r\n\r\n            Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\r\n\r\n            min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\r\n            max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\r\n\r\n            if (ray.intersectsBoxMinMax(min, max)) {\r\n                distance = Vector3.Distance(cameraSpacePosition, ray.origin);\r\n\r\n                if (!this._checkTextureAlpha(sprite, ray, distance, min, max)) {\r\n                    continue;\r\n                }\r\n\r\n                const result = new PickingInfo();\r\n                results.push(result);\r\n\r\n                cameraView.invertToRef(TmpVectors.Matrix[0]);\r\n                result.hit = true;\r\n                result.pickedSprite = sprite;\r\n                result.distance = distance;\r\n\r\n                // Get picked point\r\n                const direction = TmpVectors.Vector3[2];\r\n                direction.copyFrom(ray.direction);\r\n                direction.normalize();\r\n                direction.scaleInPlace(distance);\r\n\r\n                ray.origin.addToRef(direction, pickedPoint);\r\n                result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\r\n            }\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Render all child sprites\r\n     */\r\n    public render(): void {\r\n        // Check\r\n        if (this._fromPacked && (!this._packedAndReady || !this._spriteMap || !this._cellData)) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n        const deltaTime = engine.getDeltaTime();\r\n        if (this._packedAndReady) {\r\n            this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix(), this._customUpdate);\r\n        } else {\r\n            this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix());\r\n        }\r\n    }\r\n\r\n    private _customUpdate = (sprite: ThinSprite, baseSize: ISize): void => {\r\n        if (!sprite.cellRef) {\r\n            sprite.cellIndex = 0;\r\n        }\r\n        const num = sprite.cellIndex;\r\n        if (typeof num === \"number\" && isFinite(num) && Math.floor(num) === num) {\r\n            sprite.cellRef = this._spriteMap[sprite.cellIndex];\r\n        }\r\n        sprite._xOffset = this._cellData[sprite.cellRef].frame.x / baseSize.width;\r\n        sprite._yOffset = this._cellData[sprite.cellRef].frame.y / baseSize.height;\r\n        sprite._xSize = this._cellData[sprite.cellRef].frame.w;\r\n        sprite._ySize = this._cellData[sprite.cellRef].frame.h;\r\n    };\r\n\r\n    /**\r\n     * Rebuilds the manager (after a context lost, for eg)\r\n     */\r\n    public rebuild(): void {\r\n        this._spriteRenderer?.rebuild();\r\n    }\r\n\r\n    /**\r\n     * Release associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (this._spriteRenderer) {\r\n            this._spriteRenderer.dispose();\r\n            (<any>this._spriteRenderer) = null;\r\n        }\r\n\r\n        this._textureContent = null;\r\n\r\n        // Remove from scene\r\n        if (this._scene.spriteManagers) {\r\n            const index = this._scene.spriteManagers.indexOf(this);\r\n            this._scene.spriteManagers.splice(index, 1);\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n\r\n        this.metadata = null;\r\n    }\r\n\r\n    /**\r\n     * Serializes the sprite manager to a JSON object\r\n     * @param serializeTexture defines if the texture must be serialized as well\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(serializeTexture = false): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.capacity = this.capacity;\r\n        serializationObject.cellWidth = this.cellWidth;\r\n        serializationObject.cellHeight = this.cellHeight;\r\n        serializationObject.fogEnabled = this.fogEnabled;\r\n        serializationObject.blendMode = this.blendMode;\r\n        serializationObject.disableDepthWrite = this.disableDepthWrite;\r\n        serializationObject.pixelPerfect = this.pixelPerfect;\r\n\r\n        if (this.texture) {\r\n            if (serializeTexture) {\r\n                serializationObject.texture = this.texture.serialize();\r\n            } else {\r\n                serializationObject.textureUrl = this.texture.name;\r\n                serializationObject.invertY = this.texture._invertY;\r\n            }\r\n        }\r\n\r\n        serializationObject.sprites = [];\r\n\r\n        for (const sprite of this.sprites) {\r\n            serializationObject.sprites.push(sprite.serialize());\r\n        }\r\n\r\n        serializationObject.metadata = this.metadata;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parses a JSON object to create a new sprite manager.\r\n     * @param parsedManager The JSON object to parse\r\n     * @param scene The scene to create the sprite manager\r\n     * @param rootUrl The root url to use to load external dependencies like texture\r\n     * @returns the new sprite manager\r\n     */\r\n    public static Parse(parsedManager: any, scene: Scene, rootUrl: string): SpriteManager {\r\n        const manager = new SpriteManager(\r\n            parsedManager.name,\r\n            \"\",\r\n            parsedManager.capacity,\r\n            {\r\n                width: parsedManager.cellWidth,\r\n                height: parsedManager.cellHeight,\r\n            },\r\n            scene\r\n        );\r\n\r\n        if (parsedManager.fogEnabled !== undefined) {\r\n            manager.fogEnabled = parsedManager.fogEnabled;\r\n        }\r\n        if (parsedManager.blendMode !== undefined) {\r\n            manager.blendMode = parsedManager.blendMode;\r\n        }\r\n        if (parsedManager.disableDepthWrite !== undefined) {\r\n            manager.disableDepthWrite = parsedManager.disableDepthWrite;\r\n        }\r\n        if (parsedManager.pixelPerfect !== undefined) {\r\n            manager.pixelPerfect = parsedManager.pixelPerfect;\r\n        }\r\n\r\n        if (parsedManager.metadata !== undefined) {\r\n            manager.metadata = parsedManager.metadata;\r\n        }\r\n\r\n        if (parsedManager.texture) {\r\n            manager.texture = Texture.Parse(parsedManager.texture, scene, rootUrl) as Texture;\r\n        } else if (parsedManager.textureName) {\r\n            manager.texture = new Texture(rootUrl + parsedManager.textureUrl, scene, false, parsedManager.invertY !== undefined ? parsedManager.invertY : true);\r\n        }\r\n\r\n        for (const parsedSprite of parsedManager.sprites) {\r\n            Sprite.Parse(parsedSprite, manager);\r\n        }\r\n\r\n        return manager;\r\n    }\r\n\r\n    /**\r\n     * Creates a sprite manager from a snippet saved in a remote file\r\n     * @param name defines the name of the sprite manager to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new sprite manager\r\n     */\r\n    public static ParseFromFileAsync(name: Nullable<string>, url: string, scene: Scene, rootUrl: string = \"\"): Promise<SpriteManager> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const serializationObject = JSON.parse(request.responseText);\r\n                        const output = SpriteManager.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\r\n\r\n                        if (name) {\r\n                            output.name = name;\r\n                        }\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the sprite manager\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a sprite manager from a snippet saved by the sprite editor\r\n     * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new sprite manager\r\n     */\r\n    public static ParseFromSnippetAsync(snippetId: string, scene: Scene, rootUrl: string = \"\"): Promise<SpriteManager> {\r\n        if (snippetId === \"_BLANK\") {\r\n            return Promise.resolve(new SpriteManager(\"Default sprite manager\", \"//playground.babylonjs.com/textures/player.png\", 500, 64, scene));\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        const serializationObject = JSON.parse(snippet.spriteManager);\r\n                        const output = SpriteManager.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\r\n\r\n                        output.snippetId = snippetId;\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a sprite manager from a snippet saved by the sprite editor\r\n     * @deprecated Please use ParseFromSnippetAsync instead\r\n     * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new sprite manager\r\n     */\r\n    public static CreateFromSnippetAsync = SpriteManager.ParseFromSnippetAsync;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}