{"ast":null,"code":"import { Logger } from \"../Misc/logger.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { PlaneRotationGizmo } from \"./planeRotationGizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\n/**\n * Gizmo that enables rotating a mesh along 3 axis\n */\nexport class RotationGizmo extends Gizmo {\n  get attachedMesh() {\n    return this._meshAttached;\n  }\n  set attachedMesh(mesh) {\n    this._meshAttached = mesh;\n    this._nodeAttached = mesh;\n    this._checkBillboardTransform();\n    [this.xGizmo, this.yGizmo, this.zGizmo].forEach(gizmo => {\n      if (gizmo.isEnabled) {\n        gizmo.attachedMesh = mesh;\n      } else {\n        gizmo.attachedMesh = null;\n      }\n    });\n  }\n  get attachedNode() {\n    return this._nodeAttached;\n  }\n  set attachedNode(node) {\n    this._meshAttached = null;\n    this._nodeAttached = node;\n    this._checkBillboardTransform();\n    [this.xGizmo, this.yGizmo, this.zGizmo].forEach(gizmo => {\n      if (gizmo.isEnabled) {\n        gizmo.attachedNode = node;\n      } else {\n        gizmo.attachedNode = null;\n      }\n    });\n  }\n  _checkBillboardTransform() {\n    if (this._nodeAttached && this._nodeAttached.billboardMode) {\n      console.log(\"Rotation Gizmo will not work with transforms in billboard mode.\");\n    }\n  }\n  /**\n   * Sensitivity factor for dragging (Default: 1)\n   */\n  set sensitivity(value) {\n    this._sensitivity = value;\n    [this.xGizmo, this.yGizmo, this.zGizmo].forEach(gizmo => {\n      if (gizmo) {\n        gizmo.sensitivity = value;\n      }\n    });\n  }\n  get sensitivity() {\n    return this._sensitivity;\n  }\n  /**\n   * True when the mouse pointer is hovering a gizmo mesh\n   */\n  get isHovered() {\n    let hovered = false;\n    [this.xGizmo, this.yGizmo, this.zGizmo].forEach(gizmo => {\n      hovered = hovered || gizmo.isHovered;\n    });\n    return hovered;\n  }\n  /**\n   * Creates a RotationGizmo\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   * @param tessellation Amount of tessellation to be used when creating rotation circles\n   * @param useEulerRotation Use and update Euler angle instead of quaternion\n   * @param thickness display gizmo axis thickness\n   * @param gizmoManager Gizmo manager\n   * @param options More options\n   */\n  constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, tessellation = 32, useEulerRotation = false, thickness = 1, gizmoManager, options) {\n    super(gizmoLayer);\n    /** Fires an event when any of it's sub gizmos are dragged */\n    this.onDragStartObservable = new Observable();\n    /** Fires an event when any of it's sub gizmos are being dragged */\n    this.onDragObservable = new Observable();\n    /** Fires an event when any of it's sub gizmos are released from dragging */\n    this.onDragEndObservable = new Observable();\n    this._observables = [];\n    this._sensitivity = 1;\n    /** Node Caching for quick lookup */\n    this._gizmoAxisCache = new Map();\n    const xColor = options && options.xOptions && options.xOptions.color ? options.xOptions.color : Color3.Red().scale(0.5);\n    const yColor = options && options.yOptions && options.yOptions.color ? options.yOptions.color : Color3.Green().scale(0.5);\n    const zColor = options && options.zOptions && options.zOptions.color ? options.zOptions.color : Color3.Blue().scale(0.5);\n    this.xGizmo = new PlaneRotationGizmo(new Vector3(1, 0, 0), xColor, gizmoLayer, tessellation, this, useEulerRotation, thickness);\n    this.yGizmo = new PlaneRotationGizmo(new Vector3(0, 1, 0), yColor, gizmoLayer, tessellation, this, useEulerRotation, thickness);\n    this.zGizmo = new PlaneRotationGizmo(new Vector3(0, 0, 1), zColor, gizmoLayer, tessellation, this, useEulerRotation, thickness);\n    // Relay drag events and set update scale\n    [this.xGizmo, this.yGizmo, this.zGizmo].forEach(gizmo => {\n      //must set updateScale on each gizmo, as setting it on root RotationGizmo doesnt prevent individual gizmos from updating\n      //currently updateScale is a property with no getter/setter, so no good way to override behavior at runtime, so we will at least set it on startup\n      if (options && options.updateScale != undefined) {\n        gizmo.updateScale = options.updateScale;\n      }\n      gizmo.dragBehavior.onDragStartObservable.add(() => {\n        this.onDragStartObservable.notifyObservers({});\n      });\n      gizmo.dragBehavior.onDragObservable.add(() => {\n        this.onDragObservable.notifyObservers({});\n      });\n      gizmo.dragBehavior.onDragEndObservable.add(() => {\n        this.onDragEndObservable.notifyObservers({});\n      });\n    });\n    this.attachedMesh = null;\n    this.attachedNode = null;\n    if (gizmoManager) {\n      gizmoManager.addToAxisCache(this._gizmoAxisCache);\n    } else {\n      // Only subscribe to pointer event if gizmoManager isnt\n      Gizmo.GizmoAxisPointerObserver(gizmoLayer, this._gizmoAxisCache);\n    }\n  }\n  /**\n   * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\n   * NOTE: This is only possible for meshes with uniform scaling, as otherwise it's not possible to decompose the rotation\n   */\n  set updateGizmoRotationToMatchAttachedMesh(value) {\n    if (this.xGizmo) {\n      this.xGizmo.updateGizmoRotationToMatchAttachedMesh = value;\n      this.yGizmo.updateGizmoRotationToMatchAttachedMesh = value;\n      this.zGizmo.updateGizmoRotationToMatchAttachedMesh = value;\n    }\n  }\n  get updateGizmoRotationToMatchAttachedMesh() {\n    return this.xGizmo.updateGizmoRotationToMatchAttachedMesh;\n  }\n  set updateGizmoPositionToMatchAttachedMesh(value) {\n    if (this.xGizmo) {\n      this.xGizmo.updateGizmoPositionToMatchAttachedMesh = value;\n      this.yGizmo.updateGizmoPositionToMatchAttachedMesh = value;\n      this.zGizmo.updateGizmoPositionToMatchAttachedMesh = value;\n    }\n  }\n  get updateGizmoPositionToMatchAttachedMesh() {\n    return this.xGizmo.updateGizmoPositionToMatchAttachedMesh;\n  }\n  set anchorPoint(value) {\n    this._anchorPoint = value;\n    [this.xGizmo, this.yGizmo, this.zGizmo].forEach(gizmo => {\n      gizmo.anchorPoint = value;\n    });\n  }\n  get anchorPoint() {\n    return this._anchorPoint;\n  }\n  /**\n   * Set the coordinate system to use. By default it's local.\n   * But it's possible for a user to tweak so its local for translation and world for rotation.\n   * In that case, setting the coordinate system will change `updateGizmoRotationToMatchAttachedMesh` and `updateGizmoPositionToMatchAttachedMesh`\n   */\n  set coordinatesMode(coordinatesMode) {\n    [this.xGizmo, this.yGizmo, this.zGizmo].forEach(gizmo => {\n      gizmo.coordinatesMode = coordinatesMode;\n    });\n  }\n  set updateScale(value) {\n    if (this.xGizmo) {\n      this.xGizmo.updateScale = value;\n      this.yGizmo.updateScale = value;\n      this.zGizmo.updateScale = value;\n    }\n  }\n  get updateScale() {\n    return this.xGizmo.updateScale;\n  }\n  /**\n   * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)\n   */\n  set snapDistance(value) {\n    if (this.xGizmo) {\n      this.xGizmo.snapDistance = value;\n      this.yGizmo.snapDistance = value;\n      this.zGizmo.snapDistance = value;\n    }\n  }\n  get snapDistance() {\n    return this.xGizmo.snapDistance;\n  }\n  /**\n   * Ratio for the scale of the gizmo (Default: 1)\n   */\n  set scaleRatio(value) {\n    if (this.xGizmo) {\n      this.xGizmo.scaleRatio = value;\n      this.yGizmo.scaleRatio = value;\n      this.zGizmo.scaleRatio = value;\n    }\n  }\n  get scaleRatio() {\n    return this.xGizmo.scaleRatio;\n  }\n  /**\n   * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\n   * @param mesh Axis gizmo mesh\n   * @param cache Gizmo axis definition used for reactive gizmo UI\n   */\n  addToAxisCache(mesh, cache) {\n    this._gizmoAxisCache.set(mesh, cache);\n  }\n  /**\n   * Disposes of the gizmo\n   */\n  dispose() {\n    this.xGizmo.dispose();\n    this.yGizmo.dispose();\n    this.zGizmo.dispose();\n    this.onDragStartObservable.clear();\n    this.onDragObservable.clear();\n    this.onDragEndObservable.clear();\n    this._observables.forEach(obs => {\n      this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(obs);\n    });\n  }\n  /**\n   * CustomMeshes are not supported by this gizmo\n   */\n  setCustomMesh() {\n    Logger.Error(\"Custom meshes are not supported on this gizmo, please set the custom meshes on the gizmos contained within this one (gizmo.xGizmo, gizmo.yGizmo, gizmo.zGizmo)\");\n  }\n}","map":{"version":3,"names":["Logger","Observable","Vector3","Color3","Gizmo","PlaneRotationGizmo","UtilityLayerRenderer","RotationGizmo","attachedMesh","_meshAttached","mesh","_nodeAttached","_checkBillboardTransform","xGizmo","yGizmo","zGizmo","forEach","gizmo","isEnabled","attachedNode","node","billboardMode","console","log","sensitivity","value","_sensitivity","isHovered","hovered","constructor","gizmoLayer","DefaultUtilityLayer","tessellation","useEulerRotation","thickness","gizmoManager","options","onDragStartObservable","onDragObservable","onDragEndObservable","_observables","_gizmoAxisCache","Map","xColor","xOptions","color","Red","scale","yColor","yOptions","Green","zColor","zOptions","Blue","updateScale","undefined","dragBehavior","add","notifyObservers","addToAxisCache","GizmoAxisPointerObserver","updateGizmoRotationToMatchAttachedMesh","updateGizmoPositionToMatchAttachedMesh","anchorPoint","_anchorPoint","coordinatesMode","snapDistance","scaleRatio","cache","set","dispose","clear","obs","utilityLayerScene","onPointerObservable","remove","setCustomMesh","Error"],"sources":["../../../../dev/core/src/Gizmos/rotationGizmo.ts"],"sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { GizmoAnchorPoint, GizmoCoordinatesMode, GizmoAxisCache, IGizmo } from \"./gizmo\";\r\nimport { Gizmo } from \"./gizmo\";\r\nimport type { IPlaneRotationGizmo } from \"./planeRotationGizmo\";\r\nimport { PlaneRotationGizmo } from \"./planeRotationGizmo\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport type { Node } from \"../node\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { GizmoManager } from \"./gizmoManager\";\r\n\r\n/**\r\n * Interface for rotation gizmo\r\n */\r\nexport interface IRotationGizmo extends IGizmo {\r\n    /** Internal gizmo used for interactions on the x axis */\r\n    xGizmo: IPlaneRotationGizmo;\r\n    /** Internal gizmo used for interactions on the y axis */\r\n    yGizmo: IPlaneRotationGizmo;\r\n    /** Internal gizmo used for interactions on the z axis */\r\n    zGizmo: IPlaneRotationGizmo;\r\n    /** Fires an event when any of it's sub gizmos are dragged */\r\n    onDragStartObservable: Observable<unknown>;\r\n    /** Fires an event when any of it's sub gizmos are being dragged */\r\n    onDragObservable: Observable<unknown>;\r\n    /** Fires an event when any of it's sub gizmos are released from dragging */\r\n    onDragEndObservable: Observable<unknown>;\r\n    /** Drag distance in babylon units that the gizmo will snap to when dragged */\r\n    snapDistance: number;\r\n    /** Custom sensitivity value for the drag strength */\r\n    sensitivity: number;\r\n    /**\r\n     * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\r\n     * @param mesh Axis gizmo mesh\r\n     * @param cache Gizmo axis definition used for reactive gizmo UI\r\n     */\r\n    addToAxisCache(mesh: Mesh, cache: GizmoAxisCache): void;\r\n}\r\n\r\n/**\r\n * Options for each individual plane rotation gizmo contained within RotationGizmo\r\n * @since 5.0.0\r\n */\r\nexport interface PlaneRotationGizmoOptions {\r\n    /**\r\n     * Color to use for the plane rotation gizmo\r\n     */\r\n    color?: Color3;\r\n}\r\n\r\n/**\r\n * Additional options for each rotation gizmo\r\n */\r\nexport interface RotationGizmoOptions {\r\n    /**\r\n     * When set, the gizmo will always appear the same size no matter where the camera is (default: true)\r\n     */\r\n    updateScale?: boolean;\r\n\r\n    /**\r\n     * Specific options for xGizmo\r\n     */\r\n    xOptions?: PlaneRotationGizmoOptions;\r\n\r\n    /**\r\n     * Specific options for yGizmo\r\n     */\r\n    yOptions?: PlaneRotationGizmoOptions;\r\n\r\n    /**\r\n     * Specific options for zGizmo\r\n     */\r\n    zOptions?: PlaneRotationGizmoOptions;\r\n}\r\n\r\n/**\r\n * Gizmo that enables rotating a mesh along 3 axis\r\n */\r\nexport class RotationGizmo extends Gizmo implements IRotationGizmo {\r\n    /**\r\n     * Internal gizmo used for interactions on the x axis\r\n     */\r\n    public xGizmo: IPlaneRotationGizmo;\r\n    /**\r\n     * Internal gizmo used for interactions on the y axis\r\n     */\r\n    public yGizmo: IPlaneRotationGizmo;\r\n    /**\r\n     * Internal gizmo used for interactions on the z axis\r\n     */\r\n    public zGizmo: IPlaneRotationGizmo;\r\n\r\n    /** Fires an event when any of it's sub gizmos are dragged */\r\n    public onDragStartObservable = new Observable();\r\n    /** Fires an event when any of it's sub gizmos are being dragged */\r\n    public onDragObservable = new Observable();\r\n    /** Fires an event when any of it's sub gizmos are released from dragging */\r\n    public onDragEndObservable = new Observable();\r\n\r\n    protected _meshAttached: Nullable<AbstractMesh>;\r\n    protected _nodeAttached: Nullable<Node>;\r\n    protected _observables: Observer<PointerInfo>[] = [];\r\n    protected _sensitivity: number = 1;\r\n\r\n    /** Node Caching for quick lookup */\r\n    protected _gizmoAxisCache: Map<Mesh, GizmoAxisCache> = new Map();\r\n\r\n    public get attachedMesh() {\r\n        return this._meshAttached;\r\n    }\r\n    public set attachedMesh(mesh: Nullable<AbstractMesh>) {\r\n        this._meshAttached = mesh;\r\n        this._nodeAttached = mesh;\r\n        this._checkBillboardTransform();\r\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\r\n            if (gizmo.isEnabled) {\r\n                gizmo.attachedMesh = mesh;\r\n            } else {\r\n                gizmo.attachedMesh = null;\r\n            }\r\n        });\r\n    }\r\n\r\n    public get attachedNode() {\r\n        return this._nodeAttached;\r\n    }\r\n    public set attachedNode(node: Nullable<Node>) {\r\n        this._meshAttached = null;\r\n        this._nodeAttached = node;\r\n        this._checkBillboardTransform();\r\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\r\n            if (gizmo.isEnabled) {\r\n                gizmo.attachedNode = node;\r\n            } else {\r\n                gizmo.attachedNode = null;\r\n            }\r\n        });\r\n    }\r\n\r\n    protected _checkBillboardTransform() {\r\n        if (this._nodeAttached && (<TransformNode>this._nodeAttached).billboardMode) {\r\n            console.log(\"Rotation Gizmo will not work with transforms in billboard mode.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sensitivity factor for dragging (Default: 1)\r\n     */\r\n    public set sensitivity(value: number) {\r\n        this._sensitivity = value;\r\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\r\n            if (gizmo) {\r\n                gizmo.sensitivity = value;\r\n            }\r\n        });\r\n    }\r\n    public get sensitivity() {\r\n        return this._sensitivity;\r\n    }\r\n\r\n    /**\r\n     * True when the mouse pointer is hovering a gizmo mesh\r\n     */\r\n    public get isHovered() {\r\n        let hovered = false;\r\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\r\n            hovered = hovered || gizmo.isHovered;\r\n        });\r\n        return hovered;\r\n    }\r\n\r\n    /**\r\n     * Creates a RotationGizmo\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     * @param tessellation Amount of tessellation to be used when creating rotation circles\r\n     * @param useEulerRotation Use and update Euler angle instead of quaternion\r\n     * @param thickness display gizmo axis thickness\r\n     * @param gizmoManager Gizmo manager\r\n     * @param options More options\r\n     */\r\n    constructor(\r\n        gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer,\r\n        tessellation = 32,\r\n        useEulerRotation = false,\r\n        thickness: number = 1,\r\n        gizmoManager?: GizmoManager,\r\n        options?: RotationGizmoOptions\r\n    ) {\r\n        super(gizmoLayer);\r\n        const xColor = options && options.xOptions && options.xOptions.color ? options.xOptions.color : Color3.Red().scale(0.5);\r\n        const yColor = options && options.yOptions && options.yOptions.color ? options.yOptions.color : Color3.Green().scale(0.5);\r\n        const zColor = options && options.zOptions && options.zOptions.color ? options.zOptions.color : Color3.Blue().scale(0.5);\r\n        this.xGizmo = new PlaneRotationGizmo(new Vector3(1, 0, 0), xColor, gizmoLayer, tessellation, this, useEulerRotation, thickness);\r\n        this.yGizmo = new PlaneRotationGizmo(new Vector3(0, 1, 0), yColor, gizmoLayer, tessellation, this, useEulerRotation, thickness);\r\n        this.zGizmo = new PlaneRotationGizmo(new Vector3(0, 0, 1), zColor, gizmoLayer, tessellation, this, useEulerRotation, thickness);\r\n        // Relay drag events and set update scale\r\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\r\n            //must set updateScale on each gizmo, as setting it on root RotationGizmo doesnt prevent individual gizmos from updating\r\n            //currently updateScale is a property with no getter/setter, so no good way to override behavior at runtime, so we will at least set it on startup\r\n            if (options && options.updateScale != undefined) {\r\n                gizmo.updateScale = options.updateScale;\r\n            }\r\n            gizmo.dragBehavior.onDragStartObservable.add(() => {\r\n                this.onDragStartObservable.notifyObservers({});\r\n            });\r\n            gizmo.dragBehavior.onDragObservable.add(() => {\r\n                this.onDragObservable.notifyObservers({});\r\n            });\r\n            gizmo.dragBehavior.onDragEndObservable.add(() => {\r\n                this.onDragEndObservable.notifyObservers({});\r\n            });\r\n        });\r\n\r\n        this.attachedMesh = null;\r\n        this.attachedNode = null;\r\n\r\n        if (gizmoManager) {\r\n            gizmoManager.addToAxisCache(this._gizmoAxisCache);\r\n        } else {\r\n            // Only subscribe to pointer event if gizmoManager isnt\r\n            Gizmo.GizmoAxisPointerObserver(gizmoLayer, this._gizmoAxisCache);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\r\n     * NOTE: This is only possible for meshes with uniform scaling, as otherwise it's not possible to decompose the rotation\r\n     */\r\n    public set updateGizmoRotationToMatchAttachedMesh(value: boolean) {\r\n        if (this.xGizmo) {\r\n            this.xGizmo.updateGizmoRotationToMatchAttachedMesh = value;\r\n            this.yGizmo.updateGizmoRotationToMatchAttachedMesh = value;\r\n            this.zGizmo.updateGizmoRotationToMatchAttachedMesh = value;\r\n        }\r\n    }\r\n    public get updateGizmoRotationToMatchAttachedMesh() {\r\n        return this.xGizmo.updateGizmoRotationToMatchAttachedMesh;\r\n    }\r\n\r\n    public set updateGizmoPositionToMatchAttachedMesh(value: boolean) {\r\n        if (this.xGizmo) {\r\n            this.xGizmo.updateGizmoPositionToMatchAttachedMesh = value;\r\n            this.yGizmo.updateGizmoPositionToMatchAttachedMesh = value;\r\n            this.zGizmo.updateGizmoPositionToMatchAttachedMesh = value;\r\n        }\r\n    }\r\n    public get updateGizmoPositionToMatchAttachedMesh() {\r\n        return this.xGizmo.updateGizmoPositionToMatchAttachedMesh;\r\n    }\r\n\r\n    public set anchorPoint(value: GizmoAnchorPoint) {\r\n        this._anchorPoint = value;\r\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\r\n            gizmo.anchorPoint = value;\r\n        });\r\n    }\r\n    public get anchorPoint() {\r\n        return this._anchorPoint;\r\n    }\r\n\r\n    /**\r\n     * Set the coordinate system to use. By default it's local.\r\n     * But it's possible for a user to tweak so its local for translation and world for rotation.\r\n     * In that case, setting the coordinate system will change `updateGizmoRotationToMatchAttachedMesh` and `updateGizmoPositionToMatchAttachedMesh`\r\n     */\r\n    public set coordinatesMode(coordinatesMode: GizmoCoordinatesMode) {\r\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\r\n            gizmo.coordinatesMode = coordinatesMode;\r\n        });\r\n    }\r\n\r\n    public set updateScale(value: boolean) {\r\n        if (this.xGizmo) {\r\n            this.xGizmo.updateScale = value;\r\n            this.yGizmo.updateScale = value;\r\n            this.zGizmo.updateScale = value;\r\n        }\r\n    }\r\n    public get updateScale() {\r\n        return this.xGizmo.updateScale;\r\n    }\r\n    /**\r\n     * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)\r\n     */\r\n    public set snapDistance(value: number) {\r\n        if (this.xGizmo) {\r\n            this.xGizmo.snapDistance = value;\r\n            this.yGizmo.snapDistance = value;\r\n            this.zGizmo.snapDistance = value;\r\n        }\r\n    }\r\n    public get snapDistance() {\r\n        return this.xGizmo.snapDistance;\r\n    }\r\n\r\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\r\n    public set scaleRatio(value: number) {\r\n        if (this.xGizmo) {\r\n            this.xGizmo.scaleRatio = value;\r\n            this.yGizmo.scaleRatio = value;\r\n            this.zGizmo.scaleRatio = value;\r\n        }\r\n    }\r\n    public get scaleRatio() {\r\n        return this.xGizmo.scaleRatio;\r\n    }\r\n\r\n    /**\r\n     * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\r\n     * @param mesh Axis gizmo mesh\r\n     * @param cache Gizmo axis definition used for reactive gizmo UI\r\n     */\r\n    public addToAxisCache(mesh: Mesh, cache: GizmoAxisCache) {\r\n        this._gizmoAxisCache.set(mesh, cache);\r\n    }\r\n\r\n    /**\r\n     * Disposes of the gizmo\r\n     */\r\n    public dispose() {\r\n        this.xGizmo.dispose();\r\n        this.yGizmo.dispose();\r\n        this.zGizmo.dispose();\r\n        this.onDragStartObservable.clear();\r\n        this.onDragObservable.clear();\r\n        this.onDragEndObservable.clear();\r\n        this._observables.forEach((obs) => {\r\n            this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(obs);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * CustomMeshes are not supported by this gizmo\r\n     */\r\n    public setCustomMesh() {\r\n        Logger.Error(\r\n            \"Custom meshes are not supported on this gizmo, please set the custom meshes on the gizmos contained within this one (gizmo.xGizmo, gizmo.yGizmo, gizmo.zGizmo)\"\r\n        );\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}