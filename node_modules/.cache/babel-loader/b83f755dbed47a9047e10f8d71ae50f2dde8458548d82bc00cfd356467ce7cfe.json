{"ast":null,"code":"const defaultAttributeKeywordName = \"attribute\";\nconst defaultVaryingKeywordName = \"varying\";\n/** @internal */\nexport class ShaderCodeNode {\n  constructor() {\n    this.children = [];\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  isValid(preprocessors) {\n    return true;\n  }\n  process(preprocessors, options) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    let result = \"\";\n    if (this.line) {\n      let value = this.line;\n      const processor = options.processor;\n      if (processor) {\n        // This must be done before other replacements to avoid mistakenly changing something that was already changed.\n        if (processor.lineProcessor) {\n          value = processor.lineProcessor(value, options.isFragment, options.processingContext);\n        }\n        const attributeKeyword = (_b = (_a = options.processor) === null || _a === void 0 ? void 0 : _a.attributeKeywordName) !== null && _b !== void 0 ? _b : defaultAttributeKeywordName;\n        const varyingKeyword = options.isFragment && ((_c = options.processor) === null || _c === void 0 ? void 0 : _c.varyingFragmentKeywordName) ? (_d = options.processor) === null || _d === void 0 ? void 0 : _d.varyingFragmentKeywordName : !options.isFragment && ((_e = options.processor) === null || _e === void 0 ? void 0 : _e.varyingVertexKeywordName) ? (_f = options.processor) === null || _f === void 0 ? void 0 : _f.varyingVertexKeywordName : defaultVaryingKeywordName;\n        if (!options.isFragment && processor.attributeProcessor && this.line.startsWith(attributeKeyword)) {\n          value = processor.attributeProcessor(this.line, preprocessors, options.processingContext);\n        } else if (processor.varyingProcessor && (((_g = processor.varyingCheck) === null || _g === void 0 ? void 0 : _g.call(processor, this.line, options.isFragment)) || !processor.varyingCheck && this.line.startsWith(varyingKeyword))) {\n          value = processor.varyingProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\n        } else if (processor.uniformProcessor && processor.uniformRegexp && processor.uniformRegexp.test(this.line)) {\n          if (!options.lookForClosingBracketForUniformBuffer) {\n            value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\n          }\n        } else if (processor.uniformBufferProcessor && processor.uniformBufferRegexp && processor.uniformBufferRegexp.test(this.line)) {\n          if (!options.lookForClosingBracketForUniformBuffer) {\n            value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);\n            options.lookForClosingBracketForUniformBuffer = true;\n          }\n        } else if (processor.textureProcessor && processor.textureRegexp && processor.textureRegexp.test(this.line)) {\n          value = processor.textureProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\n        } else if ((processor.uniformProcessor || processor.uniformBufferProcessor) && this.line.startsWith(\"uniform\") && !options.lookForClosingBracketForUniformBuffer) {\n          const regex = /uniform\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/;\n          if (regex.test(this.line)) {\n            // uniform\n            if (processor.uniformProcessor) {\n              value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\n            }\n          } else {\n            // Uniform buffer\n            if (processor.uniformBufferProcessor) {\n              value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);\n              options.lookForClosingBracketForUniformBuffer = true;\n            }\n          }\n        }\n        if (options.lookForClosingBracketForUniformBuffer && this.line.indexOf(\"}\") !== -1) {\n          options.lookForClosingBracketForUniformBuffer = false;\n          if (processor.endOfUniformBufferProcessor) {\n            value = processor.endOfUniformBufferProcessor(this.line, options.isFragment, options.processingContext);\n          }\n        }\n      }\n      result += value + \"\\n\";\n    }\n    this.children.forEach(child => {\n      result += child.process(preprocessors, options);\n    });\n    if (this.additionalDefineKey) {\n      preprocessors[this.additionalDefineKey] = this.additionalDefineValue || \"true\";\n    }\n    return result;\n  }\n}","map":{"version":3,"names":["defaultAttributeKeywordName","defaultVaryingKeywordName","ShaderCodeNode","constructor","children","isValid","preprocessors","process","options","result","line","value","processor","lineProcessor","isFragment","processingContext","attributeKeyword","_b","_a","attributeKeywordName","varyingKeyword","_c","varyingFragmentKeywordName","_d","_e","varyingVertexKeywordName","_f","attributeProcessor","startsWith","varyingProcessor","_g","varyingCheck","call","uniformProcessor","uniformRegexp","test","lookForClosingBracketForUniformBuffer","uniformBufferProcessor","uniformBufferRegexp","textureProcessor","textureRegexp","regex","indexOf","endOfUniformBufferProcessor","forEach","child","additionalDefineKey","additionalDefineValue"],"sources":["../../../../../dev/core/src/Engines/Processors/shaderCodeNode.ts"],"sourcesContent":["import type { ProcessingOptions } from \"./shaderProcessingOptions\";\r\n\r\nconst defaultAttributeKeywordName = \"attribute\";\r\nconst defaultVaryingKeywordName = \"varying\";\r\n\r\n/** @internal */\r\nexport class ShaderCodeNode {\r\n    line: string;\r\n    children: ShaderCodeNode[] = [];\r\n    additionalDefineKey?: string;\r\n    additionalDefineValue?: string;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    isValid(preprocessors: { [key: string]: string }): boolean {\r\n        return true;\r\n    }\r\n\r\n    process(preprocessors: { [key: string]: string }, options: ProcessingOptions): string {\r\n        let result = \"\";\r\n        if (this.line) {\r\n            let value: string = this.line;\r\n            const processor = options.processor;\r\n            if (processor) {\r\n                // This must be done before other replacements to avoid mistakenly changing something that was already changed.\r\n                if (processor.lineProcessor) {\r\n                    value = processor.lineProcessor(value, options.isFragment, options.processingContext);\r\n                }\r\n\r\n                const attributeKeyword = options.processor?.attributeKeywordName ?? defaultAttributeKeywordName;\r\n                const varyingKeyword =\r\n                    options.isFragment && options.processor?.varyingFragmentKeywordName\r\n                        ? options.processor?.varyingFragmentKeywordName\r\n                        : !options.isFragment && options.processor?.varyingVertexKeywordName\r\n                        ? options.processor?.varyingVertexKeywordName\r\n                        : defaultVaryingKeywordName;\r\n\r\n                if (!options.isFragment && processor.attributeProcessor && this.line.startsWith(attributeKeyword)) {\r\n                    value = processor.attributeProcessor(this.line, preprocessors, options.processingContext);\r\n                } else if (\r\n                    processor.varyingProcessor &&\r\n                    (processor.varyingCheck?.(this.line, options.isFragment) || (!processor.varyingCheck && this.line.startsWith(varyingKeyword)))\r\n                ) {\r\n                    value = processor.varyingProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                } else if (processor.uniformProcessor && processor.uniformRegexp && processor.uniformRegexp.test(this.line)) {\r\n                    if (!options.lookForClosingBracketForUniformBuffer) {\r\n                        value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                    }\r\n                } else if (processor.uniformBufferProcessor && processor.uniformBufferRegexp && processor.uniformBufferRegexp.test(this.line)) {\r\n                    if (!options.lookForClosingBracketForUniformBuffer) {\r\n                        value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);\r\n                        options.lookForClosingBracketForUniformBuffer = true;\r\n                    }\r\n                } else if (processor.textureProcessor && processor.textureRegexp && processor.textureRegexp.test(this.line)) {\r\n                    value = processor.textureProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                } else if ((processor.uniformProcessor || processor.uniformBufferProcessor) && this.line.startsWith(\"uniform\") && !options.lookForClosingBracketForUniformBuffer) {\r\n                    const regex = /uniform\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/;\r\n\r\n                    if (regex.test(this.line)) {\r\n                        // uniform\r\n                        if (processor.uniformProcessor) {\r\n                            value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                        }\r\n                    } else {\r\n                        // Uniform buffer\r\n                        if (processor.uniformBufferProcessor) {\r\n                            value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);\r\n                            options.lookForClosingBracketForUniformBuffer = true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (options.lookForClosingBracketForUniformBuffer && this.line.indexOf(\"}\") !== -1) {\r\n                    options.lookForClosingBracketForUniformBuffer = false;\r\n                    if (processor.endOfUniformBufferProcessor) {\r\n                        value = processor.endOfUniformBufferProcessor(this.line, options.isFragment, options.processingContext);\r\n                    }\r\n                }\r\n            }\r\n\r\n            result += value + \"\\n\";\r\n        }\r\n\r\n        this.children.forEach((child) => {\r\n            result += child.process(preprocessors, options);\r\n        });\r\n\r\n        if (this.additionalDefineKey) {\r\n            preprocessors[this.additionalDefineKey] = this.additionalDefineValue || \"true\";\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}