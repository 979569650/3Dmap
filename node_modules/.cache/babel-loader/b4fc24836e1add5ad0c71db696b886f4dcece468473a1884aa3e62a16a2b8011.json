{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { PanoramaToCubeMapTools } from \"../../Misc/HighDynamicRange/panoramaToCubemap.js\";\nimport { BaseTexture } from \"./baseTexture.js\";\nimport { Texture } from \"./texture.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport \"../../Engines/Extensions/engine.rawTexture.js\";\nimport { LoadImage } from \"../../Misc/fileTools.js\";\n/**\n * This represents a texture coming from an equirectangular image supported by the web browser canvas.\n */\nexport class EquiRectangularCubeTexture extends BaseTexture {\n  /**\n   * Instantiates an EquiRectangularCubeTexture from the following parameters.\n   * @param url The location of the image\n   * @param scene The scene the texture will be used in\n   * @param size The cubemap desired size (the more it increases the longer the generation will be)\n   * @param noMipmap Forces to not generate the mipmap if true\n   * @param gammaSpace Specifies if the texture will be used in gamma or linear space\n   * (the PBR material requires those textures in linear space, but the standard material would require them in Gamma space)\n   * @param onLoad — defines a callback called when texture is loaded\n   * @param onError — defines a callback called if there is an error\n   */\n  constructor(url, scene, size, noMipmap = false, gammaSpace = true, onLoad = null, onError = null, supersample = false) {\n    super(scene);\n    this._onLoad = null;\n    this._onError = null;\n    if (!url) {\n      throw new Error(\"Image url is not set\");\n    }\n    this._coordinatesMode = Texture.CUBIC_MODE;\n    this.name = url;\n    this.url = url;\n    this._size = size;\n    this._supersample = supersample;\n    this._noMipmap = noMipmap;\n    this.gammaSpace = gammaSpace;\n    this._onLoad = onLoad;\n    this._onError = onError;\n    this.hasAlpha = false;\n    this.isCube = true;\n    this._texture = this._getFromCache(url, this._noMipmap, undefined, undefined, undefined, this.isCube);\n    if (!this._texture) {\n      if (!scene.useDelayedTextureLoading) {\n        this._loadImage(() => this._loadTexture(), this._onError);\n      } else {\n        this.delayLoadState = 4;\n      }\n    } else if (onLoad) {\n      if (this._texture.isReady) {\n        Tools.SetImmediate(() => onLoad());\n      } else {\n        this._texture.onLoadedObservable.add(onLoad);\n      }\n    }\n  }\n  /**\n   * Load the image data, by putting the image on a canvas and extracting its buffer.\n   * @param loadTextureCallback\n   * @param onError\n   */\n  _loadImage(loadTextureCallback, onError) {\n    const scene = this.getScene();\n    if (!scene) {\n      return;\n    }\n    // Create texture before loading\n    const texture = scene.getEngine().createRawCubeTexture(null, this._size, 4, scene.getEngine().getCaps().textureFloat ? 1 : 7, this._noMipmap, false, 3);\n    texture.generateMipMaps = !this._noMipmap;\n    scene.addPendingData(texture);\n    texture.url = this.url;\n    texture.isReady = false;\n    scene.getEngine()._internalTexturesCache.push(texture);\n    this._texture = texture;\n    const canvas = document.createElement(\"canvas\");\n    LoadImage(this.url, image => {\n      this._width = image.width;\n      this._height = image.height;\n      canvas.width = this._width;\n      canvas.height = this._height;\n      const ctx = canvas.getContext(\"2d\");\n      ctx.drawImage(image, 0, 0);\n      const imageData = ctx.getImageData(0, 0, image.width, image.height);\n      this._buffer = imageData.data.buffer;\n      canvas.remove();\n      loadTextureCallback();\n    }, (_, e) => {\n      scene.removePendingData(texture);\n      if (onError) {\n        onError(`${this.getClassName()} could not be loaded`, e);\n      }\n    }, scene ? scene.offlineProvider : null);\n  }\n  /**\n   * Convert the image buffer into a cubemap and create a CubeTexture.\n   */\n  _loadTexture() {\n    const scene = this.getScene();\n    const callback = () => {\n      const imageData = this._getFloat32ArrayFromArrayBuffer(this._buffer);\n      // Extract the raw linear data.\n      const data = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(imageData, this._width, this._height, this._size, this._supersample);\n      const results = [];\n      // Push each faces.\n      for (let i = 0; i < 6; i++) {\n        const dataFace = data[EquiRectangularCubeTexture._FacesMapping[i]];\n        results.push(dataFace);\n      }\n      return results;\n    };\n    if (!scene) {\n      return;\n    }\n    const faceDataArrays = callback();\n    const texture = this._texture;\n    scene.getEngine().updateRawCubeTexture(texture, faceDataArrays, texture.format, texture.type, texture.invertY);\n    texture.isReady = true;\n    scene.removePendingData(texture);\n    texture.onLoadedObservable.notifyObservers(texture);\n    texture.onLoadedObservable.clear();\n    if (this._onLoad) {\n      this._onLoad();\n    }\n  }\n  /**\n   * Convert the ArrayBuffer into a Float32Array and drop the transparency channel.\n   * @param buffer The ArrayBuffer that should be converted.\n   * @returns The buffer as Float32Array.\n   */\n  _getFloat32ArrayFromArrayBuffer(buffer) {\n    const dataView = new DataView(buffer);\n    const floatImageData = new Float32Array(buffer.byteLength * 3 / 4);\n    let k = 0;\n    for (let i = 0; i < buffer.byteLength; i++) {\n      // We drop the transparency channel, because we do not need/want it\n      if ((i + 1) % 4 !== 0) {\n        floatImageData[k++] = dataView.getUint8(i) / 255;\n      }\n    }\n    return floatImageData;\n  }\n  /**\n   * Get the current class name of the texture useful for serialization or dynamic coding.\n   * @returns \"EquiRectangularCubeTexture\"\n   */\n  getClassName() {\n    return \"EquiRectangularCubeTexture\";\n  }\n  /**\n   * Create a clone of the current EquiRectangularCubeTexture and return it.\n   * @returns A clone of the current EquiRectangularCubeTexture.\n   */\n  clone() {\n    const scene = this.getScene();\n    if (!scene) {\n      return this;\n    }\n    const newTexture = new EquiRectangularCubeTexture(this.url, scene, this._size, this._noMipmap, this.gammaSpace);\n    // Base texture\n    newTexture.level = this.level;\n    newTexture.wrapU = this.wrapU;\n    newTexture.wrapV = this.wrapV;\n    newTexture.coordinatesIndex = this.coordinatesIndex;\n    newTexture.coordinatesMode = this.coordinatesMode;\n    return newTexture;\n  }\n}\n/** The six faces of the cube. */\nEquiRectangularCubeTexture._FacesMapping = [\"right\", \"left\", \"up\", \"down\", \"front\", \"back\"];","map":{"version":3,"names":["PanoramaToCubeMapTools","BaseTexture","Texture","Tools","LoadImage","EquiRectangularCubeTexture","constructor","url","scene","size","noMipmap","gammaSpace","onLoad","onError","supersample","_onLoad","_onError","Error","_coordinatesMode","CUBIC_MODE","name","_size","_supersample","_noMipmap","hasAlpha","isCube","_texture","_getFromCache","undefined","useDelayedTextureLoading","_loadImage","_loadTexture","delayLoadState","isReady","SetImmediate","onLoadedObservable","add","loadTextureCallback","getScene","texture","getEngine","createRawCubeTexture","getCaps","textureFloat","generateMipMaps","addPendingData","_internalTexturesCache","push","canvas","document","createElement","image","_width","width","_height","height","ctx","getContext","drawImage","imageData","getImageData","_buffer","data","buffer","remove","_","e","removePendingData","getClassName","offlineProvider","callback","_getFloat32ArrayFromArrayBuffer","ConvertPanoramaToCubemap","results","i","dataFace","_FacesMapping","faceDataArrays","updateRawCubeTexture","format","type","invertY","notifyObservers","clear","dataView","DataView","floatImageData","Float32Array","byteLength","k","getUint8","clone","newTexture","level","wrapU","wrapV","coordinatesIndex","coordinatesMode"],"sources":["../../../../../dev/core/src/Materials/Textures/equiRectangularCubeTexture.ts"],"sourcesContent":["import { PanoramaToCubeMapTools } from \"../../Misc/HighDynamicRange/panoramaToCubemap\";\r\nimport { BaseTexture } from \"./baseTexture\";\r\nimport { Texture } from \"./texture\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { LoadImage } from \"../../Misc/fileTools\";\r\n\r\n/**\r\n * This represents a texture coming from an equirectangular image supported by the web browser canvas.\r\n */\r\nexport class EquiRectangularCubeTexture extends BaseTexture {\r\n    /** The six faces of the cube. */\r\n    private static _FacesMapping = [\"right\", \"left\", \"up\", \"down\", \"front\", \"back\"];\r\n\r\n    private _noMipmap: boolean;\r\n    private _onLoad: Nullable<() => void> = null;\r\n    private _onError: Nullable<() => void> = null;\r\n\r\n    /** The size of the cubemap. */\r\n    private _size: number;\r\n\r\n    /** Whether to supersample the input image */\r\n    private _supersample: boolean;\r\n\r\n    /** The buffer of the image. */\r\n    private _buffer: ArrayBuffer;\r\n\r\n    /** The width of the input image. */\r\n    private _width: number;\r\n\r\n    /** The height of the input image. */\r\n    private _height: number;\r\n\r\n    /** The URL to the image. */\r\n    public url: string;\r\n\r\n    /**\r\n     * Instantiates an EquiRectangularCubeTexture from the following parameters.\r\n     * @param url The location of the image\r\n     * @param scene The scene the texture will be used in\r\n     * @param size The cubemap desired size (the more it increases the longer the generation will be)\r\n     * @param noMipmap Forces to not generate the mipmap if true\r\n     * @param gammaSpace Specifies if the texture will be used in gamma or linear space\r\n     * (the PBR material requires those textures in linear space, but the standard material would require them in Gamma space)\r\n     * @param onLoad — defines a callback called when texture is loaded\r\n     * @param onError — defines a callback called if there is an error\r\n     */\r\n    constructor(\r\n        url: string,\r\n        scene: Scene,\r\n        size: number,\r\n        noMipmap: boolean = false,\r\n        gammaSpace: boolean = true,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        supersample = false\r\n    ) {\r\n        super(scene);\r\n\r\n        if (!url) {\r\n            throw new Error(\"Image url is not set\");\r\n        }\r\n\r\n        this._coordinatesMode = Texture.CUBIC_MODE;\r\n        this.name = url;\r\n        this.url = url;\r\n        this._size = size;\r\n        this._supersample = supersample;\r\n        this._noMipmap = noMipmap;\r\n        this.gammaSpace = gammaSpace;\r\n        this._onLoad = onLoad;\r\n        this._onError = onError;\r\n\r\n        this.hasAlpha = false;\r\n        this.isCube = true;\r\n\r\n        this._texture = this._getFromCache(url, this._noMipmap, undefined, undefined, undefined, this.isCube);\r\n\r\n        if (!this._texture) {\r\n            if (!scene.useDelayedTextureLoading) {\r\n                this._loadImage(() => this._loadTexture(), this._onError);\r\n            } else {\r\n                this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n            }\r\n        } else if (onLoad) {\r\n            if (this._texture.isReady) {\r\n                Tools.SetImmediate(() => onLoad());\r\n            } else {\r\n                this._texture.onLoadedObservable.add(onLoad);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load the image data, by putting the image on a canvas and extracting its buffer.\r\n     * @param loadTextureCallback\r\n     * @param onError\r\n     */\r\n    private _loadImage(loadTextureCallback: () => void, onError: Nullable<(message?: string, exception?: any) => void>): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        // Create texture before loading\r\n        const texture = scene\r\n            .getEngine()\r\n            .createRawCubeTexture(\r\n                null,\r\n                this._size,\r\n                Constants.TEXTUREFORMAT_RGB,\r\n                scene.getEngine().getCaps().textureFloat ? Constants.TEXTURETYPE_FLOAT : Constants.TEXTURETYPE_UNSIGNED_INTEGER,\r\n                this._noMipmap,\r\n                false,\r\n                Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n            );\r\n        texture.generateMipMaps = !this._noMipmap;\r\n        scene.addPendingData(texture);\r\n        texture.url = this.url;\r\n        texture.isReady = false;\r\n        scene.getEngine()._internalTexturesCache.push(texture);\r\n        this._texture = texture;\r\n\r\n        const canvas = document.createElement(\"canvas\");\r\n        LoadImage(\r\n            this.url,\r\n            (image) => {\r\n                this._width = image.width;\r\n                this._height = image.height;\r\n                canvas.width = this._width;\r\n                canvas.height = this._height;\r\n\r\n                const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n                ctx.drawImage(image, 0, 0);\r\n\r\n                const imageData = ctx.getImageData(0, 0, image.width, image.height);\r\n                this._buffer = imageData.data.buffer as ArrayBuffer;\r\n\r\n                canvas.remove();\r\n                loadTextureCallback();\r\n            },\r\n            (_, e) => {\r\n                scene.removePendingData(texture);\r\n                if (onError) {\r\n                    onError(`${this.getClassName()} could not be loaded`, e);\r\n                }\r\n            },\r\n            scene ? scene.offlineProvider : null\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Convert the image buffer into a cubemap and create a CubeTexture.\r\n     */\r\n    private _loadTexture(): void {\r\n        const scene = this.getScene();\r\n        const callback = (): ArrayBufferView[] => {\r\n            const imageData = this._getFloat32ArrayFromArrayBuffer(this._buffer);\r\n\r\n            // Extract the raw linear data.\r\n            const data = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(imageData, this._width, this._height, this._size, this._supersample);\r\n\r\n            const results = [];\r\n\r\n            // Push each faces.\r\n            for (let i = 0; i < 6; i++) {\r\n                const dataFace = (data as any)[EquiRectangularCubeTexture._FacesMapping[i]];\r\n                results.push(dataFace);\r\n            }\r\n\r\n            return results;\r\n        };\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        const faceDataArrays = callback();\r\n\r\n        const texture = this._texture!;\r\n        scene.getEngine().updateRawCubeTexture(texture, faceDataArrays, texture.format, texture.type, texture.invertY);\r\n        texture.isReady = true;\r\n        scene.removePendingData(texture);\r\n\r\n        texture.onLoadedObservable.notifyObservers(texture);\r\n        texture.onLoadedObservable.clear();\r\n\r\n        if (this._onLoad) {\r\n            this._onLoad();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert the ArrayBuffer into a Float32Array and drop the transparency channel.\r\n     * @param buffer The ArrayBuffer that should be converted.\r\n     * @returns The buffer as Float32Array.\r\n     */\r\n    private _getFloat32ArrayFromArrayBuffer(buffer: ArrayBuffer): Float32Array {\r\n        const dataView = new DataView(buffer);\r\n        const floatImageData = new Float32Array((buffer.byteLength * 3) / 4);\r\n\r\n        let k = 0;\r\n        for (let i = 0; i < buffer.byteLength; i++) {\r\n            // We drop the transparency channel, because we do not need/want it\r\n            if ((i + 1) % 4 !== 0) {\r\n                floatImageData[k++] = dataView.getUint8(i) / 255;\r\n            }\r\n        }\r\n\r\n        return floatImageData;\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"EquiRectangularCubeTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"EquiRectangularCubeTexture\";\r\n    }\r\n\r\n    /**\r\n     * Create a clone of the current EquiRectangularCubeTexture and return it.\r\n     * @returns A clone of the current EquiRectangularCubeTexture.\r\n     */\r\n    public clone(): EquiRectangularCubeTexture {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n\r\n        const newTexture = new EquiRectangularCubeTexture(this.url, scene, this._size, this._noMipmap, this.gammaSpace);\r\n\r\n        // Base texture\r\n        newTexture.level = this.level;\r\n        newTexture.wrapU = this.wrapU;\r\n        newTexture.wrapV = this.wrapV;\r\n        newTexture.coordinatesIndex = this.coordinatesIndex;\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n\r\n        return newTexture;\r\n    }\r\n}\r\n"],"mappings":";;;;AAAA,SAASA,sBAAsB,QAAQ,kDAAgD;AACvF,SAASC,WAAW,QAAQ,kBAAgB;AAC5C,SAASC,OAAO,QAAQ,cAAY;AAGpC,SAASC,KAAK,QAAQ,qBAAmB;AACzC,OAAO,+CAA6C;AAEpD,SAASC,SAAS,QAAQ,yBAAuB;AAEjD;;;AAGA,OAAM,MAAOC,0BAA2B,SAAQJ,WAAW;EA0BvD;;;;;;;;;;;EAWAK,YACIC,GAAW,EACXC,KAAY,EACZC,IAAY,EACZC,QAAA,GAAoB,KAAK,EACzBC,UAAA,GAAsB,IAAI,EAC1BC,MAAA,GAA+B,IAAI,EACnCC,OAAA,GAAiE,IAAI,EACrEC,WAAW,GAAG,KAAK;IAEnB,KAAK,CAACN,KAAK,CAAC;IA1CR,KAAAO,OAAO,GAAyB,IAAI;IACpC,KAAAC,QAAQ,GAAyB,IAAI;IA2CzC,IAAI,CAACT,GAAG,EAAE;MACN,MAAM,IAAIU,KAAK,CAAC,sBAAsB,CAAC;;IAG3C,IAAI,CAACC,gBAAgB,GAAGhB,OAAO,CAACiB,UAAU;IAC1C,IAAI,CAACC,IAAI,GAAGb,GAAG;IACf,IAAI,CAACA,GAAG,GAAGA,GAAG;IACd,IAAI,CAACc,KAAK,GAAGZ,IAAI;IACjB,IAAI,CAACa,YAAY,GAAGR,WAAW;IAC/B,IAAI,CAACS,SAAS,GAAGb,QAAQ;IACzB,IAAI,CAACC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACI,OAAO,GAAGH,MAAM;IACrB,IAAI,CAACI,QAAQ,GAAGH,OAAO;IAEvB,IAAI,CAACW,QAAQ,GAAG,KAAK;IACrB,IAAI,CAACC,MAAM,GAAG,IAAI;IAElB,IAAI,CAACC,QAAQ,GAAG,IAAI,CAACC,aAAa,CAACpB,GAAG,EAAE,IAAI,CAACgB,SAAS,EAAEK,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAE,IAAI,CAACH,MAAM,CAAC;IAErG,IAAI,CAAC,IAAI,CAACC,QAAQ,EAAE;MAChB,IAAI,CAAClB,KAAK,CAACqB,wBAAwB,EAAE;QACjC,IAAI,CAACC,UAAU,CAAC,MAAM,IAAI,CAACC,YAAY,EAAE,EAAE,IAAI,CAACf,QAAQ,CAAC;OAC5D,MAAM;QACH,IAAI,CAACgB,cAAc,GAAG;;KAE7B,MAAM,IAAIpB,MAAM,EAAE;MACf,IAAI,IAAI,CAACc,QAAQ,CAACO,OAAO,EAAE;QACvB9B,KAAK,CAAC+B,YAAY,CAAC,MAAMtB,MAAM,EAAE,CAAC;OACrC,MAAM;QACH,IAAI,CAACc,QAAQ,CAACS,kBAAkB,CAACC,GAAG,CAACxB,MAAM,CAAC;;;EAGxD;EAEA;;;;;EAKQkB,UAAUA,CAACO,mBAA+B,EAAExB,OAA8D;IAC9G,MAAML,KAAK,GAAG,IAAI,CAAC8B,QAAQ,EAAE;IAC7B,IAAI,CAAC9B,KAAK,EAAE;MACR;;IAGJ;IACA,MAAM+B,OAAO,GAAG/B,KAAK,CAChBgC,SAAS,EAAE,CACXC,oBAAoB,CACjB,IAAI,EACJ,IAAI,CAACpB,KAAK,EACV,GAAAb,KAAA,CAASgC,SAAC,GAAAE,OAAiB,CAC3B,EAAAC,YAAM,GAAW,CAAC,UAAU,CAAApB,SAAA,EAAY,KAAG;IAKnDgB,OAAO,CAACK,eAAe,GAAG,CAAC,IAAI,CAACrB,SAAS;IACzCf,KAAK,CAACqC,cAAc,CAACN,OAAO,CAAC;IAC7BA,OAAO,CAAChC,GAAG,GAAG,IAAI,CAACA,GAAG;IACtBgC,OAAO,CAACN,OAAO,GAAG,KAAK;IACvBzB,KAAK,CAACgC,SAAS,EAAE,CAACM,sBAAsB,CAACC,IAAI,CAACR,OAAO,CAAC;IACtD,IAAI,CAACb,QAAQ,GAAGa,OAAO;IAEvB,MAAMS,MAAM,GAAGC,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;IAC/C9C,SAAS,CACL,IAAI,CAACG,GAAG,EACP4C,KAAK,IAAI;MACN,IAAI,CAACC,MAAM,GAAGD,KAAK,CAACE,KAAK;MACzB,IAAI,CAACC,OAAO,GAAGH,KAAK,CAACI,MAAM;MAC3BP,MAAM,CAACK,KAAK,GAAG,IAAI,CAACD,MAAM;MAC1BJ,MAAM,CAACO,MAAM,GAAG,IAAI,CAACD,OAAO;MAE5B,MAAME,GAAG,GAAGR,MAAM,CAACS,UAAU,CAAC,IAAI,CAA6B;MAC/DD,GAAG,CAACE,SAAS,CAACP,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;MAE1B,MAAMQ,SAAS,GAAGH,GAAG,CAACI,YAAY,CAAC,CAAC,EAAE,CAAC,EAAET,KAAK,CAACE,KAAK,EAAEF,KAAK,CAACI,MAAM,CAAC;MACnE,IAAI,CAACM,OAAO,GAAGF,SAAS,CAACG,IAAI,CAACC,MAAqB;MAEnDf,MAAM,CAACgB,MAAM,EAAE;MACf3B,mBAAmB,EAAE;IACzB,CAAC,EACD,CAAC4B,CAAC,EAAEC,CAAC,KAAI;MACL1D,KAAK,CAAC2D,iBAAiB,CAAC5B,OAAO,CAAC;MAChC,IAAI1B,OAAO,EAAE;QACTA,OAAO,CAAC,GAAG,IAAI,CAACuD,YAAY,EAAE,sBAAsB,EAAEF,CAAC,CAAC;;IAEhE,CAAC,EACD1D,KAAK,GAAGA,KAAK,CAAC6D,eAAe,GAAG,IAAI,CACvC;EACL;EAEA;;;EAGQtC,YAAYA,CAAA;IAChB,MAAMvB,KAAK,GAAG,IAAI,CAAC8B,QAAQ,EAAE;IAC7B,MAAMgC,QAAQ,GAAGA,CAAA,KAAwB;MACrC,MAAMX,SAAS,GAAG,IAAI,CAACY,+BAA+B,CAAC,IAAI,CAACV,OAAO,CAAC;MAEpE;MACA,MAAMC,IAAI,GAAG9D,sBAAsB,CAACwE,wBAAwB,CAACb,SAAS,EAAE,IAAI,CAACP,MAAM,EAAE,IAAI,CAACE,OAAO,EAAE,IAAI,CAACjC,KAAK,EAAE,IAAI,CAACC,YAAY,CAAC;MAEjI,MAAMmD,OAAO,GAAG,EAAE;MAElB;MACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QACxB,MAAMC,QAAQ,GAAIb,IAAY,CAACzD,0BAA0B,CAACuE,aAAa,CAACF,CAAC,CAAC,CAAC;QAC3ED,OAAO,CAAC1B,IAAI,CAAC4B,QAAQ,CAAC;;MAG1B,OAAOF,OAAO;IAClB,CAAC;IAED,IAAI,CAACjE,KAAK,EAAE;MACR;;IAEJ,MAAMqE,cAAc,GAAGP,QAAQ,EAAE;IAEjC,MAAM/B,OAAO,GAAG,IAAI,CAACb,QAAS;IAC9BlB,KAAK,CAACgC,SAAS,EAAE,CAACsC,oBAAoB,CAACvC,OAAO,EAAEsC,cAAc,EAAEtC,OAAO,CAACwC,MAAM,EAAExC,OAAO,CAACyC,IAAI,EAAEzC,OAAO,CAAC0C,OAAO,CAAC;IAC9G1C,OAAO,CAACN,OAAO,GAAG,IAAI;IACtBzB,KAAK,CAAC2D,iBAAiB,CAAC5B,OAAO,CAAC;IAEhCA,OAAO,CAACJ,kBAAkB,CAAC+C,eAAe,CAAC3C,OAAO,CAAC;IACnDA,OAAO,CAACJ,kBAAkB,CAACgD,KAAK,EAAE;IAElC,IAAI,IAAI,CAACpE,OAAO,EAAE;MACd,IAAI,CAACA,OAAO,EAAE;;EAEtB;EAEA;;;;;EAKQwD,+BAA+BA,CAACR,MAAmB;IACvD,MAAMqB,QAAQ,GAAG,IAAIC,QAAQ,CAACtB,MAAM,CAAC;IACrC,MAAMuB,cAAc,GAAG,IAAIC,YAAY,CAAExB,MAAM,CAACyB,UAAU,GAAG,CAAC,GAAI,CAAC,CAAC;IAEpE,IAAIC,CAAC,GAAG,CAAC;IACT,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,MAAM,CAACyB,UAAU,EAAEd,CAAC,EAAE,EAAE;MACxC;MACA,IAAI,CAACA,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;QACnBY,cAAc,CAACG,CAAC,EAAE,CAAC,GAAGL,QAAQ,CAACM,QAAQ,CAAChB,CAAC,CAAC,GAAG,GAAG;;;IAIxD,OAAOY,cAAc;EACzB;EAEA;;;;EAIOlB,YAAYA,CAAA;IACf,OAAO,4BAA4B;EACvC;EAEA;;;;EAIOuB,KAAKA,CAAA;IACR,MAAMnF,KAAK,GAAG,IAAI,CAAC8B,QAAQ,EAAE;IAC7B,IAAI,CAAC9B,KAAK,EAAE;MACR,OAAO,IAAI;;IAGf,MAAMoF,UAAU,GAAG,IAAIvF,0BAA0B,CAAC,IAAI,CAACE,GAAG,EAAEC,KAAK,EAAE,IAAI,CAACa,KAAK,EAAE,IAAI,CAACE,SAAS,EAAE,IAAI,CAACZ,UAAU,CAAC;IAE/G;IACAiF,UAAU,CAACC,KAAK,GAAG,IAAI,CAACA,KAAK;IAC7BD,UAAU,CAACE,KAAK,GAAG,IAAI,CAACA,KAAK;IAC7BF,UAAU,CAACG,KAAK,GAAG,IAAI,CAACA,KAAK;IAC7BH,UAAU,CAACI,gBAAgB,GAAG,IAAI,CAACA,gBAAgB;IACnDJ,UAAU,CAACK,eAAe,GAAG,IAAI,CAACA,eAAe;IAEjD,OAAOL,UAAU;EACrB;;AApOA;AACevF,0BAAA,CAAAuE,aAAa,GAAG,CAAC,OAAO,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}