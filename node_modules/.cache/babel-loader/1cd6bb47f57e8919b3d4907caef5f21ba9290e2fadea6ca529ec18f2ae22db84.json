{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"./Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets.js\";\nimport { Observable } from \"../../Misc/observable.js\";\n/**\n * Enum used to define the compatibility state between two connection points\n */\nexport var NodeMaterialConnectionPointCompatibilityStates;\n(function (NodeMaterialConnectionPointCompatibilityStates) {\n  /** Points are compatibles */\n  NodeMaterialConnectionPointCompatibilityStates[NodeMaterialConnectionPointCompatibilityStates[\"Compatible\"] = 0] = \"Compatible\";\n  /** Points are incompatible because of their types */\n  NodeMaterialConnectionPointCompatibilityStates[NodeMaterialConnectionPointCompatibilityStates[\"TypeIncompatible\"] = 1] = \"TypeIncompatible\";\n  /** Points are incompatible because of their targets (vertex vs fragment) */\n  NodeMaterialConnectionPointCompatibilityStates[NodeMaterialConnectionPointCompatibilityStates[\"TargetIncompatible\"] = 2] = \"TargetIncompatible\";\n  /** Points are incompatible because they are in the same hierarchy **/\n  NodeMaterialConnectionPointCompatibilityStates[NodeMaterialConnectionPointCompatibilityStates[\"HierarchyIssue\"] = 3] = \"HierarchyIssue\";\n})(NodeMaterialConnectionPointCompatibilityStates || (NodeMaterialConnectionPointCompatibilityStates = {}));\n/**\n * Defines the direction of a connection point\n */\nexport var NodeMaterialConnectionPointDirection;\n(function (NodeMaterialConnectionPointDirection) {\n  /** Input */\n  NodeMaterialConnectionPointDirection[NodeMaterialConnectionPointDirection[\"Input\"] = 0] = \"Input\";\n  /** Output */\n  NodeMaterialConnectionPointDirection[NodeMaterialConnectionPointDirection[\"Output\"] = 1] = \"Output\";\n})(NodeMaterialConnectionPointDirection || (NodeMaterialConnectionPointDirection = {}));\n/**\n * Defines a connection point for a block\n */\nexport class NodeMaterialConnectionPoint {\n  /**\n   * Checks if two types are equivalent\n   * @param type1 type 1 to check\n   * @param type2 type 2 to check\n   * @returns true if both types are equivalent, else false\n   */\n  static AreEquivalentTypes(type1, type2) {\n    switch (type1) {\n      case NodeMaterialBlockConnectionPointTypes.Vector3:\n        {\n          if (type2 === NodeMaterialBlockConnectionPointTypes.Color3) {\n            return true;\n          }\n          break;\n        }\n      case NodeMaterialBlockConnectionPointTypes.Vector4:\n        {\n          if (type2 === NodeMaterialBlockConnectionPointTypes.Color4) {\n            return true;\n          }\n          break;\n        }\n      case NodeMaterialBlockConnectionPointTypes.Color3:\n        {\n          if (type2 === NodeMaterialBlockConnectionPointTypes.Vector3) {\n            return true;\n          }\n          break;\n        }\n      case NodeMaterialBlockConnectionPointTypes.Color4:\n        {\n          if (type2 === NodeMaterialBlockConnectionPointTypes.Vector4) {\n            return true;\n          }\n          break;\n        }\n    }\n    return false;\n  }\n  /** Gets the direction of the point */\n  get direction() {\n    return this._direction;\n  }\n  /**\n   * Gets or sets the associated variable name in the shader\n   */\n  get associatedVariableName() {\n    if (this._ownerBlock.isInput) {\n      return this._ownerBlock.associatedVariableName;\n    }\n    if ((!this._enforceAssociatedVariableName || !this._associatedVariableName) && this._connectedPoint) {\n      return this._connectedPoint.associatedVariableName;\n    }\n    return this._associatedVariableName;\n  }\n  set associatedVariableName(value) {\n    this._associatedVariableName = value;\n  }\n  /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */\n  get innerType() {\n    if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {\n      return this.type;\n    }\n    return this._type;\n  }\n  /**\n   * Gets or sets the connection point type (default is float)\n   */\n  get type() {\n    if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\n      if (this._ownerBlock.isInput) {\n        return this._ownerBlock.type;\n      }\n      if (this._connectedPoint) {\n        return this._connectedPoint.type;\n      }\n      if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {\n        return this._linkedConnectionSource.type;\n      }\n    }\n    if (this._type === NodeMaterialBlockConnectionPointTypes.BasedOnInput) {\n      if (this._typeConnectionSource) {\n        if (!this._typeConnectionSource.isConnected && this._defaultConnectionPointType) {\n          return this._defaultConnectionPointType;\n        }\n        return this._typeConnectionSource.type;\n      } else if (this._defaultConnectionPointType) {\n        return this._defaultConnectionPointType;\n      }\n    }\n    return this._type;\n  }\n  set type(value) {\n    this._type = value;\n  }\n  /** Gets or sets the target of that connection point */\n  get target() {\n    if (!this._prioritizeVertex || !this._ownerBlock) {\n      return this._target;\n    }\n    if (this._target !== NodeMaterialBlockTargets.VertexAndFragment) {\n      return this._target;\n    }\n    if (this._ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n      return NodeMaterialBlockTargets.Fragment;\n    }\n    return NodeMaterialBlockTargets.Vertex;\n  }\n  set target(value) {\n    this._target = value;\n  }\n  /**\n   * Gets a boolean indicating that the current point is connected to another NodeMaterialBlock\n   */\n  get isConnected() {\n    return this.connectedPoint !== null || this.hasEndpoints;\n  }\n  /**\n   * Gets a boolean indicating that the current point is connected to an input block\n   */\n  get isConnectedToInputBlock() {\n    return this.connectedPoint !== null && this.connectedPoint.ownerBlock.isInput;\n  }\n  /**\n   * Gets a the connected input block (if any)\n   */\n  get connectInputBlock() {\n    if (!this.isConnectedToInputBlock) {\n      return null;\n    }\n    return this.connectedPoint.ownerBlock;\n  }\n  /** Get the other side of the connection (if any) */\n  get connectedPoint() {\n    return this._connectedPoint;\n  }\n  /** Get the block that owns this connection point */\n  get ownerBlock() {\n    return this._ownerBlock;\n  }\n  /** Get the block connected on the other side of this connection (if any) */\n  get sourceBlock() {\n    if (!this._connectedPoint) {\n      return null;\n    }\n    return this._connectedPoint.ownerBlock;\n  }\n  /** Get the block connected on the endpoints of this connection (if any) */\n  get connectedBlocks() {\n    if (this._endpoints.length === 0) {\n      return [];\n    }\n    return this._endpoints.map(e => e.ownerBlock);\n  }\n  /** Gets the list of connected endpoints */\n  get endpoints() {\n    return this._endpoints;\n  }\n  /** Gets a boolean indicating if that output point is connected to at least one input */\n  get hasEndpoints() {\n    return this._endpoints && this._endpoints.length > 0;\n  }\n  /** Gets a boolean indicating that this connection has a path to the vertex output*/\n  get isDirectlyConnectedToVertexOutput() {\n    if (!this.hasEndpoints) {\n      return false;\n    }\n    for (const endpoint of this._endpoints) {\n      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {\n        return true;\n      }\n      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\n        if (endpoint.ownerBlock.outputs.some(o => o.isDirectlyConnectedToVertexOutput)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /** Gets a boolean indicating that this connection will be used in the vertex shader */\n  get isConnectedInVertexShader() {\n    if (this.target === NodeMaterialBlockTargets.Vertex) {\n      return true;\n    }\n    if (!this.hasEndpoints) {\n      return false;\n    }\n    for (const endpoint of this._endpoints) {\n      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {\n        return true;\n      }\n      if (endpoint.target === NodeMaterialBlockTargets.Vertex) {\n        return true;\n      }\n      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\n        if (endpoint.ownerBlock.outputs.some(o => o.isConnectedInVertexShader)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /** Gets a boolean indicating that this connection will be used in the fragment shader */\n  get isConnectedInFragmentShader() {\n    if (this.target === NodeMaterialBlockTargets.Fragment) {\n      return true;\n    }\n    if (!this.hasEndpoints) {\n      return false;\n    }\n    for (const endpoint of this._endpoints) {\n      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n        return true;\n      }\n      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\n        if (endpoint.ownerBlock.isConnectedInFragmentShader()) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Creates a block suitable to be used as an input for this input point.\n   * If null is returned, a block based on the point type will be created.\n   * @returns The returned string parameter is the name of the output point of NodeMaterialBlock (first parameter of the returned array) that can be connected to the input\n   */\n  createCustomInputBlock() {\n    return null;\n  }\n  /**\n   * Creates a new connection point\n   * @param name defines the connection point name\n   * @param ownerBlock defines the block hosting this connection point\n   * @param direction defines the direction of the connection point\n   */\n  constructor(name, ownerBlock, direction) {\n    /** @internal */\n    this._connectedPoint = null;\n    this._endpoints = new Array();\n    /** @internal */\n    this._typeConnectionSource = null;\n    /** @internal */\n    this._defaultConnectionPointType = null;\n    /** @internal */\n    this._linkedConnectionSource = null;\n    /** @internal */\n    this._acceptedConnectionPointType = null;\n    this._type = NodeMaterialBlockConnectionPointTypes.Float;\n    /** @internal */\n    this._enforceAssociatedVariableName = false;\n    /** Indicates that this connection point needs dual validation before being connected to another point */\n    this.needDualDirectionValidation = false;\n    /**\n     * Gets or sets the additional types supported by this connection point\n     */\n    this.acceptedConnectionPointTypes = new Array();\n    /**\n     * Gets or sets the additional types excluded by this connection point\n     */\n    this.excludedConnectionPointTypes = new Array();\n    /**\n     * Observable triggered when this point is connected\n     */\n    this.onConnectionObservable = new Observable();\n    /**\n     * Gets or sets a boolean indicating that this connection point is exposed on a frame\n     */\n    this.isExposedOnFrame = false;\n    /**\n     * Gets or sets number indicating the position that the port is exposed to on a frame\n     */\n    this.exposedPortPosition = -1;\n    /** @internal */\n    this._prioritizeVertex = false;\n    this._target = NodeMaterialBlockTargets.VertexAndFragment;\n    this._ownerBlock = ownerBlock;\n    this.name = name;\n    this._direction = direction;\n  }\n  /**\n   * Gets the current class name e.g. \"NodeMaterialConnectionPoint\"\n   * @returns the class name\n   */\n  getClassName() {\n    return \"NodeMaterialConnectionPoint\";\n  }\n  /**\n   * Gets a boolean indicating if the current point can be connected to another point\n   * @param connectionPoint defines the other connection point\n   * @returns a boolean\n   */\n  canConnectTo(connectionPoint) {\n    return this.checkCompatibilityState(connectionPoint) === NodeMaterialConnectionPointCompatibilityStates.Compatible;\n  }\n  /**\n   * Gets a number indicating if the current point can be connected to another point\n   * @param connectionPoint defines the other connection point\n   * @returns a number defining the compatibility state\n   */\n  checkCompatibilityState(connectionPoint) {\n    const ownerBlock = this._ownerBlock;\n    const otherBlock = connectionPoint.ownerBlock;\n    if (ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n      // Let's check we are not going reverse\n      if (otherBlock.target === NodeMaterialBlockTargets.Vertex) {\n        return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;\n      }\n      for (const output of otherBlock.outputs) {\n        if (output.ownerBlock.target != NodeMaterialBlockTargets.Neutral && output.isConnectedInVertexShader) {\n          return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;\n        }\n      }\n    }\n    if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeMaterialBlockConnectionPointTypes.AutoDetect) {\n      // Equivalents\n      if (NodeMaterialConnectionPoint.AreEquivalentTypes(this.type, connectionPoint.type)) {\n        return NodeMaterialConnectionPointCompatibilityStates.Compatible;\n      }\n      // Accepted types\n      if (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1 || connectionPoint._acceptedConnectionPointType && NodeMaterialConnectionPoint.AreEquivalentTypes(connectionPoint._acceptedConnectionPointType.type, this.type)) {\n        return NodeMaterialConnectionPointCompatibilityStates.Compatible;\n      } else {\n        return NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;\n      }\n    }\n    // Excluded\n    if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {\n      return NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;\n    }\n    // Check hierarchy\n    let targetBlock = otherBlock;\n    let sourceBlock = ownerBlock;\n    if (this.direction === NodeMaterialConnectionPointDirection.Input) {\n      targetBlock = ownerBlock;\n      sourceBlock = otherBlock;\n    }\n    if (targetBlock.isAnAncestorOf(sourceBlock)) {\n      return NodeMaterialConnectionPointCompatibilityStates.HierarchyIssue;\n    }\n    return NodeMaterialConnectionPointCompatibilityStates.Compatible;\n  }\n  /**\n   * Connect this point to another connection point\n   * @param connectionPoint defines the other connection point\n   * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)\n   * @returns the current connection point\n   */\n  connectTo(connectionPoint, ignoreConstraints = false) {\n    if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {\n      throw \"Cannot connect these two connectors.\";\n    }\n    this._endpoints.push(connectionPoint);\n    connectionPoint._connectedPoint = this;\n    this._enforceAssociatedVariableName = false;\n    this.onConnectionObservable.notifyObservers(connectionPoint);\n    connectionPoint.onConnectionObservable.notifyObservers(this);\n    return this;\n  }\n  /**\n   * Disconnect this point from one of his endpoint\n   * @param endpoint defines the other connection point\n   * @returns the current connection point\n   */\n  disconnectFrom(endpoint) {\n    const index = this._endpoints.indexOf(endpoint);\n    if (index === -1) {\n      return this;\n    }\n    this._endpoints.splice(index, 1);\n    endpoint._connectedPoint = null;\n    this._enforceAssociatedVariableName = false;\n    endpoint._enforceAssociatedVariableName = false;\n    return this;\n  }\n  /**\n   * Fill the list of excluded connection point types with all types other than those passed in the parameter\n   * @param mask Types (ORed values of NodeMaterialBlockConnectionPointTypes) that are allowed, and thus will not be pushed to the excluded list\n   */\n  addExcludedConnectionPointFromAllowedTypes(mask) {\n    let bitmask = 1;\n    while (bitmask < NodeMaterialBlockConnectionPointTypes.All) {\n      if (!(mask & bitmask)) {\n        this.excludedConnectionPointTypes.push(bitmask);\n      }\n      bitmask = bitmask << 1;\n    }\n  }\n  /**\n   * Serializes this point in a JSON representation\n   * @param isInput defines if the connection point is an input (default is true)\n   * @returns the serialized point object\n   */\n  serialize(isInput = true) {\n    const serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.displayName = this.displayName;\n    if (isInput && this.connectedPoint) {\n      serializationObject.inputName = this.name;\n      serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;\n      serializationObject.targetConnectionName = this.connectedPoint.name;\n      serializationObject.isExposedOnFrame = true;\n      serializationObject.exposedPortPosition = this.exposedPortPosition;\n    }\n    if (this.isExposedOnFrame || this.exposedPortPosition >= 0) {\n      serializationObject.isExposedOnFrame = true;\n      serializationObject.exposedPortPosition = this.exposedPortPosition;\n    }\n    return serializationObject;\n  }\n  /**\n   * Release resources\n   */\n  dispose() {\n    this.onConnectionObservable.clear();\n  }\n}","map":{"version":3,"names":["NodeMaterialBlockConnectionPointTypes","NodeMaterialBlockTargets","Observable","NodeMaterialConnectionPointCompatibilityStates","NodeMaterialConnectionPointDirection","NodeMaterialConnectionPoint","AreEquivalentTypes","type1","type2","Vector3","Color3","Vector4","Color4","direction","_direction","associatedVariableName","_ownerBlock","isInput","_enforceAssociatedVariableName","_associatedVariableName","_connectedPoint","value","innerType","_linkedConnectionSource","isConnected","type","_type","AutoDetect","BasedOnInput","_typeConnectionSource","_defaultConnectionPointType","target","_prioritizeVertex","_target","VertexAndFragment","Fragment","Vertex","connectedPoint","hasEndpoints","isConnectedToInputBlock","ownerBlock","connectInputBlock","sourceBlock","connectedBlocks","_endpoints","length","map","e","endpoints","isDirectlyConnectedToVertexOutput","endpoint","Neutral","outputs","some","o","isConnectedInVertexShader","isConnectedInFragmentShader","createCustomInputBlock","constructor","name","Array","_acceptedConnectionPointType","Float","needDualDirectionValidation","acceptedConnectionPointTypes","excludedConnectionPointTypes","onConnectionObservable","isExposedOnFrame","exposedPortPosition","getClassName","canConnectTo","connectionPoint","checkCompatibilityState","Compatible","otherBlock","TargetIncompatible","output","indexOf","TypeIncompatible","targetBlock","Input","isAnAncestorOf","HierarchyIssue","connectTo","ignoreConstraints","push","notifyObservers","disconnectFrom","index","splice","addExcludedConnectionPointFromAllowedTypes","mask","bitmask","All","serialize","serializationObject","displayName","inputName","targetBlockId","uniqueId","targetConnectionName","dispose","clear"],"sources":["../../../../../dev/core/src/Materials/Node/nodeMaterialBlockConnectionPoint.ts"],"sourcesContent":["import { NodeMaterialBlockConnectionPointTypes } from \"./Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { NodeMaterialBlock } from \"./nodeMaterialBlock\";\r\n\r\n/**\r\n * Enum used to define the compatibility state between two connection points\r\n */\r\nexport enum NodeMaterialConnectionPointCompatibilityStates {\r\n    /** Points are compatibles */\r\n    Compatible,\r\n    /** Points are incompatible because of their types */\r\n    TypeIncompatible,\r\n    /** Points are incompatible because of their targets (vertex vs fragment) */\r\n    TargetIncompatible,\r\n    /** Points are incompatible because they are in the same hierarchy **/\r\n    HierarchyIssue,\r\n}\r\n\r\n/**\r\n * Defines the direction of a connection point\r\n */\r\nexport enum NodeMaterialConnectionPointDirection {\r\n    /** Input */\r\n    Input,\r\n    /** Output */\r\n    Output,\r\n}\r\n\r\n/**\r\n * Defines a connection point for a block\r\n */\r\nexport class NodeMaterialConnectionPoint {\r\n    /**\r\n     * Checks if two types are equivalent\r\n     * @param type1 type 1 to check\r\n     * @param type2 type 2 to check\r\n     * @returns true if both types are equivalent, else false\r\n     */\r\n    public static AreEquivalentTypes(type1: number, type2: number): boolean {\r\n        switch (type1) {\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Color3) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Color4) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n            case NodeMaterialBlockConnectionPointTypes.Color3: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Vector3) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n            case NodeMaterialBlockConnectionPointTypes.Color4: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Vector4) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _ownerBlock: NodeMaterialBlock;\r\n    /** @internal */\r\n    public _connectedPoint: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    private _endpoints = new Array<NodeMaterialConnectionPoint>();\r\n    private _associatedVariableName: string;\r\n    private _direction: NodeMaterialConnectionPointDirection;\r\n\r\n    /** @internal */\r\n    public _typeConnectionSource: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    /** @internal */\r\n    public _defaultConnectionPointType: Nullable<NodeMaterialBlockConnectionPointTypes> = null;\r\n\r\n    /** @internal */\r\n    public _linkedConnectionSource: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    /** @internal */\r\n    public _acceptedConnectionPointType: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    private _type = NodeMaterialBlockConnectionPointTypes.Float;\r\n\r\n    /** @internal */\r\n    public _enforceAssociatedVariableName = false;\r\n\r\n    /** Gets the direction of the point */\r\n    public get direction() {\r\n        return this._direction;\r\n    }\r\n\r\n    /** Indicates that this connection point needs dual validation before being connected to another point */\r\n    public needDualDirectionValidation: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets the additional types supported by this connection point\r\n     */\r\n    public acceptedConnectionPointTypes = new Array<NodeMaterialBlockConnectionPointTypes>();\r\n\r\n    /**\r\n     * Gets or sets the additional types excluded by this connection point\r\n     */\r\n    public excludedConnectionPointTypes = new Array<NodeMaterialBlockConnectionPointTypes>();\r\n\r\n    /**\r\n     * Observable triggered when this point is connected\r\n     */\r\n    public onConnectionObservable = new Observable<NodeMaterialConnectionPoint>();\r\n\r\n    /**\r\n     * Gets or sets the associated variable name in the shader\r\n     */\r\n    public get associatedVariableName(): string {\r\n        if (this._ownerBlock.isInput) {\r\n            return (this._ownerBlock as InputBlock).associatedVariableName;\r\n        }\r\n\r\n        if ((!this._enforceAssociatedVariableName || !this._associatedVariableName) && this._connectedPoint) {\r\n            return this._connectedPoint.associatedVariableName;\r\n        }\r\n\r\n        return this._associatedVariableName;\r\n    }\r\n\r\n    public set associatedVariableName(value: string) {\r\n        this._associatedVariableName = value;\r\n    }\r\n\r\n    /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */\r\n    public get innerType() {\r\n        if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {\r\n            return this.type;\r\n        }\r\n        return this._type;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the connection point type (default is float)\r\n     */\r\n    public get type(): NodeMaterialBlockConnectionPointTypes {\r\n        if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n            if (this._ownerBlock.isInput) {\r\n                return (this._ownerBlock as InputBlock).type;\r\n            }\r\n\r\n            if (this._connectedPoint) {\r\n                return this._connectedPoint.type;\r\n            }\r\n\r\n            if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {\r\n                return this._linkedConnectionSource.type;\r\n            }\r\n        }\r\n\r\n        if (this._type === NodeMaterialBlockConnectionPointTypes.BasedOnInput) {\r\n            if (this._typeConnectionSource) {\r\n                if (!this._typeConnectionSource.isConnected && this._defaultConnectionPointType) {\r\n                    return this._defaultConnectionPointType;\r\n                }\r\n                return this._typeConnectionSource.type;\r\n            } else if (this._defaultConnectionPointType) {\r\n                return this._defaultConnectionPointType;\r\n            }\r\n        }\r\n\r\n        return this._type;\r\n    }\r\n\r\n    public set type(value: NodeMaterialBlockConnectionPointTypes) {\r\n        this._type = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the connection point name\r\n     */\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets the connection point name\r\n     */\r\n    public displayName: string;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point can be omitted\r\n     */\r\n    public isOptional: boolean;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is exposed on a frame\r\n     */\r\n    public isExposedOnFrame: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets number indicating the position that the port is exposed to on a frame\r\n     */\r\n    public exposedPortPosition: number = -1;\r\n\r\n    /**\r\n     * Gets or sets a string indicating that this uniform must be defined under a #ifdef\r\n     */\r\n    public define: string;\r\n\r\n    /** @internal */\r\n    public _prioritizeVertex = false;\r\n\r\n    private _target: NodeMaterialBlockTargets = NodeMaterialBlockTargets.VertexAndFragment;\r\n\r\n    /** Gets or sets the target of that connection point */\r\n    public get target(): NodeMaterialBlockTargets {\r\n        if (!this._prioritizeVertex || !this._ownerBlock) {\r\n            return this._target;\r\n        }\r\n\r\n        if (this._target !== NodeMaterialBlockTargets.VertexAndFragment) {\r\n            return this._target;\r\n        }\r\n\r\n        if (this._ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            return NodeMaterialBlockTargets.Fragment;\r\n        }\r\n\r\n        return NodeMaterialBlockTargets.Vertex;\r\n    }\r\n\r\n    public set target(value: NodeMaterialBlockTargets) {\r\n        this._target = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current point is connected to another NodeMaterialBlock\r\n     */\r\n    public get isConnected(): boolean {\r\n        return this.connectedPoint !== null || this.hasEndpoints;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current point is connected to an input block\r\n     */\r\n    public get isConnectedToInputBlock(): boolean {\r\n        return this.connectedPoint !== null && this.connectedPoint.ownerBlock.isInput;\r\n    }\r\n\r\n    /**\r\n     * Gets a the connected input block (if any)\r\n     */\r\n    public get connectInputBlock(): Nullable<InputBlock> {\r\n        if (!this.isConnectedToInputBlock) {\r\n            return null;\r\n        }\r\n\r\n        return this.connectedPoint!.ownerBlock as InputBlock;\r\n    }\r\n\r\n    /** Get the other side of the connection (if any) */\r\n    public get connectedPoint(): Nullable<NodeMaterialConnectionPoint> {\r\n        return this._connectedPoint;\r\n    }\r\n\r\n    /** Get the block that owns this connection point */\r\n    public get ownerBlock(): NodeMaterialBlock {\r\n        return this._ownerBlock;\r\n    }\r\n\r\n    /** Get the block connected on the other side of this connection (if any) */\r\n    public get sourceBlock(): Nullable<NodeMaterialBlock> {\r\n        if (!this._connectedPoint) {\r\n            return null;\r\n        }\r\n\r\n        return this._connectedPoint.ownerBlock;\r\n    }\r\n\r\n    /** Get the block connected on the endpoints of this connection (if any) */\r\n    public get connectedBlocks(): Array<NodeMaterialBlock> {\r\n        if (this._endpoints.length === 0) {\r\n            return [];\r\n        }\r\n\r\n        return this._endpoints.map((e) => e.ownerBlock);\r\n    }\r\n\r\n    /** Gets the list of connected endpoints */\r\n    public get endpoints() {\r\n        return this._endpoints;\r\n    }\r\n\r\n    /** Gets a boolean indicating if that output point is connected to at least one input */\r\n    public get hasEndpoints(): boolean {\r\n        return this._endpoints && this._endpoints.length > 0;\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection has a path to the vertex output*/\r\n    public get isDirectlyConnectedToVertexOutput(): boolean {\r\n        if (!this.hasEndpoints) {\r\n            return false;\r\n        }\r\n\r\n        for (const endpoint of this._endpoints) {\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                if (endpoint.ownerBlock.outputs.some((o) => o.isDirectlyConnectedToVertexOutput)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection will be used in the vertex shader */\r\n    public get isConnectedInVertexShader(): boolean {\r\n        if (this.target === NodeMaterialBlockTargets.Vertex) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.hasEndpoints) {\r\n            return false;\r\n        }\r\n\r\n        for (const endpoint of this._endpoints) {\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.target === NodeMaterialBlockTargets.Vertex) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                if (endpoint.ownerBlock.outputs.some((o) => o.isConnectedInVertexShader)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection will be used in the fragment shader */\r\n    public get isConnectedInFragmentShader(): boolean {\r\n        if (this.target === NodeMaterialBlockTargets.Fragment) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.hasEndpoints) {\r\n            return false;\r\n        }\r\n\r\n        for (const endpoint of this._endpoints) {\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                if (endpoint.ownerBlock.isConnectedInFragmentShader()) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Creates a block suitable to be used as an input for this input point.\r\n     * If null is returned, a block based on the point type will be created.\r\n     * @returns The returned string parameter is the name of the output point of NodeMaterialBlock (first parameter of the returned array) that can be connected to the input\r\n     */\r\n    public createCustomInputBlock(): Nullable<[NodeMaterialBlock, string]> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates a new connection point\r\n     * @param name defines the connection point name\r\n     * @param ownerBlock defines the block hosting this connection point\r\n     * @param direction defines the direction of the connection point\r\n     */\r\n    public constructor(name: string, ownerBlock: NodeMaterialBlock, direction: NodeMaterialConnectionPointDirection) {\r\n        this._ownerBlock = ownerBlock;\r\n        this.name = name;\r\n        this._direction = direction;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name e.g. \"NodeMaterialConnectionPoint\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"NodeMaterialConnectionPoint\";\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a boolean\r\n     */\r\n    public canConnectTo(connectionPoint: NodeMaterialConnectionPoint) {\r\n        return this.checkCompatibilityState(connectionPoint) === NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n    }\r\n\r\n    /**\r\n     * Gets a number indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a number defining the compatibility state\r\n     */\r\n    public checkCompatibilityState(connectionPoint: NodeMaterialConnectionPoint): NodeMaterialConnectionPointCompatibilityStates {\r\n        const ownerBlock = this._ownerBlock;\r\n        const otherBlock = connectionPoint.ownerBlock;\r\n\r\n        if (ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            // Let's check we are not going reverse\r\n\r\n            if (otherBlock.target === NodeMaterialBlockTargets.Vertex) {\r\n                return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;\r\n            }\r\n\r\n            for (const output of otherBlock.outputs) {\r\n                if (output.ownerBlock.target != NodeMaterialBlockTargets.Neutral && output.isConnectedInVertexShader) {\r\n                    return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n            // Equivalents\r\n            if (NodeMaterialConnectionPoint.AreEquivalentTypes(this.type, connectionPoint.type)) {\r\n                return NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n            }\r\n\r\n            // Accepted types\r\n            if (\r\n                (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1) ||\r\n                (connectionPoint._acceptedConnectionPointType && NodeMaterialConnectionPoint.AreEquivalentTypes(connectionPoint._acceptedConnectionPointType.type, this.type))\r\n            ) {\r\n                return NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n            } else {\r\n                return NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;\r\n            }\r\n        }\r\n\r\n        // Excluded\r\n        if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {\r\n            return NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;\r\n        }\r\n\r\n        // Check hierarchy\r\n        let targetBlock = otherBlock;\r\n        let sourceBlock = ownerBlock;\r\n        if (this.direction === NodeMaterialConnectionPointDirection.Input) {\r\n            targetBlock = ownerBlock;\r\n            sourceBlock = otherBlock;\r\n        }\r\n\r\n        if (targetBlock.isAnAncestorOf(sourceBlock)) {\r\n            return NodeMaterialConnectionPointCompatibilityStates.HierarchyIssue;\r\n        }\r\n\r\n        return NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n    }\r\n\r\n    /**\r\n     * Connect this point to another connection point\r\n     * @param connectionPoint defines the other connection point\r\n     * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)\r\n     * @returns the current connection point\r\n     */\r\n    public connectTo(connectionPoint: NodeMaterialConnectionPoint, ignoreConstraints = false): NodeMaterialConnectionPoint {\r\n        if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {\r\n            throw \"Cannot connect these two connectors.\";\r\n        }\r\n\r\n        this._endpoints.push(connectionPoint);\r\n        connectionPoint._connectedPoint = this;\r\n\r\n        this._enforceAssociatedVariableName = false;\r\n\r\n        this.onConnectionObservable.notifyObservers(connectionPoint);\r\n        connectionPoint.onConnectionObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disconnect this point from one of his endpoint\r\n     * @param endpoint defines the other connection point\r\n     * @returns the current connection point\r\n     */\r\n    public disconnectFrom(endpoint: NodeMaterialConnectionPoint): NodeMaterialConnectionPoint {\r\n        const index = this._endpoints.indexOf(endpoint);\r\n\r\n        if (index === -1) {\r\n            return this;\r\n        }\r\n\r\n        this._endpoints.splice(index, 1);\r\n        endpoint._connectedPoint = null;\r\n        this._enforceAssociatedVariableName = false;\r\n        endpoint._enforceAssociatedVariableName = false;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Fill the list of excluded connection point types with all types other than those passed in the parameter\r\n     * @param mask Types (ORed values of NodeMaterialBlockConnectionPointTypes) that are allowed, and thus will not be pushed to the excluded list\r\n     */\r\n    public addExcludedConnectionPointFromAllowedTypes(mask: number): void {\r\n        let bitmask = 1;\r\n        while (bitmask < NodeMaterialBlockConnectionPointTypes.All) {\r\n            if (!(mask & bitmask)) {\r\n                this.excludedConnectionPointTypes.push(bitmask);\r\n            }\r\n            bitmask = bitmask << 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes this point in a JSON representation\r\n     * @param isInput defines if the connection point is an input (default is true)\r\n     * @returns the serialized point object\r\n     */\r\n    public serialize(isInput = true): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.displayName = this.displayName;\r\n\r\n        if (isInput && this.connectedPoint) {\r\n            serializationObject.inputName = this.name;\r\n            serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;\r\n            serializationObject.targetConnectionName = this.connectedPoint.name;\r\n            serializationObject.isExposedOnFrame = true;\r\n            serializationObject.exposedPortPosition = this.exposedPortPosition;\r\n        }\r\n\r\n        if (this.isExposedOnFrame || this.exposedPortPosition >= 0) {\r\n            serializationObject.isExposedOnFrame = true;\r\n            serializationObject.exposedPortPosition = this.exposedPortPosition;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        this.onConnectionObservable.clear();\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}