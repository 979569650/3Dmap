{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { WebXRControllerComponent } from \"../motionController/webXRControllerComponent.js\";\nimport { Matrix, Quaternion, Vector3 } from \"../../Maths/math.vector.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * This is a movement feature to be used with WebXR-enabled motion controllers.\n * When enabled and attached, the feature will allow a user to move around and rotate in the scene using\n * the input of the attached controllers.\n */\nexport class WebXRControllerMovement extends WebXRAbstractFeature {\n  /**\n   * Current movement direction.  Will be null before XR Frames have been processed.\n   */\n  get movementDirection() {\n    return this._movementDirection;\n  }\n  /**\n   * Is movement enabled\n   */\n  get movementEnabled() {\n    return this._featureContext.movementEnabled;\n  }\n  /**\n   * Sets whether movement is enabled or not\n   * @param enabled is movement enabled\n   */\n  set movementEnabled(enabled) {\n    this._featureContext.movementEnabled = enabled;\n  }\n  /**\n   * If movement follows viewer pose\n   */\n  get movementOrientationFollowsViewerPose() {\n    return this._featureContext.movementOrientationFollowsViewerPose;\n  }\n  /**\n   * Sets whether movement follows viewer pose\n   * @param followsPose is movement should follow viewer pose\n   */\n  set movementOrientationFollowsViewerPose(followsPose) {\n    this._featureContext.movementOrientationFollowsViewerPose = followsPose;\n  }\n  /**\n   * Gets movement speed\n   */\n  get movementSpeed() {\n    return this._featureContext.movementSpeed;\n  }\n  /**\n   * Sets movement speed\n   * @param movementSpeed movement speed\n   */\n  set movementSpeed(movementSpeed) {\n    this._featureContext.movementSpeed = movementSpeed;\n  }\n  /**\n   * Gets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for movement (avoids jitter/unintentional movement)\n   */\n  get movementThreshold() {\n    return this._featureContext.movementThreshold;\n  }\n  /**\n   * Sets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for movement (avoids jitter/unintentional movement)\n   * @param movementThreshold new threshold\n   */\n  set movementThreshold(movementThreshold) {\n    this._featureContext.movementThreshold = movementThreshold;\n  }\n  /**\n   * Is rotation enabled\n   */\n  get rotationEnabled() {\n    return this._featureContext.rotationEnabled;\n  }\n  /**\n   * Sets whether rotation is enabled or not\n   * @param enabled is rotation enabled\n   */\n  set rotationEnabled(enabled) {\n    this._featureContext.rotationEnabled = enabled;\n  }\n  /**\n   * Gets rotation speed factor\n   */\n  get rotationSpeed() {\n    return this._featureContext.rotationSpeed;\n  }\n  /**\n   * Sets rotation speed factor (1.0 is default)\n   * @param rotationSpeed new rotation speed factor\n   */\n  set rotationSpeed(rotationSpeed) {\n    this._featureContext.rotationSpeed = rotationSpeed;\n  }\n  /**\n   * Gets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for rotation (avoids jitter/unintentional rotation)\n   */\n  get rotationThreshold() {\n    return this._featureContext.rotationThreshold;\n  }\n  /**\n   * Sets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for rotation (avoids jitter/unintentional rotation)\n   * @param threshold new threshold\n   */\n  set rotationThreshold(threshold) {\n    this._featureContext.rotationThreshold = threshold;\n  }\n  /**\n   * constructs a new movement controller system\n   * @param _xrSessionManager an instance of WebXRSessionManager\n   * @param options configuration object for this feature\n   */\n  constructor(_xrSessionManager, options) {\n    var _a, _b, _c, _d, _e, _f;\n    super(_xrSessionManager);\n    this._controllers = {};\n    this._currentRegistrationConfigurations = [];\n    // forward direction for movement, which may differ from viewer pose.\n    this._movementDirection = new Quaternion();\n    // unused\n    this._tmpRotationMatrix = Matrix.Identity();\n    this._tmpTranslationDirection = new Vector3();\n    this._tmpMovementTranslation = new Vector3();\n    this._tempCacheQuaternion = new Quaternion();\n    this._attachController = xrController => {\n      if (this._controllers[xrController.uniqueId]) {\n        // already attached\n        return;\n      }\n      this._controllers[xrController.uniqueId] = {\n        xrController,\n        registeredComponents: []\n      };\n      const controllerData = this._controllers[xrController.uniqueId];\n      // movement controller only available to gamepad-enabled input sources.\n      if (controllerData.xrController.inputSource.targetRayMode === \"tracked-pointer\" && controllerData.xrController.inputSource.gamepad) {\n        // motion controller support\n        const initController = () => {\n          if (xrController.motionController) {\n            for (const registration of this._currentRegistrationConfigurations) {\n              let component = null;\n              if (registration.allowedComponentTypes) {\n                for (const componentType of registration.allowedComponentTypes) {\n                  const componentOfType = xrController.motionController.getComponentOfType(componentType);\n                  if (componentOfType !== null) {\n                    component = componentOfType;\n                    break;\n                  }\n                }\n              }\n              if (registration.mainComponentOnly) {\n                const mainComponent = xrController.motionController.getMainComponent();\n                if (mainComponent === null) {\n                  continue;\n                }\n                component = mainComponent;\n              }\n              if (typeof registration.componentSelectionPredicate === \"function\") {\n                // if does not match we do want to ignore a previously found component\n                component = registration.componentSelectionPredicate(xrController);\n              }\n              if (component && registration.forceHandedness) {\n                if (xrController.inputSource.handedness !== registration.forceHandedness) {\n                  continue; // do not register\n                }\n              }\n\n              if (component === null) {\n                continue; // do not register\n              }\n\n              const registeredComponent = {\n                registrationConfiguration: registration,\n                component\n              };\n              controllerData.registeredComponents.push(registeredComponent);\n              if (\"axisChangedHandler\" in registration) {\n                registeredComponent.onAxisChangedObserver = component.onAxisValueChangedObservable.add(axesData => {\n                  registration.axisChangedHandler(axesData, this._movementState, this._featureContext, this._xrInput);\n                });\n              }\n              if (\"buttonChangedhandler\" in registration) {\n                registeredComponent.onButtonChangedObserver = component.onButtonStateChangedObservable.add(() => {\n                  if (component.changes.pressed) {\n                    registration.buttonChangedhandler(component.changes.pressed, this._movementState, this._featureContext, this._xrInput);\n                  }\n                });\n              }\n            }\n          }\n        };\n        if (xrController.motionController) {\n          initController();\n        } else {\n          xrController.onMotionControllerInitObservable.addOnce(() => {\n            initController();\n          });\n        }\n      }\n    };\n    if (!options || options.xrInput === undefined) {\n      Tools.Error('WebXRControllerMovement feature requires \"xrInput\" option.');\n      return;\n    }\n    if (Array.isArray(options.customRegistrationConfigurations)) {\n      this._currentRegistrationConfigurations = options.customRegistrationConfigurations;\n    } else {\n      this._currentRegistrationConfigurations = WebXRControllerMovement.REGISTRATIONS.default;\n    }\n    // synchronized from feature setter properties\n    this._featureContext = {\n      movementEnabled: options.movementEnabled || true,\n      movementOrientationFollowsViewerPose: (_a = options.movementOrientationFollowsViewerPose) !== null && _a !== void 0 ? _a : true,\n      movementSpeed: (_b = options.movementSpeed) !== null && _b !== void 0 ? _b : 1,\n      movementThreshold: (_c = options.movementThreshold) !== null && _c !== void 0 ? _c : 0.25,\n      rotationEnabled: (_d = options.rotationEnabled) !== null && _d !== void 0 ? _d : true,\n      rotationSpeed: (_e = options.rotationSpeed) !== null && _e !== void 0 ? _e : 1.0,\n      rotationThreshold: (_f = options.rotationThreshold) !== null && _f !== void 0 ? _f : 0.25\n    };\n    this._movementState = {\n      moveX: 0,\n      moveY: 0,\n      rotateX: 0,\n      rotateY: 0\n    };\n    this._xrInput = options.xrInput;\n  }\n  attach() {\n    if (!super.attach()) {\n      return false;\n    }\n    this._xrInput.controllers.forEach(this._attachController);\n    this._addNewAttachObserver(this._xrInput.onControllerAddedObservable, this._attachController);\n    this._addNewAttachObserver(this._xrInput.onControllerRemovedObservable, controller => {\n      // REMOVE the controller\n      this._detachController(controller.uniqueId);\n    });\n    return true;\n  }\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    Object.keys(this._controllers).forEach(controllerId => {\n      this._detachController(controllerId);\n    });\n    this._controllers = {};\n    return true;\n  }\n  /**\n   * Occurs on every XR frame.\n   * @param _xrFrame\n   */\n  _onXRFrame(_xrFrame) {\n    if (!this.attached) {\n      return;\n    }\n    if (this._movementState.rotateX !== 0 && this._featureContext.rotationEnabled) {\n      // smooth rotation\n      const deltaMillis = this._xrSessionManager.scene.getEngine().getDeltaTime();\n      const rotationY = deltaMillis * 0.001 * this._featureContext.rotationSpeed * this._movementState.rotateX * (this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);\n      if (this._featureContext.movementOrientationFollowsViewerPose) {\n        this._xrInput.xrCamera.cameraRotation.y += rotationY;\n        Quaternion.RotationYawPitchRollToRef(rotationY, 0, 0, this._tempCacheQuaternion);\n        this._xrInput.xrCamera.rotationQuaternion.multiplyToRef(this._tempCacheQuaternion, this._movementDirection);\n      } else {\n        // movement orientation direction does not affect camera.  We use rotation speed multiplier\n        // otherwise need to implement inertia and constraints for same feel as TargetCamera.\n        Quaternion.RotationYawPitchRollToRef(rotationY * 3.0, 0, 0, this._tempCacheQuaternion);\n        this._movementDirection.multiplyInPlace(this._tempCacheQuaternion);\n      }\n    } else if (this._featureContext.movementOrientationFollowsViewerPose) {\n      this._movementDirection.copyFrom(this._xrInput.xrCamera.rotationQuaternion);\n    }\n    if ((this._movementState.moveX || this._movementState.moveY) && this._featureContext.movementEnabled) {\n      Matrix.FromQuaternionToRef(this._movementDirection, this._tmpRotationMatrix);\n      this._tmpTranslationDirection.set(this._movementState.moveX, 0, this._movementState.moveY * (this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0));\n      // move according to forward direction based on camera speed\n      Vector3.TransformCoordinatesToRef(this._tmpTranslationDirection, this._tmpRotationMatrix, this._tmpMovementTranslation);\n      this._tmpMovementTranslation.scaleInPlace(this._xrInput.xrCamera._computeLocalCameraSpeed() * this._featureContext.movementSpeed);\n      this._xrInput.xrCamera.cameraDirection.addInPlace(this._tmpMovementTranslation);\n    }\n  }\n  _detachController(xrControllerUniqueId) {\n    const controllerData = this._controllers[xrControllerUniqueId];\n    if (!controllerData) {\n      return;\n    }\n    for (const registeredComponent of controllerData.registeredComponents) {\n      if (registeredComponent.onAxisChangedObserver) {\n        registeredComponent.component.onAxisValueChangedObservable.remove(registeredComponent.onAxisChangedObserver);\n      }\n      if (registeredComponent.onButtonChangedObserver) {\n        registeredComponent.component.onButtonStateChangedObservable.remove(registeredComponent.onButtonChangedObserver);\n      }\n    }\n    // remove from the map\n    delete this._controllers[xrControllerUniqueId];\n  }\n}\n/**\n * The module's name\n */\nWebXRControllerMovement.Name = WebXRFeatureName.MOVEMENT;\n/**\n * Standard controller configurations.\n */\nWebXRControllerMovement.REGISTRATIONS = {\n  default: [{\n    allowedComponentTypes: [WebXRControllerComponent.THUMBSTICK_TYPE, WebXRControllerComponent.TOUCHPAD_TYPE],\n    forceHandedness: \"left\",\n    axisChangedHandler: (axes, movementState, featureContext) => {\n      movementState.rotateX = Math.abs(axes.x) > featureContext.rotationThreshold ? axes.x : 0;\n      movementState.rotateY = Math.abs(axes.y) > featureContext.rotationThreshold ? axes.y : 0;\n    }\n  }, {\n    allowedComponentTypes: [WebXRControllerComponent.THUMBSTICK_TYPE, WebXRControllerComponent.TOUCHPAD_TYPE],\n    forceHandedness: \"right\",\n    axisChangedHandler: (axes, movementState, featureContext) => {\n      movementState.moveX = Math.abs(axes.x) > featureContext.movementThreshold ? axes.x : 0;\n      movementState.moveY = Math.abs(axes.y) > featureContext.movementThreshold ? axes.y : 0;\n    }\n  }]\n};\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the webxr specs version\n */\nWebXRControllerMovement.Version = 1;\nWebXRFeaturesManager.AddWebXRFeature(WebXRControllerMovement.Name, (xrSessionManager, options) => {\n  return () => new WebXRControllerMovement(xrSessionManager, options);\n}, WebXRControllerMovement.Version, true);","map":{"version":3,"names":["WebXRFeaturesManager","WebXRFeatureName","WebXRControllerComponent","Matrix","Quaternion","Vector3","WebXRAbstractFeature","Tools","WebXRControllerMovement","movementDirection","_movementDirection","movementEnabled","_featureContext","enabled","movementOrientationFollowsViewerPose","followsPose","movementSpeed","movementThreshold","rotationEnabled","rotationSpeed","rotationThreshold","threshold","constructor","_xrSessionManager","options","_controllers","_currentRegistrationConfigurations","_tmpRotationMatrix","Identity","_tmpTranslationDirection","_tmpMovementTranslation","_tempCacheQuaternion","_attachController","xrController","uniqueId","registeredComponents","controllerData","inputSource","targetRayMode","gamepad","initController","motionController","registration","component","allowedComponentTypes","componentType","componentOfType","getComponentOfType","mainComponentOnly","mainComponent","getMainComponent","componentSelectionPredicate","forceHandedness","handedness","registeredComponent","registrationConfiguration","push","onAxisChangedObserver","onAxisValueChangedObservable","add","axesData","axisChangedHandler","_movementState","_xrInput","onButtonChangedObserver","onButtonStateChangedObservable","changes","pressed","buttonChangedhandler","onMotionControllerInitObservable","addOnce","xrInput","undefined","Error","Array","isArray","customRegistrationConfigurations","REGISTRATIONS","default","_a","_b","_c","_d","_e","_f","moveX","moveY","rotateX","rotateY","attach","controllers","forEach","_addNewAttachObserver","onControllerAddedObservable","onControllerRemovedObservable","controller","_detachController","detach","Object","keys","controllerId","_onXRFrame","_xrFrame","attached","deltaMillis","scene","getEngine","getDeltaTime","rotationY","useRightHandedSystem","xrCamera","cameraRotation","y","RotationYawPitchRollToRef","rotationQuaternion","multiplyToRef","multiplyInPlace","copyFrom","FromQuaternionToRef","set","TransformCoordinatesToRef","scaleInPlace","_computeLocalCameraSpeed","cameraDirection","addInPlace","xrControllerUniqueId","remove","Name","MOVEMENT","THUMBSTICK_TYPE","TOUCHPAD_TYPE","axes","movementState","featureContext","Math","abs","x","Version","AddWebXRFeature","xrSessionManager"],"sources":["../../../../../dev/core/src/XR/features/WebXRControllerMovement.ts"],"sourcesContent":["import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport type { IWebXRMotionControllerAxesValue, IWebXRMotionControllerComponentChangesValues } from \"../motionController/webXRControllerComponent\";\r\nimport { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\r\nimport { Matrix, Quaternion, Vector3 } from \"../../Maths/math.vector\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport type { MotionControllerComponentType } from \"../motionController/webXRAbstractMotionController\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * The options container for the controller movement module\r\n */\r\nexport interface IWebXRControllerMovementOptions {\r\n    /**\r\n     * Override default behaviour and provide your own movement controls\r\n     */\r\n    customRegistrationConfigurations?: WebXRControllerMovementRegistrationConfiguration[];\r\n    /**\r\n     * Is movement enabled\r\n     */\r\n    movementEnabled?: boolean;\r\n    /**\r\n     * Camera direction follows view pose and movement by default will move independently of the viewer's pose.\r\n     */\r\n    movementOrientationFollowsViewerPose: boolean;\r\n    /**\r\n     * Movement speed factor (default is 1.0)\r\n     */\r\n    movementSpeed?: number;\r\n    /**\r\n     * Minimum threshold the controller's thumbstick/touchpad must pass before being recognized for movement (avoids jitter/unintentional movement)\r\n     */\r\n    movementThreshold?: number;\r\n    /**\r\n     * Is rotation enabled\r\n     */\r\n    rotationEnabled?: boolean;\r\n    /**\r\n     * Minimum threshold the controller's thumstick/touchpad must pass before being recognized for rotation (avoids jitter/unintentional rotation)\r\n     */\r\n    rotationThreshold?: number;\r\n    /**\r\n     * Movement speed factor (default is 1.0)\r\n     */\r\n    rotationSpeed?: number;\r\n    /**\r\n     * Babylon XR Input class for controller\r\n     */\r\n    xrInput: WebXRInput;\r\n}\r\n\r\n/**\r\n * Feature context is used in handlers and on each XR frame to control the camera movement/direction.\r\n */\r\nexport type WebXRControllerMovementFeatureContext = {\r\n    movementEnabled: boolean;\r\n    movementOrientationFollowsViewerPose: boolean;\r\n    movementSpeed: number;\r\n    movementThreshold: number;\r\n    rotationEnabled: boolean;\r\n    rotationSpeed: number;\r\n    rotationThreshold: number;\r\n};\r\n\r\n/**\r\n * Current state of Movements shared across components and handlers.\r\n */\r\nexport type WebXRControllerMovementState = {\r\n    moveX: number;\r\n    moveY: number;\r\n    rotateX: number;\r\n    rotateY: number;\r\n};\r\n\r\n/**\r\n * Button of Axis Handler must be specified.\r\n */\r\nexport type WebXRControllerMovementRegistrationConfiguration = {\r\n    /**\r\n     * handlers are filtered to these types only\r\n     */\r\n    allowedComponentTypes?: MotionControllerComponentType[];\r\n    /**\r\n     * For registering movement to specific hand only.  Useful if your app has a \"main hand\" and \"off hand\" for determining the functionality of a controller.\r\n     */\r\n    forceHandedness?: XRHandedness;\r\n    /**\r\n     * For main component only (useful for buttons and may not trigger axis changes).\r\n     */\r\n    mainComponentOnly?: boolean;\r\n    /**\r\n     * Additional predicate to apply to controllers to restrict a handler being added.\r\n     */\r\n    componentSelectionPredicate?: (xrController: WebXRInputSource) => Nullable<WebXRControllerComponent>;\r\n} & (\r\n    | {\r\n          /**\r\n           * Called when axis changes occur.\r\n           */\r\n          axisChangedHandler: (\r\n              axes: IWebXRMotionControllerAxesValue,\r\n              movementState: WebXRControllerMovementState,\r\n              featureContext: WebXRControllerMovementFeatureContext,\r\n              xrInput: WebXRInput\r\n          ) => void;\r\n      }\r\n    | {\r\n          /**\r\n           * Called when the button state changes.\r\n           */\r\n          buttonChangedhandler: (\r\n              pressed: IWebXRMotionControllerComponentChangesValues<boolean>,\r\n              movementState: WebXRControllerMovementState,\r\n              featureContext: WebXRControllerMovementFeatureContext,\r\n              xrInput: WebXRInput\r\n          ) => void;\r\n      }\r\n);\r\n\r\ntype RegisteredComponent = {\r\n    registrationConfiguration: WebXRControllerMovementRegistrationConfiguration;\r\n    component: WebXRControllerComponent;\r\n    onAxisChangedObserver?: Nullable<Observer<IWebXRMotionControllerAxesValue>>;\r\n    onButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n};\r\n\r\n/**\r\n * This is a movement feature to be used with WebXR-enabled motion controllers.\r\n * When enabled and attached, the feature will allow a user to move around and rotate in the scene using\r\n * the input of the attached controllers.\r\n */\r\nexport class WebXRControllerMovement extends WebXRAbstractFeature {\r\n    private _controllers: {\r\n        [controllerUniqueId: string]: {\r\n            xrController: WebXRInputSource;\r\n            registeredComponents: RegisteredComponent[];\r\n        };\r\n    } = {};\r\n\r\n    private _currentRegistrationConfigurations: WebXRControllerMovementRegistrationConfiguration[] = [];\r\n    // Feature configuration is syncronized - this is passed to all handlers (reduce GC pressure).\r\n    private _featureContext: WebXRControllerMovementFeatureContext;\r\n    // forward direction for movement, which may differ from viewer pose.\r\n    private _movementDirection: Quaternion = new Quaternion();\r\n    private _movementState: WebXRControllerMovementState;\r\n    private _xrInput: WebXRInput;\r\n\r\n    // unused\r\n    private _tmpRotationMatrix: Matrix = Matrix.Identity();\r\n    private _tmpTranslationDirection: Vector3 = new Vector3();\r\n    private _tmpMovementTranslation: Vector3 = new Vector3();\r\n    private _tempCacheQuaternion: Quaternion = new Quaternion();\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.MOVEMENT;\r\n\r\n    /**\r\n     * Standard controller configurations.\r\n     */\r\n    public static readonly REGISTRATIONS: { [key: string]: WebXRControllerMovementRegistrationConfiguration[] } = {\r\n        default: [\r\n            {\r\n                allowedComponentTypes: [WebXRControllerComponent.THUMBSTICK_TYPE, WebXRControllerComponent.TOUCHPAD_TYPE],\r\n                forceHandedness: \"left\",\r\n                axisChangedHandler: (axes: IWebXRMotionControllerAxesValue, movementState: WebXRControllerMovementState, featureContext: WebXRControllerMovementFeatureContext) => {\r\n                    movementState.rotateX = Math.abs(axes.x) > featureContext.rotationThreshold ? axes.x : 0;\r\n                    movementState.rotateY = Math.abs(axes.y) > featureContext.rotationThreshold ? axes.y : 0;\r\n                },\r\n            },\r\n            {\r\n                allowedComponentTypes: [WebXRControllerComponent.THUMBSTICK_TYPE, WebXRControllerComponent.TOUCHPAD_TYPE],\r\n                forceHandedness: \"right\",\r\n                axisChangedHandler: (axes: IWebXRMotionControllerAxesValue, movementState: WebXRControllerMovementState, featureContext: WebXRControllerMovementFeatureContext) => {\r\n                    movementState.moveX = Math.abs(axes.x) > featureContext.movementThreshold ? axes.x : 0;\r\n                    movementState.moveY = Math.abs(axes.y) > featureContext.movementThreshold ? axes.y : 0;\r\n                },\r\n            },\r\n        ],\r\n    };\r\n\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the webxr specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Current movement direction.  Will be null before XR Frames have been processed.\r\n     */\r\n    public get movementDirection(): Quaternion {\r\n        return this._movementDirection;\r\n    }\r\n\r\n    /**\r\n     * Is movement enabled\r\n     */\r\n    public get movementEnabled(): boolean {\r\n        return this._featureContext.movementEnabled;\r\n    }\r\n\r\n    /**\r\n     * Sets whether movement is enabled or not\r\n     * @param enabled is movement enabled\r\n     */\r\n    public set movementEnabled(enabled: boolean) {\r\n        this._featureContext.movementEnabled = enabled;\r\n    }\r\n\r\n    /**\r\n     * If movement follows viewer pose\r\n     */\r\n    public get movementOrientationFollowsViewerPose(): boolean {\r\n        return this._featureContext.movementOrientationFollowsViewerPose;\r\n    }\r\n\r\n    /**\r\n     * Sets whether movement follows viewer pose\r\n     * @param followsPose is movement should follow viewer pose\r\n     */\r\n    public set movementOrientationFollowsViewerPose(followsPose: boolean) {\r\n        this._featureContext.movementOrientationFollowsViewerPose = followsPose;\r\n    }\r\n\r\n    /**\r\n     * Gets movement speed\r\n     */\r\n    public get movementSpeed(): number {\r\n        return this._featureContext.movementSpeed;\r\n    }\r\n\r\n    /**\r\n     * Sets movement speed\r\n     * @param movementSpeed movement speed\r\n     */\r\n    public set movementSpeed(movementSpeed: number) {\r\n        this._featureContext.movementSpeed = movementSpeed;\r\n    }\r\n\r\n    /**\r\n     * Gets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for movement (avoids jitter/unintentional movement)\r\n     */\r\n    public get movementThreshold(): number {\r\n        return this._featureContext.movementThreshold;\r\n    }\r\n\r\n    /**\r\n     * Sets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for movement (avoids jitter/unintentional movement)\r\n     * @param movementThreshold new threshold\r\n     */\r\n    public set movementThreshold(movementThreshold: number) {\r\n        this._featureContext.movementThreshold = movementThreshold;\r\n    }\r\n\r\n    /**\r\n     * Is rotation enabled\r\n     */\r\n    public get rotationEnabled(): boolean {\r\n        return this._featureContext.rotationEnabled;\r\n    }\r\n\r\n    /**\r\n     * Sets whether rotation is enabled or not\r\n     * @param enabled is rotation enabled\r\n     */\r\n    public set rotationEnabled(enabled: boolean) {\r\n        this._featureContext.rotationEnabled = enabled;\r\n    }\r\n\r\n    /**\r\n     * Gets rotation speed factor\r\n     */\r\n    public get rotationSpeed(): number {\r\n        return this._featureContext.rotationSpeed;\r\n    }\r\n\r\n    /**\r\n     * Sets rotation speed factor (1.0 is default)\r\n     * @param rotationSpeed new rotation speed factor\r\n     */\r\n    public set rotationSpeed(rotationSpeed: number) {\r\n        this._featureContext.rotationSpeed = rotationSpeed;\r\n    }\r\n\r\n    /**\r\n     * Gets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for rotation (avoids jitter/unintentional rotation)\r\n     */\r\n    public get rotationThreshold(): number {\r\n        return this._featureContext.rotationThreshold;\r\n    }\r\n\r\n    /**\r\n     * Sets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for rotation (avoids jitter/unintentional rotation)\r\n     * @param threshold new threshold\r\n     */\r\n    public set rotationThreshold(threshold: number) {\r\n        this._featureContext.rotationThreshold = threshold;\r\n    }\r\n    /**\r\n     * constructs a new movement controller system\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param options configuration object for this feature\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, options: IWebXRControllerMovementOptions) {\r\n        super(_xrSessionManager);\r\n\r\n        if (!options || options.xrInput === undefined) {\r\n            Tools.Error('WebXRControllerMovement feature requires \"xrInput\" option.');\r\n            return;\r\n        }\r\n\r\n        if (Array.isArray(options.customRegistrationConfigurations)) {\r\n            this._currentRegistrationConfigurations = options.customRegistrationConfigurations;\r\n        } else {\r\n            this._currentRegistrationConfigurations = WebXRControllerMovement.REGISTRATIONS.default;\r\n        }\r\n\r\n        // synchronized from feature setter properties\r\n        this._featureContext = {\r\n            movementEnabled: options.movementEnabled || true,\r\n            movementOrientationFollowsViewerPose: options.movementOrientationFollowsViewerPose ?? true,\r\n            movementSpeed: options.movementSpeed ?? 1,\r\n            movementThreshold: options.movementThreshold ?? 0.25,\r\n            rotationEnabled: options.rotationEnabled ?? true,\r\n            rotationSpeed: options.rotationSpeed ?? 1.0,\r\n            rotationThreshold: options.rotationThreshold ?? 0.25,\r\n        };\r\n\r\n        this._movementState = {\r\n            moveX: 0,\r\n            moveY: 0,\r\n            rotateX: 0,\r\n            rotateY: 0,\r\n        };\r\n\r\n        this._xrInput = options.xrInput;\r\n    }\r\n\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        this._xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._xrInput.onControllerRemovedObservable, (controller: WebXRInputSource) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        this._controllers = {};\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Occurs on every XR frame.\r\n     * @param _xrFrame\r\n     */\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        if (!this.attached) {\r\n            return;\r\n        }\r\n\r\n        if (this._movementState.rotateX !== 0 && this._featureContext.rotationEnabled) {\r\n            // smooth rotation\r\n            const deltaMillis = this._xrSessionManager.scene.getEngine().getDeltaTime();\r\n            const rotationY = deltaMillis * 0.001 * this._featureContext.rotationSpeed * this._movementState.rotateX * (this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);\r\n\r\n            if (this._featureContext.movementOrientationFollowsViewerPose) {\r\n                this._xrInput.xrCamera.cameraRotation.y += rotationY;\r\n                Quaternion.RotationYawPitchRollToRef(rotationY, 0, 0, this._tempCacheQuaternion);\r\n                this._xrInput.xrCamera.rotationQuaternion.multiplyToRef(this._tempCacheQuaternion, this._movementDirection);\r\n            } else {\r\n                // movement orientation direction does not affect camera.  We use rotation speed multiplier\r\n                // otherwise need to implement inertia and constraints for same feel as TargetCamera.\r\n\r\n                Quaternion.RotationYawPitchRollToRef(rotationY * 3.0, 0, 0, this._tempCacheQuaternion);\r\n                this._movementDirection.multiplyInPlace(this._tempCacheQuaternion);\r\n            }\r\n        } else if (this._featureContext.movementOrientationFollowsViewerPose) {\r\n            this._movementDirection.copyFrom(this._xrInput.xrCamera.rotationQuaternion);\r\n        }\r\n\r\n        if ((this._movementState.moveX || this._movementState.moveY) && this._featureContext.movementEnabled) {\r\n            Matrix.FromQuaternionToRef(this._movementDirection, this._tmpRotationMatrix);\r\n            this._tmpTranslationDirection.set(this._movementState.moveX, 0, this._movementState.moveY * (this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0));\r\n            // move according to forward direction based on camera speed\r\n            Vector3.TransformCoordinatesToRef(this._tmpTranslationDirection, this._tmpRotationMatrix, this._tmpMovementTranslation);\r\n            this._tmpMovementTranslation.scaleInPlace(this._xrInput.xrCamera._computeLocalCameraSpeed() * this._featureContext.movementSpeed);\r\n\r\n            this._xrInput.xrCamera.cameraDirection.addInPlace(this._tmpMovementTranslation);\r\n        }\r\n    }\r\n\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId]) {\r\n            // already attached\r\n            return;\r\n        }\r\n\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            registeredComponents: [],\r\n        };\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n\r\n        // movement controller only available to gamepad-enabled input sources.\r\n        if (controllerData.xrController.inputSource.targetRayMode === \"tracked-pointer\" && controllerData.xrController.inputSource.gamepad) {\r\n            // motion controller support\r\n            const initController = () => {\r\n                if (xrController.motionController) {\r\n                    for (const registration of this._currentRegistrationConfigurations) {\r\n                        let component: Nullable<WebXRControllerComponent> = null;\r\n\r\n                        if (registration.allowedComponentTypes) {\r\n                            for (const componentType of registration.allowedComponentTypes) {\r\n                                const componentOfType = xrController.motionController.getComponentOfType(componentType);\r\n                                if (componentOfType !== null) {\r\n                                    component = componentOfType;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        if (registration.mainComponentOnly) {\r\n                            const mainComponent = xrController.motionController.getMainComponent();\r\n                            if (mainComponent === null) {\r\n                                continue;\r\n                            }\r\n                            component = mainComponent;\r\n                        }\r\n\r\n                        if (typeof registration.componentSelectionPredicate === \"function\") {\r\n                            // if does not match we do want to ignore a previously found component\r\n                            component = registration.componentSelectionPredicate(xrController);\r\n                        }\r\n\r\n                        if (component && registration.forceHandedness) {\r\n                            if (xrController.inputSource.handedness !== registration.forceHandedness) {\r\n                                continue; // do not register\r\n                            }\r\n                        }\r\n\r\n                        if (component === null) {\r\n                            continue; // do not register\r\n                        }\r\n\r\n                        const registeredComponent: RegisteredComponent = {\r\n                            registrationConfiguration: registration,\r\n                            component,\r\n                        };\r\n                        controllerData.registeredComponents.push(registeredComponent);\r\n\r\n                        if (\"axisChangedHandler\" in registration) {\r\n                            registeredComponent.onAxisChangedObserver = component.onAxisValueChangedObservable.add((axesData) => {\r\n                                registration.axisChangedHandler(axesData, this._movementState, this._featureContext, this._xrInput);\r\n                            });\r\n                        }\r\n\r\n                        if (\"buttonChangedhandler\" in registration) {\r\n                            registeredComponent.onButtonChangedObserver = component.onButtonStateChangedObservable.add(() => {\r\n                                if (component!.changes.pressed) {\r\n                                    registration.buttonChangedhandler(component!.changes.pressed, this._movementState, this._featureContext, this._xrInput);\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n\r\n            if (xrController.motionController) {\r\n                initController();\r\n            } else {\r\n                xrController.onMotionControllerInitObservable.addOnce(() => {\r\n                    initController();\r\n                });\r\n            }\r\n        }\r\n    };\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n\r\n        for (const registeredComponent of controllerData.registeredComponents) {\r\n            if (registeredComponent.onAxisChangedObserver) {\r\n                registeredComponent.component.onAxisValueChangedObservable.remove(registeredComponent.onAxisChangedObserver);\r\n            }\r\n            if (registeredComponent.onButtonChangedObserver) {\r\n                registeredComponent.component.onButtonStateChangedObservable.remove(registeredComponent.onButtonChangedObserver);\r\n            }\r\n        }\r\n\r\n        // remove from the map\r\n        delete this._controllers[xrControllerUniqueId];\r\n    }\r\n}\r\n\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRControllerMovement.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRControllerMovement(xrSessionManager, options);\r\n    },\r\n    WebXRControllerMovement.Version,\r\n    true\r\n);\r\n"],"mappings":";AAAA,SAASA,oBAAoB,EAAEC,gBAAgB,QAAQ,4BAA0B;AAOjF,SAASC,wBAAwB,QAAQ,iDAA+C;AACxF,SAASC,MAAM,EAAEC,UAAU,EAAEC,OAAO,QAAQ,4BAA0B;AACtE,SAASC,oBAAoB,QAAQ,2BAAyB;AAE9D,SAASC,KAAK,QAAQ,qBAAmB;AAuHzC;;;;;AAKA,OAAM,MAAOC,uBAAwB,SAAQF,oBAAoB;EA0D7D;;;EAGA,IAAWG,iBAAiBA,CAAA;IACxB,OAAO,IAAI,CAACC,kBAAkB;EAClC;EAEA;;;EAGA,IAAWC,eAAeA,CAAA;IACtB,OAAO,IAAI,CAACC,eAAe,CAACD,eAAe;EAC/C;EAEA;;;;EAIA,IAAWA,eAAeA,CAACE,OAAgB;IACvC,IAAI,CAACD,eAAe,CAACD,eAAe,GAAGE,OAAO;EAClD;EAEA;;;EAGA,IAAWC,oCAAoCA,CAAA;IAC3C,OAAO,IAAI,CAACF,eAAe,CAACE,oCAAoC;EACpE;EAEA;;;;EAIA,IAAWA,oCAAoCA,CAACC,WAAoB;IAChE,IAAI,CAACH,eAAe,CAACE,oCAAoC,GAAGC,WAAW;EAC3E;EAEA;;;EAGA,IAAWC,aAAaA,CAAA;IACpB,OAAO,IAAI,CAACJ,eAAe,CAACI,aAAa;EAC7C;EAEA;;;;EAIA,IAAWA,aAAaA,CAACA,aAAqB;IAC1C,IAAI,CAACJ,eAAe,CAACI,aAAa,GAAGA,aAAa;EACtD;EAEA;;;EAGA,IAAWC,iBAAiBA,CAAA;IACxB,OAAO,IAAI,CAACL,eAAe,CAACK,iBAAiB;EACjD;EAEA;;;;EAIA,IAAWA,iBAAiBA,CAACA,iBAAyB;IAClD,IAAI,CAACL,eAAe,CAACK,iBAAiB,GAAGA,iBAAiB;EAC9D;EAEA;;;EAGA,IAAWC,eAAeA,CAAA;IACtB,OAAO,IAAI,CAACN,eAAe,CAACM,eAAe;EAC/C;EAEA;;;;EAIA,IAAWA,eAAeA,CAACL,OAAgB;IACvC,IAAI,CAACD,eAAe,CAACM,eAAe,GAAGL,OAAO;EAClD;EAEA;;;EAGA,IAAWM,aAAaA,CAAA;IACpB,OAAO,IAAI,CAACP,eAAe,CAACO,aAAa;EAC7C;EAEA;;;;EAIA,IAAWA,aAAaA,CAACA,aAAqB;IAC1C,IAAI,CAACP,eAAe,CAACO,aAAa,GAAGA,aAAa;EACtD;EAEA;;;EAGA,IAAWC,iBAAiBA,CAAA;IACxB,OAAO,IAAI,CAACR,eAAe,CAACQ,iBAAiB;EACjD;EAEA;;;;EAIA,IAAWA,iBAAiBA,CAACC,SAAiB;IAC1C,IAAI,CAACT,eAAe,CAACQ,iBAAiB,GAAGC,SAAS;EACtD;EACA;;;;;EAKAC,YAAYC,iBAAsC,EAAEC,OAAwC;;IACxF,KAAK,CAACD,iBAAiB,CAAC;IA9KpB,KAAAE,YAAY,GAKhB,EAAE;IAEE,KAAAC,kCAAkC,GAAuD,EAAE;IAGnG;IACQ,KAAAhB,kBAAkB,GAAe,IAAIN,UAAU,EAAE;IAIzD;IACQ,KAAAuB,kBAAkB,GAAWxB,MAAM,CAACyB,QAAQ,EAAE;IAC9C,KAAAC,wBAAwB,GAAY,IAAIxB,OAAO,EAAE;IACjD,KAAAyB,uBAAuB,GAAY,IAAIzB,OAAO,EAAE;IAChD,KAAA0B,oBAAoB,GAAe,IAAI3B,UAAU,EAAE;IAkQnD,KAAA4B,iBAAiB,GAAIC,YAA8B,IAAI;MAC3D,IAAI,IAAI,CAACR,YAAY,CAACQ,YAAY,CAACC,QAAQ,CAAC,EAAE;QAC1C;QACA;;MAGJ,IAAI,CAACT,YAAY,CAACQ,YAAY,CAACC,QAAQ,CAAC,GAAG;QACvCD,YAAY;QACZE,oBAAoB,EAAE;OACzB;MACD,MAAMC,cAAc,GAAG,IAAI,CAACX,YAAY,CAACQ,YAAY,CAACC,QAAQ,CAAC;MAE/D;MACA,IAAIE,cAAc,CAACH,YAAY,CAACI,WAAW,CAACC,aAAa,KAAK,iBAAiB,IAAIF,cAAc,CAACH,YAAY,CAACI,WAAW,CAACE,OAAO,EAAE;QAChI;QACA,MAAMC,cAAc,GAAGA,CAAA,KAAK;UACxB,IAAIP,YAAY,CAACQ,gBAAgB,EAAE;YAC/B,KAAK,MAAMC,YAAY,IAAI,IAAI,CAAChB,kCAAkC,EAAE;cAChE,IAAIiB,SAAS,GAAuC,IAAI;cAExD,IAAID,YAAY,CAACE,qBAAqB,EAAE;gBACpC,KAAK,MAAMC,aAAa,IAAIH,YAAY,CAACE,qBAAqB,EAAE;kBAC5D,MAAME,eAAe,GAAGb,YAAY,CAACQ,gBAAgB,CAACM,kBAAkB,CAACF,aAAa,CAAC;kBACvF,IAAIC,eAAe,KAAK,IAAI,EAAE;oBAC1BH,SAAS,GAAGG,eAAe;oBAC3B;;;;cAKZ,IAAIJ,YAAY,CAACM,iBAAiB,EAAE;gBAChC,MAAMC,aAAa,GAAGhB,YAAY,CAACQ,gBAAgB,CAACS,gBAAgB,EAAE;gBACtE,IAAID,aAAa,KAAK,IAAI,EAAE;kBACxB;;gBAEJN,SAAS,GAAGM,aAAa;;cAG7B,IAAI,OAAOP,YAAY,CAACS,2BAA2B,KAAK,UAAU,EAAE;gBAChE;gBACAR,SAAS,GAAGD,YAAY,CAACS,2BAA2B,CAAClB,YAAY,CAAC;;cAGtE,IAAIU,SAAS,IAAID,YAAY,CAACU,eAAe,EAAE;gBAC3C,IAAInB,YAAY,CAACI,WAAW,CAACgB,UAAU,KAAKX,YAAY,CAACU,eAAe,EAAE;kBACtE,SAAS,CAAC;;;;cAIlB,IAAIT,SAAS,KAAK,IAAI,EAAE;gBACpB,SAAS,CAAC;;;cAGd,MAAMW,mBAAmB,GAAwB;gBAC7CC,yBAAyB,EAAEb,YAAY;gBACvCC;eACH;cACDP,cAAc,CAACD,oBAAoB,CAACqB,IAAI,CAACF,mBAAmB,CAAC;cAE7D,IAAI,oBAAoB,IAAIZ,YAAY,EAAE;gBACtCY,mBAAmB,CAACG,qBAAqB,GAAGd,SAAS,CAACe,4BAA4B,CAACC,GAAG,CAAEC,QAAQ,IAAI;kBAChGlB,YAAY,CAACmB,kBAAkB,CAACD,QAAQ,EAAE,IAAI,CAACE,cAAc,EAAE,IAAI,CAAClD,eAAe,EAAE,IAAI,CAACmD,QAAQ,CAAC;gBACvG,CAAC,CAAC;;cAGN,IAAI,sBAAsB,IAAIrB,YAAY,EAAE;gBACxCY,mBAAmB,CAACU,uBAAuB,GAAGrB,SAAS,CAACsB,8BAA8B,CAACN,GAAG,CAAC,MAAK;kBAC5F,IAAIhB,SAAU,CAACuB,OAAO,CAACC,OAAO,EAAE;oBAC5BzB,YAAY,CAAC0B,oBAAoB,CAACzB,SAAU,CAACuB,OAAO,CAACC,OAAO,EAAE,IAAI,CAACL,cAAc,EAAE,IAAI,CAAClD,eAAe,EAAE,IAAI,CAACmD,QAAQ,CAAC;;gBAE/H,CAAC,CAAC;;;;QAIlB,CAAC;QAED,IAAI9B,YAAY,CAACQ,gBAAgB,EAAE;UAC/BD,cAAc,EAAE;SACnB,MAAM;UACHP,YAAY,CAACoC,gCAAgC,CAACC,OAAO,CAAC,MAAK;YACvD9B,cAAc,EAAE;UACpB,CAAC,CAAC;;;IAGd,CAAC;IAzLG,IAAI,CAAChB,OAAO,IAAIA,OAAO,CAAC+C,OAAO,KAAKC,SAAS,EAAE;MAC3CjE,KAAK,CAACkE,KAAK,CAAC,4DAA4D,CAAC;MACzE;;IAGJ,IAAIC,KAAK,CAACC,OAAO,CAACnD,OAAO,CAACoD,gCAAgC,CAAC,EAAE;MACzD,IAAI,CAAClD,kCAAkC,GAAGF,OAAO,CAACoD,gCAAgC;KACrF,MAAM;MACH,IAAI,CAAClD,kCAAkC,GAAGlB,uBAAuB,CAACqE,aAAa,CAACC,OAAO;;IAG3F;IACA,IAAI,CAAClE,eAAe,GAAG;MACnBD,eAAe,EAAEa,OAAO,CAACb,eAAe,IAAI,IAAI;MAChDG,oCAAoC,EAAE,CAAAiE,EAAA,GAAAvD,OAAO,CAACV,oCAAoC,cAAAiE,EAAA,cAAAA,EAAA,GAAI,IAAI;MAC1F/D,aAAa,EAAE,CAAAgE,EAAA,GAAAxD,OAAO,CAACR,aAAa,cAAAgE,EAAA,cAAAA,EAAA,GAAI,CAAC;MACzC/D,iBAAiB,EAAE,CAAAgE,EAAA,GAAAzD,OAAO,CAACP,iBAAiB,cAAAgE,EAAA,cAAAA,EAAA,GAAI,IAAI;MACpD/D,eAAe,EAAE,CAAAgE,EAAA,GAAA1D,OAAO,CAACN,eAAe,cAAAgE,EAAA,cAAAA,EAAA,GAAI,IAAI;MAChD/D,aAAa,EAAE,CAAAgE,EAAA,GAAA3D,OAAO,CAACL,aAAa,cAAAgE,EAAA,cAAAA,EAAA,GAAI,GAAG;MAC3C/D,iBAAiB,EAAE,CAAAgE,EAAA,GAAA5D,OAAO,CAACJ,iBAAiB,cAAAgE,EAAA,cAAAA,EAAA,GAAI;KACnD;IAED,IAAI,CAACtB,cAAc,GAAG;MAClBuB,KAAK,EAAE,CAAC;MACRC,KAAK,EAAE,CAAC;MACRC,OAAO,EAAE,CAAC;MACVC,OAAO,EAAE;KACZ;IAED,IAAI,CAACzB,QAAQ,GAAGvC,OAAO,CAAC+C,OAAO;EACnC;EAEOkB,MAAMA,CAAA;IACT,IAAI,CAAC,KAAK,CAACA,MAAM,EAAE,EAAE;MACjB,OAAO,KAAK;;IAGhB,IAAI,CAAC1B,QAAQ,CAAC2B,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC3D,iBAAiB,CAAC;IACzD,IAAI,CAAC4D,qBAAqB,CAAC,IAAI,CAAC7B,QAAQ,CAAC8B,2BAA2B,EAAE,IAAI,CAAC7D,iBAAiB,CAAC;IAC7F,IAAI,CAAC4D,qBAAqB,CAAC,IAAI,CAAC7B,QAAQ,CAAC+B,6BAA6B,EAAGC,UAA4B,IAAI;MACrG;MACA,IAAI,CAACC,iBAAiB,CAACD,UAAU,CAAC7D,QAAQ,CAAC;IAC/C,CAAC,CAAC;IAEF,OAAO,IAAI;EACf;EAEO+D,MAAMA,CAAA;IACT,IAAI,CAAC,KAAK,CAACA,MAAM,EAAE,EAAE;MACjB,OAAO,KAAK;;IAGhBC,MAAM,CAACC,IAAI,CAAC,IAAI,CAAC1E,YAAY,CAAC,CAACkE,OAAO,CAAES,YAAY,IAAI;MACpD,IAAI,CAACJ,iBAAiB,CAACI,YAAY,CAAC;IACxC,CAAC,CAAC;IAEF,IAAI,CAAC3E,YAAY,GAAG,EAAE;IAEtB,OAAO,IAAI;EACf;EAEA;;;;EAIU4E,UAAUA,CAACC,QAAiB;IAClC,IAAI,CAAC,IAAI,CAACC,QAAQ,EAAE;MAChB;;IAGJ,IAAI,IAAI,CAACzC,cAAc,CAACyB,OAAO,KAAK,CAAC,IAAI,IAAI,CAAC3E,eAAe,CAACM,eAAe,EAAE;MAC3E;MACA,MAAMsF,WAAW,GAAG,IAAI,CAACjF,iBAAiB,CAACkF,KAAK,CAACC,SAAS,EAAE,CAACC,YAAY,EAAE;MAC3E,MAAMC,SAAS,GAAGJ,WAAW,GAAG,KAAK,GAAG,IAAI,CAAC5F,eAAe,CAACO,aAAa,GAAG,IAAI,CAAC2C,cAAc,CAACyB,OAAO,IAAI,IAAI,CAAChE,iBAAiB,CAACkF,KAAK,CAACI,oBAAoB,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;MAEvK,IAAI,IAAI,CAACjG,eAAe,CAACE,oCAAoC,EAAE;QAC3D,IAAI,CAACiD,QAAQ,CAAC+C,QAAQ,CAACC,cAAc,CAACC,CAAC,IAAIJ,SAAS;QACpDxG,UAAU,CAAC6G,yBAAyB,CAACL,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC7E,oBAAoB,CAAC;QAChF,IAAI,CAACgC,QAAQ,CAAC+C,QAAQ,CAACI,kBAAkB,CAACC,aAAa,CAAC,IAAI,CAACpF,oBAAoB,EAAE,IAAI,CAACrB,kBAAkB,CAAC;OAC9G,MAAM;QACH;QACA;QAEAN,UAAU,CAAC6G,yBAAyB,CAACL,SAAS,GAAG,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC7E,oBAAoB,CAAC;QACtF,IAAI,CAACrB,kBAAkB,CAAC0G,eAAe,CAAC,IAAI,CAACrF,oBAAoB,CAAC;;KAEzE,MAAM,IAAI,IAAI,CAACnB,eAAe,CAACE,oCAAoC,EAAE;MAClE,IAAI,CAACJ,kBAAkB,CAAC2G,QAAQ,CAAC,IAAI,CAACtD,QAAQ,CAAC+C,QAAQ,CAACI,kBAAkB,CAAC;;IAG/E,IAAI,CAAC,IAAI,CAACpD,cAAc,CAACuB,KAAK,IAAI,IAAI,CAACvB,cAAc,CAACwB,KAAK,KAAK,IAAI,CAAC1E,eAAe,CAACD,eAAe,EAAE;MAClGR,MAAM,CAACmH,mBAAmB,CAAC,IAAI,CAAC5G,kBAAkB,EAAE,IAAI,CAACiB,kBAAkB,CAAC;MAC5E,IAAI,CAACE,wBAAwB,CAAC0F,GAAG,CAAC,IAAI,CAACzD,cAAc,CAACuB,KAAK,EAAE,CAAC,EAAE,IAAI,CAACvB,cAAc,CAACwB,KAAK,IAAI,IAAI,CAAC/D,iBAAiB,CAACkF,KAAK,CAACI,oBAAoB,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;MAC7J;MACAxG,OAAO,CAACmH,yBAAyB,CAAC,IAAI,CAAC3F,wBAAwB,EAAE,IAAI,CAACF,kBAAkB,EAAE,IAAI,CAACG,uBAAuB,CAAC;MACvH,IAAI,CAACA,uBAAuB,CAAC2F,YAAY,CAAC,IAAI,CAAC1D,QAAQ,CAAC+C,QAAQ,CAACY,wBAAwB,EAAE,GAAG,IAAI,CAAC9G,eAAe,CAACI,aAAa,CAAC;MAEjI,IAAI,CAAC+C,QAAQ,CAAC+C,QAAQ,CAACa,eAAe,CAACC,UAAU,CAAC,IAAI,CAAC9F,uBAAuB,CAAC;;EAEvF;EAwFQkE,iBAAiBA,CAAC6B,oBAA4B;IAClD,MAAMzF,cAAc,GAAG,IAAI,CAACX,YAAY,CAACoG,oBAAoB,CAAC;IAC9D,IAAI,CAACzF,cAAc,EAAE;MACjB;;IAGJ,KAAK,MAAMkB,mBAAmB,IAAIlB,cAAc,CAACD,oBAAoB,EAAE;MACnE,IAAImB,mBAAmB,CAACG,qBAAqB,EAAE;QAC3CH,mBAAmB,CAACX,SAAS,CAACe,4BAA4B,CAACoE,MAAM,CAACxE,mBAAmB,CAACG,qBAAqB,CAAC;;MAEhH,IAAIH,mBAAmB,CAACU,uBAAuB,EAAE;QAC7CV,mBAAmB,CAACX,SAAS,CAACsB,8BAA8B,CAAC6D,MAAM,CAACxE,mBAAmB,CAACU,uBAAuB,CAAC;;;IAIxH;IACA,OAAO,IAAI,CAACvC,YAAY,CAACoG,oBAAoB,CAAC;EAClD;;AAvWA;;;AAGuBrH,uBAAA,CAAAuH,IAAI,GAAG9H,gBAAgB,CAAC+H,QAAQ;AAEvD;;;AAGuBxH,uBAAA,CAAAqE,aAAa,GAA0E;EAC1GC,OAAO,EAAE,CACL;IACIlC,qBAAqB,EAAE,CAAC1C,wBAAwB,CAAC+H,eAAe,EAAE/H,wBAAwB,CAACgI,aAAa,CAAC;IACzG9E,eAAe,EAAE,MAAM;IACvBS,kBAAkB,EAAEA,CAACsE,IAAqC,EAAEC,aAA2C,EAAEC,cAAqD,KAAI;MAC9JD,aAAa,CAAC7C,OAAO,GAAG+C,IAAI,CAACC,GAAG,CAACJ,IAAI,CAACK,CAAC,CAAC,GAAGH,cAAc,CAACjH,iBAAiB,GAAG+G,IAAI,CAACK,CAAC,GAAG,CAAC;MACxFJ,aAAa,CAAC5C,OAAO,GAAG8C,IAAI,CAACC,GAAG,CAACJ,IAAI,CAACnB,CAAC,CAAC,GAAGqB,cAAc,CAACjH,iBAAiB,GAAG+G,IAAI,CAACnB,CAAC,GAAG,CAAC;IAC5F;GACH,EACD;IACIpE,qBAAqB,EAAE,CAAC1C,wBAAwB,CAAC+H,eAAe,EAAE/H,wBAAwB,CAACgI,aAAa,CAAC;IACzG9E,eAAe,EAAE,OAAO;IACxBS,kBAAkB,EAAEA,CAACsE,IAAqC,EAAEC,aAA2C,EAAEC,cAAqD,KAAI;MAC9JD,aAAa,CAAC/C,KAAK,GAAGiD,IAAI,CAACC,GAAG,CAACJ,IAAI,CAACK,CAAC,CAAC,GAAGH,cAAc,CAACpH,iBAAiB,GAAGkH,IAAI,CAACK,CAAC,GAAG,CAAC;MACtFJ,aAAa,CAAC9C,KAAK,GAAGgD,IAAI,CAACC,GAAG,CAACJ,IAAI,CAACnB,CAAC,CAAC,GAAGqB,cAAc,CAACpH,iBAAiB,GAAGkH,IAAI,CAACnB,CAAC,GAAG,CAAC;IAC1F;GACH;CAER;AAED;;;;;AAKuBxG,uBAAA,CAAAiI,OAAO,GAAG,CAAC;AAwUtCzI,oBAAoB,CAAC0I,eAAe,CAChClI,uBAAuB,CAACuH,IAAI,EAC5B,CAACY,gBAAgB,EAAEnH,OAAO,KAAI;EAC1B,OAAO,MAAM,IAAIhB,uBAAuB,CAACmI,gBAAgB,EAAEnH,OAAO,CAAC;AACvE,CAAC,EACDhB,uBAAuB,CAACiI,OAAO,EAC/B,IAAI,CACP"},"metadata":{},"sourceType":"module","externalDependencies":[]}