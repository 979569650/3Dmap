{"ast":null,"code":"import { RenderingGroup } from \"./renderingGroup.js\";\n/**\n * This class is used by the onRenderingGroupObservable\n */\nexport class RenderingGroupInfo {}\n/**\n * This is the manager responsible of all the rendering for meshes sprites and particles.\n * It is enable to manage the different groups as well as the different necessary sort functions.\n * This should not be used directly aside of the few static configurations\n */\nexport class RenderingManager {\n  /**\n   * Gets or sets a boolean indicating that the manager will not reset between frames.\n   * This means that if a mesh becomes invisible or transparent it will not be visible until this boolean is set to false again.\n   * By default, the rendering manager will dispatch all active meshes per frame (moving them to the transparent, opaque or alpha testing lists).\n   * By turning this property on, you will accelerate the rendering by keeping all these lists unchanged between frames.\n   */\n  get maintainStateBetweenFrames() {\n    return this._maintainStateBetweenFrames;\n  }\n  set maintainStateBetweenFrames(value) {\n    if (value === this._maintainStateBetweenFrames) {\n      return;\n    }\n    this._maintainStateBetweenFrames = value;\n    // Restore wasDispatched flags when switching to maintainStateBetweenFrames to false\n    if (!this._maintainStateBetweenFrames) {\n      for (const mesh of this._scene.meshes) {\n        if (mesh.subMeshes) {\n          for (const subMesh of mesh.subMeshes) {\n            subMesh._wasDispatched = false;\n          }\n        }\n      }\n      if (this._scene.spriteManagers) {\n        for (const spriteManager of this._scene.spriteManagers) {\n          spriteManager._wasDispatched = false;\n        }\n      }\n      for (const particleSystem of this._scene.particleSystems) {\n        particleSystem._wasDispatched = false;\n      }\n    }\n  }\n  /**\n   * Instantiates a new rendering group for a particular scene\n   * @param scene Defines the scene the groups belongs to\n   */\n  constructor(scene) {\n    /**\n     * @internal\n     */\n    this._useSceneAutoClearSetup = false;\n    this._renderingGroups = new Array();\n    this._autoClearDepthStencil = {};\n    this._customOpaqueSortCompareFn = {};\n    this._customAlphaTestSortCompareFn = {};\n    this._customTransparentSortCompareFn = {};\n    this._renderingGroupInfo = new RenderingGroupInfo();\n    this._maintainStateBetweenFrames = false;\n    this._scene = scene;\n    for (let i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {\n      this._autoClearDepthStencil[i] = {\n        autoClear: true,\n        depth: true,\n        stencil: true\n      };\n    }\n  }\n  /**\n   * Gets the rendering group with the specified id.\n   */\n  getRenderingGroup(id) {\n    const renderingGroupId = id || 0;\n    this._prepareRenderingGroup(renderingGroupId);\n    return this._renderingGroups[renderingGroupId];\n  }\n  _clearDepthStencilBuffer(depth = true, stencil = true) {\n    if (this._depthStencilBufferAlreadyCleaned) {\n      return;\n    }\n    this._scene.getEngine().clear(null, false, depth, stencil);\n    this._depthStencilBufferAlreadyCleaned = true;\n  }\n  /**\n   * Renders the entire managed groups. This is used by the scene or the different render targets.\n   * @internal\n   */\n  render(customRenderFunction, activeMeshes, renderParticles, renderSprites) {\n    // Update the observable context (not null as it only goes away on dispose)\n    const info = this._renderingGroupInfo;\n    info.scene = this._scene;\n    info.camera = this._scene.activeCamera;\n    // Dispatch sprites\n    if (this._scene.spriteManagers && renderSprites) {\n      for (let index = 0; index < this._scene.spriteManagers.length; index++) {\n        const manager = this._scene.spriteManagers[index];\n        this.dispatchSprites(manager);\n      }\n    }\n    // Render\n    for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n      this._depthStencilBufferAlreadyCleaned = index === RenderingManager.MIN_RENDERINGGROUPS;\n      const renderingGroup = this._renderingGroups[index];\n      if (!renderingGroup || renderingGroup._empty) {\n        continue;\n      }\n      const renderingGroupMask = Math.pow(2, index);\n      info.renderingGroupId = index;\n      // Before Observable\n      this._scene.onBeforeRenderingGroupObservable.notifyObservers(info, renderingGroupMask);\n      // Clear depth/stencil if needed\n      if (RenderingManager.AUTOCLEAR) {\n        const autoClear = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(index) : this._autoClearDepthStencil[index];\n        if (autoClear && autoClear.autoClear) {\n          this._clearDepthStencilBuffer(autoClear.depth, autoClear.stencil);\n        }\n      }\n      // Render\n      for (const step of this._scene._beforeRenderingGroupDrawStage) {\n        step.action(index);\n      }\n      renderingGroup.render(customRenderFunction, renderSprites, renderParticles, activeMeshes);\n      for (const step of this._scene._afterRenderingGroupDrawStage) {\n        step.action(index);\n      }\n      // After Observable\n      this._scene.onAfterRenderingGroupObservable.notifyObservers(info, renderingGroupMask);\n    }\n  }\n  /**\n   * Resets the different information of the group to prepare a new frame\n   * @internal\n   */\n  reset() {\n    if (this.maintainStateBetweenFrames) {\n      return;\n    }\n    for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n      const renderingGroup = this._renderingGroups[index];\n      if (renderingGroup) {\n        renderingGroup.prepare();\n      }\n    }\n  }\n  /**\n   * Resets the sprites information of the group to prepare a new frame\n   * @internal\n   */\n  resetSprites() {\n    if (this.maintainStateBetweenFrames) {\n      return;\n    }\n    for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n      const renderingGroup = this._renderingGroups[index];\n      if (renderingGroup) {\n        renderingGroup.prepareSprites();\n      }\n    }\n  }\n  /**\n   * Dispose and release the group and its associated resources.\n   * @internal\n   */\n  dispose() {\n    this.freeRenderingGroups();\n    this._renderingGroups.length = 0;\n    this._renderingGroupInfo = null;\n  }\n  /**\n   * Clear the info related to rendering groups preventing retention points during dispose.\n   */\n  freeRenderingGroups() {\n    for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n      const renderingGroup = this._renderingGroups[index];\n      if (renderingGroup) {\n        renderingGroup.dispose();\n      }\n    }\n  }\n  _prepareRenderingGroup(renderingGroupId) {\n    if (this._renderingGroups[renderingGroupId] === undefined) {\n      this._renderingGroups[renderingGroupId] = new RenderingGroup(renderingGroupId, this._scene, this._customOpaqueSortCompareFn[renderingGroupId], this._customAlphaTestSortCompareFn[renderingGroupId], this._customTransparentSortCompareFn[renderingGroupId]);\n    }\n  }\n  /**\n   * Add a sprite manager to the rendering manager in order to render it this frame.\n   * @param spriteManager Define the sprite manager to render\n   */\n  dispatchSprites(spriteManager) {\n    if (this.maintainStateBetweenFrames && spriteManager._wasDispatched) {\n      return;\n    }\n    spriteManager._wasDispatched = true;\n    this.getRenderingGroup(spriteManager.renderingGroupId).dispatchSprites(spriteManager);\n  }\n  /**\n   * Add a particle system to the rendering manager in order to render it this frame.\n   * @param particleSystem Define the particle system to render\n   */\n  dispatchParticles(particleSystem) {\n    if (this.maintainStateBetweenFrames && particleSystem._wasDispatched) {\n      return;\n    }\n    particleSystem._wasDispatched = true;\n    this.getRenderingGroup(particleSystem.renderingGroupId).dispatchParticles(particleSystem);\n  }\n  /**\n   * Add a submesh to the manager in order to render it this frame\n   * @param subMesh The submesh to dispatch\n   * @param mesh Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\n   * @param material Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\n   */\n  dispatch(subMesh, mesh, material) {\n    if (mesh === undefined) {\n      mesh = subMesh.getMesh();\n    }\n    if (this.maintainStateBetweenFrames && subMesh._wasDispatched) {\n      return;\n    }\n    subMesh._wasDispatched = true;\n    this.getRenderingGroup(mesh.renderingGroupId).dispatch(subMesh, mesh, material);\n  }\n  /**\n   * Overrides the default sort function applied in the rendering group to prepare the meshes.\n   * This allowed control for front to back rendering or reversely depending of the special needs.\n   *\n   * @param renderingGroupId The rendering group id corresponding to its index\n   * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\n   * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\n   * @param transparentSortCompareFn The transparent queue comparison function use to sort.\n   */\n  setRenderingOrder(renderingGroupId, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {\n    this._customOpaqueSortCompareFn[renderingGroupId] = opaqueSortCompareFn;\n    this._customAlphaTestSortCompareFn[renderingGroupId] = alphaTestSortCompareFn;\n    this._customTransparentSortCompareFn[renderingGroupId] = transparentSortCompareFn;\n    if (this._renderingGroups[renderingGroupId]) {\n      const group = this._renderingGroups[renderingGroupId];\n      group.opaqueSortCompareFn = this._customOpaqueSortCompareFn[renderingGroupId];\n      group.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[renderingGroupId];\n      group.transparentSortCompareFn = this._customTransparentSortCompareFn[renderingGroupId];\n    }\n  }\n  /**\n   * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\n   *\n   * @param renderingGroupId The rendering group id corresponding to its index\n   * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\n   * @param depth Automatically clears depth between groups if true and autoClear is true.\n   * @param stencil Automatically clears stencil between groups if true and autoClear is true.\n   */\n  setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth = true, stencil = true) {\n    this._autoClearDepthStencil[renderingGroupId] = {\n      autoClear: autoClearDepthStencil,\n      depth: depth,\n      stencil: stencil\n    };\n  }\n  /**\n   * Gets the current auto clear configuration for one rendering group of the rendering\n   * manager.\n   * @param index the rendering group index to get the information for\n   * @returns The auto clear setup for the requested rendering group\n   */\n  getAutoClearDepthStencilSetup(index) {\n    return this._autoClearDepthStencil[index];\n  }\n}\n/**\n * The max id used for rendering groups (not included)\n */\nRenderingManager.MAX_RENDERINGGROUPS = 4;\n/**\n * The min id used for rendering groups (included)\n */\nRenderingManager.MIN_RENDERINGGROUPS = 0;\n/**\n * Used to globally prevent autoclearing scenes.\n */\nRenderingManager.AUTOCLEAR = true;","map":{"version":3,"names":["RenderingGroup","RenderingGroupInfo","RenderingManager","maintainStateBetweenFrames","_maintainStateBetweenFrames","value","mesh","_scene","meshes","subMeshes","subMesh","_wasDispatched","spriteManagers","spriteManager","particleSystem","particleSystems","constructor","scene","_useSceneAutoClearSetup","_renderingGroups","Array","_autoClearDepthStencil","_customOpaqueSortCompareFn","_customAlphaTestSortCompareFn","_customTransparentSortCompareFn","_renderingGroupInfo","i","MIN_RENDERINGGROUPS","MAX_RENDERINGGROUPS","autoClear","depth","stencil","getRenderingGroup","id","renderingGroupId","_prepareRenderingGroup","_clearDepthStencilBuffer","_depthStencilBufferAlreadyCleaned","getEngine","clear","render","customRenderFunction","activeMeshes","renderParticles","renderSprites","info","camera","activeCamera","index","length","manager","dispatchSprites","renderingGroup","_empty","renderingGroupMask","Math","pow","onBeforeRenderingGroupObservable","notifyObservers","AUTOCLEAR","getAutoClearDepthStencilSetup","step","_beforeRenderingGroupDrawStage","action","_afterRenderingGroupDrawStage","onAfterRenderingGroupObservable","reset","prepare","resetSprites","prepareSprites","dispose","freeRenderingGroups","undefined","dispatchParticles","dispatch","material","getMesh","setRenderingOrder","opaqueSortCompareFn","alphaTestSortCompareFn","transparentSortCompareFn","group","setRenderingAutoClearDepthStencil","autoClearDepthStencil"],"sources":["../../../../dev/core/src/Rendering/renderingManager.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport type { ISpriteManager } from \"../Sprites/spriteManager\";\r\nimport type { IParticleSystem } from \"../Particles/IParticleSystem\";\r\nimport { RenderingGroup } from \"./renderingGroup\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\n\r\n/**\r\n * Interface describing the different options available in the rendering manager\r\n * regarding Auto Clear between groups.\r\n */\r\nexport interface IRenderingManagerAutoClearSetup {\r\n    /**\r\n     * Defines whether or not autoclear is enable.\r\n     */\r\n    autoClear: boolean;\r\n    /**\r\n     * Defines whether or not to autoclear the depth buffer.\r\n     */\r\n    depth: boolean;\r\n    /**\r\n     * Defines whether or not to autoclear the stencil buffer.\r\n     */\r\n    stencil: boolean;\r\n}\r\n\r\n/**\r\n * This class is used by the onRenderingGroupObservable\r\n */\r\nexport class RenderingGroupInfo {\r\n    /**\r\n     * The Scene that being rendered\r\n     */\r\n    scene: Scene;\r\n\r\n    /**\r\n     * The camera currently used for the rendering pass\r\n     */\r\n    camera: Nullable<Camera>;\r\n\r\n    /**\r\n     * The ID of the renderingGroup being processed\r\n     */\r\n    renderingGroupId: number;\r\n}\r\n\r\n/**\r\n * This is the manager responsible of all the rendering for meshes sprites and particles.\r\n * It is enable to manage the different groups as well as the different necessary sort functions.\r\n * This should not be used directly aside of the few static configurations\r\n */\r\nexport class RenderingManager {\r\n    /**\r\n     * The max id used for rendering groups (not included)\r\n     */\r\n    public static MAX_RENDERINGGROUPS = 4;\r\n\r\n    /**\r\n     * The min id used for rendering groups (included)\r\n     */\r\n    public static MIN_RENDERINGGROUPS = 0;\r\n\r\n    /**\r\n     * Used to globally prevent autoclearing scenes.\r\n     */\r\n    public static AUTOCLEAR = true;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _useSceneAutoClearSetup = false;\r\n\r\n    private _scene: Scene;\r\n    private _renderingGroups = new Array<RenderingGroup>();\r\n    private _depthStencilBufferAlreadyCleaned: boolean;\r\n\r\n    private _autoClearDepthStencil: { [id: number]: IRenderingManagerAutoClearSetup } = {};\r\n    private _customOpaqueSortCompareFn: { [id: number]: Nullable<(a: SubMesh, b: SubMesh) => number> } = {};\r\n    private _customAlphaTestSortCompareFn: { [id: number]: Nullable<(a: SubMesh, b: SubMesh) => number> } = {};\r\n    private _customTransparentSortCompareFn: { [id: number]: Nullable<(a: SubMesh, b: SubMesh) => number> } = {};\r\n    private _renderingGroupInfo: Nullable<RenderingGroupInfo> = new RenderingGroupInfo();\r\n\r\n    private _maintainStateBetweenFrames = false;\r\n    /**\r\n     * Gets or sets a boolean indicating that the manager will not reset between frames.\r\n     * This means that if a mesh becomes invisible or transparent it will not be visible until this boolean is set to false again.\r\n     * By default, the rendering manager will dispatch all active meshes per frame (moving them to the transparent, opaque or alpha testing lists).\r\n     * By turning this property on, you will accelerate the rendering by keeping all these lists unchanged between frames.\r\n     */\r\n    public get maintainStateBetweenFrames() {\r\n        return this._maintainStateBetweenFrames;\r\n    }\r\n\r\n    public set maintainStateBetweenFrames(value: boolean) {\r\n        if (value === this._maintainStateBetweenFrames) {\r\n            return;\r\n        }\r\n\r\n        this._maintainStateBetweenFrames = value;\r\n\r\n        // Restore wasDispatched flags when switching to maintainStateBetweenFrames to false\r\n        if (!this._maintainStateBetweenFrames) {\r\n            for (const mesh of this._scene.meshes) {\r\n                if (mesh.subMeshes) {\r\n                    for (const subMesh of mesh.subMeshes) {\r\n                        subMesh._wasDispatched = false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this._scene.spriteManagers) {\r\n                for (const spriteManager of this._scene.spriteManagers) {\r\n                    spriteManager._wasDispatched = false;\r\n                }\r\n            }\r\n\r\n            for (const particleSystem of this._scene.particleSystems) {\r\n                particleSystem._wasDispatched = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new rendering group for a particular scene\r\n     * @param scene Defines the scene the groups belongs to\r\n     */\r\n    constructor(scene: Scene) {\r\n        this._scene = scene;\r\n\r\n        for (let i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {\r\n            this._autoClearDepthStencil[i] = { autoClear: true, depth: true, stencil: true };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the rendering group with the specified id.\r\n     */\r\n    public getRenderingGroup(id: number): RenderingGroup {\r\n        const renderingGroupId = id || 0;\r\n\r\n        this._prepareRenderingGroup(renderingGroupId);\r\n\r\n        return this._renderingGroups[renderingGroupId];\r\n    }\r\n\r\n    private _clearDepthStencilBuffer(depth = true, stencil = true): void {\r\n        if (this._depthStencilBufferAlreadyCleaned) {\r\n            return;\r\n        }\r\n\r\n        this._scene.getEngine().clear(null, false, depth, stencil);\r\n        this._depthStencilBufferAlreadyCleaned = true;\r\n    }\r\n\r\n    /**\r\n     * Renders the entire managed groups. This is used by the scene or the different render targets.\r\n     * @internal\r\n     */\r\n    public render(\r\n        customRenderFunction: Nullable<\r\n            (\r\n                opaqueSubMeshes: SmartArray<SubMesh>,\r\n                transparentSubMeshes: SmartArray<SubMesh>,\r\n                alphaTestSubMeshes: SmartArray<SubMesh>,\r\n                depthOnlySubMeshes: SmartArray<SubMesh>\r\n            ) => void\r\n        >,\r\n        activeMeshes: Nullable<AbstractMesh[]>,\r\n        renderParticles: boolean,\r\n        renderSprites: boolean\r\n    ): void {\r\n        // Update the observable context (not null as it only goes away on dispose)\r\n        const info = this._renderingGroupInfo!;\r\n        info.scene = this._scene;\r\n        info.camera = this._scene.activeCamera;\r\n\r\n        // Dispatch sprites\r\n        if (this._scene.spriteManagers && renderSprites) {\r\n            for (let index = 0; index < this._scene.spriteManagers.length; index++) {\r\n                const manager = this._scene.spriteManagers[index];\r\n                this.dispatchSprites(manager);\r\n            }\r\n        }\r\n\r\n        // Render\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            this._depthStencilBufferAlreadyCleaned = index === RenderingManager.MIN_RENDERINGGROUPS;\r\n            const renderingGroup = this._renderingGroups[index];\r\n            if (!renderingGroup || renderingGroup._empty) {\r\n                continue;\r\n            }\r\n\r\n            const renderingGroupMask = Math.pow(2, index);\r\n            info.renderingGroupId = index;\r\n\r\n            // Before Observable\r\n            this._scene.onBeforeRenderingGroupObservable.notifyObservers(info, renderingGroupMask);\r\n\r\n            // Clear depth/stencil if needed\r\n            if (RenderingManager.AUTOCLEAR) {\r\n                const autoClear = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(index) : this._autoClearDepthStencil[index];\r\n\r\n                if (autoClear && autoClear.autoClear) {\r\n                    this._clearDepthStencilBuffer(autoClear.depth, autoClear.stencil);\r\n                }\r\n            }\r\n\r\n            // Render\r\n            for (const step of this._scene._beforeRenderingGroupDrawStage) {\r\n                step.action(index);\r\n            }\r\n            renderingGroup.render(customRenderFunction, renderSprites, renderParticles, activeMeshes);\r\n            for (const step of this._scene._afterRenderingGroupDrawStage) {\r\n                step.action(index);\r\n            }\r\n\r\n            // After Observable\r\n            this._scene.onAfterRenderingGroupObservable.notifyObservers(info, renderingGroupMask);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the different information of the group to prepare a new frame\r\n     * @internal\r\n     */\r\n    public reset(): void {\r\n        if (this.maintainStateBetweenFrames) {\r\n            return;\r\n        }\r\n\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            const renderingGroup = this._renderingGroups[index];\r\n            if (renderingGroup) {\r\n                renderingGroup.prepare();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the sprites information of the group to prepare a new frame\r\n     * @internal\r\n     */\r\n    public resetSprites(): void {\r\n        if (this.maintainStateBetweenFrames) {\r\n            return;\r\n        }\r\n\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            const renderingGroup = this._renderingGroups[index];\r\n            if (renderingGroup) {\r\n                renderingGroup.prepareSprites();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose and release the group and its associated resources.\r\n     * @internal\r\n     */\r\n    public dispose(): void {\r\n        this.freeRenderingGroups();\r\n        this._renderingGroups.length = 0;\r\n        this._renderingGroupInfo = null;\r\n    }\r\n\r\n    /**\r\n     * Clear the info related to rendering groups preventing retention points during dispose.\r\n     */\r\n    public freeRenderingGroups(): void {\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            const renderingGroup = this._renderingGroups[index];\r\n            if (renderingGroup) {\r\n                renderingGroup.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _prepareRenderingGroup(renderingGroupId: number): void {\r\n        if (this._renderingGroups[renderingGroupId] === undefined) {\r\n            this._renderingGroups[renderingGroupId] = new RenderingGroup(\r\n                renderingGroupId,\r\n                this._scene,\r\n                this._customOpaqueSortCompareFn[renderingGroupId],\r\n                this._customAlphaTestSortCompareFn[renderingGroupId],\r\n                this._customTransparentSortCompareFn[renderingGroupId]\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a sprite manager to the rendering manager in order to render it this frame.\r\n     * @param spriteManager Define the sprite manager to render\r\n     */\r\n    public dispatchSprites(spriteManager: ISpriteManager) {\r\n        if (this.maintainStateBetweenFrames && spriteManager._wasDispatched) {\r\n            return;\r\n        }\r\n        spriteManager._wasDispatched = true;\r\n        this.getRenderingGroup(spriteManager.renderingGroupId).dispatchSprites(spriteManager);\r\n    }\r\n\r\n    /**\r\n     * Add a particle system to the rendering manager in order to render it this frame.\r\n     * @param particleSystem Define the particle system to render\r\n     */\r\n    public dispatchParticles(particleSystem: IParticleSystem) {\r\n        if (this.maintainStateBetweenFrames && particleSystem._wasDispatched) {\r\n            return;\r\n        }\r\n        particleSystem._wasDispatched = true;\r\n        this.getRenderingGroup(particleSystem.renderingGroupId).dispatchParticles(particleSystem);\r\n    }\r\n\r\n    /**\r\n     * Add a submesh to the manager in order to render it this frame\r\n     * @param subMesh The submesh to dispatch\r\n     * @param mesh Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\r\n     * @param material Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\r\n     */\r\n    public dispatch(subMesh: SubMesh, mesh?: AbstractMesh, material?: Nullable<Material>): void {\r\n        if (mesh === undefined) {\r\n            mesh = subMesh.getMesh();\r\n        }\r\n        if (this.maintainStateBetweenFrames && subMesh._wasDispatched) {\r\n            return;\r\n        }\r\n        subMesh._wasDispatched = true;\r\n        this.getRenderingGroup(mesh.renderingGroupId).dispatch(subMesh, mesh, material);\r\n    }\r\n\r\n    /**\r\n     * Overrides the default sort function applied in the rendering group to prepare the meshes.\r\n     * This allowed control for front to back rendering or reversely depending of the special needs.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\r\n     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\r\n     * @param transparentSortCompareFn The transparent queue comparison function use to sort.\r\n     */\r\n    public setRenderingOrder(\r\n        renderingGroupId: number,\r\n        opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        transparentSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null\r\n    ) {\r\n        this._customOpaqueSortCompareFn[renderingGroupId] = opaqueSortCompareFn;\r\n        this._customAlphaTestSortCompareFn[renderingGroupId] = alphaTestSortCompareFn;\r\n        this._customTransparentSortCompareFn[renderingGroupId] = transparentSortCompareFn;\r\n\r\n        if (this._renderingGroups[renderingGroupId]) {\r\n            const group = this._renderingGroups[renderingGroupId];\r\n            group.opaqueSortCompareFn = this._customOpaqueSortCompareFn[renderingGroupId];\r\n            group.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[renderingGroupId];\r\n            group.transparentSortCompareFn = this._customTransparentSortCompareFn[renderingGroupId];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n     * @param depth Automatically clears depth between groups if true and autoClear is true.\r\n     * @param stencil Automatically clears stencil between groups if true and autoClear is true.\r\n     */\r\n    public setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean, depth = true, stencil = true): void {\r\n        this._autoClearDepthStencil[renderingGroupId] = {\r\n            autoClear: autoClearDepthStencil,\r\n            depth: depth,\r\n            stencil: stencil,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the current auto clear configuration for one rendering group of the rendering\r\n     * manager.\r\n     * @param index the rendering group index to get the information for\r\n     * @returns The auto clear setup for the requested rendering group\r\n     */\r\n    public getAutoClearDepthStencilSetup(index: number): IRenderingManagerAutoClearSetup {\r\n        return this._autoClearDepthStencil[index];\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}