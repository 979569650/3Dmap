{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Gizmo } from \"@babylonjs/core/Gizmos/gizmo.js\";\nimport { Epsilon } from \"@babylonjs/core/Maths/math.constants.js\";\nimport { Matrix, Quaternion, TmpVectors, Vector3 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { TransformNode } from \"@babylonjs/core/Meshes/transformNode.js\";\nimport { PivotTools } from \"@babylonjs/core/Misc/pivotTools.js\";\nimport { CornerHandle, SideHandle } from \"./gizmoHandle.js\";\n/**\n * Gizmo to resize 2D slates\n */\nexport class SlateGizmo extends Gizmo {\n  /**\n   * The slate attached to this gizmo\n   */\n  set attachedSlate(control) {\n    if (control) {\n      this.attachedMesh = control.mesh;\n      this.updateBoundingBox();\n      this._pickedPointObserver = control._host.onPickingObservable.add(pickedMesh => {\n        if (this._handleHovered && (!pickedMesh || pickedMesh.parent !== this._handleHovered.node)) {\n          this._handleHovered.hover = false;\n          this._handleHovered = null;\n        }\n        if (pickedMesh && pickedMesh.parent && pickedMesh.parent.reservedDataStore && pickedMesh.parent.reservedDataStore.handle) {\n          const handle = pickedMesh.parent.reservedDataStore.handle;\n          if (handle.gizmo === this) {\n            this._handleHovered = handle;\n            this._handleHovered.hover = true;\n          }\n        }\n      });\n    } else if (this._attachedSlate) {\n      this._attachedSlate._host.onPickingObservable.remove(this._pickedPointObserver);\n    }\n    this._attachedSlate = control;\n  }\n  get attachedSlate() {\n    return this._attachedSlate;\n  }\n  constructor(utilityLayer) {\n    super(utilityLayer);\n    this._boundingDimensions = new Vector3(0, 0, 0);\n    this._renderObserver = null;\n    this._tmpQuaternion = new Quaternion();\n    this._tmpVector = new Vector3(0, 0, 0);\n    // Ordered bl, br, tr, tl\n    this._corners = [];\n    // Ordered left, bottom, right, top\n    this._sides = [];\n    this._boundingBoxGizmo = {\n      min: new Vector3(),\n      max: new Vector3()\n    };\n    /**\n     * Value we use to offset handles from mesh\n     */\n    this._margin = 0.35;\n    this._handleSize = 0.075;\n    this._attachedSlate = null;\n    this._existingSlateScale = new Vector3();\n    /**\n     * If set, the handles will increase in size based on the distance away from the camera to have a consistent screen size (Default: true)\n     */\n    this.fixedScreenSize = false;\n    /**\n     * The distance away from the object which the draggable meshes should appear world sized when fixedScreenSize is set to true (default: 10)\n     */\n    this.fixedScreenSizeDistanceFactor = 10;\n    this._createNode();\n    this.updateScale = false;\n    this._renderObserver = this.gizmoLayer.originalScene.onBeforeRenderObservable.add(() => {\n      // Only update the bounding box if scaling has changed\n      if (this.attachedMesh && !this._existingSlateScale.equals(this.attachedMesh.scaling)) {\n        this.updateBoundingBox();\n      }\n    });\n  }\n  _createNode() {\n    this._handlesParent = new TransformNode(\"handlesParent\", this.gizmoLayer.utilityLayerScene);\n    this._handlesParent.rotationQuaternion = Quaternion.Identity();\n    const masksCorners = [{\n      dimensions: new Vector3(-1, -1, 0),\n      origin: new Vector3(1, 0, 0)\n    }, {\n      dimensions: new Vector3(1, -1, 0),\n      origin: new Vector3(0, 0, 0)\n    }, {\n      dimensions: new Vector3(1, 1, 0),\n      origin: new Vector3(0, 1, 0)\n    }, {\n      dimensions: new Vector3(-1, 1, 0),\n      origin: new Vector3(1, 1, 0)\n    }];\n    for (let i = 0; i < 4; i++) {\n      const corner = new CornerHandle(this, this.gizmoLayer.utilityLayerScene);\n      this._corners.push(corner);\n      corner.node.rotation.z = Math.PI / 2 * i;\n      corner.node.parent = this._handlesParent;\n      this._assignDragBehaviorCorners(corner, (originStart, dimensionsStart, offset, masks) => this._moveHandle(originStart, dimensionsStart, offset, masks, true), masksCorners[i]);\n    }\n    for (let i = 0; i < 4; i++) {\n      const side = new SideHandle(this, this.gizmoLayer.utilityLayerScene);\n      this._sides.push(side);\n      side.node.rotation.z = Math.PI / 2 * i;\n      side.node.parent = this._handlesParent;\n      this._assignDragBehaviorSides(side, i % 2 === 0 ? new Vector3(0, 1, 0) : new Vector3(1, 0, 0));\n    }\n    this._handlesParent.parent = this._rootMesh;\n  }\n  _keepAspectRatio(vector, aspectRatio, invertDiagonal = false) {\n    const axis = TmpVectors.Vector3[0];\n    axis.copyFromFloats(aspectRatio, 1, 0).normalize();\n    if (invertDiagonal) {\n      axis.y *= -1;\n    }\n    const dot = Vector3.Dot(vector, axis);\n    vector.copyFrom(axis).scaleInPlace(dot);\n  }\n  _clampDimensions(vector, dimensions, mask, keepAspectRatio = false) {\n    const impact = TmpVectors.Vector3[0];\n    impact.copyFrom(vector).multiplyInPlace(mask);\n    const clampedDimensions = TmpVectors.Vector3[1];\n    clampedDimensions.copyFromFloats(Math.max(this._attachedSlate.minDimensions.x, impact.x + dimensions.x), Math.max(this._attachedSlate.minDimensions.y, impact.y + dimensions.y), 0);\n    if (keepAspectRatio) {\n      // Extra logic to ensure the ratio is maintained when the vector has been clamped\n      const ratio = dimensions.x / dimensions.y;\n      clampedDimensions.x = Math.max(clampedDimensions.x, clampedDimensions.y * ratio);\n      clampedDimensions.y = Math.max(clampedDimensions.y, clampedDimensions.x / ratio);\n    }\n    // Calculating the real impact of vector on clamped dimensions\n    impact.copyFrom(clampedDimensions).subtractInPlace(dimensions);\n    vector.x = Math.sign(vector.x) * Math.abs(impact.x);\n    vector.y = Math.sign(vector.y) * Math.abs(impact.y);\n  }\n  _moveHandle(originStart, dimensionsStart, offset, masks, isCorner) {\n    if (!this._attachedSlate) {\n      return;\n    }\n    if (isCorner) {\n      const aspectRatio = dimensionsStart.x / dimensionsStart.y;\n      this._keepAspectRatio(offset, aspectRatio, masks.dimensions.x * masks.dimensions.y < 0);\n    }\n    this._clampDimensions(offset, dimensionsStart, masks.dimensions, isCorner);\n    const offsetOriginMasked = TmpVectors.Vector3[0];\n    const offsetDimensionsMasked = TmpVectors.Vector3[1];\n    offsetOriginMasked.copyFrom(offset).multiplyInPlace(masks.origin);\n    offsetDimensionsMasked.copyFrom(offset).multiplyInPlace(masks.dimensions);\n    this._attachedSlate.origin.copyFrom(originStart).addInPlace(offsetOriginMasked);\n    this._attachedSlate.dimensions.set(dimensionsStart.x + offsetDimensionsMasked.x, dimensionsStart.y + offsetDimensionsMasked.y);\n  }\n  _assignDragBehaviorCorners(handle, moveFn, masks) {\n    const dimensionsStart = new Vector3();\n    const originStart = new Vector3();\n    const dragOrigin = new Vector3();\n    const toObjectFrame = new Matrix();\n    const dragPlaneNormal = new Vector3();\n    const projectToRef = (position, normal, origin, ref) => {\n      // Projects on the plane with its normal and origin\n      position.subtractToRef(origin, TmpVectors.Vector3[0]);\n      const dot = Vector3.Dot(TmpVectors.Vector3[0], normal);\n      TmpVectors.Vector3[1].copyFrom(normal).scaleInPlace(dot);\n      TmpVectors.Vector3[0].subtractInPlace(TmpVectors.Vector3[1]);\n      TmpVectors.Vector3[0].addToRef(origin, ref);\n    };\n    const dragStart = event => {\n      if (this.attachedSlate && this.attachedMesh) {\n        dimensionsStart.set(this.attachedSlate.dimensions.x, this.attachedSlate.dimensions.y, Epsilon);\n        originStart.copyFrom(this.attachedSlate.origin);\n        dragOrigin.copyFrom(event.position);\n        toObjectFrame.copyFrom(this.attachedMesh.computeWorldMatrix(true));\n        toObjectFrame.invert();\n        this.attachedSlate._followButton.isToggled = false;\n        Vector3.TransformNormalToRef(Vector3.Forward(), this.attachedMesh.getWorldMatrix(), dragPlaneNormal);\n        dragPlaneNormal.normalize();\n        if (this._handleHovered) {\n          this._handleDragged = this._handleHovered;\n          this._handleDragged.drag = true;\n        }\n      }\n    };\n    const dragging = event => {\n      if (this.attachedSlate && this.attachedMesh) {\n        projectToRef(event.position, dragPlaneNormal, dragOrigin, this._tmpVector);\n        this._tmpVector.subtractInPlace(dragOrigin);\n        Vector3.TransformNormalToRef(this._tmpVector, toObjectFrame, this._tmpVector);\n        moveFn(originStart, dimensionsStart, this._tmpVector, masks);\n        this.attachedSlate._positionElements();\n        this.updateBoundingBox();\n      }\n    };\n    const dragEnd = () => {\n      if (this.attachedSlate && this.attachedNode) {\n        this.attachedSlate._updatePivot();\n        if (this._handleDragged) {\n          this._handleDragged.drag = false;\n          this._handleDragged = null;\n        }\n      }\n    };\n    handle.setDragBehavior(dragStart, dragging, dragEnd);\n  }\n  _assignDragBehaviorSides(handle, dragPlaneNormal) {\n    const quaternionOrigin = new Quaternion();\n    const dragOrigin = new Vector3();\n    const directionOrigin = new Vector3();\n    const worldPivot = new Vector3();\n    const worldPlaneNormal = new Vector3();\n    const dragStart = event => {\n      if (this.attachedSlate && this.attachedMesh) {\n        quaternionOrigin.copyFrom(this.attachedMesh.rotationQuaternion);\n        dragOrigin.copyFrom(event.position);\n        worldPivot.copyFrom(this.attachedMesh.getAbsolutePivotPoint());\n        directionOrigin.copyFrom(dragOrigin).subtractInPlace(worldPivot).normalize();\n        this.attachedSlate._followButton.isToggled = false;\n        Vector3.TransformNormalToRef(dragPlaneNormal, this.attachedMesh.getWorldMatrix(), worldPlaneNormal);\n        worldPlaneNormal.normalize();\n        if (this._handleHovered) {\n          this._handleDragged = this._handleHovered;\n          this._handleDragged.drag = true;\n        }\n      }\n    };\n    const dragging = event => {\n      if (this.attachedSlate && this.attachedMesh) {\n        this._tmpVector.copyFrom(event.position);\n        this._tmpVector.subtractInPlace(worldPivot);\n        this._tmpVector.normalize();\n        const angle = -Vector3.GetAngleBetweenVectorsOnPlane(this._tmpVector, directionOrigin, worldPlaneNormal);\n        Quaternion.RotationAxisToRef(dragPlaneNormal, angle, this._tmpQuaternion);\n        quaternionOrigin.multiplyToRef(this._tmpQuaternion, this.attachedMesh.rotationQuaternion);\n      }\n    };\n    const dragEnd = () => {\n      if (this.attachedSlate && this.attachedNode) {\n        this.attachedSlate._updatePivot();\n        if (this._handleDragged) {\n          this._handleDragged.drag = false;\n          this._handleDragged = null;\n        }\n      }\n    };\n    handle.setDragBehavior(dragStart, dragging, dragEnd);\n  }\n  _attachedNodeChanged(value) {\n    if (value) {\n      this.updateBoundingBox();\n    }\n  }\n  /**\n   * Updates the bounding box information for the gizmo\n   */\n  updateBoundingBox() {\n    if (this.attachedMesh) {\n      PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);\n      // Store original parent\n      const originalParent = this.attachedMesh.parent;\n      this.attachedMesh.setParent(null);\n      this._update();\n      // Rotate based on axis\n      if (!this.attachedMesh.rotationQuaternion) {\n        this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);\n      }\n      // Store original position and reset mesh to origin before computing the bounding box\n      this._tmpQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);\n      this._tmpVector.copyFrom(this.attachedMesh.position);\n      this.attachedMesh.rotationQuaternion.set(0, 0, 0, 1);\n      this.attachedMesh.position.set(0, 0, 0);\n      // Update bounding dimensions/positions\n      const boundingMinMax = this.attachedMesh.getHierarchyBoundingVectors();\n      boundingMinMax.max.subtractToRef(boundingMinMax.min, this._boundingDimensions);\n      this._boundingBoxGizmo.min = boundingMinMax.min;\n      this._boundingBoxGizmo.max = boundingMinMax.max;\n      // Update handles of the gizmo\n      this._updateHandlesPosition();\n      this._updateHandlesScaling();\n      // Restore position/rotation values\n      this.attachedMesh.rotationQuaternion.copyFrom(this._tmpQuaternion);\n      this.attachedMesh.position.copyFrom(this._tmpVector);\n      PivotTools._RestorePivotPoint(this.attachedMesh);\n      // Restore original parent\n      this.attachedMesh.setParent(originalParent);\n      this.attachedMesh.computeWorldMatrix(true);\n      this._existingSlateScale.copyFrom(this.attachedMesh.scaling);\n    }\n  }\n  _updateHandlesPosition() {\n    const min = this._boundingBoxGizmo.min.clone();\n    const max = this._boundingBoxGizmo.max.clone();\n    const handleScaling = this._corners[0].node.scaling.length();\n    min.x -= this._margin * handleScaling;\n    min.y -= this._margin * handleScaling;\n    max.x += this._margin * handleScaling;\n    max.y += this._margin * handleScaling;\n    const center = min.add(max).scaleInPlace(0.5);\n    this._corners[0].node.position.copyFromFloats(min.x, min.y, 0);\n    this._corners[1].node.position.copyFromFloats(max.x, min.y, 0);\n    this._corners[2].node.position.copyFromFloats(max.x, max.y, 0);\n    this._corners[3].node.position.copyFromFloats(min.x, max.y, 0);\n    this._sides[0].node.position.copyFromFloats(min.x, center.y, 0);\n    this._sides[1].node.position.copyFromFloats(center.x, min.y, 0);\n    this._sides[2].node.position.copyFromFloats(max.x, center.y, 0);\n    this._sides[3].node.position.copyFromFloats(center.x, max.y, 0);\n  }\n  _updateHandlesScaling() {\n    if (this._attachedSlate && this._attachedSlate.mesh) {\n      const scaledWidth = this._attachedSlate.mesh.scaling.x * this._attachedSlate.dimensions.x;\n      const scaledHeight = this._attachedSlate.mesh.scaling.y * this._attachedSlate.dimensions.y;\n      const scale = Math.min(scaledWidth, scaledHeight) * this._handleSize;\n      for (let index = 0; index < this._corners.length; index++) {\n        this._corners[index].node.scaling.setAll(scale);\n      }\n      for (let index = 0; index < this._sides.length; index++) {\n        this._sides[index].node.scaling.setAll(scale);\n      }\n    }\n  }\n  _update() {\n    super._update();\n    if (!this.gizmoLayer.utilityLayerScene.activeCamera) {\n      return;\n    }\n    if (this._attachedSlate && this._attachedSlate.mesh) {\n      if (this.fixedScreenSize) {\n        this._attachedSlate.mesh.absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);\n        const distanceFromCamera = this._handleSize * this._tmpVector.length() / this.fixedScreenSizeDistanceFactor;\n        for (let i = 0; i < this._corners.length; i++) {\n          this._corners[i].node.scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);\n        }\n        for (let i = 0; i < this._sides.length; i++) {\n          this._sides[i].node.scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);\n        }\n      }\n      this._updateHandlesPosition();\n    }\n  }\n  dispose() {\n    this.gizmoLayer.originalScene.onBeforeRenderObservable.remove(this._renderObserver);\n    // Will dispose rootMesh and all descendants\n    super.dispose();\n    for (const corner of this._corners) {\n      corner.dispose();\n    }\n    for (const side of this._sides) {\n      side.dispose();\n    }\n  }\n}","map":{"version":3,"names":["Gizmo","Epsilon","Matrix","Quaternion","TmpVectors","Vector3","TransformNode","PivotTools","CornerHandle","SideHandle","SlateGizmo","attachedSlate","control","attachedMesh","mesh","updateBoundingBox","_pickedPointObserver","_host","onPickingObservable","add","pickedMesh","_handleHovered","parent","node","hover","reservedDataStore","handle","gizmo","_attachedSlate","remove","constructor","utilityLayer","_boundingDimensions","_renderObserver","_tmpQuaternion","_tmpVector","_corners","_sides","_boundingBoxGizmo","min","max","_margin","_handleSize","_existingSlateScale","fixedScreenSize","fixedScreenSizeDistanceFactor","_createNode","updateScale","gizmoLayer","originalScene","onBeforeRenderObservable","equals","scaling","_handlesParent","utilityLayerScene","rotationQuaternion","Identity","masksCorners","dimensions","origin","i","corner","push","rotation","z","Math","PI","_assignDragBehaviorCorners","originStart","dimensionsStart","offset","masks","_moveHandle","side","_assignDragBehaviorSides","_rootMesh","_keepAspectRatio","vector","aspectRatio","invertDiagonal","axis","copyFromFloats","normalize","y","dot","Dot","copyFrom","scaleInPlace","_clampDimensions","mask","keepAspectRatio","impact","multiplyInPlace","clampedDimensions","minDimensions","x","ratio","subtractInPlace","sign","abs","isCorner","offsetOriginMasked","offsetDimensionsMasked","addInPlace","set","moveFn","dragOrigin","toObjectFrame","dragPlaneNormal","projectToRef","position","normal","ref","subtractToRef","addToRef","dragStart","event","computeWorldMatrix","invert","_followButton","isToggled","TransformNormalToRef","Forward","getWorldMatrix","_handleDragged","drag","dragging","_positionElements","dragEnd","attachedNode","_updatePivot","setDragBehavior","quaternionOrigin","directionOrigin","worldPivot","worldPlaneNormal","getAbsolutePivotPoint","angle","GetAngleBetweenVectorsOnPlane","RotationAxisToRef","multiplyToRef","_attachedNodeChanged","value","_RemoveAndStorePivotPoint","originalParent","setParent","_update","RotationYawPitchRoll","boundingMinMax","getHierarchyBoundingVectors","_updateHandlesPosition","_updateHandlesScaling","_RestorePivotPoint","clone","handleScaling","length","center","scaledWidth","scaledHeight","scale","index","setAll","activeCamera","absolutePosition","distanceFromCamera","dispose"],"sources":["../../../../../dev/gui/src/3D/gizmos/slateGizmo.ts"],"sourcesContent":["import { Gizmo } from \"core/Gizmos/gizmo\";\r\nimport { Epsilon } from \"core/Maths/math.constants\";\r\nimport { Matrix, Quaternion, TmpVectors, Vector3 } from \"core/Maths/math.vector\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { PivotTools } from \"core/Misc/pivotTools\";\r\nimport type { UtilityLayerRenderer } from \"core/Rendering/utilityLayerRenderer\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\nimport type { HolographicSlate } from \"../controls/holographicSlate\";\r\nimport type { GizmoHandle } from \"./gizmoHandle\";\r\nimport { CornerHandle, SideHandle } from \"./gizmoHandle\";\r\n\r\n// Mask contains the influence of the drag offset vectors on dimensions or origin of the slate\r\n// Mask vector is multiplied to the offset vector\r\ntype HandleMasks = {\r\n    dimensions: Vector3;\r\n    origin: Vector3;\r\n};\r\n\r\n/**\r\n * Gizmo to resize 2D slates\r\n */\r\nexport class SlateGizmo extends Gizmo {\r\n    private _boundingDimensions = new Vector3(0, 0, 0);\r\n    private _pickedPointObserver: Nullable<Observer<Nullable<AbstractMesh>>>;\r\n    private _renderObserver: Nullable<Observer<Scene>> = null;\r\n\r\n    private _tmpQuaternion = new Quaternion();\r\n    private _tmpVector = new Vector3(0, 0, 0);\r\n\r\n    // Ordered bl, br, tr, tl\r\n    private _corners: CornerHandle[] = [];\r\n    // Ordered left, bottom, right, top\r\n    private _sides: SideHandle[] = [];\r\n    private _handlesParent: TransformNode;\r\n    private _handleHovered: Nullable<GizmoHandle>;\r\n    private _handleDragged: Nullable<GizmoHandle>;\r\n\r\n    private _boundingBoxGizmo = {\r\n        min: new Vector3(),\r\n        max: new Vector3(),\r\n    };\r\n\r\n    /**\r\n     * Value we use to offset handles from mesh\r\n     */\r\n    private _margin = 0.35;\r\n    private _handleSize = 0.075;\r\n    private _attachedSlate: Nullable<HolographicSlate> = null;\r\n    private _existingSlateScale = new Vector3();\r\n    /**\r\n     * If set, the handles will increase in size based on the distance away from the camera to have a consistent screen size (Default: true)\r\n     */\r\n    public fixedScreenSize = false;\r\n    /**\r\n     * The distance away from the object which the draggable meshes should appear world sized when fixedScreenSize is set to true (default: 10)\r\n     */\r\n    public fixedScreenSizeDistanceFactor = 10;\r\n\r\n    /**\r\n     * The slate attached to this gizmo\r\n     */\r\n    public set attachedSlate(control: Nullable<HolographicSlate>) {\r\n        if (control) {\r\n            this.attachedMesh = control.mesh;\r\n            this.updateBoundingBox();\r\n\r\n            this._pickedPointObserver = control._host.onPickingObservable.add((pickedMesh) => {\r\n                if (this._handleHovered && (!pickedMesh || pickedMesh.parent !== this._handleHovered.node)) {\r\n                    this._handleHovered.hover = false;\r\n                    this._handleHovered = null;\r\n                }\r\n\r\n                if (pickedMesh && pickedMesh.parent && pickedMesh.parent.reservedDataStore && pickedMesh.parent.reservedDataStore.handle) {\r\n                    const handle = pickedMesh.parent.reservedDataStore.handle as GizmoHandle;\r\n                    if (handle.gizmo === this) {\r\n                        this._handleHovered = handle;\r\n                        this._handleHovered.hover = true;\r\n                    }\r\n                }\r\n            });\r\n        } else if (this._attachedSlate) {\r\n            this._attachedSlate._host.onPickingObservable.remove(this._pickedPointObserver);\r\n        }\r\n        this._attachedSlate = control;\r\n    }\r\n\r\n    public get attachedSlate(): Nullable<HolographicSlate> {\r\n        return this._attachedSlate;\r\n    }\r\n\r\n    constructor(utilityLayer?: UtilityLayerRenderer) {\r\n        super(utilityLayer);\r\n\r\n        this._createNode();\r\n        this.updateScale = false;\r\n\r\n        this._renderObserver = this.gizmoLayer.originalScene.onBeforeRenderObservable.add(() => {\r\n            // Only update the bounding box if scaling has changed\r\n            if (this.attachedMesh && !this._existingSlateScale.equals(this.attachedMesh.scaling)) {\r\n                this.updateBoundingBox();\r\n            }\r\n        });\r\n    }\r\n\r\n    private _createNode() {\r\n        this._handlesParent = new TransformNode(\"handlesParent\", this.gizmoLayer.utilityLayerScene);\r\n        this._handlesParent.rotationQuaternion = Quaternion.Identity();\r\n\r\n        const masksCorners = [\r\n            {\r\n                dimensions: new Vector3(-1, -1, 0),\r\n                origin: new Vector3(1, 0, 0),\r\n            },\r\n            {\r\n                dimensions: new Vector3(1, -1, 0),\r\n                origin: new Vector3(0, 0, 0),\r\n            },\r\n            {\r\n                dimensions: new Vector3(1, 1, 0),\r\n                origin: new Vector3(0, 1, 0),\r\n            },\r\n            {\r\n                dimensions: new Vector3(-1, 1, 0),\r\n                origin: new Vector3(1, 1, 0),\r\n            },\r\n        ];\r\n\r\n        for (let i = 0; i < 4; i++) {\r\n            const corner = new CornerHandle(this, this.gizmoLayer.utilityLayerScene);\r\n            this._corners.push(corner);\r\n            corner.node.rotation.z = (Math.PI / 2) * i;\r\n\r\n            corner.node.parent = this._handlesParent;\r\n            this._assignDragBehaviorCorners(\r\n                corner,\r\n                (originStart: Vector3, dimensionsStart: Vector3, offset: Vector3, masks: HandleMasks) => this._moveHandle(originStart, dimensionsStart, offset, masks, true),\r\n                masksCorners[i]\r\n            );\r\n        }\r\n\r\n        for (let i = 0; i < 4; i++) {\r\n            const side = new SideHandle(this, this.gizmoLayer.utilityLayerScene);\r\n            this._sides.push(side);\r\n            side.node.rotation.z = (Math.PI / 2) * i;\r\n            side.node.parent = this._handlesParent;\r\n            this._assignDragBehaviorSides(side, i % 2 === 0 ? new Vector3(0, 1, 0) : new Vector3(1, 0, 0));\r\n        }\r\n\r\n        this._handlesParent.parent = this._rootMesh;\r\n    }\r\n\r\n    private _keepAspectRatio(vector: Vector3, aspectRatio: number, invertDiagonal: boolean = false) {\r\n        const axis = TmpVectors.Vector3[0];\r\n        axis.copyFromFloats(aspectRatio, 1, 0).normalize();\r\n        if (invertDiagonal) {\r\n            axis.y *= -1;\r\n        }\r\n        const dot = Vector3.Dot(vector, axis);\r\n        vector.copyFrom(axis).scaleInPlace(dot);\r\n    }\r\n\r\n    private _clampDimensions(vector: Vector3, dimensions: Vector3, mask: Vector3, keepAspectRatio: boolean = false) {\r\n        const impact = TmpVectors.Vector3[0];\r\n        impact.copyFrom(vector).multiplyInPlace(mask);\r\n\r\n        const clampedDimensions = TmpVectors.Vector3[1];\r\n        clampedDimensions.copyFromFloats(\r\n            Math.max(this._attachedSlate!.minDimensions.x, impact.x + dimensions.x),\r\n            Math.max(this._attachedSlate!.minDimensions.y, impact.y + dimensions.y),\r\n            0\r\n        );\r\n\r\n        if (keepAspectRatio) {\r\n            // Extra logic to ensure the ratio is maintained when the vector has been clamped\r\n            const ratio = dimensions.x / dimensions.y;\r\n            clampedDimensions.x = Math.max(clampedDimensions.x, clampedDimensions.y * ratio);\r\n            clampedDimensions.y = Math.max(clampedDimensions.y, clampedDimensions.x / ratio);\r\n        }\r\n\r\n        // Calculating the real impact of vector on clamped dimensions\r\n        impact.copyFrom(clampedDimensions).subtractInPlace(dimensions);\r\n\r\n        vector.x = Math.sign(vector.x) * Math.abs(impact.x);\r\n        vector.y = Math.sign(vector.y) * Math.abs(impact.y);\r\n    }\r\n\r\n    private _moveHandle(originStart: Vector3, dimensionsStart: Vector3, offset: Vector3, masks: HandleMasks, isCorner: boolean) {\r\n        if (!this._attachedSlate) {\r\n            return;\r\n        }\r\n\r\n        if (isCorner) {\r\n            const aspectRatio = dimensionsStart.x / dimensionsStart.y;\r\n            this._keepAspectRatio(offset, aspectRatio, masks.dimensions.x * masks.dimensions.y < 0);\r\n        }\r\n        this._clampDimensions(offset, dimensionsStart, masks.dimensions, isCorner);\r\n\r\n        const offsetOriginMasked = TmpVectors.Vector3[0];\r\n        const offsetDimensionsMasked = TmpVectors.Vector3[1];\r\n        offsetOriginMasked.copyFrom(offset).multiplyInPlace(masks.origin);\r\n        offsetDimensionsMasked.copyFrom(offset).multiplyInPlace(masks.dimensions);\r\n\r\n        this._attachedSlate.origin.copyFrom(originStart).addInPlace(offsetOriginMasked);\r\n        this._attachedSlate.dimensions.set(dimensionsStart.x + offsetDimensionsMasked.x, dimensionsStart.y + offsetDimensionsMasked.y);\r\n    }\r\n\r\n    private _assignDragBehaviorCorners(\r\n        handle: GizmoHandle,\r\n        moveFn: (originStart: Vector3, dimensionsStart: Vector3, offset: Vector3, masks: HandleMasks) => void,\r\n        masks: HandleMasks\r\n    ) {\r\n        const dimensionsStart = new Vector3();\r\n        const originStart = new Vector3();\r\n        const dragOrigin = new Vector3();\r\n        const toObjectFrame = new Matrix();\r\n        const dragPlaneNormal = new Vector3();\r\n\r\n        const projectToRef = (position: Vector3, normal: Vector3, origin: Vector3, ref: Vector3) => {\r\n            // Projects on the plane with its normal and origin\r\n            position.subtractToRef(origin, TmpVectors.Vector3[0]);\r\n            const dot = Vector3.Dot(TmpVectors.Vector3[0], normal);\r\n            TmpVectors.Vector3[1].copyFrom(normal).scaleInPlace(dot);\r\n            TmpVectors.Vector3[0].subtractInPlace(TmpVectors.Vector3[1]);\r\n            TmpVectors.Vector3[0].addToRef(origin, ref);\r\n        };\r\n\r\n        const dragStart = (event: { position: Vector3 }) => {\r\n            if (this.attachedSlate && this.attachedMesh) {\r\n                dimensionsStart.set(this.attachedSlate.dimensions.x, this.attachedSlate.dimensions.y, Epsilon);\r\n                originStart.copyFrom(this.attachedSlate.origin);\r\n                dragOrigin.copyFrom(event.position);\r\n                toObjectFrame.copyFrom(this.attachedMesh.computeWorldMatrix(true));\r\n                toObjectFrame.invert();\r\n                this.attachedSlate._followButton.isToggled = false;\r\n                Vector3.TransformNormalToRef(Vector3.Forward(), this.attachedMesh.getWorldMatrix(), dragPlaneNormal);\r\n                dragPlaneNormal.normalize();\r\n\r\n                if (this._handleHovered) {\r\n                    this._handleDragged = this._handleHovered;\r\n                    this._handleDragged.drag = true;\r\n                }\r\n            }\r\n        };\r\n\r\n        const dragging = (event: { position: Vector3 }) => {\r\n            if (this.attachedSlate && this.attachedMesh) {\r\n                projectToRef(event.position, dragPlaneNormal, dragOrigin, this._tmpVector);\r\n                this._tmpVector.subtractInPlace(dragOrigin);\r\n                Vector3.TransformNormalToRef(this._tmpVector, toObjectFrame, this._tmpVector);\r\n\r\n                moveFn(originStart, dimensionsStart, this._tmpVector, masks);\r\n                this.attachedSlate._positionElements();\r\n                this.updateBoundingBox();\r\n            }\r\n        };\r\n\r\n        const dragEnd = () => {\r\n            if (this.attachedSlate && this.attachedNode) {\r\n                this.attachedSlate._updatePivot();\r\n\r\n                if (this._handleDragged) {\r\n                    this._handleDragged.drag = false;\r\n                    this._handleDragged = null;\r\n                }\r\n            }\r\n        };\r\n\r\n        handle.setDragBehavior(dragStart, dragging, dragEnd);\r\n    }\r\n\r\n    private _assignDragBehaviorSides(handle: GizmoHandle, dragPlaneNormal: Vector3) {\r\n        const quaternionOrigin = new Quaternion();\r\n        const dragOrigin = new Vector3();\r\n        const directionOrigin = new Vector3();\r\n        const worldPivot = new Vector3();\r\n        const worldPlaneNormal = new Vector3();\r\n\r\n        const dragStart = (event: { position: Vector3 }) => {\r\n            if (this.attachedSlate && this.attachedMesh) {\r\n                quaternionOrigin.copyFrom(this.attachedMesh.rotationQuaternion!);\r\n                dragOrigin.copyFrom(event.position);\r\n                worldPivot.copyFrom(this.attachedMesh.getAbsolutePivotPoint());\r\n                directionOrigin.copyFrom(dragOrigin).subtractInPlace(worldPivot).normalize();\r\n                this.attachedSlate._followButton.isToggled = false;\r\n                Vector3.TransformNormalToRef(dragPlaneNormal, this.attachedMesh.getWorldMatrix(), worldPlaneNormal);\r\n                worldPlaneNormal.normalize();\r\n\r\n                if (this._handleHovered) {\r\n                    this._handleDragged = this._handleHovered;\r\n                    this._handleDragged.drag = true;\r\n                }\r\n            }\r\n        };\r\n\r\n        const dragging = (event: { position: Vector3 }) => {\r\n            if (this.attachedSlate && this.attachedMesh) {\r\n                this._tmpVector.copyFrom(event.position);\r\n                this._tmpVector.subtractInPlace(worldPivot);\r\n                this._tmpVector.normalize();\r\n\r\n                const angle = -Vector3.GetAngleBetweenVectorsOnPlane(this._tmpVector, directionOrigin, worldPlaneNormal);\r\n                Quaternion.RotationAxisToRef(dragPlaneNormal, angle, this._tmpQuaternion);\r\n                quaternionOrigin.multiplyToRef(this._tmpQuaternion, this.attachedMesh.rotationQuaternion!);\r\n            }\r\n        };\r\n\r\n        const dragEnd = () => {\r\n            if (this.attachedSlate && this.attachedNode) {\r\n                this.attachedSlate._updatePivot();\r\n\r\n                if (this._handleDragged) {\r\n                    this._handleDragged.drag = false;\r\n                    this._handleDragged = null;\r\n                }\r\n            }\r\n        };\r\n\r\n        handle.setDragBehavior(dragStart, dragging, dragEnd);\r\n    }\r\n\r\n    protected _attachedNodeChanged(value: Nullable<AbstractMesh>) {\r\n        if (value) {\r\n            this.updateBoundingBox();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the bounding box information for the gizmo\r\n     */\r\n    public updateBoundingBox() {\r\n        if (this.attachedMesh) {\r\n            PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);\r\n\r\n            // Store original parent\r\n            const originalParent = this.attachedMesh.parent;\r\n            this.attachedMesh.setParent(null);\r\n\r\n            this._update();\r\n\r\n            // Rotate based on axis\r\n            if (!this.attachedMesh.rotationQuaternion) {\r\n                this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);\r\n            }\r\n\r\n            // Store original position and reset mesh to origin before computing the bounding box\r\n            this._tmpQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);\r\n            this._tmpVector.copyFrom(this.attachedMesh.position);\r\n            this.attachedMesh.rotationQuaternion.set(0, 0, 0, 1);\r\n            this.attachedMesh.position.set(0, 0, 0);\r\n\r\n            // Update bounding dimensions/positions\r\n            const boundingMinMax = this.attachedMesh.getHierarchyBoundingVectors();\r\n            boundingMinMax.max.subtractToRef(boundingMinMax.min, this._boundingDimensions);\r\n            this._boundingBoxGizmo.min = boundingMinMax.min;\r\n            this._boundingBoxGizmo.max = boundingMinMax.max;\r\n\r\n            // Update handles of the gizmo\r\n            this._updateHandlesPosition();\r\n            this._updateHandlesScaling();\r\n\r\n            // Restore position/rotation values\r\n            this.attachedMesh.rotationQuaternion.copyFrom(this._tmpQuaternion);\r\n            this.attachedMesh.position.copyFrom(this._tmpVector);\r\n\r\n            PivotTools._RestorePivotPoint(this.attachedMesh);\r\n\r\n            // Restore original parent\r\n            this.attachedMesh.setParent(originalParent);\r\n            this.attachedMesh.computeWorldMatrix(true);\r\n\r\n            this._existingSlateScale.copyFrom(this.attachedMesh.scaling);\r\n        }\r\n    }\r\n\r\n    private _updateHandlesPosition() {\r\n        const min = this._boundingBoxGizmo.min.clone();\r\n        const max = this._boundingBoxGizmo.max.clone();\r\n\r\n        const handleScaling = this._corners[0].node.scaling.length();\r\n        min.x -= this._margin * handleScaling;\r\n        min.y -= this._margin * handleScaling;\r\n        max.x += this._margin * handleScaling;\r\n        max.y += this._margin * handleScaling;\r\n\r\n        const center = min.add(max).scaleInPlace(0.5);\r\n\r\n        this._corners[0].node.position.copyFromFloats(min.x, min.y, 0);\r\n        this._corners[1].node.position.copyFromFloats(max.x, min.y, 0);\r\n        this._corners[2].node.position.copyFromFloats(max.x, max.y, 0);\r\n        this._corners[3].node.position.copyFromFloats(min.x, max.y, 0);\r\n\r\n        this._sides[0].node.position.copyFromFloats(min.x, center.y, 0);\r\n        this._sides[1].node.position.copyFromFloats(center.x, min.y, 0);\r\n        this._sides[2].node.position.copyFromFloats(max.x, center.y, 0);\r\n        this._sides[3].node.position.copyFromFloats(center.x, max.y, 0);\r\n    }\r\n\r\n    private _updateHandlesScaling() {\r\n        if (this._attachedSlate && this._attachedSlate.mesh) {\r\n            const scaledWidth = this._attachedSlate.mesh.scaling.x * this._attachedSlate.dimensions.x;\r\n            const scaledHeight = this._attachedSlate.mesh.scaling.y * this._attachedSlate.dimensions.y;\r\n            const scale = Math.min(scaledWidth, scaledHeight) * this._handleSize;\r\n            for (let index = 0; index < this._corners.length; index++) {\r\n                this._corners[index].node.scaling.setAll(scale);\r\n            }\r\n            for (let index = 0; index < this._sides.length; index++) {\r\n                this._sides[index].node.scaling.setAll(scale);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _update() {\r\n        super._update();\r\n\r\n        if (!this.gizmoLayer.utilityLayerScene.activeCamera) {\r\n            return;\r\n        }\r\n\r\n        if (this._attachedSlate && this._attachedSlate.mesh) {\r\n            if (this.fixedScreenSize) {\r\n                this._attachedSlate.mesh.absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);\r\n                const distanceFromCamera = (this._handleSize * this._tmpVector.length()) / this.fixedScreenSizeDistanceFactor;\r\n                for (let i = 0; i < this._corners.length; i++) {\r\n                    this._corners[i].node.scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);\r\n                }\r\n                for (let i = 0; i < this._sides.length; i++) {\r\n                    this._sides[i].node.scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);\r\n                }\r\n            }\r\n            this._updateHandlesPosition();\r\n        }\r\n    }\r\n\r\n    public dispose() {\r\n        this.gizmoLayer.originalScene.onBeforeRenderObservable.remove(this._renderObserver);\r\n\r\n        // Will dispose rootMesh and all descendants\r\n        super.dispose();\r\n\r\n        for (const corner of this._corners) {\r\n            corner.dispose();\r\n        }\r\n\r\n        for (const side of this._sides) {\r\n            side.dispose();\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}