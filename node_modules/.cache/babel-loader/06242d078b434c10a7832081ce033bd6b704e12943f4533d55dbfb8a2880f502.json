{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../tslib.es6.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { serialize, SerializationHelper } from \"../Misc/decorators.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\n/**\n * Defines a target to use with MorphTargetManager\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/morphTargets\n */\nexport class MorphTarget {\n  /**\n   * Gets or sets the influence of this target (ie. its weight in the overall morphing)\n   */\n  get influence() {\n    return this._influence;\n  }\n  set influence(influence) {\n    if (this._influence === influence) {\n      return;\n    }\n    const previous = this._influence;\n    this._influence = influence;\n    if (this.onInfluenceChanged.hasObservers()) {\n      this.onInfluenceChanged.notifyObservers(previous === 0 || influence === 0);\n    }\n  }\n  /**\n   * Gets or sets the animation properties override\n   */\n  get animationPropertiesOverride() {\n    if (!this._animationPropertiesOverride && this._scene) {\n      return this._scene.animationPropertiesOverride;\n    }\n    return this._animationPropertiesOverride;\n  }\n  set animationPropertiesOverride(value) {\n    this._animationPropertiesOverride = value;\n  }\n  /**\n   * Creates a new MorphTarget\n   * @param name defines the name of the target\n   * @param influence defines the influence to use\n   * @param scene defines the scene the morphtarget belongs to\n   */\n  constructor( /** defines the name of the target */\n  name, influence = 0, scene = null) {\n    this.name = name;\n    /**\n     * Gets or sets the list of animations\n     */\n    this.animations = new Array();\n    this._positions = null;\n    this._normals = null;\n    this._tangents = null;\n    this._uvs = null;\n    this._uniqueId = 0;\n    /**\n     * Observable raised when the influence changes\n     */\n    this.onInfluenceChanged = new Observable();\n    /** @internal */\n    this._onDataLayoutChanged = new Observable();\n    this._animationPropertiesOverride = null;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this.influence = influence;\n    if (this._scene) {\n      this._uniqueId = this._scene.getUniqueId();\n    }\n  }\n  /**\n   * Gets the unique ID of this manager\n   */\n  get uniqueId() {\n    return this._uniqueId;\n  }\n  /**\n   * Gets a boolean defining if the target contains position data\n   */\n  get hasPositions() {\n    return !!this._positions;\n  }\n  /**\n   * Gets a boolean defining if the target contains normal data\n   */\n  get hasNormals() {\n    return !!this._normals;\n  }\n  /**\n   * Gets a boolean defining if the target contains tangent data\n   */\n  get hasTangents() {\n    return !!this._tangents;\n  }\n  /**\n   * Gets a boolean defining if the target contains texture coordinates data\n   */\n  get hasUVs() {\n    return !!this._uvs;\n  }\n  /**\n   * Affects position data to this target\n   * @param data defines the position data to use\n   */\n  setPositions(data) {\n    const hadPositions = this.hasPositions;\n    this._positions = data;\n    if (hadPositions !== this.hasPositions) {\n      this._onDataLayoutChanged.notifyObservers(undefined);\n    }\n  }\n  /**\n   * Gets the position data stored in this target\n   * @returns a FloatArray containing the position data (or null if not present)\n   */\n  getPositions() {\n    return this._positions;\n  }\n  /**\n   * Affects normal data to this target\n   * @param data defines the normal data to use\n   */\n  setNormals(data) {\n    const hadNormals = this.hasNormals;\n    this._normals = data;\n    if (hadNormals !== this.hasNormals) {\n      this._onDataLayoutChanged.notifyObservers(undefined);\n    }\n  }\n  /**\n   * Gets the normal data stored in this target\n   * @returns a FloatArray containing the normal data (or null if not present)\n   */\n  getNormals() {\n    return this._normals;\n  }\n  /**\n   * Affects tangent data to this target\n   * @param data defines the tangent data to use\n   */\n  setTangents(data) {\n    const hadTangents = this.hasTangents;\n    this._tangents = data;\n    if (hadTangents !== this.hasTangents) {\n      this._onDataLayoutChanged.notifyObservers(undefined);\n    }\n  }\n  /**\n   * Gets the tangent data stored in this target\n   * @returns a FloatArray containing the tangent data (or null if not present)\n   */\n  getTangents() {\n    return this._tangents;\n  }\n  /**\n   * Affects texture coordinates data to this target\n   * @param data defines the texture coordinates data to use\n   */\n  setUVs(data) {\n    const hadUVs = this.hasUVs;\n    this._uvs = data;\n    if (hadUVs !== this.hasUVs) {\n      this._onDataLayoutChanged.notifyObservers(undefined);\n    }\n  }\n  /**\n   * Gets the texture coordinates data stored in this target\n   * @returns a FloatArray containing the texture coordinates data (or null if not present)\n   */\n  getUVs() {\n    return this._uvs;\n  }\n  /**\n   * Clone the current target\n   * @returns a new MorphTarget\n   */\n  clone() {\n    const newOne = SerializationHelper.Clone(() => new MorphTarget(this.name, this.influence, this._scene), this);\n    newOne._positions = this._positions;\n    newOne._normals = this._normals;\n    newOne._tangents = this._tangents;\n    newOne._uvs = this._uvs;\n    return newOne;\n  }\n  /**\n   * Serializes the current target into a Serialization object\n   * @returns the serialized object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.influence = this.influence;\n    serializationObject.positions = Array.prototype.slice.call(this.getPositions());\n    if (this.id != null) {\n      serializationObject.id = this.id;\n    }\n    if (this.hasNormals) {\n      serializationObject.normals = Array.prototype.slice.call(this.getNormals());\n    }\n    if (this.hasTangents) {\n      serializationObject.tangents = Array.prototype.slice.call(this.getTangents());\n    }\n    if (this.hasUVs) {\n      serializationObject.uvs = Array.prototype.slice.call(this.getUVs());\n    }\n    // Animations\n    SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n    return serializationObject;\n  }\n  /**\n   * Returns the string \"MorphTarget\"\n   * @returns \"MorphTarget\"\n   */\n  getClassName() {\n    return \"MorphTarget\";\n  }\n  // Statics\n  /**\n   * Creates a new target from serialized data\n   * @param serializationObject defines the serialized data to use\n   * @param scene defines the hosting scene\n   * @returns a new MorphTarget\n   */\n  static Parse(serializationObject, scene) {\n    const result = new MorphTarget(serializationObject.name, serializationObject.influence);\n    result.setPositions(serializationObject.positions);\n    if (serializationObject.id != null) {\n      result.id = serializationObject.id;\n    }\n    if (serializationObject.normals) {\n      result.setNormals(serializationObject.normals);\n    }\n    if (serializationObject.tangents) {\n      result.setTangents(serializationObject.tangents);\n    }\n    if (serializationObject.uvs) {\n      result.setUVs(serializationObject.uvs);\n    }\n    // Animations\n    if (serializationObject.animations) {\n      for (let animationIndex = 0; animationIndex < serializationObject.animations.length; animationIndex++) {\n        const parsedAnimation = serializationObject.animations[animationIndex];\n        const internalClass = GetClass(\"BABYLON.Animation\");\n        if (internalClass) {\n          result.animations.push(internalClass.Parse(parsedAnimation));\n        }\n      }\n      if (serializationObject.autoAnimate && scene) {\n        scene.beginAnimation(result, serializationObject.autoAnimateFrom, serializationObject.autoAnimateTo, serializationObject.autoAnimateLoop, serializationObject.autoAnimateSpeed || 1.0);\n      }\n    }\n    return result;\n  }\n  /**\n   * Creates a MorphTarget from mesh data\n   * @param mesh defines the source mesh\n   * @param name defines the name to use for the new target\n   * @param influence defines the influence to attach to the target\n   * @returns a new MorphTarget\n   */\n  static FromMesh(mesh, name, influence) {\n    if (!name) {\n      name = mesh.name;\n    }\n    const result = new MorphTarget(name, influence, mesh.getScene());\n    result.setPositions(mesh.getVerticesData(VertexBuffer.PositionKind));\n    if (mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      result.setNormals(mesh.getVerticesData(VertexBuffer.NormalKind));\n    }\n    if (mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n      result.setTangents(mesh.getVerticesData(VertexBuffer.TangentKind));\n    }\n    if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n      result.setUVs(mesh.getVerticesData(VertexBuffer.UVKind));\n    }\n    return result;\n  }\n}\n__decorate([serialize()], MorphTarget.prototype, \"id\", void 0);","map":{"version":3,"names":["Observable","EngineStore","VertexBuffer","serialize","SerializationHelper","GetClass","MorphTarget","influence","_influence","previous","onInfluenceChanged","hasObservers","notifyObservers","animationPropertiesOverride","_animationPropertiesOverride","_scene","value","constructor","name","scene","animations","Array","_positions","_normals","_tangents","_uvs","_uniqueId","_onDataLayoutChanged","LastCreatedScene","getUniqueId","uniqueId","hasPositions","hasNormals","hasTangents","hasUVs","setPositions","data","hadPositions","undefined","getPositions","setNormals","hadNormals","getNormals","setTangents","hadTangents","getTangents","setUVs","hadUVs","getUVs","clone","newOne","Clone","serializationObject","positions","prototype","slice","call","id","normals","tangents","uvs","AppendSerializedAnimations","getClassName","Parse","result","animationIndex","length","parsedAnimation","internalClass","push","autoAnimate","beginAnimation","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","FromMesh","mesh","getScene","getVerticesData","PositionKind","isVerticesDataPresent","NormalKind","TangentKind","UVKind","__decorate"],"sources":["../../../../dev/core/src/Morph/morphTarget.ts"],"sourcesContent":["import type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable, FloatArray } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { AnimationPropertiesOverride } from \"../Animations/animationPropertiesOverride\";\r\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\n\r\nimport type { Animation } from \"../Animations/animation\";\r\n\r\n/**\r\n * Defines a target to use with MorphTargetManager\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/morphTargets\r\n */\r\nexport class MorphTarget implements IAnimatable {\r\n    /**\r\n     * Gets or sets the list of animations\r\n     */\r\n    public animations = new Array<Animation>();\r\n\r\n    private _scene: Nullable<Scene>;\r\n    private _positions: Nullable<FloatArray> = null;\r\n    private _normals: Nullable<FloatArray> = null;\r\n    private _tangents: Nullable<FloatArray> = null;\r\n    private _uvs: Nullable<FloatArray> = null;\r\n    private _influence: number;\r\n    private _uniqueId = 0;\r\n\r\n    /**\r\n     * Observable raised when the influence changes\r\n     */\r\n    public onInfluenceChanged = new Observable<boolean>();\r\n\r\n    /** @internal */\r\n    public _onDataLayoutChanged = new Observable<void>();\r\n\r\n    /**\r\n     * Gets or sets the influence of this target (ie. its weight in the overall morphing)\r\n     */\r\n    public get influence(): number {\r\n        return this._influence;\r\n    }\r\n\r\n    public set influence(influence: number) {\r\n        if (this._influence === influence) {\r\n            return;\r\n        }\r\n\r\n        const previous = this._influence;\r\n        this._influence = influence;\r\n\r\n        if (this.onInfluenceChanged.hasObservers()) {\r\n            this.onInfluenceChanged.notifyObservers(previous === 0 || influence === 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the id of the morph Target\r\n     */\r\n    @serialize()\r\n    public id: string;\r\n\r\n    private _animationPropertiesOverride: Nullable<AnimationPropertiesOverride> = null;\r\n\r\n    /**\r\n     * Gets or sets the animation properties override\r\n     */\r\n    public get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride> {\r\n        if (!this._animationPropertiesOverride && this._scene) {\r\n            return this._scene.animationPropertiesOverride;\r\n        }\r\n        return this._animationPropertiesOverride;\r\n    }\r\n\r\n    public set animationPropertiesOverride(value: Nullable<AnimationPropertiesOverride>) {\r\n        this._animationPropertiesOverride = value;\r\n    }\r\n\r\n    /**\r\n     * Creates a new MorphTarget\r\n     * @param name defines the name of the target\r\n     * @param influence defines the influence to use\r\n     * @param scene defines the scene the morphtarget belongs to\r\n     */\r\n    public constructor(\r\n        /** defines the name of the target */\r\n        public name: string,\r\n        influence = 0,\r\n        scene: Nullable<Scene> = null\r\n    ) {\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        this.influence = influence;\r\n\r\n        if (this._scene) {\r\n            this._uniqueId = this._scene.getUniqueId();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the unique ID of this manager\r\n     */\r\n    public get uniqueId(): number {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains position data\r\n     */\r\n    public get hasPositions(): boolean {\r\n        return !!this._positions;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains normal data\r\n     */\r\n    public get hasNormals(): boolean {\r\n        return !!this._normals;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains tangent data\r\n     */\r\n    public get hasTangents(): boolean {\r\n        return !!this._tangents;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains texture coordinates data\r\n     */\r\n    public get hasUVs(): boolean {\r\n        return !!this._uvs;\r\n    }\r\n\r\n    /**\r\n     * Affects position data to this target\r\n     * @param data defines the position data to use\r\n     */\r\n    public setPositions(data: Nullable<FloatArray>) {\r\n        const hadPositions = this.hasPositions;\r\n\r\n        this._positions = data;\r\n\r\n        if (hadPositions !== this.hasPositions) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the position data stored in this target\r\n     * @returns a FloatArray containing the position data (or null if not present)\r\n     */\r\n    public getPositions(): Nullable<FloatArray> {\r\n        return this._positions;\r\n    }\r\n\r\n    /**\r\n     * Affects normal data to this target\r\n     * @param data defines the normal data to use\r\n     */\r\n    public setNormals(data: Nullable<FloatArray>) {\r\n        const hadNormals = this.hasNormals;\r\n\r\n        this._normals = data;\r\n\r\n        if (hadNormals !== this.hasNormals) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the normal data stored in this target\r\n     * @returns a FloatArray containing the normal data (or null if not present)\r\n     */\r\n    public getNormals(): Nullable<FloatArray> {\r\n        return this._normals;\r\n    }\r\n\r\n    /**\r\n     * Affects tangent data to this target\r\n     * @param data defines the tangent data to use\r\n     */\r\n    public setTangents(data: Nullable<FloatArray>) {\r\n        const hadTangents = this.hasTangents;\r\n\r\n        this._tangents = data;\r\n\r\n        if (hadTangents !== this.hasTangents) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent data stored in this target\r\n     * @returns a FloatArray containing the tangent data (or null if not present)\r\n     */\r\n    public getTangents(): Nullable<FloatArray> {\r\n        return this._tangents;\r\n    }\r\n\r\n    /**\r\n     * Affects texture coordinates data to this target\r\n     * @param data defines the texture coordinates data to use\r\n     */\r\n    public setUVs(data: Nullable<FloatArray>) {\r\n        const hadUVs = this.hasUVs;\r\n\r\n        this._uvs = data;\r\n\r\n        if (hadUVs !== this.hasUVs) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the texture coordinates data stored in this target\r\n     * @returns a FloatArray containing the texture coordinates data (or null if not present)\r\n     */\r\n    public getUVs(): Nullable<FloatArray> {\r\n        return this._uvs;\r\n    }\r\n\r\n    /**\r\n     * Clone the current target\r\n     * @returns a new MorphTarget\r\n     */\r\n    public clone(): MorphTarget {\r\n        const newOne = SerializationHelper.Clone(() => new MorphTarget(this.name, this.influence, this._scene), this);\r\n\r\n        newOne._positions = this._positions;\r\n        newOne._normals = this._normals;\r\n        newOne._tangents = this._tangents;\r\n        newOne._uvs = this._uvs;\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current target into a Serialization object\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.influence = this.influence;\r\n\r\n        serializationObject.positions = Array.prototype.slice.call(this.getPositions());\r\n        if (this.id != null) {\r\n            serializationObject.id = this.id;\r\n        }\r\n        if (this.hasNormals) {\r\n            serializationObject.normals = Array.prototype.slice.call(this.getNormals());\r\n        }\r\n        if (this.hasTangents) {\r\n            serializationObject.tangents = Array.prototype.slice.call(this.getTangents());\r\n        }\r\n        if (this.hasUVs) {\r\n            serializationObject.uvs = Array.prototype.slice.call(this.getUVs());\r\n        }\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"MorphTarget\"\r\n     * @returns \"MorphTarget\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"MorphTarget\";\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Creates a new target from serialized data\r\n     * @param serializationObject defines the serialized data to use\r\n     * @param scene defines the hosting scene\r\n     * @returns a new MorphTarget\r\n     */\r\n    public static Parse(serializationObject: any, scene?: Scene): MorphTarget {\r\n        const result = new MorphTarget(serializationObject.name, serializationObject.influence);\r\n\r\n        result.setPositions(serializationObject.positions);\r\n\r\n        if (serializationObject.id != null) {\r\n            result.id = serializationObject.id;\r\n        }\r\n        if (serializationObject.normals) {\r\n            result.setNormals(serializationObject.normals);\r\n        }\r\n        if (serializationObject.tangents) {\r\n            result.setTangents(serializationObject.tangents);\r\n        }\r\n        if (serializationObject.uvs) {\r\n            result.setUVs(serializationObject.uvs);\r\n        }\r\n\r\n        // Animations\r\n        if (serializationObject.animations) {\r\n            for (let animationIndex = 0; animationIndex < serializationObject.animations.length; animationIndex++) {\r\n                const parsedAnimation = serializationObject.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    result.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n\r\n            if (serializationObject.autoAnimate && scene) {\r\n                scene.beginAnimation(\r\n                    result,\r\n                    serializationObject.autoAnimateFrom,\r\n                    serializationObject.autoAnimateTo,\r\n                    serializationObject.autoAnimateLoop,\r\n                    serializationObject.autoAnimateSpeed || 1.0\r\n                );\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a MorphTarget from mesh data\r\n     * @param mesh defines the source mesh\r\n     * @param name defines the name to use for the new target\r\n     * @param influence defines the influence to attach to the target\r\n     * @returns a new MorphTarget\r\n     */\r\n    public static FromMesh(mesh: AbstractMesh, name?: string, influence?: number): MorphTarget {\r\n        if (!name) {\r\n            name = mesh.name;\r\n        }\r\n\r\n        const result = new MorphTarget(name, influence, mesh.getScene());\r\n\r\n        result.setPositions(<FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind));\r\n\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            result.setNormals(<FloatArray>mesh.getVerticesData(VertexBuffer.NormalKind));\r\n        }\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            result.setTangents(<FloatArray>mesh.getVerticesData(VertexBuffer.TangentKind));\r\n        }\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            result.setUVs(<FloatArray>mesh.getVerticesData(VertexBuffer.UVKind));\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}