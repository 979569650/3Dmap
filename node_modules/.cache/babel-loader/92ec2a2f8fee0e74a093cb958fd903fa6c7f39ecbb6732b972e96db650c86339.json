{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport { Scene } from \"../scene.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { LightConstants } from \"../Lights/lightConstants.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { prepareDefinesForClipPlanes } from \"./clipPlaneMaterialHelper.js\";\n/**\n * \"Static Class\" containing the most commonly used helper while dealing with material for rendering purpose.\n *\n * It contains the basic tools to help defining defines, binding uniform for the common part of the materials.\n *\n * This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.\n */\nexport class MaterialHelper {\n  /**\n   * Binds the scene's uniform buffer to the effect.\n   * @param effect defines the effect to bind to the scene uniform buffer\n   * @param sceneUbo defines the uniform buffer storing scene data\n   */\n  static BindSceneUniformBuffer(effect, sceneUbo) {\n    sceneUbo.bindToEffect(effect, \"Scene\");\n  }\n  /**\n   * Helps preparing the defines values about the UVs in used in the effect.\n   * UVs are shared as much as we can across channels in the shaders.\n   * @param texture The texture we are preparing the UVs for\n   * @param defines The defines to update\n   * @param key The channel key \"diffuse\", \"specular\"... used in the shader\n   */\n  static PrepareDefinesForMergedUV(texture, defines, key) {\n    defines._needUVs = true;\n    defines[key] = true;\n    if (texture.optimizeUVAllocation && texture.getTextureMatrix().isIdentityAs3x2()) {\n      defines[key + \"DIRECTUV\"] = texture.coordinatesIndex + 1;\n      defines[\"MAINUV\" + (texture.coordinatesIndex + 1)] = true;\n    } else {\n      defines[key + \"DIRECTUV\"] = 0;\n    }\n  }\n  /**\n   * Binds a texture matrix value to its corresponding uniform\n   * @param texture The texture to bind the matrix for\n   * @param uniformBuffer The uniform buffer receiving the data\n   * @param key The channel key \"diffuse\", \"specular\"... used in the shader\n   */\n  static BindTextureMatrix(texture, uniformBuffer, key) {\n    const matrix = texture.getTextureMatrix();\n    uniformBuffer.updateMatrix(key + \"Matrix\", matrix);\n  }\n  /**\n   * Gets the current status of the fog (should it be enabled?)\n   * @param mesh defines the mesh to evaluate for fog support\n   * @param scene defines the hosting scene\n   * @returns true if fog must be enabled\n   */\n  static GetFogState(mesh, scene) {\n    return scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE;\n  }\n  /**\n   * Helper used to prepare the list of defines associated with misc. values for shader compilation\n   * @param mesh defines the current mesh\n   * @param scene defines the current scene\n   * @param useLogarithmicDepth defines if logarithmic depth has to be turned on\n   * @param pointsCloud defines if point cloud rendering has to be turned on\n   * @param fogEnabled defines if fog has to be turned on\n   * @param alphaTest defines if alpha testing has to be turned on\n   * @param defines defines the current list of defines\n   * @param applyDecalAfterDetail Defines if the decal is applied after or before the detail\n   */\n  static PrepareDefinesForMisc(mesh, scene, useLogarithmicDepth, pointsCloud, fogEnabled, alphaTest, defines, applyDecalAfterDetail = false) {\n    if (defines._areMiscDirty) {\n      defines[\"LOGARITHMICDEPTH\"] = useLogarithmicDepth;\n      defines[\"POINTSIZE\"] = pointsCloud;\n      defines[\"FOG\"] = fogEnabled && this.GetFogState(mesh, scene);\n      defines[\"NONUNIFORMSCALING\"] = mesh.nonUniformScaling;\n      defines[\"ALPHATEST\"] = alphaTest;\n      defines[\"DECAL_AFTER_DETAIL\"] = applyDecalAfterDetail;\n    }\n  }\n  /**\n   * Helper used to prepare the defines relative to the active camera\n   * @param scene defines the current scene\n   * @param defines specifies the list of active defines\n   * @returns true if the defines have been updated, else false\n   */\n  static PrepareDefinesForCamera(scene, defines) {\n    let changed = false;\n    if (scene.activeCamera) {\n      const wasOrtho = defines[\"CAMERA_ORTHOGRAPHIC\"] ? 1 : 0;\n      const wasPersp = defines[\"CAMERA_PERSPECTIVE\"] ? 1 : 0;\n      const isOrtho = scene.activeCamera.mode === Camera.ORTHOGRAPHIC_CAMERA ? 1 : 0;\n      const isPersp = scene.activeCamera.mode === Camera.PERSPECTIVE_CAMERA ? 1 : 0;\n      if (wasOrtho ^ isOrtho || wasPersp ^ isPersp) {\n        defines[\"CAMERA_ORTHOGRAPHIC\"] = isOrtho === 1;\n        defines[\"CAMERA_PERSPECTIVE\"] = isPersp === 1;\n        changed = true;\n      }\n    }\n    return changed;\n  }\n  /**\n   * Helper used to prepare the list of defines associated with frame values for shader compilation\n   * @param scene defines the current scene\n   * @param engine defines the current engine\n   * @param material defines the material we are compiling the shader for\n   * @param defines specifies the list of active defines\n   * @param useInstances defines if instances have to be turned on\n   * @param useClipPlane defines if clip plane have to be turned on\n   * @param useThinInstances defines if thin instances have to be turned on\n   */\n  static PrepareDefinesForFrameBoundValues(scene, engine, material, defines, useInstances, useClipPlane = null, useThinInstances = false) {\n    let changed = MaterialHelper.PrepareDefinesForCamera(scene, defines);\n    if (useClipPlane !== false) {\n      changed = prepareDefinesForClipPlanes(material, scene, defines);\n    }\n    if (defines[\"DEPTHPREPASS\"] !== !engine.getColorWrite()) {\n      defines[\"DEPTHPREPASS\"] = !defines[\"DEPTHPREPASS\"];\n      changed = true;\n    }\n    if (defines[\"INSTANCES\"] !== useInstances) {\n      defines[\"INSTANCES\"] = useInstances;\n      changed = true;\n    }\n    if (defines[\"THIN_INSTANCES\"] !== useThinInstances) {\n      defines[\"THIN_INSTANCES\"] = useThinInstances;\n      changed = true;\n    }\n    if (changed) {\n      defines.markAsUnprocessed();\n    }\n  }\n  /**\n   * Prepares the defines for bones\n   * @param mesh The mesh containing the geometry data we will draw\n   * @param defines The defines to update\n   */\n  static PrepareDefinesForBones(mesh, defines) {\n    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n      defines[\"NUM_BONE_INFLUENCERS\"] = mesh.numBoneInfluencers;\n      const materialSupportsBoneTexture = defines[\"BONETEXTURE\"] !== undefined;\n      if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {\n        defines[\"BONETEXTURE\"] = true;\n      } else {\n        defines[\"BonesPerMesh\"] = mesh.skeleton.bones.length + 1;\n        defines[\"BONETEXTURE\"] = materialSupportsBoneTexture ? false : undefined;\n        const prePassRenderer = mesh.getScene().prePassRenderer;\n        if (prePassRenderer && prePassRenderer.enabled) {\n          const nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;\n          defines[\"BONES_VELOCITY_ENABLED\"] = nonExcluded;\n        }\n      }\n    } else {\n      defines[\"NUM_BONE_INFLUENCERS\"] = 0;\n      defines[\"BonesPerMesh\"] = 0;\n      if (defines[\"BONETEXTURE\"] !== undefined) {\n        defines[\"BONETEXTURE\"] = false;\n      }\n    }\n  }\n  /**\n   * Prepares the defines for morph targets\n   * @param mesh The mesh containing the geometry data we will draw\n   * @param defines The defines to update\n   */\n  static PrepareDefinesForMorphTargets(mesh, defines) {\n    const manager = mesh.morphTargetManager;\n    if (manager) {\n      defines[\"MORPHTARGETS_UV\"] = manager.supportsUVs && defines[\"UV1\"];\n      defines[\"MORPHTARGETS_TANGENT\"] = manager.supportsTangents && defines[\"TANGENT\"];\n      defines[\"MORPHTARGETS_NORMAL\"] = manager.supportsNormals && defines[\"NORMAL\"];\n      defines[\"MORPHTARGETS\"] = manager.numInfluencers > 0;\n      defines[\"NUM_MORPH_INFLUENCERS\"] = manager.numInfluencers;\n      defines[\"MORPHTARGETS_TEXTURE\"] = manager.isUsingTextureForTargets;\n    } else {\n      defines[\"MORPHTARGETS_UV\"] = false;\n      defines[\"MORPHTARGETS_TANGENT\"] = false;\n      defines[\"MORPHTARGETS_NORMAL\"] = false;\n      defines[\"MORPHTARGETS\"] = false;\n      defines[\"NUM_MORPH_INFLUENCERS\"] = 0;\n    }\n  }\n  /**\n   * Prepares the defines for baked vertex animation\n   * @param mesh The mesh containing the geometry data we will draw\n   * @param defines The defines to update\n   */\n  static PrepareDefinesForBakedVertexAnimation(mesh, defines) {\n    const manager = mesh.bakedVertexAnimationManager;\n    defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] = manager && manager.isEnabled ? true : false;\n  }\n  /**\n   * Prepares the defines used in the shader depending on the attributes data available in the mesh\n   * @param mesh The mesh containing the geometry data we will draw\n   * @param defines The defines to update\n   * @param useVertexColor Precise whether vertex colors should be used or not (override mesh info)\n   * @param useBones Precise whether bones should be used or not (override mesh info)\n   * @param useMorphTargets Precise whether morph targets should be used or not (override mesh info)\n   * @param useVertexAlpha Precise whether vertex alpha should be used or not (override mesh info)\n   * @param useBakedVertexAnimation Precise whether baked vertex animation should be used or not (override mesh info)\n   * @returns false if defines are considered not dirty and have not been checked\n   */\n  static PrepareDefinesForAttributes(mesh, defines, useVertexColor, useBones, useMorphTargets = false, useVertexAlpha = true, useBakedVertexAnimation = true) {\n    if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {\n      return false;\n    }\n    defines._normals = defines._needNormals;\n    defines._uvs = defines._needUVs;\n    defines[\"NORMAL\"] = defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.NormalKind);\n    if (defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n      defines[\"TANGENT\"] = true;\n    }\n    for (let i = 1; i <= 6; ++i) {\n      defines[\"UV\" + i] = defines._needUVs ? mesh.isVerticesDataPresent(`uv${i === 1 ? \"\" : i}`) : false;\n    }\n    if (useVertexColor) {\n      const hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);\n      defines[\"VERTEXCOLOR\"] = hasVertexColors;\n      defines[\"VERTEXALPHA\"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;\n    }\n    if (mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind) && (mesh.hasInstances || mesh.hasThinInstances)) {\n      defines[\"INSTANCESCOLOR\"] = true;\n    }\n    if (useBones) {\n      this.PrepareDefinesForBones(mesh, defines);\n    }\n    if (useMorphTargets) {\n      this.PrepareDefinesForMorphTargets(mesh, defines);\n    }\n    if (useBakedVertexAnimation) {\n      this.PrepareDefinesForBakedVertexAnimation(mesh, defines);\n    }\n    return true;\n  }\n  /**\n   * Prepares the defines related to multiview\n   * @param scene The scene we are intending to draw\n   * @param defines The defines to update\n   */\n  static PrepareDefinesForMultiview(scene, defines) {\n    if (scene.activeCamera) {\n      const previousMultiview = defines.MULTIVIEW;\n      defines.MULTIVIEW = scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1;\n      if (defines.MULTIVIEW != previousMultiview) {\n        defines.markAsUnprocessed();\n      }\n    }\n  }\n  /**\n   * Prepares the defines related to order independant transparency\n   * @param scene The scene we are intending to draw\n   * @param defines The defines to update\n   * @param needAlphaBlending Determines if the material needs alpha blending\n   */\n  static PrepareDefinesForOIT(scene, defines, needAlphaBlending) {\n    const previousDefine = defines.ORDER_INDEPENDENT_TRANSPARENCY;\n    const previousDefine16Bits = defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;\n    defines.ORDER_INDEPENDENT_TRANSPARENCY = scene.useOrderIndependentTransparency && needAlphaBlending;\n    defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !scene.getEngine().getCaps().textureFloatLinearFiltering;\n    if (previousDefine !== defines.ORDER_INDEPENDENT_TRANSPARENCY || previousDefine16Bits !== defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS) {\n      defines.markAsUnprocessed();\n    }\n  }\n  /**\n   * Prepares the defines related to the prepass\n   * @param scene The scene we are intending to draw\n   * @param defines The defines to update\n   * @param canRenderToMRT Indicates if this material renders to several textures in the prepass\n   */\n  static PrepareDefinesForPrePass(scene, defines, canRenderToMRT) {\n    const previousPrePass = defines.PREPASS;\n    if (!defines._arePrePassDirty) {\n      return;\n    }\n    const texturesList = [{\n      type: 1,\n      define: \"PREPASS_POSITION\",\n      index: \"PREPASS_POSITION_INDEX\"\n    }, {\n      type: 2,\n      define: \"PREPASS_VELOCITY\",\n      index: \"PREPASS_VELOCITY_INDEX\"\n    }, {\n      type: 3,\n      define: \"PREPASS_REFLECTIVITY\",\n      index: \"PREPASS_REFLECTIVITY_INDEX\"\n    }, {\n      type: 0,\n      define: \"PREPASS_IRRADIANCE\",\n      index: \"PREPASS_IRRADIANCE_INDEX\"\n    }, {\n      type: 7,\n      define: \"PREPASS_ALBEDO_SQRT\",\n      index: \"PREPASS_ALBEDO_SQRT_INDEX\"\n    }, {\n      type: 5,\n      define: \"PREPASS_DEPTH\",\n      index: \"PREPASS_DEPTH_INDEX\"\n    }, {\n      type: 6,\n      define: \"PREPASS_NORMAL\",\n      index: \"PREPASS_NORMAL_INDEX\"\n    }];\n    if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {\n      defines.PREPASS = true;\n      defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;\n      defines.PREPASS_NORMAL_WORLDSPACE = scene.prePassRenderer.generateNormalsInWorldSpace;\n      for (let i = 0; i < texturesList.length; i++) {\n        const index = scene.prePassRenderer.getIndex(texturesList[i].type);\n        if (index !== -1) {\n          defines[texturesList[i].define] = true;\n          defines[texturesList[i].index] = index;\n        } else {\n          defines[texturesList[i].define] = false;\n        }\n      }\n    } else {\n      defines.PREPASS = false;\n      for (let i = 0; i < texturesList.length; i++) {\n        defines[texturesList[i].define] = false;\n      }\n    }\n    if (defines.PREPASS != previousPrePass) {\n      defines.markAsUnprocessed();\n      defines.markAsImageProcessingDirty();\n    }\n  }\n  /**\n   * Prepares the defines related to the light information passed in parameter\n   * @param scene The scene we are intending to draw\n   * @param mesh The mesh the effect is compiling for\n   * @param light The light the effect is compiling for\n   * @param lightIndex The index of the light\n   * @param defines The defines to update\n   * @param specularSupported Specifies whether specular is supported or not (override lights data)\n   * @param state Defines the current state regarding what is needed (normals, etc...)\n   * @param state.needNormals\n   * @param state.needRebuild\n   * @param state.shadowEnabled\n   * @param state.specularEnabled\n   * @param state.lightmapMode\n   */\n  static PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state) {\n    var _a;\n    state.needNormals = true;\n    if (defines[\"LIGHT\" + lightIndex] === undefined) {\n      state.needRebuild = true;\n    }\n    defines[\"LIGHT\" + lightIndex] = true;\n    defines[\"SPOTLIGHT\" + lightIndex] = false;\n    defines[\"HEMILIGHT\" + lightIndex] = false;\n    defines[\"POINTLIGHT\" + lightIndex] = false;\n    defines[\"DIRLIGHT\" + lightIndex] = false;\n    light.prepareLightSpecificDefines(defines, lightIndex);\n    // FallOff.\n    defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = false;\n    defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = false;\n    defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = false;\n    switch (light.falloffType) {\n      case LightConstants.FALLOFF_GLTF:\n        defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = true;\n        break;\n      case LightConstants.FALLOFF_PHYSICAL:\n        defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = true;\n        break;\n      case LightConstants.FALLOFF_STANDARD:\n        defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = true;\n        break;\n    }\n    // Specular\n    if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {\n      state.specularEnabled = true;\n    }\n    // Shadows\n    defines[\"SHADOW\" + lightIndex] = false;\n    defines[\"SHADOWCSM\" + lightIndex] = false;\n    defines[\"SHADOWCSMDEBUG\" + lightIndex] = false;\n    defines[\"SHADOWCSMNUM_CASCADES\" + lightIndex] = false;\n    defines[\"SHADOWCSMUSESHADOWMAXZ\" + lightIndex] = false;\n    defines[\"SHADOWCSMNOBLEND\" + lightIndex] = false;\n    defines[\"SHADOWCSM_RIGHTHANDED\" + lightIndex] = false;\n    defines[\"SHADOWPCF\" + lightIndex] = false;\n    defines[\"SHADOWPCSS\" + lightIndex] = false;\n    defines[\"SHADOWPOISSON\" + lightIndex] = false;\n    defines[\"SHADOWESM\" + lightIndex] = false;\n    defines[\"SHADOWCLOSEESM\" + lightIndex] = false;\n    defines[\"SHADOWCUBE\" + lightIndex] = false;\n    defines[\"SHADOWLOWQUALITY\" + lightIndex] = false;\n    defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = false;\n    if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {\n      const shadowGenerator = (_a = light.getShadowGenerator(scene.activeCamera)) !== null && _a !== void 0 ? _a : light.getShadowGenerator();\n      if (shadowGenerator) {\n        const shadowMap = shadowGenerator.getShadowMap();\n        if (shadowMap) {\n          if (shadowMap.renderList && shadowMap.renderList.length > 0) {\n            state.shadowEnabled = true;\n            shadowGenerator.prepareDefines(defines, lightIndex);\n          }\n        }\n      }\n    }\n    if (light.lightmapMode != LightConstants.LIGHTMAP_DEFAULT) {\n      state.lightmapMode = true;\n      defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = true;\n      defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = light.lightmapMode == LightConstants.LIGHTMAP_SHADOWSONLY;\n    } else {\n      defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = false;\n      defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = false;\n    }\n  }\n  /**\n   * Prepares the defines related to the light information passed in parameter\n   * @param scene The scene we are intending to draw\n   * @param mesh The mesh the effect is compiling for\n   * @param defines The defines to update\n   * @param specularSupported Specifies whether specular is supported or not (override lights data)\n   * @param maxSimultaneousLights Specifies how manuy lights can be added to the effect at max\n   * @param disableLighting Specifies whether the lighting is disabled (override scene and light)\n   * @returns true if normals will be required for the rest of the effect\n   */\n  static PrepareDefinesForLights(scene, mesh, defines, specularSupported, maxSimultaneousLights = 4, disableLighting = false) {\n    if (!defines._areLightsDirty) {\n      return defines._needNormals;\n    }\n    let lightIndex = 0;\n    const state = {\n      needNormals: defines._needNormals,\n      needRebuild: false,\n      lightmapMode: false,\n      shadowEnabled: false,\n      specularEnabled: false\n    };\n    if (scene.lightsEnabled && !disableLighting) {\n      for (const light of mesh.lightSources) {\n        this.PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);\n        lightIndex++;\n        if (lightIndex === maxSimultaneousLights) {\n          break;\n        }\n      }\n    }\n    defines[\"SPECULARTERM\"] = state.specularEnabled;\n    defines[\"SHADOWS\"] = state.shadowEnabled;\n    // Resetting all other lights if any\n    for (let index = lightIndex; index < maxSimultaneousLights; index++) {\n      if (defines[\"LIGHT\" + index] !== undefined) {\n        defines[\"LIGHT\" + index] = false;\n        defines[\"HEMILIGHT\" + index] = false;\n        defines[\"POINTLIGHT\" + index] = false;\n        defines[\"DIRLIGHT\" + index] = false;\n        defines[\"SPOTLIGHT\" + index] = false;\n        defines[\"SHADOW\" + index] = false;\n        defines[\"SHADOWCSM\" + index] = false;\n        defines[\"SHADOWCSMDEBUG\" + index] = false;\n        defines[\"SHADOWCSMNUM_CASCADES\" + index] = false;\n        defines[\"SHADOWCSMUSESHADOWMAXZ\" + index] = false;\n        defines[\"SHADOWCSMNOBLEND\" + index] = false;\n        defines[\"SHADOWCSM_RIGHTHANDED\" + index] = false;\n        defines[\"SHADOWPCF\" + index] = false;\n        defines[\"SHADOWPCSS\" + index] = false;\n        defines[\"SHADOWPOISSON\" + index] = false;\n        defines[\"SHADOWESM\" + index] = false;\n        defines[\"SHADOWCLOSEESM\" + index] = false;\n        defines[\"SHADOWCUBE\" + index] = false;\n        defines[\"SHADOWLOWQUALITY\" + index] = false;\n        defines[\"SHADOWMEDIUMQUALITY\" + index] = false;\n      }\n    }\n    const caps = scene.getEngine().getCaps();\n    if (defines[\"SHADOWFLOAT\"] === undefined) {\n      state.needRebuild = true;\n    }\n    defines[\"SHADOWFLOAT\"] = state.shadowEnabled && (caps.textureFloatRender && caps.textureFloatLinearFiltering || caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering);\n    defines[\"LIGHTMAPEXCLUDED\"] = state.lightmapMode;\n    if (state.needRebuild) {\n      defines.rebuild();\n    }\n    return state.needNormals;\n  }\n  /**\n   * Prepares the uniforms and samplers list to be used in the effect (for a specific light)\n   * @param lightIndex defines the light index\n   * @param uniformsList The uniform list\n   * @param samplersList The sampler list\n   * @param projectedLightTexture defines if projected texture must be used\n   * @param uniformBuffersList defines an optional list of uniform buffers\n   * @param updateOnlyBuffersList True to only update the uniformBuffersList array\n   */\n  static PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, projectedLightTexture, uniformBuffersList = null, updateOnlyBuffersList = false) {\n    if (uniformBuffersList) {\n      uniformBuffersList.push(\"Light\" + lightIndex);\n    }\n    if (updateOnlyBuffersList) {\n      return;\n    }\n    uniformsList.push(\"vLightData\" + lightIndex, \"vLightDiffuse\" + lightIndex, \"vLightSpecular\" + lightIndex, \"vLightDirection\" + lightIndex, \"vLightFalloff\" + lightIndex, \"vLightGround\" + lightIndex, \"lightMatrix\" + lightIndex, \"shadowsInfo\" + lightIndex, \"depthValues\" + lightIndex);\n    samplersList.push(\"shadowSampler\" + lightIndex);\n    samplersList.push(\"depthSampler\" + lightIndex);\n    uniformsList.push(\"viewFrustumZ\" + lightIndex, \"cascadeBlendFactor\" + lightIndex, \"lightSizeUVCorrection\" + lightIndex, \"depthCorrection\" + lightIndex, \"penumbraDarkness\" + lightIndex, \"frustumLengths\" + lightIndex);\n    if (projectedLightTexture) {\n      samplersList.push(\"projectionLightSampler\" + lightIndex);\n      uniformsList.push(\"textureProjectionMatrix\" + lightIndex);\n    }\n  }\n  /**\n   * Prepares the uniforms and samplers list to be used in the effect\n   * @param uniformsListOrOptions The uniform names to prepare or an EffectCreationOptions containing the list and extra information\n   * @param samplersList The sampler list\n   * @param defines The defines helping in the list generation\n   * @param maxSimultaneousLights The maximum number of simultaneous light allowed in the effect\n   */\n  static PrepareUniformsAndSamplersList(uniformsListOrOptions, samplersList, defines, maxSimultaneousLights = 4) {\n    let uniformsList;\n    let uniformBuffersList = null;\n    if (uniformsListOrOptions.uniformsNames) {\n      const options = uniformsListOrOptions;\n      uniformsList = options.uniformsNames;\n      uniformBuffersList = options.uniformBuffersNames;\n      samplersList = options.samplers;\n      defines = options.defines;\n      maxSimultaneousLights = options.maxSimultaneousLights || 0;\n    } else {\n      uniformsList = uniformsListOrOptions;\n      if (!samplersList) {\n        samplersList = [];\n      }\n    }\n    for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\n      if (!defines[\"LIGHT\" + lightIndex]) {\n        break;\n      }\n      this.PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex], uniformBuffersList);\n    }\n    if (defines[\"NUM_MORPH_INFLUENCERS\"]) {\n      uniformsList.push(\"morphTargetInfluences\");\n    }\n    if (defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"]) {\n      uniformsList.push(\"bakedVertexAnimationSettings\");\n      uniformsList.push(\"bakedVertexAnimationTextureSizeInverted\");\n      uniformsList.push(\"bakedVertexAnimationTime\");\n      samplersList.push(\"bakedVertexAnimationTexture\");\n    }\n  }\n  /**\n   * This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)\n   * @param defines The defines to update while falling back\n   * @param fallbacks The authorized effect fallbacks\n   * @param maxSimultaneousLights The maximum number of lights allowed\n   * @param rank the current rank of the Effect\n   * @returns The newly affected rank\n   */\n  static HandleFallbacksForShadows(defines, fallbacks, maxSimultaneousLights = 4, rank = 0) {\n    let lightFallbackRank = 0;\n    for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\n      if (!defines[\"LIGHT\" + lightIndex]) {\n        break;\n      }\n      if (lightIndex > 0) {\n        lightFallbackRank = rank + lightIndex;\n        fallbacks.addFallback(lightFallbackRank, \"LIGHT\" + lightIndex);\n      }\n      if (!defines[\"SHADOWS\"]) {\n        if (defines[\"SHADOW\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOW\" + lightIndex);\n        }\n        if (defines[\"SHADOWPCF\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOWPCF\" + lightIndex);\n        }\n        if (defines[\"SHADOWPCSS\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOWPCSS\" + lightIndex);\n        }\n        if (defines[\"SHADOWPOISSON\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOWPOISSON\" + lightIndex);\n        }\n        if (defines[\"SHADOWESM\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOWESM\" + lightIndex);\n        }\n        if (defines[\"SHADOWCLOSEESM\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOWCLOSEESM\" + lightIndex);\n        }\n      }\n    }\n    return lightFallbackRank++;\n  }\n  /**\n   * Prepares the list of attributes required for morph targets according to the effect defines.\n   * @param attribs The current list of supported attribs\n   * @param mesh The mesh to prepare the morph targets attributes for\n   * @param influencers The number of influencers\n   */\n  static PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, influencers) {\n    this._TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;\n    this.PrepareAttributesForMorphTargets(attribs, mesh, this._TmpMorphInfluencers);\n  }\n  /**\n   * Prepares the list of attributes required for morph targets according to the effect defines.\n   * @param attribs The current list of supported attribs\n   * @param mesh The mesh to prepare the morph targets attributes for\n   * @param defines The current Defines of the effect\n   */\n  static PrepareAttributesForMorphTargets(attribs, mesh, defines) {\n    const influencers = defines[\"NUM_MORPH_INFLUENCERS\"];\n    if (influencers > 0 && EngineStore.LastCreatedEngine) {\n      const maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;\n      const manager = mesh.morphTargetManager;\n      if (manager === null || manager === void 0 ? void 0 : manager.isUsingTextureForTargets) {\n        return;\n      }\n      const normal = manager && manager.supportsNormals && defines[\"NORMAL\"];\n      const tangent = manager && manager.supportsTangents && defines[\"TANGENT\"];\n      const uv = manager && manager.supportsUVs && defines[\"UV1\"];\n      for (let index = 0; index < influencers; index++) {\n        attribs.push(VertexBuffer.PositionKind + index);\n        if (normal) {\n          attribs.push(VertexBuffer.NormalKind + index);\n        }\n        if (tangent) {\n          attribs.push(VertexBuffer.TangentKind + index);\n        }\n        if (uv) {\n          attribs.push(VertexBuffer.UVKind + \"_\" + index);\n        }\n        if (attribs.length > maxAttributesCount) {\n          Logger.Error(\"Cannot add more vertex attributes for mesh \" + mesh.name);\n        }\n      }\n    }\n  }\n  /**\n   * Prepares the list of attributes required for baked vertex animations according to the effect defines.\n   * @param attribs The current list of supported attribs\n   * @param mesh The mesh to prepare the morph targets attributes for\n   * @param defines The current Defines of the effect\n   */\n  static PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines) {\n    const enabled = defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] && defines[\"INSTANCES\"];\n    if (enabled) {\n      attribs.push(\"bakedVertexAnimationSettingsInstanced\");\n    }\n  }\n  /**\n   * Prepares the list of attributes required for bones according to the effect defines.\n   * @param attribs The current list of supported attribs\n   * @param mesh The mesh to prepare the bones attributes for\n   * @param defines The current Defines of the effect\n   * @param fallbacks The current effect fallback strategy\n   */\n  static PrepareAttributesForBones(attribs, mesh, defines, fallbacks) {\n    if (defines[\"NUM_BONE_INFLUENCERS\"] > 0) {\n      fallbacks.addCPUSkinningFallback(0, mesh);\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n      if (defines[\"NUM_BONE_INFLUENCERS\"] > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n    }\n  }\n  /**\n   * Check and prepare the list of attributes required for instances according to the effect defines.\n   * @param attribs The current list of supported attribs\n   * @param defines The current MaterialDefines of the effect\n   */\n  static PrepareAttributesForInstances(attribs, defines) {\n    if (defines[\"INSTANCES\"] || defines[\"THIN_INSTANCES\"]) {\n      this.PushAttributesForInstances(attribs, !!defines[\"PREPASS_VELOCITY\"]);\n    }\n    if (defines.INSTANCESCOLOR) {\n      attribs.push(VertexBuffer.ColorInstanceKind);\n    }\n  }\n  /**\n   * Add the list of attributes required for instances to the attribs array.\n   * @param attribs The current list of supported attribs\n   * @param needsPreviousMatrices If the shader needs previous matrices\n   */\n  static PushAttributesForInstances(attribs, needsPreviousMatrices = false) {\n    attribs.push(\"world0\");\n    attribs.push(\"world1\");\n    attribs.push(\"world2\");\n    attribs.push(\"world3\");\n    if (needsPreviousMatrices) {\n      attribs.push(\"previousWorld0\");\n      attribs.push(\"previousWorld1\");\n      attribs.push(\"previousWorld2\");\n      attribs.push(\"previousWorld3\");\n    }\n  }\n  /**\n   * Binds the light information to the effect.\n   * @param light The light containing the generator\n   * @param effect The effect we are binding the data to\n   * @param lightIndex The light index in the effect used to render\n   */\n  static BindLightProperties(light, effect, lightIndex) {\n    light.transferToEffect(effect, lightIndex + \"\");\n  }\n  /**\n   * Binds the lights information from the scene to the effect for the given mesh.\n   * @param light Light to bind\n   * @param lightIndex Light index\n   * @param scene The scene where the light belongs to\n   * @param effect The effect we are binding the data to\n   * @param useSpecular Defines if specular is supported\n   * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\n   */\n  static BindLight(light, lightIndex, scene, effect, useSpecular, receiveShadows = true) {\n    light._bindLight(lightIndex, scene, effect, useSpecular, receiveShadows);\n  }\n  /**\n   * Binds the lights information from the scene to the effect for the given mesh.\n   * @param scene The scene the lights belongs to\n   * @param mesh The mesh we are binding the information to render\n   * @param effect The effect we are binding the data to\n   * @param defines The generated defines for the effect\n   * @param maxSimultaneousLights The maximum number of light that can be bound to the effect\n   */\n  static BindLights(scene, mesh, effect, defines, maxSimultaneousLights = 4) {\n    const len = Math.min(mesh.lightSources.length, maxSimultaneousLights);\n    for (let i = 0; i < len; i++) {\n      const light = mesh.lightSources[i];\n      this.BindLight(light, i, scene, effect, typeof defines === \"boolean\" ? defines : defines[\"SPECULARTERM\"], mesh.receiveShadows);\n    }\n  }\n  /**\n   * Binds the fog information from the scene to the effect for the given mesh.\n   * @param scene The scene the lights belongs to\n   * @param mesh The mesh we are binding the information to render\n   * @param effect The effect we are binding the data to\n   * @param linearSpace Defines if the fog effect is applied in linear space\n   */\n  static BindFogParameters(scene, mesh, effect, linearSpace = false) {\n    if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\n      effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\n      // Convert fog color to linear space if used in a linear space computed shader.\n      if (linearSpace) {\n        scene.fogColor.toLinearSpaceToRef(this._TempFogColor, scene.getEngine().useExactSrgbConversions);\n        effect.setColor3(\"vFogColor\", this._TempFogColor);\n      } else {\n        effect.setColor3(\"vFogColor\", scene.fogColor);\n      }\n    }\n  }\n  /**\n   * Binds the bones information from the mesh to the effect.\n   * @param mesh The mesh we are binding the information to render\n   * @param effect The effect we are binding the data to\n   * @param prePassConfiguration Configuration for the prepass, in case prepass is activated\n   */\n  static BindBonesParameters(mesh, effect, prePassConfiguration) {\n    if (!effect || !mesh) {\n      return;\n    }\n    if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {\n      mesh.computeBonesUsingShaders = false;\n    }\n    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n      const skeleton = mesh.skeleton;\n      if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex(\"boneTextureWidth\") > -1) {\n        const boneTexture = skeleton.getTransformMatrixTexture(mesh);\n        effect.setTexture(\"boneSampler\", boneTexture);\n        effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\n      } else {\n        const matrices = skeleton.getTransformMatrices(mesh);\n        if (matrices) {\n          effect.setMatrices(\"mBones\", matrices);\n          if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer.getIndex(2)) {\n            if (!prePassConfiguration.previousBones[mesh.uniqueId]) {\n              prePassConfiguration.previousBones[mesh.uniqueId] = matrices.slice();\n            }\n            effect.setMatrices(\"mPreviousBones\", prePassConfiguration.previousBones[mesh.uniqueId]);\n            MaterialHelper._CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);\n          }\n        }\n      }\n    }\n  }\n  // Copies the bones transformation matrices into the target array and returns the target's reference\n  static _CopyBonesTransformationMatrices(source, target) {\n    target.set(source);\n    return target;\n  }\n  /**\n   * Binds the morph targets information from the mesh to the effect.\n   * @param abstractMesh The mesh we are binding the information to render\n   * @param effect The effect we are binding the data to\n   */\n  static BindMorphTargetParameters(abstractMesh, effect) {\n    const manager = abstractMesh.morphTargetManager;\n    if (!abstractMesh || !manager) {\n      return;\n    }\n    effect.setFloatArray(\"morphTargetInfluences\", manager.influences);\n  }\n  /**\n   * Binds the logarithmic depth information from the scene to the effect for the given defines.\n   * @param defines The generated defines used in the effect\n   * @param effect The effect we are binding the data to\n   * @param scene The scene we are willing to render with logarithmic scale for\n   */\n  static BindLogDepth(defines, effect, scene) {\n    if (!defines || defines[\"LOGARITHMICDEPTH\"] || defines.indexOf && defines.indexOf(\"LOGARITHMICDEPTH\") >= 0) {\n      const camera = scene.activeCamera;\n      if (camera.mode === Camera.ORTHOGRAPHIC_CAMERA) {\n        Logger.Error(\"Logarithmic depth is not compatible with orthographic cameras!\", 20);\n      }\n      effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(camera.maxZ + 1.0) / Math.LN2));\n    }\n  }\n}\n// eslint-disable-next-line @typescript-eslint/naming-convention\nMaterialHelper._TmpMorphInfluencers = {\n  NUM_MORPH_INFLUENCERS: 0\n};\nMaterialHelper._TempFogColor = Color3.Black();","map":{"version":3,"names":["Logger","Camera","Scene","EngineStore","VertexBuffer","LightConstants","Color3","prepareDefinesForClipPlanes","MaterialHelper","BindSceneUniformBuffer","effect","sceneUbo","bindToEffect","PrepareDefinesForMergedUV","texture","defines","key","_needUVs","optimizeUVAllocation","getTextureMatrix","isIdentityAs3x2","coordinatesIndex","BindTextureMatrix","uniformBuffer","matrix","updateMatrix","GetFogState","mesh","scene","fogEnabled","applyFog","fogMode","FOGMODE_NONE","PrepareDefinesForMisc","useLogarithmicDepth","pointsCloud","alphaTest","applyDecalAfterDetail","_areMiscDirty","nonUniformScaling","PrepareDefinesForCamera","changed","activeCamera","wasOrtho","wasPersp","isOrtho","mode","ORTHOGRAPHIC_CAMERA","isPersp","PERSPECTIVE_CAMERA","PrepareDefinesForFrameBoundValues","engine","material","useInstances","useClipPlane","useThinInstances","getColorWrite","markAsUnprocessed","PrepareDefinesForBones","useBones","computeBonesUsingShaders","skeleton","numBoneInfluencers","materialSupportsBoneTexture","undefined","isUsingTextureForMatrices","bones","length","prePassRenderer","getScene","enabled","nonExcluded","excludedSkinnedMesh","indexOf","PrepareDefinesForMorphTargets","manager","morphTargetManager","supportsUVs","supportsTangents","supportsNormals","numInfluencers","isUsingTextureForTargets","PrepareDefinesForBakedVertexAnimation","bakedVertexAnimationManager","isEnabled","PrepareDefinesForAttributes","useVertexColor","useMorphTargets","useVertexAlpha","useBakedVertexAnimation","_areAttributesDirty","_needNormals","_normals","_uvs","isVerticesDataPresent","NormalKind","TangentKind","i","hasVertexColors","useVertexColors","ColorKind","hasVertexAlpha","ColorInstanceKind","hasInstances","hasThinInstances","PrepareDefinesForMultiview","previousMultiview","MULTIVIEW","outputRenderTarget","getViewCount","PrepareDefinesForOIT","needAlphaBlending","previousDefine","ORDER_INDEPENDENT_TRANSPARENCY","previousDefine16Bits","ORDER_INDEPENDENT_TRANSPARENCY_16BITS","useOrderIndependentTransparency","getEngine","getCaps","textureFloatLinearFiltering","PrepareDefinesForPrePass","canRenderToMRT","previousPrePass","PREPASS","_arePrePassDirty","texturesList","type","define","index","SCENE_MRT_COUNT","mrtCount","PREPASS_NORMAL_WORLDSPACE","generateNormalsInWorldSpace","getIndex","markAsImageProcessingDirty","PrepareDefinesForLight","light","lightIndex","specularSupported","state","needNormals","needRebuild","prepareLightSpecificDefines","falloffType","FALLOFF_GLTF","FALLOFF_PHYSICAL","FALLOFF_STANDARD","specular","equalsFloats","specularEnabled","receiveShadows","shadowsEnabled","shadowEnabled","shadowGenerator","_a","getShadowGenerator","shadowMap","getShadowMap","renderList","prepareDefines","lightmapMode","LIGHTMAP_DEFAULT","LIGHTMAP_SHADOWSONLY","PrepareDefinesForLights","maxSimultaneousLights","disableLighting","_areLightsDirty","lightsEnabled","lightSources","caps","textureFloatRender","textureHalfFloatRender","textureHalfFloatLinearFiltering","rebuild","PrepareUniformsAndSamplersForLight","uniformsList","samplersList","projectedLightTexture","uniformBuffersList","updateOnlyBuffersList","push","PrepareUniformsAndSamplersList","uniformsListOrOptions","uniformsNames","options","uniformBuffersNames","samplers","HandleFallbacksForShadows","fallbacks","rank","lightFallbackRank","addFallback","PrepareAttributesForMorphTargetsInfluencers","attribs","influencers","_TmpMorphInfluencers","NUM_MORPH_INFLUENCERS","PrepareAttributesForMorphTargets","LastCreatedEngine","maxAttributesCount","maxVertexAttribs","normal","tangent","uv","PositionKind","UVKind","Error","name","PrepareAttributesForBakedVertexAnimation","PrepareAttributesForBones","addCPUSkinningFallback","MatricesIndicesKind","MatricesWeightsKind","MatricesIndicesExtraKind","MatricesWeightsExtraKind","PrepareAttributesForInstances","PushAttributesForInstances","INSTANCESCOLOR","needsPreviousMatrices","BindLightProperties","transferToEffect","BindLight","useSpecular","_bindLight","BindLights","len","Math","min","BindFogParameters","linearSpace","setFloat4","fogStart","fogEnd","fogDensity","fogColor","toLinearSpaceToRef","_TempFogColor","useExactSrgbConversions","setColor3","BindBonesParameters","prePassConfiguration","_bonesComputationForcedToCPU","getUniformIndex","boneTexture","getTransformMatrixTexture","setTexture","setFloat","matrices","getTransformMatrices","setMatrices","previousBones","uniqueId","slice","_CopyBonesTransformationMatrices","source","target","set","BindMorphTargetParameters","abstractMesh","setFloatArray","influences","BindLogDepth","camera","log","maxZ","LN2","Black"],"sources":["../../../../dev/core/src/Materials/materialHelper.ts"],"sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Scene } from \"../scene\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport { LightConstants } from \"../Lights/lightConstants\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { PrePassConfiguration } from \"../Materials/prePassConfiguration\";\r\n\r\nimport type { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { Effect, IEffectCreationOptions } from \"./effect\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { MaterialDefines } from \"./materialDefines\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { EffectFallbacks } from \"./effectFallbacks\";\r\nimport { prepareDefinesForClipPlanes } from \"./clipPlaneMaterialHelper\";\r\nimport type { Material } from \"./material\";\r\n\r\n/**\r\n * \"Static Class\" containing the most commonly used helper while dealing with material for rendering purpose.\r\n *\r\n * It contains the basic tools to help defining defines, binding uniform for the common part of the materials.\r\n *\r\n * This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.\r\n */\r\nexport class MaterialHelper {\r\n    /**\r\n     * Binds the scene's uniform buffer to the effect.\r\n     * @param effect defines the effect to bind to the scene uniform buffer\r\n     * @param sceneUbo defines the uniform buffer storing scene data\r\n     */\r\n    public static BindSceneUniformBuffer(effect: Effect, sceneUbo: UniformBuffer): void {\r\n        sceneUbo.bindToEffect(effect, \"Scene\");\r\n    }\r\n\r\n    /**\r\n     * Helps preparing the defines values about the UVs in used in the effect.\r\n     * UVs are shared as much as we can across channels in the shaders.\r\n     * @param texture The texture we are preparing the UVs for\r\n     * @param defines The defines to update\r\n     * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n     */\r\n    public static PrepareDefinesForMergedUV(texture: BaseTexture, defines: any, key: string): void {\r\n        defines._needUVs = true;\r\n        defines[key] = true;\r\n        if (texture.optimizeUVAllocation && texture.getTextureMatrix().isIdentityAs3x2()) {\r\n            defines[key + \"DIRECTUV\"] = texture.coordinatesIndex + 1;\r\n            defines[\"MAINUV\" + (texture.coordinatesIndex + 1)] = true;\r\n        } else {\r\n            defines[key + \"DIRECTUV\"] = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds a texture matrix value to its corresponding uniform\r\n     * @param texture The texture to bind the matrix for\r\n     * @param uniformBuffer The uniform buffer receiving the data\r\n     * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n     */\r\n    public static BindTextureMatrix(texture: BaseTexture, uniformBuffer: UniformBuffer, key: string): void {\r\n        const matrix = texture.getTextureMatrix();\r\n\r\n        uniformBuffer.updateMatrix(key + \"Matrix\", matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the current status of the fog (should it be enabled?)\r\n     * @param mesh defines the mesh to evaluate for fog support\r\n     * @param scene defines the hosting scene\r\n     * @returns true if fog must be enabled\r\n     */\r\n    public static GetFogState(mesh: AbstractMesh, scene: Scene) {\r\n        return scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE;\r\n    }\r\n\r\n    /**\r\n     * Helper used to prepare the list of defines associated with misc. values for shader compilation\r\n     * @param mesh defines the current mesh\r\n     * @param scene defines the current scene\r\n     * @param useLogarithmicDepth defines if logarithmic depth has to be turned on\r\n     * @param pointsCloud defines if point cloud rendering has to be turned on\r\n     * @param fogEnabled defines if fog has to be turned on\r\n     * @param alphaTest defines if alpha testing has to be turned on\r\n     * @param defines defines the current list of defines\r\n     * @param applyDecalAfterDetail Defines if the decal is applied after or before the detail\r\n     */\r\n    public static PrepareDefinesForMisc(\r\n        mesh: AbstractMesh,\r\n        scene: Scene,\r\n        useLogarithmicDepth: boolean,\r\n        pointsCloud: boolean,\r\n        fogEnabled: boolean,\r\n        alphaTest: boolean,\r\n        defines: any,\r\n        applyDecalAfterDetail: boolean = false\r\n    ): void {\r\n        if (defines._areMiscDirty) {\r\n            defines[\"LOGARITHMICDEPTH\"] = useLogarithmicDepth;\r\n            defines[\"POINTSIZE\"] = pointsCloud;\r\n            defines[\"FOG\"] = fogEnabled && this.GetFogState(mesh, scene);\r\n            defines[\"NONUNIFORMSCALING\"] = mesh.nonUniformScaling;\r\n            defines[\"ALPHATEST\"] = alphaTest;\r\n            defines[\"DECAL_AFTER_DETAIL\"] = applyDecalAfterDetail;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper used to prepare the defines relative to the active camera\r\n     * @param scene defines the current scene\r\n     * @param defines specifies the list of active defines\r\n     * @returns true if the defines have been updated, else false\r\n     */\r\n    public static PrepareDefinesForCamera(scene: Scene, defines: any): boolean {\r\n        let changed = false;\r\n\r\n        if (scene.activeCamera) {\r\n            const wasOrtho = defines[\"CAMERA_ORTHOGRAPHIC\"] ? 1 : 0;\r\n            const wasPersp = defines[\"CAMERA_PERSPECTIVE\"] ? 1 : 0;\r\n            const isOrtho = scene.activeCamera.mode === Camera.ORTHOGRAPHIC_CAMERA ? 1 : 0;\r\n            const isPersp = scene.activeCamera.mode === Camera.PERSPECTIVE_CAMERA ? 1 : 0;\r\n\r\n            if (wasOrtho ^ isOrtho || wasPersp ^ isPersp) {\r\n                defines[\"CAMERA_ORTHOGRAPHIC\"] = isOrtho === 1;\r\n                defines[\"CAMERA_PERSPECTIVE\"] = isPersp === 1;\r\n                changed = true;\r\n            }\r\n        }\r\n\r\n        return changed;\r\n    }\r\n\r\n    /**\r\n     * Helper used to prepare the list of defines associated with frame values for shader compilation\r\n     * @param scene defines the current scene\r\n     * @param engine defines the current engine\r\n     * @param material defines the material we are compiling the shader for\r\n     * @param defines specifies the list of active defines\r\n     * @param useInstances defines if instances have to be turned on\r\n     * @param useClipPlane defines if clip plane have to be turned on\r\n     * @param useThinInstances defines if thin instances have to be turned on\r\n     */\r\n    public static PrepareDefinesForFrameBoundValues(\r\n        scene: Scene,\r\n        engine: Engine,\r\n        material: Material,\r\n        defines: any,\r\n        useInstances: boolean,\r\n        useClipPlane: Nullable<boolean> = null,\r\n        useThinInstances: boolean = false\r\n    ): void {\r\n        let changed = MaterialHelper.PrepareDefinesForCamera(scene, defines);\r\n\r\n        if (useClipPlane !== false) {\r\n            changed = prepareDefinesForClipPlanes(material, scene, defines);\r\n        }\r\n\r\n        if (defines[\"DEPTHPREPASS\"] !== !engine.getColorWrite()) {\r\n            defines[\"DEPTHPREPASS\"] = !defines[\"DEPTHPREPASS\"];\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"INSTANCES\"] !== useInstances) {\r\n            defines[\"INSTANCES\"] = useInstances;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"THIN_INSTANCES\"] !== useThinInstances) {\r\n            defines[\"THIN_INSTANCES\"] = useThinInstances;\r\n            changed = true;\r\n        }\r\n\r\n        if (changed) {\r\n            defines.markAsUnprocessed();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines for bones\r\n     * @param mesh The mesh containing the geometry data we will draw\r\n     * @param defines The defines to update\r\n     */\r\n    public static PrepareDefinesForBones(mesh: AbstractMesh, defines: any) {\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            defines[\"NUM_BONE_INFLUENCERS\"] = mesh.numBoneInfluencers;\r\n\r\n            const materialSupportsBoneTexture = defines[\"BONETEXTURE\"] !== undefined;\r\n\r\n            if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {\r\n                defines[\"BONETEXTURE\"] = true;\r\n            } else {\r\n                defines[\"BonesPerMesh\"] = mesh.skeleton.bones.length + 1;\r\n                defines[\"BONETEXTURE\"] = materialSupportsBoneTexture ? false : undefined;\r\n\r\n                const prePassRenderer = mesh.getScene().prePassRenderer;\r\n                if (prePassRenderer && prePassRenderer.enabled) {\r\n                    const nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;\r\n                    defines[\"BONES_VELOCITY_ENABLED\"] = nonExcluded;\r\n                }\r\n            }\r\n        } else {\r\n            defines[\"NUM_BONE_INFLUENCERS\"] = 0;\r\n            defines[\"BonesPerMesh\"] = 0;\r\n            if (defines[\"BONETEXTURE\"] !== undefined) {\r\n                defines[\"BONETEXTURE\"] = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines for morph targets\r\n     * @param mesh The mesh containing the geometry data we will draw\r\n     * @param defines The defines to update\r\n     */\r\n    public static PrepareDefinesForMorphTargets(mesh: AbstractMesh, defines: any) {\r\n        const manager = (<Mesh>mesh).morphTargetManager;\r\n        if (manager) {\r\n            defines[\"MORPHTARGETS_UV\"] = manager.supportsUVs && defines[\"UV1\"];\r\n            defines[\"MORPHTARGETS_TANGENT\"] = manager.supportsTangents && defines[\"TANGENT\"];\r\n            defines[\"MORPHTARGETS_NORMAL\"] = manager.supportsNormals && defines[\"NORMAL\"];\r\n            defines[\"MORPHTARGETS\"] = manager.numInfluencers > 0;\r\n            defines[\"NUM_MORPH_INFLUENCERS\"] = manager.numInfluencers;\r\n\r\n            defines[\"MORPHTARGETS_TEXTURE\"] = manager.isUsingTextureForTargets;\r\n        } else {\r\n            defines[\"MORPHTARGETS_UV\"] = false;\r\n            defines[\"MORPHTARGETS_TANGENT\"] = false;\r\n            defines[\"MORPHTARGETS_NORMAL\"] = false;\r\n            defines[\"MORPHTARGETS\"] = false;\r\n            defines[\"NUM_MORPH_INFLUENCERS\"] = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines for baked vertex animation\r\n     * @param mesh The mesh containing the geometry data we will draw\r\n     * @param defines The defines to update\r\n     */\r\n    public static PrepareDefinesForBakedVertexAnimation(mesh: AbstractMesh, defines: any) {\r\n        const manager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n        defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] = manager && manager.isEnabled ? true : false;\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines used in the shader depending on the attributes data available in the mesh\r\n     * @param mesh The mesh containing the geometry data we will draw\r\n     * @param defines The defines to update\r\n     * @param useVertexColor Precise whether vertex colors should be used or not (override mesh info)\r\n     * @param useBones Precise whether bones should be used or not (override mesh info)\r\n     * @param useMorphTargets Precise whether morph targets should be used or not (override mesh info)\r\n     * @param useVertexAlpha Precise whether vertex alpha should be used or not (override mesh info)\r\n     * @param useBakedVertexAnimation Precise whether baked vertex animation should be used or not (override mesh info)\r\n     * @returns false if defines are considered not dirty and have not been checked\r\n     */\r\n    public static PrepareDefinesForAttributes(\r\n        mesh: AbstractMesh,\r\n        defines: any,\r\n        useVertexColor: boolean,\r\n        useBones: boolean,\r\n        useMorphTargets = false,\r\n        useVertexAlpha = true,\r\n        useBakedVertexAnimation = true\r\n    ): boolean {\r\n        if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {\r\n            return false;\r\n        }\r\n\r\n        defines._normals = defines._needNormals;\r\n        defines._uvs = defines._needUVs;\r\n\r\n        defines[\"NORMAL\"] = defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.NormalKind);\r\n\r\n        if (defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            defines[\"TANGENT\"] = true;\r\n        }\r\n\r\n        for (let i = 1; i <= Constants.MAX_SUPPORTED_UV_SETS; ++i) {\r\n            defines[\"UV\" + i] = defines._needUVs ? mesh.isVerticesDataPresent(`uv${i === 1 ? \"\" : i}`) : false;\r\n        }\r\n\r\n        if (useVertexColor) {\r\n            const hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);\r\n            defines[\"VERTEXCOLOR\"] = hasVertexColors;\r\n            defines[\"VERTEXALPHA\"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;\r\n        }\r\n\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind) && (mesh.hasInstances || mesh.hasThinInstances)) {\r\n            defines[\"INSTANCESCOLOR\"] = true;\r\n        }\r\n\r\n        if (useBones) {\r\n            this.PrepareDefinesForBones(mesh, defines);\r\n        }\r\n\r\n        if (useMorphTargets) {\r\n            this.PrepareDefinesForMorphTargets(mesh, defines);\r\n        }\r\n\r\n        if (useBakedVertexAnimation) {\r\n            this.PrepareDefinesForBakedVertexAnimation(mesh, defines);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines related to multiview\r\n     * @param scene The scene we are intending to draw\r\n     * @param defines The defines to update\r\n     */\r\n    public static PrepareDefinesForMultiview(scene: Scene, defines: any) {\r\n        if (scene.activeCamera) {\r\n            const previousMultiview = defines.MULTIVIEW;\r\n            defines.MULTIVIEW = scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1;\r\n            if (defines.MULTIVIEW != previousMultiview) {\r\n                defines.markAsUnprocessed();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines related to order independant transparency\r\n     * @param scene The scene we are intending to draw\r\n     * @param defines The defines to update\r\n     * @param needAlphaBlending Determines if the material needs alpha blending\r\n     */\r\n    public static PrepareDefinesForOIT(scene: Scene, defines: any, needAlphaBlending: boolean) {\r\n        const previousDefine = defines.ORDER_INDEPENDENT_TRANSPARENCY;\r\n        const previousDefine16Bits = defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;\r\n\r\n        defines.ORDER_INDEPENDENT_TRANSPARENCY = scene.useOrderIndependentTransparency && needAlphaBlending;\r\n        defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !scene.getEngine().getCaps().textureFloatLinearFiltering;\r\n\r\n        if (previousDefine !== defines.ORDER_INDEPENDENT_TRANSPARENCY || previousDefine16Bits !== defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS) {\r\n            defines.markAsUnprocessed();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines related to the prepass\r\n     * @param scene The scene we are intending to draw\r\n     * @param defines The defines to update\r\n     * @param canRenderToMRT Indicates if this material renders to several textures in the prepass\r\n     */\r\n    public static PrepareDefinesForPrePass(scene: Scene, defines: any, canRenderToMRT: boolean) {\r\n        const previousPrePass = defines.PREPASS;\r\n\r\n        if (!defines._arePrePassDirty) {\r\n            return;\r\n        }\r\n\r\n        const texturesList = [\r\n            {\r\n                type: Constants.PREPASS_POSITION_TEXTURE_TYPE,\r\n                define: \"PREPASS_POSITION\",\r\n                index: \"PREPASS_POSITION_INDEX\",\r\n            },\r\n            {\r\n                type: Constants.PREPASS_VELOCITY_TEXTURE_TYPE,\r\n                define: \"PREPASS_VELOCITY\",\r\n                index: \"PREPASS_VELOCITY_INDEX\",\r\n            },\r\n            {\r\n                type: Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE,\r\n                define: \"PREPASS_REFLECTIVITY\",\r\n                index: \"PREPASS_REFLECTIVITY_INDEX\",\r\n            },\r\n            {\r\n                type: Constants.PREPASS_IRRADIANCE_TEXTURE_TYPE,\r\n                define: \"PREPASS_IRRADIANCE\",\r\n                index: \"PREPASS_IRRADIANCE_INDEX\",\r\n            },\r\n            {\r\n                type: Constants.PREPASS_ALBEDO_SQRT_TEXTURE_TYPE,\r\n                define: \"PREPASS_ALBEDO_SQRT\",\r\n                index: \"PREPASS_ALBEDO_SQRT_INDEX\",\r\n            },\r\n            {\r\n                type: Constants.PREPASS_DEPTH_TEXTURE_TYPE,\r\n                define: \"PREPASS_DEPTH\",\r\n                index: \"PREPASS_DEPTH_INDEX\",\r\n            },\r\n            {\r\n                type: Constants.PREPASS_NORMAL_TEXTURE_TYPE,\r\n                define: \"PREPASS_NORMAL\",\r\n                index: \"PREPASS_NORMAL_INDEX\",\r\n            },\r\n        ];\r\n\r\n        if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {\r\n            defines.PREPASS = true;\r\n            defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;\r\n            defines.PREPASS_NORMAL_WORLDSPACE = scene.prePassRenderer.generateNormalsInWorldSpace;\r\n\r\n            for (let i = 0; i < texturesList.length; i++) {\r\n                const index = scene.prePassRenderer.getIndex(texturesList[i].type);\r\n                if (index !== -1) {\r\n                    defines[texturesList[i].define] = true;\r\n                    defines[texturesList[i].index] = index;\r\n                } else {\r\n                    defines[texturesList[i].define] = false;\r\n                }\r\n            }\r\n        } else {\r\n            defines.PREPASS = false;\r\n            for (let i = 0; i < texturesList.length; i++) {\r\n                defines[texturesList[i].define] = false;\r\n            }\r\n        }\r\n\r\n        if (defines.PREPASS != previousPrePass) {\r\n            defines.markAsUnprocessed();\r\n            defines.markAsImageProcessingDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines related to the light information passed in parameter\r\n     * @param scene The scene we are intending to draw\r\n     * @param mesh The mesh the effect is compiling for\r\n     * @param light The light the effect is compiling for\r\n     * @param lightIndex The index of the light\r\n     * @param defines The defines to update\r\n     * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n     * @param state Defines the current state regarding what is needed (normals, etc...)\r\n     * @param state.needNormals\r\n     * @param state.needRebuild\r\n     * @param state.shadowEnabled\r\n     * @param state.specularEnabled\r\n     * @param state.lightmapMode\r\n     */\r\n    public static PrepareDefinesForLight(\r\n        scene: Scene,\r\n        mesh: AbstractMesh,\r\n        light: Light,\r\n        lightIndex: number,\r\n        defines: any,\r\n        specularSupported: boolean,\r\n        state: {\r\n            needNormals: boolean;\r\n            needRebuild: boolean;\r\n            shadowEnabled: boolean;\r\n            specularEnabled: boolean;\r\n            lightmapMode: boolean;\r\n        }\r\n    ) {\r\n        state.needNormals = true;\r\n\r\n        if (defines[\"LIGHT\" + lightIndex] === undefined) {\r\n            state.needRebuild = true;\r\n        }\r\n\r\n        defines[\"LIGHT\" + lightIndex] = true;\r\n\r\n        defines[\"SPOTLIGHT\" + lightIndex] = false;\r\n        defines[\"HEMILIGHT\" + lightIndex] = false;\r\n        defines[\"POINTLIGHT\" + lightIndex] = false;\r\n        defines[\"DIRLIGHT\" + lightIndex] = false;\r\n\r\n        light.prepareLightSpecificDefines(defines, lightIndex);\r\n\r\n        // FallOff.\r\n        defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = false;\r\n        defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = false;\r\n        defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = false;\r\n\r\n        switch (light.falloffType) {\r\n            case LightConstants.FALLOFF_GLTF:\r\n                defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = true;\r\n                break;\r\n            case LightConstants.FALLOFF_PHYSICAL:\r\n                defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = true;\r\n                break;\r\n            case LightConstants.FALLOFF_STANDARD:\r\n                defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = true;\r\n                break;\r\n        }\r\n\r\n        // Specular\r\n        if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {\r\n            state.specularEnabled = true;\r\n        }\r\n\r\n        // Shadows\r\n        defines[\"SHADOW\" + lightIndex] = false;\r\n        defines[\"SHADOWCSM\" + lightIndex] = false;\r\n        defines[\"SHADOWCSMDEBUG\" + lightIndex] = false;\r\n        defines[\"SHADOWCSMNUM_CASCADES\" + lightIndex] = false;\r\n        defines[\"SHADOWCSMUSESHADOWMAXZ\" + lightIndex] = false;\r\n        defines[\"SHADOWCSMNOBLEND\" + lightIndex] = false;\r\n        defines[\"SHADOWCSM_RIGHTHANDED\" + lightIndex] = false;\r\n        defines[\"SHADOWPCF\" + lightIndex] = false;\r\n        defines[\"SHADOWPCSS\" + lightIndex] = false;\r\n        defines[\"SHADOWPOISSON\" + lightIndex] = false;\r\n        defines[\"SHADOWESM\" + lightIndex] = false;\r\n        defines[\"SHADOWCLOSEESM\" + lightIndex] = false;\r\n        defines[\"SHADOWCUBE\" + lightIndex] = false;\r\n        defines[\"SHADOWLOWQUALITY\" + lightIndex] = false;\r\n        defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = false;\r\n\r\n        if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {\r\n            const shadowGenerator = light.getShadowGenerator(scene.activeCamera) ?? light.getShadowGenerator();\r\n            if (shadowGenerator) {\r\n                const shadowMap = shadowGenerator.getShadowMap();\r\n                if (shadowMap) {\r\n                    if (shadowMap.renderList && shadowMap.renderList.length > 0) {\r\n                        state.shadowEnabled = true;\r\n                        shadowGenerator.prepareDefines(defines, lightIndex);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (light.lightmapMode != LightConstants.LIGHTMAP_DEFAULT) {\r\n            state.lightmapMode = true;\r\n            defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = true;\r\n            defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = light.lightmapMode == LightConstants.LIGHTMAP_SHADOWSONLY;\r\n        } else {\r\n            defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = false;\r\n            defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines related to the light information passed in parameter\r\n     * @param scene The scene we are intending to draw\r\n     * @param mesh The mesh the effect is compiling for\r\n     * @param defines The defines to update\r\n     * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n     * @param maxSimultaneousLights Specifies how manuy lights can be added to the effect at max\r\n     * @param disableLighting Specifies whether the lighting is disabled (override scene and light)\r\n     * @returns true if normals will be required for the rest of the effect\r\n     */\r\n    public static PrepareDefinesForLights(scene: Scene, mesh: AbstractMesh, defines: any, specularSupported: boolean, maxSimultaneousLights = 4, disableLighting = false): boolean {\r\n        if (!defines._areLightsDirty) {\r\n            return defines._needNormals;\r\n        }\r\n\r\n        let lightIndex = 0;\r\n        const state = {\r\n            needNormals: defines._needNormals, // prevents overriding previous reflection or other needs for normals\r\n            needRebuild: false,\r\n            lightmapMode: false,\r\n            shadowEnabled: false,\r\n            specularEnabled: false,\r\n        };\r\n\r\n        if (scene.lightsEnabled && !disableLighting) {\r\n            for (const light of mesh.lightSources) {\r\n                this.PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);\r\n\r\n                lightIndex++;\r\n                if (lightIndex === maxSimultaneousLights) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        defines[\"SPECULARTERM\"] = state.specularEnabled;\r\n        defines[\"SHADOWS\"] = state.shadowEnabled;\r\n\r\n        // Resetting all other lights if any\r\n        for (let index = lightIndex; index < maxSimultaneousLights; index++) {\r\n            if (defines[\"LIGHT\" + index] !== undefined) {\r\n                defines[\"LIGHT\" + index] = false;\r\n                defines[\"HEMILIGHT\" + index] = false;\r\n                defines[\"POINTLIGHT\" + index] = false;\r\n                defines[\"DIRLIGHT\" + index] = false;\r\n                defines[\"SPOTLIGHT\" + index] = false;\r\n                defines[\"SHADOW\" + index] = false;\r\n                defines[\"SHADOWCSM\" + index] = false;\r\n                defines[\"SHADOWCSMDEBUG\" + index] = false;\r\n                defines[\"SHADOWCSMNUM_CASCADES\" + index] = false;\r\n                defines[\"SHADOWCSMUSESHADOWMAXZ\" + index] = false;\r\n                defines[\"SHADOWCSMNOBLEND\" + index] = false;\r\n                defines[\"SHADOWCSM_RIGHTHANDED\" + index] = false;\r\n                defines[\"SHADOWPCF\" + index] = false;\r\n                defines[\"SHADOWPCSS\" + index] = false;\r\n                defines[\"SHADOWPOISSON\" + index] = false;\r\n                defines[\"SHADOWESM\" + index] = false;\r\n                defines[\"SHADOWCLOSEESM\" + index] = false;\r\n                defines[\"SHADOWCUBE\" + index] = false;\r\n                defines[\"SHADOWLOWQUALITY\" + index] = false;\r\n                defines[\"SHADOWMEDIUMQUALITY\" + index] = false;\r\n            }\r\n        }\r\n\r\n        const caps = scene.getEngine().getCaps();\r\n\r\n        if (defines[\"SHADOWFLOAT\"] === undefined) {\r\n            state.needRebuild = true;\r\n        }\r\n\r\n        defines[\"SHADOWFLOAT\"] =\r\n            state.shadowEnabled && ((caps.textureFloatRender && caps.textureFloatLinearFiltering) || (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering));\r\n        defines[\"LIGHTMAPEXCLUDED\"] = state.lightmapMode;\r\n\r\n        if (state.needRebuild) {\r\n            defines.rebuild();\r\n        }\r\n\r\n        return state.needNormals;\r\n    }\r\n\r\n    /**\r\n     * Prepares the uniforms and samplers list to be used in the effect (for a specific light)\r\n     * @param lightIndex defines the light index\r\n     * @param uniformsList The uniform list\r\n     * @param samplersList The sampler list\r\n     * @param projectedLightTexture defines if projected texture must be used\r\n     * @param uniformBuffersList defines an optional list of uniform buffers\r\n     * @param updateOnlyBuffersList True to only update the uniformBuffersList array\r\n     */\r\n    public static PrepareUniformsAndSamplersForLight(\r\n        lightIndex: number,\r\n        uniformsList: string[],\r\n        samplersList: string[],\r\n        projectedLightTexture?: any,\r\n        uniformBuffersList: Nullable<string[]> = null,\r\n        updateOnlyBuffersList = false\r\n    ) {\r\n        if (uniformBuffersList) {\r\n            uniformBuffersList.push(\"Light\" + lightIndex);\r\n        }\r\n\r\n        if (updateOnlyBuffersList) {\r\n            return;\r\n        }\r\n\r\n        uniformsList.push(\r\n            \"vLightData\" + lightIndex,\r\n            \"vLightDiffuse\" + lightIndex,\r\n            \"vLightSpecular\" + lightIndex,\r\n            \"vLightDirection\" + lightIndex,\r\n            \"vLightFalloff\" + lightIndex,\r\n            \"vLightGround\" + lightIndex,\r\n            \"lightMatrix\" + lightIndex,\r\n            \"shadowsInfo\" + lightIndex,\r\n            \"depthValues\" + lightIndex\r\n        );\r\n\r\n        samplersList.push(\"shadowSampler\" + lightIndex);\r\n        samplersList.push(\"depthSampler\" + lightIndex);\r\n\r\n        uniformsList.push(\r\n            \"viewFrustumZ\" + lightIndex,\r\n            \"cascadeBlendFactor\" + lightIndex,\r\n            \"lightSizeUVCorrection\" + lightIndex,\r\n            \"depthCorrection\" + lightIndex,\r\n            \"penumbraDarkness\" + lightIndex,\r\n            \"frustumLengths\" + lightIndex\r\n        );\r\n\r\n        if (projectedLightTexture) {\r\n            samplersList.push(\"projectionLightSampler\" + lightIndex);\r\n            uniformsList.push(\"textureProjectionMatrix\" + lightIndex);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the uniforms and samplers list to be used in the effect\r\n     * @param uniformsListOrOptions The uniform names to prepare or an EffectCreationOptions containing the list and extra information\r\n     * @param samplersList The sampler list\r\n     * @param defines The defines helping in the list generation\r\n     * @param maxSimultaneousLights The maximum number of simultaneous light allowed in the effect\r\n     */\r\n    public static PrepareUniformsAndSamplersList(\r\n        uniformsListOrOptions: string[] | IEffectCreationOptions,\r\n        samplersList?: string[],\r\n        defines?: any,\r\n        maxSimultaneousLights = 4\r\n    ): void {\r\n        let uniformsList: string[];\r\n        let uniformBuffersList: Nullable<string[]> = null;\r\n\r\n        if ((<IEffectCreationOptions>uniformsListOrOptions).uniformsNames) {\r\n            const options = <IEffectCreationOptions>uniformsListOrOptions;\r\n            uniformsList = options.uniformsNames;\r\n            uniformBuffersList = options.uniformBuffersNames;\r\n            samplersList = options.samplers;\r\n            defines = options.defines;\r\n            maxSimultaneousLights = options.maxSimultaneousLights || 0;\r\n        } else {\r\n            uniformsList = <string[]>uniformsListOrOptions;\r\n            if (!samplersList) {\r\n                samplersList = [];\r\n            }\r\n        }\r\n\r\n        for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\r\n            if (!defines[\"LIGHT\" + lightIndex]) {\r\n                break;\r\n            }\r\n            this.PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex], uniformBuffersList);\r\n        }\r\n\r\n        if (defines[\"NUM_MORPH_INFLUENCERS\"]) {\r\n            uniformsList.push(\"morphTargetInfluences\");\r\n        }\r\n\r\n        if (defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"]) {\r\n            uniformsList.push(\"bakedVertexAnimationSettings\");\r\n            uniformsList.push(\"bakedVertexAnimationTextureSizeInverted\");\r\n            uniformsList.push(\"bakedVertexAnimationTime\");\r\n            samplersList.push(\"bakedVertexAnimationTexture\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)\r\n     * @param defines The defines to update while falling back\r\n     * @param fallbacks The authorized effect fallbacks\r\n     * @param maxSimultaneousLights The maximum number of lights allowed\r\n     * @param rank the current rank of the Effect\r\n     * @returns The newly affected rank\r\n     */\r\n    public static HandleFallbacksForShadows(defines: any, fallbacks: EffectFallbacks, maxSimultaneousLights = 4, rank = 0): number {\r\n        let lightFallbackRank = 0;\r\n        for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\r\n            if (!defines[\"LIGHT\" + lightIndex]) {\r\n                break;\r\n            }\r\n\r\n            if (lightIndex > 0) {\r\n                lightFallbackRank = rank + lightIndex;\r\n                fallbacks.addFallback(lightFallbackRank, \"LIGHT\" + lightIndex);\r\n            }\r\n\r\n            if (!defines[\"SHADOWS\"]) {\r\n                if (defines[\"SHADOW\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOW\" + lightIndex);\r\n                }\r\n\r\n                if (defines[\"SHADOWPCF\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWPCF\" + lightIndex);\r\n                }\r\n\r\n                if (defines[\"SHADOWPCSS\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWPCSS\" + lightIndex);\r\n                }\r\n\r\n                if (defines[\"SHADOWPOISSON\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWPOISSON\" + lightIndex);\r\n                }\r\n\r\n                if (defines[\"SHADOWESM\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWESM\" + lightIndex);\r\n                }\r\n\r\n                if (defines[\"SHADOWCLOSEESM\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWCLOSEESM\" + lightIndex);\r\n                }\r\n            }\r\n        }\r\n        return lightFallbackRank++;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private static _TmpMorphInfluencers = { NUM_MORPH_INFLUENCERS: 0 };\r\n    /**\r\n     * Prepares the list of attributes required for morph targets according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare the morph targets attributes for\r\n     * @param influencers The number of influencers\r\n     */\r\n    public static PrepareAttributesForMorphTargetsInfluencers(attribs: string[], mesh: AbstractMesh, influencers: number): void {\r\n        this._TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;\r\n        this.PrepareAttributesForMorphTargets(attribs, mesh, this._TmpMorphInfluencers);\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of attributes required for morph targets according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare the morph targets attributes for\r\n     * @param defines The current Defines of the effect\r\n     */\r\n    public static PrepareAttributesForMorphTargets(attribs: string[], mesh: AbstractMesh, defines: any): void {\r\n        const influencers = defines[\"NUM_MORPH_INFLUENCERS\"];\r\n\r\n        if (influencers > 0 && EngineStore.LastCreatedEngine) {\r\n            const maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;\r\n            const manager = (<Mesh>mesh).morphTargetManager;\r\n            if (manager?.isUsingTextureForTargets) {\r\n                return;\r\n            }\r\n            const normal = manager && manager.supportsNormals && defines[\"NORMAL\"];\r\n            const tangent = manager && manager.supportsTangents && defines[\"TANGENT\"];\r\n            const uv = manager && manager.supportsUVs && defines[\"UV1\"];\r\n            for (let index = 0; index < influencers; index++) {\r\n                attribs.push(VertexBuffer.PositionKind + index);\r\n\r\n                if (normal) {\r\n                    attribs.push(VertexBuffer.NormalKind + index);\r\n                }\r\n\r\n                if (tangent) {\r\n                    attribs.push(VertexBuffer.TangentKind + index);\r\n                }\r\n\r\n                if (uv) {\r\n                    attribs.push(VertexBuffer.UVKind + \"_\" + index);\r\n                }\r\n\r\n                if (attribs.length > maxAttributesCount) {\r\n                    Logger.Error(\"Cannot add more vertex attributes for mesh \" + mesh.name);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of attributes required for baked vertex animations according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare the morph targets attributes for\r\n     * @param defines The current Defines of the effect\r\n     */\r\n    public static PrepareAttributesForBakedVertexAnimation(attribs: string[], mesh: AbstractMesh, defines: any): void {\r\n        const enabled = defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] && defines[\"INSTANCES\"];\r\n\r\n        if (enabled) {\r\n            attribs.push(\"bakedVertexAnimationSettingsInstanced\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of attributes required for bones according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare the bones attributes for\r\n     * @param defines The current Defines of the effect\r\n     * @param fallbacks The current effect fallback strategy\r\n     */\r\n    public static PrepareAttributesForBones(attribs: string[], mesh: AbstractMesh, defines: any, fallbacks: EffectFallbacks): void {\r\n        if (defines[\"NUM_BONE_INFLUENCERS\"] > 0) {\r\n            fallbacks.addCPUSkinningFallback(0, mesh);\r\n\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (defines[\"NUM_BONE_INFLUENCERS\"] > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check and prepare the list of attributes required for instances according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param defines The current MaterialDefines of the effect\r\n     */\r\n    public static PrepareAttributesForInstances(attribs: string[], defines: MaterialDefines): void {\r\n        if (defines[\"INSTANCES\"] || defines[\"THIN_INSTANCES\"]) {\r\n            this.PushAttributesForInstances(attribs, !!defines[\"PREPASS_VELOCITY\"]);\r\n        }\r\n\r\n        if (defines.INSTANCESCOLOR) {\r\n            attribs.push(VertexBuffer.ColorInstanceKind);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add the list of attributes required for instances to the attribs array.\r\n     * @param attribs The current list of supported attribs\r\n     * @param needsPreviousMatrices If the shader needs previous matrices\r\n     */\r\n    public static PushAttributesForInstances(attribs: string[], needsPreviousMatrices: boolean = false): void {\r\n        attribs.push(\"world0\");\r\n        attribs.push(\"world1\");\r\n        attribs.push(\"world2\");\r\n        attribs.push(\"world3\");\r\n        if (needsPreviousMatrices) {\r\n            attribs.push(\"previousWorld0\");\r\n            attribs.push(\"previousWorld1\");\r\n            attribs.push(\"previousWorld2\");\r\n            attribs.push(\"previousWorld3\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the light information to the effect.\r\n     * @param light The light containing the generator\r\n     * @param effect The effect we are binding the data to\r\n     * @param lightIndex The light index in the effect used to render\r\n     */\r\n    public static BindLightProperties(light: Light, effect: Effect, lightIndex: number): void {\r\n        light.transferToEffect(effect, lightIndex + \"\");\r\n    }\r\n\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param light Light to bind\r\n     * @param lightIndex Light index\r\n     * @param scene The scene where the light belongs to\r\n     * @param effect The effect we are binding the data to\r\n     * @param useSpecular Defines if specular is supported\r\n     * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\r\n     */\r\n    public static BindLight(light: Light, lightIndex: number, scene: Scene, effect: Effect, useSpecular: boolean, receiveShadows = true): void {\r\n        light._bindLight(lightIndex, scene, effect, useSpecular, receiveShadows);\r\n    }\r\n\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param scene The scene the lights belongs to\r\n     * @param mesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     * @param defines The generated defines for the effect\r\n     * @param maxSimultaneousLights The maximum number of light that can be bound to the effect\r\n     */\r\n    public static BindLights(scene: Scene, mesh: AbstractMesh, effect: Effect, defines: any, maxSimultaneousLights = 4): void {\r\n        const len = Math.min(mesh.lightSources.length, maxSimultaneousLights);\r\n\r\n        for (let i = 0; i < len; i++) {\r\n            const light = mesh.lightSources[i];\r\n            this.BindLight(light, i, scene, effect, typeof defines === \"boolean\" ? defines : defines[\"SPECULARTERM\"], mesh.receiveShadows);\r\n        }\r\n    }\r\n\r\n    private static _TempFogColor = Color3.Black();\r\n    /**\r\n     * Binds the fog information from the scene to the effect for the given mesh.\r\n     * @param scene The scene the lights belongs to\r\n     * @param mesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     * @param linearSpace Defines if the fog effect is applied in linear space\r\n     */\r\n    public static BindFogParameters(scene: Scene, mesh: AbstractMesh, effect: Effect, linearSpace = false): void {\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\r\n            // Convert fog color to linear space if used in a linear space computed shader.\r\n            if (linearSpace) {\r\n                scene.fogColor.toLinearSpaceToRef(this._TempFogColor, scene.getEngine().useExactSrgbConversions);\r\n                effect.setColor3(\"vFogColor\", this._TempFogColor);\r\n            } else {\r\n                effect.setColor3(\"vFogColor\", scene.fogColor);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the bones information from the mesh to the effect.\r\n     * @param mesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     * @param prePassConfiguration Configuration for the prepass, in case prepass is activated\r\n     */\r\n    public static BindBonesParameters(mesh?: AbstractMesh, effect?: Effect, prePassConfiguration?: PrePassConfiguration): void {\r\n        if (!effect || !mesh) {\r\n            return;\r\n        }\r\n        if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {\r\n            mesh.computeBonesUsingShaders = false;\r\n        }\r\n\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            const skeleton = mesh.skeleton;\r\n\r\n            if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex(\"boneTextureWidth\") > -1) {\r\n                const boneTexture = skeleton.getTransformMatrixTexture(mesh);\r\n                effect.setTexture(\"boneSampler\", boneTexture);\r\n                effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\r\n            } else {\r\n                const matrices = skeleton.getTransformMatrices(mesh);\r\n\r\n                if (matrices) {\r\n                    effect.setMatrices(\"mBones\", matrices);\r\n                    if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer!.getIndex(Constants.PREPASS_VELOCITY_TEXTURE_TYPE)) {\r\n                        if (!prePassConfiguration.previousBones[mesh.uniqueId]) {\r\n                            prePassConfiguration.previousBones[mesh.uniqueId] = matrices.slice();\r\n                        }\r\n                        effect.setMatrices(\"mPreviousBones\", prePassConfiguration.previousBones[mesh.uniqueId]);\r\n                        MaterialHelper._CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Copies the bones transformation matrices into the target array and returns the target's reference\r\n    private static _CopyBonesTransformationMatrices(source: Float32Array, target: Float32Array): Float32Array {\r\n        target.set(source);\r\n\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     * Binds the morph targets information from the mesh to the effect.\r\n     * @param abstractMesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     */\r\n    public static BindMorphTargetParameters(abstractMesh: AbstractMesh, effect: Effect): void {\r\n        const manager = (<Mesh>abstractMesh).morphTargetManager;\r\n        if (!abstractMesh || !manager) {\r\n            return;\r\n        }\r\n\r\n        effect.setFloatArray(\"morphTargetInfluences\", manager.influences);\r\n    }\r\n\r\n    /**\r\n     * Binds the logarithmic depth information from the scene to the effect for the given defines.\r\n     * @param defines The generated defines used in the effect\r\n     * @param effect The effect we are binding the data to\r\n     * @param scene The scene we are willing to render with logarithmic scale for\r\n     */\r\n    public static BindLogDepth(defines: any, effect: Effect, scene: Scene): void {\r\n        if (!defines || defines[\"LOGARITHMICDEPTH\"] || (defines.indexOf && defines.indexOf(\"LOGARITHMICDEPTH\") >= 0)) {\r\n            const camera = <Camera>scene.activeCamera;\r\n            if (camera.mode === Camera.ORTHOGRAPHIC_CAMERA) {\r\n                Logger.Error(\"Logarithmic depth is not compatible with orthographic cameras!\", 20);\r\n            }\r\n            effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(camera.maxZ + 1.0) / Math.LN2));\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}