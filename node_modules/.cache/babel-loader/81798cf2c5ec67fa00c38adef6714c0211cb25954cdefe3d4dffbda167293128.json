{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { ShaderCodeNode } from \"./shaderCodeNode.js\";\nimport { ShaderCodeCursor } from \"./shaderCodeCursor.js\";\nimport { ShaderCodeConditionNode } from \"./shaderCodeConditionNode.js\";\nimport { ShaderCodeTestNode } from \"./shaderCodeTestNode.js\";\nimport { ShaderDefineIsDefinedOperator } from \"./Expressions/Operators/shaderDefineIsDefinedOperator.js\";\nimport { ShaderDefineOrOperator } from \"./Expressions/Operators/shaderDefineOrOperator.js\";\nimport { ShaderDefineAndOperator } from \"./Expressions/Operators/shaderDefineAndOperator.js\";\nimport { ShaderDefineExpression } from \"./Expressions/shaderDefineExpression.js\";\nimport { ShaderDefineArithmeticOperator } from \"./Expressions/Operators/shaderDefineArithmeticOperator.js\";\nimport { _WarnImport } from \"../../Misc/devTools.js\";\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage.js\";\nconst regexSE = /defined\\s*?\\((.+?)\\)/g;\nconst regexSERevert = /defined\\s*?\\[(.+?)\\]/g;\nconst regexShaderInclude = /#include\\s?<(.+)>(\\((.*)\\))*(\\[(.*)\\])*/g;\nconst regexShaderDecl = /__decl__/;\nconst regexLightX = /light\\{X\\}.(\\w*)/g;\nconst regexX = /\\{X\\}/g;\nconst reusableMatches = [];\n/** @internal */\nexport class ShaderProcessor {\n  static Initialize(options) {\n    if (options.processor && options.processor.initializeShaders) {\n      options.processor.initializeShaders(options.processingContext);\n    }\n  }\n  static Process(sourceCode, options, callback, engine) {\n    var _a;\n    if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.preProcessShaderCode) {\n      sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);\n    }\n    this._ProcessIncludes(sourceCode, options, codeWithIncludes => {\n      if (options.processCodeAfterIncludes) {\n        codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? \"fragment\" : \"vertex\", codeWithIncludes);\n      }\n      const migratedCode = this._ProcessShaderConversion(codeWithIncludes, options, engine);\n      callback(migratedCode, codeWithIncludes);\n    });\n  }\n  static PreProcess(sourceCode, options, callback, engine) {\n    var _a;\n    if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.preProcessShaderCode) {\n      sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);\n    }\n    this._ProcessIncludes(sourceCode, options, codeWithIncludes => {\n      if (options.processCodeAfterIncludes) {\n        codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? \"fragment\" : \"vertex\", codeWithIncludes);\n      }\n      const migratedCode = this._ApplyPreProcessing(codeWithIncludes, options, engine);\n      callback(migratedCode, codeWithIncludes);\n    });\n  }\n  static Finalize(vertexCode, fragmentCode, options) {\n    if (!options.processor || !options.processor.finalizeShaders) {\n      return {\n        vertexCode,\n        fragmentCode\n      };\n    }\n    return options.processor.finalizeShaders(vertexCode, fragmentCode, options.processingContext);\n  }\n  static _ProcessPrecision(source, options) {\n    var _a;\n    if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.noPrecision) {\n      return source;\n    }\n    const shouldUseHighPrecisionShader = options.shouldUseHighPrecisionShader;\n    if (source.indexOf(\"precision highp float\") === -1) {\n      if (!shouldUseHighPrecisionShader) {\n        source = \"precision mediump float;\\n\" + source;\n      } else {\n        source = \"precision highp float;\\n\" + source;\n      }\n    } else {\n      if (!shouldUseHighPrecisionShader) {\n        // Moving highp to mediump\n        source = source.replace(\"precision highp float\", \"precision mediump float\");\n      }\n    }\n    return source;\n  }\n  static _ExtractOperation(expression) {\n    const regex = /defined\\((.+)\\)/;\n    const match = regex.exec(expression);\n    if (match && match.length) {\n      return new ShaderDefineIsDefinedOperator(match[1].trim(), expression[0] === \"!\");\n    }\n    const operators = [\"==\", \"!=\", \">=\", \"<=\", \"<\", \">\"];\n    let operator = \"\";\n    let indexOperator = 0;\n    for (operator of operators) {\n      indexOperator = expression.indexOf(operator);\n      if (indexOperator > -1) {\n        break;\n      }\n    }\n    if (indexOperator === -1) {\n      return new ShaderDefineIsDefinedOperator(expression);\n    }\n    const define = expression.substring(0, indexOperator).trim();\n    const value = expression.substring(indexOperator + operator.length).trim();\n    return new ShaderDefineArithmeticOperator(define, operator, value);\n  }\n  static _BuildSubExpression(expression) {\n    expression = expression.replace(regexSE, \"defined[$1]\");\n    const postfix = ShaderDefineExpression.infixToPostfix(expression);\n    const stack = [];\n    for (const c of postfix) {\n      if (c !== \"||\" && c !== \"&&\") {\n        stack.push(c);\n      } else if (stack.length >= 2) {\n        let v1 = stack[stack.length - 1],\n          v2 = stack[stack.length - 2];\n        stack.length -= 2;\n        const operator = c == \"&&\" ? new ShaderDefineAndOperator() : new ShaderDefineOrOperator();\n        if (typeof v1 === \"string\") {\n          v1 = v1.replace(regexSERevert, \"defined($1)\");\n        }\n        if (typeof v2 === \"string\") {\n          v2 = v2.replace(regexSERevert, \"defined($1)\");\n        }\n        operator.leftOperand = typeof v2 === \"string\" ? this._ExtractOperation(v2) : v2;\n        operator.rightOperand = typeof v1 === \"string\" ? this._ExtractOperation(v1) : v1;\n        stack.push(operator);\n      }\n    }\n    let result = stack[stack.length - 1];\n    if (typeof result === \"string\") {\n      result = result.replace(regexSERevert, \"defined($1)\");\n    }\n    // note: stack.length !== 1 if there was an error in the parsing\n    return typeof result === \"string\" ? this._ExtractOperation(result) : result;\n  }\n  static _BuildExpression(line, start) {\n    const node = new ShaderCodeTestNode();\n    const command = line.substring(0, start);\n    let expression = line.substring(start);\n    expression = expression.substring(0, (expression.indexOf(\"//\") + 1 || expression.length + 1) - 1).trim();\n    if (command === \"#ifdef\") {\n      node.testExpression = new ShaderDefineIsDefinedOperator(expression);\n    } else if (command === \"#ifndef\") {\n      node.testExpression = new ShaderDefineIsDefinedOperator(expression, true);\n    } else {\n      node.testExpression = this._BuildSubExpression(expression);\n    }\n    return node;\n  }\n  static _MoveCursorWithinIf(cursor, rootNode, ifNode) {\n    let line = cursor.currentLine;\n    while (this._MoveCursor(cursor, ifNode)) {\n      line = cursor.currentLine;\n      const first5 = line.substring(0, 5).toLowerCase();\n      if (first5 === \"#else\") {\n        const elseNode = new ShaderCodeNode();\n        rootNode.children.push(elseNode);\n        this._MoveCursor(cursor, elseNode);\n        return;\n      } else if (first5 === \"#elif\") {\n        const elifNode = this._BuildExpression(line, 5);\n        rootNode.children.push(elifNode);\n        ifNode = elifNode;\n      }\n    }\n  }\n  static _MoveCursor(cursor, rootNode) {\n    while (cursor.canRead) {\n      cursor.lineIndex++;\n      const line = cursor.currentLine;\n      if (line.indexOf(\"#\") >= 0) {\n        const matches = ShaderProcessor._MoveCursorRegex.exec(line);\n        if (matches && matches.length) {\n          const keyword = matches[0];\n          switch (keyword) {\n            case \"#ifdef\":\n              {\n                const newRootNode = new ShaderCodeConditionNode();\n                rootNode.children.push(newRootNode);\n                const ifNode = this._BuildExpression(line, 6);\n                newRootNode.children.push(ifNode);\n                this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\n                break;\n              }\n            case \"#else\":\n            case \"#elif\":\n              return true;\n            case \"#endif\":\n              return false;\n            case \"#ifndef\":\n              {\n                const newRootNode = new ShaderCodeConditionNode();\n                rootNode.children.push(newRootNode);\n                const ifNode = this._BuildExpression(line, 7);\n                newRootNode.children.push(ifNode);\n                this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\n                break;\n              }\n            case \"#if\":\n              {\n                const newRootNode = new ShaderCodeConditionNode();\n                const ifNode = this._BuildExpression(line, 3);\n                rootNode.children.push(newRootNode);\n                newRootNode.children.push(ifNode);\n                this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\n                break;\n              }\n          }\n          continue;\n        }\n      }\n      const newNode = new ShaderCodeNode();\n      newNode.line = line;\n      rootNode.children.push(newNode);\n      // Detect additional defines\n      if (line[0] === \"#\" && line[1] === \"d\") {\n        const split = line.replace(\";\", \"\").split(\" \");\n        newNode.additionalDefineKey = split[1];\n        if (split.length === 3) {\n          newNode.additionalDefineValue = split[2];\n        }\n      }\n    }\n    return false;\n  }\n  static _EvaluatePreProcessors(sourceCode, preprocessors, options) {\n    const rootNode = new ShaderCodeNode();\n    const cursor = new ShaderCodeCursor();\n    cursor.lineIndex = -1;\n    cursor.lines = sourceCode.split(\"\\n\");\n    // Decompose (We keep it in 2 steps so it is easier to maintain and perf hit is insignificant)\n    this._MoveCursor(cursor, rootNode);\n    // Recompose\n    return rootNode.process(preprocessors, options);\n  }\n  static _PreparePreProcessors(options, engine) {\n    var _a;\n    const defines = options.defines;\n    const preprocessors = {};\n    for (const define of defines) {\n      const keyValue = define.replace(\"#define\", \"\").replace(\";\", \"\").trim();\n      const split = keyValue.split(\" \");\n      preprocessors[split[0]] = split.length > 1 ? split[1] : \"\";\n    }\n    if (((_a = options.processor) === null || _a === void 0 ? void 0 : _a.shaderLanguage) === ShaderLanguage.GLSL) {\n      preprocessors[\"GL_ES\"] = \"true\";\n    }\n    preprocessors[\"__VERSION__\"] = options.version;\n    preprocessors[options.platformName] = \"true\";\n    engine._getGlobalDefines(preprocessors);\n    return preprocessors;\n  }\n  static _ProcessShaderConversion(sourceCode, options, engine) {\n    let preparedSourceCode = this._ProcessPrecision(sourceCode, options);\n    if (!options.processor) {\n      return preparedSourceCode;\n    }\n    // Already converted\n    if (options.processor.shaderLanguage === ShaderLanguage.GLSL && preparedSourceCode.indexOf(\"#version 3\") !== -1) {\n      preparedSourceCode = preparedSourceCode.replace(\"#version 300 es\", \"\");\n      if (!options.processor.parseGLES3) {\n        return preparedSourceCode;\n      }\n    }\n    const defines = options.defines;\n    const preprocessors = this._PreparePreProcessors(options, engine);\n    // General pre processing\n    if (options.processor.preProcessor) {\n      preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);\n    }\n    preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);\n    // Post processing\n    if (options.processor.postProcessor) {\n      preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);\n    }\n    // Inline functions tagged with #define inline\n    if (engine._features.needShaderCodeInlining) {\n      preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);\n    }\n    return preparedSourceCode;\n  }\n  static _ApplyPreProcessing(sourceCode, options, engine) {\n    var _a, _b;\n    let preparedSourceCode = sourceCode;\n    const defines = options.defines;\n    const preprocessors = this._PreparePreProcessors(options, engine);\n    // General pre processing\n    if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.preProcessor) {\n      preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);\n    }\n    preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);\n    // Post processing\n    if ((_b = options.processor) === null || _b === void 0 ? void 0 : _b.postProcessor) {\n      preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);\n    }\n    // Inline functions tagged with #define inline\n    if (engine._features.needShaderCodeInlining) {\n      preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);\n    }\n    return preparedSourceCode;\n  }\n  /** @internal */\n  static _ProcessIncludes(sourceCode, options, callback) {\n    reusableMatches.length = 0;\n    let match;\n    // stay back-compat to the old matchAll syntax\n    while ((match = regexShaderInclude.exec(sourceCode)) !== null) {\n      reusableMatches.push(match);\n    }\n    let returnValue = String(sourceCode);\n    let parts = [sourceCode];\n    let keepProcessing = false;\n    for (const match of reusableMatches) {\n      let includeFile = match[1];\n      // Uniform declaration\n      if (includeFile.indexOf(\"__decl__\") !== -1) {\n        includeFile = includeFile.replace(regexShaderDecl, \"\");\n        if (options.supportsUniformBuffers) {\n          includeFile = includeFile.replace(\"Vertex\", \"Ubo\").replace(\"Fragment\", \"Ubo\");\n        }\n        includeFile = includeFile + \"Declaration\";\n      }\n      if (options.includesShadersStore[includeFile]) {\n        // Substitution\n        let includeContent = options.includesShadersStore[includeFile];\n        if (match[2]) {\n          const splits = match[3].split(\",\");\n          for (let index = 0; index < splits.length; index += 2) {\n            const source = new RegExp(splits[index], \"g\");\n            const dest = splits[index + 1];\n            includeContent = includeContent.replace(source, dest);\n          }\n        }\n        if (match[4]) {\n          const indexString = match[5];\n          if (indexString.indexOf(\"..\") !== -1) {\n            const indexSplits = indexString.split(\"..\");\n            const minIndex = parseInt(indexSplits[0]);\n            let maxIndex = parseInt(indexSplits[1]);\n            let sourceIncludeContent = includeContent.slice(0);\n            includeContent = \"\";\n            if (isNaN(maxIndex)) {\n              maxIndex = options.indexParameters[indexSplits[1]];\n            }\n            for (let i = minIndex; i < maxIndex; i++) {\n              if (!options.supportsUniformBuffers) {\n                // Ubo replacement\n                sourceIncludeContent = sourceIncludeContent.replace(regexLightX, (str, p1) => {\n                  return p1 + \"{X}\";\n                });\n              }\n              includeContent += sourceIncludeContent.replace(regexX, i.toString()) + \"\\n\";\n            }\n          } else {\n            if (!options.supportsUniformBuffers) {\n              // Ubo replacement\n              includeContent = includeContent.replace(regexLightX, (str, p1) => {\n                return p1 + \"{X}\";\n              });\n            }\n            includeContent = includeContent.replace(regexX, indexString);\n          }\n        }\n        // Replace\n        // Split all parts on match[0] and intersperse the parts with the include content\n        const newParts = [];\n        for (const part of parts) {\n          const splitPart = part.split(match[0]);\n          for (let i = 0; i < splitPart.length - 1; i++) {\n            newParts.push(splitPart[i]);\n            newParts.push(includeContent);\n          }\n          newParts.push(splitPart[splitPart.length - 1]);\n        }\n        parts = newParts;\n        keepProcessing = keepProcessing || includeContent.indexOf(\"#include<\") >= 0 || includeContent.indexOf(\"#include <\") >= 0;\n      } else {\n        const includeShaderUrl = options.shadersRepository + \"ShadersInclude/\" + includeFile + \".fx\";\n        ShaderProcessor._FileToolsLoadFile(includeShaderUrl, fileContent => {\n          options.includesShadersStore[includeFile] = fileContent;\n          this._ProcessIncludes(parts.join(\"\"), options, callback);\n        });\n        return;\n      }\n    }\n    reusableMatches.length = 0;\n    returnValue = parts.join(\"\");\n    if (keepProcessing) {\n      this._ProcessIncludes(returnValue.toString(), options, callback);\n    } else {\n      callback(returnValue);\n    }\n  }\n  /**\n   * Loads a file from a url\n   * @param url url to load\n   * @param onSuccess callback called when the file successfully loads\n   * @param onProgress callback called while file is loading (if the server supports this mode)\n   * @param offlineProvider defines the offline provider for caching\n   * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\n   * @param onError callback called when the file fails to load\n   * @returns a file request object\n   * @internal\n   */\n  static _FileToolsLoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {\n    throw _WarnImport(\"FileTools\");\n  }\n}\nShaderProcessor._MoveCursorRegex = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;","map":{"version":3,"names":["ShaderCodeNode","ShaderCodeCursor","ShaderCodeConditionNode","ShaderCodeTestNode","ShaderDefineIsDefinedOperator","ShaderDefineOrOperator","ShaderDefineAndOperator","ShaderDefineExpression","ShaderDefineArithmeticOperator","_WarnImport","ShaderLanguage","regexSE","regexSERevert","regexShaderInclude","regexShaderDecl","regexLightX","regexX","reusableMatches","ShaderProcessor","Initialize","options","processor","initializeShaders","processingContext","Process","sourceCode","callback","engine","_a","preProcessShaderCode","isFragment","_ProcessIncludes","codeWithIncludes","processCodeAfterIncludes","migratedCode","_ProcessShaderConversion","PreProcess","_ApplyPreProcessing","Finalize","vertexCode","fragmentCode","finalizeShaders","_ProcessPrecision","source","noPrecision","shouldUseHighPrecisionShader","indexOf","replace","_ExtractOperation","expression","regex","match","exec","length","trim","operators","operator","indexOperator","define","substring","value","_BuildSubExpression","postfix","infixToPostfix","stack","c","push","v1","v2","leftOperand","rightOperand","result","_BuildExpression","line","start","node","command","testExpression","_MoveCursorWithinIf","cursor","rootNode","ifNode","currentLine","_MoveCursor","first5","toLowerCase","elseNode","children","elifNode","canRead","lineIndex","matches","_MoveCursorRegex","keyword","newRootNode","newNode","split","additionalDefineKey","additionalDefineValue","_EvaluatePreProcessors","preprocessors","lines","process","_PreparePreProcessors","defines","keyValue","shaderLanguage","GLSL","version","platformName","_getGlobalDefines","preparedSourceCode","parseGLES3","preProcessor","postProcessor","_features","needShaderCodeInlining","inlineShaderCode","_b","returnValue","String","parts","keepProcessing","includeFile","supportsUniformBuffers","includesShadersStore","includeContent","splits","index","RegExp","dest","indexString","indexSplits","minIndex","parseInt","maxIndex","sourceIncludeContent","slice","isNaN","indexParameters","i","str","p1","toString","newParts","part","splitPart","includeShaderUrl","shadersRepository","_FileToolsLoadFile","fileContent","join","url","onSuccess","onProgress","offlineProvider","useArrayBuffer","onError"],"sources":["../../../../../dev/core/src/Engines/Processors/shaderProcessor.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport { ShaderCodeNode } from \"./shaderCodeNode\";\r\nimport { ShaderCodeCursor } from \"./shaderCodeCursor\";\r\nimport { ShaderCodeConditionNode } from \"./shaderCodeConditionNode\";\r\nimport { ShaderCodeTestNode } from \"./shaderCodeTestNode\";\r\nimport { ShaderDefineIsDefinedOperator } from \"./Expressions/Operators/shaderDefineIsDefinedOperator\";\r\nimport { ShaderDefineOrOperator } from \"./Expressions/Operators/shaderDefineOrOperator\";\r\nimport { ShaderDefineAndOperator } from \"./Expressions/Operators/shaderDefineAndOperator\";\r\nimport { ShaderDefineExpression } from \"./Expressions/shaderDefineExpression\";\r\nimport { ShaderDefineArithmeticOperator } from \"./Expressions/Operators/shaderDefineArithmeticOperator\";\r\nimport type { ProcessingOptions } from \"./shaderProcessingOptions\";\r\nimport { _WarnImport } from \"../../Misc/devTools\";\r\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\n\r\nimport type { WebRequest } from \"../../Misc/webRequest\";\r\nimport type { LoadFileError } from \"../../Misc/fileTools\";\r\nimport type { IOfflineProvider } from \"../../Offline/IOfflineProvider\";\r\nimport type { IFileRequest } from \"../../Misc/fileRequest\";\r\nimport type { ThinEngine } from \"../thinEngine\";\r\n\r\nconst regexSE = /defined\\s*?\\((.+?)\\)/g;\r\nconst regexSERevert = /defined\\s*?\\[(.+?)\\]/g;\r\nconst regexShaderInclude = /#include\\s?<(.+)>(\\((.*)\\))*(\\[(.*)\\])*/g;\r\nconst regexShaderDecl = /__decl__/;\r\nconst regexLightX = /light\\{X\\}.(\\w*)/g;\r\nconst regexX = /\\{X\\}/g;\r\nconst reusableMatches: RegExpMatchArray[] = [];\r\n\r\n/** @internal */\r\nexport class ShaderProcessor {\r\n    private static _MoveCursorRegex = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;\r\n\r\n    public static Initialize(options: ProcessingOptions): void {\r\n        if (options.processor && options.processor.initializeShaders) {\r\n            options.processor.initializeShaders(options.processingContext);\r\n        }\r\n    }\r\n\r\n    public static Process(sourceCode: string, options: ProcessingOptions, callback: (migratedCode: string, codeBeforeMigration: string) => void, engine: ThinEngine) {\r\n        if (options.processor?.preProcessShaderCode) {\r\n            sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);\r\n        }\r\n        this._ProcessIncludes(sourceCode, options, (codeWithIncludes) => {\r\n            if (options.processCodeAfterIncludes) {\r\n                codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? \"fragment\" : \"vertex\", codeWithIncludes);\r\n            }\r\n            const migratedCode = this._ProcessShaderConversion(codeWithIncludes, options, engine);\r\n            callback(migratedCode, codeWithIncludes);\r\n        });\r\n    }\r\n\r\n    public static PreProcess(sourceCode: string, options: ProcessingOptions, callback: (migratedCode: string, codeBeforeMigration: string) => void, engine: ThinEngine) {\r\n        if (options.processor?.preProcessShaderCode) {\r\n            sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);\r\n        }\r\n        this._ProcessIncludes(sourceCode, options, (codeWithIncludes) => {\r\n            if (options.processCodeAfterIncludes) {\r\n                codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? \"fragment\" : \"vertex\", codeWithIncludes);\r\n            }\r\n            const migratedCode = this._ApplyPreProcessing(codeWithIncludes, options, engine);\r\n            callback(migratedCode, codeWithIncludes);\r\n        });\r\n    }\r\n\r\n    public static Finalize(vertexCode: string, fragmentCode: string, options: ProcessingOptions): { vertexCode: string; fragmentCode: string } {\r\n        if (!options.processor || !options.processor.finalizeShaders) {\r\n            return { vertexCode, fragmentCode };\r\n        }\r\n\r\n        return options.processor.finalizeShaders(vertexCode, fragmentCode, options.processingContext);\r\n    }\r\n\r\n    private static _ProcessPrecision(source: string, options: ProcessingOptions): string {\r\n        if (options.processor?.noPrecision) {\r\n            return source;\r\n        }\r\n\r\n        const shouldUseHighPrecisionShader = options.shouldUseHighPrecisionShader;\r\n\r\n        if (source.indexOf(\"precision highp float\") === -1) {\r\n            if (!shouldUseHighPrecisionShader) {\r\n                source = \"precision mediump float;\\n\" + source;\r\n            } else {\r\n                source = \"precision highp float;\\n\" + source;\r\n            }\r\n        } else {\r\n            if (!shouldUseHighPrecisionShader) {\r\n                // Moving highp to mediump\r\n                source = source.replace(\"precision highp float\", \"precision mediump float\");\r\n            }\r\n        }\r\n\r\n        return source;\r\n    }\r\n\r\n    private static _ExtractOperation(expression: string) {\r\n        const regex = /defined\\((.+)\\)/;\r\n\r\n        const match = regex.exec(expression);\r\n\r\n        if (match && match.length) {\r\n            return new ShaderDefineIsDefinedOperator(match[1].trim(), expression[0] === \"!\");\r\n        }\r\n\r\n        const operators = [\"==\", \"!=\", \">=\", \"<=\", \"<\", \">\"];\r\n        let operator = \"\";\r\n        let indexOperator = 0;\r\n\r\n        for (operator of operators) {\r\n            indexOperator = expression.indexOf(operator);\r\n\r\n            if (indexOperator > -1) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (indexOperator === -1) {\r\n            return new ShaderDefineIsDefinedOperator(expression);\r\n        }\r\n\r\n        const define = expression.substring(0, indexOperator).trim();\r\n        const value = expression.substring(indexOperator + operator.length).trim();\r\n\r\n        return new ShaderDefineArithmeticOperator(define, operator, value);\r\n    }\r\n\r\n    private static _BuildSubExpression(expression: string): ShaderDefineExpression {\r\n        expression = expression.replace(regexSE, \"defined[$1]\");\r\n\r\n        const postfix = ShaderDefineExpression.infixToPostfix(expression);\r\n\r\n        const stack: (string | ShaderDefineExpression)[] = [];\r\n\r\n        for (const c of postfix) {\r\n            if (c !== \"||\" && c !== \"&&\") {\r\n                stack.push(c);\r\n            } else if (stack.length >= 2) {\r\n                let v1 = stack[stack.length - 1],\r\n                    v2 = stack[stack.length - 2];\r\n\r\n                stack.length -= 2;\r\n\r\n                const operator = c == \"&&\" ? new ShaderDefineAndOperator() : new ShaderDefineOrOperator();\r\n\r\n                if (typeof v1 === \"string\") {\r\n                    v1 = v1.replace(regexSERevert, \"defined($1)\");\r\n                }\r\n\r\n                if (typeof v2 === \"string\") {\r\n                    v2 = v2.replace(regexSERevert, \"defined($1)\");\r\n                }\r\n\r\n                operator.leftOperand = typeof v2 === \"string\" ? this._ExtractOperation(v2) : v2;\r\n                operator.rightOperand = typeof v1 === \"string\" ? this._ExtractOperation(v1) : v1;\r\n\r\n                stack.push(operator);\r\n            }\r\n        }\r\n\r\n        let result = stack[stack.length - 1];\r\n\r\n        if (typeof result === \"string\") {\r\n            result = result.replace(regexSERevert, \"defined($1)\");\r\n        }\r\n\r\n        // note: stack.length !== 1 if there was an error in the parsing\r\n\r\n        return typeof result === \"string\" ? this._ExtractOperation(result) : result;\r\n    }\r\n\r\n    private static _BuildExpression(line: string, start: number): ShaderCodeTestNode {\r\n        const node = new ShaderCodeTestNode();\r\n        const command = line.substring(0, start);\r\n        let expression = line.substring(start);\r\n\r\n        expression = expression.substring(0, (expression.indexOf(\"//\") + 1 || expression.length + 1) - 1).trim();\r\n\r\n        if (command === \"#ifdef\") {\r\n            node.testExpression = new ShaderDefineIsDefinedOperator(expression);\r\n        } else if (command === \"#ifndef\") {\r\n            node.testExpression = new ShaderDefineIsDefinedOperator(expression, true);\r\n        } else {\r\n            node.testExpression = this._BuildSubExpression(expression);\r\n        }\r\n\r\n        return node;\r\n    }\r\n\r\n    private static _MoveCursorWithinIf(cursor: ShaderCodeCursor, rootNode: ShaderCodeConditionNode, ifNode: ShaderCodeNode) {\r\n        let line = cursor.currentLine;\r\n        while (this._MoveCursor(cursor, ifNode)) {\r\n            line = cursor.currentLine;\r\n            const first5 = line.substring(0, 5).toLowerCase();\r\n\r\n            if (first5 === \"#else\") {\r\n                const elseNode = new ShaderCodeNode();\r\n                rootNode.children.push(elseNode);\r\n                this._MoveCursor(cursor, elseNode);\r\n                return;\r\n            } else if (first5 === \"#elif\") {\r\n                const elifNode = this._BuildExpression(line, 5);\r\n\r\n                rootNode.children.push(elifNode);\r\n                ifNode = elifNode;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _MoveCursor(cursor: ShaderCodeCursor, rootNode: ShaderCodeNode): boolean {\r\n        while (cursor.canRead) {\r\n            cursor.lineIndex++;\r\n            const line = cursor.currentLine;\r\n\r\n            if (line.indexOf(\"#\") >= 0) {\r\n                const matches = ShaderProcessor._MoveCursorRegex.exec(line);\r\n\r\n                if (matches && matches.length) {\r\n                    const keyword = matches[0];\r\n\r\n                    switch (keyword) {\r\n                        case \"#ifdef\": {\r\n                            const newRootNode = new ShaderCodeConditionNode();\r\n                            rootNode.children.push(newRootNode);\r\n\r\n                            const ifNode = this._BuildExpression(line, 6);\r\n                            newRootNode.children.push(ifNode);\r\n                            this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\r\n                            break;\r\n                        }\r\n                        case \"#else\":\r\n                        case \"#elif\":\r\n                            return true;\r\n                        case \"#endif\":\r\n                            return false;\r\n                        case \"#ifndef\": {\r\n                            const newRootNode = new ShaderCodeConditionNode();\r\n                            rootNode.children.push(newRootNode);\r\n\r\n                            const ifNode = this._BuildExpression(line, 7);\r\n                            newRootNode.children.push(ifNode);\r\n                            this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\r\n                            break;\r\n                        }\r\n                        case \"#if\": {\r\n                            const newRootNode = new ShaderCodeConditionNode();\r\n                            const ifNode = this._BuildExpression(line, 3);\r\n                            rootNode.children.push(newRootNode);\r\n\r\n                            newRootNode.children.push(ifNode);\r\n                            this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\r\n                            break;\r\n                        }\r\n                    }\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            const newNode = new ShaderCodeNode();\r\n            newNode.line = line;\r\n            rootNode.children.push(newNode);\r\n\r\n            // Detect additional defines\r\n            if (line[0] === \"#\" && line[1] === \"d\") {\r\n                const split = line.replace(\";\", \"\").split(\" \");\r\n                newNode.additionalDefineKey = split[1];\r\n\r\n                if (split.length === 3) {\r\n                    newNode.additionalDefineValue = split[2];\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private static _EvaluatePreProcessors(sourceCode: string, preprocessors: { [key: string]: string }, options: ProcessingOptions): string {\r\n        const rootNode = new ShaderCodeNode();\r\n        const cursor = new ShaderCodeCursor();\r\n\r\n        cursor.lineIndex = -1;\r\n        cursor.lines = sourceCode.split(\"\\n\");\r\n\r\n        // Decompose (We keep it in 2 steps so it is easier to maintain and perf hit is insignificant)\r\n        this._MoveCursor(cursor, rootNode);\r\n\r\n        // Recompose\r\n        return rootNode.process(preprocessors, options);\r\n    }\r\n\r\n    private static _PreparePreProcessors(options: ProcessingOptions, engine: ThinEngine): { [key: string]: string } {\r\n        const defines = options.defines;\r\n        const preprocessors: { [key: string]: string } = {};\r\n\r\n        for (const define of defines) {\r\n            const keyValue = define.replace(\"#define\", \"\").replace(\";\", \"\").trim();\r\n            const split = keyValue.split(\" \");\r\n            preprocessors[split[0]] = split.length > 1 ? split[1] : \"\";\r\n        }\r\n\r\n        if (options.processor?.shaderLanguage === ShaderLanguage.GLSL) {\r\n            preprocessors[\"GL_ES\"] = \"true\";\r\n        }\r\n        preprocessors[\"__VERSION__\"] = options.version;\r\n        preprocessors[options.platformName] = \"true\";\r\n\r\n        engine._getGlobalDefines(preprocessors);\r\n\r\n        return preprocessors;\r\n    }\r\n\r\n    private static _ProcessShaderConversion(sourceCode: string, options: ProcessingOptions, engine: ThinEngine): string {\r\n        let preparedSourceCode = this._ProcessPrecision(sourceCode, options);\r\n\r\n        if (!options.processor) {\r\n            return preparedSourceCode;\r\n        }\r\n\r\n        // Already converted\r\n        if (options.processor.shaderLanguage === ShaderLanguage.GLSL && preparedSourceCode.indexOf(\"#version 3\") !== -1) {\r\n            preparedSourceCode = preparedSourceCode.replace(\"#version 300 es\", \"\");\r\n            if (!options.processor.parseGLES3) {\r\n                return preparedSourceCode;\r\n            }\r\n        }\r\n\r\n        const defines = options.defines;\r\n\r\n        const preprocessors = this._PreparePreProcessors(options, engine);\r\n\r\n        // General pre processing\r\n        if (options.processor.preProcessor) {\r\n            preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);\r\n        }\r\n\r\n        preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);\r\n\r\n        // Post processing\r\n        if (options.processor.postProcessor) {\r\n            preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);\r\n        }\r\n\r\n        // Inline functions tagged with #define inline\r\n        if (engine._features.needShaderCodeInlining) {\r\n            preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);\r\n        }\r\n\r\n        return preparedSourceCode;\r\n    }\r\n\r\n    private static _ApplyPreProcessing(sourceCode: string, options: ProcessingOptions, engine: ThinEngine): string {\r\n        let preparedSourceCode = sourceCode;\r\n\r\n        const defines = options.defines;\r\n\r\n        const preprocessors = this._PreparePreProcessors(options, engine);\r\n\r\n        // General pre processing\r\n        if (options.processor?.preProcessor) {\r\n            preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);\r\n        }\r\n\r\n        preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);\r\n\r\n        // Post processing\r\n        if (options.processor?.postProcessor) {\r\n            preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);\r\n        }\r\n\r\n        // Inline functions tagged with #define inline\r\n        if (engine._features.needShaderCodeInlining) {\r\n            preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);\r\n        }\r\n\r\n        return preparedSourceCode;\r\n    }\r\n\r\n    /** @internal */\r\n    public static _ProcessIncludes(sourceCode: string, options: ProcessingOptions, callback: (data: any) => void): void {\r\n        reusableMatches.length = 0;\r\n        let match: RegExpMatchArray | null;\r\n        // stay back-compat to the old matchAll syntax\r\n        while ((match = regexShaderInclude.exec(sourceCode)) !== null) {\r\n            reusableMatches.push(match);\r\n        }\r\n\r\n        let returnValue = String(sourceCode);\r\n        let parts = [sourceCode];\r\n\r\n        let keepProcessing = false;\r\n\r\n        for (const match of reusableMatches) {\r\n            let includeFile = match[1];\r\n\r\n            // Uniform declaration\r\n            if (includeFile.indexOf(\"__decl__\") !== -1) {\r\n                includeFile = includeFile.replace(regexShaderDecl, \"\");\r\n                if (options.supportsUniformBuffers) {\r\n                    includeFile = includeFile.replace(\"Vertex\", \"Ubo\").replace(\"Fragment\", \"Ubo\");\r\n                }\r\n                includeFile = includeFile + \"Declaration\";\r\n            }\r\n\r\n            if (options.includesShadersStore[includeFile]) {\r\n                // Substitution\r\n                let includeContent = options.includesShadersStore[includeFile];\r\n                if (match[2]) {\r\n                    const splits = match[3].split(\",\");\r\n\r\n                    for (let index = 0; index < splits.length; index += 2) {\r\n                        const source = new RegExp(splits[index], \"g\");\r\n                        const dest = splits[index + 1];\r\n\r\n                        includeContent = includeContent.replace(source, dest);\r\n                    }\r\n                }\r\n\r\n                if (match[4]) {\r\n                    const indexString = match[5];\r\n\r\n                    if (indexString.indexOf(\"..\") !== -1) {\r\n                        const indexSplits = indexString.split(\"..\");\r\n                        const minIndex = parseInt(indexSplits[0]);\r\n                        let maxIndex = parseInt(indexSplits[1]);\r\n                        let sourceIncludeContent = includeContent.slice(0);\r\n                        includeContent = \"\";\r\n\r\n                        if (isNaN(maxIndex)) {\r\n                            maxIndex = options.indexParameters[indexSplits[1]];\r\n                        }\r\n\r\n                        for (let i = minIndex; i < maxIndex; i++) {\r\n                            if (!options.supportsUniformBuffers) {\r\n                                // Ubo replacement\r\n                                sourceIncludeContent = sourceIncludeContent.replace(regexLightX, (str: string, p1: string) => {\r\n                                    return p1 + \"{X}\";\r\n                                });\r\n                            }\r\n                            includeContent += sourceIncludeContent.replace(regexX, i.toString()) + \"\\n\";\r\n                        }\r\n                    } else {\r\n                        if (!options.supportsUniformBuffers) {\r\n                            // Ubo replacement\r\n                            includeContent = includeContent.replace(regexLightX, (str: string, p1: string) => {\r\n                                return p1 + \"{X}\";\r\n                            });\r\n                        }\r\n                        includeContent = includeContent.replace(regexX, indexString);\r\n                    }\r\n                }\r\n\r\n                // Replace\r\n                // Split all parts on match[0] and intersperse the parts with the include content\r\n                const newParts = [];\r\n                for (const part of parts) {\r\n                    const splitPart = part.split(match[0]);\r\n                    for (let i = 0; i < splitPart.length - 1; i++) {\r\n                        newParts.push(splitPart[i]);\r\n                        newParts.push(includeContent);\r\n                    }\r\n                    newParts.push(splitPart[splitPart.length - 1]);\r\n                }\r\n                parts = newParts;\r\n\r\n                keepProcessing = keepProcessing || includeContent.indexOf(\"#include<\") >= 0 || includeContent.indexOf(\"#include <\") >= 0;\r\n            } else {\r\n                const includeShaderUrl = options.shadersRepository + \"ShadersInclude/\" + includeFile + \".fx\";\r\n\r\n                ShaderProcessor._FileToolsLoadFile(includeShaderUrl, (fileContent) => {\r\n                    options.includesShadersStore[includeFile] = fileContent as string;\r\n                    this._ProcessIncludes(parts.join(\"\"), options, callback);\r\n                });\r\n                return;\r\n            }\r\n        }\r\n        reusableMatches.length = 0;\r\n\r\n        returnValue = parts.join(\"\");\r\n\r\n        if (keepProcessing) {\r\n            this._ProcessIncludes(returnValue.toString(), options, callback);\r\n        } else {\r\n            callback(returnValue);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads a file from a url\r\n     * @param url url to load\r\n     * @param onSuccess callback called when the file successfully loads\r\n     * @param onProgress callback called while file is loading (if the server supports this mode)\r\n     * @param offlineProvider defines the offline provider for caching\r\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n     * @param onError callback called when the file fails to load\r\n     * @returns a file request object\r\n     * @internal\r\n     */\r\n    public static _FileToolsLoadFile(\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void,\r\n        onProgress?: (ev: ProgressEvent) => void,\r\n        offlineProvider?: IOfflineProvider,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void\r\n    ): IFileRequest {\r\n        throw _WarnImport(\"FileTools\");\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}