{"ast":null,"code":"import { __decorate } from \"@babylonjs/core/tslib.es6.js\";\nimport { Observable } from \"@babylonjs/core/Misc/observable.js\";\nimport { Control } from \"./control.js\";\nimport { StackPanel } from \"./stackPanel.js\";\nimport { TextBlock } from \"./textBlock.js\";\nimport { RegisterClass } from \"@babylonjs/core/Misc/typeStore.js\";\nimport { serialize } from \"@babylonjs/core/Misc/decorators.js\";\n/**\n * Class used to represent a 2D checkbox\n */\nexport class Checkbox extends Control {\n  /** Gets or sets border thickness  */\n  get thickness() {\n    return this._thickness;\n  }\n  set thickness(value) {\n    if (this._thickness === value) {\n      return;\n    }\n    this._thickness = value;\n    this._markAsDirty();\n  }\n  /** Gets or sets a value indicating the ratio between overall size and check size */\n  get checkSizeRatio() {\n    return this._checkSizeRatio;\n  }\n  set checkSizeRatio(value) {\n    value = Math.max(Math.min(1, value), 0);\n    if (this._checkSizeRatio === value) {\n      return;\n    }\n    this._checkSizeRatio = value;\n    this._markAsDirty();\n  }\n  /** Gets or sets background color */\n  get background() {\n    return this._background;\n  }\n  set background(value) {\n    if (this._background === value) {\n      return;\n    }\n    this._background = value;\n    this._markAsDirty();\n  }\n  /** Gets or sets a boolean indicating if the checkbox is checked or not */\n  get isChecked() {\n    return this._isChecked;\n  }\n  set isChecked(value) {\n    if (this._isChecked === value) {\n      return;\n    }\n    this._isChecked = value;\n    this._markAsDirty();\n    this.onIsCheckedChangedObservable.notifyObservers(value);\n  }\n  /**\n   * Creates a new CheckBox\n   * @param name defines the control name\n   */\n  constructor(name) {\n    super(name);\n    this.name = name;\n    this._isChecked = false;\n    this._background = \"black\";\n    this._checkSizeRatio = 0.8;\n    this._thickness = 1;\n    /**\n     * Observable raised when isChecked property changes\n     */\n    this.onIsCheckedChangedObservable = new Observable();\n    this.isPointerBlocker = true;\n  }\n  _getTypeName() {\n    return \"Checkbox\";\n  }\n  /**\n   * @internal\n   */\n  _draw(context) {\n    context.save();\n    this._applyStates(context);\n    const actualWidth = this._currentMeasure.width - this._thickness;\n    const actualHeight = this._currentMeasure.height - this._thickness;\n    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\n      context.shadowColor = this.shadowColor;\n      context.shadowBlur = this.shadowBlur;\n      context.shadowOffsetX = this.shadowOffsetX;\n      context.shadowOffsetY = this.shadowOffsetY;\n    }\n    context.fillStyle = this._isEnabled ? this._background : this._disabledColor;\n    context.fillRect(this._currentMeasure.left + this._thickness / 2, this._currentMeasure.top + this._thickness / 2, actualWidth, actualHeight);\n    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\n      context.shadowBlur = 0;\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n    }\n    if (this._isChecked) {\n      context.fillStyle = this._isEnabled ? this.color : this._disabledColorItem;\n      const offsetWidth = actualWidth * this._checkSizeRatio;\n      const offsetHeight = actualHeight * this._checkSizeRatio;\n      context.fillRect(this._currentMeasure.left + this._thickness / 2 + (actualWidth - offsetWidth) / 2, this._currentMeasure.top + this._thickness / 2 + (actualHeight - offsetHeight) / 2, offsetWidth, offsetHeight);\n    }\n    context.strokeStyle = this.color;\n    context.lineWidth = this._thickness;\n    context.strokeRect(this._currentMeasure.left + this._thickness / 2, this._currentMeasure.top + this._thickness / 2, actualWidth, actualHeight);\n    context.restore();\n  }\n  // Events\n  /**\n   * @internal\n   */\n  _onPointerDown(target, coordinates, pointerId, buttonIndex, pi) {\n    if (!super._onPointerDown(target, coordinates, pointerId, buttonIndex, pi)) {\n      return false;\n    }\n    if (!this.isReadOnly) {\n      this.isChecked = !this.isChecked;\n    }\n    return true;\n  }\n  /**\n   * Utility function to easily create a checkbox with a header\n   * @param title defines the label to use for the header\n   * @param onValueChanged defines the callback to call when value changes\n   * @returns a StackPanel containing the checkbox and a textBlock\n   */\n  static AddCheckBoxWithHeader(title, onValueChanged) {\n    const panel = new StackPanel();\n    panel.isVertical = false;\n    panel.height = \"30px\";\n    const checkbox = new Checkbox();\n    checkbox.width = \"20px\";\n    checkbox.height = \"20px\";\n    checkbox.isChecked = true;\n    checkbox.color = \"green\";\n    checkbox.onIsCheckedChangedObservable.add(onValueChanged);\n    panel.addControl(checkbox);\n    const header = new TextBlock();\n    header.text = title;\n    header.width = \"180px\";\n    header.paddingLeft = \"5px\";\n    header.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\n    header.color = \"white\";\n    panel.addControl(header);\n    return panel;\n  }\n}\n__decorate([serialize()], Checkbox.prototype, \"thickness\", null);\n__decorate([serialize()], Checkbox.prototype, \"checkSizeRatio\", null);\n__decorate([serialize()], Checkbox.prototype, \"background\", null);\n__decorate([serialize()], Checkbox.prototype, \"isChecked\", null);\nRegisterClass(\"BABYLON.GUI.Checkbox\", Checkbox);","map":{"version":3,"names":["Observable","Control","StackPanel","TextBlock","RegisterClass","serialize","Checkbox","thickness","_thickness","value","_markAsDirty","checkSizeRatio","_checkSizeRatio","Math","max","min","background","_background","isChecked","_isChecked","onIsCheckedChangedObservable","notifyObservers","constructor","name","isPointerBlocker","_getTypeName","_draw","context","save","_applyStates","actualWidth","_currentMeasure","width","actualHeight","height","shadowBlur","shadowOffsetX","shadowOffsetY","shadowColor","fillStyle","_isEnabled","_disabledColor","fillRect","left","top","color","_disabledColorItem","offsetWidth","offsetHeight","strokeStyle","lineWidth","strokeRect","restore","_onPointerDown","target","coordinates","pointerId","buttonIndex","pi","isReadOnly","AddCheckBoxWithHeader","title","onValueChanged","panel","isVertical","checkbox","add","addControl","header","text","paddingLeft","textHorizontalAlignment","HORIZONTAL_ALIGNMENT_LEFT","__decorate"],"sources":["../../../../../dev/gui/src/2D/controls/checkbox.ts"],"sourcesContent":["import { Observable } from \"core/Misc/observable\";\r\nimport type { Vector2 } from \"core/Maths/math.vector\";\r\n\r\nimport { Control } from \"./control\";\r\nimport { StackPanel } from \"./stackPanel\";\r\nimport { TextBlock } from \"./textBlock\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { PointerInfoBase } from \"core/Events/pointerEvents\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\n\r\n/**\r\n * Class used to represent a 2D checkbox\r\n */\r\nexport class Checkbox extends Control {\r\n    private _isChecked = false;\r\n    private _background = \"black\";\r\n    private _checkSizeRatio = 0.8;\r\n    private _thickness = 1;\r\n\r\n    /** Gets or sets border thickness  */\r\n    @serialize()\r\n    public get thickness(): number {\r\n        return this._thickness;\r\n    }\r\n\r\n    public set thickness(value: number) {\r\n        if (this._thickness === value) {\r\n            return;\r\n        }\r\n\r\n        this._thickness = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Observable raised when isChecked property changes\r\n     */\r\n    public onIsCheckedChangedObservable = new Observable<boolean>();\r\n\r\n    /** Gets or sets a value indicating the ratio between overall size and check size */\r\n    @serialize()\r\n    public get checkSizeRatio(): number {\r\n        return this._checkSizeRatio;\r\n    }\r\n\r\n    public set checkSizeRatio(value: number) {\r\n        value = Math.max(Math.min(1, value), 0);\r\n\r\n        if (this._checkSizeRatio === value) {\r\n            return;\r\n        }\r\n\r\n        this._checkSizeRatio = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets background color */\r\n    @serialize()\r\n    public get background(): string {\r\n        return this._background;\r\n    }\r\n\r\n    public set background(value: string) {\r\n        if (this._background === value) {\r\n            return;\r\n        }\r\n\r\n        this._background = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if the checkbox is checked or not */\r\n    @serialize()\r\n    public get isChecked(): boolean {\r\n        return this._isChecked;\r\n    }\r\n\r\n    public set isChecked(value: boolean) {\r\n        if (this._isChecked === value) {\r\n            return;\r\n        }\r\n\r\n        this._isChecked = value;\r\n        this._markAsDirty();\r\n\r\n        this.onIsCheckedChangedObservable.notifyObservers(value);\r\n    }\r\n\r\n    /**\r\n     * Creates a new CheckBox\r\n     * @param name defines the control name\r\n     */\r\n    constructor(public name?: string) {\r\n        super(name);\r\n        this.isPointerBlocker = true;\r\n    }\r\n\r\n    protected _getTypeName(): string {\r\n        return \"Checkbox\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _draw(context: ICanvasRenderingContext): void {\r\n        context.save();\r\n\r\n        this._applyStates(context);\r\n        const actualWidth = this._currentMeasure.width - this._thickness;\r\n        const actualHeight = this._currentMeasure.height - this._thickness;\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowColor = this.shadowColor;\r\n            context.shadowBlur = this.shadowBlur;\r\n            context.shadowOffsetX = this.shadowOffsetX;\r\n            context.shadowOffsetY = this.shadowOffsetY;\r\n        }\r\n\r\n        context.fillStyle = this._isEnabled ? this._background : this._disabledColor;\r\n        context.fillRect(this._currentMeasure.left + this._thickness / 2, this._currentMeasure.top + this._thickness / 2, actualWidth, actualHeight);\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowBlur = 0;\r\n            context.shadowOffsetX = 0;\r\n            context.shadowOffsetY = 0;\r\n        }\r\n\r\n        if (this._isChecked) {\r\n            context.fillStyle = this._isEnabled ? this.color : this._disabledColorItem;\r\n            const offsetWidth = actualWidth * this._checkSizeRatio;\r\n            const offsetHeight = actualHeight * this._checkSizeRatio;\r\n\r\n            context.fillRect(\r\n                this._currentMeasure.left + this._thickness / 2 + (actualWidth - offsetWidth) / 2,\r\n                this._currentMeasure.top + this._thickness / 2 + (actualHeight - offsetHeight) / 2,\r\n                offsetWidth,\r\n                offsetHeight\r\n            );\r\n        }\r\n\r\n        context.strokeStyle = this.color;\r\n        context.lineWidth = this._thickness;\r\n\r\n        context.strokeRect(this._currentMeasure.left + this._thickness / 2, this._currentMeasure.top + this._thickness / 2, actualWidth, actualHeight);\r\n\r\n        context.restore();\r\n    }\r\n\r\n    // Events\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _onPointerDown(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, pi: PointerInfoBase): boolean {\r\n        if (!super._onPointerDown(target, coordinates, pointerId, buttonIndex, pi)) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.isReadOnly) {\r\n            this.isChecked = !this.isChecked;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Utility function to easily create a checkbox with a header\r\n     * @param title defines the label to use for the header\r\n     * @param onValueChanged defines the callback to call when value changes\r\n     * @returns a StackPanel containing the checkbox and a textBlock\r\n     */\r\n    public static AddCheckBoxWithHeader(title: string, onValueChanged: (value: boolean) => void): StackPanel {\r\n        const panel = new StackPanel();\r\n        panel.isVertical = false;\r\n        panel.height = \"30px\";\r\n\r\n        const checkbox = new Checkbox();\r\n        checkbox.width = \"20px\";\r\n        checkbox.height = \"20px\";\r\n        checkbox.isChecked = true;\r\n        checkbox.color = \"green\";\r\n        checkbox.onIsCheckedChangedObservable.add(onValueChanged);\r\n        panel.addControl(checkbox);\r\n\r\n        const header = new TextBlock();\r\n        header.text = title;\r\n        header.width = \"180px\";\r\n        header.paddingLeft = \"5px\";\r\n        header.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        header.color = \"white\";\r\n        panel.addControl(header);\r\n\r\n        return panel;\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.Checkbox\", Checkbox);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}