{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { GreasedLinePluginMaterial } from \"../../Materials/GreasedLine/greasedLinePluginMaterial.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { Buffer } from \"../../Buffers/buffer.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { DeepCopier } from \"../../Misc/deepCopier.js\";\nimport { GreasedLineSimpleMaterial } from \"../../Materials/GreasedLine/greasedLineSimpleMaterial.js\";\n/**\n * In POINTS_MODE_POINTS every array of points will become the center (backbone) of the ribbon. The ribbon will be expanded by `width / 2` to `+direction` and `-direction` as well.\n * In POINTS_MODE_PATHS every array of points specifies an edge. These will be used to build one ribbon.\n */\nexport var GreasedLineRibbonPointsMode;\n(function (GreasedLineRibbonPointsMode) {\n  GreasedLineRibbonPointsMode[GreasedLineRibbonPointsMode[\"POINTS_MODE_POINTS\"] = 0] = \"POINTS_MODE_POINTS\";\n  GreasedLineRibbonPointsMode[GreasedLineRibbonPointsMode[\"POINTS_MODE_PATHS\"] = 1] = \"POINTS_MODE_PATHS\";\n})(GreasedLineRibbonPointsMode || (GreasedLineRibbonPointsMode = {}));\n/**\n * FACES_MODE_SINGLE_SIDED single sided with back face culling. Default value.\n * FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING single sided without back face culling. Sets backFaceCulling = false on the material so it affects all line ribbons added to the line ribbon instance.\n * FACES_MODE_DOUBLE_SIDED extra back faces are created. This doubles the amount of faces of the mesh.\n */\nexport var GreasedLineRibbonFacesMode;\n(function (GreasedLineRibbonFacesMode) {\n  GreasedLineRibbonFacesMode[GreasedLineRibbonFacesMode[\"FACES_MODE_SINGLE_SIDED\"] = 0] = \"FACES_MODE_SINGLE_SIDED\";\n  GreasedLineRibbonFacesMode[GreasedLineRibbonFacesMode[\"FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING\"] = 1] = \"FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING\";\n  GreasedLineRibbonFacesMode[GreasedLineRibbonFacesMode[\"FACES_MODE_DOUBLE_SIDED\"] = 2] = \"FACES_MODE_DOUBLE_SIDED\";\n})(GreasedLineRibbonFacesMode || (GreasedLineRibbonFacesMode = {}));\n/**\n * Only with POINTS_MODE_PATHS.\n * AUTO_DIRECTIONS_FROM_FIRST_SEGMENT sets the direction (slope) of the ribbon from the direction of the first line segment. Recommended.\n * AUTO_DIRECTIONS_FROM_ALL_SEGMENTS in this mode the direction (slope) will be calculated for each line segment according to the direction vector between each point of the line segments. Slow method.\n * AUTO_DIRECTIONS_ENHANCED in this mode the direction (slope) will be calculated for each line segment according to the direction vector between each point of the line segments using a more sophisitcaed algorithm. Slowest method.\n * AUTO_DIRECTIONS_NONE you have to set the direction (slope) manually. Recommended.\n */\nexport var GreasedLineRibbonAutoDirectionMode;\n(function (GreasedLineRibbonAutoDirectionMode) {\n  GreasedLineRibbonAutoDirectionMode[GreasedLineRibbonAutoDirectionMode[\"AUTO_DIRECTIONS_FROM_FIRST_SEGMENT\"] = 0] = \"AUTO_DIRECTIONS_FROM_FIRST_SEGMENT\";\n  GreasedLineRibbonAutoDirectionMode[GreasedLineRibbonAutoDirectionMode[\"AUTO_DIRECTIONS_FROM_ALL_SEGMENTS\"] = 1] = \"AUTO_DIRECTIONS_FROM_ALL_SEGMENTS\";\n  GreasedLineRibbonAutoDirectionMode[GreasedLineRibbonAutoDirectionMode[\"AUTO_DIRECTIONS_ENHANCED\"] = 2] = \"AUTO_DIRECTIONS_ENHANCED\";\n  GreasedLineRibbonAutoDirectionMode[GreasedLineRibbonAutoDirectionMode[\"AUTO_DIRECTIONS_NONE\"] = 99] = \"AUTO_DIRECTIONS_NONE\";\n})(GreasedLineRibbonAutoDirectionMode || (GreasedLineRibbonAutoDirectionMode = {}));\n/**\n * GreasedLineBaseMesh\n */\nexport class GreasedLineBaseMesh extends Mesh {\n  constructor(name, scene, _options) {\n    var _a, _b, _c, _d;\n    super(name, scene, null, null, false, false);\n    this.name = name;\n    this._options = _options;\n    this._lazy = false;\n    this._updatable = false;\n    this._engine = scene.getEngine();\n    this._lazy = (_a = _options.lazy) !== null && _a !== void 0 ? _a : false;\n    this._updatable = (_b = _options.updatable) !== null && _b !== void 0 ? _b : false;\n    this._vertexPositions = [];\n    this._indices = [];\n    this._uvs = [];\n    this._points = [];\n    this._colorPointers = (_c = _options.colorPointers) !== null && _c !== void 0 ? _c : [];\n    this._widths = (_d = _options.widths) !== null && _d !== void 0 ? _d : new Array(_options.points.length).fill(1);\n  }\n  /**\n   * \"GreasedLineMesh\"\n   * @returns \"GreasedLineMesh\"\n   */\n  getClassName() {\n    return \"GreasedLineMesh\";\n  }\n  _updateWidthsWithValue(defaulValue) {\n    let pointCount = 0;\n    for (const points of this._points) {\n      pointCount += points.length;\n    }\n    const countDiff = pointCount / 3 * 2 - this._widths.length;\n    for (let i = 0; i < countDiff; i++) {\n      this._widths.push(defaulValue);\n    }\n  }\n  /**\n   * Updated a lazy line. Rerenders the line and updates boundinfo as well.\n   */\n  updateLazy() {\n    var _a, _b;\n    this._setPoints(this._points);\n    if (!this._options.colorPointers) {\n      this._updateColorPointers();\n    }\n    this._createVertexBuffers((_a = this._options.ribbonOptions) === null || _a === void 0 ? void 0 : _a.smoothShading);\n    this.refreshBoundingInfo();\n    (_b = this.greasedLineMaterial) === null || _b === void 0 ? void 0 : _b.updateLazy();\n  }\n  /**\n   * Adds new points to the line. It doesn't rerenders the line if in lazy mode.\n   * @param points points table\n   */\n  addPoints(points, options) {\n    for (const p of points) {\n      this._points.push(p);\n    }\n    if (!this._lazy) {\n      this.setPoints(this._points, options);\n    }\n  }\n  /**\n   * Dispose the line and it's resources\n   */\n  dispose() {\n    super.dispose();\n  }\n  /**\n   *\n   * @returns true if the mesh was created in lazy mode\n   */\n  isLazy() {\n    return this._lazy;\n  }\n  /**\n   * Return the the points offsets\n   */\n  get offsets() {\n    return this._offsets;\n  }\n  /**\n   * Sets point offests\n   * @param offsets offset table [x,y,z, x,y,z, ....]\n   */\n  set offsets(offsets) {\n    this._offsets = offsets;\n    if (!this._offsetsBuffer) {\n      this._createOffsetsBuffer(offsets);\n    } else {\n      this._offsetsBuffer.update(offsets);\n    }\n  }\n  /**\n   * Gets widths at each line point like [widthLower, widthUpper, widthLower, widthUpper, ...]\n   */\n  get widths() {\n    return this._widths;\n  }\n  /**\n   * Sets widths at each line point\n   * @param widths width table [widthLower, widthUpper, widthLower, widthUpper ...]\n   */\n  set widths(widths) {\n    this._widths = widths;\n    if (!this._lazy) {\n      this._widthsBuffer && this._widthsBuffer.update(widths);\n    }\n  }\n  /**\n   * Gets the color pointer. Each vertex need a color pointer. These color pointers points to the colors in the color table @see colors\n   */\n  get colorPointers() {\n    return this._colorPointers;\n  }\n  /**\n   * Sets the color pointer\n   * @param colorPointers array of color pointer in the colors array. One pointer for every vertex is needed.\n   */\n  set colorPointers(colorPointers) {\n    this._colorPointers = colorPointers;\n    if (!this._lazy) {\n      this._colorPointersBuffer && this._colorPointersBuffer.update(colorPointers);\n    }\n  }\n  /**\n   * Gets the pluginMaterial associated with line\n   */\n  get greasedLineMaterial() {\n    var _a, _b;\n    if (this.material && this.material instanceof GreasedLineSimpleMaterial) {\n      return this.material;\n    }\n    const materialPlugin = (_b = (_a = this.material) === null || _a === void 0 ? void 0 : _a.pluginManager) === null || _b === void 0 ? void 0 : _b.getPlugin(GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME);\n    if (materialPlugin) {\n      return materialPlugin;\n    }\n    return;\n  }\n  /**\n   * Return copy the points.\n   */\n  get points() {\n    const pointsCopy = [];\n    DeepCopier.DeepCopy(this._points, pointsCopy);\n    return pointsCopy;\n  }\n  /**\n   * Sets line points and rerenders the line.\n   * @param points points table\n   */\n  setPoints(points, options) {\n    this._points = points;\n    this._updateWidths();\n    if (!(options === null || options === void 0 ? void 0 : options.colorPointers)) {\n      this._updateColorPointers();\n    }\n    this._setPoints(points, options);\n  }\n  _initGreasedLine() {\n    this._vertexPositions = [];\n    this._indices = [];\n    this._uvs = [];\n  }\n  _createLineOptions() {\n    const lineOptions = {\n      points: this._points,\n      colorPointers: this._colorPointers,\n      lazy: this._lazy,\n      updatable: this._updatable,\n      uvs: this._uvs,\n      widths: this._widths,\n      ribbonOptions: this._options.ribbonOptions\n    };\n    return lineOptions;\n  }\n  /**\n   * Serializes this GreasedLineMesh\n   * @param serializationObject object to write serialization to\n   */\n  serialize(serializationObject) {\n    super.serialize(serializationObject);\n    serializationObject.type = this.getClassName();\n    serializationObject.lineOptions = this._createLineOptions();\n  }\n  _createVertexBuffers(computeNormals = false) {\n    const vertexData = new VertexData();\n    vertexData.positions = this._vertexPositions;\n    vertexData.indices = this._indices;\n    vertexData.uvs = this._uvs;\n    if (computeNormals) {\n      vertexData.normals = [];\n      VertexData.ComputeNormals(this._vertexPositions, this._indices, vertexData.normals);\n    }\n    vertexData.applyToMesh(this, this._options.updatable);\n    return vertexData;\n  }\n  _createOffsetsBuffer(offsets) {\n    const engine = this._scene.getEngine();\n    const offsetBuffer = new Buffer(engine, offsets, this._updatable, 3);\n    this.setVerticesBuffer(offsetBuffer.createVertexBuffer(\"grl_offsets\", 0, 3));\n    this._offsetsBuffer = offsetBuffer;\n  }\n}","map":{"version":3,"names":["GreasedLinePluginMaterial","Mesh","Buffer","VertexData","DeepCopier","GreasedLineSimpleMaterial","GreasedLineRibbonPointsMode","GreasedLineRibbonFacesMode","GreasedLineRibbonAutoDirectionMode","GreasedLineBaseMesh","constructor","name","scene","_options","_lazy","_updatable","_engine","getEngine","_a","lazy","_b","updatable","_vertexPositions","_indices","_uvs","_points","_colorPointers","_c","colorPointers","_widths","_d","widths","Array","points","length","fill","getClassName","_updateWidthsWithValue","defaulValue","pointCount","countDiff","i","push","updateLazy","_setPoints","_updateColorPointers","_createVertexBuffers","ribbonOptions","smoothShading","refreshBoundingInfo","greasedLineMaterial","addPoints","options","p","setPoints","dispose","isLazy","offsets","_offsets","_offsetsBuffer","_createOffsetsBuffer","update","_widthsBuffer","_colorPointersBuffer","material","materialPlugin","pluginManager","getPlugin","GREASED_LINE_MATERIAL_NAME","pointsCopy","DeepCopy","_updateWidths","_initGreasedLine","_createLineOptions","lineOptions","uvs","serialize","serializationObject","type","computeNormals","vertexData","positions","indices","normals","ComputeNormals","applyToMesh","engine","_scene","offsetBuffer","setVerticesBuffer","createVertexBuffer"],"sources":["../../../../../dev/core/src/Meshes/GreasedLine/greasedLineBaseMesh.ts"],"sourcesContent":["import type { Scene } from \"../../scene\";\r\nimport type { IGreasedLineMaterial } from \"../../Materials/GreasedLine/greasedLineMaterialInterfaces\";\r\nimport { GreasedLinePluginMaterial } from \"../../Materials/GreasedLine/greasedLinePluginMaterial\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { Buffer } from \"../../Buffers/buffer\";\r\nimport type { Vector3 } from \"../../Maths/math.vector\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport { GreasedLineSimpleMaterial } from \"../../Materials/GreasedLine/greasedLineSimpleMaterial\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\n\r\n/**\r\n * In POINTS_MODE_POINTS every array of points will become the center (backbone) of the ribbon. The ribbon will be expanded by `width / 2` to `+direction` and `-direction` as well.\r\n * In POINTS_MODE_PATHS every array of points specifies an edge. These will be used to build one ribbon.\r\n */\r\nexport enum GreasedLineRibbonPointsMode {\r\n    POINTS_MODE_POINTS = 0,\r\n    POINTS_MODE_PATHS = 1,\r\n}\r\n\r\n/**\r\n * FACES_MODE_SINGLE_SIDED single sided with back face culling. Default value.\r\n * FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING single sided without back face culling. Sets backFaceCulling = false on the material so it affects all line ribbons added to the line ribbon instance.\r\n * FACES_MODE_DOUBLE_SIDED extra back faces are created. This doubles the amount of faces of the mesh.\r\n */\r\nexport enum GreasedLineRibbonFacesMode {\r\n    FACES_MODE_SINGLE_SIDED = 0,\r\n    FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING = 1,\r\n    FACES_MODE_DOUBLE_SIDED = 2,\r\n}\r\n\r\n/**\r\n * Only with POINTS_MODE_PATHS.\r\n * AUTO_DIRECTIONS_FROM_FIRST_SEGMENT sets the direction (slope) of the ribbon from the direction of the first line segment. Recommended.\r\n * AUTO_DIRECTIONS_FROM_ALL_SEGMENTS in this mode the direction (slope) will be calculated for each line segment according to the direction vector between each point of the line segments. Slow method.\r\n * AUTO_DIRECTIONS_ENHANCED in this mode the direction (slope) will be calculated for each line segment according to the direction vector between each point of the line segments using a more sophisitcaed algorithm. Slowest method.\r\n * AUTO_DIRECTIONS_NONE you have to set the direction (slope) manually. Recommended.\r\n */\r\nexport enum GreasedLineRibbonAutoDirectionMode {\r\n    AUTO_DIRECTIONS_FROM_FIRST_SEGMENT = 0,\r\n    AUTO_DIRECTIONS_FROM_ALL_SEGMENTS = 1,\r\n    AUTO_DIRECTIONS_ENHANCED = 2,\r\n    AUTO_DIRECTIONS_NONE = 99,\r\n}\r\n\r\nexport type GreasedLineRibbonOptions = {\r\n    /**\r\n     * Defines how the points are processed.\r\n     * In GreasedLineRibbonPointsMode.POINTS_MODE_POINTS every array of points will become the center of the ribbon. The ribbon will be expanded by width/2 to +direction and -direction as well.\r\n     * In GreasedLineRibbonPointsMode.POINTS_MODE_PATHS every array of points is one path. These will be used to buuid one ribbon.\r\n     */\r\n    pointsMode?: GreasedLineRibbonPointsMode;\r\n    /**\r\n     * Normalized directions of the slopes of the non camera facing lines.\r\n     */\r\n    directions?: Vector3[] | Vector3;\r\n    /**\r\n     * Defines the calculation mode of the directions which the line will be thickened to.\r\n     */\r\n    directionsAutoMode?: GreasedLineRibbonAutoDirectionMode;\r\n    /**\r\n     * Width of the ribbon.\r\n     */\r\n    width?: number;\r\n    /**\r\n     * Controls how the faces are created.\r\n     * GreasedLineRibbonFacesMode.FACES_MODE_SINGLE_SIDED = single sided with back face culling. Default value.\r\n     * GreasedLineRibbonFacesMode.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING = single sided without back face culling\r\n     * GreasedLineRibbonFacesMode.FACES_MODE_DOUBLE_SIDED = extra back faces are created. This doubles the amount of faces of the mesh.\r\n     */\r\n    facesMode?: GreasedLineRibbonFacesMode;\r\n    /**\r\n     * If true, the path will be closed.\r\n     */\r\n    closePath?: boolean;\r\n    /**\r\n     * If true, normals will be computed when creating the vertex buffers.\r\n     * This results to smooth shading of the mesh.\r\n     */\r\n    smoothShading?: boolean;\r\n};\r\n\r\nexport type GreasedLinePoints = Vector3[] | Vector3[][] | Float32Array | Float32Array[] | number[][] | number[];\r\n\r\n/**\r\n * Options for creating a GreasedLineMesh\r\n */\r\nexport interface GreasedLineMeshOptions {\r\n    /**\r\n     * Points of the line.\r\n     */\r\n    points: GreasedLinePoints;\r\n    /**\r\n     * Each line segmment (from point to point) can have it's width multiplier. Final width = widths[segmentIdx] * width.\r\n     * Defaults to empty array.\r\n     */\r\n    widths?: number[];\r\n    /**\r\n     * If instance is specified, lines are added to the specified instance.\r\n     * Defaults to undefined.\r\n     */\r\n    instance?: GreasedLineBaseMesh;\r\n    /**\r\n     * You can manually set the color pointers so you can control which segment/part\r\n     * will use which color from the colors material option\r\n     */\r\n    colorPointers?: number[];\r\n    /**\r\n     * UVs for the mesh\r\n     */\r\n    uvs?: number[];\r\n    /**\r\n     * If true, offsets and widths are updatable.\r\n     * Defaults to false.\r\n     */\r\n    updatable?: boolean;\r\n    /**\r\n     * Use when @see instance is specified.\r\n     * If true, the line will be rendered only after calling instance.updateLazy(). If false, line will be rerendered after every call to @see CreateGreasedLine\r\n     * Defaults to false.\r\n     */\r\n    lazy?: boolean;\r\n    /**\r\n     * The options for the ribbon which will be used as a line.\r\n     * If this option is set the line switches automatically to a non camera facing mode.\r\n     */\r\n    ribbonOptions?: GreasedLineRibbonOptions;\r\n}\r\n\r\n/**\r\n * GreasedLineBaseMesh\r\n */\r\nexport abstract class GreasedLineBaseMesh extends Mesh {\r\n    protected _vertexPositions: number[];\r\n    protected _indices: number[];\r\n    protected _uvs: number[];\r\n    protected _points: number[][];\r\n    protected _offsets: number[];\r\n    protected _colorPointers: number[];\r\n    protected _widths: number[];\r\n\r\n    protected _offsetsBuffer?: Buffer;\r\n    protected _widthsBuffer?: Buffer;\r\n    protected _colorPointersBuffer?: Buffer;\r\n\r\n    protected _lazy = false;\r\n    protected _updatable = false;\r\n\r\n    protected _engine: Engine;\r\n\r\n    constructor(public readonly name: string, scene: Scene, protected _options: GreasedLineMeshOptions) {\r\n        super(name, scene, null, null, false, false);\r\n\r\n        this._engine = scene.getEngine();\r\n\r\n        this._lazy = _options.lazy ?? false;\r\n        this._updatable = _options.updatable ?? false;\r\n\r\n        this._vertexPositions = [];\r\n        this._indices = [];\r\n        this._uvs = [];\r\n        this._points = [];\r\n        this._colorPointers = _options.colorPointers ?? [];\r\n        this._widths = _options.widths ?? new Array(_options.points.length).fill(1);\r\n    }\r\n\r\n    /**\r\n     * \"GreasedLineMesh\"\r\n     * @returns \"GreasedLineMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"GreasedLineMesh\";\r\n    }\r\n\r\n    protected abstract _setPoints(points: number[][], options?: GreasedLineMeshOptions): void;\r\n    protected abstract _updateColorPointers(): void;\r\n    protected abstract _updateWidths(): void;\r\n\r\n    protected _updateWidthsWithValue(defaulValue: number) {\r\n        let pointCount = 0;\r\n        for (const points of this._points) {\r\n            pointCount += points.length;\r\n        }\r\n        const countDiff = (pointCount / 3) * 2 - this._widths.length;\r\n        for (let i = 0; i < countDiff; i++) {\r\n            this._widths.push(defaulValue);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updated a lazy line. Rerenders the line and updates boundinfo as well.\r\n     */\r\n    public updateLazy() {\r\n        this._setPoints(this._points);\r\n        if (!this._options.colorPointers) {\r\n            this._updateColorPointers();\r\n        }\r\n        this._createVertexBuffers(this._options.ribbonOptions?.smoothShading);\r\n        this.refreshBoundingInfo();\r\n\r\n        this.greasedLineMaterial?.updateLazy();\r\n    }\r\n\r\n    /**\r\n     * Adds new points to the line. It doesn't rerenders the line if in lazy mode.\r\n     * @param points points table\r\n     */\r\n    public addPoints(points: number[][], options?: GreasedLineMeshOptions) {\r\n        for (const p of points) {\r\n            this._points.push(p);\r\n        }\r\n\r\n        if (!this._lazy) {\r\n            this.setPoints(this._points, options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the line and it's resources\r\n     */\r\n    public dispose() {\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @returns true if the mesh was created in lazy mode\r\n     */\r\n    public isLazy(): boolean {\r\n        return this._lazy;\r\n    }\r\n\r\n    /**\r\n     * Return the the points offsets\r\n     */\r\n    get offsets() {\r\n        return this._offsets;\r\n    }\r\n\r\n    /**\r\n     * Sets point offests\r\n     * @param offsets offset table [x,y,z, x,y,z, ....]\r\n     */\r\n    set offsets(offsets: number[]) {\r\n        this._offsets = offsets;\r\n        if (!this._offsetsBuffer) {\r\n            this._createOffsetsBuffer(offsets);\r\n        } else {\r\n            this._offsetsBuffer.update(offsets);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets widths at each line point like [widthLower, widthUpper, widthLower, widthUpper, ...]\r\n     */\r\n    get widths() {\r\n        return this._widths;\r\n    }\r\n\r\n    /**\r\n     * Sets widths at each line point\r\n     * @param widths width table [widthLower, widthUpper, widthLower, widthUpper ...]\r\n     */\r\n    set widths(widths: number[]) {\r\n        this._widths = widths;\r\n        if (!this._lazy) {\r\n            this._widthsBuffer && this._widthsBuffer.update(widths);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the color pointer. Each vertex need a color pointer. These color pointers points to the colors in the color table @see colors\r\n     */\r\n    get colorPointers() {\r\n        return this._colorPointers;\r\n    }\r\n\r\n    /**\r\n     * Sets the color pointer\r\n     * @param colorPointers array of color pointer in the colors array. One pointer for every vertex is needed.\r\n     */\r\n    set colorPointers(colorPointers: number[]) {\r\n        this._colorPointers = colorPointers;\r\n        if (!this._lazy) {\r\n            this._colorPointersBuffer && this._colorPointersBuffer.update(colorPointers);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the pluginMaterial associated with line\r\n     */\r\n    get greasedLineMaterial(): IGreasedLineMaterial | undefined {\r\n        if (this.material && this.material instanceof GreasedLineSimpleMaterial) {\r\n            return this.material;\r\n        }\r\n        const materialPlugin = this.material?.pluginManager?.getPlugin(GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME);\r\n        if (materialPlugin) {\r\n            return <GreasedLinePluginMaterial>materialPlugin;\r\n        }\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * Return copy the points.\r\n     */\r\n    get points() {\r\n        const pointsCopy: number[][] = [];\r\n        DeepCopier.DeepCopy(this._points, pointsCopy);\r\n        return pointsCopy;\r\n    }\r\n\r\n    /**\r\n     * Sets line points and rerenders the line.\r\n     * @param points points table\r\n     */\r\n    public setPoints(points: number[][], options?: GreasedLineMeshOptions) {\r\n        this._points = points;\r\n        this._updateWidths();\r\n        if (!options?.colorPointers) {\r\n            this._updateColorPointers();\r\n        }\r\n        this._setPoints(points, options);\r\n    }\r\n\r\n    protected _initGreasedLine() {\r\n        this._vertexPositions = [];\r\n        this._indices = [];\r\n        this._uvs = [];\r\n    }\r\n\r\n    protected _createLineOptions() {\r\n        const lineOptions: GreasedLineMeshOptions = {\r\n            points: this._points,\r\n            colorPointers: this._colorPointers,\r\n            lazy: this._lazy,\r\n            updatable: this._updatable,\r\n            uvs: this._uvs,\r\n            widths: this._widths,\r\n            ribbonOptions: this._options.ribbonOptions,\r\n        };\r\n        return lineOptions;\r\n    }\r\n\r\n    /**\r\n     * Serializes this GreasedLineMesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.type = this.getClassName();\r\n\r\n        serializationObject.lineOptions = this._createLineOptions();\r\n    }\r\n\r\n    protected _createVertexBuffers(computeNormals = false) {\r\n        const vertexData = new VertexData();\r\n        vertexData.positions = this._vertexPositions;\r\n        vertexData.indices = this._indices;\r\n        vertexData.uvs = this._uvs;\r\n        if (computeNormals) {\r\n            vertexData.normals = [];\r\n            VertexData.ComputeNormals(this._vertexPositions, this._indices, vertexData.normals);\r\n        }\r\n        vertexData.applyToMesh(this, this._options.updatable);\r\n        return vertexData;\r\n    }\r\n\r\n    protected _createOffsetsBuffer(offsets: number[]) {\r\n        const engine = this._scene.getEngine();\r\n\r\n        const offsetBuffer = new Buffer(engine, offsets, this._updatable, 3);\r\n        this.setVerticesBuffer(offsetBuffer.createVertexBuffer(\"grl_offsets\", 0, 3));\r\n        this._offsetsBuffer = offsetBuffer;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}