{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { __decorate } from \"../tslib.es6.js\";\nimport { Vector3, Vector4, TmpVectors } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { nativeOverride } from \"../Misc/decorators.js\";\nimport { makeSyncFunction, runCoroutineSync } from \"../Misc/coroutine.js\";\nimport { RuntimeError, ErrorCodes } from \"../Misc/error.js\";\nimport { SubMesh } from \"./subMesh.js\";\n/** Class used to attach material info to sub section of a vertex data class */\nexport class VertexDataMaterialInfo {}\n/**\n * This class contains the various kinds of data on every vertex of a mesh used in determining its shape and appearance\n */\nexport class VertexData {\n  /**\n   * Creates a new VertexData\n   */\n  constructor() {\n    /**\n     * Gets the unique ID of this vertex Data\n     */\n    this.uniqueId = 0;\n    /**\n     * Metadata used to store contextual values\n     */\n    this.metadata = {};\n    this._applyTo = makeSyncFunction(this._applyToCoroutine.bind(this));\n    this.uniqueId = VertexData._UniqueIDGenerator;\n    VertexData._UniqueIDGenerator++;\n  }\n  /**\n   * Uses the passed data array to set the set the values for the specified kind of data\n   * @param data a linear array of floating numbers\n   * @param kind the type of data that is being set, eg positions, colors etc\n   */\n  set(data, kind) {\n    if (!data.length) {\n      Logger.Warn(`Setting vertex data kind '${kind}' with an empty array`);\n    }\n    switch (kind) {\n      case VertexBuffer.PositionKind:\n        this.positions = data;\n        break;\n      case VertexBuffer.NormalKind:\n        this.normals = data;\n        break;\n      case VertexBuffer.TangentKind:\n        this.tangents = data;\n        break;\n      case VertexBuffer.UVKind:\n        this.uvs = data;\n        break;\n      case VertexBuffer.UV2Kind:\n        this.uvs2 = data;\n        break;\n      case VertexBuffer.UV3Kind:\n        this.uvs3 = data;\n        break;\n      case VertexBuffer.UV4Kind:\n        this.uvs4 = data;\n        break;\n      case VertexBuffer.UV5Kind:\n        this.uvs5 = data;\n        break;\n      case VertexBuffer.UV6Kind:\n        this.uvs6 = data;\n        break;\n      case VertexBuffer.ColorKind:\n        this.colors = data;\n        break;\n      case VertexBuffer.MatricesIndicesKind:\n        this.matricesIndices = data;\n        break;\n      case VertexBuffer.MatricesWeightsKind:\n        this.matricesWeights = data;\n        break;\n      case VertexBuffer.MatricesIndicesExtraKind:\n        this.matricesIndicesExtra = data;\n        break;\n      case VertexBuffer.MatricesWeightsExtraKind:\n        this.matricesWeightsExtra = data;\n        break;\n    }\n  }\n  /**\n   * Associates the vertexData to the passed Mesh.\n   * Sets it as updatable or not (default `false`)\n   * @param mesh the mesh the vertexData is applied to\n   * @param updatable when used and having the value true allows new data to update the vertexData\n   * @returns the VertexData\n   */\n  applyToMesh(mesh, updatable) {\n    this._applyTo(mesh, updatable, false);\n    return this;\n  }\n  /**\n   * Associates the vertexData to the passed Geometry.\n   * Sets it as updatable or not (default `false`)\n   * @param geometry the geometry the vertexData is applied to\n   * @param updatable when used and having the value true allows new data to update the vertexData\n   * @returns VertexData\n   */\n  applyToGeometry(geometry, updatable) {\n    this._applyTo(geometry, updatable, false);\n    return this;\n  }\n  /**\n   * Updates the associated mesh\n   * @param mesh the mesh to be updated\n   * @returns VertexData\n   */\n  updateMesh(mesh) {\n    this._update(mesh);\n    return this;\n  }\n  /**\n   * Updates the associated geometry\n   * @param geometry the geometry to be updated\n   * @returns VertexData.\n   */\n  updateGeometry(geometry) {\n    this._update(geometry);\n    return this;\n  }\n  /**\n   * @internal\n   */\n  *_applyToCoroutine(meshOrGeometry, updatable = false, isAsync) {\n    if (this.positions) {\n      meshOrGeometry.setVerticesData(VertexBuffer.PositionKind, this.positions, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.normals) {\n      meshOrGeometry.setVerticesData(VertexBuffer.NormalKind, this.normals, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.tangents) {\n      meshOrGeometry.setVerticesData(VertexBuffer.TangentKind, this.tangents, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.uvs) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UVKind, this.uvs, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.uvs2) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UV2Kind, this.uvs2, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.uvs3) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UV3Kind, this.uvs3, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.uvs4) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UV4Kind, this.uvs4, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.uvs5) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UV5Kind, this.uvs5, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.uvs6) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UV6Kind, this.uvs6, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.colors) {\n      meshOrGeometry.setVerticesData(VertexBuffer.ColorKind, this.colors, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.matricesIndices) {\n      meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.matricesWeights) {\n      meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.matricesIndicesExtra) {\n      meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.matricesWeightsExtra) {\n      meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.indices) {\n      meshOrGeometry.setIndices(this.indices, null, updatable);\n      if (isAsync) {\n        yield;\n      }\n    } else {\n      meshOrGeometry.setIndices([], null);\n    }\n    if (meshOrGeometry.subMeshes && this.materialInfos && this.materialInfos.length > 1) {\n      const mesh = meshOrGeometry;\n      mesh.subMeshes = [];\n      for (const matInfo of this.materialInfos) {\n        new SubMesh(matInfo.materialIndex, matInfo.verticesStart, matInfo.verticesCount, matInfo.indexStart, matInfo.indexCount, mesh);\n      }\n    }\n    return this;\n  }\n  _update(meshOrGeometry, updateExtends, makeItUnique) {\n    if (this.positions) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.PositionKind, this.positions, updateExtends, makeItUnique);\n    }\n    if (this.normals) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.NormalKind, this.normals, updateExtends, makeItUnique);\n    }\n    if (this.tangents) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.TangentKind, this.tangents, updateExtends, makeItUnique);\n    }\n    if (this.uvs) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UVKind, this.uvs, updateExtends, makeItUnique);\n    }\n    if (this.uvs2) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV2Kind, this.uvs2, updateExtends, makeItUnique);\n    }\n    if (this.uvs3) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV3Kind, this.uvs3, updateExtends, makeItUnique);\n    }\n    if (this.uvs4) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV4Kind, this.uvs4, updateExtends, makeItUnique);\n    }\n    if (this.uvs5) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV5Kind, this.uvs5, updateExtends, makeItUnique);\n    }\n    if (this.uvs6) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV6Kind, this.uvs6, updateExtends, makeItUnique);\n    }\n    if (this.colors) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.ColorKind, this.colors, updateExtends, makeItUnique);\n    }\n    if (this.matricesIndices) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updateExtends, makeItUnique);\n    }\n    if (this.matricesWeights) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updateExtends, makeItUnique);\n    }\n    if (this.matricesIndicesExtra) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updateExtends, makeItUnique);\n    }\n    if (this.matricesWeightsExtra) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updateExtends, makeItUnique);\n    }\n    if (this.indices) {\n      meshOrGeometry.setIndices(this.indices, null);\n    }\n    return this;\n  }\n  static _TransformVector3Coordinates(coordinates, transformation, offset = 0, length = coordinates.length) {\n    const coordinate = TmpVectors.Vector3[0];\n    const transformedCoordinate = TmpVectors.Vector3[1];\n    for (let index = offset; index < offset + length; index += 3) {\n      Vector3.FromArrayToRef(coordinates, index, coordinate);\n      Vector3.TransformCoordinatesToRef(coordinate, transformation, transformedCoordinate);\n      coordinates[index] = transformedCoordinate.x;\n      coordinates[index + 1] = transformedCoordinate.y;\n      coordinates[index + 2] = transformedCoordinate.z;\n    }\n  }\n  static _TransformVector3Normals(normals, transformation, offset = 0, length = normals.length) {\n    const normal = TmpVectors.Vector3[0];\n    const transformedNormal = TmpVectors.Vector3[1];\n    for (let index = offset; index < offset + length; index += 3) {\n      Vector3.FromArrayToRef(normals, index, normal);\n      Vector3.TransformNormalToRef(normal, transformation, transformedNormal);\n      normals[index] = transformedNormal.x;\n      normals[index + 1] = transformedNormal.y;\n      normals[index + 2] = transformedNormal.z;\n    }\n  }\n  static _TransformVector4Normals(normals, transformation, offset = 0, length = normals.length) {\n    const normal = TmpVectors.Vector4[0];\n    const transformedNormal = TmpVectors.Vector4[1];\n    for (let index = offset; index < offset + length; index += 4) {\n      Vector4.FromArrayToRef(normals, index, normal);\n      Vector4.TransformNormalToRef(normal, transformation, transformedNormal);\n      normals[index] = transformedNormal.x;\n      normals[index + 1] = transformedNormal.y;\n      normals[index + 2] = transformedNormal.z;\n      normals[index + 3] = transformedNormal.w;\n    }\n  }\n  static _FlipFaces(indices, offset = 0, length = indices.length) {\n    for (let index = offset; index < offset + length; index += 3) {\n      const tmp = indices[index + 1];\n      indices[index + 1] = indices[index + 2];\n      indices[index + 2] = tmp;\n    }\n  }\n  /**\n   * Transforms each position and each normal of the vertexData according to the passed Matrix\n   * @param matrix the transforming matrix\n   * @returns the VertexData\n   */\n  transform(matrix) {\n    const flip = matrix.determinant() < 0;\n    if (this.positions) {\n      VertexData._TransformVector3Coordinates(this.positions, matrix);\n    }\n    if (this.normals) {\n      VertexData._TransformVector3Normals(this.normals, matrix);\n    }\n    if (this.tangents) {\n      VertexData._TransformVector4Normals(this.tangents, matrix);\n    }\n    if (flip && this.indices) {\n      VertexData._FlipFaces(this.indices);\n    }\n    return this;\n  }\n  /**\n   * Generates an array of vertex data where each vertex data only has one material info\n   * @returns An array of VertexData\n   */\n  splitBasedOnMaterialID() {\n    if (!this.materialInfos || this.materialInfos.length < 2) {\n      return [this];\n    }\n    const result = new Array();\n    for (const materialInfo of this.materialInfos) {\n      const vertexData = new VertexData();\n      if (this.positions) {\n        vertexData.positions = this.positions.slice(materialInfo.verticesStart * 3, (materialInfo.verticesCount + materialInfo.verticesStart) * 3);\n      }\n      if (this.normals) {\n        vertexData.normals = this.normals.slice(materialInfo.verticesStart * 3, (materialInfo.verticesCount + materialInfo.verticesStart) * 3);\n      }\n      if (this.tangents) {\n        vertexData.tangents = this.tangents.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\n      }\n      if (this.colors) {\n        vertexData.colors = this.colors.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\n      }\n      if (this.uvs) {\n        vertexData.uvs = this.uvs.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\n      }\n      if (this.uvs2) {\n        vertexData.uvs2 = this.uvs2.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\n      }\n      if (this.uvs3) {\n        vertexData.uvs3 = this.uvs3.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\n      }\n      if (this.uvs4) {\n        vertexData.uvs4 = this.uvs4.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\n      }\n      if (this.uvs5) {\n        vertexData.uvs5 = this.uvs5.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\n      }\n      if (this.uvs6) {\n        vertexData.uvs6 = this.uvs6.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\n      }\n      if (this.matricesIndices) {\n        vertexData.matricesIndices = this.matricesIndices.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\n      }\n      if (this.matricesIndicesExtra) {\n        vertexData.matricesIndicesExtra = this.matricesIndicesExtra.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\n      }\n      if (this.matricesWeights) {\n        vertexData.matricesWeights = this.matricesWeights.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\n      }\n      if (this.matricesWeightsExtra) {\n        vertexData.matricesWeightsExtra = this.matricesWeightsExtra.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\n      }\n      if (this.indices) {\n        vertexData.indices = [];\n        for (let index = materialInfo.indexStart; index < materialInfo.indexStart + materialInfo.indexCount; index++) {\n          vertexData.indices.push(this.indices[index] - materialInfo.verticesStart);\n        }\n      }\n      const newMaterialInfo = new VertexDataMaterialInfo();\n      newMaterialInfo.indexStart = 0;\n      newMaterialInfo.indexCount = vertexData.indices ? vertexData.indices.length : 0;\n      newMaterialInfo.materialIndex = materialInfo.materialIndex;\n      newMaterialInfo.verticesStart = 0;\n      newMaterialInfo.verticesCount = (vertexData.positions ? vertexData.positions.length : 0) / 3;\n      vertexData.materialInfos = [newMaterialInfo];\n      result.push(vertexData);\n    }\n    return result;\n  }\n  /**\n   * Merges the passed VertexData into the current one\n   * @param others the VertexData to be merged into the current one\n   * @param use32BitsIndices defines a boolean indicating if indices must be store in a 32 bits array\n   * @param forceCloneIndices defines a boolean indicating if indices are forced to be cloned\n   * @param mergeMaterialIds defines a boolean indicating if we need to merge the material infos\n   * @param enableCompletion defines a boolean indicating if the vertex data should be completed to be compatible\n   * @returns the modified VertexData\n   */\n  merge(others, use32BitsIndices = false, forceCloneIndices = false, mergeMaterialIds = false, enableCompletion = false) {\n    const vertexDatas = Array.isArray(others) ? others.map(other => {\n      return {\n        vertexData: other\n      };\n    }) : [{\n      vertexData: others\n    }];\n    return runCoroutineSync(this._mergeCoroutine(undefined, vertexDatas, use32BitsIndices, false, forceCloneIndices, mergeMaterialIds, enableCompletion));\n  }\n  /**\n   * @internal\n   */\n  *_mergeCoroutine(transform, vertexDatas, use32BitsIndices = false, isAsync, forceCloneIndices, mergeMaterialIds = false, enableCompletion = false) {\n    var _a, _b, _c, _d;\n    this._validate();\n    let others = vertexDatas.map(vertexData => vertexData.vertexData);\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let root = this;\n    for (const other of others) {\n      if (!other) {\n        continue;\n      }\n      other._validate();\n      if (!enableCompletion) {\n        if (!this.normals !== !other.normals || !this.tangents !== !other.tangents || !this.uvs !== !other.uvs || !this.uvs2 !== !other.uvs2 || !this.uvs3 !== !other.uvs3 || !this.uvs4 !== !other.uvs4 || !this.uvs5 !== !other.uvs5 || !this.uvs6 !== !other.uvs6 || !this.colors !== !other.colors || !this.matricesIndices !== !other.matricesIndices || !this.matricesWeights !== !other.matricesWeights || !this.matricesIndicesExtra !== !other.matricesIndicesExtra || !this.matricesWeightsExtra !== !other.matricesWeightsExtra) {\n          throw new Error(\"Cannot merge vertex data that do not have the same set of attributes\");\n        }\n      } else {\n        if (!this.normals !== !other.normals) {\n          if (!this.normals) {\n            this.normals = new Float32Array(this.positions.length);\n          } else {\n            other.normals = new Float32Array(other.positions.length);\n          }\n        }\n        if (!this.tangents !== !other.tangents) {\n          if (!this.tangents) {\n            this.tangents = new Float32Array(this.positions.length / 3 * 4);\n          } else {\n            other.tangents = new Float32Array(other.positions.length / 3 * 4);\n          }\n        }\n        if (!this.uvs !== !other.uvs) {\n          if (!this.uvs) {\n            this.uvs = new Float32Array(this.positions.length / 3 * 2);\n          } else {\n            other.uvs = new Float32Array(other.positions.length / 3 * 2);\n          }\n        }\n        if (!this.uvs2 !== !other.uvs2) {\n          if (!this.uvs2) {\n            this.uvs2 = new Float32Array(this.positions.length / 3 * 2);\n          } else {\n            other.uvs2 = new Float32Array(other.positions.length / 3 * 2);\n          }\n        }\n        if (!this.uvs3 !== !other.uvs3) {\n          if (!this.uvs3) {\n            this.uvs3 = new Float32Array(this.positions.length / 3 * 2);\n          } else {\n            other.uvs3 = new Float32Array(other.positions.length / 3 * 2);\n          }\n        }\n        if (!this.uvs4 !== !other.uvs4) {\n          if (!this.uvs4) {\n            this.uvs4 = new Float32Array(this.positions.length / 3 * 2);\n          } else {\n            other.uvs4 = new Float32Array(other.positions.length / 3 * 2);\n          }\n        }\n        if (!this.uvs5 !== !other.uvs5) {\n          if (!this.uvs5) {\n            this.uvs5 = new Float32Array(this.positions.length / 3 * 2);\n          } else {\n            other.uvs5 = new Float32Array(other.positions.length / 3 * 2);\n          }\n        }\n        if (!this.uvs6 !== !other.uvs6) {\n          if (!this.uvs6) {\n            this.uvs6 = new Float32Array(this.positions.length / 3 * 2);\n          } else {\n            other.uvs6 = new Float32Array(other.positions.length / 3 * 2);\n          }\n        }\n        if (!this.colors !== !other.colors) {\n          if (!this.colors) {\n            this.colors = new Float32Array(this.positions.length / 3 * 4);\n            this.colors.fill(1); // Set to white by default\n          } else {\n            other.colors = new Float32Array(other.positions.length / 3 * 4);\n            other.colors.fill(1); // Set to white by default\n          }\n        }\n\n        if (!this.matricesIndices !== !other.matricesIndices) {\n          if (!this.matricesIndices) {\n            this.matricesIndices = new Float32Array(this.positions.length / 3 * 4);\n          } else {\n            other.matricesIndices = new Float32Array(other.positions.length / 3 * 4);\n          }\n        }\n        if (!this.matricesWeights !== !other.matricesWeights) {\n          if (!this.matricesWeights) {\n            this.matricesWeights = new Float32Array(this.positions.length / 3 * 4);\n          } else {\n            other.matricesWeights = new Float32Array(other.positions.length / 3 * 4);\n          }\n        }\n        if (!this.matricesIndicesExtra !== !other.matricesIndicesExtra) {\n          if (!this.matricesIndicesExtra) {\n            this.matricesIndicesExtra = new Float32Array(this.positions.length / 3 * 4);\n          } else {\n            other.matricesIndicesExtra = new Float32Array(other.positions.length / 3 * 4);\n          }\n        }\n        if (!this.matricesWeightsExtra !== !other.matricesWeightsExtra) {\n          if (!this.matricesWeightsExtra) {\n            this.matricesWeightsExtra = new Float32Array(this.positions.length / 3 * 4);\n          } else {\n            other.matricesWeightsExtra = new Float32Array(other.positions.length / 3 * 4);\n          }\n        }\n      }\n    }\n    if (mergeMaterialIds) {\n      // Merge material infos\n      let materialIndex = 0;\n      let indexOffset = 0;\n      let vertexOffset = 0;\n      const materialInfos = [];\n      let currentMaterialInfo = null;\n      const vertexDataList = [];\n      // We need to split vertexData with more than one materialInfo\n      for (const split of this.splitBasedOnMaterialID()) {\n        vertexDataList.push({\n          vertexData: split,\n          transform: transform\n        });\n      }\n      for (const data of vertexDatas) {\n        if (!data.vertexData) {\n          continue;\n        }\n        for (const split of data.vertexData.splitBasedOnMaterialID()) {\n          vertexDataList.push({\n            vertexData: split,\n            transform: data.transform\n          });\n        }\n      }\n      // Sort by material IDs\n      vertexDataList.sort((a, b) => {\n        const matInfoA = a.vertexData.materialInfos ? a.vertexData.materialInfos[0].materialIndex : 0;\n        const matInfoB = b.vertexData.materialInfos ? b.vertexData.materialInfos[0].materialIndex : 0;\n        if (matInfoA > matInfoB) {\n          return 1;\n        }\n        if (matInfoA === matInfoB) {\n          return 0;\n        }\n        return -1;\n      });\n      // Build the new material info\n      for (const vertexDataSource of vertexDataList) {\n        const vertexData = vertexDataSource.vertexData;\n        if (vertexData.materialInfos) {\n          materialIndex = vertexData.materialInfos[0].materialIndex;\n        } else {\n          materialIndex = 0;\n        }\n        if (currentMaterialInfo && currentMaterialInfo.materialIndex === materialIndex) {\n          currentMaterialInfo.indexCount += vertexData.indices.length;\n          currentMaterialInfo.verticesCount += vertexData.positions.length / 3;\n        } else {\n          const materialInfo = new VertexDataMaterialInfo();\n          materialInfo.materialIndex = materialIndex;\n          materialInfo.indexStart = indexOffset;\n          materialInfo.indexCount = vertexData.indices.length;\n          materialInfo.verticesStart = vertexOffset;\n          materialInfo.verticesCount = vertexData.positions.length / 3;\n          materialInfos.push(materialInfo);\n          currentMaterialInfo = materialInfo;\n        }\n        indexOffset += vertexData.indices.length;\n        vertexOffset += vertexData.positions.length / 3;\n      }\n      // Extract sorted values\n      const first = vertexDataList.splice(0, 1)[0];\n      root = first.vertexData;\n      transform = first.transform;\n      others = vertexDataList.map(v => v.vertexData);\n      vertexDatas = vertexDataList;\n      this.materialInfos = materialInfos;\n    }\n    // Merge geometries\n    const totalIndices = others.reduce((indexSum, vertexData) => {\n      var _a, _b;\n      return indexSum + ((_b = (_a = vertexData.indices) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);\n    }, (_b = (_a = root.indices) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);\n    const sliceIndices = forceCloneIndices || others.some(vertexData => vertexData.indices === root.indices);\n    let indices = sliceIndices ? (_c = root.indices) === null || _c === void 0 ? void 0 : _c.slice() : root.indices;\n    if (totalIndices > 0) {\n      let indicesOffset = (_d = indices === null || indices === void 0 ? void 0 : indices.length) !== null && _d !== void 0 ? _d : 0;\n      if (!indices) {\n        indices = new Array(totalIndices);\n      }\n      if (indices.length !== totalIndices) {\n        if (Array.isArray(indices)) {\n          indices.length = totalIndices;\n        } else {\n          const temp = use32BitsIndices || indices instanceof Uint32Array ? new Uint32Array(totalIndices) : new Uint16Array(totalIndices);\n          temp.set(indices);\n          indices = temp;\n        }\n        if (transform && transform.determinant() < 0) {\n          VertexData._FlipFaces(indices, 0, indicesOffset);\n        }\n      }\n      let positionsOffset = root.positions ? root.positions.length / 3 : 0;\n      for (const {\n        vertexData: other,\n        transform\n      } of vertexDatas) {\n        if (other.indices) {\n          for (let index = 0; index < other.indices.length; index++) {\n            indices[indicesOffset + index] = other.indices[index] + positionsOffset;\n          }\n          if (transform && transform.determinant() < 0) {\n            VertexData._FlipFaces(indices, indicesOffset, other.indices.length);\n          }\n          // The call to _validate already checked for positions\n          positionsOffset += other.positions.length / 3;\n          indicesOffset += other.indices.length;\n          if (isAsync) {\n            yield;\n          }\n        }\n      }\n    }\n    this.indices = indices;\n    this.positions = VertexData._MergeElement(VertexBuffer.PositionKind, root.positions, transform, vertexDatas.map(other => [other.vertexData.positions, other.transform]));\n    if (isAsync) {\n      yield;\n    }\n    if (root.normals) {\n      this.normals = VertexData._MergeElement(VertexBuffer.NormalKind, root.normals, transform, vertexDatas.map(other => [other.vertexData.normals, other.transform]));\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (root.tangents) {\n      this.tangents = VertexData._MergeElement(VertexBuffer.TangentKind, root.tangents, transform, vertexDatas.map(other => [other.vertexData.tangents, other.transform]));\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (root.uvs) {\n      this.uvs = VertexData._MergeElement(VertexBuffer.UVKind, root.uvs, transform, vertexDatas.map(other => [other.vertexData.uvs, other.transform]));\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (root.uvs2) {\n      this.uvs2 = VertexData._MergeElement(VertexBuffer.UV2Kind, root.uvs2, transform, vertexDatas.map(other => [other.vertexData.uvs2, other.transform]));\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (root.uvs3) {\n      this.uvs3 = VertexData._MergeElement(VertexBuffer.UV3Kind, root.uvs3, transform, vertexDatas.map(other => [other.vertexData.uvs3, other.transform]));\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (root.uvs4) {\n      this.uvs4 = VertexData._MergeElement(VertexBuffer.UV4Kind, root.uvs4, transform, vertexDatas.map(other => [other.vertexData.uvs4, other.transform]));\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (root.uvs5) {\n      this.uvs5 = VertexData._MergeElement(VertexBuffer.UV5Kind, root.uvs5, transform, vertexDatas.map(other => [other.vertexData.uvs5, other.transform]));\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (root.uvs6) {\n      this.uvs6 = VertexData._MergeElement(VertexBuffer.UV6Kind, root.uvs6, transform, vertexDatas.map(other => [other.vertexData.uvs6, other.transform]));\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (root.colors) {\n      this.colors = VertexData._MergeElement(VertexBuffer.ColorKind, root.colors, transform, vertexDatas.map(other => [other.vertexData.colors, other.transform]));\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (root.matricesIndices) {\n      this.matricesIndices = VertexData._MergeElement(VertexBuffer.MatricesIndicesKind, root.matricesIndices, transform, vertexDatas.map(other => [other.vertexData.matricesIndices, other.transform]));\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (root.matricesWeights) {\n      this.matricesWeights = VertexData._MergeElement(VertexBuffer.MatricesWeightsKind, root.matricesWeights, transform, vertexDatas.map(other => [other.vertexData.matricesWeights, other.transform]));\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (root.matricesIndicesExtra) {\n      this.matricesIndicesExtra = VertexData._MergeElement(VertexBuffer.MatricesIndicesExtraKind, root.matricesIndicesExtra, transform, vertexDatas.map(other => [other.vertexData.matricesIndicesExtra, other.transform]));\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (root.matricesWeightsExtra) {\n      this.matricesWeightsExtra = VertexData._MergeElement(VertexBuffer.MatricesWeightsExtraKind, root.matricesWeightsExtra, transform, vertexDatas.map(other => [other.vertexData.matricesWeightsExtra, other.transform]));\n    }\n    return this;\n  }\n  static _MergeElement(kind, source, transform, others) {\n    const nonNullOthers = others.filter(other => other[0] !== null && other[0] !== undefined);\n    // If there is no source to copy and no other non-null sources then skip this element.\n    if (!source && nonNullOthers.length == 0) {\n      return source;\n    }\n    if (!source) {\n      return this._MergeElement(kind, nonNullOthers[0][0], nonNullOthers[0][1], nonNullOthers.slice(1));\n    }\n    const len = nonNullOthers.reduce((sumLen, elements) => sumLen + elements[0].length, source.length);\n    const transformRange = kind === VertexBuffer.PositionKind ? VertexData._TransformVector3Coordinates : kind === VertexBuffer.NormalKind ? VertexData._TransformVector3Normals : kind === VertexBuffer.TangentKind ? VertexData._TransformVector4Normals : () => {};\n    if (source instanceof Float32Array) {\n      // use non-loop method when the source is Float32Array\n      const ret32 = new Float32Array(len);\n      ret32.set(source);\n      transform && transformRange(ret32, transform, 0, source.length);\n      let offset = source.length;\n      for (const [vertexData, transform] of nonNullOthers) {\n        ret32.set(vertexData, offset);\n        transform && transformRange(ret32, transform, offset, vertexData.length);\n        offset += vertexData.length;\n      }\n      return ret32;\n    } else {\n      // don't use concat as it is super slow, just loop for other cases\n      const ret = new Array(len);\n      for (let i = 0; i < source.length; i++) {\n        ret[i] = source[i];\n      }\n      transform && transformRange(ret, transform, 0, source.length);\n      let offset = source.length;\n      for (const [vertexData, transform] of nonNullOthers) {\n        for (let i = 0; i < vertexData.length; i++) {\n          ret[offset + i] = vertexData[i];\n        }\n        transform && transformRange(ret, transform, offset, vertexData.length);\n        offset += vertexData.length;\n      }\n      return ret;\n    }\n  }\n  _validate() {\n    if (!this.positions) {\n      throw new RuntimeError(\"Positions are required\", ErrorCodes.MeshInvalidPositionsError);\n    }\n    const getElementCount = (kind, values) => {\n      const stride = VertexBuffer.DeduceStride(kind);\n      if (values.length % stride !== 0) {\n        throw new Error(\"The \" + kind + \"s array count must be a multiple of \" + stride);\n      }\n      return values.length / stride;\n    };\n    const positionsElementCount = getElementCount(VertexBuffer.PositionKind, this.positions);\n    const validateElementCount = (kind, values) => {\n      const elementCount = getElementCount(kind, values);\n      if (elementCount !== positionsElementCount) {\n        throw new Error(\"The \" + kind + \"s element count (\" + elementCount + \") does not match the positions count (\" + positionsElementCount + \")\");\n      }\n    };\n    if (this.normals) {\n      validateElementCount(VertexBuffer.NormalKind, this.normals);\n    }\n    if (this.tangents) {\n      validateElementCount(VertexBuffer.TangentKind, this.tangents);\n    }\n    if (this.uvs) {\n      validateElementCount(VertexBuffer.UVKind, this.uvs);\n    }\n    if (this.uvs2) {\n      validateElementCount(VertexBuffer.UV2Kind, this.uvs2);\n    }\n    if (this.uvs3) {\n      validateElementCount(VertexBuffer.UV3Kind, this.uvs3);\n    }\n    if (this.uvs4) {\n      validateElementCount(VertexBuffer.UV4Kind, this.uvs4);\n    }\n    if (this.uvs5) {\n      validateElementCount(VertexBuffer.UV5Kind, this.uvs5);\n    }\n    if (this.uvs6) {\n      validateElementCount(VertexBuffer.UV6Kind, this.uvs6);\n    }\n    if (this.colors) {\n      validateElementCount(VertexBuffer.ColorKind, this.colors);\n    }\n    if (this.matricesIndices) {\n      validateElementCount(VertexBuffer.MatricesIndicesKind, this.matricesIndices);\n    }\n    if (this.matricesWeights) {\n      validateElementCount(VertexBuffer.MatricesWeightsKind, this.matricesWeights);\n    }\n    if (this.matricesIndicesExtra) {\n      validateElementCount(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra);\n    }\n    if (this.matricesWeightsExtra) {\n      validateElementCount(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra);\n    }\n  }\n  /**\n   * Clone the current vertex data\n   * @returns a copy of the current data\n   */\n  clone() {\n    const serializationObject = this.serialize();\n    return VertexData.Parse(serializationObject);\n  }\n  /**\n   * Serializes the VertexData\n   * @returns a serialized object\n   */\n  serialize() {\n    const serializationObject = {};\n    if (this.positions) {\n      serializationObject.positions = Array.from(this.positions);\n    }\n    if (this.normals) {\n      serializationObject.normals = Array.from(this.normals);\n    }\n    if (this.tangents) {\n      serializationObject.tangents = Array.from(this.tangents);\n    }\n    if (this.uvs) {\n      serializationObject.uvs = Array.from(this.uvs);\n    }\n    if (this.uvs2) {\n      serializationObject.uvs2 = Array.from(this.uvs2);\n    }\n    if (this.uvs3) {\n      serializationObject.uvs3 = Array.from(this.uvs3);\n    }\n    if (this.uvs4) {\n      serializationObject.uvs4 = Array.from(this.uvs4);\n    }\n    if (this.uvs5) {\n      serializationObject.uvs5 = Array.from(this.uvs5);\n    }\n    if (this.uvs6) {\n      serializationObject.uvs6 = Array.from(this.uvs6);\n    }\n    if (this.colors) {\n      serializationObject.colors = Array.from(this.colors);\n    }\n    if (this.matricesIndices) {\n      serializationObject.matricesIndices = Array.from(this.matricesIndices);\n      serializationObject.matricesIndices._isExpanded = true;\n    }\n    if (this.matricesWeights) {\n      serializationObject.matricesWeights = Array.from(this.matricesWeights);\n    }\n    if (this.matricesIndicesExtra) {\n      serializationObject.matricesIndicesExtra = Array.from(this.matricesIndicesExtra);\n      serializationObject.matricesIndicesExtra._isExpanded = true;\n    }\n    if (this.matricesWeightsExtra) {\n      serializationObject.matricesWeightsExtra = Array.from(this.matricesWeightsExtra);\n    }\n    serializationObject.indices = Array.from(this.indices);\n    if (this.materialInfos) {\n      serializationObject.materialInfos = [];\n      for (const materialInfo of this.materialInfos) {\n        const materialInfoSerializationObject = {\n          indexStart: materialInfo.indexStart,\n          indexCount: materialInfo.indexCount,\n          materialIndex: materialInfo.materialIndex,\n          verticesStart: materialInfo.verticesStart,\n          verticesCount: materialInfo.verticesCount\n        };\n        serializationObject.materialInfos.push(materialInfoSerializationObject);\n      }\n    }\n    return serializationObject;\n  }\n  // Statics\n  /**\n   * Extracts the vertexData from a mesh\n   * @param mesh the mesh from which to extract the VertexData\n   * @param copyWhenShared defines if the VertexData must be cloned when shared between multiple meshes, optional, default false\n   * @param forceCopy indicating that the VertexData must be cloned, optional, default false\n   * @returns the object VertexData associated to the passed mesh\n   */\n  static ExtractFromMesh(mesh, copyWhenShared, forceCopy) {\n    return VertexData._ExtractFrom(mesh, copyWhenShared, forceCopy);\n  }\n  /**\n   * Extracts the vertexData from the geometry\n   * @param geometry the geometry from which to extract the VertexData\n   * @param copyWhenShared defines if the VertexData must be cloned when the geometry is shared between multiple meshes, optional, default false\n   * @param forceCopy indicating that the VertexData must be cloned, optional, default false\n   * @returns the object VertexData associated to the passed mesh\n   */\n  static ExtractFromGeometry(geometry, copyWhenShared, forceCopy) {\n    return VertexData._ExtractFrom(geometry, copyWhenShared, forceCopy);\n  }\n  static _ExtractFrom(meshOrGeometry, copyWhenShared, forceCopy) {\n    const result = new VertexData();\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n      result.positions = meshOrGeometry.getVerticesData(VertexBuffer.PositionKind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      result.normals = meshOrGeometry.getVerticesData(VertexBuffer.NormalKind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n      result.tangents = meshOrGeometry.getVerticesData(VertexBuffer.TangentKind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UVKind)) {\n      result.uvs = meshOrGeometry.getVerticesData(VertexBuffer.UVKind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n      result.uvs2 = meshOrGeometry.getVerticesData(VertexBuffer.UV2Kind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\n      result.uvs3 = meshOrGeometry.getVerticesData(VertexBuffer.UV3Kind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\n      result.uvs4 = meshOrGeometry.getVerticesData(VertexBuffer.UV4Kind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\n      result.uvs5 = meshOrGeometry.getVerticesData(VertexBuffer.UV5Kind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\n      result.uvs6 = meshOrGeometry.getVerticesData(VertexBuffer.UV6Kind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.ColorKind)) {\n      result.colors = meshOrGeometry.getVerticesData(VertexBuffer.ColorKind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\n      result.matricesIndices = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesKind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n      result.matricesWeights = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsKind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesExtraKind)) {\n      result.matricesIndicesExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesExtraKind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {\n      result.matricesWeightsExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsExtraKind, copyWhenShared, forceCopy);\n    }\n    result.indices = meshOrGeometry.getIndices(copyWhenShared, forceCopy);\n    return result;\n  }\n  /**\n   * Creates the VertexData for a Ribbon\n   * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\n   * * pathArray array of paths, each of which an array of successive Vector3\n   * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\n   * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\n   * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\n   * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\n   * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\n   * @param options.pathArray\n   * @param options.closeArray\n   * @param options.closePath\n   * @param options.offset\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @param options.invertUV\n   * @param options.uvs\n   * @param options.colors\n   * @returns the VertexData of the ribbon\n   * @deprecated use CreateRibbonVertexData instead\n   */\n  static CreateRibbon(options) {\n    throw _WarnImport(\"ribbonBuilder\");\n  }\n  /**\n   * Creates the VertexData for a box\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\n   * * size sets the width, height and depth of the box to the value of size, optional default 1\n   * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\n   * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\n   * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\n   * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n   * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.size\n   * @param options.width\n   * @param options.height\n   * @param options.depth\n   * @param options.faceUV\n   * @param options.faceColors\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the box\n   * @deprecated Please use CreateBoxVertexData from the BoxBuilder file instead\n   */\n  static CreateBox(options) {\n    throw _WarnImport(\"boxBuilder\");\n  }\n  /**\n   * Creates the VertexData for a tiled box\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\n   * * faceTiles sets the pattern, tile size and number of tiles for a face\n   * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n   * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * @param options.pattern\n   * @param options.width\n   * @param options.height\n   * @param options.depth\n   * @param options.tileSize\n   * @param options.tileWidth\n   * @param options.tileHeight\n   * @param options.alignHorizontal\n   * @param options.alignVertical\n   * @param options.faceUV\n   * @param options.faceColors\n   * @param options.sideOrientation\n   * @returns the VertexData of the box\n   * @deprecated Please use CreateTiledBoxVertexData instead\n   */\n  static CreateTiledBox(options) {\n    throw _WarnImport(\"tiledBoxBuilder\");\n  }\n  /**\n   * Creates the VertexData for a tiled plane\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\n   * * pattern a limited pattern arrangement depending on the number\n   * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\n   * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\n   * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.pattern\n   * @param options.tileSize\n   * @param options.tileWidth\n   * @param options.tileHeight\n   * @param options.size\n   * @param options.width\n   * @param options.height\n   * @param options.alignHorizontal\n   * @param options.alignVertical\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the tiled plane\n   * @deprecated use CreateTiledPlaneVertexData instead\n   */\n  static CreateTiledPlane(options) {\n    throw _WarnImport(\"tiledPlaneBuilder\");\n  }\n  /**\n   * Creates the VertexData for an ellipsoid, defaults to a sphere\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\n   * * segments sets the number of horizontal strips optional, default 32\n   * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\n   * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\n   * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\n   * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\n   * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\n   * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.segments\n   * @param options.diameter\n   * @param options.diameterX\n   * @param options.diameterY\n   * @param options.diameterZ\n   * @param options.arc\n   * @param options.slice\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the ellipsoid\n   * @deprecated use CreateSphereVertexData instead\n   */\n  static CreateSphere(options) {\n    throw _WarnImport(\"sphereBuilder\");\n  }\n  /**\n   * Creates the VertexData for a cylinder, cone or prism\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\n   * * height sets the height (y direction) of the cylinder, optional, default 2\n   * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\n   * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\n   * * diameter sets the diameter of the top and bottom of the cone, optional default 1\n   * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\n   * * subdivisions` the number of rings along the cylinder height, optional, default 1\n   * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\n   * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n   * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n   * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false\n   * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.height\n   * @param options.diameterTop\n   * @param options.diameterBottom\n   * @param options.diameter\n   * @param options.tessellation\n   * @param options.subdivisions\n   * @param options.arc\n   * @param options.faceColors\n   * @param options.faceUV\n   * @param options.hasRings\n   * @param options.enclose\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the cylinder, cone or prism\n   * @deprecated please use CreateCylinderVertexData instead\n   */\n  static CreateCylinder(options) {\n    throw _WarnImport(\"cylinderBuilder\");\n  }\n  /**\n   * Creates the VertexData for a torus\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\n   * * diameter the diameter of the torus, optional default 1\n   * * thickness the diameter of the tube forming the torus, optional default 0.5\n   * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.diameter\n   * @param options.thickness\n   * @param options.tessellation\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the torus\n   * @deprecated use CreateTorusVertexData instead\n   */\n  static CreateTorus(options) {\n    throw _WarnImport(\"torusBuilder\");\n  }\n  /**\n   * Creates the VertexData of the LineSystem\n   * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\n   *  - lines an array of lines, each line being an array of successive Vector3\n   *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\n   * @param options.lines\n   * @param options.colors\n   * @returns the VertexData of the LineSystem\n   * @deprecated use CreateLineSystemVertexData instead\n   */\n  static CreateLineSystem(options) {\n    throw _WarnImport(\"linesBuilder\");\n  }\n  /**\n   * Create the VertexData for a DashedLines\n   * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\n   *  - points an array successive Vector3\n   *  - dashSize the size of the dashes relative to the dash number, optional, default 3\n   *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\n   *  - dashNb the intended total number of dashes, optional, default 200\n   * @param options.points\n   * @param options.dashSize\n   * @param options.gapSize\n   * @param options.dashNb\n   * @returns the VertexData for the DashedLines\n   * @deprecated use CreateDashedLinesVertexData instead\n   */\n  static CreateDashedLines(options) {\n    throw _WarnImport(\"linesBuilder\");\n  }\n  /**\n   * Creates the VertexData for a Ground\n   * @param options an object used to set the following optional parameters for the Ground, required but can be empty\n   *  - width the width (x direction) of the ground, optional, default 1\n   *  - height the height (z direction) of the ground, optional, default 1\n   *  - subdivisions the number of subdivisions per side, optional, default 1\n   * @param options.width\n   * @param options.height\n   * @param options.subdivisions\n   * @param options.subdivisionsX\n   * @param options.subdivisionsY\n   * @returns the VertexData of the Ground\n   * @deprecated Please use CreateGroundVertexData instead\n   */\n  static CreateGround(options) {\n    throw _WarnImport(\"groundBuilder\");\n  }\n  /**\n   * Creates the VertexData for a TiledGround by subdividing the ground into tiles\n   * @param options an object used to set the following optional parameters for the Ground, required but can be empty\n   * * xmin the ground minimum X coordinate, optional, default -1\n   * * zmin the ground minimum Z coordinate, optional, default -1\n   * * xmax the ground maximum X coordinate, optional, default 1\n   * * zmax the ground maximum Z coordinate, optional, default 1\n   * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\n   * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\n   * @param options.xmin\n   * @param options.zmin\n   * @param options.xmax\n   * @param options.zmax\n   * @param options.subdivisions\n   * @param options.subdivisions.w\n   * @param options.subdivisions.h\n   * @param options.precision\n   * @param options.precision.w\n   * @param options.precision.h\n   * @returns the VertexData of the TiledGround\n   * @deprecated use CreateTiledGroundVertexData instead\n   */\n  static CreateTiledGround(options) {\n    throw _WarnImport(\"groundBuilder\");\n  }\n  /**\n   * Creates the VertexData of the Ground designed from a heightmap\n   * @param options an object used to set the following parameters for the Ground, required and provided by CreateGroundFromHeightMap\n   * * width the width (x direction) of the ground\n   * * height the height (z direction) of the ground\n   * * subdivisions the number of subdivisions per side\n   * * minHeight the minimum altitude on the ground, optional, default 0\n   * * maxHeight the maximum altitude on the ground, optional default 1\n   * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\n   * * buffer the array holding the image color data\n   * * bufferWidth the width of image\n   * * bufferHeight the height of image\n   * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\n   * @param options.width\n   * @param options.height\n   * @param options.subdivisions\n   * @param options.minHeight\n   * @param options.maxHeight\n   * @param options.colorFilter\n   * @param options.buffer\n   * @param options.bufferWidth\n   * @param options.bufferHeight\n   * @param options.alphaFilter\n   * @returns the VertexData of the Ground designed from a heightmap\n   * @deprecated use CreateGroundFromHeightMapVertexData instead\n   */\n  static CreateGroundFromHeightMap(options) {\n    throw _WarnImport(\"groundBuilder\");\n  }\n  /**\n   * Creates the VertexData for a Plane\n   * @param options an object used to set the following optional parameters for the plane, required but can be empty\n   * * size sets the width and height of the plane to the value of size, optional default 1\n   * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size\n   * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.size\n   * @param options.width\n   * @param options.height\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the box\n   * @deprecated use CreatePlaneVertexData instead\n   */\n  static CreatePlane(options) {\n    throw _WarnImport(\"planeBuilder\");\n  }\n  /**\n   * Creates the VertexData of the Disc or regular Polygon\n   * @param options an object used to set the following optional parameters for the disc, required but can be empty\n   * * radius the radius of the disc, optional default 0.5\n   * * tessellation the number of polygon sides, optional, default 64\n   * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.radius\n   * @param options.tessellation\n   * @param options.arc\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the box\n   * @deprecated use CreateDiscVertexData instead\n   */\n  static CreateDisc(options) {\n    throw _WarnImport(\"discBuilder\");\n  }\n  /**\n   * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()\n   * All parameters are provided by CreatePolygon as needed\n   * @param polygon a mesh built from polygonTriangulation.build()\n   * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n   * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n   * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param wrap a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side\n   * @returns the VertexData of the Polygon\n   * @deprecated use CreatePolygonVertexData instead\n   */\n  static CreatePolygon(polygon, sideOrientation, fUV, fColors, frontUVs, backUVs, wrap) {\n    throw _WarnImport(\"polygonBuilder\");\n  }\n  /**\n   * Creates the VertexData of the IcoSphere\n   * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty\n   * * radius the radius of the IcoSphere, optional default 1\n   * * radiusX allows stretching in the x direction, optional, default radius\n   * * radiusY allows stretching in the y direction, optional, default radius\n   * * radiusZ allows stretching in the z direction, optional, default radius\n   * * flat when true creates a flat shaded mesh, optional, default true\n   * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.radius\n   * @param options.radiusX\n   * @param options.radiusY\n   * @param options.radiusZ\n   * @param options.flat\n   * @param options.subdivisions\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the IcoSphere\n   * @deprecated use CreateIcoSphereVertexData instead\n   */\n  static CreateIcoSphere(options) {\n    throw _WarnImport(\"icoSphereBuilder\");\n  }\n  // inspired from // http://stemkoski.github.io/Three.js/Polyhedra.html\n  /**\n   * Creates the VertexData for a Polyhedron\n   * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\n   * * type provided types are:\n   *  * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\n   *  * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\n   * * size the size of the IcoSphere, optional default 1\n   * * sizeX allows stretching in the x direction, optional, default size\n   * * sizeY allows stretching in the y direction, optional, default size\n   * * sizeZ allows stretching in the z direction, optional, default size\n   * * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor\n   * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n   * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n   * * flat when true creates a flat shaded mesh, optional, default true\n   * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.type\n   * @param options.size\n   * @param options.sizeX\n   * @param options.sizeY\n   * @param options.sizeZ\n   * @param options.custom\n   * @param options.faceUV\n   * @param options.faceColors\n   * @param options.flat\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the Polyhedron\n   * @deprecated use CreatePolyhedronVertexData instead\n   */\n  static CreatePolyhedron(options) {\n    throw _WarnImport(\"polyhedronBuilder\");\n  }\n  /**\n   * Creates the VertexData for a Capsule, inspired from https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\n   * @param options an object used to set the following optional parameters for the capsule, required but can be empty\n   * @returns the VertexData of the Capsule\n   * @deprecated Please use CreateCapsuleVertexData from the capsuleBuilder file instead\n   */\n  static CreateCapsule(options = {\n    orientation: Vector3.Up(),\n    subdivisions: 2,\n    tessellation: 16,\n    height: 1,\n    radius: 0.25,\n    capSubdivisions: 6\n  }) {\n    throw _WarnImport(\"capsuleBuilder\");\n  }\n  // based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\n  /**\n   * Creates the VertexData for a TorusKnot\n   * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\n   * * radius the radius of the torus knot, optional, default 2\n   * * tube the thickness of the tube, optional, default 0.5\n   * * radialSegments the number of sides on each tube segments, optional, default 32\n   * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\n   * * p the number of windings around the z axis, optional,  default 2\n   * * q the number of windings around the x axis, optional,  default 3\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.radius\n   * @param options.tube\n   * @param options.radialSegments\n   * @param options.tubularSegments\n   * @param options.p\n   * @param options.q\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the Torus Knot\n   * @deprecated use CreateTorusKnotVertexData instead\n   */\n  static CreateTorusKnot(options) {\n    throw _WarnImport(\"torusKnotBuilder\");\n  }\n  // Tools\n  /**\n   * Compute normals for given positions and indices\n   * @param positions an array of vertex positions, [...., x, y, z, ......]\n   * @param indices an array of indices in groups of three for each triangular facet, [...., i, j, k, ......]\n   * @param normals an array of vertex normals, [...., x, y, z, ......]\n   * @param options an object used to set the following optional parameters for the TorusKnot, optional\n   * * facetNormals : optional array of facet normals (vector3)\n   * * facetPositions : optional array of facet positions (vector3)\n   * * facetPartitioning : optional partitioning array. facetPositions is required for facetPartitioning computation\n   * * ratio : optional partitioning ratio / bounding box, required for facetPartitioning computation\n   * * bInfo : optional bounding info, required for facetPartitioning computation\n   * * bbSize : optional bounding box size data, required for facetPartitioning computation\n   * * subDiv : optional partitioning data about subdivisions on  each axis (int), required for facetPartitioning computation\n   * * useRightHandedSystem: optional boolean to for right handed system computation\n   * * depthSort : optional boolean to enable the facet depth sort computation\n   * * distanceTo : optional Vector3 to compute the facet depth from this location\n   * * depthSortedFacets : optional array of depthSortedFacets to store the facet distances from the reference location\n   * @param options.facetNormals\n   * @param options.facetPositions\n   * @param options.facetPartitioning\n   * @param options.ratio\n   * @param options.bInfo\n   * @param options.bbSize\n   * @param options.subDiv\n   * @param options.useRightHandedSystem\n   * @param options.depthSort\n   * @param options.distanceTo\n   * @param options.depthSortedFacets\n   */\n  static ComputeNormals(positions, indices, normals, options) {\n    // temporary scalar variables\n    let index = 0; // facet index\n    let p1p2x = 0.0; // p1p2 vector x coordinate\n    let p1p2y = 0.0; // p1p2 vector y coordinate\n    let p1p2z = 0.0; // p1p2 vector z coordinate\n    let p3p2x = 0.0; // p3p2 vector x coordinate\n    let p3p2y = 0.0; // p3p2 vector y coordinate\n    let p3p2z = 0.0; // p3p2 vector z coordinate\n    let faceNormalx = 0.0; // facet normal x coordinate\n    let faceNormaly = 0.0; // facet normal y coordinate\n    let faceNormalz = 0.0; // facet normal z coordinate\n    let length = 0.0; // facet normal length before normalization\n    let v1x = 0; // vector1 x index in the positions array\n    let v1y = 0; // vector1 y index in the positions array\n    let v1z = 0; // vector1 z index in the positions array\n    let v2x = 0; // vector2 x index in the positions array\n    let v2y = 0; // vector2 y index in the positions array\n    let v2z = 0; // vector2 z index in the positions array\n    let v3x = 0; // vector3 x index in the positions array\n    let v3y = 0; // vector3 y index in the positions array\n    let v3z = 0; // vector3 z index in the positions array\n    let computeFacetNormals = false;\n    let computeFacetPositions = false;\n    let computeFacetPartitioning = false;\n    let computeDepthSort = false;\n    let faceNormalSign = 1;\n    let ratio = 0;\n    let distanceTo = null;\n    if (options) {\n      computeFacetNormals = options.facetNormals ? true : false;\n      computeFacetPositions = options.facetPositions ? true : false;\n      computeFacetPartitioning = options.facetPartitioning ? true : false;\n      faceNormalSign = options.useRightHandedSystem === true ? -1 : 1;\n      ratio = options.ratio || 0;\n      computeDepthSort = options.depthSort ? true : false;\n      distanceTo = options.distanceTo;\n      if (computeDepthSort) {\n        if (distanceTo === undefined) {\n          distanceTo = Vector3.Zero();\n        }\n      }\n    }\n    // facetPartitioning reinit if needed\n    let xSubRatio = 0;\n    let ySubRatio = 0;\n    let zSubRatio = 0;\n    let subSq = 0;\n    if (computeFacetPartitioning && options && options.bbSize) {\n      //let bbSizeMax = options.bbSize.x > options.bbSize.y ? options.bbSize.x : options.bbSize.y;\n      //bbSizeMax = bbSizeMax > options.bbSize.z ? bbSizeMax : options.bbSize.z;\n      xSubRatio = options.subDiv.X * ratio / options.bbSize.x;\n      ySubRatio = options.subDiv.Y * ratio / options.bbSize.y;\n      zSubRatio = options.subDiv.Z * ratio / options.bbSize.z;\n      subSq = options.subDiv.max * options.subDiv.max;\n      options.facetPartitioning.length = 0;\n    }\n    // reset the normals\n    for (index = 0; index < positions.length; index++) {\n      normals[index] = 0.0;\n    }\n    // Loop : 1 indice triplet = 1 facet\n    const nbFaces = indices.length / 3 | 0;\n    for (index = 0; index < nbFaces; index++) {\n      // get the indexes of the coordinates of each vertex of the facet\n      v1x = indices[index * 3] * 3;\n      v1y = v1x + 1;\n      v1z = v1x + 2;\n      v2x = indices[index * 3 + 1] * 3;\n      v2y = v2x + 1;\n      v2z = v2x + 2;\n      v3x = indices[index * 3 + 2] * 3;\n      v3y = v3x + 1;\n      v3z = v3x + 2;\n      p1p2x = positions[v1x] - positions[v2x]; // compute two vectors per facet : p1p2 and p3p2\n      p1p2y = positions[v1y] - positions[v2y];\n      p1p2z = positions[v1z] - positions[v2z];\n      p3p2x = positions[v3x] - positions[v2x];\n      p3p2y = positions[v3y] - positions[v2y];\n      p3p2z = positions[v3z] - positions[v2z];\n      // compute the face normal with the cross product\n      faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);\n      faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);\n      faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x);\n      // normalize this normal and store it in the array facetData\n      length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\n      length = length === 0 ? 1.0 : length;\n      faceNormalx /= length;\n      faceNormaly /= length;\n      faceNormalz /= length;\n      if (computeFacetNormals && options) {\n        options.facetNormals[index].x = faceNormalx;\n        options.facetNormals[index].y = faceNormaly;\n        options.facetNormals[index].z = faceNormalz;\n      }\n      if (computeFacetPositions && options) {\n        // compute and the facet barycenter coordinates in the array facetPositions\n        options.facetPositions[index].x = (positions[v1x] + positions[v2x] + positions[v3x]) / 3.0;\n        options.facetPositions[index].y = (positions[v1y] + positions[v2y] + positions[v3y]) / 3.0;\n        options.facetPositions[index].z = (positions[v1z] + positions[v2z] + positions[v3z]) / 3.0;\n      }\n      if (computeFacetPartitioning && options) {\n        // store the facet indexes in arrays in the main facetPartitioning array :\n        // compute each facet vertex (+ facet barycenter) index in the partiniong array\n        const ox = Math.floor((options.facetPositions[index].x - options.bInfo.minimum.x * ratio) * xSubRatio);\n        const oy = Math.floor((options.facetPositions[index].y - options.bInfo.minimum.y * ratio) * ySubRatio);\n        const oz = Math.floor((options.facetPositions[index].z - options.bInfo.minimum.z * ratio) * zSubRatio);\n        const b1x = Math.floor((positions[v1x] - options.bInfo.minimum.x * ratio) * xSubRatio);\n        const b1y = Math.floor((positions[v1y] - options.bInfo.minimum.y * ratio) * ySubRatio);\n        const b1z = Math.floor((positions[v1z] - options.bInfo.minimum.z * ratio) * zSubRatio);\n        const b2x = Math.floor((positions[v2x] - options.bInfo.minimum.x * ratio) * xSubRatio);\n        const b2y = Math.floor((positions[v2y] - options.bInfo.minimum.y * ratio) * ySubRatio);\n        const b2z = Math.floor((positions[v2z] - options.bInfo.minimum.z * ratio) * zSubRatio);\n        const b3x = Math.floor((positions[v3x] - options.bInfo.minimum.x * ratio) * xSubRatio);\n        const b3y = Math.floor((positions[v3y] - options.bInfo.minimum.y * ratio) * ySubRatio);\n        const b3z = Math.floor((positions[v3z] - options.bInfo.minimum.z * ratio) * zSubRatio);\n        const block_idx_v1 = b1x + options.subDiv.max * b1y + subSq * b1z;\n        const block_idx_v2 = b2x + options.subDiv.max * b2y + subSq * b2z;\n        const block_idx_v3 = b3x + options.subDiv.max * b3y + subSq * b3z;\n        const block_idx_o = ox + options.subDiv.max * oy + subSq * oz;\n        options.facetPartitioning[block_idx_o] = options.facetPartitioning[block_idx_o] ? options.facetPartitioning[block_idx_o] : new Array();\n        options.facetPartitioning[block_idx_v1] = options.facetPartitioning[block_idx_v1] ? options.facetPartitioning[block_idx_v1] : new Array();\n        options.facetPartitioning[block_idx_v2] = options.facetPartitioning[block_idx_v2] ? options.facetPartitioning[block_idx_v2] : new Array();\n        options.facetPartitioning[block_idx_v3] = options.facetPartitioning[block_idx_v3] ? options.facetPartitioning[block_idx_v3] : new Array();\n        // push each facet index in each block containing the vertex\n        options.facetPartitioning[block_idx_v1].push(index);\n        if (block_idx_v2 != block_idx_v1) {\n          options.facetPartitioning[block_idx_v2].push(index);\n        }\n        if (!(block_idx_v3 == block_idx_v2 || block_idx_v3 == block_idx_v1)) {\n          options.facetPartitioning[block_idx_v3].push(index);\n        }\n        if (!(block_idx_o == block_idx_v1 || block_idx_o == block_idx_v2 || block_idx_o == block_idx_v3)) {\n          options.facetPartitioning[block_idx_o].push(index);\n        }\n      }\n      if (computeDepthSort && options && options.facetPositions) {\n        const dsf = options.depthSortedFacets[index];\n        dsf.ind = index * 3;\n        dsf.sqDistance = Vector3.DistanceSquared(options.facetPositions[index], distanceTo);\n      }\n      // compute the normals anyway\n      normals[v1x] += faceNormalx; // accumulate all the normals per face\n      normals[v1y] += faceNormaly;\n      normals[v1z] += faceNormalz;\n      normals[v2x] += faceNormalx;\n      normals[v2y] += faceNormaly;\n      normals[v2z] += faceNormalz;\n      normals[v3x] += faceNormalx;\n      normals[v3y] += faceNormaly;\n      normals[v3z] += faceNormalz;\n    }\n    // last normalization of each normal\n    for (index = 0; index < normals.length / 3; index++) {\n      faceNormalx = normals[index * 3];\n      faceNormaly = normals[index * 3 + 1];\n      faceNormalz = normals[index * 3 + 2];\n      length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\n      length = length === 0 ? 1.0 : length;\n      faceNormalx /= length;\n      faceNormaly /= length;\n      faceNormalz /= length;\n      normals[index * 3] = faceNormalx;\n      normals[index * 3 + 1] = faceNormaly;\n      normals[index * 3 + 2] = faceNormalz;\n    }\n  }\n  /**\n   * @internal\n   */\n  static _ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs) {\n    const li = indices.length;\n    const ln = normals.length;\n    let i;\n    let n;\n    sideOrientation = sideOrientation || VertexData.DEFAULTSIDE;\n    switch (sideOrientation) {\n      case VertexData.FRONTSIDE:\n        // nothing changed\n        break;\n      case VertexData.BACKSIDE:\n        // indices\n        for (i = 0; i < li; i += 3) {\n          const tmp = indices[i];\n          indices[i] = indices[i + 2];\n          indices[i + 2] = tmp;\n        }\n        // normals\n        for (n = 0; n < ln; n++) {\n          normals[n] = -normals[n];\n        }\n        break;\n      case VertexData.DOUBLESIDE:\n        {\n          // positions\n          const lp = positions.length;\n          const l = lp / 3;\n          for (let p = 0; p < lp; p++) {\n            positions[lp + p] = positions[p];\n          }\n          // indices\n          for (i = 0; i < li; i += 3) {\n            indices[i + li] = indices[i + 2] + l;\n            indices[i + 1 + li] = indices[i + 1] + l;\n            indices[i + 2 + li] = indices[i] + l;\n          }\n          // normals\n          for (n = 0; n < ln; n++) {\n            normals[ln + n] = -normals[n];\n          }\n          // uvs\n          const lu = uvs.length;\n          let u = 0;\n          for (u = 0; u < lu; u++) {\n            uvs[u + lu] = uvs[u];\n          }\n          frontUVs = frontUVs ? frontUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\n          backUVs = backUVs ? backUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\n          u = 0;\n          for (i = 0; i < lu / 2; i++) {\n            uvs[u] = frontUVs.x + (frontUVs.z - frontUVs.x) * uvs[u];\n            uvs[u + 1] = frontUVs.y + (frontUVs.w - frontUVs.y) * uvs[u + 1];\n            uvs[u + lu] = backUVs.x + (backUVs.z - backUVs.x) * uvs[u + lu];\n            uvs[u + lu + 1] = backUVs.y + (backUVs.w - backUVs.y) * uvs[u + lu + 1];\n            u += 2;\n          }\n          break;\n        }\n    }\n  }\n  /**\n   * Creates a VertexData from serialized data\n   * @param parsedVertexData the parsed data from an imported file\n   * @returns a VertexData\n   */\n  static Parse(parsedVertexData) {\n    const vertexData = new VertexData();\n    // positions\n    const positions = parsedVertexData.positions;\n    if (positions) {\n      vertexData.set(positions, VertexBuffer.PositionKind);\n    }\n    // normals\n    const normals = parsedVertexData.normals;\n    if (normals) {\n      vertexData.set(normals, VertexBuffer.NormalKind);\n    }\n    // tangents\n    const tangents = parsedVertexData.tangents;\n    if (tangents) {\n      vertexData.set(tangents, VertexBuffer.TangentKind);\n    }\n    // uvs\n    const uvs = parsedVertexData.uvs;\n    if (uvs) {\n      vertexData.set(uvs, VertexBuffer.UVKind);\n    }\n    // uv2s\n    const uvs2 = parsedVertexData.uvs2;\n    if (uvs2) {\n      vertexData.set(uvs2, VertexBuffer.UV2Kind);\n    }\n    // uv3s\n    const uvs3 = parsedVertexData.uvs3;\n    if (uvs3) {\n      vertexData.set(uvs3, VertexBuffer.UV3Kind);\n    }\n    // uv4s\n    const uvs4 = parsedVertexData.uvs4;\n    if (uvs4) {\n      vertexData.set(uvs4, VertexBuffer.UV4Kind);\n    }\n    // uv5s\n    const uvs5 = parsedVertexData.uvs5;\n    if (uvs5) {\n      vertexData.set(uvs5, VertexBuffer.UV5Kind);\n    }\n    // uv6s\n    const uvs6 = parsedVertexData.uvs6;\n    if (uvs6) {\n      vertexData.set(uvs6, VertexBuffer.UV6Kind);\n    }\n    // colors\n    const colors = parsedVertexData.colors;\n    if (colors) {\n      vertexData.set(Color4.CheckColors4(colors, positions.length / 3), VertexBuffer.ColorKind);\n    }\n    // matricesIndices\n    const matricesIndices = parsedVertexData.matricesIndices;\n    if (matricesIndices) {\n      vertexData.set(matricesIndices, VertexBuffer.MatricesIndicesKind);\n    }\n    // matricesWeights\n    const matricesWeights = parsedVertexData.matricesWeights;\n    if (matricesWeights) {\n      vertexData.set(matricesWeights, VertexBuffer.MatricesWeightsKind);\n    }\n    // indices\n    const indices = parsedVertexData.indices;\n    if (indices) {\n      vertexData.indices = indices;\n    }\n    // MaterialInfos\n    const materialInfos = parsedVertexData.materialInfos;\n    if (materialInfos) {\n      vertexData.materialInfos = [];\n      for (const materialInfoFromJSON of materialInfos) {\n        const materialInfo = new VertexDataMaterialInfo();\n        materialInfo.indexCount = materialInfoFromJSON.indexCount;\n        materialInfo.indexStart = materialInfoFromJSON.indexStart;\n        materialInfo.verticesCount = materialInfoFromJSON.verticesCount;\n        materialInfo.verticesStart = materialInfoFromJSON.verticesStart;\n        materialInfo.materialIndex = materialInfoFromJSON.materialIndex;\n        vertexData.materialInfos.push(materialInfo);\n      }\n    }\n    return vertexData;\n  }\n  /**\n   * Applies VertexData created from the imported parameters to the geometry\n   * @param parsedVertexData the parsed data from an imported file\n   * @param geometry the geometry to apply the VertexData to\n   */\n  static ImportVertexData(parsedVertexData, geometry) {\n    const vertexData = VertexData.Parse(parsedVertexData);\n    geometry.setAllVerticesData(vertexData, parsedVertexData.updatable);\n  }\n}\n/**\n * Mesh side orientation : usually the external or front surface\n */\nVertexData.FRONTSIDE = 0;\n/**\n * Mesh side orientation : usually the internal or back surface\n */\nVertexData.BACKSIDE = 1;\n/**\n * Mesh side orientation : both internal and external or front and back surfaces\n */\nVertexData.DOUBLESIDE = 2;\n/**\n * Mesh side orientation : by default, `FRONTSIDE`\n */\nVertexData.DEFAULTSIDE = 0;\nVertexData._UniqueIDGenerator = 0;\n__decorate([nativeOverride.filter((...[coordinates]) => !Array.isArray(coordinates))], VertexData, \"_TransformVector3Coordinates\", null);\n__decorate([nativeOverride.filter((...[normals]) => !Array.isArray(normals))], VertexData, \"_TransformVector3Normals\", null);\n__decorate([nativeOverride.filter((...[normals]) => !Array.isArray(normals))], VertexData, \"_TransformVector4Normals\", null);\n__decorate([nativeOverride.filter((...[indices]) => !Array.isArray(indices))], VertexData, \"_FlipFaces\", null);","map":{"version":3,"names":["Vector3","Vector4","TmpVectors","VertexBuffer","_WarnImport","Color4","Logger","nativeOverride","makeSyncFunction","runCoroutineSync","RuntimeError","ErrorCodes","SubMesh","VertexDataMaterialInfo","VertexData","constructor","uniqueId","metadata","_applyTo","_applyToCoroutine","bind","_UniqueIDGenerator","set","data","kind","length","Warn","PositionKind","positions","NormalKind","normals","TangentKind","tangents","UVKind","uvs","UV2Kind","uvs2","UV3Kind","uvs3","UV4Kind","uvs4","UV5Kind","uvs5","UV6Kind","uvs6","ColorKind","colors","MatricesIndicesKind","matricesIndices","MatricesWeightsKind","matricesWeights","MatricesIndicesExtraKind","matricesIndicesExtra","MatricesWeightsExtraKind","matricesWeightsExtra","applyToMesh","mesh","updatable","applyToGeometry","geometry","updateMesh","_update","updateGeometry","meshOrGeometry","isAsync","setVerticesData","indices","setIndices","subMeshes","materialInfos","matInfo","materialIndex","verticesStart","verticesCount","indexStart","indexCount","updateExtends","makeItUnique","updateVerticesData","_TransformVector3Coordinates","coordinates","transformation","offset","coordinate","transformedCoordinate","index","FromArrayToRef","TransformCoordinatesToRef","x","y","z","_TransformVector3Normals","normal","transformedNormal","TransformNormalToRef","_TransformVector4Normals","w","_FlipFaces","tmp","transform","matrix","flip","determinant","splitBasedOnMaterialID","result","Array","materialInfo","vertexData","slice","push","newMaterialInfo","merge","others","use32BitsIndices","forceCloneIndices","mergeMaterialIds","enableCompletion","vertexDatas","isArray","map","other","_mergeCoroutine","undefined","_validate","root","Error","Float32Array","fill","indexOffset","vertexOffset","currentMaterialInfo","vertexDataList","split","sort","a","b","matInfoA","matInfoB","vertexDataSource","first","splice","v","totalIndices","reduce","indexSum","_a","_b","sliceIndices","some","_c","indicesOffset","_d","temp","Uint32Array","Uint16Array","positionsOffset","_MergeElement","source","nonNullOthers","filter","len","sumLen","elements","transformRange","ret32","ret","i","MeshInvalidPositionsError","getElementCount","values","stride","DeduceStride","positionsElementCount","validateElementCount","elementCount","clone","serializationObject","serialize","Parse","from","_isExpanded","materialInfoSerializationObject","ExtractFromMesh","copyWhenShared","forceCopy","_ExtractFrom","ExtractFromGeometry","isVerticesDataPresent","getVerticesData","getIndices","CreateRibbon","options","CreateBox","CreateTiledBox","CreateTiledPlane","CreateSphere","CreateCylinder","CreateTorus","CreateLineSystem","CreateDashedLines","CreateGround","CreateTiledGround","CreateGroundFromHeightMap","CreatePlane","CreateDisc","CreatePolygon","polygon","sideOrientation","fUV","fColors","frontUVs","backUVs","wrap","CreateIcoSphere","CreatePolyhedron","CreateCapsule","orientation","Up","subdivisions","tessellation","height","radius","capSubdivisions","CreateTorusKnot","ComputeNormals","p1p2x","p1p2y","p1p2z","p3p2x","p3p2y","p3p2z","faceNormalx","faceNormaly","faceNormalz","v1x","v1y","v1z","v2x","v2y","v2z","v3x","v3y","v3z","computeFacetNormals","computeFacetPositions","computeFacetPartitioning","computeDepthSort","faceNormalSign","ratio","distanceTo","facetNormals","facetPositions","facetPartitioning","useRightHandedSystem","depthSort","Zero","xSubRatio","ySubRatio","zSubRatio","subSq","bbSize","subDiv","X","Y","Z","max","nbFaces","Math","sqrt","ox","floor","bInfo","minimum","oy","oz","b1x","b1y","b1z","b2x","b2y","b2z","b3x","b3y","b3z","block_idx_v1","block_idx_v2","block_idx_v3","block_idx_o","dsf","depthSortedFacets","ind","sqDistance","DistanceSquared","_ComputeSides","li","ln","n","DEFAULTSIDE","FRONTSIDE","BACKSIDE","DOUBLESIDE","lp","l","p","lu","u","parsedVertexData","CheckColors4","materialInfoFromJSON","ImportVertexData","setAllVerticesData","__decorate"],"sources":["../../../../dev/core/src/Meshes/mesh.vertexData.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Nullable, FloatArray, IndicesArray, DeepImmutable } from \"../types\";\r\nimport type { Matrix, Vector2 } from \"../Maths/math.vector\";\r\nimport { Vector3, Vector4, TmpVectors } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { Color3 } from \"../Maths/math.color\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { nativeOverride } from \"../Misc/decorators\";\r\nimport type { Coroutine } from \"../Misc/coroutine\";\r\nimport { makeSyncFunction, runCoroutineSync } from \"../Misc/coroutine\";\r\nimport type { ICreateCapsuleOptions } from \"./Builders/capsuleBuilder\";\r\nimport { RuntimeError, ErrorCodes } from \"../Misc/error\";\r\n\r\nimport type { Geometry } from \"../Meshes/geometry\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { SubMesh } from \"./subMesh\";\r\n\r\n/**\r\n * Define an interface for all classes that will get and set the data on vertices\r\n */\r\nexport interface IGetSetVerticesData {\r\n    /**\r\n     * Gets a boolean indicating if specific vertex data is present\r\n     * @param kind defines the vertex data kind to use\r\n     * @returns true is data kind is present\r\n     */\r\n    isVerticesDataPresent(kind: string): boolean;\r\n    /**\r\n     * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns a float array containing vertex data\r\n     */\r\n    getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray>;\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns the indices array or an empty array if the mesh has no geometry\r\n     */\r\n    getIndices(copyWhenShared?: boolean, forceCopy?: boolean): Nullable<IndicesArray>;\r\n    /**\r\n     * Set specific vertex data\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the vertex data to use\r\n     * @param updatable defines if the vertex must be flagged as updatable (false as default)\r\n     * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified\r\n     */\r\n    setVerticesData(kind: string, data: FloatArray, updatable: boolean): void;\r\n    /**\r\n     * Update a specific associated vertex buffer\r\n     * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @param data defines the data source\r\n     * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for \"position\" kind\r\n     * @param makeItUnique defines if the geometry associated with the mesh must be cloned to make the change only for this mesh (and not all meshes associated with the same geometry)\r\n     */\r\n    updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): void;\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the indices to store in the index buffer\r\n     * @param totalVertices defines the total number of vertices (could be null)\r\n     * @param updatable defines if the index buffer must be flagged as updatable (false by default)\r\n     */\r\n    setIndices(indices: IndicesArray, totalVertices: Nullable<number>, updatable?: boolean): void;\r\n}\r\n\r\n/** Class used to attach material info to sub section of a vertex data class */\r\nexport class VertexDataMaterialInfo {\r\n    /** Defines the material index to use */\r\n    public materialIndex: number;\r\n    /** Defines vertex index start*/\r\n    public verticesStart: number;\r\n    /** Defines vertices count */\r\n    public verticesCount: number;\r\n    /** Defines index start */\r\n    public indexStart: number;\r\n    /** Defines indices count */\r\n    public indexCount: number;\r\n}\r\n\r\n/**\r\n * This class contains the various kinds of data on every vertex of a mesh used in determining its shape and appearance\r\n */\r\nexport class VertexData {\r\n    /**\r\n     * Mesh side orientation : usually the external or front surface\r\n     */\r\n    public static readonly FRONTSIDE = 0;\r\n    /**\r\n     * Mesh side orientation : usually the internal or back surface\r\n     */\r\n    public static readonly BACKSIDE = 1;\r\n    /**\r\n     * Mesh side orientation : both internal and external or front and back surfaces\r\n     */\r\n    public static readonly DOUBLESIDE = 2;\r\n    /**\r\n     * Mesh side orientation : by default, `FRONTSIDE`\r\n     */\r\n    public static readonly DEFAULTSIDE = 0;\r\n\r\n    private static _UniqueIDGenerator = 0;\r\n\r\n    /**\r\n     * An array of the x, y, z position of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public positions: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the x, y, z normal vector of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public normals: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the x, y, z tangent vector of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public tangents: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A second array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs2: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A third array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs3: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A fourth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs4: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A fifth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs5: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A sixth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs6: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the r, g, b, a, color of each vertex  [...., r, g, b, a, .....]\r\n     */\r\n    public colors: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array containing the list of indices to the array of matrices produced by bones, each vertex have up to 4 indices (8 if the matricesIndicesExtra is set).\r\n     */\r\n    public matricesIndices: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array containing the list of weights defining the weight of each indexed matrix in the final computation\r\n     */\r\n    public matricesWeights: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array extending the number of possible indices\r\n     */\r\n    public matricesIndicesExtra: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array extending the number of possible weights when the number of indices is extended\r\n     */\r\n    public matricesWeightsExtra: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of i, j, k the three vertex indices required for each triangular facet  [...., i, j, k .....]\r\n     */\r\n    public indices: Nullable<IndicesArray>;\r\n\r\n    /**\r\n     * An array defining material association for sub sections of the vertex data\r\n     */\r\n    public materialInfos: Nullable<Array<VertexDataMaterialInfo>>;\r\n\r\n    /**\r\n     * Gets the unique ID of this vertex Data\r\n     */\r\n    public uniqueId = 0;\r\n\r\n    /**\r\n     * Metadata used to store contextual values\r\n     */\r\n    public metadata: any = {};\r\n\r\n    /**\r\n     * Creates a new VertexData\r\n     */\r\n    public constructor() {\r\n        this.uniqueId = VertexData._UniqueIDGenerator;\r\n        VertexData._UniqueIDGenerator++;\r\n    }\r\n\r\n    /**\r\n     * Uses the passed data array to set the set the values for the specified kind of data\r\n     * @param data a linear array of floating numbers\r\n     * @param kind the type of data that is being set, eg positions, colors etc\r\n     */\r\n    public set(data: FloatArray, kind: string) {\r\n        if (!data.length) {\r\n            Logger.Warn(`Setting vertex data kind '${kind}' with an empty array`);\r\n        }\r\n\r\n        switch (kind) {\r\n            case VertexBuffer.PositionKind:\r\n                this.positions = data;\r\n                break;\r\n            case VertexBuffer.NormalKind:\r\n                this.normals = data;\r\n                break;\r\n            case VertexBuffer.TangentKind:\r\n                this.tangents = data;\r\n                break;\r\n            case VertexBuffer.UVKind:\r\n                this.uvs = data;\r\n                break;\r\n            case VertexBuffer.UV2Kind:\r\n                this.uvs2 = data;\r\n                break;\r\n            case VertexBuffer.UV3Kind:\r\n                this.uvs3 = data;\r\n                break;\r\n            case VertexBuffer.UV4Kind:\r\n                this.uvs4 = data;\r\n                break;\r\n            case VertexBuffer.UV5Kind:\r\n                this.uvs5 = data;\r\n                break;\r\n            case VertexBuffer.UV6Kind:\r\n                this.uvs6 = data;\r\n                break;\r\n            case VertexBuffer.ColorKind:\r\n                this.colors = data;\r\n                break;\r\n            case VertexBuffer.MatricesIndicesKind:\r\n                this.matricesIndices = data;\r\n                break;\r\n            case VertexBuffer.MatricesWeightsKind:\r\n                this.matricesWeights = data;\r\n                break;\r\n            case VertexBuffer.MatricesIndicesExtraKind:\r\n                this.matricesIndicesExtra = data;\r\n                break;\r\n            case VertexBuffer.MatricesWeightsExtraKind:\r\n                this.matricesWeightsExtra = data;\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Associates the vertexData to the passed Mesh.\r\n     * Sets it as updatable or not (default `false`)\r\n     * @param mesh the mesh the vertexData is applied to\r\n     * @param updatable when used and having the value true allows new data to update the vertexData\r\n     * @returns the VertexData\r\n     */\r\n    public applyToMesh(mesh: Mesh, updatable?: boolean): VertexData {\r\n        this._applyTo(mesh, updatable, false);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Associates the vertexData to the passed Geometry.\r\n     * Sets it as updatable or not (default `false`)\r\n     * @param geometry the geometry the vertexData is applied to\r\n     * @param updatable when used and having the value true allows new data to update the vertexData\r\n     * @returns VertexData\r\n     */\r\n    public applyToGeometry(geometry: Geometry, updatable?: boolean): VertexData {\r\n        this._applyTo(geometry, updatable, false);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the associated mesh\r\n     * @param mesh the mesh to be updated\r\n     * @returns VertexData\r\n     */\r\n    public updateMesh(mesh: Mesh): VertexData {\r\n        this._update(mesh);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the associated geometry\r\n     * @param geometry the geometry to be updated\r\n     * @returns VertexData.\r\n     */\r\n    public updateGeometry(geometry: Geometry): VertexData {\r\n        this._update(geometry);\r\n        return this;\r\n    }\r\n\r\n    private readonly _applyTo = makeSyncFunction(this._applyToCoroutine.bind(this));\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public *_applyToCoroutine(meshOrGeometry: IGetSetVerticesData, updatable: boolean = false, isAsync: boolean): Coroutine<VertexData> {\r\n        if (this.positions) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.PositionKind, this.positions, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.normals) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.NormalKind, this.normals, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.tangents) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.TangentKind, this.tangents, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UVKind, this.uvs, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV2Kind, this.uvs2, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV3Kind, this.uvs3, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV4Kind, this.uvs4, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV5Kind, this.uvs5, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV6Kind, this.uvs6, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.colors) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.ColorKind, this.colors, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.indices) {\r\n            meshOrGeometry.setIndices(this.indices, null, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        } else {\r\n            meshOrGeometry.setIndices([], null);\r\n        }\r\n\r\n        if ((meshOrGeometry as Mesh).subMeshes && this.materialInfos && this.materialInfos.length > 1) {\r\n            const mesh = meshOrGeometry as Mesh;\r\n            mesh.subMeshes = [];\r\n            for (const matInfo of this.materialInfos) {\r\n                new SubMesh(matInfo.materialIndex, matInfo.verticesStart, matInfo.verticesCount, matInfo.indexStart, matInfo.indexCount, mesh);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private _update(meshOrGeometry: IGetSetVerticesData, updateExtends?: boolean, makeItUnique?: boolean): VertexData {\r\n        if (this.positions) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.PositionKind, this.positions, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.normals) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.NormalKind, this.normals, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.tangents) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.TangentKind, this.tangents, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UVKind, this.uvs, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV2Kind, this.uvs2, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV3Kind, this.uvs3, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV4Kind, this.uvs4, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV5Kind, this.uvs5, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV6Kind, this.uvs6, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.colors) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.ColorKind, this.colors, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.indices) {\r\n            meshOrGeometry.setIndices(this.indices, null);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    @nativeOverride.filter((...[coordinates]: Parameters<typeof VertexData._TransformVector3Coordinates>) => !Array.isArray(coordinates))\r\n    private static _TransformVector3Coordinates(coordinates: FloatArray, transformation: DeepImmutable<Matrix>, offset = 0, length = coordinates.length) {\r\n        const coordinate = TmpVectors.Vector3[0];\r\n        const transformedCoordinate = TmpVectors.Vector3[1];\r\n        for (let index = offset; index < offset + length; index += 3) {\r\n            Vector3.FromArrayToRef(coordinates, index, coordinate);\r\n            Vector3.TransformCoordinatesToRef(coordinate, transformation, transformedCoordinate);\r\n            coordinates[index] = transformedCoordinate.x;\r\n            coordinates[index + 1] = transformedCoordinate.y;\r\n            coordinates[index + 2] = transformedCoordinate.z;\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[normals]: Parameters<typeof VertexData._TransformVector3Normals>) => !Array.isArray(normals))\r\n    private static _TransformVector3Normals(normals: FloatArray, transformation: DeepImmutable<Matrix>, offset = 0, length = normals.length) {\r\n        const normal = TmpVectors.Vector3[0];\r\n        const transformedNormal = TmpVectors.Vector3[1];\r\n        for (let index = offset; index < offset + length; index += 3) {\r\n            Vector3.FromArrayToRef(normals, index, normal);\r\n            Vector3.TransformNormalToRef(normal, transformation, transformedNormal);\r\n            normals[index] = transformedNormal.x;\r\n            normals[index + 1] = transformedNormal.y;\r\n            normals[index + 2] = transformedNormal.z;\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[normals]: Parameters<typeof VertexData._TransformVector4Normals>) => !Array.isArray(normals))\r\n    private static _TransformVector4Normals(normals: FloatArray, transformation: DeepImmutable<Matrix>, offset = 0, length = normals.length) {\r\n        const normal = TmpVectors.Vector4[0];\r\n        const transformedNormal = TmpVectors.Vector4[1];\r\n        for (let index = offset; index < offset + length; index += 4) {\r\n            Vector4.FromArrayToRef(normals, index, normal);\r\n            Vector4.TransformNormalToRef(normal, transformation, transformedNormal);\r\n            normals[index] = transformedNormal.x;\r\n            normals[index + 1] = transformedNormal.y;\r\n            normals[index + 2] = transformedNormal.z;\r\n            normals[index + 3] = transformedNormal.w;\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[indices]: Parameters<typeof VertexData._FlipFaces>) => !Array.isArray(indices))\r\n    private static _FlipFaces(indices: IndicesArray, offset = 0, length = indices.length) {\r\n        for (let index = offset; index < offset + length; index += 3) {\r\n            const tmp = indices[index + 1];\r\n            indices[index + 1] = indices[index + 2];\r\n            indices[index + 2] = tmp;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transforms each position and each normal of the vertexData according to the passed Matrix\r\n     * @param matrix the transforming matrix\r\n     * @returns the VertexData\r\n     */\r\n    public transform(matrix: Matrix): VertexData {\r\n        const flip = matrix.determinant() < 0;\r\n        if (this.positions) {\r\n            VertexData._TransformVector3Coordinates(this.positions, matrix);\r\n        }\r\n\r\n        if (this.normals) {\r\n            VertexData._TransformVector3Normals(this.normals, matrix);\r\n        }\r\n\r\n        if (this.tangents) {\r\n            VertexData._TransformVector4Normals(this.tangents, matrix);\r\n        }\r\n\r\n        if (flip && this.indices) {\r\n            VertexData._FlipFaces(this.indices);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Generates an array of vertex data where each vertex data only has one material info\r\n     * @returns An array of VertexData\r\n     */\r\n    public splitBasedOnMaterialID() {\r\n        if (!this.materialInfos || this.materialInfos.length < 2) {\r\n            return [this];\r\n        }\r\n\r\n        const result = new Array<VertexData>();\r\n        for (const materialInfo of this.materialInfos) {\r\n            const vertexData = new VertexData();\r\n\r\n            if (this.positions) {\r\n                vertexData.positions = this.positions.slice(materialInfo.verticesStart * 3, (materialInfo.verticesCount + materialInfo.verticesStart) * 3);\r\n            }\r\n\r\n            if (this.normals) {\r\n                vertexData.normals = this.normals.slice(materialInfo.verticesStart * 3, (materialInfo.verticesCount + materialInfo.verticesStart) * 3);\r\n            }\r\n\r\n            if (this.tangents) {\r\n                vertexData.tangents = this.tangents.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\r\n            }\r\n\r\n            if (this.colors) {\r\n                vertexData.colors = this.colors.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\r\n            }\r\n\r\n            if (this.uvs) {\r\n                vertexData.uvs = this.uvs.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\r\n            }\r\n\r\n            if (this.uvs2) {\r\n                vertexData.uvs2 = this.uvs2.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\r\n            }\r\n\r\n            if (this.uvs3) {\r\n                vertexData.uvs3 = this.uvs3.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\r\n            }\r\n\r\n            if (this.uvs4) {\r\n                vertexData.uvs4 = this.uvs4.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\r\n            }\r\n\r\n            if (this.uvs5) {\r\n                vertexData.uvs5 = this.uvs5.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\r\n            }\r\n\r\n            if (this.uvs6) {\r\n                vertexData.uvs6 = this.uvs6.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\r\n            }\r\n\r\n            if (this.matricesIndices) {\r\n                vertexData.matricesIndices = this.matricesIndices.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\r\n            }\r\n\r\n            if (this.matricesIndicesExtra) {\r\n                vertexData.matricesIndicesExtra = this.matricesIndicesExtra.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\r\n            }\r\n\r\n            if (this.matricesWeights) {\r\n                vertexData.matricesWeights = this.matricesWeights.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\r\n            }\r\n\r\n            if (this.matricesWeightsExtra) {\r\n                vertexData.matricesWeightsExtra = this.matricesWeightsExtra.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\r\n            }\r\n\r\n            if (this.indices) {\r\n                vertexData.indices = [];\r\n                for (let index = materialInfo.indexStart; index < materialInfo.indexStart + materialInfo.indexCount; index++) {\r\n                    vertexData.indices.push(this.indices[index] - materialInfo.verticesStart);\r\n                }\r\n            }\r\n\r\n            const newMaterialInfo = new VertexDataMaterialInfo();\r\n            newMaterialInfo.indexStart = 0;\r\n            newMaterialInfo.indexCount = vertexData.indices ? vertexData.indices.length : 0;\r\n            newMaterialInfo.materialIndex = materialInfo.materialIndex;\r\n            newMaterialInfo.verticesStart = 0;\r\n            newMaterialInfo.verticesCount = (vertexData.positions ? vertexData.positions.length : 0) / 3;\r\n            vertexData.materialInfos = [newMaterialInfo];\r\n\r\n            result.push(vertexData);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Merges the passed VertexData into the current one\r\n     * @param others the VertexData to be merged into the current one\r\n     * @param use32BitsIndices defines a boolean indicating if indices must be store in a 32 bits array\r\n     * @param forceCloneIndices defines a boolean indicating if indices are forced to be cloned\r\n     * @param mergeMaterialIds defines a boolean indicating if we need to merge the material infos\r\n     * @param enableCompletion defines a boolean indicating if the vertex data should be completed to be compatible\r\n     * @returns the modified VertexData\r\n     */\r\n    public merge(others: VertexData | VertexData[], use32BitsIndices = false, forceCloneIndices = false, mergeMaterialIds = false, enableCompletion = false) {\r\n        const vertexDatas: { vertexData: VertexData; transform?: Matrix }[] = Array.isArray(others)\r\n            ? others.map((other) => {\r\n                  return { vertexData: other };\r\n              })\r\n            : [{ vertexData: others }];\r\n        return runCoroutineSync(this._mergeCoroutine(undefined, vertexDatas, use32BitsIndices, false, forceCloneIndices, mergeMaterialIds, enableCompletion));\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public *_mergeCoroutine(\r\n        transform: Matrix | undefined,\r\n        vertexDatas: { vertexData: VertexData; transform?: Matrix }[],\r\n        use32BitsIndices = false,\r\n        isAsync: boolean,\r\n        forceCloneIndices: boolean,\r\n        mergeMaterialIds = false,\r\n        enableCompletion = false\r\n    ): Coroutine<VertexData> {\r\n        this._validate();\r\n\r\n        let others = vertexDatas.map((vertexData) => vertexData.vertexData);\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        let root: VertexData = this;\r\n\r\n        for (const other of others) {\r\n            if (!other) {\r\n                continue;\r\n            }\r\n\r\n            other._validate();\r\n\r\n            if (!enableCompletion) {\r\n                if (\r\n                    !this.normals !== !other.normals ||\r\n                    !this.tangents !== !other.tangents ||\r\n                    !this.uvs !== !other.uvs ||\r\n                    !this.uvs2 !== !other.uvs2 ||\r\n                    !this.uvs3 !== !other.uvs3 ||\r\n                    !this.uvs4 !== !other.uvs4 ||\r\n                    !this.uvs5 !== !other.uvs5 ||\r\n                    !this.uvs6 !== !other.uvs6 ||\r\n                    !this.colors !== !other.colors ||\r\n                    !this.matricesIndices !== !other.matricesIndices ||\r\n                    !this.matricesWeights !== !other.matricesWeights ||\r\n                    !this.matricesIndicesExtra !== !other.matricesIndicesExtra ||\r\n                    !this.matricesWeightsExtra !== !other.matricesWeightsExtra\r\n                ) {\r\n                    throw new Error(\"Cannot merge vertex data that do not have the same set of attributes\");\r\n                }\r\n            } else {\r\n                if (!this.normals !== !other.normals) {\r\n                    if (!this.normals) {\r\n                        this.normals = new Float32Array(this.positions!.length);\r\n                    } else {\r\n                        other.normals = new Float32Array(other.positions!.length);\r\n                    }\r\n                }\r\n\r\n                if (!this.tangents !== !other.tangents) {\r\n                    if (!this.tangents) {\r\n                        this.tangents = new Float32Array((this.positions!.length / 3) * 4);\r\n                    } else {\r\n                        other.tangents = new Float32Array((other.positions!.length / 3) * 4);\r\n                    }\r\n                }\r\n                if (!this.uvs !== !other.uvs) {\r\n                    if (!this.uvs) {\r\n                        this.uvs = new Float32Array((this.positions!.length / 3) * 2);\r\n                    } else {\r\n                        other.uvs = new Float32Array((other.positions!.length / 3) * 2);\r\n                    }\r\n                }\r\n\r\n                if (!this.uvs2 !== !other.uvs2) {\r\n                    if (!this.uvs2) {\r\n                        this.uvs2 = new Float32Array((this.positions!.length / 3) * 2);\r\n                    } else {\r\n                        other.uvs2 = new Float32Array((other.positions!.length / 3) * 2);\r\n                    }\r\n                }\r\n\r\n                if (!this.uvs3 !== !other.uvs3) {\r\n                    if (!this.uvs3) {\r\n                        this.uvs3 = new Float32Array((this.positions!.length / 3) * 2);\r\n                    } else {\r\n                        other.uvs3 = new Float32Array((other.positions!.length / 3) * 2);\r\n                    }\r\n                }\r\n\r\n                if (!this.uvs4 !== !other.uvs4) {\r\n                    if (!this.uvs4) {\r\n                        this.uvs4 = new Float32Array((this.positions!.length / 3) * 2);\r\n                    } else {\r\n                        other.uvs4 = new Float32Array((other.positions!.length / 3) * 2);\r\n                    }\r\n                }\r\n                if (!this.uvs5 !== !other.uvs5) {\r\n                    if (!this.uvs5) {\r\n                        this.uvs5 = new Float32Array((this.positions!.length / 3) * 2);\r\n                    } else {\r\n                        other.uvs5 = new Float32Array((other.positions!.length / 3) * 2);\r\n                    }\r\n                }\r\n\r\n                if (!this.uvs6 !== !other.uvs6) {\r\n                    if (!this.uvs6) {\r\n                        this.uvs6 = new Float32Array((this.positions!.length / 3) * 2);\r\n                    } else {\r\n                        other.uvs6 = new Float32Array((other.positions!.length / 3) * 2);\r\n                    }\r\n                }\r\n\r\n                if (!this.colors !== !other.colors) {\r\n                    if (!this.colors) {\r\n                        this.colors = new Float32Array((this.positions!.length / 3) * 4);\r\n                        this.colors.fill(1); // Set to white by default\r\n                    } else {\r\n                        other.colors = new Float32Array((other.positions!.length / 3) * 4);\r\n                        other.colors.fill(1); // Set to white by default\r\n                    }\r\n                }\r\n\r\n                if (!this.matricesIndices !== !other.matricesIndices) {\r\n                    if (!this.matricesIndices) {\r\n                        this.matricesIndices = new Float32Array((this.positions!.length / 3) * 4);\r\n                    } else {\r\n                        other.matricesIndices = new Float32Array((other.positions!.length / 3) * 4);\r\n                    }\r\n                }\r\n                if (!this.matricesWeights !== !other.matricesWeights) {\r\n                    if (!this.matricesWeights) {\r\n                        this.matricesWeights = new Float32Array((this.positions!.length / 3) * 4);\r\n                    } else {\r\n                        other.matricesWeights = new Float32Array((other.positions!.length / 3) * 4);\r\n                    }\r\n                }\r\n\r\n                if (!this.matricesIndicesExtra !== !other.matricesIndicesExtra) {\r\n                    if (!this.matricesIndicesExtra) {\r\n                        this.matricesIndicesExtra = new Float32Array((this.positions!.length / 3) * 4);\r\n                    } else {\r\n                        other.matricesIndicesExtra = new Float32Array((other.positions!.length / 3) * 4);\r\n                    }\r\n                }\r\n\r\n                if (!this.matricesWeightsExtra !== !other.matricesWeightsExtra) {\r\n                    if (!this.matricesWeightsExtra) {\r\n                        this.matricesWeightsExtra = new Float32Array((this.positions!.length / 3) * 4);\r\n                    } else {\r\n                        other.matricesWeightsExtra = new Float32Array((other.positions!.length / 3) * 4);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (mergeMaterialIds) {\r\n            // Merge material infos\r\n            let materialIndex = 0;\r\n            let indexOffset = 0;\r\n            let vertexOffset = 0;\r\n            const materialInfos: VertexDataMaterialInfo[] = [];\r\n            let currentMaterialInfo: Nullable<VertexDataMaterialInfo> = null;\r\n            const vertexDataList: { vertexData: VertexData; transform?: Matrix }[] = [];\r\n\r\n            // We need to split vertexData with more than one materialInfo\r\n            for (const split of this.splitBasedOnMaterialID()) {\r\n                vertexDataList.push({ vertexData: split, transform: transform });\r\n            }\r\n\r\n            for (const data of vertexDatas) {\r\n                if (!data.vertexData) {\r\n                    continue;\r\n                }\r\n                for (const split of data.vertexData.splitBasedOnMaterialID()) {\r\n                    vertexDataList.push({ vertexData: split, transform: data.transform });\r\n                }\r\n            }\r\n\r\n            // Sort by material IDs\r\n            vertexDataList.sort((a, b) => {\r\n                const matInfoA = a.vertexData.materialInfos ? a.vertexData.materialInfos[0].materialIndex : 0;\r\n                const matInfoB = b.vertexData.materialInfos ? b.vertexData.materialInfos[0].materialIndex : 0;\r\n\r\n                if (matInfoA > matInfoB) {\r\n                    return 1;\r\n                }\r\n\r\n                if (matInfoA === matInfoB) {\r\n                    return 0;\r\n                }\r\n\r\n                return -1;\r\n            });\r\n\r\n            // Build the new material info\r\n            for (const vertexDataSource of vertexDataList) {\r\n                const vertexData = vertexDataSource.vertexData;\r\n                if (vertexData.materialInfos) {\r\n                    materialIndex = vertexData.materialInfos[0].materialIndex;\r\n                } else {\r\n                    materialIndex = 0;\r\n                }\r\n                if (currentMaterialInfo && currentMaterialInfo.materialIndex === materialIndex) {\r\n                    currentMaterialInfo.indexCount += vertexData.indices!.length;\r\n                    currentMaterialInfo.verticesCount += vertexData.positions!.length / 3;\r\n                } else {\r\n                    const materialInfo = new VertexDataMaterialInfo();\r\n                    materialInfo.materialIndex = materialIndex;\r\n                    materialInfo.indexStart = indexOffset;\r\n                    materialInfo.indexCount = vertexData.indices!.length;\r\n                    materialInfo.verticesStart = vertexOffset;\r\n                    materialInfo.verticesCount = vertexData.positions!.length / 3;\r\n\r\n                    materialInfos.push(materialInfo);\r\n                    currentMaterialInfo = materialInfo;\r\n                }\r\n                indexOffset += vertexData.indices!.length;\r\n                vertexOffset += vertexData.positions!.length / 3;\r\n            }\r\n            // Extract sorted values\r\n            const first = vertexDataList.splice(0, 1)[0];\r\n            root = first.vertexData;\r\n            transform = first.transform;\r\n            others = vertexDataList.map((v) => v.vertexData);\r\n            vertexDatas = vertexDataList;\r\n\r\n            this.materialInfos = materialInfos;\r\n        }\r\n\r\n        // Merge geometries\r\n        const totalIndices = others.reduce((indexSum, vertexData) => indexSum + (vertexData.indices?.length ?? 0), root.indices?.length ?? 0);\r\n        const sliceIndices = forceCloneIndices || others.some((vertexData) => vertexData.indices === root.indices);\r\n        let indices = sliceIndices ? root.indices?.slice() : root.indices;\r\n        if (totalIndices > 0) {\r\n            let indicesOffset = indices?.length ?? 0;\r\n\r\n            if (!indices) {\r\n                indices = new Array<number>(totalIndices);\r\n            }\r\n\r\n            if (indices.length !== totalIndices) {\r\n                if (Array.isArray(indices)) {\r\n                    indices.length = totalIndices;\r\n                } else {\r\n                    const temp = use32BitsIndices || indices instanceof Uint32Array ? new Uint32Array(totalIndices) : new Uint16Array(totalIndices);\r\n                    temp.set(indices);\r\n                    indices = temp;\r\n                }\r\n\r\n                if (transform && transform.determinant() < 0) {\r\n                    VertexData._FlipFaces(indices, 0, indicesOffset);\r\n                }\r\n            }\r\n\r\n            let positionsOffset = root.positions ? root.positions.length / 3 : 0;\r\n            for (const { vertexData: other, transform } of vertexDatas) {\r\n                if (other.indices) {\r\n                    for (let index = 0; index < other.indices.length; index++) {\r\n                        indices[indicesOffset + index] = other.indices[index] + positionsOffset;\r\n                    }\r\n\r\n                    if (transform && transform.determinant() < 0) {\r\n                        VertexData._FlipFaces(indices, indicesOffset, other.indices.length);\r\n                    }\r\n\r\n                    // The call to _validate already checked for positions\r\n                    positionsOffset += other.positions!.length / 3;\r\n                    indicesOffset += other.indices.length;\r\n\r\n                    if (isAsync) {\r\n                        yield;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.indices = indices!;\r\n\r\n        this.positions = VertexData._MergeElement(\r\n            VertexBuffer.PositionKind,\r\n            root.positions,\r\n            transform,\r\n            vertexDatas.map((other) => [other.vertexData.positions, other.transform])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        if (root.normals) {\r\n            this.normals = VertexData._MergeElement(\r\n                VertexBuffer.NormalKind,\r\n                root.normals,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.normals, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.tangents) {\r\n            this.tangents = VertexData._MergeElement(\r\n                VertexBuffer.TangentKind,\r\n                root.tangents,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.tangents, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.uvs) {\r\n            this.uvs = VertexData._MergeElement(\r\n                VertexBuffer.UVKind,\r\n                root.uvs,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.uvs, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.uvs2) {\r\n            this.uvs2 = VertexData._MergeElement(\r\n                VertexBuffer.UV2Kind,\r\n                root.uvs2,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.uvs2, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.uvs3) {\r\n            this.uvs3 = VertexData._MergeElement(\r\n                VertexBuffer.UV3Kind,\r\n                root.uvs3,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.uvs3, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.uvs4) {\r\n            this.uvs4 = VertexData._MergeElement(\r\n                VertexBuffer.UV4Kind,\r\n                root.uvs4,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.uvs4, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.uvs5) {\r\n            this.uvs5 = VertexData._MergeElement(\r\n                VertexBuffer.UV5Kind,\r\n                root.uvs5,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.uvs5, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.uvs6) {\r\n            this.uvs6 = VertexData._MergeElement(\r\n                VertexBuffer.UV6Kind,\r\n                root.uvs6,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.uvs6, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.colors) {\r\n            this.colors = VertexData._MergeElement(\r\n                VertexBuffer.ColorKind,\r\n                root.colors,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.colors, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.matricesIndices) {\r\n            this.matricesIndices = VertexData._MergeElement(\r\n                VertexBuffer.MatricesIndicesKind,\r\n                root.matricesIndices,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.matricesIndices, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.matricesWeights) {\r\n            this.matricesWeights = VertexData._MergeElement(\r\n                VertexBuffer.MatricesWeightsKind,\r\n                root.matricesWeights,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.matricesWeights, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.matricesIndicesExtra) {\r\n            this.matricesIndicesExtra = VertexData._MergeElement(\r\n                VertexBuffer.MatricesIndicesExtraKind,\r\n                root.matricesIndicesExtra,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.matricesIndicesExtra, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.matricesWeightsExtra) {\r\n            this.matricesWeightsExtra = VertexData._MergeElement(\r\n                VertexBuffer.MatricesWeightsExtraKind,\r\n                root.matricesWeightsExtra,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.matricesWeightsExtra, other.transform])\r\n            );\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private static _MergeElement(\r\n        kind: string,\r\n        source: Nullable<FloatArray>,\r\n        transform: Matrix | undefined,\r\n        others: readonly (readonly [element: Nullable<FloatArray>, transform?: Matrix])[]\r\n    ): Nullable<FloatArray> {\r\n        const nonNullOthers = others.filter((other): other is [element: FloatArray, transform?: Matrix] => other[0] !== null && other[0] !== undefined);\r\n\r\n        // If there is no source to copy and no other non-null sources then skip this element.\r\n        if (!source && nonNullOthers.length == 0) {\r\n            return source;\r\n        }\r\n\r\n        if (!source) {\r\n            return this._MergeElement(kind, nonNullOthers[0][0], nonNullOthers[0][1], nonNullOthers.slice(1));\r\n        }\r\n\r\n        const len = nonNullOthers.reduce((sumLen, elements) => sumLen + elements[0].length, source.length);\r\n\r\n        const transformRange =\r\n            kind === VertexBuffer.PositionKind\r\n                ? VertexData._TransformVector3Coordinates\r\n                : kind === VertexBuffer.NormalKind\r\n                ? VertexData._TransformVector3Normals\r\n                : kind === VertexBuffer.TangentKind\r\n                ? VertexData._TransformVector4Normals\r\n                : () => {};\r\n\r\n        if (source instanceof Float32Array) {\r\n            // use non-loop method when the source is Float32Array\r\n            const ret32 = new Float32Array(len);\r\n            ret32.set(source);\r\n            transform && transformRange(ret32, transform, 0, source.length);\r\n\r\n            let offset = source.length;\r\n            for (const [vertexData, transform] of nonNullOthers) {\r\n                ret32.set(vertexData, offset);\r\n                transform && transformRange(ret32, transform, offset, vertexData.length);\r\n                offset += vertexData.length;\r\n            }\r\n            return ret32;\r\n        } else {\r\n            // don't use concat as it is super slow, just loop for other cases\r\n            const ret = new Array<number>(len);\r\n            for (let i = 0; i < source.length; i++) {\r\n                ret[i] = source[i];\r\n            }\r\n            transform && transformRange(ret, transform, 0, source.length);\r\n\r\n            let offset = source.length;\r\n            for (const [vertexData, transform] of nonNullOthers) {\r\n                for (let i = 0; i < vertexData.length; i++) {\r\n                    ret[offset + i] = vertexData[i];\r\n                }\r\n                transform && transformRange(ret, transform, offset, vertexData.length);\r\n                offset += vertexData.length;\r\n            }\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    private _validate(): void {\r\n        if (!this.positions) {\r\n            throw new RuntimeError(\"Positions are required\", ErrorCodes.MeshInvalidPositionsError);\r\n        }\r\n\r\n        const getElementCount = (kind: string, values: FloatArray) => {\r\n            const stride = VertexBuffer.DeduceStride(kind);\r\n            if (values.length % stride !== 0) {\r\n                throw new Error(\"The \" + kind + \"s array count must be a multiple of \" + stride);\r\n            }\r\n\r\n            return values.length / stride;\r\n        };\r\n\r\n        const positionsElementCount = getElementCount(VertexBuffer.PositionKind, this.positions);\r\n\r\n        const validateElementCount = (kind: string, values: FloatArray) => {\r\n            const elementCount = getElementCount(kind, values);\r\n            if (elementCount !== positionsElementCount) {\r\n                throw new Error(\"The \" + kind + \"s element count (\" + elementCount + \") does not match the positions count (\" + positionsElementCount + \")\");\r\n            }\r\n        };\r\n\r\n        if (this.normals) {\r\n            validateElementCount(VertexBuffer.NormalKind, this.normals);\r\n        }\r\n        if (this.tangents) {\r\n            validateElementCount(VertexBuffer.TangentKind, this.tangents);\r\n        }\r\n        if (this.uvs) {\r\n            validateElementCount(VertexBuffer.UVKind, this.uvs);\r\n        }\r\n        if (this.uvs2) {\r\n            validateElementCount(VertexBuffer.UV2Kind, this.uvs2);\r\n        }\r\n        if (this.uvs3) {\r\n            validateElementCount(VertexBuffer.UV3Kind, this.uvs3);\r\n        }\r\n        if (this.uvs4) {\r\n            validateElementCount(VertexBuffer.UV4Kind, this.uvs4);\r\n        }\r\n        if (this.uvs5) {\r\n            validateElementCount(VertexBuffer.UV5Kind, this.uvs5);\r\n        }\r\n        if (this.uvs6) {\r\n            validateElementCount(VertexBuffer.UV6Kind, this.uvs6);\r\n        }\r\n        if (this.colors) {\r\n            validateElementCount(VertexBuffer.ColorKind, this.colors);\r\n        }\r\n        if (this.matricesIndices) {\r\n            validateElementCount(VertexBuffer.MatricesIndicesKind, this.matricesIndices);\r\n        }\r\n        if (this.matricesWeights) {\r\n            validateElementCount(VertexBuffer.MatricesWeightsKind, this.matricesWeights);\r\n        }\r\n        if (this.matricesIndicesExtra) {\r\n            validateElementCount(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra);\r\n        }\r\n        if (this.matricesWeightsExtra) {\r\n            validateElementCount(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the current vertex data\r\n     * @returns a copy of the current data\r\n     */\r\n    public clone() {\r\n        const serializationObject = this.serialize();\r\n        return VertexData.Parse(serializationObject);\r\n    }\r\n\r\n    /**\r\n     * Serializes the VertexData\r\n     * @returns a serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        if (this.positions) {\r\n            serializationObject.positions = Array.from(this.positions);\r\n        }\r\n\r\n        if (this.normals) {\r\n            serializationObject.normals = Array.from(this.normals);\r\n        }\r\n\r\n        if (this.tangents) {\r\n            serializationObject.tangents = Array.from(this.tangents);\r\n        }\r\n\r\n        if (this.uvs) {\r\n            serializationObject.uvs = Array.from(this.uvs);\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            serializationObject.uvs2 = Array.from(this.uvs2);\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            serializationObject.uvs3 = Array.from(this.uvs3);\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            serializationObject.uvs4 = Array.from(this.uvs4);\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            serializationObject.uvs5 = Array.from(this.uvs5);\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            serializationObject.uvs6 = Array.from(this.uvs6);\r\n        }\r\n\r\n        if (this.colors) {\r\n            serializationObject.colors = Array.from(this.colors);\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            serializationObject.matricesIndices = Array.from(this.matricesIndices);\r\n            serializationObject.matricesIndices._isExpanded = true;\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            serializationObject.matricesWeights = Array.from(this.matricesWeights);\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            serializationObject.matricesIndicesExtra = Array.from(this.matricesIndicesExtra);\r\n            serializationObject.matricesIndicesExtra._isExpanded = true;\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            serializationObject.matricesWeightsExtra = Array.from(this.matricesWeightsExtra);\r\n        }\r\n\r\n        serializationObject.indices = Array.from(this.indices as number[]);\r\n\r\n        if (this.materialInfos) {\r\n            serializationObject.materialInfos = [];\r\n            for (const materialInfo of this.materialInfos) {\r\n                const materialInfoSerializationObject = {\r\n                    indexStart: materialInfo.indexStart,\r\n                    indexCount: materialInfo.indexCount,\r\n                    materialIndex: materialInfo.materialIndex,\r\n                    verticesStart: materialInfo.verticesStart,\r\n                    verticesCount: materialInfo.verticesCount,\r\n                };\r\n                serializationObject.materialInfos.push(materialInfoSerializationObject);\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Extracts the vertexData from a mesh\r\n     * @param mesh the mesh from which to extract the VertexData\r\n     * @param copyWhenShared defines if the VertexData must be cloned when shared between multiple meshes, optional, default false\r\n     * @param forceCopy indicating that the VertexData must be cloned, optional, default false\r\n     * @returns the object VertexData associated to the passed mesh\r\n     */\r\n    public static ExtractFromMesh(mesh: Mesh, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        return VertexData._ExtractFrom(mesh, copyWhenShared, forceCopy);\r\n    }\r\n\r\n    /**\r\n     * Extracts the vertexData from the geometry\r\n     * @param geometry the geometry from which to extract the VertexData\r\n     * @param copyWhenShared defines if the VertexData must be cloned when the geometry is shared between multiple meshes, optional, default false\r\n     * @param forceCopy indicating that the VertexData must be cloned, optional, default false\r\n     * @returns the object VertexData associated to the passed mesh\r\n     */\r\n    public static ExtractFromGeometry(geometry: Geometry, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        return VertexData._ExtractFrom(geometry, copyWhenShared, forceCopy);\r\n    }\r\n\r\n    private static _ExtractFrom(meshOrGeometry: IGetSetVerticesData, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        const result = new VertexData();\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.PositionKind)) {\r\n            result.positions = meshOrGeometry.getVerticesData(VertexBuffer.PositionKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            result.normals = meshOrGeometry.getVerticesData(VertexBuffer.NormalKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            result.tangents = meshOrGeometry.getVerticesData(VertexBuffer.TangentKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            result.uvs = meshOrGeometry.getVerticesData(VertexBuffer.UVKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n            result.uvs2 = meshOrGeometry.getVerticesData(VertexBuffer.UV2Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\r\n            result.uvs3 = meshOrGeometry.getVerticesData(VertexBuffer.UV3Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\r\n            result.uvs4 = meshOrGeometry.getVerticesData(VertexBuffer.UV4Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\r\n            result.uvs5 = meshOrGeometry.getVerticesData(VertexBuffer.UV5Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\r\n            result.uvs6 = meshOrGeometry.getVerticesData(VertexBuffer.UV6Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            result.colors = meshOrGeometry.getVerticesData(VertexBuffer.ColorKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\r\n            result.matricesIndices = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\r\n            result.matricesWeights = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesExtraKind)) {\r\n            result.matricesIndicesExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesExtraKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {\r\n            result.matricesWeightsExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsExtraKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        result.indices = meshOrGeometry.getIndices(copyWhenShared, forceCopy);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Ribbon\r\n     * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\r\n     * * pathArray array of paths, each of which an array of successive Vector3\r\n     * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\r\n     * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\r\n     * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\r\n     * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\r\n     * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\r\n     * @param options.pathArray\r\n     * @param options.closeArray\r\n     * @param options.closePath\r\n     * @param options.offset\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @param options.invertUV\r\n     * @param options.uvs\r\n     * @param options.colors\r\n     * @returns the VertexData of the ribbon\r\n     * @deprecated use CreateRibbonVertexData instead\r\n     */\r\n    public static CreateRibbon(options: {\r\n        pathArray: Vector3[][];\r\n        closeArray?: boolean;\r\n        closePath?: boolean;\r\n        offset?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        invertUV?: boolean;\r\n        uvs?: Vector2[];\r\n        colors?: Color4[];\r\n    }): VertexData {\r\n        throw _WarnImport(\"ribbonBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a box\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * size sets the width, height and depth of the box to the value of size, optional default 1\r\n     * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\r\n     * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\r\n     * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\r\n     * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n     * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.size\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.depth\r\n     * @param options.faceUV\r\n     * @param options.faceColors\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the box\r\n     * @deprecated Please use CreateBoxVertexData from the BoxBuilder file instead\r\n     */\r\n    public static CreateBox(options: {\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"boxBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a tiled box\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * faceTiles sets the pattern, tile size and number of tiles for a face\r\n     * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n     * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * @param options.pattern\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.depth\r\n     * @param options.tileSize\r\n     * @param options.tileWidth\r\n     * @param options.tileHeight\r\n     * @param options.alignHorizontal\r\n     * @param options.alignVertical\r\n     * @param options.faceUV\r\n     * @param options.faceColors\r\n     * @param options.sideOrientation\r\n     * @returns the VertexData of the box\r\n     * @deprecated Please use CreateTiledBoxVertexData instead\r\n     */\r\n    public static CreateTiledBox(options: {\r\n        pattern?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        tileSize?: number;\r\n        tileWidth?: number;\r\n        tileHeight?: number;\r\n        alignHorizontal?: number;\r\n        alignVertical?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n    }): VertexData {\r\n        throw _WarnImport(\"tiledBoxBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a tiled plane\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * pattern a limited pattern arrangement depending on the number\r\n     * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\r\n     * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\r\n     * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.pattern\r\n     * @param options.tileSize\r\n     * @param options.tileWidth\r\n     * @param options.tileHeight\r\n     * @param options.size\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.alignHorizontal\r\n     * @param options.alignVertical\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the tiled plane\r\n     * @deprecated use CreateTiledPlaneVertexData instead\r\n     */\r\n    public static CreateTiledPlane(options: {\r\n        pattern?: number;\r\n        tileSize?: number;\r\n        tileWidth?: number;\r\n        tileHeight?: number;\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        alignHorizontal?: number;\r\n        alignVertical?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"tiledPlaneBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for an ellipsoid, defaults to a sphere\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * segments sets the number of horizontal strips optional, default 32\r\n     * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\r\n     * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\r\n     * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\r\n     * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\r\n     * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\r\n     * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.segments\r\n     * @param options.diameter\r\n     * @param options.diameterX\r\n     * @param options.diameterY\r\n     * @param options.diameterZ\r\n     * @param options.arc\r\n     * @param options.slice\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the ellipsoid\r\n     * @deprecated use CreateSphereVertexData instead\r\n     */\r\n    public static CreateSphere(options: {\r\n        segments?: number;\r\n        diameter?: number;\r\n        diameterX?: number;\r\n        diameterY?: number;\r\n        diameterZ?: number;\r\n        arc?: number;\r\n        slice?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"sphereBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a cylinder, cone or prism\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * height sets the height (y direction) of the cylinder, optional, default 2\r\n     * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\r\n     * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\r\n     * * diameter sets the diameter of the top and bottom of the cone, optional default 1\r\n     * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n     * * subdivisions` the number of rings along the cylinder height, optional, default 1\r\n     * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\r\n     * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false\r\n     * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.height\r\n     * @param options.diameterTop\r\n     * @param options.diameterBottom\r\n     * @param options.diameter\r\n     * @param options.tessellation\r\n     * @param options.subdivisions\r\n     * @param options.arc\r\n     * @param options.faceColors\r\n     * @param options.faceUV\r\n     * @param options.hasRings\r\n     * @param options.enclose\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the cylinder, cone or prism\r\n     * @deprecated please use CreateCylinderVertexData instead\r\n     */\r\n    public static CreateCylinder(options: {\r\n        height?: number;\r\n        diameterTop?: number;\r\n        diameterBottom?: number;\r\n        diameter?: number;\r\n        tessellation?: number;\r\n        subdivisions?: number;\r\n        arc?: number;\r\n        faceColors?: Color4[];\r\n        faceUV?: Vector4[];\r\n        hasRings?: boolean;\r\n        enclose?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"cylinderBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a torus\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * diameter the diameter of the torus, optional default 1\r\n     * * thickness the diameter of the tube forming the torus, optional default 0.5\r\n     * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.diameter\r\n     * @param options.thickness\r\n     * @param options.tessellation\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the torus\r\n     * @deprecated use CreateTorusVertexData instead\r\n     */\r\n    public static CreateTorus(options: {\r\n        diameter?: number;\r\n        thickness?: number;\r\n        tessellation?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"torusBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the LineSystem\r\n     * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\r\n     *  - lines an array of lines, each line being an array of successive Vector3\r\n     *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\r\n     * @param options.lines\r\n     * @param options.colors\r\n     * @returns the VertexData of the LineSystem\r\n     * @deprecated use CreateLineSystemVertexData instead\r\n     */\r\n    public static CreateLineSystem(options: { lines: Vector3[][]; colors?: Nullable<Color4[][]> }): VertexData {\r\n        throw _WarnImport(\"linesBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Create the VertexData for a DashedLines\r\n     * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\r\n     *  - points an array successive Vector3\r\n     *  - dashSize the size of the dashes relative to the dash number, optional, default 3\r\n     *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\r\n     *  - dashNb the intended total number of dashes, optional, default 200\r\n     * @param options.points\r\n     * @param options.dashSize\r\n     * @param options.gapSize\r\n     * @param options.dashNb\r\n     * @returns the VertexData for the DashedLines\r\n     * @deprecated use CreateDashedLinesVertexData instead\r\n     */\r\n    public static CreateDashedLines(options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number }): VertexData {\r\n        throw _WarnImport(\"linesBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Ground\r\n     * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n     *  - width the width (x direction) of the ground, optional, default 1\r\n     *  - height the height (z direction) of the ground, optional, default 1\r\n     *  - subdivisions the number of subdivisions per side, optional, default 1\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.subdivisions\r\n     * @param options.subdivisionsX\r\n     * @param options.subdivisionsY\r\n     * @returns the VertexData of the Ground\r\n     * @deprecated Please use CreateGroundVertexData instead\r\n     */\r\n    public static CreateGround(options: { width?: number; height?: number; subdivisions?: number; subdivisionsX?: number; subdivisionsY?: number }): VertexData {\r\n        throw _WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a TiledGround by subdividing the ground into tiles\r\n     * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n     * * xmin the ground minimum X coordinate, optional, default -1\r\n     * * zmin the ground minimum Z coordinate, optional, default -1\r\n     * * xmax the ground maximum X coordinate, optional, default 1\r\n     * * zmax the ground maximum Z coordinate, optional, default 1\r\n     * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\r\n     * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\r\n     * @param options.xmin\r\n     * @param options.zmin\r\n     * @param options.xmax\r\n     * @param options.zmax\r\n     * @param options.subdivisions\r\n     * @param options.subdivisions.w\r\n     * @param options.subdivisions.h\r\n     * @param options.precision\r\n     * @param options.precision.w\r\n     * @param options.precision.h\r\n     * @returns the VertexData of the TiledGround\r\n     * @deprecated use CreateTiledGroundVertexData instead\r\n     */\r\n    public static CreateTiledGround(options: {\r\n        xmin: number;\r\n        zmin: number;\r\n        xmax: number;\r\n        zmax: number;\r\n        subdivisions?: { w: number; h: number };\r\n        precision?: { w: number; h: number };\r\n    }): VertexData {\r\n        throw _WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the Ground designed from a heightmap\r\n     * @param options an object used to set the following parameters for the Ground, required and provided by CreateGroundFromHeightMap\r\n     * * width the width (x direction) of the ground\r\n     * * height the height (z direction) of the ground\r\n     * * subdivisions the number of subdivisions per side\r\n     * * minHeight the minimum altitude on the ground, optional, default 0\r\n     * * maxHeight the maximum altitude on the ground, optional default 1\r\n     * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\r\n     * * buffer the array holding the image color data\r\n     * * bufferWidth the width of image\r\n     * * bufferHeight the height of image\r\n     * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.subdivisions\r\n     * @param options.minHeight\r\n     * @param options.maxHeight\r\n     * @param options.colorFilter\r\n     * @param options.buffer\r\n     * @param options.bufferWidth\r\n     * @param options.bufferHeight\r\n     * @param options.alphaFilter\r\n     * @returns the VertexData of the Ground designed from a heightmap\r\n     * @deprecated use CreateGroundFromHeightMapVertexData instead\r\n     */\r\n    public static CreateGroundFromHeightMap(options: {\r\n        width: number;\r\n        height: number;\r\n        subdivisions: number;\r\n        minHeight: number;\r\n        maxHeight: number;\r\n        colorFilter: Color3;\r\n        buffer: Uint8Array;\r\n        bufferWidth: number;\r\n        bufferHeight: number;\r\n        alphaFilter: number;\r\n    }): VertexData {\r\n        throw _WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Plane\r\n     * @param options an object used to set the following optional parameters for the plane, required but can be empty\r\n     * * size sets the width and height of the plane to the value of size, optional default 1\r\n     * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size\r\n     * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.size\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the box\r\n     * @deprecated use CreatePlaneVertexData instead\r\n     */\r\n    public static CreatePlane(options: { size?: number; width?: number; height?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 }): VertexData {\r\n        throw _WarnImport(\"planeBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the Disc or regular Polygon\r\n     * @param options an object used to set the following optional parameters for the disc, required but can be empty\r\n     * * radius the radius of the disc, optional default 0.5\r\n     * * tessellation the number of polygon sides, optional, default 64\r\n     * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.radius\r\n     * @param options.tessellation\r\n     * @param options.arc\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the box\r\n     * @deprecated use CreateDiscVertexData instead\r\n     */\r\n    public static CreateDisc(options: { radius?: number; tessellation?: number; arc?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 }): VertexData {\r\n        throw _WarnImport(\"discBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()\r\n     * All parameters are provided by CreatePolygon as needed\r\n     * @param polygon a mesh built from polygonTriangulation.build()\r\n     * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param wrap a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side\r\n     * @returns the VertexData of the Polygon\r\n     * @deprecated use CreatePolygonVertexData instead\r\n     */\r\n    public static CreatePolygon(polygon: Mesh, sideOrientation: number, fUV?: Vector4[], fColors?: Color4[], frontUVs?: Vector4, backUVs?: Vector4, wrap?: boolean): VertexData {\r\n        throw _WarnImport(\"polygonBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the IcoSphere\r\n     * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty\r\n     * * radius the radius of the IcoSphere, optional default 1\r\n     * * radiusX allows stretching in the x direction, optional, default radius\r\n     * * radiusY allows stretching in the y direction, optional, default radius\r\n     * * radiusZ allows stretching in the z direction, optional, default radius\r\n     * * flat when true creates a flat shaded mesh, optional, default true\r\n     * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.radius\r\n     * @param options.radiusX\r\n     * @param options.radiusY\r\n     * @param options.radiusZ\r\n     * @param options.flat\r\n     * @param options.subdivisions\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the IcoSphere\r\n     * @deprecated use CreateIcoSphereVertexData instead\r\n     */\r\n    public static CreateIcoSphere(options: {\r\n        radius?: number;\r\n        radiusX?: number;\r\n        radiusY?: number;\r\n        radiusZ?: number;\r\n        flat?: boolean;\r\n        subdivisions?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"icoSphereBuilder\");\r\n    }\r\n\r\n    // inspired from // http://stemkoski.github.io/Three.js/Polyhedra.html\r\n    /**\r\n     * Creates the VertexData for a Polyhedron\r\n     * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n     * * type provided types are:\r\n     *  * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\r\n     *  * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\r\n     * * size the size of the IcoSphere, optional default 1\r\n     * * sizeX allows stretching in the x direction, optional, default size\r\n     * * sizeY allows stretching in the y direction, optional, default size\r\n     * * sizeZ allows stretching in the z direction, optional, default size\r\n     * * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor\r\n     * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * * flat when true creates a flat shaded mesh, optional, default true\r\n     * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.type\r\n     * @param options.size\r\n     * @param options.sizeX\r\n     * @param options.sizeY\r\n     * @param options.sizeZ\r\n     * @param options.custom\r\n     * @param options.faceUV\r\n     * @param options.faceColors\r\n     * @param options.flat\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the Polyhedron\r\n     * @deprecated use CreatePolyhedronVertexData instead\r\n     */\r\n    public static CreatePolyhedron(options: {\r\n        type?: number;\r\n        size?: number;\r\n        sizeX?: number;\r\n        sizeY?: number;\r\n        sizeZ?: number;\r\n        custom?: any;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        flat?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"polyhedronBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Capsule, inspired from https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\r\n     * @param options an object used to set the following optional parameters for the capsule, required but can be empty\r\n     * @returns the VertexData of the Capsule\r\n     * @deprecated Please use CreateCapsuleVertexData from the capsuleBuilder file instead\r\n     */\r\n    public static CreateCapsule(\r\n        options: ICreateCapsuleOptions = {\r\n            orientation: Vector3.Up(),\r\n            subdivisions: 2,\r\n            tessellation: 16,\r\n            height: 1,\r\n            radius: 0.25,\r\n            capSubdivisions: 6,\r\n        }\r\n    ): VertexData {\r\n        throw _WarnImport(\"capsuleBuilder\");\r\n    }\r\n\r\n    // based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n    /**\r\n     * Creates the VertexData for a TorusKnot\r\n     * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\r\n     * * radius the radius of the torus knot, optional, default 2\r\n     * * tube the thickness of the tube, optional, default 0.5\r\n     * * radialSegments the number of sides on each tube segments, optional, default 32\r\n     * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\r\n     * * p the number of windings around the z axis, optional,  default 2\r\n     * * q the number of windings around the x axis, optional,  default 3\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.radius\r\n     * @param options.tube\r\n     * @param options.radialSegments\r\n     * @param options.tubularSegments\r\n     * @param options.p\r\n     * @param options.q\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the Torus Knot\r\n     * @deprecated use CreateTorusKnotVertexData instead\r\n     */\r\n    public static CreateTorusKnot(options: {\r\n        radius?: number;\r\n        tube?: number;\r\n        radialSegments?: number;\r\n        tubularSegments?: number;\r\n        p?: number;\r\n        q?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"torusKnotBuilder\");\r\n    }\r\n\r\n    // Tools\r\n\r\n    /**\r\n     * Compute normals for given positions and indices\r\n     * @param positions an array of vertex positions, [...., x, y, z, ......]\r\n     * @param indices an array of indices in groups of three for each triangular facet, [...., i, j, k, ......]\r\n     * @param normals an array of vertex normals, [...., x, y, z, ......]\r\n     * @param options an object used to set the following optional parameters for the TorusKnot, optional\r\n     * * facetNormals : optional array of facet normals (vector3)\r\n     * * facetPositions : optional array of facet positions (vector3)\r\n     * * facetPartitioning : optional partitioning array. facetPositions is required for facetPartitioning computation\r\n     * * ratio : optional partitioning ratio / bounding box, required for facetPartitioning computation\r\n     * * bInfo : optional bounding info, required for facetPartitioning computation\r\n     * * bbSize : optional bounding box size data, required for facetPartitioning computation\r\n     * * subDiv : optional partitioning data about subdivisions on  each axis (int), required for facetPartitioning computation\r\n     * * useRightHandedSystem: optional boolean to for right handed system computation\r\n     * * depthSort : optional boolean to enable the facet depth sort computation\r\n     * * distanceTo : optional Vector3 to compute the facet depth from this location\r\n     * * depthSortedFacets : optional array of depthSortedFacets to store the facet distances from the reference location\r\n     * @param options.facetNormals\r\n     * @param options.facetPositions\r\n     * @param options.facetPartitioning\r\n     * @param options.ratio\r\n     * @param options.bInfo\r\n     * @param options.bbSize\r\n     * @param options.subDiv\r\n     * @param options.useRightHandedSystem\r\n     * @param options.depthSort\r\n     * @param options.distanceTo\r\n     * @param options.depthSortedFacets\r\n     */\r\n    public static ComputeNormals(\r\n        positions: any,\r\n        indices: any,\r\n        normals: any,\r\n        options?: {\r\n            facetNormals?: any;\r\n            facetPositions?: any;\r\n            facetPartitioning?: any;\r\n            ratio?: number;\r\n            bInfo?: any;\r\n            bbSize?: Vector3;\r\n            subDiv?: any;\r\n            useRightHandedSystem?: boolean;\r\n            depthSort?: boolean;\r\n            distanceTo?: Vector3;\r\n            depthSortedFacets?: any;\r\n        }\r\n    ): void {\r\n        // temporary scalar variables\r\n        let index = 0; // facet index\r\n        let p1p2x = 0.0; // p1p2 vector x coordinate\r\n        let p1p2y = 0.0; // p1p2 vector y coordinate\r\n        let p1p2z = 0.0; // p1p2 vector z coordinate\r\n        let p3p2x = 0.0; // p3p2 vector x coordinate\r\n        let p3p2y = 0.0; // p3p2 vector y coordinate\r\n        let p3p2z = 0.0; // p3p2 vector z coordinate\r\n        let faceNormalx = 0.0; // facet normal x coordinate\r\n        let faceNormaly = 0.0; // facet normal y coordinate\r\n        let faceNormalz = 0.0; // facet normal z coordinate\r\n        let length = 0.0; // facet normal length before normalization\r\n        let v1x = 0; // vector1 x index in the positions array\r\n        let v1y = 0; // vector1 y index in the positions array\r\n        let v1z = 0; // vector1 z index in the positions array\r\n        let v2x = 0; // vector2 x index in the positions array\r\n        let v2y = 0; // vector2 y index in the positions array\r\n        let v2z = 0; // vector2 z index in the positions array\r\n        let v3x = 0; // vector3 x index in the positions array\r\n        let v3y = 0; // vector3 y index in the positions array\r\n        let v3z = 0; // vector3 z index in the positions array\r\n        let computeFacetNormals = false;\r\n        let computeFacetPositions = false;\r\n        let computeFacetPartitioning = false;\r\n        let computeDepthSort = false;\r\n        let faceNormalSign = 1;\r\n        let ratio = 0;\r\n        let distanceTo: Nullable<Vector3> = null;\r\n        if (options) {\r\n            computeFacetNormals = options.facetNormals ? true : false;\r\n            computeFacetPositions = options.facetPositions ? true : false;\r\n            computeFacetPartitioning = options.facetPartitioning ? true : false;\r\n            faceNormalSign = options.useRightHandedSystem === true ? -1 : 1;\r\n            ratio = options.ratio || 0;\r\n            computeDepthSort = options.depthSort ? true : false;\r\n            distanceTo = <Vector3>options.distanceTo;\r\n            if (computeDepthSort) {\r\n                if (distanceTo === undefined) {\r\n                    distanceTo = Vector3.Zero();\r\n                }\r\n            }\r\n        }\r\n\r\n        // facetPartitioning reinit if needed\r\n        let xSubRatio = 0;\r\n        let ySubRatio = 0;\r\n        let zSubRatio = 0;\r\n        let subSq = 0;\r\n        if (computeFacetPartitioning && options && options.bbSize) {\r\n            //let bbSizeMax = options.bbSize.x > options.bbSize.y ? options.bbSize.x : options.bbSize.y;\r\n            //bbSizeMax = bbSizeMax > options.bbSize.z ? bbSizeMax : options.bbSize.z;\r\n            xSubRatio = (options.subDiv.X * ratio) / options.bbSize.x;\r\n            ySubRatio = (options.subDiv.Y * ratio) / options.bbSize.y;\r\n            zSubRatio = (options.subDiv.Z * ratio) / options.bbSize.z;\r\n            subSq = options.subDiv.max * options.subDiv.max;\r\n            options.facetPartitioning.length = 0;\r\n        }\r\n\r\n        // reset the normals\r\n        for (index = 0; index < positions.length; index++) {\r\n            normals[index] = 0.0;\r\n        }\r\n\r\n        // Loop : 1 indice triplet = 1 facet\r\n        const nbFaces = (indices.length / 3) | 0;\r\n        for (index = 0; index < nbFaces; index++) {\r\n            // get the indexes of the coordinates of each vertex of the facet\r\n            v1x = indices[index * 3] * 3;\r\n            v1y = v1x + 1;\r\n            v1z = v1x + 2;\r\n            v2x = indices[index * 3 + 1] * 3;\r\n            v2y = v2x + 1;\r\n            v2z = v2x + 2;\r\n            v3x = indices[index * 3 + 2] * 3;\r\n            v3y = v3x + 1;\r\n            v3z = v3x + 2;\r\n\r\n            p1p2x = positions[v1x] - positions[v2x]; // compute two vectors per facet : p1p2 and p3p2\r\n            p1p2y = positions[v1y] - positions[v2y];\r\n            p1p2z = positions[v1z] - positions[v2z];\r\n\r\n            p3p2x = positions[v3x] - positions[v2x];\r\n            p3p2y = positions[v3y] - positions[v2y];\r\n            p3p2z = positions[v3z] - positions[v2z];\r\n\r\n            // compute the face normal with the cross product\r\n            faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);\r\n            faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);\r\n            faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x);\r\n            // normalize this normal and store it in the array facetData\r\n            length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\r\n            length = length === 0 ? 1.0 : length;\r\n            faceNormalx /= length;\r\n            faceNormaly /= length;\r\n            faceNormalz /= length;\r\n\r\n            if (computeFacetNormals && options) {\r\n                options.facetNormals[index].x = faceNormalx;\r\n                options.facetNormals[index].y = faceNormaly;\r\n                options.facetNormals[index].z = faceNormalz;\r\n            }\r\n\r\n            if (computeFacetPositions && options) {\r\n                // compute and the facet barycenter coordinates in the array facetPositions\r\n                options.facetPositions[index].x = (positions[v1x] + positions[v2x] + positions[v3x]) / 3.0;\r\n                options.facetPositions[index].y = (positions[v1y] + positions[v2y] + positions[v3y]) / 3.0;\r\n                options.facetPositions[index].z = (positions[v1z] + positions[v2z] + positions[v3z]) / 3.0;\r\n            }\r\n\r\n            if (computeFacetPartitioning && options) {\r\n                // store the facet indexes in arrays in the main facetPartitioning array :\r\n                // compute each facet vertex (+ facet barycenter) index in the partiniong array\r\n                const ox = Math.floor((options.facetPositions[index].x - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const oy = Math.floor((options.facetPositions[index].y - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const oz = Math.floor((options.facetPositions[index].z - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                const b1x = Math.floor((positions[v1x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const b1y = Math.floor((positions[v1y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const b1z = Math.floor((positions[v1z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                const b2x = Math.floor((positions[v2x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const b2y = Math.floor((positions[v2y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const b2z = Math.floor((positions[v2z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                const b3x = Math.floor((positions[v3x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const b3y = Math.floor((positions[v3y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const b3z = Math.floor((positions[v3z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n\r\n                const block_idx_v1 = b1x + options.subDiv.max * b1y + subSq * b1z;\r\n                const block_idx_v2 = b2x + options.subDiv.max * b2y + subSq * b2z;\r\n                const block_idx_v3 = b3x + options.subDiv.max * b3y + subSq * b3z;\r\n                const block_idx_o = ox + options.subDiv.max * oy + subSq * oz;\r\n\r\n                options.facetPartitioning[block_idx_o] = options.facetPartitioning[block_idx_o] ? options.facetPartitioning[block_idx_o] : new Array();\r\n                options.facetPartitioning[block_idx_v1] = options.facetPartitioning[block_idx_v1] ? options.facetPartitioning[block_idx_v1] : new Array();\r\n                options.facetPartitioning[block_idx_v2] = options.facetPartitioning[block_idx_v2] ? options.facetPartitioning[block_idx_v2] : new Array();\r\n                options.facetPartitioning[block_idx_v3] = options.facetPartitioning[block_idx_v3] ? options.facetPartitioning[block_idx_v3] : new Array();\r\n\r\n                // push each facet index in each block containing the vertex\r\n                options.facetPartitioning[block_idx_v1].push(index);\r\n                if (block_idx_v2 != block_idx_v1) {\r\n                    options.facetPartitioning[block_idx_v2].push(index);\r\n                }\r\n                if (!(block_idx_v3 == block_idx_v2 || block_idx_v3 == block_idx_v1)) {\r\n                    options.facetPartitioning[block_idx_v3].push(index);\r\n                }\r\n                if (!(block_idx_o == block_idx_v1 || block_idx_o == block_idx_v2 || block_idx_o == block_idx_v3)) {\r\n                    options.facetPartitioning[block_idx_o].push(index);\r\n                }\r\n            }\r\n\r\n            if (computeDepthSort && options && options.facetPositions) {\r\n                const dsf = options.depthSortedFacets[index];\r\n                dsf.ind = index * 3;\r\n                dsf.sqDistance = Vector3.DistanceSquared(options.facetPositions[index], distanceTo!);\r\n            }\r\n\r\n            // compute the normals anyway\r\n            normals[v1x] += faceNormalx; // accumulate all the normals per face\r\n            normals[v1y] += faceNormaly;\r\n            normals[v1z] += faceNormalz;\r\n            normals[v2x] += faceNormalx;\r\n            normals[v2y] += faceNormaly;\r\n            normals[v2z] += faceNormalz;\r\n            normals[v3x] += faceNormalx;\r\n            normals[v3y] += faceNormaly;\r\n            normals[v3z] += faceNormalz;\r\n        }\r\n        // last normalization of each normal\r\n        for (index = 0; index < normals.length / 3; index++) {\r\n            faceNormalx = normals[index * 3];\r\n            faceNormaly = normals[index * 3 + 1];\r\n            faceNormalz = normals[index * 3 + 2];\r\n\r\n            length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\r\n            length = length === 0 ? 1.0 : length;\r\n            faceNormalx /= length;\r\n            faceNormaly /= length;\r\n            faceNormalz /= length;\r\n\r\n            normals[index * 3] = faceNormalx;\r\n            normals[index * 3 + 1] = faceNormaly;\r\n            normals[index * 3 + 2] = faceNormalz;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _ComputeSides(\r\n        sideOrientation: number,\r\n        positions: FloatArray,\r\n        indices: FloatArray | IndicesArray,\r\n        normals: FloatArray,\r\n        uvs: FloatArray,\r\n        frontUVs?: Vector4,\r\n        backUVs?: Vector4\r\n    ) {\r\n        const li: number = indices.length;\r\n        const ln: number = normals.length;\r\n        let i: number;\r\n        let n: number;\r\n        sideOrientation = sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n        switch (sideOrientation) {\r\n            case VertexData.FRONTSIDE:\r\n                // nothing changed\r\n                break;\r\n\r\n            case VertexData.BACKSIDE:\r\n                // indices\r\n                for (i = 0; i < li; i += 3) {\r\n                    const tmp = indices[i];\r\n                    indices[i] = indices[i + 2];\r\n                    indices[i + 2] = tmp;\r\n                }\r\n                // normals\r\n                for (n = 0; n < ln; n++) {\r\n                    normals[n] = -normals[n];\r\n                }\r\n                break;\r\n\r\n            case VertexData.DOUBLESIDE: {\r\n                // positions\r\n                const lp: number = positions.length;\r\n                const l: number = lp / 3;\r\n                for (let p = 0; p < lp; p++) {\r\n                    positions[lp + p] = positions[p];\r\n                }\r\n                // indices\r\n                for (i = 0; i < li; i += 3) {\r\n                    indices[i + li] = indices[i + 2] + l;\r\n                    indices[i + 1 + li] = indices[i + 1] + l;\r\n                    indices[i + 2 + li] = indices[i] + l;\r\n                }\r\n                // normals\r\n                for (n = 0; n < ln; n++) {\r\n                    normals[ln + n] = -normals[n];\r\n                }\r\n\r\n                // uvs\r\n                const lu: number = uvs.length;\r\n                let u: number = 0;\r\n                for (u = 0; u < lu; u++) {\r\n                    uvs[u + lu] = uvs[u];\r\n                }\r\n                frontUVs = frontUVs ? frontUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\r\n                backUVs = backUVs ? backUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\r\n                u = 0;\r\n                for (i = 0; i < lu / 2; i++) {\r\n                    uvs[u] = frontUVs.x + (frontUVs.z - frontUVs.x) * uvs[u];\r\n                    uvs[u + 1] = frontUVs.y + (frontUVs.w - frontUVs.y) * uvs[u + 1];\r\n                    uvs[u + lu] = backUVs.x + (backUVs.z - backUVs.x) * uvs[u + lu];\r\n                    uvs[u + lu + 1] = backUVs.y + (backUVs.w - backUVs.y) * uvs[u + lu + 1];\r\n                    u += 2;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a VertexData from serialized data\r\n     * @param parsedVertexData the parsed data from an imported file\r\n     * @returns a VertexData\r\n     */\r\n    public static Parse(parsedVertexData: any) {\r\n        const vertexData = new VertexData();\r\n\r\n        // positions\r\n        const positions = parsedVertexData.positions;\r\n        if (positions) {\r\n            vertexData.set(positions, VertexBuffer.PositionKind);\r\n        }\r\n\r\n        // normals\r\n        const normals = parsedVertexData.normals;\r\n        if (normals) {\r\n            vertexData.set(normals, VertexBuffer.NormalKind);\r\n        }\r\n\r\n        // tangents\r\n        const tangents = parsedVertexData.tangents;\r\n        if (tangents) {\r\n            vertexData.set(tangents, VertexBuffer.TangentKind);\r\n        }\r\n\r\n        // uvs\r\n        const uvs = parsedVertexData.uvs;\r\n        if (uvs) {\r\n            vertexData.set(uvs, VertexBuffer.UVKind);\r\n        }\r\n\r\n        // uv2s\r\n        const uvs2 = parsedVertexData.uvs2;\r\n        if (uvs2) {\r\n            vertexData.set(uvs2, VertexBuffer.UV2Kind);\r\n        }\r\n\r\n        // uv3s\r\n        const uvs3 = parsedVertexData.uvs3;\r\n        if (uvs3) {\r\n            vertexData.set(uvs3, VertexBuffer.UV3Kind);\r\n        }\r\n\r\n        // uv4s\r\n        const uvs4 = parsedVertexData.uvs4;\r\n        if (uvs4) {\r\n            vertexData.set(uvs4, VertexBuffer.UV4Kind);\r\n        }\r\n\r\n        // uv5s\r\n        const uvs5 = parsedVertexData.uvs5;\r\n        if (uvs5) {\r\n            vertexData.set(uvs5, VertexBuffer.UV5Kind);\r\n        }\r\n\r\n        // uv6s\r\n        const uvs6 = parsedVertexData.uvs6;\r\n        if (uvs6) {\r\n            vertexData.set(uvs6, VertexBuffer.UV6Kind);\r\n        }\r\n\r\n        // colors\r\n        const colors = parsedVertexData.colors;\r\n        if (colors) {\r\n            vertexData.set(Color4.CheckColors4(colors, positions.length / 3), VertexBuffer.ColorKind);\r\n        }\r\n\r\n        // matricesIndices\r\n        const matricesIndices = parsedVertexData.matricesIndices;\r\n        if (matricesIndices) {\r\n            vertexData.set(matricesIndices, VertexBuffer.MatricesIndicesKind);\r\n        }\r\n\r\n        // matricesWeights\r\n        const matricesWeights = parsedVertexData.matricesWeights;\r\n        if (matricesWeights) {\r\n            vertexData.set(matricesWeights, VertexBuffer.MatricesWeightsKind);\r\n        }\r\n\r\n        // indices\r\n        const indices = parsedVertexData.indices;\r\n        if (indices) {\r\n            vertexData.indices = indices;\r\n        }\r\n\r\n        // MaterialInfos\r\n        const materialInfos = parsedVertexData.materialInfos;\r\n        if (materialInfos) {\r\n            vertexData.materialInfos = [];\r\n            for (const materialInfoFromJSON of materialInfos) {\r\n                const materialInfo = new VertexDataMaterialInfo();\r\n                materialInfo.indexCount = materialInfoFromJSON.indexCount;\r\n                materialInfo.indexStart = materialInfoFromJSON.indexStart;\r\n                materialInfo.verticesCount = materialInfoFromJSON.verticesCount;\r\n                materialInfo.verticesStart = materialInfoFromJSON.verticesStart;\r\n                materialInfo.materialIndex = materialInfoFromJSON.materialIndex;\r\n                vertexData.materialInfos.push(materialInfo);\r\n            }\r\n        }\r\n\r\n        return vertexData;\r\n    }\r\n\r\n    /**\r\n     * Applies VertexData created from the imported parameters to the geometry\r\n     * @param parsedVertexData the parsed data from an imported file\r\n     * @param geometry the geometry to apply the VertexData to\r\n     */\r\n    public static ImportVertexData(parsedVertexData: any, geometry: Geometry) {\r\n        const vertexData = VertexData.Parse(parsedVertexData);\r\n\r\n        geometry.setAllVerticesData(vertexData, parsedVertexData.updatable);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}