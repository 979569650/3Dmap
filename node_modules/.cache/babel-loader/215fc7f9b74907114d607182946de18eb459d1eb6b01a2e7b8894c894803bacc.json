{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { Vector3 } from \"../../../../Maths/math.vector.js\";\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator.js\";\nimport { Epsilon } from \"../../../../Maths/math.constants.js\";\n/**\n * Block used to instance geometry on every vertex of a geometry\n */\nexport class InstantiateOnVerticesBlock extends NodeGeometryBlock {\n  /**\n   * Create a new InstantiateOnVerticesBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    this._indexTranslation = null;\n    /**\n     * Gets or sets a boolean indicating that this block can evaluate context\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\n     */\n    this.evaluateContext = true;\n    /**\n     * Gets or sets a boolean indicating if the block should remove duplicated positions\n     */\n    this.removeDuplicatedPositions = true;\n    this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\n    this.registerInput(\"instance\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\n    this.registerInput(\"density\", NodeGeometryBlockConnectionPointTypes.Float, true, 1, 0, 1);\n    this.registerInput(\"matrix\", NodeGeometryBlockConnectionPointTypes.Matrix, true);\n    this.registerInput(\"rotation\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());\n    this.registerInput(\"scaling\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.One());\n    this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\n    this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\n  }\n  /**\n   * Gets the current instance index in the current flow\n   * @returns the current index\n   */\n  getInstanceIndex() {\n    return this._currentLoopIndex;\n  }\n  /**\n   * Gets the current index in the current flow\n   * @returns the current index\n   */\n  getExecutionIndex() {\n    return this._indexTranslation ? this._indexTranslation[this._currentIndex] : this._currentIndex;\n  }\n  /**\n   * Gets the current loop index in the current flow\n   * @returns the current loop index\n   */\n  getExecutionLoopIndex() {\n    return this._currentLoopIndex;\n  }\n  /**\n   * Gets the current face index in the current flow\n   * @returns the current face index\n   */\n  getExecutionFaceIndex() {\n    return 0;\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"InstantiateOnVerticesBlock\";\n  }\n  /**\n   * Gets the geometry input component\n   */\n  get geometry() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the instance input component\n   */\n  get instance() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the density input component\n   */\n  get density() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the matrix input component\n   */\n  get matrix() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the rotation input component\n   */\n  get rotation() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the scaling input component\n   */\n  get scaling() {\n    return this._inputs[5];\n  }\n  /**\n   * Gets the geometry output component\n   */\n  get output() {\n    return this._outputs[0];\n  }\n  _buildBlock(state) {\n    const func = state => {\n      state.pushExecutionContext(this);\n      state.pushInstancingContext(this);\n      this._vertexData = this.geometry.getConnectedValue(state);\n      state.pushGeometryContext(this._vertexData);\n      if (!this._vertexData || !this._vertexData.positions || !this.instance.isConnected) {\n        state.restoreExecutionContext();\n        state.restoreInstancingContext();\n        state.restoreGeometryContext();\n        this.output._storedValue = null;\n        return;\n      }\n      // Processing\n      let vertexCount = this._vertexData.positions.length / 3;\n      const additionalVertexData = [];\n      const currentPosition = new Vector3();\n      const alreadyDone = new Array();\n      let vertices = this._vertexData.positions;\n      this._currentLoopIndex = 0;\n      if (this.removeDuplicatedPositions) {\n        this._indexTranslation = {};\n        for (this._currentIndex = 0; this._currentIndex < vertexCount; this._currentIndex++) {\n          const x = vertices[this._currentIndex * 3];\n          const y = vertices[this._currentIndex * 3 + 1];\n          const z = vertices[this._currentIndex * 3 + 2];\n          let found = false;\n          for (let index = 0; index < alreadyDone.length; index += 3) {\n            if (Math.abs(alreadyDone[index] - x) < Epsilon && Math.abs(alreadyDone[index + 1] - y) < Epsilon && Math.abs(alreadyDone[index + 2] - z) < Epsilon) {\n              found = true;\n              break;\n            }\n          }\n          if (found) {\n            continue;\n          }\n          this._indexTranslation[alreadyDone.length / 3] = this._currentIndex;\n          alreadyDone.push(x, y, z);\n        }\n        vertices = alreadyDone;\n        vertexCount = vertices.length / 3;\n      } else {\n        this._indexTranslation = null;\n      }\n      for (this._currentIndex = 0; this._currentIndex < vertexCount; this._currentIndex++) {\n        const instanceGeometry = this.instance.getConnectedValue(state);\n        if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {\n          continue;\n        }\n        const density = this.density.getConnectedValue(state);\n        if (density < 1) {\n          if (Math.random() > density) {\n            continue;\n          }\n        }\n        currentPosition.fromArray(vertices, this._currentIndex * 3);\n        // Clone the instance\n        const clone = instanceGeometry.clone();\n        // Transform\n        if (this.matrix.isConnected) {\n          const transform = this.matrix.getConnectedValue(state);\n          state._instantiateWithPositionAndMatrix(clone, currentPosition, transform, additionalVertexData);\n        } else {\n          const scaling = state.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);\n          const rotation = this.rotation.getConnectedValue(state) || Vector3.ZeroReadOnly;\n          state._instantiate(clone, currentPosition, rotation, scaling, additionalVertexData);\n        }\n        this._currentLoopIndex++;\n      }\n      // Restore\n      state.restoreGeometryContext();\n      state.restoreExecutionContext();\n      state.restoreInstancingContext();\n      // Merge\n      if (additionalVertexData.length) {\n        if (additionalVertexData.length === 1) {\n          this._vertexData = additionalVertexData[0];\n        } else {\n          // We do not merge the main one as user can use a merge node if wanted\n          const main = additionalVertexData.splice(0, 1)[0];\n          this._vertexData = main.merge(additionalVertexData, true, false, true, true);\n        }\n      } else {\n        return null;\n      }\n      return this._vertexData;\n    };\n    // Storage\n    if (this.evaluateContext) {\n      this.output._storedFunction = func;\n    } else {\n      this.output._storedFunction = null;\n      this.output._storedValue = func(state);\n    }\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.removeDuplicatedPositions = ${this.removeDuplicatedPositions ? \"true\" : \"false\"};\\n`;\n    codeString += `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\n    return codeString;\n  }\n  /**\n   * Serializes this block in a JSON representation\n   * @returns the serialized block object\n   */\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.removeDuplicatedPositions = this.removeDuplicatedPositions;\n    serializationObject.evaluateContext = this.evaluateContext;\n    return serializationObject;\n  }\n  _deserialize(serializationObject) {\n    super._deserialize(serializationObject);\n    this.removeDuplicatedPositions = serializationObject.removeDuplicatedPositions;\n    if (serializationObject.evaluateContext !== undefined) {\n      this.evaluateContext = serializationObject.evaluateContext;\n    }\n  }\n}\n__decorate([editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    rebuild: true\n  }\n})], InstantiateOnVerticesBlock.prototype, \"evaluateContext\", void 0);\n__decorate([editableInPropertyPage(\"Remove duplicated positions\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    update: true\n  }\n})], InstantiateOnVerticesBlock.prototype, \"removeDuplicatedPositions\", void 0);\nRegisterClass(\"BABYLON.InstantiateOnVerticesBlock\", InstantiateOnVerticesBlock);","map":{"version":3,"names":["NodeGeometryBlock","RegisterClass","NodeGeometryBlockConnectionPointTypes","Vector3","PropertyTypeForEdition","editableInPropertyPage","Epsilon","InstantiateOnVerticesBlock","constructor","name","_indexTranslation","evaluateContext","removeDuplicatedPositions","registerInput","Geometry","Float","Matrix","Zero","One","scaling","acceptedConnectionPointTypes","push","registerOutput","getInstanceIndex","_currentLoopIndex","getExecutionIndex","_currentIndex","getExecutionLoopIndex","getExecutionFaceIndex","getClassName","geometry","_inputs","instance","density","matrix","rotation","output","_outputs","_buildBlock","state","func","pushExecutionContext","pushInstancingContext","_vertexData","getConnectedValue","pushGeometryContext","positions","isConnected","restoreExecutionContext","restoreInstancingContext","restoreGeometryContext","_storedValue","vertexCount","length","additionalVertexData","currentPosition","alreadyDone","Array","vertices","x","y","z","found","index","Math","abs","instanceGeometry","random","fromArray","clone","transform","_instantiateWithPositionAndMatrix","adaptInput","OneReadOnly","ZeroReadOnly","_instantiate","main","splice","merge","_storedFunction","_dumpPropertiesCode","codeString","_codeVariableName","serialize","serializationObject","_deserialize","undefined","__decorate","Boolean","notifiers","rebuild","update"],"sources":["../../../../../../../dev/core/src/Meshes/Node/Blocks/Instances/instantiateOnVerticesBlock.ts"],"sourcesContent":["import { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport type { INodeGeometryExecutionContext } from \"../../Interfaces/nodeGeometryExecutionContext\";\r\nimport type { VertexData } from \"../../../mesh.vertexData\";\r\nimport { Vector3 } from \"../../../../Maths/math.vector\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator\";\r\nimport { Epsilon } from \"../../../../Maths/math.constants\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport type { INodeGeometryInstancingContext } from \"../../Interfaces/nodeGeometryInstancingContext\";\r\n\r\n/**\r\n * Block used to instance geometry on every vertex of a geometry\r\n */\r\nexport class InstantiateOnVerticesBlock extends NodeGeometryBlock implements INodeGeometryExecutionContext, INodeGeometryInstancingContext {\r\n    private _vertexData: VertexData;\r\n    private _currentIndex: number;\r\n    private _currentLoopIndex: number;\r\n    private _indexTranslation: Nullable<{ [key: number]: number }> = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the block should remove duplicated positions\r\n     */\r\n    @editableInPropertyPage(\"Remove duplicated positions\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { update: true } })\r\n    public removeDuplicatedPositions = true;\r\n\r\n    /**\r\n     * Create a new InstantiateOnVerticesBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this.registerInput(\"instance\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\r\n        this.registerInput(\"density\", NodeGeometryBlockConnectionPointTypes.Float, true, 1, 0, 1);\r\n        this.registerInput(\"matrix\", NodeGeometryBlockConnectionPointTypes.Matrix, true);\r\n        this.registerInput(\"rotation\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());\r\n        this.registerInput(\"scaling\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.One());\r\n\r\n        this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current instance index in the current flow\r\n     * @returns the current index\r\n     */\r\n    public getInstanceIndex(): number {\r\n        return this._currentLoopIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current index in the current flow\r\n     * @returns the current index\r\n     */\r\n    public getExecutionIndex(): number {\r\n        return this._indexTranslation ? this._indexTranslation[this._currentIndex] : this._currentIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current loop index in the current flow\r\n     * @returns the current loop index\r\n     */\r\n    public getExecutionLoopIndex(): number {\r\n        return this._currentLoopIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current face index in the current flow\r\n     * @returns the current face index\r\n     */\r\n    public getExecutionFaceIndex(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"InstantiateOnVerticesBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry input component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the instance input component\r\n     */\r\n    public get instance(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the density input component\r\n     */\r\n    public get density(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix input component\r\n     */\r\n    public get matrix(): NodeGeometryConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the rotation input component\r\n     */\r\n    public get rotation(): NodeGeometryConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the scaling input component\r\n     */\r\n    public get scaling(): NodeGeometryConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            state.pushExecutionContext(this);\r\n            state.pushInstancingContext(this);\r\n\r\n            this._vertexData = this.geometry.getConnectedValue(state);\r\n            state.pushGeometryContext(this._vertexData);\r\n\r\n            if (!this._vertexData || !this._vertexData.positions || !this.instance.isConnected) {\r\n                state.restoreExecutionContext();\r\n                state.restoreInstancingContext();\r\n                state.restoreGeometryContext();\r\n                this.output._storedValue = null;\r\n                return;\r\n            }\r\n\r\n            // Processing\r\n            let vertexCount = this._vertexData.positions.length / 3;\r\n            const additionalVertexData: VertexData[] = [];\r\n            const currentPosition = new Vector3();\r\n            const alreadyDone = new Array<number>();\r\n            let vertices = this._vertexData.positions;\r\n            this._currentLoopIndex = 0;\r\n\r\n            if (this.removeDuplicatedPositions) {\r\n                this._indexTranslation = {};\r\n                for (this._currentIndex = 0; this._currentIndex < vertexCount; this._currentIndex++) {\r\n                    const x = vertices[this._currentIndex * 3];\r\n                    const y = vertices[this._currentIndex * 3 + 1];\r\n                    const z = vertices[this._currentIndex * 3 + 2];\r\n                    let found = false;\r\n                    for (let index = 0; index < alreadyDone.length; index += 3) {\r\n                        if (Math.abs(alreadyDone[index] - x) < Epsilon && Math.abs(alreadyDone[index + 1] - y) < Epsilon && Math.abs(alreadyDone[index + 2] - z) < Epsilon) {\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (found) {\r\n                        continue;\r\n                    }\r\n                    this._indexTranslation[alreadyDone.length / 3] = this._currentIndex;\r\n                    alreadyDone.push(x, y, z);\r\n                }\r\n\r\n                vertices = alreadyDone;\r\n                vertexCount = vertices.length / 3;\r\n            } else {\r\n                this._indexTranslation = null;\r\n            }\r\n\r\n            for (this._currentIndex = 0; this._currentIndex < vertexCount; this._currentIndex++) {\r\n                const instanceGeometry = this.instance.getConnectedValue(state) as VertexData;\r\n\r\n                if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {\r\n                    continue;\r\n                }\r\n\r\n                const density = this.density.getConnectedValue(state);\r\n\r\n                if (density < 1) {\r\n                    if (Math.random() > density) {\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                currentPosition.fromArray(vertices, this._currentIndex * 3);\r\n\r\n                // Clone the instance\r\n                const clone = instanceGeometry.clone();\r\n\r\n                // Transform\r\n                if (this.matrix.isConnected) {\r\n                    const transform = this.matrix.getConnectedValue(state);\r\n                    state._instantiateWithPositionAndMatrix(clone, currentPosition, transform, additionalVertexData);\r\n                } else {\r\n                    const scaling = state.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);\r\n                    const rotation = this.rotation.getConnectedValue(state) || Vector3.ZeroReadOnly;\r\n                    state._instantiate(clone, currentPosition, rotation, scaling, additionalVertexData);\r\n                }\r\n                this._currentLoopIndex++;\r\n            }\r\n\r\n            // Restore\r\n            state.restoreGeometryContext();\r\n            state.restoreExecutionContext();\r\n            state.restoreInstancingContext();\r\n\r\n            // Merge\r\n            if (additionalVertexData.length) {\r\n                if (additionalVertexData.length === 1) {\r\n                    this._vertexData = additionalVertexData[0];\r\n                } else {\r\n                    // We do not merge the main one as user can use a merge node if wanted\r\n                    const main = additionalVertexData.splice(0, 1)[0];\r\n                    this._vertexData = main.merge(additionalVertexData, true, false, true, true);\r\n                }\r\n            } else {\r\n                return null;\r\n            }\r\n\r\n            return this._vertexData;\r\n        };\r\n\r\n        // Storage\r\n        if (this.evaluateContext) {\r\n            this.output._storedFunction = func;\r\n        } else {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = func(state);\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.removeDuplicatedPositions = ${this.removeDuplicatedPositions ? \"true\" : \"false\"};\\n`;\r\n        codeString += `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.removeDuplicatedPositions = this.removeDuplicatedPositions;\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.removeDuplicatedPositions = serializationObject.removeDuplicatedPositions;\r\n        if (serializationObject.evaluateContext !== undefined) {\r\n            this.evaluateContext = serializationObject.evaluateContext;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.InstantiateOnVerticesBlock\", InstantiateOnVerticesBlock);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}