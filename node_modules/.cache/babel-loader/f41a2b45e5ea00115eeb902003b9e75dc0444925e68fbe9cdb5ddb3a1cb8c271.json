{"ast":null,"code":"import { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { PrecisionDate } from \"../../Misc/precisionDate.js\";\nimport { Epsilon } from \"../../Maths/math.constants.js\";\n/**\n * The autoRotation behavior (AutoRotationBehavior) is designed to create a smooth rotation of an ArcRotateCamera when there is no user interaction.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#autorotation-behavior\n */\nexport class AutoRotationBehavior {\n  constructor() {\n    this._zoomStopsAnimation = false;\n    this._idleRotationSpeed = 0.05;\n    this._idleRotationWaitTime = 2000;\n    this._idleRotationSpinupTime = 2000;\n    this.targetAlpha = null;\n    this._isPointerDown = false;\n    this._lastFrameTime = null;\n    this._lastInteractionTime = -Infinity;\n    this._cameraRotationSpeed = 0;\n    this._lastFrameRadius = 0;\n  }\n  /**\n   * Gets the name of the behavior.\n   */\n  get name() {\n    return \"AutoRotation\";\n  }\n  /**\n   * Sets the flag that indicates if user zooming should stop animation.\n   */\n  set zoomStopsAnimation(flag) {\n    this._zoomStopsAnimation = flag;\n  }\n  /**\n   * Gets the flag that indicates if user zooming should stop animation.\n   */\n  get zoomStopsAnimation() {\n    return this._zoomStopsAnimation;\n  }\n  /**\n   * Sets the default speed at which the camera rotates around the model.\n   */\n  set idleRotationSpeed(speed) {\n    this._idleRotationSpeed = speed;\n  }\n  /**\n   * Gets the default speed at which the camera rotates around the model.\n   */\n  get idleRotationSpeed() {\n    return this._idleRotationSpeed;\n  }\n  /**\n   * Sets the time (in milliseconds) to wait after user interaction before the camera starts rotating.\n   */\n  set idleRotationWaitTime(time) {\n    this._idleRotationWaitTime = time;\n  }\n  /**\n   * Gets the time (milliseconds) to wait after user interaction before the camera starts rotating.\n   */\n  get idleRotationWaitTime() {\n    return this._idleRotationWaitTime;\n  }\n  /**\n   * Sets the time (milliseconds) to take to spin up to the full idle rotation speed.\n   */\n  set idleRotationSpinupTime(time) {\n    this._idleRotationSpinupTime = time;\n  }\n  /**\n   * Gets the time (milliseconds) to take to spin up to the full idle rotation speed.\n   */\n  get idleRotationSpinupTime() {\n    return this._idleRotationSpinupTime;\n  }\n  /**\n   * Gets a value indicating if the camera is currently rotating because of this behavior\n   */\n  get rotationInProgress() {\n    return Math.abs(this._cameraRotationSpeed) > 0;\n  }\n  /**\n   * Initializes the behavior.\n   */\n  init() {\n    // Do nothing\n  }\n  /**\n   * Attaches the behavior to its arc rotate camera.\n   * @param camera Defines the camera to attach the behavior to\n   */\n  attach(camera) {\n    this._attachedCamera = camera;\n    const scene = this._attachedCamera.getScene();\n    this._onPrePointerObservableObserver = scene.onPrePointerObservable.add(pointerInfoPre => {\n      if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\n        this._isPointerDown = true;\n        return;\n      }\n      if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\n        this._isPointerDown = false;\n      }\n    });\n    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\n      if (this._reachTargetAlpha()) {\n        return;\n      }\n      const now = PrecisionDate.Now;\n      let dt = 0;\n      if (this._lastFrameTime != null) {\n        dt = now - this._lastFrameTime;\n      }\n      this._lastFrameTime = now;\n      // Stop the animation if there is user interaction and the animation should stop for this interaction\n      this._applyUserInteraction();\n      const timeToRotation = now - this._lastInteractionTime - this._idleRotationWaitTime;\n      const scale = Math.max(Math.min(timeToRotation / this._idleRotationSpinupTime, 1), 0);\n      this._cameraRotationSpeed = this._idleRotationSpeed * scale;\n      // Step camera rotation by rotation speed\n      if (this._attachedCamera) {\n        this._attachedCamera.alpha -= this._cameraRotationSpeed * (dt / 1000);\n      }\n    });\n  }\n  /**\n   * Detaches the behavior from its current arc rotate camera.\n   */\n  detach() {\n    if (!this._attachedCamera) {\n      return;\n    }\n    const scene = this._attachedCamera.getScene();\n    if (this._onPrePointerObservableObserver) {\n      scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\n    }\n    this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\n    this._attachedCamera = null;\n  }\n  /**\n   * Force-reset the last interaction time\n   * @param customTime an optional time that will be used instead of the current last interaction time. For example `Date.now()`\n   */\n  resetLastInteractionTime(customTime) {\n    this._lastInteractionTime = customTime !== null && customTime !== void 0 ? customTime : PrecisionDate.Now;\n  }\n  /**\n   * Returns true if camera alpha reaches the target alpha\n   * @returns true if camera alpha reaches the target alpha\n   */\n  _reachTargetAlpha() {\n    if (this._attachedCamera && this.targetAlpha) {\n      return Math.abs(this._attachedCamera.alpha - this.targetAlpha) < Epsilon;\n    }\n    return false;\n  }\n  /**\n   * Returns true if user is scrolling.\n   * @returns true if user is scrolling.\n   */\n  _userIsZooming() {\n    if (!this._attachedCamera) {\n      return false;\n    }\n    return this._attachedCamera.inertialRadiusOffset !== 0;\n  }\n  _shouldAnimationStopForInteraction() {\n    if (!this._attachedCamera) {\n      return false;\n    }\n    let zoomHasHitLimit = false;\n    if (this._lastFrameRadius === this._attachedCamera.radius && this._attachedCamera.inertialRadiusOffset !== 0) {\n      zoomHasHitLimit = true;\n    }\n    // Update the record of previous radius - works as an approx. indicator of hitting radius limits\n    this._lastFrameRadius = this._attachedCamera.radius;\n    return this._zoomStopsAnimation ? zoomHasHitLimit : this._userIsZooming();\n  }\n  /**\n   *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\n   */\n  _applyUserInteraction() {\n    if (this._userIsMoving() && !this._shouldAnimationStopForInteraction()) {\n      this._lastInteractionTime = PrecisionDate.Now;\n    }\n  }\n  // Tools\n  _userIsMoving() {\n    if (!this._attachedCamera) {\n      return false;\n    }\n    return this._attachedCamera.inertialAlphaOffset !== 0 || this._attachedCamera.inertialBetaOffset !== 0 || this._attachedCamera.inertialRadiusOffset !== 0 || this._attachedCamera.inertialPanningX !== 0 || this._attachedCamera.inertialPanningY !== 0 || this._isPointerDown;\n  }\n}","map":{"version":3,"names":["PointerEventTypes","PrecisionDate","Epsilon","AutoRotationBehavior","constructor","_zoomStopsAnimation","_idleRotationSpeed","_idleRotationWaitTime","_idleRotationSpinupTime","targetAlpha","_isPointerDown","_lastFrameTime","_lastInteractionTime","Infinity","_cameraRotationSpeed","_lastFrameRadius","name","zoomStopsAnimation","flag","idleRotationSpeed","speed","idleRotationWaitTime","time","idleRotationSpinupTime","rotationInProgress","Math","abs","init","attach","camera","_attachedCamera","scene","getScene","_onPrePointerObservableObserver","onPrePointerObservable","add","pointerInfoPre","type","POINTERDOWN","POINTERUP","_onAfterCheckInputsObserver","onAfterCheckInputsObservable","_reachTargetAlpha","now","Now","dt","_applyUserInteraction","timeToRotation","scale","max","min","alpha","detach","remove","resetLastInteractionTime","customTime","_userIsZooming","inertialRadiusOffset","_shouldAnimationStopForInteraction","zoomHasHitLimit","radius","_userIsMoving","inertialAlphaOffset","inertialBetaOffset","inertialPanningX","inertialPanningY"],"sources":["../../../../../dev/core/src/Behaviors/Cameras/autoRotationBehavior.ts"],"sourcesContent":["import type { Behavior } from \"../../Behaviors/behavior\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { PointerInfoPre } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\n\r\n/**\r\n * The autoRotation behavior (AutoRotationBehavior) is designed to create a smooth rotation of an ArcRotateCamera when there is no user interaction.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#autorotation-behavior\r\n */\r\nexport class AutoRotationBehavior implements Behavior<ArcRotateCamera> {\r\n    /**\r\n     * Gets the name of the behavior.\r\n     */\r\n    public get name(): string {\r\n        return \"AutoRotation\";\r\n    }\r\n\r\n    private _zoomStopsAnimation = false;\r\n    private _idleRotationSpeed = 0.05;\r\n    private _idleRotationWaitTime = 2000;\r\n    private _idleRotationSpinupTime = 2000;\r\n\r\n    public targetAlpha: Nullable<number> = null;\r\n\r\n    /**\r\n     * Sets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public set zoomStopsAnimation(flag: boolean) {\r\n        this._zoomStopsAnimation = flag;\r\n    }\r\n\r\n    /**\r\n     * Gets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public get zoomStopsAnimation(): boolean {\r\n        return this._zoomStopsAnimation;\r\n    }\r\n\r\n    /**\r\n     * Sets the default speed at which the camera rotates around the model.\r\n     */\r\n    public set idleRotationSpeed(speed: number) {\r\n        this._idleRotationSpeed = speed;\r\n    }\r\n\r\n    /**\r\n     * Gets the default speed at which the camera rotates around the model.\r\n     */\r\n    public get idleRotationSpeed() {\r\n        return this._idleRotationSpeed;\r\n    }\r\n\r\n    /**\r\n     * Sets the time (in milliseconds) to wait after user interaction before the camera starts rotating.\r\n     */\r\n    public set idleRotationWaitTime(time: number) {\r\n        this._idleRotationWaitTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the time (milliseconds) to wait after user interaction before the camera starts rotating.\r\n     */\r\n    public get idleRotationWaitTime() {\r\n        return this._idleRotationWaitTime;\r\n    }\r\n\r\n    /**\r\n     * Sets the time (milliseconds) to take to spin up to the full idle rotation speed.\r\n     */\r\n    public set idleRotationSpinupTime(time: number) {\r\n        this._idleRotationSpinupTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the time (milliseconds) to take to spin up to the full idle rotation speed.\r\n     */\r\n    public get idleRotationSpinupTime() {\r\n        return this._idleRotationSpinupTime;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating if the camera is currently rotating because of this behavior\r\n     */\r\n    public get rotationInProgress(): boolean {\r\n        return Math.abs(this._cameraRotationSpeed) > 0;\r\n    }\r\n\r\n    // Default behavior functions\r\n    private _onPrePointerObservableObserver: Nullable<Observer<PointerInfoPre>>;\r\n    private _onAfterCheckInputsObserver: Nullable<Observer<Camera>>;\r\n    private _attachedCamera: Nullable<ArcRotateCamera>;\r\n    private _isPointerDown = false;\r\n    private _lastFrameTime: Nullable<number> = null;\r\n    private _lastInteractionTime = -Infinity;\r\n    private _cameraRotationSpeed: number = 0;\r\n\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    public init(): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    public attach(camera: ArcRotateCamera): void {\r\n        this._attachedCamera = camera;\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        this._onPrePointerObservableObserver = scene.onPrePointerObservable.add((pointerInfoPre) => {\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\r\n                this._isPointerDown = true;\r\n                return;\r\n            }\r\n\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\r\n                this._isPointerDown = false;\r\n            }\r\n        });\r\n\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\r\n            if (this._reachTargetAlpha()) {\r\n                return;\r\n            }\r\n            const now = PrecisionDate.Now;\r\n            let dt = 0;\r\n            if (this._lastFrameTime != null) {\r\n                dt = now - this._lastFrameTime;\r\n            }\r\n            this._lastFrameTime = now;\r\n\r\n            // Stop the animation if there is user interaction and the animation should stop for this interaction\r\n            this._applyUserInteraction();\r\n\r\n            const timeToRotation = now - this._lastInteractionTime - this._idleRotationWaitTime;\r\n            const scale = Math.max(Math.min(timeToRotation / this._idleRotationSpinupTime, 1), 0);\r\n            this._cameraRotationSpeed = this._idleRotationSpeed * scale;\r\n\r\n            // Step camera rotation by rotation speed\r\n            if (this._attachedCamera) {\r\n                this._attachedCamera.alpha -= this._cameraRotationSpeed * (dt / 1000);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    public detach(): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        if (this._onPrePointerObservableObserver) {\r\n            scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\r\n        }\r\n\r\n        this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        this._attachedCamera = null;\r\n    }\r\n\r\n    /**\r\n     * Force-reset the last interaction time\r\n     * @param customTime an optional time that will be used instead of the current last interaction time. For example `Date.now()`\r\n     */\r\n    public resetLastInteractionTime(customTime?: number): void {\r\n        this._lastInteractionTime = customTime ?? PrecisionDate.Now;\r\n    }\r\n\r\n    /**\r\n     * Returns true if camera alpha reaches the target alpha\r\n     * @returns true if camera alpha reaches the target alpha\r\n     */\r\n    private _reachTargetAlpha(): boolean {\r\n        if (this._attachedCamera && this.targetAlpha) {\r\n            return Math.abs(this._attachedCamera.alpha - this.targetAlpha) < Epsilon;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if user is scrolling.\r\n     * @returns true if user is scrolling.\r\n     */\r\n    private _userIsZooming(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n        return this._attachedCamera.inertialRadiusOffset !== 0;\r\n    }\r\n\r\n    private _lastFrameRadius = 0;\r\n    private _shouldAnimationStopForInteraction(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        let zoomHasHitLimit = false;\r\n        if (this._lastFrameRadius === this._attachedCamera.radius && this._attachedCamera.inertialRadiusOffset !== 0) {\r\n            zoomHasHitLimit = true;\r\n        }\r\n\r\n        // Update the record of previous radius - works as an approx. indicator of hitting radius limits\r\n        this._lastFrameRadius = this._attachedCamera.radius;\r\n        return this._zoomStopsAnimation ? zoomHasHitLimit : this._userIsZooming();\r\n    }\r\n\r\n    /**\r\n     *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\r\n     */\r\n    private _applyUserInteraction(): void {\r\n        if (this._userIsMoving() && !this._shouldAnimationStopForInteraction()) {\r\n            this._lastInteractionTime = PrecisionDate.Now;\r\n        }\r\n    }\r\n\r\n    // Tools\r\n    private _userIsMoving(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            this._attachedCamera.inertialAlphaOffset !== 0 ||\r\n            this._attachedCamera.inertialBetaOffset !== 0 ||\r\n            this._attachedCamera.inertialRadiusOffset !== 0 ||\r\n            this._attachedCamera.inertialPanningX !== 0 ||\r\n            this._attachedCamera.inertialPanningY !== 0 ||\r\n            this._isPointerDown\r\n        );\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}