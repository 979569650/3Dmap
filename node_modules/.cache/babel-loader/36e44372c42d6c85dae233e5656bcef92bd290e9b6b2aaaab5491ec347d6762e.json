{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\n/**\n * Defines a block used to teleport a value to an endpoint\n */\nexport class NodeMaterialTeleportInBlock extends NodeMaterialBlock {\n  /** Gets the list of attached endpoints */\n  get endpoints() {\n    return this._endpoints;\n  }\n  /**\n   * Create a new NodeMaterialTeleportInBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Neutral);\n    this._endpoints = [];\n    this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"NodeMaterialTeleportInBlock\";\n  }\n  /**\n   * Gets the input component\n   */\n  get input() {\n    return this._inputs[0];\n  }\n  /** Gets a boolean indicating that this connection will be used in the fragment shader */\n  isConnectedInFragmentShader() {\n    return this.endpoints.some(e => e.output.isConnectedInFragmentShader);\n  }\n  _dumpCode(uniqueNames, alreadyDumped) {\n    let codeString = super._dumpCode(uniqueNames, alreadyDumped);\n    for (const endpoint of this.endpoints) {\n      if (alreadyDumped.indexOf(endpoint) === -1) {\n        codeString += endpoint._dumpCode(uniqueNames, alreadyDumped);\n      }\n    }\n    return codeString;\n  }\n  /**\n   * Checks if the current block is an ancestor of a given block\n   * @param block defines the potential descendant block to check\n   * @returns true if block is a descendant\n   */\n  isAnAncestorOf(block) {\n    for (const endpoint of this.endpoints) {\n      if (endpoint === block) {\n        return true;\n      }\n      if (endpoint.isAnAncestorOf(block)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Add an enpoint to this block\n   * @param endpoint define the endpoint to attach to\n   */\n  attachToEndpoint(endpoint) {\n    endpoint.detach();\n    this._endpoints.push(endpoint);\n    endpoint._entryPoint = this;\n    endpoint._outputs[0]._typeConnectionSource = this._inputs[0];\n    endpoint._tempEntryPointUniqueId = null;\n    endpoint.name = \"> \" + this.name;\n  }\n  /**\n   * Remove enpoint from this block\n   * @param endpoint define the endpoint to remove\n   */\n  detachFromEndpoint(endpoint) {\n    const index = this._endpoints.indexOf(endpoint);\n    if (index !== -1) {\n      this._endpoints.splice(index, 1);\n      endpoint._outputs[0]._typeConnectionSource = null;\n      endpoint._entryPoint = null;\n    }\n  }\n  /**\n   * Release resources\n   */\n  dispose() {\n    super.dispose();\n    for (const endpoint of this._endpoints) {\n      this.detachFromEndpoint(endpoint);\n    }\n    this._endpoints = [];\n  }\n}\nRegisterClass(\"BABYLON.NodeMaterialTeleportInBlock\", NodeMaterialTeleportInBlock);","map":{"version":3,"names":["RegisterClass","NodeMaterialBlockConnectionPointTypes","NodeMaterialBlockTargets","NodeMaterialBlock","NodeMaterialTeleportInBlock","endpoints","_endpoints","constructor","name","Neutral","registerInput","AutoDetect","getClassName","input","_inputs","isConnectedInFragmentShader","some","e","output","_dumpCode","uniqueNames","alreadyDumped","codeString","endpoint","indexOf","isAnAncestorOf","block","attachToEndpoint","detach","push","_entryPoint","_outputs","_typeConnectionSource","_tempEntryPointUniqueId","detachFromEndpoint","index","splice","dispose"],"sources":["../../../../../../../dev/core/src/Materials/Node/Blocks/Teleport/teleportInBlock.ts"],"sourcesContent":["import { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { NodeMaterialTeleportOutBlock } from \"./teleportOutBlock\";\r\n\r\n/**\r\n * Defines a block used to teleport a value to an endpoint\r\n */\r\nexport class NodeMaterialTeleportInBlock extends NodeMaterialBlock {\r\n    private _endpoints: NodeMaterialTeleportOutBlock[] = [];\r\n\r\n    /** Gets the list of attached endpoints */\r\n    public get endpoints() {\r\n        return this._endpoints;\r\n    }\r\n\r\n    /**\r\n     * Create a new NodeMaterialTeleportInBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"NodeMaterialTeleportInBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection will be used in the fragment shader */\r\n    public isConnectedInFragmentShader() {\r\n        return this.endpoints.some((e) => e.output.isConnectedInFragmentShader);\r\n    }\r\n\r\n    public _dumpCode(uniqueNames: string[], alreadyDumped: NodeMaterialBlock[]) {\r\n        let codeString = super._dumpCode(uniqueNames, alreadyDumped);\r\n\r\n        for (const endpoint of this.endpoints) {\r\n            if (alreadyDumped.indexOf(endpoint) === -1) {\r\n                codeString += endpoint._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Checks if the current block is an ancestor of a given block\r\n     * @param block defines the potential descendant block to check\r\n     * @returns true if block is a descendant\r\n     */\r\n    public isAnAncestorOf(block: NodeMaterialBlock): boolean {\r\n        for (const endpoint of this.endpoints) {\r\n            if (endpoint === block) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.isAnAncestorOf(block)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Add an enpoint to this block\r\n     * @param endpoint define the endpoint to attach to\r\n     */\r\n    public attachToEndpoint(endpoint: NodeMaterialTeleportOutBlock) {\r\n        endpoint.detach();\r\n\r\n        this._endpoints.push(endpoint);\r\n        endpoint._entryPoint = this;\r\n        endpoint._outputs[0]._typeConnectionSource = this._inputs[0];\r\n        endpoint._tempEntryPointUniqueId = null;\r\n        endpoint.name = \"> \" + this.name;\r\n    }\r\n\r\n    /**\r\n     * Remove enpoint from this block\r\n     * @param endpoint define the endpoint to remove\r\n     */\r\n    public detachFromEndpoint(endpoint: NodeMaterialTeleportOutBlock) {\r\n        const index = this._endpoints.indexOf(endpoint);\r\n\r\n        if (index !== -1) {\r\n            this._endpoints.splice(index, 1);\r\n            endpoint._outputs[0]._typeConnectionSource = null;\r\n            endpoint._entryPoint = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        super.dispose();\r\n\r\n        for (const endpoint of this._endpoints) {\r\n            this.detachFromEndpoint(endpoint);\r\n        }\r\n\r\n        this._endpoints = [];\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.NodeMaterialTeleportInBlock\", NodeMaterialTeleportInBlock);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}