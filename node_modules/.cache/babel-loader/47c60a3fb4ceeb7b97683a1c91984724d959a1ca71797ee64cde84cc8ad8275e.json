{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"@babylonjs/core/tslib.es6.js\";\nimport { Observable } from \"@babylonjs/core/Misc/observable.js\";\nimport { Control } from \"./control.js\";\nimport { ValueAndUnit } from \"../valueAndUnit.js\";\nimport { RegisterClass } from \"@babylonjs/core/Misc/typeStore.js\";\nimport { InputText } from \"./inputText.js\";\nimport { serialize } from \"@babylonjs/core/Misc/decorators.js\";\n/**\n * Class used to create input text control\n */\nexport class InputTextArea extends InputText {\n  /**\n   * Gets or sets outlineWidth of the text to display\n   */\n  get outlineWidth() {\n    return this._outlineWidth;\n  }\n  /**\n   * Gets or sets outlineWidth of the text to display\n   */\n  set outlineWidth(value) {\n    if (this._outlineWidth === value) {\n      return;\n    }\n    this._outlineWidth = value;\n    this._markAsDirty();\n  }\n  /**\n   * Gets or sets outlineColor of the text to display\n   */\n  get outlineColor() {\n    return this._outlineColor;\n  }\n  /**\n   * Gets or sets outlineColor of the text to display\n   */\n  set outlineColor(value) {\n    if (this._outlineColor === value) {\n      return;\n    }\n    this._outlineColor = value;\n    this._markAsDirty();\n  }\n  /** Gets or sets a boolean indicating if the control can auto stretch its height to adapt to the text */\n  get autoStretchHeight() {\n    return this._autoStretchHeight;\n  }\n  set autoStretchHeight(value) {\n    if (this._autoStretchHeight === value) {\n      return;\n    }\n    this._autoStretchHeight = value;\n    this._markAsDirty();\n  }\n  set height(value) {\n    this.fixedRatioMasterIsWidth = false;\n    if (this._height.toString(this._host) === value) {\n      return;\n    }\n    if (this._height.fromString(value)) {\n      this._markAsDirty();\n    }\n    this._autoStretchHeight = false;\n  }\n  get maxHeight() {\n    return this._maxHeight.toString(this._host);\n  }\n  /** Gets the maximum width allowed by the control in pixels */\n  get maxHeightInPixels() {\n    return this._maxHeight.getValueInPixel(this._host, this._cachedParentMeasure.height);\n  }\n  set maxHeight(value) {\n    if (this._maxHeight.toString(this._host) === value) {\n      return;\n    }\n    if (this._maxHeight.fromString(value)) {\n      this._markAsDirty();\n    }\n  }\n  /**\n   * Creates a new InputTextArea\n   * @param name defines the control name\n   * @param text defines the text of the control\n   */\n  constructor(name, text = \"\") {\n    super(name);\n    this.name = name;\n    this._textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this._textVerticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\n    this._lineSpacing = new ValueAndUnit(0);\n    this._outlineWidth = 0;\n    this._outlineColor = \"white\";\n    this._maxHeight = new ValueAndUnit(1, ValueAndUnit.UNITMODE_PERCENTAGE, false);\n    /**\n     * An event triggered after the text was broken up into lines\n     */\n    this.onLinesReadyObservable = new Observable();\n    this.text = text;\n    this.isPointerBlocker = true;\n    this.onLinesReadyObservable.add(() => this._updateCursorPosition());\n    this._highlightCursorInfo = {\n      initialStartIndex: -1,\n      initialRelativeStartIndex: -1,\n      initialLineIndex: -1\n    };\n    this._cursorInfo = {\n      globalStartIndex: 0,\n      globalEndIndex: 0,\n      relativeEndIndex: 0,\n      relativeStartIndex: 0,\n      currentLineIndex: 0\n    };\n  }\n  _getTypeName() {\n    return \"InputTextArea\";\n  }\n  /**\n   * Handles the keyboard event\n   * @param evt Defines the KeyboardEvent\n   */\n  processKeyboard(evt) {\n    // process pressed key\n    this.alternativeProcessKey(evt.code, evt.key, evt);\n    this.onKeyboardEventProcessedObservable.notifyObservers(evt);\n  }\n  /**\n   * Process the last keyboard input\n   *\n   * @param code The ascii input number\n   * @param key The key string representation\n   * @param evt The keyboard event emits with input\n   * @internal\n   */\n  alternativeProcessKey(code, key, evt) {\n    //return if clipboard event keys (i.e -ctr/cmd + c,v,x)\n    if (evt && (evt.ctrlKey || evt.metaKey) && (code === \"KeyC\" || code === \"KeyV\" || code === \"KeyX\")) {\n      return;\n    }\n    // Specific cases\n    switch (code) {\n      case \"KeyA\":\n        // A - select all\n        if (evt && (evt.ctrlKey || evt.metaKey)) {\n          this._selectAllText();\n          evt.preventDefault();\n          return;\n        }\n        break;\n      case \"Period\":\n        //SLASH\n        if (evt && evt.shiftKey) {\n          evt.preventDefault();\n        }\n        break;\n      case \"Backspace\":\n        // BACKSPACE\n        if (!this._isTextHighlightOn && this._cursorInfo.globalStartIndex > 0) {\n          this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\n          this._cursorInfo.globalStartIndex--;\n        }\n        this._textWrapper.removePart(this._cursorInfo.globalStartIndex, this._cursorInfo.globalEndIndex);\n        this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\n        if (evt) {\n          evt.preventDefault();\n        }\n        this._blinkIsEven = false;\n        this._isTextHighlightOn = false;\n        this._textHasChanged();\n        break;\n      case \"Delete\":\n        // DELETE\n        if (!this._isTextHighlightOn && this._cursorInfo.globalEndIndex < this.text.length) {\n          this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex + 1;\n        }\n        this._textWrapper.removePart(this._cursorInfo.globalStartIndex, this._cursorInfo.globalEndIndex);\n        this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\n        if (evt) {\n          evt.preventDefault();\n        }\n        this._blinkIsEven = false;\n        this._isTextHighlightOn = false;\n        this._textHasChanged();\n        break;\n      case \"Enter\":\n        // RETURN\n        this._textWrapper.removePart(this._cursorInfo.globalStartIndex, this._cursorInfo.globalEndIndex, \"\\n\");\n        this._cursorInfo.globalStartIndex++;\n        this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\n        this._blinkIsEven = false;\n        this._isTextHighlightOn = false;\n        this._textHasChanged();\n        return;\n      case \"End\":\n        // END\n        this._cursorInfo.globalStartIndex = this.text.length;\n        this._blinkIsEven = false;\n        this._isTextHighlightOn = false;\n        this._markAsDirty();\n        return;\n      case \"Home\":\n        // HOME\n        this._cursorInfo.globalStartIndex = 0;\n        this._blinkIsEven = false;\n        this._isTextHighlightOn = false;\n        this._markAsDirty();\n        return;\n      case \"ArrowLeft\":\n        // LEFT\n        this._markAsDirty();\n        if (evt && evt.shiftKey) {\n          // shift + ctrl/cmd + <-\n          if (evt.ctrlKey || evt.metaKey) {\n            // Go to line's start by substract the relativeStartIndex to the globalStartIndex\n            this._cursorInfo.globalStartIndex -= this._cursorInfo.relativeStartIndex;\n            this._cursorInfo.globalEndIndex = this._highlightCursorInfo.initialStartIndex;\n          }\n          // store the starting point\n          if (!this._isTextHighlightOn) {\n            this._highlightCursorInfo.initialLineIndex = this._cursorInfo.currentLineIndex;\n            this._highlightCursorInfo.initialStartIndex = this._cursorInfo.globalStartIndex;\n            this._highlightCursorInfo.initialRelativeStartIndex = this._cursorInfo.relativeStartIndex;\n            this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\n            this._cursorInfo.globalStartIndex--;\n            this._isTextHighlightOn = true;\n          } else {\n            if (this._cursorInfo.globalEndIndex > this._highlightCursorInfo.initialStartIndex) {\n              this._cursorInfo.globalEndIndex--;\n            } else {\n              this._cursorInfo.globalStartIndex--;\n            }\n          }\n          this._blinkIsEven = true;\n          evt.preventDefault();\n          return;\n        }\n        if (this._isTextHighlightOn) {\n          this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\n        } else if (evt && (evt.ctrlKey || evt.metaKey)) {\n          // ctr + <-\n          this._cursorInfo.globalStartIndex -= this._cursorInfo.relativeStartIndex;\n          evt.preventDefault();\n        } else if (this._cursorInfo.globalStartIndex > 0) {\n          this._cursorInfo.globalStartIndex--;\n        }\n        // update the cursor\n        this._blinkIsEven = false;\n        this._isTextHighlightOn = false;\n        return;\n      case \"ArrowRight\":\n        // RIGHT\n        this._markAsDirty();\n        if (evt && evt.shiftKey) {\n          // shift + ctrl/cmd + ->\n          if (evt.ctrlKey || evt.metaKey) {\n            const rightDelta = this._lines[this._cursorInfo.currentLineIndex].text.length - this._cursorInfo.relativeEndIndex - 1;\n            this._cursorInfo.globalEndIndex += rightDelta;\n            this._cursorInfo.globalStartIndex = this._highlightCursorInfo.initialStartIndex;\n          }\n          // store the starting point\n          if (!this._isTextHighlightOn) {\n            this._highlightCursorInfo.initialLineIndex = this._cursorInfo.currentLineIndex;\n            this._highlightCursorInfo.initialStartIndex = this._cursorInfo.globalStartIndex;\n            this._highlightCursorInfo.initialRelativeStartIndex = this._cursorInfo.relativeStartIndex;\n            this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\n            this._cursorInfo.globalEndIndex++;\n            this._isTextHighlightOn = true;\n          } else {\n            if (this._cursorInfo.globalStartIndex < this._highlightCursorInfo.initialStartIndex) {\n              this._cursorInfo.globalStartIndex++;\n            } else {\n              this._cursorInfo.globalEndIndex++;\n            }\n          }\n          this._blinkIsEven = true;\n          evt.preventDefault();\n          return;\n        }\n        if (this._isTextHighlightOn) {\n          this._cursorInfo.globalStartIndex = this._cursorInfo.globalEndIndex;\n        } else if (evt && (evt.ctrlKey || evt.metaKey)) {\n          //ctr + ->\n          const rightDelta = this._lines[this._cursorInfo.currentLineIndex].text.length - this._cursorInfo.relativeEndIndex;\n          this._cursorInfo.globalStartIndex += rightDelta;\n        } else if (this._cursorInfo.globalStartIndex < this.text.length) {\n          this._cursorInfo.globalStartIndex++;\n        }\n        // update the cursor\n        this._blinkIsEven = false;\n        this._isTextHighlightOn = false;\n        return;\n      case \"ArrowUp\":\n        // UP\n        // update the cursor\n        this._blinkIsEven = false;\n        if (evt) {\n          if (evt.shiftKey) {\n            if (!this._isTextHighlightOn) {\n              this._highlightCursorInfo.initialLineIndex = this._cursorInfo.currentLineIndex;\n              this._highlightCursorInfo.initialStartIndex = this._cursorInfo.globalStartIndex;\n              this._highlightCursorInfo.initialRelativeStartIndex = this._cursorInfo.relativeStartIndex;\n            }\n            this._isTextHighlightOn = true;\n            this._blinkIsEven = true;\n          } else {\n            this._isTextHighlightOn = false;\n          }\n          evt.preventDefault();\n        }\n        if (this._cursorInfo.currentLineIndex === 0) {\n          // First line\n          this._cursorInfo.globalStartIndex = 0;\n        } else {\n          const currentLine = this._lines[this._cursorInfo.currentLineIndex];\n          const upperLine = this._lines[this._cursorInfo.currentLineIndex - 1];\n          let tmpIndex = 0;\n          let relativeIndex = 0;\n          if (!this._isTextHighlightOn || this._cursorInfo.currentLineIndex < this._highlightCursorInfo.initialLineIndex) {\n            tmpIndex = this._cursorInfo.globalStartIndex;\n            relativeIndex = this._cursorInfo.relativeStartIndex;\n          } else {\n            tmpIndex = this._cursorInfo.globalEndIndex;\n            relativeIndex = this._cursorInfo.relativeEndIndex;\n          }\n          const currentText = currentLine.text.substr(0, relativeIndex);\n          const currentWidth = this._contextForBreakLines.measureText(currentText).width;\n          let upperWidth = 0;\n          let previousWidth = 0;\n          tmpIndex -= relativeIndex; // Start of current line\n          tmpIndex -= upperLine.text.length + upperLine.lineEnding.length; // Start of upper line\n          let upperLineRelativeIndex = 0;\n          while (upperWidth < currentWidth && upperLineRelativeIndex < upperLine.text.length) {\n            tmpIndex++;\n            upperLineRelativeIndex++;\n            previousWidth = Math.abs(currentWidth - upperWidth);\n            upperWidth = this._contextForBreakLines.measureText(upperLine.text.substr(0, upperLineRelativeIndex)).width;\n          }\n          // Find closest move\n          if (Math.abs(currentWidth - upperWidth) > previousWidth && upperLineRelativeIndex > 0) {\n            tmpIndex--;\n          }\n          if (!this._isTextHighlightOn) {\n            this._cursorInfo.globalStartIndex = tmpIndex;\n          } else if (this._cursorInfo.currentLineIndex <= this._highlightCursorInfo.initialLineIndex) {\n            this._cursorInfo.globalStartIndex = tmpIndex;\n            this._cursorInfo.globalEndIndex = this._highlightCursorInfo.initialStartIndex;\n            this._cursorInfo.relativeEndIndex = this._highlightCursorInfo.initialRelativeStartIndex;\n          } else {\n            this._cursorInfo.globalEndIndex = tmpIndex;\n          }\n        }\n        this._markAsDirty();\n        return;\n      case \"ArrowDown\":\n        // DOWN\n        // update the cursor\n        this._blinkIsEven = false;\n        if (evt) {\n          if (evt.shiftKey) {\n            if (!this._isTextHighlightOn) {\n              this._highlightCursorInfo.initialLineIndex = this._cursorInfo.currentLineIndex;\n              this._highlightCursorInfo.initialStartIndex = this._cursorInfo.globalStartIndex;\n              this._highlightCursorInfo.initialRelativeStartIndex = this._cursorInfo.relativeStartIndex;\n            }\n            this._isTextHighlightOn = true;\n            this._blinkIsEven = true;\n          } else {\n            this._isTextHighlightOn = false;\n          }\n          evt.preventDefault();\n        }\n        if (this._cursorInfo.currentLineIndex === this._lines.length - 1) {\n          // Last line\n          this._cursorInfo.globalStartIndex = this.text.length;\n        } else {\n          const currentLine = this._lines[this._cursorInfo.currentLineIndex];\n          const underLine = this._lines[this._cursorInfo.currentLineIndex + 1];\n          let tmpIndex = 0;\n          let relativeIndex = 0;\n          if (!this._isTextHighlightOn || this._cursorInfo.currentLineIndex < this._highlightCursorInfo.initialLineIndex) {\n            tmpIndex = this._cursorInfo.globalStartIndex;\n            relativeIndex = this._cursorInfo.relativeStartIndex;\n          } else {\n            tmpIndex = this._cursorInfo.globalEndIndex;\n            relativeIndex = this._cursorInfo.relativeEndIndex;\n          }\n          const currentText = currentLine.text.substr(0, relativeIndex);\n          const currentWidth = this._contextForBreakLines.measureText(currentText).width;\n          let underWidth = 0;\n          let previousWidth = 0;\n          tmpIndex += currentLine.text.length - relativeIndex + currentLine.lineEnding.length; // Start of current line\n          let underLineRelativeIndex = 0;\n          while (underWidth < currentWidth && underLineRelativeIndex < underLine.text.length) {\n            tmpIndex++;\n            underLineRelativeIndex++;\n            previousWidth = Math.abs(currentWidth - underWidth);\n            underWidth = this._contextForBreakLines.measureText(underLine.text.substr(0, underLineRelativeIndex)).width;\n          }\n          // Find closest move\n          if (Math.abs(currentWidth - underWidth) > previousWidth && underLineRelativeIndex > 0) {\n            tmpIndex--;\n          }\n          if (!this._isTextHighlightOn) {\n            this._cursorInfo.globalStartIndex = tmpIndex;\n          } else if (this._cursorInfo.currentLineIndex < this._highlightCursorInfo.initialLineIndex) {\n            this._cursorInfo.globalStartIndex = tmpIndex;\n            if (this._cursorInfo.globalStartIndex > this._cursorInfo.globalEndIndex) {\n              this._cursorInfo.globalEndIndex += this._cursorInfo.globalStartIndex;\n              this._cursorInfo.globalStartIndex = this._cursorInfo.globalEndIndex - this._cursorInfo.globalStartIndex;\n              this._cursorInfo.globalEndIndex -= this._cursorInfo.globalStartIndex;\n            }\n          } else {\n            this._cursorInfo.globalEndIndex = tmpIndex;\n            this._cursorInfo.globalStartIndex = this._highlightCursorInfo.initialStartIndex;\n          }\n        }\n        this._markAsDirty();\n        return;\n    }\n    // Printable characters\n    if ((key === null || key === void 0 ? void 0 : key.length) === 1) {\n      evt === null || evt === void 0 ? void 0 : evt.preventDefault();\n      this._currentKey = key;\n      this.onBeforeKeyAddObservable.notifyObservers(this);\n      key = this._currentKey;\n      if (this._addKey) {\n        this._isTextHighlightOn = false;\n        this._blinkIsEven = false;\n        this._textWrapper.removePart(this._cursorInfo.globalStartIndex, this._cursorInfo.globalEndIndex, key);\n        this._cursorInfo.globalStartIndex += key.length;\n        this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\n        this._textHasChanged();\n      }\n    }\n  }\n  _parseLineWordWrap(line = \"\", width, context) {\n    const lines = [];\n    const words = line.split(\" \");\n    let lineWidth = 0;\n    for (let n = 0; n < words.length; n++) {\n      const testLine = n > 0 ? line + \" \" + words[n] : words[0];\n      const metrics = context.measureText(testLine);\n      const testWidth = metrics.width;\n      if (testWidth > width) {\n        if (n > 0) {\n          // Avoid first word duplication if of too long\n          lineWidth = context.measureText(line).width;\n          lines.push({\n            text: line,\n            width: lineWidth,\n            lineEnding: \" \"\n          });\n        }\n        line = words[n];\n        let flushedLine = \"\";\n        line.split(\"\").map(char => {\n          if (context.measureText(flushedLine + char).width > width) {\n            lines.push({\n              text: flushedLine,\n              width: context.measureText(flushedLine).width,\n              lineEnding: \"\"\n            });\n            flushedLine = \"\";\n          }\n          flushedLine += char;\n        });\n        line = flushedLine;\n        // Measure remaining characters\n        lineWidth = context.measureText(line).width;\n      } else {\n        lineWidth = testWidth;\n        line = testLine;\n      }\n    }\n    lines.push({\n      text: line,\n      width: lineWidth,\n      lineEnding: \" \"\n    });\n    return lines;\n  }\n  _breakLines(refWidth, context) {\n    const lines = [];\n    const _lines = this.text.split(\"\\n\");\n    if (this.clipContent) {\n      for (const _line of _lines) {\n        lines.push(...this._parseLineWordWrap(_line, refWidth, context));\n      }\n    } else {\n      for (const _line of _lines) {\n        lines.push(this._parseLine(_line, context));\n      }\n    }\n    lines[lines.length - 1].lineEnding = \"\\n\";\n    return lines;\n  }\n  _parseLine(line = \"\", context) {\n    return {\n      text: line,\n      width: context.measureText(line).width,\n      lineEnding: \" \"\n    };\n  }\n  /**\n   * Processing of child right before the parent measurement update\n   *\n   * @param parentMeasure The parent measure\n   * @param context The rendering canvas\n   * @internal\n   */\n  _preMeasure(parentMeasure, context) {\n    if (!this._fontOffset || this._wasDirty) {\n      this._fontOffset = Control._GetFontOffset(context.font);\n    }\n    let text = this._beforeRenderText(this._textWrapper).text;\n    // placeholder conditions and color setting\n    if (!this._isFocused && !this.text && this._placeholderText) {\n      text = this._placeholderText;\n      if (this._placeholderColor) {\n        context.fillStyle = this._placeholderColor;\n      }\n    }\n    // measures the textlength -> this.measure.width\n    this._textWidth = context.measureText(text).width;\n    // we double up the margin width\n    const marginWidth = this._margin.getValueInPixel(this._host, parentMeasure.width) * 2;\n    if (this._autoStretchWidth) {\n      const tmpLines = text.split(\"\\n\");\n      const longerString = tmpLines.reduce((acc, val) => {\n        const valueLength = context.measureText(val).width;\n        const accLength = context.measureText(acc).width;\n        return valueLength > accLength ? val : acc;\n      }, \"\");\n      const longerStringWidth = context.measureText(longerString).width;\n      this.width = Math.min(this._maxWidth.getValueInPixel(this._host, parentMeasure.width), longerStringWidth + marginWidth) + \"px\";\n      this.autoStretchWidth = true;\n    }\n    this._availableWidth = this._width.getValueInPixel(this._host, parentMeasure.width) - marginWidth;\n    // Prepare lines\n    this._lines = this._breakLines(this._availableWidth, context);\n    // can we find a cleaner implementation here?\n    this._contextForBreakLines = context;\n    if (this._autoStretchHeight) {\n      const textHeight = this._lines.length * this._fontOffset.height;\n      const totalHeight = textHeight + this._margin.getValueInPixel(this._host, parentMeasure.height) * 2;\n      this.height = Math.min(this._maxHeight.getValueInPixel(this._host, parentMeasure.height), totalHeight) + \"px\";\n      this._autoStretchHeight = true;\n    }\n    this._availableHeight = this._height.getValueInPixel(this._host, parentMeasure.height) - marginWidth;\n    if (this._isFocused) {\n      this._cursorInfo.currentLineIndex = 0;\n      let lineLength = this._lines[this._cursorInfo.currentLineIndex].text.length + this._lines[this._cursorInfo.currentLineIndex].lineEnding.length;\n      let tmpLength = 0;\n      while (tmpLength + lineLength <= this._cursorInfo.globalStartIndex) {\n        tmpLength += lineLength;\n        if (this._cursorInfo.currentLineIndex < this._lines.length - 1) {\n          this._cursorInfo.currentLineIndex++;\n          lineLength = this._lines[this._cursorInfo.currentLineIndex].text.length + this._lines[this._cursorInfo.currentLineIndex].lineEnding.length;\n        }\n      }\n    }\n  }\n  _computeScroll() {\n    this._clipTextLeft = this._currentMeasure.left + this._margin.getValueInPixel(this._host, this._cachedParentMeasure.width);\n    this._clipTextTop = this._currentMeasure.top + this._margin.getValueInPixel(this._host, this._cachedParentMeasure.height);\n    if (this._isFocused && this._lines[this._cursorInfo.currentLineIndex].width > this._availableWidth) {\n      const textLeft = this._clipTextLeft - this._lines[this._cursorInfo.currentLineIndex].width + this._availableWidth;\n      if (!this._scrollLeft) {\n        this._scrollLeft = textLeft;\n      }\n    } else {\n      this._scrollLeft = this._clipTextLeft;\n    }\n    if (this._isFocused && !this._autoStretchHeight) {\n      const selectedHeight = (this._cursorInfo.currentLineIndex + 1) * this._fontOffset.height;\n      const textTop = this._clipTextTop - selectedHeight;\n      if (!this._scrollTop) {\n        this._scrollTop = textTop;\n      }\n    } else {\n      this._scrollTop = this._clipTextTop;\n    }\n  }\n  /**\n   * Processing of child after the parent measurement update\n   *\n   * @internal\n   */\n  _additionalProcessing() {\n    // Flush the highlighted text each frame\n    this.highlightedText = \"\";\n    this.onLinesReadyObservable.notifyObservers(this);\n  }\n  _drawText(text, textWidth, y, context) {\n    const width = this._currentMeasure.width;\n    let x = this._scrollLeft;\n    switch (this._textHorizontalAlignment) {\n      case Control.HORIZONTAL_ALIGNMENT_LEFT:\n        x += 0;\n        break;\n      case Control.HORIZONTAL_ALIGNMENT_RIGHT:\n        x += width - textWidth;\n        break;\n      case Control.HORIZONTAL_ALIGNMENT_CENTER:\n        x += (width - textWidth) / 2;\n        break;\n    }\n    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\n      context.shadowColor = this.shadowColor;\n      context.shadowBlur = this.shadowBlur;\n      context.shadowOffsetX = this.shadowOffsetX;\n      context.shadowOffsetY = this.shadowOffsetY;\n    }\n    if (this.outlineWidth) {\n      context.strokeText(text, this._currentMeasure.left + x, y);\n    }\n    context.fillText(text, x, y);\n  }\n  /**\n   * Copy the text in the clipboard\n   *\n   * @param ev The clipboard event\n   * @internal\n   */\n  _onCopyText(ev) {\n    this._isTextHighlightOn = false;\n    //when write permission to clipbaord data is denied\n    try {\n      ev.clipboardData && ev.clipboardData.setData(\"text/plain\", this._highlightedText);\n    } catch (_a) {} //pass\n    this._host.clipboardData = this._highlightedText;\n  }\n  /**\n   * Cut the text and copy it in the clipboard\n   *\n   * @param ev The clipboard event\n   * @internal\n   */\n  _onCutText(ev) {\n    if (!this._highlightedText) {\n      return;\n    }\n    //when write permission to clipbaord data is denied\n    try {\n      ev.clipboardData && ev.clipboardData.setData(\"text/plain\", this._highlightedText);\n    } catch (_a) {} //pass\n    this._host.clipboardData = this._highlightedText;\n    this._textWrapper.removePart(this._cursorInfo.globalStartIndex, this._cursorInfo.globalEndIndex);\n    this._textHasChanged();\n  }\n  /**\n   * Paste the copied text from the clipboard\n   *\n   * @param ev The clipboard event\n   * @internal\n   */\n  _onPasteText(ev) {\n    let data = \"\";\n    if (ev.clipboardData && ev.clipboardData.types.indexOf(\"text/plain\") !== -1) {\n      data = ev.clipboardData.getData(\"text/plain\");\n    } else {\n      //get the cached data; returns blank string by default\n      data = this._host.clipboardData;\n    }\n    this._isTextHighlightOn = false;\n    this._textWrapper.removePart(this._cursorInfo.globalStartIndex, this._cursorInfo.globalEndIndex, data);\n    const deltaIndex = data.length - (this._cursorInfo.globalEndIndex - this._cursorInfo.globalStartIndex);\n    this._cursorInfo.globalStartIndex += deltaIndex;\n    this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\n    this._textHasChanged();\n  }\n  _draw(context) {\n    var _a, _b;\n    this._computeScroll();\n    this._scrollLeft = (_a = this._scrollLeft) !== null && _a !== void 0 ? _a : 0;\n    this._scrollTop = (_b = this._scrollTop) !== null && _b !== void 0 ? _b : 0;\n    context.save();\n    this._applyStates(context);\n    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\n      context.shadowColor = this.shadowColor;\n      context.shadowBlur = this.shadowBlur;\n      context.shadowOffsetX = this.shadowOffsetX;\n      context.shadowOffsetY = this.shadowOffsetY;\n    }\n    // Background\n    if (this._isFocused) {\n      if (this._focusedBackground) {\n        context.fillStyle = this._isEnabled ? this._focusedBackground : this._disabledColor;\n        context.fillRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\n      }\n    } else if (this._background) {\n      context.fillStyle = this._isEnabled ? this._background : this._disabledColor;\n      context.fillRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\n    }\n    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\n      context.shadowBlur = 0;\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n    }\n    // sets the color of the rectangle (border if background available)\n    if (this.color) {\n      context.fillStyle = this.color;\n    }\n    const height = this._currentMeasure.height;\n    const width = this._currentMeasure.width;\n    let rootY = 0;\n    switch (this._textVerticalAlignment) {\n      case Control.VERTICAL_ALIGNMENT_TOP:\n        rootY = this._fontOffset.ascent;\n        break;\n      case Control.VERTICAL_ALIGNMENT_BOTTOM:\n        rootY = height - this._fontOffset.height * (this._lines.length - 1) - this._fontOffset.descent;\n        break;\n      case Control.VERTICAL_ALIGNMENT_CENTER:\n        rootY = this._fontOffset.ascent + (height - this._fontOffset.height * this._lines.length) / 2;\n        break;\n    }\n    context.save();\n    context.beginPath();\n    context.fillStyle = this.fontStyle;\n    // here we define the visible reactangle to clip it in next line\n    context.rect(this._clipTextLeft, this._clipTextTop, this._availableWidth + 2, this._availableHeight + 2);\n    context.clip();\n    // Text\n    rootY += this._scrollTop;\n    for (let i = 0; i < this._lines.length; i++) {\n      const line = this._lines[i];\n      if (i !== 0 && this._lineSpacing.internalValue !== 0) {\n        if (this._lineSpacing.isPixel) {\n          rootY += this._lineSpacing.getValue(this._host);\n        } else {\n          rootY = rootY + this._lineSpacing.getValue(this._host) * this._height.getValueInPixel(this._host, this._cachedParentMeasure.height);\n        }\n      }\n      this._drawText(line.text, line.width, rootY, context);\n      rootY += this._fontOffset.height;\n    }\n    context.restore();\n    // Cursor\n    if (this._isFocused) {\n      // Render cursor\n      if (!this._blinkIsEven || this._isTextHighlightOn) {\n        let cursorLeft = this._scrollLeft + context.measureText(this._lines[this._cursorInfo.currentLineIndex].text.substr(0, this._cursorInfo.relativeStartIndex)).width;\n        if (cursorLeft < this._clipTextLeft) {\n          this._scrollLeft += this._clipTextLeft - cursorLeft;\n          cursorLeft = this._clipTextLeft;\n          this._markAsDirty();\n        } else if (cursorLeft > this._clipTextLeft + this._availableWidth) {\n          this._scrollLeft += this._clipTextLeft + this._availableWidth - cursorLeft;\n          cursorLeft = this._clipTextLeft + this._availableWidth;\n          this._markAsDirty();\n        }\n        let cursorTop = this._scrollTop + this._cursorInfo.currentLineIndex * this._fontOffset.height; //cursorTop distance from top to cursor start\n        if (cursorTop < this._clipTextTop) {\n          this._scrollTop += this._clipTextTop - cursorTop;\n          cursorTop = this._clipTextTop;\n          this._markAsDirty();\n        } else if (cursorTop + this._fontOffset.height > this._clipTextTop + this._availableHeight) {\n          this._scrollTop += this._clipTextTop + this._availableHeight - cursorTop - this._fontOffset.height;\n          cursorTop = this._clipTextTop + this._availableHeight - this._fontOffset.height;\n          this._markAsDirty();\n        }\n        if (!this._isTextHighlightOn) {\n          context.fillRect(cursorLeft, cursorTop, 2, this._fontOffset.height);\n        }\n      }\n      this._resetBlinking();\n      //show the highlighted text\n      if (this._isTextHighlightOn) {\n        clearTimeout(this._blinkTimeout);\n        this._highlightedText = this.text.substring(this._cursorInfo.globalStartIndex, this._cursorInfo.globalEndIndex);\n        context.globalAlpha = this._highligherOpacity;\n        context.fillStyle = this._textHighlightColor;\n        const startLineIndex = Math.min(this._cursorInfo.currentLineIndex, this._highlightCursorInfo.initialLineIndex);\n        const endLineIndex = Math.max(this._cursorInfo.currentLineIndex, this._highlightCursorInfo.initialLineIndex);\n        let highlightRootY = this._scrollTop + startLineIndex * this._fontOffset.height;\n        for (let i = startLineIndex; i <= endLineIndex; i++) {\n          const line = this._lines[i];\n          let highlightRootX = this._scrollLeft;\n          switch (this._textHorizontalAlignment) {\n            case Control.HORIZONTAL_ALIGNMENT_LEFT:\n              highlightRootX += 0;\n              break;\n            case Control.HORIZONTAL_ALIGNMENT_RIGHT:\n              highlightRootX += width - line.width;\n              break;\n            case Control.HORIZONTAL_ALIGNMENT_CENTER:\n              highlightRootX += (width - line.width) / 2;\n              break;\n          }\n          const begin = i === startLineIndex ? this._cursorInfo.relativeStartIndex : 0;\n          const end = i === endLineIndex ? this._cursorInfo.relativeEndIndex : line.text.length;\n          const leftOffsetWidth = context.measureText(line.text.substr(0, begin)).width;\n          const selectedText = line.text.substring(begin, end);\n          const hightlightWidth = context.measureText(selectedText).width;\n          context.fillRect(highlightRootX + leftOffsetWidth, highlightRootY, hightlightWidth, this._fontOffset.height);\n          highlightRootY += this._fontOffset.height;\n        }\n        if (this._cursorInfo.globalEndIndex === this._cursorInfo.globalStartIndex) {\n          this._resetBlinking();\n        }\n      }\n    }\n    context.restore();\n    // Border\n    if (this._thickness) {\n      if (this._isFocused) {\n        if (this.focusedColor) {\n          context.strokeStyle = this.focusedColor;\n        }\n      } else {\n        if (this.color) {\n          context.strokeStyle = this.color;\n        }\n      }\n      context.lineWidth = this._thickness;\n      context.strokeRect(this._currentMeasure.left + this._thickness / 2, this._currentMeasure.top + this._thickness / 2, this._currentMeasure.width - this._thickness, this._currentMeasure.height - this._thickness);\n    }\n  }\n  _resetBlinking() {\n    clearTimeout(this._blinkTimeout);\n    this._blinkTimeout = setTimeout(() => {\n      this._blinkIsEven = !this._blinkIsEven;\n      this._markAsDirty();\n    }, 500);\n  }\n  _applyStates(context) {\n    super._applyStates(context);\n    if (this.outlineWidth) {\n      context.lineWidth = this.outlineWidth;\n      context.strokeStyle = this.outlineColor;\n    }\n  }\n  _onPointerDown(target, coordinates, pointerId, buttonIndex, pi) {\n    if (!super._onPointerDown(target, coordinates, pointerId, buttonIndex, pi)) {\n      return false;\n    }\n    this._clickedCoordinateX = coordinates.x;\n    this._clickedCoordinateY = coordinates.y;\n    this._isTextHighlightOn = false;\n    this._highlightedText = \"\";\n    this._isPointerDown = true;\n    this._host._capturingControl[pointerId] = this;\n    if (this._host.focusedControl === this) {\n      // Move cursor\n      clearTimeout(this._blinkTimeout);\n      this._markAsDirty();\n      return true;\n    }\n    if (!this._isEnabled) {\n      return false;\n    }\n    this._host.focusedControl = this;\n    return true;\n  }\n  // for textselection\n  _onPointerMove(target, coordinates, pointerId, pi) {\n    // Avoid Chromium-like beahavior when this event is fired right after onPointerDown\n    if (pi.event.movementX === 0 && pi.event.movementY === 0) {\n      return;\n    }\n    if (this._host.focusedControl === this && this._isPointerDown) {\n      this._clickedCoordinateX = coordinates.x;\n      this._clickedCoordinateY = coordinates.y;\n      if (!this._isTextHighlightOn) {\n        this._highlightCursorInfo.initialLineIndex = this._cursorInfo.currentLineIndex;\n        this._highlightCursorInfo.initialStartIndex = this._cursorInfo.globalStartIndex;\n        this._highlightCursorInfo.initialRelativeStartIndex = this._cursorInfo.relativeStartIndex;\n        this._isTextHighlightOn = true;\n      }\n      this._markAsDirty();\n    }\n    super._onPointerMove(target, coordinates, pointerId, pi);\n  }\n  /**\n   * Apply the correct position of cursor according to current modification\n   */\n  _updateCursorPosition() {\n    var _a;\n    if (!this._isFocused) {\n      return;\n    }\n    if (this._clickedCoordinateX && this._clickedCoordinateY) {\n      if (!this._isTextHighlightOn) {\n        this._cursorInfo = {\n          globalStartIndex: 0,\n          globalEndIndex: 0,\n          relativeStartIndex: 0,\n          relativeEndIndex: 0,\n          currentLineIndex: 0\n        };\n      }\n      let globalIndex = 0;\n      let relativeIndex = 0;\n      const lastClickedCoordinateY = this._clickedCoordinateY - this._scrollTop;\n      const relativeCoordinateY = Math.floor(lastClickedCoordinateY / this._fontOffset.height);\n      this._cursorInfo.currentLineIndex = Math.min(Math.max(relativeCoordinateY, 0), this._lines.length - 1);\n      let currentSize = 0;\n      const relativeXPosition = this._clickedCoordinateX - ((_a = this._scrollLeft) !== null && _a !== void 0 ? _a : 0);\n      let previousDist = 0;\n      for (let index = 0; index < this._cursorInfo.currentLineIndex; index++) {\n        const line = this._lines[index];\n        globalIndex += line.text.length + line.lineEnding.length;\n      }\n      while (currentSize < relativeXPosition && this._lines[this._cursorInfo.currentLineIndex].text.length > relativeIndex) {\n        relativeIndex++;\n        previousDist = Math.abs(relativeXPosition - currentSize);\n        currentSize = this._contextForBreakLines.measureText(this._lines[this._cursorInfo.currentLineIndex].text.substr(0, relativeIndex)).width;\n      }\n      // Find closest move\n      if (Math.abs(relativeXPosition - currentSize) > previousDist && relativeIndex > 0) {\n        relativeIndex--;\n      }\n      globalIndex += relativeIndex;\n      if (!this._isTextHighlightOn) {\n        this._cursorInfo.globalStartIndex = globalIndex;\n        this._cursorInfo.relativeStartIndex = relativeIndex;\n        this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\n        this._cursorInfo.relativeEndIndex = this._cursorInfo.relativeStartIndex;\n      } else {\n        if (globalIndex < this._highlightCursorInfo.initialStartIndex) {\n          this._cursorInfo.globalStartIndex = globalIndex;\n          this._cursorInfo.relativeStartIndex = relativeIndex;\n          this._cursorInfo.globalEndIndex = this._highlightCursorInfo.initialStartIndex;\n          this._cursorInfo.relativeEndIndex = this._highlightCursorInfo.initialRelativeStartIndex;\n        } else {\n          this._cursorInfo.globalStartIndex = this._highlightCursorInfo.initialStartIndex;\n          this._cursorInfo.relativeStartIndex = this._highlightCursorInfo.initialRelativeStartIndex;\n          this._cursorInfo.globalEndIndex = globalIndex;\n          this._cursorInfo.relativeEndIndex = relativeIndex;\n        }\n      }\n      // Avoid the caret during highlighting\n      this._blinkIsEven = this._isTextHighlightOn;\n      this._clickedCoordinateX = null;\n      this._clickedCoordinateY = null;\n    } else {\n      // Standard behavior same as Current line is at least above the initial highlight index\n      this._cursorInfo.relativeStartIndex = 0;\n      this._cursorInfo.currentLineIndex = 0;\n      let lineLength = this._lines[this._cursorInfo.currentLineIndex].text.length + this._lines[this._cursorInfo.currentLineIndex].lineEnding.length;\n      let tmpLength = 0;\n      while (tmpLength + lineLength <= this._cursorInfo.globalStartIndex) {\n        tmpLength += lineLength;\n        if (this._cursorInfo.currentLineIndex < this._lines.length - 1) {\n          this._cursorInfo.currentLineIndex++;\n          lineLength = this._lines[this._cursorInfo.currentLineIndex].text.length + this._lines[this._cursorInfo.currentLineIndex].lineEnding.length;\n        }\n      }\n      this._cursorInfo.relativeStartIndex = this._cursorInfo.globalStartIndex - tmpLength;\n      if (this._highlightCursorInfo.initialStartIndex !== -1 && this._cursorInfo.globalStartIndex >= this._highlightCursorInfo.initialStartIndex) {\n        // Current line is at least below the initial highlight index\n        while (tmpLength + lineLength <= this._cursorInfo.globalEndIndex) {\n          tmpLength += lineLength;\n          if (this._cursorInfo.currentLineIndex < this._lines.length - 1) {\n            this._cursorInfo.currentLineIndex++;\n            lineLength = this._lines[this._cursorInfo.currentLineIndex].text.length + this._lines[this._cursorInfo.currentLineIndex].lineEnding.length;\n          }\n        }\n        this._cursorInfo.relativeEndIndex = this._cursorInfo.globalEndIndex - tmpLength;\n      } else if (!this._isTextHighlightOn) {\n        this._cursorInfo.relativeEndIndex = this._cursorInfo.relativeStartIndex;\n        this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\n      }\n    }\n  }\n  /**\n   * Update all values of cursor information based on cursorIndex value\n   *\n   * @param offset The index to take care of\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _updateValueFromCursorIndex(offset) {\n    // Override to avoid parent behavior during _onPointerMove\n  }\n  /**\n   * Select the word immediatly under the cursor on double click\n   *\n   * @param _evt Pointer informations of double click\n   * @internal\n   */\n  _processDblClick(_evt) {\n    //pre-find the start and end index of the word under cursor, speeds up the rendering\n    let moveLeft, moveRight;\n    do {\n      moveLeft = this._cursorInfo.globalStartIndex > 0 && this._textWrapper.isWord(this._cursorInfo.globalStartIndex - 1) ? --this._cursorInfo.globalStartIndex : 0;\n      moveRight = this._cursorInfo.globalEndIndex < this._textWrapper.length && this._textWrapper.isWord(this._cursorInfo.globalEndIndex) ? ++this._cursorInfo.globalEndIndex : 0;\n    } while (moveLeft || moveRight);\n    this._highlightCursorInfo.initialLineIndex = this._cursorInfo.currentLineIndex;\n    this._highlightCursorInfo.initialStartIndex = this._cursorInfo.globalStartIndex;\n    this.onTextHighlightObservable.notifyObservers(this);\n    this._isTextHighlightOn = true;\n    this._blinkIsEven = true;\n    this._markAsDirty();\n  }\n  /** @internal */\n  _selectAllText() {\n    this._isTextHighlightOn = true;\n    this._blinkIsEven = true;\n    this._highlightCursorInfo = {\n      initialStartIndex: 0,\n      initialRelativeStartIndex: 0,\n      initialLineIndex: 0\n    };\n    this._cursorInfo = {\n      globalStartIndex: 0,\n      globalEndIndex: this._textWrapper.length,\n      relativeEndIndex: this._lines[this._lines.length - 1].text.length,\n      relativeStartIndex: 0,\n      currentLineIndex: this._lines.length - 1\n    };\n    this._markAsDirty();\n  }\n  dipose() {\n    super.dispose();\n    this.onLinesReadyObservable.clear();\n  }\n}\n__decorate([serialize()], InputTextArea.prototype, \"autoStretchHeight\", null);\n__decorate([serialize()], InputTextArea.prototype, \"maxHeight\", null);\nRegisterClass(\"BABYLON.GUI.InputTextArea\", InputTextArea);","map":{"version":3,"names":["Observable","Control","ValueAndUnit","RegisterClass","InputText","serialize","InputTextArea","outlineWidth","_outlineWidth","value","_markAsDirty","outlineColor","_outlineColor","autoStretchHeight","_autoStretchHeight","height","fixedRatioMasterIsWidth","_height","toString","_host","fromString","maxHeight","_maxHeight","maxHeightInPixels","getValueInPixel","_cachedParentMeasure","constructor","name","text","_textHorizontalAlignment","HORIZONTAL_ALIGNMENT_LEFT","_textVerticalAlignment","VERTICAL_ALIGNMENT_TOP","_lineSpacing","UNITMODE_PERCENTAGE","onLinesReadyObservable","isPointerBlocker","add","_updateCursorPosition","_highlightCursorInfo","initialStartIndex","initialRelativeStartIndex","initialLineIndex","_cursorInfo","globalStartIndex","globalEndIndex","relativeEndIndex","relativeStartIndex","currentLineIndex","_getTypeName","processKeyboard","evt","alternativeProcessKey","code","key","onKeyboardEventProcessedObservable","notifyObservers","ctrlKey","metaKey","_selectAllText","preventDefault","shiftKey","_isTextHighlightOn","_textWrapper","removePart","_blinkIsEven","_textHasChanged","length","rightDelta","_lines","currentLine","upperLine","tmpIndex","relativeIndex","currentText","substr","currentWidth","_contextForBreakLines","measureText","width","upperWidth","previousWidth","lineEnding","upperLineRelativeIndex","Math","abs","underLine","underWidth","underLineRelativeIndex","_currentKey","onBeforeKeyAddObservable","_addKey","_parseLineWordWrap","line","context","lines","words","split","lineWidth","n","testLine","metrics","testWidth","push","flushedLine","map","char","_breakLines","refWidth","clipContent","_line","_parseLine","_preMeasure","parentMeasure","_fontOffset","_wasDirty","_GetFontOffset","font","_beforeRenderText","_isFocused","_placeholderText","_placeholderColor","fillStyle","_textWidth","marginWidth","_margin","_autoStretchWidth","tmpLines","longerString","reduce","acc","val","valueLength","accLength","longerStringWidth","min","_maxWidth","autoStretchWidth","_availableWidth","_width","textHeight","totalHeight","_availableHeight","lineLength","tmpLength","_computeScroll","_clipTextLeft","_currentMeasure","left","_clipTextTop","top","textLeft","_scrollLeft","selectedHeight","textTop","_scrollTop","_additionalProcessing","highlightedText","_drawText","textWidth","y","x","HORIZONTAL_ALIGNMENT_RIGHT","HORIZONTAL_ALIGNMENT_CENTER","shadowBlur","shadowOffsetX","shadowOffsetY","shadowColor","strokeText","fillText","_onCopyText","ev","clipboardData","setData","_highlightedText","_a","_onCutText","_onPasteText","data","types","indexOf","getData","deltaIndex","_draw","_b","save","_applyStates","_focusedBackground","_isEnabled","_disabledColor","fillRect","_background","color","rootY","ascent","VERTICAL_ALIGNMENT_BOTTOM","descent","VERTICAL_ALIGNMENT_CENTER","beginPath","fontStyle","rect","clip","i","internalValue","isPixel","getValue","restore","cursorLeft","cursorTop","_resetBlinking","clearTimeout","_blinkTimeout","substring","globalAlpha","_highligherOpacity","_textHighlightColor","startLineIndex","endLineIndex","max","highlightRootY","highlightRootX","begin","end","leftOffsetWidth","selectedText","hightlightWidth","_thickness","focusedColor","strokeStyle","strokeRect","setTimeout","_onPointerDown","target","coordinates","pointerId","buttonIndex","pi","_clickedCoordinateX","_clickedCoordinateY","_isPointerDown","_capturingControl","focusedControl","_onPointerMove","event","movementX","movementY","globalIndex","lastClickedCoordinateY","relativeCoordinateY","floor","currentSize","relativeXPosition","previousDist","index","_updateValueFromCursorIndex","offset","_processDblClick","_evt","moveLeft","moveRight","isWord","onTextHighlightObservable","dipose","dispose","clear","__decorate"],"sources":["../../../../../dev/gui/src/2D/controls/inputTextArea.ts"],"sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport type { Vector2 } from \"core/Maths/math.vector\";\r\n\r\nimport { Control } from \"./control\";\r\nimport { ValueAndUnit } from \"../valueAndUnit\";\r\nimport type { VirtualKeyboard } from \"./virtualKeyboard\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { Measure } from \"../measure\";\r\nimport { InputText } from \"./inputText\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\nimport type { PointerInfo, PointerInfoBase } from \"core/Events/pointerEvents\";\r\nimport type { IKeyboardEvent } from \"core/Events/deviceInputEvents\";\r\n\r\nimport { serialize } from \"core/Misc/decorators\";\r\n\r\n/**\r\n * Class used to create input text control\r\n */\r\nexport class InputTextArea extends InputText {\r\n    private _textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n    private _textVerticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n\r\n    private _lines: any[];\r\n    private _lineSpacing: ValueAndUnit = new ValueAndUnit(0);\r\n    private _outlineWidth: number = 0;\r\n    private _outlineColor: string = \"white\";\r\n    private _maxHeight = new ValueAndUnit(1, ValueAndUnit.UNITMODE_PERCENTAGE, false);\r\n\r\n    private _clipTextTop: number;\r\n    private _clipTextLeft: number;\r\n\r\n    private _cursorInfo: { globalStartIndex: number; globalEndIndex: number; relativeStartIndex: number; relativeEndIndex: number; currentLineIndex: number };\r\n    private _highlightCursorInfo: { initialStartIndex: number; initialRelativeStartIndex: number; initialLineIndex: number };\r\n\r\n    /**\r\n     * An event triggered after the text was broken up into lines\r\n     */\r\n    public onLinesReadyObservable = new Observable<InputTextArea>();\r\n\r\n    /** @internal */\r\n    public _connectedVirtualKeyboard: Nullable<VirtualKeyboard>;\r\n    private _contextForBreakLines: ICanvasRenderingContext;\r\n    private _clickedCoordinateX: Nullable<number>;\r\n    private _clickedCoordinateY: Nullable<number>;\r\n\r\n    private _availableWidth: number;\r\n    private _availableHeight: number;\r\n\r\n    private _scrollTop: Nullable<number>;\r\n\r\n    private _autoStretchHeight: boolean;\r\n\r\n    /**\r\n     * Gets or sets outlineWidth of the text to display\r\n     */\r\n    public get outlineWidth(): number {\r\n        return this._outlineWidth;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets outlineWidth of the text to display\r\n     */\r\n    public set outlineWidth(value: number) {\r\n        if (this._outlineWidth === value) {\r\n            return;\r\n        }\r\n        this._outlineWidth = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets outlineColor of the text to display\r\n     */\r\n    public get outlineColor(): string {\r\n        return this._outlineColor;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets outlineColor of the text to display\r\n     */\r\n    public set outlineColor(value: string) {\r\n        if (this._outlineColor === value) {\r\n            return;\r\n        }\r\n        this._outlineColor = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if the control can auto stretch its height to adapt to the text */\r\n    @serialize()\r\n    public get autoStretchHeight(): boolean {\r\n        return this._autoStretchHeight;\r\n    }\r\n\r\n    public set autoStretchHeight(value: boolean) {\r\n        if (this._autoStretchHeight === value) {\r\n            return;\r\n        }\r\n\r\n        this._autoStretchHeight = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    public set height(value: string | number) {\r\n        this.fixedRatioMasterIsWidth = false;\r\n\r\n        if (this._height.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._height.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n\r\n        this._autoStretchHeight = false;\r\n    }\r\n\r\n    @serialize()\r\n    public get maxHeight(): string | number {\r\n        return this._maxHeight.toString(this._host);\r\n    }\r\n\r\n    /** Gets the maximum width allowed by the control in pixels */\r\n    public get maxHeightInPixels(): number {\r\n        return this._maxHeight.getValueInPixel(this._host, this._cachedParentMeasure.height);\r\n    }\r\n\r\n    public set maxHeight(value: string | number) {\r\n        if (this._maxHeight.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._maxHeight.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new InputTextArea\r\n     * @param name defines the control name\r\n     * @param text defines the text of the control\r\n     */\r\n    constructor(public name?: string, text: string = \"\") {\r\n        super(name);\r\n\r\n        this.text = text;\r\n\r\n        this.isPointerBlocker = true;\r\n\r\n        this.onLinesReadyObservable.add(() => this._updateCursorPosition());\r\n\r\n        this._highlightCursorInfo = {\r\n            initialStartIndex: -1,\r\n            initialRelativeStartIndex: -1,\r\n            initialLineIndex: -1,\r\n        };\r\n\r\n        this._cursorInfo = {\r\n            globalStartIndex: 0,\r\n            globalEndIndex: 0,\r\n            relativeEndIndex: 0,\r\n            relativeStartIndex: 0,\r\n            currentLineIndex: 0,\r\n        };\r\n    }\r\n\r\n    protected _getTypeName(): string {\r\n        return \"InputTextArea\";\r\n    }\r\n\r\n    /**\r\n     * Handles the keyboard event\r\n     * @param evt Defines the KeyboardEvent\r\n     */\r\n    public processKeyboard(evt: IKeyboardEvent): void {\r\n        // process pressed key\r\n        this.alternativeProcessKey(evt.code, evt.key, evt);\r\n\r\n        this.onKeyboardEventProcessedObservable.notifyObservers(evt);\r\n    }\r\n\r\n    /**\r\n     * Process the last keyboard input\r\n     *\r\n     * @param code The ascii input number\r\n     * @param key The key string representation\r\n     * @param evt The keyboard event emits with input\r\n     * @internal\r\n     */\r\n    public alternativeProcessKey(code: string, key?: string, evt?: IKeyboardEvent) {\r\n        //return if clipboard event keys (i.e -ctr/cmd + c,v,x)\r\n        if (evt && (evt.ctrlKey || evt.metaKey) && (code === \"KeyC\" || code === \"KeyV\" || code === \"KeyX\")) {\r\n            return;\r\n        }\r\n\r\n        // Specific cases\r\n        switch (code) {\r\n            case \"KeyA\": // A - select all\r\n                if (evt && (evt.ctrlKey || evt.metaKey)) {\r\n                    this._selectAllText();\r\n                    evt.preventDefault();\r\n                    return;\r\n                }\r\n                break;\r\n            case \"Period\": //SLASH\r\n                if (evt && evt.shiftKey) {\r\n                    evt.preventDefault();\r\n                }\r\n                break;\r\n            case \"Backspace\": // BACKSPACE\r\n                if (!this._isTextHighlightOn && this._cursorInfo.globalStartIndex > 0) {\r\n                    this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\r\n                    this._cursorInfo.globalStartIndex--;\r\n                }\r\n\r\n                this._textWrapper.removePart(this._cursorInfo.globalStartIndex, this._cursorInfo.globalEndIndex);\r\n\r\n                this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\r\n\r\n                if (evt) {\r\n                    evt.preventDefault();\r\n                }\r\n\r\n                this._blinkIsEven = false;\r\n                this._isTextHighlightOn = false;\r\n\r\n                this._textHasChanged();\r\n                break;\r\n            case \"Delete\": // DELETE\r\n                if (!this._isTextHighlightOn && this._cursorInfo.globalEndIndex < this.text.length) {\r\n                    this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex + 1;\r\n                }\r\n\r\n                this._textWrapper.removePart(this._cursorInfo.globalStartIndex, this._cursorInfo.globalEndIndex);\r\n\r\n                this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\r\n\r\n                if (evt) {\r\n                    evt.preventDefault();\r\n                }\r\n\r\n                this._blinkIsEven = false;\r\n                this._isTextHighlightOn = false;\r\n\r\n                this._textHasChanged();\r\n                break;\r\n            case \"Enter\": // RETURN\r\n                this._textWrapper.removePart(this._cursorInfo.globalStartIndex, this._cursorInfo.globalEndIndex, \"\\n\");\r\n                this._cursorInfo.globalStartIndex++;\r\n                this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\r\n\r\n                this._blinkIsEven = false;\r\n                this._isTextHighlightOn = false;\r\n\r\n                this._textHasChanged();\r\n                return;\r\n            case \"End\": // END\r\n                this._cursorInfo.globalStartIndex = this.text.length;\r\n                this._blinkIsEven = false;\r\n                this._isTextHighlightOn = false;\r\n                this._markAsDirty();\r\n                return;\r\n            case \"Home\": // HOME\r\n                this._cursorInfo.globalStartIndex = 0;\r\n                this._blinkIsEven = false;\r\n                this._isTextHighlightOn = false;\r\n                this._markAsDirty();\r\n                return;\r\n            case \"ArrowLeft\": // LEFT\r\n                this._markAsDirty();\r\n\r\n                if (evt && evt.shiftKey) {\r\n                    // shift + ctrl/cmd + <-\r\n                    if (evt.ctrlKey || evt.metaKey) {\r\n                        // Go to line's start by substract the relativeStartIndex to the globalStartIndex\r\n                        this._cursorInfo.globalStartIndex -= this._cursorInfo.relativeStartIndex;\r\n                        this._cursorInfo.globalEndIndex = this._highlightCursorInfo.initialStartIndex;\r\n                    }\r\n                    // store the starting point\r\n                    if (!this._isTextHighlightOn) {\r\n                        this._highlightCursorInfo.initialLineIndex = this._cursorInfo.currentLineIndex;\r\n                        this._highlightCursorInfo.initialStartIndex = this._cursorInfo.globalStartIndex;\r\n                        this._highlightCursorInfo.initialRelativeStartIndex = this._cursorInfo.relativeStartIndex;\r\n\r\n                        this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\r\n                        this._cursorInfo.globalStartIndex--;\r\n                        this._isTextHighlightOn = true;\r\n                    } else {\r\n                        if (this._cursorInfo.globalEndIndex > this._highlightCursorInfo.initialStartIndex) {\r\n                            this._cursorInfo.globalEndIndex--;\r\n                        } else {\r\n                            this._cursorInfo.globalStartIndex--;\r\n                        }\r\n                    }\r\n                    this._blinkIsEven = true;\r\n                    evt.preventDefault();\r\n                    return;\r\n                }\r\n\r\n                if (this._isTextHighlightOn) {\r\n                    this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\r\n                } else if (evt && (evt.ctrlKey || evt.metaKey)) {\r\n                    // ctr + <-\r\n                    this._cursorInfo.globalStartIndex -= this._cursorInfo.relativeStartIndex;\r\n                    evt.preventDefault();\r\n                } else if (this._cursorInfo.globalStartIndex > 0) {\r\n                    this._cursorInfo.globalStartIndex--;\r\n                }\r\n\r\n                // update the cursor\r\n                this._blinkIsEven = false;\r\n                this._isTextHighlightOn = false;\r\n                return;\r\n            case \"ArrowRight\": // RIGHT\r\n                this._markAsDirty();\r\n\r\n                if (evt && evt.shiftKey) {\r\n                    // shift + ctrl/cmd + ->\r\n                    if (evt.ctrlKey || evt.metaKey) {\r\n                        const rightDelta = this._lines[this._cursorInfo.currentLineIndex].text.length - this._cursorInfo.relativeEndIndex - 1;\r\n                        this._cursorInfo.globalEndIndex += rightDelta;\r\n                        this._cursorInfo.globalStartIndex = this._highlightCursorInfo.initialStartIndex;\r\n                    }\r\n                    // store the starting point\r\n                    if (!this._isTextHighlightOn) {\r\n                        this._highlightCursorInfo.initialLineIndex = this._cursorInfo.currentLineIndex;\r\n                        this._highlightCursorInfo.initialStartIndex = this._cursorInfo.globalStartIndex;\r\n                        this._highlightCursorInfo.initialRelativeStartIndex = this._cursorInfo.relativeStartIndex;\r\n\r\n                        this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\r\n                        this._cursorInfo.globalEndIndex++;\r\n                        this._isTextHighlightOn = true;\r\n                    } else {\r\n                        if (this._cursorInfo.globalStartIndex < this._highlightCursorInfo.initialStartIndex) {\r\n                            this._cursorInfo.globalStartIndex++;\r\n                        } else {\r\n                            this._cursorInfo.globalEndIndex++;\r\n                        }\r\n                    }\r\n                    this._blinkIsEven = true;\r\n                    evt.preventDefault();\r\n                    return;\r\n                }\r\n                if (this._isTextHighlightOn) {\r\n                    this._cursorInfo.globalStartIndex = this._cursorInfo.globalEndIndex;\r\n                } else if (evt && (evt.ctrlKey || evt.metaKey)) {\r\n                    //ctr + ->\r\n                    const rightDelta = this._lines[this._cursorInfo.currentLineIndex].text.length - this._cursorInfo.relativeEndIndex;\r\n                    this._cursorInfo.globalStartIndex += rightDelta;\r\n                } else if (this._cursorInfo.globalStartIndex < this.text.length) {\r\n                    this._cursorInfo.globalStartIndex++;\r\n                }\r\n\r\n                // update the cursor\r\n                this._blinkIsEven = false;\r\n                this._isTextHighlightOn = false;\r\n                return;\r\n            case \"ArrowUp\": // UP\r\n                // update the cursor\r\n                this._blinkIsEven = false;\r\n\r\n                if (evt) {\r\n                    if (evt.shiftKey) {\r\n                        if (!this._isTextHighlightOn) {\r\n                            this._highlightCursorInfo.initialLineIndex = this._cursorInfo.currentLineIndex;\r\n                            this._highlightCursorInfo.initialStartIndex = this._cursorInfo.globalStartIndex;\r\n                            this._highlightCursorInfo.initialRelativeStartIndex = this._cursorInfo.relativeStartIndex;\r\n                        }\r\n                        this._isTextHighlightOn = true;\r\n                        this._blinkIsEven = true;\r\n                    } else {\r\n                        this._isTextHighlightOn = false;\r\n                    }\r\n                    evt.preventDefault();\r\n                }\r\n\r\n                if (this._cursorInfo.currentLineIndex === 0) {\r\n                    // First line\r\n                    this._cursorInfo.globalStartIndex = 0;\r\n                } else {\r\n                    const currentLine = this._lines[this._cursorInfo.currentLineIndex];\r\n                    const upperLine = this._lines[this._cursorInfo.currentLineIndex - 1];\r\n\r\n                    let tmpIndex = 0;\r\n                    let relativeIndex = 0;\r\n                    if (!this._isTextHighlightOn || this._cursorInfo.currentLineIndex < this._highlightCursorInfo.initialLineIndex) {\r\n                        tmpIndex = this._cursorInfo.globalStartIndex;\r\n                        relativeIndex = this._cursorInfo.relativeStartIndex;\r\n                    } else {\r\n                        tmpIndex = this._cursorInfo.globalEndIndex;\r\n                        relativeIndex = this._cursorInfo.relativeEndIndex;\r\n                    }\r\n\r\n                    const currentText = currentLine.text.substr(0, relativeIndex);\r\n                    const currentWidth = this._contextForBreakLines.measureText(currentText).width;\r\n\r\n                    let upperWidth = 0;\r\n                    let previousWidth = 0;\r\n\r\n                    tmpIndex -= relativeIndex; // Start of current line\r\n                    tmpIndex -= upperLine.text.length + upperLine.lineEnding.length; // Start of upper line\r\n                    let upperLineRelativeIndex = 0;\r\n\r\n                    while (upperWidth < currentWidth && upperLineRelativeIndex < upperLine.text.length) {\r\n                        tmpIndex++;\r\n                        upperLineRelativeIndex++;\r\n                        previousWidth = Math.abs(currentWidth - upperWidth);\r\n                        upperWidth = this._contextForBreakLines.measureText(upperLine.text.substr(0, upperLineRelativeIndex)).width;\r\n                    }\r\n\r\n                    // Find closest move\r\n                    if (Math.abs(currentWidth - upperWidth) > previousWidth && upperLineRelativeIndex > 0) {\r\n                        tmpIndex--;\r\n                    }\r\n\r\n                    if (!this._isTextHighlightOn) {\r\n                        this._cursorInfo.globalStartIndex = tmpIndex;\r\n                    } else if (this._cursorInfo.currentLineIndex <= this._highlightCursorInfo.initialLineIndex) {\r\n                        this._cursorInfo.globalStartIndex = tmpIndex;\r\n                        this._cursorInfo.globalEndIndex = this._highlightCursorInfo.initialStartIndex;\r\n                        this._cursorInfo.relativeEndIndex = this._highlightCursorInfo.initialRelativeStartIndex;\r\n                    } else {\r\n                        this._cursorInfo.globalEndIndex = tmpIndex;\r\n                    }\r\n                }\r\n\r\n                this._markAsDirty();\r\n                return;\r\n            case \"ArrowDown\": // DOWN\r\n                // update the cursor\r\n                this._blinkIsEven = false;\r\n\r\n                if (evt) {\r\n                    if (evt.shiftKey) {\r\n                        if (!this._isTextHighlightOn) {\r\n                            this._highlightCursorInfo.initialLineIndex = this._cursorInfo.currentLineIndex;\r\n                            this._highlightCursorInfo.initialStartIndex = this._cursorInfo.globalStartIndex;\r\n                            this._highlightCursorInfo.initialRelativeStartIndex = this._cursorInfo.relativeStartIndex;\r\n                        }\r\n\r\n                        this._isTextHighlightOn = true;\r\n                        this._blinkIsEven = true;\r\n                    } else {\r\n                        this._isTextHighlightOn = false;\r\n                    }\r\n                    evt.preventDefault();\r\n                }\r\n\r\n                if (this._cursorInfo.currentLineIndex === this._lines.length - 1) {\r\n                    // Last line\r\n                    this._cursorInfo.globalStartIndex = this.text.length;\r\n                } else {\r\n                    const currentLine = this._lines[this._cursorInfo.currentLineIndex];\r\n                    const underLine = this._lines[this._cursorInfo.currentLineIndex + 1];\r\n\r\n                    let tmpIndex = 0;\r\n                    let relativeIndex = 0;\r\n                    if (!this._isTextHighlightOn || this._cursorInfo.currentLineIndex < this._highlightCursorInfo.initialLineIndex) {\r\n                        tmpIndex = this._cursorInfo.globalStartIndex;\r\n                        relativeIndex = this._cursorInfo.relativeStartIndex;\r\n                    } else {\r\n                        tmpIndex = this._cursorInfo.globalEndIndex;\r\n                        relativeIndex = this._cursorInfo.relativeEndIndex;\r\n                    }\r\n\r\n                    const currentText = currentLine.text.substr(0, relativeIndex);\r\n                    const currentWidth = this._contextForBreakLines.measureText(currentText).width;\r\n\r\n                    let underWidth = 0;\r\n                    let previousWidth = 0;\r\n\r\n                    tmpIndex += currentLine.text.length - relativeIndex + currentLine.lineEnding.length; // Start of current line\r\n                    let underLineRelativeIndex = 0;\r\n\r\n                    while (underWidth < currentWidth && underLineRelativeIndex < underLine.text.length) {\r\n                        tmpIndex++;\r\n                        underLineRelativeIndex++;\r\n                        previousWidth = Math.abs(currentWidth - underWidth);\r\n                        underWidth = this._contextForBreakLines.measureText(underLine.text.substr(0, underLineRelativeIndex)).width;\r\n                    }\r\n\r\n                    // Find closest move\r\n                    if (Math.abs(currentWidth - underWidth) > previousWidth && underLineRelativeIndex > 0) {\r\n                        tmpIndex--;\r\n                    }\r\n\r\n                    if (!this._isTextHighlightOn) {\r\n                        this._cursorInfo.globalStartIndex = tmpIndex;\r\n                    } else if (this._cursorInfo.currentLineIndex < this._highlightCursorInfo.initialLineIndex) {\r\n                        this._cursorInfo.globalStartIndex = tmpIndex;\r\n                        if (this._cursorInfo.globalStartIndex > this._cursorInfo.globalEndIndex) {\r\n                            this._cursorInfo.globalEndIndex += this._cursorInfo.globalStartIndex;\r\n                            this._cursorInfo.globalStartIndex = this._cursorInfo.globalEndIndex - this._cursorInfo.globalStartIndex;\r\n                            this._cursorInfo.globalEndIndex -= this._cursorInfo.globalStartIndex;\r\n                        }\r\n                    } else {\r\n                        this._cursorInfo.globalEndIndex = tmpIndex;\r\n                        this._cursorInfo.globalStartIndex = this._highlightCursorInfo.initialStartIndex;\r\n                    }\r\n                }\r\n\r\n                this._markAsDirty();\r\n                return;\r\n        }\r\n\r\n        // Printable characters\r\n        if (key?.length === 1) {\r\n            evt?.preventDefault();\r\n            this._currentKey = key;\r\n            this.onBeforeKeyAddObservable.notifyObservers(this);\r\n            key = this._currentKey;\r\n            if (this._addKey) {\r\n                this._isTextHighlightOn = false;\r\n                this._blinkIsEven = false;\r\n\r\n                this._textWrapper.removePart(this._cursorInfo.globalStartIndex, this._cursorInfo.globalEndIndex, key);\r\n                this._cursorInfo.globalStartIndex += key.length;\r\n                this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\r\n\r\n                this._textHasChanged();\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _parseLineWordWrap(line: string = \"\", width: number, context: ICanvasRenderingContext): { text: string; width: number; lineEnding: string }[] {\r\n        const lines = [];\r\n        const words = line.split(\" \");\r\n        let lineWidth = 0;\r\n\r\n        for (let n = 0; n < words.length; n++) {\r\n            const testLine = n > 0 ? line + \" \" + words[n] : words[0];\r\n            const metrics = context.measureText(testLine);\r\n            const testWidth = metrics.width;\r\n            if (testWidth > width) {\r\n                if (n > 0) {\r\n                    // Avoid first word duplication if of too long\r\n                    lineWidth = context.measureText(line).width;\r\n                    lines.push({ text: line, width: lineWidth, lineEnding: \" \" });\r\n                }\r\n\r\n                line = words[n];\r\n\r\n                let flushedLine = \"\";\r\n\r\n                line.split(\"\").map((char) => {\r\n                    if (context.measureText(flushedLine + char).width > width) {\r\n                        lines.push({ text: flushedLine, width: context.measureText(flushedLine).width, lineEnding: \"\" });\r\n                        flushedLine = \"\";\r\n                    }\r\n                    flushedLine += char;\r\n                });\r\n\r\n                line = flushedLine;\r\n                // Measure remaining characters\r\n                lineWidth = context.measureText(line).width;\r\n            } else {\r\n                lineWidth = testWidth;\r\n                line = testLine;\r\n            }\r\n        }\r\n        lines.push({ text: line, width: lineWidth, lineEnding: \" \" });\r\n\r\n        return lines;\r\n    }\r\n\r\n    protected _breakLines(refWidth: number, context: ICanvasRenderingContext): object[] {\r\n        const lines: { text: string; width: number; lineEnding: string }[] = [];\r\n        const _lines = this.text.split(\"\\n\");\r\n\r\n        if (this.clipContent) {\r\n            for (const _line of _lines) {\r\n                lines.push(...this._parseLineWordWrap(_line, refWidth, context));\r\n            }\r\n        } else {\r\n            for (const _line of _lines) {\r\n                lines.push(this._parseLine(_line, context));\r\n            }\r\n        }\r\n\r\n        lines[lines.length - 1].lineEnding = \"\\n\";\r\n\r\n        return lines;\r\n    }\r\n\r\n    protected _parseLine(line: string = \"\", context: ICanvasRenderingContext): { text: string; width: number; lineEnding: string } {\r\n        return { text: line, width: context.measureText(line).width, lineEnding: \" \" };\r\n    }\r\n\r\n    /**\r\n     * Processing of child right before the parent measurement update\r\n     *\r\n     * @param parentMeasure The parent measure\r\n     * @param context The rendering canvas\r\n     * @internal\r\n     */\r\n    protected _preMeasure(parentMeasure: Measure, context: ICanvasRenderingContext): void {\r\n        if (!this._fontOffset || this._wasDirty) {\r\n            this._fontOffset = Control._GetFontOffset(context.font);\r\n        }\r\n\r\n        let text = this._beforeRenderText(this._textWrapper).text;\r\n\r\n        // placeholder conditions and color setting\r\n        if (!this._isFocused && !this.text && this._placeholderText) {\r\n            text = this._placeholderText;\r\n\r\n            if (this._placeholderColor) {\r\n                context.fillStyle = this._placeholderColor;\r\n            }\r\n        }\r\n\r\n        // measures the textlength -> this.measure.width\r\n        this._textWidth = context.measureText(text).width;\r\n        // we double up the margin width\r\n        const marginWidth = this._margin.getValueInPixel(this._host, parentMeasure.width) * 2;\r\n\r\n        if (this._autoStretchWidth) {\r\n            const tmpLines = text.split(\"\\n\");\r\n            const longerString = tmpLines.reduce((acc: string, val: string) => {\r\n                const valueLength = context.measureText(val).width;\r\n                const accLength = context.measureText(acc).width;\r\n                return valueLength > accLength ? val : acc;\r\n            }, \"\");\r\n\r\n            const longerStringWidth = context.measureText(longerString).width;\r\n            this.width = Math.min(this._maxWidth.getValueInPixel(this._host, parentMeasure.width), longerStringWidth + marginWidth) + \"px\";\r\n\r\n            this.autoStretchWidth = true;\r\n        }\r\n\r\n        this._availableWidth = this._width.getValueInPixel(this._host, parentMeasure.width) - marginWidth;\r\n\r\n        // Prepare lines\r\n        this._lines = this._breakLines(this._availableWidth, context);\r\n        // can we find a cleaner implementation here?\r\n        this._contextForBreakLines = context;\r\n\r\n        if (this._autoStretchHeight) {\r\n            const textHeight = this._lines.length * this._fontOffset.height;\r\n            const totalHeight = textHeight + this._margin.getValueInPixel(this._host, parentMeasure.height) * 2;\r\n            this.height = Math.min(this._maxHeight.getValueInPixel(this._host, parentMeasure.height), totalHeight) + \"px\";\r\n\r\n            this._autoStretchHeight = true;\r\n        }\r\n\r\n        this._availableHeight = this._height.getValueInPixel(this._host, parentMeasure.height) - marginWidth;\r\n\r\n        if (this._isFocused) {\r\n            this._cursorInfo.currentLineIndex = 0;\r\n\r\n            let lineLength = this._lines[this._cursorInfo.currentLineIndex].text.length + this._lines[this._cursorInfo.currentLineIndex].lineEnding.length;\r\n            let tmpLength = 0;\r\n\r\n            while (tmpLength + lineLength <= this._cursorInfo.globalStartIndex) {\r\n                tmpLength += lineLength;\r\n\r\n                if (this._cursorInfo.currentLineIndex < this._lines.length - 1) {\r\n                    this._cursorInfo.currentLineIndex++;\r\n                    lineLength = this._lines[this._cursorInfo.currentLineIndex].text.length + this._lines[this._cursorInfo.currentLineIndex].lineEnding.length;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _computeScroll() {\r\n        this._clipTextLeft = this._currentMeasure.left + this._margin.getValueInPixel(this._host, this._cachedParentMeasure.width);\r\n        this._clipTextTop = this._currentMeasure.top + this._margin.getValueInPixel(this._host, this._cachedParentMeasure.height);\r\n\r\n        if (this._isFocused && this._lines[this._cursorInfo.currentLineIndex].width > this._availableWidth) {\r\n            const textLeft = this._clipTextLeft - this._lines[this._cursorInfo.currentLineIndex].width + this._availableWidth;\r\n\r\n            if (!this._scrollLeft) {\r\n                this._scrollLeft = textLeft;\r\n            }\r\n        } else {\r\n            this._scrollLeft = this._clipTextLeft;\r\n        }\r\n\r\n        if (this._isFocused && !this._autoStretchHeight) {\r\n            const selectedHeight = (this._cursorInfo.currentLineIndex + 1) * this._fontOffset.height;\r\n            const textTop = this._clipTextTop - selectedHeight;\r\n\r\n            if (!this._scrollTop) {\r\n                this._scrollTop = textTop;\r\n            }\r\n        } else {\r\n            this._scrollTop = this._clipTextTop;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Processing of child after the parent measurement update\r\n     *\r\n     * @internal\r\n     */\r\n    protected _additionalProcessing(): void {\r\n        // Flush the highlighted text each frame\r\n        this.highlightedText = \"\";\r\n\r\n        this.onLinesReadyObservable.notifyObservers(this);\r\n    }\r\n\r\n    private _drawText(text: string, textWidth: number, y: number, context: ICanvasRenderingContext): void {\r\n        const width = this._currentMeasure.width;\r\n        let x = this._scrollLeft as number;\r\n        switch (this._textHorizontalAlignment) {\r\n            case Control.HORIZONTAL_ALIGNMENT_LEFT:\r\n                x += 0;\r\n                break;\r\n            case Control.HORIZONTAL_ALIGNMENT_RIGHT:\r\n                x += width - textWidth;\r\n                break;\r\n            case Control.HORIZONTAL_ALIGNMENT_CENTER:\r\n                x += (width - textWidth) / 2;\r\n                break;\r\n        }\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowColor = this.shadowColor;\r\n            context.shadowBlur = this.shadowBlur;\r\n            context.shadowOffsetX = this.shadowOffsetX;\r\n            context.shadowOffsetY = this.shadowOffsetY;\r\n        }\r\n\r\n        if (this.outlineWidth) {\r\n            context.strokeText(text, this._currentMeasure.left + x, y);\r\n        }\r\n        context.fillText(text, x, y);\r\n    }\r\n\r\n    /**\r\n     * Copy the text in the clipboard\r\n     *\r\n     * @param ev The clipboard event\r\n     * @internal\r\n     */\r\n    protected _onCopyText(ev: ClipboardEvent): void {\r\n        this._isTextHighlightOn = false;\r\n        //when write permission to clipbaord data is denied\r\n        try {\r\n            ev.clipboardData && ev.clipboardData.setData(\"text/plain\", this._highlightedText);\r\n        } catch {} //pass\r\n        this._host.clipboardData = this._highlightedText;\r\n    }\r\n\r\n    /**\r\n     * Cut the text and copy it in the clipboard\r\n     *\r\n     * @param ev The clipboard event\r\n     * @internal\r\n     */\r\n    protected _onCutText(ev: ClipboardEvent): void {\r\n        if (!this._highlightedText) {\r\n            return;\r\n        }\r\n        //when write permission to clipbaord data is denied\r\n        try {\r\n            ev.clipboardData && ev.clipboardData.setData(\"text/plain\", this._highlightedText);\r\n        } catch {} //pass\r\n\r\n        this._host.clipboardData = this._highlightedText;\r\n\r\n        this._textWrapper.removePart(this._cursorInfo.globalStartIndex, this._cursorInfo.globalEndIndex);\r\n\r\n        this._textHasChanged();\r\n    }\r\n\r\n    /**\r\n     * Paste the copied text from the clipboard\r\n     *\r\n     * @param ev The clipboard event\r\n     * @internal\r\n     */\r\n    protected _onPasteText(ev: ClipboardEvent): void {\r\n        let data: string = \"\";\r\n        if (ev.clipboardData && ev.clipboardData.types.indexOf(\"text/plain\") !== -1) {\r\n            data = ev.clipboardData.getData(\"text/plain\");\r\n        } else {\r\n            //get the cached data; returns blank string by default\r\n            data = this._host.clipboardData;\r\n        }\r\n\r\n        this._isTextHighlightOn = false;\r\n\r\n        this._textWrapper.removePart(this._cursorInfo.globalStartIndex, this._cursorInfo.globalEndIndex, data);\r\n\r\n        const deltaIndex = data.length - (this._cursorInfo.globalEndIndex - this._cursorInfo.globalStartIndex);\r\n\r\n        this._cursorInfo.globalStartIndex += deltaIndex;\r\n        this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\r\n\r\n        this._textHasChanged();\r\n    }\r\n\r\n    public _draw(context: ICanvasRenderingContext): void {\r\n        this._computeScroll();\r\n\r\n        this._scrollLeft = this._scrollLeft ?? 0;\r\n        this._scrollTop = this._scrollTop ?? 0;\r\n\r\n        context.save();\r\n\r\n        this._applyStates(context);\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowColor = this.shadowColor;\r\n            context.shadowBlur = this.shadowBlur;\r\n            context.shadowOffsetX = this.shadowOffsetX;\r\n            context.shadowOffsetY = this.shadowOffsetY;\r\n        }\r\n\r\n        // Background\r\n        if (this._isFocused) {\r\n            if (this._focusedBackground) {\r\n                context.fillStyle = this._isEnabled ? this._focusedBackground : this._disabledColor;\r\n\r\n                context.fillRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\r\n            }\r\n        } else if (this._background) {\r\n            context.fillStyle = this._isEnabled ? this._background : this._disabledColor;\r\n\r\n            context.fillRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\r\n        }\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowBlur = 0;\r\n            context.shadowOffsetX = 0;\r\n            context.shadowOffsetY = 0;\r\n        }\r\n\r\n        // sets the color of the rectangle (border if background available)\r\n        if (this.color) {\r\n            context.fillStyle = this.color;\r\n        }\r\n\r\n        const height = this._currentMeasure.height;\r\n        const width = this._currentMeasure.width;\r\n        let rootY = 0;\r\n\r\n        switch (this._textVerticalAlignment) {\r\n            case Control.VERTICAL_ALIGNMENT_TOP:\r\n                rootY = this._fontOffset.ascent;\r\n                break;\r\n            case Control.VERTICAL_ALIGNMENT_BOTTOM:\r\n                rootY = height - this._fontOffset.height * (this._lines.length - 1) - this._fontOffset.descent;\r\n                break;\r\n            case Control.VERTICAL_ALIGNMENT_CENTER:\r\n                rootY = this._fontOffset.ascent + (height - this._fontOffset.height * this._lines.length) / 2;\r\n                break;\r\n        }\r\n\r\n        context.save();\r\n        context.beginPath();\r\n        context.fillStyle = this.fontStyle;\r\n\r\n        // here we define the visible reactangle to clip it in next line\r\n        context.rect(this._clipTextLeft, this._clipTextTop, this._availableWidth + 2, this._availableHeight + 2);\r\n        context.clip();\r\n\r\n        // Text\r\n        rootY += this._scrollTop;\r\n\r\n        for (let i = 0; i < this._lines.length; i++) {\r\n            const line = this._lines[i];\r\n\r\n            if (i !== 0 && this._lineSpacing.internalValue !== 0) {\r\n                if (this._lineSpacing.isPixel) {\r\n                    rootY += this._lineSpacing.getValue(this._host);\r\n                } else {\r\n                    rootY = rootY + this._lineSpacing.getValue(this._host) * this._height.getValueInPixel(this._host, this._cachedParentMeasure.height);\r\n                }\r\n            }\r\n\r\n            this._drawText(line.text, line.width, rootY, context);\r\n            rootY += this._fontOffset.height;\r\n        }\r\n\r\n        context.restore();\r\n\r\n        // Cursor\r\n        if (this._isFocused) {\r\n            // Render cursor\r\n            if (!this._blinkIsEven || this._isTextHighlightOn) {\r\n                let cursorLeft = this._scrollLeft + context.measureText(this._lines[this._cursorInfo.currentLineIndex].text.substr(0, this._cursorInfo.relativeStartIndex)).width;\r\n\r\n                if (cursorLeft < this._clipTextLeft) {\r\n                    this._scrollLeft += this._clipTextLeft - cursorLeft;\r\n                    cursorLeft = this._clipTextLeft;\r\n                    this._markAsDirty();\r\n                } else if (cursorLeft > this._clipTextLeft + this._availableWidth) {\r\n                    this._scrollLeft += this._clipTextLeft + this._availableWidth - cursorLeft;\r\n                    cursorLeft = this._clipTextLeft + this._availableWidth;\r\n                    this._markAsDirty();\r\n                }\r\n\r\n                let cursorTop = this._scrollTop + this._cursorInfo.currentLineIndex * this._fontOffset.height; //cursorTop distance from top to cursor start\r\n\r\n                if (cursorTop < this._clipTextTop) {\r\n                    this._scrollTop += this._clipTextTop - cursorTop;\r\n                    cursorTop = this._clipTextTop;\r\n                    this._markAsDirty();\r\n                } else if (cursorTop + this._fontOffset.height > this._clipTextTop + this._availableHeight) {\r\n                    this._scrollTop += this._clipTextTop + this._availableHeight - cursorTop - this._fontOffset.height;\r\n                    cursorTop = this._clipTextTop + this._availableHeight - this._fontOffset.height;\r\n                    this._markAsDirty();\r\n                }\r\n\r\n                if (!this._isTextHighlightOn) {\r\n                    context.fillRect(cursorLeft, cursorTop, 2, this._fontOffset.height);\r\n                }\r\n            }\r\n\r\n            this._resetBlinking();\r\n\r\n            //show the highlighted text\r\n            if (this._isTextHighlightOn) {\r\n                clearTimeout(this._blinkTimeout);\r\n\r\n                this._highlightedText = this.text.substring(this._cursorInfo.globalStartIndex, this._cursorInfo.globalEndIndex);\r\n\r\n                context.globalAlpha = this._highligherOpacity;\r\n                context.fillStyle = this._textHighlightColor;\r\n\r\n                const startLineIndex = Math.min(this._cursorInfo.currentLineIndex, this._highlightCursorInfo.initialLineIndex);\r\n                const endLineIndex = Math.max(this._cursorInfo.currentLineIndex, this._highlightCursorInfo.initialLineIndex);\r\n\r\n                let highlightRootY = this._scrollTop + startLineIndex * this._fontOffset.height;\r\n\r\n                for (let i = startLineIndex; i <= endLineIndex; i++) {\r\n                    const line = this._lines[i];\r\n\r\n                    let highlightRootX = this._scrollLeft as number;\r\n                    switch (this._textHorizontalAlignment) {\r\n                        case Control.HORIZONTAL_ALIGNMENT_LEFT:\r\n                            highlightRootX += 0;\r\n                            break;\r\n                        case Control.HORIZONTAL_ALIGNMENT_RIGHT:\r\n                            highlightRootX += width - line.width;\r\n                            break;\r\n                        case Control.HORIZONTAL_ALIGNMENT_CENTER:\r\n                            highlightRootX += (width - line.width) / 2;\r\n                            break;\r\n                    }\r\n\r\n                    const begin = i === startLineIndex ? this._cursorInfo.relativeStartIndex : 0;\r\n                    const end = i === endLineIndex ? this._cursorInfo.relativeEndIndex : line.text.length;\r\n\r\n                    const leftOffsetWidth = context.measureText(line.text.substr(0, begin)).width;\r\n                    const selectedText = line.text.substring(begin, end);\r\n                    const hightlightWidth = context.measureText(selectedText).width;\r\n\r\n                    context.fillRect(highlightRootX + leftOffsetWidth, highlightRootY, hightlightWidth, this._fontOffset.height);\r\n\r\n                    highlightRootY += this._fontOffset.height;\r\n                }\r\n\r\n                if (this._cursorInfo.globalEndIndex === this._cursorInfo.globalStartIndex) {\r\n                    this._resetBlinking();\r\n                }\r\n            }\r\n        }\r\n\r\n        context.restore();\r\n\r\n        // Border\r\n        if (this._thickness) {\r\n            if (this._isFocused) {\r\n                if (this.focusedColor) {\r\n                    context.strokeStyle = this.focusedColor;\r\n                }\r\n            } else {\r\n                if (this.color) {\r\n                    context.strokeStyle = this.color;\r\n                }\r\n            }\r\n\r\n            context.lineWidth = this._thickness;\r\n\r\n            context.strokeRect(\r\n                this._currentMeasure.left + this._thickness / 2,\r\n                this._currentMeasure.top + this._thickness / 2,\r\n                this._currentMeasure.width - this._thickness,\r\n                this._currentMeasure.height - this._thickness\r\n            );\r\n        }\r\n    }\r\n\r\n    private _resetBlinking() {\r\n        clearTimeout(this._blinkTimeout);\r\n        this._blinkTimeout = <any>setTimeout(() => {\r\n            this._blinkIsEven = !this._blinkIsEven;\r\n            this._markAsDirty();\r\n        }, 500);\r\n    }\r\n\r\n    protected _applyStates(context: ICanvasRenderingContext): void {\r\n        super._applyStates(context);\r\n        if (this.outlineWidth) {\r\n            context.lineWidth = this.outlineWidth;\r\n            context.strokeStyle = this.outlineColor;\r\n        }\r\n    }\r\n\r\n    public _onPointerDown(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, pi: PointerInfoBase): boolean {\r\n        if (!super._onPointerDown(target, coordinates, pointerId, buttonIndex, pi)) {\r\n            return false;\r\n        }\r\n\r\n        this._clickedCoordinateX = coordinates.x;\r\n        this._clickedCoordinateY = coordinates.y;\r\n\r\n        this._isTextHighlightOn = false;\r\n        this._highlightedText = \"\";\r\n        this._isPointerDown = true;\r\n        this._host._capturingControl[pointerId] = this;\r\n        if (this._host.focusedControl === this) {\r\n            // Move cursor\r\n            clearTimeout(this._blinkTimeout);\r\n            this._markAsDirty();\r\n            return true;\r\n        }\r\n        if (!this._isEnabled) {\r\n            return false;\r\n        }\r\n        this._host.focusedControl = this;\r\n\r\n        return true;\r\n    }\r\n\r\n    // for textselection\r\n    public _onPointerMove(target: Control, coordinates: Vector2, pointerId: number, pi: PointerInfoBase): void {\r\n        // Avoid Chromium-like beahavior when this event is fired right after onPointerDown\r\n        if (pi.event.movementX === 0 && pi.event.movementY === 0) {\r\n            return;\r\n        }\r\n\r\n        if (this._host.focusedControl === this && this._isPointerDown) {\r\n            this._clickedCoordinateX = coordinates.x;\r\n            this._clickedCoordinateY = coordinates.y;\r\n\r\n            if (!this._isTextHighlightOn) {\r\n                this._highlightCursorInfo.initialLineIndex = this._cursorInfo.currentLineIndex;\r\n                this._highlightCursorInfo.initialStartIndex = this._cursorInfo.globalStartIndex;\r\n                this._highlightCursorInfo.initialRelativeStartIndex = this._cursorInfo.relativeStartIndex;\r\n\r\n                this._isTextHighlightOn = true;\r\n            }\r\n\r\n            this._markAsDirty();\r\n        }\r\n        super._onPointerMove(target, coordinates, pointerId, pi);\r\n    }\r\n\r\n    /**\r\n     * Apply the correct position of cursor according to current modification\r\n     */\r\n    private _updateCursorPosition() {\r\n        if (!this._isFocused) {\r\n            return;\r\n        }\r\n\r\n        if (this._clickedCoordinateX && this._clickedCoordinateY) {\r\n            if (!this._isTextHighlightOn) {\r\n                this._cursorInfo = {\r\n                    globalStartIndex: 0,\r\n                    globalEndIndex: 0,\r\n                    relativeStartIndex: 0,\r\n                    relativeEndIndex: 0,\r\n                    currentLineIndex: 0,\r\n                };\r\n            }\r\n\r\n            let globalIndex = 0;\r\n            let relativeIndex = 0;\r\n\r\n            const lastClickedCoordinateY = this._clickedCoordinateY - (this._scrollTop as number);\r\n\r\n            const relativeCoordinateY = Math.floor(lastClickedCoordinateY / this._fontOffset.height);\r\n            this._cursorInfo.currentLineIndex = Math.min(Math.max(relativeCoordinateY, 0), this._lines.length - 1);\r\n\r\n            let currentSize = 0;\r\n\r\n            const relativeXPosition = this._clickedCoordinateX - (this._scrollLeft ?? 0);\r\n\r\n            let previousDist = 0;\r\n\r\n            for (let index = 0; index < this._cursorInfo.currentLineIndex; index++) {\r\n                const line = this._lines[index];\r\n                globalIndex += line.text.length + line.lineEnding.length;\r\n            }\r\n\r\n            while (currentSize < relativeXPosition && this._lines[this._cursorInfo.currentLineIndex].text.length > relativeIndex) {\r\n                relativeIndex++;\r\n                previousDist = Math.abs(relativeXPosition - currentSize);\r\n                currentSize = this._contextForBreakLines.measureText(this._lines[this._cursorInfo.currentLineIndex].text.substr(0, relativeIndex)).width;\r\n            }\r\n\r\n            // Find closest move\r\n            if (Math.abs(relativeXPosition - currentSize) > previousDist && relativeIndex > 0) {\r\n                relativeIndex--;\r\n            }\r\n\r\n            globalIndex += relativeIndex;\r\n\r\n            if (!this._isTextHighlightOn) {\r\n                this._cursorInfo.globalStartIndex = globalIndex;\r\n                this._cursorInfo.relativeStartIndex = relativeIndex;\r\n                this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\r\n                this._cursorInfo.relativeEndIndex = this._cursorInfo.relativeStartIndex;\r\n            } else {\r\n                if (globalIndex < this._highlightCursorInfo.initialStartIndex) {\r\n                    this._cursorInfo.globalStartIndex = globalIndex;\r\n                    this._cursorInfo.relativeStartIndex = relativeIndex;\r\n                    this._cursorInfo.globalEndIndex = this._highlightCursorInfo.initialStartIndex;\r\n                    this._cursorInfo.relativeEndIndex = this._highlightCursorInfo.initialRelativeStartIndex;\r\n                } else {\r\n                    this._cursorInfo.globalStartIndex = this._highlightCursorInfo.initialStartIndex;\r\n                    this._cursorInfo.relativeStartIndex = this._highlightCursorInfo.initialRelativeStartIndex;\r\n                    this._cursorInfo.globalEndIndex = globalIndex;\r\n                    this._cursorInfo.relativeEndIndex = relativeIndex;\r\n                }\r\n            }\r\n\r\n            // Avoid the caret during highlighting\r\n            this._blinkIsEven = this._isTextHighlightOn;\r\n            this._clickedCoordinateX = null;\r\n            this._clickedCoordinateY = null;\r\n        } else {\r\n            // Standard behavior same as Current line is at least above the initial highlight index\r\n            this._cursorInfo.relativeStartIndex = 0;\r\n            this._cursorInfo.currentLineIndex = 0;\r\n\r\n            let lineLength = this._lines[this._cursorInfo.currentLineIndex].text.length + this._lines[this._cursorInfo.currentLineIndex].lineEnding.length;\r\n            let tmpLength = 0;\r\n\r\n            while (tmpLength + lineLength <= this._cursorInfo.globalStartIndex) {\r\n                tmpLength += lineLength;\r\n\r\n                if (this._cursorInfo.currentLineIndex < this._lines.length - 1) {\r\n                    this._cursorInfo.currentLineIndex++;\r\n                    lineLength = this._lines[this._cursorInfo.currentLineIndex].text.length + this._lines[this._cursorInfo.currentLineIndex].lineEnding.length;\r\n                }\r\n            }\r\n\r\n            this._cursorInfo.relativeStartIndex = this._cursorInfo.globalStartIndex - tmpLength;\r\n\r\n            if (this._highlightCursorInfo.initialStartIndex !== -1 && this._cursorInfo.globalStartIndex >= this._highlightCursorInfo.initialStartIndex) {\r\n                // Current line is at least below the initial highlight index\r\n                while (tmpLength + lineLength <= this._cursorInfo.globalEndIndex) {\r\n                    tmpLength += lineLength;\r\n\r\n                    if (this._cursorInfo.currentLineIndex < this._lines.length - 1) {\r\n                        this._cursorInfo.currentLineIndex++;\r\n                        lineLength = this._lines[this._cursorInfo.currentLineIndex].text.length + this._lines[this._cursorInfo.currentLineIndex].lineEnding.length;\r\n                    }\r\n                }\r\n\r\n                this._cursorInfo.relativeEndIndex = this._cursorInfo.globalEndIndex - tmpLength;\r\n            } else if (!this._isTextHighlightOn) {\r\n                this._cursorInfo.relativeEndIndex = this._cursorInfo.relativeStartIndex;\r\n                this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update all values of cursor information based on cursorIndex value\r\n     *\r\n     * @param offset The index to take care of\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _updateValueFromCursorIndex(offset: number) {\r\n        // Override to avoid parent behavior during _onPointerMove\r\n    }\r\n\r\n    /**\r\n     * Select the word immediatly under the cursor on double click\r\n     *\r\n     * @param _evt Pointer informations of double click\r\n     * @internal\r\n     */\r\n    protected _processDblClick(_evt: PointerInfo) {\r\n        //pre-find the start and end index of the word under cursor, speeds up the rendering\r\n        let moveLeft, moveRight;\r\n        do {\r\n            moveLeft = this._cursorInfo.globalStartIndex > 0 && this._textWrapper.isWord(this._cursorInfo.globalStartIndex - 1) ? --this._cursorInfo.globalStartIndex : 0;\r\n            moveRight =\r\n                this._cursorInfo.globalEndIndex < this._textWrapper.length && this._textWrapper.isWord(this._cursorInfo.globalEndIndex) ? ++this._cursorInfo.globalEndIndex : 0;\r\n        } while (moveLeft || moveRight);\r\n\r\n        this._highlightCursorInfo.initialLineIndex = this._cursorInfo.currentLineIndex;\r\n        this._highlightCursorInfo.initialStartIndex = this._cursorInfo.globalStartIndex;\r\n\r\n        this.onTextHighlightObservable.notifyObservers(this);\r\n\r\n        this._isTextHighlightOn = true;\r\n        this._blinkIsEven = true;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** @internal */\r\n    protected _selectAllText() {\r\n        this._isTextHighlightOn = true;\r\n        this._blinkIsEven = true;\r\n\r\n        this._highlightCursorInfo = {\r\n            initialStartIndex: 0,\r\n            initialRelativeStartIndex: 0,\r\n            initialLineIndex: 0,\r\n        };\r\n\r\n        this._cursorInfo = {\r\n            globalStartIndex: 0,\r\n            globalEndIndex: this._textWrapper.length,\r\n            relativeEndIndex: this._lines[this._lines.length - 1].text.length,\r\n            relativeStartIndex: 0,\r\n            currentLineIndex: this._lines.length - 1,\r\n        };\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    public dipose() {\r\n        super.dispose();\r\n\r\n        this.onLinesReadyObservable.clear();\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.InputTextArea\", InputTextArea);\r\n"],"mappings":";;AACA,SAASA,UAAU,QAAE;AAGrB,SAASC,OAAO,QAAQ,cAAY;AACpC,SAASC,YAAY,QAAQ,oBAAkB;AAE/C,SAASC,aAAa,QAAE;AAExB,SAASC,SAAS,QAAQ,gBAAc;AAKxC,SAASC,SAAS,QAAE;AAEpB;;;AAGA,OAAM,MAAOC,aAAc,SAAQF,SAAS;EAkCxC;;;EAGA,IAAWG,YAAYA,CAAA;IACnB,OAAO,IAAI,CAACC,aAAa;EAC7B;EAEA;;;EAGA,IAAWD,YAAYA,CAACE,KAAa;IACjC,IAAI,IAAI,CAACD,aAAa,KAAKC,KAAK,EAAE;MAC9B;;IAEJ,IAAI,CAACD,aAAa,GAAGC,KAAK;IAC1B,IAAI,CAACC,YAAY,EAAE;EACvB;EAEA;;;EAGA,IAAWC,YAAYA,CAAA;IACnB,OAAO,IAAI,CAACC,aAAa;EAC7B;EAEA;;;EAGA,IAAWD,YAAYA,CAACF,KAAa;IACjC,IAAI,IAAI,CAACG,aAAa,KAAKH,KAAK,EAAE;MAC9B;;IAEJ,IAAI,CAACG,aAAa,GAAGH,KAAK;IAC1B,IAAI,CAACC,YAAY,EAAE;EACvB;EAEA;EAEA,IAAWG,iBAAiBA,CAAA;IACxB,OAAO,IAAI,CAACC,kBAAkB;EAClC;EAEA,IAAWD,iBAAiBA,CAACJ,KAAc;IACvC,IAAI,IAAI,CAACK,kBAAkB,KAAKL,KAAK,EAAE;MACnC;;IAGJ,IAAI,CAACK,kBAAkB,GAAGL,KAAK;IAC/B,IAAI,CAACC,YAAY,EAAE;EACvB;EAEA,IAAWK,MAAMA,CAACN,KAAsB;IACpC,IAAI,CAACO,uBAAuB,GAAG,KAAK;IAEpC,IAAI,IAAI,CAACC,OAAO,CAACC,QAAQ,CAAC,IAAI,CAACC,KAAK,CAAC,KAAKV,KAAK,EAAE;MAC7C;;IAGJ,IAAI,IAAI,CAACQ,OAAO,CAACG,UAAU,CAACX,KAAK,CAAC,EAAE;MAChC,IAAI,CAACC,YAAY,EAAE;;IAGvB,IAAI,CAACI,kBAAkB,GAAG,KAAK;EACnC;EAGA,IAAWO,SAASA,CAAA;IAChB,OAAO,IAAI,CAACC,UAAU,CAACJ,QAAQ,CAAC,IAAI,CAACC,KAAK,CAAC;EAC/C;EAEA;EACA,IAAWI,iBAAiBA,CAAA;IACxB,OAAO,IAAI,CAACD,UAAU,CAACE,eAAe,CAAC,IAAI,CAACL,KAAK,EAAE,IAAI,CAACM,oBAAoB,CAACV,MAAM,CAAC;EACxF;EAEA,IAAWM,SAASA,CAACZ,KAAsB;IACvC,IAAI,IAAI,CAACa,UAAU,CAACJ,QAAQ,CAAC,IAAI,CAACC,KAAK,CAAC,KAAKV,KAAK,EAAE;MAChD;;IAGJ,IAAI,IAAI,CAACa,UAAU,CAACF,UAAU,CAACX,KAAK,CAAC,EAAE;MACnC,IAAI,CAACC,YAAY,EAAE;;EAE3B;EAEA;;;;;EAKAgB,YAAmBC,IAAa,EAAEC,IAAA,GAAe,EAAE;IAC/C,KAAK,CAACD,IAAI,CAAC;IADI,KAAAA,IAAI,GAAJA,IAAI;IA3Hf,KAAAE,wBAAwB,GAAG5B,OAAO,CAAC6B,yBAAyB;IAC5D,KAAAC,sBAAsB,GAAG9B,OAAO,CAAC+B,sBAAsB;IAGvD,KAAAC,YAAY,GAAiB,IAAI/B,YAAY,CAAC,CAAC,CAAC;IAChD,KAAAM,aAAa,GAAW,CAAC;IACzB,KAAAI,aAAa,GAAW,OAAO;IAC/B,KAAAU,UAAU,GAAG,IAAIpB,YAAY,CAAC,CAAC,EAAEA,YAAY,CAACgC,mBAAmB,EAAE,KAAK,CAAC;IAQjF;;;IAGO,KAAAC,sBAAsB,GAAG,IAAInC,UAAU,EAAiB;IA4G3D,IAAI,CAAC4B,IAAI,GAAGA,IAAI;IAEhB,IAAI,CAACQ,gBAAgB,GAAG,IAAI;IAE5B,IAAI,CAACD,sBAAsB,CAACE,GAAG,CAAC,MAAM,IAAI,CAACC,qBAAqB,EAAE,CAAC;IAEnE,IAAI,CAACC,oBAAoB,GAAG;MACxBC,iBAAiB,EAAE,CAAC,CAAC;MACrBC,yBAAyB,EAAE,CAAC,CAAC;MAC7BC,gBAAgB,EAAE,CAAC;KACtB;IAED,IAAI,CAACC,WAAW,GAAG;MACfC,gBAAgB,EAAE,CAAC;MACnBC,cAAc,EAAE,CAAC;MACjBC,gBAAgB,EAAE,CAAC;MACnBC,kBAAkB,EAAE,CAAC;MACrBC,gBAAgB,EAAE;KACrB;EACL;EAEUC,YAAYA,CAAA;IAClB,OAAO,eAAe;EAC1B;EAEA;;;;EAIOC,eAAeA,CAACC,GAAmB;IACtC;IACA,IAAI,CAACC,qBAAqB,CAACD,GAAG,CAACE,IAAI,EAAEF,GAAG,CAACG,GAAG,EAAEH,GAAG,CAAC;IAElD,IAAI,CAACI,kCAAkC,CAACC,eAAe,CAACL,GAAG,CAAC;EAChE;EAEA;;;;;;;;EAQOC,qBAAqBA,CAACC,IAAY,EAAEC,GAAY,EAAEH,GAAoB;IACzE;IACA,IAAIA,GAAG,KAAKA,GAAG,CAACM,OAAO,IAAIN,GAAG,CAACO,OAAO,CAAC,KAAKL,IAAI,KAAK,MAAM,IAAIA,IAAI,KAAK,MAAM,IAAIA,IAAI,KAAK,MAAM,CAAC,EAAE;MAChG;;IAGJ;IACA,QAAQA,IAAI;MACR,KAAK,MAAM;QAAE;QACT,IAAIF,GAAG,KAAKA,GAAG,CAACM,OAAO,IAAIN,GAAG,CAACO,OAAO,CAAC,EAAE;UACrC,IAAI,CAACC,cAAc,EAAE;UACrBR,GAAG,CAACS,cAAc,EAAE;UACpB;;QAEJ;MACJ,KAAK,QAAQ;QAAE;QACX,IAAIT,GAAG,IAAIA,GAAG,CAACU,QAAQ,EAAE;UACrBV,GAAG,CAACS,cAAc,EAAE;;QAExB;MACJ,KAAK,WAAW;QAAE;QACd,IAAI,CAAC,IAAI,CAACE,kBAAkB,IAAI,IAAI,CAACnB,WAAW,CAACC,gBAAgB,GAAG,CAAC,EAAE;UACnE,IAAI,CAACD,WAAW,CAACE,cAAc,GAAG,IAAI,CAACF,WAAW,CAACC,gBAAgB;UACnE,IAAI,CAACD,WAAW,CAACC,gBAAgB,EAAE;;QAGvC,IAAI,CAACmB,YAAY,CAACC,UAAU,CAAC,IAAI,CAACrB,WAAW,CAACC,gBAAgB,EAAE,IAAI,CAACD,WAAW,CAACE,cAAc,CAAC;QAEhG,IAAI,CAACF,WAAW,CAACE,cAAc,GAAG,IAAI,CAACF,WAAW,CAACC,gBAAgB;QAEnE,IAAIO,GAAG,EAAE;UACLA,GAAG,CAACS,cAAc,EAAE;;QAGxB,IAAI,CAACK,YAAY,GAAG,KAAK;QACzB,IAAI,CAACH,kBAAkB,GAAG,KAAK;QAE/B,IAAI,CAACI,eAAe,EAAE;QACtB;MACJ,KAAK,QAAQ;QAAE;QACX,IAAI,CAAC,IAAI,CAACJ,kBAAkB,IAAI,IAAI,CAACnB,WAAW,CAACE,cAAc,GAAG,IAAI,CAACjB,IAAI,CAACuC,MAAM,EAAE;UAChF,IAAI,CAACxB,WAAW,CAACE,cAAc,GAAG,IAAI,CAACF,WAAW,CAACC,gBAAgB,GAAG,CAAC;;QAG3E,IAAI,CAACmB,YAAY,CAACC,UAAU,CAAC,IAAI,CAACrB,WAAW,CAACC,gBAAgB,EAAE,IAAI,CAACD,WAAW,CAACE,cAAc,CAAC;QAEhG,IAAI,CAACF,WAAW,CAACE,cAAc,GAAG,IAAI,CAACF,WAAW,CAACC,gBAAgB;QAEnE,IAAIO,GAAG,EAAE;UACLA,GAAG,CAACS,cAAc,EAAE;;QAGxB,IAAI,CAACK,YAAY,GAAG,KAAK;QACzB,IAAI,CAACH,kBAAkB,GAAG,KAAK;QAE/B,IAAI,CAACI,eAAe,EAAE;QACtB;MACJ,KAAK,OAAO;QAAE;QACV,IAAI,CAACH,YAAY,CAACC,UAAU,CAAC,IAAI,CAACrB,WAAW,CAACC,gBAAgB,EAAE,IAAI,CAACD,WAAW,CAACE,cAAc,EAAE,IAAI,CAAC;QACtG,IAAI,CAACF,WAAW,CAACC,gBAAgB,EAAE;QACnC,IAAI,CAACD,WAAW,CAACE,cAAc,GAAG,IAAI,CAACF,WAAW,CAACC,gBAAgB;QAEnE,IAAI,CAACqB,YAAY,GAAG,KAAK;QACzB,IAAI,CAACH,kBAAkB,GAAG,KAAK;QAE/B,IAAI,CAACI,eAAe,EAAE;QACtB;MACJ,KAAK,KAAK;QAAE;QACR,IAAI,CAACvB,WAAW,CAACC,gBAAgB,GAAG,IAAI,CAAChB,IAAI,CAACuC,MAAM;QACpD,IAAI,CAACF,YAAY,GAAG,KAAK;QACzB,IAAI,CAACH,kBAAkB,GAAG,KAAK;QAC/B,IAAI,CAACpD,YAAY,EAAE;QACnB;MACJ,KAAK,MAAM;QAAE;QACT,IAAI,CAACiC,WAAW,CAACC,gBAAgB,GAAG,CAAC;QACrC,IAAI,CAACqB,YAAY,GAAG,KAAK;QACzB,IAAI,CAACH,kBAAkB,GAAG,KAAK;QAC/B,IAAI,CAACpD,YAAY,EAAE;QACnB;MACJ,KAAK,WAAW;QAAE;QACd,IAAI,CAACA,YAAY,EAAE;QAEnB,IAAIyC,GAAG,IAAIA,GAAG,CAACU,QAAQ,EAAE;UACrB;UACA,IAAIV,GAAG,CAACM,OAAO,IAAIN,GAAG,CAACO,OAAO,EAAE;YAC5B;YACA,IAAI,CAACf,WAAW,CAACC,gBAAgB,IAAI,IAAI,CAACD,WAAW,CAACI,kBAAkB;YACxE,IAAI,CAACJ,WAAW,CAACE,cAAc,GAAG,IAAI,CAACN,oBAAoB,CAACC,iBAAiB;;UAEjF;UACA,IAAI,CAAC,IAAI,CAACsB,kBAAkB,EAAE;YAC1B,IAAI,CAACvB,oBAAoB,CAACG,gBAAgB,GAAG,IAAI,CAACC,WAAW,CAACK,gBAAgB;YAC9E,IAAI,CAACT,oBAAoB,CAACC,iBAAiB,GAAG,IAAI,CAACG,WAAW,CAACC,gBAAgB;YAC/E,IAAI,CAACL,oBAAoB,CAACE,yBAAyB,GAAG,IAAI,CAACE,WAAW,CAACI,kBAAkB;YAEzF,IAAI,CAACJ,WAAW,CAACE,cAAc,GAAG,IAAI,CAACF,WAAW,CAACC,gBAAgB;YACnE,IAAI,CAACD,WAAW,CAACC,gBAAgB,EAAE;YACnC,IAAI,CAACkB,kBAAkB,GAAG,IAAI;WACjC,MAAM;YACH,IAAI,IAAI,CAACnB,WAAW,CAACE,cAAc,GAAG,IAAI,CAACN,oBAAoB,CAACC,iBAAiB,EAAE;cAC/E,IAAI,CAACG,WAAW,CAACE,cAAc,EAAE;aACpC,MAAM;cACH,IAAI,CAACF,WAAW,CAACC,gBAAgB,EAAE;;;UAG3C,IAAI,CAACqB,YAAY,GAAG,IAAI;UACxBd,GAAG,CAACS,cAAc,EAAE;UACpB;;QAGJ,IAAI,IAAI,CAACE,kBAAkB,EAAE;UACzB,IAAI,CAACnB,WAAW,CAACE,cAAc,GAAG,IAAI,CAACF,WAAW,CAACC,gBAAgB;SACtE,MAAM,IAAIO,GAAG,KAAKA,GAAG,CAACM,OAAO,IAAIN,GAAG,CAACO,OAAO,CAAC,EAAE;UAC5C;UACA,IAAI,CAACf,WAAW,CAACC,gBAAgB,IAAI,IAAI,CAACD,WAAW,CAACI,kBAAkB;UACxEI,GAAG,CAACS,cAAc,EAAE;SACvB,MAAM,IAAI,IAAI,CAACjB,WAAW,CAACC,gBAAgB,GAAG,CAAC,EAAE;UAC9C,IAAI,CAACD,WAAW,CAACC,gBAAgB,EAAE;;QAGvC;QACA,IAAI,CAACqB,YAAY,GAAG,KAAK;QACzB,IAAI,CAACH,kBAAkB,GAAG,KAAK;QAC/B;MACJ,KAAK,YAAY;QAAE;QACf,IAAI,CAACpD,YAAY,EAAE;QAEnB,IAAIyC,GAAG,IAAIA,GAAG,CAACU,QAAQ,EAAE;UACrB;UACA,IAAIV,GAAG,CAACM,OAAO,IAAIN,GAAG,CAACO,OAAO,EAAE;YAC5B,MAAMU,UAAU,GAAG,IAAI,CAACC,MAAM,CAAC,IAAI,CAAC1B,WAAW,CAACK,gBAAgB,CAAC,CAACpB,IAAI,CAACuC,MAAM,GAAG,IAAI,CAACxB,WAAW,CAACG,gBAAgB,GAAG,CAAC;YACrH,IAAI,CAACH,WAAW,CAACE,cAAc,IAAIuB,UAAU;YAC7C,IAAI,CAACzB,WAAW,CAACC,gBAAgB,GAAG,IAAI,CAACL,oBAAoB,CAACC,iBAAiB;;UAEnF;UACA,IAAI,CAAC,IAAI,CAACsB,kBAAkB,EAAE;YAC1B,IAAI,CAACvB,oBAAoB,CAACG,gBAAgB,GAAG,IAAI,CAACC,WAAW,CAACK,gBAAgB;YAC9E,IAAI,CAACT,oBAAoB,CAACC,iBAAiB,GAAG,IAAI,CAACG,WAAW,CAACC,gBAAgB;YAC/E,IAAI,CAACL,oBAAoB,CAACE,yBAAyB,GAAG,IAAI,CAACE,WAAW,CAACI,kBAAkB;YAEzF,IAAI,CAACJ,WAAW,CAACE,cAAc,GAAG,IAAI,CAACF,WAAW,CAACC,gBAAgB;YACnE,IAAI,CAACD,WAAW,CAACE,cAAc,EAAE;YACjC,IAAI,CAACiB,kBAAkB,GAAG,IAAI;WACjC,MAAM;YACH,IAAI,IAAI,CAACnB,WAAW,CAACC,gBAAgB,GAAG,IAAI,CAACL,oBAAoB,CAACC,iBAAiB,EAAE;cACjF,IAAI,CAACG,WAAW,CAACC,gBAAgB,EAAE;aACtC,MAAM;cACH,IAAI,CAACD,WAAW,CAACE,cAAc,EAAE;;;UAGzC,IAAI,CAACoB,YAAY,GAAG,IAAI;UACxBd,GAAG,CAACS,cAAc,EAAE;UACpB;;QAEJ,IAAI,IAAI,CAACE,kBAAkB,EAAE;UACzB,IAAI,CAACnB,WAAW,CAACC,gBAAgB,GAAG,IAAI,CAACD,WAAW,CAACE,cAAc;SACtE,MAAM,IAAIM,GAAG,KAAKA,GAAG,CAACM,OAAO,IAAIN,GAAG,CAACO,OAAO,CAAC,EAAE;UAC5C;UACA,MAAMU,UAAU,GAAG,IAAI,CAACC,MAAM,CAAC,IAAI,CAAC1B,WAAW,CAACK,gBAAgB,CAAC,CAACpB,IAAI,CAACuC,MAAM,GAAG,IAAI,CAACxB,WAAW,CAACG,gBAAgB;UACjH,IAAI,CAACH,WAAW,CAACC,gBAAgB,IAAIwB,UAAU;SAClD,MAAM,IAAI,IAAI,CAACzB,WAAW,CAACC,gBAAgB,GAAG,IAAI,CAAChB,IAAI,CAACuC,MAAM,EAAE;UAC7D,IAAI,CAACxB,WAAW,CAACC,gBAAgB,EAAE;;QAGvC;QACA,IAAI,CAACqB,YAAY,GAAG,KAAK;QACzB,IAAI,CAACH,kBAAkB,GAAG,KAAK;QAC/B;MACJ,KAAK,SAAS;QAAE;QACZ;QACA,IAAI,CAACG,YAAY,GAAG,KAAK;QAEzB,IAAId,GAAG,EAAE;UACL,IAAIA,GAAG,CAACU,QAAQ,EAAE;YACd,IAAI,CAAC,IAAI,CAACC,kBAAkB,EAAE;cAC1B,IAAI,CAACvB,oBAAoB,CAACG,gBAAgB,GAAG,IAAI,CAACC,WAAW,CAACK,gBAAgB;cAC9E,IAAI,CAACT,oBAAoB,CAACC,iBAAiB,GAAG,IAAI,CAACG,WAAW,CAACC,gBAAgB;cAC/E,IAAI,CAACL,oBAAoB,CAACE,yBAAyB,GAAG,IAAI,CAACE,WAAW,CAACI,kBAAkB;;YAE7F,IAAI,CAACe,kBAAkB,GAAG,IAAI;YAC9B,IAAI,CAACG,YAAY,GAAG,IAAI;WAC3B,MAAM;YACH,IAAI,CAACH,kBAAkB,GAAG,KAAK;;UAEnCX,GAAG,CAACS,cAAc,EAAE;;QAGxB,IAAI,IAAI,CAACjB,WAAW,CAACK,gBAAgB,KAAK,CAAC,EAAE;UACzC;UACA,IAAI,CAACL,WAAW,CAACC,gBAAgB,GAAG,CAAC;SACxC,MAAM;UACH,MAAM0B,WAAW,GAAG,IAAI,CAACD,MAAM,CAAC,IAAI,CAAC1B,WAAW,CAACK,gBAAgB,CAAC;UAClE,MAAMuB,SAAS,GAAG,IAAI,CAACF,MAAM,CAAC,IAAI,CAAC1B,WAAW,CAACK,gBAAgB,GAAG,CAAC,CAAC;UAEpE,IAAIwB,QAAQ,GAAG,CAAC;UAChB,IAAIC,aAAa,GAAG,CAAC;UACrB,IAAI,CAAC,IAAI,CAACX,kBAAkB,IAAI,IAAI,CAACnB,WAAW,CAACK,gBAAgB,GAAG,IAAI,CAACT,oBAAoB,CAACG,gBAAgB,EAAE;YAC5G8B,QAAQ,GAAG,IAAI,CAAC7B,WAAW,CAACC,gBAAgB;YAC5C6B,aAAa,GAAG,IAAI,CAAC9B,WAAW,CAACI,kBAAkB;WACtD,MAAM;YACHyB,QAAQ,GAAG,IAAI,CAAC7B,WAAW,CAACE,cAAc;YAC1C4B,aAAa,GAAG,IAAI,CAAC9B,WAAW,CAACG,gBAAgB;;UAGrD,MAAM4B,WAAW,GAAGJ,WAAW,CAAC1C,IAAI,CAAC+C,MAAM,CAAC,CAAC,EAAEF,aAAa,CAAC;UAC7D,MAAMG,YAAY,GAAG,IAAI,CAACC,qBAAqB,CAACC,WAAW,CAACJ,WAAW,CAAC,CAACK,KAAK;UAE9E,IAAIC,UAAU,GAAG,CAAC;UAClB,IAAIC,aAAa,GAAG,CAAC;UAErBT,QAAQ,IAAIC,aAAa,CAAC,CAAC;UAC3BD,QAAQ,IAAID,SAAS,CAAC3C,IAAI,CAACuC,MAAM,GAAGI,SAAS,CAACW,UAAU,CAACf,MAAM,CAAC,CAAC;UACjE,IAAIgB,sBAAsB,GAAG,CAAC;UAE9B,OAAOH,UAAU,GAAGJ,YAAY,IAAIO,sBAAsB,GAAGZ,SAAS,CAAC3C,IAAI,CAACuC,MAAM,EAAE;YAChFK,QAAQ,EAAE;YACVW,sBAAsB,EAAE;YACxBF,aAAa,GAAGG,IAAI,CAACC,GAAG,CAACT,YAAY,GAAGI,UAAU,CAAC;YACnDA,UAAU,GAAG,IAAI,CAACH,qBAAqB,CAACC,WAAW,CAACP,SAAS,CAAC3C,IAAI,CAAC+C,MAAM,CAAC,CAAC,EAAEQ,sBAAsB,CAAC,CAAC,CAACJ,KAAK;;UAG/G;UACA,IAAIK,IAAI,CAACC,GAAG,CAACT,YAAY,GAAGI,UAAU,CAAC,GAAGC,aAAa,IAAIE,sBAAsB,GAAG,CAAC,EAAE;YACnFX,QAAQ,EAAE;;UAGd,IAAI,CAAC,IAAI,CAACV,kBAAkB,EAAE;YAC1B,IAAI,CAACnB,WAAW,CAACC,gBAAgB,GAAG4B,QAAQ;WAC/C,MAAM,IAAI,IAAI,CAAC7B,WAAW,CAACK,gBAAgB,IAAI,IAAI,CAACT,oBAAoB,CAACG,gBAAgB,EAAE;YACxF,IAAI,CAACC,WAAW,CAACC,gBAAgB,GAAG4B,QAAQ;YAC5C,IAAI,CAAC7B,WAAW,CAACE,cAAc,GAAG,IAAI,CAACN,oBAAoB,CAACC,iBAAiB;YAC7E,IAAI,CAACG,WAAW,CAACG,gBAAgB,GAAG,IAAI,CAACP,oBAAoB,CAACE,yBAAyB;WAC1F,MAAM;YACH,IAAI,CAACE,WAAW,CAACE,cAAc,GAAG2B,QAAQ;;;QAIlD,IAAI,CAAC9D,YAAY,EAAE;QACnB;MACJ,KAAK,WAAW;QAAE;QACd;QACA,IAAI,CAACuD,YAAY,GAAG,KAAK;QAEzB,IAAId,GAAG,EAAE;UACL,IAAIA,GAAG,CAACU,QAAQ,EAAE;YACd,IAAI,CAAC,IAAI,CAACC,kBAAkB,EAAE;cAC1B,IAAI,CAACvB,oBAAoB,CAACG,gBAAgB,GAAG,IAAI,CAACC,WAAW,CAACK,gBAAgB;cAC9E,IAAI,CAACT,oBAAoB,CAACC,iBAAiB,GAAG,IAAI,CAACG,WAAW,CAACC,gBAAgB;cAC/E,IAAI,CAACL,oBAAoB,CAACE,yBAAyB,GAAG,IAAI,CAACE,WAAW,CAACI,kBAAkB;;YAG7F,IAAI,CAACe,kBAAkB,GAAG,IAAI;YAC9B,IAAI,CAACG,YAAY,GAAG,IAAI;WAC3B,MAAM;YACH,IAAI,CAACH,kBAAkB,GAAG,KAAK;;UAEnCX,GAAG,CAACS,cAAc,EAAE;;QAGxB,IAAI,IAAI,CAACjB,WAAW,CAACK,gBAAgB,KAAK,IAAI,CAACqB,MAAM,CAACF,MAAM,GAAG,CAAC,EAAE;UAC9D;UACA,IAAI,CAACxB,WAAW,CAACC,gBAAgB,GAAG,IAAI,CAAChB,IAAI,CAACuC,MAAM;SACvD,MAAM;UACH,MAAMG,WAAW,GAAG,IAAI,CAACD,MAAM,CAAC,IAAI,CAAC1B,WAAW,CAACK,gBAAgB,CAAC;UAClE,MAAMsC,SAAS,GAAG,IAAI,CAACjB,MAAM,CAAC,IAAI,CAAC1B,WAAW,CAACK,gBAAgB,GAAG,CAAC,CAAC;UAEpE,IAAIwB,QAAQ,GAAG,CAAC;UAChB,IAAIC,aAAa,GAAG,CAAC;UACrB,IAAI,CAAC,IAAI,CAACX,kBAAkB,IAAI,IAAI,CAACnB,WAAW,CAACK,gBAAgB,GAAG,IAAI,CAACT,oBAAoB,CAACG,gBAAgB,EAAE;YAC5G8B,QAAQ,GAAG,IAAI,CAAC7B,WAAW,CAACC,gBAAgB;YAC5C6B,aAAa,GAAG,IAAI,CAAC9B,WAAW,CAACI,kBAAkB;WACtD,MAAM;YACHyB,QAAQ,GAAG,IAAI,CAAC7B,WAAW,CAACE,cAAc;YAC1C4B,aAAa,GAAG,IAAI,CAAC9B,WAAW,CAACG,gBAAgB;;UAGrD,MAAM4B,WAAW,GAAGJ,WAAW,CAAC1C,IAAI,CAAC+C,MAAM,CAAC,CAAC,EAAEF,aAAa,CAAC;UAC7D,MAAMG,YAAY,GAAG,IAAI,CAACC,qBAAqB,CAACC,WAAW,CAACJ,WAAW,CAAC,CAACK,KAAK;UAE9E,IAAIQ,UAAU,GAAG,CAAC;UAClB,IAAIN,aAAa,GAAG,CAAC;UAErBT,QAAQ,IAAIF,WAAW,CAAC1C,IAAI,CAACuC,MAAM,GAAGM,aAAa,GAAGH,WAAW,CAACY,UAAU,CAACf,MAAM,CAAC,CAAC;UACrF,IAAIqB,sBAAsB,GAAG,CAAC;UAE9B,OAAOD,UAAU,GAAGX,YAAY,IAAIY,sBAAsB,GAAGF,SAAS,CAAC1D,IAAI,CAACuC,MAAM,EAAE;YAChFK,QAAQ,EAAE;YACVgB,sBAAsB,EAAE;YACxBP,aAAa,GAAGG,IAAI,CAACC,GAAG,CAACT,YAAY,GAAGW,UAAU,CAAC;YACnDA,UAAU,GAAG,IAAI,CAACV,qBAAqB,CAACC,WAAW,CAACQ,SAAS,CAAC1D,IAAI,CAAC+C,MAAM,CAAC,CAAC,EAAEa,sBAAsB,CAAC,CAAC,CAACT,KAAK;;UAG/G;UACA,IAAIK,IAAI,CAACC,GAAG,CAACT,YAAY,GAAGW,UAAU,CAAC,GAAGN,aAAa,IAAIO,sBAAsB,GAAG,CAAC,EAAE;YACnFhB,QAAQ,EAAE;;UAGd,IAAI,CAAC,IAAI,CAACV,kBAAkB,EAAE;YAC1B,IAAI,CAACnB,WAAW,CAACC,gBAAgB,GAAG4B,QAAQ;WAC/C,MAAM,IAAI,IAAI,CAAC7B,WAAW,CAACK,gBAAgB,GAAG,IAAI,CAACT,oBAAoB,CAACG,gBAAgB,EAAE;YACvF,IAAI,CAACC,WAAW,CAACC,gBAAgB,GAAG4B,QAAQ;YAC5C,IAAI,IAAI,CAAC7B,WAAW,CAACC,gBAAgB,GAAG,IAAI,CAACD,WAAW,CAACE,cAAc,EAAE;cACrE,IAAI,CAACF,WAAW,CAACE,cAAc,IAAI,IAAI,CAACF,WAAW,CAACC,gBAAgB;cACpE,IAAI,CAACD,WAAW,CAACC,gBAAgB,GAAG,IAAI,CAACD,WAAW,CAACE,cAAc,GAAG,IAAI,CAACF,WAAW,CAACC,gBAAgB;cACvG,IAAI,CAACD,WAAW,CAACE,cAAc,IAAI,IAAI,CAACF,WAAW,CAACC,gBAAgB;;WAE3E,MAAM;YACH,IAAI,CAACD,WAAW,CAACE,cAAc,GAAG2B,QAAQ;YAC1C,IAAI,CAAC7B,WAAW,CAACC,gBAAgB,GAAG,IAAI,CAACL,oBAAoB,CAACC,iBAAiB;;;QAIvF,IAAI,CAAC9B,YAAY,EAAE;QACnB;;IAGR;IACA,IAAI,CAAA4C,GAAG,aAAHA,GAAG,uBAAHA,GAAG,CAAEa,MAAM,MAAK,CAAC,EAAE;MACnBhB,GAAG,aAAHA,GAAG,uBAAHA,GAAG,CAAES,cAAc,EAAE;MACrB,IAAI,CAAC6B,WAAW,GAAGnC,GAAG;MACtB,IAAI,CAACoC,wBAAwB,CAAClC,eAAe,CAAC,IAAI,CAAC;MACnDF,GAAG,GAAG,IAAI,CAACmC,WAAW;MACtB,IAAI,IAAI,CAACE,OAAO,EAAE;QACd,IAAI,CAAC7B,kBAAkB,GAAG,KAAK;QAC/B,IAAI,CAACG,YAAY,GAAG,KAAK;QAEzB,IAAI,CAACF,YAAY,CAACC,UAAU,CAAC,IAAI,CAACrB,WAAW,CAACC,gBAAgB,EAAE,IAAI,CAACD,WAAW,CAACE,cAAc,EAAES,GAAG,CAAC;QACrG,IAAI,CAACX,WAAW,CAACC,gBAAgB,IAAIU,GAAG,CAACa,MAAM;QAC/C,IAAI,CAACxB,WAAW,CAACE,cAAc,GAAG,IAAI,CAACF,WAAW,CAACC,gBAAgB;QAEnE,IAAI,CAACsB,eAAe,EAAE;;;EAGlC;EAEU0B,kBAAkBA,CAACC,IAAA,GAAe,EAAE,EAAEd,KAAa,EAAEe,OAAgC;IAC3F,MAAMC,KAAK,GAAG,EAAE;IAChB,MAAMC,KAAK,GAAGH,IAAI,CAACI,KAAK,CAAC,GAAG,CAAC;IAC7B,IAAIC,SAAS,GAAG,CAAC;IAEjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,KAAK,CAAC7B,MAAM,EAAEgC,CAAC,EAAE,EAAE;MACnC,MAAMC,QAAQ,GAAGD,CAAC,GAAG,CAAC,GAAGN,IAAI,GAAG,GAAG,GAAGG,KAAK,CAACG,CAAC,CAAC,GAAGH,KAAK,CAAC,CAAC,CAAC;MACzD,MAAMK,OAAO,GAAGP,OAAO,CAAChB,WAAW,CAACsB,QAAQ,CAAC;MAC7C,MAAME,SAAS,GAAGD,OAAO,CAACtB,KAAK;MAC/B,IAAIuB,SAAS,GAAGvB,KAAK,EAAE;QACnB,IAAIoB,CAAC,GAAG,CAAC,EAAE;UACP;UACAD,SAAS,GAAGJ,OAAO,CAAChB,WAAW,CAACe,IAAI,CAAC,CAACd,KAAK;UAC3CgB,KAAK,CAACQ,IAAI,CAAC;YAAE3E,IAAI,EAAEiE,IAAI;YAAEd,KAAK,EAAEmB,SAAS;YAAEhB,UAAU,EAAE;UAAG,CAAE,CAAC;;QAGjEW,IAAI,GAAGG,KAAK,CAACG,CAAC,CAAC;QAEf,IAAIK,WAAW,GAAG,EAAE;QAEpBX,IAAI,CAACI,KAAK,CAAC,EAAE,CAAC,CAACQ,GAAG,CAAEC,IAAI,IAAI;UACxB,IAAIZ,OAAO,CAAChB,WAAW,CAAC0B,WAAW,GAAGE,IAAI,CAAC,CAAC3B,KAAK,GAAGA,KAAK,EAAE;YACvDgB,KAAK,CAACQ,IAAI,CAAC;cAAE3E,IAAI,EAAE4E,WAAW;cAAEzB,KAAK,EAAEe,OAAO,CAAChB,WAAW,CAAC0B,WAAW,CAAC,CAACzB,KAAK;cAAEG,UAAU,EAAE;YAAE,CAAE,CAAC;YAChGsB,WAAW,GAAG,EAAE;;UAEpBA,WAAW,IAAIE,IAAI;QACvB,CAAC,CAAC;QAEFb,IAAI,GAAGW,WAAW;QAClB;QACAN,SAAS,GAAGJ,OAAO,CAAChB,WAAW,CAACe,IAAI,CAAC,CAACd,KAAK;OAC9C,MAAM;QACHmB,SAAS,GAAGI,SAAS;QACrBT,IAAI,GAAGO,QAAQ;;;IAGvBL,KAAK,CAACQ,IAAI,CAAC;MAAE3E,IAAI,EAAEiE,IAAI;MAAEd,KAAK,EAAEmB,SAAS;MAAEhB,UAAU,EAAE;IAAG,CAAE,CAAC;IAE7D,OAAOa,KAAK;EAChB;EAEUY,WAAWA,CAACC,QAAgB,EAAEd,OAAgC;IACpE,MAAMC,KAAK,GAA0D,EAAE;IACvE,MAAM1B,MAAM,GAAG,IAAI,CAACzC,IAAI,CAACqE,KAAK,CAAC,IAAI,CAAC;IAEpC,IAAI,IAAI,CAACY,WAAW,EAAE;MAClB,KAAK,MAAMC,KAAK,IAAIzC,MAAM,EAAE;QACxB0B,KAAK,CAACQ,IAAI,CAAC,GAAG,IAAI,CAACX,kBAAkB,CAACkB,KAAK,EAAEF,QAAQ,EAAEd,OAAO,CAAC,CAAC;;KAEvE,MAAM;MACH,KAAK,MAAMgB,KAAK,IAAIzC,MAAM,EAAE;QACxB0B,KAAK,CAACQ,IAAI,CAAC,IAAI,CAACQ,UAAU,CAACD,KAAK,EAAEhB,OAAO,CAAC,CAAC;;;IAInDC,KAAK,CAACA,KAAK,CAAC5B,MAAM,GAAG,CAAC,CAAC,CAACe,UAAU,GAAG,IAAI;IAEzC,OAAOa,KAAK;EAChB;EAEUgB,UAAUA,CAAClB,IAAA,GAAe,EAAE,EAAEC,OAAgC;IACpE,OAAO;MAAElE,IAAI,EAAEiE,IAAI;MAAEd,KAAK,EAAEe,OAAO,CAAChB,WAAW,CAACe,IAAI,CAAC,CAACd,KAAK;MAAEG,UAAU,EAAE;IAAG,CAAE;EAClF;EAEA;;;;;;;EAOU8B,WAAWA,CAACC,aAAsB,EAAEnB,OAAgC;IAC1E,IAAI,CAAC,IAAI,CAACoB,WAAW,IAAI,IAAI,CAACC,SAAS,EAAE;MACrC,IAAI,CAACD,WAAW,GAAGjH,OAAO,CAACmH,cAAc,CAACtB,OAAO,CAACuB,IAAI,CAAC;;IAG3D,IAAIzF,IAAI,GAAG,IAAI,CAAC0F,iBAAiB,CAAC,IAAI,CAACvD,YAAY,CAAC,CAACnC,IAAI;IAEzD;IACA,IAAI,CAAC,IAAI,CAAC2F,UAAU,IAAI,CAAC,IAAI,CAAC3F,IAAI,IAAI,IAAI,CAAC4F,gBAAgB,EAAE;MACzD5F,IAAI,GAAG,IAAI,CAAC4F,gBAAgB;MAE5B,IAAI,IAAI,CAACC,iBAAiB,EAAE;QACxB3B,OAAO,CAAC4B,SAAS,GAAG,IAAI,CAACD,iBAAiB;;;IAIlD;IACA,IAAI,CAACE,UAAU,GAAG7B,OAAO,CAAChB,WAAW,CAAClD,IAAI,CAAC,CAACmD,KAAK;IACjD;IACA,MAAM6C,WAAW,GAAG,IAAI,CAACC,OAAO,CAACrG,eAAe,CAAC,IAAI,CAACL,KAAK,EAAE8F,aAAa,CAAClC,KAAK,CAAC,GAAG,CAAC;IAErF,IAAI,IAAI,CAAC+C,iBAAiB,EAAE;MACxB,MAAMC,QAAQ,GAAGnG,IAAI,CAACqE,KAAK,CAAC,IAAI,CAAC;MACjC,MAAM+B,YAAY,GAAGD,QAAQ,CAACE,MAAM,CAAC,CAACC,GAAW,EAAEC,GAAW,KAAI;QAC9D,MAAMC,WAAW,GAAGtC,OAAO,CAAChB,WAAW,CAACqD,GAAG,CAAC,CAACpD,KAAK;QAClD,MAAMsD,SAAS,GAAGvC,OAAO,CAAChB,WAAW,CAACoD,GAAG,CAAC,CAACnD,KAAK;QAChD,OAAOqD,WAAW,GAAGC,SAAS,GAAGF,GAAG,GAAGD,GAAG;MAC9C,CAAC,EAAE,EAAE,CAAC;MAEN,MAAMI,iBAAiB,GAAGxC,OAAO,CAAChB,WAAW,CAACkD,YAAY,CAAC,CAACjD,KAAK;MACjE,IAAI,CAACA,KAAK,GAAGK,IAAI,CAACmD,GAAG,CAAC,IAAI,CAACC,SAAS,CAAChH,eAAe,CAAC,IAAI,CAACL,KAAK,EAAE8F,aAAa,CAAClC,KAAK,CAAC,EAAEuD,iBAAiB,GAAGV,WAAW,CAAC,GAAG,IAAI;MAE9H,IAAI,CAACa,gBAAgB,GAAG,IAAI;;IAGhC,IAAI,CAACC,eAAe,GAAG,IAAI,CAACC,MAAM,CAACnH,eAAe,CAAC,IAAI,CAACL,KAAK,EAAE8F,aAAa,CAAClC,KAAK,CAAC,GAAG6C,WAAW;IAEjG;IACA,IAAI,CAACvD,MAAM,GAAG,IAAI,CAACsC,WAAW,CAAC,IAAI,CAAC+B,eAAe,EAAE5C,OAAO,CAAC;IAC7D;IACA,IAAI,CAACjB,qBAAqB,GAAGiB,OAAO;IAEpC,IAAI,IAAI,CAAChF,kBAAkB,EAAE;MACzB,MAAM8H,UAAU,GAAG,IAAI,CAACvE,MAAM,CAACF,MAAM,GAAG,IAAI,CAAC+C,WAAW,CAACnG,MAAM;MAC/D,MAAM8H,WAAW,GAAGD,UAAU,GAAG,IAAI,CAACf,OAAO,CAACrG,eAAe,CAAC,IAAI,CAACL,KAAK,EAAE8F,aAAa,CAAClG,MAAM,CAAC,GAAG,CAAC;MACnG,IAAI,CAACA,MAAM,GAAGqE,IAAI,CAACmD,GAAG,CAAC,IAAI,CAACjH,UAAU,CAACE,eAAe,CAAC,IAAI,CAACL,KAAK,EAAE8F,aAAa,CAAClG,MAAM,CAAC,EAAE8H,WAAW,CAAC,GAAG,IAAI;MAE7G,IAAI,CAAC/H,kBAAkB,GAAG,IAAI;;IAGlC,IAAI,CAACgI,gBAAgB,GAAG,IAAI,CAAC7H,OAAO,CAACO,eAAe,CAAC,IAAI,CAACL,KAAK,EAAE8F,aAAa,CAAClG,MAAM,CAAC,GAAG6G,WAAW;IAEpG,IAAI,IAAI,CAACL,UAAU,EAAE;MACjB,IAAI,CAAC5E,WAAW,CAACK,gBAAgB,GAAG,CAAC;MAErC,IAAI+F,UAAU,GAAG,IAAI,CAAC1E,MAAM,CAAC,IAAI,CAAC1B,WAAW,CAACK,gBAAgB,CAAC,CAACpB,IAAI,CAACuC,MAAM,GAAG,IAAI,CAACE,MAAM,CAAC,IAAI,CAAC1B,WAAW,CAACK,gBAAgB,CAAC,CAACkC,UAAU,CAACf,MAAM;MAC9I,IAAI6E,SAAS,GAAG,CAAC;MAEjB,OAAOA,SAAS,GAAGD,UAAU,IAAI,IAAI,CAACpG,WAAW,CAACC,gBAAgB,EAAE;QAChEoG,SAAS,IAAID,UAAU;QAEvB,IAAI,IAAI,CAACpG,WAAW,CAACK,gBAAgB,GAAG,IAAI,CAACqB,MAAM,CAACF,MAAM,GAAG,CAAC,EAAE;UAC5D,IAAI,CAACxB,WAAW,CAACK,gBAAgB,EAAE;UACnC+F,UAAU,GAAG,IAAI,CAAC1E,MAAM,CAAC,IAAI,CAAC1B,WAAW,CAACK,gBAAgB,CAAC,CAACpB,IAAI,CAACuC,MAAM,GAAG,IAAI,CAACE,MAAM,CAAC,IAAI,CAAC1B,WAAW,CAACK,gBAAgB,CAAC,CAACkC,UAAU,CAACf,MAAM;;;;EAI1J;EAEQ8E,cAAcA,CAAA;IAClB,IAAI,CAACC,aAAa,GAAG,IAAI,CAACC,eAAe,CAACC,IAAI,GAAG,IAAI,CAACvB,OAAO,CAACrG,eAAe,CAAC,IAAI,CAACL,KAAK,EAAE,IAAI,CAACM,oBAAoB,CAACsD,KAAK,CAAC;IAC1H,IAAI,CAACsE,YAAY,GAAG,IAAI,CAACF,eAAe,CAACG,GAAG,GAAG,IAAI,CAACzB,OAAO,CAACrG,eAAe,CAAC,IAAI,CAACL,KAAK,EAAE,IAAI,CAACM,oBAAoB,CAACV,MAAM,CAAC;IAEzH,IAAI,IAAI,CAACwG,UAAU,IAAI,IAAI,CAAClD,MAAM,CAAC,IAAI,CAAC1B,WAAW,CAACK,gBAAgB,CAAC,CAAC+B,KAAK,GAAG,IAAI,CAAC2D,eAAe,EAAE;MAChG,MAAMa,QAAQ,GAAG,IAAI,CAACL,aAAa,GAAG,IAAI,CAAC7E,MAAM,CAAC,IAAI,CAAC1B,WAAW,CAACK,gBAAgB,CAAC,CAAC+B,KAAK,GAAG,IAAI,CAAC2D,eAAe;MAEjH,IAAI,CAAC,IAAI,CAACc,WAAW,EAAE;QACnB,IAAI,CAACA,WAAW,GAAGD,QAAQ;;KAElC,MAAM;MACH,IAAI,CAACC,WAAW,GAAG,IAAI,CAACN,aAAa;;IAGzC,IAAI,IAAI,CAAC3B,UAAU,IAAI,CAAC,IAAI,CAACzG,kBAAkB,EAAE;MAC7C,MAAM2I,cAAc,GAAG,CAAC,IAAI,CAAC9G,WAAW,CAACK,gBAAgB,GAAG,CAAC,IAAI,IAAI,CAACkE,WAAW,CAACnG,MAAM;MACxF,MAAM2I,OAAO,GAAG,IAAI,CAACL,YAAY,GAAGI,cAAc;MAElD,IAAI,CAAC,IAAI,CAACE,UAAU,EAAE;QAClB,IAAI,CAACA,UAAU,GAAGD,OAAO;;KAEhC,MAAM;MACH,IAAI,CAACC,UAAU,GAAG,IAAI,CAACN,YAAY;;EAE3C;EAEA;;;;;EAKUO,qBAAqBA,CAAA;IAC3B;IACA,IAAI,CAACC,eAAe,GAAG,EAAE;IAEzB,IAAI,CAAC1H,sBAAsB,CAACqB,eAAe,CAAC,IAAI,CAAC;EACrD;EAEQsG,SAASA,CAAClI,IAAY,EAAEmI,SAAiB,EAAEC,CAAS,EAAElE,OAAgC;IAC1F,MAAMf,KAAK,GAAG,IAAI,CAACoE,eAAe,CAACpE,KAAK;IACxC,IAAIkF,CAAC,GAAG,IAAI,CAACT,WAAqB;IAClC,QAAQ,IAAI,CAAC3H,wBAAwB;MACjC,KAAK5B,OAAO,CAAC6B,yBAAyB;QAClCmI,CAAC,IAAI,CAAC;QACN;MACJ,KAAKhK,OAAO,CAACiK,0BAA0B;QACnCD,CAAC,IAAIlF,KAAK,GAAGgF,SAAS;QACtB;MACJ,KAAK9J,OAAO,CAACkK,2BAA2B;QACpCF,CAAC,IAAI,CAAClF,KAAK,GAAGgF,SAAS,IAAI,CAAC;QAC5B;;IAGR,IAAI,IAAI,CAACK,UAAU,IAAI,IAAI,CAACC,aAAa,IAAI,IAAI,CAACC,aAAa,EAAE;MAC7DxE,OAAO,CAACyE,WAAW,GAAG,IAAI,CAACA,WAAW;MACtCzE,OAAO,CAACsE,UAAU,GAAG,IAAI,CAACA,UAAU;MACpCtE,OAAO,CAACuE,aAAa,GAAG,IAAI,CAACA,aAAa;MAC1CvE,OAAO,CAACwE,aAAa,GAAG,IAAI,CAACA,aAAa;;IAG9C,IAAI,IAAI,CAAC/J,YAAY,EAAE;MACnBuF,OAAO,CAAC0E,UAAU,CAAC5I,IAAI,EAAE,IAAI,CAACuH,eAAe,CAACC,IAAI,GAAGa,CAAC,EAAED,CAAC,CAAC;;IAE9DlE,OAAO,CAAC2E,QAAQ,CAAC7I,IAAI,EAAEqI,CAAC,EAAED,CAAC,CAAC;EAChC;EAEA;;;;;;EAMUU,WAAWA,CAACC,EAAkB;IACpC,IAAI,CAAC7G,kBAAkB,GAAG,KAAK;IAC/B;IACA,IAAI;MACA6G,EAAE,CAACC,aAAa,IAAID,EAAE,CAACC,aAAa,CAACC,OAAO,CAAC,YAAY,EAAE,IAAI,CAACC,gBAAgB,CAAC;KACpF,CAAC,OAAAC,EAAA,EAAM,EAAE,CAAC;IACX,IAAI,CAAC5J,KAAK,CAACyJ,aAAa,GAAG,IAAI,CAACE,gBAAgB;EACpD;EAEA;;;;;;EAMUE,UAAUA,CAACL,EAAkB;IACnC,IAAI,CAAC,IAAI,CAACG,gBAAgB,EAAE;MACxB;;IAEJ;IACA,IAAI;MACAH,EAAE,CAACC,aAAa,IAAID,EAAE,CAACC,aAAa,CAACC,OAAO,CAAC,YAAY,EAAE,IAAI,CAACC,gBAAgB,CAAC;KACpF,CAAC,OAAAC,EAAA,EAAM,EAAE,CAAC;IAEX,IAAI,CAAC5J,KAAK,CAACyJ,aAAa,GAAG,IAAI,CAACE,gBAAgB;IAEhD,IAAI,CAAC/G,YAAY,CAACC,UAAU,CAAC,IAAI,CAACrB,WAAW,CAACC,gBAAgB,EAAE,IAAI,CAACD,WAAW,CAACE,cAAc,CAAC;IAEhG,IAAI,CAACqB,eAAe,EAAE;EAC1B;EAEA;;;;;;EAMU+G,YAAYA,CAACN,EAAkB;IACrC,IAAIO,IAAI,GAAW,EAAE;IACrB,IAAIP,EAAE,CAACC,aAAa,IAAID,EAAE,CAACC,aAAa,CAACO,KAAK,CAACC,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,EAAE;MACzEF,IAAI,GAAGP,EAAE,CAACC,aAAa,CAACS,OAAO,CAAC,YAAY,CAAC;KAChD,MAAM;MACH;MACAH,IAAI,GAAG,IAAI,CAAC/J,KAAK,CAACyJ,aAAa;;IAGnC,IAAI,CAAC9G,kBAAkB,GAAG,KAAK;IAE/B,IAAI,CAACC,YAAY,CAACC,UAAU,CAAC,IAAI,CAACrB,WAAW,CAACC,gBAAgB,EAAE,IAAI,CAACD,WAAW,CAACE,cAAc,EAAEqI,IAAI,CAAC;IAEtG,MAAMI,UAAU,GAAGJ,IAAI,CAAC/G,MAAM,IAAI,IAAI,CAACxB,WAAW,CAACE,cAAc,GAAG,IAAI,CAACF,WAAW,CAACC,gBAAgB,CAAC;IAEtG,IAAI,CAACD,WAAW,CAACC,gBAAgB,IAAI0I,UAAU;IAC/C,IAAI,CAAC3I,WAAW,CAACE,cAAc,GAAG,IAAI,CAACF,WAAW,CAACC,gBAAgB;IAEnE,IAAI,CAACsB,eAAe,EAAE;EAC1B;EAEOqH,KAAKA,CAACzF,OAAgC;;IACzC,IAAI,CAACmD,cAAc,EAAE;IAErB,IAAI,CAACO,WAAW,GAAG,CAAAuB,EAAA,OAAI,CAACvB,WAAW,cAAAuB,EAAA,cAAAA,EAAA,GAAI,CAAC;IACxC,IAAI,CAACpB,UAAU,GAAG,CAAA6B,EAAA,OAAI,CAAC7B,UAAU,cAAA6B,EAAA,cAAAA,EAAA,GAAI,CAAC;IAEtC1F,OAAO,CAAC2F,IAAI,EAAE;IAEd,IAAI,CAACC,YAAY,CAAC5F,OAAO,CAAC;IAC1B,IAAI,IAAI,CAACsE,UAAU,IAAI,IAAI,CAACC,aAAa,IAAI,IAAI,CAACC,aAAa,EAAE;MAC7DxE,OAAO,CAACyE,WAAW,GAAG,IAAI,CAACA,WAAW;MACtCzE,OAAO,CAACsE,UAAU,GAAG,IAAI,CAACA,UAAU;MACpCtE,OAAO,CAACuE,aAAa,GAAG,IAAI,CAACA,aAAa;MAC1CvE,OAAO,CAACwE,aAAa,GAAG,IAAI,CAACA,aAAa;;IAG9C;IACA,IAAI,IAAI,CAAC/C,UAAU,EAAE;MACjB,IAAI,IAAI,CAACoE,kBAAkB,EAAE;QACzB7F,OAAO,CAAC4B,SAAS,GAAG,IAAI,CAACkE,UAAU,GAAG,IAAI,CAACD,kBAAkB,GAAG,IAAI,CAACE,cAAc;QAEnF/F,OAAO,CAACgG,QAAQ,CAAC,IAAI,CAAC3C,eAAe,CAACC,IAAI,EAAE,IAAI,CAACD,eAAe,CAACG,GAAG,EAAE,IAAI,CAACH,eAAe,CAACpE,KAAK,EAAE,IAAI,CAACoE,eAAe,CAACpI,MAAM,CAAC;;KAErI,MAAM,IAAI,IAAI,CAACgL,WAAW,EAAE;MACzBjG,OAAO,CAAC4B,SAAS,GAAG,IAAI,CAACkE,UAAU,GAAG,IAAI,CAACG,WAAW,GAAG,IAAI,CAACF,cAAc;MAE5E/F,OAAO,CAACgG,QAAQ,CAAC,IAAI,CAAC3C,eAAe,CAACC,IAAI,EAAE,IAAI,CAACD,eAAe,CAACG,GAAG,EAAE,IAAI,CAACH,eAAe,CAACpE,KAAK,EAAE,IAAI,CAACoE,eAAe,CAACpI,MAAM,CAAC;;IAGlI,IAAI,IAAI,CAACqJ,UAAU,IAAI,IAAI,CAACC,aAAa,IAAI,IAAI,CAACC,aAAa,EAAE;MAC7DxE,OAAO,CAACsE,UAAU,GAAG,CAAC;MACtBtE,OAAO,CAACuE,aAAa,GAAG,CAAC;MACzBvE,OAAO,CAACwE,aAAa,GAAG,CAAC;;IAG7B;IACA,IAAI,IAAI,CAAC0B,KAAK,EAAE;MACZlG,OAAO,CAAC4B,SAAS,GAAG,IAAI,CAACsE,KAAK;;IAGlC,MAAMjL,MAAM,GAAG,IAAI,CAACoI,eAAe,CAACpI,MAAM;IAC1C,MAAMgE,KAAK,GAAG,IAAI,CAACoE,eAAe,CAACpE,KAAK;IACxC,IAAIkH,KAAK,GAAG,CAAC;IAEb,QAAQ,IAAI,CAAClK,sBAAsB;MAC/B,KAAK9B,OAAO,CAAC+B,sBAAsB;QAC/BiK,KAAK,GAAG,IAAI,CAAC/E,WAAW,CAACgF,MAAM;QAC/B;MACJ,KAAKjM,OAAO,CAACkM,yBAAyB;QAClCF,KAAK,GAAGlL,MAAM,GAAG,IAAI,CAACmG,WAAW,CAACnG,MAAM,IAAI,IAAI,CAACsD,MAAM,CAACF,MAAM,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC+C,WAAW,CAACkF,OAAO;QAC9F;MACJ,KAAKnM,OAAO,CAACoM,yBAAyB;QAClCJ,KAAK,GAAG,IAAI,CAAC/E,WAAW,CAACgF,MAAM,GAAG,CAACnL,MAAM,GAAG,IAAI,CAACmG,WAAW,CAACnG,MAAM,GAAG,IAAI,CAACsD,MAAM,CAACF,MAAM,IAAI,CAAC;QAC7F;;IAGR2B,OAAO,CAAC2F,IAAI,EAAE;IACd3F,OAAO,CAACwG,SAAS,EAAE;IACnBxG,OAAO,CAAC4B,SAAS,GAAG,IAAI,CAAC6E,SAAS;IAElC;IACAzG,OAAO,CAAC0G,IAAI,CAAC,IAAI,CAACtD,aAAa,EAAE,IAAI,CAACG,YAAY,EAAE,IAAI,CAACX,eAAe,GAAG,CAAC,EAAE,IAAI,CAACI,gBAAgB,GAAG,CAAC,CAAC;IACxGhD,OAAO,CAAC2G,IAAI,EAAE;IAEd;IACAR,KAAK,IAAI,IAAI,CAACtC,UAAU;IAExB,KAAK,IAAI+C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACrI,MAAM,CAACF,MAAM,EAAEuI,CAAC,EAAE,EAAE;MACzC,MAAM7G,IAAI,GAAG,IAAI,CAACxB,MAAM,CAACqI,CAAC,CAAC;MAE3B,IAAIA,CAAC,KAAK,CAAC,IAAI,IAAI,CAACzK,YAAY,CAAC0K,aAAa,KAAK,CAAC,EAAE;QAClD,IAAI,IAAI,CAAC1K,YAAY,CAAC2K,OAAO,EAAE;UAC3BX,KAAK,IAAI,IAAI,CAAChK,YAAY,CAAC4K,QAAQ,CAAC,IAAI,CAAC1L,KAAK,CAAC;SAClD,MAAM;UACH8K,KAAK,GAAGA,KAAK,GAAG,IAAI,CAAChK,YAAY,CAAC4K,QAAQ,CAAC,IAAI,CAAC1L,KAAK,CAAC,GAAG,IAAI,CAACF,OAAO,CAACO,eAAe,CAAC,IAAI,CAACL,KAAK,EAAE,IAAI,CAACM,oBAAoB,CAACV,MAAM,CAAC;;;MAI3I,IAAI,CAAC+I,SAAS,CAACjE,IAAI,CAACjE,IAAI,EAAEiE,IAAI,CAACd,KAAK,EAAEkH,KAAK,EAAEnG,OAAO,CAAC;MACrDmG,KAAK,IAAI,IAAI,CAAC/E,WAAW,CAACnG,MAAM;;IAGpC+E,OAAO,CAACgH,OAAO,EAAE;IAEjB;IACA,IAAI,IAAI,CAACvF,UAAU,EAAE;MACjB;MACA,IAAI,CAAC,IAAI,CAACtD,YAAY,IAAI,IAAI,CAACH,kBAAkB,EAAE;QAC/C,IAAIiJ,UAAU,GAAG,IAAI,CAACvD,WAAW,GAAG1D,OAAO,CAAChB,WAAW,CAAC,IAAI,CAACT,MAAM,CAAC,IAAI,CAAC1B,WAAW,CAACK,gBAAgB,CAAC,CAACpB,IAAI,CAAC+C,MAAM,CAAC,CAAC,EAAE,IAAI,CAAChC,WAAW,CAACI,kBAAkB,CAAC,CAAC,CAACgC,KAAK;QAEjK,IAAIgI,UAAU,GAAG,IAAI,CAAC7D,aAAa,EAAE;UACjC,IAAI,CAACM,WAAW,IAAI,IAAI,CAACN,aAAa,GAAG6D,UAAU;UACnDA,UAAU,GAAG,IAAI,CAAC7D,aAAa;UAC/B,IAAI,CAACxI,YAAY,EAAE;SACtB,MAAM,IAAIqM,UAAU,GAAG,IAAI,CAAC7D,aAAa,GAAG,IAAI,CAACR,eAAe,EAAE;UAC/D,IAAI,CAACc,WAAW,IAAI,IAAI,CAACN,aAAa,GAAG,IAAI,CAACR,eAAe,GAAGqE,UAAU;UAC1EA,UAAU,GAAG,IAAI,CAAC7D,aAAa,GAAG,IAAI,CAACR,eAAe;UACtD,IAAI,CAAChI,YAAY,EAAE;;QAGvB,IAAIsM,SAAS,GAAG,IAAI,CAACrD,UAAU,GAAG,IAAI,CAAChH,WAAW,CAACK,gBAAgB,GAAG,IAAI,CAACkE,WAAW,CAACnG,MAAM,CAAC,CAAC;QAE/F,IAAIiM,SAAS,GAAG,IAAI,CAAC3D,YAAY,EAAE;UAC/B,IAAI,CAACM,UAAU,IAAI,IAAI,CAACN,YAAY,GAAG2D,SAAS;UAChDA,SAAS,GAAG,IAAI,CAAC3D,YAAY;UAC7B,IAAI,CAAC3I,YAAY,EAAE;SACtB,MAAM,IAAIsM,SAAS,GAAG,IAAI,CAAC9F,WAAW,CAACnG,MAAM,GAAG,IAAI,CAACsI,YAAY,GAAG,IAAI,CAACP,gBAAgB,EAAE;UACxF,IAAI,CAACa,UAAU,IAAI,IAAI,CAACN,YAAY,GAAG,IAAI,CAACP,gBAAgB,GAAGkE,SAAS,GAAG,IAAI,CAAC9F,WAAW,CAACnG,MAAM;UAClGiM,SAAS,GAAG,IAAI,CAAC3D,YAAY,GAAG,IAAI,CAACP,gBAAgB,GAAG,IAAI,CAAC5B,WAAW,CAACnG,MAAM;UAC/E,IAAI,CAACL,YAAY,EAAE;;QAGvB,IAAI,CAAC,IAAI,CAACoD,kBAAkB,EAAE;UAC1BgC,OAAO,CAACgG,QAAQ,CAACiB,UAAU,EAAEC,SAAS,EAAE,CAAC,EAAE,IAAI,CAAC9F,WAAW,CAACnG,MAAM,CAAC;;;MAI3E,IAAI,CAACkM,cAAc,EAAE;MAErB;MACA,IAAI,IAAI,CAACnJ,kBAAkB,EAAE;QACzBoJ,YAAY,CAAC,IAAI,CAACC,aAAa,CAAC;QAEhC,IAAI,CAACrC,gBAAgB,GAAG,IAAI,CAAClJ,IAAI,CAACwL,SAAS,CAAC,IAAI,CAACzK,WAAW,CAACC,gBAAgB,EAAE,IAAI,CAACD,WAAW,CAACE,cAAc,CAAC;QAE/GiD,OAAO,CAACuH,WAAW,GAAG,IAAI,CAACC,kBAAkB;QAC7CxH,OAAO,CAAC4B,SAAS,GAAG,IAAI,CAAC6F,mBAAmB;QAE5C,MAAMC,cAAc,GAAGpI,IAAI,CAACmD,GAAG,CAAC,IAAI,CAAC5F,WAAW,CAACK,gBAAgB,EAAE,IAAI,CAACT,oBAAoB,CAACG,gBAAgB,CAAC;QAC9G,MAAM+K,YAAY,GAAGrI,IAAI,CAACsI,GAAG,CAAC,IAAI,CAAC/K,WAAW,CAACK,gBAAgB,EAAE,IAAI,CAACT,oBAAoB,CAACG,gBAAgB,CAAC;QAE5G,IAAIiL,cAAc,GAAG,IAAI,CAAChE,UAAU,GAAG6D,cAAc,GAAG,IAAI,CAACtG,WAAW,CAACnG,MAAM;QAE/E,KAAK,IAAI2L,CAAC,GAAGc,cAAc,EAAEd,CAAC,IAAIe,YAAY,EAAEf,CAAC,EAAE,EAAE;UACjD,MAAM7G,IAAI,GAAG,IAAI,CAACxB,MAAM,CAACqI,CAAC,CAAC;UAE3B,IAAIkB,cAAc,GAAG,IAAI,CAACpE,WAAqB;UAC/C,QAAQ,IAAI,CAAC3H,wBAAwB;YACjC,KAAK5B,OAAO,CAAC6B,yBAAyB;cAClC8L,cAAc,IAAI,CAAC;cACnB;YACJ,KAAK3N,OAAO,CAACiK,0BAA0B;cACnC0D,cAAc,IAAI7I,KAAK,GAAGc,IAAI,CAACd,KAAK;cACpC;YACJ,KAAK9E,OAAO,CAACkK,2BAA2B;cACpCyD,cAAc,IAAI,CAAC7I,KAAK,GAAGc,IAAI,CAACd,KAAK,IAAI,CAAC;cAC1C;;UAGR,MAAM8I,KAAK,GAAGnB,CAAC,KAAKc,cAAc,GAAG,IAAI,CAAC7K,WAAW,CAACI,kBAAkB,GAAG,CAAC;UAC5E,MAAM+K,GAAG,GAAGpB,CAAC,KAAKe,YAAY,GAAG,IAAI,CAAC9K,WAAW,CAACG,gBAAgB,GAAG+C,IAAI,CAACjE,IAAI,CAACuC,MAAM;UAErF,MAAM4J,eAAe,GAAGjI,OAAO,CAAChB,WAAW,CAACe,IAAI,CAACjE,IAAI,CAAC+C,MAAM,CAAC,CAAC,EAAEkJ,KAAK,CAAC,CAAC,CAAC9I,KAAK;UAC7E,MAAMiJ,YAAY,GAAGnI,IAAI,CAACjE,IAAI,CAACwL,SAAS,CAACS,KAAK,EAAEC,GAAG,CAAC;UACpD,MAAMG,eAAe,GAAGnI,OAAO,CAAChB,WAAW,CAACkJ,YAAY,CAAC,CAACjJ,KAAK;UAE/De,OAAO,CAACgG,QAAQ,CAAC8B,cAAc,GAAGG,eAAe,EAAEJ,cAAc,EAAEM,eAAe,EAAE,IAAI,CAAC/G,WAAW,CAACnG,MAAM,CAAC;UAE5G4M,cAAc,IAAI,IAAI,CAACzG,WAAW,CAACnG,MAAM;;QAG7C,IAAI,IAAI,CAAC4B,WAAW,CAACE,cAAc,KAAK,IAAI,CAACF,WAAW,CAACC,gBAAgB,EAAE;UACvE,IAAI,CAACqK,cAAc,EAAE;;;;IAKjCnH,OAAO,CAACgH,OAAO,EAAE;IAEjB;IACA,IAAI,IAAI,CAACoB,UAAU,EAAE;MACjB,IAAI,IAAI,CAAC3G,UAAU,EAAE;QACjB,IAAI,IAAI,CAAC4G,YAAY,EAAE;UACnBrI,OAAO,CAACsI,WAAW,GAAG,IAAI,CAACD,YAAY;;OAE9C,MAAM;QACH,IAAI,IAAI,CAACnC,KAAK,EAAE;UACZlG,OAAO,CAACsI,WAAW,GAAG,IAAI,CAACpC,KAAK;;;MAIxClG,OAAO,CAACI,SAAS,GAAG,IAAI,CAACgI,UAAU;MAEnCpI,OAAO,CAACuI,UAAU,CACd,IAAI,CAAClF,eAAe,CAACC,IAAI,GAAG,IAAI,CAAC8E,UAAU,GAAG,CAAC,EAC/C,IAAI,CAAC/E,eAAe,CAACG,GAAG,GAAG,IAAI,CAAC4E,UAAU,GAAG,CAAC,EAC9C,IAAI,CAAC/E,eAAe,CAACpE,KAAK,GAAG,IAAI,CAACmJ,UAAU,EAC5C,IAAI,CAAC/E,eAAe,CAACpI,MAAM,GAAG,IAAI,CAACmN,UAAU,CAChD;;EAET;EAEQjB,cAAcA,CAAA;IAClBC,YAAY,CAAC,IAAI,CAACC,aAAa,CAAC;IAChC,IAAI,CAACA,aAAa,GAAQmB,UAAU,CAAC,MAAK;MACtC,IAAI,CAACrK,YAAY,GAAG,CAAC,IAAI,CAACA,YAAY;MACtC,IAAI,CAACvD,YAAY,EAAE;IACvB,CAAC,EAAE,GAAG,CAAC;EACX;EAEUgL,YAAYA,CAAC5F,OAAgC;IACnD,KAAK,CAAC4F,YAAY,CAAC5F,OAAO,CAAC;IAC3B,IAAI,IAAI,CAACvF,YAAY,EAAE;MACnBuF,OAAO,CAACI,SAAS,GAAG,IAAI,CAAC3F,YAAY;MACrCuF,OAAO,CAACsI,WAAW,GAAG,IAAI,CAACzN,YAAY;;EAE/C;EAEO4N,cAAcA,CAACC,MAAe,EAAEC,WAAoB,EAAEC,SAAiB,EAAEC,WAAmB,EAAEC,EAAmB;IACpH,IAAI,CAAC,KAAK,CAACL,cAAc,CAACC,MAAM,EAAEC,WAAW,EAAEC,SAAS,EAAEC,WAAW,EAAEC,EAAE,CAAC,EAAE;MACxE,OAAO,KAAK;;IAGhB,IAAI,CAACC,mBAAmB,GAAGJ,WAAW,CAACxE,CAAC;IACxC,IAAI,CAAC6E,mBAAmB,GAAGL,WAAW,CAACzE,CAAC;IAExC,IAAI,CAAClG,kBAAkB,GAAG,KAAK;IAC/B,IAAI,CAACgH,gBAAgB,GAAG,EAAE;IAC1B,IAAI,CAACiE,cAAc,GAAG,IAAI;IAC1B,IAAI,CAAC5N,KAAK,CAAC6N,iBAAiB,CAACN,SAAS,CAAC,GAAG,IAAI;IAC9C,IAAI,IAAI,CAACvN,KAAK,CAAC8N,cAAc,KAAK,IAAI,EAAE;MACpC;MACA/B,YAAY,CAAC,IAAI,CAACC,aAAa,CAAC;MAChC,IAAI,CAACzM,YAAY,EAAE;MACnB,OAAO,IAAI;;IAEf,IAAI,CAAC,IAAI,CAACkL,UAAU,EAAE;MAClB,OAAO,KAAK;;IAEhB,IAAI,CAACzK,KAAK,CAAC8N,cAAc,GAAG,IAAI;IAEhC,OAAO,IAAI;EACf;EAEA;EACOC,cAAcA,CAACV,MAAe,EAAEC,WAAoB,EAAEC,SAAiB,EAAEE,EAAmB;IAC/F;IACA,IAAIA,EAAE,CAACO,KAAK,CAACC,SAAS,KAAK,CAAC,IAAIR,EAAE,CAACO,KAAK,CAACE,SAAS,KAAK,CAAC,EAAE;MACtD;;IAGJ,IAAI,IAAI,CAAClO,KAAK,CAAC8N,cAAc,KAAK,IAAI,IAAI,IAAI,CAACF,cAAc,EAAE;MAC3D,IAAI,CAACF,mBAAmB,GAAGJ,WAAW,CAACxE,CAAC;MACxC,IAAI,CAAC6E,mBAAmB,GAAGL,WAAW,CAACzE,CAAC;MAExC,IAAI,CAAC,IAAI,CAAClG,kBAAkB,EAAE;QAC1B,IAAI,CAACvB,oBAAoB,CAACG,gBAAgB,GAAG,IAAI,CAACC,WAAW,CAACK,gBAAgB;QAC9E,IAAI,CAACT,oBAAoB,CAACC,iBAAiB,GAAG,IAAI,CAACG,WAAW,CAACC,gBAAgB;QAC/E,IAAI,CAACL,oBAAoB,CAACE,yBAAyB,GAAG,IAAI,CAACE,WAAW,CAACI,kBAAkB;QAEzF,IAAI,CAACe,kBAAkB,GAAG,IAAI;;MAGlC,IAAI,CAACpD,YAAY,EAAE;;IAEvB,KAAK,CAACwO,cAAc,CAACV,MAAM,EAAEC,WAAW,EAAEC,SAAS,EAAEE,EAAE,CAAC;EAC5D;EAEA;;;EAGQtM,qBAAqBA,CAAA;;IACzB,IAAI,CAAC,IAAI,CAACiF,UAAU,EAAE;MAClB;;IAGJ,IAAI,IAAI,CAACsH,mBAAmB,IAAI,IAAI,CAACC,mBAAmB,EAAE;MACtD,IAAI,CAAC,IAAI,CAAChL,kBAAkB,EAAE;QAC1B,IAAI,CAACnB,WAAW,GAAG;UACfC,gBAAgB,EAAE,CAAC;UACnBC,cAAc,EAAE,CAAC;UACjBE,kBAAkB,EAAE,CAAC;UACrBD,gBAAgB,EAAE,CAAC;UACnBE,gBAAgB,EAAE;SACrB;;MAGL,IAAIsM,WAAW,GAAG,CAAC;MACnB,IAAI7K,aAAa,GAAG,CAAC;MAErB,MAAM8K,sBAAsB,GAAG,IAAI,CAACT,mBAAmB,GAAI,IAAI,CAACnF,UAAqB;MAErF,MAAM6F,mBAAmB,GAAGpK,IAAI,CAACqK,KAAK,CAACF,sBAAsB,GAAG,IAAI,CAACrI,WAAW,CAACnG,MAAM,CAAC;MACxF,IAAI,CAAC4B,WAAW,CAACK,gBAAgB,GAAGoC,IAAI,CAACmD,GAAG,CAACnD,IAAI,CAACsI,GAAG,CAAC8B,mBAAmB,EAAE,CAAC,CAAC,EAAE,IAAI,CAACnL,MAAM,CAACF,MAAM,GAAG,CAAC,CAAC;MAEtG,IAAIuL,WAAW,GAAG,CAAC;MAEnB,MAAMC,iBAAiB,GAAG,IAAI,CAACd,mBAAmB,IAAI,CAAA9D,EAAA,OAAI,CAACvB,WAAW,cAAAuB,EAAA,cAAAA,EAAA,GAAI,CAAC,CAAC;MAE5E,IAAI6E,YAAY,GAAG,CAAC;MAEpB,KAAK,IAAIC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,IAAI,CAAClN,WAAW,CAACK,gBAAgB,EAAE6M,KAAK,EAAE,EAAE;QACpE,MAAMhK,IAAI,GAAG,IAAI,CAACxB,MAAM,CAACwL,KAAK,CAAC;QAC/BP,WAAW,IAAIzJ,IAAI,CAACjE,IAAI,CAACuC,MAAM,GAAG0B,IAAI,CAACX,UAAU,CAACf,MAAM;;MAG5D,OAAOuL,WAAW,GAAGC,iBAAiB,IAAI,IAAI,CAACtL,MAAM,CAAC,IAAI,CAAC1B,WAAW,CAACK,gBAAgB,CAAC,CAACpB,IAAI,CAACuC,MAAM,GAAGM,aAAa,EAAE;QAClHA,aAAa,EAAE;QACfmL,YAAY,GAAGxK,IAAI,CAACC,GAAG,CAACsK,iBAAiB,GAAGD,WAAW,CAAC;QACxDA,WAAW,GAAG,IAAI,CAAC7K,qBAAqB,CAACC,WAAW,CAAC,IAAI,CAACT,MAAM,CAAC,IAAI,CAAC1B,WAAW,CAACK,gBAAgB,CAAC,CAACpB,IAAI,CAAC+C,MAAM,CAAC,CAAC,EAAEF,aAAa,CAAC,CAAC,CAACM,KAAK;;MAG5I;MACA,IAAIK,IAAI,CAACC,GAAG,CAACsK,iBAAiB,GAAGD,WAAW,CAAC,GAAGE,YAAY,IAAInL,aAAa,GAAG,CAAC,EAAE;QAC/EA,aAAa,EAAE;;MAGnB6K,WAAW,IAAI7K,aAAa;MAE5B,IAAI,CAAC,IAAI,CAACX,kBAAkB,EAAE;QAC1B,IAAI,CAACnB,WAAW,CAACC,gBAAgB,GAAG0M,WAAW;QAC/C,IAAI,CAAC3M,WAAW,CAACI,kBAAkB,GAAG0B,aAAa;QACnD,IAAI,CAAC9B,WAAW,CAACE,cAAc,GAAG,IAAI,CAACF,WAAW,CAACC,gBAAgB;QACnE,IAAI,CAACD,WAAW,CAACG,gBAAgB,GAAG,IAAI,CAACH,WAAW,CAACI,kBAAkB;OAC1E,MAAM;QACH,IAAIuM,WAAW,GAAG,IAAI,CAAC/M,oBAAoB,CAACC,iBAAiB,EAAE;UAC3D,IAAI,CAACG,WAAW,CAACC,gBAAgB,GAAG0M,WAAW;UAC/C,IAAI,CAAC3M,WAAW,CAACI,kBAAkB,GAAG0B,aAAa;UACnD,IAAI,CAAC9B,WAAW,CAACE,cAAc,GAAG,IAAI,CAACN,oBAAoB,CAACC,iBAAiB;UAC7E,IAAI,CAACG,WAAW,CAACG,gBAAgB,GAAG,IAAI,CAACP,oBAAoB,CAACE,yBAAyB;SAC1F,MAAM;UACH,IAAI,CAACE,WAAW,CAACC,gBAAgB,GAAG,IAAI,CAACL,oBAAoB,CAACC,iBAAiB;UAC/E,IAAI,CAACG,WAAW,CAACI,kBAAkB,GAAG,IAAI,CAACR,oBAAoB,CAACE,yBAAyB;UACzF,IAAI,CAACE,WAAW,CAACE,cAAc,GAAGyM,WAAW;UAC7C,IAAI,CAAC3M,WAAW,CAACG,gBAAgB,GAAG2B,aAAa;;;MAIzD;MACA,IAAI,CAACR,YAAY,GAAG,IAAI,CAACH,kBAAkB;MAC3C,IAAI,CAAC+K,mBAAmB,GAAG,IAAI;MAC/B,IAAI,CAACC,mBAAmB,GAAG,IAAI;KAClC,MAAM;MACH;MACA,IAAI,CAACnM,WAAW,CAACI,kBAAkB,GAAG,CAAC;MACvC,IAAI,CAACJ,WAAW,CAACK,gBAAgB,GAAG,CAAC;MAErC,IAAI+F,UAAU,GAAG,IAAI,CAAC1E,MAAM,CAAC,IAAI,CAAC1B,WAAW,CAACK,gBAAgB,CAAC,CAACpB,IAAI,CAACuC,MAAM,GAAG,IAAI,CAACE,MAAM,CAAC,IAAI,CAAC1B,WAAW,CAACK,gBAAgB,CAAC,CAACkC,UAAU,CAACf,MAAM;MAC9I,IAAI6E,SAAS,GAAG,CAAC;MAEjB,OAAOA,SAAS,GAAGD,UAAU,IAAI,IAAI,CAACpG,WAAW,CAACC,gBAAgB,EAAE;QAChEoG,SAAS,IAAID,UAAU;QAEvB,IAAI,IAAI,CAACpG,WAAW,CAACK,gBAAgB,GAAG,IAAI,CAACqB,MAAM,CAACF,MAAM,GAAG,CAAC,EAAE;UAC5D,IAAI,CAACxB,WAAW,CAACK,gBAAgB,EAAE;UACnC+F,UAAU,GAAG,IAAI,CAAC1E,MAAM,CAAC,IAAI,CAAC1B,WAAW,CAACK,gBAAgB,CAAC,CAACpB,IAAI,CAACuC,MAAM,GAAG,IAAI,CAACE,MAAM,CAAC,IAAI,CAAC1B,WAAW,CAACK,gBAAgB,CAAC,CAACkC,UAAU,CAACf,MAAM;;;MAIlJ,IAAI,CAACxB,WAAW,CAACI,kBAAkB,GAAG,IAAI,CAACJ,WAAW,CAACC,gBAAgB,GAAGoG,SAAS;MAEnF,IAAI,IAAI,CAACzG,oBAAoB,CAACC,iBAAiB,KAAK,CAAC,CAAC,IAAI,IAAI,CAACG,WAAW,CAACC,gBAAgB,IAAI,IAAI,CAACL,oBAAoB,CAACC,iBAAiB,EAAE;QACxI;QACA,OAAOwG,SAAS,GAAGD,UAAU,IAAI,IAAI,CAACpG,WAAW,CAACE,cAAc,EAAE;UAC9DmG,SAAS,IAAID,UAAU;UAEvB,IAAI,IAAI,CAACpG,WAAW,CAACK,gBAAgB,GAAG,IAAI,CAACqB,MAAM,CAACF,MAAM,GAAG,CAAC,EAAE;YAC5D,IAAI,CAACxB,WAAW,CAACK,gBAAgB,EAAE;YACnC+F,UAAU,GAAG,IAAI,CAAC1E,MAAM,CAAC,IAAI,CAAC1B,WAAW,CAACK,gBAAgB,CAAC,CAACpB,IAAI,CAACuC,MAAM,GAAG,IAAI,CAACE,MAAM,CAAC,IAAI,CAAC1B,WAAW,CAACK,gBAAgB,CAAC,CAACkC,UAAU,CAACf,MAAM;;;QAIlJ,IAAI,CAACxB,WAAW,CAACG,gBAAgB,GAAG,IAAI,CAACH,WAAW,CAACE,cAAc,GAAGmG,SAAS;OAClF,MAAM,IAAI,CAAC,IAAI,CAAClF,kBAAkB,EAAE;QACjC,IAAI,CAACnB,WAAW,CAACG,gBAAgB,GAAG,IAAI,CAACH,WAAW,CAACI,kBAAkB;QACvE,IAAI,CAACJ,WAAW,CAACE,cAAc,GAAG,IAAI,CAACF,WAAW,CAACC,gBAAgB;;;EAG/E;EAEA;;;;;;EAMA;EACUkN,2BAA2BA,CAACC,MAAc;IAChD;EAAA;EAGJ;;;;;;EAMUC,gBAAgBA,CAACC,IAAiB;IACxC;IACA,IAAIC,QAAQ,EAAEC,SAAS;IACvB,GAAG;MACCD,QAAQ,GAAG,IAAI,CAACvN,WAAW,CAACC,gBAAgB,GAAG,CAAC,IAAI,IAAI,CAACmB,YAAY,CAACqM,MAAM,CAAC,IAAI,CAACzN,WAAW,CAACC,gBAAgB,GAAG,CAAC,CAAC,GAAG,EAAE,IAAI,CAACD,WAAW,CAACC,gBAAgB,GAAG,CAAC;MAC7JuN,SAAS,GACL,IAAI,CAACxN,WAAW,CAACE,cAAc,GAAG,IAAI,CAACkB,YAAY,CAACI,MAAM,IAAI,IAAI,CAACJ,YAAY,CAACqM,MAAM,CAAC,IAAI,CAACzN,WAAW,CAACE,cAAc,CAAC,GAAG,EAAE,IAAI,CAACF,WAAW,CAACE,cAAc,GAAG,CAAC;KACtK,QAAQqN,QAAQ,IAAIC,SAAS;IAE9B,IAAI,CAAC5N,oBAAoB,CAACG,gBAAgB,GAAG,IAAI,CAACC,WAAW,CAACK,gBAAgB;IAC9E,IAAI,CAACT,oBAAoB,CAACC,iBAAiB,GAAG,IAAI,CAACG,WAAW,CAACC,gBAAgB;IAE/E,IAAI,CAACyN,yBAAyB,CAAC7M,eAAe,CAAC,IAAI,CAAC;IAEpD,IAAI,CAACM,kBAAkB,GAAG,IAAI;IAC9B,IAAI,CAACG,YAAY,GAAG,IAAI;IACxB,IAAI,CAACvD,YAAY,EAAE;EACvB;EAEA;EACUiD,cAAcA,CAAA;IACpB,IAAI,CAACG,kBAAkB,GAAG,IAAI;IAC9B,IAAI,CAACG,YAAY,GAAG,IAAI;IAExB,IAAI,CAAC1B,oBAAoB,GAAG;MACxBC,iBAAiB,EAAE,CAAC;MACpBC,yBAAyB,EAAE,CAAC;MAC5BC,gBAAgB,EAAE;KACrB;IAED,IAAI,CAACC,WAAW,GAAG;MACfC,gBAAgB,EAAE,CAAC;MACnBC,cAAc,EAAE,IAAI,CAACkB,YAAY,CAACI,MAAM;MACxCrB,gBAAgB,EAAE,IAAI,CAACuB,MAAM,CAAC,IAAI,CAACA,MAAM,CAACF,MAAM,GAAG,CAAC,CAAC,CAACvC,IAAI,CAACuC,MAAM;MACjEpB,kBAAkB,EAAE,CAAC;MACrBC,gBAAgB,EAAE,IAAI,CAACqB,MAAM,CAACF,MAAM,GAAG;KAC1C;IAED,IAAI,CAACzD,YAAY,EAAE;EACvB;EAEO4P,MAAMA,CAAA;IACT,KAAK,CAACC,OAAO,EAAE;IAEf,IAAI,CAACpO,sBAAsB,CAACqO,KAAK,EAAE;EACvC;;AAhnCAC,UAAA,EADCpQ,SAAS,EAAE,C,qDAGX;AA0BDoQ,UAAA,EADCpQ,SAAS,EAAE,C,6CAGX;AAolCLF,aAAa,CAAC,2BAA2B,EAAEG,aAAa,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}