{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../tslib.es6.js\";\nimport { PushMaterial } from \"../pushMaterial.js\";\nimport { AbstractMesh } from \"../../Meshes/abstractMesh.js\";\nimport { Matrix, Vector2 } from \"../../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../../Maths/math.color.js\";\nimport { Engine } from \"../../Engines/engine.js\";\nimport { NodeMaterialBuildState } from \"./nodeMaterialBuildState.js\";\nimport { Effect } from \"../effect.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterialBuildStateSharedData } from \"./nodeMaterialBuildStateSharedData.js\";\nimport { MaterialDefines } from \"../../Materials/materialDefines.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { TransformBlock } from \"./Blocks/transformBlock.js\";\nimport { VertexOutputBlock } from \"./Blocks/Vertex/vertexOutputBlock.js\";\nimport { FragmentOutputBlock } from \"./Blocks/Fragment/fragmentOutputBlock.js\";\nimport { InputBlock } from \"./Blocks/Input/inputBlock.js\";\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore.js\";\nimport { serialize, SerializationHelper } from \"../../Misc/decorators.js\";\nimport { CurrentScreenBlock } from \"./Blocks/Dual/currentScreenBlock.js\";\nimport { ParticleTextureBlock } from \"./Blocks/Particle/particleTextureBlock.js\";\nimport { ParticleRampGradientBlock } from \"./Blocks/Particle/particleRampGradientBlock.js\";\nimport { ParticleBlendMultiplyBlock } from \"./Blocks/Particle/particleBlendMultiplyBlock.js\";\nimport { EffectFallbacks } from \"../effectFallbacks.js\";\nimport { WebRequest } from \"../../Misc/webRequest.js\";\nimport { PostProcess } from \"../../PostProcesses/postProcess.js\";\nimport { VectorMergerBlock } from \"./Blocks/vectorMergerBlock.js\";\nimport { RemapBlock } from \"./Blocks/remapBlock.js\";\nimport { MultiplyBlock } from \"./Blocks/multiplyBlock.js\";\nimport { NodeMaterialModes } from \"./Enums/nodeMaterialModes.js\";\nimport { Texture } from \"../Textures/texture.js\";\nimport { BaseParticleSystem } from \"../../Particles/baseParticleSystem.js\";\nimport { ColorSplitterBlock } from \"./Blocks/colorSplitterBlock.js\";\nimport { TimingTools } from \"../../Misc/timingTools.js\";\nimport { ProceduralTexture } from \"../Textures/Procedurals/proceduralTexture.js\";\nimport { AnimatedInputBlockTypes } from \"./Blocks/Input/animatedInputBlockTypes.js\";\nimport { TrigonometryBlock, TrigonometryBlockOperations } from \"./Blocks/trigonometryBlock.js\";\nimport { NodeMaterialSystemValues } from \"./Enums/nodeMaterialSystemValues.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\nimport { MaterialHelper } from \"../materialHelper.js\";\nconst onCreatedEffectParameters = {\n  effect: null,\n  subMesh: null\n};\n/** @internal */\nexport class NodeMaterialDefines extends MaterialDefines {\n  constructor() {\n    super();\n    this.NORMAL = false;\n    this.TANGENT = false;\n    this.VERTEXCOLOR_NME = false;\n    this.UV1 = false;\n    this.UV2 = false;\n    this.UV3 = false;\n    this.UV4 = false;\n    this.UV5 = false;\n    this.UV6 = false;\n    this.PREPASS = false;\n    this.PREPASS_NORMAL = false;\n    this.PREPASS_NORMAL_INDEX = -1;\n    this.PREPASS_POSITION = false;\n    this.PREPASS_POSITION_INDEX = -1;\n    this.PREPASS_DEPTH = false;\n    this.PREPASS_DEPTH_INDEX = -1;\n    this.SCENE_MRT_COUNT = 0;\n    /** BONES */\n    this.NUM_BONE_INFLUENCERS = 0;\n    this.BonesPerMesh = 0;\n    this.BONETEXTURE = false;\n    /** MORPH TARGETS */\n    this.MORPHTARGETS = false;\n    this.MORPHTARGETS_NORMAL = false;\n    this.MORPHTARGETS_TANGENT = false;\n    this.MORPHTARGETS_UV = false;\n    this.NUM_MORPH_INFLUENCERS = 0;\n    this.MORPHTARGETS_TEXTURE = false;\n    /** IMAGE PROCESSING */\n    this.IMAGEPROCESSING = false;\n    this.VIGNETTE = false;\n    this.VIGNETTEBLENDMODEMULTIPLY = false;\n    this.VIGNETTEBLENDMODEOPAQUE = false;\n    this.TONEMAPPING = false;\n    this.TONEMAPPING_ACES = false;\n    this.CONTRAST = false;\n    this.EXPOSURE = false;\n    this.COLORCURVES = false;\n    this.COLORGRADING = false;\n    this.COLORGRADING3D = false;\n    this.SAMPLER3DGREENDEPTH = false;\n    this.SAMPLER3DBGRMAP = false;\n    this.DITHER = false;\n    this.IMAGEPROCESSINGPOSTPROCESS = false;\n    this.SKIPFINALCOLORCLAMP = false;\n    /** MISC. */\n    this.BUMPDIRECTUV = 0;\n    this.CAMERA_ORTHOGRAPHIC = false;\n    this.CAMERA_PERSPECTIVE = false;\n    this.rebuild();\n  }\n  setValue(name, value, markAsUnprocessedIfDirty = false) {\n    if (this[name] === undefined) {\n      this._keys.push(name);\n    }\n    if (markAsUnprocessedIfDirty && this[name] !== value) {\n      this.markAsUnprocessed();\n    }\n    this[name] = value;\n  }\n}\n/**\n * Class used to create a node based material built by assembling shader blocks\n */\nexport class NodeMaterial extends PushMaterial {\n  /**\n   * Checks if a block is a texture block\n   * @param block The block to check\n   * @returns True if the block is a texture block\n   */\n  static _BlockIsTextureBlock(block) {\n    return block.getClassName() === \"TextureBlock\" || block.getClassName() === \"ReflectionTextureBaseBlock\" || block.getClassName() === \"RefractionBlock\" || block.getClassName() === \"CurrentScreenBlock\" || block.getClassName() === \"ParticleTextureBlock\" || block.getClassName() === \"ImageSourceBlock\" || block.getClassName() === \"TriPlanarBlock\" || block.getClassName() === \"BiPlanarBlock\" || block.getClassName() === \"PrePassTextureBlock\";\n  }\n  /** Get the inspector from bundle or global */\n  _getGlobalNodeMaterialEditor() {\n    // UMD Global name detection from Webpack Bundle UMD Name.\n    if (typeof NODEEDITOR !== \"undefined\") {\n      return NODEEDITOR;\n    }\n    // In case of module let's check the global emitted from the editor entry point.\n    if (typeof BABYLON !== \"undefined\" && typeof BABYLON.NodeEditor !== \"undefined\") {\n      return BABYLON;\n    }\n    return undefined;\n  }\n  /** Gets or sets options to control the node material overall behavior */\n  get options() {\n    return this._options;\n  }\n  set options(options) {\n    this._options = options;\n  }\n  /**\n   * Gets the image processing configuration used either in this material.\n   */\n  get imageProcessingConfiguration() {\n    return this._imageProcessingConfiguration;\n  }\n  /**\n   * Sets the Default image processing configuration used either in the this material.\n   *\n   * If sets to null, the scene one is in use.\n   */\n  set imageProcessingConfiguration(value) {\n    this._attachImageProcessingConfiguration(value);\n    // Ensure the effect will be rebuilt.\n    this._markAllSubMeshesAsTexturesDirty();\n  }\n  /**\n   * Gets or sets the mode property\n   */\n  get mode() {\n    return this._mode;\n  }\n  set mode(value) {\n    this._mode = value;\n  }\n  /** Gets or sets the unique identifier used to identified the effect associated with the material */\n  get buildId() {\n    return this._buildId;\n  }\n  set buildId(value) {\n    this._buildId = value;\n  }\n  /**\n   * Create a new node based material\n   * @param name defines the material name\n   * @param scene defines the hosting scene\n   * @param options defines creation option\n   */\n  constructor(name, scene, options = {}) {\n    super(name, scene || EngineStore.LastCreatedScene);\n    this._buildId = NodeMaterial._BuildIdGenerator++;\n    this._buildWasSuccessful = false;\n    this._cachedWorldViewMatrix = new Matrix();\n    this._cachedWorldViewProjectionMatrix = new Matrix();\n    this._optimizers = new Array();\n    this._animationFrame = -1;\n    this.BJSNODEMATERIALEDITOR = this._getGlobalNodeMaterialEditor();\n    /**\n     * Gets or sets data used by visual editor\n     * @see https://nme.babylonjs.com\n     */\n    this.editorData = null;\n    /**\n     * Gets or sets a boolean indicating that alpha value must be ignored (This will turn alpha blending off even if an alpha value is produced by the material)\n     */\n    this.ignoreAlpha = false;\n    /**\n     * Defines the maximum number of lights that can be used in the material\n     */\n    this.maxSimultaneousLights = 4;\n    /**\n     * Observable raised when the material is built\n     */\n    this.onBuildObservable = new Observable();\n    /**\n     * Gets or sets the root nodes of the material vertex shader\n     */\n    this._vertexOutputNodes = new Array();\n    /**\n     * Gets or sets the root nodes of the material fragment (pixel) shader\n     */\n    this._fragmentOutputNodes = new Array();\n    /**\n     * Gets an array of blocks that needs to be serialized even if they are not yet connected\n     */\n    this.attachedBlocks = new Array();\n    /**\n     * Specifies the mode of the node material\n     * @internal\n     */\n    this._mode = NodeMaterialModes.Material;\n    /**\n     * Gets or sets a boolean indicating that alpha blending must be enabled no matter what alpha value or alpha channel of the FragmentBlock are\n     */\n    this.forceAlphaBlending = false;\n    this._options = Object.assign({\n      emitComments: false\n    }, options);\n    // Setup the default processing configuration to the scene.\n    this._attachImageProcessingConfiguration(null);\n  }\n  /**\n   * Gets the current class name of the material e.g. \"NodeMaterial\"\n   * @returns the class name\n   */\n  getClassName() {\n    return \"NodeMaterial\";\n  }\n  /**\n   * Attaches a new image processing configuration to the Standard Material.\n   * @param configuration\n   */\n  _attachImageProcessingConfiguration(configuration) {\n    if (configuration === this._imageProcessingConfiguration) {\n      return;\n    }\n    // Detaches observer.\n    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n    }\n    // Pick the scene configuration if needed.\n    if (!configuration) {\n      this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\n    } else {\n      this._imageProcessingConfiguration = configuration;\n    }\n    // Attaches observer.\n    if (this._imageProcessingConfiguration) {\n      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\n        this._markAllSubMeshesAsImageProcessingDirty();\n      });\n    }\n  }\n  /**\n   * Get a block by its name\n   * @param name defines the name of the block to retrieve\n   * @returns the required block or null if not found\n   */\n  getBlockByName(name) {\n    let result = null;\n    for (const block of this.attachedBlocks) {\n      if (block.name === name) {\n        if (!result) {\n          result = block;\n        } else {\n          Tools.Warn(\"More than one block was found with the name `\" + name + \"`\");\n          return result;\n        }\n      }\n    }\n    return result;\n  }\n  /**\n   * Get a block by its name\n   * @param predicate defines the predicate used to find the good candidate\n   * @returns the required block or null if not found\n   */\n  getBlockByPredicate(predicate) {\n    for (const block of this.attachedBlocks) {\n      if (predicate(block)) {\n        return block;\n      }\n    }\n    return null;\n  }\n  /**\n   * Get an input block by its name\n   * @param predicate defines the predicate used to find the good candidate\n   * @returns the required input block or null if not found\n   */\n  getInputBlockByPredicate(predicate) {\n    for (const block of this.attachedBlocks) {\n      if (block.isInput && predicate(block)) {\n        return block;\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets the list of input blocks attached to this material\n   * @returns an array of InputBlocks\n   */\n  getInputBlocks() {\n    const blocks = [];\n    for (const block of this.attachedBlocks) {\n      if (block.isInput) {\n        blocks.push(block);\n      }\n    }\n    return blocks;\n  }\n  /**\n   * Adds a new optimizer to the list of optimizers\n   * @param optimizer defines the optimizers to add\n   * @returns the current material\n   */\n  registerOptimizer(optimizer) {\n    const index = this._optimizers.indexOf(optimizer);\n    if (index > -1) {\n      return;\n    }\n    this._optimizers.push(optimizer);\n    return this;\n  }\n  /**\n   * Remove an optimizer from the list of optimizers\n   * @param optimizer defines the optimizers to remove\n   * @returns the current material\n   */\n  unregisterOptimizer(optimizer) {\n    const index = this._optimizers.indexOf(optimizer);\n    if (index === -1) {\n      return;\n    }\n    this._optimizers.splice(index, 1);\n    return this;\n  }\n  /**\n   * Add a new block to the list of output nodes\n   * @param node defines the node to add\n   * @returns the current material\n   */\n  addOutputNode(node) {\n    if (node.target === null) {\n      throw \"This node is not meant to be an output node. You may want to explicitly set its target value.\";\n    }\n    if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\n      this._addVertexOutputNode(node);\n    }\n    if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\n      this._addFragmentOutputNode(node);\n    }\n    return this;\n  }\n  /**\n   * Remove a block from the list of root nodes\n   * @param node defines the node to remove\n   * @returns the current material\n   */\n  removeOutputNode(node) {\n    if (node.target === null) {\n      return this;\n    }\n    if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\n      this._removeVertexOutputNode(node);\n    }\n    if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\n      this._removeFragmentOutputNode(node);\n    }\n    return this;\n  }\n  _addVertexOutputNode(node) {\n    if (this._vertexOutputNodes.indexOf(node) !== -1) {\n      return;\n    }\n    node.target = NodeMaterialBlockTargets.Vertex;\n    this._vertexOutputNodes.push(node);\n    return this;\n  }\n  _removeVertexOutputNode(node) {\n    const index = this._vertexOutputNodes.indexOf(node);\n    if (index === -1) {\n      return;\n    }\n    this._vertexOutputNodes.splice(index, 1);\n    return this;\n  }\n  _addFragmentOutputNode(node) {\n    if (this._fragmentOutputNodes.indexOf(node) !== -1) {\n      return;\n    }\n    node.target = NodeMaterialBlockTargets.Fragment;\n    this._fragmentOutputNodes.push(node);\n    return this;\n  }\n  _removeFragmentOutputNode(node) {\n    const index = this._fragmentOutputNodes.indexOf(node);\n    if (index === -1) {\n      return;\n    }\n    this._fragmentOutputNodes.splice(index, 1);\n    return this;\n  }\n  /**\n   * Specifies if the material will require alpha blending\n   * @returns a boolean specifying if alpha blending is needed\n   */\n  needAlphaBlending() {\n    if (this.ignoreAlpha) {\n      return false;\n    }\n    return this.forceAlphaBlending || this.alpha < 1.0 || this._sharedData && this._sharedData.hints.needAlphaBlending;\n  }\n  /**\n   * Specifies if this material should be rendered in alpha test mode\n   * @returns a boolean specifying if an alpha test is needed.\n   */\n  needAlphaTesting() {\n    return this._sharedData && this._sharedData.hints.needAlphaTesting;\n  }\n  _processInitializeOnLink(block, state, nodesToProcessForOtherBuildState, autoConfigure = true) {\n    if (block.target === NodeMaterialBlockTargets.VertexAndFragment) {\n      nodesToProcessForOtherBuildState.push(block);\n    } else if (state.target === NodeMaterialBlockTargets.Fragment && block.target === NodeMaterialBlockTargets.Vertex && block._preparationId !== this._buildId) {\n      nodesToProcessForOtherBuildState.push(block);\n    }\n    this._initializeBlock(block, state, nodesToProcessForOtherBuildState, autoConfigure);\n  }\n  _initializeBlock(node, state, nodesToProcessForOtherBuildState, autoConfigure = true) {\n    node.initialize(state);\n    if (autoConfigure) {\n      node.autoConfigure(this);\n    }\n    node._preparationId = this._buildId;\n    if (this.attachedBlocks.indexOf(node) === -1) {\n      if (node.isUnique) {\n        const className = node.getClassName();\n        for (const other of this.attachedBlocks) {\n          if (other.getClassName() === className) {\n            throw `Cannot have multiple blocks of type ${className} in the same NodeMaterial`;\n          }\n        }\n      }\n      this.attachedBlocks.push(node);\n    }\n    for (const input of node.inputs) {\n      input.associatedVariableName = \"\";\n      const connectedPoint = input.connectedPoint;\n      if (connectedPoint) {\n        const block = connectedPoint.ownerBlock;\n        if (block !== node) {\n          this._processInitializeOnLink(block, state, nodesToProcessForOtherBuildState, autoConfigure);\n        }\n      }\n    }\n    // Teleportation\n    if (node.isTeleportOut) {\n      const teleport = node;\n      if (teleport.entryPoint) {\n        this._processInitializeOnLink(teleport.entryPoint, state, nodesToProcessForOtherBuildState, autoConfigure);\n      }\n    }\n    for (const output of node.outputs) {\n      output.associatedVariableName = \"\";\n    }\n  }\n  _resetDualBlocks(node, id) {\n    if (node.target === NodeMaterialBlockTargets.VertexAndFragment) {\n      node.buildId = id;\n    }\n    for (const inputs of node.inputs) {\n      const connectedPoint = inputs.connectedPoint;\n      if (connectedPoint) {\n        const block = connectedPoint.ownerBlock;\n        if (block !== node) {\n          this._resetDualBlocks(block, id);\n        }\n      }\n    }\n    // If this is a teleport out, we need to reset the connected block\n    if (node.isTeleportOut) {\n      const teleportOut = node;\n      if (teleportOut.entryPoint) {\n        this._resetDualBlocks(teleportOut.entryPoint, id);\n      }\n    }\n  }\n  /**\n   * Remove a block from the current node material\n   * @param block defines the block to remove\n   */\n  removeBlock(block) {\n    const attachedBlockIndex = this.attachedBlocks.indexOf(block);\n    if (attachedBlockIndex > -1) {\n      this.attachedBlocks.splice(attachedBlockIndex, 1);\n    }\n    if (block.isFinalMerger) {\n      this.removeOutputNode(block);\n    }\n  }\n  /**\n   * Build the material and generates the inner effect\n   * @param verbose defines if the build should log activity\n   * @param updateBuildId defines if the internal build Id should be updated (default is true)\n   * @param autoConfigure defines if the autoConfigure method should be called when initializing blocks (default is false)\n   */\n  build(verbose = false, updateBuildId = true, autoConfigure = false) {\n    // First time?\n    if (!this._vertexCompilationState && !autoConfigure) {\n      autoConfigure = true;\n    }\n    this._buildWasSuccessful = false;\n    const engine = this.getScene().getEngine();\n    const allowEmptyVertexProgram = this._mode === NodeMaterialModes.Particle;\n    if (this._vertexOutputNodes.length === 0 && !allowEmptyVertexProgram) {\n      throw \"You must define at least one vertexOutputNode\";\n    }\n    if (this._fragmentOutputNodes.length === 0) {\n      throw \"You must define at least one fragmentOutputNode\";\n    }\n    // Compilation state\n    this._vertexCompilationState = new NodeMaterialBuildState();\n    this._vertexCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\n    this._vertexCompilationState.target = NodeMaterialBlockTargets.Vertex;\n    this._fragmentCompilationState = new NodeMaterialBuildState();\n    this._fragmentCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\n    this._fragmentCompilationState.target = NodeMaterialBlockTargets.Fragment;\n    // Shared data\n    this._sharedData = new NodeMaterialBuildStateSharedData();\n    this._sharedData.fragmentOutputNodes = this._fragmentOutputNodes;\n    this._vertexCompilationState.sharedData = this._sharedData;\n    this._fragmentCompilationState.sharedData = this._sharedData;\n    this._sharedData.buildId = this._buildId;\n    this._sharedData.emitComments = this._options.emitComments;\n    this._sharedData.verbose = verbose;\n    this._sharedData.scene = this.getScene();\n    this._sharedData.allowEmptyVertexProgram = allowEmptyVertexProgram;\n    // Initialize blocks\n    const vertexNodes = [];\n    const fragmentNodes = [];\n    for (const vertexOutputNode of this._vertexOutputNodes) {\n      vertexNodes.push(vertexOutputNode);\n      this._initializeBlock(vertexOutputNode, this._vertexCompilationState, fragmentNodes, autoConfigure);\n    }\n    for (const fragmentOutputNode of this._fragmentOutputNodes) {\n      fragmentNodes.push(fragmentOutputNode);\n      this._initializeBlock(fragmentOutputNode, this._fragmentCompilationState, vertexNodes, autoConfigure);\n    }\n    // Optimize\n    this.optimize();\n    // Vertex\n    for (const vertexOutputNode of vertexNodes) {\n      vertexOutputNode.build(this._vertexCompilationState, vertexNodes);\n    }\n    // Fragment\n    this._fragmentCompilationState.uniforms = this._vertexCompilationState.uniforms.slice(0);\n    this._fragmentCompilationState._uniformDeclaration = this._vertexCompilationState._uniformDeclaration;\n    this._fragmentCompilationState._constantDeclaration = this._vertexCompilationState._constantDeclaration;\n    this._fragmentCompilationState._vertexState = this._vertexCompilationState;\n    for (const fragmentOutputNode of fragmentNodes) {\n      this._resetDualBlocks(fragmentOutputNode, this._buildId - 1);\n    }\n    for (const fragmentOutputNode of fragmentNodes) {\n      fragmentOutputNode.build(this._fragmentCompilationState, fragmentNodes);\n    }\n    // Finalize\n    this._vertexCompilationState.finalize(this._vertexCompilationState);\n    this._fragmentCompilationState.finalize(this._fragmentCompilationState);\n    if (updateBuildId) {\n      this._buildId = NodeMaterial._BuildIdGenerator++;\n    }\n    // Errors\n    this._sharedData.emitErrors();\n    if (verbose) {\n      console.log(\"Vertex shader:\");\n      console.log(this._vertexCompilationState.compilationString);\n      console.log(\"Fragment shader:\");\n      console.log(this._fragmentCompilationState.compilationString);\n    }\n    this._buildWasSuccessful = true;\n    this.onBuildObservable.notifyObservers(this);\n    // Wipe defines\n    const meshes = this.getScene().meshes;\n    for (const mesh of meshes) {\n      if (!mesh.subMeshes) {\n        continue;\n      }\n      for (const subMesh of mesh.subMeshes) {\n        if (subMesh.getMaterial() !== this) {\n          continue;\n        }\n        if (!subMesh.materialDefines) {\n          continue;\n        }\n        const defines = subMesh.materialDefines;\n        defines.markAllAsDirty();\n        defines.reset();\n      }\n    }\n    if (this.prePassTextureInputs.length) {\n      this.getScene().enablePrePassRenderer();\n    }\n    const prePassRenderer = this.getScene().prePassRenderer;\n    if (prePassRenderer) {\n      prePassRenderer.markAsDirty();\n    }\n  }\n  /**\n   * Runs an otpimization phase to try to improve the shader code\n   */\n  optimize() {\n    for (const optimizer of this._optimizers) {\n      optimizer.optimize(this._vertexOutputNodes, this._fragmentOutputNodes);\n    }\n  }\n  _prepareDefinesForAttributes(mesh, defines) {\n    const oldNormal = defines[\"NORMAL\"];\n    const oldTangent = defines[\"TANGENT\"];\n    const oldColor = defines[\"VERTEXCOLOR_NME\"];\n    defines[\"NORMAL\"] = mesh.isVerticesDataPresent(VertexBuffer.NormalKind);\n    defines[\"TANGENT\"] = mesh.isVerticesDataPresent(VertexBuffer.TangentKind);\n    const hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);\n    defines[\"VERTEXCOLOR_NME\"] = hasVertexColors;\n    let uvChanged = false;\n    for (let i = 1; i <= 6; ++i) {\n      const oldUV = defines[\"UV\" + i];\n      defines[\"UV\" + i] = mesh.isVerticesDataPresent(`uv${i === 1 ? \"\" : i}`);\n      uvChanged = uvChanged || defines[\"UV\" + i] !== oldUV;\n    }\n    // PrePass\n    const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;\n    MaterialHelper.PrepareDefinesForPrePass(this.getScene(), defines, !oit);\n    if (oldNormal !== defines[\"NORMAL\"] || oldTangent !== defines[\"TANGENT\"] || oldColor !== defines[\"VERTEXCOLOR_NME\"] || uvChanged) {\n      defines.markAsAttributesDirty();\n    }\n  }\n  /**\n   * Can this material render to prepass\n   */\n  get isPrePassCapable() {\n    return true;\n  }\n  /**\n   * Outputs written to the prepass\n   */\n  get prePassTextureOutputs() {\n    const prePassOutputBlock = this.getBlockByPredicate(block => block.getClassName() === \"PrePassOutputBlock\");\n    const result = [4];\n    if (!prePassOutputBlock) {\n      return result;\n    }\n    // Cannot write to prepass if we alread read from prepass\n    if (this.prePassTextureInputs.length) {\n      return result;\n    }\n    if (prePassOutputBlock.viewDepth.isConnected) {\n      result.push(5);\n    }\n    if (prePassOutputBlock.viewNormal.isConnected) {\n      result.push(6);\n    }\n    if (prePassOutputBlock.worldPosition.isConnected) {\n      result.push(1);\n    }\n    return result;\n  }\n  /**\n   * Gets the list of prepass texture required\n   */\n  get prePassTextureInputs() {\n    const prePassTextureBlocks = this.getAllTextureBlocks().filter(block => block.getClassName() === \"PrePassTextureBlock\");\n    const result = [];\n    for (const block of prePassTextureBlocks) {\n      if (block.position.isConnected && !result.includes(1)) {\n        result.push(1);\n      }\n      if (block.depth.isConnected && !result.includes(5)) {\n        result.push(5);\n      }\n      if (block.normal.isConnected && !result.includes(6)) {\n        result.push(6);\n      }\n    }\n    return result;\n  }\n  /**\n   * Sets the required values to the prepass renderer.\n   */\n  setPrePassRenderer(prePassRenderer) {\n    const prePassTexturesRequired = this.prePassTextureInputs.concat(this.prePassTextureOutputs);\n    if (prePassRenderer && prePassTexturesRequired.length > 1) {\n      let cfg = prePassRenderer.getEffectConfiguration(\"nodeMaterial\");\n      if (!cfg) {\n        cfg = prePassRenderer.addEffectConfiguration({\n          enabled: true,\n          needsImageProcessing: false,\n          name: \"nodeMaterial\",\n          texturesRequired: []\n        });\n      }\n      for (const prePassTexture of prePassTexturesRequired) {\n        if (!cfg.texturesRequired.includes(prePassTexture)) {\n          cfg.texturesRequired.push(prePassTexture);\n        }\n      }\n      cfg.enabled = true;\n    }\n    // COLOR_TEXTURE is always required for prepass, length > 1 means\n    // we actually need to write to special prepass textures\n    return prePassTexturesRequired.length > 1;\n  }\n  /**\n   * Create a post process from the material\n   * @param camera The camera to apply the render pass to.\n   * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\n   * @param engine The engine which the post process will be applied. (default: current engine)\n   * @param reusable If the post process can be reused on the same frame. (default: false)\n   * @param textureType Type of textures used when performing the post process. (default: 0)\n   * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\n   * @returns the post process created\n   */\n  createPostProcess(camera, options = 1, samplingMode = 1, engine, reusable, textureType = 0, textureFormat = 5) {\n    if (this.mode !== NodeMaterialModes.PostProcess) {\n      console.log(\"Incompatible material mode\");\n      return null;\n    }\n    return this._createEffectForPostProcess(null, camera, options, samplingMode, engine, reusable, textureType, textureFormat);\n  }\n  /**\n   * Create the post process effect from the material\n   * @param postProcess The post process to create the effect for\n   */\n  createEffectForPostProcess(postProcess) {\n    this._createEffectForPostProcess(postProcess);\n  }\n  _createEffectForPostProcess(postProcess, camera, options = 1, samplingMode = 1, engine, reusable, textureType = 0, textureFormat = 5) {\n    let tempName = this.name + this._buildId;\n    const defines = new NodeMaterialDefines();\n    const dummyMesh = new AbstractMesh(tempName + \"PostProcess\", this.getScene());\n    let buildId = this._buildId;\n    this._processDefines(dummyMesh, defines);\n    Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\n    if (!postProcess) {\n      postProcess = new PostProcess(this.name + \"PostProcess\", tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, options, camera, samplingMode, engine, reusable, defines.toString(), textureType, tempName, {\n        maxSimultaneousLights: this.maxSimultaneousLights\n      }, false, textureFormat);\n    } else {\n      postProcess.updateEffect(defines.toString(), this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, {\n        maxSimultaneousLights: this.maxSimultaneousLights\n      }, undefined, undefined, tempName, tempName);\n    }\n    postProcess.nodeMaterialSource = this;\n    postProcess.onApplyObservable.add(effect => {\n      if (buildId !== this._buildId) {\n        delete Effect.ShadersStore[tempName + \"VertexShader\"];\n        delete Effect.ShadersStore[tempName + \"PixelShader\"];\n        tempName = this.name + this._buildId;\n        defines.markAllAsDirty();\n        buildId = this._buildId;\n      }\n      const result = this._processDefines(dummyMesh, defines);\n      if (result) {\n        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\n        TimingTools.SetImmediate(() => postProcess.updateEffect(defines.toString(), this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, {\n          maxSimultaneousLights: this.maxSimultaneousLights\n        }, undefined, undefined, tempName, tempName));\n      }\n      this._checkInternals(effect);\n    });\n    return postProcess;\n  }\n  /**\n   * Create a new procedural texture based on this node material\n   * @param size defines the size of the texture\n   * @param scene defines the hosting scene\n   * @returns the new procedural texture attached to this node material\n   */\n  createProceduralTexture(size, scene) {\n    if (this.mode !== NodeMaterialModes.ProceduralTexture) {\n      console.log(\"Incompatible material mode\");\n      return null;\n    }\n    let tempName = this.name + this._buildId;\n    const proceduralTexture = new ProceduralTexture(tempName, size, null, scene);\n    const dummyMesh = new AbstractMesh(tempName + \"Procedural\", this.getScene());\n    dummyMesh.reservedDataStore = {\n      hidden: true\n    };\n    const defines = new NodeMaterialDefines();\n    const result = this._processDefines(dummyMesh, defines);\n    Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\n    let effect = this.getScene().getEngine().createEffect({\n      vertexElement: tempName,\n      fragmentElement: tempName\n    }, [VertexBuffer.PositionKind], this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString(), result === null || result === void 0 ? void 0 : result.fallbacks, undefined);\n    proceduralTexture.nodeMaterialSource = this;\n    proceduralTexture._setEffect(effect);\n    let buildId = this._buildId;\n    proceduralTexture.onBeforeGenerationObservable.add(() => {\n      if (buildId !== this._buildId) {\n        delete Effect.ShadersStore[tempName + \"VertexShader\"];\n        delete Effect.ShadersStore[tempName + \"PixelShader\"];\n        tempName = this.name + this._buildId;\n        defines.markAllAsDirty();\n        buildId = this._buildId;\n      }\n      const result = this._processDefines(dummyMesh, defines);\n      if (result) {\n        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\n        TimingTools.SetImmediate(() => {\n          effect = this.getScene().getEngine().createEffect({\n            vertexElement: tempName,\n            fragmentElement: tempName\n          }, [VertexBuffer.PositionKind], this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString(), result === null || result === void 0 ? void 0 : result.fallbacks, undefined);\n          proceduralTexture._setEffect(effect);\n        });\n      }\n      this._checkInternals(effect);\n    });\n    return proceduralTexture;\n  }\n  _createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect, defines, dummyMesh, particleSystemDefinesJoined = \"\") {\n    let tempName = this.name + this._buildId + \"_\" + blendMode;\n    if (!defines) {\n      defines = new NodeMaterialDefines();\n    }\n    if (!dummyMesh) {\n      dummyMesh = this.getScene().getMeshByName(this.name + \"Particle\");\n      if (!dummyMesh) {\n        dummyMesh = new AbstractMesh(this.name + \"Particle\", this.getScene());\n        dummyMesh.reservedDataStore = {\n          hidden: true\n        };\n      }\n    }\n    let buildId = this._buildId;\n    const particleSystemDefines = [];\n    let join = particleSystemDefinesJoined;\n    if (!effect) {\n      const result = this._processDefines(dummyMesh, defines);\n      Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString);\n      particleSystem.fillDefines(particleSystemDefines, blendMode);\n      join = particleSystemDefines.join(\"\\n\");\n      effect = this.getScene().getEngine().createEffectForParticles(tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString() + \"\\n\" + join, result === null || result === void 0 ? void 0 : result.fallbacks, onCompiled, onError, particleSystem);\n      particleSystem.setCustomEffect(effect, blendMode);\n    }\n    effect.onBindObservable.add(effect => {\n      if (buildId !== this._buildId) {\n        delete Effect.ShadersStore[tempName + \"PixelShader\"];\n        tempName = this.name + this._buildId + \"_\" + blendMode;\n        defines.markAllAsDirty();\n        buildId = this._buildId;\n      }\n      particleSystemDefines.length = 0;\n      particleSystem.fillDefines(particleSystemDefines, blendMode);\n      const particleSystemDefinesJoinedCurrent = particleSystemDefines.join(\"\\n\");\n      if (particleSystemDefinesJoinedCurrent !== join) {\n        defines.markAllAsDirty();\n        join = particleSystemDefinesJoinedCurrent;\n      }\n      const result = this._processDefines(dummyMesh, defines);\n      if (result) {\n        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString);\n        effect = this.getScene().getEngine().createEffectForParticles(tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString() + \"\\n\" + join, result === null || result === void 0 ? void 0 : result.fallbacks, onCompiled, onError, particleSystem);\n        particleSystem.setCustomEffect(effect, blendMode);\n        this._createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect, defines, dummyMesh, particleSystemDefinesJoined); // add the effect.onBindObservable observer\n        return;\n      }\n      this._checkInternals(effect);\n    });\n  }\n  _checkInternals(effect) {\n    // Animated blocks\n    if (this._sharedData.animatedInputs) {\n      const scene = this.getScene();\n      const frameId = scene.getFrameId();\n      if (this._animationFrame !== frameId) {\n        for (const input of this._sharedData.animatedInputs) {\n          input.animate(scene);\n        }\n        this._animationFrame = frameId;\n      }\n    }\n    // Bindable blocks\n    for (const block of this._sharedData.bindableBlocks) {\n      block.bind(effect, this);\n    }\n    // Connection points\n    for (const inputBlock of this._sharedData.inputBlocks) {\n      inputBlock._transmit(effect, this.getScene(), this);\n    }\n  }\n  /**\n   * Create the effect to be used as the custom effect for a particle system\n   * @param particleSystem Particle system to create the effect for\n   * @param onCompiled defines a function to call when the effect creation is successful\n   * @param onError defines a function to call when the effect creation has failed\n   */\n  createEffectForParticles(particleSystem, onCompiled, onError) {\n    if (this.mode !== NodeMaterialModes.Particle) {\n      console.log(\"Incompatible material mode\");\n      return;\n    }\n    this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_ONEONE, onCompiled, onError);\n    this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_MULTIPLY, onCompiled, onError);\n  }\n  /**\n   * Use this material as the shadow depth wrapper of a target material\n   * @param targetMaterial defines the target material\n   */\n  createAsShadowDepthWrapper(targetMaterial) {\n    if (this.mode !== NodeMaterialModes.Material) {\n      console.log(\"Incompatible material mode\");\n      return;\n    }\n    targetMaterial.shadowDepthWrapper = new BABYLON.ShadowDepthWrapper(this, this.getScene());\n  }\n  _processDefines(mesh, defines, useInstances = false, subMesh) {\n    let result = null;\n    // Global defines\n    const scene = this.getScene();\n    if (MaterialHelper.PrepareDefinesForCamera(scene, defines)) {\n      defines.markAsMiscDirty();\n    }\n    // Shared defines\n    this._sharedData.blocksWithDefines.forEach(b => {\n      b.initializeDefines(mesh, this, defines, useInstances);\n    });\n    this._sharedData.blocksWithDefines.forEach(b => {\n      b.prepareDefines(mesh, this, defines, useInstances, subMesh);\n    });\n    // Need to recompile?\n    if (defines.isDirty) {\n      const lightDisposed = defines._areLightsDisposed;\n      defines.markAsProcessed();\n      // Repeatable content generators\n      this._vertexCompilationState.compilationString = this._vertexCompilationState._builtCompilationString;\n      this._fragmentCompilationState.compilationString = this._fragmentCompilationState._builtCompilationString;\n      this._sharedData.repeatableContentBlocks.forEach(b => {\n        b.replaceRepeatableContent(this._vertexCompilationState, this._fragmentCompilationState, mesh, defines);\n      });\n      // Uniforms\n      const uniformBuffers = [];\n      this._sharedData.dynamicUniformBlocks.forEach(b => {\n        b.updateUniformsAndSamples(this._vertexCompilationState, this, defines, uniformBuffers);\n      });\n      const mergedUniforms = this._vertexCompilationState.uniforms;\n      this._fragmentCompilationState.uniforms.forEach(u => {\n        const index = mergedUniforms.indexOf(u);\n        if (index === -1) {\n          mergedUniforms.push(u);\n        }\n      });\n      // Samplers\n      const mergedSamplers = this._vertexCompilationState.samplers;\n      this._fragmentCompilationState.samplers.forEach(s => {\n        const index = mergedSamplers.indexOf(s);\n        if (index === -1) {\n          mergedSamplers.push(s);\n        }\n      });\n      const fallbacks = new EffectFallbacks();\n      this._sharedData.blocksWithFallbacks.forEach(b => {\n        b.provideFallbacks(mesh, fallbacks);\n      });\n      result = {\n        lightDisposed,\n        uniformBuffers,\n        mergedUniforms,\n        mergedSamplers,\n        fallbacks\n      };\n    }\n    return result;\n  }\n  /**\n   * Get if the submesh is ready to be used and all its information available.\n   * Child classes can use it to update shaders\n   * @param mesh defines the mesh to check\n   * @param subMesh defines which submesh to check\n   * @param useInstances specifies that instances should be used\n   * @returns a boolean indicating that the submesh is ready or not\n   */\n  isReadyForSubMesh(mesh, subMesh, useInstances = false) {\n    if (!this._buildWasSuccessful) {\n      return false;\n    }\n    const scene = this.getScene();\n    if (this._sharedData.animatedInputs) {\n      const frameId = scene.getFrameId();\n      if (this._animationFrame !== frameId) {\n        for (const input of this._sharedData.animatedInputs) {\n          input.animate(scene);\n        }\n        this._animationFrame = frameId;\n      }\n    }\n    if (subMesh.effect && this.isFrozen) {\n      if (subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\n        return true;\n      }\n    }\n    if (!subMesh.materialDefines) {\n      subMesh.materialDefines = new NodeMaterialDefines();\n    }\n    const defines = subMesh.materialDefines;\n    if (this._isReadyForSubMesh(subMesh)) {\n      return true;\n    }\n    const engine = scene.getEngine();\n    this._prepareDefinesForAttributes(mesh, defines);\n    // Check if blocks are ready\n    if (this._sharedData.blockingBlocks.some(b => !b.isReady(mesh, this, defines, useInstances))) {\n      return false;\n    }\n    const result = this._processDefines(mesh, defines, useInstances, subMesh);\n    if (result) {\n      const previousEffect = subMesh.effect;\n      // Compilation\n      const join = defines.toString();\n      let effect = engine.createEffect({\n        vertex: \"nodeMaterial\" + this._buildId,\n        fragment: \"nodeMaterial\" + this._buildId,\n        vertexSource: this._vertexCompilationState.compilationString,\n        fragmentSource: this._fragmentCompilationState.compilationString\n      }, {\n        attributes: this._vertexCompilationState.attributes,\n        uniformsNames: result.mergedUniforms,\n        uniformBuffersNames: result.uniformBuffers,\n        samplers: result.mergedSamplers,\n        defines: join,\n        fallbacks: result.fallbacks,\n        onCompiled: this.onCompiled,\n        onError: this.onError,\n        multiTarget: defines.PREPASS,\n        indexParameters: {\n          maxSimultaneousLights: this.maxSimultaneousLights,\n          maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS\n        }\n      }, engine);\n      if (effect) {\n        if (this._onEffectCreatedObservable) {\n          onCreatedEffectParameters.effect = effect;\n          onCreatedEffectParameters.subMesh = subMesh;\n          this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\n        }\n        // Use previous effect while new one is compiling\n        if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\n          effect = previousEffect;\n          defines.markAsUnprocessed();\n          if (result.lightDisposed) {\n            // re register in case it takes more than one frame.\n            defines._areLightsDisposed = true;\n            return false;\n          }\n        } else {\n          scene.resetCachedMaterial();\n          subMesh.setEffect(effect, defines, this._materialContext);\n        }\n      }\n    }\n    if (!subMesh.effect || !subMesh.effect.isReady()) {\n      return false;\n    }\n    defines._renderId = scene.getRenderId();\n    subMesh.effect._wasPreviouslyReady = true;\n    subMesh.effect._wasPreviouslyUsingInstances = useInstances;\n    this._checkScenePerformancePriority();\n    return true;\n  }\n  /**\n   * Get a string representing the shaders built by the current node graph\n   */\n  get compiledShaders() {\n    return `// Vertex shader\\n${this._vertexCompilationState.compilationString}\\n\\n// Fragment shader\\n${this._fragmentCompilationState.compilationString}`;\n  }\n  /**\n   * Binds the world matrix to the material\n   * @param world defines the world transformation matrix\n   */\n  bindOnlyWorldMatrix(world) {\n    const scene = this.getScene();\n    if (!this._activeEffect) {\n      return;\n    }\n    const hints = this._sharedData.hints;\n    if (hints.needWorldViewMatrix) {\n      world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\n    }\n    if (hints.needWorldViewProjectionMatrix) {\n      world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\n    }\n    // Connection points\n    for (const inputBlock of this._sharedData.inputBlocks) {\n      inputBlock._transmitWorld(this._activeEffect, world, this._cachedWorldViewMatrix, this._cachedWorldViewProjectionMatrix);\n    }\n  }\n  /**\n   * Binds the submesh to this material by preparing the effect and shader to draw\n   * @param world defines the world transformation matrix\n   * @param mesh defines the mesh containing the submesh\n   * @param subMesh defines the submesh to bind the material to\n   */\n  bindForSubMesh(world, mesh, subMesh) {\n    const scene = this.getScene();\n    const effect = subMesh.effect;\n    if (!effect) {\n      return;\n    }\n    this._activeEffect = effect;\n    // Matrices\n    this.bindOnlyWorldMatrix(world);\n    const mustRebind = this._mustRebind(scene, effect, mesh.visibility);\n    const sharedData = this._sharedData;\n    if (mustRebind) {\n      // Bindable blocks\n      for (const block of sharedData.bindableBlocks) {\n        block.bind(effect, this, mesh, subMesh);\n      }\n      for (const block of sharedData.forcedBindableBlocks) {\n        block.bind(effect, this, mesh, subMesh);\n      }\n      // Connection points\n      for (const inputBlock of sharedData.inputBlocks) {\n        inputBlock._transmit(effect, scene, this);\n      }\n    } else if (!this.isFrozen) {\n      for (const block of sharedData.forcedBindableBlocks) {\n        block.bind(effect, this, mesh, subMesh);\n      }\n    }\n    this._afterBind(mesh, this._activeEffect);\n  }\n  /**\n   * Gets the active textures from the material\n   * @returns an array of textures\n   */\n  getActiveTextures() {\n    const activeTextures = super.getActiveTextures();\n    if (this._sharedData) {\n      activeTextures.push(...this._sharedData.textureBlocks.filter(tb => tb.texture).map(tb => tb.texture));\n    }\n    return activeTextures;\n  }\n  /**\n   * Gets the list of texture blocks\n   * Note that this method will only return blocks that are reachable from the final block(s) and only after the material has been built!\n   * @returns an array of texture blocks\n   */\n  getTextureBlocks() {\n    if (!this._sharedData) {\n      return [];\n    }\n    return this._sharedData.textureBlocks;\n  }\n  /**\n   * Gets the list of all texture blocks\n   * Note that this method will scan all attachedBlocks and return blocks that are texture blocks\n   * @returns\n   */\n  getAllTextureBlocks() {\n    const textureBlocks = [];\n    for (const block of this.attachedBlocks) {\n      if (NodeMaterial._BlockIsTextureBlock(block)) {\n        textureBlocks.push(block);\n      }\n    }\n    return textureBlocks;\n  }\n  /**\n   * Specifies if the material uses a texture\n   * @param texture defines the texture to check against the material\n   * @returns a boolean specifying if the material uses the texture\n   */\n  hasTexture(texture) {\n    if (super.hasTexture(texture)) {\n      return true;\n    }\n    if (!this._sharedData) {\n      return false;\n    }\n    for (const t of this._sharedData.textureBlocks) {\n      if (t.texture === texture) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Disposes the material\n   * @param forceDisposeEffect specifies if effects should be forcefully disposed\n   * @param forceDisposeTextures specifies if textures should be forcefully disposed\n   * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\n   */\n  dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {\n    if (forceDisposeTextures) {\n      for (const texture of this.getTextureBlocks().filter(tb => tb.texture).map(tb => tb.texture)) {\n        texture.dispose();\n      }\n    }\n    for (const block of this.attachedBlocks) {\n      block.dispose();\n    }\n    this.attachedBlocks.length = 0;\n    this._sharedData = null;\n    this._vertexCompilationState = null;\n    this._fragmentCompilationState = null;\n    this.onBuildObservable.clear();\n    if (this._imageProcessingObserver) {\n      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n      this._imageProcessingObserver = null;\n    }\n    super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\n  }\n  /** Creates the node editor window. */\n  _createNodeEditor(additionalConfig) {\n    const nodeEditorConfig = Object.assign({\n      nodeMaterial: this\n    }, additionalConfig);\n    this.BJSNODEMATERIALEDITOR.NodeEditor.Show(nodeEditorConfig);\n  }\n  /**\n   * Launch the node material editor\n   * @param config Define the configuration of the editor\n   * @returns a promise fulfilled when the node editor is visible\n   */\n  edit(config) {\n    return new Promise(resolve => {\n      this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();\n      if (typeof this.BJSNODEMATERIALEDITOR == \"undefined\") {\n        const editorUrl = config && config.editorURL ? config.editorURL : NodeMaterial.EditorURL;\n        // Load editor and add it to the DOM\n        Tools.LoadBabylonScript(editorUrl, () => {\n          this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();\n          this._createNodeEditor(config === null || config === void 0 ? void 0 : config.nodeEditorConfig);\n          resolve();\n        });\n      } else {\n        // Otherwise creates the editor\n        this._createNodeEditor(config === null || config === void 0 ? void 0 : config.nodeEditorConfig);\n        resolve();\n      }\n    });\n  }\n  /**\n   * Clear the current material\n   */\n  clear() {\n    this._vertexOutputNodes.length = 0;\n    this._fragmentOutputNodes.length = 0;\n    this.attachedBlocks.length = 0;\n  }\n  /**\n   * Clear the current material and set it to a default state\n   */\n  setToDefault() {\n    this.clear();\n    this.editorData = null;\n    const positionInput = new InputBlock(\"Position\");\n    positionInput.setAsAttribute(\"position\");\n    const worldInput = new InputBlock(\"World\");\n    worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\n    const worldPos = new TransformBlock(\"WorldPos\");\n    positionInput.connectTo(worldPos);\n    worldInput.connectTo(worldPos);\n    const viewProjectionInput = new InputBlock(\"ViewProjection\");\n    viewProjectionInput.setAsSystemValue(NodeMaterialSystemValues.ViewProjection);\n    const worldPosdMultipliedByViewProjection = new TransformBlock(\"WorldPos * ViewProjectionTransform\");\n    worldPos.connectTo(worldPosdMultipliedByViewProjection);\n    viewProjectionInput.connectTo(worldPosdMultipliedByViewProjection);\n    const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\n    worldPosdMultipliedByViewProjection.connectTo(vertexOutput);\n    // Pixel\n    const pixelColor = new InputBlock(\"color\");\n    pixelColor.value = new Color4(0.8, 0.8, 0.8, 1);\n    const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\n    pixelColor.connectTo(fragmentOutput);\n    // Add to nodes\n    this.addOutputNode(vertexOutput);\n    this.addOutputNode(fragmentOutput);\n    this._mode = NodeMaterialModes.Material;\n  }\n  /**\n   * Clear the current material and set it to a default state for post process\n   */\n  setToDefaultPostProcess() {\n    this.clear();\n    this.editorData = null;\n    const position = new InputBlock(\"Position\");\n    position.setAsAttribute(\"position2d\");\n    const const1 = new InputBlock(\"Constant1\");\n    const1.isConstant = true;\n    const1.value = 1;\n    const vmerger = new VectorMergerBlock(\"Position3D\");\n    position.connectTo(vmerger);\n    const1.connectTo(vmerger, {\n      input: \"w\"\n    });\n    const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\n    vmerger.connectTo(vertexOutput);\n    // Pixel\n    const scale = new InputBlock(\"Scale\");\n    scale.visibleInInspector = true;\n    scale.value = new Vector2(1, 1);\n    const uv0 = new RemapBlock(\"uv0\");\n    position.connectTo(uv0);\n    const uv = new MultiplyBlock(\"UV scale\");\n    uv0.connectTo(uv);\n    scale.connectTo(uv);\n    const currentScreen = new CurrentScreenBlock(\"CurrentScreen\");\n    uv.connectTo(currentScreen);\n    currentScreen.texture = new Texture(\"https://assets.babylonjs.com/nme/currentScreenPostProcess.png\", this.getScene());\n    const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\n    currentScreen.connectTo(fragmentOutput, {\n      output: \"rgba\"\n    });\n    // Add to nodes\n    this.addOutputNode(vertexOutput);\n    this.addOutputNode(fragmentOutput);\n    this._mode = NodeMaterialModes.PostProcess;\n  }\n  /**\n   * Clear the current material and set it to a default state for procedural texture\n   */\n  setToDefaultProceduralTexture() {\n    this.clear();\n    this.editorData = null;\n    const position = new InputBlock(\"Position\");\n    position.setAsAttribute(\"position2d\");\n    const const1 = new InputBlock(\"Constant1\");\n    const1.isConstant = true;\n    const1.value = 1;\n    const vmerger = new VectorMergerBlock(\"Position3D\");\n    position.connectTo(vmerger);\n    const1.connectTo(vmerger, {\n      input: \"w\"\n    });\n    const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\n    vmerger.connectTo(vertexOutput);\n    // Pixel\n    const time = new InputBlock(\"Time\");\n    time.value = 0;\n    time.min = 0;\n    time.max = 0;\n    time.isBoolean = false;\n    time.matrixMode = 0;\n    time.animationType = AnimatedInputBlockTypes.Time;\n    time.isConstant = false;\n    const color = new InputBlock(\"Color3\");\n    color.value = new Color3(1, 1, 1);\n    color.isConstant = false;\n    const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\n    const vectorMerger = new VectorMergerBlock(\"VectorMerger\");\n    vectorMerger.visibleInInspector = false;\n    const cos = new TrigonometryBlock(\"Cos\");\n    cos.operation = TrigonometryBlockOperations.Cos;\n    position.connectTo(vectorMerger);\n    time.output.connectTo(cos.input);\n    cos.output.connectTo(vectorMerger.z);\n    vectorMerger.xyzOut.connectTo(fragmentOutput.rgb);\n    // Add to nodes\n    this.addOutputNode(vertexOutput);\n    this.addOutputNode(fragmentOutput);\n    this._mode = NodeMaterialModes.ProceduralTexture;\n  }\n  /**\n   * Clear the current material and set it to a default state for particle\n   */\n  setToDefaultParticle() {\n    this.clear();\n    this.editorData = null;\n    // Pixel\n    const uv = new InputBlock(\"uv\");\n    uv.setAsAttribute(\"particle_uv\");\n    const texture = new ParticleTextureBlock(\"ParticleTexture\");\n    uv.connectTo(texture);\n    const color = new InputBlock(\"Color\");\n    color.setAsAttribute(\"particle_color\");\n    const multiply = new MultiplyBlock(\"Texture * Color\");\n    texture.connectTo(multiply);\n    color.connectTo(multiply);\n    const rampGradient = new ParticleRampGradientBlock(\"ParticleRampGradient\");\n    multiply.connectTo(rampGradient);\n    const cSplitter = new ColorSplitterBlock(\"ColorSplitter\");\n    color.connectTo(cSplitter);\n    const blendMultiply = new ParticleBlendMultiplyBlock(\"ParticleBlendMultiply\");\n    rampGradient.connectTo(blendMultiply);\n    texture.connectTo(blendMultiply, {\n      output: \"a\"\n    });\n    cSplitter.connectTo(blendMultiply, {\n      output: \"a\"\n    });\n    const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\n    blendMultiply.connectTo(fragmentOutput);\n    // Add to nodes\n    this.addOutputNode(fragmentOutput);\n    this._mode = NodeMaterialModes.Particle;\n  }\n  /**\n   * Loads the current Node Material from a url pointing to a file save by the Node Material Editor\n   * @deprecated Please use NodeMaterial.ParseFromFileAsync instead\n   * @param url defines the url to load from\n   * @param rootUrl defines the root URL for nested url in the node material\n   * @returns a promise that will fulfil when the material is fully loaded\n   */\n  async loadAsync(url, rootUrl = \"\") {\n    return NodeMaterial.ParseFromFileAsync(\"\", url, this.getScene(), rootUrl, true, this);\n  }\n  _gatherBlocks(rootNode, list) {\n    if (list.indexOf(rootNode) !== -1) {\n      return;\n    }\n    list.push(rootNode);\n    for (const input of rootNode.inputs) {\n      const connectedPoint = input.connectedPoint;\n      if (connectedPoint) {\n        const block = connectedPoint.ownerBlock;\n        if (block !== rootNode) {\n          this._gatherBlocks(block, list);\n        }\n      }\n    }\n    // Teleportation\n    if (rootNode.isTeleportOut) {\n      const block = rootNode;\n      if (block.entryPoint) {\n        this._gatherBlocks(block.entryPoint, list);\n      }\n    }\n  }\n  /**\n   * Generate a string containing the code declaration required to create an equivalent of this material\n   * @returns a string\n   */\n  generateCode() {\n    let alreadyDumped = [];\n    const vertexBlocks = [];\n    const uniqueNames = [\"const\", \"var\", \"let\"];\n    // Gets active blocks\n    for (const outputNode of this._vertexOutputNodes) {\n      this._gatherBlocks(outputNode, vertexBlocks);\n    }\n    const fragmentBlocks = [];\n    for (const outputNode of this._fragmentOutputNodes) {\n      this._gatherBlocks(outputNode, fragmentBlocks);\n    }\n    // Generate vertex shader\n    let codeString = `var nodeMaterial = new BABYLON.NodeMaterial(\"${this.name || \"node material\"}\");\\n`;\n    codeString += `nodeMaterial.mode = BABYLON.NodeMaterialModes.${NodeMaterialModes[this.mode]};\\n`;\n    for (const node of vertexBlocks) {\n      if (node.isInput && alreadyDumped.indexOf(node) === -1) {\n        codeString += node._dumpCode(uniqueNames, alreadyDumped);\n      }\n    }\n    // Generate fragment shader\n    for (const node of fragmentBlocks) {\n      if (node.isInput && alreadyDumped.indexOf(node) === -1) {\n        codeString += node._dumpCode(uniqueNames, alreadyDumped);\n      }\n    }\n    // Connections\n    alreadyDumped = [];\n    codeString += \"\\n// Connections\\n\";\n    for (const node of this._vertexOutputNodes) {\n      codeString += node._dumpCodeForOutputConnections(alreadyDumped);\n    }\n    for (const node of this._fragmentOutputNodes) {\n      codeString += node._dumpCodeForOutputConnections(alreadyDumped);\n    }\n    // Output nodes\n    codeString += \"\\n// Output nodes\\n\";\n    for (const node of this._vertexOutputNodes) {\n      codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});\\n`;\n    }\n    for (const node of this._fragmentOutputNodes) {\n      codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});\\n`;\n    }\n    codeString += `nodeMaterial.build();\\n`;\n    return codeString;\n  }\n  /**\n   * Serializes this material in a JSON representation\n   * @param selectedBlocks\n   * @returns the serialized material object\n   */\n  serialize(selectedBlocks) {\n    const serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);\n    serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData)); // Copy\n    let blocks = [];\n    if (selectedBlocks) {\n      blocks = selectedBlocks;\n    } else {\n      serializationObject.customType = \"BABYLON.NodeMaterial\";\n      serializationObject.outputNodes = [];\n      // Outputs\n      for (const outputNode of this._vertexOutputNodes) {\n        this._gatherBlocks(outputNode, blocks);\n        serializationObject.outputNodes.push(outputNode.uniqueId);\n      }\n      for (const outputNode of this._fragmentOutputNodes) {\n        this._gatherBlocks(outputNode, blocks);\n        if (serializationObject.outputNodes.indexOf(outputNode.uniqueId) === -1) {\n          serializationObject.outputNodes.push(outputNode.uniqueId);\n        }\n      }\n    }\n    // Blocks\n    serializationObject.blocks = [];\n    for (const block of blocks) {\n      serializationObject.blocks.push(block.serialize());\n    }\n    if (!selectedBlocks) {\n      for (const block of this.attachedBlocks) {\n        if (blocks.indexOf(block) !== -1) {\n          continue;\n        }\n        serializationObject.blocks.push(block.serialize());\n      }\n    }\n    return serializationObject;\n  }\n  _restoreConnections(block, source, map) {\n    for (const outputPoint of block.outputs) {\n      for (const candidate of source.blocks) {\n        const target = map[candidate.id];\n        if (!target) {\n          continue;\n        }\n        for (const input of candidate.inputs) {\n          if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {\n            const inputPoint = target.getInputByName(input.inputName);\n            if (!inputPoint || inputPoint.isConnected) {\n              continue;\n            }\n            outputPoint.connectTo(inputPoint, true);\n            this._restoreConnections(target, source, map);\n            continue;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Clear the current graph and load a new one from a serialization object\n   * @param source defines the JSON representation of the material\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @param merge defines whether or not the source must be merged or replace the current content\n   */\n  parseSerializedObject(source, rootUrl = \"\", merge = false) {\n    var _a;\n    if (!merge) {\n      this.clear();\n    }\n    const map = {};\n    // Create blocks\n    for (const parsedBlock of source.blocks) {\n      const blockType = GetClass(parsedBlock.customType);\n      if (blockType) {\n        const block = new blockType();\n        block._deserialize(parsedBlock, this.getScene(), rootUrl);\n        map[parsedBlock.id] = block;\n        this.attachedBlocks.push(block);\n      }\n    }\n    // Reconnect teleportation\n    for (const block of this.attachedBlocks) {\n      if (block.isTeleportOut) {\n        const teleportOut = block;\n        const id = teleportOut._tempEntryPointUniqueId;\n        if (id) {\n          const source = map[id];\n          source.attachToEndpoint(teleportOut);\n        }\n      }\n    }\n    // Connections - Starts with input blocks only (except if in \"merge\" mode where we scan all blocks)\n    for (let blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {\n      const parsedBlock = source.blocks[blockIndex];\n      const block = map[parsedBlock.id];\n      if (!block) {\n        continue;\n      }\n      if (block.inputs.length && !merge) {\n        continue;\n      }\n      this._restoreConnections(block, source, map);\n    }\n    // Outputs\n    if (source.outputNodes) {\n      for (const outputNodeId of source.outputNodes) {\n        this.addOutputNode(map[outputNodeId]);\n      }\n    }\n    // UI related info\n    if (source.locations || source.editorData && source.editorData.locations) {\n      const locations = source.locations || source.editorData.locations;\n      for (const location of locations) {\n        if (map[location.blockId]) {\n          location.blockId = map[location.blockId].uniqueId;\n        }\n      }\n      if (merge && this.editorData && this.editorData.locations) {\n        locations.concat(this.editorData.locations);\n      }\n      if (source.locations) {\n        this.editorData = {\n          locations: locations\n        };\n      } else {\n        this.editorData = source.editorData;\n        this.editorData.locations = locations;\n      }\n      const blockMap = [];\n      for (const key in map) {\n        blockMap[key] = map[key].uniqueId;\n      }\n      this.editorData.map = blockMap;\n    }\n    this.comment = source.comment;\n    if (source.forceAlphaBlending !== undefined) {\n      this.forceAlphaBlending = source.forceAlphaBlending;\n    }\n    if (!merge) {\n      this._mode = (_a = source.mode) !== null && _a !== void 0 ? _a : NodeMaterialModes.Material;\n    }\n  }\n  /**\n   * Clear the current graph and load a new one from a serialization object\n   * @param source defines the JSON representation of the material\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @param merge defines whether or not the source must be merged or replace the current content\n   * @deprecated Please use the parseSerializedObject method instead\n   */\n  loadFromSerialization(source, rootUrl = \"\", merge = false) {\n    this.parseSerializedObject(source, rootUrl, merge);\n  }\n  /**\n   * Makes a duplicate of the current material.\n   * @param name defines the name to use for the new material\n   * @param shareEffect defines if the clone material should share the same effect (default is false)\n   */\n  clone(name, shareEffect = false) {\n    const serializationObject = this.serialize();\n    const clone = SerializationHelper.Clone(() => new NodeMaterial(name, this.getScene(), this.options), this);\n    clone.id = name;\n    clone.name = name;\n    clone.parseSerializedObject(serializationObject);\n    clone._buildId = this._buildId;\n    clone.build(false, !shareEffect);\n    return clone;\n  }\n  /**\n   * Awaits for all the material textures to be ready before resolving the returned promise.\n   */\n  whenTexturesReadyAsync() {\n    // Ensures all textures are ready to render.\n    const textureReadyPromises = [];\n    this.getActiveTextures().forEach(texture => {\n      const internalTexture = texture.getInternalTexture();\n      if (internalTexture && !internalTexture.isReady) {\n        textureReadyPromises.push(new Promise((textureResolve, textureReject) => {\n          internalTexture.onLoadedObservable.addOnce(() => {\n            textureResolve();\n          });\n          internalTexture.onErrorObservable.addOnce(e => {\n            textureReject(e);\n          });\n        }));\n      }\n    });\n    return Promise.all(textureReadyPromises);\n  }\n  /**\n   * Creates a node material from parsed material data\n   * @param source defines the JSON representation of the material\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a new node material\n   */\n  static Parse(source, scene, rootUrl = \"\") {\n    const nodeMaterial = SerializationHelper.Parse(() => new NodeMaterial(source.name, scene), source, scene, rootUrl);\n    nodeMaterial.parseSerializedObject(source, rootUrl);\n    nodeMaterial.build();\n    return nodeMaterial;\n  }\n  /**\n   * Creates a node material from a snippet saved in a remote file\n   * @param name defines the name of the material to create\n   * @param url defines the url to load from\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL for nested url in the node material\n   * @param skipBuild defines whether to build the node material\n   * @param targetMaterial defines a material to use instead of creating a new one\n   * @returns a promise that will resolve to the new node material\n   */\n  static async ParseFromFileAsync(name, url, scene, rootUrl = \"\", skipBuild = false, targetMaterial) {\n    const material = targetMaterial !== null && targetMaterial !== void 0 ? targetMaterial : new NodeMaterial(name, scene);\n    const data = await scene._loadFileAsync(url);\n    const serializationObject = JSON.parse(data);\n    material.parseSerializedObject(serializationObject, rootUrl);\n    if (!skipBuild) {\n      material.build();\n    }\n    return material;\n  }\n  /**\n   * Creates a node material from a snippet saved by the node material editor\n   * @param snippetId defines the snippet to load\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @param nodeMaterial defines a node material to update (instead of creating a new one)\n   * @param skipBuild defines whether to build the node material\n   * @param waitForTextureReadyness defines whether to wait for texture readiness resolving the promise (default: false)\n   * @returns a promise that will resolve to the new node material\n   */\n  static ParseFromSnippetAsync(snippetId, scene = EngineStore.LastCreatedScene, rootUrl = \"\", nodeMaterial, skipBuild = false, waitForTextureReadyness = false) {\n    if (snippetId === \"_BLANK\") {\n      return Promise.resolve(NodeMaterial.CreateDefault(\"blank\", scene));\n    }\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n            const serializationObject = JSON.parse(snippet.nodeMaterial);\n            if (!nodeMaterial) {\n              nodeMaterial = SerializationHelper.Parse(() => new NodeMaterial(snippetId, scene), serializationObject, scene, rootUrl);\n              nodeMaterial.uniqueId = scene.getUniqueId();\n            }\n            nodeMaterial.parseSerializedObject(serializationObject);\n            nodeMaterial.snippetId = snippetId;\n            try {\n              if (!skipBuild) {\n                nodeMaterial.build();\n              }\n            } catch (err) {\n              reject(err);\n            }\n            if (waitForTextureReadyness) {\n              nodeMaterial.whenTexturesReadyAsync().then(() => {\n                resolve(nodeMaterial);\n              }).catch(err => {\n                reject(err);\n              });\n            } else {\n              resolve(nodeMaterial);\n            }\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  }\n  /**\n   * Creates a new node material set to default basic configuration\n   * @param name defines the name of the material\n   * @param scene defines the hosting scene\n   * @returns a new NodeMaterial\n   */\n  static CreateDefault(name, scene) {\n    const newMaterial = new NodeMaterial(name, scene);\n    newMaterial.setToDefault();\n    newMaterial.build();\n    return newMaterial;\n  }\n}\nNodeMaterial._BuildIdGenerator = 0;\n/** Define the Url to load node editor script */\nNodeMaterial.EditorURL = `v${Engine.Version}/nodeEditor/babylon.nodeEditor.js`;\n/** Define the Url to load snippets */\nNodeMaterial.SnippetUrl = `https://snippet.babylonjs.com`;\n/** Gets or sets a boolean indicating that node materials should not deserialize textures from json / snippet content */\nNodeMaterial.IgnoreTexturesAtLoadTime = false;\n__decorate([serialize()], NodeMaterial.prototype, \"ignoreAlpha\", void 0);\n__decorate([serialize()], NodeMaterial.prototype, \"maxSimultaneousLights\", void 0);\n__decorate([serialize(\"mode\")], NodeMaterial.prototype, \"_mode\", void 0);\n__decorate([serialize(\"comment\")], NodeMaterial.prototype, \"comment\", void 0);\n__decorate([serialize()], NodeMaterial.prototype, \"forceAlphaBlending\", void 0);\nRegisterClass(\"BABYLON.NodeMaterial\", NodeMaterial);","map":{"version":3,"names":["PushMaterial","AbstractMesh","Matrix","Vector2","Color3","Color4","Engine","NodeMaterialBuildState","Effect","Observable","NodeMaterialBlockTargets","NodeMaterialBuildStateSharedData","MaterialDefines","VertexBuffer","Tools","TransformBlock","VertexOutputBlock","FragmentOutputBlock","InputBlock","GetClass","RegisterClass","serialize","SerializationHelper","CurrentScreenBlock","ParticleTextureBlock","ParticleRampGradientBlock","ParticleBlendMultiplyBlock","EffectFallbacks","WebRequest","PostProcess","VectorMergerBlock","RemapBlock","MultiplyBlock","NodeMaterialModes","Texture","BaseParticleSystem","ColorSplitterBlock","TimingTools","ProceduralTexture","AnimatedInputBlockTypes","TrigonometryBlock","TrigonometryBlockOperations","NodeMaterialSystemValues","EngineStore","MaterialHelper","onCreatedEffectParameters","effect","subMesh","NodeMaterialDefines","constructor","NORMAL","TANGENT","VERTEXCOLOR_NME","UV1","UV2","UV3","UV4","UV5","UV6","PREPASS","PREPASS_NORMAL","PREPASS_NORMAL_INDEX","PREPASS_POSITION","PREPASS_POSITION_INDEX","PREPASS_DEPTH","PREPASS_DEPTH_INDEX","SCENE_MRT_COUNT","NUM_BONE_INFLUENCERS","BonesPerMesh","BONETEXTURE","MORPHTARGETS","MORPHTARGETS_NORMAL","MORPHTARGETS_TANGENT","MORPHTARGETS_UV","NUM_MORPH_INFLUENCERS","MORPHTARGETS_TEXTURE","IMAGEPROCESSING","VIGNETTE","VIGNETTEBLENDMODEMULTIPLY","VIGNETTEBLENDMODEOPAQUE","TONEMAPPING","TONEMAPPING_ACES","CONTRAST","EXPOSURE","COLORCURVES","COLORGRADING","COLORGRADING3D","SAMPLER3DGREENDEPTH","SAMPLER3DBGRMAP","DITHER","IMAGEPROCESSINGPOSTPROCESS","SKIPFINALCOLORCLAMP","BUMPDIRECTUV","CAMERA_ORTHOGRAPHIC","CAMERA_PERSPECTIVE","rebuild","setValue","name","value","markAsUnprocessedIfDirty","undefined","_keys","push","markAsUnprocessed","NodeMaterial","_BlockIsTextureBlock","block","getClassName","_getGlobalNodeMaterialEditor","NODEEDITOR","BABYLON","NodeEditor","options","_options","imageProcessingConfiguration","_imageProcessingConfiguration","_attachImageProcessingConfiguration","_markAllSubMeshesAsTexturesDirty","mode","_mode","buildId","_buildId","scene","LastCreatedScene","_BuildIdGenerator","_buildWasSuccessful","_cachedWorldViewMatrix","_cachedWorldViewProjectionMatrix","_optimizers","Array","_animationFrame","BJSNODEMATERIALEDITOR","editorData","ignoreAlpha","maxSimultaneousLights","onBuildObservable","_vertexOutputNodes","_fragmentOutputNodes","attachedBlocks","Material","forceAlphaBlending","Object","assign","emitComments","configuration","_imageProcessingObserver","onUpdateParameters","remove","getScene","add","_markAllSubMeshesAsImageProcessingDirty","getBlockByName","result","Warn","getBlockByPredicate","predicate","getInputBlockByPredicate","isInput","getInputBlocks","blocks","registerOptimizer","optimizer","index","indexOf","unregisterOptimizer","splice","addOutputNode","node","target","Vertex","_addVertexOutputNode","Fragment","_addFragmentOutputNode","removeOutputNode","_removeVertexOutputNode","_removeFragmentOutputNode","needAlphaBlending","alpha","_sharedData","hints","needAlphaTesting","_processInitializeOnLink","state","nodesToProcessForOtherBuildState","autoConfigure","VertexAndFragment","_preparationId","_initializeBlock","initialize","isUnique","className","other","input","inputs","associatedVariableName","connectedPoint","ownerBlock","isTeleportOut","teleport","entryPoint","output","outputs","_resetDualBlocks","id","teleportOut","removeBlock","attachedBlockIndex","isFinalMerger","build","verbose","updateBuildId","_vertexCompilationState","engine","getEngine","allowEmptyVertexProgram","Particle","length","supportUniformBuffers","supportsUniformBuffers","_fragmentCompilationState","fragmentOutputNodes","sharedData","vertexNodes","fragmentNodes","vertexOutputNode","fragmentOutputNode","optimize","uniforms","slice","_uniformDeclaration","_constantDeclaration","_vertexState","finalize","emitErrors","console","log","compilationString","notifyObservers","meshes","mesh","subMeshes","getMaterial","materialDefines","defines","markAllAsDirty","reset","prePassTextureInputs","enablePrePassRenderer","prePassRenderer","markAsDirty","_prepareDefinesForAttributes","oldNormal","oldTangent","oldColor","isVerticesDataPresent","NormalKind","TangentKind","hasVertexColors","useVertexColors","ColorKind","uvChanged","i","oldUV","oit","needAlphaBlendingForMesh","useOrderIndependentTransparency","PrepareDefinesForPrePass","markAsAttributesDirty","isPrePassCapable","prePassTextureOutputs","prePassOutputBlock","viewDepth","isConnected","viewNormal","worldPosition","prePassTextureBlocks","getAllTextureBlocks","filter","position","includes","depth","normal","setPrePassRenderer","prePassTexturesRequired","concat","cfg","getEffectConfiguration","addEffectConfiguration","enabled","needsImageProcessing","texturesRequired","prePassTexture","createPostProcess","camera","samplingMode","reusable","textureType","textureFormat","_createEffectForPostProcess","createEffectForPostProcess","postProcess","tempName","dummyMesh","_processDefines","RegisterShader","_builtCompilationString","samplers","toString","updateEffect","nodeMaterialSource","onApplyObservable","ShadersStore","SetImmediate","_checkInternals","createProceduralTexture","size","proceduralTexture","reservedDataStore","hidden","createEffect","vertexElement","fragmentElement","PositionKind","fallbacks","_setEffect","onBeforeGenerationObservable","_createEffectForParticles","particleSystem","blendMode","onCompiled","onError","particleSystemDefinesJoined","getMeshByName","particleSystemDefines","join","fillDefines","createEffectForParticles","setCustomEffect","onBindObservable","particleSystemDefinesJoinedCurrent","animatedInputs","frameId","getFrameId","animate","bindableBlocks","bind","inputBlock","inputBlocks","_transmit","BLENDMODE_ONEONE","BLENDMODE_MULTIPLY","createAsShadowDepthWrapper","targetMaterial","shadowDepthWrapper","ShadowDepthWrapper","useInstances","PrepareDefinesForCamera","markAsMiscDirty","blocksWithDefines","forEach","b","initializeDefines","prepareDefines","isDirty","lightDisposed","_areLightsDisposed","markAsProcessed","repeatableContentBlocks","replaceRepeatableContent","uniformBuffers","dynamicUniformBlocks","updateUniformsAndSamples","mergedUniforms","u","mergedSamplers","s","blocksWithFallbacks","provideFallbacks","isReadyForSubMesh","isFrozen","_wasPreviouslyReady","_wasPreviouslyUsingInstances","_isReadyForSubMesh","blockingBlocks","some","isReady","previousEffect","vertex","fragment","vertexSource","fragmentSource","attributes","uniformsNames","uniformBuffersNames","multiTarget","indexParameters","maxSimultaneousMorphTargets","_onEffectCreatedObservable","allowShaderHotSwapping","resetCachedMaterial","setEffect","_materialContext","_renderId","getRenderId","_checkScenePerformancePriority","compiledShaders","bindOnlyWorldMatrix","world","_activeEffect","needWorldViewMatrix","multiplyToRef","getViewMatrix","needWorldViewProjectionMatrix","getTransformMatrix","_transmitWorld","bindForSubMesh","mustRebind","_mustRebind","visibility","forcedBindableBlocks","_afterBind","getActiveTextures","activeTextures","textureBlocks","tb","texture","map","getTextureBlocks","hasTexture","t","dispose","forceDisposeEffect","forceDisposeTextures","notBoundToMesh","clear","_createNodeEditor","additionalConfig","nodeEditorConfig","nodeMaterial","Show","edit","config","Promise","resolve","editorUrl","editorURL","EditorURL","LoadBabylonScript","setToDefault","positionInput","setAsAttribute","worldInput","setAsSystemValue","World","worldPos","connectTo","viewProjectionInput","ViewProjection","worldPosdMultipliedByViewProjection","vertexOutput","pixelColor","fragmentOutput","setToDefaultPostProcess","const1","isConstant","vmerger","scale","visibleInInspector","uv0","uv","currentScreen","setToDefaultProceduralTexture","time","min","max","isBoolean","matrixMode","animationType","Time","color","vectorMerger","cos","operation","Cos","z","xyzOut","rgb","setToDefaultParticle","multiply","rampGradient","cSplitter","blendMultiply","loadAsync","url","rootUrl","ParseFromFileAsync","_gatherBlocks","rootNode","list","generateCode","alreadyDumped","vertexBlocks","uniqueNames","outputNode","fragmentBlocks","codeString","_dumpCode","_dumpCodeForOutputConnections","_codeVariableName","selectedBlocks","serializationObject","Serialize","JSON","parse","stringify","customType","outputNodes","uniqueId","_restoreConnections","source","outputPoint","candidate","targetBlockId","targetConnectionName","inputPoint","getInputByName","inputName","parseSerializedObject","merge","parsedBlock","blockType","_deserialize","_tempEntryPointUniqueId","attachToEndpoint","blockIndex","outputNodeId","locations","location","blockId","blockMap","key","comment","_a","loadFromSerialization","clone","shareEffect","Clone","whenTexturesReadyAsync","textureReadyPromises","internalTexture","getInternalTexture","textureResolve","textureReject","onLoadedObservable","addOnce","onErrorObservable","e","all","Parse","skipBuild","material","data","_loadFileAsync","ParseFromSnippetAsync","snippetId","waitForTextureReadyness","CreateDefault","reject","request","addEventListener","readyState","status","snippet","responseText","jsonPayload","getUniqueId","err","then","catch","open","SnippetUrl","replace","send","newMaterial","Version","IgnoreTexturesAtLoadTime","__decorate"],"sources":["../../../../../dev/core/src/Materials/Node/nodeMaterial.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { NodeMaterialBlock } from \"./nodeMaterialBlock\";\r\nimport { PushMaterial } from \"../pushMaterial\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Matrix, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../../Maths/math.color\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { Engine } from \"../../Engines/engine\";\r\nimport { NodeMaterialBuildState } from \"./nodeMaterialBuildState\";\r\nimport type { IEffectCreationOptions } from \"../effect\";\r\nimport { Effect } from \"../effect\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets\";\r\nimport { NodeMaterialBuildStateSharedData } from \"./nodeMaterialBuildStateSharedData\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { MaterialDefines } from \"../../Materials/materialDefines\";\r\nimport type { NodeMaterialOptimizer } from \"./Optimizers/nodeMaterialOptimizer\";\r\nimport type { ImageProcessingConfiguration, IImageProcessingConfigurationDefines } from \"../imageProcessingConfiguration\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { TransformBlock } from \"./Blocks/transformBlock\";\r\nimport { VertexOutputBlock } from \"./Blocks/Vertex/vertexOutputBlock\";\r\nimport { FragmentOutputBlock } from \"./Blocks/Fragment/fragmentOutputBlock\";\r\nimport { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore\";\r\nimport { serialize, SerializationHelper } from \"../../Misc/decorators\";\r\nimport type { TextureBlock } from \"./Blocks/Dual/textureBlock\";\r\nimport type { ReflectionTextureBaseBlock } from \"./Blocks/Dual/reflectionTextureBaseBlock\";\r\nimport type { RefractionBlock } from \"./Blocks/PBR/refractionBlock\";\r\nimport { CurrentScreenBlock } from \"./Blocks/Dual/currentScreenBlock\";\r\nimport { ParticleTextureBlock } from \"./Blocks/Particle/particleTextureBlock\";\r\nimport { ParticleRampGradientBlock } from \"./Blocks/Particle/particleRampGradientBlock\";\r\nimport { ParticleBlendMultiplyBlock } from \"./Blocks/Particle/particleBlendMultiplyBlock\";\r\nimport { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { WebRequest } from \"../../Misc/webRequest\";\r\n\r\nimport type { PostProcessOptions } from \"../../PostProcesses/postProcess\";\r\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport { VectorMergerBlock } from \"./Blocks/vectorMergerBlock\";\r\nimport { RemapBlock } from \"./Blocks/remapBlock\";\r\nimport { MultiplyBlock } from \"./Blocks/multiplyBlock\";\r\nimport { NodeMaterialModes } from \"./Enums/nodeMaterialModes\";\r\nimport { Texture } from \"../Textures/texture\";\r\nimport type { IParticleSystem } from \"../../Particles/IParticleSystem\";\r\nimport { BaseParticleSystem } from \"../../Particles/baseParticleSystem\";\r\nimport { ColorSplitterBlock } from \"./Blocks/colorSplitterBlock\";\r\nimport { TimingTools } from \"../../Misc/timingTools\";\r\nimport { ProceduralTexture } from \"../Textures/Procedurals/proceduralTexture\";\r\nimport { AnimatedInputBlockTypes } from \"./Blocks/Input/animatedInputBlockTypes\";\r\nimport { TrigonometryBlock, TrigonometryBlockOperations } from \"./Blocks/trigonometryBlock\";\r\nimport { NodeMaterialSystemValues } from \"./Enums/nodeMaterialSystemValues\";\r\nimport type { ImageSourceBlock } from \"./Blocks/Dual/imageSourceBlock\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport type { Material } from \"../material\";\r\nimport { MaterialHelper } from \"../materialHelper\";\r\nimport type { TriPlanarBlock } from \"./Blocks/triPlanarBlock\";\r\nimport type { BiPlanarBlock } from \"./Blocks/biPlanarBlock\";\r\nimport type { PrePassRenderer } from \"../../Rendering/prePassRenderer\";\r\nimport type { PrePassTextureBlock } from \"./Blocks/Input/prePassTextureBlock\";\r\nimport type { PrePassOutputBlock } from \"./Blocks/Fragment/prePassOutputBlock\";\r\nimport type { NodeMaterialTeleportOutBlock } from \"./Blocks/Teleport/teleportOutBlock\";\r\nimport type { NodeMaterialTeleportInBlock } from \"./Blocks/Teleport/teleportInBlock\";\r\n\r\nconst onCreatedEffectParameters = { effect: null as unknown as Effect, subMesh: null as unknown as Nullable<SubMesh> };\r\n\r\n// declare NODEEDITOR namespace for compilation issue\r\ndeclare let NODEEDITOR: any;\r\ndeclare let BABYLON: any;\r\n\r\n/**\r\n * Interface used to configure the node material editor\r\n */\r\nexport interface INodeMaterialEditorOptions {\r\n    /** Define the URL to load node editor script from */\r\n    editorURL?: string;\r\n    /** Additional configuration for the NME */\r\n    nodeEditorConfig?: {\r\n        backgroundColor?: Color4;\r\n    };\r\n}\r\n\r\n/** @internal */\r\nexport class NodeMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines {\r\n    public NORMAL = false;\r\n    public TANGENT = false;\r\n    public VERTEXCOLOR_NME = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public UV3 = false;\r\n    public UV4 = false;\r\n    public UV5 = false;\r\n    public UV6 = false;\r\n\r\n    public PREPASS = false;\r\n    public PREPASS_NORMAL = false;\r\n    public PREPASS_NORMAL_INDEX = -1;\r\n    public PREPASS_POSITION = false;\r\n    public PREPASS_POSITION_INDEX = -1;\r\n    public PREPASS_DEPTH = false;\r\n    public PREPASS_DEPTH_INDEX = -1;\r\n    public SCENE_MRT_COUNT = 0;\r\n\r\n    /** BONES */\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public BONETEXTURE = false;\r\n\r\n    /** MORPH TARGETS */\r\n    public MORPHTARGETS = false;\r\n    public MORPHTARGETS_NORMAL = false;\r\n    public MORPHTARGETS_TANGENT = false;\r\n    public MORPHTARGETS_UV = false;\r\n    public NUM_MORPH_INFLUENCERS = 0;\r\n    public MORPHTARGETS_TEXTURE = false;\r\n\r\n    /** IMAGE PROCESSING */\r\n    public IMAGEPROCESSING = false;\r\n    public VIGNETTE = false;\r\n    public VIGNETTEBLENDMODEMULTIPLY = false;\r\n    public VIGNETTEBLENDMODEOPAQUE = false;\r\n    public TONEMAPPING = false;\r\n    public TONEMAPPING_ACES = false;\r\n    public CONTRAST = false;\r\n    public EXPOSURE = false;\r\n    public COLORCURVES = false;\r\n    public COLORGRADING = false;\r\n    public COLORGRADING3D = false;\r\n    public SAMPLER3DGREENDEPTH = false;\r\n    public SAMPLER3DBGRMAP = false;\r\n    public DITHER = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n\r\n    /** MISC. */\r\n    public BUMPDIRECTUV = 0;\r\n    public CAMERA_ORTHOGRAPHIC = false;\r\n    public CAMERA_PERSPECTIVE = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n\r\n    public setValue(name: string, value: any, markAsUnprocessedIfDirty = false) {\r\n        if (this[name] === undefined) {\r\n            this._keys.push(name);\r\n        }\r\n\r\n        if (markAsUnprocessedIfDirty && this[name] !== value) {\r\n            this.markAsUnprocessed();\r\n        }\r\n\r\n        this[name] = value;\r\n    }\r\n}\r\n\r\n/**\r\n * Class used to configure NodeMaterial\r\n */\r\nexport interface INodeMaterialOptions {\r\n    /**\r\n     * Defines if blocks should emit comments\r\n     */\r\n    emitComments: boolean;\r\n}\r\n\r\n/**\r\n * Blocks that manage a texture\r\n */\r\nexport type NodeMaterialTextureBlocks =\r\n    | TextureBlock\r\n    | ReflectionTextureBaseBlock\r\n    | RefractionBlock\r\n    | CurrentScreenBlock\r\n    | ParticleTextureBlock\r\n    | ImageSourceBlock\r\n    | TriPlanarBlock\r\n    | BiPlanarBlock\r\n    | PrePassTextureBlock;\r\n\r\n/**\r\n * Class used to create a node based material built by assembling shader blocks\r\n */\r\nexport class NodeMaterial extends PushMaterial {\r\n    private static _BuildIdGenerator: number = 0;\r\n    private _options: INodeMaterialOptions;\r\n    private _vertexCompilationState: NodeMaterialBuildState;\r\n    private _fragmentCompilationState: NodeMaterialBuildState;\r\n    private _sharedData: NodeMaterialBuildStateSharedData;\r\n    private _buildId: number = NodeMaterial._BuildIdGenerator++;\r\n    private _buildWasSuccessful = false;\r\n    private _cachedWorldViewMatrix = new Matrix();\r\n    private _cachedWorldViewProjectionMatrix = new Matrix();\r\n    private _optimizers = new Array<NodeMaterialOptimizer>();\r\n    private _animationFrame = -1;\r\n\r\n    /** Define the Url to load node editor script */\r\n    public static EditorURL = `v${Engine.Version}/nodeEditor/babylon.nodeEditor.js`;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Gets or sets a boolean indicating that node materials should not deserialize textures from json / snippet content */\r\n    public static IgnoreTexturesAtLoadTime = false;\r\n\r\n    /**\r\n     * Checks if a block is a texture block\r\n     * @param block The block to check\r\n     * @returns True if the block is a texture block\r\n     */\r\n    public static _BlockIsTextureBlock(block: NodeMaterialBlock): block is NodeMaterialTextureBlocks {\r\n        return (\r\n            block.getClassName() === \"TextureBlock\" ||\r\n            block.getClassName() === \"ReflectionTextureBaseBlock\" ||\r\n            block.getClassName() === \"RefractionBlock\" ||\r\n            block.getClassName() === \"CurrentScreenBlock\" ||\r\n            block.getClassName() === \"ParticleTextureBlock\" ||\r\n            block.getClassName() === \"ImageSourceBlock\" ||\r\n            block.getClassName() === \"TriPlanarBlock\" ||\r\n            block.getClassName() === \"BiPlanarBlock\" ||\r\n            block.getClassName() === \"PrePassTextureBlock\"\r\n        );\r\n    }\r\n\r\n    private BJSNODEMATERIALEDITOR = this._getGlobalNodeMaterialEditor();\r\n\r\n    /** Get the inspector from bundle or global */\r\n    private _getGlobalNodeMaterialEditor(): any {\r\n        // UMD Global name detection from Webpack Bundle UMD Name.\r\n        if (typeof NODEEDITOR !== \"undefined\") {\r\n            return NODEEDITOR;\r\n        }\r\n\r\n        // In case of module let's check the global emitted from the editor entry point.\r\n        if (typeof BABYLON !== \"undefined\" && typeof BABYLON.NodeEditor !== \"undefined\") {\r\n            return BABYLON;\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Snippet ID if the material was created from the snippet server\r\n     */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Gets or sets data used by visual editor\r\n     * @see https://nme.babylonjs.com\r\n     */\r\n    public editorData: any = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that alpha value must be ignored (This will turn alpha blending off even if an alpha value is produced by the material)\r\n     */\r\n    @serialize()\r\n    public ignoreAlpha = false;\r\n\r\n    /**\r\n     * Defines the maximum number of lights that can be used in the material\r\n     */\r\n    @serialize()\r\n    public maxSimultaneousLights = 4;\r\n\r\n    /**\r\n     * Observable raised when the material is built\r\n     */\r\n    public onBuildObservable = new Observable<NodeMaterial>();\r\n\r\n    /**\r\n     * Gets or sets the root nodes of the material vertex shader\r\n     */\r\n    public _vertexOutputNodes = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * Gets or sets the root nodes of the material fragment (pixel) shader\r\n     */\r\n    public _fragmentOutputNodes = new Array<NodeMaterialBlock>();\r\n\r\n    /** Gets or sets options to control the node material overall behavior */\r\n    public get options() {\r\n        return this._options;\r\n    }\r\n\r\n    public set options(options: INodeMaterialOptions) {\r\n        this._options = options;\r\n    }\r\n\r\n    /**\r\n     * Default configuration related to image processing available in the standard Material.\r\n     */\r\n    protected _imageProcessingConfiguration: ImageProcessingConfiguration;\r\n\r\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\r\n    public get imageProcessingConfiguration(): ImageProcessingConfiguration {\r\n        return this._imageProcessingConfiguration;\r\n    }\r\n\r\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\r\n    public set imageProcessingConfiguration(value: ImageProcessingConfiguration) {\r\n        this._attachImageProcessingConfiguration(value);\r\n\r\n        // Ensure the effect will be rebuilt.\r\n        this._markAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets an array of blocks that needs to be serialized even if they are not yet connected\r\n     */\r\n    public attachedBlocks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * Specifies the mode of the node material\r\n     * @internal\r\n     */\r\n    @serialize(\"mode\")\r\n    public _mode: NodeMaterialModes = NodeMaterialModes.Material;\r\n\r\n    /**\r\n     * Gets or sets the mode property\r\n     */\r\n    public get mode(): NodeMaterialModes {\r\n        return this._mode;\r\n    }\r\n\r\n    public set mode(value: NodeMaterialModes) {\r\n        this._mode = value;\r\n    }\r\n\r\n    /** Gets or sets the unique identifier used to identified the effect associated with the material */\r\n    public get buildId() {\r\n        return this._buildId;\r\n    }\r\n\r\n    public set buildId(value: number) {\r\n        this._buildId = value;\r\n    }\r\n\r\n    /**\r\n     * A free comment about the material\r\n     */\r\n    @serialize(\"comment\")\r\n    public comment: string;\r\n\r\n    /**\r\n     * Create a new node based material\r\n     * @param name defines the material name\r\n     * @param scene defines the hosting scene\r\n     * @param options defines creation option\r\n     */\r\n    constructor(name: string, scene?: Scene, options: Partial<INodeMaterialOptions> = {}) {\r\n        super(name, scene || EngineStore.LastCreatedScene!);\r\n\r\n        this._options = {\r\n            emitComments: false,\r\n            ...options,\r\n        };\r\n\r\n        // Setup the default processing configuration to the scene.\r\n        this._attachImageProcessingConfiguration(null);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"NodeMaterial\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"NodeMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Keep track of the image processing observer to allow dispose and replace.\r\n     */\r\n    private _imageProcessingObserver: Nullable<Observer<ImageProcessingConfiguration>>;\r\n\r\n    /**\r\n     * Attaches a new image processing configuration to the Standard Material.\r\n     * @param configuration\r\n     */\r\n    protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void {\r\n        if (configuration === this._imageProcessingConfiguration) {\r\n            return;\r\n        }\r\n\r\n        // Detaches observer.\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        // Pick the scene configuration if needed.\r\n        if (!configuration) {\r\n            this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\r\n        } else {\r\n            this._imageProcessingConfiguration = configuration;\r\n        }\r\n\r\n        // Attaches observer.\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\r\n                this._markAllSubMeshesAsImageProcessingDirty();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get a block by its name\r\n     * @param name defines the name of the block to retrieve\r\n     * @returns the required block or null if not found\r\n     */\r\n    public getBlockByName(name: string) {\r\n        let result = null;\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.name === name) {\r\n                if (!result) {\r\n                    result = block;\r\n                } else {\r\n                    Tools.Warn(\"More than one block was found with the name `\" + name + \"`\");\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get a block by its name\r\n     * @param predicate defines the predicate used to find the good candidate\r\n     * @returns the required block or null if not found\r\n     */\r\n    public getBlockByPredicate(predicate: (block: NodeMaterialBlock) => boolean) {\r\n        for (const block of this.attachedBlocks) {\r\n            if (predicate(block)) {\r\n                return block;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get an input block by its name\r\n     * @param predicate defines the predicate used to find the good candidate\r\n     * @returns the required input block or null if not found\r\n     */\r\n    public getInputBlockByPredicate(predicate: (block: InputBlock) => boolean): Nullable<InputBlock> {\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.isInput && predicate(block as InputBlock)) {\r\n                return block as InputBlock;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of input blocks attached to this material\r\n     * @returns an array of InputBlocks\r\n     */\r\n    public getInputBlocks() {\r\n        const blocks: InputBlock[] = [];\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.isInput) {\r\n                blocks.push(block as InputBlock);\r\n            }\r\n        }\r\n\r\n        return blocks;\r\n    }\r\n\r\n    /**\r\n     * Adds a new optimizer to the list of optimizers\r\n     * @param optimizer defines the optimizers to add\r\n     * @returns the current material\r\n     */\r\n    public registerOptimizer(optimizer: NodeMaterialOptimizer) {\r\n        const index = this._optimizers.indexOf(optimizer);\r\n\r\n        if (index > -1) {\r\n            return;\r\n        }\r\n\r\n        this._optimizers.push(optimizer);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove an optimizer from the list of optimizers\r\n     * @param optimizer defines the optimizers to remove\r\n     * @returns the current material\r\n     */\r\n    public unregisterOptimizer(optimizer: NodeMaterialOptimizer) {\r\n        const index = this._optimizers.indexOf(optimizer);\r\n\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._optimizers.splice(index, 1);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a new block to the list of output nodes\r\n     * @param node defines the node to add\r\n     * @returns the current material\r\n     */\r\n    public addOutputNode(node: NodeMaterialBlock) {\r\n        if (node.target === null) {\r\n            throw \"This node is not meant to be an output node. You may want to explicitly set its target value.\";\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\r\n            this._addVertexOutputNode(node);\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\r\n            this._addFragmentOutputNode(node);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a block from the list of root nodes\r\n     * @param node defines the node to remove\r\n     * @returns the current material\r\n     */\r\n    public removeOutputNode(node: NodeMaterialBlock) {\r\n        if (node.target === null) {\r\n            return this;\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\r\n            this._removeVertexOutputNode(node);\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\r\n            this._removeFragmentOutputNode(node);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private _addVertexOutputNode(node: NodeMaterialBlock) {\r\n        if (this._vertexOutputNodes.indexOf(node) !== -1) {\r\n            return;\r\n        }\r\n\r\n        node.target = NodeMaterialBlockTargets.Vertex;\r\n        this._vertexOutputNodes.push(node);\r\n\r\n        return this;\r\n    }\r\n\r\n    private _removeVertexOutputNode(node: NodeMaterialBlock) {\r\n        const index = this._vertexOutputNodes.indexOf(node);\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._vertexOutputNodes.splice(index, 1);\r\n\r\n        return this;\r\n    }\r\n\r\n    private _addFragmentOutputNode(node: NodeMaterialBlock) {\r\n        if (this._fragmentOutputNodes.indexOf(node) !== -1) {\r\n            return;\r\n        }\r\n\r\n        node.target = NodeMaterialBlockTargets.Fragment;\r\n        this._fragmentOutputNodes.push(node);\r\n\r\n        return this;\r\n    }\r\n\r\n    private _removeFragmentOutputNode(node: NodeMaterialBlock) {\r\n        const index = this._fragmentOutputNodes.indexOf(node);\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._fragmentOutputNodes.splice(index, 1);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that alpha blending must be enabled no matter what alpha value or alpha channel of the FragmentBlock are\r\n     */\r\n    @serialize()\r\n    public forceAlphaBlending = false;\r\n\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        if (this.ignoreAlpha) {\r\n            return false;\r\n        }\r\n        return this.forceAlphaBlending || this.alpha < 1.0 || (this._sharedData && this._sharedData.hints.needAlphaBlending);\r\n    }\r\n\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        return this._sharedData && this._sharedData.hints.needAlphaTesting;\r\n    }\r\n\r\n    private _processInitializeOnLink(block: NodeMaterialBlock, state: NodeMaterialBuildState, nodesToProcessForOtherBuildState: NodeMaterialBlock[], autoConfigure = true) {\r\n        if (block.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n            nodesToProcessForOtherBuildState.push(block);\r\n        } else if (state.target === NodeMaterialBlockTargets.Fragment && block.target === NodeMaterialBlockTargets.Vertex && block._preparationId !== this._buildId) {\r\n            nodesToProcessForOtherBuildState.push(block);\r\n        }\r\n        this._initializeBlock(block, state, nodesToProcessForOtherBuildState, autoConfigure);\r\n    }\r\n\r\n    private _initializeBlock(node: NodeMaterialBlock, state: NodeMaterialBuildState, nodesToProcessForOtherBuildState: NodeMaterialBlock[], autoConfigure = true) {\r\n        node.initialize(state);\r\n        if (autoConfigure) {\r\n            node.autoConfigure(this);\r\n        }\r\n        node._preparationId = this._buildId;\r\n\r\n        if (this.attachedBlocks.indexOf(node) === -1) {\r\n            if (node.isUnique) {\r\n                const className = node.getClassName();\r\n\r\n                for (const other of this.attachedBlocks) {\r\n                    if (other.getClassName() === className) {\r\n                        throw `Cannot have multiple blocks of type ${className} in the same NodeMaterial`;\r\n                    }\r\n                }\r\n            }\r\n            this.attachedBlocks.push(node);\r\n        }\r\n\r\n        for (const input of node.inputs) {\r\n            input.associatedVariableName = \"\";\r\n\r\n            const connectedPoint = input.connectedPoint;\r\n            if (connectedPoint) {\r\n                const block = connectedPoint.ownerBlock;\r\n                if (block !== node) {\r\n                    this._processInitializeOnLink(block, state, nodesToProcessForOtherBuildState, autoConfigure);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Teleportation\r\n        if (node.isTeleportOut) {\r\n            const teleport = node as NodeMaterialTeleportOutBlock;\r\n            if (teleport.entryPoint) {\r\n                this._processInitializeOnLink(teleport.entryPoint, state, nodesToProcessForOtherBuildState, autoConfigure);\r\n            }\r\n        }\r\n\r\n        for (const output of node.outputs) {\r\n            output.associatedVariableName = \"\";\r\n        }\r\n    }\r\n\r\n    private _resetDualBlocks(node: NodeMaterialBlock, id: number) {\r\n        if (node.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n            node.buildId = id;\r\n        }\r\n\r\n        for (const inputs of node.inputs) {\r\n            const connectedPoint = inputs.connectedPoint;\r\n            if (connectedPoint) {\r\n                const block = connectedPoint.ownerBlock;\r\n                if (block !== node) {\r\n                    this._resetDualBlocks(block, id);\r\n                }\r\n            }\r\n        }\r\n\r\n        // If this is a teleport out, we need to reset the connected block\r\n        if (node.isTeleportOut) {\r\n            const teleportOut = node as NodeMaterialTeleportOutBlock;\r\n            if (teleportOut.entryPoint) {\r\n                this._resetDualBlocks(teleportOut.entryPoint, id);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a block from the current node material\r\n     * @param block defines the block to remove\r\n     */\r\n    public removeBlock(block: NodeMaterialBlock) {\r\n        const attachedBlockIndex = this.attachedBlocks.indexOf(block);\r\n        if (attachedBlockIndex > -1) {\r\n            this.attachedBlocks.splice(attachedBlockIndex, 1);\r\n        }\r\n\r\n        if (block.isFinalMerger) {\r\n            this.removeOutputNode(block);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Build the material and generates the inner effect\r\n     * @param verbose defines if the build should log activity\r\n     * @param updateBuildId defines if the internal build Id should be updated (default is true)\r\n     * @param autoConfigure defines if the autoConfigure method should be called when initializing blocks (default is false)\r\n     */\r\n    public build(verbose: boolean = false, updateBuildId = true, autoConfigure = false) {\r\n        // First time?\r\n        if (!this._vertexCompilationState && !autoConfigure) {\r\n            autoConfigure = true;\r\n        }\r\n\r\n        this._buildWasSuccessful = false;\r\n        const engine = this.getScene().getEngine();\r\n\r\n        const allowEmptyVertexProgram = this._mode === NodeMaterialModes.Particle;\r\n\r\n        if (this._vertexOutputNodes.length === 0 && !allowEmptyVertexProgram) {\r\n            throw \"You must define at least one vertexOutputNode\";\r\n        }\r\n\r\n        if (this._fragmentOutputNodes.length === 0) {\r\n            throw \"You must define at least one fragmentOutputNode\";\r\n        }\r\n\r\n        // Compilation state\r\n        this._vertexCompilationState = new NodeMaterialBuildState();\r\n        this._vertexCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\r\n        this._vertexCompilationState.target = NodeMaterialBlockTargets.Vertex;\r\n        this._fragmentCompilationState = new NodeMaterialBuildState();\r\n        this._fragmentCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\r\n        this._fragmentCompilationState.target = NodeMaterialBlockTargets.Fragment;\r\n\r\n        // Shared data\r\n        this._sharedData = new NodeMaterialBuildStateSharedData();\r\n        this._sharedData.fragmentOutputNodes = this._fragmentOutputNodes;\r\n        this._vertexCompilationState.sharedData = this._sharedData;\r\n        this._fragmentCompilationState.sharedData = this._sharedData;\r\n        this._sharedData.buildId = this._buildId;\r\n        this._sharedData.emitComments = this._options.emitComments;\r\n        this._sharedData.verbose = verbose;\r\n        this._sharedData.scene = this.getScene();\r\n        this._sharedData.allowEmptyVertexProgram = allowEmptyVertexProgram;\r\n\r\n        // Initialize blocks\r\n        const vertexNodes: NodeMaterialBlock[] = [];\r\n        const fragmentNodes: NodeMaterialBlock[] = [];\r\n\r\n        for (const vertexOutputNode of this._vertexOutputNodes) {\r\n            vertexNodes.push(vertexOutputNode);\r\n            this._initializeBlock(vertexOutputNode, this._vertexCompilationState, fragmentNodes, autoConfigure);\r\n        }\r\n\r\n        for (const fragmentOutputNode of this._fragmentOutputNodes) {\r\n            fragmentNodes.push(fragmentOutputNode);\r\n            this._initializeBlock(fragmentOutputNode, this._fragmentCompilationState, vertexNodes, autoConfigure);\r\n        }\r\n\r\n        // Optimize\r\n        this.optimize();\r\n\r\n        // Vertex\r\n        for (const vertexOutputNode of vertexNodes) {\r\n            vertexOutputNode.build(this._vertexCompilationState, vertexNodes);\r\n        }\r\n\r\n        // Fragment\r\n        this._fragmentCompilationState.uniforms = this._vertexCompilationState.uniforms.slice(0);\r\n        this._fragmentCompilationState._uniformDeclaration = this._vertexCompilationState._uniformDeclaration;\r\n        this._fragmentCompilationState._constantDeclaration = this._vertexCompilationState._constantDeclaration;\r\n        this._fragmentCompilationState._vertexState = this._vertexCompilationState;\r\n\r\n        for (const fragmentOutputNode of fragmentNodes) {\r\n            this._resetDualBlocks(fragmentOutputNode, this._buildId - 1);\r\n        }\r\n\r\n        for (const fragmentOutputNode of fragmentNodes) {\r\n            fragmentOutputNode.build(this._fragmentCompilationState, fragmentNodes);\r\n        }\r\n\r\n        // Finalize\r\n        this._vertexCompilationState.finalize(this._vertexCompilationState);\r\n        this._fragmentCompilationState.finalize(this._fragmentCompilationState);\r\n\r\n        if (updateBuildId) {\r\n            this._buildId = NodeMaterial._BuildIdGenerator++;\r\n        }\r\n\r\n        // Errors\r\n        this._sharedData.emitErrors();\r\n\r\n        if (verbose) {\r\n            console.log(\"Vertex shader:\");\r\n            console.log(this._vertexCompilationState.compilationString);\r\n            console.log(\"Fragment shader:\");\r\n            console.log(this._fragmentCompilationState.compilationString);\r\n        }\r\n\r\n        this._buildWasSuccessful = true;\r\n        this.onBuildObservable.notifyObservers(this);\r\n\r\n        // Wipe defines\r\n        const meshes = this.getScene().meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (subMesh.getMaterial() !== this) {\r\n                    continue;\r\n                }\r\n\r\n                if (!subMesh.materialDefines) {\r\n                    continue;\r\n                }\r\n\r\n                const defines = subMesh.materialDefines;\r\n                defines.markAllAsDirty();\r\n                defines.reset();\r\n            }\r\n        }\r\n\r\n        if (this.prePassTextureInputs.length) {\r\n            this.getScene().enablePrePassRenderer();\r\n        }\r\n        const prePassRenderer = this.getScene().prePassRenderer;\r\n        if (prePassRenderer) {\r\n            prePassRenderer.markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Runs an otpimization phase to try to improve the shader code\r\n     */\r\n    public optimize() {\r\n        for (const optimizer of this._optimizers) {\r\n            optimizer.optimize(this._vertexOutputNodes, this._fragmentOutputNodes);\r\n        }\r\n    }\r\n\r\n    private _prepareDefinesForAttributes(mesh: AbstractMesh, defines: NodeMaterialDefines) {\r\n        const oldNormal = defines[\"NORMAL\"];\r\n        const oldTangent = defines[\"TANGENT\"];\r\n        const oldColor = defines[\"VERTEXCOLOR_NME\"];\r\n\r\n        defines[\"NORMAL\"] = mesh.isVerticesDataPresent(VertexBuffer.NormalKind);\r\n        defines[\"TANGENT\"] = mesh.isVerticesDataPresent(VertexBuffer.TangentKind);\r\n\r\n        const hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);\r\n        defines[\"VERTEXCOLOR_NME\"] = hasVertexColors;\r\n\r\n        let uvChanged = false;\r\n        for (let i = 1; i <= Constants.MAX_SUPPORTED_UV_SETS; ++i) {\r\n            const oldUV = defines[\"UV\" + i];\r\n            defines[\"UV\" + i] = mesh.isVerticesDataPresent(`uv${i === 1 ? \"\" : i}`);\r\n            uvChanged = uvChanged || defines[\"UV\" + i] !== oldUV;\r\n        }\r\n\r\n        // PrePass\r\n        const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;\r\n        MaterialHelper.PrepareDefinesForPrePass(this.getScene(), defines, !oit);\r\n\r\n        if (oldNormal !== defines[\"NORMAL\"] || oldTangent !== defines[\"TANGENT\"] || oldColor !== defines[\"VERTEXCOLOR_NME\"] || uvChanged) {\r\n            defines.markAsAttributesDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Can this material render to prepass\r\n     */\r\n    public get isPrePassCapable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Outputs written to the prepass\r\n     */\r\n    public get prePassTextureOutputs(): number[] {\r\n        const prePassOutputBlock = this.getBlockByPredicate((block) => block.getClassName() === \"PrePassOutputBlock\") as PrePassOutputBlock;\r\n        const result = [Constants.PREPASS_COLOR_TEXTURE_TYPE];\r\n        if (!prePassOutputBlock) {\r\n            return result;\r\n        }\r\n        // Cannot write to prepass if we alread read from prepass\r\n        if (this.prePassTextureInputs.length) {\r\n            return result;\r\n        }\r\n\r\n        if (prePassOutputBlock.viewDepth.isConnected) {\r\n            result.push(Constants.PREPASS_DEPTH_TEXTURE_TYPE);\r\n        }\r\n\r\n        if (prePassOutputBlock.viewNormal.isConnected) {\r\n            result.push(Constants.PREPASS_NORMAL_TEXTURE_TYPE);\r\n        }\r\n\r\n        if (prePassOutputBlock.worldPosition.isConnected) {\r\n            result.push(Constants.PREPASS_POSITION_TEXTURE_TYPE);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of prepass texture required\r\n     */\r\n    public get prePassTextureInputs(): number[] {\r\n        const prePassTextureBlocks = this.getAllTextureBlocks().filter((block) => block.getClassName() === \"PrePassTextureBlock\") as PrePassTextureBlock[];\r\n        const result = [] as number[];\r\n\r\n        for (const block of prePassTextureBlocks) {\r\n            if (block.position.isConnected && !result.includes(Constants.PREPASS_POSITION_TEXTURE_TYPE)) {\r\n                result.push(Constants.PREPASS_POSITION_TEXTURE_TYPE);\r\n            }\r\n            if (block.depth.isConnected && !result.includes(Constants.PREPASS_DEPTH_TEXTURE_TYPE)) {\r\n                result.push(Constants.PREPASS_DEPTH_TEXTURE_TYPE);\r\n            }\r\n            if (block.normal.isConnected && !result.includes(Constants.PREPASS_NORMAL_TEXTURE_TYPE)) {\r\n                result.push(Constants.PREPASS_NORMAL_TEXTURE_TYPE);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the required values to the prepass renderer.\r\n     */\r\n    public setPrePassRenderer(prePassRenderer: PrePassRenderer): boolean {\r\n        const prePassTexturesRequired = this.prePassTextureInputs.concat(this.prePassTextureOutputs);\r\n\r\n        if (prePassRenderer && prePassTexturesRequired.length > 1) {\r\n            let cfg = prePassRenderer.getEffectConfiguration(\"nodeMaterial\");\r\n            if (!cfg) {\r\n                cfg = prePassRenderer.addEffectConfiguration({\r\n                    enabled: true,\r\n                    needsImageProcessing: false,\r\n                    name: \"nodeMaterial\",\r\n                    texturesRequired: [],\r\n                });\r\n            }\r\n            for (const prePassTexture of prePassTexturesRequired) {\r\n                if (!cfg.texturesRequired.includes(prePassTexture)) {\r\n                    cfg.texturesRequired.push(prePassTexture);\r\n                }\r\n            }\r\n            cfg.enabled = true;\r\n        }\r\n\r\n        // COLOR_TEXTURE is always required for prepass, length > 1 means\r\n        // we actually need to write to special prepass textures\r\n        return prePassTexturesRequired.length > 1;\r\n    }\r\n\r\n    /**\r\n     * Create a post process from the material\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\r\n     * @returns the post process created\r\n     */\r\n    public createPostProcess(\r\n        camera: Nullable<Camera>,\r\n        options: number | PostProcessOptions = 1,\r\n        samplingMode: number = Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        textureFormat = Constants.TEXTUREFORMAT_RGBA\r\n    ): Nullable<PostProcess> {\r\n        if (this.mode !== NodeMaterialModes.PostProcess) {\r\n            console.log(\"Incompatible material mode\");\r\n            return null;\r\n        }\r\n        return this._createEffectForPostProcess(null, camera, options, samplingMode, engine, reusable, textureType, textureFormat);\r\n    }\r\n\r\n    /**\r\n     * Create the post process effect from the material\r\n     * @param postProcess The post process to create the effect for\r\n     */\r\n    public createEffectForPostProcess(postProcess: PostProcess) {\r\n        this._createEffectForPostProcess(postProcess);\r\n    }\r\n\r\n    private _createEffectForPostProcess(\r\n        postProcess: Nullable<PostProcess>,\r\n        camera?: Nullable<Camera>,\r\n        options: number | PostProcessOptions = 1,\r\n        samplingMode: number = Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        textureFormat = Constants.TEXTUREFORMAT_RGBA\r\n    ): PostProcess {\r\n        let tempName = this.name + this._buildId;\r\n\r\n        const defines = new NodeMaterialDefines();\r\n\r\n        const dummyMesh = new AbstractMesh(tempName + \"PostProcess\", this.getScene());\r\n\r\n        let buildId = this._buildId;\r\n\r\n        this._processDefines(dummyMesh, defines);\r\n\r\n        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\r\n\r\n        if (!postProcess) {\r\n            postProcess = new PostProcess(\r\n                this.name + \"PostProcess\",\r\n                tempName,\r\n                this._fragmentCompilationState.uniforms,\r\n                this._fragmentCompilationState.samplers,\r\n                options,\r\n                camera!,\r\n                samplingMode,\r\n                engine,\r\n                reusable,\r\n                defines.toString(),\r\n                textureType,\r\n                tempName,\r\n                { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                false,\r\n                textureFormat\r\n            );\r\n        } else {\r\n            postProcess.updateEffect(\r\n                defines.toString(),\r\n                this._fragmentCompilationState.uniforms,\r\n                this._fragmentCompilationState.samplers,\r\n                { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                undefined,\r\n                undefined,\r\n                tempName,\r\n                tempName\r\n            );\r\n        }\r\n\r\n        postProcess.nodeMaterialSource = this;\r\n\r\n        postProcess.onApplyObservable.add((effect) => {\r\n            if (buildId !== this._buildId) {\r\n                delete Effect.ShadersStore[tempName + \"VertexShader\"];\r\n                delete Effect.ShadersStore[tempName + \"PixelShader\"];\r\n\r\n                tempName = this.name + this._buildId;\r\n\r\n                defines.markAllAsDirty();\r\n\r\n                buildId = this._buildId;\r\n            }\r\n\r\n            const result = this._processDefines(dummyMesh, defines);\r\n\r\n            if (result) {\r\n                Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\r\n\r\n                TimingTools.SetImmediate(() =>\r\n                    postProcess!.updateEffect(\r\n                        defines.toString(),\r\n                        this._fragmentCompilationState.uniforms,\r\n                        this._fragmentCompilationState.samplers,\r\n                        { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                        undefined,\r\n                        undefined,\r\n                        tempName,\r\n                        tempName\r\n                    )\r\n                );\r\n            }\r\n\r\n            this._checkInternals(effect);\r\n        });\r\n\r\n        return postProcess;\r\n    }\r\n\r\n    /**\r\n     * Create a new procedural texture based on this node material\r\n     * @param size defines the size of the texture\r\n     * @param scene defines the hosting scene\r\n     * @returns the new procedural texture attached to this node material\r\n     */\r\n    public createProceduralTexture(size: number | { width: number; height: number; layers?: number }, scene: Scene): Nullable<ProceduralTexture> {\r\n        if (this.mode !== NodeMaterialModes.ProceduralTexture) {\r\n            console.log(\"Incompatible material mode\");\r\n            return null;\r\n        }\r\n\r\n        let tempName = this.name + this._buildId;\r\n\r\n        const proceduralTexture = new ProceduralTexture(tempName, size, null, scene);\r\n\r\n        const dummyMesh = new AbstractMesh(tempName + \"Procedural\", this.getScene());\r\n        dummyMesh.reservedDataStore = {\r\n            hidden: true,\r\n        };\r\n\r\n        const defines = new NodeMaterialDefines();\r\n        const result = this._processDefines(dummyMesh, defines);\r\n        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\r\n\r\n        let effect = this.getScene().getEngine().createEffect(\r\n            {\r\n                vertexElement: tempName,\r\n                fragmentElement: tempName,\r\n            },\r\n            [VertexBuffer.PositionKind],\r\n            this._fragmentCompilationState.uniforms,\r\n            this._fragmentCompilationState.samplers,\r\n            defines.toString(),\r\n            result?.fallbacks,\r\n            undefined\r\n        );\r\n\r\n        proceduralTexture.nodeMaterialSource = this;\r\n        proceduralTexture._setEffect(effect);\r\n\r\n        let buildId = this._buildId;\r\n        proceduralTexture.onBeforeGenerationObservable.add(() => {\r\n            if (buildId !== this._buildId) {\r\n                delete Effect.ShadersStore[tempName + \"VertexShader\"];\r\n                delete Effect.ShadersStore[tempName + \"PixelShader\"];\r\n\r\n                tempName = this.name + this._buildId;\r\n\r\n                defines.markAllAsDirty();\r\n\r\n                buildId = this._buildId;\r\n            }\r\n\r\n            const result = this._processDefines(dummyMesh, defines);\r\n\r\n            if (result) {\r\n                Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\r\n\r\n                TimingTools.SetImmediate(() => {\r\n                    effect = this.getScene().getEngine().createEffect(\r\n                        {\r\n                            vertexElement: tempName,\r\n                            fragmentElement: tempName,\r\n                        },\r\n                        [VertexBuffer.PositionKind],\r\n                        this._fragmentCompilationState.uniforms,\r\n                        this._fragmentCompilationState.samplers,\r\n                        defines.toString(),\r\n                        result?.fallbacks,\r\n                        undefined\r\n                    );\r\n\r\n                    proceduralTexture._setEffect(effect);\r\n                });\r\n            }\r\n\r\n            this._checkInternals(effect);\r\n        });\r\n\r\n        return proceduralTexture;\r\n    }\r\n\r\n    private _createEffectForParticles(\r\n        particleSystem: IParticleSystem,\r\n        blendMode: number,\r\n        onCompiled?: (effect: Effect) => void,\r\n        onError?: (effect: Effect, errors: string) => void,\r\n        effect?: Effect,\r\n        defines?: NodeMaterialDefines,\r\n        dummyMesh?: Nullable<AbstractMesh>,\r\n        particleSystemDefinesJoined = \"\"\r\n    ) {\r\n        let tempName = this.name + this._buildId + \"_\" + blendMode;\r\n\r\n        if (!defines) {\r\n            defines = new NodeMaterialDefines();\r\n        }\r\n\r\n        if (!dummyMesh) {\r\n            dummyMesh = this.getScene().getMeshByName(this.name + \"Particle\");\r\n            if (!dummyMesh) {\r\n                dummyMesh = new AbstractMesh(this.name + \"Particle\", this.getScene());\r\n                dummyMesh.reservedDataStore = {\r\n                    hidden: true,\r\n                };\r\n            }\r\n        }\r\n\r\n        let buildId = this._buildId;\r\n\r\n        const particleSystemDefines: Array<string> = [];\r\n        let join = particleSystemDefinesJoined;\r\n\r\n        if (!effect) {\r\n            const result = this._processDefines(dummyMesh, defines);\r\n\r\n            Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString);\r\n\r\n            particleSystem.fillDefines(particleSystemDefines, blendMode);\r\n\r\n            join = particleSystemDefines.join(\"\\n\");\r\n\r\n            effect = this.getScene()\r\n                .getEngine()\r\n                .createEffectForParticles(\r\n                    tempName,\r\n                    this._fragmentCompilationState.uniforms,\r\n                    this._fragmentCompilationState.samplers,\r\n                    defines.toString() + \"\\n\" + join,\r\n                    result?.fallbacks,\r\n                    onCompiled,\r\n                    onError,\r\n                    particleSystem\r\n                );\r\n\r\n            particleSystem.setCustomEffect(effect, blendMode);\r\n        }\r\n\r\n        effect.onBindObservable.add((effect) => {\r\n            if (buildId !== this._buildId) {\r\n                delete Effect.ShadersStore[tempName + \"PixelShader\"];\r\n\r\n                tempName = this.name + this._buildId + \"_\" + blendMode;\r\n\r\n                defines!.markAllAsDirty();\r\n\r\n                buildId = this._buildId;\r\n            }\r\n\r\n            particleSystemDefines.length = 0;\r\n\r\n            particleSystem.fillDefines(particleSystemDefines, blendMode);\r\n\r\n            const particleSystemDefinesJoinedCurrent = particleSystemDefines.join(\"\\n\");\r\n\r\n            if (particleSystemDefinesJoinedCurrent !== join) {\r\n                defines!.markAllAsDirty();\r\n                join = particleSystemDefinesJoinedCurrent;\r\n            }\r\n\r\n            const result = this._processDefines(dummyMesh!, defines!);\r\n\r\n            if (result) {\r\n                Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString);\r\n\r\n                effect = this.getScene()\r\n                    .getEngine()\r\n                    .createEffectForParticles(\r\n                        tempName,\r\n                        this._fragmentCompilationState.uniforms,\r\n                        this._fragmentCompilationState.samplers,\r\n                        defines!.toString() + \"\\n\" + join,\r\n                        result?.fallbacks,\r\n                        onCompiled,\r\n                        onError,\r\n                        particleSystem\r\n                    );\r\n                particleSystem.setCustomEffect(effect, blendMode);\r\n                this._createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect, defines, dummyMesh, particleSystemDefinesJoined); // add the effect.onBindObservable observer\r\n                return;\r\n            }\r\n\r\n            this._checkInternals(effect);\r\n        });\r\n    }\r\n\r\n    private _checkInternals(effect: Effect) {\r\n        // Animated blocks\r\n        if (this._sharedData.animatedInputs) {\r\n            const scene = this.getScene();\r\n\r\n            const frameId = scene.getFrameId();\r\n\r\n            if (this._animationFrame !== frameId) {\r\n                for (const input of this._sharedData.animatedInputs) {\r\n                    input.animate(scene);\r\n                }\r\n\r\n                this._animationFrame = frameId;\r\n            }\r\n        }\r\n\r\n        // Bindable blocks\r\n        for (const block of this._sharedData.bindableBlocks) {\r\n            block.bind(effect, this);\r\n        }\r\n\r\n        // Connection points\r\n        for (const inputBlock of this._sharedData.inputBlocks) {\r\n            inputBlock._transmit(effect, this.getScene(), this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create the effect to be used as the custom effect for a particle system\r\n     * @param particleSystem Particle system to create the effect for\r\n     * @param onCompiled defines a function to call when the effect creation is successful\r\n     * @param onError defines a function to call when the effect creation has failed\r\n     */\r\n    public createEffectForParticles(particleSystem: IParticleSystem, onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void) {\r\n        if (this.mode !== NodeMaterialModes.Particle) {\r\n            console.log(\"Incompatible material mode\");\r\n            return;\r\n        }\r\n\r\n        this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_ONEONE, onCompiled, onError);\r\n        this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_MULTIPLY, onCompiled, onError);\r\n    }\r\n\r\n    /**\r\n     * Use this material as the shadow depth wrapper of a target material\r\n     * @param targetMaterial defines the target material\r\n     */\r\n    public createAsShadowDepthWrapper(targetMaterial: Material) {\r\n        if (this.mode !== NodeMaterialModes.Material) {\r\n            console.log(\"Incompatible material mode\");\r\n            return;\r\n        }\r\n\r\n        targetMaterial.shadowDepthWrapper = new BABYLON.ShadowDepthWrapper(this, this.getScene());\r\n    }\r\n\r\n    private _processDefines(\r\n        mesh: AbstractMesh,\r\n        defines: NodeMaterialDefines,\r\n        useInstances = false,\r\n        subMesh?: SubMesh\r\n    ): Nullable<{\r\n        lightDisposed: boolean;\r\n        uniformBuffers: string[];\r\n        mergedUniforms: string[];\r\n        mergedSamplers: string[];\r\n        fallbacks: EffectFallbacks;\r\n    }> {\r\n        let result = null;\r\n\r\n        // Global defines\r\n        const scene = this.getScene();\r\n        if (MaterialHelper.PrepareDefinesForCamera(scene, defines)) {\r\n            defines.markAsMiscDirty();\r\n        }\r\n\r\n        // Shared defines\r\n        this._sharedData.blocksWithDefines.forEach((b) => {\r\n            b.initializeDefines(mesh, this, defines, useInstances);\r\n        });\r\n\r\n        this._sharedData.blocksWithDefines.forEach((b) => {\r\n            b.prepareDefines(mesh, this, defines, useInstances, subMesh);\r\n        });\r\n\r\n        // Need to recompile?\r\n        if (defines.isDirty) {\r\n            const lightDisposed = defines._areLightsDisposed;\r\n            defines.markAsProcessed();\r\n\r\n            // Repeatable content generators\r\n            this._vertexCompilationState.compilationString = this._vertexCompilationState._builtCompilationString;\r\n            this._fragmentCompilationState.compilationString = this._fragmentCompilationState._builtCompilationString;\r\n\r\n            this._sharedData.repeatableContentBlocks.forEach((b) => {\r\n                b.replaceRepeatableContent(this._vertexCompilationState, this._fragmentCompilationState, mesh, defines);\r\n            });\r\n\r\n            // Uniforms\r\n            const uniformBuffers: string[] = [];\r\n            this._sharedData.dynamicUniformBlocks.forEach((b) => {\r\n                b.updateUniformsAndSamples(this._vertexCompilationState, this, defines, uniformBuffers);\r\n            });\r\n\r\n            const mergedUniforms = this._vertexCompilationState.uniforms;\r\n\r\n            this._fragmentCompilationState.uniforms.forEach((u) => {\r\n                const index = mergedUniforms.indexOf(u);\r\n\r\n                if (index === -1) {\r\n                    mergedUniforms.push(u);\r\n                }\r\n            });\r\n\r\n            // Samplers\r\n            const mergedSamplers = this._vertexCompilationState.samplers;\r\n\r\n            this._fragmentCompilationState.samplers.forEach((s) => {\r\n                const index = mergedSamplers.indexOf(s);\r\n\r\n                if (index === -1) {\r\n                    mergedSamplers.push(s);\r\n                }\r\n            });\r\n\r\n            const fallbacks = new EffectFallbacks();\r\n\r\n            this._sharedData.blocksWithFallbacks.forEach((b) => {\r\n                b.provideFallbacks(mesh, fallbacks);\r\n            });\r\n\r\n            result = {\r\n                lightDisposed,\r\n                uniformBuffers,\r\n                mergedUniforms,\r\n                mergedSamplers,\r\n                fallbacks,\r\n            };\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get if the submesh is ready to be used and all its information available.\r\n     * Child classes can use it to update shaders\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances: boolean = false): boolean {\r\n        if (!this._buildWasSuccessful) {\r\n            return false;\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        if (this._sharedData.animatedInputs) {\r\n            const frameId = scene.getFrameId();\r\n\r\n            if (this._animationFrame !== frameId) {\r\n                for (const input of this._sharedData.animatedInputs) {\r\n                    input.animate(scene);\r\n                }\r\n\r\n                this._animationFrame = frameId;\r\n            }\r\n        }\r\n\r\n        if (subMesh.effect && this.isFrozen) {\r\n            if (subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new NodeMaterialDefines();\r\n        }\r\n\r\n        const defines = <NodeMaterialDefines>subMesh.materialDefines;\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        this._prepareDefinesForAttributes(mesh, defines);\r\n\r\n        // Check if blocks are ready\r\n        if (this._sharedData.blockingBlocks.some((b) => !b.isReady(mesh, this, defines, useInstances))) {\r\n            return false;\r\n        }\r\n\r\n        const result = this._processDefines(mesh, defines, useInstances, subMesh);\r\n\r\n        if (result) {\r\n            const previousEffect = subMesh.effect;\r\n            // Compilation\r\n            const join = defines.toString();\r\n            let effect = engine.createEffect(\r\n                {\r\n                    vertex: \"nodeMaterial\" + this._buildId,\r\n                    fragment: \"nodeMaterial\" + this._buildId,\r\n                    vertexSource: this._vertexCompilationState.compilationString,\r\n                    fragmentSource: this._fragmentCompilationState.compilationString,\r\n                },\r\n                <IEffectCreationOptions>{\r\n                    attributes: this._vertexCompilationState.attributes,\r\n                    uniformsNames: result.mergedUniforms,\r\n                    uniformBuffersNames: result.uniformBuffers,\r\n                    samplers: result.mergedSamplers,\r\n                    defines: join,\r\n                    fallbacks: result.fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    multiTarget: defines.PREPASS,\r\n                    indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS },\r\n                },\r\n                engine\r\n            );\r\n\r\n            if (effect) {\r\n                if (this._onEffectCreatedObservable) {\r\n                    onCreatedEffectParameters.effect = effect;\r\n                    onCreatedEffectParameters.subMesh = subMesh;\r\n                    this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n                }\r\n\r\n                // Use previous effect while new one is compiling\r\n                if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\r\n                    effect = previousEffect;\r\n                    defines.markAsUnprocessed();\r\n\r\n                    if (result.lightDisposed) {\r\n                        // re register in case it takes more than one frame.\r\n                        defines._areLightsDisposed = true;\r\n                        return false;\r\n                    }\r\n                } else {\r\n                    scene.resetCachedMaterial();\r\n                    subMesh.setEffect(effect, defines, this._materialContext);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n        subMesh.effect._wasPreviouslyUsingInstances = useInstances;\r\n\r\n        this._checkScenePerformancePriority();\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get a string representing the shaders built by the current node graph\r\n     */\r\n    public get compiledShaders() {\r\n        return `// Vertex shader\\n${this._vertexCompilationState.compilationString}\\n\\n// Fragment shader\\n${this._fragmentCompilationState.compilationString}`;\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     */\r\n    public bindOnlyWorldMatrix(world: Matrix): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!this._activeEffect) {\r\n            return;\r\n        }\r\n\r\n        const hints = this._sharedData.hints;\r\n\r\n        if (hints.needWorldViewMatrix) {\r\n            world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\r\n        }\r\n\r\n        if (hints.needWorldViewProjectionMatrix) {\r\n            world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\r\n        }\r\n\r\n        // Connection points\r\n        for (const inputBlock of this._sharedData.inputBlocks) {\r\n            inputBlock._transmitWorld(this._activeEffect, world, this._cachedWorldViewMatrix, this._cachedWorldViewProjectionMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n\r\n        const mustRebind = this._mustRebind(scene, effect, mesh.visibility);\r\n        const sharedData = this._sharedData;\r\n\r\n        if (mustRebind) {\r\n            // Bindable blocks\r\n            for (const block of sharedData.bindableBlocks) {\r\n                block.bind(effect, this, mesh, subMesh);\r\n            }\r\n\r\n            for (const block of sharedData.forcedBindableBlocks) {\r\n                block.bind(effect, this, mesh, subMesh);\r\n            }\r\n\r\n            // Connection points\r\n            for (const inputBlock of sharedData.inputBlocks) {\r\n                inputBlock._transmit(effect, scene, this);\r\n            }\r\n        } else if (!this.isFrozen) {\r\n            for (const block of sharedData.forcedBindableBlocks) {\r\n                block.bind(effect, this, mesh, subMesh);\r\n            }\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._sharedData) {\r\n            activeTextures.push(...this._sharedData.textureBlocks.filter((tb) => tb.texture).map((tb) => tb.texture!));\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of texture blocks\r\n     * Note that this method will only return blocks that are reachable from the final block(s) and only after the material has been built!\r\n     * @returns an array of texture blocks\r\n     */\r\n    public getTextureBlocks(): NodeMaterialTextureBlocks[] {\r\n        if (!this._sharedData) {\r\n            return [];\r\n        }\r\n\r\n        return this._sharedData.textureBlocks;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of all texture blocks\r\n     * Note that this method will scan all attachedBlocks and return blocks that are texture blocks\r\n     * @returns\r\n     */\r\n    public getAllTextureBlocks(): NodeMaterialTextureBlocks[] {\r\n        const textureBlocks: NodeMaterialTextureBlocks[] = [];\r\n\r\n        for (const block of this.attachedBlocks) {\r\n            if (NodeMaterial._BlockIsTextureBlock(block)) {\r\n                textureBlocks.push(block);\r\n            }\r\n        }\r\n\r\n        return textureBlocks;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (!this._sharedData) {\r\n            return false;\r\n        }\r\n\r\n        for (const t of this._sharedData.textureBlocks) {\r\n            if (t.texture === texture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            for (const texture of this.getTextureBlocks()\r\n                .filter((tb) => tb.texture)\r\n                .map((tb) => tb.texture!)) {\r\n                texture.dispose();\r\n            }\r\n        }\r\n\r\n        for (const block of this.attachedBlocks) {\r\n            block.dispose();\r\n        }\r\n\r\n        this.attachedBlocks.length = 0;\r\n        (this._sharedData as any) = null;\r\n        (this._vertexCompilationState as any) = null;\r\n        (this._fragmentCompilationState as any) = null;\r\n\r\n        this.onBuildObservable.clear();\r\n\r\n        if (this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n            this._imageProcessingObserver = null;\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\r\n    }\r\n\r\n    /** Creates the node editor window. */\r\n    private _createNodeEditor(additionalConfig?: any) {\r\n        const nodeEditorConfig: any = {\r\n            nodeMaterial: this,\r\n            ...additionalConfig,\r\n        };\r\n        this.BJSNODEMATERIALEDITOR.NodeEditor.Show(nodeEditorConfig);\r\n    }\r\n\r\n    /**\r\n     * Launch the node material editor\r\n     * @param config Define the configuration of the editor\r\n     * @returns a promise fulfilled when the node editor is visible\r\n     */\r\n    public edit(config?: INodeMaterialEditorOptions): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();\r\n            if (typeof this.BJSNODEMATERIALEDITOR == \"undefined\") {\r\n                const editorUrl = config && config.editorURL ? config.editorURL : NodeMaterial.EditorURL;\r\n\r\n                // Load editor and add it to the DOM\r\n                Tools.LoadBabylonScript(editorUrl, () => {\r\n                    this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();\r\n                    this._createNodeEditor(config?.nodeEditorConfig);\r\n                    resolve();\r\n                });\r\n            } else {\r\n                // Otherwise creates the editor\r\n                this._createNodeEditor(config?.nodeEditorConfig);\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Clear the current material\r\n     */\r\n    public clear() {\r\n        this._vertexOutputNodes.length = 0;\r\n        this._fragmentOutputNodes.length = 0;\r\n        this.attachedBlocks.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state\r\n     */\r\n    public setToDefault() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        const positionInput = new InputBlock(\"Position\");\r\n        positionInput.setAsAttribute(\"position\");\r\n\r\n        const worldInput = new InputBlock(\"World\");\r\n        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\r\n\r\n        const worldPos = new TransformBlock(\"WorldPos\");\r\n        positionInput.connectTo(worldPos);\r\n        worldInput.connectTo(worldPos);\r\n\r\n        const viewProjectionInput = new InputBlock(\"ViewProjection\");\r\n        viewProjectionInput.setAsSystemValue(NodeMaterialSystemValues.ViewProjection);\r\n\r\n        const worldPosdMultipliedByViewProjection = new TransformBlock(\"WorldPos * ViewProjectionTransform\");\r\n        worldPos.connectTo(worldPosdMultipliedByViewProjection);\r\n        viewProjectionInput.connectTo(worldPosdMultipliedByViewProjection);\r\n\r\n        const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\r\n        worldPosdMultipliedByViewProjection.connectTo(vertexOutput);\r\n\r\n        // Pixel\r\n        const pixelColor = new InputBlock(\"color\");\r\n        pixelColor.value = new Color4(0.8, 0.8, 0.8, 1);\r\n\r\n        const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n        pixelColor.connectTo(fragmentOutput);\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(vertexOutput);\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.Material;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state for post process\r\n     */\r\n    public setToDefaultPostProcess() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        const position = new InputBlock(\"Position\");\r\n        position.setAsAttribute(\"position2d\");\r\n\r\n        const const1 = new InputBlock(\"Constant1\");\r\n        const1.isConstant = true;\r\n        const1.value = 1;\r\n\r\n        const vmerger = new VectorMergerBlock(\"Position3D\");\r\n\r\n        position.connectTo(vmerger);\r\n        const1.connectTo(vmerger, { input: \"w\" });\r\n\r\n        const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\r\n        vmerger.connectTo(vertexOutput);\r\n\r\n        // Pixel\r\n        const scale = new InputBlock(\"Scale\");\r\n        scale.visibleInInspector = true;\r\n        scale.value = new Vector2(1, 1);\r\n\r\n        const uv0 = new RemapBlock(\"uv0\");\r\n        position.connectTo(uv0);\r\n\r\n        const uv = new MultiplyBlock(\"UV scale\");\r\n        uv0.connectTo(uv);\r\n        scale.connectTo(uv);\r\n\r\n        const currentScreen = new CurrentScreenBlock(\"CurrentScreen\");\r\n        uv.connectTo(currentScreen);\r\n\r\n        currentScreen.texture = new Texture(\"https://assets.babylonjs.com/nme/currentScreenPostProcess.png\", this.getScene());\r\n\r\n        const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n        currentScreen.connectTo(fragmentOutput, { output: \"rgba\" });\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(vertexOutput);\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.PostProcess;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state for procedural texture\r\n     */\r\n    public setToDefaultProceduralTexture() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        const position = new InputBlock(\"Position\");\r\n        position.setAsAttribute(\"position2d\");\r\n\r\n        const const1 = new InputBlock(\"Constant1\");\r\n        const1.isConstant = true;\r\n        const1.value = 1;\r\n\r\n        const vmerger = new VectorMergerBlock(\"Position3D\");\r\n\r\n        position.connectTo(vmerger);\r\n        const1.connectTo(vmerger, { input: \"w\" });\r\n\r\n        const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\r\n        vmerger.connectTo(vertexOutput);\r\n\r\n        // Pixel\r\n        const time = new InputBlock(\"Time\");\r\n        time.value = 0;\r\n        time.min = 0;\r\n        time.max = 0;\r\n        time.isBoolean = false;\r\n        time.matrixMode = 0;\r\n        time.animationType = AnimatedInputBlockTypes.Time;\r\n        time.isConstant = false;\r\n\r\n        const color = new InputBlock(\"Color3\");\r\n        color.value = new Color3(1, 1, 1);\r\n        color.isConstant = false;\r\n        const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n\r\n        const vectorMerger = new VectorMergerBlock(\"VectorMerger\");\r\n        vectorMerger.visibleInInspector = false;\r\n\r\n        const cos = new TrigonometryBlock(\"Cos\");\r\n        cos.operation = TrigonometryBlockOperations.Cos;\r\n\r\n        position.connectTo(vectorMerger);\r\n        time.output.connectTo(cos.input);\r\n        cos.output.connectTo(vectorMerger.z);\r\n        vectorMerger.xyzOut.connectTo(fragmentOutput.rgb);\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(vertexOutput);\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.ProceduralTexture;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state for particle\r\n     */\r\n    public setToDefaultParticle() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        // Pixel\r\n        const uv = new InputBlock(\"uv\");\r\n        uv.setAsAttribute(\"particle_uv\");\r\n\r\n        const texture = new ParticleTextureBlock(\"ParticleTexture\");\r\n        uv.connectTo(texture);\r\n\r\n        const color = new InputBlock(\"Color\");\r\n        color.setAsAttribute(\"particle_color\");\r\n\r\n        const multiply = new MultiplyBlock(\"Texture * Color\");\r\n        texture.connectTo(multiply);\r\n        color.connectTo(multiply);\r\n\r\n        const rampGradient = new ParticleRampGradientBlock(\"ParticleRampGradient\");\r\n        multiply.connectTo(rampGradient);\r\n\r\n        const cSplitter = new ColorSplitterBlock(\"ColorSplitter\");\r\n        color.connectTo(cSplitter);\r\n\r\n        const blendMultiply = new ParticleBlendMultiplyBlock(\"ParticleBlendMultiply\");\r\n        rampGradient.connectTo(blendMultiply);\r\n        texture.connectTo(blendMultiply, { output: \"a\" });\r\n        cSplitter.connectTo(blendMultiply, { output: \"a\" });\r\n\r\n        const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n        blendMultiply.connectTo(fragmentOutput);\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.Particle;\r\n    }\r\n\r\n    /**\r\n     * Loads the current Node Material from a url pointing to a file save by the Node Material Editor\r\n     * @deprecated Please use NodeMaterial.ParseFromFileAsync instead\r\n     * @param url defines the url to load from\r\n     * @param rootUrl defines the root URL for nested url in the node material\r\n     * @returns a promise that will fulfil when the material is fully loaded\r\n     */\r\n    public async loadAsync(url: string, rootUrl: string = \"\") {\r\n        return NodeMaterial.ParseFromFileAsync(\"\", url, this.getScene(), rootUrl, true, this);\r\n    }\r\n\r\n    private _gatherBlocks(rootNode: NodeMaterialBlock, list: NodeMaterialBlock[]) {\r\n        if (list.indexOf(rootNode) !== -1) {\r\n            return;\r\n        }\r\n        list.push(rootNode);\r\n\r\n        for (const input of rootNode.inputs) {\r\n            const connectedPoint = input.connectedPoint;\r\n            if (connectedPoint) {\r\n                const block = connectedPoint.ownerBlock;\r\n                if (block !== rootNode) {\r\n                    this._gatherBlocks(block, list);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Teleportation\r\n        if (rootNode.isTeleportOut) {\r\n            const block = rootNode as NodeMaterialTeleportOutBlock;\r\n            if (block.entryPoint) {\r\n                this._gatherBlocks(block.entryPoint, list);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate a string containing the code declaration required to create an equivalent of this material\r\n     * @returns a string\r\n     */\r\n    public generateCode() {\r\n        let alreadyDumped: NodeMaterialBlock[] = [];\r\n        const vertexBlocks: NodeMaterialBlock[] = [];\r\n        const uniqueNames: string[] = [\"const\", \"var\", \"let\"];\r\n        // Gets active blocks\r\n        for (const outputNode of this._vertexOutputNodes) {\r\n            this._gatherBlocks(outputNode, vertexBlocks);\r\n        }\r\n\r\n        const fragmentBlocks: NodeMaterialBlock[] = [];\r\n        for (const outputNode of this._fragmentOutputNodes) {\r\n            this._gatherBlocks(outputNode, fragmentBlocks);\r\n        }\r\n\r\n        // Generate vertex shader\r\n        let codeString = `var nodeMaterial = new BABYLON.NodeMaterial(\"${this.name || \"node material\"}\");\\n`;\r\n        codeString += `nodeMaterial.mode = BABYLON.NodeMaterialModes.${NodeMaterialModes[this.mode]};\\n`;\r\n        for (const node of vertexBlocks) {\r\n            if (node.isInput && alreadyDumped.indexOf(node) === -1) {\r\n                codeString += node._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Generate fragment shader\r\n        for (const node of fragmentBlocks) {\r\n            if (node.isInput && alreadyDumped.indexOf(node) === -1) {\r\n                codeString += node._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Connections\r\n        alreadyDumped = [];\r\n        codeString += \"\\n// Connections\\n\";\r\n        for (const node of this._vertexOutputNodes) {\r\n            codeString += node._dumpCodeForOutputConnections(alreadyDumped);\r\n        }\r\n        for (const node of this._fragmentOutputNodes) {\r\n            codeString += node._dumpCodeForOutputConnections(alreadyDumped);\r\n        }\r\n\r\n        // Output nodes\r\n        codeString += \"\\n// Output nodes\\n\";\r\n        for (const node of this._vertexOutputNodes) {\r\n            codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});\\n`;\r\n        }\r\n\r\n        for (const node of this._fragmentOutputNodes) {\r\n            codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});\\n`;\r\n        }\r\n\r\n        codeString += `nodeMaterial.build();\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @param selectedBlocks\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(selectedBlocks?: NodeMaterialBlock[]): any {\r\n        const serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);\r\n        serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData)); // Copy\r\n\r\n        let blocks: NodeMaterialBlock[] = [];\r\n\r\n        if (selectedBlocks) {\r\n            blocks = selectedBlocks;\r\n        } else {\r\n            serializationObject.customType = \"BABYLON.NodeMaterial\";\r\n            serializationObject.outputNodes = [];\r\n\r\n            // Outputs\r\n            for (const outputNode of this._vertexOutputNodes) {\r\n                this._gatherBlocks(outputNode, blocks);\r\n                serializationObject.outputNodes.push(outputNode.uniqueId);\r\n            }\r\n\r\n            for (const outputNode of this._fragmentOutputNodes) {\r\n                this._gatherBlocks(outputNode, blocks);\r\n\r\n                if (serializationObject.outputNodes.indexOf(outputNode.uniqueId) === -1) {\r\n                    serializationObject.outputNodes.push(outputNode.uniqueId);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Blocks\r\n        serializationObject.blocks = [];\r\n\r\n        for (const block of blocks) {\r\n            serializationObject.blocks.push(block.serialize());\r\n        }\r\n\r\n        if (!selectedBlocks) {\r\n            for (const block of this.attachedBlocks) {\r\n                if (blocks.indexOf(block) !== -1) {\r\n                    continue;\r\n                }\r\n                serializationObject.blocks.push(block.serialize());\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private _restoreConnections(block: NodeMaterialBlock, source: any, map: { [key: number]: NodeMaterialBlock }) {\r\n        for (const outputPoint of block.outputs) {\r\n            for (const candidate of source.blocks) {\r\n                const target = map[candidate.id];\r\n\r\n                if (!target) {\r\n                    continue;\r\n                }\r\n\r\n                for (const input of candidate.inputs) {\r\n                    if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {\r\n                        const inputPoint = target.getInputByName(input.inputName);\r\n                        if (!inputPoint || inputPoint.isConnected) {\r\n                            continue;\r\n                        }\r\n\r\n                        outputPoint.connectTo(inputPoint, true);\r\n                        this._restoreConnections(target, source, map);\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the current graph and load a new one from a serialization object\r\n     * @param source defines the JSON representation of the material\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param merge defines whether or not the source must be merged or replace the current content\r\n     */\r\n    public parseSerializedObject(source: any, rootUrl: string = \"\", merge = false) {\r\n        if (!merge) {\r\n            this.clear();\r\n        }\r\n\r\n        const map: { [key: number]: NodeMaterialBlock } = {};\r\n\r\n        // Create blocks\r\n        for (const parsedBlock of source.blocks) {\r\n            const blockType = GetClass(parsedBlock.customType);\r\n            if (blockType) {\r\n                const block: NodeMaterialBlock = new blockType();\r\n                block._deserialize(parsedBlock, this.getScene(), rootUrl);\r\n                map[parsedBlock.id] = block;\r\n\r\n                this.attachedBlocks.push(block);\r\n            }\r\n        }\r\n\r\n        // Reconnect teleportation\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.isTeleportOut) {\r\n                const teleportOut = block as NodeMaterialTeleportOutBlock;\r\n                const id = teleportOut._tempEntryPointUniqueId;\r\n                if (id) {\r\n                    const source = map[id] as NodeMaterialTeleportInBlock;\r\n                    source.attachToEndpoint(teleportOut);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Connections - Starts with input blocks only (except if in \"merge\" mode where we scan all blocks)\r\n        for (let blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {\r\n            const parsedBlock = source.blocks[blockIndex];\r\n            const block = map[parsedBlock.id];\r\n\r\n            if (!block) {\r\n                continue;\r\n            }\r\n\r\n            if (block.inputs.length && !merge) {\r\n                continue;\r\n            }\r\n            this._restoreConnections(block, source, map);\r\n        }\r\n\r\n        // Outputs\r\n        if (source.outputNodes) {\r\n            for (const outputNodeId of source.outputNodes) {\r\n                this.addOutputNode(map[outputNodeId]);\r\n            }\r\n        }\r\n\r\n        // UI related info\r\n        if (source.locations || (source.editorData && source.editorData.locations)) {\r\n            const locations: {\r\n                blockId: number;\r\n                x: number;\r\n                y: number;\r\n            }[] = source.locations || source.editorData.locations;\r\n\r\n            for (const location of locations) {\r\n                if (map[location.blockId]) {\r\n                    location.blockId = map[location.blockId].uniqueId;\r\n                }\r\n            }\r\n\r\n            if (merge && this.editorData && this.editorData.locations) {\r\n                locations.concat(this.editorData.locations);\r\n            }\r\n\r\n            if (source.locations) {\r\n                this.editorData = {\r\n                    locations: locations,\r\n                };\r\n            } else {\r\n                this.editorData = source.editorData;\r\n                this.editorData.locations = locations;\r\n            }\r\n\r\n            const blockMap: number[] = [];\r\n\r\n            for (const key in map) {\r\n                blockMap[key] = map[key].uniqueId;\r\n            }\r\n\r\n            this.editorData.map = blockMap;\r\n        }\r\n\r\n        this.comment = source.comment;\r\n\r\n        if (source.forceAlphaBlending !== undefined) {\r\n            this.forceAlphaBlending = source.forceAlphaBlending;\r\n        }\r\n\r\n        if (!merge) {\r\n            this._mode = source.mode ?? NodeMaterialModes.Material;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the current graph and load a new one from a serialization object\r\n     * @param source defines the JSON representation of the material\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param merge defines whether or not the source must be merged or replace the current content\r\n     * @deprecated Please use the parseSerializedObject method instead\r\n     */\r\n    public loadFromSerialization(source: any, rootUrl: string = \"\", merge = false) {\r\n        this.parseSerializedObject(source, rootUrl, merge);\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current material.\r\n     * @param name defines the name to use for the new material\r\n     * @param shareEffect defines if the clone material should share the same effect (default is false)\r\n     */\r\n    public clone(name: string, shareEffect: boolean = false): NodeMaterial {\r\n        const serializationObject = this.serialize();\r\n\r\n        const clone = SerializationHelper.Clone(() => new NodeMaterial(name, this.getScene(), this.options), this);\r\n        clone.id = name;\r\n        clone.name = name;\r\n\r\n        clone.parseSerializedObject(serializationObject);\r\n        clone._buildId = this._buildId;\r\n        clone.build(false, !shareEffect);\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Awaits for all the material textures to be ready before resolving the returned promise.\r\n     */\r\n    public whenTexturesReadyAsync(): Promise<void[]> {\r\n        // Ensures all textures are ready to render.\r\n        const textureReadyPromises: Promise<void>[] = [];\r\n        this.getActiveTextures().forEach((texture) => {\r\n            const internalTexture = texture.getInternalTexture();\r\n            if (internalTexture && !internalTexture.isReady) {\r\n                textureReadyPromises.push(\r\n                    new Promise((textureResolve, textureReject) => {\r\n                        internalTexture.onLoadedObservable.addOnce(() => {\r\n                            textureResolve();\r\n                        });\r\n                        internalTexture.onErrorObservable.addOnce((e) => {\r\n                            textureReject(e);\r\n                        });\r\n                    })\r\n                );\r\n            }\r\n        });\r\n\r\n        return Promise.all(textureReadyPromises);\r\n    }\r\n\r\n    /**\r\n     * Creates a node material from parsed material data\r\n     * @param source defines the JSON representation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new node material\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string = \"\"): NodeMaterial {\r\n        const nodeMaterial = SerializationHelper.Parse(() => new NodeMaterial(source.name, scene), source, scene, rootUrl);\r\n\r\n        nodeMaterial.parseSerializedObject(source, rootUrl);\r\n        nodeMaterial.build();\r\n\r\n        return nodeMaterial;\r\n    }\r\n\r\n    /**\r\n     * Creates a node material from a snippet saved in a remote file\r\n     * @param name defines the name of the material to create\r\n     * @param url defines the url to load from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL for nested url in the node material\r\n     * @param skipBuild defines whether to build the node material\r\n     * @param targetMaterial defines a material to use instead of creating a new one\r\n     * @returns a promise that will resolve to the new node material\r\n     */\r\n    public static async ParseFromFileAsync(\r\n        name: string,\r\n        url: string,\r\n        scene: Scene,\r\n        rootUrl: string = \"\",\r\n        skipBuild: boolean = false,\r\n        targetMaterial?: NodeMaterial\r\n    ): Promise<NodeMaterial> {\r\n        const material = targetMaterial ?? new NodeMaterial(name, scene);\r\n\r\n        const data = await scene._loadFileAsync(url);\r\n        const serializationObject = JSON.parse(data as string);\r\n        material.parseSerializedObject(serializationObject, rootUrl);\r\n        if (!skipBuild) {\r\n            material.build();\r\n        }\r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * Creates a node material from a snippet saved by the node material editor\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param nodeMaterial defines a node material to update (instead of creating a new one)\r\n     * @param skipBuild defines whether to build the node material\r\n     * @param waitForTextureReadyness defines whether to wait for texture readiness resolving the promise (default: false)\r\n     * @returns a promise that will resolve to the new node material\r\n     */\r\n    public static ParseFromSnippetAsync(\r\n        snippetId: string,\r\n        scene: Scene = EngineStore.LastCreatedScene!,\r\n        rootUrl: string = \"\",\r\n        nodeMaterial?: NodeMaterial,\r\n        skipBuild: boolean = false,\r\n        waitForTextureReadyness: boolean = false\r\n    ): Promise<NodeMaterial> {\r\n        if (snippetId === \"_BLANK\") {\r\n            return Promise.resolve(NodeMaterial.CreateDefault(\"blank\", scene));\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        const serializationObject = JSON.parse(snippet.nodeMaterial);\r\n\r\n                        if (!nodeMaterial) {\r\n                            nodeMaterial = SerializationHelper.Parse(() => new NodeMaterial(snippetId, scene), serializationObject, scene, rootUrl);\r\n                            nodeMaterial.uniqueId = scene.getUniqueId();\r\n                        }\r\n\r\n                        nodeMaterial.parseSerializedObject(serializationObject);\r\n                        nodeMaterial.snippetId = snippetId;\r\n\r\n                        try {\r\n                            if (!skipBuild) {\r\n                                nodeMaterial.build();\r\n                            }\r\n                        } catch (err) {\r\n                            reject(err);\r\n                        }\r\n\r\n                        if (waitForTextureReadyness) {\r\n                            nodeMaterial\r\n                                .whenTexturesReadyAsync()\r\n                                .then(() => {\r\n                                    resolve(nodeMaterial!);\r\n                                })\r\n                                .catch((err) => {\r\n                                    reject(err);\r\n                                });\r\n                        } else {\r\n                            resolve(nodeMaterial);\r\n                        }\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a new node material set to default basic configuration\r\n     * @param name defines the name of the material\r\n     * @param scene defines the hosting scene\r\n     * @returns a new NodeMaterial\r\n     */\r\n    public static CreateDefault(name: string, scene?: Scene) {\r\n        const newMaterial = new NodeMaterial(name, scene);\r\n\r\n        newMaterial.setToDefault();\r\n        newMaterial.build();\r\n\r\n        return newMaterial;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.NodeMaterial\", NodeMaterial);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}