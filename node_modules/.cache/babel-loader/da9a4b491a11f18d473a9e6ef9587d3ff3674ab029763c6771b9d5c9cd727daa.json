{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { TransformNode } from \"@babylonjs/core/Meshes/transformNode.js\";\nimport { Control3D } from \"./control3D.js\";\n/**\n * Class used to create containers for controls\n */\nexport class Container3D extends Control3D {\n  /**\n   * Gets the list of child controls\n   */\n  get children() {\n    return this._children;\n  }\n  /**\n   * Gets or sets a boolean indicating if the layout must be blocked (default is false).\n   * This is helpful to optimize layout operation when adding multiple children in a row\n   */\n  get blockLayout() {\n    return this._blockLayout;\n  }\n  set blockLayout(value) {\n    if (this._blockLayout === value) {\n      return;\n    }\n    this._blockLayout = value;\n    if (!this._blockLayout) {\n      this._arrangeChildren();\n    }\n  }\n  /**\n   * Creates a new container\n   * @param name defines the container name\n   */\n  constructor(name) {\n    super(name);\n    this._blockLayout = false;\n    /**\n     * Gets the list of child controls\n     */\n    this._children = new Array();\n  }\n  /**\n   * Force the container to update the layout. Please note that it will not take blockLayout property in account\n   * @returns the current container\n   */\n  updateLayout() {\n    this._arrangeChildren();\n    return this;\n  }\n  /**\n   * Gets a boolean indicating if the given control is in the children of this control\n   * @param control defines the control to check\n   * @returns true if the control is in the child list\n   */\n  containsControl(control) {\n    return this._children.indexOf(control) !== -1;\n  }\n  /**\n   * Adds a control to the children of this control\n   * @param control defines the control to add\n   * @returns the current container\n   */\n  addControl(control) {\n    const index = this._children.indexOf(control);\n    if (index !== -1) {\n      return this;\n    }\n    control.parent = this;\n    control._host = this._host;\n    this._children.push(control);\n    if (this._host.utilityLayer) {\n      control._prepareNode(this._host.utilityLayer.utilityLayerScene);\n      if (control.node) {\n        control.node.parent = this.node;\n      }\n      if (!this.blockLayout) {\n        this._arrangeChildren();\n      }\n    }\n    return this;\n  }\n  /**\n   * This function will be called everytime a new control is added\n   */\n  _arrangeChildren() {}\n  _createNode(scene) {\n    return new TransformNode(\"ContainerNode\", scene);\n  }\n  /**\n   * Removes a control from the children of this control\n   * @param control defines the control to remove\n   * @returns the current container\n   */\n  removeControl(control) {\n    const index = this._children.indexOf(control);\n    if (index !== -1) {\n      this._children.splice(index, 1);\n      control.parent = null;\n      control._disposeNode();\n    }\n    return this;\n  }\n  _getTypeName() {\n    return \"Container3D\";\n  }\n  /**\n   * Releases all associated resources\n   */\n  dispose() {\n    for (const control of this._children) {\n      control.dispose();\n    }\n    this._children.length = 0;\n    super.dispose();\n  }\n}\n/** Control rotation will remain unchanged  */\nContainer3D.UNSET_ORIENTATION = 0;\n/** Control will rotate to make it look at sphere central axis */\nContainer3D.FACEORIGIN_ORIENTATION = 1;\n/** Control will rotate to make it look back at sphere central axis */\nContainer3D.FACEORIGINREVERSED_ORIENTATION = 2;\n/** Control will rotate to look at z axis (0, 0, 1) */\nContainer3D.FACEFORWARD_ORIENTATION = 3;\n/** Control will rotate to look at negative z axis (0, 0, -1) */\nContainer3D.FACEFORWARDREVERSED_ORIENTATION = 4;","map":{"version":3,"names":["TransformNode","Control3D","Container3D","children","_children","blockLayout","_blockLayout","value","_arrangeChildren","constructor","name","Array","updateLayout","containsControl","control","indexOf","addControl","index","parent","_host","push","utilityLayer","_prepareNode","utilityLayerScene","node","_createNode","scene","removeControl","splice","_disposeNode","_getTypeName","dispose","length","UNSET_ORIENTATION","FACEORIGIN_ORIENTATION","FACEORIGINREVERSED_ORIENTATION","FACEFORWARD_ORIENTATION","FACEFORWARDREVERSED_ORIENTATION"],"sources":["../../../../../dev/gui/src/3D/controls/container3D.ts"],"sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport { Control3D } from \"./control3D\";\r\n\r\n/**\r\n * Class used to create containers for controls\r\n */\r\nexport class Container3D extends Control3D {\r\n    private _blockLayout = false;\r\n\r\n    /**\r\n     * Gets the list of child controls\r\n     */\r\n    protected _children = new Array<Control3D>();\r\n\r\n    /**\r\n     * Gets the list of child controls\r\n     */\r\n    public get children(): Array<Control3D> {\r\n        return this._children;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the layout must be blocked (default is false).\r\n     * This is helpful to optimize layout operation when adding multiple children in a row\r\n     */\r\n    public get blockLayout(): boolean {\r\n        return this._blockLayout;\r\n    }\r\n\r\n    public set blockLayout(value: boolean) {\r\n        if (this._blockLayout === value) {\r\n            return;\r\n        }\r\n\r\n        this._blockLayout = value;\r\n\r\n        if (!this._blockLayout) {\r\n            this._arrangeChildren();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new container\r\n     * @param name defines the container name\r\n     */\r\n    constructor(name?: string) {\r\n        super(name);\r\n    }\r\n\r\n    /**\r\n     * Force the container to update the layout. Please note that it will not take blockLayout property in account\r\n     * @returns the current container\r\n     */\r\n    public updateLayout(): Container3D {\r\n        this._arrangeChildren();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the given control is in the children of this control\r\n     * @param control defines the control to check\r\n     * @returns true if the control is in the child list\r\n     */\r\n    public containsControl(control: Control3D): boolean {\r\n        return this._children.indexOf(control) !== -1;\r\n    }\r\n\r\n    /**\r\n     * Adds a control to the children of this control\r\n     * @param control defines the control to add\r\n     * @returns the current container\r\n     */\r\n    public addControl(control: Control3D): Container3D {\r\n        const index = this._children.indexOf(control);\r\n\r\n        if (index !== -1) {\r\n            return this;\r\n        }\r\n        control.parent = this;\r\n        control._host = this._host;\r\n\r\n        this._children.push(control);\r\n\r\n        if (this._host.utilityLayer) {\r\n            control._prepareNode(this._host.utilityLayer.utilityLayerScene);\r\n\r\n            if (control.node) {\r\n                control.node.parent = this.node;\r\n            }\r\n\r\n            if (!this.blockLayout) {\r\n                this._arrangeChildren();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * This function will be called everytime a new control is added\r\n     */\r\n    protected _arrangeChildren() {}\r\n\r\n    protected _createNode(scene: Scene): Nullable<TransformNode> {\r\n        return new TransformNode(\"ContainerNode\", scene);\r\n    }\r\n\r\n    /**\r\n     * Removes a control from the children of this control\r\n     * @param control defines the control to remove\r\n     * @returns the current container\r\n     */\r\n    public removeControl(control: Control3D): Container3D {\r\n        const index = this._children.indexOf(control);\r\n\r\n        if (index !== -1) {\r\n            this._children.splice(index, 1);\r\n\r\n            control.parent = null;\r\n            control._disposeNode();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _getTypeName(): string {\r\n        return \"Container3D\";\r\n    }\r\n\r\n    /**\r\n     * Releases all associated resources\r\n     */\r\n    public dispose() {\r\n        for (const control of this._children) {\r\n            control.dispose();\r\n        }\r\n\r\n        this._children.length = 0;\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /** Control rotation will remain unchanged  */\r\n    public static readonly UNSET_ORIENTATION = 0;\r\n\r\n    /** Control will rotate to make it look at sphere central axis */\r\n    public static readonly FACEORIGIN_ORIENTATION = 1;\r\n\r\n    /** Control will rotate to make it look back at sphere central axis */\r\n    public static readonly FACEORIGINREVERSED_ORIENTATION = 2;\r\n\r\n    /** Control will rotate to look at z axis (0, 0, 1) */\r\n    public static readonly FACEFORWARD_ORIENTATION = 3;\r\n\r\n    /** Control will rotate to look at negative z axis (0, 0, -1) */\r\n    public static readonly FACEFORWARDREVERSED_ORIENTATION = 4;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}