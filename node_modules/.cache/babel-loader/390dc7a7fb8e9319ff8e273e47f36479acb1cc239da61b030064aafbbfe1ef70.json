{"ast":null,"code":"import { Matrix } from \"../Maths/math.vector.js\";\nimport { Material } from \"../Materials/material.js\";\n/**\n * Base class of materials working in push mode in babylon JS\n * @internal\n */\nexport class PushMaterial extends Material {\n  constructor(name, scene, storeEffectOnSubMeshes = true) {\n    super(name, scene);\n    this._normalMatrix = new Matrix();\n    this._storeEffectOnSubMeshes = storeEffectOnSubMeshes;\n  }\n  getEffect() {\n    return this._storeEffectOnSubMeshes ? this._activeEffect : super.getEffect();\n  }\n  isReady(mesh, useInstances) {\n    if (!mesh) {\n      return false;\n    }\n    if (!this._storeEffectOnSubMeshes) {\n      return true;\n    }\n    if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\n      return true;\n    }\n    return this.isReadyForSubMesh(mesh, mesh.subMeshes[0], useInstances);\n  }\n  _isReadyForSubMesh(subMesh) {\n    const defines = subMesh.materialDefines;\n    if (!this.checkReadyOnEveryCall && subMesh.effect && defines) {\n      if (defines._renderId === this.getScene().getRenderId()) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Binds the given world matrix to the active effect\n   *\n   * @param world the matrix to bind\n   */\n  bindOnlyWorldMatrix(world) {\n    this._activeEffect.setMatrix(\"world\", world);\n  }\n  /**\n   * Binds the given normal matrix to the active effect\n   *\n   * @param normalMatrix the matrix to bind\n   */\n  bindOnlyNormalMatrix(normalMatrix) {\n    this._activeEffect.setMatrix(\"normalMatrix\", normalMatrix);\n  }\n  bind(world, mesh) {\n    if (!mesh) {\n      return;\n    }\n    this.bindForSubMesh(world, mesh, mesh.subMeshes[0]);\n  }\n  _afterBind(mesh, effect = null) {\n    super._afterBind(mesh, effect);\n    this.getScene()._cachedEffect = effect;\n    if (effect) {\n      effect._forceRebindOnNextCall = false;\n    }\n  }\n  _mustRebind(scene, effect, visibility = 1) {\n    return scene.isCachedMaterialInvalid(this, effect, visibility);\n  }\n  dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {\n    this._activeEffect = undefined;\n    super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\n  }\n}","map":{"version":3,"names":["Matrix","Material","PushMaterial","constructor","name","scene","storeEffectOnSubMeshes","_normalMatrix","_storeEffectOnSubMeshes","getEffect","_activeEffect","isReady","mesh","useInstances","subMeshes","length","isReadyForSubMesh","_isReadyForSubMesh","subMesh","defines","materialDefines","checkReadyOnEveryCall","effect","_renderId","getScene","getRenderId","bindOnlyWorldMatrix","world","setMatrix","bindOnlyNormalMatrix","normalMatrix","bind","bindForSubMesh","_afterBind","_cachedEffect","_forceRebindOnNextCall","_mustRebind","visibility","isCachedMaterialInvalid","dispose","forceDisposeEffect","forceDisposeTextures","notBoundToMesh","undefined"],"sources":["../../../../dev/core/src/Materials/pushMaterial.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { Material } from \"../Materials/material\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\n/**\r\n * Base class of materials working in push mode in babylon JS\r\n * @internal\r\n */\r\nexport class PushMaterial extends Material {\r\n    protected _activeEffect?: Effect;\r\n\r\n    protected _normalMatrix: Matrix = new Matrix();\r\n\r\n    constructor(name: string, scene?: Scene, storeEffectOnSubMeshes = true) {\r\n        super(name, scene);\r\n        this._storeEffectOnSubMeshes = storeEffectOnSubMeshes;\r\n    }\r\n\r\n    public getEffect(): Effect {\r\n        return this._storeEffectOnSubMeshes ? this._activeEffect! : super.getEffect()!;\r\n    }\r\n\r\n    public isReady(mesh?: AbstractMesh, useInstances?: boolean): boolean {\r\n        if (!mesh) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._storeEffectOnSubMeshes) {\r\n            return true;\r\n        }\r\n\r\n        if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\r\n            return true;\r\n        }\r\n\r\n        return this.isReadyForSubMesh(mesh, mesh.subMeshes[0], useInstances);\r\n    }\r\n\r\n    protected _isReadyForSubMesh(subMesh: SubMesh) {\r\n        const defines = subMesh.materialDefines;\r\n        if (!this.checkReadyOnEveryCall && subMesh.effect && defines) {\r\n            if (defines._renderId === this.getScene().getRenderId()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Binds the given world matrix to the active effect\r\n     *\r\n     * @param world the matrix to bind\r\n     */\r\n    public bindOnlyWorldMatrix(world: Matrix): void {\r\n        this._activeEffect!.setMatrix(\"world\", world);\r\n    }\r\n\r\n    /**\r\n     * Binds the given normal matrix to the active effect\r\n     *\r\n     * @param normalMatrix the matrix to bind\r\n     */\r\n    public bindOnlyNormalMatrix(normalMatrix: Matrix): void {\r\n        this._activeEffect!.setMatrix(\"normalMatrix\", normalMatrix);\r\n    }\r\n\r\n    public bind(world: Matrix, mesh?: Mesh): void {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        this.bindForSubMesh(world, mesh, mesh.subMeshes[0]);\r\n    }\r\n\r\n    protected _afterBind(mesh?: Mesh, effect: Nullable<Effect> = null): void {\r\n        super._afterBind(mesh, effect);\r\n        this.getScene()._cachedEffect = effect;\r\n        if (effect) {\r\n            effect._forceRebindOnNextCall = false;\r\n        }\r\n    }\r\n\r\n    protected _mustRebind(scene: Scene, effect: Effect, visibility: number = 1) {\r\n        return scene.isCachedMaterialInvalid(this, effect, visibility);\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean) {\r\n        this._activeEffect = undefined;\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\r\n    }\r\n}\r\n"],"mappings":"AAEA,SAASA,MAAM,QAAQ,yBAAuB;AAG9C,SAASC,QAAQ,QAAQ,0BAAwB;AAGjD;;;;AAIA,OAAM,MAAOC,YAAa,SAAQD,QAAQ;EAKtCE,YAAYC,IAAY,EAAEC,KAAa,EAAEC,sBAAsB,GAAG,IAAI;IAClE,KAAK,CAACF,IAAI,EAAEC,KAAK,CAAC;IAHZ,KAAAE,aAAa,GAAW,IAAIP,MAAM,EAAE;IAI1C,IAAI,CAACQ,uBAAuB,GAAGF,sBAAsB;EACzD;EAEOG,SAASA,CAAA;IACZ,OAAO,IAAI,CAACD,uBAAuB,GAAG,IAAI,CAACE,aAAc,GAAG,KAAK,CAACD,SAAS,EAAG;EAClF;EAEOE,OAAOA,CAACC,IAAmB,EAAEC,YAAsB;IACtD,IAAI,CAACD,IAAI,EAAE;MACP,OAAO,KAAK;;IAGhB,IAAI,CAAC,IAAI,CAACJ,uBAAuB,EAAE;MAC/B,OAAO,IAAI;;IAGf,IAAI,CAACI,IAAI,CAACE,SAAS,IAAIF,IAAI,CAACE,SAAS,CAACC,MAAM,KAAK,CAAC,EAAE;MAChD,OAAO,IAAI;;IAGf,OAAO,IAAI,CAACC,iBAAiB,CAACJ,IAAI,EAAEA,IAAI,CAACE,SAAS,CAAC,CAAC,CAAC,EAAED,YAAY,CAAC;EACxE;EAEUI,kBAAkBA,CAACC,OAAgB;IACzC,MAAMC,OAAO,GAAGD,OAAO,CAACE,eAAe;IACvC,IAAI,CAAC,IAAI,CAACC,qBAAqB,IAAIH,OAAO,CAACI,MAAM,IAAIH,OAAO,EAAE;MAC1D,IAAIA,OAAO,CAACI,SAAS,KAAK,IAAI,CAACC,QAAQ,EAAE,CAACC,WAAW,EAAE,EAAE;QACrD,OAAO,IAAI;;;IAInB,OAAO,KAAK;EAChB;EAEA;;;;;EAKOC,mBAAmBA,CAACC,KAAa;IACpC,IAAI,CAACjB,aAAc,CAACkB,SAAS,CAAC,OAAO,EAAED,KAAK,CAAC;EACjD;EAEA;;;;;EAKOE,oBAAoBA,CAACC,YAAoB;IAC5C,IAAI,CAACpB,aAAc,CAACkB,SAAS,CAAC,cAAc,EAAEE,YAAY,CAAC;EAC/D;EAEOC,IAAIA,CAACJ,KAAa,EAAEf,IAAW;IAClC,IAAI,CAACA,IAAI,EAAE;MACP;;IAGJ,IAAI,CAACoB,cAAc,CAACL,KAAK,EAAEf,IAAI,EAAEA,IAAI,CAACE,SAAS,CAAC,CAAC,CAAC,CAAC;EACvD;EAEUmB,UAAUA,CAACrB,IAAW,EAAEU,MAAA,GAA2B,IAAI;IAC7D,KAAK,CAACW,UAAU,CAACrB,IAAI,EAAEU,MAAM,CAAC;IAC9B,IAAI,CAACE,QAAQ,EAAE,CAACU,aAAa,GAAGZ,MAAM;IACtC,IAAIA,MAAM,EAAE;MACRA,MAAM,CAACa,sBAAsB,GAAG,KAAK;;EAE7C;EAEUC,WAAWA,CAAC/B,KAAY,EAAEiB,MAAc,EAAEe,UAAA,GAAqB,CAAC;IACtE,OAAOhC,KAAK,CAACiC,uBAAuB,CAAC,IAAI,EAAEhB,MAAM,EAAEe,UAAU,CAAC;EAClE;EAEOE,OAAOA,CAACC,kBAA4B,EAAEC,oBAA8B,EAAEC,cAAwB;IACjG,IAAI,CAAChC,aAAa,GAAGiC,SAAS;IAC9B,KAAK,CAACJ,OAAO,CAACC,kBAAkB,EAAEC,oBAAoB,EAAEC,cAAc,CAAC;EAC3E"},"metadata":{},"sourceType":"module","externalDependencies":[]}