{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Matrix } from \"../../Maths/math.vector.js\";\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture.js\";\nimport { ShaderMaterial } from \"../../Materials/shaderMaterial.js\";\nimport \"../../Shaders/velocity.fragment.js\";\nimport \"../../Shaders/velocity.vertex.js\";\n/**\n * Used for Space Warp render process\n */\nexport class XRSpaceWarpRenderTarget extends RenderTargetTexture {\n  /**\n   * Creates a Space Warp render target\n   * @param motionVectorTexture WebGLTexture provided by WebGLSubImage\n   * @param depthStencilTexture WebGLTexture provided by WebGLSubImage\n   * @param scene scene used with the render target\n   * @param size the size of the render target (used for each view)\n   */\n  constructor(motionVectorTexture, depthStencilTexture, scene, size = 512) {\n    super(\"spacewarp rtt\", size, scene, false, true, 2, false, undefined, false, false, true, undefined, true);\n    this._originalPairing = [];\n    this._previousWorldMatrices = [];\n    this._previousTransforms = [Matrix.Identity(), Matrix.Identity()];\n    this._renderTarget = this.getScene().getEngine().createMultiviewRenderTargetTexture(this.getRenderWidth(), this.getRenderHeight(), motionVectorTexture, depthStencilTexture);\n    this._renderTarget._disposeOnlyFramebuffers = true;\n    this._texture = this._renderTarget.texture;\n    this._texture.isMultiview = true;\n    this._texture.format = 5;\n    if (scene) {\n      this._velocityMaterial = new ShaderMaterial(\"velocity shader material\", scene, {\n        vertex: \"velocity\",\n        fragment: \"velocity\"\n      }, {\n        uniforms: [\"world\", \"previousWorld\", \"viewProjection\", \"viewProjectionR\", \"previousViewProjection\", \"previousViewProjectionR\"]\n      });\n      this._velocityMaterial._materialHelperNeedsPreviousMatrices = true;\n      this._velocityMaterial.onBindObservable.add(mesh => {\n        // mesh. getWorldMatrix can be incorrect under rare conditions (e.g. when using a effective mesh in the render function).\n        // If the case arise that will require changing it we will need to change the bind process in the material class to also provide the world matrix as a parameter\n        this._previousWorldMatrices[mesh.uniqueId] = this._previousWorldMatrices[mesh.uniqueId] || mesh.getWorldMatrix();\n        this._velocityMaterial.getEffect().setMatrix(\"previousWorld\", this._previousWorldMatrices[mesh.uniqueId]);\n        this._previousWorldMatrices[mesh.uniqueId] = mesh.getWorldMatrix();\n        // now set the scene's previous matrix\n        this._velocityMaterial.getEffect().setMatrix(\"previousViewProjection\", this._previousTransforms[0]);\n        // multiview for sure\n        this._velocityMaterial.getEffect().setMatrix(\"previousViewProjectionR\", this._previousTransforms[1]);\n        // store the previous (current, to be exact) transforms\n        this._previousTransforms[0].copyFrom(scene.getTransformMatrix());\n        this._previousTransforms[1].copyFrom(scene._transformMatrixR);\n      });\n      this._velocityMaterial.freeze();\n    }\n  }\n  /**\n   * {@inheritDoc}\n   */\n  render(useCameraPostProcess = false, dumpForDebug = false) {\n    // Swap to use velocity material\n    this._originalPairing.length = 0;\n    const scene = this.getScene();\n    // set the velocity material to render the velocity RTT\n    if (scene && this._velocityMaterial) {\n      scene.getActiveMeshes().forEach(mesh => {\n        this._originalPairing.push([mesh, mesh.material]);\n        mesh.material = this._velocityMaterial;\n      });\n    }\n    super.render(useCameraPostProcess, dumpForDebug);\n    // Restore original materials\n    this._originalPairing.forEach(tuple => {\n      tuple[0].material = tuple[1];\n    });\n  }\n  /**\n   * @internal\n   */\n  _bindFrameBuffer() {\n    if (!this._renderTarget) {\n      return;\n    }\n    this.getScene().getEngine().bindSpaceWarpFramebuffer(this._renderTarget);\n  }\n  /**\n   * Gets the number of views the corresponding to the texture (eg. a SpaceWarpRenderTarget will have > 1)\n   * @returns the view count\n   */\n  getViewCount() {\n    return 2;\n  }\n  /**\n   * {@inheritdoc}\n   */\n  dispose() {\n    super.dispose();\n    this._velocityMaterial.dispose();\n    this._previousTransforms.length = 0;\n    this._previousWorldMatrices.length = 0;\n    this._originalPairing.length = 0;\n  }\n}\n/**\n * WebXR Space Warp Render Target Texture Provider\n */\nexport class WebXRSpaceWarpRenderTargetTextureProvider {\n  constructor(_scene, _xrSessionManager, _xrWebGLBinding) {\n    this._scene = _scene;\n    this._xrSessionManager = _xrSessionManager;\n    this._xrWebGLBinding = _xrWebGLBinding;\n    this._lastSubImages = new Map();\n    this._renderTargetTextures = new Map();\n    this._engine = _scene.getEngine();\n  }\n  _getSubImageForView(view) {\n    const layerWrapper = this._xrSessionManager._getBaseLayerWrapper();\n    if (!layerWrapper) {\n      throw new Error(\"For Space Warp, the base layer should be a WebXR Projection Layer.\");\n    }\n    if (layerWrapper.layerType !== \"XRProjectionLayer\") {\n      throw new Error('For Space Warp, the base layer type should \"XRProjectionLayer\".');\n    }\n    const layer = layerWrapper.layer;\n    return this._xrWebGLBinding.getViewSubImage(layer, view);\n  }\n  _setViewportForSubImage(viewport, subImage) {\n    viewport.x = 0;\n    viewport.y = 0;\n    viewport.width = subImage.motionVectorTextureWidth;\n    viewport.height = subImage.motionVectorTextureHeight;\n  }\n  _createRenderTargetTexture(width, height, framebuffer, motionVectorTexture, depthStencilTexture) {\n    if (!this._engine) {\n      throw new Error(\"Engine is disposed\");\n    }\n    const textureSize = {\n      width,\n      height\n    };\n    // Create render target texture from the internal texture\n    const renderTargetTexture = new XRSpaceWarpRenderTarget(motionVectorTexture, depthStencilTexture, this._scene, textureSize);\n    const renderTargetWrapper = renderTargetTexture.renderTarget;\n    if (framebuffer) {\n      renderTargetWrapper._framebuffer = framebuffer;\n    }\n    // Create internal texture\n    renderTargetWrapper._colorTextureArray = motionVectorTexture;\n    renderTargetWrapper._depthStencilTextureArray = depthStencilTexture;\n    renderTargetTexture.disableRescaling();\n    renderTargetTexture.renderListPredicate = () => true;\n    return renderTargetTexture;\n  }\n  _getRenderTargetForSubImage(subImage, view) {\n    const lastSubImage = this._lastSubImages.get(view);\n    let renderTargetTexture = this._renderTargetTextures.get(view.eye);\n    const width = subImage.motionVectorTextureWidth;\n    const height = subImage.motionVectorTextureHeight;\n    if (!renderTargetTexture || (lastSubImage === null || lastSubImage === void 0 ? void 0 : lastSubImage.textureWidth) !== width || (lastSubImage === null || lastSubImage === void 0 ? void 0 : lastSubImage.textureHeight) != height) {\n      renderTargetTexture = this._createRenderTargetTexture(width, height, null, subImage.motionVectorTexture, subImage.depthStencilTexture);\n      this._renderTargetTextures.set(view.eye, renderTargetTexture);\n      this._framebufferDimensions = {\n        framebufferWidth: width,\n        framebufferHeight: height\n      };\n    }\n    this._lastSubImages.set(view, subImage);\n    return renderTargetTexture;\n  }\n  /**\n   * {@inheritDoc}\n   */\n  trySetViewportForView(viewport, view) {\n    const subImage = this._lastSubImages.get(view) || this._getSubImageForView(view);\n    if (subImage) {\n      this._setViewportForSubImage(viewport, subImage);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Access the motion vector (which will turn on Space Warp)\n   * @param view the view to access the motion vector texture for\n   */\n  accessMotionVector(view) {\n    const subImage = this._getSubImageForView(view);\n    if (subImage) {\n      // Meta Quest Browser uses accessing these textures as a sign for turning on Space Warp\n      subImage.motionVectorTexture;\n      subImage.depthStencilTexture;\n    }\n  }\n  /**\n   * {@inheritDoc}\n   */\n  getRenderTargetTextureForEye(_eye) {\n    return null;\n  }\n  /**\n   * {@inheritDoc}\n   */\n  getRenderTargetTextureForView(view) {\n    const subImage = this._getSubImageForView(view);\n    if (subImage) {\n      return this._getRenderTargetForSubImage(subImage, view);\n    }\n    return null;\n  }\n  /**\n   * {@inheritDoc}\n   */\n  dispose() {\n    this._renderTargetTextures.forEach(rtt => rtt.dispose());\n    this._renderTargetTextures.clear();\n  }\n}\n/**\n * the WebXR Space Warp feature.\n */\nexport class WebXRSpaceWarp extends WebXRAbstractFeature {\n  /**\n   * constructor for the space warp feature\n   * @param _xrSessionManager the xr session manager for this feature\n   */\n  constructor(_xrSessionManager) {\n    super(_xrSessionManager);\n    this._onAfterRenderObserver = null;\n    /**\n     * {@inheritdoc}\n     */\n    this.dependsOn = [WebXRFeatureName.LAYERS];\n    this.xrNativeFeatureName = \"space-warp\";\n    this._xrSessionManager.scene.needsPreviousWorldMatrices = true;\n  }\n  /**\n   * Attach this feature.\n   * Will usually be called by the features manager.\n   *\n   * @returns true if successful.\n   */\n  attach() {\n    if (!super.attach()) {\n      return false;\n    }\n    const engine = this._xrSessionManager.scene.getEngine();\n    this._glContext = engine._gl;\n    this._xrWebGLBinding = new XRWebGLBinding(this._xrSessionManager.session, this._glContext);\n    this.spaceWarpRTTProvider = new WebXRSpaceWarpRenderTargetTextureProvider(this._xrSessionManager.scene, this._xrSessionManager, this._xrWebGLBinding);\n    this._onAfterRenderObserver = this._xrSessionManager.scene.onAfterRenderObservable.add(() => this._onAfterRender());\n    return true;\n  }\n  detach() {\n    this._xrSessionManager.scene.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n    return super.detach();\n  }\n  _onAfterRender() {\n    if (this.attached && this._renderTargetTexture) {\n      this._renderTargetTexture.render(false, false);\n    }\n  }\n  /**\n   * {@inheritdoc}\n   */\n  isCompatible() {\n    return this._xrSessionManager.scene.getEngine().getCaps().colorBufferHalfFloat || false;\n  }\n  /**\n   * {@inheritdoc}\n   */\n  dispose() {\n    super.dispose();\n  }\n  _onXRFrame(_xrFrame) {\n    const pose = _xrFrame.getViewerPose(this._xrSessionManager.referenceSpace);\n    if (!pose) {\n      return;\n    }\n    // get the first view to which we will create a texture (or update it)\n    const view = pose.views[0];\n    this._renderTargetTexture = this._renderTargetTexture || this.spaceWarpRTTProvider.getRenderTargetTextureForView(view);\n    this.spaceWarpRTTProvider.accessMotionVector(view);\n  }\n}\n/**\n * The module's name\n */\nWebXRSpaceWarp.Name = WebXRFeatureName.SPACE_WARP;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRSpaceWarp.Version = 1;\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRSpaceWarp.Name, xrSessionManager => {\n  return () => new WebXRSpaceWarp(xrSessionManager);\n}, WebXRSpaceWarp.Version, false);","map":{"version":3,"names":["WebXRFeatureName","WebXRFeaturesManager","WebXRAbstractFeature","Matrix","RenderTargetTexture","ShaderMaterial","XRSpaceWarpRenderTarget","constructor","motionVectorTexture","depthStencilTexture","scene","size","undefined","_originalPairing","_previousWorldMatrices","_previousTransforms","Identity","_renderTarget","getScene","getEngine","createMultiviewRenderTargetTexture","getRenderWidth","getRenderHeight","_disposeOnlyFramebuffers","_texture","texture","isMultiview","format","_velocityMaterial","vertex","fragment","uniforms","_materialHelperNeedsPreviousMatrices","onBindObservable","add","mesh","uniqueId","getWorldMatrix","getEffect","setMatrix","copyFrom","getTransformMatrix","_transformMatrixR","freeze","render","useCameraPostProcess","dumpForDebug","length","getActiveMeshes","forEach","push","material","tuple","_bindFrameBuffer","bindSpaceWarpFramebuffer","getViewCount","dispose","WebXRSpaceWarpRenderTargetTextureProvider","_scene","_xrSessionManager","_xrWebGLBinding","_lastSubImages","Map","_renderTargetTextures","_engine","_getSubImageForView","view","layerWrapper","_getBaseLayerWrapper","Error","layerType","layer","getViewSubImage","_setViewportForSubImage","viewport","subImage","x","y","width","motionVectorTextureWidth","height","motionVectorTextureHeight","_createRenderTargetTexture","framebuffer","textureSize","renderTargetTexture","renderTargetWrapper","renderTarget","_framebuffer","_colorTextureArray","_depthStencilTextureArray","disableRescaling","renderListPredicate","_getRenderTargetForSubImage","lastSubImage","get","eye","textureWidth","textureHeight","set","_framebufferDimensions","framebufferWidth","framebufferHeight","trySetViewportForView","accessMotionVector","getRenderTargetTextureForEye","_eye","getRenderTargetTextureForView","rtt","clear","WebXRSpaceWarp","_onAfterRenderObserver","dependsOn","LAYERS","xrNativeFeatureName","needsPreviousWorldMatrices","attach","engine","_glContext","_gl","XRWebGLBinding","session","spaceWarpRTTProvider","onAfterRenderObservable","_onAfterRender","detach","remove","attached","_renderTargetTexture","isCompatible","getCaps","colorBufferHalfFloat","_onXRFrame","_xrFrame","pose","getViewerPose","referenceSpace","views","Name","SPACE_WARP","Version","AddWebXRFeature","xrSessionManager"],"sources":["../../../../../dev/core/src/XR/features/WebXRSpaceWarp.ts"],"sourcesContent":["import type { Engine } from \"../../Engines/engine\";\r\nimport type { WebGLRenderTargetWrapper } from \"../../Engines/WebGL/webGLRenderTargetWrapper\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IWebXRRenderTargetTextureProvider } from \"../webXRRenderTargetTextureProvider\";\r\nimport type { Viewport } from \"../../Maths/math.viewport\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { ShaderMaterial } from \"../../Materials/shaderMaterial\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Material } from \"../../Materials/material\";\r\n\r\nimport \"../../Shaders/velocity.fragment\";\r\nimport \"../../Shaders/velocity.vertex\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\n\r\n/**\r\n * Used for Space Warp render process\r\n */\r\nexport class XRSpaceWarpRenderTarget extends RenderTargetTexture {\r\n    private _velocityMaterial: ShaderMaterial;\r\n    private _originalPairing: Array<[AbstractMesh, Nullable<Material>]> = [];\r\n    private _previousWorldMatrices: Array<Matrix> = [];\r\n    private _previousTransforms: Matrix[] = [Matrix.Identity(), Matrix.Identity()];\r\n\r\n    /**\r\n     * Creates a Space Warp render target\r\n     * @param motionVectorTexture WebGLTexture provided by WebGLSubImage\r\n     * @param depthStencilTexture WebGLTexture provided by WebGLSubImage\r\n     * @param scene scene used with the render target\r\n     * @param size the size of the render target (used for each view)\r\n     */\r\n    constructor(motionVectorTexture: WebGLTexture, depthStencilTexture: WebGLTexture, scene?: Scene, size: number | { width: number; height: number } | { ratio: number } = 512) {\r\n        super(\"spacewarp rtt\", size, scene, false, true, Constants.TEXTURETYPE_HALF_FLOAT, false, undefined, false, false, true, undefined, true);\r\n        this._renderTarget = this.getScene()!\r\n            .getEngine()\r\n            .createMultiviewRenderTargetTexture(this.getRenderWidth(), this.getRenderHeight(), motionVectorTexture, depthStencilTexture);\r\n        (this._renderTarget as WebGLRenderTargetWrapper)._disposeOnlyFramebuffers = true;\r\n        this._texture = this._renderTarget.texture!;\r\n        this._texture.isMultiview = true;\r\n        this._texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n\r\n        if (scene) {\r\n            this._velocityMaterial = new ShaderMaterial(\r\n                \"velocity shader material\",\r\n                scene,\r\n                {\r\n                    vertex: \"velocity\",\r\n                    fragment: \"velocity\",\r\n                },\r\n                {\r\n                    uniforms: [\"world\", \"previousWorld\", \"viewProjection\", \"viewProjectionR\", \"previousViewProjection\", \"previousViewProjectionR\"],\r\n                }\r\n            );\r\n            this._velocityMaterial._materialHelperNeedsPreviousMatrices = true;\r\n            this._velocityMaterial.onBindObservable.add((mesh) => {\r\n                // mesh. getWorldMatrix can be incorrect under rare conditions (e.g. when using a effective mesh in the render function).\r\n                // If the case arise that will require changing it we will need to change the bind process in the material class to also provide the world matrix as a parameter\r\n                this._previousWorldMatrices[mesh.uniqueId] = this._previousWorldMatrices[mesh.uniqueId] || mesh.getWorldMatrix();\r\n                this._velocityMaterial.getEffect().setMatrix(\"previousWorld\", this._previousWorldMatrices[mesh.uniqueId]);\r\n                this._previousWorldMatrices[mesh.uniqueId] = mesh.getWorldMatrix();\r\n                // now set the scene's previous matrix\r\n                this._velocityMaterial.getEffect().setMatrix(\"previousViewProjection\", this._previousTransforms[0]);\r\n                // multiview for sure\r\n                this._velocityMaterial.getEffect().setMatrix(\"previousViewProjectionR\", this._previousTransforms[1]);\r\n\r\n                // store the previous (current, to be exact) transforms\r\n                this._previousTransforms[0].copyFrom(scene.getTransformMatrix());\r\n                this._previousTransforms[1].copyFrom(scene._transformMatrixR);\r\n            });\r\n            this._velocityMaterial.freeze();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * {@inheritDoc}\r\n     */\r\n    public render(useCameraPostProcess: boolean = false, dumpForDebug: boolean = false): void {\r\n        // Swap to use velocity material\r\n        this._originalPairing.length = 0;\r\n        const scene = this.getScene();\r\n        // set the velocity material to render the velocity RTT\r\n        if (scene && this._velocityMaterial) {\r\n            scene.getActiveMeshes().forEach((mesh) => {\r\n                this._originalPairing.push([mesh, mesh.material]);\r\n                mesh.material = this._velocityMaterial;\r\n            });\r\n        }\r\n\r\n        super.render(useCameraPostProcess, dumpForDebug);\r\n\r\n        // Restore original materials\r\n        this._originalPairing.forEach((tuple) => {\r\n            tuple[0].material = tuple[1];\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bindFrameBuffer() {\r\n        if (!this._renderTarget) {\r\n            return;\r\n        }\r\n        this.getScene()!.getEngine().bindSpaceWarpFramebuffer(this._renderTarget);\r\n    }\r\n\r\n    /**\r\n     * Gets the number of views the corresponding to the texture (eg. a SpaceWarpRenderTarget will have > 1)\r\n     * @returns the view count\r\n     */\r\n    public getViewCount() {\r\n        return 2;\r\n    }\r\n\r\n    /**\r\n     * {@inheritdoc}\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this._velocityMaterial.dispose();\r\n        this._previousTransforms.length = 0;\r\n        this._previousWorldMatrices.length = 0;\r\n        this._originalPairing.length = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * WebXR Space Warp Render Target Texture Provider\r\n */\r\nexport class WebXRSpaceWarpRenderTargetTextureProvider implements IWebXRRenderTargetTextureProvider {\r\n    protected _lastSubImages = new Map<XRView, XRWebGLSubImage>();\r\n    protected _renderTargetTextures = new Map<XREye, RenderTargetTexture>();\r\n    protected _framebufferDimensions: Nullable<{ framebufferWidth: number; framebufferHeight: number }>;\r\n    protected _engine: Engine;\r\n\r\n    constructor(protected readonly _scene: Scene, protected readonly _xrSessionManager: WebXRSessionManager, protected readonly _xrWebGLBinding: XRWebGLBinding) {\r\n        this._engine = _scene.getEngine();\r\n    }\r\n\r\n    private _getSubImageForView(view: XRView): XRWebGLSubImage {\r\n        const layerWrapper = this._xrSessionManager._getBaseLayerWrapper();\r\n        if (!layerWrapper) {\r\n            throw new Error(\"For Space Warp, the base layer should be a WebXR Projection Layer.\");\r\n        }\r\n        if (layerWrapper.layerType !== \"XRProjectionLayer\") {\r\n            throw new Error('For Space Warp, the base layer type should \"XRProjectionLayer\".');\r\n        }\r\n        const layer = layerWrapper.layer as XRProjectionLayer;\r\n        return this._xrWebGLBinding.getViewSubImage(layer, view);\r\n    }\r\n\r\n    protected _setViewportForSubImage(viewport: Viewport, subImage: XRWebGLSubImage) {\r\n        viewport.x = 0;\r\n        viewport.y = 0;\r\n        viewport.width = subImage.motionVectorTextureWidth!;\r\n        viewport.height = subImage.motionVectorTextureHeight!;\r\n    }\r\n\r\n    protected _createRenderTargetTexture(\r\n        width: number,\r\n        height: number,\r\n        framebuffer: Nullable<WebGLFramebuffer>,\r\n        motionVectorTexture: WebGLTexture,\r\n        depthStencilTexture: WebGLTexture\r\n    ): RenderTargetTexture {\r\n        if (!this._engine) {\r\n            throw new Error(\"Engine is disposed\");\r\n        }\r\n\r\n        const textureSize = { width, height };\r\n\r\n        // Create render target texture from the internal texture\r\n        const renderTargetTexture = new XRSpaceWarpRenderTarget(motionVectorTexture, depthStencilTexture, this._scene, textureSize);\r\n        const renderTargetWrapper = renderTargetTexture.renderTarget as WebGLRenderTargetWrapper;\r\n        if (framebuffer) {\r\n            renderTargetWrapper._framebuffer = framebuffer;\r\n        }\r\n\r\n        // Create internal texture\r\n        renderTargetWrapper._colorTextureArray = motionVectorTexture;\r\n        renderTargetWrapper._depthStencilTextureArray = depthStencilTexture;\r\n\r\n        renderTargetTexture.disableRescaling();\r\n        renderTargetTexture.renderListPredicate = () => true;\r\n\r\n        return renderTargetTexture;\r\n    }\r\n\r\n    protected _getRenderTargetForSubImage(subImage: XRWebGLSubImage, view: XRView) {\r\n        const lastSubImage = this._lastSubImages.get(view);\r\n        let renderTargetTexture = this._renderTargetTextures.get(view.eye);\r\n\r\n        const width = subImage.motionVectorTextureWidth!;\r\n        const height = subImage.motionVectorTextureHeight!;\r\n\r\n        if (!renderTargetTexture || lastSubImage?.textureWidth !== width || lastSubImage?.textureHeight != height) {\r\n            renderTargetTexture = this._createRenderTargetTexture(width, height, null, subImage.motionVectorTexture!, subImage.depthStencilTexture!);\r\n            this._renderTargetTextures.set(view.eye, renderTargetTexture);\r\n\r\n            this._framebufferDimensions = {\r\n                framebufferWidth: width,\r\n                framebufferHeight: height,\r\n            };\r\n        }\r\n\r\n        this._lastSubImages.set(view, subImage);\r\n\r\n        return renderTargetTexture;\r\n    }\r\n\r\n    /**\r\n     * {@inheritDoc}\r\n     */\r\n    public trySetViewportForView(viewport: Viewport, view: XRView): boolean {\r\n        const subImage = this._lastSubImages.get(view) || this._getSubImageForView(view);\r\n        if (subImage) {\r\n            this._setViewportForSubImage(viewport, subImage);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Access the motion vector (which will turn on Space Warp)\r\n     * @param view the view to access the motion vector texture for\r\n     */\r\n    public accessMotionVector(view: XRView): void {\r\n        const subImage = this._getSubImageForView(view);\r\n        if (subImage) {\r\n            // Meta Quest Browser uses accessing these textures as a sign for turning on Space Warp\r\n            subImage.motionVectorTexture;\r\n            subImage.depthStencilTexture;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * {@inheritDoc}\r\n     */\r\n    public getRenderTargetTextureForEye(_eye: XREye): Nullable<RenderTargetTexture> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * {@inheritDoc}\r\n     */\r\n    public getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture> {\r\n        const subImage = this._getSubImageForView(view);\r\n        if (subImage) {\r\n            return this._getRenderTargetForSubImage(subImage, view);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * {@inheritDoc}\r\n     */\r\n    public dispose() {\r\n        this._renderTargetTextures.forEach((rtt) => rtt.dispose());\r\n        this._renderTargetTextures.clear();\r\n    }\r\n}\r\n\r\n/**\r\n * the WebXR Space Warp feature.\r\n */\r\nexport class WebXRSpaceWarp extends WebXRAbstractFeature {\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.SPACE_WARP;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * The space warp provider\r\n     */\r\n    public spaceWarpRTTProvider: Nullable<WebXRSpaceWarpRenderTargetTextureProvider>;\r\n    private _glContext: WebGLRenderingContext | WebGL2RenderingContext;\r\n    private _xrWebGLBinding: XRWebGLBinding;\r\n    private _renderTargetTexture: Nullable<RenderTargetTexture>;\r\n    private _onAfterRenderObserver: Nullable<Observer<Scene>> = null;\r\n\r\n    /**\r\n     * constructor for the space warp feature\r\n     * @param _xrSessionManager the xr session manager for this feature\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"space-warp\";\r\n        this._xrSessionManager.scene.needsPreviousWorldMatrices = true;\r\n    }\r\n\r\n    /**\r\n     * Attach this feature.\r\n     * Will usually be called by the features manager.\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        const engine = this._xrSessionManager.scene.getEngine();\r\n        this._glContext = engine._gl;\r\n        this._xrWebGLBinding = new XRWebGLBinding(this._xrSessionManager.session, this._glContext);\r\n\r\n        this.spaceWarpRTTProvider = new WebXRSpaceWarpRenderTargetTextureProvider(this._xrSessionManager.scene, this._xrSessionManager, this._xrWebGLBinding);\r\n\r\n        this._onAfterRenderObserver = this._xrSessionManager.scene.onAfterRenderObservable.add(() => this._onAfterRender());\r\n\r\n        return true;\r\n    }\r\n\r\n    public detach(): boolean {\r\n        this._xrSessionManager.scene.onAfterRenderObservable.remove(this._onAfterRenderObserver);\r\n        return super.detach();\r\n    }\r\n\r\n    private _onAfterRender(): void {\r\n        if (this.attached && this._renderTargetTexture) {\r\n            this._renderTargetTexture.render(false, false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * {@inheritdoc}\r\n     */\r\n    public dependsOn: string[] = [WebXRFeatureName.LAYERS];\r\n\r\n    /**\r\n     * {@inheritdoc}\r\n     */\r\n    public isCompatible(): boolean {\r\n        return this._xrSessionManager.scene.getEngine().getCaps().colorBufferHalfFloat || false;\r\n    }\r\n\r\n    /**\r\n     * {@inheritdoc}\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame): void {\r\n        const pose = _xrFrame.getViewerPose(this._xrSessionManager.referenceSpace);\r\n        if (!pose) {\r\n            return;\r\n        }\r\n\r\n        // get the first view to which we will create a texture (or update it)\r\n        const view = pose.views[0];\r\n        this._renderTargetTexture = this._renderTargetTexture || this.spaceWarpRTTProvider!.getRenderTargetTextureForView(view);\r\n        this.spaceWarpRTTProvider!.accessMotionVector(view);\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRSpaceWarp.Name,\r\n    (xrSessionManager) => {\r\n        return () => new WebXRSpaceWarp(xrSessionManager);\r\n    },\r\n    WebXRSpaceWarp.Version,\r\n    false\r\n);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}