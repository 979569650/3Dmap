{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { MaterialHelper } from \"../Materials/materialHelper.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport \"../Shaders/depth.fragment.js\";\nimport \"../Shaders/depth.vertex.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper.js\";\n/**\n * This represents a depth renderer in Babylon.\n * A depth renderer will render to it's depth map every frame which can be displayed or used in post processing\n */\nexport class DepthRenderer {\n  /**\n   * Sets a specific material to be used to render a mesh/a list of meshes by the depth renderer\n   * @param mesh mesh or array of meshes\n   * @param material material to use by the depth render when rendering the mesh(es). If undefined is passed, the specific material created by the depth renderer will be used.\n   */\n  setMaterialForRendering(mesh, material) {\n    this._depthMap.setMaterialForRendering(mesh, material);\n  }\n  /**\n   * Instantiates a depth renderer\n   * @param scene The scene the renderer belongs to\n   * @param type The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)\n   * @param camera The camera to be used to render the depth map (default: scene's active camera)\n   * @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z\n   * @param samplingMode The sampling mode to be used with the render target (Linear, Nearest...) (default: TRILINEAR_SAMPLINGMODE)\n   * @param storeCameraSpaceZ Defines whether the depth stored is the Z coordinate in camera space. If true, storeNonLinearDepth has no effect. (Default: false)\n   * @param name Name of the render target (default: DepthRenderer)\n   */\n  constructor(scene, type = 1, camera = null, storeNonLinearDepth = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, storeCameraSpaceZ = false, name) {\n    /** Enable or disable the depth renderer. When disabled, the depth texture is not updated */\n    this.enabled = true;\n    /** Force writing the transparent objects into the depth map */\n    this.forceDepthWriteTransparentMeshes = false;\n    /**\n     * Specifies that the depth renderer will only be used within\n     * the camera it is created for.\n     * This can help forcing its rendering during the camera processing.\n     */\n    this.useOnlyInActiveCamera = false;\n    /** If true, reverse the culling of materials before writing to the depth texture.\n     * So, basically, when \"true\", back facing instead of front facing faces are rasterized into the texture\n     */\n    this.reverseCulling = false;\n    this._scene = scene;\n    this._storeNonLinearDepth = storeNonLinearDepth;\n    this._storeCameraSpaceZ = storeCameraSpaceZ;\n    this.isPacked = type === 0;\n    if (this.isPacked) {\n      this.clearColor = new Color4(1.0, 1.0, 1.0, 1.0);\n    } else {\n      this.clearColor = new Color4(storeCameraSpaceZ ? 1e8 : 1.0, 0.0, 0.0, 1.0);\n    }\n    DepthRenderer._SceneComponentInitialization(this._scene);\n    const engine = scene.getEngine();\n    this._camera = camera;\n    if (samplingMode !== Texture.NEAREST_SAMPLINGMODE) {\n      if (type === 1 && !engine._caps.textureFloatLinearFiltering) {\n        samplingMode = Texture.NEAREST_SAMPLINGMODE;\n      }\n      if (type === 2 && !engine._caps.textureHalfFloatLinearFiltering) {\n        samplingMode = Texture.NEAREST_SAMPLINGMODE;\n      }\n    }\n    // Render target\n    const format = this.isPacked || !engine._features.supportExtendedTextureFormats ? 5 : 6;\n    this._depthMap = new RenderTargetTexture(name !== null && name !== void 0 ? name : \"DepthRenderer\", {\n      width: engine.getRenderWidth(),\n      height: engine.getRenderHeight()\n    }, this._scene, false, true, type, false, samplingMode, undefined, undefined, undefined, format);\n    this._depthMap.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._depthMap.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._depthMap.refreshRate = 1;\n    this._depthMap.renderParticles = false;\n    this._depthMap.renderList = null;\n    this._depthMap.noPrePassRenderer = true;\n    // Camera to get depth map from to support multiple concurrent cameras\n    this._depthMap.activeCamera = this._camera;\n    this._depthMap.ignoreCameraViewport = true;\n    this._depthMap.useCameraPostProcesses = false;\n    // set default depth value to 1.0 (far away)\n    this._depthMap.onClearObservable.add(engine => {\n      engine.clear(this.clearColor, true, true, true);\n    });\n    this._depthMap.onBeforeBindObservable.add(() => {\n      var _a;\n      (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, \"depth renderer\", 1);\n    });\n    this._depthMap.onAfterUnbindObservable.add(() => {\n      var _a;\n      (_a = engine._debugPopGroup) === null || _a === void 0 ? void 0 : _a.call(engine, 1);\n    });\n    this._depthMap.customIsReadyFunction = (mesh, refreshRate, preWarm) => {\n      if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\n        for (let i = 0; i < mesh.subMeshes.length; ++i) {\n          const subMesh = mesh.subMeshes[i];\n          const renderingMesh = subMesh.getRenderingMesh();\n          const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n          const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined || renderingMesh.hasThinInstances);\n          if (!this.isReady(subMesh, hardwareInstancedRendering)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    };\n    // Custom render function\n    const renderSubMesh = subMesh => {\n      var _a, _b;\n      const renderingMesh = subMesh.getRenderingMesh();\n      const effectiveMesh = subMesh.getEffectiveMesh();\n      const scene = this._scene;\n      const engine = scene.getEngine();\n      const material = subMesh.getMaterial();\n      effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n      if (!material || effectiveMesh.infiniteDistance || material.disableDepthWrite || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {\n        return;\n      }\n      // Culling\n      const detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;\n      let sideOrientation = (_a = renderingMesh.overrideMaterialSideOrientation) !== null && _a !== void 0 ? _a : material.sideOrientation;\n      if (detNeg) {\n        sideOrientation = sideOrientation === 0 ? 1 : 0;\n      }\n      const reverseSideOrientation = sideOrientation === 0;\n      engine.setState(material.backFaceCulling, 0, false, reverseSideOrientation, this.reverseCulling ? !material.cullBackFaces : material.cullBackFaces);\n      // Managing instances\n      const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n      if (batch.mustReturn) {\n        return;\n      }\n      const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined || renderingMesh.hasThinInstances);\n      const camera = this._camera || scene.activeCamera;\n      if (this.isReady(subMesh, hardwareInstancedRendering) && camera) {\n        subMesh._renderId = scene.getRenderId();\n        const renderingMaterial = (_b = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _b === void 0 ? void 0 : _b[engine.currentRenderPassId];\n        let drawWrapper = subMesh._getDrawWrapper();\n        if (!drawWrapper && renderingMaterial) {\n          drawWrapper = renderingMaterial._getDrawWrapper();\n        }\n        const cameraIsOrtho = camera.mode === Camera.ORTHOGRAPHIC_CAMERA;\n        if (!drawWrapper) {\n          return;\n        }\n        const effect = drawWrapper.effect;\n        engine.enableEffect(drawWrapper);\n        if (!hardwareInstancedRendering) {\n          renderingMesh._bind(subMesh, effect, material.fillMode);\n        }\n        if (!renderingMaterial) {\n          effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n          effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\n          if (this._storeCameraSpaceZ) {\n            effect.setMatrix(\"view\", scene.getViewMatrix());\n          }\n        } else {\n          renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh, subMesh);\n        }\n        let minZ, maxZ;\n        if (cameraIsOrtho) {\n          minZ = !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n          maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n        } else {\n          minZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? camera.minZ : engine.isNDCHalfZRange ? 0 : camera.minZ;\n          maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : camera.maxZ;\n        }\n        effect.setFloat2(\"depthValues\", minZ, minZ + maxZ);\n        if (!renderingMaterial) {\n          // Alpha test\n          if (material.needAlphaTesting()) {\n            const alphaTexture = material.getAlphaTestTexture();\n            if (alphaTexture) {\n              effect.setTexture(\"diffuseSampler\", alphaTexture);\n              effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n            }\n          }\n          // Bones\n          if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n            const skeleton = renderingMesh.skeleton;\n            if (skeleton.isUsingTextureForMatrices) {\n              const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\n              if (!boneTexture) {\n                return;\n              }\n              effect.setTexture(\"boneSampler\", boneTexture);\n              effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\n            } else {\n              effect.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\n            }\n          }\n          // Clip planes\n          bindClipPlane(effect, material, scene);\n          // Morph targets\n          MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);\n          if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\n            renderingMesh.morphTargetManager._bind(effect);\n          }\n        }\n        // Draw\n        renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) => effect.setMatrix(\"world\", world));\n      }\n    };\n    this._depthMap.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => {\n      let index;\n      if (depthOnlySubMeshes.length) {\n        for (index = 0; index < depthOnlySubMeshes.length; index++) {\n          renderSubMesh(depthOnlySubMeshes.data[index]);\n        }\n      }\n      for (index = 0; index < opaqueSubMeshes.length; index++) {\n        renderSubMesh(opaqueSubMeshes.data[index]);\n      }\n      for (index = 0; index < alphaTestSubMeshes.length; index++) {\n        renderSubMesh(alphaTestSubMeshes.data[index]);\n      }\n      if (this.forceDepthWriteTransparentMeshes) {\n        for (index = 0; index < transparentSubMeshes.length; index++) {\n          renderSubMesh(transparentSubMeshes.data[index]);\n        }\n      } else {\n        for (index = 0; index < transparentSubMeshes.length; index++) {\n          transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n        }\n      }\n    };\n  }\n  /**\n   * Creates the depth rendering effect and checks if the effect is ready.\n   * @param subMesh The submesh to be used to render the depth map of\n   * @param useInstances If multiple world instances should be used\n   * @returns if the depth renderer is ready to render the depth map\n   */\n  isReady(subMesh, useInstances) {\n    var _a;\n    const engine = this._scene.getEngine();\n    const mesh = subMesh.getMesh();\n    const scene = mesh.getScene();\n    const renderingMaterial = (_a = mesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a === void 0 ? void 0 : _a[engine.currentRenderPassId];\n    if (renderingMaterial) {\n      return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\n    }\n    const material = subMesh.getMaterial();\n    if (!material || material.disableDepthWrite) {\n      return false;\n    }\n    const defines = [];\n    const attribs = [VertexBuffer.PositionKind];\n    // Alpha test\n    if (material && material.needAlphaTesting() && material.getAlphaTestTexture()) {\n      defines.push(\"#define ALPHATEST\");\n      if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n        attribs.push(VertexBuffer.UVKind);\n        defines.push(\"#define UV1\");\n      }\n      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n        attribs.push(VertexBuffer.UV2Kind);\n        defines.push(\"#define UV2\");\n      }\n    }\n    // Bones\n    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n      if (mesh.numBoneInfluencers > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n      const skeleton = subMesh.getRenderingMesh().skeleton;\n      if (skeleton === null || skeleton === void 0 ? void 0 : skeleton.isUsingTextureForMatrices) {\n        defines.push(\"#define BONETEXTURE\");\n      }\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    }\n    // Morph targets\n    const morphTargetManager = mesh.morphTargetManager;\n    let numMorphInfluencers = 0;\n    if (morphTargetManager) {\n      if (morphTargetManager.numInfluencers > 0) {\n        numMorphInfluencers = morphTargetManager.numInfluencers;\n        defines.push(\"#define MORPHTARGETS\");\n        defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\n        if (morphTargetManager.isUsingTextureForTargets) {\n          defines.push(\"#define MORPHTARGETS_TEXTURE\");\n        }\n        MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\n      }\n    }\n    // Instances\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      MaterialHelper.PushAttributesForInstances(attribs);\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    }\n    // None linear depth\n    if (this._storeNonLinearDepth) {\n      defines.push(\"#define NONLINEARDEPTH\");\n    }\n    // Store camera space Z coordinate instead of NDC Z\n    if (this._storeCameraSpaceZ) {\n      defines.push(\"#define STORE_CAMERASPACE_Z\");\n    }\n    // Float Mode\n    if (this.isPacked) {\n      defines.push(\"#define PACKED\");\n    }\n    // Clip planes\n    prepareStringDefinesForClipPlanes(material, scene, defines);\n    // Get correct effect\n    const drawWrapper = subMesh._getDrawWrapper(undefined, true);\n    const cachedDefines = drawWrapper.defines;\n    const join = defines.join(\"\\n\");\n    if (cachedDefines !== join) {\n      const uniforms = [\"world\", \"mBones\", \"boneTextureWidth\", \"viewProjection\", \"view\", \"diffuseMatrix\", \"depthValues\", \"morphTargetInfluences\", \"morphTargetTextureInfo\", \"morphTargetTextureIndices\"];\n      addClipPlaneUniforms(uniforms);\n      drawWrapper.setEffect(engine.createEffect(\"depth\", attribs, uniforms, [\"diffuseSampler\", \"morphTargets\", \"boneSampler\"], join, undefined, undefined, undefined, {\n        maxSimultaneousMorphTargets: numMorphInfluencers\n      }), join);\n    }\n    return drawWrapper.effect.isReady();\n  }\n  /**\n   * Gets the texture which the depth map will be written to.\n   * @returns The depth map texture\n   */\n  getDepthMap() {\n    return this._depthMap;\n  }\n  /**\n   * Disposes of the depth renderer.\n   */\n  dispose() {\n    const keysToDelete = [];\n    for (const key in this._scene._depthRenderer) {\n      const depthRenderer = this._scene._depthRenderer[key];\n      if (depthRenderer === this) {\n        keysToDelete.push(key);\n      }\n    }\n    if (keysToDelete.length > 0) {\n      this._depthMap.dispose();\n      for (const key of keysToDelete) {\n        delete this._scene._depthRenderer[key];\n      }\n    }\n  }\n}\n/**\n * @internal\n */\nDepthRenderer._SceneComponentInitialization = _ => {\n  throw _WarnImport(\"DepthRendererSceneComponent\");\n};","map":{"version":3,"names":["Color4","VertexBuffer","Texture","RenderTargetTexture","MaterialHelper","Camera","_WarnImport","addClipPlaneUniforms","bindClipPlane","prepareStringDefinesForClipPlanes","DepthRenderer","setMaterialForRendering","mesh","material","_depthMap","constructor","scene","type","camera","storeNonLinearDepth","samplingMode","TRILINEAR_SAMPLINGMODE","storeCameraSpaceZ","name","enabled","forceDepthWriteTransparentMeshes","useOnlyInActiveCamera","reverseCulling","_scene","_storeNonLinearDepth","_storeCameraSpaceZ","isPacked","clearColor","_SceneComponentInitialization","engine","getEngine","_camera","NEAREST_SAMPLINGMODE","_caps","textureFloatLinearFiltering","textureHalfFloatLinearFiltering","format","_features","supportExtendedTextureFormats","width","getRenderWidth","height","getRenderHeight","undefined","wrapU","CLAMP_ADDRESSMODE","wrapV","refreshRate","renderParticles","renderList","noPrePassRenderer","activeCamera","ignoreCameraViewport","useCameraPostProcesses","onClearObservable","add","clear","onBeforeBindObservable","_a","_debugPushGroup","call","onAfterUnbindObservable","_debugPopGroup","customIsReadyFunction","preWarm","subMeshes","i","length","subMesh","renderingMesh","getRenderingMesh","batch","_getInstancesRenderList","_id","getReplacementMesh","hardwareInstancedRendering","getCaps","instancedArrays","visibleInstances","hasThinInstances","isReady","renderSubMesh","effectiveMesh","getEffectiveMesh","getMaterial","_internalAbstractMeshDataInfo","_isActiveIntermediate","infiniteDistance","disableDepthWrite","verticesCount","_renderId","getRenderId","detNeg","_getWorldMatrixDeterminant","sideOrientation","overrideMaterialSideOrientation","reverseSideOrientation","setState","backFaceCulling","cullBackFaces","mustReturn","renderingMaterial","_b","_materialForRenderPass","currentRenderPassId","drawWrapper","_getDrawWrapper","cameraIsOrtho","mode","ORTHOGRAPHIC_CAMERA","effect","enableEffect","_bind","fillMode","setMatrix","getTransformMatrix","getWorldMatrix","getViewMatrix","bindForSubMesh","minZ","maxZ","useReverseDepthBuffer","isNDCHalfZRange","setFloat2","needAlphaTesting","alphaTexture","getAlphaTestTexture","setTexture","getTextureMatrix","useBones","computeBonesUsingShaders","skeleton","isUsingTextureForMatrices","boneTexture","getTransformMatrixTexture","setFloat","bones","setMatrices","getTransformMatrices","BindMorphTargetParameters","morphTargetManager","isUsingTextureForTargets","_processRendering","isInstance","world","customRenderFunction","opaqueSubMeshes","alphaTestSubMeshes","transparentSubMeshes","depthOnlySubMeshes","index","data","useInstances","getMesh","getScene","isReadyForSubMesh","defines","attribs","PositionKind","push","isVerticesDataPresent","UVKind","UV2Kind","MatricesIndicesKind","MatricesWeightsKind","numBoneInfluencers","MatricesIndicesExtraKind","MatricesWeightsExtraKind","numMorphInfluencers","numInfluencers","PrepareAttributesForMorphTargetsInfluencers","PushAttributesForInstances","cachedDefines","join","uniforms","setEffect","createEffect","maxSimultaneousMorphTargets","getDepthMap","dispose","keysToDelete","key","_depthRenderer","depthRenderer","_"],"sources":["../../../../dev/core/src/Rendering/depthRenderer.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/depth.fragment\";\r\nimport \"../Shaders/depth.vertex\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper\";\r\n\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\n\r\n/**\r\n * This represents a depth renderer in Babylon.\r\n * A depth renderer will render to it's depth map every frame which can be displayed or used in post processing\r\n */\r\nexport class DepthRenderer {\r\n    private _scene: Scene;\r\n    private _depthMap: RenderTargetTexture;\r\n    private readonly _storeNonLinearDepth: boolean;\r\n    private readonly _storeCameraSpaceZ: boolean;\r\n\r\n    /** Color used to clear the depth texture. Default: (1,0,0,1) */\r\n    public clearColor: Color4;\r\n\r\n    /** Get if the depth renderer is using packed depth or not */\r\n    public readonly isPacked: boolean;\r\n\r\n    private _camera: Nullable<Camera>;\r\n\r\n    /** Enable or disable the depth renderer. When disabled, the depth texture is not updated */\r\n    public enabled = true;\r\n\r\n    /** Force writing the transparent objects into the depth map */\r\n    public forceDepthWriteTransparentMeshes = false;\r\n\r\n    /**\r\n     * Specifies that the depth renderer will only be used within\r\n     * the camera it is created for.\r\n     * This can help forcing its rendering during the camera processing.\r\n     */\r\n    public useOnlyInActiveCamera: boolean = false;\r\n\r\n    /** If true, reverse the culling of materials before writing to the depth texture.\r\n     * So, basically, when \"true\", back facing instead of front facing faces are rasterized into the texture\r\n     */\r\n    public reverseCulling = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"DepthRendererSceneComponent\");\r\n    };\r\n\r\n    /**\r\n     * Sets a specific material to be used to render a mesh/a list of meshes by the depth renderer\r\n     * @param mesh mesh or array of meshes\r\n     * @param material material to use by the depth render when rendering the mesh(es). If undefined is passed, the specific material created by the depth renderer will be used.\r\n     */\r\n    public setMaterialForRendering(mesh: AbstractMesh | AbstractMesh[], material?: Material): void {\r\n        this._depthMap.setMaterialForRendering(mesh, material);\r\n    }\r\n\r\n    /**\r\n     * Instantiates a depth renderer\r\n     * @param scene The scene the renderer belongs to\r\n     * @param type The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)\r\n     * @param camera The camera to be used to render the depth map (default: scene's active camera)\r\n     * @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z\r\n     * @param samplingMode The sampling mode to be used with the render target (Linear, Nearest...) (default: TRILINEAR_SAMPLINGMODE)\r\n     * @param storeCameraSpaceZ Defines whether the depth stored is the Z coordinate in camera space. If true, storeNonLinearDepth has no effect. (Default: false)\r\n     * @param name Name of the render target (default: DepthRenderer)\r\n     */\r\n    constructor(\r\n        scene: Scene,\r\n        type: number = Constants.TEXTURETYPE_FLOAT,\r\n        camera: Nullable<Camera> = null,\r\n        storeNonLinearDepth = false,\r\n        samplingMode = Texture.TRILINEAR_SAMPLINGMODE,\r\n        storeCameraSpaceZ = false,\r\n        name?: string\r\n    ) {\r\n        this._scene = scene;\r\n        this._storeNonLinearDepth = storeNonLinearDepth;\r\n        this._storeCameraSpaceZ = storeCameraSpaceZ;\r\n        this.isPacked = type === Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        if (this.isPacked) {\r\n            this.clearColor = new Color4(1.0, 1.0, 1.0, 1.0);\r\n        } else {\r\n            this.clearColor = new Color4(storeCameraSpaceZ ? 1e8 : 1.0, 0.0, 0.0, 1.0);\r\n        }\r\n\r\n        DepthRenderer._SceneComponentInitialization(this._scene);\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        this._camera = camera;\r\n\r\n        if (samplingMode !== Texture.NEAREST_SAMPLINGMODE) {\r\n            if (type === Constants.TEXTURETYPE_FLOAT && !engine._caps.textureFloatLinearFiltering) {\r\n                samplingMode = Texture.NEAREST_SAMPLINGMODE;\r\n            }\r\n            if (type === Constants.TEXTURETYPE_HALF_FLOAT && !engine._caps.textureHalfFloatLinearFiltering) {\r\n                samplingMode = Texture.NEAREST_SAMPLINGMODE;\r\n            }\r\n        }\r\n\r\n        // Render target\r\n        const format = this.isPacked || !engine._features.supportExtendedTextureFormats ? Constants.TEXTUREFORMAT_RGBA : Constants.TEXTUREFORMAT_R;\r\n        this._depthMap = new RenderTargetTexture(\r\n            name ?? \"DepthRenderer\",\r\n            { width: engine.getRenderWidth(), height: engine.getRenderHeight() },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            type,\r\n            false,\r\n            samplingMode,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            format\r\n        );\r\n        this._depthMap.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._depthMap.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._depthMap.refreshRate = 1;\r\n        this._depthMap.renderParticles = false;\r\n        this._depthMap.renderList = null;\r\n        this._depthMap.noPrePassRenderer = true;\r\n\r\n        // Camera to get depth map from to support multiple concurrent cameras\r\n        this._depthMap.activeCamera = this._camera;\r\n        this._depthMap.ignoreCameraViewport = true;\r\n        this._depthMap.useCameraPostProcesses = false;\r\n\r\n        // set default depth value to 1.0 (far away)\r\n        this._depthMap.onClearObservable.add((engine) => {\r\n            engine.clear(this.clearColor, true, true, true);\r\n        });\r\n\r\n        this._depthMap.onBeforeBindObservable.add(() => {\r\n            engine._debugPushGroup?.(\"depth renderer\", 1);\r\n        });\r\n\r\n        this._depthMap.onAfterUnbindObservable.add(() => {\r\n            engine._debugPopGroup?.(1);\r\n        });\r\n\r\n        this._depthMap.customIsReadyFunction = (mesh: AbstractMesh, refreshRate: number, preWarm?: boolean) => {\r\n            if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\r\n                for (let i = 0; i < mesh.subMeshes.length; ++i) {\r\n                    const subMesh = mesh.subMeshes[i];\r\n                    const renderingMesh = subMesh.getRenderingMesh();\r\n\r\n                    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n                    const hardwareInstancedRendering =\r\n                        engine.getCaps().instancedArrays &&\r\n                        ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || renderingMesh.hasThinInstances);\r\n\r\n                    if (!this.isReady(subMesh, hardwareInstancedRendering)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        };\r\n\r\n        // Custom render function\r\n        const renderSubMesh = (subMesh: SubMesh): void => {\r\n            const renderingMesh = subMesh.getRenderingMesh();\r\n            const effectiveMesh = subMesh.getEffectiveMesh();\r\n            const scene = this._scene;\r\n            const engine = scene.getEngine();\r\n            const material = subMesh.getMaterial();\r\n\r\n            effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n\r\n            if (!material || effectiveMesh.infiniteDistance || material.disableDepthWrite || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {\r\n                return;\r\n            }\r\n\r\n            // Culling\r\n            const detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;\r\n            let sideOrientation = renderingMesh.overrideMaterialSideOrientation ?? material.sideOrientation;\r\n            if (detNeg) {\r\n                sideOrientation =\r\n                    sideOrientation === Constants.MATERIAL_ClockWiseSideOrientation\r\n                        ? Constants.MATERIAL_CounterClockWiseSideOrientation\r\n                        : Constants.MATERIAL_ClockWiseSideOrientation;\r\n            }\r\n            const reverseSideOrientation = sideOrientation === Constants.MATERIAL_ClockWiseSideOrientation;\r\n\r\n            engine.setState(material.backFaceCulling, 0, false, reverseSideOrientation, this.reverseCulling ? !material.cullBackFaces : material.cullBackFaces);\r\n\r\n            // Managing instances\r\n            const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n\r\n            if (batch.mustReturn) {\r\n                return;\r\n            }\r\n\r\n            const hardwareInstancedRendering =\r\n                engine.getCaps().instancedArrays &&\r\n                ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || renderingMesh.hasThinInstances);\r\n\r\n            const camera = this._camera || scene.activeCamera;\r\n            if (this.isReady(subMesh, hardwareInstancedRendering) && camera) {\r\n                subMesh._renderId = scene.getRenderId();\r\n\r\n                const renderingMaterial = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n                let drawWrapper = subMesh._getDrawWrapper();\r\n                if (!drawWrapper && renderingMaterial) {\r\n                    drawWrapper = renderingMaterial._getDrawWrapper();\r\n                }\r\n                const cameraIsOrtho = camera.mode === Camera.ORTHOGRAPHIC_CAMERA;\r\n\r\n                if (!drawWrapper) {\r\n                    return;\r\n                }\r\n\r\n                const effect = drawWrapper.effect!;\r\n\r\n                engine.enableEffect(drawWrapper);\r\n\r\n                if (!hardwareInstancedRendering) {\r\n                    renderingMesh._bind(subMesh, effect, material.fillMode);\r\n                }\r\n\r\n                if (!renderingMaterial) {\r\n                    effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n                    effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\r\n                    if (this._storeCameraSpaceZ) {\r\n                        effect.setMatrix(\"view\", scene.getViewMatrix());\r\n                    }\r\n                } else {\r\n                    renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh as Mesh, subMesh);\r\n                }\r\n\r\n                let minZ: number, maxZ: number;\r\n\r\n                if (cameraIsOrtho) {\r\n                    minZ = !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\r\n                    maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\r\n                } else {\r\n                    minZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? camera.minZ : engine.isNDCHalfZRange ? 0 : camera.minZ;\r\n                    maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : camera.maxZ;\r\n                }\r\n\r\n                effect.setFloat2(\"depthValues\", minZ, minZ + maxZ);\r\n\r\n                if (!renderingMaterial) {\r\n                    // Alpha test\r\n                    if (material.needAlphaTesting()) {\r\n                        const alphaTexture = material.getAlphaTestTexture();\r\n\r\n                        if (alphaTexture) {\r\n                            effect.setTexture(\"diffuseSampler\", alphaTexture);\r\n                            effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\r\n                        }\r\n                    }\r\n\r\n                    // Bones\r\n                    if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\r\n                        const skeleton = renderingMesh.skeleton;\r\n\r\n                        if (skeleton.isUsingTextureForMatrices) {\r\n                            const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\r\n                            if (!boneTexture) {\r\n                                return;\r\n                            }\r\n\r\n                            effect.setTexture(\"boneSampler\", boneTexture);\r\n                            effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\r\n                        } else {\r\n                            effect.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\r\n                        }\r\n                    }\r\n\r\n                    // Clip planes\r\n                    bindClipPlane(effect, material, scene);\r\n\r\n                    // Morph targets\r\n                    MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);\r\n                    if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\r\n                        renderingMesh.morphTargetManager._bind(effect);\r\n                    }\r\n                }\r\n\r\n                // Draw\r\n                renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) =>\r\n                    effect.setMatrix(\"world\", world)\r\n                );\r\n            }\r\n        };\r\n\r\n        this._depthMap.customRenderFunction = (\r\n            opaqueSubMeshes: SmartArray<SubMesh>,\r\n            alphaTestSubMeshes: SmartArray<SubMesh>,\r\n            transparentSubMeshes: SmartArray<SubMesh>,\r\n            depthOnlySubMeshes: SmartArray<SubMesh>\r\n        ): void => {\r\n            let index;\r\n\r\n            if (depthOnlySubMeshes.length) {\r\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\r\n                    renderSubMesh(depthOnlySubMeshes.data[index]);\r\n                }\r\n            }\r\n\r\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\r\n                renderSubMesh(opaqueSubMeshes.data[index]);\r\n            }\r\n\r\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\r\n                renderSubMesh(alphaTestSubMeshes.data[index]);\r\n            }\r\n\r\n            if (this.forceDepthWriteTransparentMeshes) {\r\n                for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                    renderSubMesh(transparentSubMeshes.data[index]);\r\n                }\r\n            } else {\r\n                for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                    transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Creates the depth rendering effect and checks if the effect is ready.\r\n     * @param subMesh The submesh to be used to render the depth map of\r\n     * @param useInstances If multiple world instances should be used\r\n     * @returns if the depth renderer is ready to render the depth map\r\n     */\r\n    public isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        const engine = this._scene.getEngine();\r\n        const mesh = subMesh.getMesh();\r\n        const scene = mesh.getScene();\r\n\r\n        const renderingMaterial = mesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n        if (renderingMaterial) {\r\n            return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\r\n        }\r\n\r\n        const material = subMesh.getMaterial();\r\n        if (!material || material.disableDepthWrite) {\r\n            return false;\r\n        }\r\n\r\n        const defines = [];\r\n\r\n        const attribs = [VertexBuffer.PositionKind];\r\n\r\n        // Alpha test\r\n        if (material && material.needAlphaTesting() && material.getAlphaTestTexture()) {\r\n            defines.push(\"#define ALPHATEST\");\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n                defines.push(\"#define UV1\");\r\n            }\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n                defines.push(\"#define UV2\");\r\n            }\r\n        }\r\n\r\n        // Bones\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\r\n\r\n            const skeleton = subMesh.getRenderingMesh().skeleton;\r\n\r\n            if (skeleton?.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph targets\r\n        const morphTargetManager = (mesh as Mesh).morphTargetManager;\r\n        let numMorphInfluencers = 0;\r\n        if (morphTargetManager) {\r\n            if (morphTargetManager.numInfluencers > 0) {\r\n                numMorphInfluencers = morphTargetManager.numInfluencers;\r\n\r\n                defines.push(\"#define MORPHTARGETS\");\r\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\r\n\r\n                if (morphTargetManager.isUsingTextureForTargets) {\r\n                    defines.push(\"#define MORPHTARGETS_TEXTURE\");\r\n                }\r\n\r\n                MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\r\n            }\r\n        }\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs);\r\n            if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        // None linear depth\r\n        if (this._storeNonLinearDepth) {\r\n            defines.push(\"#define NONLINEARDEPTH\");\r\n        }\r\n\r\n        // Store camera space Z coordinate instead of NDC Z\r\n        if (this._storeCameraSpaceZ) {\r\n            defines.push(\"#define STORE_CAMERASPACE_Z\");\r\n        }\r\n\r\n        // Float Mode\r\n        if (this.isPacked) {\r\n            defines.push(\"#define PACKED\");\r\n        }\r\n\r\n        // Clip planes\r\n        prepareStringDefinesForClipPlanes(material, scene, defines);\r\n\r\n        // Get correct effect\r\n        const drawWrapper = subMesh._getDrawWrapper(undefined, true)!;\r\n        const cachedDefines = drawWrapper.defines;\r\n        const join = defines.join(\"\\n\");\r\n        if (cachedDefines !== join) {\r\n            const uniforms = [\r\n                \"world\",\r\n                \"mBones\",\r\n                \"boneTextureWidth\",\r\n                \"viewProjection\",\r\n                \"view\",\r\n                \"diffuseMatrix\",\r\n                \"depthValues\",\r\n                \"morphTargetInfluences\",\r\n                \"morphTargetTextureInfo\",\r\n                \"morphTargetTextureIndices\",\r\n            ];\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            drawWrapper.setEffect(\r\n                engine.createEffect(\"depth\", attribs, uniforms, [\"diffuseSampler\", \"morphTargets\", \"boneSampler\"], join, undefined, undefined, undefined, {\r\n                    maxSimultaneousMorphTargets: numMorphInfluencers,\r\n                }),\r\n                join\r\n            );\r\n        }\r\n\r\n        return drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    /**\r\n     * Gets the texture which the depth map will be written to.\r\n     * @returns The depth map texture\r\n     */\r\n    public getDepthMap(): RenderTargetTexture {\r\n        return this._depthMap;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the depth renderer.\r\n     */\r\n    public dispose(): void {\r\n        const keysToDelete = [];\r\n        for (const key in this._scene._depthRenderer) {\r\n            const depthRenderer = this._scene._depthRenderer[key];\r\n            if (depthRenderer === this) {\r\n                keysToDelete.push(key);\r\n            }\r\n        }\r\n\r\n        if (keysToDelete.length > 0) {\r\n            this._depthMap.dispose();\r\n\r\n            for (const key of keysToDelete) {\r\n                delete this._scene._depthRenderer[key];\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}