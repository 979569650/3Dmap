{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\n\n/**\n * Helper class useful to convert panorama picture to their cubemap representation in 6 faces.\n */\nexport class PanoramaToCubeMapTools {\n  /**\n   * Converts a panorama stored in RGB right to left up to down format into a cubemap (6 faces).\n   *\n   * @param float32Array The source data.\n   * @param inputWidth The width of the input panorama.\n   * @param inputHeight The height of the input panorama.\n   * @param size The willing size of the generated cubemap (each faces will be size * size pixels)\n   * @returns The cubemap data\n   */\n  static ConvertPanoramaToCubemap(float32Array, inputWidth, inputHeight, size, supersample = false) {\n    if (!float32Array) {\n      throw \"ConvertPanoramaToCubemap: input cannot be null\";\n    }\n    if (float32Array.length != inputWidth * inputHeight * 3) {\n      throw \"ConvertPanoramaToCubemap: input size is wrong\";\n    }\n    const textureFront = this.CreateCubemapTexture(size, this.FACE_FRONT, float32Array, inputWidth, inputHeight, supersample);\n    const textureBack = this.CreateCubemapTexture(size, this.FACE_BACK, float32Array, inputWidth, inputHeight, supersample);\n    const textureLeft = this.CreateCubemapTexture(size, this.FACE_LEFT, float32Array, inputWidth, inputHeight, supersample);\n    const textureRight = this.CreateCubemapTexture(size, this.FACE_RIGHT, float32Array, inputWidth, inputHeight, supersample);\n    const textureUp = this.CreateCubemapTexture(size, this.FACE_UP, float32Array, inputWidth, inputHeight, supersample);\n    const textureDown = this.CreateCubemapTexture(size, this.FACE_DOWN, float32Array, inputWidth, inputHeight, supersample);\n    return {\n      front: textureFront,\n      back: textureBack,\n      left: textureLeft,\n      right: textureRight,\n      up: textureUp,\n      down: textureDown,\n      size: size,\n      type: 1,\n      format: 4,\n      gammaSpace: false\n    };\n  }\n  static CreateCubemapTexture(texSize, faceData, float32Array, inputWidth, inputHeight, supersample = false) {\n    const buffer = new ArrayBuffer(texSize * texSize * 4 * 3);\n    const textureArray = new Float32Array(buffer);\n    // If supersampling, determine number of samples needed when source texture width is divided for 4 cube faces\n    const samples = supersample ? Math.max(1, Math.round(inputWidth / 4 / texSize)) : 1;\n    const sampleFactor = 1 / samples;\n    const sampleFactorSqr = sampleFactor * sampleFactor;\n    const rotDX1 = faceData[1].subtract(faceData[0]).scale(sampleFactor / texSize);\n    const rotDX2 = faceData[3].subtract(faceData[2]).scale(sampleFactor / texSize);\n    const dy = 1 / texSize;\n    let fy = 0;\n    for (let y = 0; y < texSize; y++) {\n      for (let sy = 0; sy < samples; sy++) {\n        let xv1 = faceData[0];\n        let xv2 = faceData[2];\n        for (let x = 0; x < texSize; x++) {\n          for (let sx = 0; sx < samples; sx++) {\n            const v = xv2.subtract(xv1).scale(fy).add(xv1);\n            v.normalize();\n            const color = this.CalcProjectionSpherical(v, float32Array, inputWidth, inputHeight);\n            // 3 channels per pixels\n            textureArray[y * texSize * 3 + x * 3 + 0] += color.r * sampleFactorSqr;\n            textureArray[y * texSize * 3 + x * 3 + 1] += color.g * sampleFactorSqr;\n            textureArray[y * texSize * 3 + x * 3 + 2] += color.b * sampleFactorSqr;\n            xv1 = xv1.add(rotDX1);\n            xv2 = xv2.add(rotDX2);\n          }\n        }\n        fy += dy * sampleFactor;\n      }\n    }\n    return textureArray;\n  }\n  static CalcProjectionSpherical(vDir, float32Array, inputWidth, inputHeight) {\n    let theta = Math.atan2(vDir.z, vDir.x);\n    const phi = Math.acos(vDir.y);\n    while (theta < -Math.PI) {\n      theta += 2 * Math.PI;\n    }\n    while (theta > Math.PI) {\n      theta -= 2 * Math.PI;\n    }\n    let dx = theta / Math.PI;\n    const dy = phi / Math.PI;\n    // recenter.\n    dx = dx * 0.5 + 0.5;\n    let px = Math.round(dx * inputWidth);\n    if (px < 0) {\n      px = 0;\n    } else if (px >= inputWidth) {\n      px = inputWidth - 1;\n    }\n    let py = Math.round(dy * inputHeight);\n    if (py < 0) {\n      py = 0;\n    } else if (py >= inputHeight) {\n      py = inputHeight - 1;\n    }\n    const inputY = inputHeight - py - 1;\n    const r = float32Array[inputY * inputWidth * 3 + px * 3 + 0];\n    const g = float32Array[inputY * inputWidth * 3 + px * 3 + 1];\n    const b = float32Array[inputY * inputWidth * 3 + px * 3 + 2];\n    return {\n      r: r,\n      g: g,\n      b: b\n    };\n  }\n}\nPanoramaToCubeMapTools.FACE_LEFT = [new Vector3(-1.0, -1.0, -1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(1.0, 1.0, -1.0)];\nPanoramaToCubeMapTools.FACE_RIGHT = [new Vector3(1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, 1.0)];\nPanoramaToCubeMapTools.FACE_FRONT = [new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0), new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0)];\nPanoramaToCubeMapTools.FACE_BACK = [new Vector3(-1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0)];\nPanoramaToCubeMapTools.FACE_DOWN = [new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(-1.0, 1.0, 1.0)];\nPanoramaToCubeMapTools.FACE_UP = [new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0)];","map":{"version":3,"names":["Vector3","PanoramaToCubeMapTools","ConvertPanoramaToCubemap","float32Array","inputWidth","inputHeight","size","supersample","length","textureFront","CreateCubemapTexture","FACE_FRONT","textureBack","FACE_BACK","textureLeft","FACE_LEFT","textureRight","FACE_RIGHT","textureUp","FACE_UP","textureDown","FACE_DOWN","front","back","left","right","up","down","type","format","gammaSpace","texSize","faceData","buffer","ArrayBuffer","textureArray","Float32Array","samples","Math","max","round","sampleFactor","sampleFactorSqr","rotDX1","subtract","scale","rotDX2","dy","fy","y","sy","xv1","xv2","x","sx","v","add","normalize","color","CalcProjectionSpherical","r","g","b","vDir","theta","atan2","z","phi","acos","PI","dx","px","py","inputY"],"sources":["../../../../../dev/core/src/Misc/HighDynamicRange/panoramaToCubemap.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../types\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\n/**\r\n * CubeMap information grouping all the data for each faces as well as the cubemap size.\r\n */\r\nexport interface CubeMapInfo {\r\n    /**\r\n     * The pixel array for the front face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    front: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the back face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    back: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the left face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    left: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the right face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    right: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the up face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    up: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the down face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    down: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The size of the cubemap stored.\r\n     *\r\n     * Each faces will be size * size pixels.\r\n     */\r\n    size: number;\r\n\r\n    /**\r\n     * The format of the texture.\r\n     *\r\n     * RGBA, RGB.\r\n     */\r\n    format: number;\r\n\r\n    /**\r\n     * The type of the texture data.\r\n     *\r\n     * UNSIGNED_INT, FLOAT.\r\n     */\r\n    type: number;\r\n\r\n    /**\r\n     * Specifies whether the texture is in gamma space.\r\n     */\r\n    gammaSpace: boolean;\r\n}\r\n\r\n/**\r\n * Helper class useful to convert panorama picture to their cubemap representation in 6 faces.\r\n */\r\nexport class PanoramaToCubeMapTools {\r\n    private static FACE_LEFT = [new Vector3(-1.0, -1.0, -1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(1.0, 1.0, -1.0)];\r\n    private static FACE_RIGHT = [new Vector3(1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, 1.0)];\r\n    private static FACE_FRONT = [new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0), new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0)];\r\n    private static FACE_BACK = [new Vector3(-1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0)];\r\n    private static FACE_DOWN = [new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(-1.0, 1.0, 1.0)];\r\n    private static FACE_UP = [new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0)];\r\n\r\n    /**\r\n     * Converts a panorama stored in RGB right to left up to down format into a cubemap (6 faces).\r\n     *\r\n     * @param float32Array The source data.\r\n     * @param inputWidth The width of the input panorama.\r\n     * @param inputHeight The height of the input panorama.\r\n     * @param size The willing size of the generated cubemap (each faces will be size * size pixels)\r\n     * @returns The cubemap data\r\n     */\r\n    public static ConvertPanoramaToCubemap(float32Array: Float32Array, inputWidth: number, inputHeight: number, size: number, supersample = false): CubeMapInfo {\r\n        if (!float32Array) {\r\n            throw \"ConvertPanoramaToCubemap: input cannot be null\";\r\n        }\r\n\r\n        if (float32Array.length != inputWidth * inputHeight * 3) {\r\n            throw \"ConvertPanoramaToCubemap: input size is wrong\";\r\n        }\r\n\r\n        const textureFront = this.CreateCubemapTexture(size, this.FACE_FRONT, float32Array, inputWidth, inputHeight, supersample);\r\n        const textureBack = this.CreateCubemapTexture(size, this.FACE_BACK, float32Array, inputWidth, inputHeight, supersample);\r\n        const textureLeft = this.CreateCubemapTexture(size, this.FACE_LEFT, float32Array, inputWidth, inputHeight, supersample);\r\n        const textureRight = this.CreateCubemapTexture(size, this.FACE_RIGHT, float32Array, inputWidth, inputHeight, supersample);\r\n        const textureUp = this.CreateCubemapTexture(size, this.FACE_UP, float32Array, inputWidth, inputHeight, supersample);\r\n        const textureDown = this.CreateCubemapTexture(size, this.FACE_DOWN, float32Array, inputWidth, inputHeight, supersample);\r\n\r\n        return {\r\n            front: textureFront,\r\n            back: textureBack,\r\n            left: textureLeft,\r\n            right: textureRight,\r\n            up: textureUp,\r\n            down: textureDown,\r\n            size: size,\r\n            type: Constants.TEXTURETYPE_FLOAT,\r\n            format: Constants.TEXTUREFORMAT_RGB,\r\n            gammaSpace: false,\r\n        };\r\n    }\r\n\r\n    private static CreateCubemapTexture(texSize: number, faceData: Vector3[], float32Array: Float32Array, inputWidth: number, inputHeight: number, supersample = false) {\r\n        const buffer = new ArrayBuffer(texSize * texSize * 4 * 3);\r\n        const textureArray = new Float32Array(buffer);\r\n\r\n        // If supersampling, determine number of samples needed when source texture width is divided for 4 cube faces\r\n        const samples = supersample ? Math.max(1, Math.round(inputWidth / 4 / texSize)) : 1;\r\n        const sampleFactor = 1 / samples;\r\n        const sampleFactorSqr = sampleFactor * sampleFactor;\r\n\r\n        const rotDX1 = faceData[1].subtract(faceData[0]).scale(sampleFactor / texSize);\r\n        const rotDX2 = faceData[3].subtract(faceData[2]).scale(sampleFactor / texSize);\r\n\r\n        const dy = 1 / texSize;\r\n        let fy = 0;\r\n\r\n        for (let y = 0; y < texSize; y++) {\r\n            for (let sy = 0; sy < samples; sy++) {\r\n                let xv1 = faceData[0];\r\n                let xv2 = faceData[2];\r\n\r\n                for (let x = 0; x < texSize; x++) {\r\n                    for (let sx = 0; sx < samples; sx++) {\r\n                        const v = xv2.subtract(xv1).scale(fy).add(xv1);\r\n                        v.normalize();\r\n\r\n                        const color = this.CalcProjectionSpherical(v, float32Array, inputWidth, inputHeight);\r\n\r\n                        // 3 channels per pixels\r\n                        textureArray[y * texSize * 3 + x * 3 + 0] += color.r * sampleFactorSqr;\r\n                        textureArray[y * texSize * 3 + x * 3 + 1] += color.g * sampleFactorSqr;\r\n                        textureArray[y * texSize * 3 + x * 3 + 2] += color.b * sampleFactorSqr;\r\n\r\n                        xv1 = xv1.add(rotDX1);\r\n                        xv2 = xv2.add(rotDX2);\r\n                    }\r\n                }\r\n\r\n                fy += dy * sampleFactor;\r\n            }\r\n        }\r\n\r\n        return textureArray;\r\n    }\r\n\r\n    private static CalcProjectionSpherical(vDir: Vector3, float32Array: Float32Array, inputWidth: number, inputHeight: number): any {\r\n        let theta = Math.atan2(vDir.z, vDir.x);\r\n        const phi = Math.acos(vDir.y);\r\n\r\n        while (theta < -Math.PI) {\r\n            theta += 2 * Math.PI;\r\n        }\r\n        while (theta > Math.PI) {\r\n            theta -= 2 * Math.PI;\r\n        }\r\n\r\n        let dx = theta / Math.PI;\r\n        const dy = phi / Math.PI;\r\n\r\n        // recenter.\r\n        dx = dx * 0.5 + 0.5;\r\n\r\n        let px = Math.round(dx * inputWidth);\r\n        if (px < 0) {\r\n            px = 0;\r\n        } else if (px >= inputWidth) {\r\n            px = inputWidth - 1;\r\n        }\r\n\r\n        let py = Math.round(dy * inputHeight);\r\n        if (py < 0) {\r\n            py = 0;\r\n        } else if (py >= inputHeight) {\r\n            py = inputHeight - 1;\r\n        }\r\n\r\n        const inputY = inputHeight - py - 1;\r\n        const r = float32Array[inputY * inputWidth * 3 + px * 3 + 0];\r\n        const g = float32Array[inputY * inputWidth * 3 + px * 3 + 1];\r\n        const b = float32Array[inputY * inputWidth * 3 + px * 3 + 2];\r\n\r\n        return {\r\n            r: r,\r\n            g: g,\r\n            b: b,\r\n        };\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}