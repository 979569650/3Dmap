{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { RawTexture } from \"../../Materials/Textures/rawTexture.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport { Engine } from \"../../Engines/engine.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { WebGLHardwareTexture } from \"../../Engines/WebGL/webGLHardwareTexture.js\";\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\n/**\n * WebXR Feature for WebXR Depth Sensing Module\n * @since 5.49.1\n */\nexport class WebXRDepthSensing extends WebXRAbstractFeature {\n  /**\n   * Width of depth data. If depth data is not exist, returns null.\n   */\n  get width() {\n    return this._width;\n  }\n  /**\n   * Height of depth data. If depth data is not exist, returns null.\n   */\n  get height() {\n    return this._height;\n  }\n  /**\n   * Scale factor by which the raw depth values must be multiplied in order to get the depths in meters.\n   */\n  get rawValueToMeters() {\n    return this._rawValueToMeters;\n  }\n  /**\n   * An XRRigidTransform that needs to be applied when indexing into the depth buffer.\n   */\n  get normDepthBufferFromNormView() {\n    return this._normDepthBufferFromNormView;\n  }\n  /**\n   * Describes which depth-sensing usage (\"cpu\" or \"gpu\") is used.\n   */\n  get depthUsage() {\n    switch (this._xrSessionManager.session.depthUsage) {\n      case \"cpu-optimized\":\n        return \"cpu\";\n      case \"gpu-optimized\":\n        return \"gpu\";\n    }\n  }\n  /**\n   * Describes which depth sensing data format (\"ushort\" or \"float\") is used.\n   */\n  get depthDataFormat() {\n    switch (this._xrSessionManager.session.depthDataFormat) {\n      case \"luminance-alpha\":\n        return \"ushort\";\n      case \"float32\":\n        return \"float\";\n    }\n  }\n  /**\n   * Latest cached InternalTexture which containing depth buffer information.\n   * This can be used when the depth usage is \"gpu\".\n   */\n  get latestInternalTexture() {\n    var _a, _b;\n    if (!this._cachedWebGLTexture) {\n      return null;\n    }\n    const engine = this._xrSessionManager.scene.getEngine();\n    const internalTexture = new InternalTexture(engine, InternalTextureSource.Unknown);\n    internalTexture.isCube = false;\n    internalTexture.invertY = false;\n    internalTexture._useSRGBBuffer = false;\n    internalTexture.format = this.depthDataFormat === \"ushort\" ? 2 : 5;\n    internalTexture.generateMipMaps = false;\n    internalTexture.type = this.depthDataFormat === \"ushort\" ? 5 : 1;\n    internalTexture.samplingMode = 7;\n    internalTexture.width = (_a = this.width) !== null && _a !== void 0 ? _a : 0;\n    internalTexture.height = (_b = this.height) !== null && _b !== void 0 ? _b : 0;\n    internalTexture._cachedWrapU = 1;\n    internalTexture._cachedWrapV = 1;\n    internalTexture._hardwareTexture = new WebGLHardwareTexture(this._cachedWebGLTexture, engine._gl);\n    return internalTexture;\n  }\n  /**\n   * cached depth buffer\n   */\n  get latestDepthBuffer() {\n    if (!this._cachedDepthBuffer) {\n      return null;\n    }\n    return this.depthDataFormat === \"ushort\" ? new Uint16Array(this._cachedDepthBuffer) : new Float32Array(this._cachedDepthBuffer);\n  }\n  /**\n   * Latest cached Texture of depth image which is made from the depth buffer data.\n   */\n  get latestDepthImageTexture() {\n    return this._cachedDepthImageTexture;\n  }\n  /**\n   * Creates a new instance of the depth sensing feature\n   * @param _xrSessionManager the WebXRSessionManager\n   * @param options options for WebXR Depth Sensing Feature\n   */\n  constructor(_xrSessionManager, options) {\n    super(_xrSessionManager);\n    this.options = options;\n    this._width = null;\n    this._height = null;\n    this._rawValueToMeters = null;\n    this._normDepthBufferFromNormView = null;\n    this._cachedDepthBuffer = null;\n    this._cachedWebGLTexture = null;\n    this._cachedDepthImageTexture = null;\n    /**\n     * Event that notify when `DepthInformation.getDepthInMeters` is available.\n     * `getDepthInMeters` method needs active XRFrame (not available for cached XRFrame)\n     */\n    this.onGetDepthInMetersAvailable = new Observable();\n    this.xrNativeFeatureName = \"depth-sensing\";\n    // https://immersive-web.github.io/depth-sensing/\n    Tools.Warn(\"depth-sensing is an experimental and unstable feature.\");\n  }\n  /**\n   * attach this feature\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  attach(force) {\n    if (!super.attach(force)) {\n      return false;\n    }\n    const isBothDepthUsageAndFormatNull = this._xrSessionManager.session.depthDataFormat == null || this._xrSessionManager.session.depthUsage == null;\n    if (isBothDepthUsageAndFormatNull) {\n      return false;\n    }\n    this._glBinding = new XRWebGLBinding(this._xrSessionManager.session, this._xrSessionManager.scene.getEngine()._gl);\n    return true;\n  }\n  /**\n   * Dispose this feature and all of the resources attached\n   */\n  dispose() {\n    var _a;\n    (_a = this._cachedDepthImageTexture) === null || _a === void 0 ? void 0 : _a.dispose();\n  }\n  _onXRFrame(_xrFrame) {\n    const referenceSPace = this._xrSessionManager.referenceSpace;\n    const pose = _xrFrame.getViewerPose(referenceSPace);\n    if (pose == null) {\n      return;\n    }\n    for (const view of pose.views) {\n      switch (this.depthUsage) {\n        case \"cpu\":\n          this._updateDepthInformationAndTextureCPUDepthUsage(_xrFrame, view, this.depthDataFormat);\n          break;\n        case \"gpu\":\n          if (!this._glBinding) {\n            break;\n          }\n          this._updateDepthInformationAndTextureWebGLDepthUsage(this._glBinding, view, this.depthDataFormat);\n          break;\n        default:\n          Tools.Error(\"Unknown depth usage\");\n          this.detach();\n          break;\n      }\n    }\n  }\n  _updateDepthInformationAndTextureCPUDepthUsage(frame, view, dataFormat) {\n    const depthInfo = frame.getDepthInformation(view);\n    if (depthInfo === null) {\n      return;\n    }\n    const {\n      data,\n      width,\n      height,\n      rawValueToMeters,\n      getDepthInMeters\n    } = depthInfo;\n    this._width = width;\n    this._height = height;\n    this._rawValueToMeters = rawValueToMeters;\n    this._cachedDepthBuffer = data;\n    // to avoid Illegal Invocation error, bind `this`\n    this.onGetDepthInMetersAvailable.notifyObservers(getDepthInMeters.bind(depthInfo));\n    if (!this._cachedDepthImageTexture) {\n      this._cachedDepthImageTexture = RawTexture.CreateRTexture(null, width, height, this._xrSessionManager.scene, false, true, Texture.NEAREST_SAMPLINGMODE, Engine.TEXTURETYPE_FLOAT);\n    }\n    switch (dataFormat) {\n      case \"ushort\":\n        this._cachedDepthImageTexture.update(Float32Array.from(new Uint16Array(data)).map(value => value * rawValueToMeters));\n        break;\n      case \"float\":\n        this._cachedDepthImageTexture.update(new Float32Array(data).map(value => value * rawValueToMeters));\n        break;\n      default:\n        break;\n    }\n  }\n  _updateDepthInformationAndTextureWebGLDepthUsage(webglBinding, view, dataFormat) {\n    const depthInfo = webglBinding.getDepthInformation(view);\n    if (depthInfo === null) {\n      return;\n    }\n    const {\n      texture,\n      width,\n      height\n    } = depthInfo;\n    this._width = width;\n    this._height = height;\n    this._cachedWebGLTexture = texture;\n    const scene = this._xrSessionManager.scene;\n    const engine = scene.getEngine();\n    const internalTexture = engine.wrapWebGLTexture(texture);\n    if (!this._cachedDepthImageTexture) {\n      this._cachedDepthImageTexture = RawTexture.CreateRTexture(null, width, height, scene, false, true, Texture.NEAREST_SAMPLINGMODE, dataFormat === \"ushort\" ? Engine.TEXTURETYPE_UNSIGNED_BYTE : Engine.TEXTURETYPE_FLOAT);\n    }\n    this._cachedDepthImageTexture._texture = internalTexture;\n  }\n  /**\n   * Extends the session init object if needed\n   * @returns augmentation object for the xr session init object.\n   */\n  getXRSessionInitExtension() {\n    const isDepthUsageDeclared = this.options.usagePreference != null && this.options.usagePreference.length !== 0;\n    const isDataFormatDeclared = this.options.dataFormatPreference != null && this.options.dataFormatPreference.length !== 0;\n    return new Promise(resolve => {\n      if (isDepthUsageDeclared && isDataFormatDeclared) {\n        const usages = this.options.usagePreference.map(usage => {\n          switch (usage) {\n            case \"cpu\":\n              return \"cpu-optimized\";\n            case \"gpu\":\n              return \"gpu-optimized\";\n          }\n        });\n        const dataFormats = this.options.dataFormatPreference.map(format => {\n          switch (format) {\n            case \"ushort\":\n              return \"luminance-alpha\";\n            case \"float\":\n              return \"float32\";\n          }\n        });\n        resolve({\n          depthSensing: {\n            usagePreference: usages,\n            dataFormatPreference: dataFormats\n          }\n        });\n      } else {\n        resolve({});\n      }\n    });\n  }\n}\n/**\n * The module's name\n */\nWebXRDepthSensing.Name = WebXRFeatureName.DEPTH_SENSING;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRDepthSensing.Version = 1;\nWebXRFeaturesManager.AddWebXRFeature(WebXRDepthSensing.Name, (xrSessionManager, options) => {\n  return () => new WebXRDepthSensing(xrSessionManager, options);\n}, WebXRDepthSensing.Version, false);","map":{"version":3,"names":["RawTexture","WebXRFeatureName","WebXRFeaturesManager","WebXRAbstractFeature","Tools","Texture","Engine","Observable","WebGLHardwareTexture","InternalTexture","InternalTextureSource","WebXRDepthSensing","width","_width","height","_height","rawValueToMeters","_rawValueToMeters","normDepthBufferFromNormView","_normDepthBufferFromNormView","depthUsage","_xrSessionManager","session","depthDataFormat","latestInternalTexture","_cachedWebGLTexture","engine","scene","getEngine","internalTexture","Unknown","isCube","invertY","_useSRGBBuffer","format","generateMipMaps","type","samplingMode","_a","_b","_cachedWrapU","_cachedWrapV","_hardwareTexture","_gl","latestDepthBuffer","_cachedDepthBuffer","Uint16Array","Float32Array","latestDepthImageTexture","_cachedDepthImageTexture","constructor","options","onGetDepthInMetersAvailable","xrNativeFeatureName","Warn","attach","force","isBothDepthUsageAndFormatNull","_glBinding","XRWebGLBinding","dispose","_onXRFrame","_xrFrame","referenceSPace","referenceSpace","pose","getViewerPose","view","views","_updateDepthInformationAndTextureCPUDepthUsage","_updateDepthInformationAndTextureWebGLDepthUsage","Error","detach","frame","dataFormat","depthInfo","getDepthInformation","data","getDepthInMeters","notifyObservers","bind","CreateRTexture","NEAREST_SAMPLINGMODE","TEXTURETYPE_FLOAT","update","from","map","value","webglBinding","texture","wrapWebGLTexture","TEXTURETYPE_UNSIGNED_BYTE","_texture","getXRSessionInitExtension","isDepthUsageDeclared","usagePreference","length","isDataFormatDeclared","dataFormatPreference","Promise","resolve","usages","usage","dataFormats","depthSensing","Name","DEPTH_SENSING","Version","AddWebXRFeature","xrSessionManager"],"sources":["../../../../../dev/core/src/XR/features/WebXRDepthSensing.ts"],"sourcesContent":["import { RawTexture } from \"../../Materials/Textures/rawTexture\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Engine } from \"../../Engines/engine\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { WebGLHardwareTexture } from \"../../Engines/WebGL/webGLHardwareTexture\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\n\r\nexport type WebXRDepthUsage = \"cpu\" | \"gpu\";\r\nexport type WebXRDepthDataFormat = \"ushort\" | \"float\";\r\n\r\n/**\r\n * Options for Depth Sensing feature\r\n */\r\nexport interface IWebXRDepthSensingOptions {\r\n    /**\r\n     *  The desired depth sensing usage for the session\r\n     */\r\n    usagePreference: WebXRDepthUsage[];\r\n    /**\r\n     * The desired depth sensing data format for the session\r\n     */\r\n    dataFormatPreference: WebXRDepthDataFormat[];\r\n}\r\n\r\ntype GetDepthInMetersType = (x: number, y: number) => number;\r\n\r\n/**\r\n * WebXR Feature for WebXR Depth Sensing Module\r\n * @since 5.49.1\r\n */\r\nexport class WebXRDepthSensing extends WebXRAbstractFeature {\r\n    private _width: Nullable<number> = null;\r\n    private _height: Nullable<number> = null;\r\n    private _rawValueToMeters: Nullable<number> = null;\r\n    private _normDepthBufferFromNormView: Nullable<XRRigidTransform> = null;\r\n    private _cachedDepthBuffer: Nullable<ArrayBuffer> = null;\r\n    private _cachedWebGLTexture: Nullable<WebGLTexture> = null;\r\n    private _cachedDepthImageTexture: Nullable<RawTexture> = null;\r\n\r\n    /**\r\n     * Width of depth data. If depth data is not exist, returns null.\r\n     */\r\n    public get width(): Nullable<number> {\r\n        return this._width;\r\n    }\r\n\r\n    /**\r\n     * Height of depth data. If depth data is not exist, returns null.\r\n     */\r\n    public get height(): Nullable<number> {\r\n        return this._height;\r\n    }\r\n\r\n    /**\r\n     * Scale factor by which the raw depth values must be multiplied in order to get the depths in meters.\r\n     */\r\n    public get rawValueToMeters(): Nullable<number> {\r\n        return this._rawValueToMeters;\r\n    }\r\n\r\n    /**\r\n     * An XRRigidTransform that needs to be applied when indexing into the depth buffer.\r\n     */\r\n    public get normDepthBufferFromNormView(): Nullable<XRRigidTransform> {\r\n        return this._normDepthBufferFromNormView;\r\n    }\r\n\r\n    /**\r\n     * Describes which depth-sensing usage (\"cpu\" or \"gpu\") is used.\r\n     */\r\n    public get depthUsage(): WebXRDepthUsage {\r\n        switch (this._xrSessionManager.session.depthUsage) {\r\n            case \"cpu-optimized\":\r\n                return \"cpu\";\r\n            case \"gpu-optimized\":\r\n                return \"gpu\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Describes which depth sensing data format (\"ushort\" or \"float\") is used.\r\n     */\r\n    public get depthDataFormat(): WebXRDepthDataFormat {\r\n        switch (this._xrSessionManager.session.depthDataFormat) {\r\n            case \"luminance-alpha\":\r\n                return \"ushort\";\r\n            case \"float32\":\r\n                return \"float\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Latest cached InternalTexture which containing depth buffer information.\r\n     * This can be used when the depth usage is \"gpu\".\r\n     */\r\n    public get latestInternalTexture(): Nullable<InternalTexture> {\r\n        if (!this._cachedWebGLTexture) {\r\n            return null;\r\n        }\r\n\r\n        const engine = this._xrSessionManager.scene.getEngine();\r\n        const internalTexture = new InternalTexture(engine, InternalTextureSource.Unknown);\r\n        internalTexture.isCube = false;\r\n        internalTexture.invertY = false;\r\n        internalTexture._useSRGBBuffer = false;\r\n        internalTexture.format = this.depthDataFormat === \"ushort\" ? Constants.TEXTUREFORMAT_LUMINANCE_ALPHA : Constants.TEXTUREFORMAT_RGBA;\r\n        internalTexture.generateMipMaps = false;\r\n        internalTexture.type = this.depthDataFormat === \"ushort\" ? Constants.TEXTURETYPE_UNSIGNED_SHORT : Constants.TEXTURETYPE_FLOAT;\r\n        internalTexture.samplingMode = Constants.TEXTURE_NEAREST_LINEAR;\r\n        internalTexture.width = this.width ?? 0;\r\n        internalTexture.height = this.height ?? 0;\r\n        internalTexture._cachedWrapU = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n        internalTexture._cachedWrapV = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n        internalTexture._hardwareTexture = new WebGLHardwareTexture(this._cachedWebGLTexture, engine._gl);\r\n\r\n        return internalTexture;\r\n    }\r\n\r\n    /**\r\n     * cached depth buffer\r\n     */\r\n    public get latestDepthBuffer(): Nullable<ArrayBufferView> {\r\n        if (!this._cachedDepthBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return this.depthDataFormat === \"ushort\" ? new Uint16Array(this._cachedDepthBuffer) : new Float32Array(this._cachedDepthBuffer);\r\n    }\r\n\r\n    /**\r\n     * Event that notify when `DepthInformation.getDepthInMeters` is available.\r\n     * `getDepthInMeters` method needs active XRFrame (not available for cached XRFrame)\r\n     */\r\n    public onGetDepthInMetersAvailable: Observable<GetDepthInMetersType> = new Observable<GetDepthInMetersType>();\r\n\r\n    /**\r\n     * Latest cached Texture of depth image which is made from the depth buffer data.\r\n     */\r\n    public get latestDepthImageTexture(): Nullable<RawTexture> {\r\n        return this._cachedDepthImageTexture;\r\n    }\r\n\r\n    /**\r\n     * XRWebGLBinding which is used for acquiring WebGLDepthInformation\r\n     */\r\n    private _glBinding?: XRWebGLBinding;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.DEPTH_SENSING;\r\n\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Creates a new instance of the depth sensing feature\r\n     * @param _xrSessionManager the WebXRSessionManager\r\n     * @param options options for WebXR Depth Sensing Feature\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, public readonly options: IWebXRDepthSensingOptions) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"depth-sensing\";\r\n\r\n        // https://immersive-web.github.io/depth-sensing/\r\n        Tools.Warn(\"depth-sensing is an experimental and unstable feature.\");\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(force?: boolean | undefined): boolean {\r\n        if (!super.attach(force)) {\r\n            return false;\r\n        }\r\n\r\n        const isBothDepthUsageAndFormatNull = this._xrSessionManager.session.depthDataFormat == null || this._xrSessionManager.session.depthUsage == null;\r\n        if (isBothDepthUsageAndFormatNull) {\r\n            return false;\r\n        }\r\n\r\n        this._glBinding = new XRWebGLBinding(this._xrSessionManager.session, this._xrSessionManager.scene.getEngine()._gl);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        this._cachedDepthImageTexture?.dispose();\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame): void {\r\n        const referenceSPace = this._xrSessionManager.referenceSpace;\r\n\r\n        const pose = _xrFrame.getViewerPose(referenceSPace);\r\n        if (pose == null) {\r\n            return;\r\n        }\r\n\r\n        for (const view of pose.views) {\r\n            switch (this.depthUsage) {\r\n                case \"cpu\":\r\n                    this._updateDepthInformationAndTextureCPUDepthUsage(_xrFrame, view, this.depthDataFormat);\r\n                    break;\r\n\r\n                case \"gpu\":\r\n                    if (!this._glBinding) {\r\n                        break;\r\n                    }\r\n\r\n                    this._updateDepthInformationAndTextureWebGLDepthUsage(this._glBinding, view, this.depthDataFormat);\r\n                    break;\r\n\r\n                default:\r\n                    Tools.Error(\"Unknown depth usage\");\r\n                    this.detach();\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _updateDepthInformationAndTextureCPUDepthUsage(frame: XRFrame, view: XRView, dataFormat: WebXRDepthDataFormat): void {\r\n        const depthInfo = frame.getDepthInformation(view);\r\n        if (depthInfo === null) {\r\n            return;\r\n        }\r\n\r\n        const { data, width, height, rawValueToMeters, getDepthInMeters } = depthInfo as XRCPUDepthInformation;\r\n\r\n        this._width = width;\r\n        this._height = height;\r\n        this._rawValueToMeters = rawValueToMeters;\r\n        this._cachedDepthBuffer = data;\r\n\r\n        // to avoid Illegal Invocation error, bind `this`\r\n        this.onGetDepthInMetersAvailable.notifyObservers(getDepthInMeters.bind(depthInfo));\r\n\r\n        if (!this._cachedDepthImageTexture) {\r\n            this._cachedDepthImageTexture = RawTexture.CreateRTexture(\r\n                null,\r\n                width,\r\n                height,\r\n                this._xrSessionManager.scene,\r\n                false,\r\n                true,\r\n                Texture.NEAREST_SAMPLINGMODE,\r\n                Engine.TEXTURETYPE_FLOAT\r\n            );\r\n        }\r\n\r\n        switch (dataFormat) {\r\n            case \"ushort\":\r\n                this._cachedDepthImageTexture.update(Float32Array.from(new Uint16Array(data)).map((value) => value * rawValueToMeters));\r\n                break;\r\n\r\n            case \"float\":\r\n                this._cachedDepthImageTexture.update(new Float32Array(data).map((value) => value * rawValueToMeters));\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    private _updateDepthInformationAndTextureWebGLDepthUsage(webglBinding: XRWebGLBinding, view: XRView, dataFormat: WebXRDepthDataFormat): void {\r\n        const depthInfo = webglBinding.getDepthInformation(view);\r\n        if (depthInfo === null) {\r\n            return;\r\n        }\r\n\r\n        const { texture, width, height } = depthInfo as XRWebGLDepthInformation;\r\n\r\n        this._width = width;\r\n        this._height = height;\r\n        this._cachedWebGLTexture = texture;\r\n\r\n        const scene = this._xrSessionManager.scene;\r\n        const engine = scene.getEngine();\r\n        const internalTexture = engine.wrapWebGLTexture(texture);\r\n\r\n        if (!this._cachedDepthImageTexture) {\r\n            this._cachedDepthImageTexture = RawTexture.CreateRTexture(\r\n                null,\r\n                width,\r\n                height,\r\n                scene,\r\n                false,\r\n                true,\r\n                Texture.NEAREST_SAMPLINGMODE,\r\n                dataFormat === \"ushort\" ? Engine.TEXTURETYPE_UNSIGNED_BYTE : Engine.TEXTURETYPE_FLOAT\r\n            );\r\n        }\r\n\r\n        this._cachedDepthImageTexture._texture = internalTexture;\r\n    }\r\n\r\n    /**\r\n     * Extends the session init object if needed\r\n     * @returns augmentation object for the xr session init object.\r\n     */\r\n    public getXRSessionInitExtension(): Promise<Partial<XRSessionInit>> {\r\n        const isDepthUsageDeclared = this.options.usagePreference != null && this.options.usagePreference.length !== 0;\r\n        const isDataFormatDeclared = this.options.dataFormatPreference != null && this.options.dataFormatPreference.length !== 0;\r\n\r\n        return new Promise((resolve) => {\r\n            if (isDepthUsageDeclared && isDataFormatDeclared) {\r\n                const usages: XRDepthUsage[] = this.options.usagePreference.map((usage) => {\r\n                    switch (usage) {\r\n                        case \"cpu\":\r\n                            return \"cpu-optimized\";\r\n                        case \"gpu\":\r\n                            return \"gpu-optimized\";\r\n                    }\r\n                });\r\n                const dataFormats: XRDepthDataFormat[] = this.options.dataFormatPreference.map((format) => {\r\n                    switch (format) {\r\n                        case \"ushort\":\r\n                            return \"luminance-alpha\";\r\n                        case \"float\":\r\n                            return \"float32\";\r\n                    }\r\n                });\r\n\r\n                resolve({\r\n                    depthSensing: {\r\n                        usagePreference: usages,\r\n                        dataFormatPreference: dataFormats,\r\n                    },\r\n                });\r\n            } else {\r\n                resolve({});\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRDepthSensing.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRDepthSensing(xrSessionManager, options);\r\n    },\r\n    WebXRDepthSensing.Version,\r\n    false\r\n);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}