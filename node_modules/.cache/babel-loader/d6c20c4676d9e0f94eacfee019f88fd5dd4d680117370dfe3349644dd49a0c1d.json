{"ast":null,"code":"import \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\nimport \"core-js/modules/es.array.push.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { WebRequest } from \"./webRequest.js\";\nimport { IsWindowObjectExist } from \"./domManagement.js\";\nimport { Observable } from \"./observable.js\";\nimport { FilesInputStore } from \"./filesInputStore.js\";\nimport { RetryStrategy } from \"./retryStrategy.js\";\nimport { BaseError, ErrorCodes, RuntimeError } from \"./error.js\";\nimport { DecodeBase64ToBinary, DecodeBase64ToString, EncodeArrayBufferToBase64 } from \"./stringTools.js\";\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor.js\";\nimport { ThinEngine } from \"../Engines/thinEngine.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Logger } from \"./logger.js\";\nimport { TimingTools } from \"./timingTools.js\";\nconst Base64DataUrlRegEx = new RegExp(/^data:([^,]+\\/[^,]+)?;base64,/i);\n/** @ignore */\nexport class LoadFileError extends RuntimeError {\n  /**\n   * Creates a new LoadFileError\n   * @param message defines the message of the error\n   * @param object defines the optional web request\n   */\n  constructor(message, object) {\n    super(message, ErrorCodes.LoadFileError);\n    this.name = \"LoadFileError\";\n    BaseError._setPrototypeOf(this, LoadFileError.prototype);\n    if (object instanceof WebRequest) {\n      this.request = object;\n    } else {\n      this.file = object;\n    }\n  }\n}\n/** @ignore */\nexport class RequestFileError extends RuntimeError {\n  /**\n   * Creates a new LoadFileError\n   * @param message defines the message of the error\n   * @param request defines the optional web request\n   */\n  constructor(message, request) {\n    super(message, ErrorCodes.RequestFileError);\n    this.request = request;\n    this.name = \"RequestFileError\";\n    BaseError._setPrototypeOf(this, RequestFileError.prototype);\n  }\n}\n/** @ignore */\nexport class ReadFileError extends RuntimeError {\n  /**\n   * Creates a new ReadFileError\n   * @param message defines the message of the error\n   * @param file defines the optional file\n   */\n  constructor(message, file) {\n    super(message, ErrorCodes.ReadFileError);\n    this.file = file;\n    this.name = \"ReadFileError\";\n    BaseError._setPrototypeOf(this, ReadFileError.prototype);\n  }\n}\n/**\n * @internal\n */\nexport const FileToolsOptions = {\n  /**\n   * Gets or sets the retry strategy to apply when an error happens while loading an asset.\n   * When defining this function, return the wait time before trying again or return -1 to\n   * stop retrying and error out.\n   */\n  DefaultRetryStrategy: RetryStrategy.ExponentialBackoff(),\n  /**\n   * Gets or sets the base URL to use to load assets\n   */\n  BaseUrl: \"\",\n  /**\n   * Default behaviour for cors in the application.\n   * It can be a string if the expected behavior is identical in the entire app.\n   * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)\n   */\n  CorsBehavior: \"anonymous\",\n  /**\n   * Gets or sets a function used to pre-process url before using them to load assets\n   * @param url\n   */\n  PreprocessUrl: url => url,\n  /**\n   * Gets or sets the base URL to use to load scripts\n   * Used for both JS and WASM\n   */\n  ScriptBaseUrl: \"https://cdn.babylonjs.com/\",\n  /**\n   * Gets or sets a function used to pre-process script url before using them to load.\n   * Used for both JS and WASM\n   * @param url defines the url to process\n   */\n  ScriptPreprocessUrl: url => url\n};\n/**\n * Removes unwanted characters from an url\n * @param url defines the url to clean\n * @returns the cleaned url\n */\nconst _CleanUrl = url => {\n  url = url.replace(/#/gm, \"%23\");\n  return url;\n};\n/**\n * Sets the cors behavior on a dom element. This will add the required Tools.CorsBehavior to the element.\n * @param url define the url we are trying\n * @param element define the dom element where to configure the cors policy\n * @internal\n */\nexport const SetCorsBehavior = (url, element) => {\n  if (url && url.indexOf(\"data:\") === 0) {\n    return;\n  }\n  if (FileToolsOptions.CorsBehavior) {\n    if (typeof FileToolsOptions.CorsBehavior === \"string\" || FileToolsOptions.CorsBehavior instanceof String) {\n      element.crossOrigin = FileToolsOptions.CorsBehavior;\n    } else {\n      const result = FileToolsOptions.CorsBehavior(url);\n      if (result) {\n        element.crossOrigin = result;\n      }\n    }\n  }\n};\n/**\n * Loads an image as an HTMLImageElement.\n * @param input url string, ArrayBuffer, or Blob to load\n * @param onLoad callback called when the image successfully loads\n * @param onError callback called when the image fails to load\n * @param offlineProvider offline provider for caching\n * @param mimeType optional mime type\n * @param imageBitmapOptions\n * @returns the HTMLImageElement of the loaded image\n * @internal\n */\nexport const LoadImage = (input, onLoad, onError, offlineProvider, mimeType = \"\", imageBitmapOptions) => {\n  var _a;\n  let url;\n  let usingObjectURL = false;\n  if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {\n    if (typeof Blob !== \"undefined\" && typeof URL !== \"undefined\") {\n      url = URL.createObjectURL(new Blob([input], {\n        type: mimeType\n      }));\n      usingObjectURL = true;\n    } else {\n      url = `data:${mimeType};base64,` + EncodeArrayBufferToBase64(input);\n    }\n  } else if (input instanceof Blob) {\n    url = URL.createObjectURL(input);\n    usingObjectURL = true;\n  } else {\n    url = _CleanUrl(input);\n    url = FileToolsOptions.PreprocessUrl(input);\n  }\n  const engine = EngineStore.LastCreatedEngine;\n  const onErrorHandler = exception => {\n    if (onError) {\n      const inputText = url || input.toString();\n      onError(`Error while trying to load image: ${inputText.indexOf(\"http\") === 0 || inputText.length <= 128 ? inputText : inputText.slice(0, 128) + \"...\"}`, exception);\n    }\n  };\n  if (typeof Image === \"undefined\" || ((_a = engine === null || engine === void 0 ? void 0 : engine._features.forceBitmapOverHTMLImageElement) !== null && _a !== void 0 ? _a : false)) {\n    LoadFile(url, data => {\n      engine.createImageBitmap(new Blob([data], {\n        type: mimeType\n      }), Object.assign({\n        premultiplyAlpha: \"none\"\n      }, imageBitmapOptions)).then(imgBmp => {\n        onLoad(imgBmp);\n        if (usingObjectURL) {\n          URL.revokeObjectURL(url);\n        }\n      }).catch(reason => {\n        if (onError) {\n          onError(\"Error while trying to load image: \" + input, reason);\n        }\n      });\n    }, undefined, offlineProvider || undefined, true, (request, exception) => {\n      onErrorHandler(exception);\n    });\n    return null;\n  }\n  const img = new Image();\n  SetCorsBehavior(url, img);\n  const handlersList = [];\n  const loadHandlersList = () => {\n    handlersList.forEach(handler => {\n      handler.target.addEventListener(handler.name, handler.handler);\n    });\n  };\n  const unloadHandlersList = () => {\n    handlersList.forEach(handler => {\n      handler.target.removeEventListener(handler.name, handler.handler);\n    });\n    handlersList.length = 0;\n  };\n  const loadHandler = () => {\n    unloadHandlersList();\n    onLoad(img);\n    // Must revoke the URL after calling onLoad to avoid security exceptions in\n    // certain scenarios (e.g. when hosted in vscode).\n    if (usingObjectURL && img.src) {\n      URL.revokeObjectURL(img.src);\n    }\n  };\n  const errorHandler = err => {\n    unloadHandlersList();\n    onErrorHandler(err);\n    if (usingObjectURL && img.src) {\n      URL.revokeObjectURL(img.src);\n    }\n  };\n  const cspHandler = err => {\n    if (err.blockedURI !== img.src) {\n      return;\n    }\n    unloadHandlersList();\n    const cspException = new Error(`CSP violation of policy ${err.effectiveDirective} ${err.blockedURI}. Current policy is ${err.originalPolicy}`);\n    EngineStore.UseFallbackTexture = false;\n    onErrorHandler(cspException);\n    if (usingObjectURL && img.src) {\n      URL.revokeObjectURL(img.src);\n    }\n    img.src = \"\";\n  };\n  handlersList.push({\n    target: img,\n    name: \"load\",\n    handler: loadHandler\n  });\n  handlersList.push({\n    target: img,\n    name: \"error\",\n    handler: errorHandler\n  });\n  handlersList.push({\n    target: document,\n    name: \"securitypolicyviolation\",\n    handler: cspHandler\n  });\n  loadHandlersList();\n  const fromBlob = url.substring(0, 5) === \"blob:\";\n  const fromData = url.substring(0, 5) === \"data:\";\n  const noOfflineSupport = () => {\n    if (fromBlob || fromData || !WebRequest.IsCustomRequestAvailable) {\n      img.src = url;\n    } else {\n      LoadFile(url, (data, _, contentType) => {\n        const type = !mimeType && contentType ? contentType : mimeType;\n        const blob = new Blob([data], {\n          type\n        });\n        const url = URL.createObjectURL(blob);\n        usingObjectURL = true;\n        img.src = url;\n      }, undefined, offlineProvider || undefined, true, (_request, exception) => {\n        onErrorHandler(exception);\n      });\n    }\n  };\n  const loadFromOfflineSupport = () => {\n    if (offlineProvider) {\n      offlineProvider.loadImage(url, img);\n    }\n  };\n  if (!fromBlob && !fromData && offlineProvider && offlineProvider.enableTexturesOffline) {\n    offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);\n  } else {\n    if (url.indexOf(\"file:\") !== -1) {\n      const textureName = decodeURIComponent(url.substring(5).toLowerCase());\n      if (FilesInputStore.FilesToLoad[textureName] && typeof URL !== \"undefined\") {\n        try {\n          let blobURL;\n          try {\n            blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\n          } catch (ex) {\n            // Chrome doesn't support oneTimeOnly parameter\n            blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\n          }\n          img.src = blobURL;\n          usingObjectURL = true;\n        } catch (e) {\n          img.src = \"\";\n        }\n        return img;\n      }\n    }\n    noOfflineSupport();\n  }\n  return img;\n};\n/**\n * Reads a file from a File object\n * @param file defines the file to load\n * @param onSuccess defines the callback to call when data is loaded\n * @param onProgress defines the callback to call during loading process\n * @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer\n * @param onError defines the callback to call when an error occurs\n * @returns a file request object\n * @internal\n */\nexport const ReadFile = (file, onSuccess, onProgress, useArrayBuffer, onError) => {\n  const reader = new FileReader();\n  const fileRequest = {\n    onCompleteObservable: new Observable(),\n    abort: () => reader.abort()\n  };\n  reader.onloadend = () => fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n  if (onError) {\n    reader.onerror = () => {\n      onError(new ReadFileError(`Unable to read ${file.name}`, file));\n    };\n  }\n  reader.onload = e => {\n    //target doesn't have result from ts 1.3\n    onSuccess(e.target[\"result\"]);\n  };\n  if (onProgress) {\n    reader.onprogress = onProgress;\n  }\n  if (!useArrayBuffer) {\n    // Asynchronous read\n    reader.readAsText(file);\n  } else {\n    reader.readAsArrayBuffer(file);\n  }\n  return fileRequest;\n};\n/**\n * Loads a file from a url, a data url, or a file url\n * @param fileOrUrl file, url, data url, or file url to load\n * @param onSuccess callback called when the file successfully loads\n * @param onProgress callback called while file is loading (if the server supports this mode)\n * @param offlineProvider defines the offline provider for caching\n * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\n * @param onError callback called when the file fails to load\n * @param onOpened\n * @returns a file request object\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const LoadFile = (fileOrUrl, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) => {\n  if (fileOrUrl.name) {\n    return ReadFile(fileOrUrl, onSuccess, onProgress, useArrayBuffer, onError ? error => {\n      onError(undefined, error);\n    } : undefined);\n  }\n  const url = fileOrUrl;\n  // If file and file input are set\n  if (url.indexOf(\"file:\") !== -1) {\n    let fileName = decodeURIComponent(url.substring(5).toLowerCase());\n    if (fileName.indexOf(\"./\") === 0) {\n      fileName = fileName.substring(2);\n    }\n    const file = FilesInputStore.FilesToLoad[fileName];\n    if (file) {\n      return ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError ? error => onError(undefined, new LoadFileError(error.message, error.file)) : undefined);\n    }\n  }\n  // For a Base64 Data URL\n  const {\n    match,\n    type\n  } = TestBase64DataUrl(url);\n  if (match) {\n    const fileRequest = {\n      onCompleteObservable: new Observable(),\n      abort: () => () => {}\n    };\n    try {\n      const data = useArrayBuffer ? DecodeBase64UrlToBinary(url) : DecodeBase64UrlToString(url);\n      onSuccess(data, undefined, type);\n    } catch (error) {\n      if (onError) {\n        onError(undefined, error);\n      } else {\n        Logger.Error(error.message || \"Failed to parse the Data URL\");\n      }\n    }\n    TimingTools.SetImmediate(() => {\n      fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n    });\n    return fileRequest;\n  }\n  return RequestFile(url, (data, request) => {\n    onSuccess(data, request === null || request === void 0 ? void 0 : request.responseURL, request === null || request === void 0 ? void 0 : request.getResponseHeader(\"content-type\"));\n  }, onProgress, offlineProvider, useArrayBuffer, onError ? error => {\n    onError(error.request, new LoadFileError(error.message, error.request));\n  } : undefined, onOpened);\n};\n/**\n * Loads a file from a url\n * @param url url to load\n * @param onSuccess callback called when the file successfully loads\n * @param onProgress callback called while file is loading (if the server supports this mode)\n * @param offlineProvider defines the offline provider for caching\n * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\n * @param onError callback called when the file fails to load\n * @param onOpened callback called when the web request is opened\n * @returns a file request object\n * @internal\n */\nexport const RequestFile = (url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) => {\n  url = _CleanUrl(url);\n  url = FileToolsOptions.PreprocessUrl(url);\n  const loadUrl = FileToolsOptions.BaseUrl + url;\n  let aborted = false;\n  const fileRequest = {\n    onCompleteObservable: new Observable(),\n    abort: () => aborted = true\n  };\n  const requestFile = () => {\n    let request = new WebRequest();\n    let retryHandle = null;\n    let onReadyStateChange;\n    const unbindEvents = () => {\n      if (!request) {\n        return;\n      }\n      if (onProgress) {\n        request.removeEventListener(\"progress\", onProgress);\n      }\n      if (onReadyStateChange) {\n        request.removeEventListener(\"readystatechange\", onReadyStateChange);\n      }\n      request.removeEventListener(\"loadend\", onLoadEnd);\n    };\n    let onLoadEnd = () => {\n      unbindEvents();\n      fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n      fileRequest.onCompleteObservable.clear();\n      onProgress = undefined;\n      onReadyStateChange = null;\n      onLoadEnd = null;\n      onError = undefined;\n      onOpened = undefined;\n      onSuccess = undefined;\n    };\n    fileRequest.abort = () => {\n      aborted = true;\n      if (onLoadEnd) {\n        onLoadEnd();\n      }\n      if (request && request.readyState !== (XMLHttpRequest.DONE || 4)) {\n        request.abort();\n      }\n      if (retryHandle !== null) {\n        clearTimeout(retryHandle);\n        retryHandle = null;\n      }\n      request = null;\n    };\n    const handleError = error => {\n      const message = error.message || \"Unknown error\";\n      if (onError && request) {\n        onError(new RequestFileError(message, request));\n      } else {\n        Logger.Error(message);\n      }\n    };\n    const retryLoop = retryIndex => {\n      if (!request) {\n        return;\n      }\n      request.open(\"GET\", loadUrl);\n      if (onOpened) {\n        try {\n          onOpened(request);\n        } catch (e) {\n          handleError(e);\n          return;\n        }\n      }\n      if (useArrayBuffer) {\n        request.responseType = \"arraybuffer\";\n      }\n      if (onProgress) {\n        request.addEventListener(\"progress\", onProgress);\n      }\n      if (onLoadEnd) {\n        request.addEventListener(\"loadend\", onLoadEnd);\n      }\n      onReadyStateChange = () => {\n        if (aborted || !request) {\n          return;\n        }\n        // In case of undefined state in some browsers.\n        if (request.readyState === (XMLHttpRequest.DONE || 4)) {\n          // Some browsers have issues where onreadystatechange can be called multiple times with the same value.\n          if (onReadyStateChange) {\n            request.removeEventListener(\"readystatechange\", onReadyStateChange);\n          }\n          if (request.status >= 200 && request.status < 300 || request.status === 0 && (!IsWindowObjectExist() || IsFileURL())) {\n            try {\n              if (onSuccess) {\n                onSuccess(useArrayBuffer ? request.response : request.responseText, request);\n              }\n            } catch (e) {\n              handleError(e);\n            }\n            return;\n          }\n          const retryStrategy = FileToolsOptions.DefaultRetryStrategy;\n          if (retryStrategy) {\n            const waitTime = retryStrategy(loadUrl, request, retryIndex);\n            if (waitTime !== -1) {\n              // Prevent the request from completing for retry.\n              unbindEvents();\n              request = new WebRequest();\n              retryHandle = setTimeout(() => retryLoop(retryIndex + 1), waitTime);\n              return;\n            }\n          }\n          const error = new RequestFileError(\"Error status: \" + request.status + \" \" + request.statusText + \" - Unable to load \" + loadUrl, request);\n          if (onError) {\n            onError(error);\n          }\n        }\n      };\n      request.addEventListener(\"readystatechange\", onReadyStateChange);\n      request.send();\n    };\n    retryLoop(0);\n  };\n  // Caching all files\n  if (offlineProvider && offlineProvider.enableSceneOffline) {\n    const noOfflineSupport = request => {\n      if (request && request.status > 400) {\n        if (onError) {\n          onError(request);\n        }\n      } else {\n        requestFile();\n      }\n    };\n    const loadFromOfflineSupport = () => {\n      // TODO: database needs to support aborting and should return a IFileRequest\n      if (offlineProvider) {\n        offlineProvider.loadFile(FileToolsOptions.BaseUrl + url, data => {\n          if (!aborted && onSuccess) {\n            onSuccess(data);\n          }\n          fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n        }, onProgress ? event => {\n          if (!aborted && onProgress) {\n            onProgress(event);\n          }\n        } : undefined, noOfflineSupport, useArrayBuffer);\n      }\n    };\n    offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);\n  } else {\n    requestFile();\n  }\n  return fileRequest;\n};\n/**\n * Checks if the loaded document was accessed via `file:`-Protocol.\n * @returns boolean\n * @internal\n */\nexport const IsFileURL = () => {\n  return typeof location !== \"undefined\" && location.protocol === \"file:\";\n};\n/**\n * Test if the given uri is a valid base64 data url\n * @param uri The uri to test\n * @returns True if the uri is a base64 data url or false otherwise\n * @internal\n */\nexport const IsBase64DataUrl = uri => {\n  return Base64DataUrlRegEx.test(uri);\n};\nexport const TestBase64DataUrl = uri => {\n  const results = Base64DataUrlRegEx.exec(uri);\n  if (results === null || results.length === 0) {\n    return {\n      match: false,\n      type: \"\"\n    };\n  } else {\n    const type = results[0].replace(\"data:\", \"\").replace(\"base64,\", \"\");\n    return {\n      match: true,\n      type\n    };\n  }\n};\n/**\n * Decode the given base64 uri.\n * @param uri The uri to decode\n * @returns The decoded base64 data.\n * @internal\n */\nexport function DecodeBase64UrlToBinary(uri) {\n  return DecodeBase64ToBinary(uri.split(\",\")[1]);\n}\n/**\n * Decode the given base64 uri into a UTF-8 encoded string.\n * @param uri The uri to decode\n * @returns The decoded base64 data.\n * @internal\n */\nexport const DecodeBase64UrlToString = uri => {\n  return DecodeBase64ToString(uri.split(\",\")[1]);\n};\n/**\n * This will be executed automatically for UMD and es5.\n * If esm dev wants the side effects to execute they will have to run it manually\n * Once we build native modules those need to be exported.\n * @internal\n */\nconst initSideEffects = () => {\n  ThinEngine._FileToolsLoadImage = LoadImage;\n  ThinEngine._FileToolsLoadFile = LoadFile;\n  ShaderProcessor._FileToolsLoadFile = LoadFile;\n};\ninitSideEffects();\n// deprecated\n/**\n * FileTools defined as any.\n * This should not be imported or used in future releases or in any module in the framework\n * @internal\n * @deprecated import the needed function from fileTools.ts\n */\nexport let FileTools;\n/**\n * @param DecodeBase64UrlToBinary\n * @param DecodeBase64UrlToString\n * @param FileToolsOptions\n * @internal\n */\nexport const _injectLTSFileTools = (DecodeBase64UrlToBinary, DecodeBase64UrlToString, FileToolsOptions, IsBase64DataUrl, IsFileURL, LoadFile, LoadImage, ReadFile, RequestFile, SetCorsBehavior) => {\n  /**\n   * Backwards compatibility.\n   * @internal\n   * @deprecated\n   */\n  FileTools = {\n    DecodeBase64UrlToBinary,\n    DecodeBase64UrlToString,\n    DefaultRetryStrategy: FileToolsOptions.DefaultRetryStrategy,\n    BaseUrl: FileToolsOptions.BaseUrl,\n    CorsBehavior: FileToolsOptions.CorsBehavior,\n    PreprocessUrl: FileToolsOptions.PreprocessUrl,\n    IsBase64DataUrl,\n    IsFileURL,\n    LoadFile,\n    LoadImage,\n    ReadFile,\n    RequestFile,\n    SetCorsBehavior\n  };\n  Object.defineProperty(FileTools, \"DefaultRetryStrategy\", {\n    get: function () {\n      return FileToolsOptions.DefaultRetryStrategy;\n    },\n    set: function (value) {\n      FileToolsOptions.DefaultRetryStrategy = value;\n    }\n  });\n  Object.defineProperty(FileTools, \"BaseUrl\", {\n    get: function () {\n      return FileToolsOptions.BaseUrl;\n    },\n    set: function (value) {\n      FileToolsOptions.BaseUrl = value;\n    }\n  });\n  Object.defineProperty(FileTools, \"PreprocessUrl\", {\n    get: function () {\n      return FileToolsOptions.PreprocessUrl;\n    },\n    set: function (value) {\n      FileToolsOptions.PreprocessUrl = value;\n    }\n  });\n  Object.defineProperty(FileTools, \"CorsBehavior\", {\n    get: function () {\n      return FileToolsOptions.CorsBehavior;\n    },\n    set: function (value) {\n      FileToolsOptions.CorsBehavior = value;\n    }\n  });\n};\n_injectLTSFileTools(DecodeBase64UrlToBinary, DecodeBase64UrlToString, FileToolsOptions, IsBase64DataUrl, IsFileURL, LoadFile, LoadImage, ReadFile, RequestFile, SetCorsBehavior);","map":{"version":3,"names":["WebRequest","IsWindowObjectExist","Observable","FilesInputStore","RetryStrategy","BaseError","ErrorCodes","RuntimeError","DecodeBase64ToBinary","DecodeBase64ToString","EncodeArrayBufferToBase64","ShaderProcessor","ThinEngine","EngineStore","Logger","TimingTools","Base64DataUrlRegEx","RegExp","LoadFileError","constructor","message","object","name","_setPrototypeOf","prototype","request","file","RequestFileError","ReadFileError","FileToolsOptions","DefaultRetryStrategy","ExponentialBackoff","BaseUrl","CorsBehavior","PreprocessUrl","url","ScriptBaseUrl","ScriptPreprocessUrl","_CleanUrl","replace","SetCorsBehavior","element","indexOf","String","crossOrigin","result","LoadImage","input","onLoad","onError","offlineProvider","mimeType","imageBitmapOptions","usingObjectURL","ArrayBuffer","isView","Blob","URL","createObjectURL","type","engine","LastCreatedEngine","onErrorHandler","exception","inputText","toString","length","slice","Image","_a","_features","forceBitmapOverHTMLImageElement","LoadFile","data","createImageBitmap","Object","assign","premultiplyAlpha","then","imgBmp","revokeObjectURL","catch","reason","undefined","img","handlersList","loadHandlersList","forEach","handler","target","addEventListener","unloadHandlersList","removeEventListener","loadHandler","src","errorHandler","err","cspHandler","blockedURI","cspException","Error","effectiveDirective","originalPolicy","UseFallbackTexture","push","document","fromBlob","substring","fromData","noOfflineSupport","IsCustomRequestAvailable","_","contentType","blob","_request","loadFromOfflineSupport","loadImage","enableTexturesOffline","open","textureName","decodeURIComponent","toLowerCase","FilesToLoad","blobURL","ex","e","ReadFile","onSuccess","onProgress","useArrayBuffer","reader","FileReader","fileRequest","onCompleteObservable","abort","onloadend","notifyObservers","onerror","onload","onprogress","readAsText","readAsArrayBuffer","fileOrUrl","onOpened","error","fileName","match","TestBase64DataUrl","DecodeBase64UrlToBinary","DecodeBase64UrlToString","SetImmediate","RequestFile","responseURL","getResponseHeader","loadUrl","aborted","requestFile","retryHandle","onReadyStateChange","unbindEvents","onLoadEnd","clear","readyState","XMLHttpRequest","DONE","clearTimeout","handleError","retryLoop","retryIndex","responseType","status","IsFileURL","response","responseText","retryStrategy","waitTime","setTimeout","statusText","send","enableSceneOffline","loadFile","event","location","protocol","IsBase64DataUrl","uri","test","results","exec","split","initSideEffects","_FileToolsLoadImage","_FileToolsLoadFile","FileTools","_injectLTSFileTools","defineProperty","get","set","value"],"sources":["../../../../dev/core/src/Misc/fileTools.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { WebRequest } from \"./webRequest\";\r\nimport { IsWindowObjectExist } from \"./domManagement\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { IOfflineProvider } from \"../Offline/IOfflineProvider\";\r\nimport type { IFileRequest } from \"./fileRequest\";\r\nimport { Observable } from \"./observable\";\r\nimport { FilesInputStore } from \"./filesInputStore\";\r\nimport { RetryStrategy } from \"./retryStrategy\";\r\nimport { BaseError, ErrorCodes, RuntimeError } from \"./error\";\r\nimport { DecodeBase64ToBinary, DecodeBase64ToString, EncodeArrayBufferToBase64 } from \"./stringTools\";\r\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor\";\r\nimport { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Logger } from \"./logger\";\r\nimport { TimingTools } from \"./timingTools\";\r\n\r\nconst Base64DataUrlRegEx = new RegExp(/^data:([^,]+\\/[^,]+)?;base64,/i);\r\n\r\n/** @ignore */\r\nexport class LoadFileError extends RuntimeError {\r\n    public request?: WebRequest;\r\n    public file?: File;\r\n\r\n    /**\r\n     * Creates a new LoadFileError\r\n     * @param message defines the message of the error\r\n     * @param object defines the optional web request\r\n     */\r\n    constructor(message: string, object?: WebRequest | File) {\r\n        super(message, ErrorCodes.LoadFileError);\r\n\r\n        this.name = \"LoadFileError\";\r\n        BaseError._setPrototypeOf(this, LoadFileError.prototype);\r\n\r\n        if (object instanceof WebRequest) {\r\n            this.request = object;\r\n        } else {\r\n            this.file = object;\r\n        }\r\n    }\r\n}\r\n\r\n/** @ignore */\r\nexport class RequestFileError extends RuntimeError {\r\n    /**\r\n     * Creates a new LoadFileError\r\n     * @param message defines the message of the error\r\n     * @param request defines the optional web request\r\n     */\r\n    constructor(message: string, public request: WebRequest) {\r\n        super(message, ErrorCodes.RequestFileError);\r\n        this.name = \"RequestFileError\";\r\n        BaseError._setPrototypeOf(this, RequestFileError.prototype);\r\n    }\r\n}\r\n\r\n/** @ignore */\r\nexport class ReadFileError extends RuntimeError {\r\n    /**\r\n     * Creates a new ReadFileError\r\n     * @param message defines the message of the error\r\n     * @param file defines the optional file\r\n     */\r\n    constructor(message: string, public file: File) {\r\n        super(message, ErrorCodes.ReadFileError);\r\n        this.name = \"ReadFileError\";\r\n        BaseError._setPrototypeOf(this, ReadFileError.prototype);\r\n    }\r\n}\r\n/**\r\n * @internal\r\n */\r\nexport const FileToolsOptions: {\r\n    DefaultRetryStrategy: (url: string, request: WebRequest, retryIndex: number) => number;\r\n    BaseUrl: string;\r\n    CorsBehavior: string | ((url: string | string[]) => string);\r\n    PreprocessUrl: (url: string) => string;\r\n    ScriptBaseUrl: string;\r\n    ScriptPreprocessUrl: (url: string) => string;\r\n} = {\r\n    /**\r\n     * Gets or sets the retry strategy to apply when an error happens while loading an asset.\r\n     * When defining this function, return the wait time before trying again or return -1 to\r\n     * stop retrying and error out.\r\n     */\r\n    DefaultRetryStrategy: RetryStrategy.ExponentialBackoff(),\r\n\r\n    /**\r\n     * Gets or sets the base URL to use to load assets\r\n     */\r\n    BaseUrl: \"\",\r\n\r\n    /**\r\n     * Default behaviour for cors in the application.\r\n     * It can be a string if the expected behavior is identical in the entire app.\r\n     * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)\r\n     */\r\n    CorsBehavior: \"anonymous\",\r\n\r\n    /**\r\n     * Gets or sets a function used to pre-process url before using them to load assets\r\n     * @param url\r\n     */\r\n    PreprocessUrl: (url: string) => url,\r\n\r\n    /**\r\n     * Gets or sets the base URL to use to load scripts\r\n     * Used for both JS and WASM\r\n     */\r\n    ScriptBaseUrl: \"https://cdn.babylonjs.com/\",\r\n    /**\r\n     * Gets or sets a function used to pre-process script url before using them to load.\r\n     * Used for both JS and WASM\r\n     * @param url defines the url to process\r\n     */\r\n    ScriptPreprocessUrl: (url: string) => url,\r\n};\r\n\r\n/**\r\n * Removes unwanted characters from an url\r\n * @param url defines the url to clean\r\n * @returns the cleaned url\r\n */\r\nconst _CleanUrl = (url: string): string => {\r\n    url = url.replace(/#/gm, \"%23\");\r\n    return url;\r\n};\r\n\r\n/**\r\n * Sets the cors behavior on a dom element. This will add the required Tools.CorsBehavior to the element.\r\n * @param url define the url we are trying\r\n * @param element define the dom element where to configure the cors policy\r\n * @internal\r\n */\r\nexport const SetCorsBehavior = (url: string | string[], element: { crossOrigin: string | null }): void => {\r\n    if (url && url.indexOf(\"data:\") === 0) {\r\n        return;\r\n    }\r\n\r\n    if (FileToolsOptions.CorsBehavior) {\r\n        if (typeof FileToolsOptions.CorsBehavior === \"string\" || FileToolsOptions.CorsBehavior instanceof String) {\r\n            element.crossOrigin = <string>FileToolsOptions.CorsBehavior;\r\n        } else {\r\n            const result = FileToolsOptions.CorsBehavior(url);\r\n            if (result) {\r\n                element.crossOrigin = result;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Loads an image as an HTMLImageElement.\r\n * @param input url string, ArrayBuffer, or Blob to load\r\n * @param onLoad callback called when the image successfully loads\r\n * @param onError callback called when the image fails to load\r\n * @param offlineProvider offline provider for caching\r\n * @param mimeType optional mime type\r\n * @param imageBitmapOptions\r\n * @returns the HTMLImageElement of the loaded image\r\n * @internal\r\n */\r\nexport const LoadImage = (\r\n    input: string | ArrayBuffer | ArrayBufferView | Blob,\r\n    onLoad: (img: HTMLImageElement | ImageBitmap) => void,\r\n    onError: (message?: string, exception?: any) => void,\r\n    offlineProvider: Nullable<IOfflineProvider>,\r\n    mimeType: string = \"\",\r\n    imageBitmapOptions?: ImageBitmapOptions\r\n): Nullable<HTMLImageElement> => {\r\n    let url: string;\r\n    let usingObjectURL = false;\r\n\r\n    if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {\r\n        if (typeof Blob !== \"undefined\" && typeof URL !== \"undefined\") {\r\n            url = URL.createObjectURL(new Blob([input], { type: mimeType }));\r\n            usingObjectURL = true;\r\n        } else {\r\n            url = `data:${mimeType};base64,` + EncodeArrayBufferToBase64(input);\r\n        }\r\n    } else if (input instanceof Blob) {\r\n        url = URL.createObjectURL(input);\r\n        usingObjectURL = true;\r\n    } else {\r\n        url = _CleanUrl(input);\r\n        url = FileToolsOptions.PreprocessUrl(input);\r\n    }\r\n\r\n    const engine = EngineStore.LastCreatedEngine;\r\n\r\n    const onErrorHandler = (exception: any) => {\r\n        if (onError) {\r\n            const inputText = url || input.toString();\r\n            onError(`Error while trying to load image: ${inputText.indexOf(\"http\") === 0 || inputText.length <= 128 ? inputText : inputText.slice(0, 128) + \"...\"}`, exception);\r\n        }\r\n    };\r\n\r\n    if (typeof Image === \"undefined\" || (engine?._features.forceBitmapOverHTMLImageElement ?? false)) {\r\n        LoadFile(\r\n            url,\r\n            (data) => {\r\n                engine!\r\n                    .createImageBitmap(new Blob([data], { type: mimeType }), { premultiplyAlpha: \"none\", ...imageBitmapOptions })\r\n                    .then((imgBmp) => {\r\n                        onLoad(imgBmp);\r\n                        if (usingObjectURL) {\r\n                            URL.revokeObjectURL(url);\r\n                        }\r\n                    })\r\n                    .catch((reason) => {\r\n                        if (onError) {\r\n                            onError(\"Error while trying to load image: \" + input, reason);\r\n                        }\r\n                    });\r\n            },\r\n            undefined,\r\n            offlineProvider || undefined,\r\n            true,\r\n            (request, exception) => {\r\n                onErrorHandler(exception);\r\n            }\r\n        );\r\n\r\n        return null;\r\n    }\r\n\r\n    const img = new Image();\r\n    SetCorsBehavior(url, img);\r\n\r\n    const handlersList: { target: any; name: string; handler: any }[] = [];\r\n\r\n    const loadHandlersList = () => {\r\n        handlersList.forEach((handler) => {\r\n            handler.target.addEventListener(handler.name, handler.handler);\r\n        });\r\n    };\r\n\r\n    const unloadHandlersList = () => {\r\n        handlersList.forEach((handler) => {\r\n            handler.target.removeEventListener(handler.name, handler.handler);\r\n        });\r\n        handlersList.length = 0;\r\n    };\r\n\r\n    const loadHandler = () => {\r\n        unloadHandlersList();\r\n\r\n        onLoad(img);\r\n\r\n        // Must revoke the URL after calling onLoad to avoid security exceptions in\r\n        // certain scenarios (e.g. when hosted in vscode).\r\n        if (usingObjectURL && img.src) {\r\n            URL.revokeObjectURL(img.src);\r\n        }\r\n    };\r\n\r\n    const errorHandler = (err: any) => {\r\n        unloadHandlersList();\r\n\r\n        onErrorHandler(err);\r\n\r\n        if (usingObjectURL && img.src) {\r\n            URL.revokeObjectURL(img.src);\r\n        }\r\n    };\r\n\r\n    const cspHandler = (err: any) => {\r\n        if (err.blockedURI !== img.src) {\r\n            return;\r\n        }\r\n\r\n        unloadHandlersList();\r\n        const cspException = new Error(`CSP violation of policy ${err.effectiveDirective} ${err.blockedURI}. Current policy is ${err.originalPolicy}`);\r\n\r\n        EngineStore.UseFallbackTexture = false;\r\n        onErrorHandler(cspException);\r\n        if (usingObjectURL && img.src) {\r\n            URL.revokeObjectURL(img.src);\r\n        }\r\n        img.src = \"\";\r\n    };\r\n\r\n    handlersList.push({ target: img, name: \"load\", handler: loadHandler });\r\n    handlersList.push({ target: img, name: \"error\", handler: errorHandler });\r\n    handlersList.push({ target: document, name: \"securitypolicyviolation\", handler: cspHandler });\r\n\r\n    loadHandlersList();\r\n\r\n    const fromBlob = url.substring(0, 5) === \"blob:\";\r\n    const fromData = url.substring(0, 5) === \"data:\";\r\n    const noOfflineSupport = () => {\r\n        if (fromBlob || fromData || !WebRequest.IsCustomRequestAvailable) {\r\n            img.src = url;\r\n        } else {\r\n            LoadFile(\r\n                url,\r\n                (data, _, contentType) => {\r\n                    const type = !mimeType && contentType ? contentType : mimeType;\r\n                    const blob = new Blob([data], { type });\r\n                    const url = URL.createObjectURL(blob);\r\n                    usingObjectURL = true;\r\n                    img.src = url;\r\n                },\r\n                undefined,\r\n                offlineProvider || undefined,\r\n                true,\r\n                (_request, exception) => {\r\n                    onErrorHandler(exception);\r\n                }\r\n            );\r\n        }\r\n    };\r\n\r\n    const loadFromOfflineSupport = () => {\r\n        if (offlineProvider) {\r\n            offlineProvider.loadImage(url, img);\r\n        }\r\n    };\r\n\r\n    if (!fromBlob && !fromData && offlineProvider && offlineProvider.enableTexturesOffline) {\r\n        offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);\r\n    } else {\r\n        if (url.indexOf(\"file:\") !== -1) {\r\n            const textureName = decodeURIComponent(url.substring(5).toLowerCase());\r\n            if (FilesInputStore.FilesToLoad[textureName] && typeof URL !== \"undefined\") {\r\n                try {\r\n                    let blobURL;\r\n                    try {\r\n                        blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\r\n                    } catch (ex) {\r\n                        // Chrome doesn't support oneTimeOnly parameter\r\n                        blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\r\n                    }\r\n                    img.src = blobURL;\r\n                    usingObjectURL = true;\r\n                } catch (e) {\r\n                    img.src = \"\";\r\n                }\r\n                return img;\r\n            }\r\n        }\r\n\r\n        noOfflineSupport();\r\n    }\r\n\r\n    return img;\r\n};\r\n\r\n/**\r\n * Reads a file from a File object\r\n * @param file defines the file to load\r\n * @param onSuccess defines the callback to call when data is loaded\r\n * @param onProgress defines the callback to call during loading process\r\n * @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer\r\n * @param onError defines the callback to call when an error occurs\r\n * @returns a file request object\r\n * @internal\r\n */\r\nexport const ReadFile = (\r\n    file: File,\r\n    onSuccess: (data: any) => void,\r\n    onProgress?: (ev: ProgressEvent) => any,\r\n    useArrayBuffer?: boolean,\r\n    onError?: (error: ReadFileError) => void\r\n): IFileRequest => {\r\n    const reader = new FileReader();\r\n    const fileRequest: IFileRequest = {\r\n        onCompleteObservable: new Observable<IFileRequest>(),\r\n        abort: () => reader.abort(),\r\n    };\r\n\r\n    reader.onloadend = () => fileRequest.onCompleteObservable.notifyObservers(fileRequest);\r\n    if (onError) {\r\n        reader.onerror = () => {\r\n            onError(new ReadFileError(`Unable to read ${file.name}`, file));\r\n        };\r\n    }\r\n    reader.onload = (e) => {\r\n        //target doesn't have result from ts 1.3\r\n        onSuccess((<any>e.target)[\"result\"]);\r\n    };\r\n    if (onProgress) {\r\n        reader.onprogress = onProgress;\r\n    }\r\n    if (!useArrayBuffer) {\r\n        // Asynchronous read\r\n        reader.readAsText(file);\r\n    } else {\r\n        reader.readAsArrayBuffer(file);\r\n    }\r\n\r\n    return fileRequest;\r\n};\r\n\r\n/**\r\n * Loads a file from a url, a data url, or a file url\r\n * @param fileOrUrl file, url, data url, or file url to load\r\n * @param onSuccess callback called when the file successfully loads\r\n * @param onProgress callback called while file is loading (if the server supports this mode)\r\n * @param offlineProvider defines the offline provider for caching\r\n * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n * @param onError callback called when the file fails to load\r\n * @param onOpened\r\n * @returns a file request object\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport const LoadFile = (\r\n    fileOrUrl: File | string,\r\n    onSuccess: (data: string | ArrayBuffer, responseURL?: string, contentType?: Nullable<string>) => void,\r\n    onProgress?: (ev: ProgressEvent) => void,\r\n    offlineProvider?: IOfflineProvider,\r\n    useArrayBuffer?: boolean,\r\n    onError?: (request?: WebRequest, exception?: LoadFileError) => void,\r\n    onOpened?: (request: WebRequest) => void\r\n): IFileRequest => {\r\n    if ((fileOrUrl as File).name) {\r\n        return ReadFile(\r\n            fileOrUrl as File,\r\n            onSuccess,\r\n            onProgress,\r\n            useArrayBuffer,\r\n            onError\r\n                ? (error: ReadFileError) => {\r\n                      onError(undefined, error);\r\n                  }\r\n                : undefined\r\n        );\r\n    }\r\n\r\n    const url = fileOrUrl as string;\r\n\r\n    // If file and file input are set\r\n    if (url.indexOf(\"file:\") !== -1) {\r\n        let fileName = decodeURIComponent(url.substring(5).toLowerCase());\r\n        if (fileName.indexOf(\"./\") === 0) {\r\n            fileName = fileName.substring(2);\r\n        }\r\n        const file = FilesInputStore.FilesToLoad[fileName];\r\n        if (file) {\r\n            return ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError ? (error) => onError(undefined, new LoadFileError(error.message, error.file)) : undefined);\r\n        }\r\n    }\r\n\r\n    // For a Base64 Data URL\r\n    const { match, type } = TestBase64DataUrl(url);\r\n    if (match) {\r\n        const fileRequest: IFileRequest = {\r\n            onCompleteObservable: new Observable<IFileRequest>(),\r\n            abort: () => () => {},\r\n        };\r\n\r\n        try {\r\n            const data = useArrayBuffer ? DecodeBase64UrlToBinary(url) : DecodeBase64UrlToString(url);\r\n            onSuccess(data, undefined, type);\r\n        } catch (error) {\r\n            if (onError) {\r\n                onError(undefined, error);\r\n            } else {\r\n                Logger.Error(error.message || \"Failed to parse the Data URL\");\r\n            }\r\n        }\r\n\r\n        TimingTools.SetImmediate(() => {\r\n            fileRequest.onCompleteObservable.notifyObservers(fileRequest);\r\n        });\r\n\r\n        return fileRequest;\r\n    }\r\n\r\n    return RequestFile(\r\n        url,\r\n        (data, request) => {\r\n            onSuccess(data, request?.responseURL, request?.getResponseHeader(\"content-type\"));\r\n        },\r\n        onProgress,\r\n        offlineProvider,\r\n        useArrayBuffer,\r\n        onError\r\n            ? (error) => {\r\n                  onError(error.request, new LoadFileError(error.message, error.request));\r\n              }\r\n            : undefined,\r\n        onOpened\r\n    );\r\n};\r\n\r\n/**\r\n * Loads a file from a url\r\n * @param url url to load\r\n * @param onSuccess callback called when the file successfully loads\r\n * @param onProgress callback called while file is loading (if the server supports this mode)\r\n * @param offlineProvider defines the offline provider for caching\r\n * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n * @param onError callback called when the file fails to load\r\n * @param onOpened callback called when the web request is opened\r\n * @returns a file request object\r\n * @internal\r\n */\r\nexport const RequestFile = (\r\n    url: string,\r\n    onSuccess?: (data: string | ArrayBuffer, request?: WebRequest) => void,\r\n    onProgress?: (event: ProgressEvent) => void,\r\n    offlineProvider?: IOfflineProvider,\r\n    useArrayBuffer?: boolean,\r\n    onError?: (error: RequestFileError) => void,\r\n    onOpened?: (request: WebRequest) => void\r\n): IFileRequest => {\r\n    url = _CleanUrl(url);\r\n    url = FileToolsOptions.PreprocessUrl(url);\r\n\r\n    const loadUrl = FileToolsOptions.BaseUrl + url;\r\n\r\n    let aborted = false;\r\n    const fileRequest: IFileRequest = {\r\n        onCompleteObservable: new Observable<IFileRequest>(),\r\n        abort: () => (aborted = true),\r\n    };\r\n\r\n    const requestFile = () => {\r\n        let request: Nullable<WebRequest> = new WebRequest();\r\n        let retryHandle: Nullable<ReturnType<typeof setTimeout>> = null;\r\n        let onReadyStateChange: Nullable<() => void>;\r\n\r\n        const unbindEvents = () => {\r\n            if (!request) {\r\n                return;\r\n            }\r\n\r\n            if (onProgress) {\r\n                request.removeEventListener(\"progress\", onProgress);\r\n            }\r\n            if (onReadyStateChange) {\r\n                request.removeEventListener(\"readystatechange\", onReadyStateChange);\r\n            }\r\n            request.removeEventListener(\"loadend\", onLoadEnd!);\r\n        };\r\n\r\n        let onLoadEnd: Nullable<() => void> = () => {\r\n            unbindEvents();\r\n\r\n            fileRequest.onCompleteObservable.notifyObservers(fileRequest);\r\n            fileRequest.onCompleteObservable.clear();\r\n\r\n            onProgress = undefined;\r\n            onReadyStateChange = null;\r\n            onLoadEnd = null;\r\n            onError = undefined;\r\n            onOpened = undefined;\r\n            onSuccess = undefined;\r\n        };\r\n\r\n        fileRequest.abort = () => {\r\n            aborted = true;\r\n\r\n            if (onLoadEnd) {\r\n                onLoadEnd();\r\n            }\r\n\r\n            if (request && request.readyState !== (XMLHttpRequest.DONE || 4)) {\r\n                request.abort();\r\n            }\r\n\r\n            if (retryHandle !== null) {\r\n                clearTimeout(retryHandle);\r\n                retryHandle = null;\r\n            }\r\n\r\n            request = null;\r\n        };\r\n\r\n        const handleError = (error: any) => {\r\n            const message = error.message || \"Unknown error\";\r\n            if (onError && request) {\r\n                onError(new RequestFileError(message, request));\r\n            } else {\r\n                Logger.Error(message);\r\n            }\r\n        };\r\n\r\n        const retryLoop = (retryIndex: number) => {\r\n            if (!request) {\r\n                return;\r\n            }\r\n            request.open(\"GET\", loadUrl);\r\n\r\n            if (onOpened) {\r\n                try {\r\n                    onOpened(request);\r\n                } catch (e) {\r\n                    handleError(e);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (useArrayBuffer) {\r\n                request.responseType = \"arraybuffer\";\r\n            }\r\n\r\n            if (onProgress) {\r\n                request.addEventListener(\"progress\", onProgress);\r\n            }\r\n\r\n            if (onLoadEnd) {\r\n                request.addEventListener(\"loadend\", onLoadEnd);\r\n            }\r\n\r\n            onReadyStateChange = () => {\r\n                if (aborted || !request) {\r\n                    return;\r\n                }\r\n\r\n                // In case of undefined state in some browsers.\r\n                if (request.readyState === (XMLHttpRequest.DONE || 4)) {\r\n                    // Some browsers have issues where onreadystatechange can be called multiple times with the same value.\r\n                    if (onReadyStateChange) {\r\n                        request.removeEventListener(\"readystatechange\", onReadyStateChange);\r\n                    }\r\n\r\n                    if ((request.status >= 200 && request.status < 300) || (request.status === 0 && (!IsWindowObjectExist() || IsFileURL()))) {\r\n                        try {\r\n                            if (onSuccess) {\r\n                                onSuccess(useArrayBuffer ? request.response : request.responseText, request);\r\n                            }\r\n                        } catch (e) {\r\n                            handleError(e);\r\n                        }\r\n                        return;\r\n                    }\r\n\r\n                    const retryStrategy = FileToolsOptions.DefaultRetryStrategy;\r\n                    if (retryStrategy) {\r\n                        const waitTime = retryStrategy(loadUrl, request, retryIndex);\r\n                        if (waitTime !== -1) {\r\n                            // Prevent the request from completing for retry.\r\n                            unbindEvents();\r\n\r\n                            request = new WebRequest();\r\n                            retryHandle = setTimeout(() => retryLoop(retryIndex + 1), waitTime);\r\n                            return;\r\n                        }\r\n                    }\r\n\r\n                    const error = new RequestFileError(\"Error status: \" + request.status + \" \" + request.statusText + \" - Unable to load \" + loadUrl, request);\r\n                    if (onError) {\r\n                        onError(error);\r\n                    }\r\n                }\r\n            };\r\n\r\n            request.addEventListener(\"readystatechange\", onReadyStateChange);\r\n\r\n            request.send();\r\n        };\r\n\r\n        retryLoop(0);\r\n    };\r\n\r\n    // Caching all files\r\n    if (offlineProvider && offlineProvider.enableSceneOffline) {\r\n        const noOfflineSupport = (request?: any) => {\r\n            if (request && request.status > 400) {\r\n                if (onError) {\r\n                    onError(request);\r\n                }\r\n            } else {\r\n                requestFile();\r\n            }\r\n        };\r\n\r\n        const loadFromOfflineSupport = () => {\r\n            // TODO: database needs to support aborting and should return a IFileRequest\r\n\r\n            if (offlineProvider) {\r\n                offlineProvider.loadFile(\r\n                    FileToolsOptions.BaseUrl + url,\r\n                    (data) => {\r\n                        if (!aborted && onSuccess) {\r\n                            onSuccess(data);\r\n                        }\r\n\r\n                        fileRequest.onCompleteObservable.notifyObservers(fileRequest);\r\n                    },\r\n                    onProgress\r\n                        ? (event) => {\r\n                              if (!aborted && onProgress) {\r\n                                  onProgress(event);\r\n                              }\r\n                          }\r\n                        : undefined,\r\n                    noOfflineSupport,\r\n                    useArrayBuffer\r\n                );\r\n            }\r\n        };\r\n\r\n        offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);\r\n    } else {\r\n        requestFile();\r\n    }\r\n\r\n    return fileRequest;\r\n};\r\n\r\n/**\r\n * Checks if the loaded document was accessed via `file:`-Protocol.\r\n * @returns boolean\r\n * @internal\r\n */\r\nexport const IsFileURL = (): boolean => {\r\n    return typeof location !== \"undefined\" && location.protocol === \"file:\";\r\n};\r\n\r\n/**\r\n * Test if the given uri is a valid base64 data url\r\n * @param uri The uri to test\r\n * @returns True if the uri is a base64 data url or false otherwise\r\n * @internal\r\n */\r\nexport const IsBase64DataUrl = (uri: string): boolean => {\r\n    return Base64DataUrlRegEx.test(uri);\r\n};\r\n\r\nexport const TestBase64DataUrl = (uri: string): { match: boolean; type: string } => {\r\n    const results = Base64DataUrlRegEx.exec(uri);\r\n    if (results === null || results.length === 0) {\r\n        return { match: false, type: \"\" };\r\n    } else {\r\n        const type = results[0].replace(\"data:\", \"\").replace(\"base64,\", \"\");\r\n        return { match: true, type };\r\n    }\r\n};\r\n\r\n/**\r\n * Decode the given base64 uri.\r\n * @param uri The uri to decode\r\n * @returns The decoded base64 data.\r\n * @internal\r\n */\r\nexport function DecodeBase64UrlToBinary(uri: string): ArrayBuffer {\r\n    return DecodeBase64ToBinary(uri.split(\",\")[1]);\r\n}\r\n\r\n/**\r\n * Decode the given base64 uri into a UTF-8 encoded string.\r\n * @param uri The uri to decode\r\n * @returns The decoded base64 data.\r\n * @internal\r\n */\r\nexport const DecodeBase64UrlToString = (uri: string): string => {\r\n    return DecodeBase64ToString(uri.split(\",\")[1]);\r\n};\r\n\r\n/**\r\n * This will be executed automatically for UMD and es5.\r\n * If esm dev wants the side effects to execute they will have to run it manually\r\n * Once we build native modules those need to be exported.\r\n * @internal\r\n */\r\nconst initSideEffects = () => {\r\n    ThinEngine._FileToolsLoadImage = LoadImage;\r\n    ThinEngine._FileToolsLoadFile = LoadFile;\r\n    ShaderProcessor._FileToolsLoadFile = LoadFile;\r\n};\r\n\r\ninitSideEffects();\r\n\r\n// deprecated\r\n\r\n/**\r\n * FileTools defined as any.\r\n * This should not be imported or used in future releases or in any module in the framework\r\n * @internal\r\n * @deprecated import the needed function from fileTools.ts\r\n */\r\nexport let FileTools: {\r\n    DecodeBase64UrlToBinary: (uri: string) => ArrayBuffer;\r\n    DecodeBase64UrlToString: (uri: string) => string;\r\n    DefaultRetryStrategy: any;\r\n    BaseUrl: any;\r\n    CorsBehavior: any;\r\n    PreprocessUrl: any;\r\n    IsBase64DataUrl: (uri: string) => boolean;\r\n    IsFileURL: () => boolean;\r\n    LoadFile: (\r\n        fileOrUrl: string | File,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string | undefined) => void,\r\n        onProgress?: ((ev: ProgressEvent<EventTarget>) => void) | undefined,\r\n        offlineProvider?: IOfflineProvider | undefined,\r\n        useArrayBuffer?: boolean | undefined,\r\n        onError?: ((request?: WebRequest | undefined, exception?: LoadFileError | undefined) => void) | undefined,\r\n        onOpened?: ((request: WebRequest) => void) | undefined\r\n    ) => IFileRequest;\r\n    LoadImage: (\r\n        input: string | ArrayBuffer | Blob | ArrayBufferView,\r\n        onLoad: (img: HTMLImageElement | ImageBitmap) => void,\r\n        onError: (message?: string | undefined, exception?: any) => void,\r\n        offlineProvider: Nullable<IOfflineProvider>,\r\n        mimeType?: string | undefined,\r\n        imageBitmapOptions?: ImageBitmapOptions | undefined\r\n    ) => Nullable<HTMLImageElement>;\r\n    ReadFile: (\r\n        file: File,\r\n        onSuccess: (data: any) => void,\r\n        onProgress?: ((ev: ProgressEvent<EventTarget>) => any) | undefined,\r\n        useArrayBuffer?: boolean | undefined,\r\n        onError?: ((error: ReadFileError) => void) | undefined\r\n    ) => IFileRequest;\r\n    RequestFile: (\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, request?: WebRequest | undefined) => void,\r\n        onProgress?: ((event: ProgressEvent<EventTarget>) => void) | undefined,\r\n        offlineProvider?: IOfflineProvider | undefined,\r\n        useArrayBuffer?: boolean | undefined,\r\n        onError?: ((error: RequestFileError) => void) | undefined,\r\n        onOpened?: ((request: WebRequest) => void) | undefined\r\n    ) => IFileRequest;\r\n    SetCorsBehavior: (url: string | string[], element: { crossOrigin: string | null }) => void;\r\n};\r\n/**\r\n * @param DecodeBase64UrlToBinary\r\n * @param DecodeBase64UrlToString\r\n * @param FileToolsOptions\r\n * @internal\r\n */\r\nexport const _injectLTSFileTools = (\r\n    DecodeBase64UrlToBinary: (uri: string) => ArrayBuffer,\r\n    DecodeBase64UrlToString: (uri: string) => string,\r\n    FileToolsOptions: { DefaultRetryStrategy: any; BaseUrl: any; CorsBehavior: any; PreprocessUrl: any },\r\n    IsBase64DataUrl: (uri: string) => boolean,\r\n    IsFileURL: () => boolean,\r\n    LoadFile: (\r\n        fileOrUrl: string | File,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string | undefined) => void,\r\n        onProgress?: ((ev: ProgressEvent<EventTarget>) => void) | undefined,\r\n        offlineProvider?: IOfflineProvider | undefined,\r\n        useArrayBuffer?: boolean | undefined,\r\n        onError?: ((request?: WebRequest | undefined, exception?: LoadFileError | undefined) => void) | undefined,\r\n        onOpened?: ((request: WebRequest) => void) | undefined\r\n    ) => IFileRequest,\r\n    LoadImage: (\r\n        input: string | ArrayBuffer | ArrayBufferView | Blob,\r\n        onLoad: (img: HTMLImageElement | ImageBitmap) => void,\r\n        onError: (message?: string | undefined, exception?: any) => void,\r\n        offlineProvider: Nullable<IOfflineProvider>,\r\n        mimeType?: string,\r\n        imageBitmapOptions?: ImageBitmapOptions | undefined\r\n    ) => Nullable<HTMLImageElement>,\r\n    ReadFile: (\r\n        file: File,\r\n        onSuccess: (data: any) => void,\r\n        onProgress?: ((ev: ProgressEvent<EventTarget>) => any) | undefined,\r\n        useArrayBuffer?: boolean | undefined,\r\n        onError?: ((error: ReadFileError) => void) | undefined\r\n    ) => IFileRequest,\r\n    RequestFile: (\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, request?: WebRequest | undefined) => void,\r\n        onProgress?: ((event: ProgressEvent<EventTarget>) => void) | undefined,\r\n        offlineProvider?: IOfflineProvider | undefined,\r\n        useArrayBuffer?: boolean | undefined,\r\n        onError?: ((error: RequestFileError) => void) | undefined,\r\n        onOpened?: ((request: WebRequest) => void) | undefined\r\n    ) => IFileRequest,\r\n    SetCorsBehavior: (url: string | string[], element: { crossOrigin: string | null }) => void\r\n) => {\r\n    /**\r\n     * Backwards compatibility.\r\n     * @internal\r\n     * @deprecated\r\n     */\r\n    FileTools = {\r\n        DecodeBase64UrlToBinary,\r\n        DecodeBase64UrlToString,\r\n        DefaultRetryStrategy: FileToolsOptions.DefaultRetryStrategy,\r\n        BaseUrl: FileToolsOptions.BaseUrl,\r\n        CorsBehavior: FileToolsOptions.CorsBehavior,\r\n        PreprocessUrl: FileToolsOptions.PreprocessUrl,\r\n        IsBase64DataUrl,\r\n        IsFileURL,\r\n        LoadFile,\r\n        LoadImage,\r\n        ReadFile,\r\n        RequestFile,\r\n        SetCorsBehavior,\r\n    };\r\n\r\n    Object.defineProperty(FileTools, \"DefaultRetryStrategy\", {\r\n        get: function (this: null) {\r\n            return FileToolsOptions.DefaultRetryStrategy;\r\n        },\r\n        set: function (this: null, value: (url: string, request: WebRequest, retryIndex: number) => number) {\r\n            FileToolsOptions.DefaultRetryStrategy = value;\r\n        },\r\n    });\r\n\r\n    Object.defineProperty(FileTools, \"BaseUrl\", {\r\n        get: function (this: null) {\r\n            return FileToolsOptions.BaseUrl;\r\n        },\r\n        set: function (this: null, value: string) {\r\n            FileToolsOptions.BaseUrl = value;\r\n        },\r\n    });\r\n\r\n    Object.defineProperty(FileTools, \"PreprocessUrl\", {\r\n        get: function (this: null) {\r\n            return FileToolsOptions.PreprocessUrl;\r\n        },\r\n        set: function (this: null, value: (url: string) => string) {\r\n            FileToolsOptions.PreprocessUrl = value;\r\n        },\r\n    });\r\n\r\n    Object.defineProperty(FileTools, \"CorsBehavior\", {\r\n        get: function (this: null) {\r\n            return FileToolsOptions.CorsBehavior;\r\n        },\r\n        set: function (this: null, value: string | ((url: string | string[]) => string)) {\r\n            FileToolsOptions.CorsBehavior = value;\r\n        },\r\n    });\r\n};\r\n\r\n_injectLTSFileTools(DecodeBase64UrlToBinary, DecodeBase64UrlToString, FileToolsOptions, IsBase64DataUrl, IsFileURL, LoadFile, LoadImage, ReadFile, RequestFile, SetCorsBehavior);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}