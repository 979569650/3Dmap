{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { StandardMaterial } from \"./../../Materials/standardMaterial.js\";\nimport { PBRMaterial } from \"../../Materials/PBR/pbrMaterial.js\";\nimport { GreasedLineMesh } from \"../GreasedLine/greasedLineMesh.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\nimport { GreasedLineSimpleMaterial } from \"../../Materials/GreasedLine/greasedLineSimpleMaterial.js\";\nimport { GreasedLineTools } from \"../../Misc/greasedLineTools.js\";\nimport { GreasedLineRibbonAutoDirectionMode, GreasedLineRibbonFacesMode, GreasedLineRibbonPointsMode } from \"../GreasedLine/greasedLineBaseMesh.js\";\nimport { GreasedLineRibbonMesh } from \"../GreasedLine/greasedLineRibbonMesh.js\";\nimport { GreasedLineMeshMaterialType } from \"../../Materials/GreasedLine/greasedLineMaterialInterfaces.js\";\nimport { GreasedLinePluginMaterial } from \"../../Materials/GreasedLine/greasedLinePluginMaterial.js\";\nimport { GreasedLineMaterialDefaults } from \"../../Materials/GreasedLine/greasedLineMaterialDefaults.js\";\n/**\n * How are the colors distributed along the color table\n * {@link https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param/greased_line#colors-and-colordistribution}\n */\nexport var GreasedLineMeshColorDistribution;\n(function (GreasedLineMeshColorDistribution) {\n  /**\n   * Do no modify the color table\n   */\n  GreasedLineMeshColorDistribution[GreasedLineMeshColorDistribution[\"COLOR_DISTRIBUTION_NONE\"] = 0] = \"COLOR_DISTRIBUTION_NONE\";\n  /**\n   * Repeat the colors until the color table is full\n   */\n  GreasedLineMeshColorDistribution[GreasedLineMeshColorDistribution[\"COLOR_DISTRIBUTION_REPEAT\"] = 1] = \"COLOR_DISTRIBUTION_REPEAT\";\n  /**\n   * Distribute the colors evenly through the color table\n   */\n  GreasedLineMeshColorDistribution[GreasedLineMeshColorDistribution[\"COLOR_DISTRIBUTION_EVEN\"] = 2] = \"COLOR_DISTRIBUTION_EVEN\";\n  /**\n   * Put the colors to start of the color table a fill the rest with the default color\n   */\n  GreasedLineMeshColorDistribution[GreasedLineMeshColorDistribution[\"COLOR_DISTRIBUTION_START\"] = 3] = \"COLOR_DISTRIBUTION_START\";\n  /**\n   * Put the colors to the end of the color table and fill the rest with the default color\n   */\n  GreasedLineMeshColorDistribution[GreasedLineMeshColorDistribution[\"COLOR_DISTRIBUTION_END\"] = 4] = \"COLOR_DISTRIBUTION_END\";\n  /**\n   * Put the colors to start and to the end of the color table and fill the gap between with the default color\n   */\n  GreasedLineMeshColorDistribution[GreasedLineMeshColorDistribution[\"COLOR_DISTRIBUTION_START_END\"] = 5] = \"COLOR_DISTRIBUTION_START_END\";\n})(GreasedLineMeshColorDistribution || (GreasedLineMeshColorDistribution = {}));\n/**\n * How are the widths distributed along the width table\n * {@link https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param/greased_line#widths-and-widthdistribution}\n */\nexport var GreasedLineMeshWidthDistribution;\n(function (GreasedLineMeshWidthDistribution) {\n  /**\n   * Do no modify the width table\n   */\n  GreasedLineMeshWidthDistribution[GreasedLineMeshWidthDistribution[\"WIDTH_DISTRIBUTION_NONE\"] = 0] = \"WIDTH_DISTRIBUTION_NONE\";\n  /**\n   * Repeat the widths until the width table is full\n   */\n  GreasedLineMeshWidthDistribution[GreasedLineMeshWidthDistribution[\"WIDTH_DISTRIBUTION_REPEAT\"] = 1] = \"WIDTH_DISTRIBUTION_REPEAT\";\n  /**\n   * Distribute the widths evenly through the width table\n   */\n  GreasedLineMeshWidthDistribution[GreasedLineMeshWidthDistribution[\"WIDTH_DISTRIBUTION_EVEN\"] = 2] = \"WIDTH_DISTRIBUTION_EVEN\";\n  /**\n   * Put the widths to start of the width table a fill the rest with the default width\n   */\n  GreasedLineMeshWidthDistribution[GreasedLineMeshWidthDistribution[\"WIDTH_DISTRIBUTION_START\"] = 3] = \"WIDTH_DISTRIBUTION_START\";\n  /**\n   * Put the widths to the end of the width table and fill the rest with the default width\n   */\n  GreasedLineMeshWidthDistribution[GreasedLineMeshWidthDistribution[\"WIDTH_DISTRIBUTION_END\"] = 4] = \"WIDTH_DISTRIBUTION_END\";\n  /**\n   * Put the widths to start and to the end of the width table and fill the gap between with the default width\n   */\n  GreasedLineMeshWidthDistribution[GreasedLineMeshWidthDistribution[\"WIDTH_DISTRIBUTION_START_END\"] = 5] = \"WIDTH_DISTRIBUTION_START_END\";\n})(GreasedLineMeshWidthDistribution || (GreasedLineMeshWidthDistribution = {}));\n/**\n * Builder functions for creating GreasedLineMeshes\n */\n/**\n * Creates a new @see GreasedLinePluginMaterial\n * @param name name of the material\n * @param options material options @see GreasedLineMaterialOptions\n * @param scene scene or null to use the last scene\n * @returns StandardMaterial or PBRMaterial with the @see GreasedLinePluginMaterial attached to it\n */\nexport function CreateGreasedLineMaterial(name, options, scene) {\n  scene = scene !== null && scene !== void 0 ? scene : EngineStore.LastCreatedScene;\n  let material;\n  switch (options.materialType) {\n    case GreasedLineMeshMaterialType.MATERIAL_TYPE_PBR:\n      material = new PBRMaterial(name, scene);\n      new GreasedLinePluginMaterial(material, scene, options);\n      break;\n    case GreasedLineMeshMaterialType.MATERIAL_TYPE_SIMPLE:\n      material = new GreasedLineSimpleMaterial(name, scene, options);\n      break;\n    default:\n      material = new StandardMaterial(name, scene);\n      new GreasedLinePluginMaterial(material, scene, options);\n      break;\n  }\n  return material;\n}\n/**\n * Creates a GreasedLine mesh\n * @param name name of the mesh\n * @param options options for the mesh\n * @param materialOptions material options for the mesh\n * @param scene scene where the mesh will be created\n * @returns instance of GreasedLineMesh\n */\nexport function CreateGreasedLine(name, options, materialOptions, scene) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n  scene = scene !== null && scene !== void 0 ? scene : EngineStore.LastCreatedScene;\n  let instance;\n  const allPoints = GreasedLineTools.ConvertPoints(options.points);\n  options.widthDistribution = (_a = options.widthDistribution) !== null && _a !== void 0 ? _a : GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_START;\n  if (options.ribbonOptions) {\n    options.ribbonOptions.facesMode = (_b = options.ribbonOptions.facesMode) !== null && _b !== void 0 ? _b : GreasedLineRibbonFacesMode.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING;\n    options.ribbonOptions.pointsMode = (_c = options.ribbonOptions.pointsMode) !== null && _c !== void 0 ? _c : GreasedLineRibbonPointsMode.POINTS_MODE_POINTS;\n    options.ribbonOptions.directionsAutoMode = (_d = options.ribbonOptions.directionsAutoMode) !== null && _d !== void 0 ? _d : options.ribbonOptions.directions ? GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_NONE : GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT;\n  }\n  materialOptions = materialOptions !== null && materialOptions !== void 0 ? materialOptions : {\n    color: GreasedLineMaterialDefaults.DEFAULT_COLOR\n  };\n  materialOptions.createAndAssignMaterial = (_e = materialOptions.createAndAssignMaterial) !== null && _e !== void 0 ? _e : true;\n  materialOptions.colorDistribution = (_f = materialOptions === null || materialOptions === void 0 ? void 0 : materialOptions.colorDistribution) !== null && _f !== void 0 ? _f : GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_START;\n  materialOptions.materialType = (_g = materialOptions.materialType) !== null && _g !== void 0 ? _g : GreasedLineMeshMaterialType.MATERIAL_TYPE_STANDARD;\n  let length = 0;\n  if (Array.isArray(allPoints[0])) {\n    allPoints.forEach(points => {\n      length += points.length / 3;\n    });\n  }\n  const widths = CompleteGreasedLineWidthTable(length, (_h = options.widths) !== null && _h !== void 0 ? _h : [], options.widthDistribution);\n  const colors = (materialOptions === null || materialOptions === void 0 ? void 0 : materialOptions.colors) ? CompleteGreasedLineColorTable(length, materialOptions.colors, materialOptions.colorDistribution, (_j = materialOptions.color) !== null && _j !== void 0 ? _j : GreasedLineMaterialDefaults.DEFAULT_COLOR) : undefined;\n  // create new mesh if instance is not defined\n  const initialGreasedLineOptions = {\n    points: allPoints,\n    updatable: options.updatable,\n    widths,\n    lazy: options.lazy,\n    ribbonOptions: options.ribbonOptions,\n    uvs: options.uvs,\n    colorPointers: options.colorPointers\n  };\n  if (initialGreasedLineOptions.ribbonOptions) {\n    if (initialGreasedLineOptions.ribbonOptions.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_POINTS) {\n      initialGreasedLineOptions.ribbonOptions.width = (_l = (_k = materialOptions.width) !== null && _k !== void 0 ? _k : initialGreasedLineOptions.ribbonOptions.width) !== null && _l !== void 0 ? _l : GreasedLineMaterialDefaults.DEFAULT_WIDTH;\n    }\n  }\n  if (!options.instance) {\n    instance = initialGreasedLineOptions.ribbonOptions ? new GreasedLineRibbonMesh(name, scene, initialGreasedLineOptions) : new GreasedLineMesh(name, scene, initialGreasedLineOptions);\n    if (materialOptions) {\n      const initialMaterialOptions = {\n        materialType: materialOptions.materialType,\n        dashCount: materialOptions.dashCount,\n        dashOffset: materialOptions.dashOffset,\n        dashRatio: materialOptions.dashRatio,\n        resolution: materialOptions.resolution,\n        sizeAttenuation: materialOptions.sizeAttenuation,\n        useColors: materialOptions.useColors,\n        useDash: materialOptions.useDash,\n        visibility: materialOptions.visibility,\n        width: materialOptions.width,\n        color: materialOptions.color,\n        colorMode: materialOptions.colorMode,\n        colorsSampling: materialOptions.colorsSampling,\n        colorDistributionType: materialOptions.colorDistributionType,\n        colors,\n        cameraFacing: !options.ribbonOptions,\n        colorsTexture: materialOptions.colorsTexture\n      };\n      if (materialOptions.createAndAssignMaterial) {\n        const material = CreateGreasedLineMaterial(name, initialMaterialOptions, scene);\n        instance.material = material;\n        if (((_m = options.ribbonOptions) === null || _m === void 0 ? void 0 : _m.facesMode) === GreasedLineRibbonFacesMode.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING) {\n          material.backFaceCulling = false;\n        }\n      }\n    }\n  } else {\n    // update the data on the mesh instance\n    instance = options.instance;\n    if (instance instanceof GreasedLineRibbonMesh) {\n      instance.addPoints(allPoints, initialGreasedLineOptions);\n    } else {\n      const currentWidths = instance.widths;\n      if (currentWidths) {\n        const newWidths = currentWidths.slice();\n        for (const w of widths) {\n          newWidths.push(w);\n        }\n        instance.widths = newWidths;\n      } else {\n        instance.widths = widths;\n      }\n      instance.addPoints(allPoints);\n    }\n  }\n  // add colors\n  // it will merge if any colors already on the instance\n  if (colors && options.instance) {\n    if (options.instance.greasedLineMaterial) {\n      const currentColors = options.instance.greasedLineMaterial.colors;\n      if (currentColors) {\n        const newColors = currentColors.concat(colors);\n        options.instance.greasedLineMaterial.setColors(newColors, instance.isLazy());\n      }\n    }\n  }\n  return instance;\n}\n/**\n * Completes the width table/fills the missing entries. It means it creates a width entry for every point of the line mesh.\n * You can provide more points the widths when creating the mesh. This function will fill the empty entries.\n * The algorithm used to fill the empty entries can be\n * GreasedLineMeshWidthDistribution.REPEAT - the width table will be repeatedly copied to the empty values [wL, wU] = [wL, wU, wL, wU, wL, wU, wL, wU, ...]\n * GreasedLineMeshWidthDistribution.EVEN - the width table will be evenly copied to the empty values [wL, wU] = [wL, wL, wL, wL, wU, wU, wU, wU]\n * GreasedLineMeshWidthDistribution.START - the width table will be copied at the start of the empty values\n * and rest will be filled width the default width upper and default width lower values [wU, wL] = [wL, wU, dwL, dwU, dwL, dwU, dwL, dwU]\n * GreasedLineMeshWidthDistribution.END - the width table will be copied at the end of the empty values\n * and rest will be filled width the default values [wL, wU] = [wL, wU, dwL, dwU, dwL, dwU, wL, wU]\n * @param pointCount number of points of the line mesh\n * @param widths array of widths [widhtLower, widthUpper, widthLower, widthUpper ...]. Two widths (lower/upper) per point.\n * @param widthsDistribution how to distribute widths if the widths array has fewer entries than pointCount\n * @param defaultWidthUpper the default value which will be used to fill empty width entries - upper width\n * @param defaultWidthLower the default value which will be used to fill empty width entries - lower width\n * @returns completed width table.\n */\nexport function CompleteGreasedLineWidthTable(pointCount, widths, widthsDistribution, defaultWidthUpper = 1, defaultWidthLower = 1) {\n  const missingCount = pointCount - widths.length / 2;\n  const widthsData = [];\n  if (missingCount < 0) {\n    return widths.slice(0, pointCount * 2);\n  }\n  // is the width table shorter than the point table?\n  if (missingCount > 0) {\n    if (widths.length % 2 != 0) {\n      widths.push(defaultWidthUpper);\n    }\n    // it is, fill in the missing elements\n    if (widthsDistribution === GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_START_END) {\n      const halfCount = Math.floor(widths.length / 2);\n      // start sector\n      for (let i = 0, j = 0; i < halfCount - 1; i++) {\n        widthsData.push(widths[j++]);\n        widthsData.push(widths[j++]);\n      }\n      // middle sector\n      const widthL = widths[halfCount / 2];\n      const widthU = widths[halfCount / 2 + 1];\n      for (let i = 0; i < missingCount; i++) {\n        widthsData.push(widthU);\n        widthsData.push(widthL);\n      }\n      // end sector\n      for (let i = halfCount; i < widths.length; i += 2) {\n        widthsData.push(widths[i]);\n        widthsData.push(widths[i + 1]);\n      }\n    } else if (widthsDistribution === GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_START) {\n      // start sector\n      for (let i = 0; i < widths.length; i += 2) {\n        widthsData.push(widths[i]);\n        widthsData.push(widths[i + 1]);\n      }\n      // end sector\n      for (let i = 0; i < missingCount; i++) {\n        widthsData.push(defaultWidthUpper);\n        widthsData.push(defaultWidthLower);\n      }\n    } else if (widthsDistribution === GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_END) {\n      // start sector\n      for (let i = 0; i < missingCount; i++) {\n        widthsData.push(defaultWidthUpper);\n        widthsData.push(defaultWidthLower);\n      }\n      // end sector\n      for (let i = 0; i < widths.length; i += 2) {\n        widthsData.push(widths[i]);\n        widthsData.push(widths[i + 1]);\n      }\n    } else if (widthsDistribution === GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_REPEAT) {\n      let i = 0;\n      for (let x = 0; x < pointCount; x++) {\n        widthsData.push(widths[i++]);\n        widthsData.push(widths[i++]);\n        if (i === widths.length) {\n          i = 0;\n        }\n      }\n    } else if (widthsDistribution === GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_EVEN) {\n      let j = 0;\n      const widthsectorLength = widths.length / ((pointCount - 1) * 2);\n      for (let x = 0; x < pointCount; x++) {\n        const i = Math.floor(j);\n        widthsData.push(widths[i]);\n        widthsData.push(widths[i + 1]);\n        j += widthsectorLength;\n      }\n    }\n  } else {\n    for (let i = 0; i < widths.length; i++) {\n      widthsData.push(widths[i]);\n    }\n  }\n  return widthsData;\n}\n/**\n * Completes the color table/fill the missing color entries. It means it creates a color entry for every point of the line mesh.\n * You can provide more points the colors when creating the mesh. This function will fill the empty entries.\n * The algorithm used to fill the empty entries can be\n * GreasedLineMesColorhDistribution.REPEAT - the color table will be repeatedly copied to the empty values [c1, c2] = [c1, c2, c1, c2, c1, c2, c1, c2]\n * GreasedLineMesColorhDistribution.EVEN - the color table will be evenly copied to the empty values [c1, c2] = [c1, c1, c1, c1, c2, c2, c2, c2]\n * GreasedLineMesColorhDistribution.START - the color table will be copied at the start of the empty values\n * and rest will be filled color the default color value [c1, c2] = [c1, c2, dc, dc, dc, dc, dc, dc]\n * GreasedLineMesColorhDistribution.START_END - the color table will be copied at the start and the end of the empty values\n * and rest will be filled color the default color value [c1, c2] = [c1, c2, dc, dc, dc, dc, c1, c2]\n * @param pointCount number of points of the line mesh\n * @param colors array of Color3 for the color table\n * @param colorDistribution how to distribute colors if the colors array has fewer entries than pointCount\n * @param defaultColor default color to be used to fill empty entries in the color table\n * @returns completed array of Color3s\n */\nexport function CompleteGreasedLineColorTable(pointCount, colors, colorDistribution, defaultColor) {\n  pointCount = Math.max(colors.length, pointCount);\n  const missingCount = pointCount - colors.length;\n  if (missingCount < 0) {\n    return colors.slice(0, pointCount);\n  }\n  const colorsData = [];\n  // is the color table shorter than the point table?\n  if (missingCount > 0) {\n    // it is, fill in the missing elements\n    if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_START_END) {\n      const halfCount = Math.floor(colors.length / 2);\n      // start sector\n      for (let i = 0; i < halfCount; i++) {\n        colorsData.push(colors[i]);\n      }\n      // middle sector\n      for (let i = 0; i < missingCount - 1; i++) {\n        colorsData.push(defaultColor);\n      }\n      // end sector\n      for (let i = halfCount; i < colors.length; i++) {\n        colorsData.push(colors[i]);\n      }\n    } else if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_START) {\n      // start sector\n      for (let i = 0; i < colors.length; i++) {\n        colorsData.push(colors[i]);\n      }\n      // end sector\n      for (let i = 0; i < missingCount; i++) {\n        colorsData.push(defaultColor);\n      }\n    } else if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_END) {\n      // start sector\n      for (let i = 0; i < missingCount - 1; i++) {\n        colorsData.push(defaultColor);\n      }\n      // end sector\n      for (let i = 0; i < colors.length; i++) {\n        colorsData.push(colors[i]);\n      }\n    } else if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_REPEAT) {\n      let i = 0;\n      for (let x = 0; x < pointCount; x++) {\n        colorsData.push(colors[i]);\n        i++;\n        if (i === colors.length) {\n          i = 0;\n        }\n      }\n    } else if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_EVEN) {\n      let j = 0;\n      const colorSectorLength = colors.length / (pointCount - 1);\n      for (let x = 0; x < pointCount - 1; x++) {\n        const i = Math.floor(j);\n        colorsData.push(colors[i]);\n        j += colorSectorLength;\n      }\n    } else if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_NONE) {\n      for (let i = 0; i < colors.length; i++) {\n        colorsData.push(colors[i]);\n      }\n    }\n  } else {\n    for (let i = 0; i < pointCount; i++) {\n      colorsData.push(colors[i]);\n    }\n  }\n  return colorsData;\n}","map":{"version":3,"names":["StandardMaterial","PBRMaterial","GreasedLineMesh","EngineStore","GreasedLineSimpleMaterial","GreasedLineTools","GreasedLineRibbonAutoDirectionMode","GreasedLineRibbonFacesMode","GreasedLineRibbonPointsMode","GreasedLineRibbonMesh","GreasedLineMeshMaterialType","GreasedLinePluginMaterial","GreasedLineMaterialDefaults","GreasedLineMeshColorDistribution","GreasedLineMeshWidthDistribution","CreateGreasedLineMaterial","name","options","scene","LastCreatedScene","material","materialType","MATERIAL_TYPE_PBR","MATERIAL_TYPE_SIMPLE","CreateGreasedLine","materialOptions","instance","allPoints","ConvertPoints","points","widthDistribution","_a","WIDTH_DISTRIBUTION_START","ribbonOptions","facesMode","_b","FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING","pointsMode","_c","POINTS_MODE_POINTS","directionsAutoMode","_d","directions","AUTO_DIRECTIONS_NONE","AUTO_DIRECTIONS_FROM_FIRST_SEGMENT","color","DEFAULT_COLOR","createAndAssignMaterial","_e","colorDistribution","_f","COLOR_DISTRIBUTION_START","_g","MATERIAL_TYPE_STANDARD","length","Array","isArray","forEach","widths","CompleteGreasedLineWidthTable","_h","colors","CompleteGreasedLineColorTable","_j","undefined","initialGreasedLineOptions","updatable","lazy","uvs","colorPointers","width","_l","_k","DEFAULT_WIDTH","initialMaterialOptions","dashCount","dashOffset","dashRatio","resolution","sizeAttenuation","useColors","useDash","visibility","colorMode","colorsSampling","colorDistributionType","cameraFacing","colorsTexture","_m","backFaceCulling","addPoints","currentWidths","newWidths","slice","w","push","greasedLineMaterial","currentColors","newColors","concat","setColors","isLazy","pointCount","widthsDistribution","defaultWidthUpper","defaultWidthLower","missingCount","widthsData","WIDTH_DISTRIBUTION_START_END","halfCount","Math","floor","i","j","widthL","widthU","WIDTH_DISTRIBUTION_END","WIDTH_DISTRIBUTION_REPEAT","x","WIDTH_DISTRIBUTION_EVEN","widthsectorLength","defaultColor","max","colorsData","COLOR_DISTRIBUTION_START_END","COLOR_DISTRIBUTION_END","COLOR_DISTRIBUTION_REPEAT","COLOR_DISTRIBUTION_EVEN","colorSectorLength","COLOR_DISTRIBUTION_NONE"],"sources":["../../../../../dev/core/src/Meshes/Builders/greasedLineBuilder.ts"],"sourcesContent":["import { StandardMaterial } from \"./../../Materials/standardMaterial\";\r\nimport { PBRMaterial } from \"../../Materials/PBR/pbrMaterial\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { GreasedLineMesh } from \"../GreasedLine/greasedLineMesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport type { Color3 } from \"../../Maths/math.color\";\r\nimport { GreasedLineSimpleMaterial } from \"../../Materials/GreasedLine/greasedLineSimpleMaterial\";\r\nimport { GreasedLineTools } from \"../../Misc/greasedLineTools\";\r\nimport type { GreasedLineMeshOptions } from \"../GreasedLine/greasedLineBaseMesh\";\r\nimport { GreasedLineRibbonAutoDirectionMode, GreasedLineRibbonFacesMode, GreasedLineRibbonPointsMode } from \"../GreasedLine/greasedLineBaseMesh\";\r\nimport { GreasedLineRibbonMesh } from \"../GreasedLine/greasedLineRibbonMesh\";\r\nimport type { GreasedLineMaterialOptions } from \"../../Materials/GreasedLine/greasedLineMaterialInterfaces\";\r\nimport { GreasedLineMeshMaterialType } from \"../../Materials/GreasedLine/greasedLineMaterialInterfaces\";\r\nimport { GreasedLinePluginMaterial } from \"../../Materials/GreasedLine/greasedLinePluginMaterial\";\r\nimport { GreasedLineMaterialDefaults } from \"../../Materials/GreasedLine/greasedLineMaterialDefaults\";\r\n\r\n/**\r\n * How are the colors distributed along the color table\r\n * {@link https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param/greased_line#colors-and-colordistribution}\r\n */\r\nexport enum GreasedLineMeshColorDistribution {\r\n    /**\r\n     * Do no modify the color table\r\n     */\r\n    COLOR_DISTRIBUTION_NONE = 0,\r\n    /**\r\n     * Repeat the colors until the color table is full\r\n     */\r\n    COLOR_DISTRIBUTION_REPEAT = 1,\r\n    /**\r\n     * Distribute the colors evenly through the color table\r\n     */\r\n    COLOR_DISTRIBUTION_EVEN = 2,\r\n    /**\r\n     * Put the colors to start of the color table a fill the rest with the default color\r\n     */\r\n    COLOR_DISTRIBUTION_START = 3,\r\n    /**\r\n     * Put the colors to the end of the color table and fill the rest with the default color\r\n     */\r\n    COLOR_DISTRIBUTION_END = 4,\r\n    /**\r\n     * Put the colors to start and to the end of the color table and fill the gap between with the default color\r\n     */\r\n    COLOR_DISTRIBUTION_START_END = 5,\r\n}\r\n\r\n/**\r\n * How are the widths distributed along the width table\r\n * {@link https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param/greased_line#widths-and-widthdistribution}\r\n */\r\nexport enum GreasedLineMeshWidthDistribution {\r\n    /**\r\n     * Do no modify the width table\r\n     */\r\n    WIDTH_DISTRIBUTION_NONE = 0,\r\n    /**\r\n     * Repeat the widths until the width table is full\r\n     */\r\n    WIDTH_DISTRIBUTION_REPEAT = 1,\r\n    /**\r\n     * Distribute the widths evenly through the width table\r\n     */\r\n    WIDTH_DISTRIBUTION_EVEN = 2,\r\n    /**\r\n     * Put the widths to start of the width table a fill the rest with the default width\r\n     */\r\n    WIDTH_DISTRIBUTION_START = 3,\r\n    /**\r\n     * Put the widths to the end of the width table and fill the rest with the default width\r\n     */\r\n    WIDTH_DISTRIBUTION_END = 4,\r\n    /**\r\n     * Put the widths to start and to the end of the width table and fill the gap between with the default width\r\n     */\r\n    WIDTH_DISTRIBUTION_START_END = 5,\r\n}\r\n\r\n/**\r\n * Material options for GreasedLineBuilder\r\n */\r\nexport interface GreasedLineMaterialBuilderOptions extends GreasedLineMaterialOptions {\r\n    /**\r\n     * If set to true a new material will be created and a new material plugin will be attached\r\n     * to the material. The material will be set on the mesh. If the instance option is specified in the mesh options,\r\n     * no material will be created/assigned. Defaults to true.\r\n     */\r\n    createAndAssignMaterial?: boolean;\r\n    /**\r\n     * Distribution of the colors if the color table contains fewer entries than needed. Defaults to GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_START\r\n     * @see CompleteGreasedLineColorTable\r\n     */\r\n    colorDistribution?: GreasedLineMeshColorDistribution;\r\n}\r\n\r\n/**\r\n * Line mesh options for GreasedLineBuilder\r\n */\r\nexport interface GreasedLineMeshBuilderOptions extends GreasedLineMeshOptions {\r\n    /**\r\n     * Distribution of the widths if the width table contains fewer entries than needed. Defaults to GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_START\r\n     * @see CompleteGreasedLineWidthTable\r\n     */\r\n    widthDistribution?: GreasedLineMeshWidthDistribution;\r\n}\r\n\r\n/**\r\n * Builder functions for creating GreasedLineMeshes\r\n */\r\n\r\n/**\r\n * Creates a new @see GreasedLinePluginMaterial\r\n * @param name name of the material\r\n * @param options material options @see GreasedLineMaterialOptions\r\n * @param scene scene or null to use the last scene\r\n * @returns StandardMaterial or PBRMaterial with the @see GreasedLinePluginMaterial attached to it\r\n */\r\nexport function CreateGreasedLineMaterial(name: string, options: GreasedLineMaterialOptions, scene: Nullable<Scene>) {\r\n    scene = <Scene>(scene ?? EngineStore.LastCreatedScene);\r\n\r\n    let material;\r\n    switch (options.materialType) {\r\n        case GreasedLineMeshMaterialType.MATERIAL_TYPE_PBR:\r\n            material = new PBRMaterial(name, scene);\r\n            new GreasedLinePluginMaterial(material, scene, options);\r\n            break;\r\n        case GreasedLineMeshMaterialType.MATERIAL_TYPE_SIMPLE:\r\n            material = new GreasedLineSimpleMaterial(name, scene, options);\r\n            break;\r\n        default:\r\n            material = new StandardMaterial(name, scene);\r\n            new GreasedLinePluginMaterial(material, scene, options);\r\n            break;\r\n    }\r\n\r\n    return material;\r\n}\r\n\r\n/**\r\n * Creates a GreasedLine mesh\r\n * @param name name of the mesh\r\n * @param options options for the mesh\r\n * @param materialOptions material options for the mesh\r\n * @param scene scene where the mesh will be created\r\n * @returns instance of GreasedLineMesh\r\n */\r\nexport function CreateGreasedLine(name: string, options: GreasedLineMeshBuilderOptions, materialOptions?: Nullable<GreasedLineMaterialBuilderOptions>, scene?: Nullable<Scene>) {\r\n    scene = <Scene>(scene ?? EngineStore.LastCreatedScene);\r\n\r\n    let instance;\r\n    const allPoints = GreasedLineTools.ConvertPoints(options.points);\r\n\r\n    options.widthDistribution = options.widthDistribution ?? GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_START;\r\n    if (options.ribbonOptions) {\r\n        options.ribbonOptions.facesMode = options.ribbonOptions.facesMode ?? GreasedLineRibbonFacesMode.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING;\r\n        options.ribbonOptions.pointsMode = options.ribbonOptions.pointsMode ?? GreasedLineRibbonPointsMode.POINTS_MODE_POINTS;\r\n        options.ribbonOptions.directionsAutoMode =\r\n            options.ribbonOptions.directionsAutoMode ??\r\n            (options.ribbonOptions.directions ? GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_NONE : GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT);\r\n    }\r\n\r\n    materialOptions = materialOptions ?? {\r\n        color: GreasedLineMaterialDefaults.DEFAULT_COLOR,\r\n    };\r\n    materialOptions.createAndAssignMaterial = materialOptions.createAndAssignMaterial ?? true;\r\n    materialOptions.colorDistribution = materialOptions?.colorDistribution ?? GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_START;\r\n    materialOptions.materialType = materialOptions.materialType ?? GreasedLineMeshMaterialType.MATERIAL_TYPE_STANDARD;\r\n\r\n    let length = 0;\r\n    if (Array.isArray(allPoints[0])) {\r\n        allPoints.forEach((points) => {\r\n            length += points.length / 3;\r\n        });\r\n    }\r\n\r\n    const widths = CompleteGreasedLineWidthTable(length, options.widths ?? [], options.widthDistribution);\r\n\r\n    const colors = materialOptions?.colors\r\n        ? CompleteGreasedLineColorTable(length, materialOptions.colors, materialOptions.colorDistribution, materialOptions.color ?? GreasedLineMaterialDefaults.DEFAULT_COLOR)\r\n        : undefined;\r\n\r\n    // create new mesh if instance is not defined\r\n    const initialGreasedLineOptions: GreasedLineMeshOptions = {\r\n        points: allPoints,\r\n        updatable: options.updatable,\r\n        widths,\r\n        lazy: options.lazy,\r\n        ribbonOptions: options.ribbonOptions,\r\n        uvs: options.uvs,\r\n        colorPointers: options.colorPointers,\r\n    };\r\n\r\n    if (initialGreasedLineOptions.ribbonOptions) {\r\n        if (initialGreasedLineOptions.ribbonOptions.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_POINTS) {\r\n            initialGreasedLineOptions.ribbonOptions.width = materialOptions.width ?? initialGreasedLineOptions.ribbonOptions.width ?? GreasedLineMaterialDefaults.DEFAULT_WIDTH;\r\n        }\r\n    }\r\n\r\n    if (!options.instance) {\r\n        instance = initialGreasedLineOptions.ribbonOptions\r\n            ? new GreasedLineRibbonMesh(name, scene, initialGreasedLineOptions)\r\n            : new GreasedLineMesh(name, scene, initialGreasedLineOptions);\r\n\r\n        if (materialOptions) {\r\n            const initialMaterialOptions: GreasedLineMaterialOptions = {\r\n                materialType: materialOptions.materialType,\r\n                dashCount: materialOptions.dashCount,\r\n                dashOffset: materialOptions.dashOffset,\r\n                dashRatio: materialOptions.dashRatio,\r\n                resolution: materialOptions.resolution,\r\n                sizeAttenuation: materialOptions.sizeAttenuation,\r\n                useColors: materialOptions.useColors,\r\n                useDash: materialOptions.useDash,\r\n                visibility: materialOptions.visibility,\r\n                width: materialOptions.width,\r\n                color: materialOptions.color,\r\n                colorMode: materialOptions.colorMode,\r\n                colorsSampling: materialOptions.colorsSampling,\r\n                colorDistributionType: materialOptions.colorDistributionType,\r\n                colors,\r\n                cameraFacing: !options.ribbonOptions,\r\n                colorsTexture: materialOptions.colorsTexture,\r\n            };\r\n\r\n            if (materialOptions.createAndAssignMaterial) {\r\n                const material = CreateGreasedLineMaterial(name, initialMaterialOptions, scene);\r\n                instance.material = material;\r\n\r\n                if (options.ribbonOptions?.facesMode === GreasedLineRibbonFacesMode.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING) {\r\n                    material.backFaceCulling = false;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        // update the data on the mesh instance\r\n        instance = options.instance;\r\n        if (instance instanceof GreasedLineRibbonMesh) {\r\n            instance.addPoints(allPoints, initialGreasedLineOptions);\r\n        } else {\r\n            const currentWidths = instance.widths;\r\n\r\n            if (currentWidths) {\r\n                const newWidths = currentWidths.slice();\r\n                for (const w of widths) {\r\n                    newWidths.push(w);\r\n                }\r\n                instance.widths = newWidths;\r\n            } else {\r\n                instance.widths = widths;\r\n            }\r\n            instance.addPoints(allPoints);\r\n        }\r\n    }\r\n\r\n    // add colors\r\n    // it will merge if any colors already on the instance\r\n    if (colors && options.instance) {\r\n        if (options.instance.greasedLineMaterial) {\r\n            const currentColors = options.instance.greasedLineMaterial.colors;\r\n            if (currentColors) {\r\n                const newColors = currentColors.concat(colors);\r\n                options.instance.greasedLineMaterial.setColors(newColors, instance.isLazy());\r\n            }\r\n        }\r\n    }\r\n\r\n    return instance;\r\n}\r\n\r\n/**\r\n * Completes the width table/fills the missing entries. It means it creates a width entry for every point of the line mesh.\r\n * You can provide more points the widths when creating the mesh. This function will fill the empty entries.\r\n * The algorithm used to fill the empty entries can be\r\n * GreasedLineMeshWidthDistribution.REPEAT - the width table will be repeatedly copied to the empty values [wL, wU] = [wL, wU, wL, wU, wL, wU, wL, wU, ...]\r\n * GreasedLineMeshWidthDistribution.EVEN - the width table will be evenly copied to the empty values [wL, wU] = [wL, wL, wL, wL, wU, wU, wU, wU]\r\n * GreasedLineMeshWidthDistribution.START - the width table will be copied at the start of the empty values\r\n * and rest will be filled width the default width upper and default width lower values [wU, wL] = [wL, wU, dwL, dwU, dwL, dwU, dwL, dwU]\r\n * GreasedLineMeshWidthDistribution.END - the width table will be copied at the end of the empty values\r\n * and rest will be filled width the default values [wL, wU] = [wL, wU, dwL, dwU, dwL, dwU, wL, wU]\r\n * @param pointCount number of points of the line mesh\r\n * @param widths array of widths [widhtLower, widthUpper, widthLower, widthUpper ...]. Two widths (lower/upper) per point.\r\n * @param widthsDistribution how to distribute widths if the widths array has fewer entries than pointCount\r\n * @param defaultWidthUpper the default value which will be used to fill empty width entries - upper width\r\n * @param defaultWidthLower the default value which will be used to fill empty width entries - lower width\r\n * @returns completed width table.\r\n */\r\nexport function CompleteGreasedLineWidthTable(\r\n    pointCount: number,\r\n    widths: number[],\r\n    widthsDistribution: GreasedLineMeshWidthDistribution,\r\n    defaultWidthUpper = 1,\r\n    defaultWidthLower = 1\r\n): number[] {\r\n    const missingCount = pointCount - widths.length / 2;\r\n\r\n    const widthsData: number[] = [];\r\n    if (missingCount < 0) {\r\n        return widths.slice(0, pointCount * 2);\r\n    }\r\n\r\n    // is the width table shorter than the point table?\r\n    if (missingCount > 0) {\r\n        if (widths.length % 2 != 0) {\r\n            widths.push(defaultWidthUpper);\r\n        }\r\n        // it is, fill in the missing elements\r\n        if (widthsDistribution === GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_START_END) {\r\n            const halfCount = Math.floor(widths.length / 2);\r\n\r\n            // start sector\r\n            for (let i = 0, j = 0; i < halfCount - 1; i++) {\r\n                widthsData.push(widths[j++]);\r\n                widthsData.push(widths[j++]);\r\n            }\r\n\r\n            // middle sector\r\n            const widthL = widths[halfCount / 2];\r\n            const widthU = widths[halfCount / 2 + 1];\r\n            for (let i = 0; i < missingCount; i++) {\r\n                widthsData.push(widthU);\r\n                widthsData.push(widthL);\r\n            }\r\n\r\n            // end sector\r\n            for (let i = halfCount; i < widths.length; i += 2) {\r\n                widthsData.push(widths[i]);\r\n                widthsData.push(widths[i + 1]);\r\n            }\r\n        } else if (widthsDistribution === GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_START) {\r\n            // start sector\r\n            for (let i = 0; i < widths.length; i += 2) {\r\n                widthsData.push(widths[i]);\r\n                widthsData.push(widths[i + 1]);\r\n            }\r\n\r\n            // end sector\r\n            for (let i = 0; i < missingCount; i++) {\r\n                widthsData.push(defaultWidthUpper);\r\n                widthsData.push(defaultWidthLower);\r\n            }\r\n        } else if (widthsDistribution === GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_END) {\r\n            // start sector\r\n            for (let i = 0; i < missingCount; i++) {\r\n                widthsData.push(defaultWidthUpper);\r\n                widthsData.push(defaultWidthLower);\r\n            }\r\n\r\n            // end sector\r\n            for (let i = 0; i < widths.length; i += 2) {\r\n                widthsData.push(widths[i]);\r\n                widthsData.push(widths[i + 1]);\r\n            }\r\n        } else if (widthsDistribution === GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_REPEAT) {\r\n            let i = 0;\r\n            for (let x = 0; x < pointCount; x++) {\r\n                widthsData.push(widths[i++]);\r\n                widthsData.push(widths[i++]);\r\n\r\n                if (i === widths.length) {\r\n                    i = 0;\r\n                }\r\n            }\r\n        } else if (widthsDistribution === GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_EVEN) {\r\n            let j = 0;\r\n            const widthsectorLength = widths.length / ((pointCount - 1) * 2);\r\n            for (let x = 0; x < pointCount; x++) {\r\n                const i = Math.floor(j);\r\n\r\n                widthsData.push(widths[i]);\r\n                widthsData.push(widths[i + 1]);\r\n\r\n                j += widthsectorLength;\r\n            }\r\n        }\r\n    } else {\r\n        for (let i = 0; i < widths.length; i++) {\r\n            widthsData.push(widths[i]);\r\n        }\r\n    }\r\n\r\n    return widthsData;\r\n}\r\n\r\n/**\r\n * Completes the color table/fill the missing color entries. It means it creates a color entry for every point of the line mesh.\r\n * You can provide more points the colors when creating the mesh. This function will fill the empty entries.\r\n * The algorithm used to fill the empty entries can be\r\n * GreasedLineMesColorhDistribution.REPEAT - the color table will be repeatedly copied to the empty values [c1, c2] = [c1, c2, c1, c2, c1, c2, c1, c2]\r\n * GreasedLineMesColorhDistribution.EVEN - the color table will be evenly copied to the empty values [c1, c2] = [c1, c1, c1, c1, c2, c2, c2, c2]\r\n * GreasedLineMesColorhDistribution.START - the color table will be copied at the start of the empty values\r\n * and rest will be filled color the default color value [c1, c2] = [c1, c2, dc, dc, dc, dc, dc, dc]\r\n * GreasedLineMesColorhDistribution.START_END - the color table will be copied at the start and the end of the empty values\r\n * and rest will be filled color the default color value [c1, c2] = [c1, c2, dc, dc, dc, dc, c1, c2]\r\n * @param pointCount number of points of the line mesh\r\n * @param colors array of Color3 for the color table\r\n * @param colorDistribution how to distribute colors if the colors array has fewer entries than pointCount\r\n * @param defaultColor default color to be used to fill empty entries in the color table\r\n * @returns completed array of Color3s\r\n */\r\nexport function CompleteGreasedLineColorTable(pointCount: number, colors: Color3[], colorDistribution: GreasedLineMeshColorDistribution, defaultColor: Color3): Color3[] {\r\n    pointCount = Math.max(colors.length, pointCount);\r\n    const missingCount = pointCount - colors.length;\r\n    if (missingCount < 0) {\r\n        return colors.slice(0, pointCount);\r\n    }\r\n\r\n    const colorsData: Color3[] = [];\r\n    // is the color table shorter than the point table?\r\n    if (missingCount > 0) {\r\n        // it is, fill in the missing elements\r\n        if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_START_END) {\r\n            const halfCount = Math.floor(colors.length / 2);\r\n\r\n            // start sector\r\n            for (let i = 0; i < halfCount; i++) {\r\n                colorsData.push(colors[i]);\r\n            }\r\n\r\n            // middle sector\r\n            for (let i = 0; i < missingCount - 1; i++) {\r\n                colorsData.push(defaultColor);\r\n            }\r\n\r\n            // end sector\r\n            for (let i = halfCount; i < colors.length; i++) {\r\n                colorsData.push(colors[i]);\r\n            }\r\n        } else if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_START) {\r\n            // start sector\r\n            for (let i = 0; i < colors.length; i++) {\r\n                colorsData.push(colors[i]);\r\n            }\r\n\r\n            // end sector\r\n            for (let i = 0; i < missingCount; i++) {\r\n                colorsData.push(defaultColor);\r\n            }\r\n        } else if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_END) {\r\n            // start sector\r\n            for (let i = 0; i < missingCount - 1; i++) {\r\n                colorsData.push(defaultColor);\r\n            }\r\n\r\n            // end sector\r\n            for (let i = 0; i < colors.length; i++) {\r\n                colorsData.push(colors[i]);\r\n            }\r\n        } else if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_REPEAT) {\r\n            let i = 0;\r\n            for (let x = 0; x < pointCount; x++) {\r\n                colorsData.push(colors[i]);\r\n\r\n                i++;\r\n\r\n                if (i === colors.length) {\r\n                    i = 0;\r\n                }\r\n            }\r\n        } else if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_EVEN) {\r\n            let j = 0;\r\n            const colorSectorLength = colors.length / (pointCount - 1);\r\n            for (let x = 0; x < pointCount - 1; x++) {\r\n                const i = Math.floor(j);\r\n\r\n                colorsData.push(colors[i]);\r\n\r\n                j += colorSectorLength;\r\n            }\r\n        } else if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_NONE) {\r\n            for (let i = 0; i < colors.length; i++) {\r\n                colorsData.push(colors[i]);\r\n            }\r\n        }\r\n    } else {\r\n        for (let i = 0; i < pointCount; i++) {\r\n            colorsData.push(colors[i]);\r\n        }\r\n    }\r\n\r\n    return colorsData;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}