{"ast":null,"code":"import { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Quaternion, TmpVectors, Vector3 } from \"../../Maths/math.vector.js\";\n/**\n * A behavior that allows a transform node to stick to a surface position/orientation\n * @since 5.0.0\n */\nexport class SurfaceMagnetismBehavior {\n  constructor() {\n    this._attachPointLocalOffset = new Vector3();\n    this._workingPosition = new Vector3();\n    this._workingQuaternion = new Quaternion();\n    this._lastTick = -1;\n    this._hit = false;\n    /**\n     * Distance offset from the hit point to place the target at, along the hit normal.\n     */\n    this.hitNormalOffset = 0.05;\n    /**\n     * Spatial mapping meshes to collide with\n     */\n    this.meshes = [];\n    /**\n     * Set to false if the node should strictly follow the camera without any interpolation time\n     */\n    this.interpolatePose = true;\n    /**\n     * Rate of interpolation of position and rotation of the attached node.\n     * Higher values will give a slower interpolation.\n     */\n    this.lerpTime = 250;\n    /**\n     * If true, pitch and roll are omitted.\n     */\n    this.keepOrientationVertical = true;\n    /**\n     * Is this behavior reacting to pointer events\n     */\n    this.enabled = true;\n    /**\n     * Maximum distance for the node to stick to the surface\n     */\n    this.maxStickingDistance = 0.8;\n  }\n  /**\n   * Name of the behavior\n   */\n  get name() {\n    return \"SurfaceMagnetism\";\n  }\n  /**\n   * Function called when the behavior needs to be initialized (after attaching it to a target)\n   */\n  init() {}\n  /**\n   * Attaches the behavior to a transform node\n   * @param target defines the target where the behavior is attached to\n   * @param scene the scene\n   */\n  attach(target, scene) {\n    this._attachedMesh = target;\n    this._scene = scene || target.getScene();\n    if (!this._attachedMesh.rotationQuaternion) {\n      this._attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._attachedMesh.rotation.y, this._attachedMesh.rotation.x, this._attachedMesh.rotation.z);\n    }\n    this.updateAttachPoint();\n    this._workingPosition.copyFrom(this._attachedMesh.position);\n    this._workingQuaternion.copyFrom(this._attachedMesh.rotationQuaternion);\n    this._addObservables();\n  }\n  /**\n   * Detaches the behavior\n   */\n  detach() {\n    this._attachedMesh = null;\n    this._removeObservables();\n  }\n  _getTargetPose(pickingInfo) {\n    if (!this._attachedMesh) {\n      return null;\n    }\n    if (pickingInfo && pickingInfo.hit) {\n      const pickedNormal = pickingInfo.getNormal(true, true);\n      const pickedPoint = pickingInfo.pickedPoint;\n      if (!pickedNormal || !pickedPoint) {\n        return null;\n      }\n      pickedNormal.normalize();\n      const worldTarget = TmpVectors.Vector3[0];\n      worldTarget.copyFrom(pickedNormal);\n      worldTarget.scaleInPlace(this.hitNormalOffset);\n      worldTarget.addInPlace(pickedPoint);\n      if (this._attachedMesh.parent) {\n        TmpVectors.Matrix[0].copyFrom(this._attachedMesh.parent.getWorldMatrix()).invert();\n        Vector3.TransformNormalToRef(worldTarget, TmpVectors.Matrix[0], worldTarget);\n      }\n      return {\n        position: worldTarget,\n        quaternion: Quaternion.RotationYawPitchRoll(-Math.atan2(pickedNormal.x, -pickedNormal.z), this.keepOrientationVertical ? 0 : Math.atan2(pickedNormal.y, Math.sqrt(pickedNormal.z * pickedNormal.z + pickedNormal.x * pickedNormal.x)), 0)\n      };\n    }\n    return null;\n  }\n  /**\n   * Updates the attach point with the current geometry extents of the attached mesh\n   */\n  updateAttachPoint() {\n    this._getAttachPointOffsetToRef(this._attachPointLocalOffset);\n  }\n  /**\n   * Finds the intersection point of the given ray onto the meshes and updates the target.\n   * Transformation will be interpolated according to `interpolatePose` and `lerpTime` properties.\n   * If no mesh of `meshes` are hit, this does nothing.\n   * @param pickInfo The input pickingInfo that will be used to intersect the meshes\n   * @returns a boolean indicating if we found a hit to stick to\n   */\n  findAndUpdateTarget(pickInfo) {\n    this._hit = false;\n    if (!pickInfo.ray) {\n      return false;\n    }\n    const subPicking = pickInfo.ray.intersectsMeshes(this.meshes)[0];\n    if (this._attachedMesh && subPicking && subPicking.hit && subPicking.pickedMesh) {\n      const pose = this._getTargetPose(subPicking);\n      if (pose && Vector3.Distance(this._attachedMesh.position, pose.position) < this.maxStickingDistance) {\n        this._workingPosition.copyFrom(pose.position);\n        this._workingQuaternion.copyFrom(pose.quaternion);\n        this._hit = true;\n      }\n    }\n    return this._hit;\n  }\n  _getAttachPointOffsetToRef(ref) {\n    if (!this._attachedMesh) {\n      ref.setAll(0);\n      return;\n    }\n    const storedQuat = TmpVectors.Quaternion[0];\n    storedQuat.copyFrom(this._attachedMesh.rotationQuaternion);\n    this._attachedMesh.rotationQuaternion.copyFromFloats(0, 0, 0, 1);\n    this._attachedMesh.computeWorldMatrix();\n    const boundingMinMax = this._attachedMesh.getHierarchyBoundingVectors();\n    const center = TmpVectors.Vector3[0];\n    boundingMinMax.max.addToRef(boundingMinMax.min, center);\n    center.scaleInPlace(0.5);\n    center.z = boundingMinMax.max.z;\n    // We max the z coordinate because we want the attach point to be on the back of the mesh\n    const invWorld = TmpVectors.Matrix[0];\n    this._attachedMesh.getWorldMatrix().invertToRef(invWorld);\n    Vector3.TransformCoordinatesToRef(center, invWorld, ref);\n    this._attachedMesh.rotationQuaternion.copyFrom(storedQuat);\n  }\n  _updateTransformToGoal(elapsed) {\n    if (!this._attachedMesh || !this._hit) {\n      return;\n    }\n    const oldParent = this._attachedMesh.parent;\n    this._attachedMesh.setParent(null);\n    const worldOffset = TmpVectors.Vector3[0];\n    Vector3.TransformNormalToRef(this._attachPointLocalOffset, this._attachedMesh.getWorldMatrix(), worldOffset);\n    if (!this.interpolatePose) {\n      this._attachedMesh.position.copyFrom(this._workingPosition).subtractInPlace(worldOffset);\n      this._attachedMesh.rotationQuaternion.copyFrom(this._workingQuaternion);\n      return;\n    }\n    // position\n    const interpolatedPosition = new Vector3();\n    Vector3.SmoothToRef(this._attachedMesh.position, this._workingPosition, elapsed, this.lerpTime, interpolatedPosition);\n    this._attachedMesh.position.copyFrom(interpolatedPosition);\n    // rotation\n    const currentRotation = new Quaternion();\n    currentRotation.copyFrom(this._attachedMesh.rotationQuaternion);\n    Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this._attachedMesh.rotationQuaternion);\n    this._attachedMesh.setParent(oldParent);\n  }\n  _addObservables() {\n    this._pointerObserver = this._scene.onPointerObservable.add(pointerInfo => {\n      if (this.enabled && pointerInfo.type == PointerEventTypes.POINTERMOVE && pointerInfo.pickInfo) {\n        this.findAndUpdateTarget(pointerInfo.pickInfo);\n      }\n    });\n    this._lastTick = Date.now();\n    this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {\n      const tick = Date.now();\n      this._updateTransformToGoal(tick - this._lastTick);\n      this._lastTick = tick;\n    });\n  }\n  _removeObservables() {\n    this._scene.onPointerObservable.remove(this._pointerObserver);\n    this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);\n    this._pointerObserver = null;\n    this._onBeforeRender = null;\n  }\n}","map":{"version":3,"names":["PointerEventTypes","Quaternion","TmpVectors","Vector3","SurfaceMagnetismBehavior","constructor","_attachPointLocalOffset","_workingPosition","_workingQuaternion","_lastTick","_hit","hitNormalOffset","meshes","interpolatePose","lerpTime","keepOrientationVertical","enabled","maxStickingDistance","name","init","attach","target","scene","_attachedMesh","_scene","getScene","rotationQuaternion","RotationYawPitchRoll","rotation","y","x","z","updateAttachPoint","copyFrom","position","_addObservables","detach","_removeObservables","_getTargetPose","pickingInfo","hit","pickedNormal","getNormal","pickedPoint","normalize","worldTarget","scaleInPlace","addInPlace","parent","Matrix","getWorldMatrix","invert","TransformNormalToRef","quaternion","Math","atan2","sqrt","_getAttachPointOffsetToRef","findAndUpdateTarget","pickInfo","ray","subPicking","intersectsMeshes","pickedMesh","pose","Distance","ref","setAll","storedQuat","copyFromFloats","computeWorldMatrix","boundingMinMax","getHierarchyBoundingVectors","center","max","addToRef","min","invWorld","invertToRef","TransformCoordinatesToRef","_updateTransformToGoal","elapsed","oldParent","setParent","worldOffset","subtractInPlace","interpolatedPosition","SmoothToRef","currentRotation","_pointerObserver","onPointerObservable","add","pointerInfo","type","POINTERMOVE","Date","now","_onBeforeRender","onBeforeRenderObservable","tick","remove"],"sources":["../../../../../dev/core/src/Behaviors/Meshes/surfaceMagnetismBehavior.ts"],"sourcesContent":["import type { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Quaternion, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Behavior } from \"../behavior\";\r\n\r\n/**\r\n * A behavior that allows a transform node to stick to a surface position/orientation\r\n * @since 5.0.0\r\n */\r\nexport class SurfaceMagnetismBehavior implements Behavior<Mesh> {\r\n    private _scene: Scene;\r\n    private _attachedMesh: Nullable<Mesh>;\r\n    private _attachPointLocalOffset: Vector3 = new Vector3();\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>>;\r\n    private _workingPosition: Vector3 = new Vector3();\r\n    private _workingQuaternion: Quaternion = new Quaternion();\r\n    private _lastTick: number = -1;\r\n    private _onBeforeRender: Nullable<Observer<Scene>>;\r\n    private _hit = false;\r\n\r\n    /**\r\n     * Distance offset from the hit point to place the target at, along the hit normal.\r\n     */\r\n    public hitNormalOffset: number = 0.05;\r\n\r\n    /**\r\n     * Name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"SurfaceMagnetism\";\r\n    }\r\n\r\n    /**\r\n     * Spatial mapping meshes to collide with\r\n     */\r\n    public meshes: AbstractMesh[] = [];\r\n\r\n    /**\r\n     * Function called when the behavior needs to be initialized (after attaching it to a target)\r\n     */\r\n    public init(): void {}\r\n\r\n    /**\r\n     * Set to false if the node should strictly follow the camera without any interpolation time\r\n     */\r\n    public interpolatePose = true;\r\n\r\n    /**\r\n     * Rate of interpolation of position and rotation of the attached node.\r\n     * Higher values will give a slower interpolation.\r\n     */\r\n    public lerpTime = 250;\r\n\r\n    /**\r\n     * If true, pitch and roll are omitted.\r\n     */\r\n    public keepOrientationVertical = true;\r\n\r\n    /**\r\n     * Is this behavior reacting to pointer events\r\n     */\r\n    public enabled = true;\r\n\r\n    /**\r\n     * Maximum distance for the node to stick to the surface\r\n     */\r\n    public maxStickingDistance = 0.8;\r\n\r\n    /**\r\n     * Attaches the behavior to a transform node\r\n     * @param target defines the target where the behavior is attached to\r\n     * @param scene the scene\r\n     */\r\n    public attach(target: Mesh, scene?: Scene): void {\r\n        this._attachedMesh = target;\r\n        this._scene = scene || target.getScene();\r\n        if (!this._attachedMesh.rotationQuaternion) {\r\n            this._attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._attachedMesh.rotation.y, this._attachedMesh.rotation.x, this._attachedMesh.rotation.z);\r\n        }\r\n        this.updateAttachPoint();\r\n\r\n        this._workingPosition.copyFrom(this._attachedMesh.position);\r\n        this._workingQuaternion.copyFrom(this._attachedMesh.rotationQuaternion);\r\n        this._addObservables();\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior\r\n     */\r\n    public detach(): void {\r\n        this._attachedMesh = null;\r\n        this._removeObservables();\r\n    }\r\n\r\n    private _getTargetPose(pickingInfo: PickingInfo): Nullable<{ position: Vector3; quaternion: Quaternion }> {\r\n        if (!this._attachedMesh) {\r\n            return null;\r\n        }\r\n\r\n        if (pickingInfo && pickingInfo.hit) {\r\n            const pickedNormal = pickingInfo.getNormal(true, true);\r\n            const pickedPoint = pickingInfo.pickedPoint;\r\n\r\n            if (!pickedNormal || !pickedPoint) {\r\n                return null;\r\n            }\r\n            pickedNormal.normalize();\r\n\r\n            const worldTarget = TmpVectors.Vector3[0];\r\n            worldTarget.copyFrom(pickedNormal);\r\n            worldTarget.scaleInPlace(this.hitNormalOffset);\r\n            worldTarget.addInPlace(pickedPoint);\r\n\r\n            if (this._attachedMesh.parent) {\r\n                TmpVectors.Matrix[0].copyFrom(this._attachedMesh.parent.getWorldMatrix()).invert();\r\n                Vector3.TransformNormalToRef(worldTarget, TmpVectors.Matrix[0], worldTarget);\r\n            }\r\n\r\n            return {\r\n                position: worldTarget,\r\n                quaternion: Quaternion.RotationYawPitchRoll(\r\n                    -Math.atan2(pickedNormal.x, -pickedNormal.z),\r\n                    this.keepOrientationVertical ? 0 : Math.atan2(pickedNormal.y, Math.sqrt(pickedNormal.z * pickedNormal.z + pickedNormal.x * pickedNormal.x)),\r\n                    0\r\n                ),\r\n            };\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Updates the attach point with the current geometry extents of the attached mesh\r\n     */\r\n    public updateAttachPoint() {\r\n        this._getAttachPointOffsetToRef(this._attachPointLocalOffset);\r\n    }\r\n\r\n    /**\r\n     * Finds the intersection point of the given ray onto the meshes and updates the target.\r\n     * Transformation will be interpolated according to `interpolatePose` and `lerpTime` properties.\r\n     * If no mesh of `meshes` are hit, this does nothing.\r\n     * @param pickInfo The input pickingInfo that will be used to intersect the meshes\r\n     * @returns a boolean indicating if we found a hit to stick to\r\n     */\r\n    public findAndUpdateTarget(pickInfo: PickingInfo): boolean {\r\n        this._hit = false;\r\n        if (!pickInfo.ray) {\r\n            return false;\r\n        }\r\n\r\n        const subPicking = pickInfo.ray.intersectsMeshes(this.meshes)[0];\r\n\r\n        if (this._attachedMesh && subPicking && subPicking.hit && subPicking.pickedMesh) {\r\n            const pose = this._getTargetPose(subPicking);\r\n            if (pose && Vector3.Distance(this._attachedMesh.position, pose.position) < this.maxStickingDistance) {\r\n                this._workingPosition.copyFrom(pose.position);\r\n                this._workingQuaternion.copyFrom(pose.quaternion);\r\n                this._hit = true;\r\n            }\r\n        }\r\n\r\n        return this._hit;\r\n    }\r\n\r\n    private _getAttachPointOffsetToRef(ref: Vector3) {\r\n        if (!this._attachedMesh) {\r\n            ref.setAll(0);\r\n            return;\r\n        }\r\n\r\n        const storedQuat = TmpVectors.Quaternion[0];\r\n        storedQuat.copyFrom(this._attachedMesh.rotationQuaternion!);\r\n        this._attachedMesh.rotationQuaternion!.copyFromFloats(0, 0, 0, 1);\r\n        this._attachedMesh.computeWorldMatrix();\r\n        const boundingMinMax = this._attachedMesh.getHierarchyBoundingVectors();\r\n        const center = TmpVectors.Vector3[0];\r\n        boundingMinMax.max.addToRef(boundingMinMax.min, center);\r\n        center.scaleInPlace(0.5);\r\n        center.z = boundingMinMax.max.z;\r\n        // We max the z coordinate because we want the attach point to be on the back of the mesh\r\n        const invWorld = TmpVectors.Matrix[0];\r\n        this._attachedMesh.getWorldMatrix().invertToRef(invWorld);\r\n        Vector3.TransformCoordinatesToRef(center, invWorld, ref);\r\n        this._attachedMesh.rotationQuaternion!.copyFrom(storedQuat);\r\n    }\r\n\r\n    private _updateTransformToGoal(elapsed: number) {\r\n        if (!this._attachedMesh || !this._hit) {\r\n            return;\r\n        }\r\n\r\n        const oldParent = this._attachedMesh.parent;\r\n        this._attachedMesh.setParent(null);\r\n\r\n        const worldOffset = TmpVectors.Vector3[0];\r\n        Vector3.TransformNormalToRef(this._attachPointLocalOffset, this._attachedMesh.getWorldMatrix(), worldOffset);\r\n\r\n        if (!this.interpolatePose) {\r\n            this._attachedMesh.position.copyFrom(this._workingPosition).subtractInPlace(worldOffset);\r\n            this._attachedMesh.rotationQuaternion!.copyFrom(this._workingQuaternion);\r\n            return;\r\n        }\r\n\r\n        // position\r\n        const interpolatedPosition = new Vector3();\r\n        Vector3.SmoothToRef(this._attachedMesh.position, this._workingPosition, elapsed, this.lerpTime, interpolatedPosition);\r\n        this._attachedMesh.position.copyFrom(interpolatedPosition);\r\n\r\n        // rotation\r\n        const currentRotation = new Quaternion();\r\n        currentRotation.copyFrom(this._attachedMesh.rotationQuaternion!);\r\n        Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this._attachedMesh.rotationQuaternion!);\r\n\r\n        this._attachedMesh.setParent(oldParent);\r\n    }\r\n\r\n    private _addObservables() {\r\n        this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {\r\n            if (this.enabled && pointerInfo.type == PointerEventTypes.POINTERMOVE && pointerInfo.pickInfo) {\r\n                this.findAndUpdateTarget(pointerInfo.pickInfo);\r\n            }\r\n        });\r\n\r\n        this._lastTick = Date.now();\r\n        this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {\r\n            const tick = Date.now();\r\n            this._updateTransformToGoal(tick - this._lastTick);\r\n            this._lastTick = tick;\r\n        });\r\n    }\r\n\r\n    private _removeObservables() {\r\n        this._scene.onPointerObservable.remove(this._pointerObserver);\r\n        this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);\r\n        this._pointerObserver = null;\r\n        this._onBeforeRender = null;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}